{"sha": "a443b5033c2e95ee58bf086f7093ddc610d4f78f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0NDNiNTAzM2MyZTk1ZWU1OGJmMDg2ZjcwOTNkZGM2MTBkNGY3OGY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-26T11:29:12Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-26T11:29:12Z"}, "message": "Id-ify Ty::Adt", "tree": {"sha": "5f05620adde03f7cb521b2f59aad6b2470e6272e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f05620adde03f7cb521b2f59aad6b2470e6272e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a443b5033c2e95ee58bf086f7093ddc610d4f78f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a443b5033c2e95ee58bf086f7093ddc610d4f78f", "html_url": "https://github.com/rust-lang/rust/commit/a443b5033c2e95ee58bf086f7093ddc610d4f78f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a443b5033c2e95ee58bf086f7093ddc610d4f78f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5eadb339039e21718d382c0b3d02a4bf053b3f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5eadb339039e21718d382c0b3d02a4bf053b3f4", "html_url": "https://github.com/rust-lang/rust/commit/e5eadb339039e21718d382c0b3d02a4bf053b3f4"}], "stats": {"total": 137, "additions": 98, "deletions": 39}, "files": [{"sha": "bb1596bed0a8896cd5e066c936d1d7354e00f450", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=a443b5033c2e95ee58bf086f7093ddc610d4f78f", "patch": "@@ -11,9 +11,9 @@ use hir_def::{\n     per_ns::PerNs,\n     resolver::{HasResolver, TypeNs},\n     type_ref::{Mutability, TypeRef},\n-    AstItemDef, ConstId, ContainerId, DefWithBodyId, EnumId, FunctionId, GenericDefId, HasModule,\n-    ImplId, LocalEnumVariantId, LocalImportId, LocalModuleId, LocalStructFieldId, Lookup, ModuleId,\n-    StaticId, StructId, TraitId, TypeAliasId, UnionId,\n+    AdtId, AstItemDef, ConstId, ContainerId, DefWithBodyId, EnumId, FunctionId, GenericDefId,\n+    HasModule, ImplId, LocalEnumVariantId, LocalImportId, LocalModuleId, LocalStructFieldId,\n+    Lookup, ModuleId, StaticId, StructId, TraitId, TypeAliasId, UnionId,\n };\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n@@ -383,6 +383,28 @@ impl Union {\n     pub fn ty(self, db: &impl HirDatabase) -> Ty {\n         db.type_for_def(self.into(), Namespace::Types)\n     }\n+\n+    pub fn fields(self, db: &impl HirDatabase) -> Vec<StructField> {\n+        db.union_data(self.id)\n+            .variant_data\n+            .fields()\n+            .iter()\n+            .map(|(id, _)| StructField { parent: self.into(), id })\n+            .collect()\n+    }\n+\n+    pub fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n+        db.union_data(self.id)\n+            .variant_data\n+            .fields()\n+            .iter()\n+            .find(|(_id, data)| data.name == *name)\n+            .map(|(id, _)| StructField { parent: self.into(), id })\n+    }\n+\n+    fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n+        db.union_data(self.id).variant_data.clone()\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -501,35 +523,40 @@ impl Adt {\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum VariantDef {\n     Struct(Struct),\n+    Union(Union),\n     EnumVariant(EnumVariant),\n }\n-impl_froms!(VariantDef: Struct, EnumVariant);\n+impl_froms!(VariantDef: Struct, Union, EnumVariant);\n \n impl VariantDef {\n     pub fn fields(self, db: &impl HirDatabase) -> Vec<StructField> {\n         match self {\n             VariantDef::Struct(it) => it.fields(db),\n+            VariantDef::Union(it) => it.fields(db),\n             VariantDef::EnumVariant(it) => it.fields(db),\n         }\n     }\n \n     pub(crate) fn field(self, db: &impl HirDatabase, name: &Name) -> Option<StructField> {\n         match self {\n             VariantDef::Struct(it) => it.field(db, name),\n+            VariantDef::Union(it) => it.field(db, name),\n             VariantDef::EnumVariant(it) => it.field(db, name),\n         }\n     }\n \n     pub fn module(self, db: &impl HirDatabase) -> Module {\n         match self {\n             VariantDef::Struct(it) => it.module(db),\n+            VariantDef::Union(it) => it.module(db),\n             VariantDef::EnumVariant(it) => it.module(db),\n         }\n     }\n \n     pub(crate) fn variant_data(self, db: &impl DefDatabase) -> Arc<VariantData> {\n         match self {\n             VariantDef::Struct(it) => it.variant_data(db),\n+            VariantDef::Union(it) => it.variant_data(db),\n             VariantDef::EnumVariant(it) => it.variant_data(db),\n         }\n     }\n@@ -1056,19 +1083,24 @@ impl Type {\n     }\n \n     pub fn fields(&self, db: &impl HirDatabase) -> Vec<(StructField, Type)> {\n-        let mut res = Vec::new();\n         if let Ty::Apply(a_ty) = &self.ty.value {\n             match a_ty.ctor {\n-                ty::TypeCtor::Adt(Adt::Struct(s)) => {\n-                    for field in s.fields(db) {\n-                        let ty = field.ty(db).subst(&a_ty.parameters);\n-                        res.push((field, self.derived(ty)));\n-                    }\n+                ty::TypeCtor::Adt(AdtId::StructId(s)) => {\n+                    let var_def = s.into();\n+                    return db\n+                        .field_types(var_def)\n+                        .iter()\n+                        .map(|(local_id, ty)| {\n+                            let def = StructField { parent: var_def.into(), id: local_id };\n+                            let ty = ty.clone().subst(&a_ty.parameters);\n+                            (def, self.derived(ty))\n+                        })\n+                        .collect();\n                 }\n                 _ => {}\n             }\n         };\n-        res\n+        Vec::new()\n     }\n \n     pub fn tuple_fields(&self, _db: &impl HirDatabase) -> Vec<Type> {"}, {"sha": "adb9805ab8fb0d3b3a78a0fc4a28ec8a8457b6b7", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=a443b5033c2e95ee58bf086f7093ddc610d4f78f", "patch": "@@ -2,7 +2,7 @@\n \n use std::sync::Arc;\n \n-use hir_def::{path::known, resolver::HasResolver};\n+use hir_def::{path::known, resolver::HasResolver, AdtId};\n use hir_expand::diagnostics::DiagnosticSink;\n use ra_syntax::ast;\n use ra_syntax::AstPtr;\n@@ -127,7 +127,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             _ => return,\n         };\n \n-        let std_result_ctor = TypeCtor::Adt(Adt::Enum(std_result_enum.into()));\n+        let std_result_ctor = TypeCtor::Adt(AdtId::EnumId(std_result_enum));\n         let params = match &mismatch.expected {\n             Ty::Apply(ApplicationTy { ctor, parameters }) if ctor == &std_result_ctor => parameters,\n             _ => return,"}, {"sha": "38daa5e59ff043840acab3a6557ba18d14d58a14", "filename": "crates/ra_hir/src/from_id.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=a443b5033c2e95ee58bf086f7093ddc610d4f78f", "patch": "@@ -199,11 +199,22 @@ impl From<Adt> for GenericDefId {\n     }\n }\n \n+impl From<VariantId> for VariantDef {\n+    fn from(def: VariantId) -> Self {\n+        match def {\n+            VariantId::StructId(it) => VariantDef::Struct(it.into()),\n+            VariantId::EnumVariantId(it) => VariantDef::EnumVariant(it.into()),\n+            VariantId::UnionId(it) => VariantDef::Union(it.into()),\n+        }\n+    }\n+}\n+\n impl From<VariantDef> for VariantId {\n     fn from(def: VariantDef) -> Self {\n         match def {\n             VariantDef::Struct(it) => VariantId::StructId(it.id),\n             VariantDef::EnumVariant(it) => VariantId::EnumVariantId(it.into()),\n+            VariantDef::Union(it) => VariantId::UnionId(it.id),\n         }\n     }\n }\n@@ -214,6 +225,12 @@ impl From<StructField> for StructFieldId {\n     }\n }\n \n+impl From<StructFieldId> for StructField {\n+    fn from(def: StructFieldId) -> Self {\n+        StructField { parent: def.parent.into(), id: def.local_id }\n+    }\n+}\n+\n impl From<AttrDef> for AttrDefId {\n     fn from(def: AttrDef) -> Self {\n         match def {"}, {"sha": "bd03055b9393f30976f22f6369be0e831698ef17", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=a443b5033c2e95ee58bf086f7093ddc610d4f78f", "patch": "@@ -58,7 +58,7 @@ pub enum TypeCtor {\n     Float(Uncertain<FloatTy>),\n \n     /// Structures, enumerations and unions.\n-    Adt(Adt),\n+    Adt(AdtId),\n \n     /// The pointee of a string slice. Written as `str`.\n     Str,\n@@ -174,7 +174,7 @@ impl TypeCtor {\n             | TypeCtor::Tuple { .. } => None,\n             // Closure's krate is irrelevant for coherence I would think?\n             TypeCtor::Closure { .. } => None,\n-            TypeCtor::Adt(adt) => adt.krate(db),\n+            TypeCtor::Adt(adt) => Some(adt.module(db).krate.into()),\n             TypeCtor::FnDef(callable) => Some(callable.krate(db).into()),\n             TypeCtor::AssociatedType(type_alias) => {\n                 Some(type_alias.lookup(db).module(db).krate.into())\n@@ -598,7 +598,7 @@ impl Ty {\n     pub fn as_adt(&self) -> Option<(Adt, &Substs)> {\n         match self {\n             Ty::Apply(ApplicationTy { ctor: TypeCtor::Adt(adt_def), parameters }) => {\n-                Some((*adt_def, parameters))\n+                Some(((*adt_def).into(), parameters))\n             }\n             _ => None,\n         }\n@@ -889,9 +889,9 @@ impl HirDisplay for ApplicationTy {\n             }\n             TypeCtor::Adt(def_id) => {\n                 let name = match def_id {\n-                    Adt::Struct(s) => s.name(f.db),\n-                    Adt::Union(u) => u.name(f.db),\n-                    Adt::Enum(e) => e.name(f.db),\n+                    AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n+                    AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n+                    AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n                 }\n                 .unwrap_or_else(Name::missing);\n                 write!(f, \"{}\", name)?;"}, {"sha": "fce45321df3950d42d52f22d43d51181b212d237", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=a443b5033c2e95ee58bf086f7093ddc610d4f78f", "patch": "@@ -598,10 +598,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         trait_.associated_type_by_name(self.db, &name::OUTPUT_TYPE)\n     }\n \n-    fn resolve_boxed_box(&self) -> Option<Adt> {\n+    fn resolve_boxed_box(&self) -> Option<AdtId> {\n         let path = known::std_boxed_box();\n         let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n-        Some(Adt::Struct(struct_.into()))\n+        Some(struct_.into())\n     }\n }\n "}, {"sha": "5ed4470afaf30e190a038eeccb7ddae9a84a0469", "filename": "crates/ra_hir/src/ty/infer/coerce.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fcoerce.rs?ref=a443b5033c2e95ee58bf086f7093ddc610d4f78f", "patch": "@@ -4,14 +4,14 @@\n //!\n //! See: https://doc.rust-lang.org/nomicon/coercions.html\n \n-use hir_def::{lang_item::LangItemTarget, resolver::Resolver};\n+use hir_def::{lang_item::LangItemTarget, resolver::Resolver, AdtId};\n use rustc_hash::FxHashMap;\n use test_utils::tested_by;\n \n use crate::{\n     db::HirDatabase,\n     ty::{autoderef, Substs, Ty, TypeCtor, TypeWalk},\n-    Adt, Mutability,\n+    Mutability,\n };\n \n use super::{InEnvironment, InferTy, InferenceContext, TypeVarValue};\n@@ -242,11 +242,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             // - T is not part of the type of any other fields\n             // - Bar<T>: Unsize<Bar<U>>, if the last field of Foo has type Bar<T>\n             (\n-                ty_app!(TypeCtor::Adt(Adt::Struct(struct1)), st1),\n-                ty_app!(TypeCtor::Adt(Adt::Struct(struct2)), st2),\n+                ty_app!(TypeCtor::Adt(AdtId::StructId(struct1)), st1),\n+                ty_app!(TypeCtor::Adt(AdtId::StructId(struct2)), st2),\n             ) if struct1 == struct2 => {\n-                let field_tys = self.db.field_types(struct1.id.into());\n-                let struct_data = self.db.struct_data(struct1.id);\n+                let field_tys = self.db.field_types((*struct1).into());\n+                let struct_data = self.db.struct_data(*struct1);\n \n                 let mut fields = struct_data.variant_data.fields().iter();\n                 let (last_field_id, _data) = fields.next_back()?;"}, {"sha": "3d0895dc6123c4b5a6ba5b759e3e0b4075372a44", "filename": "crates/ra_hir/src/ty/infer/expr.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs?ref=a443b5033c2e95ee58bf086f7093ddc610d4f78f", "patch": "@@ -8,7 +8,7 @@ use hir_def::{\n     generics::GenericParams,\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n-    ContainerId, Lookup,\n+    AdtId, ContainerId, Lookup, StructFieldId,\n };\n use hir_expand::name;\n \n@@ -20,7 +20,7 @@ use crate::{\n         Mutability, Namespace, Obligation, ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty,\n         TypeCtor, TypeWalk, Uncertain,\n     },\n-    Adt, Name,\n+    Name,\n };\n \n use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch};\n@@ -259,14 +259,17 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         TypeCtor::Tuple { .. } => name\n                             .as_tuple_index()\n                             .and_then(|idx| a_ty.parameters.0.get(idx).cloned()),\n-                        TypeCtor::Adt(Adt::Struct(s)) => s.field(self.db, name).map(|field| {\n-                            self.write_field_resolution(tgt_expr, field);\n-                            self.db.field_types(s.id.into())[field.id]\n-                                .clone()\n-                                .subst(&a_ty.parameters)\n-                        }),\n+                        TypeCtor::Adt(AdtId::StructId(s)) => {\n+                            self.db.struct_data(s).variant_data.field(name).map(|local_id| {\n+                                let field = StructFieldId { parent: s.into(), local_id }.into();\n+                                self.write_field_resolution(tgt_expr, field);\n+                                self.db.field_types(s.into())[field.id]\n+                                    .clone()\n+                                    .subst(&a_ty.parameters)\n+                            })\n+                        }\n                         // FIXME:\n-                        TypeCtor::Adt(Adt::Union(_)) => None,\n+                        TypeCtor::Adt(AdtId::UnionId(_)) => None,\n                         _ => None,\n                     },\n                     _ => None,"}, {"sha": "485871e6904b6bf416d33d8b25e70ce94e3aedac", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=a443b5033c2e95ee58bf086f7093ddc610d4f78f", "patch": "@@ -762,7 +762,7 @@ fn type_for_adt(db: &impl HirDatabase, adt: impl Into<Adt>) -> Ty {\n     let adt = adt.into();\n     let adt_id: AdtId = adt.into();\n     let generics = db.generic_params(adt_id.into());\n-    Ty::apply(TypeCtor::Adt(adt), Substs::identity(&generics))\n+    Ty::apply(TypeCtor::Adt(adt_id), Substs::identity(&generics))\n }\n \n fn type_for_type_alias(db: &impl HirDatabase, t: TypeAlias) -> Ty {"}, {"sha": "7f0ff2e8ca93d5d376e41b830ad2b0a0d78e5cbb", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=a443b5033c2e95ee58bf086f7093ddc610d4f78f", "patch": "@@ -5,7 +5,7 @@\n use std::sync::Arc;\n \n use arrayvec::ArrayVec;\n-use hir_def::{lang_item::LangItemTarget, resolver::Resolver, AstItemDef};\n+use hir_def::{lang_item::LangItemTarget, resolver::Resolver, AstItemDef, HasModule};\n use rustc_hash::FxHashMap;\n \n use crate::{\n@@ -102,7 +102,9 @@ fn def_crates(db: &impl HirDatabase, cur_crate: Crate, ty: &Ty) -> Option<ArrayV\n \n     let lang_item_targets = match ty {\n         Ty::Apply(a_ty) => match a_ty.ctor {\n-            TypeCtor::Adt(def_id) => return Some(std::iter::once(def_id.krate(db)?).collect()),\n+            TypeCtor::Adt(def_id) => {\n+                return Some(std::iter::once(def_id.module(db).krate.into()).collect())\n+            }\n             TypeCtor::Bool => lang_item_crate!(\"bool\"),\n             TypeCtor::Char => lang_item_crate!(\"char\"),\n             TypeCtor::Float(Uncertain::Known(f)) => match f.bitness {"}, {"sha": "0cf418d301a912019b21a0f5a074289e81488b40", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=a443b5033c2e95ee58bf086f7093ddc610d4f78f", "patch": "@@ -129,6 +129,10 @@ impl VariantData {\n         }\n     }\n \n+    pub fn field(&self, name: &Name) -> Option<LocalStructFieldId> {\n+        self.fields().iter().find_map(|(id, data)| if &data.name == name { Some(id) } else { None })\n+    }\n+\n     pub fn is_unit(&self) -> bool {\n         match self {\n             VariantData::Unit => true,"}, {"sha": "cf12db066aeb984407f0289cf5c943407794a680", "filename": "crates/ra_ide_api/src/references/name_definition.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fname_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a443b5033c2e95ee58bf086f7093ddc610d4f78f/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fname_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fname_definition.rs?ref=a443b5033c2e95ee58bf086f7093ddc610d4f78f", "patch": "@@ -46,6 +46,7 @@ pub(super) fn from_struct_field(db: &RootDatabase, field: StructField) -> NameDe\n     let container = parent.module(db);\n     let visibility = match parent {\n         VariantDef::Struct(s) => s.source(db).value.visibility(),\n+        VariantDef::Union(e) => e.source(db).value.visibility(),\n         VariantDef::EnumVariant(e) => e.source(db).value.parent_enum().visibility(),\n     };\n     NameDefinition { kind, container, visibility }"}]}