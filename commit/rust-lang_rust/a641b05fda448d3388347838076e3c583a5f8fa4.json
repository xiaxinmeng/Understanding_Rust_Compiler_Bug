{"sha": "a641b05fda448d3388347838076e3c583a5f8fa4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2NDFiMDVmZGE0NDhkMzM4ODM0NzgzODA3NmUzYzU4M2E1ZjhmYTQ=", "commit": {"author": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-04-23T09:37:39Z"}, "committer": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-05-06T05:22:26Z"}, "message": "core: updated for the master changes.\n\nThe master no longer has `std::num::Float`, so a generic `ldexp` is\nnot readily available. `DecodableFloat::ldexpi` works around this.", "tree": {"sha": "8ec983e0bbaa717babdf6b36b78e362c17da81e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ec983e0bbaa717babdf6b36b78e362c17da81e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a641b05fda448d3388347838076e3c583a5f8fa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a641b05fda448d3388347838076e3c583a5f8fa4", "html_url": "https://github.com/rust-lang/rust/commit/a641b05fda448d3388347838076e3c583a5f8fa4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a641b05fda448d3388347838076e3c583a5f8fa4/comments", "author": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97ea7c14bae496d6444752be570dd41cf1a507bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/97ea7c14bae496d6444752be570dd41cf1a507bd", "html_url": "https://github.com/rust-lang/rust/commit/97ea7c14bae496d6444752be570dd41cf1a507bd"}], "stats": {"total": 194, "additions": 96, "deletions": 98}, "files": [{"sha": "f98bc11a315f0dab50c4e580262652f7e144a9b9", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a641b05fda448d3388347838076e3c583a5f8fa4/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a641b05fda448d3388347838076e3c583a5f8fa4/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=a641b05fda448d3388347838076e3c583a5f8fa4", "patch": "@@ -53,15 +53,20 @@ pub enum FullDecoded {\n \n /// A floating point type which can be `decode`d.\n pub trait DecodableFloat: Float + Copy {\n+    /// Returns `x * 2^exp`. Almost same to `std::{f32,f64}::ldexp`.\n+    /// This is used for testing.\n+    fn ldexpi(f: i64, exp: isize) -> Self;\n     /// The minimum positive normalized value.\n     fn min_pos_norm_value() -> Self;\n }\n \n impl DecodableFloat for f32 {\n+    fn ldexpi(f: i64, exp: isize) -> Self { f as Self * (exp as Self).exp2() }\n     fn min_pos_norm_value() -> Self { f32::MIN_POSITIVE }\n }\n \n impl DecodableFloat for f64 {\n+    fn ldexpi(f: i64, exp: isize) -> Self { f as Self * (exp as Self).exp2() }\n     fn min_pos_norm_value() -> Self { f64::MIN_POSITIVE }\n }\n "}, {"sha": "21260c520f6235e26f0129dd141dec9a07f58146", "filename": "src/libcoretest/num/flt2dec/estimator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a641b05fda448d3388347838076e3c583a5f8fa4/src%2Flibcoretest%2Fnum%2Fflt2dec%2Festimator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a641b05fda448d3388347838076e3c583a5f8fa4/src%2Flibcoretest%2Fnum%2Fflt2dec%2Festimator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Festimator.rs?ref=a641b05fda448d3388347838076e3c583a5f8fa4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::num::Float;\n+use std::f64;\n use core::num::flt2dec::estimator::*;\n \n #[test]\n@@ -54,7 +54,7 @@ fn test_estimate_scaling_factor() {\n     assert_almost_eq!(estimate_scaling_factor(0x1fffffffffffff, 971), 309);\n \n     for i in -1074..972 {\n-        let expected = Float::ldexp(1.0, i).log10().ceil();\n+        let expected = f64::ldexp(1.0, i).log10().ceil();\n         assert_almost_eq!(estimate_scaling_factor(1, i as i16), expected as i16);\n     }\n }"}, {"sha": "7b076e80532031de36b859029062ca8fbfe98c39", "filename": "src/libcoretest/num/flt2dec/mod.rs", "status": "modified", "additions": 89, "deletions": 96, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/a641b05fda448d3388347838076e3c583a5f8fa4/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a641b05fda448d3388347838076e3c583a5f8fa4/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs?ref=a641b05fda448d3388347838076e3c583a5f8fa4", "patch": "@@ -10,7 +10,6 @@\n \n use std::prelude::v1::*;\n use std::{str, mem, i16, f32, f64, fmt};\n-use std::num::Float as StdFloat;\n use std::slice::bytes;\n use std::__rand as rand;\n use rand::{Rand, XorShiftRng};\n@@ -159,12 +158,12 @@ fn check_exact<F, T>(mut f: F, v: T, vstr: &str, expected: &[u8], expectedk: i16\n     }\n }\n \n-fn check_exact_one<F, T>(mut f: F, x: T, e: isize, tstr: &str, expected: &[u8], expectedk: i16)\n-        where T: DecodableFloat + StdFloat + fmt::Display,\n+fn check_exact_one<F, T>(mut f: F, x: i64, e: isize, tstr: &str, expected: &[u8], expectedk: i16)\n+        where T: DecodableFloat + fmt::Display,\n               F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n     // use a large enough buffer\n     let mut buf = [b'_'; 1024];\n-    let v: T = StdFloat::ldexp(x, e);\n+    let v: T = DecodableFloat::ldexpi(x, e);\n     let decoded = decode_finite(v);\n \n     try_exact!(f(&decoded) => &mut buf, &expected, expectedk;\n@@ -220,8 +219,7 @@ pub fn f32_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8])\n     // 10^8 * 0.3355443\n     // 10^8 * 0.33554432\n     // 10^8 * 0.33554436\n-    let twoto25: f32 = StdFloat::ldexp(1.0, 25);\n-    check_shortest!(f(twoto25) => b\"33554432\", 8);\n+    check_shortest!(f(f32::ldexp(1.0, 25)) => b\"33554432\", 8);\n \n     // 10^39 * 0.340282326356119256160033759537265639424\n     // 10^39 * 0.34028234663852885981170418348451692544\n@@ -236,13 +234,13 @@ pub fn f32_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8])\n     // 10^-44 * 0\n     // 10^-44 * 0.1401298464324817070923729583289916131280...\n     // 10^-44 * 0.2802596928649634141847459166579832262560...\n-    let minf32: f32 = StdFloat::ldexp(1.0, -149);\n+    let minf32 = f32::ldexp(1.0, -149);\n     check_shortest!(f(minf32) => b\"1\", -44);\n }\n \n pub fn f32_exact_sanity_test<F>(mut f: F)\n         where F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n-    let minf32: f32 = StdFloat::ldexp(1.0, -149);\n+    let minf32 = f32::ldexp(1.0, -149);\n \n     check_exact!(f(0.1f32)            => b\"100000001490116119384765625             \", 0);\n     check_exact!(f(1.0f32/3.0)        => b\"3333333432674407958984375               \", 0);\n@@ -253,32 +251,32 @@ pub fn f32_exact_sanity_test<F>(mut f: F)\n     check_exact!(f(minf32)            => b\"1401298464324817070923729583289916131280\", -44);\n \n     // [1], Table 16: Stress Inputs for Converting 24-bit Binary to Decimal, < 1/2 ULP\n-    check_exact_one!(f(12676506.0, -102; f32) => b\"2\",            -23);\n-    check_exact_one!(f(12676506.0, -103; f32) => b\"12\",           -23);\n-    check_exact_one!(f(15445013.0,   86; f32) => b\"119\",           34);\n-    check_exact_one!(f(13734123.0, -138; f32) => b\"3941\",         -34);\n-    check_exact_one!(f(12428269.0, -130; f32) => b\"91308\",        -32);\n-    check_exact_one!(f(15334037.0, -146; f32) => b\"171900\",       -36);\n-    check_exact_one!(f(11518287.0,  -41; f32) => b\"5237910\",       -5);\n-    check_exact_one!(f(12584953.0, -145; f32) => b\"28216440\",     -36);\n-    check_exact_one!(f(15961084.0, -125; f32) => b\"375243281\",    -30);\n-    check_exact_one!(f(14915817.0, -146; f32) => b\"1672120916\",   -36);\n-    check_exact_one!(f(10845484.0, -102; f32) => b\"21388945814\",  -23);\n-    check_exact_one!(f(16431059.0,  -61; f32) => b\"712583594561\", -11);\n+    check_exact_one!(f(12676506, -102; f32) => b\"2\",            -23);\n+    check_exact_one!(f(12676506, -103; f32) => b\"12\",           -23);\n+    check_exact_one!(f(15445013,   86; f32) => b\"119\",           34);\n+    check_exact_one!(f(13734123, -138; f32) => b\"3941\",         -34);\n+    check_exact_one!(f(12428269, -130; f32) => b\"91308\",        -32);\n+    check_exact_one!(f(15334037, -146; f32) => b\"171900\",       -36);\n+    check_exact_one!(f(11518287,  -41; f32) => b\"5237910\",       -5);\n+    check_exact_one!(f(12584953, -145; f32) => b\"28216440\",     -36);\n+    check_exact_one!(f(15961084, -125; f32) => b\"375243281\",    -30);\n+    check_exact_one!(f(14915817, -146; f32) => b\"1672120916\",   -36);\n+    check_exact_one!(f(10845484, -102; f32) => b\"21388945814\",  -23);\n+    check_exact_one!(f(16431059,  -61; f32) => b\"712583594561\", -11);\n \n     // [1], Table 17: Stress Inputs for Converting 24-bit Binary to Decimal, > 1/2 ULP\n-    check_exact_one!(f(16093626.0,   69; f32) => b\"1\",             29);\n-    check_exact_one!(f( 9983778.0,   25; f32) => b\"34\",            15);\n-    check_exact_one!(f(12745034.0,  104; f32) => b\"259\",           39);\n-    check_exact_one!(f(12706553.0,   72; f32) => b\"6001\",          29);\n-    check_exact_one!(f(11005028.0,   45; f32) => b\"38721\",         21);\n-    check_exact_one!(f(15059547.0,   71; f32) => b\"355584\",        29);\n-    check_exact_one!(f(16015691.0,  -99; f32) => b\"2526831\",      -22);\n-    check_exact_one!(f( 8667859.0,   56; f32) => b\"62458507\",      24);\n-    check_exact_one!(f(14855922.0,  -82; f32) => b\"307213267\",    -17);\n-    check_exact_one!(f(14855922.0,  -83; f32) => b\"1536066333\",   -17);\n-    check_exact_one!(f(10144164.0, -110; f32) => b\"78147796834\",  -26);\n-    check_exact_one!(f(13248074.0,   95; f32) => b\"524810279937\",  36);\n+    check_exact_one!(f(16093626,   69; f32) => b\"1\",             29);\n+    check_exact_one!(f( 9983778,   25; f32) => b\"34\",            15);\n+    check_exact_one!(f(12745034,  104; f32) => b\"259\",           39);\n+    check_exact_one!(f(12706553,   72; f32) => b\"6001\",          29);\n+    check_exact_one!(f(11005028,   45; f32) => b\"38721\",         21);\n+    check_exact_one!(f(15059547,   71; f32) => b\"355584\",        29);\n+    check_exact_one!(f(16015691,  -99; f32) => b\"2526831\",      -22);\n+    check_exact_one!(f( 8667859,   56; f32) => b\"62458507\",      24);\n+    check_exact_one!(f(14855922,  -82; f32) => b\"307213267\",    -17);\n+    check_exact_one!(f(14855922,  -83; f32) => b\"1536066333\",   -17);\n+    check_exact_one!(f(10144164, -110; f32) => b\"78147796834\",  -26);\n+    check_exact_one!(f(13248074,   95; f32) => b\"524810279937\",  36);\n }\n \n pub fn f64_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n@@ -319,8 +317,7 @@ pub fn f64_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8])\n     // 10^20 * 0.18446744073709549568\n     // 10^20 * 0.18446744073709551616\n     // 10^20 * 0.18446744073709555712\n-    let twoto64: f64 = StdFloat::ldexp(1.0, 64);\n-    check_shortest!(f(twoto64) => b\"18446744073709552\", 20);\n+    check_shortest!(f(f64::ldexp(1.0, 64)) => b\"18446744073709552\", 20);\n \n     // pathological case: high = 10^23 (exact). tie breaking should always prefer that.\n     // 10^24 * 0.099999999999999974834176\n@@ -341,13 +338,13 @@ pub fn f64_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8])\n     // 10^-323 * 0\n     // 10^-323 * 0.4940656458412465441765687928682213723650...\n     // 10^-323 * 0.9881312916824930883531375857364427447301...\n-    let minf64: f64 = StdFloat::ldexp(1.0, -1074);\n+    let minf64 = f64::ldexp(1.0, -1074);\n     check_shortest!(f(minf64) => b\"5\", -323);\n }\n \n pub fn f64_exact_sanity_test<F>(mut f: F)\n         where F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n-    let minf64: f64 = StdFloat::ldexp(1.0, -1074);\n+    let minf64 = f64::ldexp(1.0, -1074);\n \n     check_exact!(f(0.1f64)            => b\"1000000000000000055511151231257827021181\", 0);\n     check_exact!(f(0.45f64)           => b\"4500000000000000111022302462515654042363\", 0);\n@@ -381,52 +378,52 @@ pub fn f64_exact_sanity_test<F>(mut f: F)\n                                            7538682506419718265533447265625         \", -323);\n \n     // [1], Table 3: Stress Inputs for Converting 53-bit Binary to Decimal, < 1/2 ULP\n-    check_exact_one!(f(8511030020275656.0,  -342; f64) => b\"9\",                       -87);\n-    check_exact_one!(f(5201988407066741.0,  -824; f64) => b\"46\",                     -232);\n-    check_exact_one!(f(6406892948269899.0,   237; f64) => b\"141\",                      88);\n-    check_exact_one!(f(8431154198732492.0,    72; f64) => b\"3981\",                     38);\n-    check_exact_one!(f(6475049196144587.0,    99; f64) => b\"41040\",                    46);\n-    check_exact_one!(f(8274307542972842.0,   726; f64) => b\"292084\",                  235);\n-    check_exact_one!(f(5381065484265332.0,  -456; f64) => b\"2891946\",                -121);\n-    check_exact_one!(f(6761728585499734.0, -1057; f64) => b\"43787718\",               -302);\n-    check_exact_one!(f(7976538478610756.0,   376; f64) => b\"122770163\",               130);\n-    check_exact_one!(f(5982403858958067.0,   377; f64) => b\"1841552452\",              130);\n-    check_exact_one!(f(5536995190630837.0,    93; f64) => b\"54835744350\",              44);\n-    check_exact_one!(f(7225450889282194.0,   710; f64) => b\"389190181146\",            230);\n-    check_exact_one!(f(7225450889282194.0,   709; f64) => b\"1945950905732\",           230);\n-    check_exact_one!(f(8703372741147379.0,   117; f64) => b\"14460958381605\",           52);\n-    check_exact_one!(f(8944262675275217.0, -1001; f64) => b\"417367747458531\",        -285);\n-    check_exact_one!(f(7459803696087692.0,  -707; f64) => b\"1107950772878888\",       -196);\n-    check_exact_one!(f(6080469016670379.0,  -381; f64) => b\"12345501366327440\",       -98);\n-    check_exact_one!(f(8385515147034757.0,   721; f64) => b\"925031711960365024\",      233);\n-    check_exact_one!(f(7514216811389786.0,  -828; f64) => b\"4198047150284889840\",    -233);\n-    check_exact_one!(f(8397297803260511.0,  -345; f64) => b\"11716315319786511046\",    -87);\n-    check_exact_one!(f(6733459239310543.0,   202; f64) => b\"432810072844612493629\",    77);\n-    check_exact_one!(f(8091450587292794.0,  -473; f64) => b\"3317710118160031081518\", -126);\n+    check_exact_one!(f(8511030020275656,  -342; f64) => b\"9\",                       -87);\n+    check_exact_one!(f(5201988407066741,  -824; f64) => b\"46\",                     -232);\n+    check_exact_one!(f(6406892948269899,   237; f64) => b\"141\",                      88);\n+    check_exact_one!(f(8431154198732492,    72; f64) => b\"3981\",                     38);\n+    check_exact_one!(f(6475049196144587,    99; f64) => b\"41040\",                    46);\n+    check_exact_one!(f(8274307542972842,   726; f64) => b\"292084\",                  235);\n+    check_exact_one!(f(5381065484265332,  -456; f64) => b\"2891946\",                -121);\n+    check_exact_one!(f(6761728585499734, -1057; f64) => b\"43787718\",               -302);\n+    check_exact_one!(f(7976538478610756,   376; f64) => b\"122770163\",               130);\n+    check_exact_one!(f(5982403858958067,   377; f64) => b\"1841552452\",              130);\n+    check_exact_one!(f(5536995190630837,    93; f64) => b\"54835744350\",              44);\n+    check_exact_one!(f(7225450889282194,   710; f64) => b\"389190181146\",            230);\n+    check_exact_one!(f(7225450889282194,   709; f64) => b\"1945950905732\",           230);\n+    check_exact_one!(f(8703372741147379,   117; f64) => b\"14460958381605\",           52);\n+    check_exact_one!(f(8944262675275217, -1001; f64) => b\"417367747458531\",        -285);\n+    check_exact_one!(f(7459803696087692,  -707; f64) => b\"1107950772878888\",       -196);\n+    check_exact_one!(f(6080469016670379,  -381; f64) => b\"12345501366327440\",       -98);\n+    check_exact_one!(f(8385515147034757,   721; f64) => b\"925031711960365024\",      233);\n+    check_exact_one!(f(7514216811389786,  -828; f64) => b\"4198047150284889840\",    -233);\n+    check_exact_one!(f(8397297803260511,  -345; f64) => b\"11716315319786511046\",    -87);\n+    check_exact_one!(f(6733459239310543,   202; f64) => b\"432810072844612493629\",    77);\n+    check_exact_one!(f(8091450587292794,  -473; f64) => b\"3317710118160031081518\", -126);\n \n     // [1], Table 4: Stress Inputs for Converting 53-bit Binary to Decimal, > 1/2 ULP\n-    check_exact_one!(f(6567258882077402.0,   952; f64) => b\"3\",                       303);\n-    check_exact_one!(f(6712731423444934.0,   535; f64) => b\"76\",                      177);\n-    check_exact_one!(f(6712731423444934.0,   534; f64) => b\"378\",                     177);\n-    check_exact_one!(f(5298405411573037.0,  -957; f64) => b\"4350\",                   -272);\n-    check_exact_one!(f(5137311167659507.0,  -144; f64) => b\"23037\",                   -27);\n-    check_exact_one!(f(6722280709661868.0,   363; f64) => b\"126301\",                  126);\n-    check_exact_one!(f(5344436398034927.0,  -169; f64) => b\"7142211\",                 -35);\n-    check_exact_one!(f(8369123604277281.0,  -853; f64) => b\"13934574\",               -240);\n-    check_exact_one!(f(8995822108487663.0,  -780; f64) => b\"141463449\",              -218);\n-    check_exact_one!(f(8942832835564782.0,  -383; f64) => b\"4539277920\",              -99);\n-    check_exact_one!(f(8942832835564782.0,  -384; f64) => b\"22696389598\",             -99);\n-    check_exact_one!(f(8942832835564782.0,  -385; f64) => b\"113481947988\",            -99);\n-    check_exact_one!(f(6965949469487146.0,  -249; f64) => b\"7700366561890\",           -59);\n-    check_exact_one!(f(6965949469487146.0,  -250; f64) => b\"38501832809448\",          -59);\n-    check_exact_one!(f(6965949469487146.0,  -251; f64) => b\"192509164047238\",         -59);\n-    check_exact_one!(f(7487252720986826.0,   548; f64) => b\"6898586531774201\",        181);\n-    check_exact_one!(f(5592117679628511.0,   164; f64) => b\"13076622631878654\",        66);\n-    check_exact_one!(f(8887055249355788.0,   665; f64) => b\"136052020756121240\",      217);\n-    check_exact_one!(f(6994187472632449.0,   690; f64) => b\"3592810217475959676\",     224);\n-    check_exact_one!(f(8797576579012143.0,   588; f64) => b\"89125197712484551899\",    193);\n-    check_exact_one!(f(7363326733505337.0,   272; f64) => b\"558769757362301140950\",    98);\n-    check_exact_one!(f(8549497411294502.0,  -448; f64) => b\"1176257830728540379990\", -118);\n+    check_exact_one!(f(6567258882077402,   952; f64) => b\"3\",                       303);\n+    check_exact_one!(f(6712731423444934,   535; f64) => b\"76\",                      177);\n+    check_exact_one!(f(6712731423444934,   534; f64) => b\"378\",                     177);\n+    check_exact_one!(f(5298405411573037,  -957; f64) => b\"4350\",                   -272);\n+    check_exact_one!(f(5137311167659507,  -144; f64) => b\"23037\",                   -27);\n+    check_exact_one!(f(6722280709661868,   363; f64) => b\"126301\",                  126);\n+    check_exact_one!(f(5344436398034927,  -169; f64) => b\"7142211\",                 -35);\n+    check_exact_one!(f(8369123604277281,  -853; f64) => b\"13934574\",               -240);\n+    check_exact_one!(f(8995822108487663,  -780; f64) => b\"141463449\",              -218);\n+    check_exact_one!(f(8942832835564782,  -383; f64) => b\"4539277920\",              -99);\n+    check_exact_one!(f(8942832835564782,  -384; f64) => b\"22696389598\",             -99);\n+    check_exact_one!(f(8942832835564782,  -385; f64) => b\"113481947988\",            -99);\n+    check_exact_one!(f(6965949469487146,  -249; f64) => b\"7700366561890\",           -59);\n+    check_exact_one!(f(6965949469487146,  -250; f64) => b\"38501832809448\",          -59);\n+    check_exact_one!(f(6965949469487146,  -251; f64) => b\"192509164047238\",         -59);\n+    check_exact_one!(f(7487252720986826,   548; f64) => b\"6898586531774201\",        181);\n+    check_exact_one!(f(5592117679628511,   164; f64) => b\"13076622631878654\",        66);\n+    check_exact_one!(f(8887055249355788,   665; f64) => b\"136052020756121240\",      217);\n+    check_exact_one!(f(6994187472632449,   690; f64) => b\"3592810217475959676\",     224);\n+    check_exact_one!(f(8797576579012143,   588; f64) => b\"89125197712484551899\",    193);\n+    check_exact_one!(f(7363326733505337,   272; f64) => b\"558769757362301140950\",    98);\n+    check_exact_one!(f(8549497411294502,  -448; f64) => b\"1176257830728540379990\", -118);\n }\n \n pub fn more_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n@@ -532,8 +529,7 @@ pub fn to_shortest_str_test<F>(mut f_: F)\n     use core::num::flt2dec::Sign::*;\n \n     fn to_string<T, F>(f: &mut F, v: T, sign: Sign, frac_digits: usize, upper: bool) -> String\n-            where T: DecodableFloat + StdFloat,\n-                  F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+            where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n         to_string_with_parts(|buf, parts| to_shortest_str(|d,b| f(d,b), v, sign,\n                                                           frac_digits, upper, buf, parts))\n     }\n@@ -600,7 +596,7 @@ pub fn to_shortest_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, f32::MAX, Minus, 1, false), format!(\"34028235{:0>31}.0\", \"\"));\n     assert_eq!(to_string(f, f32::MAX, Minus, 8, false), format!(\"34028235{:0>31}.00000000\", \"\"));\n \n-    let minf32: f32 = StdFloat::ldexp(1.0, -149);\n+    let minf32 = f32::ldexp(1.0, -149);\n     assert_eq!(to_string(f, minf32, Minus,  0, false), format!(\"0.{:0>44}1\", \"\"));\n     assert_eq!(to_string(f, minf32, Minus, 45, false), format!(\"0.{:0>44}1\", \"\"));\n     assert_eq!(to_string(f, minf32, Minus, 46, false), format!(\"0.{:0>44}10\", \"\"));\n@@ -612,7 +608,7 @@ pub fn to_shortest_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, f64::MAX, Minus, 8, false),\n                format!(\"17976931348623157{:0>292}.00000000\", \"\"));\n \n-    let minf64: f64 = StdFloat::ldexp(1.0, -1074);\n+    let minf64 = f64::ldexp(1.0, -1074);\n     assert_eq!(to_string(f, minf64, Minus,   0, false), format!(\"0.{:0>323}5\", \"\"));\n     assert_eq!(to_string(f, minf64, Minus, 324, false), format!(\"0.{:0>323}5\", \"\"));\n     assert_eq!(to_string(f, minf64, Minus, 325, false), format!(\"0.{:0>323}50\", \"\"));\n@@ -626,8 +622,7 @@ pub fn to_shortest_exp_str_test<F>(mut f_: F)\n     use core::num::flt2dec::Sign::*;\n \n     fn to_string<T, F>(f: &mut F, v: T, sign: Sign, exp_bounds: (i16, i16), upper: bool) -> String\n-            where T: DecodableFloat + StdFloat,\n-                  F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+            where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n         to_string_with_parts(|buf, parts| to_shortest_exp_str(|d,b| f(d,b), v, sign,\n                                                               exp_bounds, upper, buf, parts))\n     }\n@@ -715,7 +710,7 @@ pub fn to_shortest_exp_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, f32::MAX, Minus, (-39, 38), false), \"3.4028235e38\");\n     assert_eq!(to_string(f, f32::MAX, Minus, (-38, 39), false), format!(\"34028235{:0>31}\", \"\"));\n \n-    let minf32: f32 = StdFloat::ldexp(1.0, -149);\n+    let minf32 = f32::ldexp(1.0, -149);\n     assert_eq!(to_string(f, minf32, Minus, ( -4, 16), false), \"1e-45\");\n     assert_eq!(to_string(f, minf32, Minus, (-44, 45), false), \"1e-45\");\n     assert_eq!(to_string(f, minf32, Minus, (-45, 44), false), format!(\"0.{:0>44}1\", \"\"));\n@@ -727,7 +722,7 @@ pub fn to_shortest_exp_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, f64::MAX, Minus, (-309, 308), false),\n                \"1.7976931348623157e308\");\n \n-    let minf64: f64 = StdFloat::ldexp(1.0, -1074);\n+    let minf64 = f64::ldexp(1.0, -1074);\n     assert_eq!(to_string(f, minf64, Minus, (  -4,  16), false), \"5e-324\");\n     assert_eq!(to_string(f, minf64, Minus, (-324, 323), false), format!(\"0.{:0>323}5\", \"\"));\n     assert_eq!(to_string(f, minf64, Minus, (-323, 324), false), \"5e-324\");\n@@ -740,8 +735,7 @@ pub fn to_exact_exp_str_test<F>(mut f_: F)\n     use core::num::flt2dec::Sign::*;\n \n     fn to_string<T, F>(f: &mut F, v: T, sign: Sign, ndigits: usize, upper: bool) -> String\n-            where T: DecodableFloat + StdFloat,\n-                  F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+            where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n         to_string_with_parts(|buf, parts| to_exact_exp_str(|d,b,l| f(d,b,l), v, sign,\n                                                            ndigits, upper, buf, parts))\n     }\n@@ -860,7 +854,7 @@ pub fn to_exact_exp_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, f32::MAX, Minus, 64, false),\n                \"3.402823466385288598117041834845169254400000000000000000000000000e38\");\n \n-    let minf32: f32 = StdFloat::ldexp(1.0, -149);\n+    let minf32 = f32::ldexp(1.0, -149);\n     assert_eq!(to_string(f, minf32, Minus,   1, false), \"1e-45\");\n     assert_eq!(to_string(f, minf32, Minus,   2, false), \"1.4e-45\");\n     assert_eq!(to_string(f, minf32, Minus,   4, false), \"1.401e-45\");\n@@ -900,7 +894,7 @@ pub fn to_exact_exp_str_test<F>(mut f_: F)\n                  0000000000000000000000000000000000000000000000000000000000000000e308\");\n \n     // okay, this is becoming tough. fortunately for us, this is almost the worst case.\n-    let minf64: f64 = StdFloat::ldexp(1.0, -1074);\n+    let minf64 = f64::ldexp(1.0, -1074);\n     assert_eq!(to_string(f, minf64, Minus,    1, false), \"5e-324\");\n     assert_eq!(to_string(f, minf64, Minus,    2, false), \"4.9e-324\");\n     assert_eq!(to_string(f, minf64, Minus,    4, false), \"4.941e-324\");\n@@ -961,8 +955,7 @@ pub fn to_exact_fixed_str_test<F>(mut f_: F)\n     use core::num::flt2dec::Sign::*;\n \n     fn to_string<T, F>(f: &mut F, v: T, sign: Sign, frac_digits: usize, upper: bool) -> String\n-            where T: DecodableFloat + StdFloat,\n-                  F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+            where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n         to_string_with_parts(|buf, parts| to_exact_fixed_str(|d,b,l| f(d,b,l), v, sign,\n                                                              frac_digits, upper, buf, parts))\n     }\n@@ -1102,7 +1095,7 @@ pub fn to_exact_fixed_str_test<F>(mut f_: F)\n     assert_eq!(to_string(f, f32::MAX, Minus, 2, false),\n                \"340282346638528859811704183484516925440.00\");\n \n-    let minf32: f32 = StdFloat::ldexp(1.0, -149);\n+    let minf32 = f32::ldexp(1.0, -149);\n     assert_eq!(to_string(f, minf32, Minus,   0, false), \"0\");\n     assert_eq!(to_string(f, minf32, Minus,   1, false), \"0.0\");\n     assert_eq!(to_string(f, minf32, Minus,   2, false), \"0.00\");\n@@ -1134,7 +1127,7 @@ pub fn to_exact_fixed_str_test<F>(mut f_: F)\n                 9440758685084551339423045832369032229481658085593321233482747978\\\n                 26204144723168738177180919299881250404026184124858368.0000000000\");\n \n-    let minf64: f64 = StdFloat::ldexp(1.0, -1074);\n+    let minf64 = f64::ldexp(1.0, -1074);\n     assert_eq!(to_string(f, minf64, Minus, 0, false), \"0\");\n     assert_eq!(to_string(f, minf64, Minus, 1, false), \"0.0\");\n     assert_eq!(to_string(f, minf64, Minus, 10, false), \"0.0000000000\");"}]}