{"sha": "47f8218d0dfcd9f31185f2628d07a993ba6780f5", "node_id": "C_kwDOAAsO6NoAKDQ3ZjgyMThkMGRmY2Q5ZjMxMTg1ZjI2MjhkMDdhOTkzYmE2NzgwZjU", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-03-12T16:21:45Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-03-12T17:17:23Z"}, "message": "add write_int_fields to replace write_packed_immediates\n\nfor stat, lookup fields by name", "tree": {"sha": "a736092dc7e8ac54898ee732d0360bc024a8cd65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a736092dc7e8ac54898ee732d0360bc024a8cd65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47f8218d0dfcd9f31185f2628d07a993ba6780f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47f8218d0dfcd9f31185f2628d07a993ba6780f5", "html_url": "https://github.com/rust-lang/rust/commit/47f8218d0dfcd9f31185f2628d07a993ba6780f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47f8218d0dfcd9f31185f2628d07a993ba6780f5/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bd6bc90986987c65f5f3e183032ce0a78fc716b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bd6bc90986987c65f5f3e183032ce0a78fc716b", "html_url": "https://github.com/rust-lang/rust/commit/4bd6bc90986987c65f5f3e183032ce0a78fc716b"}], "stats": {"total": 351, "additions": 169, "deletions": 182}, "files": [{"sha": "ba12e0a7e394e1ef8680770913db65175436b18b", "filename": "src/helpers.rs", "status": "modified", "additions": 64, "deletions": 58, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/47f8218d0dfcd9f31185f2628d07a993ba6780f5/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f8218d0dfcd9f31185f2628d07a993ba6780f5/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=47f8218d0dfcd9f31185f2628d07a993ba6780f5", "patch": "@@ -57,8 +57,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     /// Evaluates the scalar at the specified path. Returns Some(val)\n     /// if the path could be resolved, and None otherwise\n-    fn eval_path_scalar(&mut self, path: &[&str]) -> InterpResult<'tcx, Scalar<Tag>> {\n-        let this = self.eval_context_mut();\n+    fn eval_path_scalar(&self, path: &[&str]) -> InterpResult<'tcx, Scalar<Tag>> {\n+        let this = self.eval_context_ref();\n         let instance = this.resolve_path(path);\n         let cid = GlobalId { instance, promoted: None };\n         let const_val = this.eval_to_allocation(cid)?;\n@@ -67,51 +67,98 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     /// Helper function to get a `libc` constant as a `Scalar`.\n-    fn eval_libc(&mut self, name: &str) -> InterpResult<'tcx, Scalar<Tag>> {\n-        self.eval_context_mut().eval_path_scalar(&[\"libc\", name])\n+    fn eval_libc(&self, name: &str) -> InterpResult<'tcx, Scalar<Tag>> {\n+        self.eval_path_scalar(&[\"libc\", name])\n     }\n \n     /// Helper function to get a `libc` constant as an `i32`.\n-    fn eval_libc_i32(&mut self, name: &str) -> InterpResult<'tcx, i32> {\n+    fn eval_libc_i32(&self, name: &str) -> InterpResult<'tcx, i32> {\n         // TODO: Cache the result.\n         self.eval_libc(name)?.to_i32()\n     }\n \n     /// Helper function to get a `windows` constant as a `Scalar`.\n-    fn eval_windows(&mut self, module: &str, name: &str) -> InterpResult<'tcx, Scalar<Tag>> {\n-        self.eval_context_mut().eval_path_scalar(&[\"std\", \"sys\", \"windows\", module, name])\n+    fn eval_windows(&self, module: &str, name: &str) -> InterpResult<'tcx, Scalar<Tag>> {\n+        self.eval_context_ref().eval_path_scalar(&[\"std\", \"sys\", \"windows\", module, name])\n     }\n \n     /// Helper function to get a `windows` constant as a `u64`.\n-    fn eval_windows_u64(&mut self, module: &str, name: &str) -> InterpResult<'tcx, u64> {\n+    fn eval_windows_u64(&self, module: &str, name: &str) -> InterpResult<'tcx, u64> {\n         // TODO: Cache the result.\n         self.eval_windows(module, name)?.to_u64()\n     }\n \n     /// Helper function to get the `TyAndLayout` of a `libc` type\n-    fn libc_ty_layout(&mut self, name: &str) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n-        let this = self.eval_context_mut();\n+    fn libc_ty_layout(&self, name: &str) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n+        let this = self.eval_context_ref();\n         let ty = this.resolve_path(&[\"libc\", name]).ty(*this.tcx, ty::ParamEnv::reveal_all());\n         this.layout_of(ty)\n     }\n \n     /// Helper function to get the `TyAndLayout` of a `windows` type\n-    fn windows_ty_layout(&mut self, name: &str) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n-        let this = self.eval_context_mut();\n+    fn windows_ty_layout(&self, name: &str) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n+        let this = self.eval_context_ref();\n         let ty = this\n             .resolve_path(&[\"std\", \"sys\", \"windows\", \"c\", name])\n             .ty(*this.tcx, ty::ParamEnv::reveal_all());\n         this.layout_of(ty)\n     }\n \n-    /// Write a uint of the appropriate size to `dest`.\n-    fn write_uint(&mut self, i: impl Into<u128>, dest: &PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n-        self.eval_context_mut().write_scalar(Scalar::from_uint(i, dest.layout.size), dest)\n+    /// Project to the given *named* field of the mplace (which must be a struct or union type).\n+    fn mplace_field_named(\n+        &self,\n+        mplace: &MPlaceTy<'tcx, Tag>,\n+        name: &str,\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, Tag>> {\n+        let this = self.eval_context_ref();\n+        let adt = mplace.layout.ty.ty_adt_def().unwrap();\n+        for (idx, field) in adt.non_enum_variant().fields.iter().enumerate() {\n+            if field.name.as_str() == name {\n+                return this.mplace_field(mplace, idx);\n+            }\n+        }\n+        bug!(\"No field named {} in type {}\", name, mplace.layout.ty);\n     }\n \n-    /// Write an int of the appropriate size to `dest`.\n+    /// Write an int of the appropriate size to `dest`. The target type may be signed or unsigned,\n+    /// we try to do the right thing anyway. `i128` can fit all integer types except for `u128` so\n+    /// this method is fine for almost all integer types.\n     fn write_int(&mut self, i: impl Into<i128>, dest: &PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n-        self.eval_context_mut().write_scalar(Scalar::from_int(i, dest.layout.size), dest)\n+        assert!(dest.layout.abi.is_scalar(), \"write_int on non-scalar type {}\", dest.layout.ty);\n+        let val = if dest.layout.abi.is_signed() {\n+            Scalar::from_int(i, dest.layout.size)\n+        } else {\n+            Scalar::from_uint(u64::try_from(i.into()).unwrap(), dest.layout.size)\n+        };\n+        self.eval_context_mut().write_scalar(val, dest)\n+    }\n+\n+    /// Write the first N fields of the given place.\n+    fn write_int_fields(\n+        &mut self,\n+        values: &[i128],\n+        dest: &MPlaceTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        for (idx, &val) in values.iter().enumerate() {\n+            let field = this.mplace_field(dest, idx)?;\n+            this.write_int(val, &field.into())?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// Write the given fields of the given place.\n+    fn write_int_fields_named(\n+        &mut self,\n+        values: &[(&str, i128)],\n+        dest: &MPlaceTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        for &(name, val) in values.iter() {\n+            let field = this.mplace_field_named(dest, name)?;\n+            this.write_int(val, &field.into())?;\n+        }\n+        Ok(())\n     }\n \n     /// Write a 0 of the appropriate size to `dest`.\n@@ -383,27 +430,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    // Writes several `ImmTy`s contiguously into memory. This is useful when you have to pack\n-    // different values into a struct.\n-    fn write_packed_immediates(\n-        &mut self,\n-        place: &MPlaceTy<'tcx, Tag>,\n-        imms: &[ImmTy<'tcx, Tag>],\n-    ) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n-\n-        let mut offset = Size::from_bytes(0);\n-\n-        for &imm in imms {\n-            this.write_immediate(\n-                *imm,\n-                &place.offset(offset, MemPlaceMeta::None, imm.layout, &*this.tcx)?.into(),\n-            )?;\n-            offset += imm.layout.size;\n-        }\n-        Ok(())\n-    }\n-\n     /// Helper function used inside the shims of foreign functions to check that isolation is\n     /// disabled. It returns an error using the `name` of the foreign function if this is not the\n     /// case.\n@@ -750,26 +776,6 @@ pub fn isolation_abort_error(name: &str) -> InterpResult<'static> {\n     )))\n }\n \n-pub fn immty_from_int_checked<'tcx>(\n-    int: impl Into<i128>,\n-    layout: TyAndLayout<'tcx>,\n-) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n-    let int = int.into();\n-    Ok(ImmTy::try_from_int(int, layout).ok_or_else(|| {\n-        err_unsup_format!(\"signed value {:#x} does not fit in {} bits\", int, layout.size.bits())\n-    })?)\n-}\n-\n-pub fn immty_from_uint_checked<'tcx>(\n-    int: impl Into<u128>,\n-    layout: TyAndLayout<'tcx>,\n-) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n-    let int = int.into();\n-    Ok(ImmTy::try_from_uint(int, layout).ok_or_else(|| {\n-        err_unsup_format!(\"unsigned value {:#x} does not fit in {} bits\", int, layout.size.bits())\n-    })?)\n-}\n-\n pub fn bool_to_simd_element(b: bool, size: Size) -> Scalar<Tag> {\n     // SIMD uses all-1 as pattern for \"true\"\n     let val = if b { -1 } else { 0 };"}, {"sha": "b71f53cce566e4a84c973f501c647aff41b2b80c", "filename": "src/shims/posix/fs.rs", "status": "modified", "additions": 97, "deletions": 97, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/47f8218d0dfcd9f31185f2628d07a993ba6780f5/src%2Fshims%2Fposix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f8218d0dfcd9f31185f2628d07a993ba6780f5/src%2Fshims%2Fposix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Ffs.rs?ref=47f8218d0dfcd9f31185f2628d07a993ba6780f5", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::{self, layout::LayoutOf};\n use rustc_target::abi::{Align, Size};\n \n use crate::*;\n-use helpers::{check_arg_count, immty_from_int_checked, immty_from_uint_checked};\n+use helpers::check_arg_count;\n use shims::os_str::os_str_to_bytes;\n use shims::time::system_time_to_duration;\n \n@@ -318,45 +318,32 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, '\n         let (created_sec, created_nsec) = metadata.created.unwrap_or((0, 0));\n         let (modified_sec, modified_nsec) = metadata.modified.unwrap_or((0, 0));\n \n-        let dev_t_layout = this.libc_ty_layout(\"dev_t\")?;\n-        let mode_t_layout = this.libc_ty_layout(\"mode_t\")?;\n-        let nlink_t_layout = this.libc_ty_layout(\"nlink_t\")?;\n-        let ino_t_layout = this.libc_ty_layout(\"ino_t\")?;\n-        let uid_t_layout = this.libc_ty_layout(\"uid_t\")?;\n-        let gid_t_layout = this.libc_ty_layout(\"gid_t\")?;\n-        let time_t_layout = this.libc_ty_layout(\"time_t\")?;\n-        let long_layout = this.libc_ty_layout(\"c_long\")?;\n-        let off_t_layout = this.libc_ty_layout(\"off_t\")?;\n-        let blkcnt_t_layout = this.libc_ty_layout(\"blkcnt_t\")?;\n-        let blksize_t_layout = this.libc_ty_layout(\"blksize_t\")?;\n-        let uint32_t_layout = this.libc_ty_layout(\"uint32_t\")?;\n-\n-        let imms = [\n-            immty_from_uint_checked(0u128, dev_t_layout)?, // st_dev\n-            immty_from_uint_checked(mode, mode_t_layout)?, // st_mode\n-            immty_from_uint_checked(0u128, nlink_t_layout)?, // st_nlink\n-            immty_from_uint_checked(0u128, ino_t_layout)?, // st_ino\n-            immty_from_uint_checked(0u128, uid_t_layout)?, // st_uid\n-            immty_from_uint_checked(0u128, gid_t_layout)?, // st_gid\n-            immty_from_uint_checked(0u128, dev_t_layout)?, // st_rdev\n-            immty_from_uint_checked(0u128, uint32_t_layout)?, // padding\n-            immty_from_uint_checked(access_sec, time_t_layout)?, // st_atime\n-            immty_from_uint_checked(access_nsec, long_layout)?, // st_atime_nsec\n-            immty_from_uint_checked(modified_sec, time_t_layout)?, // st_mtime\n-            immty_from_uint_checked(modified_nsec, long_layout)?, // st_mtime_nsec\n-            immty_from_uint_checked(0u128, time_t_layout)?, // st_ctime\n-            immty_from_uint_checked(0u128, long_layout)?,  // st_ctime_nsec\n-            immty_from_uint_checked(created_sec, time_t_layout)?, // st_birthtime\n-            immty_from_uint_checked(created_nsec, long_layout)?, // st_birthtime_nsec\n-            immty_from_uint_checked(metadata.size, off_t_layout)?, // st_size\n-            immty_from_uint_checked(0u128, blkcnt_t_layout)?, // st_blocks\n-            immty_from_uint_checked(0u128, blksize_t_layout)?, // st_blksize\n-            immty_from_uint_checked(0u128, uint32_t_layout)?, // st_flags\n-            immty_from_uint_checked(0u128, uint32_t_layout)?, // st_gen\n-        ];\n-\n         let buf = this.deref_operand(buf_op)?;\n-        this.write_packed_immediates(&buf, &imms)?;\n+        this.write_int_fields_named(\n+            &[\n+                (\"st_dev\", 0),\n+                (\"st_mode\", mode.into()),\n+                (\"st_nlink\", 0),\n+                (\"st_ino\", 0),\n+                (\"st_uid\", 0),\n+                (\"st_gid\", 0),\n+                (\"st_rdev\", 0),\n+                (\"st_atime\", access_sec.into()),\n+                (\"st_atime_nsec\", access_nsec.into()),\n+                (\"st_mtime\", modified_sec.into()),\n+                (\"st_mtime_nsec\", modified_nsec.into()),\n+                (\"st_ctime\", 0),\n+                (\"st_ctime_nsec\", 0),\n+                (\"st_birthtime\", created_sec.into()),\n+                (\"st_birthtime_nsec\", created_nsec.into()),\n+                (\"st_size\", metadata.size.into()),\n+                (\"st_blocks\", 0),\n+                (\"st_blksize\", 0),\n+                (\"st_flags\", 0),\n+                (\"st_gen\", 0),\n+            ],\n+            &buf,\n+        )?;\n \n         Ok(0)\n     }\n@@ -954,7 +941,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // `syscall` function is untyped. This means that all the `statx` parameters are provided\n         // as `isize`s instead of having the proper types. Thus, we have to recover the layout of\n         // `statxbuf_op` by using the `libc::statx` struct type.\n-        let statxbuf_place = {\n+        let statxbuf = {\n             // FIXME: This long path is required because `libc::statx` is an struct and also a\n             // function and `resolve_path` is returning the latter.\n             let statx_ty = this\n@@ -1064,44 +1051,55 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             })\n             .unwrap_or(Ok((0, 0)))?;\n \n-        let __u32_layout = this.libc_ty_layout(\"__u32\")?;\n-        let __u64_layout = this.libc_ty_layout(\"__u64\")?;\n-        let __u16_layout = this.libc_ty_layout(\"__u16\")?;\n-\n-        // Now we transform all this fields into `ImmTy`s and write them to `statxbuf`. We write a\n-        // zero for the unavailable fields.\n-        let imms = [\n-            immty_from_uint_checked(mask, __u32_layout)?, // stx_mask\n-            immty_from_uint_checked(0u128, __u32_layout)?, // stx_blksize\n-            immty_from_uint_checked(0u128, __u64_layout)?, // stx_attributes\n-            immty_from_uint_checked(0u128, __u32_layout)?, // stx_nlink\n-            immty_from_uint_checked(0u128, __u32_layout)?, // stx_uid\n-            immty_from_uint_checked(0u128, __u32_layout)?, // stx_gid\n-            immty_from_uint_checked(mode, __u16_layout)?, // stx_mode\n-            immty_from_uint_checked(0u128, __u16_layout)?, // statx padding\n-            immty_from_uint_checked(0u128, __u64_layout)?, // stx_ino\n-            immty_from_uint_checked(metadata.size, __u64_layout)?, // stx_size\n-            immty_from_uint_checked(0u128, __u64_layout)?, // stx_blocks\n-            immty_from_uint_checked(0u128, __u64_layout)?, // stx_attributes\n-            immty_from_uint_checked(access_sec, __u64_layout)?, // stx_atime.tv_sec\n-            immty_from_uint_checked(access_nsec, __u32_layout)?, // stx_atime.tv_nsec\n-            immty_from_uint_checked(0u128, __u32_layout)?, // statx_timestamp padding\n-            immty_from_uint_checked(created_sec, __u64_layout)?, // stx_btime.tv_sec\n-            immty_from_uint_checked(created_nsec, __u32_layout)?, // stx_btime.tv_nsec\n-            immty_from_uint_checked(0u128, __u32_layout)?, // statx_timestamp padding\n-            immty_from_uint_checked(0u128, __u64_layout)?, // stx_ctime.tv_sec\n-            immty_from_uint_checked(0u128, __u32_layout)?, // stx_ctime.tv_nsec\n-            immty_from_uint_checked(0u128, __u32_layout)?, // statx_timestamp padding\n-            immty_from_uint_checked(modified_sec, __u64_layout)?, // stx_mtime.tv_sec\n-            immty_from_uint_checked(modified_nsec, __u32_layout)?, // stx_mtime.tv_nsec\n-            immty_from_uint_checked(0u128, __u32_layout)?, // statx_timestamp padding\n-            immty_from_uint_checked(0u128, __u64_layout)?, // stx_rdev_major\n-            immty_from_uint_checked(0u128, __u64_layout)?, // stx_rdev_minor\n-            immty_from_uint_checked(0u128, __u64_layout)?, // stx_dev_major\n-            immty_from_uint_checked(0u128, __u64_layout)?, // stx_dev_minor\n-        ];\n-\n-        this.write_packed_immediates(&statxbuf_place, &imms)?;\n+        // Now we write everything to `statxbuf`. We write a zero for the unavailable fields.\n+        this.write_int_fields_named(\n+            &[\n+                (\"stx_mask\", mask.into()),\n+                (\"stx_blksize\", 0),\n+                (\"stx_attributes\", 0),\n+                (\"stx_nlink\", 0),\n+                (\"stx_uid\", 0),\n+                (\"stx_gid\", 0),\n+                (\"stx_mode\", mode.into()),\n+                (\"stx_ino\", 0),\n+                (\"stx_size\", metadata.size.into()),\n+                (\"stx_blocks\", 0),\n+                (\"stx_attributes_mask\", 0),\n+                (\"stx_rdev_major\", 0),\n+                (\"stx_rdev_minor\", 0),\n+                (\"stx_dev_major\", 0),\n+                (\"stx_dev_minor\", 0),\n+            ],\n+            &statxbuf,\n+        )?;\n+        this.write_int_fields(\n+            &[\n+                access_sec.into(),  // stx_atime.tv_sec\n+                access_nsec.into(), // stx_atime.tv_nsec\n+            ],\n+            &this.mplace_field_named(&statxbuf, \"stx_atime\")?,\n+        )?;\n+        this.write_int_fields(\n+            &[\n+                created_sec.into(),  // stx_btime.tv_sec\n+                created_nsec.into(), // stx_btime.tv_nsec\n+            ],\n+            &this.mplace_field_named(&statxbuf, \"stx_btime\")?,\n+        )?;\n+        this.write_int_fields(\n+            &[\n+                0.into(), // stx_ctime.tv_sec\n+                0.into(), // stx_ctime.tv_nsec\n+            ],\n+            &this.mplace_field_named(&statxbuf, \"stx_ctime\")?,\n+        )?;\n+        this.write_int_fields(\n+            &[\n+                modified_sec.into(),  // stx_mtime.tv_sec\n+                modified_nsec.into(), // stx_mtime.tv_nsec\n+            ],\n+            &this.mplace_field_named(&statxbuf, \"stx_mtime\")?,\n+        )?;\n \n         Ok(0)\n     }\n@@ -1247,7 +1245,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             Some(Ok(dir_entry)) => {\n                 // Write the directory entry into a newly allocated buffer.\n                 // The name is written with write_bytes, while the rest of the\n-                // dirent64 struct is written using write_packed_immediates.\n+                // dirent64 struct is written using write_int_fields.\n \n                 // For reference:\n                 // pub struct dirent64 {\n@@ -1279,11 +1277,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n                 let file_type = this.file_type_to_d_type(dir_entry.file_type())?;\n \n-                let entry_place = MPlaceTy::from_aligned_ptr(entry, dirent64_layout);\n-                this.write_uint(ino, &this.mplace_field(&entry_place, 0)?.into())?; // d_ino\n-                this.write_uint(0u128, &this.mplace_field(&entry_place, 1)?.into())?; // d_off\n-                this.write_uint(size, &this.mplace_field(&entry_place, 2)?.into())?; // d_reclen\n-                this.write_int(file_type, &this.mplace_field(&entry_place, 3)?.into())?; // d_type\n+                this.write_int_fields(\n+                    &[\n+                        ino.into(),       // d_ino\n+                        0,                // d_off\n+                        size.into(),      // d_reclen\n+                        file_type.into(), // d_type\n+                    ],\n+                    &MPlaceTy::from_aligned_ptr(entry, dirent64_layout),\n+                )?;\n \n                 let name_ptr = entry.offset(Size::from_bytes(d_name_offset), this)?;\n                 this.memory.write_bytes(name_ptr, name_bytes.iter().copied())?;\n@@ -1333,7 +1335,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             Some(Ok(dir_entry)) => {\n                 // Write into entry, write pointer to result, return 0 on success.\n                 // The name is written with write_os_str_to_c_str, while the rest of the\n-                // dirent struct is written using write_packed_Immediates.\n+                // dirent struct is written using write_int_fields.\n \n                 // For reference:\n                 // pub struct dirent {\n@@ -1361,10 +1363,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n \n                 let entry_place = this.deref_operand(entry_op)?;\n-                let ino_t_layout = this.libc_ty_layout(\"ino_t\")?;\n-                let off_t_layout = this.libc_ty_layout(\"off_t\")?;\n-                let c_ushort_layout = this.libc_ty_layout(\"c_ushort\")?;\n-                let c_uchar_layout = this.libc_ty_layout(\"c_uchar\")?;\n \n                 // If the host is a Unix system, fill in the inode number with its real value.\n                 // If not, use 0 as a fallback value.\n@@ -1375,14 +1373,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n                 let file_type = this.file_type_to_d_type(dir_entry.file_type())?;\n \n-                let imms = [\n-                    immty_from_uint_checked(ino, ino_t_layout)?,      // d_ino\n-                    immty_from_uint_checked(0u128, off_t_layout)?,    // d_seekoff\n-                    immty_from_uint_checked(0u128, c_ushort_layout)?, // d_reclen\n-                    immty_from_uint_checked(file_name_len, c_ushort_layout)?, // d_namlen\n-                    immty_from_int_checked(file_type, c_uchar_layout)?, // d_type\n-                ];\n-                this.write_packed_immediates(&entry_place, &imms)?;\n+                this.write_int_fields(\n+                    &[\n+                        ino.into(),           // d_ino\n+                        0,                    // d_seekoff\n+                        0,                    // d_reclen\n+                        file_name_len.into(), // d_namlen\n+                        file_type.into(),     // d_type\n+                    ],\n+                    &entry_place,\n+                )?;\n \n                 let result_place = this.deref_operand(result_op)?;\n                 this.write_scalar(this.read_scalar(entry_op)?, &result_place.into())?;"}, {"sha": "0acd697fa4050fbb2c627240788eafafa1058bf4", "filename": "src/shims/time.rs", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/47f8218d0dfcd9f31185f2628d07a993ba6780f5/src%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f8218d0dfcd9f31185f2628d07a993ba6780f5/src%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftime.rs?ref=47f8218d0dfcd9f31185f2628d07a993ba6780f5", "patch": "@@ -2,7 +2,6 @@ use std::convert::TryFrom;\n use std::time::{Duration, Instant, SystemTime};\n \n use crate::*;\n-use helpers::{immty_from_int_checked, immty_from_uint_checked};\n use thread::Time;\n \n /// Returns the time elapsed between the provided time and the unix epoch as a `Duration`.\n@@ -24,7 +23,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.check_no_isolation(\"`clock_gettime`\")?;\n \n         let clk_id = this.read_scalar(clk_id_op)?.to_i32()?;\n-        let tp = this.deref_operand(tp_op)?;\n \n         let duration = if clk_id == this.eval_libc_i32(\"CLOCK_REALTIME\")? {\n             system_time_to_duration(&SystemTime::now())?\n@@ -41,12 +39,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let tv_sec = duration.as_secs();\n         let tv_nsec = duration.subsec_nanos();\n \n-        let imms = [\n-            immty_from_int_checked(tv_sec, this.libc_ty_layout(\"time_t\")?)?,\n-            immty_from_int_checked(tv_nsec, this.libc_ty_layout(\"c_long\")?)?,\n-        ];\n-\n-        this.write_packed_immediates(&tp, &imms)?;\n+        this.write_int_fields(&[tv_sec.into(), tv_nsec.into()], &this.deref_operand(tp_op)?)?;\n \n         Ok(0)\n     }\n@@ -69,18 +62,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return Ok(-1);\n         }\n \n-        let tv = this.deref_operand(tv_op)?;\n-\n         let duration = system_time_to_duration(&SystemTime::now())?;\n         let tv_sec = duration.as_secs();\n         let tv_usec = duration.subsec_micros();\n \n-        let imms = [\n-            immty_from_int_checked(tv_sec, this.libc_ty_layout(\"time_t\")?)?,\n-            immty_from_int_checked(tv_usec, this.libc_ty_layout(\"suseconds_t\")?)?,\n-        ];\n-\n-        this.write_packed_immediates(&tv, &imms)?;\n+        this.write_int_fields(&[tv_sec.into(), tv_usec.into()], &this.deref_operand(tv_op)?)?;\n \n         Ok(0)\n     }\n@@ -105,12 +91,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let dwLowDateTime = u32::try_from(duration_ticks & 0x00000000FFFFFFFF).unwrap();\n         let dwHighDateTime = u32::try_from((duration_ticks & 0xFFFFFFFF00000000) >> 32).unwrap();\n-        let DWORD_tylayout = this.machine.layouts.u32;\n-        let imms = [\n-            immty_from_uint_checked(dwLowDateTime, DWORD_tylayout)?,\n-            immty_from_uint_checked(dwHighDateTime, DWORD_tylayout)?,\n-        ];\n-        this.write_packed_immediates(&this.deref_operand(LPFILETIME_op)?, &imms)?;\n+        this.write_int_fields(\n+            &[dwLowDateTime.into(), dwHighDateTime.into()],\n+            &this.deref_operand(LPFILETIME_op)?,\n+        )?;\n+\n         Ok(())\n     }\n \n@@ -185,12 +170,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Since our emulated ticks in `mach_absolute_time` *are* nanoseconds,\n         // no scaling needs to happen.\n         let (numer, denom) = (1, 1);\n-        let imms = [\n-            immty_from_int_checked(numer, this.machine.layouts.u32)?,\n-            immty_from_int_checked(denom, this.machine.layouts.u32)?,\n-        ];\n+        this.write_int_fields(&[numer.into(), denom.into()], &info)?;\n \n-        this.write_packed_immediates(&info, &imms)?;\n         Ok(0) // KERN_SUCCESS\n     }\n "}]}