{"sha": "91a9f83dd1d73cfd451f81306361df3fafad84a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYTlmODNkZDFkNzNjZmQ0NTFmODEzMDYzNjFkZjNmYWZhZDg0YTU=", "commit": {"author": {"name": "Dan Gohman", "email": "dev@sunfishcode.online", "date": "2020-10-16T16:09:20Z"}, "committer": {"name": "Dan Gohman", "email": "dev@sunfishcode.online", "date": "2020-10-16T19:05:49Z"}, "message": "Define `fs::hard_link` to not follow symlinks.\n\nPOSIX leaves it implementation-defined whether `link` follows symlinks.\nIn practice, for example, on Linux it does not and on FreeBSD it does.\nSo, switch to `linkat`, so that we can pick a behavior rather than\ndepending on OS defaults.\n\nPick the option to not follow symlinks. This is somewhat arbitrary, but\nseems the less surprising choice because hard linking is a very\nlow-level feature which requires the source and destination to be on\nthe same mounted filesystem, and following a symbolic link could end\nup in a different mounted filesystem.", "tree": {"sha": "b3eff22b5672b6fbd8099552216dbc58c65ee78f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3eff22b5672b6fbd8099552216dbc58c65ee78f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91a9f83dd1d73cfd451f81306361df3fafad84a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91a9f83dd1d73cfd451f81306361df3fafad84a5", "html_url": "https://github.com/rust-lang/rust/commit/91a9f83dd1d73cfd451f81306361df3fafad84a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91a9f83dd1d73cfd451f81306361df3fafad84a5/comments", "author": {"login": "sunfishcode", "id": 4503403, "node_id": "MDQ6VXNlcjQ1MDM0MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/4503403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunfishcode", "html_url": "https://github.com/sunfishcode", "followers_url": "https://api.github.com/users/sunfishcode/followers", "following_url": "https://api.github.com/users/sunfishcode/following{/other_user}", "gists_url": "https://api.github.com/users/sunfishcode/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunfishcode/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunfishcode/subscriptions", "organizations_url": "https://api.github.com/users/sunfishcode/orgs", "repos_url": "https://api.github.com/users/sunfishcode/repos", "events_url": "https://api.github.com/users/sunfishcode/events{/privacy}", "received_events_url": "https://api.github.com/users/sunfishcode/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sunfishcode", "id": 4503403, "node_id": "MDQ6VXNlcjQ1MDM0MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/4503403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunfishcode", "html_url": "https://github.com/sunfishcode", "followers_url": "https://api.github.com/users/sunfishcode/followers", "following_url": "https://api.github.com/users/sunfishcode/following{/other_user}", "gists_url": "https://api.github.com/users/sunfishcode/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunfishcode/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunfishcode/subscriptions", "organizations_url": "https://api.github.com/users/sunfishcode/orgs", "repos_url": "https://api.github.com/users/sunfishcode/repos", "events_url": "https://api.github.com/users/sunfishcode/events{/privacy}", "received_events_url": "https://api.github.com/users/sunfishcode/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a78a62fc996ba16f7a111c99520b23f77029f4eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a78a62fc996ba16f7a111c99520b23f77029f4eb", "html_url": "https://github.com/rust-lang/rust/commit/a78a62fc996ba16f7a111c99520b23f77029f4eb"}], "stats": {"total": 63, "additions": 60, "deletions": 3}, "files": [{"sha": "c611bf4d74a49d312635206556115e9481bd196d", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/91a9f83dd1d73cfd451f81306361df3fafad84a5/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a9f83dd1d73cfd451f81306361df3fafad84a5/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=91a9f83dd1d73cfd451f81306361df3fafad84a5", "patch": "@@ -1701,10 +1701,13 @@ pub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<u64> {\n /// The `dst` path will be a link pointing to the `src` path. Note that systems\n /// often require these two paths to both be located on the same filesystem.\n ///\n+/// If `src` names a symbolic link, it is not followed. The created hard link\n+/// points to the symbolic link itself.\n+///\n /// # Platform-specific behavior\n ///\n-/// This function currently corresponds to the `link` function on Unix\n-/// and the `CreateHardLink` function on Windows.\n+/// This function currently corresponds to the `linkat` function with no flags\n+/// on Unix and the `CreateHardLink` function on Windows.\n /// Note that, this [may change in the future][changes].\n ///\n /// [changes]: io#platform-specific-behavior"}, {"sha": "8a723d3b4ae22c1fa55c66678d4f4bc8035bd565", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/91a9f83dd1d73cfd451f81306361df3fafad84a5/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a9f83dd1d73cfd451f81306361df3fafad84a5/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=91a9f83dd1d73cfd451f81306361df3fafad84a5", "patch": "@@ -1337,3 +1337,54 @@ fn metadata_access_times() {\n         }\n     }\n }\n+\n+/// Test creating hard links to symlinks.\n+#[test]\n+fn symlink_hard_link() {\n+    let tmpdir = tmpdir();\n+\n+    // Create \"file\", a file.\n+    check!(fs::File::create(tmpdir.join(\"file\")));\n+\n+    // Create \"symlink\", a symlink to \"file\".\n+    check!(symlink_file(\"file\", tmpdir.join(\"symlink\")));\n+\n+    // Create \"hard_link\", a hard link to \"symlink\".\n+    check!(fs::hard_link(tmpdir.join(\"symlink\"), tmpdir.join(\"hard_link\")));\n+\n+    // \"hard_link\" should appear as a symlink.\n+    assert!(check!(fs::symlink_metadata(tmpdir.join(\"hard_link\"))).file_type().is_symlink());\n+\n+    // We sould be able to open \"file\" via any of the above names.\n+    let _ = check!(fs::File::open(tmpdir.join(\"file\")));\n+    assert!(fs::File::open(tmpdir.join(\"file.renamed\")).is_err());\n+    let _ = check!(fs::File::open(tmpdir.join(\"symlink\")));\n+    let _ = check!(fs::File::open(tmpdir.join(\"hard_link\")));\n+\n+    // Rename \"file\" to \"file.renamed\".\n+    check!(fs::rename(tmpdir.join(\"file\"), tmpdir.join(\"file.renamed\")));\n+\n+    // Now, the symlink and the hard link should be dangling.\n+    assert!(fs::File::open(tmpdir.join(\"file\")).is_err());\n+    let _ = check!(fs::File::open(tmpdir.join(\"file.renamed\")));\n+    assert!(fs::File::open(tmpdir.join(\"symlink\")).is_err());\n+    assert!(fs::File::open(tmpdir.join(\"hard_link\")).is_err());\n+\n+    // The symlink and the hard link should both still point to \"file\".\n+    assert!(fs::read_link(tmpdir.join(\"file\")).is_err());\n+    assert!(fs::read_link(tmpdir.join(\"file.renamed\")).is_err());\n+    assert_eq!(check!(fs::read_link(tmpdir.join(\"symlink\"))), Path::new(\"file\"));\n+    assert_eq!(check!(fs::read_link(tmpdir.join(\"hard_link\"))), Path::new(\"file\"));\n+\n+    // Remove \"file.renamed\".\n+    check!(fs::remove_file(tmpdir.join(\"file.renamed\")));\n+\n+    // Now, we can't open the file by any name.\n+    assert!(fs::File::open(tmpdir.join(\"file\")).is_err());\n+    assert!(fs::File::open(tmpdir.join(\"file.renamed\")).is_err());\n+    assert!(fs::File::open(tmpdir.join(\"symlink\")).is_err());\n+    assert!(fs::File::open(tmpdir.join(\"hard_link\")).is_err());\n+\n+    // \"hard_link\" should still appear as a symlink.\n+    assert!(check!(fs::symlink_metadata(tmpdir.join(\"hard_link\"))).file_type().is_symlink());\n+}"}, {"sha": "88693e4786c0f4030ef6c83e4e83bf9cd2478af1", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/91a9f83dd1d73cfd451f81306361df3fafad84a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a9f83dd1d73cfd451f81306361df3fafad84a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=91a9f83dd1d73cfd451f81306361df3fafad84a5", "patch": "@@ -1067,7 +1067,10 @@ pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n     let src = cstr(src)?;\n     let dst = cstr(dst)?;\n-    cvt(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) })?;\n+    // Use `linkat` with `AT_FDCWD` instead of `link` as `link` leaves it\n+    // implmentation-defined whether it follows symlinks. Pass 0 as the\n+    // `linkat` flags argument so that we don't follow symlinks.\n+    cvt(unsafe { libc::linkat(libc::AT_FDCWD, src.as_ptr(), libc::AT_FDCWD, dst.as_ptr(), 0) })?;\n     Ok(())\n }\n "}]}