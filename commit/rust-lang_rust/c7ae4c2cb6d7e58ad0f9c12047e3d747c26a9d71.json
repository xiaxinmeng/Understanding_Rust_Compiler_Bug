{"sha": "c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3YWU0YzJjYjZkN2U1OGFkMGY5YzEyMDQ3ZTNkNzQ3YzI2YTlkNzE=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-10-23T07:45:07Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-11-06T02:24:12Z"}, "message": "Splitting transform/instrument_coverage.rs into transform/coverage/...", "tree": {"sha": "fdbb5014c0353a7a29a61b07364575b04d81362a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdbb5014c0353a7a29a61b07364575b04d81362a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71", "html_url": "https://github.com/rust-lang/rust/commit/c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7747cc772f4b4c30ede3616678d7a3bc2c89bf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7747cc772f4b4c30ede3616678d7a3bc2c89bf7", "html_url": "https://github.com/rust-lang/rust/commit/c7747cc772f4b4c30ede3616678d7a3bc2c89bf7"}], "stats": {"total": 1496, "additions": 766, "deletions": 730}, "files": [{"sha": "511ad937c248f70f212dcd2cb3d12832e6f32607", "filename": "compiler/rustc_mir/src/transform/coverage/counters.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fcounters.rs?ref=c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71", "patch": "@@ -0,0 +1,54 @@\n+use rustc_middle::mir::coverage::*;\n+\n+/// Manages the counter and expression indexes/IDs to generate `CoverageKind` components for MIR\n+/// `Coverage` statements.\n+pub(crate) struct CoverageCounters {\n+    function_source_hash: u64,\n+    next_counter_id: u32,\n+    num_expressions: u32,\n+}\n+\n+impl CoverageCounters {\n+    pub fn new(function_source_hash: u64) -> Self {\n+        Self {\n+            function_source_hash,\n+            next_counter_id: CounterValueReference::START.as_u32(),\n+            num_expressions: 0,\n+        }\n+    }\n+\n+    pub fn make_counter(&mut self) -> CoverageKind {\n+        CoverageKind::Counter {\n+            function_source_hash: self.function_source_hash,\n+            id: self.next_counter(),\n+        }\n+    }\n+\n+    pub fn make_expression(\n+        &mut self,\n+        lhs: ExpressionOperandId,\n+        op: Op,\n+        rhs: ExpressionOperandId,\n+    ) -> CoverageKind {\n+        let id = self.next_expression();\n+        CoverageKind::Expression { id, lhs, op, rhs }\n+    }\n+\n+    /// Counter IDs start from one and go up.\n+    fn next_counter(&mut self) -> CounterValueReference {\n+        assert!(self.next_counter_id < u32::MAX - self.num_expressions);\n+        let next = self.next_counter_id;\n+        self.next_counter_id += 1;\n+        CounterValueReference::from(next)\n+    }\n+\n+    /// Expression IDs start from u32::MAX and go down because a Expression can reference\n+    /// (add or subtract counts) of both Counter regions and Expression regions. The counter\n+    /// expression operand IDs must be unique across both types.\n+    fn next_expression(&mut self) -> InjectedExpressionId {\n+        assert!(self.next_counter_id < u32::MAX - self.num_expressions);\n+        let next = u32::MAX - self.num_expressions;\n+        self.num_expressions += 1;\n+        InjectedExpressionId::from(next)\n+    }\n+}"}, {"sha": "0cd2e413da94428d3e90135388cfb158fe14c1a8", "filename": "compiler/rustc_mir/src/transform/coverage/debug.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs?ref=c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71", "patch": "@@ -0,0 +1,70 @@\n+use super::graph::BasicCoverageBlocks;\n+use super::spans::CoverageSpan;\n+\n+use crate::util::pretty;\n+use crate::util::spanview::{self, SpanViewable};\n+\n+use rustc_middle::mir::{self, TerminatorKind};\n+use rustc_middle::ty::TyCtxt;\n+\n+/// Generates the MIR pass `CoverageSpan`-specific spanview dump file.\n+pub(crate) fn dump_coverage_spanview(\n+    tcx: TyCtxt<'tcx>,\n+    mir_body: &mir::Body<'tcx>,\n+    basic_coverage_blocks: &BasicCoverageBlocks,\n+    pass_name: &str,\n+    coverage_spans: &Vec<CoverageSpan>,\n+) {\n+    let mir_source = mir_body.source;\n+    let def_id = mir_source.def_id();\n+\n+    let span_viewables = span_viewables(tcx, mir_body, basic_coverage_blocks, &coverage_spans);\n+    let mut file = pretty::create_dump_file(tcx, \"html\", None, pass_name, &0, mir_source)\n+        .expect(\"Unexpected error creating MIR spanview HTML file\");\n+    let crate_name = tcx.crate_name(def_id.krate);\n+    let item_name = tcx.def_path(def_id).to_filename_friendly_no_crate();\n+    let title = format!(\"{}.{} - Coverage Spans\", crate_name, item_name);\n+    spanview::write_document(tcx, def_id, span_viewables, &title, &mut file)\n+        .expect(\"Unexpected IO error dumping coverage spans as HTML\");\n+}\n+\n+/// Converts the computed `BasicCoverageBlock`s into `SpanViewable`s.\n+fn span_viewables(\n+    tcx: TyCtxt<'tcx>,\n+    mir_body: &mir::Body<'tcx>,\n+    basic_coverage_blocks: &BasicCoverageBlocks,\n+    coverage_spans: &Vec<CoverageSpan>,\n+) -> Vec<SpanViewable> {\n+    let mut span_viewables = Vec::new();\n+    for coverage_span in coverage_spans {\n+        let tooltip = coverage_span.format_coverage_statements(tcx, mir_body);\n+        let CoverageSpan { span, bcb_leader_bb: bb, .. } = coverage_span;\n+        let bcb = &basic_coverage_blocks[*bb];\n+        let id = bcb.id();\n+        let leader_bb = bcb.leader_bb();\n+        span_viewables.push(SpanViewable { bb: leader_bb, span: *span, id, tooltip });\n+    }\n+    span_viewables\n+}\n+\n+/// Returns a simple string representation of a `TerminatorKind` variant, indenpendent of any\n+/// values it might hold.\n+pub(crate) fn term_type(kind: &TerminatorKind<'tcx>) -> &'static str {\n+    match kind {\n+        TerminatorKind::Goto { .. } => \"Goto\",\n+        TerminatorKind::SwitchInt { .. } => \"SwitchInt\",\n+        TerminatorKind::Resume => \"Resume\",\n+        TerminatorKind::Abort => \"Abort\",\n+        TerminatorKind::Return => \"Return\",\n+        TerminatorKind::Unreachable => \"Unreachable\",\n+        TerminatorKind::Drop { .. } => \"Drop\",\n+        TerminatorKind::DropAndReplace { .. } => \"DropAndReplace\",\n+        TerminatorKind::Call { .. } => \"Call\",\n+        TerminatorKind::Assert { .. } => \"Assert\",\n+        TerminatorKind::Yield { .. } => \"Yield\",\n+        TerminatorKind::GeneratorDrop => \"GeneratorDrop\",\n+        TerminatorKind::FalseEdge { .. } => \"FalseEdge\",\n+        TerminatorKind::FalseUnwind { .. } => \"FalseUnwind\",\n+        TerminatorKind::InlineAsm { .. } => \"InlineAsm\",\n+    }\n+}"}, {"sha": "c0a698833a1fe7bfe37166aed1e1dd0514f8123c", "filename": "compiler/rustc_mir/src/transform/coverage/graph.rs", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fgraph.rs?ref=c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71", "patch": "@@ -0,0 +1,274 @@\n+use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::mir::{self, BasicBlock, BasicBlockData, TerminatorKind};\n+\n+const ID_SEPARATOR: &str = \",\";\n+\n+/// A BasicCoverageBlock (BCB) represents the maximal-length sequence of CFG (MIR) BasicBlocks\n+/// without conditional branches.\n+///\n+/// The BCB allows coverage analysis to be performed on a simplified projection of the underlying\n+/// MIR CFG, without altering the original CFG. Note that running the MIR `SimplifyCfg` transform,\n+/// is not sufficient, and therefore not necessary, since the BCB-based CFG projection is a more\n+/// aggressive simplification. For example:\n+///\n+///   * The BCB CFG projection ignores (trims) branches not relevant to coverage, such as unwind-\n+///     related code that is injected by the Rust compiler but has no physical source code to\n+///     count. This also means a BasicBlock with a `Call` terminator can be merged into its\n+///     primary successor target block, in the same BCB.\n+///   * Some BasicBlock terminators support Rust-specific concerns--like borrow-checking--that are\n+///     not relevant to coverage analysis. `FalseUnwind`, for example, can be treated the same as\n+///     a `Goto`, and merged with its successor into the same BCB.\n+///\n+/// Each BCB with at least one computed `CoverageSpan` will have no more than one `Counter`.\n+/// In some cases, a BCB's execution count can be computed by `CounterExpression`. Additional\n+/// disjoint `CoverageSpan`s in a BCB can also be counted by `CounterExpression` (by adding `ZERO`\n+/// to the BCB's primary counter or expression).\n+///\n+/// Dominator/dominated relationships (which are fundamental to the coverage analysis algorithm)\n+/// between two BCBs can be computed using the `mir::Body` `dominators()` with any `BasicBlock`\n+/// member of each BCB. (For consistency, BCB's use the first `BasicBlock`, also referred to as the\n+/// `bcb_leader_bb`.)\n+///\n+/// The BCB CFG projection is critical to simplifying the coverage analysis by ensuring graph\n+/// path-based queries (`is_dominated_by()`, `predecessors`, `successors`, etc.) have branch\n+/// (control flow) significance.\n+#[derive(Debug, Clone)]\n+pub(crate) struct BasicCoverageBlock {\n+    pub blocks: Vec<BasicBlock>,\n+}\n+\n+impl BasicCoverageBlock {\n+    pub fn leader_bb(&self) -> BasicBlock {\n+        self.blocks[0]\n+    }\n+\n+    pub fn id(&self) -> String {\n+        format!(\n+            \"@{}\",\n+            self.blocks\n+                .iter()\n+                .map(|bb| bb.index().to_string())\n+                .collect::<Vec<_>>()\n+                .join(ID_SEPARATOR)\n+        )\n+    }\n+}\n+\n+pub(crate) struct BasicCoverageBlocks {\n+    vec: IndexVec<BasicBlock, Option<BasicCoverageBlock>>,\n+}\n+\n+impl BasicCoverageBlocks {\n+    pub fn from_mir(mir_body: &mir::Body<'tcx>) -> Self {\n+        let mut basic_coverage_blocks =\n+            BasicCoverageBlocks { vec: IndexVec::from_elem_n(None, mir_body.basic_blocks().len()) };\n+        basic_coverage_blocks.extract_from_mir(mir_body);\n+        basic_coverage_blocks\n+    }\n+\n+    pub fn iter(&self) -> impl Iterator<Item = &BasicCoverageBlock> {\n+        self.vec.iter().filter_map(|bcb| bcb.as_ref())\n+    }\n+\n+    pub fn num_nodes(&self) -> usize {\n+        self.vec.len()\n+    }\n+\n+    pub fn extract_from_mir(&mut self, mir_body: &mir::Body<'tcx>) {\n+        // Traverse the CFG but ignore anything following an `unwind`\n+        let cfg_without_unwind = ShortCircuitPreorder::new(&mir_body, |term_kind| {\n+            let mut successors = term_kind.successors();\n+            match &term_kind {\n+                // SwitchInt successors are never unwind, and all of them should be traversed.\n+\n+                // NOTE: TerminatorKind::FalseEdge targets from SwitchInt don't appear to be\n+                // helpful in identifying unreachable code. I did test the theory, but the following\n+                // changes were not beneficial. (I assumed that replacing some constants with\n+                // non-deterministic variables might effect which blocks were targeted by a\n+                // `FalseEdge` `imaginary_target`. It did not.)\n+                //\n+                // Also note that, if there is a way to identify BasicBlocks that are part of the\n+                // MIR CFG, but not actually reachable, here are some other things to consider:\n+                //\n+                // Injecting unreachable code regions will probably require computing the set\n+                // difference between the basic blocks found without filtering out unreachable\n+                // blocks, and the basic blocks found with the filter; then computing the\n+                // `CoverageSpans` without the filter; and then injecting `Counter`s or\n+                // `CounterExpression`s for blocks that are not unreachable, or injecting\n+                // `Unreachable` code regions otherwise. This seems straightforward, but not\n+                // trivial.\n+                //\n+                // Alternatively, we might instead want to leave the unreachable blocks in\n+                // (bypass the filter here), and inject the counters. This will result in counter\n+                // values of zero (0) for unreachable code (and, notably, the code will be displayed\n+                // with a red background by `llvm-cov show`).\n+                //\n+                // TerminatorKind::SwitchInt { .. } => {\n+                //     let some_imaginary_target = successors.clone().find_map(|&successor| {\n+                //         let term = mir_body.basic_blocks()[successor].terminator();\n+                //         if let TerminatorKind::FalseEdge { imaginary_target, .. } = term.kind {\n+                //             if mir_body.predecessors()[imaginary_target].len() == 1 {\n+                //                 return Some(imaginary_target);\n+                //             }\n+                //         }\n+                //         None\n+                //     });\n+                //     if let Some(imaginary_target) = some_imaginary_target {\n+                //         box successors.filter(move |&&successor| successor != imaginary_target)\n+                //     } else {\n+                //         box successors\n+                //     }\n+                // }\n+                //\n+                // Note this also required changing the closure signature for the\n+                // `ShortCurcuitPreorder` to:\n+                //\n+                // F: Fn(&'tcx TerminatorKind<'tcx>) -> Box<dyn Iterator<Item = &BasicBlock> + 'a>,\n+                TerminatorKind::SwitchInt { .. } => successors,\n+\n+                // For all other kinds, return only the first successor, if any, and ignore unwinds\n+                _ => successors.next().into_iter().chain(&[]),\n+            }\n+        });\n+\n+        // Walk the CFG using a Preorder traversal, which starts from `START_BLOCK` and follows\n+        // each block terminator's `successors()`. Coverage spans must map to actual source code,\n+        // so compiler generated blocks and paths can be ignored. To that end the CFG traversal\n+        // intentionally omits unwind paths.\n+        let mut blocks = Vec::new();\n+        for (bb, data) in cfg_without_unwind {\n+            if let Some(last) = blocks.last() {\n+                let predecessors = &mir_body.predecessors()[bb];\n+                if predecessors.len() > 1 || !predecessors.contains(last) {\n+                    // The `bb` has more than one _incoming_ edge, and should start its own\n+                    // `BasicCoverageBlock`. (Note, the `blocks` vector does not yet include `bb`;\n+                    // it contains a sequence of one or more sequential blocks with no intermediate\n+                    // branches in or out. Save these as a new `BasicCoverageBlock` before starting\n+                    // the new one.)\n+                    self.add_basic_coverage_block(blocks.split_off(0));\n+                    debug!(\n+                        \"  because {}\",\n+                        if predecessors.len() > 1 {\n+                            \"predecessors.len() > 1\".to_owned()\n+                        } else {\n+                            format!(\"bb {} is not in precessors: {:?}\", bb.index(), predecessors)\n+                        }\n+                    );\n+                }\n+            }\n+            blocks.push(bb);\n+\n+            let term = data.terminator();\n+\n+            match term.kind {\n+                TerminatorKind::Return { .. }\n+                | TerminatorKind::Abort\n+                | TerminatorKind::Assert { .. }\n+                | TerminatorKind::Yield { .. }\n+                | TerminatorKind::SwitchInt { .. } => {\n+                    // The `bb` has more than one _outgoing_ edge, or exits the function. Save the\n+                    // current sequence of `blocks` gathered to this point, as a new\n+                    // `BasicCoverageBlock`.\n+                    self.add_basic_coverage_block(blocks.split_off(0));\n+                    debug!(\"  because term.kind = {:?}\", term.kind);\n+                    // Note that this condition is based on `TerminatorKind`, even though it\n+                    // theoretically boils down to `successors().len() != 1`; that is, either zero\n+                    // (e.g., `Return`, `Abort`) or multiple successors (e.g., `SwitchInt`), but\n+                    // since the Coverage graph (the BCB CFG projection) ignores things like unwind\n+                    // branches (which exist in the `Terminator`s `successors()` list) checking the\n+                    // number of successors won't work.\n+                }\n+                TerminatorKind::Goto { .. }\n+                | TerminatorKind::Resume\n+                | TerminatorKind::Unreachable\n+                | TerminatorKind::Drop { .. }\n+                | TerminatorKind::DropAndReplace { .. }\n+                | TerminatorKind::Call { .. }\n+                | TerminatorKind::GeneratorDrop\n+                | TerminatorKind::FalseEdge { .. }\n+                | TerminatorKind::FalseUnwind { .. }\n+                | TerminatorKind::InlineAsm { .. } => {}\n+            }\n+        }\n+\n+        if !blocks.is_empty() {\n+            // process any remaining blocks into a final `BasicCoverageBlock`\n+            self.add_basic_coverage_block(blocks.split_off(0));\n+            debug!(\"  because the end of the CFG was reached while traversing\");\n+        }\n+    }\n+\n+    fn add_basic_coverage_block(&mut self, blocks: Vec<BasicBlock>) {\n+        let leader_bb = blocks[0];\n+        let bcb = BasicCoverageBlock { blocks };\n+        debug!(\"adding BCB: {:?}\", bcb);\n+        self.vec[leader_bb] = Some(bcb);\n+    }\n+}\n+\n+impl std::ops::Index<BasicBlock> for BasicCoverageBlocks {\n+    type Output = BasicCoverageBlock;\n+\n+    fn index(&self, index: BasicBlock) -> &Self::Output {\n+        self.vec[index].as_ref().expect(\"is_some if BasicBlock is a BasicCoverageBlock leader\")\n+    }\n+}\n+\n+pub struct ShortCircuitPreorder<\n+    'a,\n+    'tcx,\n+    F: Fn(&'tcx TerminatorKind<'tcx>) -> mir::Successors<'tcx>,\n+> {\n+    body: &'a mir::Body<'tcx>,\n+    visited: BitSet<BasicBlock>,\n+    worklist: Vec<BasicBlock>,\n+    filtered_successors: F,\n+}\n+\n+impl<'a, 'tcx, F: Fn(&'tcx TerminatorKind<'tcx>) -> mir::Successors<'tcx>>\n+    ShortCircuitPreorder<'a, 'tcx, F>\n+{\n+    pub fn new(\n+        body: &'a mir::Body<'tcx>,\n+        filtered_successors: F,\n+    ) -> ShortCircuitPreorder<'a, 'tcx, F> {\n+        let worklist = vec![mir::START_BLOCK];\n+\n+        ShortCircuitPreorder {\n+            body,\n+            visited: BitSet::new_empty(body.basic_blocks().len()),\n+            worklist,\n+            filtered_successors,\n+        }\n+    }\n+}\n+\n+impl<'a: 'tcx, 'tcx, F: Fn(&'tcx TerminatorKind<'tcx>) -> mir::Successors<'tcx>> Iterator\n+    for ShortCircuitPreorder<'a, 'tcx, F>\n+{\n+    type Item = (BasicBlock, &'a BasicBlockData<'tcx>);\n+\n+    fn next(&mut self) -> Option<(BasicBlock, &'a BasicBlockData<'tcx>)> {\n+        while let Some(idx) = self.worklist.pop() {\n+            if !self.visited.insert(idx) {\n+                continue;\n+            }\n+\n+            let data = &self.body[idx];\n+\n+            if let Some(ref term) = data.terminator {\n+                self.worklist.extend((self.filtered_successors)(&term.kind));\n+            }\n+\n+            return Some((idx, data));\n+        }\n+\n+        None\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let size = self.body.basic_blocks().len() - self.visited.count();\n+        (size, Some(size))\n+    }\n+}"}, {"sha": "9961afba8e7c4e797a09d2a40dcec413a74e36fa", "filename": "compiler/rustc_mir/src/transform/coverage/mod.rs", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs?ref=c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71", "patch": "@@ -0,0 +1,241 @@\n+pub mod query;\n+\n+mod counters;\n+mod debug;\n+mod graph;\n+mod spans;\n+\n+use counters::CoverageCounters;\n+use graph::BasicCoverageBlocks;\n+use spans::{CoverageSpan, CoverageSpans};\n+\n+use crate::transform::MirPass;\n+use crate::util::pretty;\n+\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::hir;\n+use rustc_middle::hir::map::blocks::FnLikeNode;\n+use rustc_middle::ich::StableHashingContext;\n+use rustc_middle::mir::coverage::*;\n+use rustc_middle::mir::{self, BasicBlock, Coverage, Statement, StatementKind};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::def_id::DefId;\n+use rustc_span::{CharPos, Pos, SourceFile, Span, Symbol};\n+\n+/// Inserts `StatementKind::Coverage` statements that either instrument the binary with injected\n+/// counters, via intrinsic `llvm.instrprof.increment`, and/or inject metadata used during codegen\n+/// to construct the coverage map.\n+pub struct InstrumentCoverage;\n+\n+impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, mir_body: &mut mir::Body<'tcx>) {\n+        let mir_source = mir_body.source;\n+\n+        // If the InstrumentCoverage pass is called on promoted MIRs, skip them.\n+        // See: https://github.com/rust-lang/rust/pull/73011#discussion_r438317601\n+        if mir_source.promoted.is_some() {\n+            trace!(\n+                \"InstrumentCoverage skipped for {:?} (already promoted for Miri evaluation)\",\n+                mir_source.def_id()\n+            );\n+            return;\n+        }\n+\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(mir_source.def_id().expect_local());\n+        let is_fn_like = FnLikeNode::from_node(tcx.hir().get(hir_id)).is_some();\n+\n+        // Only instrument functions, methods, and closures (not constants since they are evaluated\n+        // at compile time by Miri).\n+        // FIXME(#73156): Handle source code coverage in const eval, but note, if and when const\n+        // expressions get coverage spans, we will probably have to \"carve out\" space for const\n+        // expressions from coverage spans in enclosing MIR's, like we do for closures. (That might\n+        // be tricky if const expressions have no corresponding statements in the enclosing MIR.\n+        // Closures are carved out by their initial `Assign` statement.)\n+        if !is_fn_like {\n+            trace!(\"InstrumentCoverage skipped for {:?} (not an FnLikeNode)\", mir_source.def_id());\n+            return;\n+        }\n+        // FIXME(richkadel): By comparison, the MIR pass `ConstProp` includes associated constants,\n+        // with functions, methods, and closures. I assume Miri is used for associated constants as\n+        // well. If not, we may need to include them here too.\n+\n+        trace!(\"InstrumentCoverage starting for {:?}\", mir_source.def_id());\n+        Instrumentor::new(&self.name(), tcx, mir_body).inject_counters();\n+        trace!(\"InstrumentCoverage starting for {:?}\", mir_source.def_id());\n+    }\n+}\n+\n+struct Instrumentor<'a, 'tcx> {\n+    pass_name: &'a str,\n+    tcx: TyCtxt<'tcx>,\n+    mir_body: &'a mut mir::Body<'tcx>,\n+    body_span: Span,\n+    basic_coverage_blocks: BasicCoverageBlocks,\n+    coverage_counters: CoverageCounters,\n+}\n+\n+impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n+    fn new(pass_name: &'a str, tcx: TyCtxt<'tcx>, mir_body: &'a mut mir::Body<'tcx>) -> Self {\n+        let hir_body = hir_body(tcx, mir_body.source.def_id());\n+        let body_span = hir_body.value.span;\n+        let function_source_hash = hash_mir_source(tcx, hir_body);\n+        let basic_coverage_blocks = BasicCoverageBlocks::from_mir(mir_body);\n+        Self {\n+            pass_name,\n+            tcx,\n+            mir_body,\n+            body_span,\n+            basic_coverage_blocks,\n+            coverage_counters: CoverageCounters::new(function_source_hash),\n+        }\n+    }\n+\n+    fn inject_counters(&'a mut self) {\n+        let tcx = self.tcx;\n+        let source_map = tcx.sess.source_map();\n+        let mir_source = self.mir_body.source;\n+        let def_id = mir_source.def_id();\n+        let body_span = self.body_span;\n+\n+        debug!(\"instrumenting {:?}, span: {}\", def_id, source_map.span_to_string(body_span));\n+\n+        ////////////////////////////////////////////////////\n+        // Compute `CoverageSpan`s from the `BasicCoverageBlocks`.\n+        let coverage_spans = CoverageSpans::generate_coverage_spans(\n+            &self.mir_body,\n+            body_span,\n+            &self.basic_coverage_blocks,\n+        );\n+\n+        if pretty::dump_enabled(tcx, self.pass_name, def_id) {\n+            debug::dump_coverage_spanview(\n+                tcx,\n+                self.mir_body,\n+                &self.basic_coverage_blocks,\n+                self.pass_name,\n+                &coverage_spans,\n+            );\n+        }\n+\n+        self.inject_coverage_span_counters(coverage_spans);\n+    }\n+\n+    /// Inject a counter for each `CoverageSpan`. There can be multiple `CoverageSpan`s for a given\n+    /// BCB, but only one actual counter needs to be incremented per BCB. `bcb_counters` maps each\n+    /// `bcb` to its `Counter`, when injected. Subsequent `CoverageSpan`s for a BCB that already has\n+    /// a `Counter` will inject an `Expression` instead, and compute its value by adding `ZERO` to\n+    /// the BCB `Counter` value.\n+    fn inject_coverage_span_counters(&mut self, coverage_spans: Vec<CoverageSpan>) {\n+        let tcx = self.tcx;\n+        let source_map = tcx.sess.source_map();\n+        let body_span = self.body_span;\n+        let source_file = source_map.lookup_source_file(body_span.lo());\n+        let file_name = Symbol::intern(&source_file.name.to_string());\n+\n+        let mut bb_counters = IndexVec::from_elem_n(None, self.mir_body.basic_blocks().len());\n+        for CoverageSpan { span, bcb_leader_bb: bb, .. } in coverage_spans {\n+            if let Some(&counter_operand) = bb_counters[bb].as_ref() {\n+                let expression = self.coverage_counters.make_expression(\n+                    counter_operand,\n+                    Op::Add,\n+                    ExpressionOperandId::ZERO,\n+                );\n+                debug!(\n+                    \"Injecting counter expression {:?} at: {:?}:\\n{}\\n==========\",\n+                    expression,\n+                    span,\n+                    source_map.span_to_snippet(span).expect(\"Error getting source for span\"),\n+                );\n+                let code_region = make_code_region(file_name, &source_file, span, body_span);\n+                inject_statement(self.mir_body, expression, bb, Some(code_region));\n+            } else {\n+                let counter = self.coverage_counters.make_counter();\n+                debug!(\n+                    \"Injecting counter {:?} at: {:?}:\\n{}\\n==========\",\n+                    counter,\n+                    span,\n+                    source_map.span_to_snippet(span).expect(\"Error getting source for span\"),\n+                );\n+                let counter_operand = counter.as_operand_id();\n+                bb_counters[bb] = Some(counter_operand);\n+                let code_region = make_code_region(file_name, &source_file, span, body_span);\n+                inject_statement(self.mir_body, counter, bb, Some(code_region));\n+            }\n+        }\n+    }\n+}\n+\n+fn inject_statement(\n+    mir_body: &mut mir::Body<'tcx>,\n+    counter_kind: CoverageKind,\n+    bb: BasicBlock,\n+    some_code_region: Option<CodeRegion>,\n+) {\n+    debug!(\n+        \"  injecting statement {:?} for {:?} at code region: {:?}\",\n+        counter_kind, bb, some_code_region\n+    );\n+    let data = &mut mir_body[bb];\n+    let source_info = data.terminator().source_info;\n+    let statement = Statement {\n+        source_info,\n+        kind: StatementKind::Coverage(box Coverage {\n+            kind: counter_kind,\n+            code_region: some_code_region,\n+        }),\n+    };\n+    data.statements.push(statement);\n+}\n+\n+/// Convert the Span into its file name, start line and column, and end line and column\n+fn make_code_region(\n+    file_name: Symbol,\n+    source_file: &Lrc<SourceFile>,\n+    span: Span,\n+    body_span: Span,\n+) -> CodeRegion {\n+    let (start_line, mut start_col) = source_file.lookup_file_pos(span.lo());\n+    let (end_line, end_col) = if span.hi() == span.lo() {\n+        let (end_line, mut end_col) = (start_line, start_col);\n+        // Extend an empty span by one character so the region will be counted.\n+        let CharPos(char_pos) = start_col;\n+        if span.hi() == body_span.hi() {\n+            start_col = CharPos(char_pos - 1);\n+        } else {\n+            end_col = CharPos(char_pos + 1);\n+        }\n+        (end_line, end_col)\n+    } else {\n+        source_file.lookup_file_pos(span.hi())\n+    };\n+    CodeRegion {\n+        file_name,\n+        start_line: start_line as u32,\n+        start_col: start_col.to_u32() + 1,\n+        end_line: end_line as u32,\n+        end_col: end_col.to_u32() + 1,\n+    }\n+}\n+\n+fn hir_body<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx rustc_hir::Body<'tcx> {\n+    let hir_node = tcx.hir().get_if_local(def_id).expect(\"expected DefId is local\");\n+    let fn_body_id = hir::map::associated_body(hir_node).expect(\"HIR node is a function with body\");\n+    tcx.hir().body(fn_body_id)\n+}\n+\n+fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, hir_body: &'tcx rustc_hir::Body<'tcx>) -> u64 {\n+    let mut hcx = tcx.create_no_span_stable_hashing_context();\n+    hash(&mut hcx, &hir_body.value).to_smaller_hash()\n+}\n+\n+fn hash(\n+    hcx: &mut StableHashingContext<'tcx>,\n+    node: &impl HashStable<StableHashingContext<'tcx>>,\n+) -> Fingerprint {\n+    let mut stable_hasher = StableHasher::new();\n+    node.hash_stable(hcx, &mut stable_hasher);\n+    stable_hasher.finish()\n+}"}, {"sha": "c17221b78ddd4711d87f86cc91de9489766ad4d0", "filename": "compiler/rustc_mir/src/transform/coverage/query.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fquery.rs?ref=c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71", "patch": "@@ -0,0 +1,113 @@\n+use rustc_middle::mir::coverage::*;\n+use rustc_middle::mir::visit::Visitor;\n+use rustc_middle::mir::{Coverage, CoverageInfo, Location};\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::def_id::DefId;\n+\n+/// The `query` provider for `CoverageInfo`, requested by `codegen_coverage()` (to inject each\n+/// counter) and `FunctionCoverage::new()` (to extract the coverage map metadata from the MIR).\n+pub(crate) fn provide(providers: &mut Providers) {\n+    providers.coverageinfo = |tcx, def_id| coverageinfo_from_mir(tcx, def_id);\n+}\n+\n+/// The `num_counters` argument to `llvm.instrprof.increment` is the max counter_id + 1, or in\n+/// other words, the number of counter value references injected into the MIR (plus 1 for the\n+/// reserved `ZERO` counter, which uses counter ID `0` when included in an expression). Injected\n+/// counters have a counter ID from `1..num_counters-1`.\n+///\n+/// `num_expressions` is the number of counter expressions added to the MIR body.\n+///\n+/// Both `num_counters` and `num_expressions` are used to initialize new vectors, during backend\n+/// code generate, to lookup counters and expressions by simple u32 indexes.\n+///\n+/// MIR optimization may split and duplicate some BasicBlock sequences, or optimize out some code\n+/// including injected counters. (It is OK if some counters are optimized out, but those counters\n+/// are still included in the total `num_counters` or `num_expressions`.) Simply counting the\n+/// calls may not work; but computing the number of counters or expressions by adding `1` to the\n+/// highest ID (for a given instrumented function) is valid.\n+///\n+/// This visitor runs twice, first with `add_missing_operands` set to `false`, to find the maximum\n+/// counter ID and maximum expression ID based on their enum variant `id` fields; then, as a\n+/// safeguard, with `add_missing_operands` set to `true`, to find any other counter or expression\n+/// IDs referenced by expression operands, if not already seen.\n+///\n+/// Ideally, every expression operand in the MIR will have a corresponding Counter or Expression,\n+/// but since current or future MIR optimizations can theoretically optimize out segments of a\n+/// MIR, it may not be possible to guarantee this, so the second pass ensures the `CoverageInfo`\n+/// counts include all referenced IDs.\n+struct CoverageVisitor {\n+    info: CoverageInfo,\n+    add_missing_operands: bool,\n+}\n+\n+impl CoverageVisitor {\n+    // If an expression operand is encountered with an ID outside the range of known counters and\n+    // expressions, the only way to determine if the ID is a counter ID or an expression ID is to\n+    // assume a maximum possible counter ID value.\n+    const MAX_COUNTER_GUARD: u32 = (u32::MAX / 2) + 1;\n+\n+    #[inline(always)]\n+    fn update_num_counters(&mut self, counter_id: u32) {\n+        self.info.num_counters = std::cmp::max(self.info.num_counters, counter_id + 1);\n+    }\n+\n+    #[inline(always)]\n+    fn update_num_expressions(&mut self, expression_id: u32) {\n+        let expression_index = u32::MAX - expression_id;\n+        self.info.num_expressions = std::cmp::max(self.info.num_expressions, expression_index + 1);\n+    }\n+\n+    fn update_from_expression_operand(&mut self, operand_id: u32) {\n+        if operand_id >= self.info.num_counters {\n+            let operand_as_expression_index = u32::MAX - operand_id;\n+            if operand_as_expression_index >= self.info.num_expressions {\n+                if operand_id <= Self::MAX_COUNTER_GUARD {\n+                    self.update_num_counters(operand_id)\n+                } else {\n+                    self.update_num_expressions(operand_id)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl Visitor<'_> for CoverageVisitor {\n+    fn visit_coverage(&mut self, coverage: &Coverage, _location: Location) {\n+        if self.add_missing_operands {\n+            match coverage.kind {\n+                CoverageKind::Expression { lhs, rhs, .. } => {\n+                    self.update_from_expression_operand(u32::from(lhs));\n+                    self.update_from_expression_operand(u32::from(rhs));\n+                }\n+                _ => {}\n+            }\n+        } else {\n+            match coverage.kind {\n+                CoverageKind::Counter { id, .. } => {\n+                    self.update_num_counters(u32::from(id));\n+                }\n+                CoverageKind::Expression { id, .. } => {\n+                    self.update_num_expressions(u32::from(id));\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+}\n+\n+fn coverageinfo_from_mir<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> CoverageInfo {\n+    let mir_body = tcx.optimized_mir(def_id);\n+\n+    let mut coverage_visitor = CoverageVisitor {\n+        info: CoverageInfo { num_counters: 0, num_expressions: 0 },\n+        add_missing_operands: false,\n+    };\n+\n+    coverage_visitor.visit_body(mir_body);\n+\n+    coverage_visitor.add_missing_operands = true;\n+    coverage_visitor.visit_body(mir_body);\n+\n+    coverage_visitor.info\n+}"}, {"sha": "7957b6f3ff5926b7a1ebff8d61961afd34a1214b", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "renamed", "additions": 11, "deletions": 727, "changes": 738, "blob_url": "https://github.com/rust-lang/rust/blob/c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71", "patch": "@@ -1,396 +1,24 @@\n-use crate::transform::MirPass;\n-use crate::util::pretty;\n-use crate::util::spanview::{self, source_range_no_file, SpanViewable};\n+use super::debug::term_type;\n+use super::graph::{BasicCoverageBlock, BasicCoverageBlocks};\n+\n+use crate::util::spanview::source_range_no_file;\n \n-use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_data_structures::graph::WithNumNodes;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::Lrc;\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n-use rustc_middle::hir;\n-use rustc_middle::hir::map::blocks::FnLikeNode;\n-use rustc_middle::ich::StableHashingContext;\n-use rustc_middle::mir;\n-use rustc_middle::mir::coverage::*;\n-use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::{\n-    AggregateKind, BasicBlock, BasicBlockData, Coverage, CoverageInfo, FakeReadCause, Location,\n-    Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n+    self, AggregateKind, BasicBlock, FakeReadCause, Rvalue, Statement, StatementKind, Terminator,\n+    TerminatorKind,\n };\n-use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::def_id::DefId;\n+\n use rustc_span::source_map::original_sp;\n-use rustc_span::{BytePos, CharPos, Pos, SourceFile, Span, Symbol, SyntaxContext};\n+use rustc_span::{BytePos, Span, SyntaxContext};\n \n use std::cmp::Ordering;\n \n-const ID_SEPARATOR: &str = \",\";\n-\n-/// The `query` provider for `CoverageInfo`, requested by `codegen_coverage()` (to inject each\n-/// counter) and `FunctionCoverage::new()` (to extract the coverage map metadata from the MIR).\n-pub(crate) fn provide(providers: &mut Providers) {\n-    providers.coverageinfo = |tcx, def_id| coverageinfo_from_mir(tcx, def_id);\n-}\n-\n-/// The `num_counters` argument to `llvm.instrprof.increment` is the max counter_id + 1, or in\n-/// other words, the number of counter value references injected into the MIR (plus 1 for the\n-/// reserved `ZERO` counter, which uses counter ID `0` when included in an expression). Injected\n-/// counters have a counter ID from `1..num_counters-1`.\n-///\n-/// `num_expressions` is the number of counter expressions added to the MIR body.\n-///\n-/// Both `num_counters` and `num_expressions` are used to initialize new vectors, during backend\n-/// code generate, to lookup counters and expressions by simple u32 indexes.\n-///\n-/// MIR optimization may split and duplicate some BasicBlock sequences, or optimize out some code\n-/// including injected counters. (It is OK if some counters are optimized out, but those counters\n-/// are still included in the total `num_counters` or `num_expressions`.) Simply counting the\n-/// calls may not work; but computing the number of counters or expressions by adding `1` to the\n-/// highest ID (for a given instrumented function) is valid.\n-///\n-/// This visitor runs twice, first with `add_missing_operands` set to `false`, to find the maximum\n-/// counter ID and maximum expression ID based on their enum variant `id` fields; then, as a\n-/// safeguard, with `add_missing_operands` set to `true`, to find any other counter or expression\n-/// IDs referenced by expression operands, if not already seen.\n-///\n-/// Ideally, every expression operand in the MIR will have a corresponding Counter or Expression,\n-/// but since current or future MIR optimizations can theoretically optimize out segments of a\n-/// MIR, it may not be possible to guarantee this, so the second pass ensures the `CoverageInfo`\n-/// counts include all referenced IDs.\n-struct CoverageVisitor {\n-    info: CoverageInfo,\n-    add_missing_operands: bool,\n-}\n-\n-impl CoverageVisitor {\n-    // If an expression operand is encountered with an ID outside the range of known counters and\n-    // expressions, the only way to determine if the ID is a counter ID or an expression ID is to\n-    // assume a maximum possible counter ID value.\n-    const MAX_COUNTER_GUARD: u32 = (u32::MAX / 2) + 1;\n-\n-    #[inline(always)]\n-    fn update_num_counters(&mut self, counter_id: u32) {\n-        self.info.num_counters = std::cmp::max(self.info.num_counters, counter_id + 1);\n-    }\n-\n-    #[inline(always)]\n-    fn update_num_expressions(&mut self, expression_id: u32) {\n-        let expression_index = u32::MAX - expression_id;\n-        self.info.num_expressions = std::cmp::max(self.info.num_expressions, expression_index + 1);\n-    }\n-\n-    fn update_from_expression_operand(&mut self, operand_id: u32) {\n-        if operand_id >= self.info.num_counters {\n-            let operand_as_expression_index = u32::MAX - operand_id;\n-            if operand_as_expression_index >= self.info.num_expressions {\n-                if operand_id <= Self::MAX_COUNTER_GUARD {\n-                    self.update_num_counters(operand_id)\n-                } else {\n-                    self.update_num_expressions(operand_id)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl Visitor<'_> for CoverageVisitor {\n-    fn visit_coverage(&mut self, coverage: &Coverage, _location: Location) {\n-        if self.add_missing_operands {\n-            match coverage.kind {\n-                CoverageKind::Expression { lhs, rhs, .. } => {\n-                    self.update_from_expression_operand(u32::from(lhs));\n-                    self.update_from_expression_operand(u32::from(rhs));\n-                }\n-                _ => {}\n-            }\n-        } else {\n-            match coverage.kind {\n-                CoverageKind::Counter { id, .. } => {\n-                    self.update_num_counters(u32::from(id));\n-                }\n-                CoverageKind::Expression { id, .. } => {\n-                    self.update_num_expressions(u32::from(id));\n-                }\n-                _ => {}\n-            }\n-        }\n-    }\n-}\n-\n-fn coverageinfo_from_mir<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> CoverageInfo {\n-    let mir_body = tcx.optimized_mir(def_id);\n-\n-    let mut coverage_visitor = CoverageVisitor {\n-        info: CoverageInfo { num_counters: 0, num_expressions: 0 },\n-        add_missing_operands: false,\n-    };\n-\n-    coverage_visitor.visit_body(mir_body);\n-\n-    coverage_visitor.add_missing_operands = true;\n-    coverage_visitor.visit_body(mir_body);\n-\n-    coverage_visitor.info\n-}\n-/// Inserts `StatementKind::Coverage` statements that either instrument the binary with injected\n-/// counters, via intrinsic `llvm.instrprof.increment`, and/or inject metadata used during codegen\n-/// to construct the coverage map.\n-pub struct InstrumentCoverage;\n-\n-impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, mir_body: &mut mir::Body<'tcx>) {\n-        let mir_source = mir_body.source;\n-\n-        // If the InstrumentCoverage pass is called on promoted MIRs, skip them.\n-        // See: https://github.com/rust-lang/rust/pull/73011#discussion_r438317601\n-        if mir_source.promoted.is_some() {\n-            trace!(\n-                \"InstrumentCoverage skipped for {:?} (already promoted for Miri evaluation)\",\n-                mir_source.def_id()\n-            );\n-            return;\n-        }\n-\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(mir_source.def_id().expect_local());\n-        let is_fn_like = FnLikeNode::from_node(tcx.hir().get(hir_id)).is_some();\n-\n-        // Only instrument functions, methods, and closures (not constants since they are evaluated\n-        // at compile time by Miri).\n-        // FIXME(#73156): Handle source code coverage in const eval, but note, if and when const\n-        // expressions get coverage spans, we will probably have to \"carve out\" space for const\n-        // expressions from coverage spans in enclosing MIR's, like we do for closures. (That might\n-        // be tricky if const expressions have no corresponding statements in the enclosing MIR.\n-        // Closures are carved out by their initial `Assign` statement.)\n-        if !is_fn_like {\n-            trace!(\"InstrumentCoverage skipped for {:?} (not an FnLikeNode)\", mir_source.def_id());\n-            return;\n-        }\n-        // FIXME(richkadel): By comparison, the MIR pass `ConstProp` includes associated constants,\n-        // with functions, methods, and closures. I assume Miri is used for associated constants as\n-        // well. If not, we may need to include them here too.\n-\n-        trace!(\"InstrumentCoverage starting for {:?}\", mir_source.def_id());\n-        Instrumentor::new(&self.name(), tcx, mir_body).inject_counters();\n-        trace!(\"InstrumentCoverage starting for {:?}\", mir_source.def_id());\n-    }\n-}\n-\n-/// A BasicCoverageBlock (BCB) represents the maximal-length sequence of CFG (MIR) BasicBlocks\n-/// without conditional branches.\n-///\n-/// The BCB allows coverage analysis to be performed on a simplified projection of the underlying\n-/// MIR CFG, without altering the original CFG. Note that running the MIR `SimplifyCfg` transform,\n-/// is not sufficient, and therefore not necessary, since the BCB-based CFG projection is a more\n-/// aggressive simplification. For example:\n-///\n-///   * The BCB CFG projection ignores (trims) branches not relevant to coverage, such as unwind-\n-///     related code that is injected by the Rust compiler but has no physical source code to\n-///     count. This also means a BasicBlock with a `Call` terminator can be merged into its\n-///     primary successor target block, in the same BCB.\n-///   * Some BasicBlock terminators support Rust-specific concerns--like borrow-checking--that are\n-///     not relevant to coverage analysis. `FalseUnwind`, for example, can be treated the same as\n-///     a `Goto`, and merged with its successor into the same BCB.\n-///\n-/// Each BCB with at least one computed `CoverageSpan` will have no more than one `Counter`.\n-/// In some cases, a BCB's execution count can be computed by `CounterExpression`. Additional\n-/// disjoint `CoverageSpan`s in a BCB can also be counted by `CounterExpression` (by adding `ZERO`\n-/// to the BCB's primary counter or expression).\n-///\n-/// Dominator/dominated relationships (which are fundamental to the coverage analysis algorithm)\n-/// between two BCBs can be computed using the `mir::Body` `dominators()` with any `BasicBlock`\n-/// member of each BCB. (For consistency, BCB's use the first `BasicBlock`, also referred to as the\n-/// `bcb_leader_bb`.)\n-///\n-/// The BCB CFG projection is critical to simplifying the coverage analysis by ensuring graph\n-/// path-based queries (`is_dominated_by()`, `predecessors`, `successors`, etc.) have branch\n-/// (control flow) significance.\n-#[derive(Debug, Clone)]\n-struct BasicCoverageBlock {\n-    pub blocks: Vec<BasicBlock>,\n-}\n-\n-impl BasicCoverageBlock {\n-    pub fn leader_bb(&self) -> BasicBlock {\n-        self.blocks[0]\n-    }\n-\n-    pub fn id(&self) -> String {\n-        format!(\n-            \"@{}\",\n-            self.blocks\n-                .iter()\n-                .map(|bb| bb.index().to_string())\n-                .collect::<Vec<_>>()\n-                .join(ID_SEPARATOR)\n-        )\n-    }\n-}\n-\n-struct BasicCoverageBlocks {\n-    vec: IndexVec<BasicBlock, Option<BasicCoverageBlock>>,\n-}\n-\n-impl BasicCoverageBlocks {\n-    pub fn from_mir(mir_body: &mir::Body<'tcx>) -> Self {\n-        let mut basic_coverage_blocks =\n-            BasicCoverageBlocks { vec: IndexVec::from_elem_n(None, mir_body.basic_blocks().len()) };\n-        basic_coverage_blocks.extract_from_mir(mir_body);\n-        basic_coverage_blocks\n-    }\n-\n-    pub fn iter(&self) -> impl Iterator<Item = &BasicCoverageBlock> {\n-        self.vec.iter().filter_map(|bcb| bcb.as_ref())\n-    }\n-\n-    pub fn num_nodes(&self) -> usize {\n-        self.vec.len()\n-    }\n-\n-    pub fn extract_from_mir(&mut self, mir_body: &mir::Body<'tcx>) {\n-        // Traverse the CFG but ignore anything following an `unwind`\n-        let cfg_without_unwind = ShortCircuitPreorder::new(&mir_body, |term_kind| {\n-            let mut successors = term_kind.successors();\n-            match &term_kind {\n-                // SwitchInt successors are never unwind, and all of them should be traversed.\n-\n-                // NOTE: TerminatorKind::FalseEdge targets from SwitchInt don't appear to be\n-                // helpful in identifying unreachable code. I did test the theory, but the following\n-                // changes were not beneficial. (I assumed that replacing some constants with\n-                // non-deterministic variables might effect which blocks were targeted by a\n-                // `FalseEdge` `imaginary_target`. It did not.)\n-                //\n-                // Also note that, if there is a way to identify BasicBlocks that are part of the\n-                // MIR CFG, but not actually reachable, here are some other things to consider:\n-                //\n-                // Injecting unreachable code regions will probably require computing the set\n-                // difference between the basic blocks found without filtering out unreachable\n-                // blocks, and the basic blocks found with the filter; then computing the\n-                // `CoverageSpans` without the filter; and then injecting `Counter`s or\n-                // `CounterExpression`s for blocks that are not unreachable, or injecting\n-                // `Unreachable` code regions otherwise. This seems straightforward, but not\n-                // trivial.\n-                //\n-                // Alternatively, we might instead want to leave the unreachable blocks in\n-                // (bypass the filter here), and inject the counters. This will result in counter\n-                // values of zero (0) for unreachable code (and, notably, the code will be displayed\n-                // with a red background by `llvm-cov show`).\n-                //\n-                // TerminatorKind::SwitchInt { .. } => {\n-                //     let some_imaginary_target = successors.clone().find_map(|&successor| {\n-                //         let term = mir_body.basic_blocks()[successor].terminator();\n-                //         if let TerminatorKind::FalseEdge { imaginary_target, .. } = term.kind {\n-                //             if mir_body.predecessors()[imaginary_target].len() == 1 {\n-                //                 return Some(imaginary_target);\n-                //             }\n-                //         }\n-                //         None\n-                //     });\n-                //     if let Some(imaginary_target) = some_imaginary_target {\n-                //         box successors.filter(move |&&successor| successor != imaginary_target)\n-                //     } else {\n-                //         box successors\n-                //     }\n-                // }\n-                //\n-                // Note this also required changing the closure signature for the\n-                // `ShortCurcuitPreorder` to:\n-                //\n-                // F: Fn(&'tcx TerminatorKind<'tcx>) -> Box<dyn Iterator<Item = &BasicBlock> + 'a>,\n-                TerminatorKind::SwitchInt { .. } => successors,\n-\n-                // For all other kinds, return only the first successor, if any, and ignore unwinds\n-                _ => successors.next().into_iter().chain(&[]),\n-            }\n-        });\n-\n-        // Walk the CFG using a Preorder traversal, which starts from `START_BLOCK` and follows\n-        // each block terminator's `successors()`. Coverage spans must map to actual source code,\n-        // so compiler generated blocks and paths can be ignored. To that end the CFG traversal\n-        // intentionally omits unwind paths.\n-        let mut blocks = Vec::new();\n-        for (bb, data) in cfg_without_unwind {\n-            if let Some(last) = blocks.last() {\n-                let predecessors = &mir_body.predecessors()[bb];\n-                if predecessors.len() > 1 || !predecessors.contains(last) {\n-                    // The `bb` has more than one _incoming_ edge, and should start its own\n-                    // `BasicCoverageBlock`. (Note, the `blocks` vector does not yet include `bb`;\n-                    // it contains a sequence of one or more sequential blocks with no intermediate\n-                    // branches in or out. Save these as a new `BasicCoverageBlock` before starting\n-                    // the new one.)\n-                    self.add_basic_coverage_block(blocks.split_off(0));\n-                    debug!(\n-                        \"  because {}\",\n-                        if predecessors.len() > 1 {\n-                            \"predecessors.len() > 1\".to_owned()\n-                        } else {\n-                            format!(\"bb {} is not in precessors: {:?}\", bb.index(), predecessors)\n-                        }\n-                    );\n-                }\n-            }\n-            blocks.push(bb);\n-\n-            let term = data.terminator();\n-\n-            match term.kind {\n-                TerminatorKind::Return { .. }\n-                | TerminatorKind::Abort\n-                | TerminatorKind::Assert { .. }\n-                | TerminatorKind::Yield { .. }\n-                | TerminatorKind::SwitchInt { .. } => {\n-                    // The `bb` has more than one _outgoing_ edge, or exits the function. Save the\n-                    // current sequence of `blocks` gathered to this point, as a new\n-                    // `BasicCoverageBlock`.\n-                    self.add_basic_coverage_block(blocks.split_off(0));\n-                    debug!(\"  because term.kind = {:?}\", term.kind);\n-                    // Note that this condition is based on `TerminatorKind`, even though it\n-                    // theoretically boils down to `successors().len() != 1`; that is, either zero\n-                    // (e.g., `Return`, `Abort`) or multiple successors (e.g., `SwitchInt`), but\n-                    // since the Coverage graph (the BCB CFG projection) ignores things like unwind\n-                    // branches (which exist in the `Terminator`s `successors()` list) checking the\n-                    // number of successors won't work.\n-                }\n-                TerminatorKind::Goto { .. }\n-                | TerminatorKind::Resume\n-                | TerminatorKind::Unreachable\n-                | TerminatorKind::Drop { .. }\n-                | TerminatorKind::DropAndReplace { .. }\n-                | TerminatorKind::Call { .. }\n-                | TerminatorKind::GeneratorDrop\n-                | TerminatorKind::FalseEdge { .. }\n-                | TerminatorKind::FalseUnwind { .. }\n-                | TerminatorKind::InlineAsm { .. } => {}\n-            }\n-        }\n-\n-        if !blocks.is_empty() {\n-            // process any remaining blocks into a final `BasicCoverageBlock`\n-            self.add_basic_coverage_block(blocks.split_off(0));\n-            debug!(\"  because the end of the CFG was reached while traversing\");\n-        }\n-    }\n-\n-    fn add_basic_coverage_block(&mut self, blocks: Vec<BasicBlock>) {\n-        let leader_bb = blocks[0];\n-        let bcb = BasicCoverageBlock { blocks };\n-        debug!(\"adding BCB: {:?}\", bcb);\n-        self.vec[leader_bb] = Some(bcb);\n-    }\n-}\n-\n-impl std::ops::Index<BasicBlock> for BasicCoverageBlocks {\n-    type Output = BasicCoverageBlock;\n-\n-    fn index(&self, index: BasicBlock) -> &Self::Output {\n-        self.vec[index].as_ref().expect(\"is_some if BasicBlock is a BasicCoverageBlock leader\")\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone)]\n-enum CoverageStatement {\n+pub(crate) enum CoverageStatement {\n     Statement(BasicBlock, Span, usize),\n     Terminator(BasicBlock, Span),\n }\n@@ -428,28 +56,6 @@ impl CoverageStatement {\n     }\n }\n \n-/// Returns a simple string representation of a `TerminatorKind` variant, indenpendent of any\n-/// values it might hold.\n-fn term_type(kind: &TerminatorKind<'tcx>) -> &'static str {\n-    match kind {\n-        TerminatorKind::Goto { .. } => \"Goto\",\n-        TerminatorKind::SwitchInt { .. } => \"SwitchInt\",\n-        TerminatorKind::Resume => \"Resume\",\n-        TerminatorKind::Abort => \"Abort\",\n-        TerminatorKind::Return => \"Return\",\n-        TerminatorKind::Unreachable => \"Unreachable\",\n-        TerminatorKind::Drop { .. } => \"Drop\",\n-        TerminatorKind::DropAndReplace { .. } => \"DropAndReplace\",\n-        TerminatorKind::Call { .. } => \"Call\",\n-        TerminatorKind::Assert { .. } => \"Assert\",\n-        TerminatorKind::Yield { .. } => \"Yield\",\n-        TerminatorKind::GeneratorDrop => \"GeneratorDrop\",\n-        TerminatorKind::FalseEdge { .. } => \"FalseEdge\",\n-        TerminatorKind::FalseUnwind { .. } => \"FalseUnwind\",\n-        TerminatorKind::InlineAsm { .. } => \"InlineAsm\",\n-    }\n-}\n-\n /// A BCB is deconstructed into one or more `Span`s. Each `Span` maps to a `CoverageSpan` that\n /// references the originating BCB and one or more MIR `Statement`s and/or `Terminator`s.\n /// Initially, the `Span`s come from the `Statement`s and `Terminator`s, but subsequent\n@@ -461,7 +67,7 @@ fn term_type(kind: &TerminatorKind<'tcx>) -> &'static str {\n /// or is subsumed by the `Span` associated with this `CoverageSpan`, and it's `BasicBlock`\n /// `is_dominated_by()` the `BasicBlock`s in this `CoverageSpan`.\n #[derive(Debug, Clone)]\n-struct CoverageSpan {\n+pub(crate) struct CoverageSpan {\n     pub span: Span,\n     pub bcb_leader_bb: BasicBlock,\n     pub coverage_statements: Vec<CoverageStatement>,\n@@ -547,220 +153,6 @@ impl CoverageSpan {\n     }\n }\n \n-struct Instrumentor<'a, 'tcx> {\n-    pass_name: &'a str,\n-    tcx: TyCtxt<'tcx>,\n-    mir_body: &'a mut mir::Body<'tcx>,\n-    body_span: Span,\n-    basic_coverage_blocks: BasicCoverageBlocks,\n-    coverage_counters: CoverageCounters,\n-}\n-\n-impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n-    fn new(pass_name: &'a str, tcx: TyCtxt<'tcx>, mir_body: &'a mut mir::Body<'tcx>) -> Self {\n-        let hir_body = hir_body(tcx, mir_body.source.def_id());\n-        let body_span = hir_body.value.span;\n-        let function_source_hash = hash_mir_source(tcx, hir_body);\n-        let basic_coverage_blocks = BasicCoverageBlocks::from_mir(mir_body);\n-        Self {\n-            pass_name,\n-            tcx,\n-            mir_body,\n-            body_span,\n-            basic_coverage_blocks,\n-            coverage_counters: CoverageCounters::new(function_source_hash),\n-        }\n-    }\n-\n-    fn inject_counters(&'a mut self) {\n-        let tcx = self.tcx;\n-        let source_map = tcx.sess.source_map();\n-        let mir_source = self.mir_body.source;\n-        let def_id = mir_source.def_id();\n-        let body_span = self.body_span;\n-\n-        debug!(\"instrumenting {:?}, span: {}\", def_id, source_map.span_to_string(body_span));\n-\n-        ////////////////////////////////////////////////////\n-        // Compute `CoverageSpan`s from the `BasicCoverageBlocks`.\n-        let coverage_spans = CoverageSpans::generate_coverage_spans(\n-            &self.mir_body,\n-            body_span,\n-            &self.basic_coverage_blocks,\n-        );\n-\n-        if pretty::dump_enabled(tcx, self.pass_name, def_id) {\n-            dump_coverage_spanview(\n-                tcx,\n-                self.mir_body,\n-                &self.basic_coverage_blocks,\n-                self.pass_name,\n-                &coverage_spans,\n-            );\n-        }\n-\n-        self.inject_coverage_span_counters(coverage_spans);\n-    }\n-\n-    /// Inject a counter for each `CoverageSpan`. There can be multiple `CoverageSpan`s for a given\n-    /// BCB, but only one actual counter needs to be incremented per BCB. `bcb_counters` maps each\n-    /// `bcb` to its `Counter`, when injected. Subsequent `CoverageSpan`s for a BCB that already has\n-    /// a `Counter` will inject an `Expression` instead, and compute its value by adding `ZERO` to\n-    /// the BCB `Counter` value.\n-    fn inject_coverage_span_counters(&mut self, coverage_spans: Vec<CoverageSpan>) {\n-        let tcx = self.tcx;\n-        let source_map = tcx.sess.source_map();\n-        let body_span = self.body_span;\n-        let source_file = source_map.lookup_source_file(body_span.lo());\n-        let file_name = Symbol::intern(&source_file.name.to_string());\n-\n-        let mut bb_counters = IndexVec::from_elem_n(None, self.mir_body.basic_blocks().len());\n-        for CoverageSpan { span, bcb_leader_bb: bb, .. } in coverage_spans {\n-            if let Some(&counter_operand) = bb_counters[bb].as_ref() {\n-                let expression = self.coverage_counters.make_expression(\n-                    counter_operand,\n-                    Op::Add,\n-                    ExpressionOperandId::ZERO,\n-                );\n-                debug!(\n-                    \"Injecting counter expression {:?} at: {:?}:\\n{}\\n==========\",\n-                    expression,\n-                    span,\n-                    source_map.span_to_snippet(span).expect(\"Error getting source for span\"),\n-                );\n-                let code_region = make_code_region(file_name, &source_file, span, body_span);\n-                inject_statement(self.mir_body, expression, bb, Some(code_region));\n-            } else {\n-                let counter = self.coverage_counters.make_counter();\n-                debug!(\n-                    \"Injecting counter {:?} at: {:?}:\\n{}\\n==========\",\n-                    counter,\n-                    span,\n-                    source_map.span_to_snippet(span).expect(\"Error getting source for span\"),\n-                );\n-                let counter_operand = counter.as_operand_id();\n-                bb_counters[bb] = Some(counter_operand);\n-                let code_region = make_code_region(file_name, &source_file, span, body_span);\n-                inject_statement(self.mir_body, counter, bb, Some(code_region));\n-            }\n-        }\n-    }\n-}\n-\n-/// Generates the MIR pass `CoverageSpan`-specific spanview dump file.\n-fn dump_coverage_spanview(\n-    tcx: TyCtxt<'tcx>,\n-    mir_body: &mir::Body<'tcx>,\n-    basic_coverage_blocks: &BasicCoverageBlocks,\n-    pass_name: &str,\n-    coverage_spans: &Vec<CoverageSpan>,\n-) {\n-    let mir_source = mir_body.source;\n-    let def_id = mir_source.def_id();\n-\n-    let span_viewables = span_viewables(tcx, mir_body, basic_coverage_blocks, &coverage_spans);\n-    let mut file = pretty::create_dump_file(tcx, \"html\", None, pass_name, &0, mir_source)\n-        .expect(\"Unexpected error creating MIR spanview HTML file\");\n-    let crate_name = tcx.crate_name(def_id.krate);\n-    let item_name = tcx.def_path(def_id).to_filename_friendly_no_crate();\n-    let title = format!(\"{}.{} - Coverage Spans\", crate_name, item_name);\n-    spanview::write_document(tcx, def_id, span_viewables, &title, &mut file)\n-        .expect(\"Unexpected IO error dumping coverage spans as HTML\");\n-}\n-\n-/// Converts the computed `BasicCoverageBlock`s into `SpanViewable`s.\n-fn span_viewables(\n-    tcx: TyCtxt<'tcx>,\n-    mir_body: &mir::Body<'tcx>,\n-    basic_coverage_blocks: &BasicCoverageBlocks,\n-    coverage_spans: &Vec<CoverageSpan>,\n-) -> Vec<SpanViewable> {\n-    let mut span_viewables = Vec::new();\n-    for coverage_span in coverage_spans {\n-        let tooltip = coverage_span.format_coverage_statements(tcx, mir_body);\n-        let CoverageSpan { span, bcb_leader_bb: bb, .. } = coverage_span;\n-        let bcb = &basic_coverage_blocks[*bb];\n-        let id = bcb.id();\n-        let leader_bb = bcb.leader_bb();\n-        span_viewables.push(SpanViewable { bb: leader_bb, span: *span, id, tooltip });\n-    }\n-    span_viewables\n-}\n-\n-/// Manages the counter and expression indexes/IDs to generate `CoverageKind` components for MIR\n-/// `Coverage` statements.\n-struct CoverageCounters {\n-    function_source_hash: u64,\n-    next_counter_id: u32,\n-    num_expressions: u32,\n-}\n-\n-impl CoverageCounters {\n-    pub fn new(function_source_hash: u64) -> Self {\n-        Self {\n-            function_source_hash,\n-            next_counter_id: CounterValueReference::START.as_u32(),\n-            num_expressions: 0,\n-        }\n-    }\n-\n-    pub fn make_counter(&mut self) -> CoverageKind {\n-        CoverageKind::Counter {\n-            function_source_hash: self.function_source_hash,\n-            id: self.next_counter(),\n-        }\n-    }\n-\n-    pub fn make_expression(\n-        &mut self,\n-        lhs: ExpressionOperandId,\n-        op: Op,\n-        rhs: ExpressionOperandId,\n-    ) -> CoverageKind {\n-        let id = self.next_expression();\n-        CoverageKind::Expression { id, lhs, op, rhs }\n-    }\n-\n-    /// Counter IDs start from one and go up.\n-    fn next_counter(&mut self) -> CounterValueReference {\n-        assert!(self.next_counter_id < u32::MAX - self.num_expressions);\n-        let next = self.next_counter_id;\n-        self.next_counter_id += 1;\n-        CounterValueReference::from(next)\n-    }\n-\n-    /// Expression IDs start from u32::MAX and go down because a Expression can reference\n-    /// (add or subtract counts) of both Counter regions and Expression regions. The counter\n-    /// expression operand IDs must be unique across both types.\n-    fn next_expression(&mut self) -> InjectedExpressionId {\n-        assert!(self.next_counter_id < u32::MAX - self.num_expressions);\n-        let next = u32::MAX - self.num_expressions;\n-        self.num_expressions += 1;\n-        InjectedExpressionId::from(next)\n-    }\n-}\n-fn inject_statement(\n-    mir_body: &mut mir::Body<'tcx>,\n-    counter_kind: CoverageKind,\n-    bb: BasicBlock,\n-    some_code_region: Option<CodeRegion>,\n-) {\n-    debug!(\n-        \"  injecting statement {:?} for {:?} at code region: {:?}\",\n-        counter_kind, bb, some_code_region\n-    );\n-    let data = &mut mir_body[bb];\n-    let source_info = data.terminator().source_info;\n-    let statement = Statement {\n-        source_info,\n-        kind: StatementKind::Coverage(box Coverage {\n-            kind: counter_kind,\n-            code_region: some_code_region,\n-        }),\n-    };\n-    data.statements.push(statement);\n-}\n-\n /// Converts the initial set of `CoverageSpan`s (one per MIR `Statement` or `Terminator`) into a\n /// minimal set of `CoverageSpan`s, using the BCB CFG to determine where it is safe and useful to:\n ///\n@@ -818,7 +210,7 @@ pub struct CoverageSpans<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n-    fn generate_coverage_spans(\n+    pub(crate) fn generate_coverage_spans(\n         mir_body: &'a mir::Body<'tcx>,\n         body_span: Span,\n         basic_coverage_blocks: &'a BasicCoverageBlocks,\n@@ -1366,111 +758,3 @@ fn is_goto(term_kind: &TerminatorKind<'tcx>) -> bool {\n         _ => false,\n     }\n }\n-\n-/// Convert the Span into its file name, start line and column, and end line and column\n-fn make_code_region(\n-    file_name: Symbol,\n-    source_file: &Lrc<SourceFile>,\n-    span: Span,\n-    body_span: Span,\n-) -> CodeRegion {\n-    let (start_line, mut start_col) = source_file.lookup_file_pos(span.lo());\n-    let (end_line, end_col) = if span.hi() == span.lo() {\n-        let (end_line, mut end_col) = (start_line, start_col);\n-        // Extend an empty span by one character so the region will be counted.\n-        let CharPos(char_pos) = start_col;\n-        if span.hi() == body_span.hi() {\n-            start_col = CharPos(char_pos - 1);\n-        } else {\n-            end_col = CharPos(char_pos + 1);\n-        }\n-        (end_line, end_col)\n-    } else {\n-        source_file.lookup_file_pos(span.hi())\n-    };\n-    CodeRegion {\n-        file_name,\n-        start_line: start_line as u32,\n-        start_col: start_col.to_u32() + 1,\n-        end_line: end_line as u32,\n-        end_col: end_col.to_u32() + 1,\n-    }\n-}\n-\n-fn hir_body<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx rustc_hir::Body<'tcx> {\n-    let hir_node = tcx.hir().get_if_local(def_id).expect(\"expected DefId is local\");\n-    let fn_body_id = hir::map::associated_body(hir_node).expect(\"HIR node is a function with body\");\n-    tcx.hir().body(fn_body_id)\n-}\n-\n-fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, hir_body: &'tcx rustc_hir::Body<'tcx>) -> u64 {\n-    let mut hcx = tcx.create_no_span_stable_hashing_context();\n-    hash(&mut hcx, &hir_body.value).to_smaller_hash()\n-}\n-\n-fn hash(\n-    hcx: &mut StableHashingContext<'tcx>,\n-    node: &impl HashStable<StableHashingContext<'tcx>>,\n-) -> Fingerprint {\n-    let mut stable_hasher = StableHasher::new();\n-    node.hash_stable(hcx, &mut stable_hasher);\n-    stable_hasher.finish()\n-}\n-\n-pub struct ShortCircuitPreorder<\n-    'a,\n-    'tcx,\n-    F: Fn(&'tcx TerminatorKind<'tcx>) -> mir::Successors<'tcx>,\n-> {\n-    body: &'a mir::Body<'tcx>,\n-    visited: BitSet<BasicBlock>,\n-    worklist: Vec<BasicBlock>,\n-    filtered_successors: F,\n-}\n-\n-impl<'a, 'tcx, F: Fn(&'tcx TerminatorKind<'tcx>) -> mir::Successors<'tcx>>\n-    ShortCircuitPreorder<'a, 'tcx, F>\n-{\n-    pub fn new(\n-        body: &'a mir::Body<'tcx>,\n-        filtered_successors: F,\n-    ) -> ShortCircuitPreorder<'a, 'tcx, F> {\n-        let worklist = vec![mir::START_BLOCK];\n-\n-        ShortCircuitPreorder {\n-            body,\n-            visited: BitSet::new_empty(body.basic_blocks().len()),\n-            worklist,\n-            filtered_successors,\n-        }\n-    }\n-}\n-\n-impl<'a: 'tcx, 'tcx, F: Fn(&'tcx TerminatorKind<'tcx>) -> mir::Successors<'tcx>> Iterator\n-    for ShortCircuitPreorder<'a, 'tcx, F>\n-{\n-    type Item = (BasicBlock, &'a BasicBlockData<'tcx>);\n-\n-    fn next(&mut self) -> Option<(BasicBlock, &'a BasicBlockData<'tcx>)> {\n-        while let Some(idx) = self.worklist.pop() {\n-            if !self.visited.insert(idx) {\n-                continue;\n-            }\n-\n-            let data = &self.body[idx];\n-\n-            if let Some(ref term) = data.terminator {\n-                self.worklist.extend((self.filtered_successors)(&term.kind));\n-            }\n-\n-            return Some((idx, data));\n-        }\n-\n-        None\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let size = self.body.basic_blocks().len() - self.visited.count();\n-        (size, Some(size))\n-    }\n-}", "previous_filename": "compiler/rustc_mir/src/transform/instrument_coverage.rs"}, {"sha": "e3fea2d2701e5a461c8b7b9548e21ea778552ec4", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=c7ae4c2cb6d7e58ad0f9c12047e3d747c26a9d71", "patch": "@@ -22,6 +22,7 @@ pub mod check_packed_ref;\n pub mod check_unsafety;\n pub mod cleanup_post_borrowck;\n pub mod const_prop;\n+pub mod coverage;\n pub mod deaggregator;\n pub mod dest_prop;\n pub mod dump_mir;\n@@ -31,7 +32,6 @@ pub mod function_item_references;\n pub mod generator;\n pub mod inline;\n pub mod instcombine;\n-pub mod instrument_coverage;\n pub mod match_branches;\n pub mod multiple_return_terminators;\n pub mod no_landing_pads;\n@@ -85,7 +85,7 @@ pub(crate) fn provide(providers: &mut Providers) {\n         },\n         ..*providers\n     };\n-    instrument_coverage::provide(providers);\n+    coverage::query::provide(providers);\n }\n \n fn is_mir_available(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n@@ -306,7 +306,7 @@ fn mir_promoted(\n     ];\n \n     let opt_coverage: &[&dyn MirPass<'tcx>] = if tcx.sess.opts.debugging_opts.instrument_coverage {\n-        &[&instrument_coverage::InstrumentCoverage]\n+        &[&coverage::InstrumentCoverage]\n     } else {\n         &[]\n     };"}]}