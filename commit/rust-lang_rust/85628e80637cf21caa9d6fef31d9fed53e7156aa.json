{"sha": "85628e80637cf21caa9d6fef31d9fed53e7156aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1NjI4ZTgwNjM3Y2YyMWNhYTlkNmZlZjMxZDlmZWQ1M2U3MTU2YWE=", "commit": {"author": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2019-10-17T16:10:35Z"}, "committer": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2019-10-17T16:10:35Z"}, "message": "Add more explaining comments to the code", "tree": {"sha": "9b42ccbbdeb2a1d02fd36f06fba4e4552817eb2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b42ccbbdeb2a1d02fd36f06fba4e4552817eb2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85628e80637cf21caa9d6fef31d9fed53e7156aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85628e80637cf21caa9d6fef31d9fed53e7156aa", "html_url": "https://github.com/rust-lang/rust/commit/85628e80637cf21caa9d6fef31d9fed53e7156aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85628e80637cf21caa9d6fef31d9fed53e7156aa/comments", "author": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddc6a5fd0e3e56f2ccbc576fdeed149579f141de", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddc6a5fd0e3e56f2ccbc576fdeed149579f141de", "html_url": "https://github.com/rust-lang/rust/commit/ddc6a5fd0e3e56f2ccbc576fdeed149579f141de"}], "stats": {"total": 162, "additions": 94, "deletions": 68}, "files": [{"sha": "e17030726ceaa0e721b828bcdcc7a349602a72b6", "filename": "src/libtest/console.rs", "status": "modified", "additions": 81, "deletions": 67, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/85628e80637cf21caa9d6fef31d9fed53e7156aa/src%2Flibtest%2Fconsole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85628e80637cf21caa9d6fef31d9fed53e7156aa/src%2Flibtest%2Fconsole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fconsole.rs?ref=85628e80637cf21caa9d6fef31d9fed53e7156aa", "patch": "@@ -7,21 +7,23 @@ use std::io;\n use term;\n \n use super::{\n+    bench::fmt_bench_samples,\n+    cli::TestOpts,\n+    event::{TestEvent, CompletedTest},\n+    formatters::{JsonFormatter, OutputFormatter, PrettyFormatter, TerseFormatter},\n     helpers::{\n         concurrency::get_concurrency,\n         metrics::MetricMap,\n     },\n     types::{TestDesc, TestDescAndFn, NamePadding},\n     options::{Options, OutputFormat},\n-    bench::fmt_bench_samples,\n     test_result::TestResult,\n     time::TestExecTime,\n-    cli::TestOpts,\n-    event::TestEvent,\n     run_tests,\n     filter_tests,\n };\n \n+/// Generic wrapper over stdout.\n pub enum OutputLocation<T> {\n     Pretty(Box<term::StdoutTerminal>),\n     Raw(T),\n@@ -43,8 +45,6 @@ impl<T: Write> Write for OutputLocation<T> {\n     }\n }\n \n-use crate::formatters::{JsonFormatter, OutputFormatter, PrettyFormatter, TerseFormatter};\n-\n pub struct ConsoleTestState {\n     pub log_out: Option<File>,\n     pub total: usize,\n@@ -190,65 +190,77 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n     Ok(())\n }\n \n-// A simple console test runner\n-pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<bool> {\n-    // A callback handling events that occure during test execution.\n-    fn on_test_event(\n-        event: &TestEvent,\n-        st: &mut ConsoleTestState,\n-        out: &mut dyn OutputFormatter,\n-    ) -> io::Result<()> {\n-        match (*event).clone() {\n-            TestEvent::TeFiltered(ref filtered_tests) => {\n-                st.total = filtered_tests.len();\n-                out.write_run_start(filtered_tests.len())\n-            }\n-            TestEvent::TeFilteredOut(filtered_out) => Ok(st.filtered_out = filtered_out),\n-            TestEvent::TeWait(ref test) => out.write_test_start(test),\n-            TestEvent::TeTimeout(ref test) => out.write_timeout(test),\n-            TestEvent::TeResult(completed_test) => {\n-                let test = completed_test.desc;\n-                let result = &completed_test.result;\n-                let exec_time = &completed_test.exec_time;\n-                let stdout = completed_test.stdout;\n-\n-                st.write_log_result(&test, result, exec_time.as_ref())?;\n-                out.write_result(&test, result, exec_time.as_ref(), &*stdout, st)?;\n-                match result {\n-                    TestResult::TrOk => {\n-                        st.passed += 1;\n-                        st.not_failures.push((test, stdout));\n-                    }\n-                    TestResult::TrIgnored => st.ignored += 1,\n-                    TestResult::TrAllowedFail => st.allowed_fail += 1,\n-                    TestResult::TrBench(bs) => {\n-                        st.metrics.insert_metric(\n-                            test.name.as_slice(),\n-                            bs.ns_iter_summ.median,\n-                            bs.ns_iter_summ.max - bs.ns_iter_summ.min,\n-                        );\n-                        st.measured += 1\n-                    }\n-                    TestResult::TrFailed => {\n-                        st.failed += 1;\n-                        st.failures.push((test, stdout));\n-                    }\n-                    TestResult::TrFailedMsg(msg) => {\n-                        st.failed += 1;\n-                        let mut stdout = stdout;\n-                        stdout.extend_from_slice(format!(\"note: {}\", msg).as_bytes());\n-                        st.failures.push((test, stdout));\n-                    }\n-                    TestResult::TrTimedFail => {\n-                        st.failed += 1;\n-                        st.time_failures.push((test, stdout));\n-                    }\n-                }\n-                Ok(())\n-            }\n+// Updates `ConsoleTestState` depending on result of the test execution.\n+fn handle_test_result(st: &mut ConsoleTestState, completed_test: CompletedTest) {\n+    let test = completed_test.desc;\n+    let stdout = completed_test.stdout;\n+    match completed_test.result {\n+        TestResult::TrOk => {\n+            st.passed += 1;\n+            st.not_failures.push((test, stdout));\n+        }\n+        TestResult::TrIgnored => st.ignored += 1,\n+        TestResult::TrAllowedFail => st.allowed_fail += 1,\n+        TestResult::TrBench(bs) => {\n+            st.metrics.insert_metric(\n+                test.name.as_slice(),\n+                bs.ns_iter_summ.median,\n+                bs.ns_iter_summ.max - bs.ns_iter_summ.min,\n+            );\n+            st.measured += 1\n+        }\n+        TestResult::TrFailed => {\n+            st.failed += 1;\n+            st.failures.push((test, stdout));\n+        }\n+        TestResult::TrFailedMsg(msg) => {\n+            st.failed += 1;\n+            let mut stdout = stdout;\n+            stdout.extend_from_slice(format!(\"note: {}\", msg).as_bytes());\n+            st.failures.push((test, stdout));\n+        }\n+        TestResult::TrTimedFail => {\n+            st.failed += 1;\n+            st.time_failures.push((test, stdout));\n+        }\n+    }\n+}\n+\n+// Handler for events that occur during test execution.\n+// It is provided as a callback to the `run_tests` function.\n+fn on_test_event(\n+    event: &TestEvent,\n+    st: &mut ConsoleTestState,\n+    out: &mut dyn OutputFormatter,\n+) -> io::Result<()> {\n+    match (*event).clone() {\n+        TestEvent::TeFiltered(ref filtered_tests) => {\n+            st.total = filtered_tests.len();\n+            out.write_run_start(filtered_tests.len())?;\n+        }\n+        TestEvent::TeFilteredOut(filtered_out) => {\n+            st.filtered_out = filtered_out;\n+        }\n+        TestEvent::TeWait(ref test) => out.write_test_start(test)?,\n+        TestEvent::TeTimeout(ref test) => out.write_timeout(test)?,\n+        TestEvent::TeResult(completed_test) => {\n+            let test = &completed_test.desc;\n+            let result = &completed_test.result;\n+            let exec_time = &completed_test.exec_time;\n+            let stdout = &completed_test.stdout;\n+\n+            st.write_log_result(test, result, exec_time.as_ref())?;\n+            out.write_result(test, result, exec_time.as_ref(), &*stdout, st)?;\n+            handle_test_result(st, completed_test);\n         }\n     }\n \n+    Ok(())\n+}\n+\n+/// A simple console test runner.\n+/// Runs provided tests reporting process and results to the stdout.\n+pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<bool> {\n     let output = match term::stdout() {\n         None => OutputLocation::Raw(io::stdout()),\n         Some(t) => OutputLocation::Pretty(t),\n@@ -279,16 +291,18 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n         OutputFormat::Json => Box::new(JsonFormatter::new(output)),\n     };\n     let mut st = ConsoleTestState::new(opts)?;\n-    fn len_if_padded(t: &TestDescAndFn) -> usize {\n-        match t.testfn.padding() {\n-            NamePadding::PadNone => 0,\n-            NamePadding::PadOnRight => t.desc.name.as_slice().len(),\n-        }\n-    }\n \n     run_tests(opts, tests, |x| on_test_event(&x, &mut st, &mut *out))?;\n \n     assert!(st.current_test_count() == st.total);\n \n     return out.write_run_finish(&st);\n }\n+\n+// Calculates padding for given test description.\n+fn len_if_padded(t: &TestDescAndFn) -> usize {\n+    match t.testfn.padding() {\n+        NamePadding::PadNone => 0,\n+        NamePadding::PadOnRight => t.desc.name.as_slice().len(),\n+    }\n+}"}, {"sha": "ec87b0fcd463b58ef2a4dccb2cddc8a8043d2730", "filename": "src/libtest/options.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/85628e80637cf21caa9d6fef31d9fed53e7156aa/src%2Flibtest%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85628e80637cf21caa9d6fef31d9fed53e7156aa/src%2Flibtest%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Foptions.rs?ref=85628e80637cf21caa9d6fef31d9fed53e7156aa", "patch": "@@ -7,37 +7,46 @@ pub enum Concurrent {\n     No,\n }\n \n+/// Number of times to run a benchmarked function\n #[derive(Clone, PartialEq, Eq)]\n pub enum BenchMode {\n     Auto,\n     Single,\n }\n \n+/// Whether test is expected to panic or not\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum ShouldPanic {\n     No,\n     Yes,\n     YesWithMessage(&'static str),\n }\n \n+/// Whether should console output be colored or not\n #[derive(Copy, Clone, Debug)]\n pub enum ColorConfig {\n     AutoColor,\n     AlwaysColor,\n     NeverColor,\n }\n \n+/// Format of the test results output\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum OutputFormat {\n+    /// Verbose output\n     Pretty,\n+    /// Quiet output\n     Terse,\n+    /// JSON output\n     Json,\n }\n \n+/// Whether ignored test should be runned or not\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum RunIgnored {\n     Yes,\n     No,\n+    /// Run only ignored tests\n     Only,\n }\n \n@@ -53,6 +62,7 @@ pub enum RunStrategy {\n     SpawnPrimary,\n }\n \n+/// Options for the test run defined by the caller (instead of CLI arguments).\n /// In case we want to add other options as well, just add them in this struct.\n #[derive(Copy, Clone, Debug)]\n pub struct Options {"}, {"sha": "dd4dfd9997f0963af60ec81ce07309d29dc952d8", "filename": "src/libtest/test_result.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85628e80637cf21caa9d6fef31d9fed53e7156aa/src%2Flibtest%2Ftest_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85628e80637cf21caa9d6fef31d9fed53e7156aa/src%2Flibtest%2Ftest_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftest_result.rs?ref=85628e80637cf21caa9d6fef31d9fed53e7156aa", "patch": "@@ -27,7 +27,8 @@ pub enum TestResult {\n \n unsafe impl Send for TestResult {}\n \n-\n+/// Creates a `TestResult` depending on the raw result of test execution\n+/// and assotiated data.\n pub fn calc_result<'a>(\n     desc: &TestDesc,\n     task_result: Result<(), &'a (dyn Any + 'static + Send)>,\n@@ -73,6 +74,7 @@ pub fn calc_result<'a>(\n     result\n }\n \n+/// Creates a `TestResult` depending on the exit code of test subprocess.\n pub fn get_result_from_exit_code(\n     desc: &TestDesc,\n     code: i32,"}]}