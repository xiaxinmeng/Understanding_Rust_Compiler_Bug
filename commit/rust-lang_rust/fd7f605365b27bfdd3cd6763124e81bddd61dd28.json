{"sha": "fd7f605365b27bfdd3cd6763124e81bddd61dd28", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkN2Y2MDUzNjViMjdiZmRkM2NkNjc2MzEyNGU4MWJkZGQ2MWRkMjg=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-04-04T04:46:33Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-04-05T01:26:09Z"}, "message": "Increase `Span` from 4 bytes to 8 bytes.\n\nThis increases the size of some important types, such as `ast::Expr` and\n`mir::Statement`. However, it drastically reduces how much the interner\nis used, and the fields are more natural sizes that don't require bit\noperations to extract.\n\nAs a result, instruction counts drop across a range of workloads, by as\nmuch as 12% for incremental \"check\" builds of `script-servo`.\n\nPeak memory usage goes up a little for some cases, but down by more for\nsome other cases -- as much as 18% for non-incremental builds of\n`packed-simd`.\n\nThe commit also:\n- removes the `repr(packed)`, because it has negligible effect, but can\n  cause undefined behaviour;\n- replaces explicit impls of common traits (`Copy`, `PartialEq`, etc.)\n  with derived ones.", "tree": {"sha": "f42ba7fafa06245fd788902040dc1554dfba607c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f42ba7fafa06245fd788902040dc1554dfba607c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd7f605365b27bfdd3cd6763124e81bddd61dd28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd7f605365b27bfdd3cd6763124e81bddd61dd28", "html_url": "https://github.com/rust-lang/rust/commit/fd7f605365b27bfdd3cd6763124e81bddd61dd28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd7f605365b27bfdd3cd6763124e81bddd61dd28/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "314a79cd80ed905f80d24b79fd7acb4c8c72789b", "url": "https://api.github.com/repos/rust-lang/rust/commits/314a79cd80ed905f80d24b79fd7acb4c8c72789b", "html_url": "https://github.com/rust-lang/rust/commit/314a79cd80ed905f80d24b79fd7acb4c8c72789b"}], "stats": {"total": 193, "additions": 90, "deletions": 103}, "files": [{"sha": "3cab7a3812f2a2d963c923dc6f9564d0df25cf01", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd7f605365b27bfdd3cd6763124e81bddd61dd28/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd7f605365b27bfdd3cd6763124e81bddd61dd28/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=fd7f605365b27bfdd3cd6763124e81bddd61dd28", "patch": "@@ -1735,7 +1735,7 @@ pub struct Statement<'tcx> {\n \n // `Statement` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert!(MEM_SIZE_OF_STATEMENT: mem::size_of::<Statement<'_>>() == 48);\n+static_assert!(MEM_SIZE_OF_STATEMENT: mem::size_of::<Statement<'_>>() == 56);\n \n impl<'tcx> Statement<'tcx> {\n     /// Changes a statement to a nop. This is both faster than deleting instructions and avoids"}, {"sha": "cf909e30e322abfffc91f5621d41d65118cb9e85", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd7f605365b27bfdd3cd6763124e81bddd61dd28/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd7f605365b27bfdd3cd6763124e81bddd61dd28/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=fd7f605365b27bfdd3cd6763124e81bddd61dd28", "patch": "@@ -946,7 +946,7 @@ pub struct Expr {\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert!(MEM_SIZE_OF_EXPR: std::mem::size_of::<Expr>() == 88);\n+static_assert!(MEM_SIZE_OF_EXPR: std::mem::size_of::<Expr>() == 96);\n \n impl Expr {\n     /// Whether this expression would be valid somewhere that expects a value; for example, an `if`"}, {"sha": "1ffecea44edf2b6065c89cdbeb6a3496390afca7", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd7f605365b27bfdd3cd6763124e81bddd61dd28/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd7f605365b27bfdd3cd6763124e81bddd61dd28/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=fd7f605365b27bfdd3cd6763124e81bddd61dd28", "patch": "@@ -218,14 +218,17 @@ pub fn clear_markings() {\n }\n \n impl SyntaxContext {\n+    #[inline]\n     pub const fn empty() -> Self {\n         SyntaxContext(0)\n     }\n \n+    #[inline]\n     crate fn as_u32(self) -> u32 {\n         self.0\n     }\n \n+    #[inline]\n     crate fn from_u32(raw: u32) -> SyntaxContext {\n         SyntaxContext(raw)\n     }"}, {"sha": "525ec13623289e50c3f6921cdeabac851a1f3612", "filename": "src/libsyntax_pos/span_encoding.rs", "status": "modified", "additions": 85, "deletions": 101, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/fd7f605365b27bfdd3cd6763124e81bddd61dd28/src%2Flibsyntax_pos%2Fspan_encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd7f605365b27bfdd3cd6763124e81bddd61dd28/src%2Flibsyntax_pos%2Fspan_encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fspan_encoding.rs?ref=fd7f605365b27bfdd3cd6763124e81bddd61dd28", "patch": "@@ -9,122 +9,106 @@ use crate::{BytePos, SpanData};\n use crate::hygiene::SyntaxContext;\n \n use rustc_data_structures::fx::FxHashMap;\n-use std::hash::{Hash, Hasher};\n \n /// A compressed span.\n-/// Contains either fields of `SpanData` inline if they are small, or index into span interner.\n-/// The primary goal of `Span` is to be as small as possible and fit into other structures\n-/// (that's why it uses `packed` as well). Decoding speed is the second priority.\n-/// See `SpanData` for the info on span fields in decoded representation.\n-#[repr(packed)]\n-pub struct Span(u32);\n-\n-impl Copy for Span {}\n-impl Clone for Span {\n-    #[inline]\n-    fn clone(&self) -> Span {\n-        *self\n-    }\n-}\n-impl PartialEq for Span {\n-    #[inline]\n-    fn eq(&self, other: &Span) -> bool {\n-        let a = self.0;\n-        let b = other.0;\n-        a == b\n-    }\n-}\n-impl Eq for Span {}\n-impl Hash for Span {\n-    #[inline]\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        let a = self.0;\n-        a.hash(state)\n-    }\n+///\n+/// `SpanData` is 12 bytes, which is a bit too big to stick everywhere. `Span`\n+/// is a form that only takes up 8 bytes, with less space for the length and\n+/// context. The vast majority (99.9%+) of `SpanData` instances will fit within\n+/// those 8 bytes; any `SpanData` whose fields don't fit into a `Span` are\n+/// stored in a separate interner table, and the `Span` will index into that\n+/// table. Interning is rare enough that the cost is low, but common enough\n+/// that the code is exercised regularly.\n+///\n+/// An earlier version of this code used only 4 bytes for `Span`, but that was\n+/// slower because only 80--90% of spans could be stored inline (even less in\n+/// very large crates) and so the interner was used a lot more.\n+///\n+/// Inline (compressed) format:\n+/// - `span.base_or_index == span_data.lo`\n+/// - `span.len_or_tag == len == span_data.hi - span_data.lo` (must be `<= MAX_LEN`)\n+/// - `span.ctxt == span_data.ctxt` (must be `<= MAX_CTXT`)\n+///\n+/// Interned format:\n+/// - `span.base_or_index == index` (indexes into the interner table)\n+/// - `span.len_or_tag == LEN_TAG` (high bit set, all other bits are zero)\n+/// - `span.ctxt == 0`\n+///\n+/// The inline form uses 0 for the tag value (rather than 1) so that we don't\n+/// need to mask out the tag bit when getting the length, and so that the\n+/// dummy span can be all zeroes.\n+///\n+/// Notes about the choice of field sizes:\n+/// - `base` is 32 bits in both `Span` and `SpanData`, which means that `base`\n+///   values never cause interning. The number of bits needed for `base`\n+///   depends on the crate size. 32 bits allows up to 4 GiB of code in a crate.\n+///   `script-servo` is the largest crate in `rustc-perf`, requiring 26 bits\n+///   for some spans.\n+/// - `len` is 15 bits in `Span` (a u16, minus 1 bit for the tag) and 32 bits\n+///   in `SpanData`, which means that large `len` values will cause interning.\n+///   The number of bits needed for `len` does not depend on the crate size.\n+///   The most common number of bits for `len` are 0--7, with a peak usually at\n+///   3 or 4, and then it drops off quickly from 8 onwards. 15 bits is enough\n+///   for 99.99%+ of cases, but larger values (sometimes 20+ bits) might occur\n+///   dozens of times in a typical crate.\n+/// - `ctxt` is 16 bits in `Span` and 32 bits in `SpanData`, which means that\n+///   large `ctxt` values will cause interning. The number of bits needed for\n+///   `ctxt` values depend partly on the crate size and partly on the form of\n+///   the code. No crates in `rustc-perf` need more than 15 bits for `ctxt`,\n+///   but larger crates might need more than 16 bits.\n+///\n+#[derive(Clone, Copy, Eq, PartialEq, Hash)]\n+pub struct Span {\n+    base_or_index: u32,\n+    len_or_tag: u16,\n+    ctxt_or_zero: u16\n }\n \n+const LEN_TAG: u16 = 0b1000_0000_0000_0000;\n+const MAX_LEN: u32 = 0b0111_1111_1111_1111;\n+const MAX_CTXT: u32 = 0b1111_1111_1111_1111;\n+\n /// Dummy span, both position and length are zero, syntax context is zero as well.\n-/// This span is kept inline and encoded with format 0.\n-pub const DUMMY_SP: Span = Span(0);\n+pub const DUMMY_SP: Span = Span { base_or_index: 0, len_or_tag: 0, ctxt_or_zero: 0 };\n \n impl Span {\n     #[inline]\n-    pub fn new(lo: BytePos, hi: BytePos, ctxt: SyntaxContext) -> Self {\n-        encode(&match lo <= hi {\n-            true => SpanData { lo, hi, ctxt },\n-            false => SpanData { lo: hi, hi: lo, ctxt },\n-        })\n+    pub fn new(mut lo: BytePos, mut hi: BytePos, ctxt: SyntaxContext) -> Self {\n+        if lo > hi {\n+            std::mem::swap(&mut lo, &mut hi);\n+        }\n+\n+        let (base, len, ctxt2) = (lo.0, hi.0 - lo.0, ctxt.as_u32());\n+\n+        if len <= MAX_LEN && ctxt2 <= MAX_CTXT {\n+            // Inline format.\n+            Span { base_or_index: base, len_or_tag: len as u16, ctxt_or_zero: ctxt2 as u16 }\n+        } else {\n+            // Interned format.\n+            let index = with_span_interner(|interner| interner.intern(&SpanData { lo, hi, ctxt }));\n+            Span { base_or_index: index, len_or_tag: LEN_TAG, ctxt_or_zero: 0 }\n+        }\n     }\n \n     #[inline]\n     pub fn data(self) -> SpanData {\n-        decode(self)\n+        if self.len_or_tag != LEN_TAG {\n+            // Inline format.\n+            debug_assert!(self.len_or_tag as u32 <= MAX_LEN);\n+            SpanData {\n+                lo: BytePos(self.base_or_index),\n+                hi: BytePos(self.base_or_index + self.len_or_tag as u32),\n+                ctxt: SyntaxContext::from_u32(self.ctxt_or_zero as u32),\n+            }\n+        } else {\n+            // Interned format.\n+            debug_assert!(self.ctxt_or_zero == 0);\n+            let index = self.base_or_index;\n+            with_span_interner(|interner| *interner.get(index))\n+        }\n     }\n }\n \n-// Tags\n-const TAG_INLINE: u32 = 0;\n-const TAG_INTERNED: u32 = 1;\n-const TAG_MASK: u32 = 1;\n-\n-// Fields indexes\n-const BASE_INDEX: usize = 0;\n-const LEN_INDEX: usize = 1;\n-const CTXT_INDEX: usize = 2;\n-\n-// Tag = 0, inline format.\n-// -------------------------------------------------------------\n-// | base 31:7  | len 6:1  | ctxt (currently 0 bits) | tag 0:0 |\n-// -------------------------------------------------------------\n-// Since there are zero bits for ctxt, only SpanData with a 0 SyntaxContext\n-// can be inline.\n-const INLINE_SIZES: [u32; 3] = [25, 6, 0];\n-const INLINE_OFFSETS: [u32; 3] = [7, 1, 1];\n-\n-// Tag = 1, interned format.\n-// ------------------------\n-// | index 31:1 | tag 0:0 |\n-// ------------------------\n-const INTERNED_INDEX_SIZE: u32 = 31;\n-const INTERNED_INDEX_OFFSET: u32 = 1;\n-\n-#[inline]\n-fn encode(sd: &SpanData) -> Span {\n-    let (base, len, ctxt) = (sd.lo.0, sd.hi.0 - sd.lo.0, sd.ctxt.as_u32());\n-\n-    let val = if (base >> INLINE_SIZES[BASE_INDEX]) == 0 &&\n-                 (len >> INLINE_SIZES[LEN_INDEX]) == 0 &&\n-                 (ctxt >> INLINE_SIZES[CTXT_INDEX]) == 0 {\n-        (base << INLINE_OFFSETS[BASE_INDEX]) | (len << INLINE_OFFSETS[LEN_INDEX]) |\n-        (ctxt << INLINE_OFFSETS[CTXT_INDEX]) | TAG_INLINE\n-    } else {\n-        let index = with_span_interner(|interner| interner.intern(sd));\n-        (index << INTERNED_INDEX_OFFSET) | TAG_INTERNED\n-    };\n-    Span(val)\n-}\n-\n-#[inline]\n-fn decode(span: Span) -> SpanData {\n-    let val = span.0;\n-\n-    // Extract a field at position `pos` having size `size`.\n-    let extract = |pos: u32, size: u32| {\n-        let mask = ((!0u32) as u64 >> (32 - size)) as u32; // Can't shift u32 by 32\n-        (val >> pos) & mask\n-    };\n-\n-    let (base, len, ctxt) = if val & TAG_MASK == TAG_INLINE {(\n-        extract(INLINE_OFFSETS[BASE_INDEX], INLINE_SIZES[BASE_INDEX]),\n-        extract(INLINE_OFFSETS[LEN_INDEX], INLINE_SIZES[LEN_INDEX]),\n-        extract(INLINE_OFFSETS[CTXT_INDEX], INLINE_SIZES[CTXT_INDEX]),\n-    )} else {\n-        let index = extract(INTERNED_INDEX_OFFSET, INTERNED_INDEX_SIZE);\n-        return with_span_interner(|interner| *interner.get(index));\n-    };\n-    SpanData { lo: BytePos(base), hi: BytePos(base + len), ctxt: SyntaxContext::from_u32(ctxt) }\n-}\n-\n #[derive(Default)]\n pub struct SpanInterner {\n     spans: FxHashMap<SpanData, u32>,"}]}