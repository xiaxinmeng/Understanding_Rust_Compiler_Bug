{"sha": "bbf0daa19276354d5759d0b0bd7d31bcd3cc301c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiZjBkYWExOTI3NjM1NGQ1NzU5ZDBiMGJkN2QzMWJjZDNjYzMwMWM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-06-16T09:56:33Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-06-30T05:21:26Z"}, "message": "Add parent_node to ast_map", "tree": {"sha": "5cedc8c228ac92bd58fba40ee67859a689764fe2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cedc8c228ac92bd58fba40ee67859a689764fe2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbf0daa19276354d5759d0b0bd7d31bcd3cc301c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbf0daa19276354d5759d0b0bd7d31bcd3cc301c", "html_url": "https://github.com/rust-lang/rust/commit/bbf0daa19276354d5759d0b0bd7d31bcd3cc301c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbf0daa19276354d5759d0b0bd7d31bcd3cc301c/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf", "html_url": "https://github.com/rust-lang/rust/commit/27975c49a643d0b2f8cbcd7854931c4c9a8c5dbf"}], "stats": {"total": 200, "additions": 133, "deletions": 67}, "files": [{"sha": "39ad2022183e479bf954807e4f9516e1b3c9bb05", "filename": "src/librustc/ast_map/mod.rs", "status": "modified", "additions": 133, "deletions": 67, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/bbf0daa19276354d5759d0b0bd7d31bcd3cc301c/src%2Flibrustc%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbf0daa19276354d5759d0b0bd7d31bcd3cc301c/src%2Flibrustc%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fast_map%2Fmod.rs?ref=bbf0daa19276354d5759d0b0bd7d31bcd3cc301c", "patch": "@@ -121,27 +121,28 @@ pub enum Node<'ast> {\n     NodeLifetime(&'ast Lifetime),\n }\n \n-/// Represents an entry and its parent Node ID\n+/// Represents an entry and its parent NodeID and parent_node NodeID, see\n+/// get_parent_node for the distinction.\n /// The odd layout is to bring down the total size.\n #[derive(Copy, Debug)]\n enum MapEntry<'ast> {\n     /// Placeholder for holes in the map.\n     NotPresent,\n \n-    /// All the node types, with a parent ID.\n-    EntryItem(NodeId, &'ast Item),\n-    EntryForeignItem(NodeId, &'ast ForeignItem),\n-    EntryTraitItem(NodeId, &'ast TraitItem),\n-    EntryImplItem(NodeId, &'ast ImplItem),\n-    EntryVariant(NodeId, &'ast Variant),\n-    EntryExpr(NodeId, &'ast Expr),\n-    EntryStmt(NodeId, &'ast Stmt),\n-    EntryArg(NodeId, &'ast Pat),\n-    EntryLocal(NodeId, &'ast Pat),\n-    EntryPat(NodeId, &'ast Pat),\n-    EntryBlock(NodeId, &'ast Block),\n-    EntryStructCtor(NodeId, &'ast StructDef),\n-    EntryLifetime(NodeId, &'ast Lifetime),\n+    /// All the node types, with a parent and scope ID.\n+    EntryItem(NodeId, NodeId, &'ast Item),\n+    EntryForeignItem(NodeId, NodeId, &'ast ForeignItem),\n+    EntryTraitItem(NodeId, NodeId, &'ast TraitItem),\n+    EntryImplItem(NodeId, NodeId, &'ast ImplItem),\n+    EntryVariant(NodeId, NodeId, &'ast Variant),\n+    EntryExpr(NodeId, NodeId, &'ast Expr),\n+    EntryStmt(NodeId, NodeId, &'ast Stmt),\n+    EntryArg(NodeId, NodeId, &'ast Pat),\n+    EntryLocal(NodeId, NodeId, &'ast Pat),\n+    EntryPat(NodeId, NodeId, &'ast Pat),\n+    EntryBlock(NodeId, NodeId, &'ast Block),\n+    EntryStructCtor(NodeId, NodeId, &'ast StructDef),\n+    EntryLifetime(NodeId, NodeId, &'ast Lifetime),\n \n     /// Roots for node trees.\n     RootCrate,\n@@ -161,58 +162,77 @@ struct InlinedParent {\n }\n \n impl<'ast> MapEntry<'ast> {\n-    fn from_node(p: NodeId, node: Node<'ast>) -> MapEntry<'ast> {\n+    fn from_node(p: NodeId, s: NodeId, node: Node<'ast>) -> MapEntry<'ast> {\n         match node {\n-            NodeItem(n) => EntryItem(p, n),\n-            NodeForeignItem(n) => EntryForeignItem(p, n),\n-            NodeTraitItem(n) => EntryTraitItem(p, n),\n-            NodeImplItem(n) => EntryImplItem(p, n),\n-            NodeVariant(n) => EntryVariant(p, n),\n-            NodeExpr(n) => EntryExpr(p, n),\n-            NodeStmt(n) => EntryStmt(p, n),\n-            NodeArg(n) => EntryArg(p, n),\n-            NodeLocal(n) => EntryLocal(p, n),\n-            NodePat(n) => EntryPat(p, n),\n-            NodeBlock(n) => EntryBlock(p, n),\n-            NodeStructCtor(n) => EntryStructCtor(p, n),\n-            NodeLifetime(n) => EntryLifetime(p, n)\n+            NodeItem(n) => EntryItem(p, s, n),\n+            NodeForeignItem(n) => EntryForeignItem(p, s, n),\n+            NodeTraitItem(n) => EntryTraitItem(p, s, n),\n+            NodeImplItem(n) => EntryImplItem(p, s, n),\n+            NodeVariant(n) => EntryVariant(p, s, n),\n+            NodeExpr(n) => EntryExpr(p, s, n),\n+            NodeStmt(n) => EntryStmt(p, s, n),\n+            NodeArg(n) => EntryArg(p, s, n),\n+            NodeLocal(n) => EntryLocal(p, s, n),\n+            NodePat(n) => EntryPat(p, s, n),\n+            NodeBlock(n) => EntryBlock(p, s, n),\n+            NodeStructCtor(n) => EntryStructCtor(p, s, n),\n+            NodeLifetime(n) => EntryLifetime(p, s, n)\n         }\n     }\n \n     fn parent(self) -> Option<NodeId> {\n         Some(match self {\n-            EntryItem(id, _) => id,\n-            EntryForeignItem(id, _) => id,\n-            EntryTraitItem(id, _) => id,\n-            EntryImplItem(id, _) => id,\n-            EntryVariant(id, _) => id,\n-            EntryExpr(id, _) => id,\n-            EntryStmt(id, _) => id,\n-            EntryArg(id, _) => id,\n-            EntryLocal(id, _) => id,\n-            EntryPat(id, _) => id,\n-            EntryBlock(id, _) => id,\n-            EntryStructCtor(id, _) => id,\n-            EntryLifetime(id, _) => id,\n+            EntryItem(id, _, _) => id,\n+            EntryForeignItem(id, _, _) => id,\n+            EntryTraitItem(id, _, _) => id,\n+            EntryImplItem(id, _, _) => id,\n+            EntryVariant(id, _, _) => id,\n+            EntryExpr(id, _, _) => id,\n+            EntryStmt(id, _, _) => id,\n+            EntryArg(id, _, _) => id,\n+            EntryLocal(id, _, _) => id,\n+            EntryPat(id, _, _) => id,\n+            EntryBlock(id, _, _) => id,\n+            EntryStructCtor(id, _, _) => id,\n+            EntryLifetime(id, _, _) => id,\n+            _ => return None\n+        })\n+    }\n+\n+    fn parent_node(self) -> Option<NodeId> {\n+        Some(match self {\n+            EntryItem(_, id, _) => id,\n+            EntryForeignItem(_, id, _) => id,\n+            EntryTraitItem(_, id, _) => id,\n+            EntryImplItem(_, id, _) => id,\n+            EntryVariant(_, id, _) => id,\n+            EntryExpr(_, id, _) => id,\n+            EntryStmt(_, id, _) => id,\n+            EntryArg(_, id, _) => id,\n+            EntryLocal(_, id, _) => id,\n+            EntryPat(_, id, _) => id,\n+            EntryBlock(_, id, _) => id,\n+            EntryStructCtor(_, id, _) => id,\n+            EntryLifetime(_, id, _) => id,\n             _ => return None\n         })\n     }\n \n     fn to_node(self) -> Option<Node<'ast>> {\n         Some(match self {\n-            EntryItem(_, n) => NodeItem(n),\n-            EntryForeignItem(_, n) => NodeForeignItem(n),\n-            EntryTraitItem(_, n) => NodeTraitItem(n),\n-            EntryImplItem(_, n) => NodeImplItem(n),\n-            EntryVariant(_, n) => NodeVariant(n),\n-            EntryExpr(_, n) => NodeExpr(n),\n-            EntryStmt(_, n) => NodeStmt(n),\n-            EntryArg(_, n) => NodeArg(n),\n-            EntryLocal(_, n) => NodeLocal(n),\n-            EntryPat(_, n) => NodePat(n),\n-            EntryBlock(_, n) => NodeBlock(n),\n-            EntryStructCtor(_, n) => NodeStructCtor(n),\n-            EntryLifetime(_, n) => NodeLifetime(n),\n+            EntryItem(_, _, n) => NodeItem(n),\n+            EntryForeignItem(_, _, n) => NodeForeignItem(n),\n+            EntryTraitItem(_, _, n) => NodeTraitItem(n),\n+            EntryImplItem(_, _, n) => NodeImplItem(n),\n+            EntryVariant(_, _, n) => NodeVariant(n),\n+            EntryExpr(_, _, n) => NodeExpr(n),\n+            EntryStmt(_, _, n) => NodeStmt(n),\n+            EntryArg(_, _, n) => NodeArg(n),\n+            EntryLocal(_, _, n) => NodeLocal(n),\n+            EntryPat(_, _, n) => NodePat(n),\n+            EntryBlock(_, _, n) => NodeBlock(n),\n+            EntryStructCtor(_, _, n) => NodeStructCtor(n),\n+            EntryLifetime(_, _, n) => NodeLifetime(n),\n             _ => return None\n         })\n     }\n@@ -289,6 +309,18 @@ impl<'ast> Map<'ast> {\n         self.find_entry(id).and_then(|x| x.parent()).unwrap_or(id)\n     }\n \n+    /// Similar to get_parent, returns the parent node id or id if there is no\n+    /// parent.\n+    /// This function returns the most direct parent in the AST, whereas get_parent\n+    /// returns the enclosing item. Note that this might not be the actual parent\n+    /// node in the AST - some kinds of nodes are not in the map and these will\n+    /// never appear as the parent_node. So you can always walk the parent_nodes\n+    /// from a node to the root of the ast (unless you get the same id back here\n+    /// that can happen if the id is not in the map itself or is just weird).\n+    pub fn get_parent_node(&self, id: NodeId) -> NodeId {\n+        self.find_entry(id).and_then(|x| x.parent_node()).unwrap_or(id)\n+    }\n+\n     pub fn get_parent_did(&self, id: NodeId) -> DefId {\n         let parent = self.get_parent(id);\n         match self.find_entry(parent) {\n@@ -301,7 +333,7 @@ impl<'ast> Map<'ast> {\n     pub fn get_foreign_abi(&self, id: NodeId) -> abi::Abi {\n         let parent = self.get_parent(id);\n         let abi = match self.find_entry(parent) {\n-            Some(EntryItem(_, i)) => {\n+            Some(EntryItem(_, _, i)) => {\n                 match i.node {\n                     ItemForeignMod(ref nm) => Some(nm.abi),\n                     _ => None\n@@ -591,11 +623,11 @@ impl<'a, 'ast> Iterator for NodesMatchingSuffix<'a, 'ast> {\n             }\n             self.idx += 1;\n             let (p, name) = match self.map.find_entry(idx) {\n-                Some(EntryItem(p, n))       => (p, n.name()),\n-                Some(EntryForeignItem(p, n))=> (p, n.name()),\n-                Some(EntryTraitItem(p, n))  => (p, n.name()),\n-                Some(EntryImplItem(p, n))   => (p, n.name()),\n-                Some(EntryVariant(p, n))    => (p, n.name()),\n+                Some(EntryItem(p, _, n))       => (p, n.name()),\n+                Some(EntryForeignItem(p, _, n))=> (p, n.name()),\n+                Some(EntryTraitItem(p, _, n))  => (p, n.name()),\n+                Some(EntryImplItem(p, _, n))   => (p, n.name()),\n+                Some(EntryVariant(p, _, n))    => (p, n.name()),\n                 _ => continue,\n             };\n             if self.matches_names(p, name) {\n@@ -648,7 +680,8 @@ impl<F: FoldOps> Folder for IdAndSpanUpdater<F> {\n struct NodeCollector<'ast> {\n     map: Vec<MapEntry<'ast>>,\n     /// The node in which we are currently mapping (an item or a method).\n-    parent: NodeId\n+    parent: NodeId,\n+    parent_node: NodeId,\n }\n \n impl<'ast> NodeCollector<'ast> {\n@@ -662,7 +695,7 @@ impl<'ast> NodeCollector<'ast> {\n     }\n \n     fn insert(&mut self, id: NodeId, node: Node<'ast>) {\n-        let entry = MapEntry::from_node(self.parent, node);\n+        let entry = MapEntry::from_node(self.parent, self.parent_node, node);\n         self.insert_entry(id, entry);\n     }\n \n@@ -678,6 +711,8 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.insert(i.id, NodeItem(i));\n         let parent = self.parent;\n         self.parent = i.id;\n+        let parent_node = self.parent_node;\n+        self.parent_node = i.id;\n         match i.node {\n             ItemImpl(_, _, _, _, _, ref impl_items) => {\n                 for ii in impl_items {\n@@ -728,64 +763,93 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         }\n         visit::walk_item(self, i);\n         self.parent = parent;\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n         let parent = self.parent;\n         self.parent = ti.id;\n+        let parent_node = self.parent_node;\n+        self.parent_node = ti.id;\n         visit::walk_trait_item(self, ti);\n         self.parent = parent;\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n         let parent = self.parent;\n         self.parent = ii.id;\n+        let parent_node = self.parent_node;\n+        self.parent_node = ii.id;\n         visit::walk_impl_item(self, ii);\n         self.parent = parent;\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_pat(&mut self, pat: &'ast Pat) {\n+        let parent_node = self.parent_node;\n+        self.parent_node = pat.id;\n         self.insert(pat.id, match pat.node {\n             // Note: this is at least *potentially* a pattern...\n             PatIdent(..) => NodeLocal(pat),\n             _ => NodePat(pat)\n         });\n         visit::walk_pat(self, pat);\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_expr(&mut self, expr: &'ast Expr) {\n+        let parent_node = self.parent_node;\n+        self.parent_node = expr.id;\n         self.insert(expr.id, NodeExpr(expr));\n         visit::walk_expr(self, expr);\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_stmt(&mut self, stmt: &'ast Stmt) {\n-        self.insert(ast_util::stmt_id(stmt), NodeStmt(stmt));\n+        let id = ast_util::stmt_id(stmt);\n+        let parent_node = self.parent_node;\n+        self.parent_node = id;\n+        self.insert(id, NodeStmt(stmt));\n         visit::walk_stmt(self, stmt);\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_fn(&mut self, fk: visit::FnKind<'ast>, fd: &'ast FnDecl,\n-                b: &'ast Block, s: Span, _: NodeId) {\n+                b: &'ast Block, s: Span, id: NodeId) {\n+        let parent_node = self.parent_node;\n+        self.parent_node = id;\n         self.visit_fn_decl(fd);\n         visit::walk_fn(self, fk, fd, b, s);\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_ty(&mut self, ty: &'ast Ty) {\n+        let parent_node = self.parent_node;\n+        self.parent_node = ty.id;\n         match ty.node {\n             TyBareFn(ref fd) => {\n                 self.visit_fn_decl(&*fd.decl);\n             }\n             _ => {}\n         }\n         visit::walk_ty(self, ty);\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_block(&mut self, block: &'ast Block) {\n+        let parent_node = self.parent_node;\n+        self.parent_node = block.id;\n         self.insert(block.id, NodeBlock(block));\n         visit::walk_block(self, block);\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_lifetime_ref(&mut self, lifetime: &'ast Lifetime) {\n+        let parent_node = self.parent_node;\n+        self.parent_node = lifetime.id;\n         self.insert(lifetime.id, NodeLifetime(lifetime));\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n@@ -809,7 +873,8 @@ pub fn map_crate<'ast, F: FoldOps>(forest: &'ast mut Forest, fold_ops: F) -> Map\n \n     let mut collector = NodeCollector {\n         map: vec![],\n-        parent: CRATE_NODE_ID\n+        parent: CRATE_NODE_ID,\n+        parent_node: CRATE_NODE_ID,\n     };\n     collector.insert_entry(CRATE_NODE_ID, RootCrate);\n     visit::walk_crate(&mut collector, &forest.krate);\n@@ -866,7 +931,8 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n \n     let mut collector = NodeCollector {\n         map: mem::replace(&mut *map.map.borrow_mut(), vec![]),\n-        parent: fld.new_id(DUMMY_NODE_ID)\n+        parent: fld.new_id(DUMMY_NODE_ID),\n+        parent_node: fld.new_id(DUMMY_NODE_ID),\n     };\n     let ii_parent_id = collector.parent;\n     collector.insert_entry(ii_parent_id, RootInlinedParent(ii_parent));"}]}