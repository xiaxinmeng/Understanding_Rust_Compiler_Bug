{"sha": "d37c3186779e6fcafe216e291ce30d1775ce4cbb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzN2MzMTg2Nzc5ZTZmY2FmZTIxNmUyOTFjZTMwZDE3NzVjZTRjYmI=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-09-26T23:26:11Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-09-30T18:24:27Z"}, "message": "Add graphviz debug output for generic dataflow", "tree": {"sha": "95f3b87d691cb160621127e0e96c39807af543b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95f3b87d691cb160621127e0e96c39807af543b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d37c3186779e6fcafe216e291ce30d1775ce4cbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d37c3186779e6fcafe216e291ce30d1775ce4cbb", "html_url": "https://github.com/rust-lang/rust/commit/d37c3186779e6fcafe216e291ce30d1775ce4cbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d37c3186779e6fcafe216e291ce30d1775ce4cbb/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e88aa20b49fdc7693e253dafc3d782973f05c84", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e88aa20b49fdc7693e253dafc3d782973f05c84", "html_url": "https://github.com/rust-lang/rust/commit/3e88aa20b49fdc7693e253dafc3d782973f05c84"}], "stats": {"total": 515, "additions": 510, "deletions": 5}, "files": [{"sha": "dd6238b80d1744115ea4615de706806a728afa48", "filename": "src/librustc_mir/dataflow/generic.rs", "status": "modified", "additions": 98, "deletions": 5, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/d37c3186779e6fcafe216e291ce30d1775ce4cbb/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d37c3186779e6fcafe216e291ce30d1775ce4cbb/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs?ref=d37c3186779e6fcafe216e291ce30d1775ce4cbb", "patch": "@@ -16,16 +16,24 @@\n //! [gk]: https://en.wikipedia.org/wiki/Data-flow_analysis#Bit_vector_problems\n //! [#64566]: https://github.com/rust-lang/rust/pull/64566\n \n+use std::borrow::Borrow;\n use std::cmp::Ordering;\n-use std::ops;\n+use std::ffi::OsString;\n+use std::path::{Path, PathBuf};\n+use std::{fs, io, ops};\n \n+use rustc::hir::def_id::DefId;\n use rustc::mir::{self, traversal, BasicBlock, Location};\n+use rustc::ty::{self, TyCtxt};\n+use rustc_data_structures::work_queue::WorkQueue;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_data_structures::work_queue::WorkQueue;\n+use syntax::symbol::sym;\n \n use crate::dataflow::BottomValue;\n \n+mod graphviz;\n+\n /// A specific kind of dataflow analysis.\n ///\n /// To run a dataflow analysis, one must set the initial state of the `START_BLOCK` via\n@@ -62,6 +70,13 @@ pub trait Analysis<'tcx>: BottomValue {\n     /// and try to keep it short.\n     const NAME: &'static str;\n \n+    /// How each element of your dataflow state will be displayed during debugging.\n+    ///\n+    /// By default, this is the `fmt::Debug` representation of `Self::Idx`.\n+    fn pretty_print_idx(&self, w: &mut impl io::Write, idx: Self::Idx) -> io::Result<()> {\n+        write!(w, \"{:?}\", idx)\n+    }\n+\n     /// The size of each bitvector allocated for each block.\n     fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize;\n \n@@ -357,7 +372,9 @@ where\n {\n     analysis: A,\n     bits_per_block: usize,\n+    tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n+    def_id: DefId,\n     dead_unwinds: &'a BitSet<BasicBlock>,\n     entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n }\n@@ -367,7 +384,9 @@ where\n     A: Analysis<'tcx>,\n {\n     pub fn new(\n+        tcx: TyCtxt<'tcx>,\n         body: &'a mir::Body<'tcx>,\n+        def_id: DefId,\n         dead_unwinds: &'a BitSet<BasicBlock>,\n         analysis: A,\n     ) -> Self {\n@@ -385,7 +404,9 @@ where\n         Engine {\n             analysis,\n             bits_per_block,\n+            tcx,\n             body,\n+            def_id,\n             dead_unwinds,\n             entry_sets,\n         }\n@@ -421,10 +442,26 @@ where\n             );\n         }\n \n-        Results {\n-            analysis: self.analysis,\n-            entry_sets: self.entry_sets,\n+        let Engine {\n+            tcx,\n+            body,\n+            def_id,\n+            analysis,\n+            entry_sets,\n+            ..\n+        } = self;\n+\n+        let results = Results { analysis, entry_sets };\n+\n+        let attrs = tcx.get_attrs(def_id);\n+        if let Some(path) = get_dataflow_graphviz_output_path(tcx, attrs, A::NAME) {\n+            let result = write_dataflow_graphviz_results(body, def_id, &path, &results);\n+            if let Err(e) = result {\n+                warn!(\"Failed to write dataflow results to {}: {}\", path.display(), e);\n+            }\n         }\n+\n+        results\n     }\n \n     fn propagate_bits_into_graph_successors_of(\n@@ -518,3 +555,59 @@ where\n         }\n     }\n }\n+\n+/// Looks for attributes like `#[rustc_mir(borrowck_graphviz_postflow=\"./path/to/suffix.dot\")]` and\n+/// extracts the path with the given analysis name prepended to the suffix.\n+///\n+/// Returns `None` if no such attribute exists.\n+fn get_dataflow_graphviz_output_path(\n+    tcx: TyCtxt<'tcx>,\n+    attrs: ty::Attributes<'tcx>,\n+    analysis: &str,\n+) -> Option<PathBuf> {\n+    let mut rustc_mir_attrs = attrs\n+        .into_iter()\n+        .filter(|attr| attr.check_name(sym::rustc_mir))\n+        .flat_map(|attr| attr.meta_item_list().into_iter().flat_map(|v| v.into_iter()));\n+\n+    let borrowck_graphviz_postflow = rustc_mir_attrs\n+        .find(|attr| attr.check_name(sym::borrowck_graphviz_postflow))?;\n+\n+    let path_and_suffix = match borrowck_graphviz_postflow.value_str() {\n+        Some(p) => p,\n+        None => {\n+            tcx.sess.span_err(\n+                borrowck_graphviz_postflow.span(),\n+                \"borrowck_graphviz_postflow requires a path\",\n+            );\n+\n+            return None;\n+        }\n+    };\n+\n+    // Change \"path/suffix.dot\" to \"path/analysis_name_suffix.dot\"\n+    let mut ret = PathBuf::from(path_and_suffix.to_string());\n+    let suffix = ret.file_name().unwrap();\n+\n+    let mut file_name: OsString = analysis.into();\n+    file_name.push(\"_\");\n+    file_name.push(suffix);\n+    ret.set_file_name(file_name);\n+\n+    Some(ret)\n+}\n+\n+fn write_dataflow_graphviz_results<A: Analysis<'tcx>>(\n+    body: &mir::Body<'tcx>,\n+    def_id: DefId,\n+    path: &Path,\n+    results: &Results<'tcx, A>\n+) -> io::Result<()> {\n+    debug!(\"printing dataflow results for {:?} to {}\", def_id, path.display());\n+\n+    let mut buf = Vec::new();\n+    let graphviz = graphviz::Formatter::new(body, def_id, results);\n+\n+    dot::render(&graphviz, &mut buf)?;\n+    fs::write(path, buf)\n+}"}, {"sha": "2a08feff9e77ab1bcb3a7708fbfe1a9086184d41", "filename": "src/librustc_mir/dataflow/generic/graphviz.rs", "status": "added", "additions": 412, "deletions": 0, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/d37c3186779e6fcafe216e291ce30d1775ce4cbb/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d37c3186779e6fcafe216e291ce30d1775ce4cbb/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fgraphviz.rs?ref=d37c3186779e6fcafe216e291ce30d1775ce4cbb", "patch": "@@ -0,0 +1,412 @@\n+use std::cell::RefCell;\n+use std::io::{self, Write};\n+use std::{ops, str};\n+\n+use rustc::hir::def_id::DefId;\n+use rustc::mir::{self, BasicBlock, Body, Location};\n+use rustc_index::bit_set::{BitSet, HybridBitSet};\n+use rustc_index::vec::Idx;\n+\n+use crate::util::graphviz_safe_def_name;\n+use super::{Analysis, Results, ResultsRefCursor};\n+\n+pub struct Formatter<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    body: &'a Body<'tcx>,\n+    def_id: DefId,\n+\n+    // This must be behind a `RefCell` because `dot::Labeller` takes `&self`.\n+    block_formatter: RefCell<BlockFormatter<'a, 'tcx, A>>,\n+}\n+\n+impl<A> Formatter<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    pub fn new(\n+        body: &'a Body<'tcx>,\n+        def_id: DefId,\n+        results: &'a Results<'tcx, A>,\n+    ) -> Self {\n+        let block_formatter = BlockFormatter {\n+            bg: Background::Light,\n+            prev_state: BitSet::new_empty(results.analysis.bits_per_block(body)),\n+            results: ResultsRefCursor::new(body, results),\n+        };\n+\n+        Formatter {\n+            body,\n+            def_id,\n+            block_formatter: RefCell::new(block_formatter),\n+        }\n+    }\n+}\n+\n+/// A pair of a basic block and an index into that basic blocks `successors`.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct CfgEdge {\n+    source: BasicBlock,\n+    index: usize,\n+}\n+\n+fn outgoing_edges(body: &Body<'_>, bb: BasicBlock) -> Vec<CfgEdge> {\n+    body[bb]\n+        .terminator()\n+        .successors()\n+        .enumerate()\n+        .map(|(index, _)| CfgEdge { source: bb, index })\n+        .collect()\n+}\n+\n+impl<A> dot::Labeller<'_> for Formatter<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    type Node = BasicBlock;\n+    type Edge = CfgEdge;\n+\n+    fn graph_id(&self) -> dot::Id<'_> {\n+        let name = graphviz_safe_def_name(self.def_id);\n+        dot::Id::new(format!(\"graph_for_def_id_{}\", name)).unwrap()\n+    }\n+\n+    fn node_id(&self, n: &Self::Node) -> dot::Id<'_> {\n+        dot::Id::new(format!(\"bb_{}\", n.index())).unwrap()\n+    }\n+\n+    fn node_label(&self, block: &Self::Node) -> dot::LabelText<'_> {\n+        let mut label = Vec::new();\n+        self.block_formatter\n+            .borrow_mut()\n+            .write_node_label(&mut label, self.body, *block)\n+            .unwrap();\n+        dot::LabelText::html(String::from_utf8(label).unwrap())\n+    }\n+\n+    fn node_shape(&self, _n: &Self::Node) -> Option<dot::LabelText<'_>> {\n+        Some(dot::LabelText::label(\"none\"))\n+    }\n+\n+    fn edge_label(&self, e: &Self::Edge) -> dot::LabelText<'_> {\n+        let label = &self.body\n+            [e.source]\n+            .terminator()\n+            .kind\n+            .fmt_successor_labels()\n+            [e.index];\n+        dot::LabelText::label(label.clone())\n+    }\n+}\n+\n+impl<A> dot::GraphWalk<'a> for Formatter<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    type Node = BasicBlock;\n+    type Edge = CfgEdge;\n+\n+    fn nodes(&self) -> dot::Nodes<'_, Self::Node> {\n+        self.body\n+            .basic_blocks()\n+            .indices()\n+            .collect::<Vec<_>>()\n+            .into()\n+    }\n+\n+    fn edges(&self) -> dot::Edges<'_, Self::Edge> {\n+        self.body\n+            .basic_blocks()\n+            .indices()\n+            .flat_map(|bb| outgoing_edges(self.body, bb))\n+            .collect::<Vec<_>>()\n+            .into()\n+    }\n+\n+    fn source(&self, edge: &Self::Edge) -> Self::Node {\n+        edge.source\n+    }\n+\n+    fn target(&self, edge: &Self::Edge) -> Self::Node {\n+        self.body\n+            [edge.source]\n+            .terminator()\n+            .successors()\n+            .nth(edge.index)\n+            .copied()\n+            .unwrap()\n+    }\n+}\n+\n+struct BlockFormatter<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    prev_state: BitSet<A::Idx>,\n+    results: ResultsRefCursor<'a, 'a, 'tcx, A>,\n+    bg: Background,\n+}\n+\n+impl<A> BlockFormatter<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    fn toggle_background(&mut self) -> Background {\n+        let bg = self.bg;\n+        self.bg = !bg;\n+        bg\n+    }\n+\n+    fn write_node_label(\n+        &mut self,\n+        w: &mut impl io::Write,\n+        body: &'a Body<'tcx>,\n+        block: BasicBlock,\n+    ) -> io::Result<()> {\n+        //   Sample output:\n+        //   +-+--------------------------------------------------+\n+        // A |                         bb4                        |\n+        //   +-+----------------------------------+---------------+\n+        // B |               MIR                  |     STATE     |\n+        //   +-+----------------------------------+---------------+\n+        // C | | (on entry)                       | {_0,_2,_3}    |\n+        //   +-+----------------------------------+---------------+\n+        // D |0|  0: StorageLive(_7)              |               |\n+        //   +-+----------------------------------+---------------+\n+        //   |1|  1: StorageLive(_8)              |               |\n+        //   +-+----------------------------------+---------------+\n+        //   |2|  2: _8 = &mut _1                 | +_8           |\n+        //   +-+----------------------------------+---------------+\n+        // E |T| _7 = const Foo::twiddle(move _8) | -_8           |\n+        //   +-+----------------------------------+---------------+\n+        // F | | (on unwind)                      | {_0,_2,_3,_7} |\n+        //   +-+----------------------------------+---------------+\n+        //   | | (on successful return)           | +_7           |\n+        //   +-+----------------------------------+---------------+\n+\n+        write!(\n+            w,\n+            r#\"<table border=\"1\" cellborder=\"1\" cellspacing=\"0\" cellpadding=\"3\" sides=\"rb\">\"#,\n+        )?;\n+\n+        // A: Block info\n+        write!(\n+            w,\n+            r#\"<tr>\n+                 <td colspan=\"{num_headers}\" sides=\"tl\">bb{block_id}</td>\n+               </tr>\"#,\n+            num_headers = 3,\n+            block_id = block.index(),\n+        )?;\n+\n+        // B: Column headings\n+        write!(\n+            w,\n+            r#\"<tr>\n+                 <td colspan=\"2\" {fmt}>MIR</td>\n+                 <td {fmt}>STATE</td>\n+               </tr>\"#,\n+            fmt = r##\"bgcolor=\"#a0a0a0\" sides=\"tl\"\"##,\n+        )?;\n+\n+        // C: Entry state\n+        self.results.seek_to_block_start(block);\n+        self.write_row_with_curr_state(w, \"\", \"(on entry)\")?;\n+        self.prev_state.overwrite(self.results.get());\n+\n+        // D: Statement transfer functions\n+        for (i, statement) in body[block].statements.iter().enumerate() {\n+            let location = Location { block, statement_index: i };\n+\n+            let mir_col = format!(\"{:?}\", statement);\n+            let i_col = i.to_string();\n+\n+            self.results.seek_after(location);\n+            self.write_row_with_curr_diff(w, &i_col, &mir_col)?;\n+            self.prev_state.overwrite(self.results.get());\n+        }\n+\n+        // E: Terminator transfer function\n+        let terminator = body[block].terminator();\n+        let location = body.terminator_loc(block);\n+\n+        let mut mir_col = String::new();\n+        terminator.kind.fmt_head(&mut mir_col).unwrap();\n+\n+        self.results.seek_after(location);\n+        self.write_row_with_curr_diff(w, \"T\", &mir_col)?;\n+        self.prev_state.overwrite(self.results.get());\n+\n+        // F: Exit state\n+        if let mir::TerminatorKind::Call { destination: Some(_), ..  } = &terminator.kind {\n+            self.write_row_with_curr_state(w, \"\", \"(on unwind)\")?;\n+\n+            self.results.seek_after_assume_call_returns(location);\n+            self.write_row_with_curr_diff(w, \"\", \"(on successful return)\")?;\n+        } else {\n+            self.write_row_with_curr_state(w, \"\", \"(on exit)\")?;\n+        }\n+\n+        write!(w, \"</table>\")\n+    }\n+\n+    fn write_row_with_curr_state(\n+        &mut self,\n+        w: &mut impl io::Write,\n+        i: &str,\n+        mir: &str,\n+    ) -> io::Result<()> {\n+        let bg = self.toggle_background();\n+\n+        let mut out = Vec::new();\n+        write!(&mut out, \"{{\")?;\n+        pretty_print_state_elems(&mut out, self.results.analysis(), self.results.get().iter())?;\n+        write!(&mut out, \"}}\")?;\n+\n+        write!(\n+            w,\n+            r#\"<tr>\n+                 <td {fmt} align=\"right\">{i}</td>\n+                 <td {fmt} align=\"left\">{mir}</td>\n+                 <td {fmt} align=\"left\">{state}</td>\n+               </tr>\"#,\n+            fmt = &[\"sides=\\\"tl\\\"\", bg.attr()].join(\" \"),\n+            i = i,\n+            mir = dot::escape_html(mir),\n+            state = dot::escape_html(str::from_utf8(&out).unwrap()),\n+        )\n+    }\n+\n+    fn write_row_with_curr_diff(\n+        &mut self,\n+        w: &mut impl io::Write,\n+        i: &str,\n+        mir: &str,\n+    ) -> io::Result<()> {\n+        let bg = self.toggle_background();\n+        let analysis = self.results.analysis();\n+\n+        let diff = BitSetDiff::compute(&self.prev_state, self.results.get());\n+\n+        let mut set = Vec::new();\n+        pretty_print_state_elems(&mut set, analysis, diff.set.iter())?;\n+\n+        let mut clear = Vec::new();\n+        pretty_print_state_elems(&mut clear, analysis, diff.clear.iter())?;\n+\n+        write!(\n+            w,\n+            r#\"<tr>\n+                 <td {fmt} align=\"right\">{i}</td>\n+                 <td {fmt} align=\"left\">{mir}</td>\n+                 <td {fmt} align=\"left\">\"#,\n+            i = i,\n+            fmt = &[\"sides=\\\"tl\\\"\", bg.attr()].join(\" \"),\n+            mir = dot::escape_html(mir),\n+        )?;\n+\n+        if !set.is_empty() {\n+            write!(\n+                w,\n+                r#\"<font color=\"darkgreen\">+{}</font>\"#,\n+                dot::escape_html(str::from_utf8(&set).unwrap()),\n+            )?;\n+        }\n+\n+        if !set.is_empty() && !clear.is_empty() {\n+            write!(w, \"  \")?;\n+        }\n+\n+        if !clear.is_empty() {\n+            write!(\n+                w,\n+                r#\"<font color=\"red\">-{}</font>\"#,\n+                dot::escape_html(str::from_utf8(&clear).unwrap()),\n+            )?;\n+        }\n+\n+        write!(w, \"</td></tr>\")\n+    }\n+}\n+\n+/// The operations required to transform one `BitSet` into another.\n+struct BitSetDiff<T: Idx> {\n+    set: HybridBitSet<T>,\n+    clear: HybridBitSet<T>,\n+}\n+\n+impl<T: Idx> BitSetDiff<T> {\n+    fn compute(from: &BitSet<T>, to: &BitSet<T>) -> Self {\n+        assert_eq!(from.domain_size(), to.domain_size());\n+        let len = from.domain_size();\n+\n+        let mut set = HybridBitSet::new_empty(len);\n+        let mut clear = HybridBitSet::new_empty(len);\n+\n+        // FIXME: This could be made faster if `BitSet::xor` were implemented.\n+        for i in (0..len).map(|i| T::new(i)) {\n+            match (from.contains(i), to.contains(i)) {\n+                (false, true) => set.insert(i),\n+                (true, false) => clear.insert(i),\n+                _ => continue,\n+            };\n+        }\n+\n+        BitSetDiff {\n+            set,\n+            clear,\n+        }\n+    }\n+}\n+\n+/// Formats each `elem` using the pretty printer provided by `analysis` into a comma-separated\n+/// list.\n+fn pretty_print_state_elems<A>(\n+    w: &mut impl io::Write,\n+    analysis: &A,\n+    elems: impl Iterator<Item = A::Idx>,\n+) -> io::Result<()>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    let mut first = true;\n+    for idx in elems {\n+        if first {\n+            first = false;\n+        } else {\n+            write!(w, \",\")?;\n+        }\n+\n+        analysis.pretty_print_idx(w, idx)?;\n+    }\n+\n+    Ok(())\n+}\n+\n+/// The background color used for zebra-striping the table.\n+#[derive(Clone, Copy)]\n+enum Background {\n+    Light,\n+    Dark,\n+}\n+\n+impl Background {\n+    fn attr(self) -> &'static str {\n+        match self {\n+            Self::Dark => \"bgcolor=\\\"#f0f0f0\\\"\",\n+            Self::Light => \"\",\n+        }\n+    }\n+}\n+\n+impl ops::Not for Background {\n+    type Output = Self;\n+\n+    fn not(self) -> Self {\n+        match self {\n+            Self::Light => Self::Dark,\n+            Self::Dark => Self::Light,\n+        }\n+    }\n+}"}]}