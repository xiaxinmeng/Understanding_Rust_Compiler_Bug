{"sha": "a8af13e784ec81be80804e6e3bc31ee7190a2869", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4YWYxM2U3ODRlYzgxYmU4MDgwNGU2ZTNiYzMxZWU3MTkwYTI4Njk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-31T04:11:14Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-02T17:39:12Z"}, "message": "Move compiletest modules into separate files", "tree": {"sha": "e1df99316ac2b441d580cd94b458bf13b064b142", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1df99316ac2b441d580cd94b458bf13b064b142"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8af13e784ec81be80804e6e3bc31ee7190a2869", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8af13e784ec81be80804e6e3bc31ee7190a2869", "html_url": "https://github.com/rust-lang/rust/commit/a8af13e784ec81be80804e6e3bc31ee7190a2869", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8af13e784ec81be80804e6e3bc31ee7190a2869/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "840a09c86ed354be8ed29a0b657bb7289c754442", "url": "https://api.github.com/repos/rust-lang/rust/commits/840a09c86ed354be8ed29a0b657bb7289c754442", "html_url": "https://github.com/rust-lang/rust/commit/840a09c86ed354be8ed29a0b657bb7289c754442"}], "stats": {"total": 1204, "additions": 617, "deletions": 587}, "files": [{"sha": "d0fe2ebb1cf90c4ba0dbafef57c550f85e1e620c", "filename": "src/test/compiletest/common.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a8af13e784ec81be80804e6e3bc31ee7190a2869/src%2Ftest%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8af13e784ec81be80804e6e3bc31ee7190a2869/src%2Ftest%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcommon.rs?ref=a8af13e784ec81be80804e6e3bc31ee7190a2869", "patch": "@@ -0,0 +1,33 @@\n+import std::option;\n+\n+tag mode { mode_compile_fail; mode_run_fail; mode_run_pass; }\n+\n+type config = {\n+    // The library paths required for running the compiler\n+    compile_lib_path: str,\n+    // The library paths required for running compiled programs\n+    run_lib_path: str,\n+    // The rustc executable\n+    rustc_path: str,\n+    // The directory containing the tests to run\n+    src_base: str,\n+    // The directory where programs should be built\n+    build_base: str,\n+    // The name of the stage being built (stage1, etc)\n+    stage_id: str,\n+    // The test mode, compile-fail, run-fail, run-pass\n+    mode: mode,\n+    // Run ignored tests\n+    run_ignored: bool,\n+    // Only run tests that match this filter\n+    filter: option::t[str],\n+    // A command line to prefix program execution with,\n+    // for running under valgrind\n+    runtool: option::t[str],\n+    // Flags to pass to the compiler\n+    rustcflags: option::t[str],\n+    // Explain what's going on\n+    verbose: bool\n+};\n+\n+type cx = {config: config, procsrv: procsrv::handle};"}, {"sha": "2f9ffe50f81e3d217729030c254e4c70baf2c763", "filename": "src/test/compiletest/compiletest.rc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a8af13e784ec81be80804e6e3bc31ee7190a2869/src%2Ftest%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a8af13e784ec81be80804e6e3bc31ee7190a2869/src%2Ftest%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rc?ref=a8af13e784ec81be80804e6e3bc31ee7190a2869", "patch": "@@ -1,6 +1,11 @@\n use std;\n \n mod compiletest;\n+mod procsrv;\n+mod util;\n+mod header;\n+mod runtest;\n+mod common;\n \n // Local Variables:\n // fill-column: 78;"}, {"sha": "9621d2b414c047ec2781a25059e2df07756f2c1b", "filename": "src/test/compiletest/compiletest.rs", "status": "modified", "additions": 9, "deletions": 587, "changes": 596, "blob_url": "https://github.com/rust-lang/rust/blob/a8af13e784ec81be80804e6e3bc31ee7190a2869/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8af13e784ec81be80804e6e3bc31ee7190a2869/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rs?ref=a8af13e784ec81be80804e6e3bc31ee7190a2869", "patch": "@@ -5,43 +5,15 @@ import std::fs;\n import std::str;\n import std::vec;\n import std::ivec;\n-import std::io;\n-import std::generic_os::setenv;\n-import std::generic_os::getenv;\n-import std::os;\n-import std::run;\n import std::task;\n-import std::unsafe;\n-\n-tag mode { mode_compile_fail; mode_run_fail; mode_run_pass; }\n-\n-type config = {\n- // The library paths required for running the compiler\n- compile_lib_path: str,\n- // The library paths required for running compiled programs\n- run_lib_path: str,\n- // The rustc executable\n- rustc_path: str,\n- // The directory containing the tests to run\n- src_base: str,\n- // The directory where programs should be built\n- build_base: str,\n- // The name of the stage being built (stage1, etc)\n- stage_id: str,\n- // The test mode, compile-fail, run-fail, run-pass\n- mode: mode,\n- // Run ignored tests\n- run_ignored: bool,\n- // Only run tests that match this filter\n- filter: option::t[str],\n- // A command line to prefix program execution with,\n- // for running under valgrind\n- runtool: option::t[str],\n- // Flags to pass to the compiler\n- rustcflags: option::t[str],\n- // Explain what's going on\n- verbose: bool\n-};\n+\n+import common::cx;\n+import common::config;\n+import common::mode_run_pass;\n+import common::mode_run_fail;\n+import common::mode_compile_fail;\n+import common::mode;\n+import util::logv;\n \n fn main(args: vec[str]) {\n \n@@ -134,8 +106,6 @@ fn mode_str(mode: mode) -> str {\n     }\n }\n \n-type cx = {config: config, procsrv: procsrv::handle};\n-\n fn run_tests(config: &config) {\n     let opts = test_opts(config);\n     let cx = {config: config, procsrv: procsrv::mk()};\n@@ -173,7 +143,7 @@ fn make_test(cx: &cx, testfile: &str, configport: &port[str]) ->\n    test::test_desc {\n     {name: testfile,\n      fn: make_test_closure(testfile, chan(configport)),\n-            ignore: header::is_test_ignored(cx.config, testfile)}\n+            ignore: header::is_test_ignored(cx.config.stage_id, testfile)}\n }\n \n /*\n@@ -253,554 +223,6 @@ fn run_test_task(compile_lib_path: str, run_lib_path: str, rustc_path: str,\n     runtest::run(cx, testfile);\n }\n \n-\n-fn make_cmdline(libpath: &str, prog: &str, args: &vec[str]) -> str {\n-    #fmt(\"%s %s %s\", lib_path_cmd_prefix(libpath), prog,\n-         str::connect(args, \" \"))\n-}\n-\n-// Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n-// for diagnostic purposes\n-fn lib_path_cmd_prefix(path: &str) -> str {\n-    #fmt(\"%s=\\\"%s\\\"\", lib_path_env_var(), make_new_path(path))\n-}\n-\n-fn make_new_path(path: &str) -> str {\n-\n-    // Windows just uses PATH as the library search path, so we have to\n-    // maintain the current value while adding our own\n-    alt getenv(lib_path_env_var()) {\n-      option::some(curr) { #fmt(\"%s:%s\", path, curr) }\n-      option::none. { path }\n-    }\n-}\n-\n-#[cfg(target_os = \"linux\")]\n-fn lib_path_env_var() -> str { \"LD_LIBRARY_PATH\" }\n-\n-#[cfg(target_os = \"macos\")]\n-fn lib_path_env_var() -> str { \"DYLD_LIBRARY_PATH\" }\n-\n-#[cfg(target_os = \"win32\")]\n-fn lib_path_env_var() -> str { \"PATH\" }\n-\n-fn make_exe_name(config: &config, testfile: &str) -> str {\n-    output_base_name(config, testfile) + os::exec_suffix()\n-}\n-\n-fn output_base_name(config: &config, testfile: &str) -> str {\n-    let base = config.build_base;\n-    let filename =\n-        {\n-            let parts = str::split(fs::basename(testfile), '.' as u8);\n-            parts = vec::slice(parts, 0u, vec::len(parts) - 1u);\n-            str::connect(parts, \".\")\n-        };\n-    #fmt(\"%s%s.%s\", base, filename, config.stage_id)\n-}\n-\n-fn logv(config: &config, s: &str) {\n-    log s;\n-    if config.verbose { io::stdout().write_line(s); }\n-}\n-\n-fn clone_str(s: &str) -> str {\n-    let new = s + \"\";\n-    // new should be a different pointer\n-    let sptr: int = unsafe::reinterpret_cast(s);\n-    let newptr: int = unsafe::reinterpret_cast(new);\n-    assert sptr != newptr;\n-    new\n-}\n-\n-fn clone_ivecstr(v: &str[]) -> str[] {\n-    let r = ~[];\n-    for t: str in ivec::slice(v, 0u, ivec::len(v)) {\n-        r += ~[clone_str(t)];\n-    }\n-    ret r;\n-}\n-\n-mod header {\n-\n-    export test_props;\n-    export load_props;\n-    export is_test_ignored;\n-\n-    type test_props = {error_patterns: str[], compile_flags: option::t[str]};\n-\n-    // Load any test directives embedded in the file\n-    fn load_props(testfile: &str) -> test_props {\n-        let error_patterns = ~[];\n-        let compile_flags = option::none;\n-        for each ln: str  in iter_header(testfile) {\n-                alt parse_error_pattern(ln) {\n-                        option::some(ep) { error_patterns += ~[ep]; }\n-                        option::none. { }\n-                    }\n-\n-\n-                if option::is_none(compile_flags) {\n-                        compile_flags = parse_compile_flags(ln);\n-                    }\n-            }\n-        ret {error_patterns: error_patterns, compile_flags: compile_flags};\n-    }\n-\n-    fn is_test_ignored(config: &config, testfile: &str) -> bool {\n-        let found = false;\n-        for each ln: str  in iter_header(testfile) {\n-                // FIXME: Can't return or break from iterator\n-                found = found\n-                    || parse_name_directive(ln, \"xfail-\" + config.stage_id);\n-            }\n-        ret found;\n-    }\n-\n-    iter iter_header(testfile: &str) -> str {\n-        let rdr = io::file_reader(testfile);\n-        while !rdr.eof() {\n-                let ln = rdr.read_line();\n-\n-                // Assume that any directives will be found before the first\n-                // module or function. This doesn't seem to be an optimization\n-                // with a warm page cache. Maybe with a cold one.\n-                if str::starts_with(ln, \"fn\") || str::starts_with(ln, \"mod\") {\n-                        break;\n-                    } else { put ln; }\n-            }\n-    }\n-\n-    fn parse_error_pattern(line: &str) -> option::t[str] {\n-        parse_name_value_directive(line, \"error-pattern\")\n-            }\n-\n-    fn parse_compile_flags(line: &str) -> option::t[str] {\n-        parse_name_value_directive(line, \"compile-flags\")\n-            }\n-\n-    fn parse_name_directive(line: &str, directive: &str) -> bool {\n-        str::find(line, directive) >= 0\n-            }\n-\n-    fn parse_name_value_directive(line: &str,\n-                                  directive: &str) -> option::t[str] {\n-        let keycolon = directive + \":\";\n-        if str::find(line, keycolon) >= 0 {\n-                let colon = str::find(line, keycolon) as uint;\n-                let value =\n-                    str::slice(line, colon + str::byte_len(keycolon),\n-                               str::byte_len(line));\n-                log #fmt(\"%s: %s\", directive, value);\n-                option::some(value)\n-                    } else { option::none }\n-    }\n-}\n-\n-mod runtest {\n-\n-    import header::load_props;\n-    import header::test_props;\n-\n-    export run;\n-\n-    fn run(cx: &cx, testfile: &str) {\n-        test::configure_test_task();\n-        if (cx.config.verbose) {\n-            // We're going to be dumping a lot of info. Start on a new line.\n-            io::stdout().write_str(\"\\n\\n\");\n-        }\n-        log #fmt(\"running %s\", testfile);\n-        let props = load_props(testfile);\n-        alt cx.config.mode {\n-          mode_compile_fail. { run_cfail_test(cx, props, testfile); }\n-          mode_run_fail. { run_rfail_test(cx, props, testfile); }\n-          mode_run_pass. { run_rpass_test(cx, props, testfile); }\n-        }\n-    }\n-\n-    fn run_cfail_test(cx: &cx, props: &test_props, testfile: &str) {\n-        let procres = compile_test(cx, props, testfile);\n-\n-        if procres.status == 0 {\n-            fatal_procres(\"compile-fail test compiled successfully!\",\n-                          procres);\n-        }\n-\n-        check_error_patterns(props, testfile, procres);\n-    }\n-\n-    fn run_rfail_test(cx: &cx, props: &test_props, testfile: &str) {\n-        let procres = compile_test(cx, props, testfile);\n-\n-        if procres.status != 0 {\n-                fatal_procres(\"compilation failed!\", procres); }\n-\n-        procres = exec_compiled_test(cx, testfile);\n-\n-        if procres.status == 0 {\n-            fatal_procres(\"run-fail test didn't produce an error!\",\n-                          procres);\n-            }\n-\n-        check_error_patterns(props, testfile, procres);\n-    }\n-\n-    fn run_rpass_test(cx: &cx, props: &test_props, testfile: &str) {\n-        let procres = compile_test(cx, props, testfile);\n-\n-        if procres.status != 0 {\n-                fatal_procres(\"compilation failed!\", procres); }\n-\n-        procres = exec_compiled_test(cx, testfile);\n-\n-\n-        if procres.status != 0 { fatal_procres(\"test run failed!\", procres); }\n-    }\n-\n-    fn check_error_patterns(props: &test_props, testfile: &str,\n-                            procres: &procres) {\n-        if ivec::is_empty(props.error_patterns) {\n-                fatal(\"no error pattern specified in \" + testfile);\n-            }\n-\n-        let next_err_idx = 0u;\n-        let next_err_pat = props.error_patterns.(next_err_idx);\n-        for line: str  in str::split(procres.stdout, '\\n' as u8) {\n-                if str::find(line, next_err_pat) > 0 {\n-                        log #fmt(\"found error pattern %s\", next_err_pat);\n-                        next_err_idx += 1u;\n-                        if next_err_idx == ivec::len(props.error_patterns) {\n-                                log \"found all error patterns\";\n-                                ret;\n-                            }\n-                        next_err_pat = props.error_patterns.(next_err_idx);\n-                    }\n-            }\n-\n-        let missing_patterns =\n-            ivec::slice(props.error_patterns, next_err_idx,\n-                        ivec::len(props.error_patterns));\n-        if ivec::len(missing_patterns) == 1u {\n-                fatal_procres(#fmt(\"error pattern '%s' not found!\",\n-                                   missing_patterns.(0)), procres);\n-            } else {\n-            for pattern: str  in missing_patterns {\n-                    error(#fmt(\"error pattern '%s' not found!\", pattern));\n-                }\n-            fatal_procres(\"multiple error patterns not found\", procres);\n-        }\n-    }\n-\n-    type procargs = {prog: str, args: vec[str]};\n-\n-    type procres = {status: int, stdout: str, stderr: str, cmdline: str};\n-\n-    fn compile_test(cx: &cx, props: &test_props, testfile: &str) -> procres {\n-        compose_and_run(cx, testfile, bind make_compile_args(_, props, _),\n-                        cx.config.compile_lib_path)\n-            }\n-\n-    fn exec_compiled_test(cx: &cx, testfile: &str) -> procres {\n-        compose_and_run(cx, testfile, make_run_args, cx.config.run_lib_path)\n-            }\n-\n-    fn compose_and_run(cx: &cx, testfile: &str,\n-                       make_args: fn(&config, &str) -> procargs ,\n-                       lib_path: &str) -> procres {\n-        let procargs = make_args(cx.config, testfile);\n-        ret program_output(cx, testfile, lib_path,\n-                           procargs.prog, procargs.args);\n-    }\n-\n-    fn make_compile_args(config: &config,\n-                         props: &test_props, testfile: &str) ->\n-        procargs {\n-        let prog = config.rustc_path;\n-        let args = [testfile, \"-o\", make_exe_name(config, testfile)];\n-        args += split_maybe_args(config.rustcflags);\n-        args += split_maybe_args(props.compile_flags);\n-        ret {prog: prog, args: args};\n-    }\n-\n-    fn make_run_args(config: &config, testfile: &str) -> procargs {\n-        // If we've got another tool to run under (valgrind),\n-        // then split apart its command\n-        let args =\n-            split_maybe_args(config.runtool)\n-            + [make_exe_name(config, testfile)];\n-        ret {prog: args.(0), args: vec::slice(args, 1u, vec::len(args))};\n-    }\n-\n-    fn split_maybe_args(argstr: &option::t[str]) -> vec[str] {\n-        fn rm_whitespace(v: vec[str]) -> vec[str] {\n-            fn flt(s: &str) -> option::t[str] {\n-                if !is_whitespace(s) {\n-                    option::some(s)\n-                } else {\n-                    option::none\n-                }\n-            }\n-\n-            // FIXME: This should be in std\n-            fn is_whitespace(s: str) -> bool {\n-                for c: u8 in s {\n-                    if c != (' ' as u8) { ret false; }\n-                }\n-                ret true;\n-            }\n-            vec::filter_map(flt, v)\n-        }\n-\n-        alt argstr {\n-                option::some(s) { rm_whitespace(str::split(s, ' ' as u8)) }\n-                option::none. { [] }\n-            }\n-    }\n-\n-    fn program_output(cx: &cx, testfile: &str, lib_path: &str, prog: &str,\n-                      args: &vec[str]) -> procres {\n-        let cmdline =\n-            {\n-                let cmdline = make_cmdline(lib_path, prog, args);\n-                logv(cx.config, #fmt(\"executing %s\", cmdline));\n-                cmdline\n-            };\n-        let res = procsrv::run(cx.procsrv, lib_path, prog, args);\n-        dump_output(cx.config, testfile, res.out, res.err);\n-        ret {status: res.status, stdout: res.out,\n-             stderr: res.err, cmdline: cmdline};\n-    }\n-\n-    fn dump_output(config: &config, testfile: &str,\n-                   out: &str, err: &str) {\n-        dump_output_file(config, testfile, out, \"out\");\n-        dump_output_file(config, testfile, err, \"err\");\n-        maybe_dump_to_stdout(config, out, err);\n-    }\n-\n-    #[cfg(target_os = \"win32\")]\n-    #[cfg(target_os = \"linux\")]\n-    fn dump_output_file(config: &config, testfile: &str,\n-                        out: &str, extension: &str) {\n-        let outfile = make_out_name(config, testfile, extension);\n-        let writer = io::file_writer(outfile, [io::create, io::truncate]);\n-        writer.write_str(out);\n-    }\n-\n-    // FIXME (726): Can't use file_writer on mac\n-    #[cfg(target_os = \"macos\")]\n-    fn dump_output_file(config: &config, testfile: &str,\n-                        out: &str, extension: &str) {\n-    }\n-\n-    fn make_out_name(config: &config, testfile: &str,\n-                     extension: &str) -> str {\n-        output_base_name(config, testfile) + \".\" + extension\n-    }\n-\n-    fn maybe_dump_to_stdout(config: &config,\n-                            out: &str, err: &str) {\n-        if config.verbose {\n-            let sep1 = #fmt(\"------%s------------------------------\",\n-                            \"stdout\");\n-            let sep2 = #fmt(\"------%s------------------------------\",\n-                            \"stderr\");\n-            let sep3 = \"------------------------------------------\";\n-            io::stdout().write_line(sep1);\n-            io::stdout().write_line(out);\n-            io::stdout().write_line(sep2);\n-            io::stdout().write_line(err);\n-            io::stdout().write_line(sep3);\n-        }\n-    }\n-\n-    fn error(err: &str) { io::stdout().write_line(#fmt(\"\\nerror: %s\", err)); }\n-\n-    fn fatal(err: &str) -> ! { error(err); fail; }\n-\n-    fn fatal_procres(err: &str, procres: procres) -> ! {\n-        let msg =\n-            #fmt(\"\\n\\\n-                  error: %s\\n\\\n-                  command: %s\\n\\\n-                  stdout:\\n\\\n-                  ------------------------------------------\\n\\\n-                  %s\\n\\\n-                  ------------------------------------------\\n\\\n-                  stderr:\\n\\\n-                  ------------------------------------------\\n\\\n-                  %s\\n\\\n-                  ------------------------------------------\\n\\\n-                  \\n\",\n-                 err, procres.cmdline, procres.stdout, procres.stderr);\n-        io::stdout().write_str(msg);\n-        fail;\n-    }\n-}\n-\n-// So when running tests in parallel there's a potential race on environment\n-// variables if we let each task spawn its own children - between the time the\n-// environment is set and the process is spawned another task could spawn its\n-// child process. Because of that we have to use a complicated scheme with a\n-// dedicated server for spawning processes.\n-mod procsrv {\n-\n-    export handle;\n-    export mk;\n-    export from_chan;\n-    export clone;\n-    export run;\n-    export close;\n-    export reqchan;\n-\n-    type reqchan = chan[request];\n-\n-    type handle = {task: option::t[task], chan: reqchan};\n-\n-    tag request { exec(str, str, str[], chan[response]); stop; }\n-\n-    type response = {pid: int, outfd: int, errfd: int};\n-\n-    fn mk() -> handle {\n-        let setupport = port();\n-        let task = spawn fn(setupchan: chan[chan[request]]) {\n-            let reqport = port();\n-            let reqchan = chan(reqport);\n-            task::send(setupchan, task::clone_chan(reqchan));\n-            worker(reqport);\n-        } (chan(setupport));\n-        ret {task: option::some(task),\n-                chan: task::recv(setupport)\n-                };\n-    }\n-\n-    fn from_chan(ch: &reqchan) -> handle { {task: option::none, chan: ch} }\n-\n-    fn clone(handle: &handle) -> handle {\n-\n-        // Sharing tasks across tasks appears to be (yet another) recipe for\n-        // disaster, so our handle clones will not get the task pointer.\n-        {task: option::none, chan: task::clone_chan(handle.chan)}\n-    }\n-\n-    fn close(handle: &handle) {\n-        task::send(handle.chan, stop);\n-        task::join(option::get(handle.task));\n-    }\n-\n-    fn run(handle: &handle, lib_path: &str, prog: &str, args: &vec[str]) ->\n-        {status: int, out: str, err: str} {\n-        let p = port[response]();\n-        let ch = chan(p);\n-        task::send(handle.chan, exec(lib_path,\n-                                     prog,\n-                                     clone_ivecstr(ivec::from_vec(args)),\n-                                     task::clone_chan(ch)));\n-        let resp = task::recv(p);\n-        let output = readclose(resp.outfd);\n-        let errput = readclose(resp.errfd);\n-        let status = os::waitpid(resp.pid);\n-        ret {status: status, out: output, err: errput};\n-    }\n-\n-    fn readclose(fd: int) -> str {\n-        // Copied from run::program_output\n-        let file = os::fd_FILE(fd);\n-        let reader = io::new_reader(io::FILE_buf_reader(file, option::none));\n-        let buf = \"\";\n-        while !reader.eof() {\n-            let bytes = reader.read_bytes(4096u);\n-            buf += str::unsafe_from_bytes(bytes);\n-        }\n-        os::libc::fclose(file);\n-        ret buf;\n-    }\n-\n-    fn worker(p: port[request]) {\n-\n-        // FIXME (787): If we declare this inside of the while loop and then\n-        // break out of it before it's ever initialized (i.e. we don't run\n-        // any tests), then the cleanups will puke, so we're initializing it\n-        // here with defaults.\n-        let execparms = {\n-            lib_path: \"\",\n-            prog: \"\",\n-            args: ~[],\n-            // This works because a NULL box is ignored during cleanup\n-            respchan: unsafe::reinterpret_cast(0)\n-        };\n-\n-        while true {\n-            // FIXME: Sending strings across channels seems to still\n-            // leave them refed on the sender's end, which causes problems if\n-            // the receiver's poniters outlive the sender's. Here we clone\n-            // everything and let the originals go out of scope before sending\n-            // a response.\n-            execparms = {\n-                // FIXME (785): The 'discriminant' of an alt expression has\n-                // the same scope as the alt expression itself, so we have to\n-                // put the entire alt in another block to make sure the exec\n-                // message goes out of scope. Seems like the scoping rules for\n-                // the alt discriminant are wrong.\n-                alt task::recv(p) {\n-                  exec(lib_path, prog, args, respchan) {\n-                    {\n-                        lib_path: clone_str(lib_path),\n-                        prog: clone_str(prog),\n-                        args: clone_ivecstr(args),\n-                        respchan: respchan\n-                    }\n-                  }\n-                  stop. { ret }\n-                }\n-            };\n-\n-            // This is copied from run::start_program\n-            let pipe_in = os::pipe();\n-            let pipe_out = os::pipe();\n-            let pipe_err = os::pipe();\n-            let spawnproc =\n-                bind run::spawn_process(execparms.prog,\n-                                        ivec::to_vec(execparms.args),\n-                                        pipe_in.in,\n-                                        pipe_out.out,\n-                                        pipe_err.out);\n-            let pid = with_lib_path(execparms.lib_path, spawnproc);\n-            os::libc::close(pipe_in.in);\n-            os::libc::close(pipe_in.out);\n-            os::libc::close(pipe_out.out);\n-            os::libc::close(pipe_err.out);\n-            if pid == -1 {\n-                os::libc::close(pipe_out.in);\n-                os::libc::close(pipe_err.in);\n-                fail;\n-            }\n-            task::send(execparms.respchan,\n-                       {pid: pid,\n-                        outfd: pipe_out.in,\n-                        errfd: pipe_err.in});\n-        }\n-    }\n-\n-    fn with_lib_path[T](path: &str, f: fn() -> T ) -> T {\n-        let maybe_oldpath = getenv(lib_path_env_var());\n-        append_lib_path(path);\n-        let res = f();\n-        if option::is_some(maybe_oldpath) {\n-            export_lib_path(option::get(maybe_oldpath));\n-        } else {\n-            // FIXME: This should really be unset but we don't have that yet\n-            export_lib_path(\"\");\n-        }\n-        ret res;\n-    }\n-\n-    fn append_lib_path(path: &str) { export_lib_path(make_new_path(path)); }\n-\n-    fn export_lib_path(path: &str) { setenv(lib_path_env_var(), path); }\n-}\n-\n // Local Variables:\n // fill-column: 78;\n // indent-tabs-mode: nil"}, {"sha": "9961852f16e9eb85edfb588a1d1213f9d5965731", "filename": "src/test/compiletest/header.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a8af13e784ec81be80804e6e3bc31ee7190a2869/src%2Ftest%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8af13e784ec81be80804e6e3bc31ee7190a2869/src%2Ftest%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fheader.rs?ref=a8af13e784ec81be80804e6e3bc31ee7190a2869", "patch": "@@ -0,0 +1,76 @@\n+import std::option;\n+import std::str;\n+import std::io;\n+\n+export test_props;\n+export load_props;\n+export is_test_ignored;\n+\n+type test_props = {error_patterns: str[], compile_flags: option::t[str]};\n+\n+// Load any test directives embedded in the file\n+fn load_props(testfile: &str) -> test_props {\n+    let error_patterns = ~[];\n+    let compile_flags = option::none;\n+    for each ln: str  in iter_header(testfile) {\n+        alt parse_error_pattern(ln) {\n+          option::some(ep) { error_patterns += ~[ep]; }\n+          option::none. { }\n+        }\n+\n+\n+        if option::is_none(compile_flags) {\n+            compile_flags = parse_compile_flags(ln);\n+        }\n+    }\n+    ret {error_patterns: error_patterns, compile_flags: compile_flags};\n+}\n+\n+fn is_test_ignored(stage_id: &str, testfile: &str) -> bool {\n+    let found = false;\n+    for each ln: str  in iter_header(testfile) {\n+        // FIXME: Can't return or break from iterator\n+        found = found\n+            || parse_name_directive(ln, \"xfail-\" + stage_id);\n+    }\n+    ret found;\n+}\n+\n+iter iter_header(testfile: &str) -> str {\n+    let rdr = io::file_reader(testfile);\n+    while !rdr.eof() {\n+        let ln = rdr.read_line();\n+\n+        // Assume that any directives will be found before the first\n+        // module or function. This doesn't seem to be an optimization\n+        // with a warm page cache. Maybe with a cold one.\n+        if str::starts_with(ln, \"fn\") || str::starts_with(ln, \"mod\") {\n+            break;\n+        } else { put ln; }\n+    }\n+}\n+\n+fn parse_error_pattern(line: &str) -> option::t[str] {\n+    parse_name_value_directive(line, \"error-pattern\")\n+}\n+\n+fn parse_compile_flags(line: &str) -> option::t[str] {\n+    parse_name_value_directive(line, \"compile-flags\")\n+}\n+\n+fn parse_name_directive(line: &str, directive: &str) -> bool {\n+    str::find(line, directive) >= 0\n+}\n+\n+fn parse_name_value_directive(line: &str,\n+                              directive: &str) -> option::t[str] {\n+    let keycolon = directive + \":\";\n+    if str::find(line, keycolon) >= 0 {\n+        let colon = str::find(line, keycolon) as uint;\n+        let value =\n+            str::slice(line, colon + str::byte_len(keycolon),\n+                       str::byte_len(line));\n+        log #fmt(\"%s: %s\", directive, value);\n+        option::some(value)\n+    } else { option::none }\n+}"}, {"sha": "0cc1e34a1f0fa4fe8865402c1807408e68547041", "filename": "src/test/compiletest/procsrv.rs", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/a8af13e784ec81be80804e6e3bc31ee7190a2869/src%2Ftest%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8af13e784ec81be80804e6e3bc31ee7190a2869/src%2Ftest%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fprocsrv.rs?ref=a8af13e784ec81be80804e6e3bc31ee7190a2869", "patch": "@@ -0,0 +1,186 @@\n+// So when running tests in parallel there's a potential race on environment\n+// variables if we let each task spawn its own children - between the time the\n+// environment is set and the process is spawned another task could spawn its\n+// child process. Because of that we have to use a complicated scheme with a\n+// dedicated server for spawning processes.\n+\n+import std::option;\n+import std::task;\n+import std::generic_os::setenv;\n+import std::generic_os::getenv;\n+import std::ivec;\n+import std::os;\n+import std::run;\n+import std::unsafe;\n+import std::io;\n+import std::str;\n+\n+export handle;\n+export mk;\n+export from_chan;\n+export run;\n+export close;\n+export reqchan;\n+\n+type reqchan = chan[request];\n+\n+type handle = {task: option::t[task], chan: reqchan};\n+\n+tag request { exec(str, str, str[], chan[response]); stop; }\n+\n+type response = {pid: int, outfd: int, errfd: int};\n+\n+fn mk() -> handle {\n+    let setupport = port();\n+    let task = spawn fn(setupchan: chan[chan[request]]) {\n+        let reqport = port();\n+        let reqchan = chan(reqport);\n+        task::send(setupchan, task::clone_chan(reqchan));\n+        worker(reqport);\n+    } (chan(setupport));\n+    ret {task: option::some(task),\n+         chan: task::recv(setupport)\n+        };\n+}\n+\n+fn from_chan(ch: &reqchan) -> handle { {task: option::none, chan: ch} }\n+\n+fn clone(handle: &handle) -> handle {\n+\n+    // Sharing tasks across tasks appears to be (yet another) recipe for\n+    // disaster, so our handle clones will not get the task pointer.\n+    {task: option::none, chan: task::clone_chan(handle.chan)}\n+}\n+\n+fn close(handle: &handle) {\n+    task::send(handle.chan, stop);\n+    task::join(option::get(handle.task));\n+}\n+\n+fn run(handle: &handle, lib_path: &str, prog: &str, args: &vec[str]) ->\n+{status: int, out: str, err: str} {\n+    let p = port[response]();\n+    let ch = chan(p);\n+    task::send(handle.chan, exec(lib_path,\n+                                 prog,\n+                                 clone_ivecstr(ivec::from_vec(args)),\n+                                 task::clone_chan(ch)));\n+    let resp = task::recv(p);\n+    let output = readclose(resp.outfd);\n+    let errput = readclose(resp.errfd);\n+    let status = os::waitpid(resp.pid);\n+    ret {status: status, out: output, err: errput};\n+}\n+\n+fn readclose(fd: int) -> str {\n+    // Copied from run::program_output\n+    let file = os::fd_FILE(fd);\n+    let reader = io::new_reader(io::FILE_buf_reader(file, option::none));\n+    let buf = \"\";\n+    while !reader.eof() {\n+        let bytes = reader.read_bytes(4096u);\n+        buf += str::unsafe_from_bytes(bytes);\n+    }\n+    os::libc::fclose(file);\n+    ret buf;\n+}\n+\n+fn worker(p: port[request]) {\n+\n+    // FIXME (787): If we declare this inside of the while loop and then\n+    // break out of it before it's ever initialized (i.e. we don't run\n+    // any tests), then the cleanups will puke, so we're initializing it\n+    // here with defaults.\n+    let execparms = {\n+        lib_path: \"\",\n+        prog: \"\",\n+        args: ~[],\n+        // This works because a NULL box is ignored during cleanup\n+        respchan: unsafe::reinterpret_cast(0)\n+    };\n+\n+    while true {\n+        // FIXME: Sending strings across channels seems to still\n+        // leave them refed on the sender's end, which causes problems if\n+        // the receiver's poniters outlive the sender's. Here we clone\n+        // everything and let the originals go out of scope before sending\n+        // a response.\n+        execparms = {\n+            // FIXME (785): The 'discriminant' of an alt expression has\n+            // the same scope as the alt expression itself, so we have to\n+            // put the entire alt in another block to make sure the exec\n+            // message goes out of scope. Seems like the scoping rules for\n+            // the alt discriminant are wrong.\n+            alt task::recv(p) {\n+              exec(lib_path, prog, args, respchan) {\n+                {\n+                    lib_path: clone_str(lib_path),\n+                    prog: clone_str(prog),\n+                    args: clone_ivecstr(args),\n+                    respchan: respchan\n+                }\n+              }\n+              stop. { ret }\n+            }\n+        };\n+\n+        // This is copied from run::start_program\n+        let pipe_in = os::pipe();\n+        let pipe_out = os::pipe();\n+        let pipe_err = os::pipe();\n+        let spawnproc =\n+            bind run::spawn_process(execparms.prog,\n+                                    ivec::to_vec(execparms.args),\n+                                    pipe_in.in,\n+                                    pipe_out.out,\n+                                    pipe_err.out);\n+        let pid = with_lib_path(execparms.lib_path, spawnproc);\n+        os::libc::close(pipe_in.in);\n+        os::libc::close(pipe_in.out);\n+        os::libc::close(pipe_out.out);\n+        os::libc::close(pipe_err.out);\n+        if pid == -1 {\n+            os::libc::close(pipe_out.in);\n+            os::libc::close(pipe_err.in);\n+            fail;\n+        }\n+        task::send(execparms.respchan,\n+                   {pid: pid,\n+                    outfd: pipe_out.in,\n+                    errfd: pipe_err.in});\n+    }\n+}\n+\n+fn with_lib_path[T](path: &str, f: fn() -> T ) -> T {\n+    let maybe_oldpath = getenv(util::lib_path_env_var());\n+    append_lib_path(path);\n+    let res = f();\n+    if option::is_some(maybe_oldpath) {\n+        export_lib_path(option::get(maybe_oldpath));\n+    } else {\n+        // FIXME: This should really be unset but we don't have that yet\n+        export_lib_path(\"\");\n+    }\n+    ret res;\n+}\n+\n+fn append_lib_path(path: &str) { export_lib_path(util::make_new_path(path)); }\n+\n+fn export_lib_path(path: &str) { setenv(util::lib_path_env_var(), path); }\n+\n+fn clone_str(s: &str) -> str {\n+    let new = s + \"\";\n+    // new should be a different pointer\n+    let sptr: int = unsafe::reinterpret_cast(s);\n+    let newptr: int = unsafe::reinterpret_cast(new);\n+    assert sptr != newptr;\n+    new\n+}\n+\n+fn clone_ivecstr(v: &str[]) -> str[] {\n+    let r = ~[];\n+    for t: str in ivec::slice(v, 0u, ivec::len(v)) {\n+        r += ~[clone_str(t)];\n+    }\n+    ret r;\n+}"}, {"sha": "9355ed5620e08eee06a7d83ace1dfb5292fa1e52", "filename": "src/test/compiletest/runtest.rs", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/a8af13e784ec81be80804e6e3bc31ee7190a2869/src%2Ftest%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8af13e784ec81be80804e6e3bc31ee7190a2869/src%2Ftest%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fruntest.rs?ref=a8af13e784ec81be80804e6e3bc31ee7190a2869", "patch": "@@ -0,0 +1,279 @@\n+import std::io;\n+import std::str;\n+import std::option;\n+import std::vec;\n+import std::fs;\n+import std::os;\n+import std::ivec;\n+import std::test;\n+\n+import common::mode_run_pass;\n+import common::mode_run_fail;\n+import common::mode_compile_fail;\n+import common::cx;\n+import common::config;\n+import header::load_props;\n+import header::test_props;\n+import util::logv;\n+\n+export run;\n+\n+fn run(cx: &cx, testfile: &str) {\n+    test::configure_test_task();\n+    if (cx.config.verbose) {\n+        // We're going to be dumping a lot of info. Start on a new line.\n+        io::stdout().write_str(\"\\n\\n\");\n+    }\n+    log #fmt(\"running %s\", testfile);\n+    let props = load_props(testfile);\n+    alt cx.config.mode {\n+      mode_compile_fail. { run_cfail_test(cx, props, testfile); }\n+      mode_run_fail. { run_rfail_test(cx, props, testfile); }\n+      mode_run_pass. { run_rpass_test(cx, props, testfile); }\n+    }\n+}\n+\n+fn run_cfail_test(cx: &cx, props: &test_props, testfile: &str) {\n+    let procres = compile_test(cx, props, testfile);\n+\n+    if procres.status == 0 {\n+        fatal_procres(\"compile-fail test compiled successfully!\",\n+                      procres);\n+    }\n+\n+    check_error_patterns(props, testfile, procres);\n+}\n+\n+fn run_rfail_test(cx: &cx, props: &test_props, testfile: &str) {\n+    let procres = compile_test(cx, props, testfile);\n+\n+    if procres.status != 0 {\n+        fatal_procres(\"compilation failed!\", procres); }\n+\n+    procres = exec_compiled_test(cx, testfile);\n+\n+    if procres.status == 0 {\n+        fatal_procres(\"run-fail test didn't produce an error!\",\n+                      procres);\n+    }\n+\n+    check_error_patterns(props, testfile, procres);\n+}\n+\n+fn run_rpass_test(cx: &cx, props: &test_props, testfile: &str) {\n+    let procres = compile_test(cx, props, testfile);\n+\n+    if procres.status != 0 {\n+        fatal_procres(\"compilation failed!\", procres); }\n+\n+    procres = exec_compiled_test(cx, testfile);\n+\n+\n+    if procres.status != 0 { fatal_procres(\"test run failed!\", procres); }\n+}\n+\n+fn check_error_patterns(props: &test_props, testfile: &str,\n+                        procres: &procres) {\n+    if ivec::is_empty(props.error_patterns) {\n+        fatal(\"no error pattern specified in \" + testfile);\n+    }\n+\n+    let next_err_idx = 0u;\n+    let next_err_pat = props.error_patterns.(next_err_idx);\n+    for line: str  in str::split(procres.stdout, '\\n' as u8) {\n+        if str::find(line, next_err_pat) > 0 {\n+            log #fmt(\"found error pattern %s\", next_err_pat);\n+            next_err_idx += 1u;\n+            if next_err_idx == ivec::len(props.error_patterns) {\n+                log \"found all error patterns\";\n+                ret;\n+            }\n+            next_err_pat = props.error_patterns.(next_err_idx);\n+        }\n+    }\n+\n+    let missing_patterns =\n+        ivec::slice(props.error_patterns, next_err_idx,\n+                    ivec::len(props.error_patterns));\n+    if ivec::len(missing_patterns) == 1u {\n+        fatal_procres(#fmt(\"error pattern '%s' not found!\",\n+                           missing_patterns.(0)), procres);\n+    } else {\n+        for pattern: str  in missing_patterns {\n+            error(#fmt(\"error pattern '%s' not found!\", pattern));\n+        }\n+        fatal_procres(\"multiple error patterns not found\", procres);\n+    }\n+}\n+\n+type procargs = {prog: str, args: vec[str]};\n+\n+type procres = {status: int, stdout: str, stderr: str, cmdline: str};\n+\n+fn compile_test(cx: &cx, props: &test_props, testfile: &str) -> procres {\n+    compose_and_run(cx, testfile, bind make_compile_args(_, props, _),\n+                    cx.config.compile_lib_path)\n+}\n+\n+fn exec_compiled_test(cx: &cx, testfile: &str) -> procres {\n+    compose_and_run(cx, testfile, make_run_args, cx.config.run_lib_path)\n+}\n+\n+fn compose_and_run(cx: &cx, testfile: &str,\n+                   make_args: fn(&config, &str) -> procargs ,\n+                   lib_path: &str) -> procres {\n+    let procargs = make_args(cx.config, testfile);\n+    ret program_output(cx, testfile, lib_path,\n+                       procargs.prog, procargs.args);\n+}\n+\n+fn make_compile_args(config: &config,\n+                     props: &test_props, testfile: &str) ->\n+    procargs {\n+    let prog = config.rustc_path;\n+    let args = [testfile, \"-o\", make_exe_name(config, testfile)];\n+    args += split_maybe_args(config.rustcflags);\n+    args += split_maybe_args(props.compile_flags);\n+    ret {prog: prog, args: args};\n+}\n+\n+fn make_exe_name(config: &config, testfile: &str) -> str {\n+    output_base_name(config, testfile) + os::exec_suffix()\n+}\n+\n+fn make_run_args(config: &config, testfile: &str) -> procargs {\n+    // If we've got another tool to run under (valgrind),\n+    // then split apart its command\n+    let args =\n+        split_maybe_args(config.runtool)\n+        + [make_exe_name(config, testfile)];\n+    ret {prog: args.(0), args: vec::slice(args, 1u, vec::len(args))};\n+}\n+\n+fn split_maybe_args(argstr: &option::t[str]) -> vec[str] {\n+    fn rm_whitespace(v: vec[str]) -> vec[str] {\n+        fn flt(s: &str) -> option::t[str] {\n+            if !is_whitespace(s) {\n+                option::some(s)\n+            } else {\n+                option::none\n+            }\n+        }\n+\n+        // FIXME: This should be in std\n+        fn is_whitespace(s: str) -> bool {\n+            for c: u8 in s {\n+                if c != (' ' as u8) { ret false; }\n+            }\n+            ret true;\n+        }\n+        vec::filter_map(flt, v)\n+    }\n+\n+    alt argstr {\n+      option::some(s) { rm_whitespace(str::split(s, ' ' as u8)) }\n+      option::none. { [] }\n+    }\n+}\n+\n+fn program_output(cx: &cx, testfile: &str, lib_path: &str, prog: &str,\n+                  args: &vec[str]) -> procres {\n+    let cmdline =\n+    {\n+        let cmdline = make_cmdline(lib_path, prog, args);\n+        logv(cx.config, #fmt(\"executing %s\", cmdline));\n+        cmdline\n+    };\n+    let res = procsrv::run(cx.procsrv, lib_path, prog, args);\n+    dump_output(cx.config, testfile, res.out, res.err);\n+    ret {status: res.status, stdout: res.out,\n+         stderr: res.err, cmdline: cmdline};\n+}\n+\n+fn make_cmdline(libpath: &str, prog: &str, args: &vec[str]) -> str {\n+    #fmt(\"%s %s %s\", lib_path_cmd_prefix(libpath), prog,\n+         str::connect(args, \" \"))\n+}\n+\n+// Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n+// for diagnostic purposes\n+fn lib_path_cmd_prefix(path: &str) -> str {\n+    #fmt(\"%s=\\\"%s\\\"\", util::lib_path_env_var(), util::make_new_path(path))\n+}\n+\n+fn dump_output(config: &config, testfile: &str,\n+               out: &str, err: &str) {\n+    dump_output_file(config, testfile, out, \"out\");\n+    dump_output_file(config, testfile, err, \"err\");\n+    maybe_dump_to_stdout(config, out, err);\n+}\n+\n+#[cfg(target_os = \"win32\")]\n+#[cfg(target_os = \"linux\")]\n+fn dump_output_file(config: &config, testfile: &str,\n+                    out: &str, extension: &str) {\n+    let outfile = make_out_name(config, testfile, extension);\n+    let writer = io::file_writer(outfile, [io::create, io::truncate]);\n+    writer.write_str(out);\n+}\n+\n+// FIXME (726): Can't use file_writer on mac\n+#[cfg(target_os = \"macos\")]\n+fn dump_output_file(config: &config, testfile: &str,\n+                    out: &str, extension: &str) {\n+}\n+\n+fn make_out_name(config: &config, testfile: &str,\n+                 extension: &str) -> str {\n+    output_base_name(config, testfile) + \".\" + extension\n+}\n+\n+fn output_base_name(config: &config, testfile: &str) -> str {\n+    let base = config.build_base;\n+    let filename =\n+        {\n+            let parts = str::split(fs::basename(testfile), '.' as u8);\n+            parts = vec::slice(parts, 0u, vec::len(parts) - 1u);\n+            str::connect(parts, \".\")\n+        };\n+    #fmt(\"%s%s.%s\", base, filename, config.stage_id)\n+}\n+\n+fn maybe_dump_to_stdout(config: &config,\n+                        out: &str, err: &str) {\n+    if config.verbose {\n+        let sep1 = #fmt(\"------%s------------------------------\",\n+                        \"stdout\");\n+        let sep2 = #fmt(\"------%s------------------------------\",\n+                        \"stderr\");\n+        let sep3 = \"------------------------------------------\";\n+        io::stdout().write_line(sep1);\n+        io::stdout().write_line(out);\n+        io::stdout().write_line(sep2);\n+        io::stdout().write_line(err);\n+        io::stdout().write_line(sep3);\n+    }\n+}\n+\n+fn error(err: &str) { io::stdout().write_line(#fmt(\"\\nerror: %s\", err)); }\n+\n+fn fatal(err: &str) -> ! { error(err); fail; }\n+\n+fn fatal_procres(err: &str, procres: procres) -> ! {\n+    let msg =\n+        #fmt(\"\\n\\\n+error: %s\\n\\\n+command: %s\\n\\\n+stdout:\\n\\\n+------------------------------------------\\n\\\n+%s\\n\\\n+------------------------------------------\\n\\\n+stderr:\\n\\\n+------------------------------------------\\n\\\n+%s\\n\\\n+------------------------------------------\\n\\\n+\\n\",\n+             err, procres.cmdline, procres.stdout, procres.stderr);\n+    io::stdout().write_str(msg);\n+    fail;\n+}"}, {"sha": "5f971777c751e49b5ce426a92370c3e966602e9c", "filename": "src/test/compiletest/util.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a8af13e784ec81be80804e6e3bc31ee7190a2869/src%2Ftest%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8af13e784ec81be80804e6e3bc31ee7190a2869/src%2Ftest%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Futil.rs?ref=a8af13e784ec81be80804e6e3bc31ee7190a2869", "patch": "@@ -0,0 +1,29 @@\n+import std::option;\n+import std::generic_os::getenv;\n+import std::io;\n+\n+import common::config;\n+\n+fn make_new_path(path: &str) -> str {\n+\n+    // Windows just uses PATH as the library search path, so we have to\n+    // maintain the current value while adding our own\n+    alt getenv(lib_path_env_var()) {\n+      option::some(curr) { #fmt(\"%s:%s\", path, curr) }\n+      option::none. { path }\n+    }\n+}\n+\n+#[cfg(target_os = \"linux\")]\n+fn lib_path_env_var() -> str { \"LD_LIBRARY_PATH\" }\n+\n+#[cfg(target_os = \"macos\")]\n+fn lib_path_env_var() -> str { \"DYLD_LIBRARY_PATH\" }\n+\n+#[cfg(target_os = \"win32\")]\n+fn lib_path_env_var() -> str { \"PATH\" }\n+\n+fn logv(config: &config, s: &str) {\n+    log s;\n+    if config.verbose { io::stdout().write_line(s); }\n+}"}]}