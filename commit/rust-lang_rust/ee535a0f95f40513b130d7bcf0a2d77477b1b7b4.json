{"sha": "ee535a0f95f40513b130d7bcf0a2d77477b1b7b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlNTM1YTBmOTVmNDA1MTNiMTMwZDdiY2YwYTJkNzc0NzdiMWI3YjQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-11-19T12:10:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-19T12:10:17Z"}, "message": "Rollup merge of #66431 - Aaron1011:fix/opaque-type-infer, r=varkor\n\nFix 'type annotations needed' error with opaque types\n\nRelated: #66426\n\nThis commit adds handling for opaque types during inference variable\nfallback. Type variables generated from the instantiation of opaque\ntypes now fallback to the opaque type itself.\n\nNormally, the type variable for an instantiated opaque type is either\nunified with the concrete type, or with the opaque type itself (e.g when\na function returns an opaque type by calling another function).\n\nHowever, it's possible for the type variable to be left completely\nunconstrained. This can occur in code like this:\n\n```rust\npub type Foo = impl Copy;\nfn produce() -> Option<Foo> {\n    None\n}\n```\n\nHere, we'll instantatiate the `Foo` in `Option<Foo>` to a fresh type\nvariable, but we will never unify it with anything due to the fact\nthat we return a `None`.\n\nThis results in the error message:\n```\ntype annotations needed: cannot resolve `_: std::marker::Copy\n```\n\npointing at `pub type Foo = impl Copy`.\n\nThis message is not only confusing, it's incorrect. When an opaque type\ninference variable is completely unconstrained, we can always fall back\nto using the opaque type itself. This effectively turns that particular\nuse of the opaque type into a non-defining use, even if it appears in a\ndefining scope.", "tree": {"sha": "4b5e021b18f4095da692f7e794d9d87749a6e8aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b5e021b18f4095da692f7e794d9d87749a6e8aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee535a0f95f40513b130d7bcf0a2d77477b1b7b4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd09upCRBK7hj4Ov3rIwAAdHIIAAOMb2XA8pcnJXsXFyT3AtS9\nDrZNMG94zsDCXA/U/eOk7z/acO83K5Q76sk6HrwQv9nOYM/GqbZQG2LrBVXb94wG\nCB4aWylFFzDjMkPC4cYARAFsP7bwNnJ53W/qbJEjYe6RK7n7LKLr0B0l4eVLS8Ry\nELrAY48foZnQUtMra6SL+Sh6MaUqyz4qGsmzxTMIMPneQ3ihBYCsdrLI7deIPP7d\nXAIdIEsGYj7yAM/SbiEB7xCcq+sx+nCKtzQPIpQSmGyfK1SYYpcJBSnonLJRB2x/\n5AjXoXVPtI9gwcEp7aFS9fJGdI3l3yl9Aj8luQZXuG2JT/BgyfYi24VP6EsRm34=\n=X0gl\n-----END PGP SIGNATURE-----\n", "payload": "tree 4b5e021b18f4095da692f7e794d9d87749a6e8aa\nparent 95b9766e0a43b4c527d3de62a781a2f5418655c6\nparent a11abe0d6b0f1a7a7bb4bdfde1dedfd89b357732\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1574165417 +0100\ncommitter GitHub <noreply@github.com> 1574165417 +0100\n\nRollup merge of #66431 - Aaron1011:fix/opaque-type-infer, r=varkor\n\nFix 'type annotations needed' error with opaque types\n\nRelated: #66426\n\nThis commit adds handling for opaque types during inference variable\nfallback. Type variables generated from the instantiation of opaque\ntypes now fallback to the opaque type itself.\n\nNormally, the type variable for an instantiated opaque type is either\nunified with the concrete type, or with the opaque type itself (e.g when\na function returns an opaque type by calling another function).\n\nHowever, it's possible for the type variable to be left completely\nunconstrained. This can occur in code like this:\n\n```rust\npub type Foo = impl Copy;\nfn produce() -> Option<Foo> {\n    None\n}\n```\n\nHere, we'll instantatiate the `Foo` in `Option<Foo>` to a fresh type\nvariable, but we will never unify it with anything due to the fact\nthat we return a `None`.\n\nThis results in the error message:\n```\ntype annotations needed: cannot resolve `_: std::marker::Copy\n```\n\npointing at `pub type Foo = impl Copy`.\n\nThis message is not only confusing, it's incorrect. When an opaque type\ninference variable is completely unconstrained, we can always fall back\nto using the opaque type itself. This effectively turns that particular\nuse of the opaque type into a non-defining use, even if it appears in a\ndefining scope.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee535a0f95f40513b130d7bcf0a2d77477b1b7b4", "html_url": "https://github.com/rust-lang/rust/commit/ee535a0f95f40513b130d7bcf0a2d77477b1b7b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee535a0f95f40513b130d7bcf0a2d77477b1b7b4/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95b9766e0a43b4c527d3de62a781a2f5418655c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/95b9766e0a43b4c527d3de62a781a2f5418655c6", "html_url": "https://github.com/rust-lang/rust/commit/95b9766e0a43b4c527d3de62a781a2f5418655c6"}, {"sha": "a11abe0d6b0f1a7a7bb4bdfde1dedfd89b357732", "url": "https://api.github.com/repos/rust-lang/rust/commits/a11abe0d6b0f1a7a7bb4bdfde1dedfd89b357732", "html_url": "https://github.com/rust-lang/rust/commit/a11abe0d6b0f1a7a7bb4bdfde1dedfd89b357732"}], "stats": {"total": 271, "additions": 205, "deletions": 66}, "files": [{"sha": "9b197c1ecb14076ff8c38d2a5bf5d20e19ced3ba", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ee535a0f95f40513b130d7bcf0a2d77477b1b7b4/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee535a0f95f40513b130d7bcf0a2d77477b1b7b4/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=ee535a0f95f40513b130d7bcf0a2d77477b1b7b4", "patch": "@@ -24,6 +24,10 @@ pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n /// appear in the return type).\n #[derive(Copy, Clone, Debug)]\n pub struct OpaqueTypeDecl<'tcx> {\n+\n+    /// The opaque type (`ty::Opaque`) for this declaration.\n+    pub opaque_type: Ty<'tcx>,\n+\n     /// The substitutions that we apply to the opaque type that this\n     /// `impl Trait` desugars to. e.g., if:\n     ///\n@@ -1150,6 +1154,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         self.opaque_types.insert(\n             def_id,\n             OpaqueTypeDecl {\n+                opaque_type: ty,\n                 substs,\n                 definition_span,\n                 concrete_ty: ty_var,"}, {"sha": "50c1a74fe911b80bc067836e453baddb70d1f8cf", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 107, "deletions": 4, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/ee535a0f95f40513b130d7bcf0a2d77477b1b7b4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee535a0f95f40513b130d7bcf0a2d77477b1b7b4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ee535a0f95f40513b130d7bcf0a2d77477b1b7b4", "patch": "@@ -147,7 +147,7 @@ use crate::TypeAndSubsts;\n use crate::lint;\n use crate::util::captures::Captures;\n use crate::util::common::{ErrorReported, indenter};\n-use crate::util::nodemap::{DefIdMap, DefIdSet, FxHashSet, HirIdMap};\n+use crate::util::nodemap::{DefIdMap, DefIdSet, FxHashMap, FxHashSet, HirIdMap};\n \n pub use self::Expectation::*;\n use self::autoderef::Autoderef;\n@@ -231,6 +231,13 @@ pub struct Inherited<'a, 'tcx> {\n     // 'de-opaque' OpaqueTypeDecl, after typeck is done with all functions.\n     opaque_types: RefCell<DefIdMap<OpaqueTypeDecl<'tcx>>>,\n \n+    /// A map from inference variables created from opaque\n+    /// type instantiations (`ty::Infer`) to the actual opaque\n+    /// type (`ty::Opaque`). Used during fallback to map unconstrained\n+    /// opaque type inference variables to their corresponding\n+    /// opaque type.\n+    opaque_types_vars: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n+\n     /// Each type parameter has an implicit region bound that\n     /// indicates it must outlive at least the function body (the user\n     /// may specify stronger requirements). This field indicates the\n@@ -696,6 +703,7 @@ impl Inherited<'a, 'tcx> {\n             deferred_cast_checks: RefCell::new(Vec::new()),\n             deferred_generator_interiors: RefCell::new(Vec::new()),\n             opaque_types: RefCell::new(Default::default()),\n+            opaque_types_vars: RefCell::new(Default::default()),\n             implicit_region_bound,\n             body_id,\n         }\n@@ -937,9 +945,46 @@ fn typeck_tables_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TypeckTables<'_> {\n         // All type checking constraints were added, try to fallback unsolved variables.\n         fcx.select_obligations_where_possible(false, |_| {});\n         let mut fallback_has_occurred = false;\n+\n+        // We do fallback in two passes, to try to generate\n+        // better error messages.\n+        // The first time, we do *not* replace opaque types.\n         for ty in &fcx.unsolved_variables() {\n-            fallback_has_occurred |= fcx.fallback_if_possible(ty);\n+            fallback_has_occurred |= fcx.fallback_if_possible(ty, FallbackMode::NoOpaque);\n+        }\n+        // We now see if we can make progress. This might\n+        // cause us to unify inference variables for opaque types,\n+        // since we may have unified some other type variables\n+        // during the first phase of fallback.\n+        // This means that we only replace inference variables with their underlying\n+        // opaque types as a last resort.\n+        //\n+        // In code like this:\n+        //\n+        // ```rust\n+        // type MyType = impl Copy;\n+        // fn produce() -> MyType { true }\n+        // fn bad_produce() -> MyType { panic!() }\n+        // ```\n+        //\n+        // we want to unify the opaque inference variable in `bad_produce`\n+        // with the diverging fallback for `panic!` (e.g. `()` or `!`).\n+        // This will produce a nice error message about conflicting concrete\n+        // types for `MyType`.\n+        //\n+        // If we had tried to fallback the opaque inference variable to `MyType`,\n+        // we will generate a confusing type-check error that does not explicitly\n+        // refer to opaque types.\n+        fcx.select_obligations_where_possible(fallback_has_occurred, |_| {});\n+\n+        // We now run fallback again, but this time we allow it to replace\n+        // unconstrained opaque type variables, in addition to performing\n+        // other kinds of fallback.\n+        for ty in &fcx.unsolved_variables() {\n+            fallback_has_occurred |= fcx.fallback_if_possible(ty, FallbackMode::All);\n         }\n+\n+        // See if we can make any more progress.\n         fcx.select_obligations_where_possible(fallback_has_occurred, |_| {});\n \n         // Even though coercion casts provide type hints, we check casts after fallback for\n@@ -2499,6 +2544,16 @@ enum TupleArgumentsFlag {\n     TupleArguments,\n }\n \n+/// Controls how we perform fallback for unconstrained\n+/// type variables.\n+enum FallbackMode {\n+    /// Do not fallback type variables to opaque types.\n+    NoOpaque,\n+    /// Perform all possible kinds of fallback, including\n+    /// turning type variables to opaque types.\n+    All,\n+}\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn new(\n         inh: &'a Inherited<'a, 'tcx>,\n@@ -2864,8 +2919,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         let mut opaque_types = self.opaque_types.borrow_mut();\n+        let mut opaque_types_vars = self.opaque_types_vars.borrow_mut();\n         for (ty, decl) in opaque_type_map {\n             let _ = opaque_types.insert(ty, decl);\n+            let _ = opaque_types_vars.insert(decl.concrete_ty, decl.opaque_type);\n         }\n \n         value\n@@ -3078,7 +3135,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // Fallback becomes very dubious if we have encountered type-checking errors.\n     // In that case, fallback to Error.\n     // The return value indicates whether fallback has occurred.\n-    fn fallback_if_possible(&self, ty: Ty<'tcx>) -> bool {\n+    fn fallback_if_possible(&self, ty: Ty<'tcx>, mode: FallbackMode) -> bool {\n         use rustc::ty::error::UnconstrainedNumeric::Neither;\n         use rustc::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n \n@@ -3088,7 +3145,53 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             UnconstrainedInt => self.tcx.types.i32,\n             UnconstrainedFloat => self.tcx.types.f64,\n             Neither if self.type_var_diverges(ty) => self.tcx.mk_diverging_default(),\n-            Neither => return false,\n+            Neither => {\n+                // This type variable was created from the instantiation of an opaque\n+                // type. The fact that we're attempting to perform fallback for it\n+                // means that the function neither constrained it to a concrete\n+                // type, nor to the opaque type itself.\n+                //\n+                // For example, in this code:\n+                //\n+                //```\n+                // type MyType = impl Copy;\n+                // fn defining_use() -> MyType { true }\n+                // fn other_use() -> MyType { defining_use() }\n+                // ```\n+                //\n+                // `defining_use` will constrain the instantiated inference\n+                // variable to `bool`, while `other_use` will constrain\n+                // the instantiated inference variable to `MyType`.\n+                //\n+                // When we process opaque types during writeback, we\n+                // will handle cases like `other_use`, and not count\n+                // them as defining usages\n+                //\n+                // However, we also need to handle cases like this:\n+                //\n+                // ```rust\n+                // pub type Foo = impl Copy;\n+                // fn produce() -> Option<Foo> {\n+                //     None\n+                //  }\n+                //  ```\n+                //\n+                // In the above snippet, the inference varaible created by\n+                // instantiating `Option<Foo>` will be completely unconstrained.\n+                // We treat this as a non-defining use by making the inference\n+                // variable fall back to the opaque type itself.\n+                if let FallbackMode::All = mode {\n+                    if let Some(opaque_ty) = self.opaque_types_vars.borrow().get(ty) {\n+                        debug!(\"fallback_if_possible: falling back opaque type var {:?} to {:?}\",\n+                               ty, opaque_ty);\n+                        *opaque_ty\n+                    } else {\n+                        return false;\n+                    }\n+                } else {\n+                    return false;\n+                }\n+            },\n         };\n         debug!(\"fallback_if_possible: defaulting `{:?}` to `{:?}`\", ty, fallback);\n         self.demand_eqtype(syntax_pos::DUMMY_SP, ty, fallback);"}, {"sha": "f7744ef1b3eaeb0da606b0e3625755b39090bca1", "filename": "src/test/ui/impl-trait/where-allowed-2.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ee535a0f95f40513b130d7bcf0a2d77477b1b7b4/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee535a0f95f40513b130d7bcf0a2d77477b1b7b4/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs?ref=ee535a0f95f40513b130d7bcf0a2d77477b1b7b4", "patch": "@@ -0,0 +1,9 @@\n+//! Ideally, these tests would go in `where-allowed.rs`, but we bail out\n+//! too early to display them.\n+use std::fmt::Debug;\n+\n+// Disallowed\n+fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n+//~^ ERROR opaque type expands to a recursive type\n+\n+fn main() {}"}, {"sha": "1de15014c1f8dd3cd46ce46f92d597eaffd3fc71", "filename": "src/test/ui/impl-trait/where-allowed-2.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ee535a0f95f40513b130d7bcf0a2d77477b1b7b4/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ee535a0f95f40513b130d7bcf0a2d77477b1b7b4/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr?ref=ee535a0f95f40513b130d7bcf0a2d77477b1b7b4", "patch": "@@ -0,0 +1,11 @@\n+error[E0720]: opaque type expands to a recursive type\n+  --> $DIR/where-allowed-2.rs:6:30\n+   |\n+LL | fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n+   |                              ^^^^^^^^^^ expands to a recursive type\n+   |\n+   = note: type resolves to itself\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0720`."}, {"sha": "211a14ed4dd9998a24445a990b51bb94ba11a5b5", "filename": "src/test/ui/impl-trait/where-allowed.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ee535a0f95f40513b130d7bcf0a2d77477b1b7b4/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee535a0f95f40513b130d7bcf0a2d77477b1b7b4/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.rs?ref=ee535a0f95f40513b130d7bcf0a2d77477b1b7b4", "patch": "@@ -11,10 +11,6 @@ fn in_return() -> impl Debug { panic!() }\n // Allowed\n fn in_adt_in_parameters(_: Vec<impl Debug>) { panic!() }\n \n-// Disallowed\n-fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n-//~^ ERROR type annotations needed\n-\n // Disallowed\n fn in_fn_parameter_in_parameters(_: fn(impl Debug)) { panic!() }\n //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n@@ -60,7 +56,6 @@ fn in_impl_Fn_return_in_parameters(_: &impl Fn() -> impl Debug) { panic!() }\n fn in_impl_Fn_parameter_in_return() -> &'static impl Fn(impl Debug) { panic!() }\n //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n //~| ERROR nested `impl Trait` is not allowed\n-//~| ERROR type annotations needed\n \n // Disallowed\n fn in_impl_Fn_return_in_return() -> &'static impl Fn() -> impl Debug { panic!() }"}, {"sha": "e5d2feff51cc45857419a51e850bb6fa138543ac", "filename": "src/test/ui/impl-trait/where-allowed.stderr", "status": "modified", "additions": 45, "deletions": 57, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/ee535a0f95f40513b130d7bcf0a2d77477b1b7b4/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ee535a0f95f40513b130d7bcf0a2d77477b1b7b4/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.stderr?ref=ee535a0f95f40513b130d7bcf0a2d77477b1b7b4", "patch": "@@ -1,5 +1,5 @@\n error[E0666]: nested `impl Trait` is not allowed\n-  --> $DIR/where-allowed.rs:51:51\n+  --> $DIR/where-allowed.rs:47:51\n    |\n LL | fn in_impl_Fn_parameter_in_parameters(_: &impl Fn(impl Debug)) { panic!() }\n    |                                           --------^^^^^^^^^^-\n@@ -8,7 +8,7 @@ LL | fn in_impl_Fn_parameter_in_parameters(_: &impl Fn(impl Debug)) { panic!() }\n    |                                           outer `impl Trait`\n \n error[E0666]: nested `impl Trait` is not allowed\n-  --> $DIR/where-allowed.rs:60:57\n+  --> $DIR/where-allowed.rs:56:57\n    |\n LL | fn in_impl_Fn_parameter_in_return() -> &'static impl Fn(impl Debug) { panic!() }\n    |                                                 --------^^^^^^^^^^-\n@@ -17,7 +17,7 @@ LL | fn in_impl_Fn_parameter_in_return() -> &'static impl Fn(impl Debug) { panic\n    |                                                 outer `impl Trait`\n \n error[E0658]: `impl Trait` in type aliases is unstable\n-  --> $DIR/where-allowed.rs:124:16\n+  --> $DIR/where-allowed.rs:119:16\n    |\n LL |     type Out = impl Debug;\n    |                ^^^^^^^^^^\n@@ -26,7 +26,7 @@ LL |     type Out = impl Debug;\n    = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n error[E0658]: `impl Trait` in type aliases is unstable\n-  --> $DIR/where-allowed.rs:160:23\n+  --> $DIR/where-allowed.rs:155:23\n    |\n LL | type InTypeAlias<R> = impl Debug;\n    |                       ^^^^^^^^^^\n@@ -35,7 +35,7 @@ LL | type InTypeAlias<R> = impl Debug;\n    = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n error[E0658]: `impl Trait` in type aliases is unstable\n-  --> $DIR/where-allowed.rs:164:39\n+  --> $DIR/where-allowed.rs:159:39\n    |\n LL | type InReturnInTypeAlias<R> = fn() -> impl Debug;\n    |                                       ^^^^^^^^^^\n@@ -44,242 +44,230 @@ LL | type InReturnInTypeAlias<R> = fn() -> impl Debug;\n    = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:19:40\n+  --> $DIR/where-allowed.rs:15:40\n    |\n LL | fn in_fn_parameter_in_parameters(_: fn(impl Debug)) { panic!() }\n    |                                        ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:23:42\n+  --> $DIR/where-allowed.rs:19:42\n    |\n LL | fn in_fn_return_in_parameters(_: fn() -> impl Debug) { panic!() }\n    |                                          ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:27:38\n+  --> $DIR/where-allowed.rs:23:38\n    |\n LL | fn in_fn_parameter_in_return() -> fn(impl Debug) { panic!() }\n    |                                      ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:31:40\n+  --> $DIR/where-allowed.rs:27:40\n    |\n LL | fn in_fn_return_in_return() -> fn() -> impl Debug { panic!() }\n    |                                        ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:35:49\n+  --> $DIR/where-allowed.rs:31:49\n    |\n LL | fn in_dyn_Fn_parameter_in_parameters(_: &dyn Fn(impl Debug)) { panic!() }\n    |                                                 ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:39:51\n+  --> $DIR/where-allowed.rs:35:51\n    |\n LL | fn in_dyn_Fn_return_in_parameters(_: &dyn Fn() -> impl Debug) { panic!() }\n    |                                                   ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:43:55\n+  --> $DIR/where-allowed.rs:39:55\n    |\n LL | fn in_dyn_Fn_parameter_in_return() -> &'static dyn Fn(impl Debug) { panic!() }\n    |                                                       ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:47:57\n+  --> $DIR/where-allowed.rs:43:57\n    |\n LL | fn in_dyn_Fn_return_in_return() -> &'static dyn Fn() -> impl Debug { panic!() }\n    |                                                         ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:51:51\n+  --> $DIR/where-allowed.rs:47:51\n    |\n LL | fn in_impl_Fn_parameter_in_parameters(_: &impl Fn(impl Debug)) { panic!() }\n    |                                                   ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:56:53\n+  --> $DIR/where-allowed.rs:52:53\n    |\n LL | fn in_impl_Fn_return_in_parameters(_: &impl Fn() -> impl Debug) { panic!() }\n    |                                                     ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:60:57\n+  --> $DIR/where-allowed.rs:56:57\n    |\n LL | fn in_impl_Fn_parameter_in_return() -> &'static impl Fn(impl Debug) { panic!() }\n    |                                                         ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:66:59\n+  --> $DIR/where-allowed.rs:61:59\n    |\n LL | fn in_impl_Fn_return_in_return() -> &'static impl Fn() -> impl Debug { panic!() }\n    |                                                           ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:70:38\n+  --> $DIR/where-allowed.rs:65:38\n    |\n LL | fn in_Fn_parameter_in_generics<F: Fn(impl Debug)> (_: F) { panic!() }\n    |                                      ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:74:40\n+  --> $DIR/where-allowed.rs:69:40\n    |\n LL | fn in_Fn_return_in_generics<F: Fn() -> impl Debug> (_: F) { panic!() }\n    |                                        ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:87:32\n+  --> $DIR/where-allowed.rs:82:32\n    |\n LL | struct InBraceStructField { x: impl Debug }\n    |                                ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:91:41\n+  --> $DIR/where-allowed.rs:86:41\n    |\n LL | struct InAdtInBraceStructField { x: Vec<impl Debug> }\n    |                                         ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:95:27\n+  --> $DIR/where-allowed.rs:90:27\n    |\n LL | struct InTupleStructField(impl Debug);\n    |                           ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:100:25\n+  --> $DIR/where-allowed.rs:95:25\n    |\n LL |     InBraceVariant { x: impl Debug },\n    |                         ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:102:20\n+  --> $DIR/where-allowed.rs:97:20\n    |\n LL |     InTupleVariant(impl Debug),\n    |                    ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:113:23\n+  --> $DIR/where-allowed.rs:108:23\n    |\n LL |     fn in_return() -> impl Debug;\n    |                       ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:131:34\n+  --> $DIR/where-allowed.rs:126:34\n    |\n LL |     fn in_trait_impl_return() -> impl Debug { () }\n    |                                  ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:144:33\n+  --> $DIR/where-allowed.rs:139:33\n    |\n LL |     fn in_foreign_parameters(_: impl Debug);\n    |                                 ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:147:31\n+  --> $DIR/where-allowed.rs:142:31\n    |\n LL |     fn in_foreign_return() -> impl Debug;\n    |                               ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:164:39\n+  --> $DIR/where-allowed.rs:159:39\n    |\n LL | type InReturnInTypeAlias<R> = fn() -> impl Debug;\n    |                                       ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:169:16\n+  --> $DIR/where-allowed.rs:164:16\n    |\n LL | impl PartialEq<impl Debug> for () {\n    |                ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:174:24\n+  --> $DIR/where-allowed.rs:169:24\n    |\n LL | impl PartialEq<()> for impl Debug {\n    |                        ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:179:6\n+  --> $DIR/where-allowed.rs:174:6\n    |\n LL | impl impl Debug {\n    |      ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:185:24\n+  --> $DIR/where-allowed.rs:180:24\n    |\n LL | impl InInherentImplAdt<impl Debug> {\n    |                        ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:191:11\n+  --> $DIR/where-allowed.rs:186:11\n    |\n LL |     where impl Debug: Debug\n    |           ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:198:15\n+  --> $DIR/where-allowed.rs:193:15\n    |\n LL |     where Vec<impl Debug>: Debug\n    |               ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:205:24\n+  --> $DIR/where-allowed.rs:200:24\n    |\n LL |     where T: PartialEq<impl Debug>\n    |                        ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:212:17\n+  --> $DIR/where-allowed.rs:207:17\n    |\n LL |     where T: Fn(impl Debug)\n    |                 ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:219:22\n+  --> $DIR/where-allowed.rs:214:22\n    |\n LL |     where T: Fn() -> impl Debug\n    |                      ^^^^^^^^^^\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:225:29\n+  --> $DIR/where-allowed.rs:220:29\n    |\n LL |     let _in_local_variable: impl Fn() = || {};\n    |                             ^^^^^^^^^\n    |\n    = help: add `#![feature(impl_trait_in_bindings)]` to the crate attributes to enable\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/where-allowed.rs:227:46\n+  --> $DIR/where-allowed.rs:222:46\n    |\n LL |     let _in_return_in_local_variable = || -> impl Fn() { || {} };\n    |                                              ^^^^^^^^^\n \n-error[E0282]: type annotations needed\n-  --> $DIR/where-allowed.rs:15:30\n-   |\n-LL | fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n-   |                              ^^^^^^^^^^ cannot infer type\n-\n-error[E0282]: type annotations needed\n-  --> $DIR/where-allowed.rs:60:49\n-   |\n-LL | fn in_impl_Fn_parameter_in_return() -> &'static impl Fn(impl Debug) { panic!() }\n-   |                                                 ^^^^^^^^^^^^^^^^^^^ cannot infer type\n-\n error: could not find defining uses\n-  --> $DIR/where-allowed.rs:160:1\n+  --> $DIR/where-allowed.rs:155:1\n    |\n LL | type InTypeAlias<R> = impl Debug;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: could not find defining uses\n-  --> $DIR/where-allowed.rs:124:5\n+  --> $DIR/where-allowed.rs:119:5\n    |\n LL |     type Out = impl Debug;\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 44 previous errors\n+error: aborting due to 42 previous errors\n \n-Some errors have detailed explanations: E0282, E0562, E0658, E0666.\n-For more information about an error, try `rustc --explain E0282`.\n+Some errors have detailed explanations: E0562, E0658, E0666.\n+For more information about an error, try `rustc --explain E0562`."}, {"sha": "fe1ca2230dacade16cd3108df900f4f594ce49cb", "filename": "src/test/ui/type-alias-impl-trait/fallback.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ee535a0f95f40513b130d7bcf0a2d77477b1b7b4/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee535a0f95f40513b130d7bcf0a2d77477b1b7b4/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffallback.rs?ref=ee535a0f95f40513b130d7bcf0a2d77477b1b7b4", "patch": "@@ -0,0 +1,28 @@\n+// Tests that we correctly handle the instantiated\n+// inference variable being completely unconstrained.\n+//\n+// check-pass\n+#![feature(type_alias_impl_trait)]\n+\n+type Foo = impl Copy;\n+\n+enum Wrapper<T> {\n+    First(T),\n+    Second\n+}\n+\n+// This method constrains `Foo` to be `bool`\n+fn constrained_foo() -> Foo {\n+    true\n+}\n+\n+\n+// This method does not constrain `Foo`.\n+// Per RFC 2071, function bodies may either\n+// fully constrain an opaque type, or place no\n+// constraints on it.\n+fn unconstrained_foo() -> Wrapper<Foo> {\n+    Wrapper::Second\n+}\n+\n+fn main() {}"}]}