{"sha": "c1a4b264064cecc9c979650416879670ec64a6cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxYTRiMjY0MDY0Y2VjYzljOTc5NjUwNDE2ODc5NjcwZWM2NGE2Y2M=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2019-08-26T09:11:43Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2019-08-26T09:11:43Z"}, "message": "Cleaner code for unsep literals", "tree": {"sha": "808e63e5cb616b9750a929e355f328f605959a06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/808e63e5cb616b9750a929e355f328f605959a06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1a4b264064cecc9c979650416879670ec64a6cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1a4b264064cecc9c979650416879670ec64a6cc", "html_url": "https://github.com/rust-lang/rust/commit/c1a4b264064cecc9c979650416879670ec64a6cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1a4b264064cecc9c979650416879670ec64a6cc/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05f603e6cec63d0b2681a84d4a64a51bccac1624", "url": "https://api.github.com/repos/rust-lang/rust/commits/05f603e6cec63d0b2681a84d4a64a51bccac1624", "html_url": "https://github.com/rust-lang/rust/commit/05f603e6cec63d0b2681a84d4a64a51bccac1624"}], "stats": {"total": 209, "additions": 126, "deletions": 83}, "files": [{"sha": "6ff2a404579767025bac63c71c4cdedbfa9b9d4b", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 73, "deletions": 73, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/c1a4b264064cecc9c979650416879670ec64a6cc/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1a4b264064cecc9c979650416879670ec64a6cc/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=c1a4b264064cecc9c979650416879670ec64a6cc", "patch": "@@ -6,7 +6,6 @@ use rustc::lint::{in_external_macro, EarlyContext, EarlyLintPass, LintArray, Lin\n use rustc::{declare_lint_pass, declare_tool_lint};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n-use std::char;\n use syntax::ast::*;\n use syntax::source_map::Span;\n use syntax::visit::{walk_expr, FnKind, Visitor};\n@@ -391,92 +390,93 @@ impl EarlyLintPass for MiscEarlyLints {\n \n impl MiscEarlyLints {\n     fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n-        if_chain! {\n-            if let LitKind::Int(value, ..) = lit.node;\n-            if let Some(src) = snippet_opt(cx, lit.span);\n-            if let Some(firstch) = src.chars().next();\n-            if char::to_digit(firstch, 10).is_some();\n-            then {\n-                let mut prev = '\\0';\n-                for (idx, ch) in src.chars().enumerate() {\n-                    if ch == 'i' || ch == 'u' {\n-                        if prev != '_' {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                UNSEPARATED_LITERAL_SUFFIX,\n-                                lit.span,\n-                                \"integer type suffix should be separated by an underscore\",\n-                                \"add an underscore\",\n-                                format!(\"{}_{}\", &src[0..idx], &src[idx..]),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                        break;\n-                    }\n-                    prev = ch;\n+        // The `line!()` macro is compiler built-in and a special case for these lints.\n+        let lit_snip = match snippet_opt(cx, lit.span) {\n+            Some(snip) => {\n+                if snip.contains('!') {\n+                    return;\n                 }\n-                if src.starts_with(\"0x\") {\n-                    let mut seen = (false, false);\n-                    for ch in src.chars() {\n-                        match ch {\n-                            'a' ..= 'f' => seen.0 = true,\n-                            'A' ..= 'F' => seen.1 = true,\n-                            'i' | 'u'   => break,   // start of suffix already\n-                            _ => ()\n-                        }\n+                snip\n+            },\n+            _ => return,\n+        };\n+\n+        if let LitKind::Int(value, lit_int_type) = lit.node {\n+            let suffix = match lit_int_type {\n+                LitIntType::Signed(ty) => ty.ty_to_string(),\n+                LitIntType::Unsigned(ty) => ty.ty_to_string(),\n+                LitIntType::Unsuffixed => \"\",\n+            };\n+\n+            let maybe_last_sep_idx = lit_snip.len() - suffix.len() - 1;\n+            // Do not lint when literal is unsuffixed.\n+            if !suffix.is_empty() && lit_snip.as_bytes()[maybe_last_sep_idx] != b'_' {\n+                span_lint_and_sugg(\n+                    cx,\n+                    UNSEPARATED_LITERAL_SUFFIX,\n+                    lit.span,\n+                    \"integer type suffix should be separated by an underscore\",\n+                    \"add an underscore\",\n+                    format!(\"{}_{}\", &lit_snip[..=maybe_last_sep_idx], suffix),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+\n+            if lit_snip.starts_with(\"0x\") {\n+                let mut seen = (false, false);\n+                for ch in lit_snip.as_bytes()[2..=maybe_last_sep_idx].iter() {\n+                    match ch {\n+                        b'a'..=b'f' => seen.0 = true,\n+                        b'A'..=b'F' => seen.1 = true,\n+                        _ => {},\n                     }\n                     if seen.0 && seen.1 {\n-                        span_lint(cx, MIXED_CASE_HEX_LITERALS, lit.span,\n-                                    \"inconsistent casing in hexadecimal literal\");\n+                        span_lint(\n+                            cx,\n+                            MIXED_CASE_HEX_LITERALS,\n+                            lit.span,\n+                            \"inconsistent casing in hexadecimal literal\",\n+                        );\n+                        break;\n                     }\n-                } else if src.starts_with(\"0b\") || src.starts_with(\"0o\") {\n-                    /* nothing to do */\n-                } else if value != 0 && src.starts_with('0') {\n-                    span_lint_and_then(cx,\n-                                        ZERO_PREFIXED_LITERAL,\n-                                        lit.span,\n-                                        \"this is a decimal constant\",\n-                                        |db| {\n+                }\n+            } else if lit_snip.starts_with(\"0b\") || lit_snip.starts_with(\"0o\") {\n+                /* nothing to do */\n+            } else if value != 0 && lit_snip.starts_with('0') {\n+                span_lint_and_then(\n+                    cx,\n+                    ZERO_PREFIXED_LITERAL,\n+                    lit.span,\n+                    \"this is a decimal constant\",\n+                    |db| {\n                         db.span_suggestion(\n                             lit.span,\n-                            \"if you mean to use a decimal constant, remove the `0` to remove confusion\",\n-                            src.trim_start_matches(|c| c == '_' || c == '0').to_string(),\n+                            \"if you mean to use a decimal constant, remove the `0` to avoid confusion\",\n+                            lit_snip.trim_start_matches(|c| c == '_' || c == '0').to_string(),\n                             Applicability::MaybeIncorrect,\n                         );\n                         db.span_suggestion(\n                             lit.span,\n                             \"if you mean to use an octal constant, use `0o`\",\n-                            format!(\"0o{}\", src.trim_start_matches(|c| c == '_' || c == '0')),\n+                            format!(\"0o{}\", lit_snip.trim_start_matches(|c| c == '_' || c == '0')),\n                             Applicability::MaybeIncorrect,\n                         );\n-                    });\n-                }\n+                    },\n+                );\n             }\n-        }\n-        if_chain! {\n-            if let LitKind::Float(..) = lit.node;\n-            if let Some(src) = snippet_opt(cx, lit.span);\n-            if let Some(firstch) = src.chars().next();\n-            if char::to_digit(firstch, 10).is_some();\n-            then {\n-                let mut prev = '\\0';\n-                for (idx, ch) in src.chars().enumerate() {\n-                    if ch == 'f' {\n-                        if prev != '_' {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                UNSEPARATED_LITERAL_SUFFIX,\n-                                lit.span,\n-                                \"float type suffix should be separated by an underscore\",\n-                                \"add an underscore\",\n-                                format!(\"{}_{}\", &src[0..idx], &src[idx..]),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                        break;\n-                    }\n-                    prev = ch;\n-                }\n+        } else if let LitKind::Float(_, float_ty) = lit.node {\n+            let suffix = float_ty.ty_to_string();\n+            let maybe_last_sep_idx = lit_snip.len() - suffix.len() - 1;\n+            if lit_snip.as_bytes()[maybe_last_sep_idx] != b'_' {\n+                span_lint_and_sugg(\n+                    cx,\n+                    UNSEPARATED_LITERAL_SUFFIX,\n+                    lit.span,\n+                    \"float type suffix should be separated by an underscore\",\n+                    \"add an underscore\",\n+                    format!(\"{}_{}\", &lit_snip[..=maybe_last_sep_idx], suffix),\n+                    Applicability::MachineApplicable,\n+                );\n             }\n         }\n     }"}, {"sha": "33321440d831a9fef5e974bdbac7c46142129a65", "filename": "tests/ui/literals.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1a4b264064cecc9c979650416879670ec64a6cc/tests%2Fui%2Fliterals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1a4b264064cecc9c979650416879670ec64a6cc/tests%2Fui%2Fliterals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fliterals.stderr?ref=c1a4b264064cecc9c979650416879670ec64a6cc", "patch": "@@ -25,7 +25,7 @@ LL |     let fail_multi_zero = 000_123usize;\n    |                           ^^^^^^^^^^^^\n    |\n    = note: `-D clippy::zero-prefixed-literal` implied by `-D warnings`\n-help: if you mean to use a decimal constant, remove the `0` to remove confusion\n+help: if you mean to use a decimal constant, remove the `0` to avoid confusion\n    |\n LL |     let fail_multi_zero = 123usize;\n    |                           ^^^^^^^^\n@@ -39,7 +39,7 @@ error: this is a decimal constant\n    |\n LL |     let fail8 = 0123;\n    |                 ^^^^\n-help: if you mean to use a decimal constant, remove the `0` to remove confusion\n+help: if you mean to use a decimal constant, remove the `0` to avoid confusion\n    |\n LL |     let fail8 = 123;\n    |                 ^^^"}, {"sha": "26bc47257b7954da284b8c58d1c08eb044dba9c3", "filename": "tests/ui/unseparated_prefix_literals.fixed", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c1a4b264064cecc9c979650416879670ec64a6cc/tests%2Fui%2Funseparated_prefix_literals.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c1a4b264064cecc9c979650416879670ec64a6cc/tests%2Fui%2Funseparated_prefix_literals.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funseparated_prefix_literals.fixed?ref=c1a4b264064cecc9c979650416879670ec64a6cc", "patch": "@@ -3,6 +3,12 @@\n #![warn(clippy::unseparated_literal_suffix)]\n #![allow(dead_code)]\n \n+macro_rules! lit_from_macro {\n+    () => {\n+        42_usize\n+    };\n+}\n+\n fn main() {\n     let _ok1 = 1234_i32;\n     let _ok2 = 1234_isize;\n@@ -17,4 +23,12 @@ fn main() {\n     let _okf2 = 1_f32;\n     let _failf1 = 1.5_f32;\n     let _failf2 = 1_f32;\n+\n+    // Test for macro\n+    let _ = lit_from_macro!();\n+\n+    // Counter example\n+    let _ = line!();\n+    // Because `assert!` contains `line!()` macro.\n+    assert_eq!(4897_u32, 32223);\n }"}, {"sha": "d710ccd1be2cd36ee546049ff2ef20f1e94b0984", "filename": "tests/ui/unseparated_prefix_literals.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c1a4b264064cecc9c979650416879670ec64a6cc/tests%2Fui%2Funseparated_prefix_literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1a4b264064cecc9c979650416879670ec64a6cc/tests%2Fui%2Funseparated_prefix_literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funseparated_prefix_literals.rs?ref=c1a4b264064cecc9c979650416879670ec64a6cc", "patch": "@@ -3,6 +3,12 @@\n #![warn(clippy::unseparated_literal_suffix)]\n #![allow(dead_code)]\n \n+macro_rules! lit_from_macro {\n+    () => {\n+        42usize\n+    };\n+}\n+\n fn main() {\n     let _ok1 = 1234_i32;\n     let _ok2 = 1234_isize;\n@@ -17,4 +23,12 @@ fn main() {\n     let _okf2 = 1_f32;\n     let _failf1 = 1.5f32;\n     let _failf2 = 1f32;\n+\n+    // Test for macro\n+    let _ = lit_from_macro!();\n+\n+    // Counter example\n+    let _ = line!();\n+    // Because `assert!` contains `line!()` macro.\n+    assert_eq!(4897u32, 32223);\n }"}, {"sha": "85f1881949eb72a1dc631f4709a45693ac9a7e46", "filename": "tests/ui/unseparated_prefix_literals.stderr", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c1a4b264064cecc9c979650416879670ec64a6cc/tests%2Fui%2Funseparated_prefix_literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1a4b264064cecc9c979650416879670ec64a6cc/tests%2Fui%2Funseparated_prefix_literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funseparated_prefix_literals.stderr?ref=c1a4b264064cecc9c979650416879670ec64a6cc", "patch": "@@ -1,46 +1,61 @@\n error: integer type suffix should be separated by an underscore\n-  --> $DIR/unseparated_prefix_literals.rs:10:18\n+  --> $DIR/unseparated_prefix_literals.rs:16:18\n    |\n LL |     let _fail1 = 1234i32;\n    |                  ^^^^^^^ help: add an underscore: `1234_i32`\n    |\n    = note: `-D clippy::unseparated-literal-suffix` implied by `-D warnings`\n \n error: integer type suffix should be separated by an underscore\n-  --> $DIR/unseparated_prefix_literals.rs:11:18\n+  --> $DIR/unseparated_prefix_literals.rs:17:18\n    |\n LL |     let _fail2 = 1234u32;\n    |                  ^^^^^^^ help: add an underscore: `1234_u32`\n \n error: integer type suffix should be separated by an underscore\n-  --> $DIR/unseparated_prefix_literals.rs:12:18\n+  --> $DIR/unseparated_prefix_literals.rs:18:18\n    |\n LL |     let _fail3 = 1234isize;\n    |                  ^^^^^^^^^ help: add an underscore: `1234_isize`\n \n error: integer type suffix should be separated by an underscore\n-  --> $DIR/unseparated_prefix_literals.rs:13:18\n+  --> $DIR/unseparated_prefix_literals.rs:19:18\n    |\n LL |     let _fail4 = 1234usize;\n    |                  ^^^^^^^^^ help: add an underscore: `1234_usize`\n \n error: integer type suffix should be separated by an underscore\n-  --> $DIR/unseparated_prefix_literals.rs:14:18\n+  --> $DIR/unseparated_prefix_literals.rs:20:18\n    |\n LL |     let _fail5 = 0x123isize;\n    |                  ^^^^^^^^^^ help: add an underscore: `0x123_isize`\n \n error: float type suffix should be separated by an underscore\n-  --> $DIR/unseparated_prefix_literals.rs:18:19\n+  --> $DIR/unseparated_prefix_literals.rs:24:19\n    |\n LL |     let _failf1 = 1.5f32;\n    |                   ^^^^^^ help: add an underscore: `1.5_f32`\n \n error: float type suffix should be separated by an underscore\n-  --> $DIR/unseparated_prefix_literals.rs:19:19\n+  --> $DIR/unseparated_prefix_literals.rs:25:19\n    |\n LL |     let _failf2 = 1f32;\n    |                   ^^^^ help: add an underscore: `1_f32`\n \n-error: aborting due to 7 previous errors\n+error: integer type suffix should be separated by an underscore\n+  --> $DIR/unseparated_prefix_literals.rs:8:9\n+   |\n+LL |         42usize\n+   |         ^^^^^^^ help: add an underscore: `42_usize`\n+...\n+LL |     let _ = lit_from_macro!();\n+   |             ----------------- in this macro invocation\n+\n+error: integer type suffix should be separated by an underscore\n+  --> $DIR/unseparated_prefix_literals.rs:33:16\n+   |\n+LL |     assert_eq!(4897u32, 32223);\n+   |                ^^^^^^^ help: add an underscore: `4897_u32`\n+\n+error: aborting due to 9 previous errors\n "}]}