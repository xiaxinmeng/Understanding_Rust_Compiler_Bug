{"sha": "0cfc08d81e7cc664330ce9d38a874c14a4ae51bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjZmMwOGQ4MWU3Y2M2NjQzMzBjZTlkMzhhODc0YzE0YTRhZTUxYmY=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T03:09:51Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T13:02:54Z"}, "message": "std: convert character-based str::find_* to methods. Add .slice_{to,from} methods.", "tree": {"sha": "ad575636aa13556e1f6cb605b77c296e87596499", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad575636aa13556e1f6cb605b77c296e87596499"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf", "html_url": "https://github.com/rust-lang/rust/commit/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76fc9be5a1634c8b7ebf766f51ad594d9012fe9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/76fc9be5a1634c8b7ebf766f51ad594d9012fe9c", "html_url": "https://github.com/rust-lang/rust/commit/76fc9be5a1634c8b7ebf766f51ad594d9012fe9c"}], "stats": {"total": 563, "additions": 158, "deletions": 405}, "files": [{"sha": "8f493fa2d064d3892cb3f2f7681b35e605620386", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=0cfc08d81e7cc664330ce9d38a874c14a4ae51bf", "patch": "@@ -417,7 +417,7 @@ fn scan_until_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n-    let opt = str::find_char_from(haystack, needle, *idx);\n+    let opt = haystack.slice_from(*idx).find(needle);\n     if opt.is_none() {\n         return false;\n     }"}, {"sha": "95aea33d31a90a8bc283abcf7a68379d64518246", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=0cfc08d81e7cc664330ce9d38a874c14a4ae51bf", "patch": "@@ -375,7 +375,7 @@ pub fn check_variants_T<T:Copy>(crate: @ast::crate,\n }\n \n pub fn last_part(filename: ~str) -> ~str {\n-    let ix = str::rfind_char(filename, '/').get();\n+    let ix = filename.rfind('/').get();\n     filename.slice(ix + 1u, filename.len() - 3u).to_owned()\n }\n "}, {"sha": "7462067162dc767b25796e94786e89bcdffa974e", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=0cfc08d81e7cc664330ce9d38a874c14a4ae51bf", "patch": "@@ -841,26 +841,11 @@ fn check_item_non_camel_case_types(cx: &Context, it: @ast::item) {\n     fn is_camel_case(cx: ty::ctxt, ident: ast::ident) -> bool {\n         let ident = cx.sess.str_of(ident);\n         assert!(!ident.is_empty());\n-        let ident = ident_without_trailing_underscores(*ident);\n-        let ident = ident_without_leading_underscores(ident);\n+        let ident = ident.trim_chars(&['_']);\n         char::is_uppercase(str::char_at(ident, 0)) &&\n             !ident.contains_char('_')\n     }\n \n-    fn ident_without_trailing_underscores<'r>(ident: &'r str) -> &'r str {\n-        match str::rfind(ident, |c| c != '_') {\n-            Some(idx) => ident.slice(0, idx + 1),\n-            None => ident, // all underscores\n-        }\n-    }\n-\n-    fn ident_without_leading_underscores<'r>(ident: &'r str) -> &'r str {\n-        match str::find(ident, |c| c != '_') {\n-            Some(idx) => ident.slice(idx, ident.len()),\n-            None => ident // all underscores\n-        }\n-    }\n-\n     fn check_case(cx: &Context, ident: ast::ident, span: span) {\n         if !is_camel_case(cx.tcx, ident) {\n             cx.span_lint(non_camel_case_types, span,"}, {"sha": "dd70c2bfb563f04534ad1869ba6f47d6ed831e4a", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=0cfc08d81e7cc664330ce9d38a874c14a4ae51bf", "patch": "@@ -2681,7 +2681,7 @@ impl Resolver {\n         match module_prefix_result {\n             Failed => {\n                 let mpath = self.idents_to_str(module_path);\n-                match str::rfind(self.idents_to_str(module_path), |c| { c == ':' }) {\n+                match self.idents_to_str(module_path).rfind(':') {\n                     Some(idx) => {\n                         self.session.span_err(span, fmt!(\"unresolved import: could not find `%s` \\\n                                                          in `%s`\", str::substr(mpath, idx,"}, {"sha": "0f4ade0551de74384be7793ad9250cc50353efe6", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=0cfc08d81e7cc664330ce9d38a874c14a4ae51bf", "patch": "@@ -118,19 +118,17 @@ fn first_sentence_(s: &str) -> ~str {\n     let mut dotcount = 0;\n     // The index of the character following a single dot. This allows\n     // Things like [0..1) to appear in the brief description\n-    let idx = do str::find(s) |ch| {\n+    let idx = s.find(|ch: char| {\n         if ch == '.' {\n             dotcount += 1;\n             false\n+        } else if dotcount == 1 {\n+            true\n         } else {\n-            if dotcount == 1 {\n-                true\n-            } else {\n-                dotcount = 0;\n-                false\n-            }\n+            dotcount = 0;\n+            false\n         }\n-    };\n+    });\n     match idx {\n         Some(idx) if idx > 2u => {\n             str::to_owned(s.slice(0, idx - 1))"}, {"sha": "b38f440a941f32a25ad256886fdd0f7ce7a772af", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=0cfc08d81e7cc664330ce9d38a874c14a4ae51bf", "patch": "@@ -175,7 +175,7 @@ pub fn split_version<'a>(s: &'a str) -> Option<(&'a str, Version)> {\n     if { let mut i: uint = 0; for str::to_chars(s).each |&c| { if c == '#' { i += 1; } }; i > 1 } {\n         return None;\n     }\n-    match str::rfind_char(s, '#') {\n+    match s.rfind('#') {\n         Some(i) => {\n             debug!(\"in %s, i = %?\", s, i);\n             let path = s.slice(0, i);"}, {"sha": "4df07830b2386d13627791cb574b10c7629d2fc1", "filename": "src/libstd/path.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=0cfc08d81e7cc664330ce9d38a874c14a4ae51bf", "patch": "@@ -479,8 +479,8 @@ impl GenericPath for PosixPath {\n         match self.filename() {\n             None => None,\n             Some(ref f) => {\n-                match str::rfind_char(*f, '.') {\n-                    Some(p) => Some(f.slice(0, p).to_owned()),\n+                match f.rfind('.') {\n+                    Some(p) => Some(f.slice_to(p).to_owned()),\n                     None => Some(copy *f),\n                 }\n             }\n@@ -491,8 +491,8 @@ impl GenericPath for PosixPath {\n         match self.filename() {\n             None => None,\n             Some(ref f) => {\n-                match str::rfind_char(*f, '.') {\n-                    Some(p) if p < f.len() => Some(f.slice(p, f.len()).to_owned()),\n+                match f.rfind('.') {\n+                    Some(p) if p < f.len() => Some(f.slice_from(p).to_owned()),\n                     _ => None,\n                 }\n             }\n@@ -693,8 +693,8 @@ impl GenericPath for WindowsPath {\n         match self.filename() {\n             None => None,\n             Some(ref f) => {\n-                match str::rfind_char(*f, '.') {\n-                    Some(p) => Some(f.slice(0, p).to_owned()),\n+                match f.rfind('.') {\n+                    Some(p) => Some(f.slice_to(p).to_owned()),\n                     None => Some(copy *f),\n                 }\n             }\n@@ -705,8 +705,8 @@ impl GenericPath for WindowsPath {\n         match self.filename() {\n           None => None,\n           Some(ref f) => {\n-            match str::rfind_char(*f, '.') {\n-                Some(p) if p < f.len() => Some(f.slice(p, f.len()).to_owned()),\n+            match f.rfind('.') {\n+                Some(p) if p < f.len() => Some(f.slice_from(p).to_owned()),\n                 _ => None,\n             }\n           }"}, {"sha": "a7f152a27e592fa877387aab23fa7a8df9212e00", "filename": "src/libstd/str.rs", "status": "modified", "additions": 134, "deletions": 363, "changes": 497, "blob_url": "https://github.com/rust-lang/rust/blob/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=0cfc08d81e7cc664330ce9d38a874c14a4ae51bf", "patch": "@@ -21,6 +21,7 @@ use at_vec;\n use cast::transmute;\n use cast;\n use char;\n+use char::Char;\n use clone::Clone;\n use cmp::{TotalOrd, Ordering, Less, Equal, Greater};\n use container::Container;\n@@ -510,7 +511,7 @@ pub fn unshift_char(s: &mut ~str, ch: char) {\n pub fn trim_left_chars<'a>(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n     if chars_to_trim.is_empty() { return s; }\n \n-    match find(s, |c| !chars_to_trim.contains(&c)) {\n+    match s.find(|c| !chars_to_trim.contains(&c)) {\n       None => \"\",\n       Some(first) => unsafe { raw::slice_bytes(s, first, s.len()) }\n     }\n@@ -528,7 +529,7 @@ pub fn trim_left_chars<'a>(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n pub fn trim_right_chars<'a>(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n     if chars_to_trim.is_empty() { return s; }\n \n-    match rfind(s, |c| !chars_to_trim.contains(&c)) {\n+    match s.rfind(|c| !chars_to_trim.contains(&c)) {\n       None => \"\",\n       Some(last) => {\n         let next = char_range_at(s, last).next;\n@@ -552,15 +553,15 @@ pub fn trim_chars<'a>(s: &'a str, chars_to_trim: &[char]) -> &'a str {\n \n /// Returns a string with leading whitespace removed\n pub fn trim_left<'a>(s: &'a str) -> &'a str {\n-    match find(s, |c| !char::is_whitespace(c)) {\n+    match s.find(|c| !char::is_whitespace(c)) {\n       None => \"\",\n       Some(first) => unsafe { raw::slice_bytes(s, first, s.len()) }\n     }\n }\n \n /// Returns a string with trailing whitespace removed\n pub fn trim_right<'a>(s: &'a str) -> &'a str {\n-    match rfind(s, |c| !char::is_whitespace(c)) {\n+    match s.rfind(|c| !char::is_whitespace(c)) {\n       None => \"\",\n       Some(last) => {\n         let next = char_range_at(s, last).next;\n@@ -621,6 +622,34 @@ pub fn substr<'a>(s: &'a str, begin: uint, n: uint) -> &'a str {\n     s.slice(begin, begin + count_bytes(s, begin, n))\n }\n \n+/// Something that can be used to compare against a character\n+pub trait CharEq {\n+    /// Determine if the splitter should split at the given character\n+    fn matches(&self, char) -> bool;\n+    /// Indicate if this is only concerned about ASCII characters,\n+    /// which can allow for a faster implementation.\n+    fn only_ascii(&self) -> bool;\n+}\n+impl CharEq for char {\n+    #[inline(always)]\n+    fn matches(&self, c: char) -> bool { *self == c }\n+\n+    fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n+}\n+impl<'self> CharEq for &'self fn(char) -> bool {\n+    #[inline(always)]\n+    fn matches(&self, c: char) -> bool { (*self)(c) }\n+\n+    fn only_ascii(&self) -> bool { false }\n+}\n+impl CharEq for extern \"Rust\" fn(char) -> bool {\n+    #[inline(always)]\n+    fn matches(&self, c: char) -> bool { (*self)(c) }\n+\n+    fn only_ascii(&self) -> bool { false }\n+}\n+\n+\n /// An iterator over the substrings of a string, separated by `sep`.\n pub struct StrCharSplitIterator<'self,Sep> {\n     priv string: &'self str,\n@@ -639,34 +668,7 @@ pub type WordIterator<'self> =\n     FilterIterator<'self, &'self str,\n              StrCharSplitIterator<'self, extern \"Rust\" fn(char) -> bool>>;\n \n-/// A separator for splitting a string character-wise\n-pub trait StrCharSplitSeparator {\n-    /// Determine if the splitter should split at the given character\n-    fn should_split(&self, char) -> bool;\n-    /// Indicate if the splitter only uses ASCII characters, which\n-    /// allows for a faster implementation.\n-    fn only_ascii(&self) -> bool;\n-}\n-impl StrCharSplitSeparator for char {\n-    #[inline(always)]\n-    fn should_split(&self, c: char) -> bool { *self == c }\n-\n-    fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n-}\n-impl<'self> StrCharSplitSeparator for &'self fn(char) -> bool {\n-    #[inline(always)]\n-    fn should_split(&self, c: char) -> bool { (*self)(c) }\n-\n-    fn only_ascii(&self) -> bool { false }\n-}\n-impl<'self> StrCharSplitSeparator for extern \"Rust\" fn(char) -> bool {\n-    #[inline(always)]\n-    fn should_split(&self, c: char) -> bool { (*self)(c) }\n-\n-    fn only_ascii(&self) -> bool { false }\n-}\n-\n-impl<'self, Sep: StrCharSplitSeparator> Iterator<&'self str> for StrCharSplitIterator<'self, Sep> {\n+impl<'self, Sep: CharEq> Iterator<&'self str> for StrCharSplitIterator<'self, Sep> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self str> {\n         if self.finished { return None }\n@@ -680,7 +682,7 @@ impl<'self, Sep: StrCharSplitSeparator> Iterator<&'self str> for StrCharSplitIte\n             while self.position < l && self.count > 0 {\n                 let byte = self.string[self.position];\n \n-                if self.sep.should_split(byte as char) {\n+                if self.sep.matches(byte as char) {\n                     let slice = unsafe { raw::slice_bytes(self.string, start, self.position) };\n                     self.position += 1;\n                     self.count -= 1;\n@@ -692,7 +694,7 @@ impl<'self, Sep: StrCharSplitSeparator> Iterator<&'self str> for StrCharSplitIte\n             while self.position < l && self.count > 0 {\n                 let CharRange {ch, next} = char_range_at(self.string, self.position);\n \n-                if self.sep.should_split(ch) {\n+                if self.sep.matches(ch) {\n                     let slice = unsafe { raw::slice_bytes(self.string, start, self.position) };\n                     self.position = next;\n                     self.count -= 1;\n@@ -1157,318 +1159,6 @@ pub fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n Section: Searching\n */\n \n-/**\n- * Returns the byte index of the first matching character\n- *\n- * # Arguments\n- *\n- * * `s` - The string to search\n- * * `c` - The character to search for\n- *\n- * # Return value\n- *\n- * An `option` containing the byte index of the first matching character\n- * or `none` if there is no match\n- */\n-pub fn find_char(s: &str, c: char) -> Option<uint> {\n-    find_char_between(s, c, 0u, s.len())\n-}\n-\n-/**\n- * Returns the byte index of the first matching character beginning\n- * from a given byte offset\n- *\n- * # Arguments\n- *\n- * * `s` - The string to search\n- * * `c` - The character to search for\n- * * `start` - The byte index to begin searching at, inclusive\n- *\n- * # Return value\n- *\n- * An `option` containing the byte index of the first matching character\n- * or `none` if there is no match\n- *\n- * # Failure\n- *\n- * `start` must be less than or equal to `s.len()`. `start` must be the\n- * index of a character boundary, as defined by `is_char_boundary`.\n- */\n-pub fn find_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n-    find_char_between(s, c, start, s.len())\n-}\n-\n-/**\n- * Returns the byte index of the first matching character within a given range\n- *\n- * # Arguments\n- *\n- * * `s` - The string to search\n- * * `c` - The character to search for\n- * * `start` - The byte index to begin searching at, inclusive\n- * * `end` - The byte index to end searching at, exclusive\n- *\n- * # Return value\n- *\n- * An `option` containing the byte index of the first matching character\n- * or `none` if there is no match\n- *\n- * # Failure\n- *\n- * `start` must be less than or equal to `end` and `end` must be less than\n- * or equal to `s.len()`. `start` must be the index of a character boundary,\n- * as defined by `is_char_boundary`.\n- */\n-pub fn find_char_between(s: &str, c: char, start: uint, end: uint)\n-    -> Option<uint> {\n-    if c < 128u as char {\n-        assert!(start <= end);\n-        assert!(end <= s.len());\n-        let mut i = start;\n-        let b = c as u8;\n-        while i < end {\n-            if s[i] == b { return Some(i); }\n-            i += 1u;\n-        }\n-        return None;\n-    } else {\n-        find_between(s, start, end, |x| x == c)\n-    }\n-}\n-\n-/**\n- * Returns the byte index of the last matching character\n- *\n- * # Arguments\n- *\n- * * `s` - The string to search\n- * * `c` - The character to search for\n- *\n- * # Return value\n- *\n- * An `option` containing the byte index of the last matching character\n- * or `none` if there is no match\n- */\n-pub fn rfind_char(s: &str, c: char) -> Option<uint> {\n-    rfind_char_between(s, c, s.len(), 0u)\n-}\n-\n-/**\n- * Returns the byte index of the last matching character beginning\n- * from a given byte offset\n- *\n- * # Arguments\n- *\n- * * `s` - The string to search\n- * * `c` - The character to search for\n- * * `start` - The byte index to begin searching at, exclusive\n- *\n- * # Return value\n- *\n- * An `option` containing the byte index of the last matching character\n- * or `none` if there is no match\n- *\n- * # Failure\n- *\n- * `start` must be less than or equal to `s.len()`. `start` must be\n- * the index of a character boundary, as defined by `is_char_boundary`.\n- */\n-pub fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n-    rfind_char_between(s, c, start, 0u)\n-}\n-\n-/**\n- * Returns the byte index of the last matching character within a given range\n- *\n- * # Arguments\n- *\n- * * `s` - The string to search\n- * * `c` - The character to search for\n- * * `start` - The byte index to begin searching at, exclusive\n- * * `end` - The byte index to end searching at, inclusive\n- *\n- * # Return value\n- *\n- * An `option` containing the byte index of the last matching character\n- * or `none` if there is no match\n- *\n- * # Failure\n- *\n- * `end` must be less than or equal to `start` and `start` must be less than\n- * or equal to `s.len()`. `start` must be the index of a character boundary,\n- * as defined by `is_char_boundary`.\n- */\n-pub fn rfind_char_between(s: &str, c: char, start: uint, end: uint) -> Option<uint> {\n-    if c < 128u as char {\n-        assert!(start >= end);\n-        assert!(start <= s.len());\n-        let mut i = start;\n-        let b = c as u8;\n-        while i > end {\n-            i -= 1u;\n-            if s[i] == b { return Some(i); }\n-        }\n-        return None;\n-    } else {\n-        rfind_between(s, start, end, |x| x == c)\n-    }\n-}\n-\n-/**\n- * Returns the byte index of the first character that satisfies\n- * the given predicate\n- *\n- * # Arguments\n- *\n- * * `s` - The string to search\n- * * `f` - The predicate to satisfy\n- *\n- * # Return value\n- *\n- * An `option` containing the byte index of the first matching character\n- * or `none` if there is no match\n- */\n-pub fn find(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n-    find_between(s, 0u, s.len(), f)\n-}\n-\n-/**\n- * Returns the byte index of the first character that satisfies\n- * the given predicate, beginning from a given byte offset\n- *\n- * # Arguments\n- *\n- * * `s` - The string to search\n- * * `start` - The byte index to begin searching at, inclusive\n- * * `f` - The predicate to satisfy\n- *\n- * # Return value\n- *\n- * An `option` containing the byte index of the first matching charactor\n- * or `none` if there is no match\n- *\n- * # Failure\n- *\n- * `start` must be less than or equal to `s.len()`. `start` must be the\n- * index of a character boundary, as defined by `is_char_boundary`.\n- */\n-pub fn find_from(s: &str, start: uint, f: &fn(char)\n-    -> bool) -> Option<uint> {\n-    find_between(s, start, s.len(), f)\n-}\n-\n-/**\n- * Returns the byte index of the first character that satisfies\n- * the given predicate, within a given range\n- *\n- * # Arguments\n- *\n- * * `s` - The string to search\n- * * `start` - The byte index to begin searching at, inclusive\n- * * `end` - The byte index to end searching at, exclusive\n- * * `f` - The predicate to satisfy\n- *\n- * # Return value\n- *\n- * An `option` containing the byte index of the first matching character\n- * or `none` if there is no match\n- *\n- * # Failure\n- *\n- * `start` must be less than or equal to `end` and `end` must be less than\n- * or equal to `s.len()`. `start` must be the index of a character\n- * boundary, as defined by `is_char_boundary`.\n- */\n-pub fn find_between(s: &str, start: uint, end: uint, f: &fn(char) -> bool) -> Option<uint> {\n-    assert!(start <= end);\n-    assert!(end <= s.len());\n-    assert!(is_char_boundary(s, start));\n-    let mut i = start;\n-    while i < end {\n-        let CharRange {ch, next} = char_range_at(s, i);\n-        if f(ch) { return Some(i); }\n-        i = next;\n-    }\n-    return None;\n-}\n-\n-/**\n- * Returns the byte index of the last character that satisfies\n- * the given predicate\n- *\n- * # Arguments\n- *\n- * * `s` - The string to search\n- * * `f` - The predicate to satisfy\n- *\n- * # Return value\n- *\n- * An option containing the byte index of the last matching character\n- * or `none` if there is no match\n- */\n-pub fn rfind(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n-    rfind_between(s, s.len(), 0u, f)\n-}\n-\n-/**\n- * Returns the byte index of the last character that satisfies\n- * the given predicate, beginning from a given byte offset\n- *\n- * # Arguments\n- *\n- * * `s` - The string to search\n- * * `start` - The byte index to begin searching at, exclusive\n- * * `f` - The predicate to satisfy\n- *\n- * # Return value\n- *\n- * An `option` containing the byte index of the last matching character\n- * or `none` if there is no match\n- *\n- * # Failure\n- *\n- * `start` must be less than or equal to `s.len()', `start` must be the\n- * index of a character boundary, as defined by `is_char_boundary`\n- */\n-pub fn rfind_from(s: &str, start: uint, f: &fn(char) -> bool) -> Option<uint> {\n-    rfind_between(s, start, 0u, f)\n-}\n-\n-/**\n- * Returns the byte index of the last character that satisfies\n- * the given predicate, within a given range\n- *\n- * # Arguments\n- *\n- * * `s` - The string to search\n- * * `start` - The byte index to begin searching at, exclusive\n- * * `end` - The byte index to end searching at, inclusive\n- * * `f` - The predicate to satisfy\n- *\n- * # Return value\n- *\n- * An `option` containing the byte index of the last matching character\n- * or `none` if there is no match\n- *\n- * # Failure\n- *\n- * `end` must be less than or equal to `start` and `start` must be less\n- * than or equal to `s.len()`. `start` must be the index of a character\n- * boundary, as defined by `is_char_boundary`\n- */\n-pub fn rfind_between(s: &str, start: uint, end: uint, f: &fn(char) -> bool) -> Option<uint> {\n-    assert!(start >= end);\n-    assert!(start <= s.len());\n-    assert!(is_char_boundary(s, start));\n-    let mut i = start;\n-    while i > end {\n-        let CharRange {ch, next: prev} = char_range_at_reverse(s, i);\n-        if f(ch) { return Some(prev); }\n-        i = prev;\n-    }\n-    return None;\n-}\n-\n // Utility used by various searching functions\n fn match_at<'a,'b>(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n     let mut i = at;\n@@ -1580,7 +1270,7 @@ pub fn contains<'a,'b>(haystack: &'a str, needle: &'b str) -> bool {\n  * * needle - The char to look for\n  */\n pub fn contains_char(haystack: &str, needle: char) -> bool {\n-    find_char(haystack, needle).is_some()\n+    haystack.find(needle).is_some()\n }\n \n /**\n@@ -2415,11 +2105,9 @@ pub trait StrSlice<'self> {\n     fn rev_iter(&self) -> StrCharRevIterator<'self>;\n     fn bytes_iter(&self) -> StrBytesIterator<'self>;\n     fn bytes_rev_iter(&self) -> StrBytesRevIterator<'self>;\n-    fn split_iter<Sep: StrCharSplitSeparator>(&self, sep: Sep) -> StrCharSplitIterator<'self, Sep>;\n-    fn splitn_iter<Sep: StrCharSplitSeparator>(&self, sep: Sep, count: uint)\n-        -> StrCharSplitIterator<'self, Sep>;\n-    fn split_options_iter<Sep: StrCharSplitSeparator>(&self, sep: Sep,\n-                                                      count: uint, allow_trailing_empty: bool)\n+    fn split_iter<Sep: CharEq>(&self, sep: Sep) -> StrCharSplitIterator<'self, Sep>;\n+    fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> StrCharSplitIterator<'self, Sep>;\n+    fn split_options_iter<Sep: CharEq>(&self, sep: Sep, count: uint, allow_trailing_empty: bool)\n         -> StrCharSplitIterator<'self, Sep>;\n     /// An iterator over the start and end indices of each match of\n     /// `sep` within `self`.\n@@ -2448,6 +2136,8 @@ pub trait StrSlice<'self> {\n     fn len(&self) -> uint;\n     fn char_len(&self) -> uint;\n     fn slice(&self, begin: uint, end: uint) -> &'self str;\n+    fn slice_from(&self, begin: uint) -> &'self str;\n+    fn slice_to(&self, end: uint) -> &'self str;\n     fn starts_with<'a>(&self, needle: &'a str) -> bool;\n     fn substr(&self, begin: uint, n: uint) -> &'self str;\n     fn escape_default(&self) -> ~str;\n@@ -2463,6 +2153,9 @@ pub trait StrSlice<'self> {\n     fn char_at(&self, i: uint) -> char;\n     fn char_at_reverse(&self, i: uint) -> char;\n     fn to_bytes(&self) -> ~[u8];\n+\n+    fn find<C: CharEq>(&self, search: C) -> Option<uint>;\n+    fn rfind<C: CharEq>(&self, search: C) -> Option<uint>;\n }\n \n /// Extension methods for strings\n@@ -2500,16 +2193,14 @@ impl<'self> StrSlice<'self> for &'self str {\n         StrBytesRevIterator { it: as_bytes_slice(*self).rev_iter() }\n     }\n \n-    fn split_iter<Sep: StrCharSplitSeparator>(&self, sep: Sep) -> StrCharSplitIterator<'self, Sep> {\n+    fn split_iter<Sep: CharEq>(&self, sep: Sep) -> StrCharSplitIterator<'self, Sep> {\n         self.split_options_iter(sep, self.len(), true)\n     }\n \n-    fn splitn_iter<Sep: StrCharSplitSeparator>(&self, sep: Sep, count: uint)\n-        -> StrCharSplitIterator<'self, Sep> {\n+    fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> StrCharSplitIterator<'self, Sep> {\n         self.split_options_iter(sep, count, true)\n     }\n-    fn split_options_iter<Sep: StrCharSplitSeparator>(&self, sep: Sep,\n-                                                      count: uint, allow_trailing_empty: bool)\n+    fn split_options_iter<Sep: CharEq>(&self, sep: Sep, count: uint, allow_trailing_empty: bool)\n         -> StrCharSplitIterator<'self, Sep> {\n         let only_ascii = sep.only_ascii();\n         StrCharSplitIterator {\n@@ -2590,6 +2281,14 @@ impl<'self> StrSlice<'self> for &'self str {\n         unsafe { raw::slice_bytes(*self, begin, end) }\n     }\n     #[inline]\n+    fn slice_from(&self, begin: uint) -> &'self str {\n+        self.slice(begin, self.len())\n+    }\n+    #[inline]\n+    fn slice_to(&self, end: uint) -> &'self str {\n+        self.slice(0, end)\n+    }\n+    #[inline]\n     fn starts_with<'a>(&self, needle: &'a str) -> bool {\n         starts_with(*self, needle)\n     }\n@@ -2654,6 +2353,54 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     fn to_bytes(&self) -> ~[u8] { to_bytes(*self) }\n+\n+    /**\n+     * Returns the byte index of the first character of `self` that matches `search`\n+     *\n+     * # Return value\n+     *\n+     * `Some` containing the byte index of the last matching character\n+     * or `None` if there is no match\n+     */\n+    fn find<C: CharEq>(&self, search: C) -> Option<uint> {\n+        if search.only_ascii() {\n+            for self.bytes_iter().enumerate().advance |(i, b)| {\n+                if search.matches(b as char) { return Some(i) }\n+            }\n+        } else {\n+            let mut index = 0;\n+            for self.iter().advance |c| {\n+                if search.matches(c) { return Some(index); }\n+                index += c.len_utf8_bytes();\n+            }\n+        }\n+\n+        None\n+    }\n+    /**\n+     * Returns the byte index of the last character of `self` that matches `search`\n+     *\n+     * # Return value\n+     *\n+     * `Some` containing the byte index of the last matching character\n+     * or `None` if there is no match\n+     */\n+    fn rfind<C: CharEq>(&self, search: C) -> Option<uint> {\n+        let mut index = self.len();\n+        if search.only_ascii() {\n+            for self.bytes_rev_iter().advance |b| {\n+                index -= 1;\n+                if search.matches(b as char) { return Some(index); }\n+            }\n+        } else {\n+            for self.rev_iter().advance |c| {\n+                index -= c.len_utf8_bytes();\n+                if search.matches(c) { return Some(index); }\n+            }\n+        }\n+\n+        None\n+    }\n }\n \n #[allow(missing_doc)]\n@@ -2803,12 +2550,23 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_rfind_char() {\n-        assert_eq!(rfind_char(\"hello\", 'l'), Some(3u));\n-        assert_eq!(rfind_char(\"hello\", 'o'), Some(4u));\n-        assert_eq!(rfind_char(\"hello\", 'h'), Some(0u));\n-        assert!(rfind_char(\"hello\", 'z').is_none());\n-        assert_eq!(rfind_char(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e'), Some(30u));\n+    fn test_find() {\n+        assert_eq!(\"hello\".find('l'), Some(2u));\n+        assert_eq!(\"hello\".find(|c:char| c == 'o'), Some(4u));\n+        assert!(\"hello\".find('x').is_none());\n+        assert!(\"hello\".find(|c:char| c == 'x').is_none());\n+        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".find('\u534e'), Some(30u));\n+        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".find(|c: char| c == '\u534e'), Some(30u));\n+    }\n+\n+    #[test]\n+    fn test_rfind() {\n+        assert_eq!(\"hello\".rfind('l'), Some(3u));\n+        assert_eq!(\"hello\".rfind(|c:char| c == 'o'), Some(4u));\n+        assert!(\"hello\".rfind('x').is_none());\n+        assert!(\"hello\".rfind(|c:char| c == 'x').is_none());\n+        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind('\u534e'), Some(30u));\n+        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind(|c: char| c == '\u534e'), Some(30u));\n     }\n \n     #[test]\n@@ -3122,6 +2880,19 @@ mod tests {\n         \"\u4e2d\u534eVi\u1ec7t Nam\".slice(0u, 2u);\n     }\n \n+    #[test]\n+    fn test_slice_from() {\n+        assert_eq!(\"abcd\".slice_from(0), \"abcd\");\n+        assert_eq!(\"abcd\".slice_from(2), \"cd\");\n+        assert_eq!(\"abcd\".slice_from(4), \"\");\n+    }\n+    #[test]\n+    fn test_slice_to() {\n+        assert_eq!(\"abcd\".slice_to(0), \"\");\n+        assert_eq!(\"abcd\".slice_to(2), \"ab\");\n+        assert_eq!(\"abcd\".slice_to(4), \"abcd\");\n+    }\n+\n     #[test]\n     fn test_trim_left_chars() {\n         assert!(trim_left_chars(\" *** foo *** \", []) == \" *** foo *** \");"}, {"sha": "68403b2c608598f78d2ad24e4a74a7e2cd1812e0", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cfc08d81e7cc664330ce9d38a874c14a4ae51bf/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=0cfc08d81e7cc664330ce9d38a874c14a4ae51bf", "patch": "@@ -24,7 +24,6 @@ source code snippets, etc.\n use core::prelude::*;\n \n use core::cmp;\n-use core::str;\n use core::to_bytes;\n use core::uint;\n use extra::serialize::{Encodable, Decodable, Encoder, Decoder};\n@@ -288,11 +287,11 @@ impl FileMap {\n     pub fn get_line(&self, line: int) -> ~str {\n         let begin: BytePos = self.lines[line] - self.start_pos;\n         let begin = begin.to_uint();\n-        let end = match str::find_char_from(*self.src, '\\n', begin) {\n-            Some(e) => e,\n-            None => self.src.len()\n-        };\n-        self.src.slice(begin, end).to_owned()\n+        let slice = self.src.slice_from(begin);\n+        match slice.find('\\n') {\n+            Some(e) => slice.slice_to(e).to_owned(),\n+            None => slice.to_owned()\n+        }\n     }\n \n     pub fn record_multibyte_char(&self, pos: BytePos, bytes: uint) {"}]}