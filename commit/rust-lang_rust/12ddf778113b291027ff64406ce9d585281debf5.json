{"sha": "12ddf778113b291027ff64406ce9d585281debf5", "node_id": "C_kwDOAAsO6NoAKDEyZGRmNzc4MTEzYjI5MTAyN2ZmNjQ0MDZjZTlkNTg1MjgxZGViZjU", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2023-01-08T06:54:52Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2023-01-11T21:30:10Z"}, "message": "When suggesting writing a fully qualified path probe for appropriate types\n\nFix #46585.", "tree": {"sha": "b96e07bafbe19d8a4772f0d0cbbd2be8e2054fdb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b96e07bafbe19d8a4772f0d0cbbd2be8e2054fdb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12ddf778113b291027ff64406ce9d585281debf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12ddf778113b291027ff64406ce9d585281debf5", "html_url": "https://github.com/rust-lang/rust/commit/12ddf778113b291027ff64406ce9d585281debf5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12ddf778113b291027ff64406ce9d585281debf5/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b22c152958eade17a71d899b29a2d39bcc77aa48", "url": "https://api.github.com/repos/rust-lang/rust/commits/b22c152958eade17a71d899b29a2d39bcc77aa48", "html_url": "https://github.com/rust-lang/rust/commit/b22c152958eade17a71d899b29a2d39bcc77aa48"}], "stats": {"total": 350, "additions": 295, "deletions": 55}, "files": [{"sha": "7127dadc1e167d347ce7dba2fbd9e6d5c9fbbdec", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 160, "deletions": 17, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/12ddf778113b291027ff64406ce9d585281debf5/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12ddf778113b291027ff64406ce9d585281debf5/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=12ddf778113b291027ff64406ce9d585281debf5", "patch": "@@ -24,6 +24,7 @@ use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{walk_generics, Visitor as _};\n use rustc_hir::{GenericArg, GenericArgs, OpaqueTyOrigin};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::middle::stability::AllowUnstable;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n use rustc_middle::ty::GenericParamDefKind;\n@@ -1633,8 +1634,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn report_ambiguous_associated_type(\n         &self,\n         span: Span,\n-        type_str: &str,\n-        trait_str: &str,\n+        types: &[String],\n+        traits: &[String],\n         name: Symbol,\n     ) -> ErrorGuaranteed {\n         let mut err = struct_span_err!(self.tcx().sess, span, E0223, \"ambiguous associated type\");\n@@ -1645,19 +1646,92 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .keys()\n             .any(|full_span| full_span.contains(span))\n         {\n-            err.span_suggestion(\n+            err.span_suggestion_verbose(\n                 span.shrink_to_lo(),\n                 \"you are looking for the module in `std`, not the primitive type\",\n                 \"std::\",\n                 Applicability::MachineApplicable,\n             );\n         } else {\n-            err.span_suggestion(\n-                span,\n-                \"use fully-qualified syntax\",\n-                format!(\"<{} as {}>::{}\", type_str, trait_str, name),\n-                Applicability::HasPlaceholders,\n-            );\n+            match (types, traits) {\n+                ([], []) => {\n+                    err.span_suggestion_verbose(\n+                        span,\n+                        &format!(\n+                            \"if there were a type named `Type` that implements a trait named \\\n+                             `Trait` with associated type `{name}`, you could use the \\\n+                             fully-qualified path\",\n+                        ),\n+                        format!(\"<Type as Trait>::{name}\"),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+                ([], [trait_str]) => {\n+                    err.span_suggestion_verbose(\n+                        span,\n+                        &format!(\n+                            \"if there were a type named `Example` that implemented `{trait_str}`, \\\n+                             you could use the fully-qualified path\",\n+                        ),\n+                        format!(\"<Example as {trait_str}>::{name}\"),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+                ([], traits) => {\n+                    err.span_suggestions(\n+                        span,\n+                        &format!(\n+                            \"if there were a type named `Example` that implemented one of the \\\n+                             traits with associated type `{name}`, you could use the \\\n+                             fully-qualified path\",\n+                        ),\n+                        traits\n+                            .iter()\n+                            .map(|trait_str| format!(\"<Example as {trait_str}>::{name}\"))\n+                            .collect::<Vec<_>>(),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+                ([type_str], []) => {\n+                    err.span_suggestion_verbose(\n+                        span,\n+                        &format!(\n+                            \"if there were a trait named `Example` with associated type `{name}` \\\n+                             implemented for `{type_str}`, you could use the fully-qualified path\",\n+                        ),\n+                        format!(\"<{type_str} as Example>::{name}\"),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+                (types, []) => {\n+                    err.span_suggestions(\n+                        span,\n+                        &format!(\n+                            \"if there were a trait named `Example` with associated type `{name}` \\\n+                             implemented for one of the types, you could use the fully-qualified \\\n+                             path\",\n+                        ),\n+                        types\n+                            .into_iter()\n+                            .map(|type_str| format!(\"<{type_str} as Example>::{name}\")),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+                (types, traits) => {\n+                    let mut suggestions = vec![];\n+                    for type_str in types {\n+                        for trait_str in traits {\n+                            suggestions.push(format!(\"<{type_str} as {trait_str}>::{name}\"));\n+                        }\n+                    }\n+                    err.span_suggestions(\n+                        span,\n+                        \"use the fully-qualified path\",\n+                        suggestions,\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n         }\n         err.emit()\n     }\n@@ -2040,12 +2114,67 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     err.emit()\n                 } else if let Err(reported) = qself_ty.error_reported() {\n                     reported\n+                } else if let ty::Alias(ty::Opaque, alias_ty) = qself_ty.kind() {\n+                    // `<impl Trait as OtherTrait>::Assoc` makes no sense.\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        tcx.def_span(alias_ty.def_id),\n+                        E0667,\n+                        \"`impl Trait` is not allowed in path parameters\"\n+                    )\n+                    .emit() // Already reported in an earlier stage.\n                 } else {\n+                    // Find all the `impl`s that `qself_ty` has for any trait that has the\n+                    // associated type, so that we suggest the right one.\n+                    let infcx = tcx.infer_ctxt().build();\n+                    // We create a fresh `ty::ParamEnv` instead of the one for `self.item_def_id()`\n+                    // to avoid a cycle error in `src/test/ui/resolve/issue-102946.rs`.\n+                    let param_env = ty::ParamEnv::new(\n+                        ty::List::empty(),\n+                        traits::Reveal::All,\n+                        hir::Constness::NotConst,\n+                    );\n+                    let traits: Vec<_> = self\n+                        .tcx()\n+                        .all_traits()\n+                        .filter(|trait_def_id| {\n+                            // Consider only traits with the associated type\n+                            tcx.associated_items(*trait_def_id)\n+                                .in_definition_order()\n+                                .find(|i| {\n+                                    i.kind.namespace() == Namespace::TypeNS\n+                                        && i.ident(tcx).normalize_to_macros_2_0() == assoc_ident\n+                                        && matches!(i.kind, ty::AssocKind::Type)\n+                                })\n+                                .is_some()\n+                            // Consider only accessible traits\n+                            && tcx.visibility(*trait_def_id)\n+                                .is_accessible_from(self.item_def_id(), tcx)\n+                            && tcx.all_impls(*trait_def_id)\n+                                .filter(|impl_def_id| {\n+                                    let trait_ref = tcx.impl_trait_ref(impl_def_id);\n+                                    trait_ref.map_or(false, |impl_| {\n+                                        infcx\n+                                            .can_eq(\n+                                                param_env,\n+                                                tcx.erase_regions(impl_.self_ty()),\n+                                                tcx.erase_regions(qself_ty),\n+                                            )\n+                                            .is_ok()\n+                                    })\n+                                    && tcx.impl_polarity(impl_def_id) != ty::ImplPolarity::Negative\n+                                })\n+                                .next()\n+                                .is_some()\n+                        })\n+                        .map(|trait_def_id| tcx.def_path_str(trait_def_id))\n+                        .collect();\n+\n                     // Don't print `TyErr` to the user.\n                     self.report_ambiguous_associated_type(\n                         span,\n-                        &qself_ty.to_string(),\n-                        \"Trait\",\n+                        &[qself_ty.to_string()],\n+                        &traits,\n                         assoc_ident.name,\n                     )\n                 };\n@@ -2163,16 +2292,30 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             let is_part_of_self_trait_constraints = def_id == trait_def_id;\n             let is_part_of_fn_in_self_trait = parent_def_id == Some(trait_def_id);\n \n-            let type_name = if is_part_of_self_trait_constraints || is_part_of_fn_in_self_trait {\n-                \"Self\"\n+            let type_names = if is_part_of_self_trait_constraints || is_part_of_fn_in_self_trait {\n+                vec![\"Self\".to_string()]\n             } else {\n-                \"Type\"\n+                // Find all the types that have an `impl` for the trait.\n+                tcx.all_impls(trait_def_id)\n+                    .filter(|impl_def_id| {\n+                        // Consider only accessible traits\n+                        tcx.visibility(*impl_def_id).is_accessible_from(self.item_def_id(), tcx)\n+                            && tcx.impl_polarity(impl_def_id) != ty::ImplPolarity::Negative\n+                    })\n+                    .filter_map(|impl_def_id| tcx.impl_trait_ref(impl_def_id))\n+                    .map(|impl_| impl_.self_ty())\n+                    // We don't care about blanket impls.\n+                    .filter(|self_ty| !self_ty.has_non_region_infer())\n+                    .map(|self_ty| tcx.erase_regions(self_ty).to_string())\n+                    .collect()\n             };\n-\n+            // FIXME: also look at `tcx.generics_of(self.item_def_id()).params` any that\n+            // references the trait. Relevant for the first case in\n+            // `src/test/ui/associated-types/associated-types-in-ambiguous-context.rs`\n             let reported = self.report_ambiguous_associated_type(\n                 span,\n-                type_name,\n-                &path_str,\n+                &type_names,\n+                &[path_str],\n                 item_segment.ident.name,\n             );\n             return tcx.ty_error_with_guaranteed(reported)"}, {"sha": "d0c170620766c4d19a983e0f7dc8fa75d8a77e51", "filename": "tests/ui/associated-item/associated-item-duplicate-names-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fassociated-item%2Fassociated-item-duplicate-names-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fassociated-item%2Fassociated-item-duplicate-names-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-item%2Fassociated-item-duplicate-names-3.stderr?ref=12ddf778113b291027ff64406ce9d585281debf5", "patch": "@@ -13,7 +13,7 @@ error[E0223]: ambiguous associated type\n   --> $DIR/associated-item-duplicate-names-3.rs:18:12\n    |\n LL |     let x: Baz::Bar = 5;\n-   |            ^^^^^^^^ help: use fully-qualified syntax: `<Baz as Trait>::Bar`\n+   |            ^^^^^^^^ help: use the fully-qualified path: `<Baz as Foo>::Bar`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "00856b55df5ece3ba2e995e921b61b1c3ad93d36", "filename": "tests/ui/associated-types/associated-types-in-ambiguous-context.stderr", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fassociated-types%2Fassociated-types-in-ambiguous-context.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fassociated-types%2Fassociated-types-in-ambiguous-context.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-types%2Fassociated-types-in-ambiguous-context.stderr?ref=12ddf778113b291027ff64406ce9d585281debf5", "patch": "@@ -2,31 +2,46 @@ error[E0223]: ambiguous associated type\n   --> $DIR/associated-types-in-ambiguous-context.rs:6:36\n    |\n LL | fn get<T:Get,U:Get>(x: T, y: U) -> Get::Value {}\n-   |                                    ^^^^^^^^^^ help: use fully-qualified syntax: `<Type as Get>::Value`\n+   |                                    ^^^^^^^^^^\n+   |\n+help: if there were a type named `Example` that implemented `Get`, you could use the fully-qualified path\n+   |\n+LL | fn get<T:Get,U:Get>(x: T, y: U) -> <Example as Get>::Value {}\n+   |                                    ~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/associated-types-in-ambiguous-context.rs:20:17\n    |\n LL | trait Foo where Foo::Assoc: Bar {\n-   |                 ^^^^^^^^^^ help: use fully-qualified syntax: `<Self as Foo>::Assoc`\n+   |                 ^^^^^^^^^^ help: use the fully-qualified path: `<Self as Foo>::Assoc`\n \n error[E0223]: ambiguous associated type\n   --> $DIR/associated-types-in-ambiguous-context.rs:25:10\n    |\n LL | type X = std::ops::Deref::Target;\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<Type as Deref>::Target`\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a type named `Example` that implemented `Deref`, you could use the fully-qualified path\n+   |\n+LL | type X = <Example as Deref>::Target;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/associated-types-in-ambiguous-context.rs:11:23\n    |\n LL |     fn grab(&self) -> Grab::Value;\n-   |                       ^^^^^^^^^^^ help: use fully-qualified syntax: `<Self as Grab>::Value`\n+   |                       ^^^^^^^^^^^ help: use the fully-qualified path: `<Self as Grab>::Value`\n \n error[E0223]: ambiguous associated type\n   --> $DIR/associated-types-in-ambiguous-context.rs:14:22\n    |\n LL |     fn get(&self) -> Get::Value;\n-   |                      ^^^^^^^^^^ help: use fully-qualified syntax: `<Type as Get>::Value`\n+   |                      ^^^^^^^^^^\n+   |\n+help: if there were a type named `Example` that implemented `Get`, you could use the fully-qualified path\n+   |\n+LL |     fn get(&self) -> <Example as Get>::Value;\n+   |                      ~~~~~~~~~~~~~~~~~~~~~~~\n \n error: aborting due to 5 previous errors\n "}, {"sha": "7cd349c7507f9048271eb6746f5af861860d6bf4", "filename": "tests/ui/did_you_mean/bad-assoc-ty.stderr", "status": "modified", "additions": 53, "deletions": 9, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr?ref=12ddf778113b291027ff64406ce9d585281debf5", "patch": "@@ -61,25 +61,45 @@ error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:1:10\n    |\n LL | type A = [u8; 4]::AssocTy;\n-   |          ^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<[u8; 4] as Trait>::AssocTy`\n+   |          ^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `[u8; 4]`, you could use the fully-qualified path\n+   |\n+LL | type A = <[u8; 4] as Example>::AssocTy;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:5:10\n    |\n LL | type B = [u8]::AssocTy;\n-   |          ^^^^^^^^^^^^^ help: use fully-qualified syntax: `<[u8] as Trait>::AssocTy`\n+   |          ^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `[u8]`, you could use the fully-qualified path\n+   |\n+LL | type B = <[u8] as Example>::AssocTy;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:9:10\n    |\n LL | type C = (u8)::AssocTy;\n-   |          ^^^^^^^^^^^^^ help: use fully-qualified syntax: `<u8 as Trait>::AssocTy`\n+   |          ^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `u8`, you could use the fully-qualified path\n+   |\n+LL | type C = <u8 as Example>::AssocTy;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:13:10\n    |\n LL | type D = (u8, u8)::AssocTy;\n-   |          ^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<(u8, u8) as Trait>::AssocTy`\n+   |          ^^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `(u8, u8)`, you could use the fully-qualified path\n+   |\n+LL | type D = <(u8, u8) as Example>::AssocTy;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0121]: the placeholder `_` is not allowed within types on item signatures for type aliases\n   --> $DIR/bad-assoc-ty.rs:17:10\n@@ -91,13 +111,23 @@ error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:21:19\n    |\n LL | type F = &'static (u8)::AssocTy;\n-   |                   ^^^^^^^^^^^^^ help: use fully-qualified syntax: `<u8 as Trait>::AssocTy`\n+   |                   ^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `u8`, you could use the fully-qualified path\n+   |\n+LL | type F = &'static <u8 as Example>::AssocTy;\n+   |                   ~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:27:10\n    |\n LL | type G = dyn 'static + (Send)::AssocTy;\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<(dyn Send + 'static) as Trait>::AssocTy`\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `(dyn Send + 'static)`, you could use the fully-qualified path\n+   |\n+LL | type G = <(dyn Send + 'static) as Example>::AssocTy;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n warning: trait objects without an explicit `dyn` are deprecated\n   --> $DIR/bad-assoc-ty.rs:33:10\n@@ -117,24 +147,38 @@ error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:33:10\n    |\n LL | type H = Fn(u8) -> (u8)::Output;\n-   |          ^^^^^^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<(dyn Fn(u8) -> u8 + 'static) as Trait>::Output`\n+   |          ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `Output` implemented for `(dyn Fn(u8) -> u8 + 'static)`, you could use the fully-qualified path\n+   |\n+LL | type H = <(dyn Fn(u8) -> u8 + 'static) as Example>::Output;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:39:19\n    |\n LL |     ($ty: ty) => ($ty::AssocTy);\n-   |                   ^^^^^^^^^^^^ help: use fully-qualified syntax: `<u8 as Trait>::AssocTy`\n+   |                   ^^^^^^^^^^^^\n ...\n LL | type J = ty!(u8);\n    |          ------- in this macro invocation\n    |\n    = note: this error originates in the macro `ty` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `u8`, you could use the fully-qualified path\n+   |\n+LL |     ($ty: ty) => (<u8 as Example>::AssocTy);\n+   |                   ~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:46:10\n    |\n LL | type I = ty!()::AssocTy;\n-   |          ^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<u8 as Trait>::AssocTy`\n+   |          ^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `AssocTy` implemented for `u8`, you could use the fully-qualified path\n+   |\n+LL | type I = <u8 as Example>::AssocTy;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/bad-assoc-ty.rs:51:13"}, {"sha": "2fe252de256650cf5b67b00bd1e0a28c7557572d", "filename": "tests/ui/error-codes/E0223.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Ferror-codes%2FE0223.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Ferror-codes%2FE0223.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0223.rs?ref=12ddf778113b291027ff64406ce9d585281debf5", "patch": "@@ -1,4 +1,8 @@\n trait MyTrait { type X; }\n+struct MyStruct;\n+impl MyTrait for MyStruct {\n+    type X = ();\n+}\n \n fn main() {\n     let foo: MyTrait::X;"}, {"sha": "42945e42f6ea1c682884a60c3e92c671964a0dcc", "filename": "tests/ui/error-codes/E0223.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Ferror-codes%2FE0223.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Ferror-codes%2FE0223.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0223.stderr?ref=12ddf778113b291027ff64406ce9d585281debf5", "patch": "@@ -1,8 +1,8 @@\n error[E0223]: ambiguous associated type\n-  --> $DIR/E0223.rs:4:14\n+  --> $DIR/E0223.rs:8:14\n    |\n LL |     let foo: MyTrait::X;\n-   |              ^^^^^^^^^^ help: use fully-qualified syntax: `<Type as MyTrait>::X`\n+   |              ^^^^^^^^^^ help: use the fully-qualified path: `<MyStruct as MyTrait>::X`\n \n error: aborting due to previous error\n "}, {"sha": "b3ff2ce5a7bfada2b3b20cdadd9dd86f013a2729", "filename": "tests/ui/impl-trait/impl_trait_projections.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fimpl-trait%2Fimpl_trait_projections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fimpl-trait%2Fimpl_trait_projections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fimpl_trait_projections.rs?ref=12ddf778113b291027ff64406ce9d585281debf5", "patch": "@@ -11,7 +11,7 @@ fn path_parametrized_type_is_allowed() -> option::Option<impl Debug> {\n \n fn projection_is_disallowed(x: impl Iterator) -> <impl Iterator>::Item {\n //~^ ERROR `impl Trait` is not allowed in path parameters\n-//~^^ ERROR ambiguous associated type\n+//~| ERROR `impl Trait` is not allowed in path parameters\n     x.next().unwrap()\n }\n "}, {"sha": "4deb24731bc030b12c8ca24dc088ee11b3c13297", "filename": "tests/ui/impl-trait/impl_trait_projections.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fimpl-trait%2Fimpl_trait_projections.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fimpl-trait%2Fimpl_trait_projections.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fimpl_trait_projections.stderr?ref=12ddf778113b291027ff64406ce9d585281debf5", "patch": "@@ -22,13 +22,12 @@ error[E0667]: `impl Trait` is not allowed in path parameters\n LL |     -> <dyn Iterator<Item = impl Debug> as Iterator>::Item\n    |                             ^^^^^^^^^^\n \n-error[E0223]: ambiguous associated type\n-  --> $DIR/impl_trait_projections.rs:12:50\n+error[E0667]: `impl Trait` is not allowed in path parameters\n+  --> $DIR/impl_trait_projections.rs:12:51\n    |\n LL | fn projection_is_disallowed(x: impl Iterator) -> <impl Iterator>::Item {\n-   |                                                  ^^^^^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<impl Iterator as Trait>::Item`\n+   |                                                   ^^^^^^^^^^^^^\n \n error: aborting due to 5 previous errors\n \n-Some errors have detailed explanations: E0223, E0667.\n-For more information about an error, try `rustc --explain E0223`.\n+For more information about this error, try `rustc --explain E0667`."}, {"sha": "3a9f49ef167d692d6fe7feed84623e5c1b3a8f9e", "filename": "tests/ui/issues/issue-23073.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fissues%2Fissue-23073.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fissues%2Fissue-23073.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-23073.stderr?ref=12ddf778113b291027ff64406ce9d585281debf5", "patch": "@@ -2,7 +2,12 @@ error[E0223]: ambiguous associated type\n   --> $DIR/issue-23073.rs:6:17\n    |\n LL |     type FooT = <<Self as Bar>::Foo>::T;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<<Self as Bar>::Foo as Trait>::T`\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `T` implemented for `<Self as Bar>::Foo`, you could use the fully-qualified path\n+   |\n+LL |     type FooT = <<Self as Bar>::Foo as Example>::T;\n+   |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "70daf8a2f1a6475b2ed53dbaf7fba87283829b8d", "filename": "tests/ui/issues/issue-78622.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fissues%2Fissue-78622.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fissues%2Fissue-78622.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-78622.stderr?ref=12ddf778113b291027ff64406ce9d585281debf5", "patch": "@@ -2,7 +2,12 @@ error[E0223]: ambiguous associated type\n   --> $DIR/issue-78622.rs:5:5\n    |\n LL |     S::A::<f> {}\n-   |     ^^^^ help: use fully-qualified syntax: `<S as Trait>::A`\n+   |     ^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `A` implemented for `S`, you could use the fully-qualified path\n+   |\n+LL |     <S as Example>::A::<f> {}\n+   |     ~~~~~~~~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "a19f4963c239bc6ef90f601ee534cf35ed31ef8b", "filename": "tests/ui/lint/bare-trait-objects-path.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Flint%2Fbare-trait-objects-path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Flint%2Fbare-trait-objects-path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fbare-trait-objects-path.stderr?ref=12ddf778113b291027ff64406ce9d585281debf5", "patch": "@@ -16,7 +16,7 @@ error[E0223]: ambiguous associated type\n   --> $DIR/bare-trait-objects-path.rs:23:12\n    |\n LL |     let _: Dyn::Ty;\n-   |            ^^^^^^^ help: use fully-qualified syntax: `<dyn Dyn as Trait>::Ty`\n+   |            ^^^^^^^ help: use the fully-qualified path: `<dyn Dyn as Assoc>::Ty`\n \n warning: trait objects without an explicit `dyn` are deprecated\n   --> $DIR/bare-trait-objects-path.rs:14:5"}, {"sha": "b6cf19b8286cca19fd31427caa3ca5e6ce691a52", "filename": "tests/ui/qualified/qualified-path-params-2.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fqualified%2Fqualified-path-params-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fqualified%2Fqualified-path-params-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fqualified%2Fqualified-path-params-2.stderr?ref=12ddf778113b291027ff64406ce9d585281debf5", "patch": "@@ -2,7 +2,12 @@ error[E0223]: ambiguous associated type\n   --> $DIR/qualified-path-params-2.rs:18:10\n    |\n LL | type A = <S as Tr>::A::f<u8>;\n-   |          ^^^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<<S as Tr>::A as Trait>::f`\n+   |          ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `f` implemented for `<S as Tr>::A`, you could use the fully-qualified path\n+   |\n+LL | type A = <<S as Tr>::A as Example>::f;\n+   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "d4d141fb06f39e600e0a8417d694d7ec2931323f", "filename": "tests/ui/resolve/issue-103202.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fresolve%2Fissue-103202.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fresolve%2Fissue-103202.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresolve%2Fissue-103202.stderr?ref=12ddf778113b291027ff64406ce9d585281debf5", "patch": "@@ -2,7 +2,12 @@ error[E0223]: ambiguous associated type\n   --> $DIR/issue-103202.rs:4:17\n    |\n LL |     fn f(self: &S::x) {}\n-   |                 ^^^^ help: use fully-qualified syntax: `<S as Trait>::x`\n+   |                 ^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `x` implemented for `S`, you could use the fully-qualified path\n+   |\n+LL |     fn f(self: &<S as Example>::x) {}\n+   |                 ~~~~~~~~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "36372b644d6e171a18f033f6a74b0bc2d96fa247", "filename": "tests/ui/self/self-impl.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fself%2Fself-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fself%2Fself-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fself%2Fself-impl.stderr?ref=12ddf778113b291027ff64406ce9d585281debf5", "patch": "@@ -2,13 +2,13 @@ error[E0223]: ambiguous associated type\n   --> $DIR/self-impl.rs:23:16\n    |\n LL |         let _: <Self>::Baz = true;\n-   |                ^^^^^^^^^^^ help: use fully-qualified syntax: `<Bar as Trait>::Baz`\n+   |                ^^^^^^^^^^^ help: use the fully-qualified path: `<Bar as Foo>::Baz`\n \n error[E0223]: ambiguous associated type\n   --> $DIR/self-impl.rs:25:16\n    |\n LL |         let _: Self::Baz = true;\n-   |                ^^^^^^^^^ help: use fully-qualified syntax: `<Bar as Trait>::Baz`\n+   |                ^^^^^^^^^ help: use the fully-qualified path: `<Bar as Foo>::Baz`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ca5f0b7e21e7d4fb37c3e31d17f748305b63a0d2", "filename": "tests/ui/structs/struct-path-associated-type.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fstructs%2Fstruct-path-associated-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fstructs%2Fstruct-path-associated-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstructs%2Fstruct-path-associated-type.stderr?ref=12ddf778113b291027ff64406ce9d585281debf5", "patch": "@@ -48,19 +48,19 @@ error[E0223]: ambiguous associated type\n   --> $DIR/struct-path-associated-type.rs:32:13\n    |\n LL |     let s = S::A {};\n-   |             ^^^^ help: use fully-qualified syntax: `<S as Trait>::A`\n+   |             ^^^^ help: use the fully-qualified path: `<S as Tr>::A`\n \n error[E0223]: ambiguous associated type\n   --> $DIR/struct-path-associated-type.rs:33:13\n    |\n LL |     let z = S::A::<u8> {};\n-   |             ^^^^ help: use fully-qualified syntax: `<S as Trait>::A`\n+   |             ^^^^ help: use the fully-qualified path: `<S as Tr>::A`\n \n error[E0223]: ambiguous associated type\n   --> $DIR/struct-path-associated-type.rs:35:9\n    |\n LL |         S::A {} => {}\n-   |         ^^^^ help: use fully-qualified syntax: `<S as Trait>::A`\n+   |         ^^^^ help: use the fully-qualified path: `<S as Tr>::A`\n \n error: aborting due to 8 previous errors\n "}, {"sha": "b90ae051fb77675f1847cb8063b674661f8965fc", "filename": "tests/ui/suggestions/let-binding-init-expr-as-ty.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fsuggestions%2Flet-binding-init-expr-as-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fsuggestions%2Flet-binding-init-expr-as-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Flet-binding-init-expr-as-ty.stderr?ref=12ddf778113b291027ff64406ce9d585281debf5", "patch": "@@ -21,7 +21,12 @@ error[E0223]: ambiguous associated type\n   --> $DIR/let-binding-init-expr-as-ty.rs:2:14\n    |\n LL |     let foo: i32::from_be(num);\n-   |              ^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<i32 as Trait>::from_be`\n+   |              ^^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `from_be` implemented for `i32`, you could use the fully-qualified path\n+   |\n+LL |     let foo: <i32 as Example>::from_be;\n+   |              ~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error: aborting due to 3 previous errors\n "}, {"sha": "293cfbda86c4925b680463596a809cb5226438cc", "filename": "tests/ui/traits/item-privacy.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Ftraits%2Fitem-privacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Ftraits%2Fitem-privacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fitem-privacy.stderr?ref=12ddf778113b291027ff64406ce9d585281debf5", "patch": "@@ -148,19 +148,24 @@ error[E0223]: ambiguous associated type\n   --> $DIR/item-privacy.rs:115:12\n    |\n LL |     let _: S::A;\n-   |            ^^^^ help: use fully-qualified syntax: `<S as Trait>::A`\n+   |            ^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `A` implemented for `S`, you could use the fully-qualified path\n+   |\n+LL |     let _: <S as Example>::A;\n+   |            ~~~~~~~~~~~~~~~~~\n \n error[E0223]: ambiguous associated type\n   --> $DIR/item-privacy.rs:116:12\n    |\n LL |     let _: S::B;\n-   |            ^^^^ help: use fully-qualified syntax: `<S as Trait>::B`\n+   |            ^^^^ help: use the fully-qualified path: `<S as assoc_ty::B>::B`\n \n error[E0223]: ambiguous associated type\n   --> $DIR/item-privacy.rs:117:12\n    |\n LL |     let _: S::C;\n-   |            ^^^^ help: use fully-qualified syntax: `<S as Trait>::C`\n+   |            ^^^^ help: use the fully-qualified path: `<S as assoc_ty::C>::C`\n \n error[E0624]: associated type `A` is private\n   --> $DIR/item-privacy.rs:119:12"}, {"sha": "72fccea8ae399f1b763a23756c0169210cdad7ed", "filename": "tests/ui/ufcs/ufcs-partially-resolved.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12ddf778113b291027ff64406ce9d585281debf5/tests%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr?ref=12ddf778113b291027ff64406ce9d585281debf5", "patch": "@@ -205,7 +205,12 @@ error[E0223]: ambiguous associated type\n   --> $DIR/ufcs-partially-resolved.rs:36:12\n    |\n LL |     let _: <u8 as Tr>::Y::NN;\n-   |            ^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<<u8 as Tr>::Y as Trait>::NN`\n+   |            ^^^^^^^^^^^^^^^^^\n+   |\n+help: if there were a trait named `Example` with associated type `NN` implemented for `<u8 as Tr>::Y`, you could use the fully-qualified path\n+   |\n+LL |     let _: <<u8 as Tr>::Y as Example>::NN;\n+   |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0599]: no associated item named `NN` found for type `u16` in the current scope\n   --> $DIR/ufcs-partially-resolved.rs:38:20"}]}