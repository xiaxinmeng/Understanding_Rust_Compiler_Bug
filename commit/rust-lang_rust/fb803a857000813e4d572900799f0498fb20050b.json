{"sha": "fb803a857000813e4d572900799f0498fb20050b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiODAzYTg1NzAwMDgxM2U0ZDU3MjkwMDc5OWYwNDk4ZmIyMDA1MGI=", "commit": {"author": {"name": "Flavio Percoco", "email": "flaper87@gmail.com", "date": "2014-12-06T16:39:25Z"}, "committer": {"name": "Flavio Percoco", "email": "flaper87@gmail.com", "date": "2014-12-26T16:26:32Z"}, "message": "Require types to opt-in Sync", "tree": {"sha": "a1247d535c6dbb3fcaca0743cda7900481d14053", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1247d535c6dbb3fcaca0743cda7900481d14053"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb803a857000813e4d572900799f0498fb20050b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb803a857000813e4d572900799f0498fb20050b", "html_url": "https://github.com/rust-lang/rust/commit/fb803a857000813e4d572900799f0498fb20050b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb803a857000813e4d572900799f0498fb20050b/comments", "author": {"login": "flaper87", "id": 13816, "node_id": "MDQ6VXNlcjEzODE2", "avatar_url": "https://avatars.githubusercontent.com/u/13816?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flaper87", "html_url": "https://github.com/flaper87", "followers_url": "https://api.github.com/users/flaper87/followers", "following_url": "https://api.github.com/users/flaper87/following{/other_user}", "gists_url": "https://api.github.com/users/flaper87/gists{/gist_id}", "starred_url": "https://api.github.com/users/flaper87/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flaper87/subscriptions", "organizations_url": "https://api.github.com/users/flaper87/orgs", "repos_url": "https://api.github.com/users/flaper87/repos", "events_url": "https://api.github.com/users/flaper87/events{/privacy}", "received_events_url": "https://api.github.com/users/flaper87/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flaper87", "id": 13816, "node_id": "MDQ6VXNlcjEzODE2", "avatar_url": "https://avatars.githubusercontent.com/u/13816?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flaper87", "html_url": "https://github.com/flaper87", "followers_url": "https://api.github.com/users/flaper87/followers", "following_url": "https://api.github.com/users/flaper87/following{/other_user}", "gists_url": "https://api.github.com/users/flaper87/gists{/gist_id}", "starred_url": "https://api.github.com/users/flaper87/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flaper87/subscriptions", "organizations_url": "https://api.github.com/users/flaper87/orgs", "repos_url": "https://api.github.com/users/flaper87/repos", "events_url": "https://api.github.com/users/flaper87/events{/privacy}", "received_events_url": "https://api.github.com/users/flaper87/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c43efee6def9a4a4e943feef0236d3e17b3f581d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c43efee6def9a4a4e943feef0236d3e17b3f581d", "html_url": "https://github.com/rust-lang/rust/commit/c43efee6def9a4a4e943feef0236d3e17b3f581d"}], "stats": {"total": 1194, "additions": 742, "deletions": 452}, "files": [{"sha": "e060ecad974b405b532c7263c909bce978a93e45", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -129,6 +129,10 @@ pub struct Weak<T> {\n     _ptr: *mut ArcInner<T>,\n }\n \n+impl<T: Sync + Send> Send for Arc<T> { }\n+\n+impl<T: Sync + Send> Sync for Arc<T> { }\n+\n struct ArcInner<T> {\n     strong: atomic::AtomicUint,\n     weak: atomic::AtomicUint,"}, {"sha": "0f81d43356d44d58d3f49142a1dfbff592d0d8d1", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -19,6 +19,7 @@ use core::hash::{mod, Hash};\n use core::kinds::Sized;\n use core::mem;\n use core::option::Option;\n+use core::ptr::OwnedPtr;\n use core::raw::TraitObject;\n use core::result::Result;\n use core::result::Result::{Ok, Err};\n@@ -44,7 +45,7 @@ pub static HEAP: () = ();\n /// A type that represents a uniquely-owned value.\n #[lang = \"owned_box\"]\n #[unstable = \"custom allocators will add an additional type parameter (with default)\"]\n-pub struct Box<T>(*mut T);\n+pub struct Box<T>(OwnedPtr<T>);\n \n #[stable]\n impl<T: Default> Default for Box<T> {"}, {"sha": "9b668b25df34604f177e293ecb37077116223130", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -58,7 +58,7 @@ use core::kinds::marker::{ContravariantLifetime, InvariantType};\n use core::mem;\n use core::num::{Int, UnsignedInt};\n use core::ops;\n-use core::ptr;\n+use core::ptr::{mod, OwnedPtr};\n use core::raw::Slice as RawSlice;\n use core::uint;\n \n@@ -133,7 +133,7 @@ use slice::CloneSliceExt;\n #[unsafe_no_drop_flag]\n #[stable]\n pub struct Vec<T> {\n-    ptr: *mut T,\n+    ptr: OwnedPtr<T>,\n     len: uint,\n     cap: uint,\n }\n@@ -176,7 +176,7 @@ impl<T> Vec<T> {\n         // non-null value which is fine since we never call deallocate on the ptr\n         // if cap is 0. The reason for this is because the pointer of a slice\n         // being NULL would break the null pointer optimization for enums.\n-        Vec { ptr: EMPTY as *mut T, len: 0, cap: 0 }\n+        Vec { ptr: OwnedPtr(EMPTY as *mut T), len: 0, cap: 0 }\n     }\n \n     /// Constructs a new, empty `Vec<T>` with the specified capacity.\n@@ -209,15 +209,15 @@ impl<T> Vec<T> {\n     #[stable]\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n-            Vec { ptr: EMPTY as *mut T, len: 0, cap: uint::MAX }\n+            Vec { ptr: OwnedPtr(EMPTY as *mut T), len: 0, cap: uint::MAX }\n         } else if capacity == 0 {\n             Vec::new()\n         } else {\n             let size = capacity.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n             let ptr = unsafe { allocate(size, mem::min_align_of::<T>()) };\n             if ptr.is_null() { ::alloc::oom() }\n-            Vec { ptr: ptr as *mut T, len: 0, cap: capacity }\n+            Vec { ptr: OwnedPtr(ptr as *mut T), len: 0, cap: capacity }\n         }\n     }\n \n@@ -284,7 +284,7 @@ impl<T> Vec<T> {\n     #[unstable = \"needs finalization\"]\n     pub unsafe fn from_raw_parts(ptr: *mut T, length: uint,\n                                  capacity: uint) -> Vec<T> {\n-        Vec { ptr: ptr, len: length, cap: capacity }\n+        Vec { ptr: OwnedPtr(ptr), len: length, cap: capacity }\n     }\n \n     /// Creates a vector by copying the elements from a raw pointer.\n@@ -795,19 +795,19 @@ impl<T> Vec<T> {\n         if self.len == 0 {\n             if self.cap != 0 {\n                 unsafe {\n-                    dealloc(self.ptr, self.cap)\n+                    dealloc(self.ptr.0, self.cap)\n                 }\n                 self.cap = 0;\n             }\n         } else {\n             unsafe {\n                 // Overflow check is unnecessary as the vector is already at\n                 // least this large.\n-                self.ptr = reallocate(self.ptr as *mut u8,\n-                                      self.cap * mem::size_of::<T>(),\n-                                      self.len * mem::size_of::<T>(),\n-                                      mem::min_align_of::<T>()) as *mut T;\n-                if self.ptr.is_null() { ::alloc::oom() }\n+                self.ptr = OwnedPtr(reallocate(self.ptr.0 as *mut u8,\n+                                               self.cap * mem::size_of::<T>(),\n+                                               self.len * mem::size_of::<T>(),\n+                                               mem::min_align_of::<T>()) as *mut T);\n+                if self.ptr.0.is_null() { ::alloc::oom() }\n             }\n             self.cap = self.len;\n         }\n@@ -867,7 +867,7 @@ impl<T> Vec<T> {\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n             mem::transmute(RawSlice {\n-                data: self.ptr as *const T,\n+                data: self.ptr.0 as *const T,\n                 len: self.len,\n             })\n         }\n@@ -890,9 +890,9 @@ impl<T> Vec<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> IntoIter<T> {\n         unsafe {\n-            let ptr = self.ptr;\n+            let ptr = self.ptr.0;\n             let cap = self.cap;\n-            let begin = self.ptr as *const T;\n+            let begin = self.ptr.0 as *const T;\n             let end = if mem::size_of::<T>() == 0 {\n                 (ptr as uint + self.len()) as *const T\n             } else {\n@@ -1110,14 +1110,14 @@ impl<T> Vec<T> {\n             let size = max(old_size, 2 * mem::size_of::<T>()) * 2;\n             if old_size > size { panic!(\"capacity overflow\") }\n             unsafe {\n-                self.ptr = alloc_or_realloc(self.ptr, old_size, size);\n-                if self.ptr.is_null() { ::alloc::oom() }\n+                self.ptr = OwnedPtr(alloc_or_realloc(self.ptr.0, old_size, size));\n+                if self.ptr.0.is_null() { ::alloc::oom() }\n             }\n             self.cap = max(self.cap, 2) * 2;\n         }\n \n         unsafe {\n-            let end = (self.ptr as *const T).offset(self.len as int) as *mut T;\n+            let end = self.ptr.0.offset(self.len as int);\n             ptr::write(&mut *end, value);\n             self.len += 1;\n         }\n@@ -1162,11 +1162,11 @@ impl<T> Vec<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n         unsafe {\n-            let begin = self.ptr as *const T;\n+            let begin = self.ptr.0 as *const T;\n             let end = if mem::size_of::<T>() == 0 {\n-                (self.ptr as uint + self.len()) as *const T\n+                (self.ptr.0 as uint + self.len()) as *const T\n             } else {\n-                self.ptr.offset(self.len() as int) as *const T\n+                self.ptr.0.offset(self.len() as int) as *const T\n             };\n             self.set_len(0);\n             Drain {\n@@ -1231,8 +1231,10 @@ impl<T> Vec<T> {\n             let size = capacity.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n             unsafe {\n-                self.ptr = alloc_or_realloc(self.ptr, self.cap * mem::size_of::<T>(), size);\n-                if self.ptr.is_null() { ::alloc::oom() }\n+                self.ptr = OwnedPtr(alloc_or_realloc(self.ptr.0,\n+                                                     self.cap * mem::size_of::<T>(),\n+                                                     size));\n+                if self.ptr.0.is_null() { ::alloc::oom() }\n             }\n             self.cap = capacity;\n         }\n@@ -1355,7 +1357,7 @@ impl<T> AsSlice<T> for Vec<T> {\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         unsafe {\n             mem::transmute(RawSlice {\n-                data: self.ptr as *const T,\n+                data: self.ptr.0 as *const T,\n                 len: self.len\n             })\n         }\n@@ -1380,7 +1382,7 @@ impl<T> Drop for Vec<T> {\n                 for x in self.iter() {\n                     ptr::read(x);\n                 }\n-                dealloc(self.ptr, self.cap)\n+                dealloc(self.ptr.0, self.cap)\n             }\n         }\n     }\n@@ -1418,7 +1420,7 @@ impl<T> IntoIter<T> {\n             for _x in self { }\n             let IntoIter { allocation, cap, ptr: _ptr, end: _end } = self;\n             mem::forget(self);\n-            Vec { ptr: allocation, cap: cap, len: 0 }\n+            Vec { ptr: OwnedPtr(allocation), cap: cap, len: 0 }\n         }\n     }\n "}, {"sha": "a34f13d127c07d468ef8fb9c69b738cb7ed66225", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -15,30 +15,30 @@\n pub use self::Ordering::*;\n \n use intrinsics;\n-use cell::UnsafeCell;\n+use cell::{UnsafeCell, RacyCell};\n \n /// A boolean type which can be safely shared between threads.\n #[stable]\n pub struct AtomicBool {\n-    v: UnsafeCell<uint>,\n+    v: RacyCell<uint>,\n }\n \n /// A signed integer type which can be safely shared between threads.\n #[stable]\n pub struct AtomicInt {\n-    v: UnsafeCell<int>,\n+    v: RacyCell<int>,\n }\n \n /// An unsigned integer type which can be safely shared between threads.\n #[stable]\n pub struct AtomicUint {\n-    v: UnsafeCell<uint>,\n+    v: RacyCell<uint>,\n }\n \n /// A raw pointer type which can be safely shared between threads.\n #[stable]\n pub struct AtomicPtr<T> {\n-    p: UnsafeCell<uint>,\n+    p: RacyCell<uint>,\n }\n \n /// Atomic memory orderings\n@@ -80,15 +80,15 @@ pub enum Ordering {\n /// An `AtomicBool` initialized to `false`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n pub const INIT_ATOMIC_BOOL: AtomicBool =\n-        AtomicBool { v: UnsafeCell { value: 0 } };\n+        AtomicBool { v: RacyCell(UnsafeCell { value: 0 }) };\n /// An `AtomicInt` initialized to `0`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n pub const INIT_ATOMIC_INT: AtomicInt =\n-        AtomicInt { v: UnsafeCell { value: 0 } };\n+        AtomicInt { v: RacyCell(UnsafeCell { value: 0 }) };\n /// An `AtomicUint` initialized to `0`.\n #[unstable = \"may be renamed, pending conventions for static initalizers\"]\n pub const INIT_ATOMIC_UINT: AtomicUint =\n-        AtomicUint { v: UnsafeCell { value: 0, } };\n+        AtomicUint { v: RacyCell(UnsafeCell { value: 0 }) };\n \n // NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n const UINT_TRUE: uint = -1;\n@@ -108,7 +108,7 @@ impl AtomicBool {\n     #[stable]\n     pub fn new(v: bool) -> AtomicBool {\n         let val = if v { UINT_TRUE } else { 0 };\n-        AtomicBool { v: UnsafeCell::new(val) }\n+        AtomicBool { v: RacyCell::new(val) }\n     }\n \n     /// Loads a value from the bool.\n@@ -348,7 +348,7 @@ impl AtomicInt {\n     #[inline]\n     #[stable]\n     pub fn new(v: int) -> AtomicInt {\n-        AtomicInt {v: UnsafeCell::new(v)}\n+        AtomicInt {v: RacyCell::new(v)}\n     }\n \n     /// Loads a value from the int.\n@@ -534,7 +534,7 @@ impl AtomicUint {\n     #[inline]\n     #[stable]\n     pub fn new(v: uint) -> AtomicUint {\n-        AtomicUint { v: UnsafeCell::new(v) }\n+        AtomicUint { v: RacyCell::new(v) }\n     }\n \n     /// Loads a value from the uint.\n@@ -721,7 +721,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable]\n     pub fn new(p: *mut T) -> AtomicPtr<T> {\n-        AtomicPtr { p: UnsafeCell::new(p as uint) }\n+        AtomicPtr { p: RacyCell::new(p as uint) }\n     }\n \n     /// Loads a value from the pointer."}, {"sha": "89118a6a8e4903d4f3fcd6366fcdd8ccaa6d5b93", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -158,7 +158,7 @@\n use clone::Clone;\n use cmp::PartialEq;\n use default::Default;\n-use kinds::{marker, Copy};\n+use kinds::{marker, Copy, Send, Sync};\n use ops::{Deref, DerefMut, Drop};\n use option::Option;\n use option::Option::{None, Some};\n@@ -555,3 +555,28 @@ impl<T> UnsafeCell<T> {\n     #[deprecated = \"renamed to into_inner()\"]\n     pub unsafe fn unwrap(self) -> T { self.into_inner() }\n }\n+\n+/// A version of `UnsafeCell` intended for use in concurrent data\n+/// structures (for example, you might put it in an `Arc`).\n+pub struct RacyCell<T>(pub UnsafeCell<T>);\n+\n+impl<T> RacyCell<T> {\n+    /// DOX\n+    pub fn new(value: T) -> RacyCell<T> {\n+        RacyCell(UnsafeCell { value: value })\n+    }\n+\n+    /// DOX\n+    pub unsafe fn get(&self) -> *mut T {\n+        self.0.get()\n+    }\n+\n+    /// DOX\n+    pub unsafe fn into_inner(self) -> T {\n+        self.0.into_inner()\n+    }\n+}\n+\n+impl<T:Send> Send for RacyCell<T> { }\n+\n+impl<T> Sync for RacyCell<T> { } // Oh dear"}, {"sha": "9b8a3f97f395384cbbe3cbeaff1a395f06d9c294", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -92,6 +92,7 @@ use clone::Clone;\n use intrinsics;\n use option::Option;\n use option::Option::{Some, None};\n+use kinds::{Send, Sync};\n \n use cmp::{PartialEq, Eq, Ord, PartialOrd, Equiv};\n use cmp::Ordering;\n@@ -501,3 +502,35 @@ impl<T> PartialOrd for *mut T {\n     #[inline]\n     fn ge(&self, other: &*mut T) -> bool { *self >= *other }\n }\n+\n+/// A wrapper around a raw `*mut T` that indicates that the possessor\n+/// of this wrapper owns the referent. This in turn implies that the\n+/// `OwnedPtr<T>` is `Send`/`Sync` if `T` is `Send`/`Sync`, unlike a\n+/// raw `*mut T` (which conveys no particular ownership semantics).\n+/// Useful for building abstractions like `Vec<T>` or `Box<T>`, which\n+/// internally use raw pointers to manage the memory that they own.\n+pub struct OwnedPtr<T>(pub *mut T);\n+\n+/// `OwnedPtr` pointers are `Send` if `T` is `Send` because the data they\n+/// reference is unaliased. Note that this aliasing invariant is\n+/// unenforced by the type system; the abstraction using the\n+/// `OwnedPtr` must enforce it.\n+impl<T:Send> Send for OwnedPtr<T> { }\n+\n+/// `OwnedPtr` pointers are `Sync` if `T` is `Sync` because the data they\n+/// reference is unaliased. Note that this aliasing invariant is\n+/// unenforced by the type system; the abstraction using the\n+/// `OwnedPtr` must enforce it.\n+impl<T:Sync> Sync for OwnedPtr<T> { }\n+\n+impl<T> OwnedPtr<T> {\n+    /// Returns a null OwnedPtr.\n+    pub fn null() -> OwnedPtr<T> {\n+        OwnedPtr(RawPtr::null())\n+    }\n+\n+    /// Return an (unsafe) pointer into the memory owned by `self`.\n+    pub unsafe fn offset(self, offset: int) -> *mut T {\n+        (self.0 as *const T).offset(offset) as *mut T\n+    }\n+}"}, {"sha": "1f14fde9ed4879f99a92b5adb59a40abe9cb10a8", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -27,8 +27,9 @@\n \n extern crate libc;\n \n-use std::c_vec::CVec;\n use libc::{c_void, size_t, c_int};\n+use std::c_vec::CVec;\n+use std::ptr::OwnedPtr;\n \n #[link(name = \"miniz\", kind = \"static\")]\n extern {\n@@ -59,7 +60,8 @@ fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n                                              &mut outsz,\n                                              flags);\n         if !res.is_null() {\n-            Some(CVec::new_with_dtor(res as *mut u8, outsz as uint, move|:| libc::free(res)))\n+            let res = OwnedPtr(res);\n+            Some(CVec::new_with_dtor(res.0 as *mut u8, outsz as uint, move|:| libc::free(res.0)))\n         } else {\n             None\n         }\n@@ -84,7 +86,8 @@ fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n                                                &mut outsz,\n                                                flags);\n         if !res.is_null() {\n-            Some(CVec::new_with_dtor(res as *mut u8, outsz as uint, move|:| libc::free(res)))\n+            let res = OwnedPtr(res);\n+            Some(CVec::new_with_dtor(res.0 as *mut u8, outsz as uint, move|:| libc::free(res.0)))\n         } else {\n             None\n         }"}, {"sha": "1ea79bdf606dade4719c6cf7a3e9e39d2917fe74", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -67,5 +67,6 @@ register_diagnostics! {\n     E0173,\n     E0174,\n     E0177,\n-    E0178\n+    E0178,\n+    E0179\n }"}, {"sha": "14f927f5b1ecb6fba5ea6a0da295145933187be5", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -31,6 +31,7 @@ use middle::infer;\n use middle::traits;\n use middle::mem_categorization as mc;\n use middle::expr_use_visitor as euv;\n+use util::common::ErrorReported;\n use util::nodemap::NodeSet;\n \n use syntax::ast;\n@@ -119,12 +120,19 @@ impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n         let ty = ty::node_id_to_type(self.tcx, e.id);\n         let infcx = infer::new_infer_ctxt(self.tcx);\n         let mut fulfill_cx = traits::FulfillmentContext::new();\n-        fulfill_cx.register_builtin_bound(self.tcx, ty, ty::BoundSync,\n-                                          traits::ObligationCause::dummy());\n-        let env = ty::empty_parameter_environment();\n-        if !fulfill_cx.select_all_or_error(&infcx, &env, self.tcx).is_ok() {\n-            self.tcx.sess.span_err(e.span, \"shared static items must have a \\\n-                                            type which implements Sync\");\n+        match traits::poly_trait_ref_for_builtin_bound(self.tcx, ty::BoundSync, ty) {\n+            Ok(trait_ref) => {\n+                let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n+                fulfill_cx.register_trait_ref(self.tcx, trait_ref, cause);\n+                let env = ty::empty_parameter_environment();\n+                match fulfill_cx.select_all_or_error(&infcx, &env, self.tcx) {\n+                    Ok(()) => { },\n+                    Err(ref errors) => {\n+                      traits::report_fulfillment_errors(&infcx, errors);\n+                    }\n+                }\n+            }\n+            Err(ErrorReported) => { }\n         }\n     }\n }"}, {"sha": "462857de1d4f88b6b1e25b348959200242cfc4a7", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -0,0 +1,349 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::{FulfillmentError, FulfillmentErrorCode,\n+            ObligationCauseCode, SelectionError,\n+            PredicateObligation, OutputTypeParameterMismatch};\n+\n+use middle::infer::InferCtxt;\n+use middle::ty::{mod};\n+use syntax::codemap::Span;\n+use util::ppaux::{Repr, UserString};\n+\n+pub fn report_fulfillment_errors<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                           errors: &Vec<FulfillmentError<'tcx>>) {\n+    for error in errors.iter() {\n+        report_fulfillment_error(infcx, error);\n+    }\n+}\n+\n+fn report_fulfillment_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                      error: &FulfillmentError<'tcx>) {\n+    match error.code {\n+        FulfillmentErrorCode::CodeSelectionError(ref e) => {\n+            report_selection_error(infcx, &error.obligation, e);\n+        }\n+        FulfillmentErrorCode::CodeAmbiguity => {\n+            maybe_report_ambiguity(infcx, &error.obligation);\n+        }\n+    }\n+}\n+\n+pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                        obligation: &PredicateObligation<'tcx>,\n+                                        error: &SelectionError<'tcx>)\n+{\n+    match *error {\n+        SelectionError::Overflow => {\n+            // We could track the stack here more precisely if we wanted, I imagine.\n+            match obligation.trait_ref {\n+                ty::Predicate::Trait(ref trait_ref) => {\n+                    let trait_ref =\n+                        infcx.resolve_type_vars_if_possible(&**trait_ref);\n+                    infcx.tcx.sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\n+                            \"overflow evaluating the trait `{}` for the type `{}`\",\n+                            trait_ref.user_string(infcx.tcx),\n+                            trait_ref.self_ty().user_string(infcx.tcx))[]);\n+                }\n+\n+                ty::Predicate::Equate(ref predicate) => {\n+                    let predicate = infcx.resolve_type_vars_if_possible(predicate);\n+                    let err = infcx.equality_predicate(obligation.cause.span,\n+                                                       &predicate).unwrap_err();\n+\n+                    infcx.tcx.sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate.user_string(infcx.tcx),\n+                            ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n+                }\n+\n+                ty::Predicate::TypeOutlives(..) |\n+                ty::Predicate::RegionOutlives(..) => {\n+                    infcx.tcx.sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\"overflow evaluating lifetime predicate\").as_slice());\n+                }\n+            }\n+\n+            let current_limit = infcx.tcx.sess.recursion_limit.get();\n+            let suggested_limit = current_limit * 2;\n+            infcx.tcx.sess.span_note(\n+                obligation.cause.span,\n+                format!(\n+                    \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n+                    suggested_limit)[]);\n+\n+            note_obligation_cause(infcx, obligation);\n+        }\n+        SelectionError::Unimplemented => {\n+            match obligation.trait_ref {\n+                ty::Predicate::Trait(ref trait_ref) => {\n+                    let trait_ref =\n+                        infcx.resolve_type_vars_if_possible(\n+                            &**trait_ref);\n+                    if !ty::type_is_error(trait_ref.self_ty()) {\n+                        infcx.tcx.sess.span_err(\n+                            obligation.cause.span,\n+                            format!(\n+                                \"the trait `{}` is not implemented for the type `{}`\",\n+                                trait_ref.user_string(infcx.tcx),\n+                                trait_ref.self_ty().user_string(infcx.tcx)).as_slice());\n+                        note_obligation_cause(infcx, obligation);\n+                    }\n+                }\n+\n+                ty::Predicate::Equate(ref predicate) => {\n+                    let predicate = infcx.resolve_type_vars_if_possible(predicate);\n+                    let err = infcx.equality_predicate(obligation.cause.span,\n+                                                       &predicate).unwrap_err();\n+\n+                    infcx.tcx.sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate.user_string(infcx.tcx),\n+                            ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n+                }\n+\n+                ty::Predicate::TypeOutlives(..) |\n+                ty::Predicate::RegionOutlives(..) => {\n+                    let predicate = infcx.resolve_type_vars_if_possible(&obligation.trait_ref);\n+                    infcx.tcx.sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\n+                            \"the requirement `{}` is not satisfied\",\n+                            predicate.user_string(infcx.tcx)).as_slice());\n+                }\n+            }\n+        }\n+        OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, ref e) => {\n+            let expected_trait_ref =\n+                infcx.resolve_type_vars_if_possible(\n+                    &**expected_trait_ref);\n+            let actual_trait_ref =\n+                infcx.resolve_type_vars_if_possible(\n+                    &**actual_trait_ref);\n+            if !ty::type_is_error(actual_trait_ref.self_ty()) {\n+                infcx.tcx.sess.span_err(\n+                    obligation.cause.span,\n+                    format!(\n+                        \"type mismatch: the type `{}` implements the trait `{}`, \\\n+                         but the trait `{}` is required ({})\",\n+                        expected_trait_ref.self_ty().user_string(infcx.tcx),\n+                        expected_trait_ref.user_string(infcx.tcx),\n+                        actual_trait_ref.user_string(infcx.tcx),\n+                        ty::type_err_to_str(infcx.tcx, e)).as_slice());\n+                note_obligation_cause(infcx, obligation);\n+            }\n+        }\n+    }\n+}\n+\n+fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                    obligation: &PredicateObligation<'tcx>) {\n+    // Unable to successfully determine, probably means\n+    // insufficient type information, but could mean\n+    // ambiguous impls. The latter *ought* to be a\n+    // coherence violation, so we don't report it here.\n+\n+    let trait_ref = match obligation.trait_ref {\n+        ty::Predicate::Trait(ref trait_ref) => {\n+            infcx.resolve_type_vars_if_possible(&**trait_ref)\n+        }\n+        _ => {\n+            infcx.tcx.sess.span_bug(\n+                obligation.cause.span,\n+                format!(\"ambiguity from something other than a trait: {}\",\n+                        obligation.trait_ref.repr(infcx.tcx)).as_slice());\n+        }\n+    };\n+    let self_ty = trait_ref.self_ty();\n+\n+    debug!(\"maybe_report_ambiguity(trait_ref={}, self_ty={}, obligation={})\",\n+           trait_ref.repr(infcx.tcx),\n+           self_ty.repr(infcx.tcx),\n+           obligation.repr(infcx.tcx));\n+    let all_types = &trait_ref.substs().types;\n+    if all_types.iter().any(|&t| ty::type_is_error(t)) {\n+    } else if all_types.iter().any(|&t| ty::type_needs_infer(t)) {\n+        // This is kind of a hack: it frequently happens that some earlier\n+        // error prevents types from being fully inferred, and then we get\n+        // a bunch of uninteresting errors saying something like \"<generic\n+        // #0> doesn't implement Sized\".  It may even be true that we\n+        // could just skip over all checks where the self-ty is an\n+        // inference variable, but I was afraid that there might be an\n+        // inference variable created, registered as an obligation, and\n+        // then never forced by writeback, and hence by skipping here we'd\n+        // be ignoring the fact that we don't KNOW the type works\n+        // out. Though even that would probably be harmless, given that\n+        // we're only talking about builtin traits, which are known to be\n+        // inhabited. But in any case I just threw in this check for\n+        // has_errors() to be sure that compilation isn't happening\n+        // anyway. In that case, why inundate the user.\n+        if !infcx.tcx.sess.has_errors() {\n+            if infcx.tcx.lang_items.sized_trait()\n+                  .map_or(false, |sized_id| sized_id == trait_ref.def_id()) {\n+                infcx.tcx.sess.span_err(\n+                    obligation.cause.span,\n+                    format!(\n+                        \"unable to infer enough type information about `{}`; type annotations \\\n+                         required\",\n+                        self_ty.user_string(infcx.tcx)).as_slice());\n+            } else {\n+                infcx.tcx.sess.span_err(\n+                    obligation.cause.span,\n+                    format!(\n+                        \"unable to infer enough type information to \\\n+                         locate the impl of the trait `{}` for \\\n+                         the type `{}`; type annotations required\",\n+                        trait_ref.user_string(infcx.tcx),\n+                        self_ty.user_string(infcx.tcx))[]);\n+                note_obligation_cause(infcx, obligation);\n+            }\n+        }\n+    } else if !infcx.tcx.sess.has_errors() {\n+         // Ambiguity. Coherence should have reported an error.\n+        infcx.tcx.sess.span_bug(\n+            obligation.cause.span,\n+            format!(\n+                \"coherence failed to report ambiguity: \\\n+                 cannot locate the impl of the trait `{}` for \\\n+                 the type `{}`\",\n+                trait_ref.user_string(infcx.tcx),\n+                self_ty.user_string(infcx.tcx))[]);\n+    }\n+}\n+\n+fn note_obligation_cause<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                   obligation: &PredicateObligation<'tcx>)\n+{\n+    let trait_ref = match obligation.trait_ref {\n+        ty::Predicate::Trait(ref trait_ref) => {\n+            infcx.resolve_type_vars_if_possible(&**trait_ref)\n+        }\n+        _ => {\n+            infcx.tcx.sess.span_bug(\n+                obligation.cause.span,\n+                format!(\"ambiguity from something other than a trait: {}\",\n+                        obligation.trait_ref.repr(infcx.tcx)).as_slice());\n+        }\n+    };\n+\n+    note_obligation_cause_code(infcx,\n+                               &trait_ref,\n+                               obligation.cause.span,\n+                               &obligation.cause.code)\n+}\n+\n+fn note_obligation_cause_code<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                        trait_ref: &ty::PolyTraitRef<'tcx>,\n+                                        cause_span: Span,\n+                                        cause_code: &ObligationCauseCode<'tcx>)\n+{\n+    let tcx = infcx.tcx;\n+    let trait_name = ty::item_path_str(tcx, trait_ref.def_id());\n+    match *cause_code {\n+        ObligationCauseCode::MiscObligation => { }\n+        ObligationCauseCode::ItemObligation(item_def_id) => {\n+            let item_name = ty::item_path_str(tcx, item_def_id);\n+            tcx.sess.span_note(\n+                cause_span,\n+                format!(\n+                    \"the trait `{}` must be implemented because it is required by `{}`\",\n+                    trait_name,\n+                    item_name).as_slice());\n+        }\n+        ObligationCauseCode::ObjectCastObligation(object_ty) => {\n+            tcx.sess.span_note(\n+                cause_span,\n+                format!(\n+                    \"the trait `{}` must be implemented for the cast \\\n+                     to the object type `{}`\",\n+                    trait_name,\n+                    infcx.ty_to_string(object_ty)).as_slice());\n+        }\n+        ObligationCauseCode::RepeatVec => {\n+            tcx.sess.span_note(\n+                cause_span,\n+                \"the `Copy` trait is required because the \\\n+                 repeated element will be copied\");\n+        }\n+        ObligationCauseCode::VariableType(_) => {\n+            tcx.sess.span_note(\n+                cause_span,\n+                \"all local variables must have a statically known size\");\n+        }\n+        ObligationCauseCode::ReturnType => {\n+            tcx.sess.span_note(\n+                cause_span,\n+                \"the return type of a function must have a \\\n+                 statically known size\");\n+        }\n+        ObligationCauseCode::AssignmentLhsSized => {\n+            tcx.sess.span_note(\n+                cause_span,\n+                \"the left-hand-side of an assignment must have a statically known size\");\n+        }\n+        ObligationCauseCode::StructInitializerSized => {\n+            tcx.sess.span_note(\n+                cause_span,\n+                \"structs must have a statically known size to be initialized\");\n+        }\n+        ObligationCauseCode::ClosureCapture(var_id, closure_span, builtin_bound) => {\n+            let def_id = tcx.lang_items.from_builtin_kind(builtin_bound).unwrap();\n+            let trait_name = ty::item_path_str(tcx, def_id);\n+            let name = ty::local_var_name_str(tcx, var_id);\n+            span_note!(tcx.sess, closure_span,\n+                       \"the closure that captures `{}` requires that all captured variables \\\n+                       implement the trait `{}`\",\n+                       name,\n+                       trait_name);\n+        }\n+        ObligationCauseCode::FieldSized => {\n+            span_note!(tcx.sess, cause_span,\n+                       \"only the last field of a struct or enum variant \\\n+                       may have a dynamically sized type\")\n+        }\n+        ObligationCauseCode::ObjectSized => {\n+            span_note!(tcx.sess, cause_span,\n+                       \"only sized types can be made into objects\");\n+        }\n+        ObligationCauseCode::SharedStatic => {\n+            span_note!(tcx.sess, cause_span,\n+                       \"shared static variables must have a type that implements `Sync`\");\n+        }\n+        ObligationCauseCode::BuiltinDerivedObligation(ref root_trait_ref, ref root_cause_code) => {\n+            let root_trait_ref =\n+                infcx.resolve_type_vars_if_possible(&**root_trait_ref);\n+            span_note!(tcx.sess, cause_span,\n+                       \"the type `{}` must implement `{}` because it appears within the type `{}`\",\n+                       trait_ref.self_ty().user_string(infcx.tcx),\n+                       trait_ref.user_string(infcx.tcx),\n+                       root_trait_ref.self_ty().user_string(infcx.tcx));\n+            note_obligation_cause_code(infcx, &root_trait_ref, cause_span, &**root_cause_code);\n+        }\n+        ObligationCauseCode::ImplDerivedObligation(ref root_trait_ref, ref root_cause_code) => {\n+            let root_trait_ref =\n+                infcx.resolve_type_vars_if_possible(&**root_trait_ref);\n+            span_note!(tcx.sess, cause_span,\n+                       \"the type `{}` must implement `{}` due to the requirements \\\n+                        on the impl of `{}` for the type `{}`\",\n+                       trait_ref.self_ty().user_string(infcx.tcx),\n+                       trait_ref.user_string(infcx.tcx),\n+                       root_trait_ref.user_string(infcx.tcx),\n+                       root_trait_ref.self_ty().user_string(infcx.tcx));\n+            note_obligation_cause_code(infcx, &root_trait_ref, cause_span, &**root_cause_code);\n+        }\n+    }\n+}"}, {"sha": "e9e80ed8c18c9c3aea0adb018829f391a5ee78cd", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -305,7 +305,7 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n     let tcx = selcx.tcx();\n     match predicate.trait_ref {\n         ty::Predicate::Trait(ref trait_ref) => {\n-            let trait_obligation = Obligation { cause: predicate.cause,\n+            let trait_obligation = Obligation { cause: predicate.cause.clone(),\n                                                 recursion_depth: predicate.recursion_depth,\n                                                 trait_ref: trait_ref.clone() };\n             match selcx.select(&trait_obligation) {\n@@ -368,7 +368,9 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                         CodeSelectionError(Unimplemented)));\n             } else {\n                 let ty::OutlivesPredicate(t_a, r_b) = binder.0;\n-                register_region_obligation(tcx, t_a, r_b, predicate.cause, region_obligations);\n+                register_region_obligation(tcx, t_a, r_b,\n+                                           predicate.cause.clone(),\n+                                           region_obligations);\n             }\n             true\n         }"}, {"sha": "6597730846dedbe55d63c98c3b4885c1d4ae1237", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -23,6 +23,7 @@ use std::slice::Iter;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n \n+pub use self::error_reporting::report_fulfillment_errors;\n pub use self::fulfill::{FulfillmentContext, RegionObligation};\n pub use self::select::SelectionContext;\n pub use self::select::SelectionCache;\n@@ -36,6 +37,7 @@ pub use self::util::transitive_bounds;\n pub use self::util::poly_trait_ref_for_builtin_bound;\n \n mod coherence;\n+mod error_reporting;\n mod fulfill;\n mod select;\n mod util;\n@@ -57,7 +59,7 @@ pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n pub type TraitObligation<'tcx> = Obligation<'tcx, Rc<ty::PolyTraitRef<'tcx>>>;\n \n /// Why did we incur this obligation? Used for error reporting.\n-#[deriving(Copy, Clone)]\n+#[deriving(Clone)]\n pub struct ObligationCause<'tcx> {\n     pub span: Span,\n \n@@ -72,7 +74,7 @@ pub struct ObligationCause<'tcx> {\n     pub code: ObligationCauseCode<'tcx>\n }\n \n-#[deriving(Copy, Clone)]\n+#[deriving(Clone)]\n pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from span.\n     MiscObligation,\n@@ -84,9 +86,6 @@ pub enum ObligationCauseCode<'tcx> {\n     /// Obligation incurred due to an object cast.\n     ObjectCastObligation(/* Object type */ Ty<'tcx>),\n \n-    /// To implement drop, type must be sendable.\n-    DropTrait,\n-\n     /// Various cases where expressions must be sized/copy/etc:\n     AssignmentLhsSized,        // L = X implies that L is Sized\n     StructInitializerSized,    // S { ... } must be Sized\n@@ -103,6 +102,13 @@ pub enum ObligationCauseCode<'tcx> {\n \n     // Only Sized types can be made into objects\n     ObjectSized,\n+\n+    // static items must have `Sync` type\n+    SharedStatic,\n+\n+    BuiltinDerivedObligation(Rc<ty::PolyTraitRef<'tcx>>, Rc<ObligationCauseCode<'tcx>>),\n+\n+    ImplDerivedObligation(Rc<ty::PolyTraitRef<'tcx>>, Rc<ObligationCauseCode<'tcx>>),\n }\n \n pub type Obligations<'tcx, O> = subst::VecPerParamSpace<Obligation<'tcx, O>>;"}, {"sha": "fe9ef33467910627dd7a8219f981dda1110adb3d", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 62, "deletions": 29, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -18,6 +18,7 @@ use self::BuiltinBoundConditions::*;\n use self::EvaluationResult::*;\n \n use super::{PredicateObligation, Obligation, TraitObligation, ObligationCause};\n+use super::{ObligationCauseCode, BuiltinDerivedObligation};\n use super::{SelectionError, Unimplemented, Overflow, OutputTypeParameterMismatch};\n use super::{Selection};\n use super::{SelectionResult};\n@@ -256,7 +257,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let obligation =\n             util::predicate_for_builtin_bound(\n                 self.tcx(),\n-                previous_stack.obligation.cause,\n+                previous_stack.obligation.cause.clone(),\n                 bound,\n                 previous_stack.obligation.recursion_depth + 1,\n                 ty);\n@@ -416,7 +417,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(substs) => {\n                     let vtable_impl = self.vtable_impl(impl_def_id,\n                                                        substs,\n-                                                       obligation.cause,\n+                                                       obligation.cause.clone(),\n                                                        obligation.recursion_depth + 1,\n                                                        skol_map,\n                                                        snapshot);\n@@ -663,25 +664,35 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // behavior, ignore user-defined impls here. This will\n                 // go away by the time 1.0 is released.\n                 if !self.tcx().sess.features.borrow().opt_out_copy {\n-                    try!(self.assemble_candidates_from_impls(obligation, &mut candidates));\n+                    try!(self.assemble_candidates_from_impls(obligation, &mut candidates.vec));\n                 }\n \n                 try!(self.assemble_builtin_bound_candidates(ty::BoundCopy,\n                                                             stack,\n                                                             &mut candidates));\n             }\n+            Some(bound @ ty::BoundSend) |\n+            Some(bound @ ty::BoundSync) => {\n+                try!(self.assemble_candidates_from_impls(obligation, &mut candidates.vec));\n+\n+                // No explicit impls were declared for this type, consider the fallback rules.\n+                if candidates.vec.is_empty() {\n+                    try!(self.assemble_builtin_bound_candidates(bound, stack, &mut candidates));\n+                }\n+            }\n+\n+            Some(bound @ ty::BoundSized) => {\n+                // Sized and Copy are always automatically computed.\n+                try!(self.assemble_builtin_bound_candidates(bound, stack, &mut candidates));\n+            }\n \n             None => {\n                 // For the time being, we ignore user-defined impls for builtin-bounds, other than\n                 // `Copy`.\n                 // (And unboxed candidates only apply to the Fn/FnMut/etc traits.)\n                 try!(self.assemble_unboxed_closure_candidates(obligation, &mut candidates));\n                 try!(self.assemble_fn_pointer_candidates(obligation, &mut candidates));\n-                try!(self.assemble_candidates_from_impls(obligation, &mut candidates));\n-            }\n-\n-            Some(bound) => {\n-                try!(self.assemble_builtin_bound_candidates(bound, stack, &mut candidates));\n+                try!(self.assemble_candidates_from_impls(obligation, &mut candidates.vec));\n             }\n         }\n \n@@ -816,7 +827,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Search for impls that might apply to `obligation`.\n     fn assemble_candidates_from_impls(&mut self,\n                                       obligation: &TraitObligation<'tcx>,\n-                                      candidates: &mut CandidateSet<'tcx>)\n+                                      candidate_vec: &mut Vec<Candidate<'tcx>>)\n                                       -> Result<(), SelectionError<'tcx>>\n     {\n         let all_impls = self.all_impls(obligation.trait_ref.def_id());\n@@ -827,7 +838,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 match self.match_impl(impl_def_id, obligation, snapshot,\n                                       &skol_map, Rc::new(skol_obligation_trait_ref)) {\n                     Ok(_) => {\n-                        candidates.vec.push(ImplCandidate(impl_def_id));\n+                        candidate_vec.push(ImplCandidate(impl_def_id));\n                     }\n                     Err(()) => { }\n                 }\n@@ -1007,7 +1018,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::ty_ptr(ty::mt { ty: referent_ty, .. }) => {     // *const T, *mut T\n+            ty::ty_ptr(..) => {     // *const T, *mut T\n                 match bound {\n                     ty::BoundCopy |\n                     ty::BoundSized => {\n@@ -1016,7 +1027,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                     ty::BoundSync |\n                     ty::BoundSend => {\n-                        Ok(If(vec![referent_ty]))\n+                        // sync and send are not implemented for *const, *mut\n+                        Err(Unimplemented)\n                     }\n                 }\n             }\n@@ -1324,16 +1336,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ty::BoundSync => {\n                     if\n                         Some(def_id) == tcx.lang_items.no_sync_bound() ||\n-                        Some(def_id) == tcx.lang_items.managed_bound()\n-                    {\n-                        return Err(Unimplemented)\n-                    } else if\n+                        Some(def_id) == tcx.lang_items.managed_bound() ||\n                         Some(def_id) == tcx.lang_items.unsafe_type()\n                     {\n-                        // FIXME(#13231) -- we currently consider `UnsafeCell<T>`\n-                        // to always be sync. This is allow for types like `Queue`\n-                        // and `Mutex`, where `Queue<T> : Sync` is `T : Send`.\n-                        return Ok(If(Vec::new()));\n+                        return Err(Unimplemented)\n                     }\n                 }\n \n@@ -1408,7 +1414,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // where-clause trait-ref could be unified with the obligation\n         // trait-ref. Repeat that unification now without any\n         // transactional boundary; it should not fail.\n-        match self.confirm_poly_trait_refs(obligation.cause,\n+        match self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                            obligation.trait_ref.clone(),\n                                            param.bound.clone()) {\n             Ok(()) => Ok(param),\n@@ -1447,10 +1453,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                            nested: Vec<Ty<'tcx>>)\n                            -> VtableBuiltinData<PredicateObligation<'tcx>>\n     {\n+        let derived_cause = self.derived_cause(obligation, BuiltinDerivedObligation);\n         let obligations = nested.iter().map(|&t| {\n             util::predicate_for_builtin_bound(\n                 self.tcx(),\n-                obligation.cause,\n+                derived_cause.clone(),\n                 bound,\n                 obligation.recursion_depth + 1,\n                 t)\n@@ -1463,7 +1470,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // as a special case, `Send` requires `'static`\n         if bound == ty::BoundSend {\n             obligations.push(Obligation {\n-                cause: obligation.cause,\n+                cause: obligation.cause.clone(),\n                 recursion_depth: obligation.recursion_depth+1,\n                 trait_ref: ty::Binder(ty::OutlivesPredicate(obligation.self_ty(),\n                                                             ty::ReStatic)).as_predicate(),\n@@ -1497,7 +1504,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let substs = self.rematch_impl(impl_def_id, obligation,\n                                            snapshot, &skol_map, Rc::new(skol_obligation_trait_ref));\n             debug!(\"confirm_impl_candidate substs={}\", substs);\n-            Ok(self.vtable_impl(impl_def_id, substs, obligation.cause,\n+            Ok(self.vtable_impl(impl_def_id, substs, obligation.cause.clone(),\n                                 obligation.recursion_depth + 1, skol_map, snapshot))\n         })\n     }\n@@ -1571,10 +1578,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             substs: substs,\n         }));\n \n-        try!(self.confirm_poly_trait_refs(obligation.cause,\n+        try!(self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                           obligation.trait_ref.clone(),\n                                           trait_ref));\n-\n         Ok(self_ty)\n     }\n \n@@ -1617,7 +1623,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                closure_def_id.repr(self.tcx()),\n                trait_ref.repr(self.tcx()));\n \n-        self.confirm_poly_trait_refs(obligation.cause,\n+        self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                      obligation.trait_ref.clone(),\n                                      trait_ref)\n     }\n@@ -1809,7 +1815,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// back `Ok(T=int)`.\n     fn match_inherent_impl(&mut self,\n                            impl_def_id: ast::DefId,\n-                           obligation_cause: ObligationCause,\n+                           obligation_cause: &ObligationCause,\n                            obligation_self_ty: Ty<'tcx>)\n                            -> Result<Substs<'tcx>,()>\n     {\n@@ -1842,7 +1848,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn match_self_types(&mut self,\n-                        cause: ObligationCause,\n+                        cause: &ObligationCause,\n \n                         // The self type provided by the impl/caller-obligation:\n                         provided_self_ty: Ty<'tcx>,\n@@ -1921,6 +1927,33 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             None\n         }\n     }\n+\n+    fn derived_cause(&self,\n+                     obligation: &TraitObligation<'tcx>,\n+                     variant: fn(Rc<ty::Binder<ty::TraitRef<'tcx>>>,\n+                                 Rc<ObligationCauseCode<'tcx>>)\n+                                 -> ObligationCauseCode<'tcx>)\n+                     -> ObligationCause<'tcx>\n+    {\n+        /*!\n+         * Creates a cause for obligations that are derived from\n+         * `obligation` by a recursive search (e.g., for a builtin\n+         * bound, or eventually a `impl Foo for ..`). If `obligation`\n+         * is itself a derived obligation, this is just a clone, but\n+         * otherwise we create a \"derived obligation\" cause so as to\n+         * keep track of the original root obligation for error\n+         * reporting.\n+         */\n+\n+        if obligation.recursion_depth == 0 {\n+            ObligationCause::new(obligation.cause.span,\n+                                 obligation.trait_ref.def_id().node,\n+                                 variant(obligation.trait_ref.clone(),\n+                                         Rc::new(obligation.cause.code.clone())))\n+        } else {\n+            obligation.cause.clone()\n+        }\n+    }\n }\n \n impl<'tcx> Repr<'tcx> for Candidate<'tcx> {"}, {"sha": "0864b21870d08f08204cba0b7715f42bc420ea2c", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -260,7 +260,7 @@ pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n            generic_bounds.repr(tcx));\n \n     generic_bounds.predicates.map(|predicate| {\n-        Obligation { cause: cause,\n+        Obligation { cause: cause.clone(),\n                      recursion_depth: recursion_depth,\n                      trait_ref: predicate.clone() }\n     })"}, {"sha": "b7cde762a849fe87e9c0526eab00033bcf6c6cc9", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -439,7 +439,7 @@ impl<'tcx,O> TypeFoldable<'tcx> for traits::Obligation<'tcx,O>\n {\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Obligation<'tcx, O> {\n         traits::Obligation {\n-            cause: self.cause,\n+            cause: self.cause.clone(),\n             recursion_depth: self.recursion_depth,\n             trait_ref: self.trait_ref.fold_with(folder),\n         }"}, {"sha": "6348ce8960887f52f7cadd2b672e44d220b5c95b", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -281,6 +281,8 @@ struct ModuleConfig {\n     time_passes: bool,\n }\n \n+impl Send for ModuleConfig { }\n+\n impl ModuleConfig {\n     fn new(tm: TargetMachineRef, passes: Vec<String>) -> ModuleConfig {\n         ModuleConfig {"}, {"sha": "640e83469b2695ae8a8020d4140b5dfa76a0126c", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -216,32 +216,32 @@ use syntax::{ast, codemap, ast_util, ast_map};\n use syntax::ast_util::PostExpansionMethod;\n use syntax::parse::token::{mod, special_idents};\n \n-static DW_LANG_RUST: c_uint = 0x9000;\n+const DW_LANG_RUST: c_uint = 0x9000;\n \n #[allow(non_upper_case_globals)]\n-static DW_TAG_auto_variable: c_uint = 0x100;\n+const DW_TAG_auto_variable: c_uint = 0x100;\n #[allow(non_upper_case_globals)]\n-static DW_TAG_arg_variable: c_uint = 0x101;\n+const DW_TAG_arg_variable: c_uint = 0x101;\n \n #[allow(non_upper_case_globals)]\n-static DW_ATE_boolean: c_uint = 0x02;\n+const DW_ATE_boolean: c_uint = 0x02;\n #[allow(non_upper_case_globals)]\n-static DW_ATE_float: c_uint = 0x04;\n+const DW_ATE_float: c_uint = 0x04;\n #[allow(non_upper_case_globals)]\n-static DW_ATE_signed: c_uint = 0x05;\n+const DW_ATE_signed: c_uint = 0x05;\n #[allow(non_upper_case_globals)]\n-static DW_ATE_unsigned: c_uint = 0x07;\n+const DW_ATE_unsigned: c_uint = 0x07;\n #[allow(non_upper_case_globals)]\n-static DW_ATE_unsigned_char: c_uint = 0x08;\n+const DW_ATE_unsigned_char: c_uint = 0x08;\n \n-static UNKNOWN_LINE_NUMBER: c_uint = 0;\n-static UNKNOWN_COLUMN_NUMBER: c_uint = 0;\n+const UNKNOWN_LINE_NUMBER: c_uint = 0;\n+const UNKNOWN_COLUMN_NUMBER: c_uint = 0;\n \n // ptr::null() doesn't work :(\n-static UNKNOWN_FILE_METADATA: DIFile = (0 as DIFile);\n-static UNKNOWN_SCOPE_METADATA: DIScope = (0 as DIScope);\n+const UNKNOWN_FILE_METADATA: DIFile = (0 as DIFile);\n+const UNKNOWN_SCOPE_METADATA: DIScope = (0 as DIScope);\n \n-static FLAGS_NONE: c_uint = 0;\n+const FLAGS_NONE: c_uint = 0;\n \n //=-----------------------------------------------------------------------------\n //  Public Interface of debuginfo module"}, {"sha": "c8cfdd3e4e4a4d8d8fc49455a8b90ca26c9bc211", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -60,6 +60,9 @@ pub struct ModuleTranslation {\n     pub llmod: ModuleRef,\n }\n \n+impl Send for ModuleTranslation { }\n+impl Sync for ModuleTranslation { }\n+\n pub struct CrateTranslation {\n     pub modules: Vec<ModuleTranslation>,\n     pub metadata_module: ModuleTranslation,"}, {"sha": "7ebf39e2e9a143198c7fcb860cbe8b7e4912631d", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 276, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -11,16 +11,14 @@\n use check::{FnCtxt, structurally_resolved_type};\n use middle::subst::{FnSpace};\n use middle::traits;\n-use middle::traits::{SelectionError, OutputTypeParameterMismatch, Overflow, Unimplemented};\n use middle::traits::{Obligation, ObligationCause};\n-use middle::traits::{FulfillmentError, CodeSelectionError, CodeAmbiguity};\n-use middle::traits::{PredicateObligation};\n+use middle::traits::report_fulfillment_errors;\n use middle::ty::{mod, Ty};\n use middle::infer;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n-use util::ppaux::{UserString, Repr, ty_to_string};\n+use util::ppaux::{Repr, ty_to_string};\n \n pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                    cast_expr: &ast::Expr,\n@@ -285,199 +283,7 @@ pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n                                                fcx);\n     match r {\n         Ok(()) => { }\n-        Err(errors) => { report_fulfillment_errors(fcx, &errors); }\n-    }\n-}\n-\n-pub fn report_fulfillment_errors<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                           errors: &Vec<FulfillmentError<'tcx>>) {\n-    for error in errors.iter() {\n-        report_fulfillment_error(fcx, error);\n-    }\n-}\n-\n-pub fn report_fulfillment_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                          error: &FulfillmentError<'tcx>) {\n-    match error.code {\n-        CodeSelectionError(ref e) => {\n-            report_selection_error(fcx, &error.obligation, e);\n-        }\n-        CodeAmbiguity => {\n-            maybe_report_ambiguity(fcx, &error.obligation);\n-        }\n-    }\n-}\n-\n-pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                        obligation: &PredicateObligation<'tcx>,\n-                                        error: &SelectionError<'tcx>)\n-{\n-    match *error {\n-        Overflow => {\n-            // We could track the stack here more precisely if we wanted, I imagine.\n-            let predicate =\n-                fcx.infcx().resolve_type_vars_if_possible(&obligation.trait_ref);\n-            fcx.tcx().sess.span_err(\n-                obligation.cause.span,\n-                format!(\n-                    \"overflow evaluating the requirement `{}`\",\n-                    predicate.user_string(fcx.tcx())).as_slice());\n-\n-            let current_limit = fcx.tcx().sess.recursion_limit.get();\n-            let suggested_limit = current_limit * 2;\n-            fcx.tcx().sess.span_note(\n-                obligation.cause.span,\n-                format!(\n-                    \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n-                    suggested_limit)[]);\n-\n-            note_obligation_cause(fcx, obligation);\n-        }\n-        Unimplemented => {\n-            match obligation.trait_ref {\n-                ty::Predicate::Trait(ref trait_ref) => {\n-                    let trait_ref = fcx.infcx().resolve_type_vars_if_possible(&**trait_ref);\n-                    if !ty::type_is_error(trait_ref.self_ty()) {\n-                        fcx.tcx().sess.span_err(\n-                            obligation.cause.span,\n-                            format!(\n-                                \"the trait `{}` is not implemented for the type `{}`\",\n-                                trait_ref.user_string(fcx.tcx()),\n-                                trait_ref.self_ty().user_string(fcx.tcx())).as_slice());\n-                    }\n-                }\n-\n-                ty::Predicate::Equate(ref predicate) => {\n-                    let predicate = fcx.infcx().resolve_type_vars_if_possible(predicate);\n-                    let err = fcx.infcx().equality_predicate(obligation.cause.span,\n-                                                             &predicate).unwrap_err();\n-                    fcx.tcx().sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\n-                            \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate.user_string(fcx.tcx()),\n-                            ty::type_err_to_str(fcx.tcx(), &err)).as_slice());\n-                }\n-\n-                ty::Predicate::RegionOutlives(ref predicate) => {\n-                    let predicate = fcx.infcx().resolve_type_vars_if_possible(predicate);\n-                    let err = fcx.infcx().region_outlives_predicate(obligation.cause.span,\n-                                                                    &predicate).unwrap_err();\n-                    fcx.tcx().sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\n-                            \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate.user_string(fcx.tcx()),\n-                            ty::type_err_to_str(fcx.tcx(), &err)).as_slice());\n-                }\n-\n-                ty::Predicate::TypeOutlives(ref predicate) => {\n-                    let predicate = fcx.infcx().resolve_type_vars_if_possible(predicate);\n-                    fcx.tcx().sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\n-                            \"the requirement `{}` is not satisfied\",\n-                            predicate.user_string(fcx.tcx())).as_slice());\n-                }\n-            }\n-\n-            note_obligation_cause(fcx, obligation);\n-        }\n-        OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, ref e) => {\n-            let expected_trait_ref =\n-                fcx.infcx().resolve_type_vars_if_possible(\n-                    &**expected_trait_ref);\n-            let actual_trait_ref =\n-                fcx.infcx().resolve_type_vars_if_possible(\n-                    &**actual_trait_ref);\n-            if !ty::type_is_error(actual_trait_ref.self_ty()) {\n-                fcx.tcx().sess.span_err(\n-                    obligation.cause.span,\n-                    format!(\n-                        \"type mismatch: the type `{}` implements the trait `{}`, \\\n-                         but the trait `{}` is required ({})\",\n-                        expected_trait_ref.self_ty().user_string(fcx.tcx()),\n-                        expected_trait_ref.user_string(fcx.tcx()),\n-                        actual_trait_ref.user_string(fcx.tcx()),\n-                        ty::type_err_to_str(fcx.tcx(), e)).as_slice());\n-                note_obligation_cause(fcx, obligation);\n-            }\n-        }\n-    }\n-}\n-\n-pub fn maybe_report_ambiguity<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                        obligation: &PredicateObligation<'tcx>) {\n-    // Unable to successfully determine, probably means\n-    // insufficient type information, but could mean\n-    // ambiguous impls. The latter *ought* to be a\n-    // coherence violation, so we don't report it here.\n-\n-    let trait_ref = match obligation.trait_ref {\n-        ty::Predicate::Trait(ref trait_ref) => {\n-            fcx.infcx().resolve_type_vars_if_possible(&**trait_ref)\n-        }\n-        _ => {\n-            fcx.tcx().sess.span_bug(\n-                obligation.cause.span,\n-                format!(\"ambiguity from something other than a trait: {}\",\n-                        obligation.trait_ref.repr(fcx.tcx())).as_slice());\n-        }\n-    };\n-    let self_ty = trait_ref.self_ty();\n-\n-    debug!(\"maybe_report_ambiguity(trait_ref={}, self_ty={}, obligation={})\",\n-           trait_ref.repr(fcx.tcx()),\n-           self_ty.repr(fcx.tcx()),\n-           obligation.repr(fcx.tcx()));\n-    let all_types = &trait_ref.substs().types;\n-    if all_types.iter().any(|&t| ty::type_is_error(t)) {\n-    } else if all_types.iter().any(|&t| ty::type_needs_infer(t)) {\n-        // This is kind of a hack: it frequently happens that some earlier\n-        // error prevents types from being fully inferred, and then we get\n-        // a bunch of uninteresting errors saying something like \"<generic\n-        // #0> doesn't implement Sized\".  It may even be true that we\n-        // could just skip over all checks where the self-ty is an\n-        // inference variable, but I was afraid that there might be an\n-        // inference variable created, registered as an obligation, and\n-        // then never forced by writeback, and hence by skipping here we'd\n-        // be ignoring the fact that we don't KNOW the type works\n-        // out. Though even that would probably be harmless, given that\n-        // we're only talking about builtin traits, which are known to be\n-        // inhabited. But in any case I just threw in this check for\n-        // has_errors() to be sure that compilation isn't happening\n-        // anyway. In that case, why inundate the user.\n-        if !fcx.tcx().sess.has_errors() {\n-            if fcx.ccx.tcx.lang_items.sized_trait()\n-                  .map_or(false, |sized_id| sized_id == trait_ref.def_id()) {\n-                fcx.tcx().sess.span_err(\n-                    obligation.cause.span,\n-                    format!(\n-                        \"unable to infer enough type information about `{}`; type annotations \\\n-                         required\",\n-                        self_ty.user_string(fcx.tcx()))[]);\n-            } else {\n-                fcx.tcx().sess.span_err(\n-                    obligation.cause.span,\n-                    format!(\n-                        \"unable to infer enough type information to \\\n-                         locate the impl of the trait `{}` for \\\n-                         the type `{}`; type annotations required\",\n-                        trait_ref.user_string(fcx.tcx()),\n-                        self_ty.user_string(fcx.tcx()))[]);\n-                note_obligation_cause(fcx, obligation);\n-            }\n-        }\n-    } else if !fcx.tcx().sess.has_errors() {\n-         // Ambiguity. Coherence should have reported an error.\n-        fcx.tcx().sess.span_bug(\n-            obligation.cause.span,\n-            format!(\n-                \"coherence failed to report ambiguity: \\\n-                 cannot locate the impl of the trait `{}` for \\\n-                 the type `{}`\",\n-                trait_ref.user_string(fcx.tcx()),\n-                self_ty.user_string(fcx.tcx()))[]);\n+        Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }\n     }\n }\n \n@@ -490,7 +296,7 @@ pub fn select_fcx_obligations_where_possible(fcx: &FnCtxt)\n         .select_where_possible(fcx.infcx(), &fcx.inh.param_env, fcx)\n     {\n         Ok(()) => { }\n-        Err(errors) => { report_fulfillment_errors(fcx, &errors); }\n+        Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }\n     }\n }\n \n@@ -504,83 +310,6 @@ pub fn select_new_fcx_obligations(fcx: &FnCtxt) {\n         .select_new_obligations(fcx.infcx(), &fcx.inh.param_env, fcx)\n     {\n         Ok(()) => { }\n-        Err(errors) => { report_fulfillment_errors(fcx, &errors); }\n-    }\n-}\n-\n-fn note_obligation_cause<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                   obligation: &PredicateObligation<'tcx>) {\n-    let tcx = fcx.tcx();\n-    match obligation.cause.code {\n-        traits::MiscObligation => { }\n-        traits::ItemObligation(item_def_id) => {\n-            let item_name = ty::item_path_str(tcx, item_def_id);\n-            tcx.sess.span_note(\n-                obligation.cause.span,\n-                format!(\n-                    \"required by `{}`\",\n-                    item_name).as_slice());\n-        }\n-        traits::ObjectCastObligation(object_ty) => {\n-            tcx.sess.span_note(\n-                obligation.cause.span,\n-                format!(\n-                    \"required for the cast to the object type `{}`\",\n-                    fcx.infcx().ty_to_string(object_ty)).as_slice());\n-        }\n-        traits::RepeatVec => {\n-            tcx.sess.span_note(\n-                obligation.cause.span,\n-                \"the `Copy` trait is required because the \\\n-                 repeated element will be copied\");\n-        }\n-        traits::VariableType(_) => {\n-            tcx.sess.span_note(\n-                obligation.cause.span,\n-                \"all local variables must have a statically known size\");\n-        }\n-        traits::ReturnType => {\n-            tcx.sess.span_note(\n-                obligation.cause.span,\n-                \"the return type of a function must have a \\\n-                 statically known size\");\n-        }\n-        traits::AssignmentLhsSized => {\n-            tcx.sess.span_note(\n-                obligation.cause.span,\n-                \"the left-hand-side of an assignment must have a statically known size\");\n-        }\n-        traits::StructInitializerSized => {\n-            tcx.sess.span_note(\n-                obligation.cause.span,\n-                \"structs must have a statically known size to be initialized\");\n-        }\n-        traits::DropTrait => {\n-            span_note!(tcx.sess, obligation.cause.span,\n-                      \"cannot implement a destructor on a \\\n-                      structure or enumeration that does not satisfy Send\");\n-            span_help!(tcx.sess, obligation.cause.span,\n-                       \"use \\\"#[unsafe_destructor]\\\" on the implementation \\\n-                       to force the compiler to allow this\");\n-        }\n-        traits::ClosureCapture(var_id, closure_span, builtin_bound) => {\n-            let def_id = tcx.lang_items.from_builtin_kind(builtin_bound).unwrap();\n-            let trait_name = ty::item_path_str(tcx, def_id);\n-            let name = ty::local_var_name_str(tcx, var_id);\n-            span_note!(tcx.sess, closure_span,\n-                       \"the closure that captures `{}` requires that all captured variables \\\"\n-                       implement the trait `{}`\",\n-                       name,\n-                       trait_name);\n-        }\n-        traits::FieldSized => {\n-            span_note!(tcx.sess, obligation.cause.span,\n-                       \"only the last field of a struct or enum variant \\\n-                       may have a dynamically sized type\")\n-        }\n-        traits::ObjectSized => {\n-            span_note!(tcx.sess, obligation.cause.span,\n-                       \"only sized types can be made into objects\");\n-        }\n+        Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }\n     }\n }"}, {"sha": "39bcfb354b873f380064fdbdd5b46ccbd9e3bc17", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -188,7 +188,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 match self_ty.sty {\n                     ty::ty_struct(def_id, _) |\n                     ty::ty_enum(def_id, _) => {\n-                        check_struct_safe_for_destructor(fcx, item.span, self_ty, def_id);\n+                        check_struct_safe_for_destructor(fcx, item.span, def_id);\n                     }\n                     _ => {\n                         // Coherence already reports an error in this case.\n@@ -221,7 +221,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             let poly_trait_ref = ty::Binder(trait_ref);\n             let predicates = ty::predicates_for_trait_ref(fcx.tcx(), &poly_trait_ref);\n             for predicate in predicates.into_iter() {\n-                fcx.register_predicate(traits::Obligation::new(cause, predicate));\n+                fcx.register_predicate(traits::Obligation::new(cause.clone(), predicate));\n             }\n         });\n     }\n@@ -460,20 +460,16 @@ fn filter_to_trait_obligations<'tcx>(bounds: ty::GenericBounds<'tcx>)\n \n fn check_struct_safe_for_destructor<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                               span: Span,\n-                                              self_ty: Ty<'tcx>,\n                                               struct_did: ast::DefId) {\n     let struct_tpt = ty::lookup_item_type(fcx.tcx(), struct_did);\n-    if !struct_tpt.generics.has_type_params(subst::TypeSpace)\n-        && !struct_tpt.generics.has_region_params(subst::TypeSpace)\n+    if struct_tpt.generics.has_type_params(subst::TypeSpace)\n+        || struct_tpt.generics.has_region_params(subst::TypeSpace)\n     {\n-        let cause = traits::ObligationCause::new(span, fcx.body_id, traits::DropTrait);\n-        fcx.register_builtin_bound(self_ty, ty::BoundSend, cause);\n-    } else {\n         span_err!(fcx.tcx().sess, span, E0141,\n                   \"cannot implement a destructor on a structure \\\n-                       with type parameters\");\n-            span_note!(fcx.tcx().sess, span,\n-                       \"use \\\"#[unsafe_destructor]\\\" on the implementation \\\n-                        to force the compiler to allow this\");\n+                   with type parameters\");\n+        span_note!(fcx.tcx().sess, span,\n+                   \"use \\\"#[unsafe_destructor]\\\" on the implementation \\\n+                    to force the compiler to allow this\");\n     }\n }"}, {"sha": "27b63be6cd0b1c851342ee621e97535224c33228", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -72,13 +72,12 @@ use libc;\n \n use fmt;\n use hash;\n-use kinds::marker;\n use mem;\n use ptr;\n use slice::{mod, ImmutableIntSlice};\n use str;\n use string::String;\n-\n+use core::kinds::marker;\n \n /// The representation of a C String.\n ///\n@@ -90,6 +89,9 @@ pub struct CString {\n     owns_buffer_: bool,\n }\n \n+impl Send for CString { }\n+impl Sync for CString { }\n+\n impl Clone for CString {\n     /// Clone this CString into a new, uniquely owned CString. For safety\n     /// reasons, this is always a deep clone with the memory allocated"}, {"sha": "ee37eb277956b2213375771673698be343a6365e", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -23,7 +23,7 @@ use num::{Int, UnsignedInt};\n use ops::{Deref, DerefMut, Drop};\n use option::Option;\n use option::Option::{Some, None};\n-use ptr::{RawPtr, copy_nonoverlapping_memory, zero_memory};\n+use ptr::{OwnedPtr, RawPtr, copy_nonoverlapping_memory, zero_memory};\n use ptr;\n use rt::heap::{allocate, deallocate};\n \n@@ -69,7 +69,7 @@ const EMPTY_BUCKET: u64 = 0u64;\n pub struct RawTable<K, V> {\n     capacity: uint,\n     size:     uint,\n-    hashes:   *mut u64,\n+    hashes:   OwnedPtr<u64>,\n     // Because K/V do not appear directly in any of the types in the struct,\n     // inform rustc that in fact instances of K and V are reachable from here.\n     marker:   marker::CovariantType<(K,V)>,\n@@ -563,7 +563,7 @@ impl<K, V> RawTable<K, V> {\n             return RawTable {\n                 size: 0,\n                 capacity: 0,\n-                hashes: 0 as *mut u64,\n+                hashes: OwnedPtr::null(),\n                 marker: marker::CovariantType,\n             };\n         }\n@@ -602,7 +602,7 @@ impl<K, V> RawTable<K, V> {\n         RawTable {\n             capacity: capacity,\n             size:     0,\n-            hashes:   hashes,\n+            hashes:   OwnedPtr(hashes),\n             marker:   marker::CovariantType,\n         }\n     }\n@@ -611,14 +611,14 @@ impl<K, V> RawTable<K, V> {\n         let hashes_size = self.capacity * size_of::<u64>();\n         let keys_size = self.capacity * size_of::<K>();\n \n-        let buffer = self.hashes as *mut u8;\n+        let buffer = self.hashes.0 as *mut u8;\n         let (keys_offset, vals_offset) = calculate_offsets(hashes_size,\n                                                            keys_size, min_align_of::<K>(),\n                                                            min_align_of::<V>());\n \n         unsafe {\n             RawBucket {\n-                hash: self.hashes,\n+                hash: self.hashes.0,\n                 key:  buffer.offset(keys_offset as int) as *mut K,\n                 val:  buffer.offset(vals_offset as int) as *mut V\n             }\n@@ -631,7 +631,7 @@ impl<K, V> RawTable<K, V> {\n     pub fn new(capacity: uint) -> RawTable<K, V> {\n         unsafe {\n             let ret = RawTable::new_uninitialized(capacity);\n-            zero_memory(ret.hashes, capacity);\n+            zero_memory(ret.hashes.0, capacity);\n             ret\n         }\n     }\n@@ -651,7 +651,7 @@ impl<K, V> RawTable<K, V> {\n         RawBuckets {\n             raw: self.first_bucket_raw(),\n             hashes_end: unsafe {\n-                self.hashes.offset(self.capacity as int)\n+                self.hashes.0.offset(self.capacity as int)\n             },\n             marker: marker::ContravariantLifetime,\n         }\n@@ -916,7 +916,7 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n #[unsafe_destructor]\n impl<K, V> Drop for RawTable<K, V> {\n     fn drop(&mut self) {\n-        if self.hashes.is_null() {\n+        if self.hashes.0.is_null() {\n             return;\n         }\n         // This is done in reverse because we've likely partially taken\n@@ -936,7 +936,7 @@ impl<K, V> Drop for RawTable<K, V> {\n                                                     vals_size, min_align_of::<V>());\n \n         unsafe {\n-            deallocate(self.hashes as *mut u8, size, align);\n+            deallocate(self.hashes.0 as *mut u8, size, align);\n             // Remember how everything was allocated out of one buffer\n             // during initialization? We only need one call to free here.\n         }"}, {"sha": "a154224824c0a5161ad361cd8109e3403ba8b3d0", "filename": "src/libstd/comm/blocking.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fcomm%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fcomm%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fblocking.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -17,6 +17,7 @@ use kinds::marker::{NoSend, NoSync};\n use mem;\n use clone::Clone;\n \n+#[deriving(Send, Sync)]\n struct Inner {\n     thread: Thread,\n     woken: AtomicBool,"}, {"sha": "18b50c621e93bf7c9e8c19f5e98bd8ca1881b925", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -321,7 +321,7 @@ use self::Flavor::*;\n use alloc::arc::Arc;\n use core::kinds::marker;\n use core::mem;\n-use core::cell::UnsafeCell;\n+use core::cell::{UnsafeCell, RacyCell};\n \n pub use self::select::{Select, Handle};\n use self::select::StartResult;\n@@ -359,10 +359,12 @@ mod spsc_queue;\n #[unstable]\n pub struct Receiver<T> {\n     inner: UnsafeCell<Flavor<T>>,\n-    // can't share in an arc\n-    _marker: marker::NoSync,\n }\n \n+// The receiver port can be sent from place to place, so long as it\n+// is not used to receive non-sendable things.\n+impl<T:Send> Send for Receiver<T> { }\n+\n /// An iterator over messages on a receiver, this iterator will block\n /// whenever `next` is called, waiting for a new message, and `None` will be\n /// returned when the corresponding channel has hung up.\n@@ -376,15 +378,17 @@ pub struct Messages<'a, T:'a> {\n #[unstable]\n pub struct Sender<T> {\n     inner: UnsafeCell<Flavor<T>>,\n-    // can't share in an arc\n-    _marker: marker::NoSync,\n }\n \n+// The send port can be sent from place to place, so long as it\n+// is not used to send non-sendable things.\n+impl<T:Send> Send for Sender<T> { }\n+\n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n #[unstable = \"this type may be renamed, but it will always exist\"]\n pub struct SyncSender<T> {\n-    inner: Arc<UnsafeCell<sync::Packet<T>>>,\n+    inner: Arc<RacyCell<sync::Packet<T>>>,\n     // can't share in an arc\n     _marker: marker::NoSync,\n }\n@@ -420,10 +424,10 @@ pub enum TrySendError<T> {\n }\n \n enum Flavor<T> {\n-    Oneshot(Arc<UnsafeCell<oneshot::Packet<T>>>),\n-    Stream(Arc<UnsafeCell<stream::Packet<T>>>),\n-    Shared(Arc<UnsafeCell<shared::Packet<T>>>),\n-    Sync(Arc<UnsafeCell<sync::Packet<T>>>),\n+    Oneshot(Arc<RacyCell<oneshot::Packet<T>>>),\n+    Stream(Arc<RacyCell<stream::Packet<T>>>),\n+    Shared(Arc<RacyCell<shared::Packet<T>>>),\n+    Sync(Arc<RacyCell<sync::Packet<T>>>),\n }\n \n #[doc(hidden)]\n@@ -474,7 +478,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// ```\n #[unstable]\n pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n-    let a = Arc::new(UnsafeCell::new(oneshot::Packet::new()));\n+    let a = Arc::new(RacyCell::new(oneshot::Packet::new()));\n     (Sender::new(Oneshot(a.clone())), Receiver::new(Oneshot(a)))\n }\n \n@@ -514,7 +518,7 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n #[unstable = \"this function may be renamed to more accurately reflect the type \\\n               of channel that is is creating\"]\n pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n-    let a = Arc::new(UnsafeCell::new(sync::Packet::new(bound)));\n+    let a = Arc::new(RacyCell::new(sync::Packet::new(bound)));\n     (SyncSender::new(a.clone()), Receiver::new(Sync(a)))\n }\n \n@@ -526,7 +530,6 @@ impl<T: Send> Sender<T> {\n     fn new(inner: Flavor<T>) -> Sender<T> {\n         Sender {\n             inner: UnsafeCell::new(inner),\n-            _marker: marker::NoSync,\n         }\n     }\n \n@@ -596,7 +599,8 @@ impl<T: Send> Sender<T> {\n                     if !(*p).sent() {\n                         return (*p).send(t);\n                     } else {\n-                        let a = Arc::new(UnsafeCell::new(stream::Packet::new()));\n+                        let a =\n+                            Arc::new(RacyCell::new(stream::Packet::new()));\n                         match (*p).upgrade(Receiver::new(Stream(a.clone()))) {\n                             oneshot::UpSuccess => {\n                                 let ret = (*a.get()).send(t);\n@@ -633,7 +637,7 @@ impl<T: Send> Clone for Sender<T> {\n     fn clone(&self) -> Sender<T> {\n         let (packet, sleeper, guard) = match *unsafe { self.inner() } {\n             Oneshot(ref p) => {\n-                let a = Arc::new(UnsafeCell::new(shared::Packet::new()));\n+                let a = Arc::new(RacyCell::new(shared::Packet::new()));\n                 unsafe {\n                     let guard = (*a.get()).postinit_lock();\n                     match (*p.get()).upgrade(Receiver::new(Shared(a.clone()))) {\n@@ -644,7 +648,7 @@ impl<T: Send> Clone for Sender<T> {\n                 }\n             }\n             Stream(ref p) => {\n-                let a = Arc::new(UnsafeCell::new(shared::Packet::new()));\n+                let a = Arc::new(RacyCell::new(shared::Packet::new()));\n                 unsafe {\n                     let guard = (*a.get()).postinit_lock();\n                     match (*p.get()).upgrade(Receiver::new(Shared(a.clone()))) {\n@@ -688,7 +692,7 @@ impl<T: Send> Drop for Sender<T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n impl<T: Send> SyncSender<T> {\n-    fn new(inner: Arc<UnsafeCell<sync::Packet<T>>>) -> SyncSender<T> {\n+    fn new(inner: Arc<RacyCell<sync::Packet<T>>>) -> SyncSender<T> {\n         SyncSender { inner: inner, _marker: marker::NoSync }\n     }\n \n@@ -777,7 +781,7 @@ impl<T: Send> Drop for SyncSender<T> {\n \n impl<T: Send> Receiver<T> {\n     fn new(inner: Flavor<T>) -> Receiver<T> {\n-        Receiver { inner: UnsafeCell::new(inner), _marker: marker::NoSync }\n+        Receiver { inner: UnsafeCell::new(inner) }\n     }\n \n     /// Blocks waiting for a value on this receiver"}, {"sha": "6298896a18b428b04264490b2700ff8ceba53aeb", "filename": "src/libstd/comm/mpsc_queue.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fcomm%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fcomm%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmpsc_queue.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -76,6 +76,9 @@ pub struct Queue<T> {\n     tail: UnsafeCell<*mut Node<T>>,\n }\n \n+impl<T:Send> Send for Queue<T> { }\n+impl<T:Send> Sync for Queue<T> { }\n+\n impl<T> Node<T> {\n     unsafe fn new(v: Option<T>) -> *mut Node<T> {\n         mem::transmute(box Node {"}, {"sha": "dbf1f25599720a0e9ae491e2665eae43c33e8691", "filename": "src/libstd/comm/spsc_queue.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fcomm%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fcomm%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fspsc_queue.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -73,6 +73,10 @@ pub struct Queue<T> {\n     cache_subtractions: AtomicUint,\n }\n \n+impl<T: Send> Send for Queue<T> { }\n+\n+impl<T: Send> Sync for Queue<T> { }\n+\n impl<T: Send> Node<T> {\n     fn new() -> *mut Node<T> {\n         unsafe {"}, {"sha": "f4f4c7472e2714856b39977f4fe1b339940356a1", "filename": "src/libstd/comm/sync.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fsync.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -53,6 +53,11 @@ pub struct Packet<T> {\n     lock: Mutex<State<T>>,\n }\n \n+impl<T:Send> Send for Packet<T> { }\n+\n+impl<T:Send> Sync for Packet<T> { }\n+\n+#[deriving(Send)]\n struct State<T> {\n     disconnected: bool, // Is the channel disconnected yet?\n     queue: Queue,       // queue of senders waiting to send data\n@@ -88,6 +93,8 @@ struct Node {\n     next: *mut Node,\n }\n \n+impl Send for Node {}\n+\n /// A simple ring-buffer\n struct Buffer<T> {\n     buf: Vec<Option<T>>,"}, {"sha": "a878066ad160fbec2743a956da2de75a8dc1d0f7", "filename": "src/libstd/rt/exclusive.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Frt%2Fexclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Frt%2Fexclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fexclusive.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -26,6 +26,10 @@ pub struct Exclusive<T> {\n     data: UnsafeCell<T>,\n }\n \n+impl<T:Send> Send for Exclusive<T> { }\n+\n+impl<T:Send> Sync for Exclusive<T> { }\n+\n /// An RAII guard returned via `lock`\n pub struct ExclusiveGuard<'a, T:'a> {\n     // FIXME #12808: strange name to try to avoid interfering with"}, {"sha": "2849813c51051c58531335a742e55f2aa7c97de2", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -10,7 +10,7 @@\n \n use prelude::*;\n \n-use cell::UnsafeCell;\n+use cell::{UnsafeCell, RacyCell};\n use kinds::marker;\n use sync::{poison, AsMutexGuard};\n use sys_common::mutex as sys;\n@@ -70,9 +70,13 @@ pub struct Mutex<T> {\n     // time, so to ensure that the native mutex is used correctly we box the\n     // inner lock to give it a constant address.\n     inner: Box<StaticMutex>,\n-    data: UnsafeCell<T>,\n+    data: RacyCell<T>,\n }\n \n+impl<T:Send> Send for Mutex<T> { }\n+\n+impl<T:Send> Sync for Mutex<T> { }\n+\n /// The static mutex type is provided to allow for static allocation of mutexes.\n ///\n /// Note that this is a separate type because using a Mutex correctly means that\n@@ -94,9 +98,10 @@ pub struct Mutex<T> {\n /// }\n /// // lock is unlocked here.\n /// ```\n+#[deriving(Sync)]\n pub struct StaticMutex {\n     lock: sys::Mutex,\n-    poison: UnsafeCell<poison::Flag>,\n+    poison: RacyCell<poison::Flag>,\n }\n \n /// An RAII implementation of a \"scoped lock\" of a mutex. When this structure is\n@@ -125,15 +130,15 @@ pub struct StaticMutexGuard {\n /// other mutex constants.\n pub const MUTEX_INIT: StaticMutex = StaticMutex {\n     lock: sys::MUTEX_INIT,\n-    poison: UnsafeCell { value: poison::Flag { failed: false } },\n+    poison: RacyCell(UnsafeCell { value: poison::Flag { failed: false } }),\n };\n \n impl<T: Send> Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n     pub fn new(t: T) -> Mutex<T> {\n         Mutex {\n             inner: box MUTEX_INIT,\n-            data: UnsafeCell::new(t),\n+            data: RacyCell::new(t),\n         }\n     }\n "}, {"sha": "4b940b0420af33a06adc926db41542d07737089d", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -35,6 +35,7 @@ use sync::{StaticMutex, MUTEX_INIT};\n ///     // run initialization here\n /// });\n /// ```\n+#[deriving(Sync)]\n pub struct Once {\n     mutex: StaticMutex,\n     cnt: atomic::AtomicInt,"}, {"sha": "9df69d8e0d689964aeb1e10164ef1869feb422c1", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -59,6 +59,10 @@ pub struct Helper<M> {\n     pub shutdown: UnsafeCell<bool>,\n }\n \n+impl<M:Send> Send for Helper<M> { }\n+\n+impl<M:Send> Sync for Helper<M> { }\n+\n impl<M: Send> Helper<M> {\n     /// Lazily boots a helper thread, becoming a no-op if the helper has already\n     /// been spawned."}, {"sha": "5869c280517b2fe67da501507da8531d9fd1d017", "filename": "src/libstd/sys/common/mutex.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -15,6 +15,7 @@ use sys::mutex as imp;\n /// This is the thinnest cross-platform wrapper around OS mutexes. All usage of\n /// this mutex is unsafe and it is recommended to instead use the safe wrapper\n /// at the top level of the crate instead of this type.\n+#[deriving(Sync)]\n pub struct Mutex(imp::Mutex);\n \n /// Constant initializer for statically allocated mutexes."}, {"sha": "a5796f8dd016f3ff2ade1e022f44c5cc04cb80e3", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -162,6 +162,9 @@ mod signal {\n         sa_restorer: *mut libc::c_void,\n     }\n \n+    impl ::kinds::Send for sigaction { }\n+    impl ::kinds::Sync for sigaction { }\n+\n     #[repr(C)]\n     #[cfg(target_word_size = \"32\")]\n     pub struct sigset_t {\n@@ -211,6 +214,9 @@ mod signal {\n         sa_resv: [libc::c_int, ..1],\n     }\n \n+    impl ::kinds::Send for sigaction { }\n+    impl ::kinds::Sync for sigaction { }\n+\n     #[repr(C)]\n     pub struct sigset_t {\n         __val: [libc::c_ulong, ..32],"}, {"sha": "52ed0649694478343ce217426d2586d473d0211b", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -8,19 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use cell::UnsafeCell;\n+use cell::{UnsafeCell, RacyCell};\n use sys::sync as ffi;\n use sys_common::mutex;\n \n-pub struct Mutex { inner: UnsafeCell<ffi::pthread_mutex_t> }\n+#[deriving(Sync)]\n+pub struct Mutex { inner: RacyCell<ffi::pthread_mutex_t> }\n \n #[inline]\n pub unsafe fn raw(m: &Mutex) -> *mut ffi::pthread_mutex_t {\n     m.inner.get()\n }\n \n pub const MUTEX_INIT: Mutex = Mutex {\n-    inner: UnsafeCell { value: ffi::PTHREAD_MUTEX_INITIALIZER },\n+    inner: RacyCell(UnsafeCell { value: ffi::PTHREAD_MUTEX_INITIALIZER }),\n };\n \n impl Mutex {"}, {"sha": "8d1010937bcac1118959bd165ce67ea9430f7d84", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -210,6 +210,7 @@ impl Clone for UnixStream {\n // Unix Listener\n ////////////////////////////////////////////////////////////////////////////////\n \n+#[deriving(Sync)]\n pub struct UnixListener {\n     inner: Inner,\n     path: CString,\n@@ -252,6 +253,7 @@ pub struct UnixAcceptor {\n     deadline: u64,\n }\n \n+#[deriving(Sync)]\n struct AcceptorInner {\n     listener: UnixListener,\n     reader: FileDesc,"}, {"sha": "bcbbb8766b7f47038534f8b574e19be6c9773989", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -160,7 +160,7 @@ mod imp {\n \n         pub static SIGSTKSZ: libc::size_t = 8192;\n \n-        pub static SIG_DFL: sighandler_t = 0i as sighandler_t;\n+        pub const SIG_DFL: sighandler_t = 0i as sighandler_t;\n \n         // This definition is not as accurate as it could be, {si_addr} is\n         // actually a giant union. Currently we're only interested in that field,"}, {"sha": "60ca76171b1457e6c1ce12806d68881f5fe937ff", "filename": "src/libstd/sys/unix/tcp.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -29,6 +29,7 @@ pub use sys_common::net::TcpStream;\n // TCP listeners\n ////////////////////////////////////////////////////////////////////////////////\n \n+#[deriving(Sync)]\n pub struct TcpListener {\n     pub inner: FileDesc,\n }\n@@ -89,6 +90,7 @@ pub struct TcpAcceptor {\n     deadline: u64,\n }\n \n+#[deriving(Sync)]\n struct AcceptorInner {\n     listener: TcpListener,\n     reader: FileDesc,"}, {"sha": "e3b97afb31da14b7b733d33487722e722038e310", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -127,9 +127,9 @@\n use any::Any;\n use borrow::IntoCow;\n use boxed::Box;\n-use cell::UnsafeCell;\n+use cell::RacyCell;\n use clone::Clone;\n-use kinds::Send;\n+use kinds::{Send, Sync};\n use ops::{Drop, FnOnce};\n use option::Option::{mod, Some, None};\n use result::Result::{Err, Ok};\n@@ -211,7 +211,7 @@ impl Builder {\n     }\n \n     fn spawn_inner<T: Send>(self, f: Thunk<(), T>) -> JoinGuard<T> {\n-        let my_packet = Arc::new(UnsafeCell::new(None));\n+        let my_packet = Arc::new(RacyCell::new(None));\n         let their_packet = my_packet.clone();\n \n         let Builder { name, stack_size, stdout, stderr } = self;\n@@ -283,13 +283,14 @@ impl Builder {\n     }\n }\n \n+#[deriving(Sync)]\n struct Inner {\n     name: Option<String>,\n     lock: Mutex<bool>,          // true when there is a buffered unpark\n     cvar: Condvar,\n }\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Sync)]\n /// A handle to a thread.\n pub struct Thread {\n     inner: Arc<Inner>,\n@@ -387,7 +388,7 @@ pub struct JoinGuard<T> {\n     native: imp::rust_thread,\n     thread: Thread,\n     joined: bool,\n-    packet: Arc<UnsafeCell<Option<Result<T>>>>,\n+    packet: Arc<RacyCell<Option<Result<T>>>>,\n }\n \n impl<T: Send> JoinGuard<T> {"}, {"sha": "55fb315113390a74f82354edb27b6a5e1d6ed26a", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -280,6 +280,8 @@ mod imp {\n         pub dtor_running: UnsafeCell<bool>, // should be Cell\n     }\n \n+    impl<T> ::kinds::Sync for Key<T> { }\n+\n     #[doc(hidden)]\n     impl<T> Key<T> {\n         pub unsafe fn get(&'static self) -> Option<&'static T> {\n@@ -410,6 +412,8 @@ mod imp {\n         pub os: OsStaticKey,\n     }\n \n+    impl<T> ::kinds::Sync for Key<T> { }\n+\n     struct Value<T: 'static> {\n         key: &'static Key<T>,\n         value: T,"}, {"sha": "83e61373dd1ec46ee96c756a1015fac376fa28b6", "filename": "src/libstd/thread_local/scoped.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fthread_local%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibstd%2Fthread_local%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fscoped.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -198,10 +198,12 @@ impl<T> Key<T> {\n mod imp {\n     use std::cell::UnsafeCell;\n \n-    // FIXME: Should be a `Cell`, but that's not `Sync`\n+    // SNAP c9f6d69 switch to `Cell`\n     #[doc(hidden)]\n     pub struct KeyInner<T> { pub inner: UnsafeCell<*mut T> }\n \n+    #[cfg(not(stage0))] impl<T> ::kinds::Sync for KeyInner<T> { }\n+\n     #[doc(hidden)]\n     impl<T> KeyInner<T> {\n         #[doc(hidden)]\n@@ -222,6 +224,8 @@ mod imp {\n         pub marker: marker::InvariantType<T>,\n     }\n \n+    #[cfg(not(stage0))] impl<T> ::kinds::Sync for KeyInner<T> { }\n+\n     #[doc(hidden)]\n     impl<T> KeyInner<T> {\n         #[doc(hidden)]"}, {"sha": "dc30f973ff7f397829df3a11b21fde839c9ef477", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -976,6 +976,8 @@ enum TestEvent {\n \n pub type MonitorMsg = (TestDesc, TestResult, Vec<u8> );\n \n+impl Send for MonitorMsg {}\n+\n fn run_tests<F>(opts: &TestOpts,\n                 tests: Vec<TestDescAndFn> ,\n                 mut callback: F) -> io::IoResult<()> where"}, {"sha": "81943b9f13aab29aa120b85bf7e660d5fcf6e5ae", "filename": "src/test/run-pass/const-block.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Ftest%2Frun-pass%2Fconst-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Ftest%2Frun-pass%2Fconst-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-block.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -11,11 +11,15 @@\n #![allow(dead_code)]\n #![allow(unused_unsafe)]\n \n+use std::kinds::Sync;\n+\n struct Foo {\n     a: uint,\n     b: *const ()\n }\n \n+impl Sync for Foo {}\n+\n fn foo<T>(a: T) -> T {\n     a\n }"}, {"sha": "e581a3a65d1fc289850db2e9930a0e5cb7869033", "filename": "src/test/run-pass/const-cast-ptr-int.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Ftest%2Frun-pass%2Fconst-cast-ptr-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Ftest%2Frun-pass%2Fconst-cast-ptr-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-cast-ptr-int.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -10,8 +10,14 @@\n \n use std::ptr;\n \n-static a: *const u8 = 0 as *const u8;\n+struct TestStruct {\n+    x: *const u8\n+}\n+\n+impl Sync for TestStruct {}\n+\n+static a: TestStruct = TestStruct{x: 0 as *const u8};\n \n pub fn main() {\n-    assert_eq!(a, ptr::null());\n+    assert_eq!(a.x, ptr::null());\n }"}, {"sha": "29c119f742f11680aa86a2a1a064b79f9d2aeabf", "filename": "src/test/run-pass/const-cast.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Ftest%2Frun-pass%2Fconst-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Ftest%2Frun-pass%2Fconst-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-cast.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -10,14 +10,16 @@\n \n extern crate libc;\n \n-extern fn foo() {}\n+struct TestStruct {\n+    x: *const libc::c_void\n+}\n \n+impl Sync for TestStruct {}\n+\n+extern fn foo() {}\n const x: extern \"C\" fn() = foo;\n-static y: *const libc::c_void = x as *const libc::c_void;\n-const a: &'static int = &10;\n-static b: *const int = a as *const int;\n+static y: TestStruct = TestStruct { x: x as *const libc::c_void };\n \n pub fn main() {\n-    assert_eq!(x as *const libc::c_void, y);\n-    assert_eq!(a as *const int, b);\n+    assert_eq!(x as *const libc::c_void, y.x);\n }"}, {"sha": "3a3d236b69dbe69256cba59bd76ce4075be5478f", "filename": "src/test/run-pass/issue-13837.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Ftest%2Frun-pass%2Fissue-13837.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Ftest%2Frun-pass%2Fissue-13837.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13837.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -8,6 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static TEST_VALUE : *const [int; 2] = 0x1234 as *const [int; 2];\n+struct TestStruct {\n+    x: *const [int; 2]\n+}\n+\n+impl Sync for TestStruct {}\n+\n+static TEST_VALUE : TestStruct = TestStruct{x: 0x1234 as *const [int; 2]};\n \n fn main() {}"}, {"sha": "9ca1245f067c81f8ec4fea8341576f9c12ce0ac9", "filename": "src/test/run-pass/issue-17718-static-unsafe-interior.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Ftest%2Frun-pass%2Fissue-17718-static-unsafe-interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Ftest%2Frun-pass%2Fissue-17718-static-unsafe-interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17718-static-unsafe-interior.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n use std::kinds::marker;\n-use std::cell::UnsafeCell;\n+use std::cell::{UnsafeCell, RacyCell};\n \n struct MyUnsafe<T> {\n-    value: UnsafeCell<T>\n+    value: RacyCell<T>\n }\n \n impl<T> MyUnsafe<T> {\n@@ -21,23 +21,25 @@ impl<T> MyUnsafe<T> {\n \n enum UnsafeEnum<T> {\n     VariantSafe,\n-    VariantUnsafe(UnsafeCell<T>)\n+    VariantUnsafe(RacyCell<T>)\n }\n \n static STATIC1: UnsafeEnum<int> = UnsafeEnum::VariantSafe;\n \n-static STATIC2: UnsafeCell<int> = UnsafeCell { value: 1 };\n-const CONST: UnsafeCell<int> = UnsafeCell { value: 1 };\n+static STATIC2: RacyCell<int> = RacyCell(UnsafeCell { value: 1 });\n+const CONST: RacyCell<int> = RacyCell(UnsafeCell { value: 1 });\n static STATIC3: MyUnsafe<int> = MyUnsafe{value: CONST};\n \n-static STATIC4: &'static UnsafeCell<int> = &STATIC2;\n+static STATIC4: &'static RacyCell<int> = &STATIC2;\n \n struct Wrap<T> {\n     value: T\n }\n \n-static UNSAFE: UnsafeCell<int> = UnsafeCell{value: 1};\n-static WRAPPED_UNSAFE: Wrap<&'static UnsafeCell<int>> = Wrap { value: &UNSAFE };\n+impl<T: Send> Sync for Wrap<T> {}\n+\n+static UNSAFE: RacyCell<int> = RacyCell(UnsafeCell{value: 1});\n+static WRAPPED_UNSAFE: Wrap<&'static RacyCell<int>> = Wrap { value: &UNSAFE };\n \n fn main() {\n     let a = &STATIC1;"}, {"sha": "73cda4ba8fb430271cbe3e6c8f1f2e53535f02f3", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -23,6 +23,7 @@ pub mod pipes {\n     use std::mem::{replace, swap};\n     use std::mem;\n     use std::task;\n+    use std::kinds::Send;\n \n     pub struct Stuff<T> {\n         state: state,\n@@ -45,6 +46,8 @@ pub mod pipes {\n         payload: Option<T>\n     }\n \n+    impl<T:Send> Send for packet<T> {}\n+\n     pub fn packet<T:Send>() -> *const packet<T> {\n         unsafe {\n             let p: *const packet<T> = mem::transmute(box Stuff{\n@@ -230,8 +233,13 @@ pub mod pingpong {\n     use std::mem;\n \n     pub struct ping(::pipes::send_packet<pong>);\n+\n+    unsafe impl Send for ping {}\n+\n     pub struct pong(::pipes::send_packet<ping>);\n \n+    unsafe impl Send for pong {}\n+\n     pub fn liberate_ping(p: ping) -> ::pipes::send_packet<pong> {\n         unsafe {\n             let _addr : *const ::pipes::send_packet<pong> = match &p {"}, {"sha": "5e9d778e5ba847ceabb4ac10bf7af67930a28f2b", "filename": "src/test/run-pass/typeck_type_placeholder_1.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb803a857000813e4d572900799f0498fb20050b/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb803a857000813e4d572900799f0498fb20050b/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs?ref=fb803a857000813e4d572900799f0498fb20050b", "patch": "@@ -11,7 +11,14 @@\n // This test checks that the `_` type placeholder works\n // correctly for enabling type inference.\n \n-static CONSTEXPR: *const int = &413 as *const _;\n+struct TestStruct {\n+    x: *const int\n+}\n+\n+impl Sync for TestStruct {}\n+\n+static CONSTEXPR: TestStruct = TestStruct{x: &413 as *const _};\n+\n \n pub fn main() {\n     let x: Vec<_> = range(0u, 5).collect();"}]}