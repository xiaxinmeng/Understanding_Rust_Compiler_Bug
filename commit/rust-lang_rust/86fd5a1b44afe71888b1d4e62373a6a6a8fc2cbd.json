{"sha": "86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd", "node_id": "C_kwDOAAsO6NoAKDg2ZmQ1YTFiNDRhZmU3MTg4OGIxZDRlNjIzNzNhNmE2YThmYzJjYmQ", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-02-15T10:30:14Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-02-15T11:00:03Z"}, "message": "Use more let chain", "tree": {"sha": "92d9f49cdba1035d6825ba6a1223d703c206731f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92d9f49cdba1035d6825ba6a1223d703c206731f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd", "html_url": "https://github.com/rust-lang/rust/commit/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bb6e60d1f1360234aae90c97964c0fa5524f141", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bb6e60d1f1360234aae90c97964c0fa5524f141", "html_url": "https://github.com/rust-lang/rust/commit/9bb6e60d1f1360234aae90c97964c0fa5524f141"}], "stats": {"total": 471, "additions": 220, "deletions": 251}, "files": [{"sha": "dd58a5b51fc1a1d2726b992c8bc778cfdc510191", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd", "patch": "@@ -164,10 +164,10 @@ impl Cfg {\n     /// Renders the configuration for human display, as a short HTML description.\n     pub(crate) fn render_short_html(&self) -> String {\n         let mut msg = Display(self, Format::ShortHtml).to_string();\n-        if self.should_capitalize_first_letter() {\n-            if let Some(i) = msg.find(|c: char| c.is_ascii_alphanumeric()) {\n-                msg[i..i + 1].make_ascii_uppercase();\n-            }\n+        if self.should_capitalize_first_letter() &&\n+            let Some(i) = msg.find(|c: char| c.is_ascii_alphanumeric())\n+        {\n+            msg[i..i + 1].make_ascii_uppercase();\n         }\n         msg\n     }"}, {"sha": "8bb8f122e2268b373de9b7a5c0f1d6d1ca355a72", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd", "patch": "@@ -390,18 +390,17 @@ pub(crate) fn build_impl(\n \n     // Only inline impl if the implemented trait is\n     // reachable in rustdoc generated documentation\n-    if !did.is_local() {\n-        if let Some(traitref) = associated_trait {\n-            let did = traitref.def_id;\n-            if !cx.cache.effective_visibilities.is_directly_public(tcx, did) {\n-                return;\n-            }\n+    if !did.is_local() && let Some(traitref) = associated_trait {\n+        let did = traitref.def_id;\n+        if !cx.cache.effective_visibilities.is_directly_public(tcx, did) {\n+            return;\n+        }\n \n-            if let Some(stab) = tcx.lookup_stability(did) {\n-                if stab.is_unstable() && stab.feature == sym::rustc_private {\n-                    return;\n-                }\n-            }\n+        if let Some(stab) = tcx.lookup_stability(did) &&\n+            stab.is_unstable() &&\n+            stab.feature == sym::rustc_private\n+        {\n+            return;\n         }\n     }\n \n@@ -525,10 +524,8 @@ pub(crate) fn build_impl(\n     }\n \n     while let Some(ty) = stack.pop() {\n-        if let Some(did) = ty.def_id(&cx.cache) {\n-            if tcx.is_doc_hidden(did) {\n-                return;\n-            }\n+        if let Some(did) = ty.def_id(&cx.cache) && tcx.is_doc_hidden(did) {\n+            return;\n         }\n         if let Some(generics) = ty.generics() {\n             stack.extend(generics);"}, {"sha": "65736bb16fc05e1d18ab2b6571238ced860459a7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 57, "deletions": 62, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd", "patch": "@@ -787,43 +787,43 @@ fn clean_ty_generics<'tcx>(\n                 None\n             })();\n \n-            if let Some(param_idx) = param_idx {\n-                if let Some(b) = impl_trait.get_mut(&param_idx.into()) {\n-                    let p: WherePredicate = clean_predicate(*p, cx)?;\n+            if let Some(param_idx) = param_idx\n+                && let Some(b) = impl_trait.get_mut(&param_idx.into())\n+            {\n+                let p: WherePredicate = clean_predicate(*p, cx)?;\n+\n+                b.extend(\n+                    p.get_bounds()\n+                        .into_iter()\n+                        .flatten()\n+                        .cloned()\n+                        .filter(|b| !b.is_sized_bound(cx)),\n+                );\n \n-                    b.extend(\n-                        p.get_bounds()\n+                let proj = projection.map(|p| {\n+                    (\n+                        clean_projection(p.map_bound(|p| p.projection_ty), cx, None),\n+                        p.map_bound(|p| p.term),\n+                    )\n+                });\n+                if let Some(((_, trait_did, name), rhs)) = proj\n+                    .as_ref()\n+                    .and_then(|(lhs, rhs): &(Type, _)| Some((lhs.projection()?, rhs)))\n+                {\n+                    // FIXME(...): Remove this unwrap()\n+                    impl_trait_proj.entry(param_idx).or_default().push((\n+                        trait_did,\n+                        name,\n+                        rhs.map_bound(|rhs| rhs.ty().unwrap()),\n+                        p.get_bound_params()\n                             .into_iter()\n                             .flatten()\n-                            .cloned()\n-                            .filter(|b| !b.is_sized_bound(cx)),\n-                    );\n-\n-                    let proj = projection.map(|p| {\n-                        (\n-                            clean_projection(p.map_bound(|p| p.projection_ty), cx, None),\n-                            p.map_bound(|p| p.term),\n-                        )\n-                    });\n-                    if let Some(((_, trait_did, name), rhs)) = proj\n-                        .as_ref()\n-                        .and_then(|(lhs, rhs): &(Type, _)| Some((lhs.projection()?, rhs)))\n-                    {\n-                        // FIXME(...): Remove this unwrap()\n-                        impl_trait_proj.entry(param_idx).or_default().push((\n-                            trait_did,\n-                            name,\n-                            rhs.map_bound(|rhs| rhs.ty().unwrap()),\n-                            p.get_bound_params()\n-                                .into_iter()\n-                                .flatten()\n-                                .map(|param| GenericParamDef::lifetime(param.0))\n-                                .collect(),\n-                        ));\n-                    }\n-\n-                    return None;\n+                            .map(|param| GenericParamDef::lifetime(param.0))\n+                            .collect(),\n+                    ));\n                 }\n+\n+                return None;\n             }\n \n             Some(p)\n@@ -886,7 +886,7 @@ fn clean_ty_generics<'tcx>(\n     // `?Sized` bound for each one we didn't find to be `Sized`.\n     for tp in &stripped_params {\n         if let types::GenericParamDefKind::Type { .. } = tp.kind\n-        && !sized_params.contains(&tp.name)\n+            && !sized_params.contains(&tp.name)\n         {\n             where_predicates.push(WherePredicate::BoundPredicate {\n                 ty: Type::Generic(tp.name),\n@@ -1461,10 +1461,10 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n             // Try to normalize `<X as Y>::T` to a type\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             // `hir_to_ty` can return projection types with escaping vars for GATs, e.g. `<() as Trait>::Gat<'_>`\n-            if !ty.has_escaping_bound_vars() {\n-                if let Some(normalized_value) = normalize(cx, ty::Binder::dummy(ty)) {\n-                    return clean_middle_ty(normalized_value, cx, None);\n-                }\n+            if !ty.has_escaping_bound_vars()\n+                && let Some(normalized_value) = normalize(cx, ty::Binder::dummy(ty))\n+            {\n+                return clean_middle_ty(normalized_value, cx, None);\n             }\n \n             let trait_segments = &p.segments[..p.segments.len() - 1];\n@@ -1878,11 +1878,9 @@ fn clean_middle_opaque_bounds<'tcx>(\n                 _ => return None,\n             };\n \n-            if let Some(sized) = cx.tcx.lang_items().sized_trait() {\n-                if trait_ref.def_id() == sized {\n-                    has_sized = true;\n-                    return None;\n-                }\n+            if let Some(sized) = cx.tcx.lang_items().sized_trait() && trait_ref.def_id() == sized {\n+                has_sized = true;\n+                return None;\n             }\n \n             let bindings: ThinVec<_> = bounds\n@@ -2392,17 +2390,15 @@ fn clean_use_statement_inner<'tcx>(\n     let is_visible_from_parent_mod =\n         visibility.is_accessible_from(parent_mod, cx.tcx) && !current_mod.is_top_level_module();\n \n-    if pub_underscore {\n-        if let Some(ref inline) = inline_attr {\n-            rustc_errors::struct_span_err!(\n-                cx.tcx.sess,\n-                inline.span(),\n-                E0780,\n-                \"anonymous imports cannot be inlined\"\n-            )\n-            .span_label(import.span, \"anonymous import\")\n-            .emit();\n-        }\n+    if pub_underscore && let Some(ref inline) = inline_attr {\n+        rustc_errors::struct_span_err!(\n+            cx.tcx.sess,\n+            inline.span(),\n+            E0780,\n+            \"anonymous imports cannot be inlined\"\n+        )\n+        .span_label(import.span, \"anonymous import\")\n+        .emit();\n     }\n \n     // We consider inlining the documentation of `pub use` statements, but we\n@@ -2438,14 +2434,13 @@ fn clean_use_statement_inner<'tcx>(\n         }\n         Import::new_glob(resolve_use_source(cx, path), true)\n     } else {\n-        if inline_attr.is_none() {\n-            if let Res::Def(DefKind::Mod, did) = path.res {\n-                if !did.is_local() && did.is_crate_root() {\n-                    // if we're `pub use`ing an extern crate root, don't inline it unless we\n-                    // were specifically asked for it\n-                    denied = true;\n-                }\n-            }\n+        if inline_attr.is_none()\n+            && let Res::Def(DefKind::Mod, did) = path.res\n+            && !did.is_local() && did.is_crate_root()\n+        {\n+            // if we're `pub use`ing an extern crate root, don't inline it unless we\n+            // were specifically asked for it\n+            denied = true;\n         }\n         if !denied {\n             let mut visited = DefIdSet::default();"}, {"sha": "b3b917ad7311b1e4e3e6558a58cdee8c0b4d6992", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd", "patch": "@@ -182,10 +182,8 @@ impl ExternalCrate {\n             return Local;\n         }\n \n-        if extern_url_takes_precedence {\n-            if let Some(url) = extern_url {\n-                return to_remote(url);\n-            }\n+        if extern_url_takes_precedence && let Some(url) = extern_url {\n+            return to_remote(url);\n         }\n \n         // Failing that, see if there's an attribute specifying where to find this\n@@ -1172,10 +1170,10 @@ impl GenericBound {\n \n     pub(crate) fn is_sized_bound(&self, cx: &DocContext<'_>) -> bool {\n         use rustc_hir::TraitBoundModifier as TBM;\n-        if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n-            if Some(trait_.def_id()) == cx.tcx.lang_items().sized_trait() {\n-                return true;\n-            }\n+        if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self &&\n+            Some(trait_.def_id()) == cx.tcx.lang_items().sized_trait()\n+        {\n+            return true;\n         }\n         false\n     }"}, {"sha": "4d8ce54dc5c62669e9b6e2d167e56de5b262275a", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd", "patch": "@@ -345,10 +345,10 @@ pub(crate) fn is_literal_expr(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n             return true;\n         }\n \n-        if let hir::ExprKind::Unary(hir::UnOp::Neg, expr) = &expr.kind {\n-            if let hir::ExprKind::Lit(_) = &expr.kind {\n-                return true;\n-            }\n+        if let hir::ExprKind::Unary(hir::UnOp::Neg, expr) = &expr.kind &&\n+            let hir::ExprKind::Lit(_) = &expr.kind\n+        {\n+            return true;\n         }\n     }\n "}, {"sha": "0eba81c7c1ee3e0f7a2d836a41ca1ce7941b236b", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 27, "deletions": 32, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd", "patch": "@@ -229,11 +229,11 @@ fn scrape_test_config(attrs: &[ast::Attribute]) -> GlobalTestOptions {\n         if attr.has_name(sym::no_crate_inject) {\n             opts.no_crate_inject = true;\n         }\n-        if attr.has_name(sym::attr) {\n-            if let Some(l) = attr.meta_item_list() {\n-                for item in l {\n-                    opts.attrs.push(pprust::meta_list_item_to_string(item));\n-                }\n+        if attr.has_name(sym::attr)\n+            && let Some(l) = attr.meta_item_list()\n+        {\n+            for item in l {\n+                opts.attrs.push(pprust::meta_list_item_to_string(item));\n             }\n         }\n     }\n@@ -594,31 +594,28 @@ pub(crate) fn make_test(\n             loop {\n                 match parser.parse_item(ForceCollect::No) {\n                     Ok(Some(item)) => {\n-                        if !found_main {\n-                            if let ast::ItemKind::Fn(..) = item.kind {\n-                                if item.ident.name == sym::main {\n-                                    found_main = true;\n-                                }\n-                            }\n+                        if !found_main &&\n+                            let ast::ItemKind::Fn(..) = item.kind &&\n+                            item.ident.name == sym::main\n+                        {\n+                            found_main = true;\n                         }\n \n-                        if !found_extern_crate {\n-                            if let ast::ItemKind::ExternCrate(original) = item.kind {\n-                                // This code will never be reached if `crate_name` is none because\n-                                // `found_extern_crate` is initialized to `true` if it is none.\n-                                let crate_name = crate_name.unwrap();\n+                        if !found_extern_crate &&\n+                            let ast::ItemKind::ExternCrate(original) = item.kind\n+                        {\n+                            // This code will never be reached if `crate_name` is none because\n+                            // `found_extern_crate` is initialized to `true` if it is none.\n+                            let crate_name = crate_name.unwrap();\n \n-                                match original {\n-                                    Some(name) => found_extern_crate = name.as_str() == crate_name,\n-                                    None => found_extern_crate = item.ident.as_str() == crate_name,\n-                                }\n+                            match original {\n+                                Some(name) => found_extern_crate = name.as_str() == crate_name,\n+                                None => found_extern_crate = item.ident.as_str() == crate_name,\n                             }\n                         }\n \n-                        if !found_macro {\n-                            if let ast::ItemKind::MacCall(..) = item.kind {\n-                                found_macro = true;\n-                            }\n+                        if !found_macro && let ast::ItemKind::MacCall(..) = item.kind {\n+                            found_macro = true;\n                         }\n \n                         if found_main && found_extern_crate {\n@@ -972,14 +969,12 @@ impl Collector {\n     fn get_filename(&self) -> FileName {\n         if let Some(ref source_map) = self.source_map {\n             let filename = source_map.span_to_filename(self.position);\n-            if let FileName::Real(ref filename) = filename {\n-                if let Ok(cur_dir) = env::current_dir() {\n-                    if let Some(local_path) = filename.local_path() {\n-                        if let Ok(path) = local_path.strip_prefix(&cur_dir) {\n-                            return path.to_owned().into();\n-                        }\n-                    }\n-                }\n+            if let FileName::Real(ref filename) = filename &&\n+                let Ok(cur_dir) = env::current_dir() &&\n+                let Some(local_path) = filename.local_path() &&\n+                let Ok(path) = local_path.strip_prefix(&cur_dir)\n+            {\n+                return path.to_owned().into();\n             }\n             filename\n         } else if let Some(ref filename) = self.filename {"}, {"sha": "b1db16cfe3cacd6081854c4143289d41151f04c5", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd", "patch": "@@ -229,16 +229,15 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         }\n \n         // Collect all the implementors of traits.\n-        if let clean::ImplItem(ref i) = *item.kind {\n-            if let Some(trait_) = &i.trait_ {\n-                if !i.kind.is_blanket() {\n-                    self.cache\n-                        .implementors\n-                        .entry(trait_.def_id())\n-                        .or_default()\n-                        .push(Impl { impl_item: item.clone() });\n-                }\n-            }\n+        if let clean::ImplItem(ref i) = *item.kind &&\n+            let Some(trait_) = &i.trait_ &&\n+            !i.kind.is_blanket()\n+        {\n+            self.cache\n+                .implementors\n+                .entry(trait_.def_id())\n+                .or_default()\n+                .push(Impl { impl_item: item.clone() });\n         }\n \n         // Index this method for searching later on."}, {"sha": "fd0fcdbd4ab48036355f81b5965a25738c8d3a44", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd", "patch": "@@ -709,11 +709,9 @@ pub(crate) fn href_with_root_path(\n             }\n         }\n     };\n-    if !is_remote {\n-        if let Some(root_path) = root_path {\n-            let root = root_path.trim_end_matches('/');\n-            url_parts.push_front(root);\n-        }\n+    if !is_remote && let Some(root_path) = root_path {\n+        let root = root_path.trim_end_matches('/');\n+        url_parts.push_front(root);\n     }\n     debug!(?url_parts);\n     match shortty {"}, {"sha": "2c9fc4e3ca37824f4455dc47f397bc1e8f79525c", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd", "patch": "@@ -466,10 +466,8 @@ impl<'a> PeekIter<'a> {\n     }\n     /// Returns the next item after the current one. It doesn't interfere with `peek_next` output.\n     fn peek(&mut self) -> Option<&(TokenKind, &'a str)> {\n-        if self.stored.is_empty() {\n-            if let Some(next) = self.iter.next() {\n-                self.stored.push_back(next);\n-            }\n+        if self.stored.is_empty() && let Some(next) = self.iter.next() {\n+            self.stored.push_back(next);\n         }\n         self.stored.front()\n     }"}, {"sha": "5e4a595627b4a367385ca479c30f8257cdf3579e", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd", "patch": "@@ -705,14 +705,12 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             shared.fs.write(scrape_examples_help_file, v)?;\n         }\n \n-        if let Some(ref redirections) = shared.redirections {\n-            if !redirections.borrow().is_empty() {\n-                let redirect_map_path =\n-                    self.dst.join(crate_name.as_str()).join(\"redirect-map.json\");\n-                let paths = serde_json::to_string(&*redirections.borrow()).unwrap();\n-                shared.ensure_dir(&self.dst.join(crate_name.as_str()))?;\n-                shared.fs.write(redirect_map_path, paths)?;\n-            }\n+        if let Some(ref redirections) = shared.redirections && !redirections.borrow().is_empty() {\n+            let redirect_map_path =\n+                self.dst.join(crate_name.as_str()).join(\"redirect-map.json\");\n+            let paths = serde_json::to_string(&*redirections.borrow()).unwrap();\n+            shared.ensure_dir(&self.dst.join(crate_name.as_str()))?;\n+            shared.fs.write(redirect_map_path, paths)?;\n         }\n \n         // No need for it anymore."}, {"sha": "e6a040d02e565b464792ba16784b377367ae42ea", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd", "patch": "@@ -2225,14 +2225,13 @@ fn sidebar_deref_methods(\n         })\n     {\n         debug!(\"found target, real_target: {:?} {:?}\", target, real_target);\n-        if let Some(did) = target.def_id(c) {\n-            if let Some(type_did) = impl_.inner_impl().for_.def_id(c) {\n-                // `impl Deref<Target = S> for S`\n-                if did == type_did || !derefs.insert(did) {\n-                    // Avoid infinite cycles\n-                    return;\n-                }\n-            }\n+        if let Some(did) = target.def_id(c) &&\n+            let Some(type_did) = impl_.inner_impl().for_.def_id(c) &&\n+            // `impl Deref<Target = S> for S`\n+            (did == type_did || !derefs.insert(did))\n+        {\n+            // Avoid infinite cycles\n+            return;\n         }\n         let deref_mut = v.iter().any(|i| i.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n         let inner_impl = target\n@@ -2266,25 +2265,24 @@ fn sidebar_deref_methods(\n         }\n \n         // Recurse into any further impls that might exist for `target`\n-        if let Some(target_did) = target.def_id(c) {\n-            if let Some(target_impls) = c.impls.get(&target_did) {\n-                if let Some(target_deref_impl) = target_impls.iter().find(|i| {\n-                    i.inner_impl()\n-                        .trait_\n-                        .as_ref()\n-                        .map(|t| Some(t.def_id()) == cx.tcx().lang_items().deref_trait())\n-                        .unwrap_or(false)\n-                }) {\n-                    sidebar_deref_methods(\n-                        cx,\n-                        out,\n-                        target_deref_impl,\n-                        target_impls,\n-                        derefs,\n-                        used_links,\n-                    );\n-                }\n-            }\n+        if let Some(target_did) = target.def_id(c) &&\n+            let Some(target_impls) = c.impls.get(&target_did) &&\n+            let Some(target_deref_impl) = target_impls.iter().find(|i| {\n+                i.inner_impl()\n+                    .trait_\n+                    .as_ref()\n+                    .map(|t| Some(t.def_id()) == cx.tcx().lang_items().deref_trait())\n+                    .unwrap_or(false)\n+            })\n+        {\n+            sidebar_deref_methods(\n+                cx,\n+                out,\n+                target_deref_impl,\n+                target_impls,\n+                derefs,\n+                used_links,\n+            );\n         }\n     }\n }"}, {"sha": "e3788fe57d013d8eb06fc50a963272055266da59", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd", "patch": "@@ -80,12 +80,11 @@ impl<'tcx> JsonRenderer<'tcx> {\n                         // document primitive items in an arbitrary crate by using\n                         // `doc(primitive)`.\n                         let mut is_primitive_impl = false;\n-                        if let clean::types::ItemKind::ImplItem(ref impl_) = *item.kind {\n-                            if impl_.trait_.is_none() {\n-                                if let clean::types::Type::Primitive(_) = impl_.for_ {\n-                                    is_primitive_impl = true;\n-                                }\n-                            }\n+                        if let clean::types::ItemKind::ImplItem(ref impl_) = *item.kind &&\n+                            impl_.trait_.is_none() &&\n+                            let clean::types::Type::Primitive(_) = impl_.for_\n+                        {\n+                            is_primitive_impl = true;\n                         }\n \n                         if item.item_id.is_local() || is_primitive_impl {"}, {"sha": "a39d57d42b72e1910b9ea2c61e31b51039cca559", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd", "patch": "@@ -82,18 +82,17 @@ pub(crate) fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -\n     let def_id = item.item_id.expect_def_id().expect_local();\n \n     // check if parent is trait impl\n-    if let Some(parent_def_id) = cx.tcx.opt_local_parent(def_id) {\n-        if let Some(parent_node) = cx.tcx.hir().find_by_def_id(parent_def_id) {\n-            if matches!(\n-                parent_node,\n-                hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }),\n-                    ..\n-                })\n-            ) {\n-                return false;\n-            }\n-        }\n+    if let Some(parent_def_id) = cx.tcx.opt_local_parent(def_id) &&\n+        let Some(parent_node) = cx.tcx.hir().find_by_def_id(parent_def_id) &&\n+        matches!(\n+            parent_node,\n+            hir::Node::Item(hir::Item {\n+                kind: hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }),\n+                ..\n+            })\n+        )\n+    {\n+        return false;\n     }\n \n     if cx.tcx.is_doc_hidden(def_id.to_def_id())"}, {"sha": "189b37b69d132db3785e4cfcd1dbb6ea7c9ec0cf", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd", "patch": "@@ -156,39 +156,38 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n \n     // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n     for it in new_items_external.iter().chain(new_items_local.iter()) {\n-        if let ImplItem(box Impl { ref for_, ref trait_, ref items, .. }) = *it.kind {\n-            if trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait()\n-                && cleaner.keep_impl(for_, true)\n-            {\n-                let target = items\n-                    .iter()\n-                    .find_map(|item| match *item.kind {\n-                        AssocTypeItem(ref t, _) => Some(&t.type_),\n-                        _ => None,\n-                    })\n-                    .expect(\"Deref impl without Target type\");\n+        if let ImplItem(box Impl { ref for_, ref trait_, ref items, .. }) = *it.kind &&\n+            trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait() &&\n+            cleaner.keep_impl(for_, true)\n+        {\n+            let target = items\n+                .iter()\n+                .find_map(|item| match *item.kind {\n+                    AssocTypeItem(ref t, _) => Some(&t.type_),\n+                    _ => None,\n+                })\n+                .expect(\"Deref impl without Target type\");\n \n-                if let Some(prim) = target.primitive_type() {\n-                    cleaner.prims.insert(prim);\n-                } else if let Some(did) = target.def_id(&cx.cache) {\n-                    cleaner.items.insert(did.into());\n-                }\n-                if let Some(for_did) = for_.def_id(&cx.cache) {\n-                    if type_did_to_deref_target.insert(for_did, target).is_none() {\n-                        // Since only the `DefId` portion of the `Type` instances is known to be same for both the\n-                        // `Deref` target type and the impl for type positions, this map of types is keyed by\n-                        // `DefId` and for convenience uses a special cleaner that accepts `DefId`s directly.\n-                        if cleaner.keep_impl_with_def_id(for_did.into()) {\n-                            let mut targets = DefIdSet::default();\n-                            targets.insert(for_did);\n-                            add_deref_target(\n-                                cx,\n-                                &type_did_to_deref_target,\n-                                &mut cleaner,\n-                                &mut targets,\n-                                for_did,\n-                            );\n-                        }\n+            if let Some(prim) = target.primitive_type() {\n+                cleaner.prims.insert(prim);\n+            } else if let Some(did) = target.def_id(&cx.cache) {\n+                cleaner.items.insert(did.into());\n+            }\n+            if let Some(for_did) = for_.def_id(&cx.cache) {\n+                if type_did_to_deref_target.insert(for_did, target).is_none() {\n+                    // Since only the `DefId` portion of the `Type` instances is known to be same for both the\n+                    // `Deref` target type and the impl for type positions, this map of types is keyed by\n+                    // `DefId` and for convenience uses a special cleaner that accepts `DefId`s directly.\n+                    if cleaner.keep_impl_with_def_id(for_did.into()) {\n+                        let mut targets = DefIdSet::default();\n+                        targets.insert(for_did);\n+                        add_deref_target(\n+                            cx,\n+                            &type_did_to_deref_target,\n+                            &mut cleaner,\n+                            &mut targets,\n+                            for_did,\n+                        );\n                     }\n                 }\n             }"}, {"sha": "eac362b37b20988d60a1fa17c5db65199e834ee9", "filename": "src/librustdoc/passes/lint/html_tags.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fpasses%2Flint%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fpasses%2Flint%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint%2Fhtml_tags.rs?ref=86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd", "patch": "@@ -210,11 +210,9 @@ fn extract_path_backwards(text: &str, end_pos: usize) -> Option<usize> {\n             .take_while(|(_, c)| is_id_start(*c) || is_id_continue(*c))\n             .reduce(|_accum, item| item)\n             .and_then(|(new_pos, c)| is_id_start(c).then_some(new_pos));\n-        if let Some(new_pos) = new_pos {\n-            if current_pos != new_pos {\n-                current_pos = new_pos;\n-                continue;\n-            }\n+        if let Some(new_pos) = new_pos && current_pos != new_pos {\n+            current_pos = new_pos;\n+            continue;\n         }\n         break;\n     }"}, {"sha": "cba55e5fe655c7eb19c2a12266b190ec4f7ec6d0", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=86fd5a1b44afe71888b1d4e62373a6a6a8fc2cbd", "patch": "@@ -201,27 +201,25 @@ impl<'a> DocFolder for ImplStripper<'a, '_> {\n             // Because we don't inline in `maybe_inline_local` if the output format is JSON,\n             // we need to make a special check for JSON output: we want to keep it unless it has\n             // a `#[doc(hidden)]` attribute if the `for_` type is exported.\n-            if let Some(did) = imp.for_.def_id(self.cache) {\n-                if !imp.for_.is_assoc_ty() && !self.should_keep_impl(&i, did) {\n-                    debug!(\"ImplStripper: impl item for stripped type; removing\");\n-                    return None;\n-                }\n+            if let Some(did) = imp.for_.def_id(self.cache) &&\n+                !imp.for_.is_assoc_ty() && !self.should_keep_impl(&i, did)\n+            {\n+                debug!(\"ImplStripper: impl item for stripped type; removing\");\n+                return None;\n             }\n-            if let Some(did) = imp.trait_.as_ref().map(|t| t.def_id()) {\n-                if !self.should_keep_impl(&i, did) {\n-                    debug!(\"ImplStripper: impl item for stripped trait; removing\");\n-                    return None;\n-                }\n+            if let Some(did) = imp.trait_.as_ref().map(|t| t.def_id()) &&\n+                !self.should_keep_impl(&i, did) {\n+                debug!(\"ImplStripper: impl item for stripped trait; removing\");\n+                return None;\n             }\n             if let Some(generics) = imp.trait_.as_ref().and_then(|t| t.generics()) {\n                 for typaram in generics {\n-                    if let Some(did) = typaram.def_id(self.cache) {\n-                        if !self.should_keep_impl(&i, did) {\n-                            debug!(\n-                                \"ImplStripper: stripped item in trait's generics; removing impl\"\n-                            );\n-                            return None;\n-                        }\n+                    if let Some(did) = typaram.def_id(self.cache) && !self.should_keep_impl(&i, did)\n+                    {\n+                        debug!(\n+                            \"ImplStripper: stripped item in trait's generics; removing impl\"\n+                        );\n+                        return None;\n                     }\n                 }\n             }"}]}