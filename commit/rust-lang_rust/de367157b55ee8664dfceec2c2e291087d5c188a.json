{"sha": "de367157b55ee8664dfceec2c2e291087d5c188a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlMzY3MTU3YjU1ZWU4NjY0ZGZjZWVjMmMyZTI5MTA4N2Q1YzE4OGE=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-06-09T01:38:47Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-06-09T03:19:30Z"}, "message": "remove deprecated vec::{is_empty, len} functions", "tree": {"sha": "3d8ba27d2250f4a7a06235b422e674514a69e7b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d8ba27d2250f4a7a06235b422e674514a69e7b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de367157b55ee8664dfceec2c2e291087d5c188a", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de367157b55ee8664dfceec2c2e291087d5c188a", "html_url": "https://github.com/rust-lang/rust/commit/de367157b55ee8664dfceec2c2e291087d5c188a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de367157b55ee8664dfceec2c2e291087d5c188a/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "470bf0dfb362e7494cfddf4e7d443e1264dfdf2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/470bf0dfb362e7494cfddf4e7d443e1264dfdf2f", "html_url": "https://github.com/rust-lang/rust/commit/470bf0dfb362e7494cfddf4e7d443e1264dfdf2f"}], "stats": {"total": 204, "additions": 100, "deletions": 104}, "files": [{"sha": "f487398d19c23121b83175d0da8bde3adc4b1ca2", "filename": "doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -2046,7 +2046,7 @@ trait Seq<T> {\n }\n \n impl<T> Seq<T> for ~[T] {\n-    fn len(&self) -> uint { vec::len(*self) }\n+    fn len(&self) -> uint { self.len() }\n     fn iter(&self, b: &fn(v: &T)) {\n         for vec::each(*self) |elt| { b(elt); }\n     }"}, {"sha": "7a0622d059d0cdd8d01abc569602a2be30036d30", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -97,7 +97,7 @@ pub fn parse_config(args: ~[~str]) -> config {\n         mode: str_mode(getopts::opt_str(matches, \"mode\")),\n         run_ignored: getopts::opt_present(matches, \"ignored\"),\n         filter:\n-             if vec::len(matches.free) > 0u {\n+             if !matches.free.is_empty() {\n                  option::Some(copy matches.free[0])\n              } else { option::None },\n         logfile: getopts::opt_maybe_str(matches, \"logfile\").map(|s| Path(*s)),"}, {"sha": "b4a20886ad8661219c11162ab4c3b223b8b92163", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -297,7 +297,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n fn check_error_patterns(props: &TestProps,\n                         testfile: &Path,\n                         ProcRes: &ProcRes) {\n-    if vec::is_empty(props.error_patterns) {\n+    if props.error_patterns.is_empty() {\n         fatal(~\"no error pattern specified in \" + testfile.to_str());\n     }\n "}, {"sha": "233c80426400901941096c45d6af497c70e826e3", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -179,7 +179,7 @@ pub mod reader {\n     }\n \n     pub fn Doc(data: @~[u8]) -> Doc {\n-        Doc { data: data, start: 0u, end: vec::len::<u8>(*data) }\n+        Doc { data: data, start: 0u, end: data.len() }\n     }\n \n     pub fn doc_at(data: @~[u8], start: uint) -> TaggedDoc {"}, {"sha": "2bc0a8ef6b09ff1277568184292104529f24a702", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -427,7 +427,7 @@ pub fn opt_strs(mm: &Matches, nm: &str) -> ~[~str] {\n /// Returns the string argument supplied to a matching option or none\n pub fn opt_maybe_str(mm: &Matches, nm: &str) -> Option<~str> {\n     let vals = opt_vals(mm, nm);\n-    if vec::len::<Optval>(vals) == 0u { return None::<~str>; }\n+    if vals.is_empty() { return None::<~str>; }\n     return match vals[0] {\n         Val(ref s) => Some(copy *s),\n         _ => None\n@@ -444,7 +444,7 @@ pub fn opt_maybe_str(mm: &Matches, nm: &str) -> Option<~str> {\n  */\n pub fn opt_default(mm: &Matches, nm: &str, def: &str) -> Option<~str> {\n     let vals = opt_vals(mm, nm);\n-    if vec::len::<Optval>(vals) == 0u { return None::<~str>; }\n+    if vals.is_empty() { return None::<~str>; }\n     return match vals[0] { Val(ref s) => Some::<~str>(copy *s),\n                            _      => Some::<~str>(str::to_owned(def)) }\n }"}, {"sha": "3ad2e727a5d17c51ea86ef448260ace945eb820d", "filename": "src/libextra/sha1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibextra%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibextra%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsha1.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -195,7 +195,7 @@ pub fn sha1() -> @Sha1 {\n      * can be assumed that the message digest has been computed.\n      */\n     fn pad_msg(st: &mut Sha1State) {\n-        assert_eq!(vec::len((*st).msg_block), msg_block_len);\n+        assert_eq!((*st).msg_block.len(), msg_block_len);\n \n         /*\n          * Check to see if the current message block is too small to hold\n@@ -368,8 +368,8 @@ mod tests {\n         ];\n         let tests = fips_180_1_tests + wikipedia_tests;\n         fn check_vec_eq(v0: ~[u8], v1: ~[u8]) {\n-            assert_eq!(vec::len::<u8>(v0), vec::len::<u8>(v1));\n-            let len = vec::len::<u8>(v0);\n+            assert_eq!(v0.len(), v1.len());\n+            let len = v0.len();\n             let mut i = 0u;\n             while i < len {\n                 let a = v0[i];"}, {"sha": "0189e0db6d4ef5115c3777170f07465696a23a5f", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -15,7 +15,6 @@ use core::prelude::*;\n use core::cmp::{Eq, Ord};\n use core::uint;\n use core::util::swap;\n-use core::vec::len;\n use core::vec;\n \n type Le<'self, T> = &'self fn(v1: &T, v2: &T) -> bool;\n@@ -29,7 +28,7 @@ type Le<'self, T> = &'self fn(v1: &T, v2: &T) -> bool;\n pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n     type Slice = (uint, uint);\n \n-    return merge_sort_(v, (0u, len(v)), le);\n+    return merge_sort_(v, (0u, v.len()), le);\n \n     fn merge_sort_<T:Copy>(v: &[T], slice: Slice, le: Le<T>)\n         -> ~[T] {\n@@ -47,10 +46,10 @@ pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n     }\n \n     fn merge<T:Copy>(le: Le<T>, a: &[T], b: &[T]) -> ~[T] {\n-        let mut rs = vec::with_capacity(len(a) + len(b));\n-        let a_len = len(a);\n+        let mut rs = vec::with_capacity(a.len() + b.len());\n+        let a_len = a.len();\n         let mut a_ix = 0;\n-        let b_len = len(b);\n+        let b_len = b.len();\n         let mut b_ix = 0;\n         while a_ix < a_len && b_ix < b_len {\n             if le(&a[a_ix], &b[b_ix]) {\n@@ -100,8 +99,9 @@ fn qsort<T>(arr: &mut [T], left: uint,\n  * This is an unstable sort.\n  */\n pub fn quick_sort<T>(arr: &mut [T], compare_func: Le<T>) {\n-    if len::<T>(arr) == 0u { return; }\n-    qsort::<T>(arr, 0u, len::<T>(arr) - 1u, compare_func);\n+    let len = arr.len();\n+    if len == 0u { return; }\n+    qsort::<T>(arr, 0u, len - 1u, compare_func);\n }\n \n fn qsort3<T:Copy + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n@@ -138,7 +138,7 @@ fn qsort3<T:Copy + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n         vec::swap(arr, k as uint, j as uint);\n         k += 1;\n         j -= 1;\n-        if k == len::<T>(arr) as int { break; }\n+        if k == arr.len() as int { break; }\n     }\n     k = right - 1;\n     while k > q {\n@@ -754,7 +754,7 @@ mod test_qsort3 {\n     use core::vec;\n \n     fn check_sort(v1: &mut [int], v2: &mut [int]) {\n-        let len = vec::len::<int>(v1);\n+        let len = v1.len();\n         quick_sort3::<int>(v1);\n         let mut i = 0;\n         while i < len {\n@@ -799,7 +799,7 @@ mod test_qsort {\n     use core::vec;\n \n     fn check_sort(v1: &mut [int], v2: &mut [int]) {\n-        let len = vec::len::<int>(v1);\n+        let len = v1.len();\n         fn leual(a: &int, b: &int) -> bool { *a <= *b }\n         quick_sort::<int>(v1, leual);\n         let mut i = 0u;\n@@ -864,7 +864,7 @@ mod tests {\n     use core::vec;\n \n     fn check_sort(v1: &[int], v2: &[int]) {\n-        let len = vec::len::<int>(v1);\n+        let len = v1.len();\n         pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let f = le;\n         let v3 = merge_sort::<int>(v1, f);\n@@ -951,7 +951,7 @@ mod test_tim_sort {\n     }\n \n     fn check_sort(v1: &mut [int], v2: &mut [int]) {\n-        let len = vec::len::<int>(v1);\n+        let len = v1.len();\n         tim_sort::<int>(v1);\n         let mut i = 0u;\n         while i < len {"}, {"sha": "17f1cd499b08a5b88d8dedc31e2b77850300effd", "filename": "src/libextra/uv_ll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibextra%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibextra%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv_ll.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -988,7 +988,7 @@ pub unsafe fn accept(server: *libc::c_void, client: *libc::c_void)\n pub unsafe fn write<T>(req: *uv_write_t, stream: *T,\n          buf_in: *~[uv_buf_t], cb: *u8) -> libc::c_int {\n     let buf_ptr = vec::raw::to_ptr(*buf_in);\n-    let buf_cnt = vec::len(*buf_in) as i32;\n+    let buf_cnt = (*buf_in).len() as i32;\n     return rust_uv_write(req as *libc::c_void,\n                               stream as *libc::c_void,\n                               buf_ptr, buf_cnt, cb);"}, {"sha": "4e285e686df52c2db2a8ff6a97f87484ae74eca2", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -624,7 +624,7 @@ pub fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n }\n \n pub fn check_convergence(files: &[Path]) {\n-    error!(\"pp convergence tests: %u files\", vec::len(files));\n+    error!(\"pp convergence tests: %u files\", files.len());\n     for files.each |file| {\n         if !file_might_not_converge(file) {\n             let s = @result::get(&io::read_whole_file_str(file));\n@@ -689,7 +689,7 @@ pub fn check_variants(files: &[Path], cx: Context) {\n \n pub fn main() {\n     let args = os::args();\n-    if vec::len(args) != 2u {\n+    if args.len() != 2u {\n         error!(\"usage: %s <testdir>\", args[0]);\n         return;\n     }"}, {"sha": "c05e2a85bc708fca8d1946aaf1e02a342c1dc850", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -203,8 +203,7 @@ fn is_test_fn(cx: @mut TestCtxt, i: @ast::item) -> bool {\n }\n \n fn is_bench_fn(i: @ast::item) -> bool {\n-    let has_bench_attr =\n-        vec::len(attr::find_attrs_by_name(i.attrs, \"bench\")) > 0u;\n+    let has_bench_attr = !attr::find_attrs_by_name(i.attrs, \"bench\").is_empty();\n \n     fn has_test_signature(i: @ast::item) -> bool {\n         match i.node {\n@@ -242,7 +241,7 @@ fn is_ignored(cx: @mut TestCtxt, i: @ast::item) -> bool {\n }\n \n fn should_fail(i: @ast::item) -> bool {\n-    vec::len(attr::find_attrs_by_name(i.attrs, \"should_fail\")) > 0u\n+    !attr::find_attrs_by_name(i.attrs, \"should_fail\").is_empty()\n }\n \n fn add_test_module(cx: &TestCtxt, m: &ast::_mod) -> ast::_mod {"}, {"sha": "2017c29590cbe505f62804492c49c29ba6470707", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -212,7 +212,7 @@ fn get_metadata_section(os: os,\n                 let mut found = None;\n                 unsafe {\n                     let cvbuf: *u8 = cast::transmute(cbuf);\n-                    let vlen = vec::len(encoder::metadata_encoding_version);\n+                    let vlen = encoder::metadata_encoding_version.len();\n                     debug!(\"checking %u bytes of metadata-version stamp\",\n                            vlen);\n                     let minsz = uint::min(vlen, csz);"}, {"sha": "c95ff49e53cd50b5073e3bacacb46f8d2f3c3093", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -786,7 +786,7 @@ pub fn check_fn(cx: @MatchCheckCtxt,\n pub fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n     match cx.tcx.def_map.find(&pat.id) {\n       Some(&def_variant(enum_id, _)) => {\n-        if vec::len(*ty::enum_variants(cx.tcx, enum_id)) != 1u {\n+        if ty::enum_variants(cx.tcx, enum_id).len() != 1u {\n             return true;\n         }\n       }"}, {"sha": "abce35bebffb4f6cdb981e52c7460f6a9c94647d", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -119,5 +119,5 @@ pub fn get_freevars(tcx: ty::ctxt, fid: ast::node_id) -> freevar_info {\n }\n \n pub fn has_freevars(tcx: ty::ctxt, fid: ast::node_id) -> bool {\n-    return vec::len(*get_freevars(tcx, fid)) != 0u;\n+    !get_freevars(tcx, fid).is_empty()\n }"}, {"sha": "f1938129b06015b806929666eafd46d1283567d6", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -348,7 +348,7 @@ fn is_nullary_variant(cx: Context, ex: @expr) -> bool {\n       expr_path(_) => {\n         match cx.tcx.def_map.get_copy(&ex.id) {\n           def_variant(edid, vdid) => {\n-              vec::len(ty::enum_variant_with_id(cx.tcx, edid, vdid).args) == 0u\n+              ty::enum_variant_with_id(cx.tcx, edid, vdid).args.is_empty()\n           }\n           _ => false\n         }"}, {"sha": "3b26a2cbf22462eaf45bd88ae81b25d6c4fc971d", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -53,14 +53,13 @@ pub fn count_insn(cx: block, category: &str) {\n \n         // Pass 1: scan table mapping str -> rightmost pos.\n         let mut mm = HashMap::new();\n-        let len = vec::len(*v);\n+        let len = v.len();\n         let mut i = 0u;\n         while i < len {\n             mm.insert(copy v[i], i);\n             i += 1u;\n         }\n \n-\n         // Pass 2: concat strings for each elt, skipping\n         // forwards over any cycles by advancing to rightmost\n         // occurrence of each element in path."}, {"sha": "ae3adce0c0e0b800809c7fe61fb387ceab20bcfb", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -2373,7 +2373,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             ty_enum(did, ref substs) => {\n                 seen.push(did);\n                 let vs = enum_variants(cx, did);\n-                let r = vec::len(*vs) > 0u && do vs.iter().all |variant| {\n+                let r = !vs.is_empty() && do vs.iter().all |variant| {\n                     do variant.args.iter().any |aty| {\n                         let sty = subst(cx, substs, *aty);\n                         type_requires(cx, seen, r_ty, sty)"}, {"sha": "ab52ef36978a52f848a0fdc4ef08093ade52b6bb", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -113,9 +113,9 @@ impl ResolveState {\n         // n.b. This is a hokey mess because the current fold doesn't\n         // allow us to pass back errors in any useful way.\n \n-        assert!(vec::is_empty(self.v_seen));\n+        assert!(self.v_seen.is_empty());\n         let rty = indent(|| self.resolve_type(typ) );\n-        assert!(vec::is_empty(self.v_seen));\n+        assert!(self.v_seen.is_empty());\n         match self.err {\n           None => {\n             debug!(\"Resolved to %s + %s (modes=%x)\","}, {"sha": "adb0f43e2d72069e3477591221bfef76a50ae0ca", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -279,7 +279,7 @@ pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n         version(*binary);\n         return;\n     }\n-    let input = match vec::len(matches.free) {\n+    let input = match matches.free.len() {\n       0u => early_error(demitter, ~\"no input filename given\"),\n       1u => {\n         let ifile = /*bad*/copy matches.free[0];"}, {"sha": "74a403ff7412db92d68573746bfb885b3193d50a", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -141,7 +141,7 @@ fn should_prune_unconfigured_items() {\n     let source = ~\"#[cfg(shut_up_and_leave_me_alone)]fn a() { }\";\n     do from_str(source) |srv| {\n         do exec(srv) |ctxt| {\n-            assert!(vec::is_empty(ctxt.ast.node.module.items));\n+            assert!(ctxt.ast.node.module.items.is_empty());\n         }\n     }\n }"}, {"sha": "73956df954239058c68be4c5b4be8a2ac10ff607", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -295,8 +295,8 @@ mod test {\n     #[test]\n     fn extract_empty_crate() {\n         let doc = mk_doc(~\"\");\n-        assert!(vec::is_empty(doc.cratemod().mods()));\n-        assert!(vec::is_empty(doc.cratemod().fns()));\n+        assert!(doc.cratemod().mods().is_empty());\n+        assert!(doc.cratemod().fns().is_empty());\n     }\n \n     #[test]"}, {"sha": "7d41b899bc3d5af1ec2aab7ed5e9761579804a77", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -343,7 +343,7 @@ fn item_header_lvl(doc: &doc::ItemTag) -> Hlvl {\n }\n \n fn write_index(ctxt: &Ctxt, index: &doc::Index) {\n-    if vec::is_empty(index.entries) {\n+    if index.entries.is_empty() {\n         return;\n     }\n \n@@ -437,7 +437,7 @@ fn write_variants(\n     ctxt: &Ctxt,\n     docs: &[doc::VariantDoc]\n ) {\n-    if vec::is_empty(docs) {\n+    if docs.is_empty() {\n         return;\n     }\n "}, {"sha": "bb5d71e8db1682ac870086a68127c7fde506e7ba", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -191,6 +191,6 @@ mod test {\n     #[test]\n     fn should_remove_mods_from_containing_mods() {\n         let doc = mk_doc(~\"mod a { }\");\n-        assert!(vec::is_empty(doc.cratemod().mods()));\n+        assert!(doc.cratemod().mods().is_empty());\n     }\n }"}, {"sha": "8a90d3f74d3907c4b1e16b8582dad94de1c0b8c4", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -80,6 +80,6 @@ mod test {\n         use core::vec;\n \n         let doc = mk_doc(~\"#[doc(hidden)] mod a { }\");\n-        assert!(vec::is_empty(doc.cratemod().mods()))\n+        assert!(doc.cratemod().mods().is_empty())\n     }\n }"}, {"sha": "e861939c2dde795483a9130f0ff8eb16b803d9c5", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -175,7 +175,7 @@ mod test {\n     #[test]\n     fn should_prune_items_without_pub_modifier() {\n         let doc = mk_doc(~\"mod a { }\");\n-        assert!(vec::is_empty(doc.cratemod().mods()));\n+        assert!(doc.cratemod().mods().is_empty());\n     }\n \n     #[test]"}, {"sha": "75f8e22f67e13e4ab9e256711c2d5bfa01ebcc0d", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -217,7 +217,7 @@ mod test {\n               Body\\\"]\\\n               mod a {\n }\");\n-        assert!(vec::is_empty(doc.cratemod().mods()[0].item.sections));\n+        assert!(doc.cratemod().mods()[0].item.sections.is_empty());\n     }\n \n     #[test]"}, {"sha": "24751b66925e66416703716455f16c9e79801705", "filename": "src/libstd/result.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -20,6 +20,7 @@ use option::{None, Option, Some};\n use old_iter::BaseIter;\n use vec;\n use vec::OwnedVector;\n+use container::Container;\n \n /// The result type\n #[deriving(Clone, Eq)]\n@@ -301,7 +302,7 @@ impl<T, E: Copy> Result<T, E> {\n pub fn map_vec<T,U:Copy,V:Copy>(\n     ts: &[T], op: &fn(&T) -> Result<V,U>) -> Result<~[V],U> {\n \n-    let mut vs: ~[V] = vec::with_capacity(vec::len(ts));\n+    let mut vs: ~[V] = vec::with_capacity(ts.len());\n     for ts.each |t| {\n         match op(t) {\n           Ok(v) => vs.push(v),\n@@ -339,7 +340,7 @@ pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n                 op: &fn(&S,&T) -> Result<V,U>) -> Result<~[V],U> {\n \n     assert!(vec::same_length(ss, ts));\n-    let n = vec::len(ts);\n+    let n = ts.len();\n     let mut vs = vec::with_capacity(n);\n     let mut i = 0u;\n     while i < n {\n@@ -362,7 +363,7 @@ pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n                          op: &fn(&S,&T) -> Result<(),U>) -> Result<(),U> {\n \n     assert!(vec::same_length(ss, ts));\n-    let n = vec::len(ts);\n+    let n = ts.len();\n     let mut i = 0u;\n     while i < n {\n         match op(&ss[i],&ts[i]) {"}, {"sha": "2af300fc1b881ffa4c4af507b23bc458678fe6f5", "filename": "src/libstd/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -1752,7 +1752,7 @@ Section: Misc\n /// Determines if a vector of bytes contains valid UTF-8\n pub fn is_utf8(v: &const [u8]) -> bool {\n     let mut i = 0u;\n-    let total = vec::len::<u8>(v);\n+    let total = v.len();\n     while i < total {\n         let mut chsize = utf8_char_width(v[i]);\n         if chsize == 0u { return false; }\n@@ -3693,7 +3693,7 @@ mod tests {\n         let s2: ~str = from_bytes(v);\n         let mut i: uint = 0u;\n         let n1: uint = len(s1);\n-        let n2: uint = vec::len::<u8>(v);\n+        let n2: uint = v.len();\n         assert_eq!(n1, n2);\n         while i < n1 {\n             let a: u8 = s1[i];"}, {"sha": "19233c533481e01a9542d55129f8f15eb6751f57", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 33, "deletions": 38, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -56,11 +56,6 @@ pub mod rustrt {\n     }\n }\n \n-/// Returns true if a vector contains no elements\n-pub fn is_empty<T>(v: &const [T]) -> bool {\n-    as_const_buf(v, |_p, len| len == 0u)\n-}\n-\n /// Returns true if two vectors have the same length\n pub fn same_length<T, U>(xs: &const [T], ys: &const [U]) -> bool {\n     xs.len() == ys.len()\n@@ -123,12 +118,6 @@ pub fn capacity<T>(v: &const ~[T]) -> uint {\n     }\n }\n \n-/// Returns the length of a vector\n-#[inline(always)]\n-pub fn len<T>(v: &const [T]) -> uint {\n-    as_const_buf(v, |_p, len| len)\n-}\n-\n // A botch to tide us over until core and std are fully demuted.\n #[allow(missing_doc)]\n pub fn uniq_len<T>(v: &const ~[T]) -> uint {\n@@ -291,7 +280,7 @@ pub fn last_opt<'r,T>(v: &'r [T]) -> Option<&'r T> {\n #[inline(always)]\n pub fn slice<'r,T>(v: &'r [T], start: uint, end: uint) -> &'r [T] {\n     assert!(start <= end);\n-    assert!(end <= len(v));\n+    assert!(end <= v.len());\n     do as_imm_buf(v) |p, _len| {\n         unsafe {\n             transmute((ptr::offset(p, start),\n@@ -319,7 +308,7 @@ pub fn mut_slice<'r,T>(v: &'r mut [T], start: uint, end: uint)\n pub fn const_slice<'r,T>(v: &'r const [T], start: uint, end: uint)\n                       -> &'r const [T] {\n     assert!(start <= end);\n-    assert!(end <= len(v));\n+    assert!(end <= v.len());\n     do as_const_buf(v) |p, _len| {\n         unsafe {\n             transmute((ptr::const_offset(p, start),\n@@ -332,7 +321,7 @@ pub fn const_slice<'r,T>(v: &'r const [T], start: uint, end: uint)\n \n /// Split the vector `v` by applying each element against the predicate `f`.\n pub fn split<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n-    let ln = len(v);\n+    let ln = v.len();\n     if (ln == 0u) { return ~[] }\n \n     let mut start = 0u;\n@@ -355,7 +344,7 @@ pub fn split<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n  * to `n` times.\n  */\n pub fn splitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n-    let ln = len(v);\n+    let ln = v.len();\n     if (ln == 0u) { return ~[] }\n \n     let mut start = 0u;\n@@ -381,7 +370,7 @@ pub fn splitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n  * `f`.\n  */\n pub fn rsplit<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n-    let ln = len(v);\n+    let ln = v.len();\n     if (ln == 0) { return ~[] }\n \n     let mut end = ln;\n@@ -405,7 +394,7 @@ pub fn rsplit<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n  * `f` up to `n times.\n  */\n pub fn rsplitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n-    let ln = len(v);\n+    let ln = v.len();\n     if (ln == 0u) { return ~[] }\n \n     let mut end = ln;\n@@ -861,7 +850,7 @@ pub fn grow_set<T:Copy>(v: &mut ~[T], index: uint, initval: &T, val: T) {\n \n /// Apply a function to each element of a vector and return the results\n pub fn map<T, U>(v: &[T], f: &fn(t: &T) -> U) -> ~[U] {\n-    let mut result = with_capacity(len(v));\n+    let mut result = with_capacity(v.len());\n     for each(v) |elem| {\n         result.push(f(elem));\n     }\n@@ -908,8 +897,8 @@ pub fn flat_map<T, U>(v: &[T], f: &fn(t: &T) -> ~[U]) -> ~[U] {\n  */\n pub fn map_zip<T:Copy,U:Copy,V>(v0: &[T], v1: &[U],\n                                   f: &fn(t: &T, v: &U) -> V) -> ~[V] {\n-    let v0_len = len(v0);\n-    if v0_len != len(v1) { fail!(); }\n+    let v0_len = v0.len();\n+    if v0_len != v1.len() { fail!(); }\n     let mut u: ~[V] = ~[];\n     let mut i = 0u;\n     while i < v0_len {\n@@ -1080,7 +1069,7 @@ pub fn contains<T:Eq>(v: &[T], x: &T) -> bool {\n  * is returned. If `f` matches no elements then none is returned.\n  */\n pub fn find<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n-    find_between(v, 0u, len(v), f)\n+    find_between(v, 0u, v.len(), f)\n }\n \n /**\n@@ -1103,7 +1092,7 @@ pub fn find_between<T:Copy>(v: &[T], start: uint, end: uint,\n  * matches no elements then none is returned.\n  */\n pub fn rfind<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n-    rfind_between(v, 0u, len(v), f)\n+    rfind_between(v, 0u, v.len(), f)\n }\n \n /**\n@@ -1134,7 +1123,7 @@ pub fn position_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n  * then none is returned.\n  */\n pub fn position<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n-    position_between(v, 0u, len(v), f)\n+    position_between(v, 0u, v.len(), f)\n }\n \n /**\n@@ -1150,7 +1139,7 @@ pub fn position_between<T>(v: &[T],\n                            f: &fn(t: &T) -> bool)\n                         -> Option<uint> {\n     assert!(start <= end);\n-    assert!(end <= len(v));\n+    assert!(end <= v.len());\n     let mut i = start;\n     while i < end { if f(&v[i]) { return Some::<uint>(i); } i += 1u; }\n     None\n@@ -1169,7 +1158,7 @@ pub fn rposition_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n  * matches no elements then none is returned.\n  */\n pub fn rposition<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n-    rposition_between(v, 0u, len(v), f)\n+    rposition_between(v, 0u, v.len(), f)\n }\n \n /**\n@@ -1183,7 +1172,7 @@ pub fn rposition<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n pub fn rposition_between<T>(v: &[T], start: uint, end: uint,\n                              f: &fn(t: &T) -> bool) -> Option<uint> {\n     assert!(start <= end);\n-    assert!(end <= len(v));\n+    assert!(end <= v.len());\n     let mut i = end;\n     while i > start {\n         if f(&v[i - 1u]) { return Some::<uint>(i - 1u); }\n@@ -1273,9 +1262,9 @@ pub fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n pub fn zip_slice<T:Copy,U:Copy>(v: &const [T], u: &const [U])\n         -> ~[(T, U)] {\n     let mut zipped = ~[];\n-    let sz = len(v);\n+    let sz = v.len();\n     let mut i = 0u;\n-    assert_eq!(sz, len(u));\n+    assert_eq!(sz, u.len());\n     while i < sz {\n         zipped.push((v[i], u[i]));\n         i += 1u;\n@@ -1290,8 +1279,8 @@ pub fn zip_slice<T:Copy,U:Copy>(v: &const [T], u: &const [U])\n  * i-th elements from each of the input vectors.\n  */\n pub fn zip<T, U>(mut v: ~[T], mut u: ~[U]) -> ~[(T, U)] {\n-    let mut i = len(v);\n-    assert_eq!(i, len(u));\n+    let mut i = v.len();\n+    assert_eq!(i, u.len());\n     let mut w = with_capacity(i);\n     while i > 0 {\n         w.push((v.pop(),u.pop()));\n@@ -1324,7 +1313,7 @@ pub fn swap<T>(v: &mut [T], a: uint, b: uint) {\n /// Reverse the order of elements in a vector, in place\n pub fn reverse<T>(v: &mut [T]) {\n     let mut i: uint = 0;\n-    let ln = len::<T>(v);\n+    let ln = v.len();\n     while i < ln / 2 {\n         swap(v, i, ln - i - 1);\n         i += 1;\n@@ -1372,7 +1361,7 @@ pub fn reverse_part<T>(v: &mut [T], start: uint, end : uint) {\n /// Returns a vector with the order of elements reversed\n pub fn reversed<T:Copy>(v: &const [T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n-    let mut i = len::<T>(v);\n+    let mut i = v.len();\n     if i == 0 { return (rs); } else { i -= 1; }\n     while i != 0 { rs.push(v[i]); i -= 1; }\n     rs.push(v[0]);\n@@ -1479,7 +1468,7 @@ pub fn eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) -> bool {\n  * of elements in `v` (so if `v` is sorted then the permutations are\n  * lexicographically sorted).\n  *\n- * The total number of permutations produced is `len(v)!`.  If `v` contains\n+ * The total number of permutations produced is `v.len()!`.  If `v` contains\n  * repeated elements, then some permutations are repeated.\n  *\n  * See [Algorithms to generate\n@@ -1779,11 +1768,16 @@ pub mod traits {\n impl<'self,T> Container for &'self const [T] {\n     /// Returns true if a vector contains no elements\n     #[inline]\n-    fn is_empty(&const self) -> bool { is_empty(*self) }\n+    fn is_empty(&const self) -> bool {\n+        as_const_buf(*self, |_p, len| len == 0u)\n+    }\n \n     /// Returns the length of a vector\n     #[inline]\n-    fn len(&const self) -> uint { len(*self) }\n+    fn len(&const self) -> uint {\n+        as_const_buf(*self, |_p, len| len)\n+    }\n+\n }\n \n #[allow(missing_doc)]\n@@ -2250,7 +2244,7 @@ pub mod raw {\n     use ptr;\n     use sys;\n     use unstable::intrinsics;\n-    use vec::{UnboxedVecRepr, as_const_buf, as_mut_buf, len, with_capacity};\n+    use vec::{UnboxedVecRepr, as_const_buf, as_mut_buf, with_capacity};\n     use util;\n \n     /// The internal representation of a (boxed) vector\n@@ -2872,8 +2866,9 @@ mod tests {\n \n     #[test]\n     fn test_is_empty() {\n-        assert!(is_empty::<int>([]));\n-        assert!(!is_empty([0]));\n+        let xs: [int, ..0] = [];\n+        assert!(xs.is_empty());\n+        assert!(![0].is_empty());\n     }\n \n     #[test]"}, {"sha": "fecded5e87b21fa2e3b324fe6f3ecbf4ba40819e", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -66,7 +66,7 @@ pub fn path_to_str_with_sep(p: &[path_elt], sep: &str, itr: @ident_interner)\n }\n \n pub fn path_ident_to_str(p: &path, i: ident, itr: @ident_interner) -> ~str {\n-    if vec::is_empty(*p) {\n+    if p.is_empty() {\n         //FIXME /* FIXME (#2543) */ copy *i\n         copy *itr.get(i.name)\n     } else {"}, {"sha": "59db35201f1008a8e138858fc49f2d7f6a39d4d3", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -2768,7 +2768,7 @@ impl Parser {\n             attributes_box.push_all(self.parse_outer_attributes());\n             match *self.token {\n                 token::SEMI => {\n-                    if !vec::is_empty(attributes_box) {\n+                    if !attributes_box.is_empty() {\n                         self.span_err(*self.last_span, \"expected item after attributes\");\n                         attributes_box = ~[];\n                     }\n@@ -2839,7 +2839,7 @@ impl Parser {\n             }\n         }\n \n-        if !vec::is_empty(attributes_box) {\n+        if !attributes_box.is_empty() {\n             self.span_err(*self.last_span, \"expected item after attributes\");\n         }\n "}, {"sha": "5c81d406cd2001fcd70ff4dcb1d419ab5c7aae13", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -2041,7 +2041,7 @@ pub fn lit_to_str(l: @ast::lit) -> ~str {\n pub fn next_lit(s: @ps, pos: BytePos) -> Option<comments::lit> {\n     match s.literals {\n       Some(ref lits) => {\n-        while s.cur_cmnt_and_lit.cur_lit < vec::len((*lits)) {\n+        while s.cur_cmnt_and_lit.cur_lit < lits.len() {\n             let ltrl = /*bad*/ copy (*lits)[s.cur_cmnt_and_lit.cur_lit];\n             if ltrl.pos > pos { return None; }\n             s.cur_cmnt_and_lit.cur_lit += 1u;\n@@ -2128,7 +2128,7 @@ pub fn to_str<T: Copy>(t: T, f: @fn(@ps, T), intr: @ident_interner) -> ~str {\n pub fn next_comment(s: @ps) -> Option<comments::cmnt> {\n     match s.comments {\n       Some(ref cmnts) => {\n-        if s.cur_cmnt_and_lit.cur_cmnt < vec::len((*cmnts)) {\n+        if s.cur_cmnt_and_lit.cur_cmnt < cmnts.len() {\n             return Some(copy cmnts[s.cur_cmnt_and_lit.cur_cmnt]);\n         } else { return None::<comments::cmnt>; }\n       }"}, {"sha": "020b53b9d9ae1ac886a2032ab16b258e835c2f8c", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -40,7 +40,7 @@ fn send(p: &pipe, msg: uint) {\n fn recv(p: &pipe) -> uint {\n     unsafe {\n         do p.access_cond |state, cond| {\n-            while vec::is_empty(*state) {\n+            while state.is_empty() {\n                 cond.wait();\n             }\n             state.pop()"}, {"sha": "f2fe45ac5bdbe608112f09e24f6d1b88b659c26e", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -37,7 +37,7 @@ fn send(p: &pipe, msg: uint) {\n }\n fn recv(p: &pipe) -> uint {\n     do p.write_cond |state, cond| {\n-        while vec::is_empty(*state) {\n+        while state.is_empty() {\n             cond.wait();\n         }\n         state.pop()"}, {"sha": "9f125a48de95648d7d27ca6a9df0f0b89e93d378", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -64,7 +64,7 @@ fn select_random(r: u32, genelist: ~[AminoAcids]) -> char {\n             } else { return bisect(v, mid, hi, target); }\n         } else { return v[hi].ch; }\n     }\n-    return bisect(copy genelist, 0, vec::len::<AminoAcids>(genelist) - 1, r);\n+    return bisect(copy genelist, 0, genelist.len() - 1, r);\n }\n \n fn make_random_fasta(wr: @io::Writer,"}, {"sha": "b423073eca7212826006455bef131814299a05cb", "filename": "src/test/run-pass/import-in-block.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Ftest%2Frun-pass%2Fimport-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Ftest%2Frun-pass%2Fimport-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-in-block.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -9,10 +9,12 @@\n // except according to those terms.\n \n pub fn main() {\n-    use std::vec::from_fn;\n-    debug!(::std::vec::len(from_fn(2, |i| i)));\n+    use std::util::replace;\n+    let mut x = 5;\n+    replace(&mut x, 6);\n     {\n-        use std::vec::*;\n-        debug!(len(~[2]));\n+        use std::util::*;\n+        let mut y = 6;\n+        swap(&mut x, &mut y);\n     }\n }"}, {"sha": "1d9e7d3c649667c4ec6387e2f4cb3780b2c37215", "filename": "src/test/run-pass/mutable-alias-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -20,7 +20,7 @@ pub fn main() {\n     grow(&mut v);\n     grow(&mut v);\n     grow(&mut v);\n-    let len = vec::len::<int>(v);\n+    let len = v.len();\n     debug!(len);\n     assert_eq!(len, 3 as uint);\n }"}, {"sha": "3d3f1404dc2a5029e2a2332b5c666851da1098f9", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -47,7 +47,7 @@ trait vec_utils<T> {\n }\n \n impl<T> vec_utils<T> for ~[T] {\n-    fn length_(&self) -> uint { vec::len(*self) }\n+    fn length_(&self) -> uint { self.len() }\n     fn iter_(&self, f: &fn(&T)) { for self.each |x| { f(x); } }\n     fn map_<U:Copy>(&self, f: &fn(&T) -> U) -> ~[U] {\n         let mut r = ~[];"}, {"sha": "0069165aed4ef8cc3f65bd44c13344ac7cae5bea", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de367157b55ee8664dfceec2c2e291087d5c188a/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=de367157b55ee8664dfceec2c2e291087d5c188a", "patch": "@@ -20,7 +20,7 @@ pub fn main() {\n \n     assert!(str::len(s) == 10u);\n     assert!(str::char_len(s) == 4u);\n-    assert!(vec::len(str::to_chars(s)) == 4u);\n+    assert!(str::to_chars(s).len() == 4u);\n     assert!(str::from_chars(str::to_chars(s)) == s);\n     assert!(str::char_at(s, 0u) == 'e');\n     assert!(str::char_at(s, 1u) == '\u00e9');"}]}