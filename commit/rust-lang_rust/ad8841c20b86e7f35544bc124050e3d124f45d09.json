{"sha": "ad8841c20b86e7f35544bc124050e3d124f45d09", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkODg0MWMyMGI4NmU3ZjM1NTQ0YmMxMjQwNTBlM2QxMjRmNDVkMDk=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-06-07T10:11:14Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-06-07T10:11:14Z"}, "message": "Merge pull request #92 from Manishearth/inline_always\n\nRemove false positives on inline_always. this closes issue #84 and adds a few utils", "tree": {"sha": "a0f28df2c786ace5064b16308c5899d1333d6e0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0f28df2c786ace5064b16308c5899d1333d6e0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad8841c20b86e7f35544bc124050e3d124f45d09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad8841c20b86e7f35544bc124050e3d124f45d09", "html_url": "https://github.com/rust-lang/rust/commit/ad8841c20b86e7f35544bc124050e3d124f45d09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad8841c20b86e7f35544bc124050e3d124f45d09/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e81a7ee3caeac59032226451543128c177d5b397", "url": "https://api.github.com/repos/rust-lang/rust/commits/e81a7ee3caeac59032226451543128c177d5b397", "html_url": "https://github.com/rust-lang/rust/commit/e81a7ee3caeac59032226451543128c177d5b397"}, {"sha": "19e718966d0d3660df374f60022f219f5bf48469", "url": "https://api.github.com/repos/rust-lang/rust/commits/19e718966d0d3660df374f60022f219f5bf48469", "html_url": "https://github.com/rust-lang/rust/commit/19e718966d0d3660df374f60022f219f5bf48469"}], "stats": {"total": 128, "additions": 117, "deletions": 11}, "files": [{"sha": "d5a56b1547f32b067a07edb3e63e88d53dd02515", "filename": "src/attrs.rs", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/ad8841c20b86e7f35544bc124050e3d124f45d09/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8841c20b86e7f35544bc124050e3d124f45d09/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=ad8841c20b86e7f35544bc124050e3d124f45d09", "patch": "@@ -6,7 +6,7 @@ use syntax::ast::*;\n use syntax::ptr::P;\n use syntax::codemap::{Span, ExpnInfo};\n use syntax::parse::token::InternedString;\n-use utils::in_macro;\n+use utils::{in_macro, match_path};\n \n declare_lint! { pub INLINE_ALWAYS, Warn,\n     \"#[inline(always)] is usually a bad idea.\"}\n@@ -21,18 +21,73 @@ impl LintPass for AttrPass {\n     }\n     \n     fn check_item(&mut self, cx: &Context, item: &Item) {\n-\t\tcx.sess().codemap().with_expn_info(item.span.expn_id, \n-\t\t\t|info| check_attrs(cx, info, &item.ident, &item.attrs))\n+\t\tif is_relevant_item(item) {\n+\t\t\tcx.sess().codemap().with_expn_info(item.span.expn_id, \n+\t\t\t\t|info| check_attrs(cx, info, &item.ident, &item.attrs))\n+\t\t}\n \t}\n     \n-    fn check_impl_item(&mut self, cx: &Context, item: &ImplItem) { \n-\t\tcx.sess().codemap().with_expn_info(item.span.expn_id, \n-\t\t\t|info| check_attrs(cx, info, &item.ident, &item.attrs))\n+    fn check_impl_item(&mut self, cx: &Context, item: &ImplItem) {\n+\t\tif is_relevant_impl(item) {\n+\t\t\tcx.sess().codemap().with_expn_info(item.span.expn_id, \n+\t\t\t\t|info| check_attrs(cx, info, &item.ident, &item.attrs))\n+\t\t}\n \t}\n         \n \tfn check_trait_item(&mut self, cx: &Context, item: &TraitItem) {\n-\t\tcx.sess().codemap().with_expn_info(item.span.expn_id, \n-\t\t\t|info| check_attrs(cx, info, &item.ident, &item.attrs))\n+\t\tif is_relevant_trait(item) {\n+\t\t\tcx.sess().codemap().with_expn_info(item.span.expn_id, \n+\t\t\t\t|info| check_attrs(cx, info, &item.ident, &item.attrs))\n+\t\t}\n+\t}\n+}\n+\n+fn is_relevant_item(item: &Item) -> bool {\n+\tif let &ItemFn(_, _, _, _, _, ref block) = &item.node {\n+\t\tis_relevant_block(block)\n+\t} else { false }\n+}\n+\n+fn is_relevant_impl(item: &ImplItem) -> bool {\n+\tmatch item.node {\n+\t\tMethodImplItem(_, ref block) => is_relevant_block(block),\n+\t\t_ => false\n+\t}\n+}\n+\n+fn is_relevant_trait(item: &TraitItem) -> bool {\n+\tmatch item.node {\n+\t\tMethodTraitItem(_, None) => true,\n+\t\tMethodTraitItem(_, Some(ref block)) => is_relevant_block(block),\n+\t\t_ => false\n+\t}\n+}\n+\n+fn is_relevant_block(block: &Block) -> bool {\n+\tfor stmt in block.stmts.iter() { \n+\t\tmatch stmt.node {\n+\t\t\tStmtDecl(_, _) => return true,\n+\t\t\tStmtExpr(ref expr, _) | StmtSemi(ref expr, _) => {\n+\t\t\t\treturn is_relevant_expr(expr);\n+\t\t\t}\n+\t\t\t_ => ()\n+\t\t}\n+\t}\n+\tblock.expr.as_ref().map_or(false, |e| is_relevant_expr(&*e))\n+}\n+\n+fn is_relevant_expr(expr: &Expr) -> bool {\n+\tmatch expr.node {\n+\t\tExprBlock(ref block) => is_relevant_block(block),\n+\t\tExprRet(Some(ref e)) | ExprParen(ref e) => \n+\t\t\tis_relevant_expr(&*e),\n+\t\tExprRet(None) | ExprBreak(_) | ExprMac(_) => false,\n+\t\tExprCall(ref path_expr, _) => {\n+\t\t\tif let ExprPath(_, ref path) = path_expr.node {\n+\t\t\t\t!match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])\n+\t\t\t} else { true }\n+\t\t}\n+\t\t_ => true\n \t}\n }\n "}, {"sha": "b99ed45b3c38c0ea3d9c4f4c85df5e2cc034bf47", "filename": "src/utils.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ad8841c20b86e7f35544bc124050e3d124f45d09/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8841c20b86e7f35544bc124050e3d124f45d09/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=ad8841c20b86e7f35544bc124050e3d124f45d09", "patch": "@@ -1,12 +1,42 @@\n use rustc::lint::Context;\n-use syntax::codemap::ExpnInfo;\n+use syntax::ast::{DefId, Name, Path};\n+use syntax::codemap::{ExpnInfo, Span};\n+use rustc::middle::ty;\n \n+/// returns true if the macro that expanded the crate was outside of\n+/// the current crate or was a compiler plugin\n pub fn in_macro(cx: &Context, opt_info: Option<&ExpnInfo>) -> bool {\n+\t// no ExpnInfo = no macro\n \topt_info.map_or(false, |info| {\n+\t\t// no span for the callee = external macro\n \t\tinfo.callee.span.map_or(true, |span| {\n+\t\t\t// no snippet = external macro or compiler-builtin expansion\n \t\t\tcx.sess().codemap().span_to_snippet(span).ok().map_or(true, |code| \n+\t\t\t\t// macro doesn't start with \"macro_rules\"\n+\t\t\t\t// = compiler plugin\n \t\t\t\t!code.starts_with(\"macro_rules\")\n \t\t\t)\n \t\t})\n \t})\n }\n+\n+/// invokes in_macro with the expansion info of the given span\n+pub fn in_external_macro(cx: &Context, span: Span) -> bool {\n+\tcx.sess().codemap().with_expn_info(span.expn_id, \n+\t\t\t|info| in_macro(cx, info))\n+}\n+\n+/// check if a DefId's path matches the given absolute type path\n+/// usage e.g. with\n+/// `match_def_path(cx, id, &[\"core\", \"option\", \"Option\"])`\n+pub fn match_def_path(cx: &Context, def_id: DefId, path: &[&str]) -> bool {\n+\tty::with_path(cx.tcx, def_id, |iter| iter.map(|elem| elem.name())\n+\t\t.zip(path.iter()).all(|(nm, p)| &nm.as_str() == p))\n+}\n+\n+/// match a Path against a slice of segment string literals, e.g.\n+/// `match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])`\n+pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n+\tpath.segments.iter().rev().zip(segments.iter().rev()).all(\n+\t\t|(a,b)| a.identifier.as_str() == *b)\n+}"}, {"sha": "9b648a517e0cd2fd502fccf89461ba1f3727894c", "filename": "tests/compile-fail/attrs.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ad8841c20b86e7f35544bc124050e3d124f45d09/tests%2Fcompile-fail%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8841c20b86e7f35544bc124050e3d124f45d09/tests%2Fcompile-fail%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fattrs.rs?ref=ad8841c20b86e7f35544bc124050e3d124f45d09", "patch": "@@ -1,12 +1,33 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n \n-#[deny(inline_always)]\n+#![deny(inline_always)]\n+\n #[inline(always)] //~ERROR You have declared #[inline(always)] on test_attr_lint.\n fn test_attr_lint() {\n \tassert!(true)\n }\n \n+#[inline(always)]\n+fn false_positive_expr() {\n+\tunreachable!()\n+}\n+\n+#[inline(always)]\n+fn false_positive_stmt() {\n+\tunreachable!();\n+}\n+\n+#[inline(always)]\n+fn empty_and_false_positive_stmt() {\n+\t;\n+\tunreachable!();\n+}\n+\n+\n fn main() {\n-\ttest_attr_lint()\n+\ttest_attr_lint();\n+\tif false { false_positive_expr() }\n+\tif false { false_positive_stmt() }\n+\tif false { empty_and_false_positive_stmt() }\n }"}]}