{"sha": "f77afc8f9c63d789519c0b1a733462ca654d894a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3N2FmYzhmOWM2M2Q3ODk1MTljMGIxYTczMzQ2MmNhNjU0ZDg5NGE=", "commit": {"author": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-03-07T11:04:40Z"}, "committer": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-03-08T10:01:12Z"}, "message": "Allow ZSTs in `AllocRef`", "tree": {"sha": "b785317fc7da68131a30b7b8967478014f8f2d13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b785317fc7da68131a30b7b8967478014f8f2d13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f77afc8f9c63d789519c0b1a733462ca654d894a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f77afc8f9c63d789519c0b1a733462ca654d894a", "html_url": "https://github.com/rust-lang/rust/commit/f77afc8f9c63d789519c0b1a733462ca654d894a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f77afc8f9c63d789519c0b1a733462ca654d894a/comments", "author": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f943349eafaa75a60c05b0c84dcdb771d0eae8c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f943349eafaa75a60c05b0c84dcdb771d0eae8c9", "html_url": "https://github.com/rust-lang/rust/commit/f943349eafaa75a60c05b0c84dcdb771d0eae8c9"}], "stats": {"total": 177, "additions": 96, "deletions": 81}, "files": [{"sha": "9f82b2c6fa66d6a27085d71c1bb144387ff470c4", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f77afc8f9c63d789519c0b1a733462ca654d894a/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f77afc8f9c63d789519c0b1a733462ca654d894a/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=f77afc8f9c63d789519c0b1a733462ca654d894a", "patch": "@@ -165,13 +165,19 @@ pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for Global {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        NonNull::new(alloc(layout)).ok_or(AllocErr).map(|p| (p, layout.size()))\n+    fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        if layout.size() == 0 {\n+            Ok((layout.dangling(), 0))\n+        } else {\n+            unsafe { NonNull::new(alloc(layout)).ok_or(AllocErr).map(|p| (p, layout.size())) }\n+        }\n     }\n \n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n-        dealloc(ptr.as_ptr(), layout)\n+        if layout.size() != 0 {\n+            dealloc(ptr.as_ptr(), layout)\n+        }\n     }\n \n     #[inline]\n@@ -181,12 +187,28 @@ unsafe impl AllocRef for Global {\n         layout: Layout,\n         new_size: usize,\n     ) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        NonNull::new(realloc(ptr.as_ptr(), layout, new_size)).ok_or(AllocErr).map(|p| (p, new_size))\n+        match (layout.size(), new_size) {\n+            (0, 0) => Ok((layout.dangling(), 0)),\n+            (0, _) => self.alloc(Layout::from_size_align_unchecked(new_size, layout.align())),\n+            (_, 0) => {\n+                self.dealloc(ptr, layout);\n+                Ok((layout.dangling(), 0))\n+            }\n+            (_, _) => NonNull::new(realloc(ptr.as_ptr(), layout, new_size))\n+                .ok_or(AllocErr)\n+                .map(|p| (p, new_size)),\n+        }\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        NonNull::new(alloc_zeroed(layout)).ok_or(AllocErr).map(|p| (p, layout.size()))\n+    fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        if layout.size() == 0 {\n+            Ok((layout.dangling(), 0))\n+        } else {\n+            unsafe {\n+                NonNull::new(alloc_zeroed(layout)).ok_or(AllocErr).map(|p| (p, layout.size()))\n+            }\n+        }\n     }\n }\n "}, {"sha": "b31fec7f037c966ba48bba4bf079827b20757430", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f77afc8f9c63d789519c0b1a733462ca654d894a/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f77afc8f9c63d789519c0b1a733462ca654d894a/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=f77afc8f9c63d789519c0b1a733462ca654d894a", "patch": "@@ -73,30 +73,28 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     }\n \n     fn allocate_in(mut capacity: usize, zeroed: bool, mut a: A) -> Self {\n-        unsafe {\n-            let elem_size = mem::size_of::<T>();\n+        let elem_size = mem::size_of::<T>();\n \n-            let alloc_size = capacity.checked_mul(elem_size).unwrap_or_else(|| capacity_overflow());\n-            alloc_guard(alloc_size).unwrap_or_else(|_| capacity_overflow());\n+        let alloc_size = capacity.checked_mul(elem_size).unwrap_or_else(|| capacity_overflow());\n+        alloc_guard(alloc_size).unwrap_or_else(|_| capacity_overflow());\n \n-            // Handles ZSTs and `capacity == 0` alike.\n-            let ptr = if alloc_size == 0 {\n-                NonNull::<T>::dangling()\n-            } else {\n-                let align = mem::align_of::<T>();\n-                let layout = Layout::from_size_align(alloc_size, align).unwrap();\n-                let result = if zeroed { a.alloc_zeroed(layout) } else { a.alloc(layout) };\n-                match result {\n-                    Ok((ptr, size)) => {\n-                        capacity = size / elem_size;\n-                        ptr.cast()\n-                    }\n-                    Err(_) => handle_alloc_error(layout),\n+        // Handles ZSTs and `capacity == 0` alike.\n+        let ptr = if alloc_size == 0 {\n+            NonNull::<T>::dangling()\n+        } else {\n+            let align = mem::align_of::<T>();\n+            let layout = Layout::from_size_align(alloc_size, align).unwrap();\n+            let result = if zeroed { a.alloc_zeroed(layout) } else { a.alloc(layout) };\n+            match result {\n+                Ok((ptr, size)) => {\n+                    capacity = size / elem_size;\n+                    ptr.cast()\n                 }\n-            };\n+                Err(_) => handle_alloc_error(layout),\n+            }\n+        };\n \n-            RawVec { ptr: ptr.into(), cap: capacity, a }\n-        }\n+        RawVec { ptr: ptr.into(), cap: capacity, a }\n     }\n }\n "}, {"sha": "21a8a76d0a75b179b8c7d5208f432d1295d57654", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f77afc8f9c63d789519c0b1a733462ca654d894a/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f77afc8f9c63d789519c0b1a733462ca654d894a/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=f77afc8f9c63d789519c0b1a733462ca654d894a", "patch": "@@ -20,7 +20,7 @@ fn allocator_param() {\n         fuel: usize,\n     }\n     unsafe impl AllocRef for BoundedAlloc {\n-        unsafe fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n             let size = layout.size();\n             if size > self.fuel {\n                 return Err(AllocErr);"}, {"sha": "d2a513451ccb6bda48317f696b93098e0800d10c", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 13, "deletions": 43, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f77afc8f9c63d789519c0b1a733462ca654d894a/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f77afc8f9c63d789519c0b1a733462ca654d894a/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=f77afc8f9c63d789519c0b1a733462ca654d894a", "patch": "@@ -606,20 +606,11 @@ pub unsafe trait GlobalAlloc {\n ///   method (`dealloc`) or by being passed to a reallocation method\n ///  (see above) that returns `Ok`.\n ///\n-/// A note regarding zero-sized types and zero-sized layouts: many\n-/// methods in the `AllocRef` trait state that allocation requests\n-/// must be non-zero size, or else undefined behavior can result.\n-///\n-/// * If an `AllocRef` implementation chooses to return `Ok` in this\n-///   case (i.e., the pointer denotes a zero-sized inaccessible block)\n-///   then that returned pointer must be considered \"currently\n-///   allocated\". On such an allocator, *all* methods that take\n-///   currently-allocated pointers as inputs must accept these\n-///   zero-sized pointers, *without* causing undefined behavior.\n-///\n-/// * In other words, if a zero-sized pointer can flow out of an\n-///   allocator, then that allocator must likewise accept that pointer\n-///   flowing back into its deallocation and reallocation methods.\n+/// Unlike [`GlobalAlloc`], zero-sized allocations are allowed in\n+/// `AllocRef`. If an underlying allocator does not support this (like\n+/// jemalloc) or return a null pointer (such as `libc::malloc`), this case\n+/// must be caught. In this case [`Layout::dangling()`] can be used to\n+/// create a dangling, but aligned `NonNull<u8>`.\n ///\n /// Some of the methods require that a layout *fit* a memory block.\n /// What it means for a layout to \"fit\" a memory block means (or\n@@ -649,6 +640,9 @@ pub unsafe trait GlobalAlloc {\n ///  * if an allocator does not support overallocating, it is fine to\n ///    simply return `layout.size()` as the allocated size.\n ///\n+/// [`GlobalAlloc`]: self::GlobalAlloc\n+/// [`Layout::dangling()`]: self::Layout::dangling\n+///\n /// # Safety\n ///\n /// The `AllocRef` trait is an `unsafe` trait for a number of reasons, and\n@@ -669,14 +663,6 @@ pub unsafe trait GlobalAlloc {\n /// the future.\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub unsafe trait AllocRef {\n-    // (Note: some existing allocators have unspecified but well-defined\n-    // behavior in response to a zero size allocation request ;\n-    // e.g., in C, `malloc` of 0 will either return a null pointer or a\n-    // unique pointer, but will not have arbitrary undefined\n-    // behavior.\n-    // However in jemalloc for example,\n-    // `mallocx(0)` is documented as undefined behavior.)\n-\n     /// On success, returns a pointer meeting the size and alignment\n     /// guarantees of `layout` and the actual size of the allocated block,\n     /// which must be greater than or equal to `layout.size()`.\n@@ -690,15 +676,6 @@ pub unsafe trait AllocRef {\n     /// behavior, e.g., to ensure initialization to particular sets of\n     /// bit patterns.)\n     ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure that `layout` has non-zero size.\n-    ///\n-    /// (Extension subtraits might provide more specific bounds on\n-    /// behavior, e.g., guarantee a sentinel address or a null pointer\n-    /// in response to a zero-size allocation request.)\n-    ///\n     /// # Errors\n     ///\n     /// Returning `Err` indicates that either memory is exhausted or\n@@ -716,7 +693,7 @@ pub unsafe trait AllocRef {\n     /// rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr>;\n+    fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr>;\n \n     /// Deallocate the memory referenced by `ptr`.\n     ///\n@@ -738,10 +715,6 @@ pub unsafe trait AllocRef {\n     /// Behaves like `alloc`, but also ensures that the contents\n     /// are set to zero before being returned.\n     ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe for the same reasons that `alloc` is.\n-    ///\n     /// # Errors\n     ///\n     /// Returning `Err` indicates that either memory is exhausted or\n@@ -753,17 +726,17 @@ pub unsafe trait AllocRef {\n     /// rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+    fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n         let size = layout.size();\n         let result = self.alloc(layout);\n         if let Ok((p, _)) = result {\n-            ptr::write_bytes(p.as_ptr(), 0, size);\n+            unsafe { ptr::write_bytes(p.as_ptr(), 0, size) }\n         }\n         result\n     }\n \n     // == METHODS FOR MEMORY REUSE ==\n-    // realloc. alloc_excess, realloc_excess\n+    // realloc, realloc_zeroed, grow_in_place, grow_in_place_zeroed, shrink_in_place\n \n     /// Returns a pointer suitable for holding data described by\n     /// a new layout with `layout`\u2019s alignment and a size given\n@@ -793,8 +766,6 @@ pub unsafe trait AllocRef {\n     /// * `layout` must *fit* the `ptr` (see above). (The `new_size`\n     ///   argument need not fit it.)\n     ///\n-    /// * `new_size` must be greater than zero.\n-    ///\n     /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`,\n     ///   must not overflow (i.e., the rounded value must be less than `usize::MAX`).\n     ///\n@@ -1009,8 +980,7 @@ pub unsafe trait AllocRef {\n     /// * `layout` must *fit* the `ptr` (see above); note the\n     ///   `new_size` argument need not fit it,\n     ///\n-    /// * `new_size` must not be greater than `layout.size()`\n-    ///   (and must be greater than zero),\n+    /// * `new_size` must not be greater than `layout.size()`,\n     ///\n     /// # Errors\n     ///"}, {"sha": "25f3ddcbebab69f848ebceae9b668022ef625a2e", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f77afc8f9c63d789519c0b1a733462ca654d894a/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f77afc8f9c63d789519c0b1a733462ca654d894a/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=f77afc8f9c63d789519c0b1a733462ca654d894a", "patch": "@@ -133,24 +133,41 @@ pub use alloc_crate::alloc::*;\n #[derive(Debug, Default, Copy, Clone)]\n pub struct System;\n \n-// The AllocRef impl just forwards to the GlobalAlloc impl, which is in `std::sys::*::alloc`.\n+// The AllocRef impl checks the layout size to be non-zero and forwards to the GlobalAlloc impl,\n+// which is in `std::sys::*::alloc`.\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for System {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr).map(|p| (p, layout.size()))\n+    fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        if layout.size() == 0 {\n+            Ok((layout.dangling(), 0))\n+        } else {\n+            unsafe {\n+                NonNull::new(GlobalAlloc::alloc(self, layout))\n+                    .ok_or(AllocErr)\n+                    .map(|p| (p, layout.size()))\n+            }\n+        }\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        NonNull::new(GlobalAlloc::alloc_zeroed(self, layout))\n-            .ok_or(AllocErr)\n-            .map(|p| (p, layout.size()))\n+    fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        if layout.size() == 0 {\n+            Ok((layout.dangling(), 0))\n+        } else {\n+            unsafe {\n+                NonNull::new(GlobalAlloc::alloc_zeroed(self, layout))\n+                    .ok_or(AllocErr)\n+                    .map(|p| (p, layout.size()))\n+            }\n+        }\n     }\n \n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n-        GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n+        if layout.size() != 0 {\n+            GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n+        }\n     }\n \n     #[inline]\n@@ -160,9 +177,17 @@ unsafe impl AllocRef for System {\n         layout: Layout,\n         new_size: usize,\n     ) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size))\n-            .ok_or(AllocErr)\n-            .map(|p| (p, new_size))\n+        match (layout.size(), new_size) {\n+            (0, 0) => Ok((layout.dangling(), 0)),\n+            (0, _) => self.alloc(Layout::from_size_align_unchecked(new_size, layout.align())),\n+            (_, 0) => {\n+                self.dealloc(ptr, layout);\n+                Ok((layout.dangling(), 0))\n+            }\n+            (_, _) => NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size))\n+                .ok_or(AllocErr)\n+                .map(|p| (p, new_size)),\n+        }\n     }\n }\n "}]}