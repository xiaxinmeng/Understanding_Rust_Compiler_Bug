{"sha": "a21c5f267a722b6c80790a559bf272942b946cd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyMWM1ZjI2N2E3MjJiNmM4MDc5MGE1NTliZjI3Mjk0MmI5NDZjZDQ=", "commit": {"author": {"name": "NODA, Kai", "email": "nodakai@gmail.com", "date": "2016-03-20T08:59:38Z"}, "committer": {"name": "NODA, Kai", "email": "nodakai@gmail.com", "date": "2016-03-24T00:57:45Z"}, "message": "Add core::ops::Range*::contains() as per rust-lang/rust#32311\n\nSigned-off-by: NODA, Kai <nodakai@gmail.com>", "tree": {"sha": "8e637e1dba28627bbe3309ee822fdbc63b64fff9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e637e1dba28627bbe3309ee822fdbc63b64fff9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a21c5f267a722b6c80790a559bf272942b946cd4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABCAAGBQJW8zuJAAoJENU+ddTERR/CdOkQAK5ppeXn6fOzZgBMaIOos/vr\nMcwTYadj7GVZLIWL/ejgW3G2ilhxlI6avrv56wOG55S+7YWBXu0tEFJ36L/0o9mI\n01TmJQPS5BQILEEvuUwqfZGg8T6QIoY1vwRV2acJj4WEijsmk9nFKas9KIR7BEM2\nnKTg9IKV7f7BSEg5Ak2AQNKa7O5FuzAb0ZrSc1++DyWIbV9rvhHn/PXM+aPf6ppT\n/OLBMSizN6DCThTu4FvXoKTVaDoNQZN9X+JTLgDAj7w8/frl+cxkDhxdmA5Ky6+i\nu/wXAng65y6UIfJGNxzABCiWHEAxfJc7LpbTK5z5yxV4p3UXhN1ce8ZLfySiDiRJ\nv/5qIsK8ysbwcyDpIJWj1b+A7onhW7CnQ+XSawGZJb6ipG1uGhfkizUgb8iBd5zF\nbmNpRIAe7QfQP+ycu1QNtGwFfuifNSFkKXWGOxu0g0eoBrpWaNzBl9YyAMsCxraA\njdjUQ0yRM23y9vHIXogXHirlu/mBd9jusFeq+AUF5QtCv+eb9BIjIX7u8yWkePoc\nbS9WsCxENkjfvbXDCekZQ83XJDuBdEwijuRsk/iJXIwF7Qy5QBmPJdryY5b3cgIM\n0NtyuPT2yM0znyFpNpvNUWtUh/G+6mRU/EGEWXqYcbut8RkHrmkRAbJKERijlfHX\nKzN3iB15YU26h/FONIx6\n=eNfT\n-----END PGP SIGNATURE-----", "payload": "tree 8e637e1dba28627bbe3309ee822fdbc63b64fff9\nparent 98f0a9128f0fc6545de14a5de8f0e91675045e56\nauthor NODA, Kai <nodakai@gmail.com> 1458464378 +0800\ncommitter NODA, Kai <nodakai@gmail.com> 1458781065 +0800\n\nAdd core::ops::Range*::contains() as per rust-lang/rust#32311\n\nSigned-off-by: NODA, Kai <nodakai@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a21c5f267a722b6c80790a559bf272942b946cd4", "html_url": "https://github.com/rust-lang/rust/commit/a21c5f267a722b6c80790a559bf272942b946cd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a21c5f267a722b6c80790a559bf272942b946cd4/comments", "author": {"login": "nodakai", "id": 90726, "node_id": "MDQ6VXNlcjkwNzI2", "avatar_url": "https://avatars.githubusercontent.com/u/90726?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nodakai", "html_url": "https://github.com/nodakai", "followers_url": "https://api.github.com/users/nodakai/followers", "following_url": "https://api.github.com/users/nodakai/following{/other_user}", "gists_url": "https://api.github.com/users/nodakai/gists{/gist_id}", "starred_url": "https://api.github.com/users/nodakai/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nodakai/subscriptions", "organizations_url": "https://api.github.com/users/nodakai/orgs", "repos_url": "https://api.github.com/users/nodakai/repos", "events_url": "https://api.github.com/users/nodakai/events{/privacy}", "received_events_url": "https://api.github.com/users/nodakai/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nodakai", "id": 90726, "node_id": "MDQ6VXNlcjkwNzI2", "avatar_url": "https://avatars.githubusercontent.com/u/90726?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nodakai", "html_url": "https://github.com/nodakai", "followers_url": "https://api.github.com/users/nodakai/followers", "following_url": "https://api.github.com/users/nodakai/following{/other_user}", "gists_url": "https://api.github.com/users/nodakai/gists{/gist_id}", "starred_url": "https://api.github.com/users/nodakai/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nodakai/subscriptions", "organizations_url": "https://api.github.com/users/nodakai/orgs", "repos_url": "https://api.github.com/users/nodakai/repos", "events_url": "https://api.github.com/users/nodakai/events{/privacy}", "received_events_url": "https://api.github.com/users/nodakai/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98f0a9128f0fc6545de14a5de8f0e91675045e56", "url": "https://api.github.com/repos/rust-lang/rust/commits/98f0a9128f0fc6545de14a5de8f0e91675045e56", "html_url": "https://github.com/rust-lang/rust/commit/98f0a9128f0fc6545de14a5de8f0e91675045e56"}], "stats": {"total": 214, "additions": 208, "deletions": 6}, "files": [{"sha": "44c498ef6d4e0836fb88b5c3c39aa6a0835473f4", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 208, "deletions": 6, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/a21c5f267a722b6c80790a559bf272942b946cd4/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a21c5f267a722b6c80790a559bf272942b946cd4/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=a21c5f267a722b6c80790a559bf272942b946cd4", "patch": "@@ -1446,7 +1446,24 @@ pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n     fn index_mut(&mut self, index: Idx) -> &mut Self::Output;\n }\n \n-/// An unbounded range.\n+/// An unbounded range. Use `..` (two dots) for its shorthand.\n+///\n+/// Its primary use case is slicing index. It cannot serve as an iterator\n+/// because it doesn't have a starting point.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// fn main() {\n+///     assert_eq!((..), std::ops::RangeFull);\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ .. ], [0,1,2,3]);  // RangeFull\n+///     assert_eq!(arr[ ..3], [0,1,2  ]);\n+///     assert_eq!(arr[1.. ], [  1,2,3]);\n+///     assert_eq!(arr[1..3], [  1,2  ]);\n+/// }\n+/// ```\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFull;\n@@ -1458,7 +1475,26 @@ impl fmt::Debug for RangeFull {\n     }\n }\n \n-/// A (half-open) range which is bounded at both ends.\n+/// A (half-open) range which is bounded at both ends: { x | start <= x < end }.\n+/// Use `start..end` (two dots) for its shorthand.\n+///\n+/// See the [`contains()`](#method.contains) method for its characterization.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(iter_arith)]\n+/// fn main() {\n+///     assert_eq!((3..5), std::ops::Range{ start: 3, end: 5 });\n+///     assert_eq!(3+4+5, (3..6).sum());\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ .. ], [0,1,2,3]);\n+///     assert_eq!(arr[ ..3], [0,1,2  ]);\n+///     assert_eq!(arr[1.. ], [  1,2,3]);\n+///     assert_eq!(arr[1..3], [  1,2  ]);  // Range\n+/// }\n+/// ```\n #[derive(Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Range<Idx> {\n@@ -1477,7 +1513,47 @@ impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n     }\n }\n \n-/// A range which is only bounded below.\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> Range<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains)]\n+    /// fn main() {\n+    ///     assert!( ! (3..5).contains(2));\n+    ///     assert!(   (3..5).contains(3));\n+    ///     assert!(   (3..5).contains(4));\n+    ///     assert!( ! (3..5).contains(5));\n+    ///\n+    ///     assert!( ! (3..3).contains(3));\n+    ///     assert!( ! (3..2).contains(3));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        (self.start <= item) && (item < self.end)\n+    }\n+}\n+\n+/// A range which is only bounded below: { x | start <= x }.\n+/// Use `start..` for its shorthand.\n+///\n+/// See the [`contains()`](#method.contains) method for its characterization.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(iter_arith)]\n+/// fn main() {\n+///     assert_eq!((2..), std::ops::RangeFrom{ start: 2 });\n+///     assert_eq!(2+3+4, (2..).take(3).sum());\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ .. ], [0,1,2,3]);\n+///     assert_eq!(arr[ ..3], [0,1,2  ]);\n+///     assert_eq!(arr[1.. ], [  1,2,3]);  // RangeFrom\n+///     assert_eq!(arr[1..3], [  1,2  ]);\n+/// }\n+/// ```\n #[derive(Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFrom<Idx> {\n@@ -1493,7 +1569,40 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n     }\n }\n \n-/// A range which is only bounded above.\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains)]\n+    /// fn main() {\n+    ///     assert!( ! (3..).contains(2));\n+    ///     assert!(   (3..).contains(3));\n+    ///     assert!(   (3..).contains(1_000_000_000));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        (self.start <= item)\n+    }\n+}\n+\n+/// A range which is only bounded above: { x | x < end }.\n+/// Use `..end` (two dots) for its shorthand.\n+///\n+/// See the [`contains()`](#method.contains) method for its characterization.\n+///\n+/// It cannot serve as an iterator because it doesn't have a starting point.\n+/// ```\n+/// fn main() {\n+///     assert_eq!((..5), std::ops::RangeTo{ end: 5 });\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ .. ], [0,1,2,3]);\n+///     assert_eq!(arr[ ..3], [0,1,2  ]);  // RangeTo\n+///     assert_eq!(arr[1.. ], [  1,2,3]);\n+///     assert_eq!(arr[1..3], [  1,2  ]);\n+/// }\n+/// ```\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeTo<Idx> {\n@@ -1509,7 +1618,41 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n     }\n }\n \n-/// An inclusive range which is bounded at both ends.\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains)]\n+    /// fn main() {\n+    ///     assert!(   (..5).contains(-1_000_000_000));\n+    ///     assert!(   (..5).contains(4));\n+    ///     assert!( ! (..5).contains(5));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        (item < self.end)\n+    }\n+}\n+\n+/// An inclusive range which is bounded at both ends: { x | start <= x <= end }.\n+/// Use `start...end` (three dots) for its shorthand.\n+///\n+/// See the [`contains()`](#method.contains) method for its characterization.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(inclusive_range,inclusive_range_syntax,iter_arith)]\n+/// fn main() {\n+///     assert_eq!((3...5), std::ops::RangeInclusive::NonEmpty{ start: 3, end: 5 });\n+///     assert_eq!(3+4+5, (3...5).sum());\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ ...2], [0,1,2  ]);\n+///     assert_eq!(arr[1...2], [  1,2  ]);  // RangeInclusive\n+/// }\n+/// ```\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n pub enum RangeInclusive<Idx> {\n@@ -1572,7 +1715,49 @@ impl<Idx: PartialOrd + One + Sub<Output=Idx>> From<Range<Idx>> for RangeInclusiv\n     }\n }\n \n-/// An inclusive range which is only bounded above.\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains,inclusive_range_syntax)]\n+    /// fn main() {\n+    ///     assert!( ! (3...5).contains(2));\n+    ///     assert!(   (3...5).contains(3));\n+    ///     assert!(   (3...5).contains(4));\n+    ///     assert!(   (3...5).contains(5));\n+    ///     assert!( ! (3...5).contains(6));\n+    ///\n+    ///     assert!(   (3...3).contains(3));\n+    ///     assert!( ! (3...2).contains(3));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        if let &RangeInclusive::NonEmpty{ref start, ref end} = self {\n+            (*start <= item) && (item <= *end)\n+        } else { false }\n+    }\n+}\n+\n+/// An inclusive range which is only bounded above: { x | x <= end }.\n+/// Use `...end` (three dots) for its shorthand.\n+///\n+/// See the [`contains()`](#method.contains) method for its characterization.\n+///\n+/// It cannot serve as an iterator because it doesn't have a starting point.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(inclusive_range,inclusive_range_syntax)]\n+/// fn main() {\n+///     assert_eq!((...5), std::ops::RangeToInclusive{ end: 5 });\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ ...2], [0,1,2  ]);  // RangeToInclusive\n+///     assert_eq!(arr[1...2], [  1,2  ]);\n+/// }\n+/// ```\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n pub struct RangeToInclusive<Idx> {\n@@ -1590,6 +1775,23 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n     }\n }\n \n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains,inclusive_range_syntax)]\n+    /// fn main() {\n+    ///     assert!(   (...5).contains(-1_000_000_000));\n+    ///     assert!(   (...5).contains(5));\n+    ///     assert!( ! (...5).contains(6));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        (item <= self.end)\n+    }\n+}\n+\n // RangeToInclusive<Idx> cannot impl From<RangeTo<Idx>>\n // because underflow would be possible with (..0).into()\n "}]}