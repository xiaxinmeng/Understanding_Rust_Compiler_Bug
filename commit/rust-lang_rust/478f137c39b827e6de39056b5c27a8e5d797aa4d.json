{"sha": "478f137c39b827e6de39056b5c27a8e5d797aa4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3OGYxMzdjMzliODI3ZTZkZTM5MDU2YjVjMjdhOGU1ZDc5N2FhNGQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-30T14:08:18Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-01T07:58:03Z"}, "message": "put all the logic into reactivatable()", "tree": {"sha": "f507e72287935f7ea83763536e9ea590aeac0abf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f507e72287935f7ea83763536e9ea590aeac0abf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/478f137c39b827e6de39056b5c27a8e5d797aa4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/478f137c39b827e6de39056b5c27a8e5d797aa4d", "html_url": "https://github.com/rust-lang/rust/commit/478f137c39b827e6de39056b5c27a8e5d797aa4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/478f137c39b827e6de39056b5c27a8e5d797aa4d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3302656247438d89936bbbfd55fe696c82fa98e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3302656247438d89936bbbfd55fe696c82fa98e4", "html_url": "https://github.com/rust-lang/rust/commit/3302656247438d89936bbbfd55fe696c82fa98e4"}], "stats": {"total": 140, "additions": 63, "deletions": 77}, "files": [{"sha": "dcb284b1bc3fdf3f90d5da867b323a71dac4b34f", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 63, "deletions": 77, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/478f137c39b827e6de39056b5c27a8e5d797aa4d/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478f137c39b827e6de39056b5c27a8e5d797aa4d/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=478f137c39b827e6de39056b5c27a8e5d797aa4d", "patch": "@@ -142,74 +142,76 @@ pub struct Stacks {\n \n /// Core operations\n impl<'tcx> Stack {\n-    /// Check if `bor` is currently active.  We accept a `Raw` on a frozen location\n-    /// because this could be a shared (re)borrow.  If you want to mutate, this\n-    /// is not the right function to call!\n-    fn check(&self, bor: Borrow) -> bool {\n-        match bor {\n-            Borrow::Frz(acc_t) =>\n-                // Must be frozen at least as long as the `acc_t` says.\n-                self.frozen_since.map_or(false, |loc_t| loc_t <= acc_t),\n-            Borrow::Mut(acc_m) =>\n-                // Raw pointers are fine with frozen locations. This is important because &Cell is raw!\n-                if self.frozen_since.is_some() {\n-                    acc_m.is_raw()\n-                } else {\n-                    self.borrows.last().map_or(false, |&loc_itm| loc_itm == BorStackItem::Mut(acc_m))\n-                }\n-        }\n-    }\n-\n     /// Check if `bor` could be activated by unfreezing and popping.\n-    /// `force_mut` indicates whether being frozen is potentially acceptable.\n+    /// `ref_kind` indicates whether this is being used to read/write (or, equivalently, to\n+    /// borrow as &/&mut), or to borrow as raw.\n     /// Returns `Err` if the answer is \"no\"; otherwise the data says\n     /// what needs to happen to activate this: `None` = nothing,\n     /// `Some(n)` = unfreeze and make item `n` the top item of the stack.\n-    fn reactivatable(&self, bor: Borrow, force_mut: bool) -> Result<Option<usize>, String> {\n-        // Unless mutation is bound to happen, do NOT change anything if `bor` is already active.\n-        // In particular, if it is a `Mut(Raw)` and we are frozen, this should be a NOP.\n-        if !force_mut && self.check(bor) {\n-            return Ok(None);\n-        }\n-\n-        let acc_m = match bor {\n+    fn reactivatable(&self, bor: Borrow, ref_kind: RefKind) -> Result<Option<usize>, String> {\n+        let mut_borrow = match bor {\n             Borrow::Frz(since) =>\n-                return Err(if force_mut {\n-                    format!(\"Using a shared borrow for mutation\")\n-                } else {\n-                    format!(\n-                        \"Location should be frozen since {} but {}\",\n-                        since,\n-                        match self.frozen_since {\n-                            None => format!(\"it is not frozen at all\"),\n-                            Some(since) => format!(\"it is only frozen since {}\", since),\n-                        }\n-                    )\n-                }),\n-            Borrow::Mut(acc_m) => acc_m\n+                // The only way to reactivate a `Frz` is if this is already frozen.\n+                return match self.frozen_since {\n+                    _ if ref_kind == RefKind::Mut =>\n+                        Err(format!(\"Using a shared borrow for mutation\")),\n+                    None =>\n+                        Err(format!(\"Location should be frozen but it is not\")),\n+                    Some(loc) if loc <= since =>\n+                        Ok(None),\n+                    Some(loc) =>\n+                        Err(format!(\"Location should be frozen since {} but it is only frozen \\\n+                                     since {}\", since, loc)),\n+                },\n+            Borrow::Mut(Mut::Raw) if self.is_frozen() && ref_kind != RefKind::Mut =>\n+                // Non-mutating access with a raw from a frozen location is a special case: The\n+                // shared refs do not mind raw reads, and the raw itself does not assume any\n+                // exclusivity. So we do not even require there to be a raw on the stack.\n+                // This does not break the assumption that an `&mut` we own is\n+                // exclusive for reads, because there we have the invariant that\n+                // the location is *not* frozen.\n+                return Ok(None),\n+            Borrow::Mut(mut_borrow) => mut_borrow\n         };\n-        // This is where we would unfreeze.\n+        // See if we can get there via popping.\n         for (idx, &itm) in self.borrows.iter().enumerate().rev() {\n             match itm {\n                 BorStackItem::FnBarrier(_) =>\n-                    return Err(format!(\"Trying to reactivate a mutable borrow ({:?}) that lives behind a barrier\", acc_m)),\n-                BorStackItem::Mut(loc_m) => {\n-                    if loc_m == acc_m { return Ok(Some(idx)); }\n+                    return Err(format!(\"Trying to reactivate a mutable borrow ({:?}) that lives \\\n+                                        behind a barrier\", mut_borrow)),\n+                BorStackItem::Mut(loc) => {\n+                    if loc == mut_borrow {\n+                        // We found it!  This is good to know.\n+                        // Yet, maybe we do not really want to pop?\n+                        if ref_kind == RefKind::Shr && self.is_frozen() {\n+                            // Whoever had exclusive access to this location allowed it\n+                            // to become frozen.  That can only happen if they reborrowed\n+                            // to a shared ref, at which point they gave up on exclusive access.\n+                            // Hence we allow more reads, entirely ignoring everything above\n+                            // on the stack (but still making sure it is on the stack).\n+                            // This does not break the assumption that an `&mut` we own is\n+                            // exclusive for reads, because there we have the invariant that\n+                            // the location is *not* frozen.\n+                            return Ok(None);\n+                        } else {\n+                            return Ok(Some(idx));\n+                        }\n+                    }\n                 }\n             }\n         }\n         // Nothing to be found.\n-        Err(format!(\"Mutable borrow-to-reactivate ({:?}) does not exist on the stack\", acc_m))\n+        Err(format!(\"Mutable borrow-to-reactivate ({:?}) does not exist on the stack\", mut_borrow))\n     }\n \n-    /// Reactive `bor` for this stack.  If `force_mut` is set, we want to aggressively\n-    /// unfreeze this location (because we are about to mutate, so a frozen `Raw` is not okay).\n-    fn reactivate(&mut self, bor: Borrow, force_mut: bool) -> EvalResult<'tcx> {\n-        let action = match self.reactivatable(bor, force_mut) {\n+    /// Reactive `bor` for this stack.  `ref_kind` indicates whether this is being\n+    /// used to read/write (or, equivalently, to borrow as &/&mut), or to borrow as raw.\n+    fn reactivate(&mut self, bor: Borrow, ref_kind: RefKind) -> EvalResult<'tcx> {\n+        let action = match self.reactivatable(bor, ref_kind) {\n             Ok(action) => action,\n             Err(err) => return err!(MachineError(err)),\n         };\n-\n+        // Execute what `reactivatable` told us to do.\n         match action {\n             None => {}, // nothing to do\n             Some(top) => {\n@@ -285,27 +287,7 @@ impl<'tcx> Stacks {\n             ptr.tag, ref_kind, new_bor, ptr, size.bytes());\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            if ref_kind == RefKind::Shr && stack.is_frozen() {\n-                // Location already frozen.  We don't want to unfreeze, but make sure\n-                // the ref makes some sense.\n-                if let Err(err) = stack.reactivatable(ptr.tag, /*force_mut*/false) {\n-                    return err!(MachineError(err));\n-                }\n-            } else {\n-                // If we are creating a mutable ref, we certainly want to unfreeze.\n-                // Even if we are doing so from a raw.\n-                // Notice that if this is a local, whenever we access it directly the\n-                // tag here will be the bottommost `Uniq` for that local.  That `Uniq`\n-                // never is accessible by the program, so it will not be used by any\n-                // other access.  IOW, whenever we directly use a local this will pop\n-                // everything else off the stack, invalidating all previous pointers\n-                // and, in particular, *all* raw pointers.  This subsumes the explicit\n-                // `reset` which the blog post [1] says to perform when accessing a local.\n-                //\n-                // [1] https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html\n-                let force_mut = ref_kind == RefKind::Mut;\n-                stack.reactivate(ptr.tag, force_mut)?;\n-            }\n+            stack.reactivate(ptr.tag, ref_kind)?;\n             if let Some(new_bor) = new_bor {\n                 stack.initiate(new_bor);\n             }\n@@ -484,11 +466,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         let mut stacks = alloc.extra.stacks.borrow_mut();\n         // We need `iter_mut` because `iter` would skip gaps!\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            // We accept &mut to a frozen location here, that is just normal.  There might\n-            // be shared reborrows that we are about to invalidate with this access.\n-            // We cannot invalidate them aggressively here because the deref might also be\n-            // to just create more shared refs.\n-            if let Err(err) = stack.reactivatable(ptr.tag, /*force_mut*/false) {\n+            // Conservatively assume that we will only read.\n+            if let Err(err) = stack.reactivatable(ptr.tag, RefKind::Shr) {\n                 return err!(MachineError(format!(\"Encountered {:?} reference with non-reactivatable tag: {}\", ref_kind, err)))\n             }\n         }\n@@ -503,7 +482,14 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n     ) -> Borrow {\n         let mut_borrow = match kind {\n             MemoryKind::Stack => {\n-                // New unique borrow\n+                // New unique borrow. This `Uniq` is not accessible by the program,\n+                // so it will only ever be used when using the local directly (i.e.,\n+                // not through a pointer).  IOW, whenever we directly use a local this will pop\n+                // everything else off the stack, invalidating all previous pointers\n+                // and, in particular, *all* raw pointers.  This subsumes the explicit\n+                // `reset` which the blog post [1] says to perform when accessing a local.\n+                //\n+                // [1] https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html\n                 let time = self.machine.stacked_borrows.increment_clock();\n                 Mut::Uniq(time)\n             }"}]}