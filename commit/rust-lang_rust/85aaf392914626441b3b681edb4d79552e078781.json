{"sha": "85aaf392914626441b3b681edb4d79552e078781", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1YWFmMzkyOTE0NjI2NDQxYjNiNjgxZWRiNGQ3OTU1MmUwNzg3ODE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-02-26T18:23:18Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-02-26T20:28:32Z"}, "message": "Reimplement type_needs_drop on top of TypeContents", "tree": {"sha": "6690b9c78a9afd0fa0ed7d42d9c9c94e6c95360b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6690b9c78a9afd0fa0ed7d42d9c9c94e6c95360b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85aaf392914626441b3b681edb4d79552e078781", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85aaf392914626441b3b681edb4d79552e078781", "html_url": "https://github.com/rust-lang/rust/commit/85aaf392914626441b3b681edb4d79552e078781", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85aaf392914626441b3b681edb4d79552e078781/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6439e286f90a34d96cec91d82f941f7572817939", "url": "https://api.github.com/repos/rust-lang/rust/commits/6439e286f90a34d96cec91d82f941f7572817939", "html_url": "https://github.com/rust-lang/rust/commit/6439e286f90a34d96cec91d82f941f7572817939"}], "stats": {"total": 98, "additions": 17, "deletions": 81}, "files": [{"sha": "182ab11b91721317fbc591a8f1820125ade37e60", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 17, "deletions": 81, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/85aaf392914626441b3b681edb4d79552e078781/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85aaf392914626441b3b681edb4d79552e078781/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=85aaf392914626441b3b681edb4d79552e078781", "patch": "@@ -259,7 +259,6 @@ struct ctxt_ {\n     rcache: creader_cache,\n     ccache: constness_cache,\n     short_names_cache: HashMap<t, @~str>,\n-    needs_drop_cache: HashMap<t, bool>,\n     needs_unwind_cleanup_cache: HashMap<t, bool>,\n     tc_cache: @mut LinearMap<uint, TypeContents>,\n     ast_ty_to_ty_cache: HashMap<node_id, ast_ty_to_ty_cache_entry>,\n@@ -822,7 +821,6 @@ pub fn mk_ctxt(s: session::Session,\n         rcache: mk_rcache(),\n         ccache: HashMap(),\n         short_names_cache: new_ty_hash(),\n-        needs_drop_cache: new_ty_hash(),\n         needs_unwind_cleanup_cache: new_ty_hash(),\n         tc_cache: @mut LinearMap::new(),\n         ast_ty_to_ty_cache: HashMap(),\n@@ -1600,79 +1598,7 @@ pub fn type_is_immediate(ty: t) -> bool {\n }\n \n pub fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n-    match cx.needs_drop_cache.find(&ty) {\n-      Some(result) => return result,\n-      None => {/* fall through */ }\n-    }\n-\n-    let mut accum = false;\n-    let result = match /*bad*/copy get(ty).sty {\n-      // scalar types\n-      ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_type | ty_ptr(_) | ty_rptr(_, _) |\n-      ty_estr(vstore_fixed(_)) |\n-      ty_estr(vstore_slice(_)) |\n-      ty_evec(_, vstore_slice(_)) |\n-      ty_self => false,\n-\n-      ty_box(_) | ty_uniq(_) |\n-      ty_opaque_box | ty_opaque_closure_ptr(*) |\n-      ty_estr(vstore_uniq) |\n-      ty_estr(vstore_box) |\n-      ty_evec(_, vstore_uniq) |\n-      ty_evec(_, vstore_box) => true,\n-\n-      ty_trait(_, _, vstore_box) |\n-      ty_trait(_, _, vstore_uniq) => true,\n-      ty_trait(_, _, vstore_fixed(_)) |\n-      ty_trait(_, _, vstore_slice(_)) => false,\n-\n-      ty_param(*) | ty_infer(*) | ty_err => true,\n-\n-      ty_evec(mt, vstore_fixed(_)) => type_needs_drop(cx, mt.ty),\n-      ty_unboxed_vec(mt) => type_needs_drop(cx, mt.ty),\n-      ty_rec(flds) => {\n-        for flds.each |f| {\n-            if type_needs_drop(cx, f.mt.ty) { accum = true; }\n-        }\n-        accum\n-      }\n-      ty_struct(did, ref substs) => {\n-         // Any struct with a dtor needs a drop\n-         ty_dtor(cx, did).is_present() || {\n-             for vec::each(ty::struct_fields(cx, did, substs)) |f| {\n-                 if type_needs_drop(cx, f.mt.ty) { accum = true; }\n-             }\n-             accum\n-         }\n-      }\n-      ty_tup(elts) => {\n-          for elts.each |m| { if type_needs_drop(cx, *m) { accum = true; } }\n-        accum\n-      }\n-      ty_enum(did, ref substs) => {\n-        let variants = enum_variants(cx, did);\n-          for vec::each(*variants) |variant| {\n-              for variant.args.each |aty| {\n-                // Perform any type parameter substitutions.\n-                let arg_ty = subst(cx, substs, *aty);\n-                if type_needs_drop(cx, arg_ty) { accum = true; }\n-            }\n-            if accum { break; }\n-        }\n-        accum\n-      }\n-      ty_bare_fn(*) => false,\n-      ty_closure(ref fty) => {\n-        match fty.sigil {\n-          ast::BorrowedSigil => false,\n-          ast::ManagedSigil | ast::OwnedSigil => true,\n-        }\n-      }\n-    };\n-\n-    cx.needs_drop_cache.insert(ty, result);\n-    return result;\n+    type_contents(cx, ty).needs_drop(cx)\n }\n \n // Some things don't need cleanups during unwinding because the\n@@ -1819,7 +1745,7 @@ pub impl TypeContents {\n \n     static fn nonimplicitly_copyable(cx: ctxt) -> TypeContents {\n         let base = TypeContents::noncopyable(cx) + TC_OWNED_POINTER;\n-        if cx.vecs_implicitly_copyable {base} else {base + TC_OWNED_SLICE}\n+        if cx.vecs_implicitly_copyable {base} else {base + TC_OWNED_VEC}\n     }\n \n     fn is_safe_for_default_mode(&self, cx: ctxt) -> bool {\n@@ -1828,7 +1754,17 @@ pub impl TypeContents {\n \n     static fn nondefault_mode(cx: ctxt) -> TypeContents {\n         let tc = TypeContents::nonimplicitly_copyable(cx);\n-        tc + TC_BIG + TC_OWNED_SLICE // disregard cx.vecs_implicitly_copyable\n+        tc + TC_BIG + TC_OWNED_VEC // disregard cx.vecs_implicitly_copyable\n+    }\n+\n+    fn needs_drop(&self, cx: ctxt) -> bool {\n+        let tc = TC_MANAGED + TC_DTOR + TypeContents::owned(cx);\n+        self.intersects(tc)\n+    }\n+\n+    static fn owned(&self, _cx: ctxt) -> TypeContents {\n+        //! Any kind of owned contents.\n+        TC_OWNED_CLOSURE + TC_OWNED_POINTER + TC_OWNED_VEC\n     }\n }\n \n@@ -1859,8 +1795,8 @@ const TC_BORROWED_POINTER: TypeContents = TypeContents{bits:0b0000_00000001};\n /// Contains an owned pointer (~T) but not slice of some kind\n const TC_OWNED_POINTER: TypeContents =    TypeContents{bits:0b000000000010};\n \n-/// Contains an owned slice\n-const TC_OWNED_SLICE: TypeContents =      TypeContents{bits:0b000000000100};\n+/// Contains an owned vector ~[] or owned string ~str\n+const TC_OWNED_VEC: TypeContents =        TypeContents{bits:0b000000000100};\n \n /// Contains a ~fn() or a ~Trait, which is non-copyable.\n const TC_OWNED_CLOSURE: TypeContents =    TypeContents{bits:0b000000001000};\n@@ -1963,7 +1899,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             }\n \n             ty_estr(vstore_uniq) => {\n-                TC_OWNED_SLICE\n+                TC_OWNED_VEC\n             }\n \n             ty_closure(ref c) => {\n@@ -1996,7 +1932,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             }\n \n             ty_evec(mt, vstore_uniq) => {\n-                TC_OWNED_SLICE + tc_mt(cx, mt, cache)\n+                TC_OWNED_VEC + tc_mt(cx, mt, cache)\n             }\n \n             ty_evec(mt, vstore_box) => {"}]}