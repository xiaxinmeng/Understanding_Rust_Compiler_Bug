{"sha": "ef37cfdeccbdf8151129d2d182a568d7310754c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMzdjZmRlY2NiZGY4MTUxMTI5ZDJkMTgyYTU2OGQ3MzEwNzU0YzE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-04-07T21:00:19Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-08T07:03:11Z"}, "message": "std: Add more docs for ptr mod", "tree": {"sha": "f40815cc8d02bbd26fc47338cc9ae4ddf687f350", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f40815cc8d02bbd26fc47338cc9ae4ddf687f350"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef37cfdeccbdf8151129d2d182a568d7310754c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef37cfdeccbdf8151129d2d182a568d7310754c1", "html_url": "https://github.com/rust-lang/rust/commit/ef37cfdeccbdf8151129d2d182a568d7310754c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef37cfdeccbdf8151129d2d182a568d7310754c1/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3ea3e439fbc5251279d914a95cd8344556982cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3ea3e439fbc5251279d914a95cd8344556982cb", "html_url": "https://github.com/rust-lang/rust/commit/c3ea3e439fbc5251279d914a95cd8344556982cb"}], "stats": {"total": 235, "additions": 182, "deletions": 53}, "files": [{"sha": "19eee8755a0cc185c7ed2be7478e82fa744a401c", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 182, "deletions": 53, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/ef37cfdeccbdf8151129d2d182a568d7310754c1/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef37cfdeccbdf8151129d2d182a568d7310754c1/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=ef37cfdeccbdf8151129d2d182a568d7310754c1", "patch": "@@ -8,7 +8,87 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Unsafe pointer utility functions\n+//! Conveniences for working with unsafe pointers, the `*T`, and `*mut T` types.\n+//!\n+//! Working with unsafe pointers in Rust is fairly uncommon,\n+//! and often limited to some narrow use cases: holding\n+//! an unsafe pointer when safe pointers are unsuitable;\n+//! checking for null; and converting back to safe pointers.\n+//! As a result, there is not yet an abundance of library code\n+//! for working with unsafe poniters, and in particular,\n+//! since pointer math is fairly uncommon in Rust, it is not\n+//! all that convenient.\n+//!\n+//! Use the [`null` function](fn.null.html) to create null pointers,\n+//! the [`is_null`](trait.RawPtr.html#tymethod.is_null)\n+//! and [`is_not_null`](trait.RawPtr.html#method.is_not_null)\n+//! methods of the [`RawPtr` trait](trait.RawPtr.html) to check for null.\n+//! The `RawPtr` trait is imported by the prelude, so `is_null` etc.\n+//! work everywhere.\n+//!\n+//! # Common ways to create unsafe pointers\n+//!\n+//! ## 1. Coerce a reference (`&T`) or mutable reference (`&mut T`).\n+//!\n+//! ```\n+//! let my_num: int = 10;\n+//! let my_num_ptr: *int = &my_num;\n+//! let mut my_speed: int = 88;\n+//! let my_speed_ptr: *mut int = &mut my_speed;\n+//! ```\n+//!\n+//! This does not take ownership of the original allocation\n+//! and requires no resource management later,\n+//! but you must not use the pointer after its lifetime.\n+//!\n+//! ## 2. Transmute an owned box (`~T`).\n+//!\n+//! The `transmute` function takes, by value, whatever it's given\n+//! and returns it as whatever type is requested, as long as the\n+//! types are the same size. Because `~T` and `*T` have the same\n+//! representation they can be trivially,\n+//! though unsafely, transformed from one type to the other.\n+//!\n+//! ```\n+//! use std::cast;\n+//!\n+//! unsafe {\n+//!     let my_num: ~int = ~10;\n+//!     let my_num: *int = cast::transmute(my_num);\n+//!     let my_speed: ~int = ~88;\n+//!     let my_speed: *mut int = cast::transmute(my_speed);\n+//!\n+//!     // By taking ownership of the original `~T` though\n+//!     // we are obligated to transmute it back later to be destroyed.\n+//!     drop(cast::transmute::<_, ~int>(my_speed));\n+//!     drop(cast::transmute::<_, ~int>(my_num));\n+//! }\n+//! ```\n+//!\n+//! Note that here the call to `drop` is for clarity - it indicates\n+//! that we are done with the given value and it should be destroyed.\n+//!\n+//! ## 3. Get it from C.\n+//!\n+//! ```\n+//! extern crate libc;\n+//!\n+//! use std::mem;\n+//!\n+//! fn main() {\n+//!     unsafe {\n+//!         let my_num: *mut int = libc::malloc(mem::size_of::<int>() as libc::size_t) as *mut int;\n+//!         if my_num.is_null() {\n+//!             fail!(\"failed to allocate memory\");\n+//!         }\n+//!         libc::free(my_num as *mut libc::c_void);\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! Usually you wouldn't literally use `malloc` and `free` from Rust,\n+//! but C APIs hand out a lot of pointers generally, so are a common source\n+//! of unsafe pointers in Rust.\n \n use cast;\n use clone::Clone;\n@@ -51,59 +131,119 @@ pub unsafe fn position<T>(buf: *T, f: |&T| -> bool) -> uint {\n     }\n }\n \n-/// Create an unsafe null pointer\n+/// Create an null pointer.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// let p: *int = ptr::null();\n+/// assert!(p.is_null());\n+/// ```\n #[inline]\n pub fn null<T>() -> *T { 0 as *T }\n \n-/// Create an unsafe mutable null pointer\n+/// Create an unsafe mutable null pointer.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::ptr;\n+///\n+/// let p: *mut int = ptr::mut_null();\n+/// assert!(p.is_null());\n+/// ```\n #[inline]\n pub fn mut_null<T>() -> *mut T { 0 as *mut T }\n \n-/**\n- * Copies data from one location to another.\n- *\n- * Copies `count` elements (not bytes) from `src` to `dst`. The source\n- * and destination may overlap.\n- */\n+/// Copies data from one location to another.\n+///\n+/// Copies `count` elements (not bytes) from `src` to `dst`. The source\n+/// and destination may overlap.\n+///\n+/// `copy_memory` is semantically equivalent to C's `memmove`.\n+///\n+/// # Example\n+///\n+/// Efficiently create a Rust vector from an unsafe buffer:\n+///\n+/// ```\n+/// use std::ptr;\n+/// use std::slice;\n+///\n+/// unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> ~[T] {\n+///     let mut dst = slice::with_capacity(elts);\n+///     dst.set_len(elts);\n+///     ptr::copy_memory(dst.as_mut_ptr(), ptr, elts);\n+///     dst\n+/// }\n+/// ```\n+///\n #[inline]\n pub unsafe fn copy_memory<T>(dst: *mut T, src: *T, count: uint) {\n     intrinsics::copy_memory(dst, src, count)\n }\n \n-/**\n- * Copies data from one location to another.\n- *\n- * Copies `count` elements (not bytes) from `src` to `dst`. The source\n- * and destination may *not* overlap.\n- */\n+/// Copies data from one location to another.\n+///\n+/// Copies `count` elements (not bytes) from `src` to `dst`. The source\n+/// and destination may *not* overlap.\n+///\n+/// `copy_nonoverlapping_memory` is semantically equivalent to C's `memcpy`.\n+///\n+/// # Example\n+///\n+/// A safe swap function:\n+///\n+/// ```\n+/// use std::cast;\n+/// use std::mem;\n+/// use std::ptr;\n+///\n+/// fn swap<T>(x: &mut T, y: &mut T) {\n+///     unsafe {\n+///         // Give ourselves some scratch space to work with\n+///         let mut t: T = mem::uninit();\n+///\n+///         // Perform the swap, `&mut` pointers never alias\n+///         ptr::copy_nonoverlapping_memory(&mut t, &*x, 1);\n+///         ptr::copy_nonoverlapping_memory(x, &*y, 1);\n+///         ptr::copy_nonoverlapping_memory(y, &t, 1);\n+///\n+///         // y and t now point to the same thing, but we need to completely forget `tmp`\n+///         // because it's no longer relevant.\n+///         cast::forget(t);\n+///     }\n+/// }\n+/// ```\n+///\n+/// # Safety Note\n+///\n+/// If the source and destination overlap then the behavior of this\n+/// function is undefined.\n #[inline]\n pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T,\n                                             src: *T,\n                                             count: uint) {\n     intrinsics::copy_nonoverlapping_memory(dst, src, count)\n }\n \n-/**\n- * Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n- * bytes of memory starting at `dst` to `c`.\n- */\n+/// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n+/// bytes of memory starting at `dst` to `c`.\n #[inline]\n pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) {\n     intrinsics::set_memory(dst, c, count)\n }\n \n-/**\n- * Zeroes out `count * size_of::<T>` bytes of memory at `dst`\n- */\n+/// Zeroes out `count * size_of::<T>` bytes of memory at `dst`\n #[inline]\n pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n     set_memory(dst, 0, count);\n }\n \n-/**\n- * Swap the values at two mutable locations of the same type, without\n- * deinitialising either. They may overlap.\n- */\n+/// Swap the values at two mutable locations of the same type, without\n+/// deinitialising either. They may overlap.\n #[inline]\n pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     // Give ourselves some scratch space to work with\n@@ -120,30 +260,24 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     cast::forget(tmp);\n }\n \n-/**\n- * Replace the value at a mutable location with a new one, returning the old\n- * value, without deinitialising either.\n- */\n+/// Replace the value at a mutable location with a new one, returning the old\n+/// value, without deinitialising either.\n #[inline]\n pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n     mem::swap(cast::transmute(dest), &mut src); // cannot overlap\n     src\n }\n \n-/**\n- * Reads the value from `*src` and returns it.\n- */\n+/// Reads the value from `*src` and returns it.\n #[inline(always)]\n pub unsafe fn read<T>(src: *T) -> T {\n     let mut tmp: T = mem::uninit();\n     copy_nonoverlapping_memory(&mut tmp, src, 1);\n     tmp\n }\n \n-/**\n- * Reads the value from `*src` and nulls it out.\n- * This currently prevents destructors from executing.\n- */\n+/// Reads the value from `*src` and nulls it out.\n+/// This currently prevents destructors from executing.\n #[inline(always)]\n pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     // Copy the data out from `dest`:\n@@ -155,13 +289,9 @@ pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     tmp\n }\n \n-/**\n-  Given a **T (pointer to an array of pointers),\n-  iterate through each *T, up to the provided `len`,\n-  passing to the provided callback function\n-\n-  SAFETY NOTE: Pointer-arithmetic. Dragons be here.\n-*/\n+/// Given a **T (pointer to an array of pointers),\n+/// iterate through each *T, up to the provided `len`,\n+/// passing to the provided callback function\n pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: |*T|) {\n     if arr.is_null() {\n         fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n@@ -173,15 +303,14 @@ pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: |*T|) {\n     }\n }\n \n-/**\n-  Given a null-pointer-terminated **T (pointer to\n-  an array of pointers), iterate through each *T,\n-  passing to the provided callback function\n-\n-  SAFETY NOTE: This will only work with a null-terminated\n-  pointer array. Barely less-dodgy Pointer Arithmetic.\n-  Dragons be here.\n-*/\n+/// Given a null-pointer-terminated **T (pointer to\n+/// an array of pointers), iterate through each *T,\n+/// passing to the provided callback function\n+///\n+/// # Safety Note\n+///\n+/// This will only work with a null-terminated\n+/// pointer array.\n pub unsafe fn array_each<T>(arr: **T, cb: |*T|) {\n     if arr.is_null()  {\n         fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");"}]}