{"sha": "bba9785dd73f61aacd301a2cb379e1e85a129047", "node_id": "C_kwDOAAsO6NoAKGJiYTk3ODVkZDczZjYxYWFjZDMwMWEyY2IzNzllMWU4NWExMjkwNDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-08T11:53:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-08T11:53:25Z"}, "message": "Auto merge of #100720 - camsteffen:representable, r=cjgillot\n\nRewrite representability\n\n * Improve placement of `Box` in the suggestion\n * Multiple items in a cycle emit 1 error instead of an error for each item in the cycle\n * Introduce `representability` query to avoid traversing an item every time it is used.\n * Also introduce `params_in_repr` query to avoid traversing generic items every time it is used.", "tree": {"sha": "1325e86a86ce101c60353107590ac9f990a3e41c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1325e86a86ce101c60353107590ac9f990a3e41c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bba9785dd73f61aacd301a2cb379e1e85a129047", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bba9785dd73f61aacd301a2cb379e1e85a129047", "html_url": "https://github.com/rust-lang/rust/commit/bba9785dd73f61aacd301a2cb379e1e85a129047", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bba9785dd73f61aacd301a2cb379e1e85a129047/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a688a0305fad9219505a8f2576446510601bafe8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a688a0305fad9219505a8f2576446510601bafe8", "html_url": "https://github.com/rust-lang/rust/commit/a688a0305fad9219505a8f2576446510601bafe8"}, {"sha": "ff940db666daeae83c6c71685901c6c14df17018", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff940db666daeae83c6c71685901c6c14df17018", "html_url": "https://github.com/rust-lang/rust/commit/ff940db666daeae83c6c71685901c6c14df17018"}], "stats": {"total": 1265, "additions": 529, "deletions": 736}, "files": [{"sha": "3b8d0d87f2a9cd60f4105aad3559919f3e1870df", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -3552,7 +3552,6 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n- \"rustc_ty_utils\",\n  \"rustc_type_ir\",\n  \"smallvec\",\n  \"tracing\","}, {"sha": "0761d8cdbd8f641da9510c74fb0dc69871624256", "filename": "compiler/rustc_hir_analysis/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_hir_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_hir_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2FCargo.toml?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -26,7 +26,6 @@ rustc_span = { path = \"../rustc_span\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_infer = { path = \"../rustc_infer\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n-rustc_ty_utils = { path = \"../rustc_ty_utils\" }\n rustc_lint = { path = \"../rustc_lint\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_type_ir = { path = \"../rustc_type_ir\" }"}, {"sha": "fea02d2356c60017013fc01833680e4e3013ddc1", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 3, "deletions": 25, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -31,7 +31,6 @@ use rustc_span::{self, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCtxt};\n-use rustc_ty_utils::representability::{self, Representability};\n \n use std::ops::ControlFlow;\n \n@@ -381,7 +380,7 @@ fn check_struct(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let def = tcx.adt_def(def_id);\n     let span = tcx.def_span(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n-    check_representable(tcx, span, def_id);\n+    let _ = tcx.representability(def_id);\n \n     if def.repr().simd() {\n         check_simd(tcx, span, def_id);\n@@ -395,7 +394,7 @@ fn check_union(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let def = tcx.adt_def(def_id);\n     let span = tcx.def_span(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n-    check_representable(tcx, span, def_id);\n+    let _ = tcx.representability(def_id);\n     check_transparent(tcx, span, def);\n     check_union_fields(tcx, span, def_id);\n     check_packed(tcx, span, def);\n@@ -1151,27 +1150,6 @@ fn check_impl_items_against_trait<'tcx>(\n     }\n }\n \n-/// Checks whether a type can be represented in memory. In particular, it\n-/// identifies types that contain themselves without indirection through a\n-/// pointer, which would mean their size is unbounded.\n-pub(super) fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: LocalDefId) -> bool {\n-    let rty = tcx.type_of(item_def_id);\n-\n-    // Check that it is possible to represent this type. This call identifies\n-    // (1) types that contain themselves and (2) types that contain a different\n-    // recursive type. It is only necessary to throw an error on those that\n-    // contain themselves. For case 2, there must be an inner type that will be\n-    // caught by case 1.\n-    match representability::ty_is_representable(tcx, rty, sp, None) {\n-        Representability::SelfRecursive(spans) => {\n-            recursive_type_with_infinite_size_error(tcx, item_def_id.to_def_id(), spans);\n-            return false;\n-        }\n-        Representability::Representable | Representability::ContainsRecursive => (),\n-    }\n-    true\n-}\n-\n pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: LocalDefId) {\n     let t = tcx.type_of(def_id);\n     if let ty::Adt(def, substs) = t.kind()\n@@ -1509,7 +1487,7 @@ fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, vs: &'tcx [hir::Variant<'tcx>], def_id: L\n \n     detect_discriminant_duplicate(tcx, def.discriminants(tcx).collect(), vs, sp);\n \n-    check_representable(tcx, sp, def_id);\n+    let _ = tcx.representability(def_id);\n     check_transparent(tcx, sp, def);\n }\n "}, {"sha": "331bd7e26c858ed56c744477cf273eb4334f3878", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -123,7 +123,6 @@ use rustc_span::{self, BytePos, Span, Symbol};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n-use rustc_trait_selection::traits::error_reporting::recursive_type_with_infinite_size_error;\n use rustc_trait_selection::traits::error_reporting::suggestions::ReturnsVisitor;\n use std::cell::RefCell;\n use std::num::NonZeroU32;"}, {"sha": "aa54b3d8ac2bc058cc91b773f86db57130000014", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -25,6 +25,9 @@ macro_rules! pluralize {\n     ($x:expr) => {\n         if $x != 1 { \"s\" } else { \"\" }\n     };\n+    (\"has\", $x:expr) => {\n+        if $x == 1 { \"has\" } else { \"have\" }\n+    };\n     (\"is\", $x:expr) => {\n         if $x == 1 { \"is\" } else { \"are\" }\n     };"}, {"sha": "c4dff8b3f48ed476f3fdc5f55634e5d9cb0cf4bb", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -210,6 +210,7 @@ provide! { tcx, def_id, other, cdata,\n     lookup_const_stability => { table }\n     lookup_default_body_stability => { table }\n     lookup_deprecation_entry => { table }\n+    params_in_repr => { table }\n     unused_generic_params => { table }\n     opt_def_kind => { table_direct }\n     impl_parent => { table }"}, {"sha": "3fc10197b91292fcf8f18317097df179b917fc68", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -1156,6 +1156,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             if let DefKind::Trait | DefKind::TraitAlias = def_kind {\n                 record!(self.tables.super_predicates_of[def_id] <- self.tcx.super_predicates_of(def_id));\n             }\n+            if let DefKind::Enum | DefKind::Struct | DefKind::Union = def_kind {\n+                let params_in_repr = self.tcx.params_in_repr(def_id);\n+                record!(self.tables.params_in_repr[def_id] <- params_in_repr);\n+            }\n             if should_encode_trait_impl_trait_tys(tcx, def_id)\n                 && let Ok(table) = self.tcx.collect_trait_impl_trait_tys(def_id)\n             {"}, {"sha": "a509ecdf7591baf52a45eccc69490282d038f5f4", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -13,7 +13,8 @@ use rustc_hir::def::{CtorKind, DefKind};\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, DefPathHash, StableCrateId};\n use rustc_hir::definitions::DefKey;\n use rustc_hir::lang_items;\n-use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n+use rustc_index::bit_set::{BitSet, FiniteBitSet};\n+use rustc_index::vec::IndexVec;\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n@@ -383,6 +384,7 @@ define_tables! {\n     inherent_impls: Table<DefIndex, LazyArray<DefIndex>>,\n     expn_that_defined: Table<DefIndex, LazyValue<ExpnId>>,\n     unused_generic_params: Table<DefIndex, LazyValue<FiniteBitSet<u32>>>,\n+    params_in_repr: Table<DefIndex, LazyValue<BitSet<u32>>>,\n     repr_options: Table<DefIndex, LazyValue<ReprOptions>>,\n     // `def_keys` and `def_path_hashes` represent a lazy version of a\n     // `DefPathTable`. This allows us to avoid deserializing an entire"}, {"sha": "d2847e4bc12a7093dcaf06b02698dfc396de413a", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -103,6 +103,7 @@ macro_rules! arena_types {\n             [] dep_kind: rustc_middle::dep_graph::DepKindStruct<'tcx>,\n \n             [decode] trait_impl_trait_tys: rustc_data_structures::fx::FxHashMap<rustc_hir::def_id::DefId, rustc_middle::ty::Ty<'tcx>>,\n+            [] bit_set_u32: rustc_index::bit_set::BitSet<u32>,\n         ]);\n     )\n }"}, {"sha": "a175b1eb467339e952f50cdb2b5657dd80036001", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -301,6 +301,32 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n+    /// Checks whether a type is representable or infinitely sized\n+    query representability(_: LocalDefId) -> rustc_middle::ty::Representability {\n+        desc { \"checking if {:?} is representable\", tcx.def_path_str(key.to_def_id()) }\n+        // infinitely sized types will cause a cycle\n+        cycle_delay_bug\n+        // we don't want recursive representability calls to be forced with\n+        // incremental compilation because, if a cycle occurs, we need the\n+        // entire cycle to be in memory for diagnostics\n+        anon\n+    }\n+\n+    /// An implementation detail for the `representability` query\n+    query representability_adt_ty(_: Ty<'tcx>) -> rustc_middle::ty::Representability {\n+        desc { \"checking if {:?} is representable\", key }\n+        cycle_delay_bug\n+        anon\n+    }\n+\n+    /// Set of param indexes for type params that are in the type's representation\n+    query params_in_repr(key: DefId) -> rustc_index::bit_set::BitSet<u32> {\n+        desc { \"finding type parameters in the representation\" }\n+        arena_cache\n+        no_hash\n+        separate_provide_extern\n+    }\n+\n     /// Fetch the THIR for a given body. If typeck for that body failed, returns an empty `Thir`.\n     query thir_body(key: ty::WithOptConstParam<LocalDefId>)\n         -> Result<(&'tcx Steal<thir::Thir<'tcx>>, thir::ExprId), ErrorGuaranteed>"}, {"sha": "80bbc8e630e02ab7d19ed3acc8f9cdf0d831ca93", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -566,3 +566,10 @@ impl<'tcx> AdtDef<'tcx> {\n         ty::EarlyBinder(tcx.adt_sized_constraint(self.did()).0)\n     }\n }\n+\n+#[derive(Clone, Copy, Debug)]\n+#[derive(HashStable)]\n+pub enum Representability {\n+    Representable,\n+    Infinite,\n+}"}, {"sha": "f289f2265a287a4169e7e03fe4bdd95aace88363", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -82,6 +82,7 @@ trivially_parameterized_over_tcx! {\n     rustc_hir::def::DefKind,\n     rustc_hir::def_id::DefIndex,\n     rustc_hir::definitions::DefKey,\n+    rustc_index::bit_set::BitSet<u32>,\n     rustc_index::bit_set::FiniteBitSet<u32>,\n     rustc_session::cstore::ForeignModule,\n     rustc_session::cstore::LinkagePreference,"}, {"sha": "bb89959b29dedabcb5db1d52869d1db5ace509d6", "filename": "compiler/rustc_middle/src/values.rs", "status": "modified", "additions": 165, "deletions": 5, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -1,16 +1,26 @@\n-use rustc_middle::ty::{self, AdtSizedConstraint, Ty, TyCtxt};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::{pluralize, struct_span_err, Applicability, MultiSpan};\n+use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n+use rustc_middle::ty::Representability;\n+use rustc_middle::ty::{self, AdtSizedConstraint, DefIdTree, Ty, TyCtxt};\n+use rustc_query_system::query::QueryInfo;\n use rustc_query_system::Value;\n+use rustc_span::def_id::LocalDefId;\n+use rustc_span::Span;\n+\n+use std::fmt::Write;\n \n impl<'tcx> Value<TyCtxt<'tcx>> for Ty<'_> {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>, _: &[QueryInfo]) -> Self {\n         // SAFETY: This is never called when `Self` is not `Ty<'tcx>`.\n         // FIXME: Represent the above fact in the trait system somehow.\n         unsafe { std::mem::transmute::<Ty<'tcx>, Ty<'_>>(tcx.ty_error()) }\n     }\n }\n \n impl<'tcx> Value<TyCtxt<'tcx>> for ty::SymbolName<'_> {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>, _: &[QueryInfo]) -> Self {\n         // SAFETY: This is never called when `Self` is not `SymbolName<'tcx>`.\n         // FIXME: Represent the above fact in the trait system somehow.\n         unsafe {\n@@ -22,7 +32,7 @@ impl<'tcx> Value<TyCtxt<'tcx>> for ty::SymbolName<'_> {\n }\n \n impl<'tcx> Value<TyCtxt<'tcx>> for AdtSizedConstraint<'_> {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>, _: &[QueryInfo]) -> Self {\n         // SAFETY: This is never called when `Self` is not `AdtSizedConstraint<'tcx>`.\n         // FIXME: Represent the above fact in the trait system somehow.\n         unsafe {\n@@ -34,7 +44,7 @@ impl<'tcx> Value<TyCtxt<'tcx>> for AdtSizedConstraint<'_> {\n }\n \n impl<'tcx> Value<TyCtxt<'tcx>> for ty::Binder<'_, ty::FnSig<'_>> {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>, _: &[QueryInfo]) -> Self {\n         let err = tcx.ty_error();\n         // FIXME(compiler-errors): It would be nice if we could get the\n         // query key, so we could at least generate a fn signature that\n@@ -52,3 +62,153 @@ impl<'tcx> Value<TyCtxt<'tcx>> for ty::Binder<'_, ty::FnSig<'_>> {\n         unsafe { std::mem::transmute::<ty::PolyFnSig<'tcx>, ty::Binder<'_, ty::FnSig<'_>>>(fn_sig) }\n     }\n }\n+\n+impl<'tcx> Value<TyCtxt<'tcx>> for Representability {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>, cycle: &[QueryInfo]) -> Self {\n+        let mut item_and_field_ids = Vec::new();\n+        let mut representable_ids = FxHashSet::default();\n+        for info in cycle {\n+            if info.query.name == \"representability\"\n+                && let Some(field_id) = info.query.def_id\n+                && let Some(field_id) = field_id.as_local()\n+                && let Some(DefKind::Field) = info.query.def_kind\n+            {\n+                let parent_id = tcx.parent(field_id.to_def_id());\n+                let item_id = match tcx.def_kind(parent_id) {\n+                    DefKind::Variant => tcx.parent(parent_id),\n+                    _ => parent_id,\n+                };\n+                item_and_field_ids.push((item_id.expect_local(), field_id));\n+            }\n+        }\n+        for info in cycle {\n+            if info.query.name == \"representability_adt_ty\"\n+                && let Some(def_id) = info.query.ty_adt_id\n+                && let Some(def_id) = def_id.as_local()\n+                && !item_and_field_ids.iter().any(|&(id, _)| id == def_id)\n+            {\n+                representable_ids.insert(def_id);\n+            }\n+        }\n+        recursive_type_error(tcx, item_and_field_ids, &representable_ids);\n+        Representability::Infinite\n+    }\n+}\n+\n+// item_and_field_ids should form a cycle where each field contains the\n+// type in the next element in the list\n+pub fn recursive_type_error(\n+    tcx: TyCtxt<'_>,\n+    mut item_and_field_ids: Vec<(LocalDefId, LocalDefId)>,\n+    representable_ids: &FxHashSet<LocalDefId>,\n+) {\n+    const ITEM_LIMIT: usize = 5;\n+\n+    // Rotate the cycle so that the item with the lowest span is first\n+    let start_index = item_and_field_ids\n+        .iter()\n+        .enumerate()\n+        .min_by_key(|&(_, &(id, _))| tcx.def_span(id))\n+        .unwrap()\n+        .0;\n+    item_and_field_ids.rotate_left(start_index);\n+\n+    let cycle_len = item_and_field_ids.len();\n+    let show_cycle_len = cycle_len.min(ITEM_LIMIT);\n+\n+    let mut err_span = MultiSpan::from_spans(\n+        item_and_field_ids[..show_cycle_len]\n+            .iter()\n+            .map(|(id, _)| tcx.def_span(id.to_def_id()))\n+            .collect(),\n+    );\n+    let mut suggestion = Vec::with_capacity(show_cycle_len * 2);\n+    for i in 0..show_cycle_len {\n+        let (_, field_id) = item_and_field_ids[i];\n+        let (next_item_id, _) = item_and_field_ids[(i + 1) % cycle_len];\n+        // Find the span(s) that contain the next item in the cycle\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(field_id);\n+        let hir::Node::Field(field) = tcx.hir().get(hir_id) else { bug!(\"expected field\") };\n+        let mut found = Vec::new();\n+        find_item_ty_spans(tcx, field.ty, next_item_id, &mut found, representable_ids);\n+\n+        // Couldn't find the type. Maybe it's behind a type alias?\n+        // In any case, we'll just suggest boxing the whole field.\n+        if found.is_empty() {\n+            found.push(field.ty.span);\n+        }\n+\n+        for span in found {\n+            err_span.push_span_label(span, \"recursive without indirection\");\n+            // FIXME(compiler-errors): This suggestion might be erroneous if Box is shadowed\n+            suggestion.push((span.shrink_to_lo(), \"Box<\".to_string()));\n+            suggestion.push((span.shrink_to_hi(), \">\".to_string()));\n+        }\n+    }\n+    let items_list = {\n+        let mut s = String::new();\n+        for (i, (item_id, _)) in item_and_field_ids.iter().enumerate() {\n+            let path = tcx.def_path_str(item_id.to_def_id());\n+            write!(&mut s, \"`{path}`\").unwrap();\n+            if i == (ITEM_LIMIT - 1) && cycle_len > ITEM_LIMIT {\n+                write!(&mut s, \" and {} more\", cycle_len - 5).unwrap();\n+                break;\n+            }\n+            if cycle_len > 1 && i < cycle_len - 2 {\n+                s.push_str(\", \");\n+            } else if cycle_len > 1 && i == cycle_len - 2 {\n+                s.push_str(\" and \")\n+            }\n+        }\n+        s\n+    };\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        err_span,\n+        E0072,\n+        \"recursive type{} {} {} infinite size\",\n+        pluralize!(cycle_len),\n+        items_list,\n+        pluralize!(\"has\", cycle_len),\n+    );\n+    err.multipart_suggestion(\n+        \"insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\",\n+        suggestion,\n+        Applicability::HasPlaceholders,\n+    );\n+    err.emit();\n+}\n+\n+fn find_item_ty_spans(\n+    tcx: TyCtxt<'_>,\n+    ty: &hir::Ty<'_>,\n+    needle: LocalDefId,\n+    spans: &mut Vec<Span>,\n+    seen_representable: &FxHashSet<LocalDefId>,\n+) {\n+    match ty.kind {\n+        hir::TyKind::Path(hir::QPath::Resolved(_, path)) => {\n+            if let Some(def_id) = path.res.opt_def_id() {\n+                let check_params = def_id.as_local().map_or(true, |def_id| {\n+                    if def_id == needle {\n+                        spans.push(ty.span);\n+                    }\n+                    seen_representable.contains(&def_id)\n+                });\n+                if check_params && let Some(args) = path.segments.last().unwrap().args {\n+                    let params_in_repr = tcx.params_in_repr(def_id);\n+                    for (i, arg) in args.args.iter().enumerate() {\n+                        if let hir::GenericArg::Type(ty) = arg && params_in_repr.contains(i as u32) {\n+                            find_item_ty_spans(tcx, ty, needle, spans, seen_representable);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        hir::TyKind::Array(ty, _) => find_item_ty_spans(tcx, ty, needle, spans, seen_representable),\n+        hir::TyKind::Tup(tys) => {\n+            tys.iter().for_each(|ty| find_item_ty_spans(tcx, ty, needle, spans, seen_representable))\n+        }\n+        _ => {}\n+    }\n+}"}, {"sha": "8be2e2be86b589667e91fd4bcd1846763119a747", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -27,6 +27,10 @@ pub trait Key {\n     fn key_as_def_id(&self) -> Option<DefId> {\n         None\n     }\n+\n+    fn ty_adt_id(&self) -> Option<DefId> {\n+        None\n+    }\n }\n \n impl Key for () {\n@@ -407,6 +411,12 @@ impl<'tcx> Key for Ty<'tcx> {\n     fn default_span(&self, _: TyCtxt<'_>) -> Span {\n         DUMMY_SP\n     }\n+    fn ty_adt_id(&self) -> Option<DefId> {\n+        match self.kind() {\n+            ty::Adt(adt, _) => Some(adt.did()),\n+            _ => None,\n+        }\n+    }\n }\n \n impl<'tcx> Key for TyAndLayout<'tcx> {"}, {"sha": "aaeaa3bd51d63b0b3a56db4405b49b9a4c4bc024", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -318,13 +318,12 @@ pub(crate) fn create_query_frame<\n     } else {\n         Some(key.default_span(*tcx))\n     };\n+    let def_id = key.key_as_def_id();\n     let def_kind = if kind == dep_graph::DepKind::opt_def_kind {\n         // Try to avoid infinite recursion.\n         None\n     } else {\n-        key.key_as_def_id()\n-            .and_then(|def_id| def_id.as_local())\n-            .and_then(|def_id| tcx.opt_def_kind(def_id))\n+        def_id.and_then(|def_id| def_id.as_local()).and_then(|def_id| tcx.opt_def_kind(def_id))\n     };\n     let hash = || {\n         tcx.with_stable_hashing_context(|mut hcx| {\n@@ -334,8 +333,9 @@ pub(crate) fn create_query_frame<\n             hasher.finish::<u64>()\n         })\n     };\n+    let ty_adt_id = key.ty_adt_id();\n \n-    QueryStackFrame::new(name, description, span, def_kind, hash)\n+    QueryStackFrame::new(name, description, span, def_id, def_kind, ty_adt_id, hash)\n }\n \n fn try_load_from_on_disk_cache<'tcx, Q>(tcx: TyCtxt<'tcx>, dep_node: DepNode)"}, {"sha": "ed65393f57e4da59cd1c37d7b85536adbc41a553", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -551,7 +551,7 @@ pub fn deadlock(query_map: QueryMap, registry: &rayon_core::Registry) {\n #[cold]\n pub(crate) fn report_cycle<'a>(\n     sess: &'a Session,\n-    CycleError { usage, cycle: stack }: CycleError,\n+    CycleError { usage, cycle: stack }: &CycleError,\n ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n     assert!(!stack.is_empty());\n \n@@ -569,10 +569,10 @@ pub(crate) fn report_cycle<'a>(\n     }\n \n     let mut cycle_usage = None;\n-    if let Some((span, query)) = usage {\n+    if let Some((span, ref query)) = *usage {\n         cycle_usage = Some(crate::error::CycleUsage {\n             span: query.default_span(span),\n-            usage: query.description,\n+            usage: query.description.to_string(),\n         });\n     }\n "}, {"sha": "118703fc0d48c408392a19683ab281bc0b7a993c", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -18,6 +18,7 @@ use crate::dep_graph::{DepNodeIndex, HasDepContext, SerializedDepNodeIndex};\n use rustc_data_structures::sync::Lock;\n use rustc_errors::Diagnostic;\n use rustc_hir::def::DefKind;\n+use rustc_span::def_id::DefId;\n use rustc_span::Span;\n use thin_vec::ThinVec;\n \n@@ -29,7 +30,9 @@ pub struct QueryStackFrame {\n     pub name: &'static str,\n     pub description: String,\n     span: Option<Span>,\n-    def_kind: Option<DefKind>,\n+    pub def_id: Option<DefId>,\n+    pub def_kind: Option<DefKind>,\n+    pub ty_adt_id: Option<DefId>,\n     /// This hash is used to deterministically pick\n     /// a query to remove cycles in the parallel compiler.\n     #[cfg(parallel_compiler)]\n@@ -42,14 +45,18 @@ impl QueryStackFrame {\n         name: &'static str,\n         description: String,\n         span: Option<Span>,\n+        def_id: Option<DefId>,\n         def_kind: Option<DefKind>,\n+        ty_adt_id: Option<DefId>,\n         _hash: impl FnOnce() -> u64,\n     ) -> Self {\n         Self {\n             name,\n             description,\n             span,\n+            def_id,\n             def_kind,\n+            ty_adt_id,\n             #[cfg(parallel_compiler)]\n             hash: _hash(),\n         }"}, {"sha": "15b89daa6db11162770a48d0e9ed0565f45d4c98", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -119,7 +119,7 @@ where\n #[inline(never)]\n fn mk_cycle<CTX, V, R>(\n     tcx: CTX,\n-    error: CycleError,\n+    cycle_error: CycleError,\n     handler: HandleCycleError,\n     cache: &dyn crate::query::QueryStorage<Value = V, Stored = R>,\n ) -> R\n@@ -128,13 +128,14 @@ where\n     V: std::fmt::Debug + Value<CTX::DepContext>,\n     R: Clone,\n {\n-    let error = report_cycle(tcx.dep_context().sess(), error);\n-    let value = handle_cycle_error(*tcx.dep_context(), error, handler);\n+    let error = report_cycle(tcx.dep_context().sess(), &cycle_error);\n+    let value = handle_cycle_error(*tcx.dep_context(), &cycle_error, error, handler);\n     cache.store_nocache(value)\n }\n \n fn handle_cycle_error<CTX, V>(\n     tcx: CTX,\n+    cycle_error: &CycleError,\n     mut error: DiagnosticBuilder<'_, ErrorGuaranteed>,\n     handler: HandleCycleError,\n ) -> V\n@@ -146,7 +147,7 @@ where\n     match handler {\n         Error => {\n             error.emit();\n-            Value::from_cycle_error(tcx)\n+            Value::from_cycle_error(tcx, &cycle_error.cycle)\n         }\n         Fatal => {\n             error.emit();\n@@ -155,7 +156,7 @@ where\n         }\n         DelayBug => {\n             error.delay_as_bug();\n-            Value::from_cycle_error(tcx)\n+            Value::from_cycle_error(tcx, &cycle_error.cycle)\n         }\n     }\n }"}, {"sha": "67fbf14e6129985d1e7cf346ffdde80f6f5d67ab", "filename": "compiler/rustc_query_system/src/values.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_query_system%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_query_system%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fvalues.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -1,11 +1,12 @@\n use crate::dep_graph::DepContext;\n+use crate::query::QueryInfo;\n \n pub trait Value<CTX: DepContext>: Sized {\n-    fn from_cycle_error(tcx: CTX) -> Self;\n+    fn from_cycle_error(tcx: CTX, cycle: &[QueryInfo]) -> Self;\n }\n \n impl<CTX: DepContext, T> Value<CTX> for T {\n-    default fn from_cycle_error(tcx: CTX) -> T {\n+    default fn from_cycle_error(tcx: CTX, _: &[QueryInfo]) -> T {\n         tcx.sess().abort_if_errors();\n         // Ideally we would use `bug!` here. But bug! is only defined in rustc_middle, and it's\n         // non-trivial to define it earlier."}, {"sha": "22289657b81472f74d3d873815de1ff12aeec537", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -2751,82 +2751,6 @@ impl<'v> Visitor<'v> for FindTypeParam {\n     }\n }\n \n-pub fn recursive_type_with_infinite_size_error<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    type_def_id: DefId,\n-    spans: Vec<(Span, Option<hir::HirId>)>,\n-) {\n-    assert!(type_def_id.is_local());\n-    let span = tcx.def_span(type_def_id);\n-    let path = tcx.def_path_str(type_def_id);\n-    let mut err =\n-        struct_span_err!(tcx.sess, span, E0072, \"recursive type `{}` has infinite size\", path);\n-    err.span_label(span, \"recursive type has infinite size\");\n-    for &(span, _) in &spans {\n-        err.span_label(span, \"recursive without indirection\");\n-    }\n-    let msg = format!(\n-        \"insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `{}` representable\",\n-        path,\n-    );\n-    if spans.len() <= 4 {\n-        // FIXME(compiler-errors): This suggestion might be erroneous if Box is shadowed\n-        err.multipart_suggestion(\n-            &msg,\n-            spans\n-                .into_iter()\n-                .flat_map(|(span, field_id)| {\n-                    if let Some(generic_span) = get_option_generic_from_field_id(tcx, field_id) {\n-                        // If we match an `Option` and can grab the span of the Option's generic, then\n-                        // suggest boxing the generic arg for a non-null niche optimization.\n-                        vec![\n-                            (generic_span.shrink_to_lo(), \"Box<\".to_string()),\n-                            (generic_span.shrink_to_hi(), \">\".to_string()),\n-                        ]\n-                    } else {\n-                        vec![\n-                            (span.shrink_to_lo(), \"Box<\".to_string()),\n-                            (span.shrink_to_hi(), \">\".to_string()),\n-                        ]\n-                    }\n-                })\n-                .collect(),\n-            Applicability::HasPlaceholders,\n-        );\n-    } else {\n-        err.help(&msg);\n-    }\n-    err.emit();\n-}\n-\n-/// Extract the span for the generic type `T` of `Option<T>` in a field definition\n-fn get_option_generic_from_field_id(tcx: TyCtxt<'_>, field_id: Option<hir::HirId>) -> Option<Span> {\n-    let node = tcx.hir().find(field_id?);\n-\n-    // Expect a field from our field_id\n-    let Some(hir::Node::Field(field_def)) = node\n-        else { bug!(\"Expected HirId corresponding to FieldDef, found: {:?}\", node) };\n-\n-    // Match a type that is a simple QPath with no Self\n-    let hir::TyKind::Path(hir::QPath::Resolved(None, path)) = &field_def.ty.kind\n-        else { return None };\n-\n-    // Check if the path we're checking resolves to Option\n-    let hir::def::Res::Def(_, did) = path.res\n-        else { return None };\n-\n-    // Bail if this path doesn't describe `::core::option::Option`\n-    if !tcx.is_diagnostic_item(sym::Option, did) {\n-        return None;\n-    }\n-\n-    // Match a single generic arg in the 0th path segment\n-    let generic_arg = path.segments.last()?.args?.args.get(0)?;\n-\n-    // Take the span out of the type, if it's a type\n-    if let hir::GenericArg::Type(generic_ty) = generic_arg { Some(generic_ty.span) } else { None }\n-}\n-\n /// Summarizes information\n #[derive(Clone)]\n pub enum ArgKind {"}, {"sha": "cce5a79ddc855cbcc5970c55855cb94edafb0fdb", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -39,6 +39,7 @@ pub fn provide(providers: &mut Providers) {\n     implied_bounds::provide(providers);\n     layout::provide(providers);\n     needs_drop::provide(providers);\n+    representability::provide(providers);\n     ty::provide(providers);\n     instance::provide(providers);\n }"}, {"sha": "7f48fb804178dee969d1994c052b29dcba7fdf8b", "filename": "compiler/rustc_ty_utils/src/representability.rs", "status": "modified", "additions": 92, "deletions": 359, "changes": 451, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -1,386 +1,119 @@\n-//! Check whether a type is representable.\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir as hir;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_span::Span;\n-use std::cmp;\n+#![allow(rustc::untranslatable_diagnostic, rustc::diagnostic_outside_of_impl)]\n \n-/// Describes whether a type is representable. For types that are not\n-/// representable, 'SelfRecursive' and 'ContainsRecursive' are used to\n-/// distinguish between types that are recursive with themselves and types that\n-/// contain a different recursive type. These cases can therefore be treated\n-/// differently when reporting errors.\n-///\n-/// The ordering of the cases is significant. They are sorted so that cmp::max\n-/// will keep the \"more erroneous\" of two values.\n-#[derive(Clone, PartialOrd, Ord, Eq, PartialEq, Debug)]\n-pub enum Representability {\n-    Representable,\n-    ContainsRecursive,\n-    /// Return a list of types that are included in themselves:\n-    /// the spans where they are self-included, and (if found)\n-    /// the HirId of the FieldDef that defines the self-inclusion.\n-    SelfRecursive(Vec<(Span, Option<hir::HirId>)>),\n-}\n+use rustc_hir::def::DefKind;\n+use rustc_index::bit_set::BitSet;\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::{self, Representability, Ty, TyCtxt};\n+use rustc_span::def_id::{DefId, LocalDefId};\n \n-/// Check whether a type is representable. This means it cannot contain unboxed\n-/// structural recursion. This check is needed for structs and enums.\n-pub fn ty_is_representable<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    ty: Ty<'tcx>,\n-    sp: Span,\n-    field_id: Option<hir::HirId>,\n-) -> Representability {\n-    debug!(\"is_type_representable: {:?}\", ty);\n-    // To avoid a stack overflow when checking an enum variant or struct that\n-    // contains a different, structurally recursive type, maintain a stack of\n-    // seen types and check recursion for each of them (issues #3008, #3779,\n-    // #74224, #84611). `shadow_seen` contains the full stack and `seen` only\n-    // the one for the current type (e.g. if we have structs A and B, B contains\n-    // a field of type A, and we're currently looking at B, then `seen` will be\n-    // cleared when recursing to check A, but `shadow_seen` won't, so that we\n-    // can catch cases of mutual recursion where A also contains B).\n-    let mut seen: Vec<Ty<'_>> = Vec::new();\n-    let mut shadow_seen: Vec<ty::AdtDef<'tcx>> = Vec::new();\n-    let mut representable_cache = FxHashMap::default();\n-    let mut force_result = false;\n-    let r = is_type_structurally_recursive(\n-        tcx,\n-        &mut seen,\n-        &mut shadow_seen,\n-        &mut representable_cache,\n-        ty,\n-        sp,\n-        field_id,\n-        &mut force_result,\n-    );\n-    debug!(\"is_type_representable: {:?} is {:?}\", ty, r);\n-    r\n+pub fn provide(providers: &mut Providers) {\n+    *providers =\n+        Providers { representability, representability_adt_ty, params_in_repr, ..*providers };\n }\n \n-// Iterate until something non-representable is found\n-fn fold_repr<It: Iterator<Item = Representability>>(iter: It) -> Representability {\n-    iter.fold(Representability::Representable, |r1, r2| match (r1, r2) {\n-        (Representability::SelfRecursive(v1), Representability::SelfRecursive(v2)) => {\n-            Representability::SelfRecursive(v1.into_iter().chain(v2).collect())\n+macro_rules! rtry {\n+    ($e:expr) => {\n+        match $e {\n+            e @ Representability::Infinite => return e,\n+            Representability::Representable => {}\n         }\n-        (r1, r2) => cmp::max(r1, r2),\n-    })\n+    };\n }\n \n-fn are_inner_types_recursive<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    seen: &mut Vec<Ty<'tcx>>,\n-    shadow_seen: &mut Vec<ty::AdtDef<'tcx>>,\n-    representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n-    ty: Ty<'tcx>,\n-    sp: Span,\n-    field_id: Option<hir::HirId>,\n-    force_result: &mut bool,\n-) -> Representability {\n-    debug!(\"are_inner_types_recursive({:?}, {:?}, {:?})\", ty, seen, shadow_seen);\n-    match ty.kind() {\n-        ty::Tuple(fields) => {\n-            // Find non representable\n-            fold_repr(fields.iter().map(|ty| {\n-                is_type_structurally_recursive(\n-                    tcx,\n-                    seen,\n-                    shadow_seen,\n-                    representable_cache,\n-                    ty,\n-                    sp,\n-                    field_id,\n-                    force_result,\n-                )\n-            }))\n-        }\n-        // Fixed-length vectors.\n-        // FIXME(#11924) Behavior undecided for zero-length vectors.\n-        ty::Array(ty, _) => is_type_structurally_recursive(\n-            tcx,\n-            seen,\n-            shadow_seen,\n-            representable_cache,\n-            *ty,\n-            sp,\n-            field_id,\n-            force_result,\n-        ),\n-        ty::Adt(def, substs) => {\n-            // Find non representable fields with their spans\n-            fold_repr(def.all_fields().map(|field| {\n-                let ty = field.ty(tcx, substs);\n-                let (sp, field_id) = match field\n-                    .did\n-                    .as_local()\n-                    .map(|id| tcx.hir().local_def_id_to_hir_id(id))\n-                    .and_then(|id| tcx.hir().find(id))\n-                {\n-                    Some(hir::Node::Field(field)) => (field.ty.span, Some(field.hir_id)),\n-                    _ => (sp, field_id),\n-                };\n-\n-                let mut result = None;\n-\n-                // First, we check whether the field type per se is representable.\n-                // This catches cases as in #74224 and #84611. There is a special\n-                // case related to mutual recursion, though; consider this example:\n-                //\n-                //   struct A<T> {\n-                //       z: T,\n-                //       x: B<T>,\n-                //   }\n-                //\n-                //   struct B<T> {\n-                //       y: A<T>\n-                //   }\n-                //\n-                // Here, without the following special case, both A and B are\n-                // ContainsRecursive, which is a problem because we only report\n-                // errors for SelfRecursive. We fix this by detecting this special\n-                // case (shadow_seen.first() is the type we are originally\n-                // interested in, and if we ever encounter the same AdtDef again,\n-                // we know that it must be SelfRecursive) and \"forcibly\" returning\n-                // SelfRecursive (by setting force_result, which tells the calling\n-                // invocations of are_inner_types_representable to forward the\n-                // result without adjusting).\n-                if shadow_seen.len() > seen.len() && shadow_seen.first() == Some(def) {\n-                    *force_result = true;\n-                    result = Some(Representability::SelfRecursive(vec![(sp, field_id)]));\n-                }\n-\n-                if result == None {\n-                    result = Some(Representability::Representable);\n-\n-                    // Now, we check whether the field types per se are representable, e.g.\n-                    // for struct Foo { x: Option<Foo> }, we first check whether Option<_>\n-                    // by itself is representable (which it is), and the nesting of Foo\n-                    // will be detected later. This is necessary for #74224 and #84611.\n-\n-                    // If we have encountered an ADT definition that we have not seen\n-                    // before (no need to check them twice), recurse to see whether that\n-                    // definition is SelfRecursive. If so, we must be ContainsRecursive.\n-                    if shadow_seen.len() > 1\n-                        && !shadow_seen\n-                            .iter()\n-                            .take(shadow_seen.len() - 1)\n-                            .any(|seen_def| seen_def == def)\n-                    {\n-                        let adt_def_id = def.did();\n-                        let raw_adt_ty = tcx.type_of(adt_def_id);\n-                        debug!(\"are_inner_types_recursive: checking nested type: {:?}\", raw_adt_ty);\n-\n-                        // Check independently whether the ADT is SelfRecursive. If so,\n-                        // we must be ContainsRecursive (except for the special case\n-                        // mentioned above).\n-                        let mut nested_seen: Vec<Ty<'_>> = vec![];\n-                        result = Some(\n-                            match is_type_structurally_recursive(\n-                                tcx,\n-                                &mut nested_seen,\n-                                shadow_seen,\n-                                representable_cache,\n-                                raw_adt_ty,\n-                                sp,\n-                                field_id,\n-                                force_result,\n-                            ) {\n-                                Representability::SelfRecursive(_) => {\n-                                    if *force_result {\n-                                        Representability::SelfRecursive(vec![(sp, field_id)])\n-                                    } else {\n-                                        Representability::ContainsRecursive\n-                                    }\n-                                }\n-                                x => x,\n-                            },\n-                        );\n-                    }\n-\n-                    // We only enter the following block if the type looks representable\n-                    // so far. This is necessary for cases such as this one (#74224):\n-                    //\n-                    //   struct A<T> {\n-                    //       x: T,\n-                    //       y: A<A<T>>,\n-                    //   }\n-                    //\n-                    //   struct B {\n-                    //       z: A<usize>\n-                    //   }\n-                    //\n-                    // When checking B, we recurse into A and check field y of type\n-                    // A<A<usize>>. We haven't seen this exact type before, so we recurse\n-                    // into A<A<usize>>, which contains, A<A<A<usize>>>, and so forth,\n-                    // ad infinitum. We can prevent this from happening by first checking\n-                    // A separately (the code above) and only checking for nested Bs if\n-                    // A actually looks representable (which it wouldn't in this example).\n-                    if result == Some(Representability::Representable) {\n-                        // Now, even if the type is representable (e.g. Option<_>),\n-                        // it might still contribute to a recursive type, e.g.:\n-                        //   struct Foo { x: Option<Option<Foo>> }\n-                        // These cases are handled by passing the full `seen`\n-                        // stack to is_type_structurally_recursive (instead of the\n-                        // empty `nested_seen` above):\n-                        result = Some(\n-                            match is_type_structurally_recursive(\n-                                tcx,\n-                                seen,\n-                                shadow_seen,\n-                                representable_cache,\n-                                ty,\n-                                sp,\n-                                field_id,\n-                                force_result,\n-                            ) {\n-                                Representability::SelfRecursive(_) => {\n-                                    Representability::SelfRecursive(vec![(sp, field_id)])\n-                                }\n-                                x => x,\n-                            },\n-                        );\n-                    }\n+fn representability(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Representability {\n+    match tcx.def_kind(def_id) {\n+        DefKind::Struct | DefKind::Union | DefKind::Enum => {\n+            let adt_def = tcx.adt_def(def_id);\n+            for variant in adt_def.variants() {\n+                for field in variant.fields.iter() {\n+                    rtry!(tcx.representability(field.did.expect_local()));\n                 }\n-\n-                result.unwrap()\n-            }))\n-        }\n-        ty::Closure(..) => {\n-            // this check is run on type definitions, so we don't expect\n-            // to see closure types\n-            bug!(\"requires check invoked on inapplicable type: {:?}\", ty)\n+            }\n+            Representability::Representable\n         }\n-        _ => Representability::Representable,\n+        DefKind::Field => representability_ty(tcx, tcx.type_of(def_id)),\n+        def_kind => bug!(\"unexpected {def_kind:?}\"),\n     }\n }\n \n-fn same_adt<'tcx>(ty: Ty<'tcx>, def: ty::AdtDef<'tcx>) -> bool {\n+fn representability_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Representability {\n     match *ty.kind() {\n-        ty::Adt(ty_def, _) => ty_def == def,\n-        _ => false,\n+        ty::Adt(..) => tcx.representability_adt_ty(ty),\n+        // FIXME(#11924) allow zero-length arrays?\n+        ty::Array(ty, _) => representability_ty(tcx, ty),\n+        ty::Tuple(tys) => {\n+            for ty in tys {\n+                rtry!(representability_ty(tcx, ty));\n+            }\n+            Representability::Representable\n+        }\n+        _ => Representability::Representable,\n     }\n }\n \n-// Does the type `ty` directly (without indirection through a pointer)\n-// contain any types on stack `seen`?\n-fn is_type_structurally_recursive<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    seen: &mut Vec<Ty<'tcx>>,\n-    shadow_seen: &mut Vec<ty::AdtDef<'tcx>>,\n-    representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n-    ty: Ty<'tcx>,\n-    sp: Span,\n-    field_id: Option<hir::HirId>,\n-    force_result: &mut bool,\n-) -> Representability {\n-    debug!(\"is_type_structurally_recursive: {:?} {:?} {:?}\", ty, sp, field_id);\n-    if let Some(representability) = representable_cache.get(&ty) {\n-        debug!(\n-            \"is_type_structurally_recursive: {:?} {:?} {:?} - (cached) {:?}\",\n-            ty, sp, field_id, representability\n-        );\n-        return representability.clone();\n+/*\n+The reason for this being a separate query is very subtle:\n+Consider this infinitely sized struct: `struct Foo(Box<Foo>, Bar<Foo>)`:\n+When calling representability(Foo), a query cycle will occur:\n+  representability(Foo)\n+    -> representability_adt_ty(Bar<Foo>)\n+    -> representability(Foo)\n+For the diagnostic output (in `Value::from_cycle_error`), we want to detect that\n+the `Foo` in the *second* field of the struct is culpable. This requires\n+traversing the HIR of the struct and calling `params_in_repr(Bar)`. But we can't\n+call params_in_repr for a given type unless it is known to be representable.\n+params_in_repr will cycle/panic on infinitely sized types. Looking at the query\n+cycle above, we know that `Bar` is representable because\n+representability_adt_ty(Bar<..>) is in the cycle and representability(Bar) is\n+*not* in the cycle.\n+*/\n+fn representability_adt_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Representability {\n+    let ty::Adt(adt, substs) = ty.kind() else { bug!(\"expected adt\") };\n+    if let Some(def_id) = adt.did().as_local() {\n+        rtry!(tcx.representability(def_id));\n     }\n-\n-    let representability = is_type_structurally_recursive_inner(\n-        tcx,\n-        seen,\n-        shadow_seen,\n-        representable_cache,\n-        ty,\n-        sp,\n-        field_id,\n-        force_result,\n-    );\n-\n-    representable_cache.insert(ty, representability.clone());\n-    representability\n+    // At this point, we know that the item of the ADT type is representable;\n+    // but the type parameters may cause a cycle with an upstream type\n+    let params_in_repr = tcx.params_in_repr(adt.did());\n+    for (i, subst) in substs.iter().enumerate() {\n+        if let ty::GenericArgKind::Type(ty) = subst.unpack() {\n+            if params_in_repr.contains(i as u32) {\n+                rtry!(representability_ty(tcx, ty));\n+            }\n+        }\n+    }\n+    Representability::Representable\n }\n \n-fn is_type_structurally_recursive_inner<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    seen: &mut Vec<Ty<'tcx>>,\n-    shadow_seen: &mut Vec<ty::AdtDef<'tcx>>,\n-    representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n-    ty: Ty<'tcx>,\n-    sp: Span,\n-    field_id: Option<hir::HirId>,\n-    force_result: &mut bool,\n-) -> Representability {\n-    match ty.kind() {\n-        ty::Adt(def, _) => {\n-            {\n-                debug!(\"is_type_structurally_recursive_inner: adt: {:?}, seen: {:?}\", ty, seen);\n-\n-                // Iterate through stack of previously seen types.\n-                let mut iter = seen.iter();\n-\n-                // The first item in `seen` is the type we are actually curious about.\n-                // We want to return SelfRecursive if this type contains itself.\n-                // It is important that we DON'T take generic parameters into account\n-                // for this check, so that Bar<T> in this example counts as SelfRecursive:\n-                //\n-                // struct Foo;\n-                // struct Bar<T> { x: Bar<Foo> }\n-\n-                if let Some(&seen_adt) = iter.next() {\n-                    if same_adt(seen_adt, *def) {\n-                        debug!(\"SelfRecursive: {:?} contains {:?}\", seen_adt, ty);\n-                        return Representability::SelfRecursive(vec![(sp, field_id)]);\n-                    }\n-                }\n-\n-                // We also need to know whether the first item contains other types\n-                // that are structurally recursive. If we don't catch this case, we\n-                // will recurse infinitely for some inputs.\n-                //\n-                // It is important that we DO take generic parameters into account\n-                // here, because nesting e.g. Options is allowed (as long as the\n-                // definition of Option doesn't itself include an Option field, which\n-                // would be a case of SelfRecursive above). The following, too, counts\n-                // as SelfRecursive:\n-                //\n-                // struct Foo { Option<Option<Foo>> }\n+fn params_in_repr(tcx: TyCtxt<'_>, def_id: DefId) -> BitSet<u32> {\n+    let adt_def = tcx.adt_def(def_id);\n+    let generics = tcx.generics_of(def_id);\n+    let mut params_in_repr = BitSet::new_empty(generics.params.len());\n+    for variant in adt_def.variants() {\n+        for field in variant.fields.iter() {\n+            params_in_repr_ty(tcx, tcx.type_of(field.did), &mut params_in_repr);\n+        }\n+    }\n+    params_in_repr\n+}\n \n-                for &seen_adt in iter {\n-                    if ty == seen_adt {\n-                        debug!(\"ContainsRecursive: {:?} contains {:?}\", seen_adt, ty);\n-                        return Representability::ContainsRecursive;\n+fn params_in_repr_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, params_in_repr: &mut BitSet<u32>) {\n+    match *ty.kind() {\n+        ty::Adt(adt, substs) => {\n+            let inner_params_in_repr = tcx.params_in_repr(adt.did());\n+            for (i, subst) in substs.iter().enumerate() {\n+                if let ty::GenericArgKind::Type(ty) = subst.unpack() {\n+                    if inner_params_in_repr.contains(i as u32) {\n+                        params_in_repr_ty(tcx, ty, params_in_repr);\n                     }\n                 }\n             }\n-\n-            // For structs and enums, track all previously seen types by pushing them\n-            // onto the 'seen' stack.\n-            seen.push(ty);\n-            shadow_seen.push(*def);\n-            let out = are_inner_types_recursive(\n-                tcx,\n-                seen,\n-                shadow_seen,\n-                representable_cache,\n-                ty,\n-                sp,\n-                field_id,\n-                force_result,\n-            );\n-            shadow_seen.pop();\n-            seen.pop();\n-            out\n         }\n-        _ => {\n-            // No need to push in other cases.\n-            are_inner_types_recursive(\n-                tcx,\n-                seen,\n-                shadow_seen,\n-                representable_cache,\n-                ty,\n-                sp,\n-                field_id,\n-                force_result,\n-            )\n+        ty::Array(ty, _) => params_in_repr_ty(tcx, ty, params_in_repr),\n+        ty::Tuple(tys) => tys.iter().for_each(|ty| params_in_repr_ty(tcx, ty, params_in_repr)),\n+        ty::Param(param) => {\n+            params_in_repr.insert(param.index);\n         }\n+        _ => {}\n     }\n }"}, {"sha": "7ce47947cbb0c86118ea649ca31df1c3e1e78c37", "filename": "src/test/incremental/issue-61323.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fincremental%2Fissue-61323.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fincremental%2Fissue-61323.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-61323.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -1,7 +1,7 @@\n // revisions: rpass cfail\n \n enum A {\n-    //[cfail]~^ ERROR 3:1: 3:7: recursive type `A` has infinite size [E0072]\n+    //[cfail]~^ ERROR 3:1: 3:7: recursive types `A` and `C` have infinite size [E0072]\n     B(C),\n }\n \n@@ -10,6 +10,5 @@ struct C(Box<A>);\n \n #[cfg(cfail)]\n struct C(A);\n-//[cfail]~^ ERROR 12:1: 12:9: recursive type `C` has infinite size [E0072]\n \n fn main() {}"}, {"sha": "e6ab67d59ce5818e55fcc7c93e84b3a8c3ebaddf", "filename": "src/test/rustdoc-ui/infinite-recursive-type-impl-trait-return.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait-return.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -2,12 +2,12 @@ error[E0072]: recursive type `DEF_ID` has infinite size\n   --> $DIR/infinite-recursive-type-impl-trait-return.rs:7:5\n    |\n LL |     enum E {\n-   |     ^^^^^^ recursive type has infinite size\n+   |     ^^^^^^\n LL |\n LL |         This(E),\n    |              - recursive without indirection\n    |\n-help: insert some indirection (e.g., a `DEF_ID` representable\n+help: insert some indirection (e.g., a `DEF_ID`) to break the cycle\n    |\n LL |         This(Box<E>),\n    |              ++++ +"}, {"sha": "165ff6783724417adf64e0b8a1d0760924198bb3", "filename": "src/test/rustdoc-ui/infinite-recursive-type-impl-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type-impl-trait.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -2,12 +2,12 @@ error[E0072]: recursive type `f::E` has infinite size\n   --> $DIR/infinite-recursive-type-impl-trait.rs:2:5\n    |\n LL |     enum E {\n-   |     ^^^^^^ recursive type has infinite size\n+   |     ^^^^^^\n LL |\n LL |         V(E),\n    |           - recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `f::E` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL |         V(Box<E>),\n    |           ++++ +"}, {"sha": "9e2c3ff16420952710368a21fd73c0f46a44d505", "filename": "src/test/rustdoc-ui/infinite-recursive-type.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finfinite-recursive-type.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -2,12 +2,12 @@ error[E0072]: recursive type `E` has infinite size\n   --> $DIR/infinite-recursive-type.rs:1:1\n    |\n LL | enum E {\n-   | ^^^^^^ recursive type has infinite size\n+   | ^^^^^^\n LL |\n LL |     V(E),\n    |       - recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `E` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL |     V(Box<E>),\n    |       ++++ +"}, {"sha": "f08e10f6bdbc0b3e976f299e2a9f9088862ecc5f", "filename": "src/test/ui/infinite/infinite-struct.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Finfinite%2Finfinite-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Finfinite%2Finfinite-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite%2Finfinite-struct.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -6,4 +6,11 @@ fn foo() -> Take {\n     Take(loop {})\n }\n \n+// mutually infinite structs\n+struct Foo { //~ ERROR has infinite size\n+    x: Bar<Foo>,\n+}\n+\n+struct Bar<T>([T; 1]);\n+\n fn main() {}"}, {"sha": "b6c72b1de4695a7f885aea7931393c633d38d3dd", "filename": "src/test/ui/infinite/infinite-struct.stderr", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Finfinite%2Finfinite-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Finfinite%2Finfinite-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite%2Finfinite-struct.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -3,14 +3,25 @@ error[E0072]: recursive type `Take` has infinite size\n    |\n LL | struct Take(Take);\n    | ^^^^^^^^^^^ ---- recursive without indirection\n-   | |\n-   | recursive type has infinite size\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Take` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL | struct Take(Box<Take>);\n    |             ++++    +\n \n-error: aborting due to previous error\n+error[E0072]: recursive type `Foo` has infinite size\n+  --> $DIR/infinite-struct.rs:10:1\n+   |\n+LL | struct Foo {\n+   | ^^^^^^^^^^\n+LL |     x: Bar<Foo>,\n+   |            --- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n+   |\n+LL |     x: Bar<Box<Foo>>,\n+   |            ++++   +\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0072`."}, {"sha": "513bbfc1b8cf1b9bbf7350fce3ce495875f04f2c", "filename": "src/test/ui/infinite/infinite-tag-type-recursion.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Finfinite%2Finfinite-tag-type-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Finfinite%2Finfinite-tag-type-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite%2Finfinite-tag-type-recursion.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -3,10 +3,8 @@ error[E0072]: recursive type `MList` has infinite size\n    |\n LL | enum MList { Cons(isize, MList), Nil }\n    | ^^^^^^^^^^               ----- recursive without indirection\n-   | |\n-   | recursive type has infinite size\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `MList` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL | enum MList { Cons(isize, Box<MList>), Nil }\n    |                          ++++     +"}, {"sha": "e3af8976cee919025bac1d83d6e2d5f12d0ede4a", "filename": "src/test/ui/issues/issue-17431-1.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-17431-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-17431-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-1.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -2,14 +2,12 @@ error[E0072]: recursive type `Foo` has infinite size\n   --> $DIR/issue-17431-1.rs:1:1\n    |\n LL | struct Foo { foo: Option<Option<Foo>> }\n-   | ^^^^^^^^^^        ------------------- recursive without indirection\n-   | |\n-   | recursive type has infinite size\n+   | ^^^^^^^^^^                      --- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n-LL | struct Foo { foo: Option<Box<Option<Foo>>> }\n-   |                          ++++           +\n+LL | struct Foo { foo: Option<Option<Box<Foo>>> }\n+   |                                 ++++   +\n \n error: aborting due to previous error\n "}, {"sha": "f7b9c6a55ddf7009a8c4510b218910a6dde4c96d", "filename": "src/test/ui/issues/issue-17431-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-17431-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-17431-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-2.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -1,8 +1,7 @@\n struct Baz { q: Option<Foo> }\n-//~^ ERROR recursive type `Baz` has infinite size\n+//~^ ERROR recursive types `Baz` and `Foo` have infinite size\n \n struct Foo { q: Option<Baz> }\n-//~^ ERROR recursive type `Foo` has infinite size\n \n impl Foo { fn bar(&self) {} }\n "}, {"sha": "39a99ec1ef73986cc766edf7c77ae00d4610d9df", "filename": "src/test/ui/issues/issue-17431-2.stderr", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-17431-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-17431-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-2.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -1,29 +1,20 @@\n-error[E0072]: recursive type `Baz` has infinite size\n+error[E0072]: recursive types `Baz` and `Foo` have infinite size\n   --> $DIR/issue-17431-2.rs:1:1\n    |\n LL | struct Baz { q: Option<Foo> }\n-   | ^^^^^^^^^^      ----------- recursive without indirection\n-   | |\n-   | recursive type has infinite size\n-   |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Baz` representable\n-   |\n-LL | struct Baz { q: Option<Box<Foo>> }\n-   |                        ++++   +\n-\n-error[E0072]: recursive type `Foo` has infinite size\n-  --> $DIR/issue-17431-2.rs:4:1\n-   |\n+   | ^^^^^^^^^^             --- recursive without indirection\n+...\n LL | struct Foo { q: Option<Baz> }\n-   | ^^^^^^^^^^      ----------- recursive without indirection\n-   | |\n-   | recursive type has infinite size\n+   | ^^^^^^^^^^             --- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n+LL ~ struct Baz { q: Option<Box<Foo>> }\n+LL |\n+LL | \n+LL ~ struct Foo { q: Option<Box<Baz>> }\n    |\n-LL | struct Foo { q: Option<Box<Baz>> }\n-   |                        ++++   +\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0072`."}, {"sha": "394134c78556bab8b4dfa6f38691cb2849bcfd1b", "filename": "src/test/ui/issues/issue-17431-3.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-17431-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-17431-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-3.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -2,14 +2,12 @@ error[E0072]: recursive type `Foo` has infinite size\n   --> $DIR/issue-17431-3.rs:3:1\n    |\n LL | struct Foo { foo: Mutex<Option<Foo>> }\n-   | ^^^^^^^^^^        ------------------ recursive without indirection\n-   | |\n-   | recursive type has infinite size\n+   | ^^^^^^^^^^                     --- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n-LL | struct Foo { foo: Box<Mutex<Option<Foo>>> }\n-   |                   ++++                  +\n+LL | struct Foo { foo: Mutex<Option<Box<Foo>>> }\n+   |                                ++++   +\n \n error: aborting due to previous error\n "}, {"sha": "3d141e44babf475dfab9d682241c257584ca627a", "filename": "src/test/ui/issues/issue-17431-4.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-17431-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-17431-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-4.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -2,14 +2,12 @@ error[E0072]: recursive type `Foo` has infinite size\n   --> $DIR/issue-17431-4.rs:3:1\n    |\n LL | struct Foo<T> { foo: Option<Option<Foo<T>>>, marker: marker::PhantomData<T> }\n-   | ^^^^^^^^^^^^^        ---------------------- recursive without indirection\n-   | |\n-   | recursive type has infinite size\n+   | ^^^^^^^^^^^^^                      ------ recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n-LL | struct Foo<T> { foo: Option<Box<Option<Foo<T>>>>, marker: marker::PhantomData<T> }\n-   |                             ++++              +\n+LL | struct Foo<T> { foo: Option<Option<Box<Foo<T>>>>, marker: marker::PhantomData<T> }\n+   |                                    ++++      +\n \n error: aborting due to previous error\n "}, {"sha": "44a90a6fe3898b4d48bede1043339e66b430a96e", "filename": "src/test/ui/issues/issue-17431-5.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-17431-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-17431-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-5.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -3,10 +3,8 @@ error[E0072]: recursive type `Bar` has infinite size\n    |\n LL | struct Bar<T> { x: Bar<Foo> , marker: marker::PhantomData<T> }\n    | ^^^^^^^^^^^^^      -------- recursive without indirection\n-   | |\n-   | recursive type has infinite size\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Bar` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL | struct Bar<T> { x: Box<Bar<Foo>> , marker: marker::PhantomData<T> }\n    |                    ++++        +"}, {"sha": "e0a8225507e5aa90d9c1933f56a96ebe1d9efa52", "filename": "src/test/ui/issues/issue-17431-6.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-17431-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-17431-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-6.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -2,14 +2,12 @@ error[E0072]: recursive type `Foo` has infinite size\n   --> $DIR/issue-17431-6.rs:3:1\n    |\n LL | enum Foo { X(Mutex<Option<Foo>>) }\n-   | ^^^^^^^^     ------------------ recursive without indirection\n-   | |\n-   | recursive type has infinite size\n+   | ^^^^^^^^                  --- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n-LL | enum Foo { X(Box<Mutex<Option<Foo>>>) }\n-   |              ++++                  +\n+LL | enum Foo { X(Mutex<Option<Box<Foo>>>) }\n+   |                           ++++   +\n \n error: aborting due to previous error\n "}, {"sha": "ecf072b8e8aea16815e3f080000aed2b096df133", "filename": "src/test/ui/issues/issue-17431-7.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-17431-7.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-17431-7.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-7.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -2,14 +2,12 @@ error[E0072]: recursive type `Foo` has infinite size\n   --> $DIR/issue-17431-7.rs:1:1\n    |\n LL | enum Foo { Voo(Option<Option<Foo>>) }\n-   | ^^^^^^^^       ------------------- recursive without indirection\n-   | |\n-   | recursive type has infinite size\n+   | ^^^^^^^^                     --- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n-LL | enum Foo { Voo(Option<Box<Option<Foo>>>) }\n-   |                       ++++           +\n+LL | enum Foo { Voo(Option<Option<Box<Foo>>>) }\n+   |                              ++++   +\n \n error: aborting due to previous error\n "}, {"sha": "7ea620f386a205fcb3dffc3081028c8dc3a996f8", "filename": "src/test/ui/issues/issue-2718-a.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-2718-a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-2718-a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2718-a.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -3,10 +3,8 @@ error[E0072]: recursive type `Pong` has infinite size\n    |\n LL |     pub struct Pong(SendPacket<Ping>);\n    |     ^^^^^^^^^^^^^^^ ---------------- recursive without indirection\n-   |     |\n-   |     recursive type has infinite size\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Pong` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL |     pub struct Pong(Box<SendPacket<Ping>>);\n    |                     ++++                +"}, {"sha": "be25b9091d589560e58c2922d9f4b29db99ed303", "filename": "src/test/ui/issues/issue-3008-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-3008-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-3008-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3008-1.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -2,12 +2,12 @@ error[E0072]: recursive type `Bar` has infinite size\n   --> $DIR/issue-3008-1.rs:5:1\n    |\n LL | enum Bar {\n-   | ^^^^^^^^ recursive type has infinite size\n+   | ^^^^^^^^\n ...\n LL |     BarSome(Bar)\n    |             --- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Bar` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL |     BarSome(Box<Bar>)\n    |             ++++   +"}, {"sha": "858a8fd6af808a9b5ffec99a3d65491df1ad2007", "filename": "src/test/ui/issues/issue-3008-2.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-3008-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-3008-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3008-2.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -3,10 +3,8 @@ error[E0072]: recursive type `Bar` has infinite size\n    |\n LL | struct Bar { x: Bar }\n    | ^^^^^^^^^^      --- recursive without indirection\n-   | |\n-   | recursive type has infinite size\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Bar` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL | struct Bar { x: Box<Bar> }\n    |                 ++++   +"}, {"sha": "a1a81e29367754d1576394a51e01e447ae113d97", "filename": "src/test/ui/issues/issue-3008-3.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-3008-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-3008-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3008-3.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -3,10 +3,8 @@ error[E0072]: recursive type `E2` has infinite size\n    |\n LL | enum E2<T> { V2(E2<E1>, marker::PhantomData<T>), }\n    | ^^^^^^^^^^      ------ recursive without indirection\n-   | |\n-   | recursive type has infinite size\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `E2` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL | enum E2<T> { V2(Box<E2<E1>>, marker::PhantomData<T>), }\n    |                 ++++      +"}, {"sha": "dc51198d98ce80dc179ff8d67726a84b706bab21", "filename": "src/test/ui/issues/issue-32326.stderr", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-32326.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-32326.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32326.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -2,16 +2,14 @@ error[E0072]: recursive type `Expr` has infinite size\n   --> $DIR/issue-32326.rs:5:1\n    |\n LL | enum Expr {\n-   | ^^^^^^^^^ recursive type has infinite size\n+   | ^^^^^^^^^\n LL |     Plus(Expr, Expr),\n-   |          ----  ---- recursive without indirection\n-   |          |\n-   |          recursive without indirection\n+   |          ---- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Expr` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n-LL |     Plus(Box<Expr>, Box<Expr>),\n-   |          ++++    +  ++++    +\n+LL |     Plus(Box<Expr>, Expr),\n+   |          ++++    +\n \n error: aborting due to previous error\n "}, {"sha": "a0dbcc920fa3d24f65a8150027286604a7f83bf8", "filename": "src/test/ui/issues/issue-3779.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-3779.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-3779.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3779.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -2,12 +2,12 @@ error[E0072]: recursive type `S` has infinite size\n   --> $DIR/issue-3779.rs:1:1\n    |\n LL | struct S {\n-   | ^^^^^^^^ recursive type has infinite size\n+   | ^^^^^^^^\n LL |\n LL |     element: Option<S>\n-   |              --------- recursive without indirection\n+   |                     - recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `S` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL |     element: Option<Box<S>>\n    |                     ++++ +"}, {"sha": "f74222e3e51db16245832ba863aecd2695a7beaa", "filename": "src/test/ui/issues/issue-57271.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-57271.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-57271.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57271.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -4,7 +4,7 @@ extern crate issue_57271_lib;\n \n use issue_57271_lib::BaseType;\n \n-pub enum ObjectType { //~ ERROR recursive type `ObjectType` has infinite size\n+pub enum ObjectType { //~ ERROR recursive types `ObjectType` and `TypeSignature` have infinite size\n     Class(ClassTypeSignature),\n     Array(TypeSignature),\n     TypeVariable(()),\n@@ -16,7 +16,7 @@ pub struct ClassTypeSignature {\n     pub inner: (),\n }\n \n-pub enum TypeSignature { //~ ERROR recursive type `TypeSignature` has infinite size\n+pub enum TypeSignature {\n     Base(BaseType),\n     Object(ObjectType),\n }"}, {"sha": "391e69c91fb0f63e2fb95b286689e4bddae4e85b", "filename": "src/test/ui/issues/issue-57271.stderr", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-57271.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-57271.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57271.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -1,31 +1,27 @@\n-error[E0072]: recursive type `ObjectType` has infinite size\n+error[E0072]: recursive types `ObjectType` and `TypeSignature` have infinite size\n   --> $DIR/issue-57271.rs:7:1\n    |\n LL | pub enum ObjectType {\n-   | ^^^^^^^^^^^^^^^^^^^ recursive type has infinite size\n+   | ^^^^^^^^^^^^^^^^^^^\n LL |     Class(ClassTypeSignature),\n LL |     Array(TypeSignature),\n    |           ------------- recursive without indirection\n-   |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `ObjectType` representable\n-   |\n-LL |     Array(Box<TypeSignature>),\n-   |           ++++             +\n-\n-error[E0072]: recursive type `TypeSignature` has infinite size\n-  --> $DIR/issue-57271.rs:19:1\n-   |\n+...\n LL | pub enum TypeSignature {\n-   | ^^^^^^^^^^^^^^^^^^^^^^ recursive type has infinite size\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n LL |     Base(BaseType),\n LL |     Object(ObjectType),\n    |            ---------- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `TypeSignature` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n+   |\n+LL ~     Array(Box<TypeSignature>),\n+LL |     TypeVariable(()),\n+ ...\n+LL |     Base(BaseType),\n+LL ~     Object(Box<ObjectType>),\n    |\n-LL |     Object(Box<ObjectType>),\n-   |            ++++          +\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0072`."}, {"sha": "bc85cd7b18d551d39e6a2b282dd575bac0f4006f", "filename": "src/test/ui/issues/issue-72554.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-72554.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fissues%2Fissue-72554.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72554.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -2,12 +2,12 @@ error[E0072]: recursive type `ElemDerived` has infinite size\n   --> $DIR/issue-72554.rs:4:1\n    |\n LL | pub enum ElemDerived {\n-   | ^^^^^^^^^^^^^^^^^^^^ recursive type has infinite size\n+   | ^^^^^^^^^^^^^^^^^^^^\n ...\n LL |     A(ElemDerived)\n    |       ----------- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `ElemDerived` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL |     A(Box<ElemDerived>)\n    |       ++++           +"}, {"sha": "5aef94754869f742bd811abed5d7fb041289935e", "filename": "src/test/ui/keyword/keyword-self-as-type-param.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-self-as-type-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-self-as-type-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkeyword%2Fkeyword-self-as-type-param.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -19,10 +19,8 @@ error[E0072]: recursive type `Foo` has infinite size\n    |\n LL | struct Foo<Self>(Self);\n    | ^^^^^^^^^^^^^^^^ ---- recursive without indirection\n-   | |\n-   | recursive type has infinite size\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL | struct Foo<Self>(Box<Self>);\n    |                  ++++    +"}, {"sha": "d662d1022038d211c15011c8d3e7c1a7447d129e", "filename": "src/test/ui/recursion/recursive-enum.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Frecursion%2Frecursive-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Frecursion%2Frecursive-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-enum.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -3,10 +3,8 @@ error[E0072]: recursive type `List` has infinite size\n    |\n LL | enum List<T> { Cons(T, List<T>), Nil }\n    | ^^^^^^^^^^^^           ------- recursive without indirection\n-   | |\n-   | recursive type has infinite size\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `List` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL | enum List<T> { Cons(T, Box<List<T>>), Nil }\n    |                        ++++       +"}, {"sha": "766a5fa0de3dc6f0fb4de3c79d6a5471f40277cf", "filename": "src/test/ui/sized-cycle-note.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fsized-cycle-note.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fsized-cycle-note.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsized-cycle-note.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -1,15 +1,6 @@\n-// Test the error message resulting from a cycle in solving `Foo:\n-// Sized`. The specifics of the message will of course but the main\n-// thing we want to preserve is that:\n-//\n-// 1. the message should appear attached to one of the structs\n-//    defined in this file;\n-// 2. it should elaborate the steps that led to the cycle.\n-\n struct Baz { q: Option<Foo> }\n-//~^ ERROR recursive type `Baz` has infinite size\n+//~^ ERROR recursive types `Baz` and `Foo` have infinite size\n struct Foo { q: Option<Baz> }\n-//~^ ERROR recursive type `Foo` has infinite size\n \n impl Foo { fn bar(&self) {} }\n "}, {"sha": "06c87b61f41f6927ba9e37d2219191732309f96b", "filename": "src/test/ui/sized-cycle-note.stderr", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fsized-cycle-note.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fsized-cycle-note.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsized-cycle-note.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -1,29 +1,19 @@\n-error[E0072]: recursive type `Baz` has infinite size\n-  --> $DIR/sized-cycle-note.rs:9:1\n+error[E0072]: recursive types `Baz` and `Foo` have infinite size\n+  --> $DIR/sized-cycle-note.rs:1:1\n    |\n LL | struct Baz { q: Option<Foo> }\n-   | ^^^^^^^^^^      ----------- recursive without indirection\n-   | |\n-   | recursive type has infinite size\n-   |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Baz` representable\n-   |\n-LL | struct Baz { q: Option<Box<Foo>> }\n-   |                        ++++   +\n-\n-error[E0072]: recursive type `Foo` has infinite size\n-  --> $DIR/sized-cycle-note.rs:11:1\n-   |\n+   | ^^^^^^^^^^             --- recursive without indirection\n+LL |\n LL | struct Foo { q: Option<Baz> }\n-   | ^^^^^^^^^^      ----------- recursive without indirection\n-   | |\n-   | recursive type has infinite size\n+   | ^^^^^^^^^^             --- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n+LL ~ struct Baz { q: Option<Box<Foo>> }\n+LL |\n+LL ~ struct Foo { q: Option<Box<Baz>> }\n    |\n-LL | struct Foo { q: Option<Box<Baz>> }\n-   |                        ++++   +\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0072`."}, {"sha": "20f2e0df05efe7dc80e1e5628afe997b74cbc42e", "filename": "src/test/ui/span/E0072.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fspan%2FE0072.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fspan%2FE0072.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0072.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -2,12 +2,12 @@ error[E0072]: recursive type `ListNode` has infinite size\n   --> $DIR/E0072.rs:1:1\n    |\n LL | struct ListNode {\n-   | ^^^^^^^^^^^^^^^ recursive type has infinite size\n+   | ^^^^^^^^^^^^^^^\n LL |     head: u8,\n LL |     tail: Option<ListNode>,\n-   |           ---------------- recursive without indirection\n+   |                  -------- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `ListNode` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL |     tail: Option<Box<ListNode>>,\n    |                  ++++        +"}, {"sha": "fc2f6e6622c2ad2fb8e4ca27e77b7c7d6de52af0", "filename": "src/test/ui/span/multiline-span-E0072.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -3,12 +3,12 @@ error[E0072]: recursive type `ListNode` has infinite size\n    |\n LL | / struct\n LL | | ListNode\n-   | |________^ recursive type has infinite size\n+   | |________^\n ...\n LL |       tail: Option<ListNode>,\n-   |             ---------------- recursive without indirection\n+   |                    -------- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `ListNode` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL |     tail: Option<Box<ListNode>>,\n    |                  ++++        +"}, {"sha": "bd4c435347cfc35c7f0725e545db47407bbe49eb", "filename": "src/test/ui/span/recursive-type-field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -1,11 +1,11 @@\n use std::rc::Rc;\n \n-struct Foo<'a> { //~ ERROR recursive type\n+struct Foo<'a> { //~ ERROR recursive types `Foo` and `Bar` have infinite size\n     bar: Bar<'a>,\n     b: Rc<Bar<'a>>,\n }\n \n-struct Bar<'a> { //~ ERROR recursive type\n+struct Bar<'a> {\n     y: (Foo<'a>, Foo<'a>),\n     z: Option<Bar<'a>>,\n     a: &'a Foo<'a>,"}, {"sha": "10af4c36ba4b4a97a9b02c7ddb2905a5f774b289", "filename": "src/test/ui/span/recursive-type-field.stderr", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -1,35 +1,27 @@\n-error[E0072]: recursive type `Foo` has infinite size\n+error[E0072]: recursive types `Foo` and `Bar` have infinite size\n   --> $DIR/recursive-type-field.rs:3:1\n    |\n LL | struct Foo<'a> {\n-   | ^^^^^^^^^^^^^^ recursive type has infinite size\n+   | ^^^^^^^^^^^^^^\n LL |     bar: Bar<'a>,\n    |          ------- recursive without indirection\n+...\n+LL | struct Bar<'a> {\n+   | ^^^^^^^^^^^^^^\n+LL |     y: (Foo<'a>, Foo<'a>),\n+   |         -------  ------- recursive without indirection\n+   |         |\n+   |         recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n-   |\n-LL |     bar: Box<Bar<'a>>,\n-   |          ++++       +\n-\n-error[E0072]: recursive type `Bar` has infinite size\n-  --> $DIR/recursive-type-field.rs:8:1\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n+LL ~     bar: Box<Bar<'a>>,\n+LL |     b: Rc<Bar<'a>>,\n+ ...\n LL | struct Bar<'a> {\n-   | ^^^^^^^^^^^^^^ recursive type has infinite size\n-LL |     y: (Foo<'a>, Foo<'a>),\n-   |        ------------------ recursive without indirection\n-LL |     z: Option<Bar<'a>>,\n-   |        --------------- recursive without indirection\n-...\n-LL |     d: [Bar<'a>; 1],\n-   |        ------------ recursive without indirection\n-LL |     e: Foo<'a>,\n-   |        ------- recursive without indirection\n-LL |     x: Bar<'a>,\n-   |        ------- recursive without indirection\n+LL ~     y: (Box<Foo<'a>>, Box<Foo<'a>>),\n    |\n-   = help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Bar` representable\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0072`."}, {"sha": "f1d50bc8af5acbf584593c4bb2a7a6dc9a608b77", "filename": "src/test/ui/structs-enums/struct-rec/issue-74224.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-74224.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-74224.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-74224.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -2,12 +2,12 @@ error[E0072]: recursive type `A` has infinite size\n   --> $DIR/issue-74224.rs:1:1\n    |\n LL | struct A<T> {\n-   | ^^^^^^^^^^^ recursive type has infinite size\n+   | ^^^^^^^^^^^\n ...\n LL |     y: A<A<T>>,\n    |        ------- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `A` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL |     y: Box<A<A<T>>>,\n    |        ++++       +"}, {"sha": "536f54e3e96111d31dfb17e1a4ab73732b1cbaa8", "filename": "src/test/ui/structs-enums/struct-rec/issue-84611.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-84611.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-84611.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fissue-84611.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -2,12 +2,12 @@ error[E0072]: recursive type `Foo` has infinite size\n   --> $DIR/issue-84611.rs:1:1\n    |\n LL | struct Foo<T> {\n-   | ^^^^^^^^^^^^^ recursive type has infinite size\n+   | ^^^^^^^^^^^^^\n LL |\n LL |     x: Foo<[T; 1]>,\n    |        ----------- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL |     x: Box<Foo<[T; 1]>>,\n    |        ++++           +"}, {"sha": "3bfce8b4f9656e8dd0fc0c5678ef436aa464a90b", "filename": "src/test/ui/structs-enums/struct-rec/mutual-struct-recursion.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.rs?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -1,22 +1,20 @@\n struct A<T> {\n-//~^ ERROR recursive type `A` has infinite size\n+//~^ ERROR recursive types `A` and `B` have infinite size\n     x: T,\n     y: B<T>,\n }\n \n struct B<T> {\n-//~^ ERROR recursive type `B` has infinite size\n     z: A<T>\n }\n \n struct C<T> {\n-//~^ ERROR recursive type `C` has infinite size\n+//~^ ERROR recursive types `C` and `D` have infinite size\n     x: T,\n     y: Option<Option<D<T>>>,\n }\n \n struct D<T> {\n-//~^ ERROR recursive type `D` has infinite size\n     z: Option<Option<C<T>>>,\n }\n "}, {"sha": "881bc2819369b817a3b56824e5d9f66793fb718d", "filename": "src/test/ui/structs-enums/struct-rec/mutual-struct-recursion.stderr", "status": "modified", "additions": 26, "deletions": 36, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -1,59 +1,49 @@\n-error[E0072]: recursive type `A` has infinite size\n+error[E0072]: recursive types `A` and `B` have infinite size\n   --> $DIR/mutual-struct-recursion.rs:1:1\n    |\n LL | struct A<T> {\n-   | ^^^^^^^^^^^ recursive type has infinite size\n+   | ^^^^^^^^^^^\n ...\n LL |     y: B<T>,\n    |        ---- recursive without indirection\n-   |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `A` representable\n-   |\n-LL |     y: Box<B<T>>,\n-   |        ++++    +\n-\n-error[E0072]: recursive type `B` has infinite size\n-  --> $DIR/mutual-struct-recursion.rs:7:1\n-   |\n+...\n LL | struct B<T> {\n-   | ^^^^^^^^^^^ recursive type has infinite size\n-LL |\n+   | ^^^^^^^^^^^\n LL |     z: A<T>\n    |        ---- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `B` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n+   |\n+LL ~     y: Box<B<T>>,\n+LL | }\n+LL | \n+LL | struct B<T> {\n+LL ~     z: Box<A<T>>\n    |\n-LL |     z: Box<A<T>>\n-   |        ++++    +\n \n-error[E0072]: recursive type `C` has infinite size\n-  --> $DIR/mutual-struct-recursion.rs:12:1\n+error[E0072]: recursive types `C` and `D` have infinite size\n+  --> $DIR/mutual-struct-recursion.rs:11:1\n    |\n LL | struct C<T> {\n-   | ^^^^^^^^^^^ recursive type has infinite size\n+   | ^^^^^^^^^^^\n ...\n LL |     y: Option<Option<D<T>>>,\n-   |        -------------------- recursive without indirection\n-   |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `C` representable\n-   |\n-LL |     y: Option<Box<Option<D<T>>>>,\n-   |               ++++            +\n-\n-error[E0072]: recursive type `D` has infinite size\n-  --> $DIR/mutual-struct-recursion.rs:18:1\n-   |\n+   |                      ---- recursive without indirection\n+...\n LL | struct D<T> {\n-   | ^^^^^^^^^^^ recursive type has infinite size\n-LL |\n+   | ^^^^^^^^^^^\n LL |     z: Option<Option<C<T>>>,\n-   |        -------------------- recursive without indirection\n+   |                      ---- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `D` representable\n+LL ~     y: Option<Option<Box<D<T>>>>,\n+LL | }\n+LL | \n+LL | struct D<T> {\n+LL ~     z: Option<Option<Box<C<T>>>>,\n    |\n-LL |     z: Option<Box<Option<C<T>>>>,\n-   |               ++++            +\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0072`."}, {"sha": "cb0e982877cf76c26b00af90df425a80405aad06", "filename": "src/test/ui/type/type-recursive-box-shadowed.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Ftype%2Ftype-recursive-box-shadowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Ftype%2Ftype-recursive-box-shadowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-recursive-box-shadowed.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -2,12 +2,12 @@ error[E0072]: recursive type `Foo` has infinite size\n   --> $DIR/type-recursive-box-shadowed.rs:7:1\n    |\n LL | struct Foo {\n-   | ^^^^^^^^^^ recursive type has infinite size\n+   | ^^^^^^^^^^\n LL |\n LL |     inner: Foo,\n    |            --- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL |     inner: Box<Foo>,\n    |            ++++   +"}, {"sha": "9a4d798f61e01e1e8841f28ebad6945aa0e33ccf", "filename": "src/test/ui/type/type-recursive.stderr", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Ftype%2Ftype-recursive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Ftype%2Ftype-recursive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-recursive.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -2,12 +2,12 @@ error[E0072]: recursive type `T1` has infinite size\n   --> $DIR/type-recursive.rs:1:1\n    |\n LL | struct T1 {\n-   | ^^^^^^^^^ recursive type has infinite size\n+   | ^^^^^^^^^\n LL |     foo: isize,\n LL |     foolish: T1,\n    |              -- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T1` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL |     foolish: Box<T1>,\n    |              ++++  +\n@@ -16,11 +16,11 @@ error[E0072]: recursive type `T2` has infinite size\n   --> $DIR/type-recursive.rs:6:1\n    |\n LL | struct T2 {\n-   | ^^^^^^^^^ recursive type has infinite size\n+   | ^^^^^^^^^\n LL |     inner: Option<T2>,\n-   |            ---------- recursive without indirection\n+   |                   -- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T2` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL |     inner: Option<Box<T2>>,\n    |                   ++++  +\n@@ -29,11 +29,11 @@ error[E0072]: recursive type `T3` has infinite size\n   --> $DIR/type-recursive.rs:12:1\n    |\n LL | struct T3 {\n-   | ^^^^^^^^^ recursive type has infinite size\n+   | ^^^^^^^^^\n LL |     inner: OptionT3,\n    |            -------- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T3` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL |     inner: Box<OptionT3>,\n    |            ++++        +\n@@ -42,11 +42,9 @@ error[E0072]: recursive type `T4` has infinite size\n   --> $DIR/type-recursive.rs:16:1\n    |\n LL | struct T4(Option<T4>);\n-   | ^^^^^^^^^ ---------- recursive without indirection\n-   | |\n-   | recursive type has infinite size\n+   | ^^^^^^^^^        -- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T4` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL | struct T4(Option<Box<T4>>);\n    |                  ++++  +\n@@ -55,11 +53,11 @@ error[E0072]: recursive type `T5` has infinite size\n   --> $DIR/type-recursive.rs:18:1\n    |\n LL | enum T5 {\n-   | ^^^^^^^ recursive type has infinite size\n+   | ^^^^^^^\n LL |     Variant(Option<T5>),\n-   |             ---------- recursive without indirection\n+   |                    -- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T5` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL |     Variant(Option<Box<T5>>),\n    |                    ++++  +\n@@ -68,11 +66,11 @@ error[E0072]: recursive type `T6` has infinite size\n   --> $DIR/type-recursive.rs:22:1\n    |\n LL | enum T6 {\n-   | ^^^^^^^ recursive type has infinite size\n+   | ^^^^^^^\n LL |     Variant{ field: Option<T6> },\n-   |                     ---------- recursive without indirection\n+   |                            -- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T6` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n LL |     Variant{ field: Option<Box<T6>> },\n    |                            ++++  +\n@@ -81,14 +79,14 @@ error[E0072]: recursive type `T7` has infinite size\n   --> $DIR/type-recursive.rs:26:1\n    |\n LL | struct T7 {\n-   | ^^^^^^^^^ recursive type has infinite size\n+   | ^^^^^^^^^\n LL |     foo: std::cell::Cell<Option<T7>>,\n-   |          --------------------------- recursive without indirection\n+   |                                 -- recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T7` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n-LL |     foo: Box<std::cell::Cell<Option<T7>>>,\n-   |          ++++                           +\n+LL |     foo: std::cell::Cell<Option<Box<T7>>>,\n+   |                                 ++++  +\n \n error: aborting due to 7 previous errors\n "}, {"sha": "c266d2e9e138b83b9c3fbfcff16896172a012456", "filename": "src/test/ui/union/union-nonrepresentable.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Funion%2Funion-nonrepresentable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bba9785dd73f61aacd301a2cb379e1e85a129047/src%2Ftest%2Fui%2Funion%2Funion-nonrepresentable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-nonrepresentable.stderr?ref=bba9785dd73f61aacd301a2cb379e1e85a129047", "patch": "@@ -2,15 +2,15 @@ error[E0072]: recursive type `U` has infinite size\n   --> $DIR/union-nonrepresentable.rs:1:1\n    |\n LL | union U {\n-   | ^^^^^^^ recursive type has infinite size\n+   | ^^^^^^^\n LL |     a: u8,\n LL |     b: std::mem::ManuallyDrop<U>,\n-   |        ------------------------- recursive without indirection\n+   |                               - recursive without indirection\n    |\n-help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `U` representable\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle\n    |\n-LL |     b: Box<std::mem::ManuallyDrop<U>>,\n-   |        ++++                         +\n+LL |     b: std::mem::ManuallyDrop<Box<U>>,\n+   |                               ++++ +\n \n error: aborting due to previous error\n "}]}