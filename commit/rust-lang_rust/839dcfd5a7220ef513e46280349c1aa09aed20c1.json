{"sha": "839dcfd5a7220ef513e46280349c1aa09aed20c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzOWRjZmQ1YTcyMjBlZjUxM2U0NjI4MDM0OWMxYWEwOWFlZDIwYzE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-05-11T21:32:53Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-05-19T17:53:06Z"}, "message": "rustc_back: Refactor Archive to better express intent\n\nThis commit was initially written to target either `ar` or `lib.exe` for MSVC,\nbut it ended up not needing `lib.exe` support after all. I would personally like\nto refactor this to one day not invoke processes at all (but rather use the\n`llvm-ar.cpp` file in LLVM as alibrary) so I chose to preserve this refactoring\nto allow it to be easily done in the future.", "tree": {"sha": "ac1c9ed550779f9ca38d6f2dd41ef03fa078f693", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac1c9ed550779f9ca38d6f2dd41ef03fa078f693"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/839dcfd5a7220ef513e46280349c1aa09aed20c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/839dcfd5a7220ef513e46280349c1aa09aed20c1", "html_url": "https://github.com/rust-lang/rust/commit/839dcfd5a7220ef513e46280349c1aa09aed20c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/839dcfd5a7220ef513e46280349c1aa09aed20c1/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9846e902dae169255c2d2b1766e7b9846488a89", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9846e902dae169255c2d2b1766e7b9846488a89", "html_url": "https://github.com/rust-lang/rust/commit/f9846e902dae169255c2d2b1766e7b9846488a89"}], "stats": {"total": 174, "additions": 87, "deletions": 87}, "files": [{"sha": "cd2e27cf58d6067bc8407fb8164c0c03d9f2568e", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 87, "deletions": 87, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/839dcfd5a7220ef513e46280349c1aa09aed20c1/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/839dcfd5a7220ef513e46280349c1aa09aed20c1/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=839dcfd5a7220ef513e46280349c1aa09aed20c1", "patch": "@@ -30,16 +30,11 @@ pub struct ArchiveConfig<'a> {\n     pub lib_search_paths: Vec<PathBuf>,\n     pub slib_prefix: String,\n     pub slib_suffix: String,\n-    pub maybe_ar_prog: Option<String>\n+    pub ar_prog: String\n }\n \n pub struct Archive<'a> {\n-    handler: &'a ErrorHandler,\n-    dst: PathBuf,\n-    lib_search_paths: Vec<PathBuf>,\n-    slib_prefix: String,\n-    slib_suffix: String,\n-    maybe_ar_prog: Option<String>\n+    config: ArchiveConfig<'a>,\n }\n \n /// Helper for adding many files to an archive with a single invocation of\n@@ -53,47 +48,10 @@ pub struct ArchiveBuilder<'a> {\n     should_update_symbols: bool,\n }\n \n-fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n-          args: &str, cwd: Option<&Path>,\n-          paths: &[&Path]) -> Output {\n-    let ar = match *maybe_ar_prog {\n-        Some(ref ar) => &ar[..],\n-        None => \"ar\"\n-    };\n-    let mut cmd = Command::new(ar);\n-\n-    cmd.arg(args).args(paths).stdout(Stdio::piped()).stderr(Stdio::piped());\n-    debug!(\"{:?}\", cmd);\n-\n-    match cwd {\n-        Some(p) => {\n-            cmd.current_dir(p);\n-            debug!(\"inside {:?}\", p.display());\n-        }\n-        None => {}\n-    }\n-\n-    match cmd.spawn() {\n-        Ok(prog) => {\n-            let o = prog.wait_with_output().unwrap();\n-            if !o.status.success() {\n-                handler.err(&format!(\"{:?} failed with: {}\", cmd, o.status));\n-                handler.note(&format!(\"stdout ---\\n{}\",\n-                                  str::from_utf8(&o.stdout).unwrap()));\n-                handler.note(&format!(\"stderr ---\\n{}\",\n-                                  str::from_utf8(&o.stderr).unwrap())\n-                             );\n-                handler.abort_if_errors();\n-            }\n-            o\n-        },\n-        Err(e) => {\n-            handler.err(&format!(\"could not exec `{}`: {}\", &ar[..],\n-                             e));\n-            handler.abort_if_errors();\n-            panic!(\"rustc::back::archive::run_ar() should not reach this point\");\n-        }\n-    }\n+enum Action<'a> {\n+    Remove(&'a Path),\n+    AddObjects(&'a [&'a PathBuf], bool),\n+    UpdateSymbols,\n }\n \n pub fn find_library(name: &str, osprefix: &str, ossuffix: &str,\n@@ -120,43 +78,89 @@ pub fn find_library(name: &str, osprefix: &str, ossuffix: &str,\n \n impl<'a> Archive<'a> {\n     fn new(config: ArchiveConfig<'a>) -> Archive<'a> {\n-        let ArchiveConfig { handler, dst, lib_search_paths, slib_prefix, slib_suffix,\n-            maybe_ar_prog } = config;\n-        Archive {\n-            handler: handler,\n-            dst: dst,\n-            lib_search_paths: lib_search_paths,\n-            slib_prefix: slib_prefix,\n-            slib_suffix: slib_suffix,\n-            maybe_ar_prog: maybe_ar_prog\n-        }\n+        Archive { config: config }\n     }\n \n     /// Opens an existing static archive\n     pub fn open(config: ArchiveConfig<'a>) -> Archive<'a> {\n         let archive = Archive::new(config);\n-        assert!(archive.dst.exists());\n+        assert!(archive.config.dst.exists());\n         archive\n     }\n \n     /// Removes a file from this archive\n     pub fn remove_file(&mut self, file: &str) {\n-        run_ar(self.handler, &self.maybe_ar_prog, \"d\", None, &[&self.dst, &Path::new(file)]);\n+        self.run(None, Action::Remove(Path::new(file)));\n     }\n \n     /// Lists all files in an archive\n     pub fn files(&self) -> Vec<String> {\n-        let output = run_ar(self.handler, &self.maybe_ar_prog, \"t\", None, &[&self.dst]);\n-        let output = str::from_utf8(&output.stdout).unwrap();\n-        // use lines_any because windows delimits output with `\\r\\n` instead of\n-        // just `\\n`\n-        output.lines_any().map(|s| s.to_string()).collect()\n+        let archive = match ArchiveRO::open(&self.config.dst) {\n+            Some(ar) => ar,\n+            None => return Vec::new(),\n+        };\n+        let ret = archive.iter().filter_map(|child| child.name())\n+                         .map(|name| name.to_string())\n+                         .collect();\n+        return ret;\n     }\n \n     /// Creates an `ArchiveBuilder` for adding files to this archive.\n     pub fn extend(self) -> ArchiveBuilder<'a> {\n         ArchiveBuilder::new(self)\n     }\n+\n+    fn run(&self, cwd: Option<&Path>, action: Action) -> Output {\n+        let abs_dst = env::current_dir().unwrap().join(&self.config.dst);\n+        let ar = &self.config.ar_prog;\n+        let mut cmd = Command::new(ar);\n+        cmd.stdout(Stdio::piped()).stderr(Stdio::piped());\n+        self.prepare_ar_action(&mut cmd, &abs_dst, action);\n+        info!(\"{:?}\", cmd);\n+\n+        if let Some(p) = cwd {\n+            cmd.current_dir(p);\n+            info!(\"inside {:?}\", p.display());\n+        }\n+\n+        let handler = &self.config.handler;\n+        match cmd.spawn() {\n+            Ok(prog) => {\n+                let o = prog.wait_with_output().unwrap();\n+                if !o.status.success() {\n+                    handler.err(&format!(\"{:?} failed with: {}\", cmd, o.status));\n+                    handler.note(&format!(\"stdout ---\\n{}\",\n+                                          str::from_utf8(&o.stdout).unwrap()));\n+                    handler.note(&format!(\"stderr ---\\n{}\",\n+                                          str::from_utf8(&o.stderr).unwrap()));\n+                    handler.abort_if_errors();\n+                }\n+                o\n+            },\n+            Err(e) => {\n+                handler.err(&format!(\"could not exec `{}`: {}\",\n+                                     self.config.ar_prog, e));\n+                handler.abort_if_errors();\n+                panic!(\"rustc::back::archive::run() should not reach this point\");\n+            }\n+        }\n+    }\n+\n+    fn prepare_ar_action(&self, cmd: &mut Command, dst: &Path, action: Action) {\n+        match action {\n+            Action::Remove(file) => {\n+                cmd.arg(\"d\").arg(dst).arg(file);\n+            }\n+            Action::AddObjects(objs, update_symbols) => {\n+                cmd.arg(if update_symbols {\"crus\"} else {\"cruS\"})\n+                   .arg(dst)\n+                   .args(objs);\n+            }\n+            Action::UpdateSymbols => {\n+                cmd.arg(\"s\").arg(dst);\n+            }\n+        }\n+    }\n }\n \n impl<'a> ArchiveBuilder<'a> {\n@@ -179,10 +183,10 @@ impl<'a> ArchiveBuilder<'a> {\n     /// search in the relevant locations for a library named `name`.\n     pub fn add_native_library(&mut self, name: &str) -> io::Result<()> {\n         let location = find_library(name,\n-                                    &self.archive.slib_prefix,\n-                                    &self.archive.slib_suffix,\n-                                    &self.archive.lib_search_paths,\n-                                    self.archive.handler);\n+                                    &self.archive.config.slib_prefix,\n+                                    &self.archive.config.slib_suffix,\n+                                    &self.archive.config.lib_search_paths,\n+                                    self.archive.config.handler);\n         self.add_archive(&location, name, |_| false)\n     }\n \n@@ -229,17 +233,13 @@ impl<'a> ArchiveBuilder<'a> {\n     pub fn build(self) -> Archive<'a> {\n         // Get an absolute path to the destination, so `ar` will work even\n         // though we run it from `self.work_dir`.\n-        let abs_dst = env::current_dir().unwrap().join(&self.archive.dst);\n-        assert!(!abs_dst.is_relative());\n-        let mut args = vec![&*abs_dst];\n-        let mut total_len = abs_dst.to_string_lossy().len();\n+        let mut objects = Vec::new();\n+        let mut total_len = self.archive.config.dst.to_string_lossy().len();\n \n         if self.members.is_empty() {\n-            // OSX `ar` does not allow using `r` with no members, but it does\n-            // allow running `ar s file.a` to update symbols only.\n             if self.should_update_symbols {\n-                run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-                       \"s\", Some(self.work_dir.path()), &args[..]);\n+                self.archive.run(Some(self.work_dir.path()),\n+                                 Action::UpdateSymbols);\n             }\n             return self.archive;\n         }\n@@ -257,24 +257,22 @@ impl<'a> ArchiveBuilder<'a> {\n             // string, not an array of strings.)\n             if total_len + len + 1 > ARG_LENGTH_LIMIT {\n                 // Add the archive members seen so far, without updating the\n-                // symbol table (`S`).\n-                run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-                       \"cruS\", Some(self.work_dir.path()), &args[..]);\n+                // symbol table.\n+                self.archive.run(Some(self.work_dir.path()),\n+                                 Action::AddObjects(&objects, false));\n \n-                args.clear();\n-                args.push(&abs_dst);\n-                total_len = abs_dst.to_string_lossy().len();\n+                objects.clear();\n+                total_len = self.archive.config.dst.to_string_lossy().len();\n             }\n \n-            args.push(member_name);\n+            objects.push(member_name);\n             total_len += len + 1;\n         }\n \n         // Add the remaining archive members, and update the symbol table if\n         // necessary.\n-        let flags = if self.should_update_symbols { \"crus\" } else { \"cruS\" };\n-        run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-               flags, Some(self.work_dir.path()), &args[..]);\n+        self.archive.run(Some(self.work_dir.path()),\n+                         Action::AddObjects(&objects, self.should_update_symbols));\n \n         self.archive\n     }\n@@ -305,6 +303,8 @@ impl<'a> ArchiveBuilder<'a> {\n             };\n             if filename.contains(\".SYMDEF\") { continue }\n             if skip(filename) { continue }\n+            let filename = Path::new(filename).file_name().unwrap()\n+                                              .to_str().unwrap();\n \n             // An archive can contain files of the same name multiple times, so\n             // we need to be sure to not have them overwrite one another when we"}]}