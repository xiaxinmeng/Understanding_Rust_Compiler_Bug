{"sha": "97d4e76c20ec2e80affd100dd169155914370fd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3ZDRlNzZjMjBlYzJlODBhZmZkMTAwZGQxNjkxNTU5MTQzNzBmZDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-27T22:46:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-27T22:46:48Z"}, "message": "Auto merge of #24701 - Stebalien:slice, r=alexcrichton\n\nInstead of using the O(n) defaults, define O(1) shortcuts. I also copied (and slightly modified) the relevant tests from the iter tests into the slice tests just in case someone comes along and changes them in the future.\r\n\r\nPartially implements  #24214.", "tree": {"sha": "dc2285a690b84ce31a19cfe61e401770a0b51d63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc2285a690b84ce31a19cfe61e401770a0b51d63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97d4e76c20ec2e80affd100dd169155914370fd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97d4e76c20ec2e80affd100dd169155914370fd2", "html_url": "https://github.com/rust-lang/rust/commit/97d4e76c20ec2e80affd100dd169155914370fd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97d4e76c20ec2e80affd100dd169155914370fd2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c88f3be126d0fe02a92c20e1d78192f4b648401", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c88f3be126d0fe02a92c20e1d78192f4b648401", "html_url": "https://github.com/rust-lang/rust/commit/9c88f3be126d0fe02a92c20e1d78192f4b648401"}, {"sha": "e129b92c40678f65490ce58fa06079d38ae07eba", "url": "https://api.github.com/repos/rust-lang/rust/commits/e129b92c40678f65490ce58fa06079d38ae07eba", "html_url": "https://github.com/rust-lang/rust/commit/e129b92c40678f65490ce58fa06079d38ae07eba"}], "stats": {"total": 135, "additions": 110, "deletions": 25}, "files": [{"sha": "38e66c5a3d6a2460e4e474a41f7e0c78a0ffb287", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 79, "deletions": 25, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/97d4e76c20ec2e80affd100dd169155914370fd2/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97d4e76c20ec2e80affd100dd169155914370fd2/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=97d4e76c20ec2e80affd100dd169155914370fd2", "patch": "@@ -625,6 +625,36 @@ impl<'a, T> IntoIterator for &'a mut [T] {\n     }\n }\n \n+#[inline(always)]\n+fn size_from_ptr<T>(_: *const T) -> usize {\n+    mem::size_of::<T>()\n+}\n+\n+\n+// Use macro to be generic over const/mut\n+macro_rules! slice_offset {\n+    ($ptr:expr, $by:expr) => {{\n+        let ptr = $ptr;\n+        if size_from_ptr(ptr) == 0 {\n+            transmute(ptr as usize + $by)\n+        } else {\n+            ptr.offset($by)\n+        }\n+    }};\n+}\n+\n+macro_rules! slice_ref {\n+    ($ptr:expr) => {{\n+        let ptr = $ptr;\n+        if size_from_ptr(ptr) == 0 {\n+            // Use a non-null pointer value\n+            &mut *(1 as *mut _)\n+        } else {\n+            transmute(ptr)\n+        }\n+    }};\n+}\n+\n // The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n@@ -641,20 +671,9 @@ macro_rules! iterator {\n                     if self.ptr == self.end {\n                         None\n                     } else {\n-                        if mem::size_of::<T>() == 0 {\n-                            // purposefully don't use 'ptr.offset' because for\n-                            // vectors with 0-size elements this would return the\n-                            // same pointer.\n-                            self.ptr = transmute(self.ptr as usize + 1);\n-\n-                            // Use a non-null pointer value\n-                            Some(&mut *(1 as *mut _))\n-                        } else {\n-                            let old = self.ptr;\n-                            self.ptr = self.ptr.offset(1);\n-\n-                            Some(transmute(old))\n-                        }\n+                        let old = self.ptr;\n+                        self.ptr = slice_offset!(self.ptr, 1);\n+                        Some(slice_ref!(old))\n                     }\n                 }\n             }\n@@ -666,6 +685,22 @@ macro_rules! iterator {\n                 let exact = diff / (if size == 0 {1} else {size});\n                 (exact, Some(exact))\n             }\n+\n+            #[inline]\n+            fn count(self) -> usize {\n+                self.size_hint().0\n+            }\n+\n+            #[inline]\n+            fn nth(&mut self, n: usize) -> Option<$elem> {\n+                // Call helper method. Can't put the definition here because mut versus const.\n+                self.iter_nth(n)\n+            }\n+\n+            #[inline]\n+            fn last(mut self) -> Option<$elem> {\n+                self.next_back()\n+            }\n         }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -679,17 +714,8 @@ macro_rules! iterator {\n                     if self.end == self.ptr {\n                         None\n                     } else {\n-                        if mem::size_of::<T>() == 0 {\n-                            // See above for why 'ptr.offset' isn't used\n-                            self.end = transmute(self.end as usize - 1);\n-\n-                            // Use a non-null pointer value\n-                            Some(&mut *(1 as *mut _))\n-                        } else {\n-                            self.end = self.end.offset(-1);\n-\n-                            Some(transmute(self.end))\n-                        }\n+                        self.end = slice_offset!(self.end, -1);\n+                        Some(slice_ref!(self.end))\n                     }\n                 }\n             }\n@@ -785,6 +811,20 @@ impl<'a, T> Iter<'a, T> {\n     pub fn as_slice(&self) -> &'a [T] {\n         make_slice!(T => &'a [T]: self.ptr, self.end)\n     }\n+\n+    // Helper function for Iter::nth\n+    fn iter_nth(&mut self, n: usize) -> Option<&'a T> {\n+        match self.as_slice().get(n) {\n+            Some(elem_ref) => unsafe {\n+                self.ptr = slice_offset!(elem_ref as *const _, 1);\n+                Some(slice_ref!(elem_ref))\n+            },\n+            None => {\n+                self.ptr = self.end;\n+                None\n+            }\n+        }\n+    }\n }\n \n iterator!{struct Iter -> *const T, &'a T}\n@@ -914,6 +954,20 @@ impl<'a, T> IterMut<'a, T> {\n     pub fn into_slice(self) -> &'a mut [T] {\n         make_mut_slice!(T => &'a mut [T]: self.ptr, self.end)\n     }\n+\n+    // Helper function for IterMut::nth\n+    fn iter_nth(&mut self, n: usize) -> Option<&'a mut T> {\n+        match make_mut_slice!(T => &'a mut [T]: self.ptr, self.end).get_mut(n) {\n+            Some(elem_ref) => unsafe {\n+                self.ptr = slice_offset!(elem_ref as *mut _, 1);\n+                Some(slice_ref!(elem_ref))\n+            },\n+            None => {\n+                self.ptr = self.end;\n+                None\n+            }\n+        }\n+    }\n }\n \n iterator!{struct IterMut -> *mut T, &'a mut T}"}, {"sha": "7c884a73ce05bd4a83e86cc29cb3baef47ad6ba1", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/97d4e76c20ec2e80affd100dd169155914370fd2/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97d4e76c20ec2e80affd100dd169155914370fd2/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=97d4e76c20ec2e80affd100dd169155914370fd2", "patch": "@@ -82,3 +82,34 @@ fn iterator_to_slice() {\n     test!([1u8,2,3]);\n     test!([(),(),()]);\n }\n+\n+#[test]\n+fn test_iterator_nth() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+    for i in 0..v.len() {\n+        assert_eq!(v.iter().nth(i).unwrap(), &v[i]);\n+    }\n+    assert_eq!(v.iter().nth(v.len()), None);\n+\n+    let mut iter = v.iter();\n+    assert_eq!(iter.nth(2).unwrap(), &v[2]);\n+    assert_eq!(iter.nth(1).unwrap(), &v[4]);\n+}\n+\n+#[test]\n+fn test_iterator_last() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+    assert_eq!(v.iter().last().unwrap(), &4);\n+    assert_eq!(v[..1].iter().last().unwrap(), &0);\n+}\n+\n+#[test]\n+fn test_iterator_count() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+    assert_eq!(v.iter().count(), 5);\n+\n+    let mut iter2 = v.iter();\n+    iter2.next();\n+    iter2.next();\n+    assert_eq!(iter2.count(), 3);\n+}"}]}