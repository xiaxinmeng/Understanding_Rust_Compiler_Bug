{"sha": "881a7cd86ef1001bdfa9590878ca24e57794302f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4MWE3Y2Q4NmVmMTAwMWJkZmE5NTkwODc4Y2EyNGU1Nzc5NDMwMmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-17T14:23:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-17T14:23:57Z"}, "message": "Auto merge of #49836 - nikomatsakis:nll-facts-prep, r=pnkfelix\n\nprep work for using timely dataflow with NLL\n\nTwo major changes:\n\n**Two-phase borrows are overhauled.** We no longer have two bits per borrow. Instead, we track -- for each borrow -- an (optional) \"activation point\". Then, for each point P where the borrow is in scope, we check where P falls relative to the activation point. If P is between the reservation point and the activation point, then this is the \"reservation\" phase of the borrow, else the borrow is considered active. This is simpler and means that the dataflow doesn't have to care about 2-phase at all, at last not yet.\n\n**We no longer support using the MIR borrow checker without NLL.** It is going to be increasingly untenable to support lexical mode as we go forward, I think, and also of increasingly little value. This also exposed a few bugs in NLL mode due to increased testing.\n\nr? @pnkfelix\ncc @bobtwinkles", "tree": {"sha": "947639046e0b0f2a1ddc5d0ad6d6f4e33040ff44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/947639046e0b0f2a1ddc5d0ad6d6f4e33040ff44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/881a7cd86ef1001bdfa9590878ca24e57794302f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/881a7cd86ef1001bdfa9590878ca24e57794302f", "html_url": "https://github.com/rust-lang/rust/commit/881a7cd86ef1001bdfa9590878ca24e57794302f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/881a7cd86ef1001bdfa9590878ca24e57794302f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d703622ce08d51eb91a909278f7917762e743438", "url": "https://api.github.com/repos/rust-lang/rust/commits/d703622ce08d51eb91a909278f7917762e743438", "html_url": "https://github.com/rust-lang/rust/commit/d703622ce08d51eb91a909278f7917762e743438"}, {"sha": "96dba9358c5ad24bc33eeb3a9a39a4868c331bcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/96dba9358c5ad24bc33eeb3a9a39a4868c331bcf", "html_url": "https://github.com/rust-lang/rust/commit/96dba9358c5ad24bc33eeb3a9a39a4868c331bcf"}], "stats": {"total": 2269, "additions": 1141, "deletions": 1128}, "files": [{"sha": "d8a2c95ab5904f1adadc5c1ad00f2a0a0808924b", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -303,28 +303,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n-        if will_later_be_reported_by_nll && self.tcx.nll() {\n+        if will_later_be_reported_by_nll && self.tcx.use_mir_borrowck() {\n             // With `#![feature(nll)]`, we want to present a nice user\n             // experience, so don't even mention the errors from the\n             // AST checker.\n             if self.tcx.features().nll {\n                 return;\n             }\n \n-            // But with -Znll, it's nice to have some note for later.\n+            // But with nll, it's nice to have some note for later.\n             for error in errors {\n                 match *error {\n                     RegionResolutionError::ConcreteFailure(ref origin, ..)\n                     | RegionResolutionError::GenericBoundFailure(ref origin, ..) => {\n                         self.tcx\n                             .sess\n-                            .span_warn(origin.span(), \"not reporting region error due to -Znll\");\n+                            .span_warn(origin.span(), \"not reporting region error due to nll\");\n                     }\n \n                     RegionResolutionError::SubSupConflict(ref rvo, ..) => {\n                         self.tcx\n                             .sess\n-                            .span_warn(rvo.span(), \"not reporting region error due to -Znll\");\n+                            .span_warn(rvo.span(), \"not reporting region error due to nll\");\n                     }\n                 }\n             }"}, {"sha": "c525c4ed651f244faf93df66289f4884629441c3", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1991,7 +1991,7 @@ impl Location {\n         Location { block: self.block, statement_index: self.statement_index + 1 }\n     }\n \n-    pub fn dominates(&self, other: &Location, dominators: &Dominators<BasicBlock>) -> bool {\n+    pub fn dominates(&self, other: Location, dominators: &Dominators<BasicBlock>) -> bool {\n         if self.block == other.block {\n             self.statement_index <= other.statement_index\n         } else {"}, {"sha": "59823390a0a5861f6ad3472e1c4f1e007846f98d", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1259,8 +1259,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         useful for profiling / PGO.\"),\n     relro_level: Option<RelroLevel> = (None, parse_relro_level, [TRACKED],\n         \"choose which RELRO level to use\"),\n-    nll: bool = (false, parse_bool, [UNTRACKED],\n-                 \"run the non-lexical lifetimes MIR pass\"),\n     disable_nll_user_type_assert: bool = (false, parse_bool, [UNTRACKED],\n         \"disable user provided type assertion in NLL\"),\n     trans_time_graph: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "28ad5edbd2db7ad376e1c7d3adace5694f62bb7b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1459,15 +1459,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.on_disk_query_result_cache.serialize(self.global_tcx(), encoder)\n     }\n \n-    /// If true, we should use NLL-style region checking instead of\n-    /// lexical style.\n-    pub fn nll(self) -> bool {\n-        self.features().nll || self.sess.opts.debugging_opts.nll\n-    }\n-\n     /// If true, we should use the MIR-based borrowck (we may *also* use\n     /// the AST-based borrowck).\n-    pub fn use_mir(self) -> bool {\n+    pub fn use_mir_borrowck(self) -> bool {\n         self.borrowck_mode().use_mir()\n     }\n \n@@ -1486,7 +1480,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             mode @ BorrowckMode::Compare => mode,\n \n             mode @ BorrowckMode::Ast => {\n-                if self.nll() {\n+                if self.features().nll {\n                     BorrowckMode::Mir\n                 } else {\n                     mode\n@@ -1500,11 +1494,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// MIR borrowck, but not when NLL is used. They are also consumed\n     /// by the validation stuff.\n     pub fn emit_end_regions(self) -> bool {\n-        // FIXME(#46875) -- we should not emit end regions when NLL is enabled,\n-        // but for now we can't stop doing so because it causes false positives\n         self.sess.opts.debugging_opts.emit_end_regions ||\n             self.sess.opts.debugging_opts.mir_emit_validate > 0 ||\n-            self.use_mir()\n+            self.use_mir_borrowck()\n     }\n \n     #[inline]"}, {"sha": "ccfb44a8b58fbf3ab1cda42cb11a82cf5daac592", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -0,0 +1,328 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::place_ext::PlaceExt;\n+use dataflow::indexes::BorrowIndex;\n+use rustc::mir::traversal;\n+use rustc::mir::visit::{PlaceContext, Visitor};\n+use rustc::mir::{self, Location, Mir, Place};\n+use rustc::ty::{Region, TyCtxt};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use std::fmt;\n+use std::hash::Hash;\n+use std::ops::Index;\n+\n+crate struct BorrowSet<'tcx> {\n+    /// The fundamental map relating bitvector indexes to the borrows\n+    /// in the MIR.\n+    crate borrows: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n+\n+    /// Each borrow is also uniquely identified in the MIR by the\n+    /// `Location` of the assignment statement in which it appears on\n+    /// the right hand side; we map each such location to the\n+    /// corresponding `BorrowIndex`.\n+    crate location_map: FxHashMap<Location, BorrowIndex>,\n+\n+    /// Locations which activate borrows.\n+    /// NOTE: A given location may activate more than one borrow in the future\n+    /// when more general two-phase borrow support is introduced, but for now we\n+    /// only need to store one borrow index\n+    crate activation_map: FxHashMap<Location, Vec<BorrowIndex>>,\n+\n+    /// Every borrow has a region; this maps each such regions back to\n+    /// its borrow-indexes.\n+    crate region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n+\n+    /// Map from local to all the borrows on that local\n+    crate local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n+}\n+\n+impl<'tcx> Index<BorrowIndex> for BorrowSet<'tcx> {\n+    type Output = BorrowData<'tcx>;\n+\n+    fn index(&self, index: BorrowIndex) -> &BorrowData<'tcx> {\n+        &self.borrows[index]\n+    }\n+}\n+\n+#[derive(Debug)]\n+crate struct BorrowData<'tcx> {\n+    /// Location where the borrow reservation starts.\n+    /// In many cases, this will be equal to the activation location but not always.\n+    crate reserve_location: Location,\n+    /// Location where the borrow is activated. None if this is not a\n+    /// 2-phase borrow.\n+    crate activation_location: Option<Location>,\n+    /// What kind of borrow this is\n+    crate kind: mir::BorrowKind,\n+    /// The region for which this borrow is live\n+    crate region: Region<'tcx>,\n+    /// Place from which we are borrowing\n+    crate borrowed_place: mir::Place<'tcx>,\n+    /// Place to which the borrow was stored\n+    crate assigned_place: mir::Place<'tcx>,\n+}\n+\n+impl<'tcx> fmt::Display for BorrowData<'tcx> {\n+    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n+        let kind = match self.kind {\n+            mir::BorrowKind::Shared => \"\",\n+            mir::BorrowKind::Unique => \"uniq \",\n+            mir::BorrowKind::Mut { .. } => \"mut \",\n+        };\n+        let region = format!(\"{}\", self.region);\n+        let region = if region.len() > 0 {\n+            format!(\"{} \", region)\n+        } else {\n+            region\n+        };\n+        write!(w, \"&{}{}{:?}\", region, kind, self.borrowed_place)\n+    }\n+}\n+\n+impl<'tcx> BorrowSet<'tcx> {\n+    pub fn build(tcx: TyCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) -> Self {\n+        let mut visitor = GatherBorrows {\n+            tcx,\n+            mir,\n+            idx_vec: IndexVec::new(),\n+            location_map: FxHashMap(),\n+            activation_map: FxHashMap(),\n+            region_map: FxHashMap(),\n+            local_map: FxHashMap(),\n+            pending_activations: FxHashMap(),\n+        };\n+\n+        for (block, block_data) in traversal::preorder(mir) {\n+            visitor.visit_basic_block_data(block, block_data);\n+        }\n+\n+        // Double check: We should have found an activation for every pending\n+        // activation.\n+        assert_eq!(\n+            visitor\n+                .pending_activations\n+                .iter()\n+                .find(|&(_local, &borrow_index)| visitor.idx_vec[borrow_index]\n+                    .activation_location\n+                    .is_none()),\n+            None,\n+            \"never found an activation for this borrow!\",\n+        );\n+\n+        BorrowSet {\n+            borrows: visitor.idx_vec,\n+            location_map: visitor.location_map,\n+            activation_map: visitor.activation_map,\n+            region_map: visitor.region_map,\n+            local_map: visitor.local_map,\n+        }\n+    }\n+\n+    crate fn activations_at_location(&self, location: Location) -> &[BorrowIndex] {\n+        self.activation_map\n+            .get(&location)\n+            .map(|activations| &activations[..])\n+            .unwrap_or(&[])\n+    }\n+}\n+\n+struct GatherBorrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+    idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n+    location_map: FxHashMap<Location, BorrowIndex>,\n+    activation_map: FxHashMap<Location, Vec<BorrowIndex>>,\n+    region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n+    local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n+\n+    /// When we encounter a 2-phase borrow statement, it will always\n+    /// be assigning into a temporary TEMP:\n+    ///\n+    ///    TEMP = &foo\n+    ///\n+    /// We add TEMP into this map with `b`, where `b` is the index of\n+    /// the borrow. When we find a later use of this activation, we\n+    /// remove from the map (and add to the \"tombstone\" set below).\n+    pending_activations: FxHashMap<mir::Local, BorrowIndex>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n+    fn visit_assign(\n+        &mut self,\n+        block: mir::BasicBlock,\n+        assigned_place: &mir::Place<'tcx>,\n+        rvalue: &mir::Rvalue<'tcx>,\n+        location: mir::Location,\n+    ) {\n+        if let mir::Rvalue::Ref(region, kind, ref borrowed_place) = *rvalue {\n+            if borrowed_place.is_unsafe_place(self.tcx, self.mir) {\n+                return;\n+            }\n+\n+            let borrow = BorrowData {\n+                kind,\n+                region,\n+                reserve_location: location,\n+                activation_location: None,\n+                borrowed_place: borrowed_place.clone(),\n+                assigned_place: assigned_place.clone(),\n+            };\n+            let idx = self.idx_vec.push(borrow);\n+            self.location_map.insert(location, idx);\n+\n+            self.insert_as_pending_if_two_phase(location, &assigned_place, region, kind, idx);\n+\n+            insert(&mut self.region_map, &region, idx);\n+            if let Some(local) = borrowed_place.root_local() {\n+                insert(&mut self.local_map, &local, idx);\n+            }\n+        }\n+\n+        return self.super_assign(block, assigned_place, rvalue, location);\n+\n+        fn insert<'a, K, V>(map: &'a mut FxHashMap<K, FxHashSet<V>>, k: &K, v: V)\n+        where\n+            K: Clone + Eq + Hash,\n+            V: Eq + Hash,\n+        {\n+            map.entry(k.clone()).or_insert(FxHashSet()).insert(v);\n+        }\n+    }\n+\n+    fn visit_place(\n+        &mut self,\n+        place: &mir::Place<'tcx>,\n+        context: PlaceContext<'tcx>,\n+        location: Location,\n+    ) {\n+        self.super_place(place, context, location);\n+\n+        // We found a use of some temporary TEMP...\n+        if let Place::Local(temp) = place {\n+            // ... check whether we (earlier) saw a 2-phase borrow like\n+            //\n+            //     TMP = &mut place\n+            match self.pending_activations.get(temp) {\n+                Some(&borrow_index) => {\n+                    let borrow_data = &mut self.idx_vec[borrow_index];\n+\n+                    // Watch out: the use of TMP in the borrow\n+                    // itself doesn't count as an\n+                    // activation. =)\n+                    if borrow_data.reserve_location == location && context == PlaceContext::Store {\n+                        return;\n+                    }\n+\n+                    if let Some(other_activation) = borrow_data.activation_location {\n+                        span_bug!(\n+                            self.mir.source_info(location).span,\n+                            \"found two activations for 2-phase borrow temporary {:?}: \\\n+                             {:?} and {:?}\",\n+                            temp,\n+                            location,\n+                            other_activation,\n+                        );\n+                    }\n+\n+                    // Otherwise, this is the unique later use\n+                    // that we expect.\n+                    borrow_data.activation_location = Some(location);\n+                    self.activation_map\n+                        .entry(location)\n+                        .or_insert(Vec::new())\n+                        .push(borrow_index);\n+                }\n+\n+                None => {}\n+            }\n+        }\n+    }\n+\n+    fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'tcx>, location: mir::Location) {\n+        if let mir::Rvalue::Ref(region, kind, ref place) = *rvalue {\n+            // double-check that we already registered a BorrowData for this\n+\n+            let borrow_index = self.location_map[&location];\n+            let borrow_data = &self.idx_vec[borrow_index];\n+            assert_eq!(borrow_data.reserve_location, location);\n+            assert_eq!(borrow_data.kind, kind);\n+            assert_eq!(borrow_data.region, region);\n+            assert_eq!(borrow_data.borrowed_place, *place);\n+        }\n+\n+        return self.super_rvalue(rvalue, location);\n+    }\n+\n+    fn visit_statement(\n+        &mut self,\n+        block: mir::BasicBlock,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        return self.super_statement(block, statement, location);\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> GatherBorrows<'a, 'gcx, 'tcx> {\n+    /// Returns true if the borrow represented by `kind` is\n+    /// allowed to be split into separate Reservation and\n+    /// Activation phases.\n+    fn allow_two_phase_borrow(&self, kind: mir::BorrowKind) -> bool {\n+        self.tcx.two_phase_borrows()\n+            && (kind.allows_two_phase_borrow()\n+                || self.tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n+    }\n+\n+    /// If this is a two-phase borrow, then we will record it\n+    /// as \"pending\" until we find the activating use.\n+    fn insert_as_pending_if_two_phase(\n+        &mut self,\n+        start_location: Location,\n+        assigned_place: &mir::Place<'tcx>,\n+        region: Region<'tcx>,\n+        kind: mir::BorrowKind,\n+        borrow_index: BorrowIndex,\n+    ) {\n+        debug!(\n+            \"Borrows::insert_as_pending_if_two_phase({:?}, {:?}, {:?}, {:?})\",\n+            start_location, assigned_place, region, borrow_index,\n+        );\n+\n+        if !self.allow_two_phase_borrow(kind) {\n+            debug!(\"  -> {:?}\", start_location);\n+            return;\n+        }\n+\n+        // When we encounter a 2-phase borrow statement, it will always\n+        // be assigning into a temporary TEMP:\n+        //\n+        //    TEMP = &foo\n+        //\n+        // so extract `temp`.\n+        let temp = if let &mir::Place::Local(temp) = assigned_place {\n+            temp\n+        } else {\n+            span_bug!(\n+                self.mir.source_info(start_location).span,\n+                \"expected 2-phase borrow to assign to a local, not `{:?}`\",\n+                assigned_place,\n+            );\n+        };\n+\n+        // Insert `temp` into the list of pending activations. From\n+        // now on, we'll be on the lookout for a use of it. Note that\n+        // we are guaranteed that this use will come after the\n+        // assignment.\n+        let old_value = self.pending_activations.insert(temp, borrow_index);\n+        assert!(old_value.is_none());\n+    }\n+}"}, {"sha": "3dc5a7a84900cb280376e1933ddb24b5413321fd", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 11, "deletions": 46, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -18,7 +18,9 @@ use rustc_data_structures::sync::Lrc;\n \n use super::{Context, MirBorrowckCtxt};\n use super::{InitializationRequiringAction, PrefixSet};\n-use dataflow::{Borrows, BorrowData, FlowAtLocation, MovingOutStatements};\n+use super::borrow_set::BorrowData;\n+\n+use dataflow::{FlowAtLocation, MovingOutStatements};\n use dataflow::move_paths::MovePathIndex;\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n@@ -261,7 +263,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         (place, span): (&Place<'tcx>, Span),\n         gen_borrow_kind: BorrowKind,\n         issued_borrow: &BorrowData<'tcx>,\n-        end_issued_loan_span: Option<Span>,\n     ) {\n         let issued_span = self.retrieve_borrow_span(issued_borrow);\n \n@@ -295,7 +296,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     \"it\",\n                     rgt,\n                     \"\",\n-                    end_issued_loan_span,\n+                    None,\n                     Origin::Mir,\n                 )\n             }\n@@ -307,7 +308,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     \"\",\n                     issued_span,\n                     \"\",\n-                    end_issued_loan_span,\n+                    None,\n                     Origin::Mir,\n                 )\n             }\n@@ -317,7 +318,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     span,\n                     &desc_place,\n                     issued_span,\n-                    end_issued_loan_span,\n+                    None,\n                     Origin::Mir,\n                 )\n             }\n@@ -329,7 +330,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 issued_span,\n                 \"it\",\n                 \"\",\n-                end_issued_loan_span,\n+                None,\n                 Origin::Mir,\n             ),\n \n@@ -341,7 +342,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     lft,\n                     issued_span,\n                     \"\",\n-                    end_issued_loan_span,\n+                    None,\n                     Origin::Mir,\n                 )\n             }\n@@ -354,7 +355,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     lft,\n                     issued_span,\n                     \"\",\n-                    end_issued_loan_span,\n+                    None,\n                     Origin::Mir,\n                 )\n             }\n@@ -389,10 +390,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         context: Context,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n-        borrows: &Borrows<'cx, 'gcx, 'tcx>\n     ) {\n-        let end_span = borrows.opt_region_end_span(&borrow.region);\n-        let scope_tree = borrows.scope_tree();\n+        let scope_tree = self.tcx.region_scope_tree(self.mir_def_id);\n         let root_place = self.prefixes(&borrow.borrowed_place, PrefixSet::All)\n             .last()\n             .unwrap();\n@@ -426,7 +425,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     drop_span,\n                     borrow_span,\n                     proper_span,\n-                    end_span,\n                 );\n             }\n             (RegionKind::ReScope(_), None) => {\n@@ -437,7 +435,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     drop_span,\n                     borrow_span,\n                     proper_span,\n-                    end_span,\n                 );\n             }\n             (RegionKind::ReEarlyBound(_), Some(name))\n@@ -453,7 +450,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     drop_span,\n                     borrow_span,\n                     proper_span,\n-                    end_span,\n                 );\n             }\n             (RegionKind::ReEarlyBound(_), None)\n@@ -468,7 +464,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     drop_span,\n                     borrow_span,\n                     proper_span,\n-                    end_span,\n                 );\n             }\n             (RegionKind::ReLateBound(_, _), _)\n@@ -490,7 +485,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         drop_span: Span,\n         borrow_span: Span,\n         _proper_span: Span,\n-        end_span: Option<Span>,\n     ) {\n         let tcx = self.tcx;\n         let mut err =\n@@ -500,9 +494,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             drop_span,\n             format!(\"`{}` dropped here while still borrowed\", name),\n         );\n-        if let Some(end) = end_span {\n-            err.span_label(end, \"borrowed value needs to live until here\");\n-        }\n         self.explain_why_borrow_contains_point(context, borrow, &mut err);\n         err.emit();\n     }\n@@ -515,7 +506,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         drop_span: Span,\n         _borrow_span: Span,\n         proper_span: Span,\n-        end_span: Option<Span>,\n     ) {\n         let tcx = self.tcx;\n         let mut err =\n@@ -526,9 +516,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"temporary value dropped here while still borrowed\",\n         );\n         err.note(\"consider using a `let` binding to increase its lifetime\");\n-        if let Some(end) = end_span {\n-            err.span_label(end, \"temporary value needs to live until here\");\n-        }\n         self.explain_why_borrow_contains_point(context, borrow, &mut err);\n         err.emit();\n     }\n@@ -542,7 +529,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         drop_span: Span,\n         borrow_span: Span,\n         _proper_span: Span,\n-        _end_span: Option<Span>,\n     ) {\n         debug!(\n             \"report_unscoped_local_value_does_not_live_long_enough(\\\n@@ -557,16 +543,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.span_label(borrow_span, \"borrowed value does not live long enough\");\n         err.span_label(drop_span, \"borrowed value only lives until here\");\n \n-        if !tcx.nll() {\n-            tcx.note_and_explain_region(\n-                scope_tree,\n-                &mut err,\n-                \"borrowed value must be valid for \",\n-                borrow.region,\n-                \"...\",\n-            );\n-        }\n-\n         self.explain_why_borrow_contains_point(context, borrow, &mut err);\n         err.emit();\n     }\n@@ -579,7 +555,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         drop_span: Span,\n         _borrow_span: Span,\n         proper_span: Span,\n-        _end_span: Option<Span>,\n     ) {\n         debug!(\n             \"report_unscoped_temporary_value_does_not_live_long_enough(\\\n@@ -594,16 +569,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.span_label(proper_span, \"temporary value does not live long enough\");\n         err.span_label(drop_span, \"temporary value only lives until here\");\n \n-        if !tcx.nll() {\n-            tcx.note_and_explain_region(\n-                scope_tree,\n-                &mut err,\n-                \"borrowed value must be valid for \",\n-                borrow.region,\n-                \"...\",\n-            );\n-        }\n-\n         self.explain_why_borrow_contains_point(context, borrow, &mut err);\n         err.emit();\n     }\n@@ -834,7 +799,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     // Retrieve span of given borrow from the current MIR representation\n-    pub fn retrieve_borrow_span(&self, borrow: &BorrowData) -> Span {\n+    crate fn retrieve_borrow_span(&self, borrow: &BorrowData) -> Span {\n         self.mir.source_info(borrow.reserve_location).span\n     }\n "}, {"sha": "070dc1d09bf6bd855bc45cf58affb4f3cc39832d", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -14,25 +14,27 @@\n //! but is not as ugly as it is right now.\n \n use rustc::mir::{BasicBlock, Location};\n+use rustc_data_structures::indexed_set::Iter;\n \n use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use dataflow::{EverInitializedPlaces, MovingOutStatements};\n use dataflow::{Borrows};\n use dataflow::{FlowAtLocation, FlowsAtLocation};\n use dataflow::move_paths::HasMoveData;\n+use dataflow::move_paths::indexes::BorrowIndex;\n use std::fmt;\n \n // (forced to be `pub` due to its use as an associated type below.)\n-pub(crate) struct Flows<'b, 'gcx: 'tcx, 'tcx: 'b> {\n-    pub borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n+crate struct Flows<'b, 'gcx: 'tcx, 'tcx: 'b> {\n+    borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n     pub inits: FlowAtLocation<MaybeInitializedPlaces<'b, 'gcx, 'tcx>>,\n     pub uninits: FlowAtLocation<MaybeUninitializedPlaces<'b, 'gcx, 'tcx>>,\n     pub move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,\n     pub ever_inits: FlowAtLocation<EverInitializedPlaces<'b, 'gcx, 'tcx>>,\n }\n \n impl<'b, 'gcx, 'tcx> Flows<'b, 'gcx, 'tcx> {\n-    pub fn new(\n+    crate fn new(\n         borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n         inits: FlowAtLocation<MaybeInitializedPlaces<'b, 'gcx, 'tcx>>,\n         uninits: FlowAtLocation<MaybeUninitializedPlaces<'b, 'gcx, 'tcx>>,\n@@ -47,6 +49,14 @@ impl<'b, 'gcx, 'tcx> Flows<'b, 'gcx, 'tcx> {\n             ever_inits,\n         }\n     }\n+\n+    crate fn borrows_in_scope(&self) -> impl Iterator<Item = BorrowIndex> + '_ {\n+        self.borrows.iter_incoming()\n+    }\n+\n+    crate fn with_outgoing_borrows(&self, op: impl FnOnce(Iter<BorrowIndex>)) {\n+        self.borrows.with_iter_outgoing(op)\n+    }\n }\n \n macro_rules! each_flow {\n@@ -88,9 +98,8 @@ impl<'b, 'gcx, 'tcx> fmt::Display for Flows<'b, 'gcx, 'tcx> {\n                 s.push_str(\", \");\n             };\n             saw_one = true;\n-            let borrow_data = &self.borrows.operator().borrows()[borrow.borrow_index()];\n-            s.push_str(&format!(\"{}{}\", borrow_data,\n-                                if borrow.is_activation() { \"@active\" } else { \"\" }));\n+            let borrow_data = &self.borrows.operator().borrows()[borrow];\n+            s.push_str(&format!(\"{}\", borrow_data));\n         });\n         s.push_str(\"] \");\n \n@@ -101,7 +110,7 @@ impl<'b, 'gcx, 'tcx> fmt::Display for Flows<'b, 'gcx, 'tcx> {\n                 s.push_str(\", \");\n             };\n             saw_one = true;\n-            let borrow_data = &self.borrows.operator().borrows()[borrow.borrow_index()];\n+            let borrow_data = &self.borrows.operator().borrows()[borrow];\n             s.push_str(&format!(\"{}\", borrow_data));\n         });\n         s.push_str(\"] \");"}, {"sha": "4dd8d245d3beaff1474d47f0d4961202c40b5dbe", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 157, "deletions": 114, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -22,13 +22,13 @@ use rustc::mir::{Mir, Mutability, Operand, Projection, ProjectionElem, Rvalue};\n use rustc::mir::{Field, Statement, StatementKind, Terminator, TerminatorKind};\n use rustc::mir::ClosureRegionRequirements;\n \n+use rustc_data_structures::control_flow_graph::dominators::Dominators;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n \n use std::rc::Rc;\n \n-use syntax::ast;\n use syntax_pos::Span;\n \n use dataflow::{do_dataflow, DebugFormatted};\n@@ -37,7 +37,7 @@ use dataflow::MoveDataParamEnv;\n use dataflow::{DataflowResultsConsumer};\n use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use dataflow::{EverInitializedPlaces, MovingOutStatements};\n-use dataflow::{BorrowData, Borrows, ReserveOrActivateIndex};\n+use dataflow::Borrows;\n use dataflow::indexes::BorrowIndex;\n use dataflow::move_paths::{IllegalMoveOriginKind, MoveError};\n use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MovePathIndex};\n@@ -46,12 +46,15 @@ use util::collect_writes::FindAssignments;\n \n use std::iter;\n \n+use self::borrow_set::{BorrowSet, BorrowData};\n use self::flows::Flows;\n use self::prefixes::PrefixSet;\n use self::MutateMode::{JustWrite, WriteAndRead};\n \n+crate mod borrow_set;\n mod error_reporting;\n mod flows;\n+crate mod place_ext;\n mod prefixes;\n \n pub(crate) mod nll;\n@@ -70,7 +73,7 @@ fn mir_borrowck<'a, 'tcx>(\n     let input_mir = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.item_path_str(def_id));\n \n-    if !tcx.has_attr(def_id, \"rustc_mir_borrowck\") && !tcx.use_mir() {\n+    if !tcx.has_attr(def_id, \"rustc_mir_borrowck\") && !tcx.use_mir_borrowck() {\n         return None;\n     }\n \n@@ -95,19 +98,13 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         .as_local_node_id(def_id)\n         .expect(\"do_mir_borrowck: non-local DefId\");\n \n-    // Make our own copy of the MIR. This copy will be modified (in place) to\n-    // contain non-lexical lifetimes. It will have a lifetime tied\n-    // to the inference context.\n+    // Replace all regions with fresh inference variables. This\n+    // requires first making our own copy of the MIR. This copy will\n+    // be modified (in place) to contain non-lexical lifetimes. It\n+    // will have a lifetime tied to the inference context.\n     let mut mir: Mir<'tcx> = input_mir.clone();\n-    let free_regions = if !tcx.nll() {\n-        None\n-    } else {\n-        let mir = &mut mir;\n-\n-        // Replace all regions with fresh inference variables.\n-        Some(nll::replace_regions_in_mir(infcx, def_id, param_env, mir))\n-    };\n-    let mir = &mir;\n+    let free_regions = nll::replace_regions_in_mir(infcx, def_id, param_env, &mut mir);\n+    let mir = &mir; // no further changes\n \n     let move_data: MoveData<'tcx> = match MoveData::gather_moves(mir, tcx) {\n         Ok(move_data) => move_data,\n@@ -189,22 +186,20 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         |bd, i| DebugFormatted::new(&bd.move_data().inits[i]),\n     ));\n \n+    let borrow_set = Rc::new(BorrowSet::build(tcx, mir));\n+\n     // If we are in non-lexical mode, compute the non-lexical lifetimes.\n-    let (opt_regioncx, opt_closure_req) = if let Some(free_regions) = free_regions {\n-        let (regioncx, opt_closure_req) = nll::compute_regions(\n-            infcx,\n-            def_id,\n-            free_regions,\n-            mir,\n-            param_env,\n-            &mut flow_inits,\n-            &mdpe.move_data,\n-        );\n-        (Some(Rc::new(regioncx)), opt_closure_req)\n-    } else {\n-        assert!(!tcx.nll());\n-        (None, None)\n-    };\n+    let (regioncx, opt_closure_req) = nll::compute_regions(\n+        infcx,\n+        def_id,\n+        free_regions,\n+        mir,\n+        param_env,\n+        &mut flow_inits,\n+        &mdpe.move_data,\n+        &borrow_set,\n+    );\n+    let regioncx = Rc::new(regioncx);\n     let flow_inits = flow_inits; // remove mut\n \n     let flow_borrows = FlowAtLocation::new(do_dataflow(\n@@ -213,24 +208,24 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         id,\n         &attributes,\n         &dead_unwinds,\n-        Borrows::new(tcx, mir, opt_regioncx.clone(), def_id, body_id),\n-        |rs, i| {\n-            DebugFormatted::new(&(i.kind(), rs.location(i.borrow_index())))\n-        }\n+        Borrows::new(tcx, mir, regioncx.clone(), def_id, body_id, &borrow_set),\n+        |rs, i| DebugFormatted::new(&rs.location(i)),\n     ));\n \n-    let movable_generator = !match tcx.hir.get(id) {\n+    let movable_generator = match tcx.hir.get(id) {\n         hir::map::Node::NodeExpr(&hir::Expr {\n             node: hir::ExprClosure(.., Some(hir::GeneratorMovability::Static)),\n             ..\n-        }) => true,\n-        _ => false,\n+        }) => false,\n+        _ => true,\n     };\n \n+    let dominators = mir.dominators();\n+\n     let mut mbcx = MirBorrowckCtxt {\n         tcx: tcx,\n         mir: mir,\n-        node_id: id,\n+        mir_def_id: def_id,\n         move_data: &mdpe.move_data,\n         param_env: param_env,\n         movable_generator,\n@@ -241,8 +236,10 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         access_place_error_reported: FxHashSet(),\n         reservation_error_reported: FxHashSet(),\n         moved_error_reported: FxHashSet(),\n-        nonlexical_regioncx: opt_regioncx,\n+        nonlexical_regioncx: regioncx,\n         nonlexical_cause_info: None,\n+        borrow_set,\n+        dominators,\n     };\n \n     let mut state = Flows::new(\n@@ -262,7 +259,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     mir: &'cx Mir<'tcx>,\n-    node_id: ast::NodeId,\n+    mir_def_id: DefId,\n     move_data: &'cx MoveData<'tcx>,\n     param_env: ParamEnv<'gcx>,\n     movable_generator: bool,\n@@ -293,8 +290,14 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// Non-lexical region inference context, if NLL is enabled.  This\n     /// contains the results from region inference and lets us e.g.\n     /// find out which CFG points are contained in each borrow region.\n-    nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n+    nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n     nonlexical_cause_info: Option<RegionCausalInfo>,\n+\n+    /// The set of borrows extracted from the MIR\n+    borrow_set: Rc<BorrowSet<'tcx>>,\n+\n+    /// Dominators for MIR\n+    dominators: Dominators<BasicBlock>,\n }\n \n // Check that:\n@@ -535,11 +538,10 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n \n                 if self.movable_generator {\n                     // Look for any active borrows to locals\n-                    let domain = flow_state.borrows.operator();\n-                    let data = domain.borrows();\n-                    flow_state.borrows.with_iter_outgoing(|borrows| {\n+                    let borrow_set = self.borrow_set.clone();\n+                    flow_state.with_outgoing_borrows(|borrows| {\n                         for i in borrows {\n-                            let borrow = &data[i.borrow_index()];\n+                            let borrow = &borrow_set[i];\n                             self.check_for_local_borrow(borrow, span);\n                         }\n                     });\n@@ -551,13 +553,12 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 // Often, the storage will already have been killed by an explicit\n                 // StorageDead, but we don't always emit those (notably on unwind paths),\n                 // so this \"extra check\" serves as a kind of backup.\n-                let domain = flow_state.borrows.operator();\n-                let data = domain.borrows();\n-                flow_state.borrows.with_iter_outgoing(|borrows| {\n+                let borrow_set = self.borrow_set.clone();\n+                flow_state.with_outgoing_borrows(|borrows| {\n                     for i in borrows {\n-                        let borrow = &data[i.borrow_index()];\n+                        let borrow = &borrow_set[i];\n                         let context = ContextKind::StorageDead.new(loc);\n-                        self.check_for_invalidation_at_exit(context, borrow, span, flow_state);\n+                        self.check_for_invalidation_at_exit(context, borrow, span);\n                     }\n                 });\n             }\n@@ -836,27 +837,34 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         rw: ReadOrWrite,\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) -> bool {\n+        debug!(\n+            \"check_access_for_conflict(context={:?}, place_span={:?}, sd={:?}, rw={:?})\",\n+            context,\n+            place_span,\n+            sd,\n+            rw,\n+        );\n+\n         let mut error_reported = false;\n         self.each_borrow_involving_path(\n             context,\n             (sd, place_span.0),\n             flow_state,\n-            |this, index, borrow| match (rw, borrow.kind) {\n+            |this, borrow_index, borrow| match (rw, borrow.kind) {\n                 // Obviously an activation is compatible with its own\n                 // reservation (or even prior activating uses of same\n                 // borrow); so don't check if they interfere.\n                 //\n                 // NOTE: *reservations* do conflict with themselves;\n                 // thus aren't injecting unsoundenss w/ this check.)\n-                (Activation(_, activating), _) if activating == index.borrow_index() => {\n+                (Activation(_, activating), _) if activating == borrow_index => {\n                     debug!(\n                         \"check_access_for_conflict place_span: {:?} sd: {:?} rw: {:?} \\\n-                         skipping {:?} b/c activation of same borrow_index: {:?}\",\n+                         skipping {:?} b/c activation of same borrow_index\",\n                         place_span,\n                         sd,\n                         rw,\n-                        (index, borrow),\n-                        index.borrow_index()\n+                        (borrow_index, borrow),\n                     );\n                     Control::Continue\n                 }\n@@ -867,7 +875,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut { .. }) => {\n                     // Reading from mere reservations of mutable-borrows is OK.\n-                    if this.allow_two_phase_borrow(borrow.kind) && index.is_reservation() {\n+                    if !this.is_active(borrow, context.loc) {\n+                        assert!(this.allow_two_phase_borrow(borrow.kind));\n                         return Control::Continue;\n                     }\n \n@@ -877,17 +886,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             this.report_use_while_mutably_borrowed(context, place_span, borrow)\n                         }\n                         ReadKind::Borrow(bk) => {\n-                            let end_issued_loan_span = flow_state\n-                                .borrows\n-                                .operator()\n-                                .opt_region_end_span(&borrow.region);\n                             error_reported = true;\n                             this.report_conflicting_borrow(\n                                 context,\n                                 place_span,\n                                 bk,\n                                 &borrow,\n-                                end_issued_loan_span,\n                             )\n                         }\n                     }\n@@ -919,18 +923,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                     match kind {\n                         WriteKind::MutableBorrow(bk) => {\n-                            let end_issued_loan_span = flow_state\n-                                .borrows\n-                                .operator()\n-                                .opt_region_end_span(&borrow.region);\n-\n                             error_reported = true;\n                             this.report_conflicting_borrow(\n                                 context,\n                                 place_span,\n                                 bk,\n                                 &borrow,\n-                                end_issued_loan_span,\n                             )\n                         }\n                         WriteKind::StorageDeadOrDrop => {\n@@ -939,7 +937,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 context,\n                                 borrow,\n                                 place_span.1,\n-                                flow_state.borrows.operator(),\n                             );\n                         }\n                         WriteKind::Mutate => {\n@@ -1141,7 +1138,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         context: Context,\n         borrow: &BorrowData<'tcx>,\n         span: Span,\n-        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n         debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n         let place = &borrow.borrowed_place;\n@@ -1194,7 +1190,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 context,\n                 borrow,\n                 span,\n-                flow_state.borrows.operator(),\n             )\n         }\n     }\n@@ -1249,36 +1244,30 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // Two-phase borrow support: For each activation that is newly\n         // generated at this statement, check if it interferes with\n         // another borrow.\n-        let domain = flow_state.borrows.operator();\n-        let data = domain.borrows();\n-        flow_state.borrows.each_gen_bit(|gen| {\n-            if gen.is_activation() {\n-                let borrow_index = gen.borrow_index();\n-                let borrow = &data[borrow_index];\n-                // currently the flow analysis registers\n-                // activations for both mutable and immutable\n-                // borrows. So make sure we are talking about a\n-                // mutable borrow before we check it.\n-                match borrow.kind {\n-                    BorrowKind::Shared => return,\n-                    BorrowKind::Unique | BorrowKind::Mut { .. } => {}\n-                }\n-\n-                self.access_place(\n-                    ContextKind::Activation.new(location),\n-                    (&borrow.borrowed_place, span),\n-                    (\n-                        Deep,\n-                        Activation(WriteKind::MutableBorrow(borrow.kind), borrow_index),\n-                    ),\n-                    LocalMutationIsAllowed::No,\n-                    flow_state,\n-                );\n-                // We do not need to call `check_if_path_or_subpath_is_moved`\n-                // again, as we already called it when we made the\n-                // initial reservation.\n-            }\n-        });\n+        let borrow_set = self.borrow_set.clone();\n+        for &borrow_index in borrow_set.activations_at_location(location) {\n+            let borrow = &borrow_set[borrow_index];\n+\n+            // only mutable borrows should be 2-phase\n+            assert!(match borrow.kind {\n+                BorrowKind::Shared => false,\n+                BorrowKind::Unique | BorrowKind::Mut { .. } => true,\n+            });\n+\n+            self.access_place(\n+                ContextKind::Activation.new(location),\n+                (&borrow.borrowed_place, span),\n+                (\n+                    Deep,\n+                    Activation(WriteKind::MutableBorrow(borrow.kind), borrow_index),\n+                ),\n+                LocalMutationIsAllowed::No,\n+                flow_state,\n+            );\n+            // We do not need to call `check_if_path_or_subpath_is_moved`\n+            // again, as we already called it when we made the\n+            // initial reservation.\n+        }\n     }\n }\n \n@@ -2217,39 +2206,34 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         unreachable!(\"iter::repeat returned None\")\n     }\n \n-    /// This function iterates over all of the current borrows\n-    /// (represented by 1-bits in `flow_state.borrows`) that conflict\n-    /// with an access to a place, invoking the `op` callback for each\n-    /// one.\n+    /// This function iterates over all of the in-scope borrows that\n+    /// conflict with an access to a place, invoking the `op` callback\n+    /// for each one.\n     ///\n     /// \"Current borrow\" here means a borrow that reaches the point in\n     /// the control-flow where the access occurs.\n     ///\n-    /// The borrow's phase is represented by the ReserveOrActivateIndex\n-    /// passed to the callback: one can call `is_reservation()` and\n-    /// `is_activation()` to determine what phase the borrow is\n-    /// currently in, when such distinction matters.\n+    /// The borrow's phase is represented by the IsActive parameter\n+    /// passed to the callback.\n     fn each_borrow_involving_path<F>(\n         &mut self,\n         _context: Context,\n         access_place: (ShallowOrDeep, &Place<'tcx>),\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n         mut op: F,\n     ) where\n-        F: FnMut(&mut Self, ReserveOrActivateIndex, &BorrowData<'tcx>) -> Control,\n+        F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>) -> Control,\n     {\n         let (access, place) = access_place;\n \n         // FIXME: analogous code in check_loans first maps `place` to\n         // its base_path.\n \n-        let data = flow_state.borrows.operator().borrows();\n-\n         // check for loan restricting path P being used. Accounts for\n         // borrows of P, P.a.b, etc.\n-        let mut iter_incoming = flow_state.borrows.iter_incoming();\n-        while let Some(i) = iter_incoming.next() {\n-            let borrowed = &data[i.borrow_index()];\n+        let borrow_set = self.borrow_set.clone();\n+        for i in flow_state.borrows_in_scope() {\n+            let borrowed = &borrow_set[i];\n \n             if self.places_conflict(&borrowed.borrowed_place, place, access) {\n                 debug!(\n@@ -2263,6 +2247,65 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n     }\n+\n+    fn is_active(\n+        &self,\n+        borrow_data: &BorrowData<'tcx>,\n+        location: Location\n+    ) -> bool {\n+        debug!(\"is_active(borrow_data={:?}, location={:?})\", borrow_data, location);\n+\n+        // If this is not a 2-phase borrow, it is always active.\n+        let activation_location = match borrow_data.activation_location {\n+            Some(v) => v,\n+            None => return true,\n+        };\n+\n+        // Otherwise, it is active for every location *except* in between\n+        // the reservation and the activation:\n+        //\n+        //       X\n+        //      /\n+        //     R      <--+ Except for this\n+        //    / \\        | diamond\n+        //    \\ /        |\n+        //     A  <------+\n+        //     |\n+        //     Z\n+        //\n+        // Note that we assume that:\n+        // - the reservation R dominates the activation A\n+        // - the activation A post-dominates the reservation R (ignoring unwinding edges).\n+        //\n+        // This means that there can't be an edge that leaves A and\n+        // comes back into that diamond unless it passes through R.\n+        //\n+        // Suboptimal: In some cases, this code walks the dominator\n+        // tree twice when it only has to be walked once. I am\n+        // lazy. -nmatsakis\n+\n+        // If dominated by the activation A, then it is active. The\n+        // activation occurs upon entering the point A, so this is\n+        // also true if location == activation_location.\n+        if activation_location.dominates(location, &self.dominators) {\n+            return true;\n+        }\n+\n+        // The reservation starts *on exiting* the reservation block,\n+        // so check if the location is dominated by R.successor. If so,\n+        // this point falls in between the reservation and location.\n+        let reserve_location = borrow_data.reserve_location.successor_within_block();\n+        if reserve_location.dominates(location, &self.dominators) {\n+            false\n+        } else {\n+            // Otherwise, this point is outside the diamond, so\n+            // consider the borrow active. This could happen for\n+            // example if the borrow remains active around a loop (in\n+            // which case it would be active also for the point R,\n+            // which would generate an error).\n+            true\n+        }\n+    }\n }\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {"}, {"sha": "d5e11a312ec26fb763f3be5dc6f8e9c5162131be", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 59, "deletions": 60, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -10,7 +10,7 @@\n \n use borrow_check::nll::region_infer::{Cause, RegionInferenceContext};\n use borrow_check::{Context, MirBorrowckCtxt};\n-use dataflow::BorrowData;\n+use borrow_check::borrow_set::BorrowData;\n use rustc::mir::visit::{MirVisitable, PlaceContext, Visitor};\n use rustc::mir::{Local, Location, Mir};\n use rustc_data_structures::fx::FxHashSet;\n@@ -29,82 +29,81 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         borrow: &BorrowData<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n     ) {\n-        if let Some(regioncx) = &self.nonlexical_regioncx {\n-            let mir = self.mir;\n+        let regioncx = &&self.nonlexical_regioncx;\n+        let mir = self.mir;\n \n-            if self.nonlexical_cause_info.is_none() {\n-                self.nonlexical_cause_info = Some(regioncx.compute_causal_info(mir));\n-            }\n+        if self.nonlexical_cause_info.is_none() {\n+            self.nonlexical_cause_info = Some(regioncx.compute_causal_info(mir));\n+        }\n+\n+        let cause_info = self.nonlexical_cause_info.as_ref().unwrap();\n+        if let Some(cause) = cause_info.why_region_contains_point(borrow.region, context.loc) {\n+            match *cause.root_cause() {\n+                Cause::LiveVar(local, location) => {\n+                    match find_regular_use(mir, regioncx, borrow, location, local) {\n+                        Some(p) => {\n+                            err.span_label(\n+                                mir.source_info(p).span,\n+                                format!(\"borrow later used here\"),\n+                            );\n+                        }\n+\n+                        None => {\n+                            span_bug!(\n+                                mir.source_info(context.loc).span,\n+                                \"Cause should end in a LiveVar\"\n+                            );\n+                        }\n+                    }\n+                }\n \n-            let cause_info = self.nonlexical_cause_info.as_ref().unwrap();\n-            if let Some(cause) = cause_info.why_region_contains_point(borrow.region, context.loc) {\n-                match *cause.root_cause() {\n-                    Cause::LiveVar(local, location) => {\n-                        match find_regular_use(mir, regioncx, borrow, location, local) {\n-                            Some(p) => {\n+                Cause::DropVar(local, location) => {\n+                    match find_drop_use(mir, regioncx, borrow, location, local) {\n+                        Some(p) => match &mir.local_decls[local].name {\n+                            Some(local_name) => {\n                                 err.span_label(\n                                     mir.source_info(p).span,\n-                                    format!(\"borrow later used here\"),\n+                                    format!(\n+                                        \"borrow later used here, when `{}` is dropped\",\n+                                        local_name\n+                                    ),\n                                 );\n                             }\n-\n                             None => {\n-                                span_bug!(\n-                                    mir.source_info(context.loc).span,\n-                                    \"Cause should end in a LiveVar\"\n+                                err.span_label(\n+                                    mir.local_decls[local].source_info.span,\n+                                    \"borrow may end up in a temporary, created here\",\n                                 );\n-                            }\n-                        }\n-                    }\n \n-                    Cause::DropVar(local, location) => {\n-                        match find_drop_use(mir, regioncx, borrow, location, local) {\n-                            Some(p) => match &mir.local_decls[local].name {\n-                                Some(local_name) => {\n-                                    err.span_label(\n-                                        mir.source_info(p).span,\n-                                        format!(\n-                                            \"borrow later used here, when `{}` is dropped\",\n-                                            local_name\n-                                        ),\n-                                    );\n-                                }\n-                                None => {\n-                                    err.span_label(\n-                                        mir.local_decls[local].source_info.span,\n-                                        \"borrow may end up in a temporary, created here\",\n-                                    );\n-\n-                                    err.span_label(\n-                                        mir.source_info(p).span,\n-                                        \"temporary later dropped here, \\\n-                                         potentially using the reference\",\n-                                    );\n-                                }\n-                            },\n-\n-                            None => {\n-                                span_bug!(\n-                                    mir.source_info(context.loc).span,\n-                                    \"Cause should end in a DropVar\"\n+                                err.span_label(\n+                                    mir.source_info(p).span,\n+                                    \"temporary later dropped here, \\\n+                                     potentially using the reference\",\n                                 );\n                             }\n-                        }\n-                    }\n+                        },\n \n-                    Cause::UniversalRegion(region_vid) => {\n-                        if let Some(region) = regioncx.to_error_region(region_vid) {\n-                            self.tcx.note_and_explain_free_region(\n-                                err,\n-                                \"borrowed value must be valid for \",\n-                                region,\n-                                \"...\",\n+                        None => {\n+                            span_bug!(\n+                                mir.source_info(context.loc).span,\n+                                \"Cause should end in a DropVar\"\n                             );\n                         }\n                     }\n+                }\n \n-                    _ => {}\n+                Cause::UniversalRegion(region_vid) => {\n+                    if let Some(region) = regioncx.to_error_region(region_vid) {\n+                        self.tcx.note_and_explain_free_region(\n+                            err,\n+                            \"borrowed value must be valid for \",\n+                            region,\n+                            \"...\",\n+                        );\n+                    }\n                 }\n+\n+                _ => {}\n             }\n         }\n     }"}, {"sha": "3ca1bd23e86ef4c9556ebcc289dabd076a53354a", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use borrow_check::borrow_set::BorrowSet;\n use rustc::hir::def_id::DefId;\n use rustc::mir::{ClosureRegionRequirements, ClosureOutlivesSubject, Mir};\n use rustc::infer::InferCtxt;\n@@ -73,6 +74,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     param_env: ty::ParamEnv<'gcx>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'cx, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n+    _borrow_set: &BorrowSet<'tcx>,\n ) -> (\n     RegionInferenceContext<'tcx>,\n     Option<ClosureRegionRequirements<'gcx>>,"}, {"sha": "acd246b7031260ad0bad7304a111fc83714ac218", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1611,7 +1611,7 @@ impl MirPass for TypeckMir {\n \n         // When NLL is enabled, the borrow checker runs the typeck\n         // itself, so we don't need this MIR pass anymore.\n-        if tcx.nll() {\n+        if tcx.use_mir_borrowck() {\n             return;\n         }\n "}, {"sha": "f6ffe3c6d2314d5890e862687be1f28e3266b892", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir;\n+use rustc::mir::ProjectionElem;\n+use rustc::mir::{Local, Mir, Place};\n+use rustc::ty::{self, TyCtxt};\n+\n+/// Extension methods for the `Place` type.\n+crate trait PlaceExt<'tcx> {\n+    /// True if this is a deref of a raw pointer.\n+    fn is_unsafe_place(&self, tcx: TyCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) -> bool;\n+\n+    /// If this is a place like `x.f.g`, returns the local\n+    /// `x`. Returns `None` if this is based in a static.\n+    fn root_local(&self) -> Option<Local>;\n+}\n+\n+impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n+    fn is_unsafe_place(&self, tcx: TyCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) -> bool {\n+        match self {\n+            Place::Local(_) => false,\n+            Place::Static(static_) => {\n+                tcx.is_static(static_.def_id) == Some(hir::Mutability::MutMutable)\n+            }\n+            Place::Projection(proj) => match proj.elem {\n+                ProjectionElem::Field(..)\n+                | ProjectionElem::Downcast(..)\n+                | ProjectionElem::Subslice { .. }\n+                | ProjectionElem::ConstantIndex { .. }\n+                | ProjectionElem::Index(_) => proj.base.is_unsafe_place(tcx, mir),\n+                ProjectionElem::Deref => {\n+                    let ty = proj.base.ty(mir, tcx).to_ty(tcx);\n+                    match ty.sty {\n+                        ty::TyRawPtr(..) => true,\n+                        _ => proj.base.is_unsafe_place(tcx, mir),\n+                    }\n+                }\n+            },\n+        }\n+    }\n+\n+    fn root_local(&self) -> Option<Local> {\n+        let mut p = self;\n+        loop {\n+            match p {\n+                Place::Projection(pi) => p = &pi.base,\n+                Place::Static(_) => return None,\n+                Place::Local(l) => return Some(*l),\n+            }\n+        }\n+    }\n+}"}, {"sha": "a21691813a4d4bdd8f8edaa579da1430bfef6346", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 65, "deletions": 544, "changes": 609, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,31 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use borrow_check::borrow_set::{BorrowSet, BorrowData};\n+use borrow_check::place_ext::PlaceExt;\n+\n use rustc;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n use rustc::mir::{self, Location, Place, Mir};\n-use rustc::mir::visit::{PlaceContext, Visitor};\n-use rustc::ty::{self, Region, TyCtxt};\n+use rustc::ty::TyCtxt;\n use rustc::ty::RegionKind;\n use rustc::ty::RegionKind::ReScope;\n-use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n-use rustc_data_structures::bitslice::{BitwiseOperator};\n-use rustc_data_structures::indexed_set::{IdxSet};\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::bitslice::BitwiseOperator;\n+use rustc_data_structures::indexed_set::IdxSet;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n \n use dataflow::{BitDenotation, BlockSets, InitialFlow};\n-pub use dataflow::indexes::{BorrowIndex, ReserveOrActivateIndex};\n+pub use dataflow::indexes::BorrowIndex;\n use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::ToRegionVid;\n \n-use syntax_pos::Span;\n-\n-use std::fmt;\n-use std::hash::Hash;\n use std::rc::Rc;\n \n /// `Borrows` stores the data used in the analyses that track the flow\n@@ -48,534 +45,102 @@ pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     scope_tree: Lrc<region::ScopeTree>,\n     root_scope: Option<region::Scope>,\n \n-    /// The fundamental map relating bitvector indexes to the borrows\n-    /// in the MIR.\n-    borrows: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n-\n-    /// Each borrow is also uniquely identified in the MIR by the\n-    /// `Location` of the assignment statement in which it appears on\n-    /// the right hand side; we map each such location to the\n-    /// corresponding `BorrowIndex`.\n-    location_map: FxHashMap<Location, BorrowIndex>,\n-\n-    /// Every borrow in MIR is immediately stored into a place via an\n-    /// assignment statement. This maps each such assigned place back\n-    /// to its borrow-indexes.\n-    assigned_map: FxHashMap<Place<'tcx>, FxHashSet<BorrowIndex>>,\n-\n-    /// Locations which activate borrows.\n-    activation_map: FxHashMap<Location, FxHashSet<BorrowIndex>>,\n-\n-    /// Every borrow has a region; this maps each such regions back to\n-    /// its borrow-indexes.\n-    region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n-\n-    /// Map from local to all the borrows on that local\n-    local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n-\n-    /// Maps regions to their corresponding source spans\n-    /// Only contains ReScope()s as keys\n-    region_span_map: FxHashMap<RegionKind, Span>,\n+    borrow_set: Rc<BorrowSet<'tcx>>,\n \n     /// NLL region inference context with which NLL queries should be resolved\n-    nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n-}\n-\n-// temporarily allow some dead fields: `kind` and `region` will be\n-// needed by borrowck; `borrowed_place` will probably be a MovePathIndex when\n-// that is extended to include borrowed data paths.\n-#[allow(dead_code)]\n-#[derive(Debug)]\n-pub struct BorrowData<'tcx> {\n-    /// Location where the borrow reservation starts.\n-    /// In many cases, this will be equal to the activation location but not always.\n-    pub(crate) reserve_location: Location,\n-    /// What kind of borrow this is\n-    pub(crate) kind: mir::BorrowKind,\n-    /// The region for which this borrow is live\n-    pub(crate) region: Region<'tcx>,\n-    /// Place from which we are borrowing\n-    pub(crate) borrowed_place: mir::Place<'tcx>,\n-    /// Place to which the borrow was stored\n-    pub(crate) assigned_place: mir::Place<'tcx>,\n-}\n-\n-impl<'tcx> fmt::Display for BorrowData<'tcx> {\n-    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n-        let kind = match self.kind {\n-            mir::BorrowKind::Shared => \"\",\n-            mir::BorrowKind::Unique => \"uniq \",\n-            mir::BorrowKind::Mut { .. } => \"mut \",\n-        };\n-        let region = format!(\"{}\", self.region);\n-        let region = if region.len() > 0 { format!(\"{} \", region) } else { region };\n-        write!(w, \"&{}{}{:?}\", region, kind, self.borrowed_place)\n-    }\n-}\n-\n-impl ReserveOrActivateIndex {\n-    fn reserved(i: BorrowIndex) -> Self { ReserveOrActivateIndex::new(i.index() * 2) }\n-    fn active(i: BorrowIndex) -> Self { ReserveOrActivateIndex::new((i.index() * 2) + 1) }\n-\n-    pub(crate) fn is_reservation(self) -> bool { self.index() % 2 == 0 }\n-    pub(crate) fn is_activation(self) -> bool { self.index() % 2 == 1}\n-\n-    pub(crate) fn kind(self) -> &'static str {\n-        if self.is_reservation() { \"reserved\" } else { \"active\" }\n-    }\n-    pub(crate) fn borrow_index(self) -> BorrowIndex {\n-        BorrowIndex::new(self.index() / 2)\n-    }\n+    nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               mir: &'a Mir<'tcx>,\n-               nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n-               def_id: DefId,\n-               body_id: Option<hir::BodyId>)\n-               -> Self {\n+    crate fn new(\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        mir: &'a Mir<'tcx>,\n+        nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n+        def_id: DefId,\n+        body_id: Option<hir::BodyId>,\n+        borrow_set: &Rc<BorrowSet<'tcx>>\n+    ) -> Self {\n         let scope_tree = tcx.region_scope_tree(def_id);\n         let root_scope = body_id.map(|body_id| {\n             region::Scope::CallSite(tcx.hir.body(body_id).value.hir_id.local_id)\n         });\n-        let mut visitor = GatherBorrows {\n-            tcx,\n-            mir,\n-            idx_vec: IndexVec::new(),\n-            location_map: FxHashMap(),\n-            assigned_map: FxHashMap(),\n-            activation_map: FxHashMap(),\n-            region_map: FxHashMap(),\n-            local_map: FxHashMap(),\n-            region_span_map: FxHashMap(),\n-            nonlexical_regioncx: nonlexical_regioncx.clone()\n-        };\n-        visitor.visit_mir(mir);\n-        return Borrows { tcx: tcx,\n-                         mir: mir,\n-                         borrows: visitor.idx_vec,\n-                         scope_tree,\n-                         root_scope,\n-                         location_map: visitor.location_map,\n-                         assigned_map: visitor.assigned_map,\n-                         activation_map: visitor.activation_map,\n-                         region_map: visitor.region_map,\n-                         local_map: visitor.local_map,\n-                         region_span_map: visitor.region_span_map,\n-                         nonlexical_regioncx };\n-\n-        struct GatherBorrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-            tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-            mir: &'a Mir<'tcx>,\n-            idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n-            location_map: FxHashMap<Location, BorrowIndex>,\n-            assigned_map: FxHashMap<Place<'tcx>, FxHashSet<BorrowIndex>>,\n-            activation_map: FxHashMap<Location, FxHashSet<BorrowIndex>>,\n-            region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n-            local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n-            region_span_map: FxHashMap<RegionKind, Span>,\n-            nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n-        }\n-\n-        impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n-            fn visit_assign(&mut self,\n-                            block: mir::BasicBlock,\n-                            assigned_place: &mir::Place<'tcx>,\n-                            rvalue: &mir::Rvalue<'tcx>,\n-                            location: mir::Location) {\n-                fn root_local(mut p: &mir::Place<'_>) -> Option<mir::Local> {\n-                    loop { match p {\n-                        mir::Place::Projection(pi) => p = &pi.base,\n-                        mir::Place::Static(_) => return None,\n-                        mir::Place::Local(l) => return Some(*l)\n-                    }}\n-                }\n-\n-                if let mir::Rvalue::Ref(region, kind, ref borrowed_place) = *rvalue {\n-                    if is_unsafe_place(self.tcx, self.mir, borrowed_place) { return; }\n-\n-                    let activate_location = self.compute_activation_location(location,\n-                                                                             &assigned_place,\n-                                                                             region,\n-                                                                             kind);\n-                    let borrow = BorrowData {\n-                        kind, region,\n-                        reserve_location: location,\n-                        borrowed_place: borrowed_place.clone(),\n-                        assigned_place: assigned_place.clone(),\n-                    };\n-                    let idx = self.idx_vec.push(borrow);\n-                    self.location_map.insert(location, idx);\n-\n-                    insert(&mut self.activation_map, &activate_location, idx);\n-                    insert(&mut self.assigned_map, assigned_place, idx);\n-                    insert(&mut self.region_map, &region, idx);\n-                    if let Some(local) = root_local(borrowed_place) {\n-                        insert(&mut self.local_map, &local, idx);\n-                    }\n-                }\n-\n-                return self.super_assign(block, assigned_place, rvalue, location);\n-\n-                fn insert<'a, K, V>(map: &'a mut FxHashMap<K, FxHashSet<V>>,\n-                                    k: &K,\n-                                    v: V)\n-                    where K: Clone+Eq+Hash, V: Eq+Hash\n-                {\n-                    map.entry(k.clone())\n-                        .or_insert(FxHashSet())\n-                        .insert(v);\n-                }\n-            }\n-\n-            fn visit_rvalue(&mut self,\n-                            rvalue: &mir::Rvalue<'tcx>,\n-                            location: mir::Location) {\n-                if let mir::Rvalue::Ref(region, kind, ref place) = *rvalue {\n-                    // double-check that we already registered a BorrowData for this\n-\n-                    let mut found_it = false;\n-                    for idx in &self.region_map[region] {\n-                        let bd = &self.idx_vec[*idx];\n-                        if bd.reserve_location == location &&\n-                            bd.kind == kind &&\n-                            bd.region == region &&\n-                            bd.borrowed_place == *place\n-                        {\n-                            found_it = true;\n-                            break;\n-                        }\n-                    }\n-                    assert!(found_it, \"Ref {:?} at {:?} missing BorrowData\", rvalue, location);\n-                }\n-\n-                return self.super_rvalue(rvalue, location);\n-            }\n-\n-            fn visit_statement(&mut self,\n-                               block: mir::BasicBlock,\n-                               statement: &mir::Statement<'tcx>,\n-                               location: Location) {\n-                if let mir::StatementKind::EndRegion(region_scope) = statement.kind {\n-                    self.region_span_map.insert(ReScope(region_scope), statement.source_info.span);\n-                }\n-                return self.super_statement(block, statement, location);\n-            }\n-        }\n-\n-        /// A MIR visitor that determines if a specific place is used in a two-phase activating\n-        /// manner in a given chunk of MIR.\n-        struct ContainsUseOfPlace<'b, 'tcx: 'b> {\n-            target: &'b Place<'tcx>,\n-            use_found: bool,\n-        }\n-\n-        impl<'b, 'tcx: 'b> ContainsUseOfPlace<'b, 'tcx> {\n-            fn new(place: &'b Place<'tcx>) -> Self {\n-                Self { target: place, use_found: false }\n-            }\n-\n-            /// return whether `context` should be considered a \"use\" of a\n-            /// place found in that context. \"Uses\" activate associated\n-            /// borrows (at least when such uses occur while the borrow also\n-            /// has a reservation at the time).\n-            fn is_potential_use(context: PlaceContext) -> bool {\n-                match context {\n-                    // storage effects on a place do not activate it\n-                    PlaceContext::StorageLive | PlaceContext::StorageDead => false,\n-\n-                    // validation effects do not activate a place\n-                    //\n-                    // FIXME: Should they? Is it just another read? Or can we\n-                    // guarantee it won't dereference the stored address? How\n-                    // \"deep\" does validation go?\n-                    PlaceContext::Validate => false,\n-\n-                    // FIXME: This is here to not change behaviour from before\n-                    // AsmOutput existed, but it's not necessarily a pure overwrite.\n-                    // so it's possible this should activate the place.\n-                    PlaceContext::AsmOutput |\n-                    // pure overwrites of a place do not activate it. (note\n-                    // PlaceContext::Call is solely about dest place)\n-                    PlaceContext::Store | PlaceContext::Call => false,\n-\n-                    // reads of a place *do* activate it\n-                    PlaceContext::Move |\n-                    PlaceContext::Copy |\n-                    PlaceContext::Drop |\n-                    PlaceContext::Inspect |\n-                    PlaceContext::Borrow { .. } |\n-                    PlaceContext::Projection(..) => true,\n-                }\n-            }\n-        }\n-\n-        impl<'b, 'tcx: 'b> Visitor<'tcx> for ContainsUseOfPlace<'b, 'tcx> {\n-            fn visit_place(&mut self,\n-                           place: &mir::Place<'tcx>,\n-                           context: PlaceContext<'tcx>,\n-                           location: Location) {\n-                if Self::is_potential_use(context) && place == self.target {\n-                    self.use_found = true;\n-                    return;\n-                    // There is no need to keep checking the statement, we already found a use\n-                }\n-\n-                self.super_place(place, context, location);\n-            }\n-        }\n-\n-        impl<'a, 'gcx, 'tcx> GatherBorrows<'a, 'gcx, 'tcx> {\n-            /// Returns true if the borrow represented by `kind` is\n-            /// allowed to be split into separate Reservation and\n-            /// Activation phases.\n-            fn allow_two_phase_borrow(&self, kind: mir::BorrowKind) -> bool {\n-                self.tcx.two_phase_borrows() &&\n-                    (kind.allows_two_phase_borrow() ||\n-                     self.tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n-            }\n-\n-            /// Returns true if the given location contains an NLL-activating use of the given place\n-            fn location_contains_use(&self, location: Location, place: &Place) -> bool {\n-                let mut use_checker = ContainsUseOfPlace::new(place);\n-                let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n-                    panic!(\"could not find block at location {:?}\", location);\n-                });\n-                if location.statement_index != block.statements.len() {\n-                    // This is a statement\n-                    let stmt = block.statements.get(location.statement_index).unwrap_or_else(|| {\n-                        panic!(\"could not find statement at location {:?}\");\n-                    });\n-                    use_checker.visit_statement(location.block, stmt, location);\n-                } else {\n-                    // This is a terminator\n-                    match block.terminator {\n-                        Some(ref term) => {\n-                            use_checker.visit_terminator(location.block, term, location);\n-                        }\n-                        None => {\n-                            // There is no way for Place to be used by the terminator if there is no\n-                            // terminator\n-                        }\n-                    }\n-                }\n-\n-                use_checker.use_found\n-            }\n-\n-            /// Determines if the provided region is terminated after the provided location.\n-            /// EndRegion statements terminate their enclosed region::Scope.\n-            /// We also consult with the NLL region inference engine, should one be available\n-            fn region_terminated_after(&self, region: Region<'tcx>, location: Location) -> bool {\n-                let block_data = &self.mir[location.block];\n-                if location.statement_index != block_data.statements.len() {\n-                    let stmt = &block_data.statements[location.statement_index];\n-                    if let mir::StatementKind::EndRegion(region_scope) = stmt.kind {\n-                        if &ReScope(region_scope) == region {\n-                            // We encountered an EndRegion statement that terminates the provided\n-                            // region\n-                            return true;\n-                        }\n-                    }\n-                }\n-                if let Some(ref regioncx) = self.nonlexical_regioncx {\n-                    if !regioncx.region_contains_point(region, location) {\n-                        // NLL says the region has ended already\n-                        return true;\n-                    }\n-                }\n-\n-                false\n-            }\n-\n-            /// Computes the activation location of a borrow.\n-            /// The general idea is to start at the beginning of the region and perform a DFS\n-            /// until we exit the region, either via an explicit EndRegion or because NLL tells\n-            /// us so. If we find more than one valid activation point, we currently panic the\n-            /// compiler since two-phase borrows are only currently supported for compiler-\n-            /// generated code. More precisely, we only allow two-phase borrows for:\n-            ///   - Function calls (fn some_func(&mut self, ....))\n-            ///   - *Assign operators (a += b -> fn add_assign(&mut self, other: Self))\n-            /// See\n-            ///   - https://github.com/rust-lang/rust/issues/48431\n-            /// for detailed design notes.\n-            /// See the FIXME in the body of the function for notes on extending support to more\n-            /// general two-phased borrows.\n-            fn compute_activation_location(&self,\n-                                           start_location: Location,\n-                                           assigned_place: &mir::Place<'tcx>,\n-                                           region: Region<'tcx>,\n-                                           kind: mir::BorrowKind) -> Location {\n-                debug!(\"Borrows::compute_activation_location({:?}, {:?}, {:?})\",\n-                       start_location,\n-                       assigned_place,\n-                       region);\n-                if !self.allow_two_phase_borrow(kind) {\n-                    debug!(\"  -> {:?}\", start_location);\n-                    return start_location;\n-                }\n-\n-                // Perform the DFS.\n-                // `stack` is the stack of locations still under consideration\n-                // `visited` is the set of points we have already visited\n-                // `found_use` is an Option that becomes Some when we find a use\n-                let mut stack = vec![start_location];\n-                let mut visited = FxHashSet();\n-                let mut found_use = None;\n-                while let Some(curr_loc) = stack.pop() {\n-                    let block_data = &self.mir.basic_blocks()\n-                        .get(curr_loc.block)\n-                        .unwrap_or_else(|| {\n-                            panic!(\"could not find block at location {:?}\", curr_loc);\n-                        });\n-\n-                    if self.region_terminated_after(region, curr_loc) {\n-                        // No need to process this statement.\n-                        // It's either an EndRegion (and thus couldn't use assigned_place) or not\n-                        // contained in the NLL region and thus a use would be invalid\n-                        continue;\n-                    }\n-\n-                    if !visited.insert(curr_loc) {\n-                        debug!(\"  Already visited {:?}\", curr_loc);\n-                        continue;\n-                    }\n-\n-                    if self.location_contains_use(curr_loc, assigned_place) {\n-                        // FIXME: Handle this case a little more gracefully. Perhaps collect\n-                        // all uses in a vector, and find the point in the CFG that dominates\n-                        // all of them?\n-                        // Right now this is sufficient though since there should only be exactly\n-                        // one borrow-activating use of the borrow.\n-                        assert!(found_use.is_none(), \"Found secondary use of place\");\n-                        found_use = Some(curr_loc);\n-                    }\n-\n-                    // Push the points we should consider next.\n-                    if curr_loc.statement_index < block_data.statements.len() {\n-                        stack.push(curr_loc.successor_within_block());\n-                    } else {\n-                        stack.extend(block_data.terminator().successors().iter().map(\n-                            |&basic_block| {\n-                                Location {\n-                                    statement_index: 0,\n-                                    block: basic_block\n-                                }\n-                            }\n-                        ))\n-                    }\n-                }\n \n-                let found_use = found_use.expect(\"Did not find use of two-phase place\");\n-                debug!(\"  -> {:?}\", found_use);\n-                found_use\n-            }\n-        }\n-    }\n-\n-    /// Returns the span for the \"end point\" given region. This will\n-    /// return `None` if NLL is enabled, since that concept has no\n-    /// meaning there.  Otherwise, return region span if it exists and\n-    /// span for end of the function if it doesn't exist.\n-    pub(crate) fn opt_region_end_span(&self, region: &Region) -> Option<Span> {\n-        match self.nonlexical_regioncx {\n-            Some(_) => None,\n-            None => {\n-                match self.region_span_map.get(region) {\n-                    Some(span) => Some(self.tcx.sess.codemap().end_point(*span)),\n-                    None => Some(self.tcx.sess.codemap().end_point(self.mir.span))\n-                }\n-            }\n+        Borrows {\n+            tcx: tcx,\n+            mir: mir,\n+            borrow_set: borrow_set.clone(),\n+            scope_tree,\n+            root_scope,\n+            nonlexical_regioncx,\n         }\n     }\n \n-    pub fn borrows(&self) -> &IndexVec<BorrowIndex, BorrowData<'tcx>> { &self.borrows }\n+    crate fn borrows(&self) -> &IndexVec<BorrowIndex, BorrowData<'tcx>> { &self.borrow_set.borrows }\n \n     pub fn scope_tree(&self) -> &Lrc<region::ScopeTree> { &self.scope_tree }\n \n     pub fn location(&self, idx: BorrowIndex) -> &Location {\n-        &self.borrows[idx].reserve_location\n+        &self.borrow_set.borrows[idx].reserve_location\n     }\n \n     /// Add all borrows to the kill set, if those borrows are out of scope at `location`.\n     /// That means either they went out of either a nonlexical scope, if we care about those\n     /// at the moment, or the location represents a lexical EndRegion\n     fn kill_loans_out_of_scope_at_location(&self,\n-                                           sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                                           sets: &mut BlockSets<BorrowIndex>,\n                                            location: Location) {\n-        if let Some(ref regioncx) = self.nonlexical_regioncx {\n-            // NOTE: The state associated with a given `location`\n-            // reflects the dataflow on entry to the statement. If it\n-            // does not contain `borrow_region`, then then that means\n-            // that the statement at `location` kills the borrow.\n-            //\n-            // We are careful always to call this function *before* we\n-            // set up the gen-bits for the statement or\n-            // termanator. That way, if the effect of the statement or\n-            // terminator *does* introduce a new loan of the same\n-            // region, then setting that gen-bit will override any\n-            // potential kill introduced here.\n-            for (borrow_index, borrow_data) in self.borrows.iter_enumerated() {\n-                let borrow_region = borrow_data.region.to_region_vid();\n-                if !regioncx.region_contains_point(borrow_region, location) {\n-                    sets.kill(&ReserveOrActivateIndex::reserved(borrow_index));\n-                    sets.kill(&ReserveOrActivateIndex::active(borrow_index));\n-                }\n+        let regioncx = &self.nonlexical_regioncx;\n+\n+        // NOTE: The state associated with a given `location`\n+        // reflects the dataflow on entry to the statement. If it\n+        // does not contain `borrow_region`, then then that means\n+        // that the statement at `location` kills the borrow.\n+        //\n+        // We are careful always to call this function *before* we\n+        // set up the gen-bits for the statement or\n+        // termanator. That way, if the effect of the statement or\n+        // terminator *does* introduce a new loan of the same\n+        // region, then setting that gen-bit will override any\n+        // potential kill introduced here.\n+        for (borrow_index, borrow_data) in self.borrow_set.borrows.iter_enumerated() {\n+            let borrow_region = borrow_data.region.to_region_vid();\n+            if !regioncx.region_contains_point(borrow_region, location) {\n+                sets.kill(&borrow_index);\n             }\n         }\n     }\n \n     fn kill_borrows_on_local(&self,\n-                             sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                             sets: &mut BlockSets<BorrowIndex>,\n                              local: &rustc::mir::Local)\n     {\n-        if let Some(borrow_indexes) = self.local_map.get(local) {\n-            sets.kill_all(borrow_indexes.iter()\n-                          .map(|b| ReserveOrActivateIndex::reserved(*b)));\n-            sets.kill_all(borrow_indexes.iter()\n-                          .map(|b| ReserveOrActivateIndex::active(*b)));\n-        }\n-    }\n-\n-    /// Performs the activations for a given location\n-    fn perform_activations_at_location(&self,\n-                                       sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                                       location: Location) {\n-        // Handle activations\n-        match self.activation_map.get(&location) {\n-            Some(activations) => {\n-                for activated in activations {\n-                    debug!(\"activating borrow {:?}\", activated);\n-                    sets.gen(&ReserveOrActivateIndex::active(*activated))\n-                }\n-            }\n-            None => {}\n+        if let Some(borrow_indexes) = self.borrow_set.local_map.get(local) {\n+            sets.kill_all(borrow_indexes);\n         }\n     }\n }\n \n impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n-    type Idx = ReserveOrActivateIndex;\n+    type Idx = BorrowIndex;\n     fn name() -> &'static str { \"borrows\" }\n     fn bits_per_block(&self) -> usize {\n-        self.borrows.len() * 2\n+        self.borrow_set.borrows.len() * 2\n     }\n \n-    fn start_block_effect(&self, _entry_set: &mut IdxSet<ReserveOrActivateIndex>) {\n+    fn start_block_effect(&self, _entry_set: &mut IdxSet<BorrowIndex>) {\n         // no borrows of code region_scopes have been taken prior to\n         // function execution, so this method has no effect on\n         // `_sets`.\n     }\n \n     fn before_statement_effect(&self,\n-                               sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                               sets: &mut BlockSets<BorrowIndex>,\n                                location: Location) {\n         debug!(\"Borrows::before_statement_effect sets: {:?} location: {:?}\", sets, location);\n         self.kill_loans_out_of_scope_at_location(sets, location);\n     }\n \n-    fn statement_effect(&self, sets: &mut BlockSets<ReserveOrActivateIndex>, location: Location) {\n+    fn statement_effect(&self, sets: &mut BlockSets<BorrowIndex>, location: Location) {\n         debug!(\"Borrows::statement_effect sets: {:?} location: {:?}\", sets, location);\n \n         let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n@@ -585,21 +150,10 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n             panic!(\"could not find statement at location {:?}\");\n         });\n \n-        self.perform_activations_at_location(sets, location);\n         self.kill_loans_out_of_scope_at_location(sets, location);\n \n         match stmt.kind {\n-            // EndRegion kills any borrows (reservations and active borrows both)\n-            mir::StatementKind::EndRegion(region_scope) => {\n-                if let Some(borrow_indexes) = self.region_map.get(&ReScope(region_scope)) {\n-                    assert!(self.nonlexical_regioncx.is_none());\n-                    for idx in borrow_indexes {\n-                        sets.kill(&ReserveOrActivateIndex::reserved(*idx));\n-                        sets.kill(&ReserveOrActivateIndex::active(*idx));\n-                    }\n-                } else {\n-                    // (if there is no entry, then there are no borrows to be tracked)\n-                }\n+            mir::StatementKind::EndRegion(_) => {\n             }\n \n             mir::StatementKind::Assign(ref lhs, ref rhs) => {\n@@ -617,22 +171,22 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                 // propagate_call_return method.\n \n                 if let mir::Rvalue::Ref(region, _, ref place) = *rhs {\n-                    if is_unsafe_place(self.tcx, self.mir, place) { return; }\n-                    let index = self.location_map.get(&location).unwrap_or_else(|| {\n+                    if place.is_unsafe_place(self.tcx, self.mir) { return; }\n+                    let index = self.borrow_set.location_map.get(&location).unwrap_or_else(|| {\n                         panic!(\"could not find BorrowIndex for location {:?}\", location);\n                     });\n \n                     if let RegionKind::ReEmpty = region {\n                         // If the borrowed value dies before the borrow is used, the region for\n                         // the borrow can be empty. Don't track the borrow in that case.\n-                        sets.kill(&ReserveOrActivateIndex::active(*index));\n+                        sets.kill(&index);\n                         return\n                     }\n \n-                    assert!(self.region_map.get(region).unwrap_or_else(|| {\n+                    assert!(self.borrow_set.region_map.get(region).unwrap_or_else(|| {\n                         panic!(\"could not find BorrowIndexs for region {:?}\", region);\n                     }).contains(&index));\n-                    sets.gen(&ReserveOrActivateIndex::reserved(*index));\n+                    sets.gen(&index);\n \n                     // Issue #46746: Two-phase borrows handles\n                     // stmts of form `Tmp = &mut Borrow` ...\n@@ -643,7 +197,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                             // e.g. `box (&mut _)`. Current\n                             // conservative solution: force\n                             // immediate activation here.\n-                            sets.gen(&ReserveOrActivateIndex::active(*index));\n+                            sets.gen(&index);\n                         }\n                     }\n                 }\n@@ -679,21 +233,20 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n     }\n \n     fn before_terminator_effect(&self,\n-                                sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                                sets: &mut BlockSets<BorrowIndex>,\n                                 location: Location) {\n         debug!(\"Borrows::before_terminator_effect sets: {:?} location: {:?}\", sets, location);\n         self.kill_loans_out_of_scope_at_location(sets, location);\n     }\n \n-    fn terminator_effect(&self, sets: &mut BlockSets<ReserveOrActivateIndex>, location: Location) {\n+    fn terminator_effect(&self, sets: &mut BlockSets<BorrowIndex>, location: Location) {\n         debug!(\"Borrows::terminator_effect sets: {:?} location: {:?}\", sets, location);\n \n         let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n             panic!(\"could not find block at location {:?}\", location);\n         });\n \n         let term = block.terminator();\n-        self.perform_activations_at_location(sets, location);\n         self.kill_loans_out_of_scope_at_location(sets, location);\n \n \n@@ -707,7 +260,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                 // and hence most of these loans will already be dead -- but, in some cases\n                 // like unwind paths, we do not always emit `EndRegion` statements, so we\n                 // add some kills here as a \"backup\" and to avoid spurious error messages.\n-                for (borrow_index, borrow_data) in self.borrows.iter_enumerated() {\n+                for (borrow_index, borrow_data) in self.borrow_set.borrows.iter_enumerated() {\n                     if let ReScope(scope) = borrow_data.region {\n                         // Check that the scope is not actually a scope from a function that is\n                         // a parent of our closure. Note that the CallSite scope itself is\n@@ -716,8 +269,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                             if *scope != root_scope &&\n                                 self.scope_tree.is_subscope_of(*scope, root_scope)\n                             {\n-                                sets.kill(&ReserveOrActivateIndex::reserved(borrow_index));\n-                                sets.kill(&ReserveOrActivateIndex::active(borrow_index));\n+                                sets.kill(&borrow_index);\n                             }\n                         }\n                     }\n@@ -738,7 +290,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n     }\n \n     fn propagate_call_return(&self,\n-                             _in_out: &mut IdxSet<ReserveOrActivateIndex>,\n+                             _in_out: &mut IdxSet<BorrowIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n                              _dest_place: &mir::Place) {\n@@ -764,34 +316,3 @@ impl<'a, 'gcx, 'tcx> InitialFlow for Borrows<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn is_unsafe_place<'a, 'gcx: 'tcx, 'tcx: 'a>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n-    place: &mir::Place<'tcx>\n-) -> bool {\n-    use self::mir::Place::*;\n-    use self::mir::ProjectionElem;\n-\n-    match *place {\n-        Local(_) => false,\n-        Static(ref static_) => tcx.is_static(static_.def_id) == Some(hir::Mutability::MutMutable),\n-        Projection(ref proj) => {\n-            match proj.elem {\n-                ProjectionElem::Field(..) |\n-                ProjectionElem::Downcast(..) |\n-                ProjectionElem::Subslice { .. } |\n-                ProjectionElem::ConstantIndex { .. } |\n-                ProjectionElem::Index(_) => {\n-                    is_unsafe_place(tcx, mir, &proj.base)\n-                }\n-                ProjectionElem::Deref => {\n-                    let ty = proj.base.ty(mir, tcx).to_ty(tcx);\n-                    match ty.sty {\n-                        ty::TyRawPtr(..) => true,\n-                        _ => is_unsafe_place(tcx, mir, &proj.base),\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "f64fd64b283ea5ea63ad992123d702695f28bffa", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -19,6 +19,7 @@ use rustc_data_structures::indexed_set::{IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n \n use super::MoveDataParamEnv;\n+\n use util::elaborate_drops::DropFlagState;\n \n use super::move_paths::{HasMoveData, MoveData, MoveOutIndex, MovePathIndex, InitIndex};\n@@ -37,7 +38,6 @@ mod borrowed_locals;\n \n pub use self::borrowed_locals::*;\n \n-#[allow(dead_code)]\n pub(super) mod borrows;\n \n /// `MaybeInitializedPlaces` tracks all places that might be"}, {"sha": "85458c7d6848848174a9eab94fb1ea47bf610a8a", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -29,9 +29,8 @@ pub use self::impls::{MaybeStorageLive};\n pub use self::impls::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n pub use self::impls::{DefinitelyInitializedPlaces, MovingOutStatements};\n pub use self::impls::EverInitializedPlaces;\n-pub use self::impls::borrows::{Borrows, BorrowData};\n+pub use self::impls::borrows::Borrows;\n pub use self::impls::HaveBeenBorrowedLocals;\n-pub(crate) use self::impls::borrows::{ReserveOrActivateIndex};\n pub use self::at_location::{FlowAtLocation, FlowsAtLocation};\n pub(crate) use self::drop_flag_effects::*;\n "}, {"sha": "3a49e28f04187dbaf71b8e4e1bf7cd0cd1421f45", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -65,9 +65,6 @@ pub(crate) mod indexes {\n \n     /// Index into Borrows.locations\n     new_index!(BorrowIndex, \"bw\");\n-\n-    /// Index into Reservations/Activations bitvector\n-    new_index!(ReserveOrActivateIndex, \"ra\");\n }\n \n pub use self::indexes::MovePathIndex;"}, {"sha": "de3063a575673bc8b6f88e5f7fe5d78b5624f014", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -20,6 +20,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(catch_expr)]\n+#![feature(crate_visibility_modifier)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(decl_macro)]"}, {"sha": "5643e1ef09146eb1fe6b4daae607938d6c3797b1", "filename": "src/test/compile-fail/E0501.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2FE0501.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2FE0501.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0501.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -26,10 +26,12 @@ fn foo(a: &mut i32) {\n         inside_closure(a)\n     };\n     outside_closure_1(a); //[ast]~ ERROR cannot borrow `*a` as mutable because previous closure requires unique access\n-                         //[mir]~^ ERROR cannot borrow `*a` as mutable because previous closure requires unique access\n+    //[mir]~^ ERROR cannot borrow `*a` as mutable because previous closure requires unique access\n \n     outside_closure_2(a); //[ast]~ ERROR cannot borrow `*a` as immutable because previous closure requires unique access\n-                         //[mir]~^ ERROR cannot borrow `*a` as immutable because previous closure requires unique access\n+    //[mir]~^ ERROR cannot borrow `*a` as immutable because previous closure requires unique access\n+\n+    drop(bar);\n }\n \n fn main() {"}, {"sha": "0b230be85ad97c2ab68d97220eb720159c6172d2", "filename": "src/test/compile-fail/borrowck/borrowck-asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-asm.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -14,7 +14,7 @@\n // ignore-sparc\n \n // revisions: ast mir\n-//[mir]compile-flags: -Z borrowck=mir -Z nll\n+//[mir]compile-flags: -Z borrowck=mir\n \n #![feature(asm)]\n "}, {"sha": "9057ba0790712f36ec808332ab3523acacdcd7c4", "filename": "src/test/compile-fail/borrowck/borrowck-closures-mut-and-imm.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-closures-mut-and-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-closures-mut-and-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-closures-mut-and-imm.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -29,42 +29,48 @@ fn a() {\n     let mut x = 3;\n     let c1 = || x = 4;\n     let c2 = || x * 5; //[ast]~ ERROR cannot borrow `x`\n-                       //[mir]~^ ERROR cannot borrow `x` as immutable because it is also borrowed as mutable\n+    //[mir]~^ ERROR cannot borrow `x` as immutable because it is also borrowed as mutable\n+    drop(c1);\n }\n \n fn b() {\n     let mut x = 3;\n     let c1 = || set(&mut x);\n     let c2 = || get(&x); //[ast]~ ERROR cannot borrow `x`\n                          //[mir]~^ ERROR cannot borrow `x` as immutable because it is also borrowed as mutable\n+    drop(c1);\n }\n \n fn c() {\n     let mut x = 3;\n     let c1 = || set(&mut x);\n     let c2 = || x * 5; //[ast]~ ERROR cannot borrow `x`\n                        //[mir]~^ ERROR cannot borrow `x` as immutable because it is also borrowed as mutable\n+    drop(c1);\n }\n \n fn d() {\n     let mut x = 3;\n     let c2 = || x * 5;\n     x = 5; //[ast]~ ERROR cannot assign\n            //[mir]~^ ERROR cannot assign to `x` because it is borrowed\n+    drop(c2);\n }\n \n fn e() {\n     let mut x = 3;\n     let c1 = || get(&x);\n     x = 5; //[ast]~ ERROR cannot assign\n            //[mir]~^ ERROR cannot assign to `x` because it is borrowed\n+    drop(c1);\n }\n \n fn f() {\n     let mut x: Box<_> = box 3;\n     let c1 = || get(&*x);\n     *x = 5; //[ast]~ ERROR cannot assign to `*x`\n             //[mir]~^ ERROR cannot assign to `*x` because it is borrowed\n+    drop(c1);\n }\n \n fn g() {\n@@ -76,6 +82,7 @@ fn g() {\n     let c1 = || get(&*x.f);\n     *x.f = 5; //[ast]~ ERROR cannot assign to `*x.f`\n               //[mir]~^ ERROR cannot assign to `*x.f` because it is borrowed\n+    drop(c1);\n }\n \n fn h() {\n@@ -87,6 +94,7 @@ fn h() {\n     let c1 = || get(&*x.f);\n     let c2 = || *x.f = 5; //[ast]~ ERROR cannot borrow `x` as mutable\n                           //[mir]~^ ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n+    drop(c1);\n }\n \n fn main() {"}, {"sha": "3a7e4a13740d070ab1b4afbba2bf2a7283f52968", "filename": "src/test/compile-fail/borrowck/borrowck-describe-lvalue.rs", "status": "modified", "additions": 42, "deletions": 22, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -49,83 +49,93 @@ fn main() {\n     // Local and field from struct\n     {\n         let mut f = Foo { x: 22 };\n-        let _x = f.x();\n+        let x = f.x();\n         f.x; //[ast]~ ERROR cannot use `f.x` because it was mutably borrowed\n-             //[mir]~^ ERROR cannot use `f.x` because it was mutably borrowed\n+        //[mir]~^ ERROR cannot use `f.x` because it was mutably borrowed\n+        drop(x);\n     }\n     // Local and field from tuple-struct\n     {\n         let mut g = Bar(22);\n-        let _0 = g.x();\n+        let x = g.x();\n         g.0; //[ast]~ ERROR cannot use `g.0` because it was mutably borrowed\n              //[mir]~^ ERROR cannot use `g.0` because it was mutably borrowed\n+        drop(x);\n     }\n     // Local and field from tuple\n     {\n         let mut h = (22, 23);\n-        let _0 = &mut h.0;\n+        let x = &mut h.0;\n         h.0; //[ast]~ ERROR cannot use `h.0` because it was mutably borrowed\n              //[mir]~^ ERROR cannot use `h.0` because it was mutably borrowed\n+        drop(x);\n     }\n     // Local and field from enum\n     {\n         let mut e = Baz::X(2);\n-        let _e0 = e.x();\n+        let x = e.x();\n         match e { //[mir]~ ERROR cannot use `e` because it was mutably borrowed\n             Baz::X(value) => value\n             //[ast]~^ ERROR cannot use `e.0` because it was mutably borrowed\n             //[mir]~^^ ERROR cannot use `e.0` because it was mutably borrowed\n         };\n+        drop(x);\n     }\n     // Local and field from union\n     unsafe {\n         let mut u = U { b: 0 };\n-        let _ra = &mut u.a;\n+        let x = &mut u.a;\n         u.a; //[ast]~ ERROR cannot use `u.a` because it was mutably borrowed\n              //[mir]~^ ERROR cannot use `u.a` because it was mutably borrowed\n+        drop(x);\n     }\n     // Deref and field from struct\n     {\n         let mut f = Box::new(Foo { x: 22 });\n-        let _x = f.x();\n+        let x = f.x();\n         f.x; //[ast]~ ERROR cannot use `f.x` because it was mutably borrowed\n              //[mir]~^ ERROR cannot use `f.x` because it was mutably borrowed\n+        drop(x);\n     }\n     // Deref and field from tuple-struct\n     {\n         let mut g = Box::new(Bar(22));\n-        let _0 = g.x();\n+        let x = g.x();\n         g.0; //[ast]~ ERROR cannot use `g.0` because it was mutably borrowed\n              //[mir]~^ ERROR cannot use `g.0` because it was mutably borrowed\n+        drop(x);\n     }\n     // Deref and field from tuple\n     {\n         let mut h = Box::new((22, 23));\n-        let _0 = &mut h.0;\n+        let x = &mut h.0;\n         h.0; //[ast]~ ERROR cannot use `h.0` because it was mutably borrowed\n              //[mir]~^ ERROR cannot use `h.0` because it was mutably borrowed\n+        drop(x);\n     }\n     // Deref and field from enum\n     {\n         let mut e = Box::new(Baz::X(3));\n-        let _e0 = e.x();\n+        let x = e.x();\n         match *e { //[mir]~ ERROR cannot use `*e` because it was mutably borrowed\n             Baz::X(value) => value\n             //[ast]~^ ERROR cannot use `e.0` because it was mutably borrowed\n             //[mir]~^^ ERROR cannot use `e.0` because it was mutably borrowed\n         };\n+        drop(x);\n     }\n     // Deref and field from union\n     unsafe {\n         let mut u = Box::new(U { b: 0 });\n-        let _ra = &mut u.a;\n+        let x = &mut u.a;\n         u.a; //[ast]~ ERROR cannot use `u.a` because it was mutably borrowed\n              //[mir]~^ ERROR cannot use `u.a` because it was mutably borrowed\n+        drop(x);\n     }\n     // Constant index\n     {\n         let mut v = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        let _v = &mut v;\n+        let x = &mut v;\n         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n             &[x, _, .., _, _] => println!(\"{}\", x),\n                 //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n@@ -150,11 +160,12 @@ fn main() {\n                 //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed\n                             _ => panic!(\"other case\"),\n         }\n+        drop(x);\n     }\n     // Subslices\n     {\n         let mut v = &[1, 2, 3, 4, 5];\n-        let _v = &mut v;\n+        let x = &mut v;\n         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n             &[x..] => println!(\"{:?}\", x),\n                 //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n@@ -179,13 +190,14 @@ fn main() {\n                 //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed\n             _ => panic!(\"other case\"),\n         }\n+        drop(x);\n     }\n     // Downcasted field\n     {\n         enum E<X> { A(X), B { x: X } }\n \n         let mut e = E::A(3);\n-        let _e = &mut e;\n+        let x = &mut e;\n         match e { //[mir]~ ERROR cannot use `e` because it was mutably borrowed\n             E::A(ref ax) =>\n                 //[ast]~^ ERROR cannot borrow `e.0` as immutable because `e` is also borrowed as mutable\n@@ -197,13 +209,14 @@ fn main() {\n                 //[mir]~^^ ERROR cannot borrow `e.x` as immutable because it is also borrowed as mutable\n                 println!(\"e.bx: {:?}\", bx),\n         }\n+        drop(x);\n     }\n     // Field in field\n     {\n         struct F { x: u32, y: u32 };\n         struct S { x: F, y: (u32, u32), };\n         let mut s = S { x: F { x: 1, y: 2}, y: (999, 998) };\n-        let _s = &mut s;\n+        let x = &mut s;\n         match s { //[mir]~ ERROR cannot use `s` because it was mutably borrowed\n             S  { y: (ref y0, _), .. } =>\n                 //[ast]~^ ERROR cannot borrow `s.y.0` as immutable because `s` is also borrowed as mutable\n@@ -218,6 +231,7 @@ fn main() {\n                 println!(\"x0: {:?}\", x0),\n             _ => panic!(\"other case\"),\n         }\n+        drop(x);\n     }\n     // Field of ref\n     {\n@@ -231,6 +245,7 @@ fn main() {\n             let p: &'a u8 = &*block.current;\n             //[mir]~^ ERROR cannot borrow `*block.current` as immutable because it is also borrowed as mutable\n             // No errors in AST because of issue rust#38899\n+            drop(x);\n         }\n     }\n     // Field of ptr\n@@ -245,29 +260,32 @@ fn main() {\n             let p : *const u8 = &*(*block).current;\n             //[mir]~^ ERROR cannot borrow `*block.current` as immutable because it is also borrowed as mutable\n             // No errors in AST because of issue rust#38899\n+            drop(x);\n         }\n     }\n     // Field of index\n     {\n         struct F {x: u32, y: u32};\n         let mut v = &[F{x: 1, y: 2}, F{x: 3, y: 4}];\n-        let _v = &mut v;\n+        let x = &mut v;\n         v[0].y;\n         //[ast]~^ ERROR cannot use `v[..].y` because it was mutably borrowed\n         //[mir]~^^ ERROR cannot use `v[..].y` because it was mutably borrowed\n         //[mir]~| ERROR cannot use `*v` because it was mutably borrowed\n+        drop(x);\n     }\n     // Field of constant index\n     {\n         struct F {x: u32, y: u32};\n         let mut v = &[F{x: 1, y: 2}, F{x: 3, y: 4}];\n-        let _v = &mut v;\n+        let x = &mut v;\n         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n             &[_, F {x: ref xf, ..}] => println!(\"{}\", xf),\n             //[mir]~^ ERROR cannot borrow `v[..].x` as immutable because it is also borrowed as mutable\n             // No errors in AST\n             _ => panic!(\"other case\")\n         }\n+        drop(x);\n     }\n     // Field from upvar\n     {\n@@ -281,13 +299,15 @@ fn main() {\n     }\n     // Field from upvar nested\n     {\n+        // FIXME(#49824) -- the free region error below should probably not be there\n         let mut x = 0;\n            || {\n-               || {\n-                let y = &mut x;\n-                &mut x; //[ast]~ ERROR cannot borrow `**x` as mutable more than once at a time\n-                        //[mir]~^ ERROR cannot borrow `x` as mutable more than once at a time\n-                *y = 1;\n+               || { //[mir]~ ERROR free region `` does not outlive\n+                   let y = &mut x;\n+                   &mut x; //[ast]~ ERROR cannot borrow `**x` as mutable more than once at a time\n+                   //[mir]~^ ERROR cannot borrow `x` as mutable more than once at a time\n+                   *y = 1;\n+                   drop(y);\n                 }\n            };\n     }"}, {"sha": "6f0e0f43f60885bc17c2d2c01b80b7c2ce63a3be", "filename": "src/test/compile-fail/borrowck/borrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -13,10 +13,12 @@\n \n fn main() {\n     let mut _a = 3;\n-    let _b = &mut _a;\n+    let b = &mut _a;\n     {\n-        let _c = &*_b;\n+        let c = &*b;\n         _a = 4; //[ast]~ ERROR cannot assign to `_a`\n-                //[mir]~^ ERROR cannot assign to `_a` because it is borrowed\n+        //[mir]~^ ERROR cannot assign to `_a` because it is borrowed\n+        drop(c);\n     }\n+    drop(b);\n }"}, {"sha": "f2f3e7914227c788619e6122d3058227ee978e7d", "filename": "src/test/compile-fail/borrowck/borrowck-lend-flow-match.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-lend-flow-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-lend-flow-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-lend-flow-match.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -24,9 +24,10 @@ fn separate_arms() {\n             // fact no outstanding loan of x!\n             x = Some(0);\n         }\n-        Some(ref __isize) => {\n+        Some(ref r) => {\n             x = Some(1); //[ast]~ ERROR cannot assign\n-                         //[mir]~^ ERROR cannot assign to `x` because it is borrowed\n+            //[mir]~^ ERROR cannot assign to `x` because it is borrowed\n+            drop(r);\n         }\n     }\n     x.clone(); // just to prevent liveness warnings"}, {"sha": "c2136e62a7b228afb0993055d0914953ffec9f25", "filename": "src/test/compile-fail/borrowck/borrowck-match-already-borrowed.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-match-already-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-match-already-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-match-already-borrowed.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -25,16 +25,18 @@ fn match_enum() {\n         Foo::A(x) => x //[ast]~ ERROR [E0503]\n                        //[mir]~^ ERROR [E0503]\n     };\n+    drop(p);\n }\n \n \n fn main() {\n     let mut x = 1;\n-    let _x = &mut x;\n+    let r = &mut x;\n     let _ = match x { //[mir]~ ERROR [E0503]\n         x => x + 1, //[ast]~ ERROR [E0503]\n                     //[mir]~^ ERROR [E0503]\n         y => y + 2, //[ast]~ ERROR [E0503]\n                     //[mir]~^ ERROR [E0503]\n     };\n+    drop(r);\n }"}, {"sha": "7b0a71815a5f065de4f43d43110ec81790642896", "filename": "src/test/compile-fail/borrowck/borrowck-mut-borrow-linear-errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -17,14 +17,14 @@\n \n fn main() {\n     let mut x = 1;\n-    let mut addr;\n+    let mut addr = vec![];\n     loop {\n         match 1 {\n-            1 => { addr = &mut x; } //[ast]~ ERROR [E0499]\n+            1 => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n             //[mir]~^ ERROR [E0499]\n-            2 => { addr = &mut x; } //[ast]~ ERROR [E0499]\n+            2 => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n             //[mir]~^ ERROR [E0499]\n-            _ => { addr = &mut x; } //[ast]~ ERROR [E0499]\n+            _ => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n             //[mir]~^ ERROR [E0499]\n         }\n     }"}, {"sha": "109fe3d1128e1990b186e36158e679b864db127d", "filename": "src/test/compile-fail/borrowck/borrowck-overloaded-index-ref-index.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-overloaded-index-ref-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-overloaded-index-ref-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-overloaded-index-ref-index.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -71,4 +71,5 @@ fn main() {\n     s[2] = 20;\n     //[ast]~^ ERROR cannot assign to immutable indexed content\n     //[mir]~^^ ERROR cannot assign to immutable item\n+    drop(rs);\n }"}, {"sha": "d917a0abb88d089a1cd20eafa558562dbe3a4dba", "filename": "src/test/compile-fail/borrowck/borrowck-pat-reassign-binding.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-pat-reassign-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-pat-reassign-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-pat-reassign-binding.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -21,7 +21,8 @@ fn main() {\n       Some(ref i) => {\n           // But on this branch, `i` is an outstanding borrow\n           x = Some(*i+1); //[ast]~ ERROR cannot assign to `x`\n-                          //[mir]~^ ERROR cannot assign to `x` because it is borrowed\n+          //[mir]~^ ERROR cannot assign to `x` because it is borrowed\n+          drop(i);\n       }\n     }\n     x.clone(); // just to prevent liveness warnings"}, {"sha": "97193bd0191237ffe735c3f904257746f4f09abe", "filename": "src/test/compile-fail/borrowck/borrowck-union-borrow.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -25,82 +25,98 @@ fn main() {\n         {\n             let ra = &u.a;\n             let ra2 = &u.a; // OK\n+            drop(ra);\n         }\n         {\n             let ra = &u.a;\n             let a = u.a; // OK\n+            drop(ra);\n         }\n         {\n             let ra = &u.a;\n             let rma = &mut u.a; //[ast]~ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n                                 //[mir]~^ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n+            drop(ra);\n         }\n         {\n             let ra = &u.a;\n             u.a = 1; //[ast]~ ERROR cannot assign to `u.a` because it is borrowed\n                      //[mir]~^ ERROR cannot assign to `u.a` because it is borrowed\n+            drop(ra);\n         }\n         // Imm borrow, other field\n         {\n             let ra = &u.a;\n             let rb = &u.b; // OK\n+            drop(ra);\n         }\n         {\n             let ra = &u.a;\n             let b = u.b; // OK\n+            drop(ra);\n         }\n         {\n             let ra = &u.a;\n             let rmb = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n                                 //[mir]~^ ERROR cannot borrow `u.b` as mutable because it is also borrowed as immutable\n+            drop(ra);\n         }\n         {\n             let ra = &u.a;\n             u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n                      //[mir]~^ ERROR cannot assign to `u.b` because it is borrowed\n+            drop(ra);\n         }\n         // Mut borrow, same field\n         {\n             let rma = &mut u.a;\n             let ra = &u.a; //[ast]~ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n                          //[mir]~^ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n+            drop(rma);\n         }\n         {\n             let ra = &mut u.a;\n             let a = u.a; //[ast]~ ERROR cannot use `u.a` because it was mutably borrowed\n                          //[mir]~^ ERROR cannot use `u.a` because it was mutably borrowed\n+            drop(ra);\n         }\n         {\n             let rma = &mut u.a;\n             let rma2 = &mut u.a; //[ast]~ ERROR cannot borrow `u.a` as mutable more than once at a time\n                                  //[mir]~^ ERROR cannot borrow `u.a` as mutable more than once at a time\n+            drop(rma);\n         }\n         {\n             let rma = &mut u.a;\n             u.a = 1; //[ast]~ ERROR cannot assign to `u.a` because it is borrowed\n                      //[mir]~^ ERROR cannot assign to `u.a` because it is borrowed\n+            drop(rma);\n         }\n         // Mut borrow, other field\n         {\n             let rma = &mut u.a;\n             let rb = &u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n                            //[mir]~^ ERROR cannot borrow `u.b` as immutable because it is also borrowed as mutable\n+            drop(rma);\n         }\n         {\n             let ra = &mut u.a;\n             let b = u.b; //[ast]~ ERROR cannot use `u.b` because it was mutably borrowed\n                          //[mir]~^ ERROR cannot use `u.b` because it was mutably borrowed\n \n+            drop(ra);\n         }\n         {\n             let rma = &mut u.a;\n             let rmb2 = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable more than once at a time\n                                  //[mir]~^ ERROR cannot borrow `u.b` as mutable more than once at a time\n+            drop(rma);\n         }\n         {\n             let rma = &mut u.a;\n             u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n                      //[mir]~^ ERROR cannot assign to `u.b` because it is borrowed\n+            drop(rma);\n         }\n     }\n }"}, {"sha": "e03a0355b48d6ea60b7b7633e9f17e0ee70d5814", "filename": "src/test/compile-fail/borrowck/two-phase-across-loop.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-across-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-across-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-across-loop.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a borrow which starts as a 2-phase borrow and gets\n+// carried around a loop winds up conflicting with itself.\n+\n+#![feature(nll)]\n+\n+struct Foo { x: String }\n+\n+impl Foo {\n+    fn get_string(&mut self) -> &str {\n+        &self.x\n+    }\n+}\n+\n+fn main() {\n+    let mut foo = Foo { x: format!(\"Hello, world\") };\n+    let mut strings = vec![];\n+\n+    loop {\n+        strings.push(foo.get_string()); //~ ERROR cannot borrow `foo` as mutable\n+        if strings.len() > 2 { break; }\n+    }\n+\n+    println!(\"{:?}\", strings);\n+}"}, {"sha": "77b237e34f2b7d0bc7c3810d5b33b67a12d83304", "filename": "src/test/compile-fail/borrowck/two-phase-activation-sharing-interference.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -13,10 +13,9 @@\n // revisions: nll_target\n \n // The following revisions are disabled due to missing support from two-phase beyond autorefs\n-//[lxl_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref\n-//[nll_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref -Z nll\n+//[nll_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref\n \n-//[nll_target] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+//[nll_target] compile-flags: -Z borrowck=mir -Z two-phase-borrows\n \n // This is an important corner case pointed out by Niko: one is\n // allowed to initiate a shared borrow during a reservation, but it"}, {"sha": "5deabf9376482ccdcf5c1ece14710ae1c83f8f24", "filename": "src/test/compile-fail/borrowck/two-phase-allow-access-during-reservation.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-allow-access-during-reservation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-allow-access-during-reservation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-allow-access-during-reservation.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -13,11 +13,9 @@\n // revisions: nll_target\n \n // The following revisions are disabled due to missing support for two_phase_beyond_autoref\n-//[lxl_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two_phase_beyond_autoref\n-//[nll_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two_phase_beyond_autoref -Z nll\n+//[nll_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two_phase_beyond_autoref\n \n-\n-//[nll_target] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+//[nll_target] compile-flags: -Z borrowck=mir -Z two-phase-borrows\n \n // This is the second counter-example from Niko's blog post\n // smallcultfollowing.com/babysteps/blog/2017/03/01/nested-method-calls-via-two-phase-borrowing/\n@@ -44,9 +42,8 @@ fn main() {\n \n     /*3*/ *p += 1;        // (mutable borrow of `i` starts here, since `p` is used)\n \n-    /*4*/ let k = i;      //[lxl_beyond]~   ERROR cannot use `i` because it was mutably borrowed [E0503]\n-                          //[nll_beyond]~^  ERROR cannot use `i` because it was mutably borrowed [E0503]\n-                          //[nll_target]~^^ ERROR cannot use `i` because it was mutably borrowed [E0503]\n+    /*4*/ let k = i;      //[nll_beyond]~  ERROR cannot use `i` because it was mutably borrowed [E0503]\n+                          //[nll_target]~^ ERROR cannot use `i` because it was mutably borrowed [E0503]\n \n     /*5*/ *p += 1;\n "}, {"sha": "15700a1d61a1fa324780195ae44d4ae40fbe10aa", "filename": "src/test/compile-fail/borrowck/two-phase-cannot-nest-mut-self-calls.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-cannot-nest-mut-self-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-cannot-nest-mut-self-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-cannot-nest-mut-self-calls.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: lxl nll\n-//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n-//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+// compile-flags: -Z borrowck=mir -Z two-phase-borrows\n \n // This is the third counter-example from Niko's blog post\n // smallcultfollowing.com/babysteps/blog/2017/03/01/nested-method-calls-via-two-phase-borrowing/\n@@ -26,8 +24,7 @@ fn main() {\n     vec.get({\n \n         vec.push(2);\n-        //[lxl]~^ ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n-        //[nll]~^^   ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n+        //~^ ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n \n         0\n     });"}, {"sha": "4303048138d91c4bbdc49f6b01445e4097f01028", "filename": "src/test/compile-fail/borrowck/two-phase-nonrecv-autoref.rs", "status": "modified", "additions": 26, "deletions": 36, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: ast lxl nll\n+// revisions: ast nll\n //[ast]compile-flags:\n-//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n-//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n \n-//[g2p]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll -Z two-phase-beyond-autoref\n+//[g2p]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref\n // the above revision is disabled until two-phase-beyond-autoref support is better\n \n // This is a test checking that when we limit two-phase borrows to\n@@ -69,44 +68,38 @@ fn overloaded_call_traits() {\n \n     fn twice_ten_sm<F: FnMut(i32) -> i32>(f: &mut F) {\n         f(f(10));\n-        //[lxl]~^     ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[nll]~^^   ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[g2p]~^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[ast]~^^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[nll]~^   ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[g2p]~^^ ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[ast]~^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n     }\n     fn twice_ten_si<F: Fn(i32) -> i32>(f: &mut F) {\n         f(f(10));\n     }\n     fn twice_ten_so<F: FnOnce(i32) -> i32>(f: Box<F>) {\n         f(f(10));\n-        //[lxl]~^    ERROR use of moved value: `*f`\n-        //[nll]~^^   ERROR use of moved value: `*f`\n-        //[g2p]~^^^  ERROR use of moved value: `*f`\n-        //[ast]~^^^^ ERROR use of moved value: `*f`\n+        //[nll]~^   ERROR use of moved value: `*f`\n+        //[g2p]~^^  ERROR use of moved value: `*f`\n+        //[ast]~^^^ ERROR use of moved value: `*f`\n     }\n \n     fn twice_ten_om(f: &mut FnMut(i32) -> i32) {\n         f(f(10));\n-        //[lxl]~^    ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[nll]~^^   ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[g2p]~^^^  ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[ast]~^^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[nll]~^   ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[g2p]~^^  ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[ast]~^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n     }\n     fn twice_ten_oi(f: &mut Fn(i32) -> i32) {\n         f(f(10));\n     }\n     fn twice_ten_oo(f: Box<FnOnce(i32) -> i32>) {\n         f(f(10));\n-        //[lxl]~^             ERROR cannot move a value of type\n-        //[lxl]~^^            ERROR cannot move a value of type\n-        //[lxl]~^^^           ERROR use of moved value: `*f`\n-        //[nll]~^^^^          ERROR cannot move a value of type\n-        //[nll]~^^^^^         ERROR cannot move a value of type\n-        //[nll]~^^^^^^        ERROR use of moved value: `*f`\n-        //[g2p]~^^^^^^^       ERROR cannot move a value of type\n-        //[g2p]~^^^^^^^^      ERROR cannot move a value of type\n-        //[g2p]~^^^^^^^^^     ERROR use of moved value: `*f`\n-        //[ast]~^^^^^^^^^^    ERROR use of moved value: `*f`\n+        //[nll]~^          ERROR cannot move a value of type\n+        //[nll]~^^         ERROR cannot move a value of type\n+        //[nll]~^^^        ERROR use of moved value: `*f`\n+        //[g2p]~^^^^       ERROR cannot move a value of type\n+        //[g2p]~^^^^^      ERROR cannot move a value of type\n+        //[g2p]~^^^^^^     ERROR use of moved value: `*f`\n+        //[ast]~^^^^^^^    ERROR use of moved value: `*f`\n     }\n \n     twice_ten_sm(&mut |x| x + 1);\n@@ -144,10 +137,9 @@ fn coerce_unsized() {\n \n     // This is not okay.\n     double_access(&mut a, &a);\n-    //[lxl]~^    ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n-    //[nll]~^^   ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n-    //[g2p]~^^^  ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n-    //[ast]~^^^^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n+    //[nll]~^   ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n+    //[g2p]~^^  ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n+    //[ast]~^^^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n \n     // But this is okay.\n     a.m(a.i(10));\n@@ -173,16 +165,14 @@ impl IndexMut<i32> for I {\n fn coerce_index_op() {\n     let mut i = I(10);\n     i[i[3]] = 4;\n-    //[lxl]~^   ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n-    //[nll]~^^  ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n-    //[ast]~^^^ ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+    //[nll]~^  ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+    //[ast]~^^ ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n \n     i[3] = i[4];\n \n     i[i[3]] = i[4];\n-    //[lxl]~^   ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n-    //[nll]~^^  ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n-    //[ast]~^^^ ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+    //[nll]~^  ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+    //[ast]~^^ ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n }\n \n fn main() {"}, {"sha": "f9326d944b8e4220a82896ca77c0032215700ed4", "filename": "src/test/compile-fail/borrowck/two-phase-reservation-sharing-interference-2.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference-2.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: lxl nll\n-//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n-//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+// compile-flags: -Z borrowck=mir -Z two-phase-borrows\n \n // This is similar to two-phase-reservation-sharing-interference.rs\n // in that it shows a reservation that overlaps with a shared borrow.\n@@ -26,12 +24,11 @@\n #![feature(rustc_attrs)]\n \n #[rustc_error]\n-fn main() { //[nll]~ ERROR compilation successful\n+fn main() { //~ ERROR compilation successful\n     let mut v = vec![0, 1, 2];\n     let shared = &v;\n \n     v.push(shared.len());\n-    //[lxl]~^  ERROR cannot borrow `v` as mutable because it is also borrowed as immutable [E0502]\n \n     assert_eq!(v, [0, 1, 2, 3]);\n }"}, {"sha": "1333167b780a8537f714a571c602046dc4b29ebc", "filename": "src/test/compile-fail/borrowck/two-phase-reservation-sharing-interference.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -10,15 +10,13 @@\n \n // ignore-tidy-linelength\n \n-// revisions: lxl_beyond nll_beyond nll_target\n+// revisions: nll_beyond nll_target\n \n // The following revisions are disabled due to missing support from two-phase beyond autorefs\n-//[lxl_beyond]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref\n-//[lxl_beyond] should-fail\n-//[nll_beyond]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref -Z nll\n+//[nll_beyond]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref\n //[nll_beyond] should-fail\n \n-//[nll_target]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+//[nll_target]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n \n // This is a corner case that the current implementation is (probably)\n // treating more conservatively than is necessary. But it also does\n@@ -46,9 +44,8 @@ fn main() {\n         // with the shared borrow. But in the current implementation,\n         // its an error.\n         delay = &mut vec;\n-        //[lxl_beyond]~^   ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n-        //[nll_beyond]~^^  ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n-        //[nll_target]~^^^ ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n+        //[nll_beyond]~^  ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n+        //[nll_target]~^^ ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n \n         shared[0];\n     }"}, {"sha": "eec4b470d75f76d3da7418442533b80cc49e0b4f", "filename": "src/test/compile-fail/borrowck/two-phase-sneaky.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-sneaky.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-sneaky.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-sneaky.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: lxl nll\n-//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n-//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+// cmpile-flags: -Z borrowck=mir -Z two-phase-borrows\n \n // This is the first counter-example from Niko's blog post\n // smallcultfollowing.com/babysteps/blog/2017/03/01/nested-method-calls-via-two-phase-borrowing/\n@@ -22,8 +20,7 @@ fn main() {\n     v[0].push_str({\n \n         v.push(format!(\"foo\"));\n-        //[lxl]~^ ERROR cannot borrow `v` as mutable more than once at a time [E0499]\n-        //[nll]~^^   ERROR cannot borrow `v` as mutable more than once at a time [E0499]\n+        //~^   ERROR cannot borrow `v` as mutable more than once at a time [E0499]\n \n         \"World!\"\n     });"}, {"sha": "5a05f59c6f402303676de7494218b99a260c5aa0", "filename": "src/test/compile-fail/coerce-overloaded-autoderef.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fcoerce-overloaded-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fcoerce-overloaded-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-overloaded-autoderef.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -22,6 +22,7 @@ fn double_mut_borrow<T>(x: &mut Box<T>) {\n     let z = borrow_mut(x);\n     //[ast]~^ ERROR cannot borrow `*x` as mutable more than once at a time\n     //[mir]~^^ ERROR cannot borrow `*x` as mutable more than once at a time\n+    drop((y, z));\n }\n \n fn double_imm_borrow(x: &mut Box<i32>) {\n@@ -30,6 +31,7 @@ fn double_imm_borrow(x: &mut Box<i32>) {\n     **x += 1;\n     //[ast]~^ ERROR cannot assign to `**x` because it is borrowed\n     //[mir]~^^ ERROR cannot assign to `**x` because it is borrowed\n+    drop((y, z));\n }\n \n fn double_mut_borrow2<T>(x: &mut Box<T>) {"}, {"sha": "e98cf4eb2abd92f3e09021c1860ef100d40b096c", "filename": "src/test/compile-fail/hrtb-identity-fn-borrows.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fhrtb-identity-fn-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fhrtb-identity-fn-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhrtb-identity-fn-borrows.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -33,6 +33,7 @@ fn call_repeatedly<F>(f: F)\n     f.call(&x);\n     f.call(&x);\n     x = 5;\n+    drop(y);\n }\n \n fn main() {"}, {"sha": "ed6a2f85fbe23a8bb963bf61732b64239649e2d9", "filename": "src/test/compile-fail/issue-36082.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fissue-36082.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fissue-36082.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-36082.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -11,6 +11,8 @@\n // revisions: ast mir\n //[mir]compile-flags: -Z borrowck=mir\n \n+// FIXME(#49821) -- No tip about using a let binding\n+\n use std::cell::RefCell;\n \n fn main() {\n@@ -24,10 +26,9 @@ fn main() {\n     //[ast]~| NOTE temporary value does not live long enough\n     //[ast]~| NOTE consider using a `let` binding to increase its lifetime\n     //[mir]~^^^^^ ERROR borrowed value does not live long enough [E0597]\n-    //[mir]~| NOTE temporary value dropped here while still borrowed\n     //[mir]~| NOTE temporary value does not live long enough\n-    //[mir]~| NOTE consider using a `let` binding to increase its lifetime\n+    //[mir]~| NOTE temporary value only lives until here\n     println!(\"{}\", val);\n+    //[mir]~^ borrow later used here\n }\n //[ast]~^ NOTE temporary value needs to live until here\n-//[mir]~^^ NOTE temporary value needs to live until here"}, {"sha": "d8f5956b585303847cde55e450d7aa96b1835070", "filename": "src/test/compile-fail/mir_check_cast_closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_closure.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z borrowck=mir -Z nll\n+// compile-flags: -Z borrowck=mir\n \n #![allow(dead_code)]\n \n fn bar<'a, 'b>() -> fn(&'a u32, &'b u32) -> &'a u32 {\n     let g: fn(_, _) -> _ = |_x, y| y;\n     //~^ ERROR free region `'b` does not outlive free region `'a`\n     g\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n }\n \n fn main() {}"}, {"sha": "1f9174b3574a7bb57d0c5177eff5cc12067da4d7", "filename": "src/test/compile-fail/mir_check_cast_reify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_reify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_reify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_reify.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z borrowck=mir -Z nll\n+// compile-flags: -Zborrowck=mir\n \n #![allow(dead_code)]\n \n@@ -44,7 +44,7 @@ fn bar<'a>(x: &'a u32) -> &'static u32 {\n     // The MIR type checker must therefore relate `'?0` to `'?1` and `'?2`\n     // as part of checking the `ReifyFnPointer`.\n     let f: fn(_) -> _ = foo;\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| ERROR free region `'a` does not outlive free region `'static`\n     f(x)\n }"}, {"sha": "27ca2728ddfd623a5bb74f2b2710d3531206bba4", "filename": "src/test/compile-fail/mir_check_cast_unsafe_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsafe_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsafe_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsafe_fn.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z borrowck=mir -Z nll\n+// compile-flags: -Zborrowck=mir\n \n #![allow(dead_code)]\n \n fn bar<'a>(input: &'a u32, f: fn(&'a u32) -> &'a u32) -> &'static u32 {\n     // Here the NLL checker must relate the types in `f` to the types\n     // in `g`. These are related via the `UnsafeFnPointer` cast.\n     let g: unsafe fn(_) -> _ = f;\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| ERROR free region `'a` does not outlive free region `'static`\n     unsafe { g(input) }\n }"}, {"sha": "e30bed610581503d7bcb0910eb5d539d0e596488", "filename": "src/test/compile-fail/mir_check_cast_unsize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsize.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z borrowck=mir -Z nll\n+// compile-flags: -Z borrowck=mir\n \n #![allow(dead_code)]\n #![feature(dyn_trait)]\n@@ -18,7 +18,7 @@ use std::fmt::Debug;\n fn bar<'a>(x: &'a u32) -> &'static dyn Debug {\n     //~^ ERROR free region `'a` does not outlive free region `'static`\n     x\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n }\n \n fn main() {}"}, {"sha": "a05ee64937eb7ede999fa221e564dcb18ce8dd21", "filename": "src/test/compile-fail/mut-pattern-internal-mutability.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fmut-pattern-internal-mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fmut-pattern-internal-mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-pattern-internal-mutability.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -25,5 +25,6 @@ fn main() {\n     // check borrowing is detected successfully\n     let &mut ref x = foo;\n     *foo += 1; //[ast]~ ERROR cannot assign to `*foo` because it is borrowed\n-               //[mir]~^ ERROR cannot assign to `*foo` because it is borrowed\n+    //[mir]~^ ERROR cannot assign to `*foo` because it is borrowed\n+    drop(x);\n }"}, {"sha": "97126e98cbf3ad3ab09efb5401d057d15990ad68", "filename": "src/test/compile-fail/nll/loan_ends_mid_block_pair.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fnll%2Floan_ends_mid_block_pair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fnll%2Floan_ends_mid_block_pair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Floan_ends_mid_block_pair.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-// compile-flags:-Zborrowck=compare -Znll\n+// compile-flags:-Zborrowck=compare\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]"}, {"sha": "b5357d0ee827c100fbb1ebdaf9b2541036dad9a8", "filename": "src/test/compile-fail/nll/loan_ends_mid_block_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fnll%2Floan_ends_mid_block_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fnll%2Floan_ends_mid_block_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Floan_ends_mid_block_vec.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-// compile-flags:-Zborrowck=compare -Znll\n+// compile-flags:-Zborrowck=compare\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]"}, {"sha": "589a3daa38d853dc344b8bf2faa6602353ee9d33", "filename": "src/test/compile-fail/nll/reference-carried-through-struct-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fnll%2Freference-carried-through-struct-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fnll%2Freference-carried-through-struct-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Freference-carried-through-struct-field.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n //revisions: ast mir\n-//[mir] compile-flags: -Z borrowck=mir -Z nll\n+//[mir] compile-flags: -Z borrowck=mir\n \n #![allow(unused_assignments)]\n "}, {"sha": "e1c47a6bbff2cea9b0bf3f20c7a16a7a590ab692", "filename": "src/test/compile-fail/nll/region-ends-after-if-condition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fnll%2Fregion-ends-after-if-condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fnll%2Fregion-ends-after-if-condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Fregion-ends-after-if-condition.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -12,7 +12,7 @@\n // in the type of `p` includes the points after `&v[0]` up to (but not\n // including) the call to `use_x`. The `else` branch is not included.\n \n-// compile-flags:-Zborrowck=compare -Znll\n+// compile-flags:-Zborrowck=compare\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]"}, {"sha": "13f1ca6431b3d8e4adf793ec5310cd16c3494040", "filename": "src/test/compile-fail/nll/return_from_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fnll%2Freturn_from_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fnll%2Freturn_from_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Freturn_from_loop.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -12,7 +12,7 @@\n // in the type of `p` includes the points after `&v[0]` up to (but not\n // including) the call to `use_x`. The `else` branch is not included.\n \n-// compile-flags:-Zborrowck=compare -Znll\n+// compile-flags:-Zborrowck=compare\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]"}, {"sha": "1a3dc76005db4629f86595c575aef3e1e5641b04", "filename": "src/test/compile-fail/nll/where_clauses_in_functions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_functions.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z borrowck=mir -Z nll\n+// compile-flags: -Zborrowck=mir\n \n #![allow(dead_code)]\n \n@@ -22,7 +22,7 @@ where\n fn bar<'a, 'b>(x: &'a u32, y: &'b u32) -> (&'a u32, &'b u32) {\n     foo(x, y)\n     //~^ ERROR lifetime mismatch [E0623]\n-    //~| WARNING not reporting region error due to -Znll\n+    //~| WARNING not reporting region error due to nll\n }\n \n fn main() {}"}, {"sha": "69f0f43af13425af0d5942286d4cefc3d1806a51", "filename": "src/test/compile-fail/nll/where_clauses_in_structs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_structs.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z borrowck=mir -Z nll\n+// compile-flags: -Z borrowck=mir\n \n #![allow(dead_code)]\n \n@@ -22,7 +22,7 @@ struct Foo<'a: 'b, 'b> {\n fn bar<'a, 'b>(x: Cell<&'a u32>, y: Cell<&'b u32>) {\n     Foo { x, y };\n     //~^ ERROR lifetime mismatch [E0623]\n-    //~| WARNING not reporting region error due to -Znll\n+    //~| WARNING not reporting region error due to nll\n }\n \n fn main() {}"}, {"sha": "1f23dcbb72523baaeb6689d55fd7a144cfde4d58", "filename": "src/test/compile-fail/regions-pattern-typing-issue-19997.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19997.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19997.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19997.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -18,7 +18,8 @@ fn main() {\n     match (&a1,) {\n         (&ref b0,) => {\n             a1 = &f; //[ast]~ ERROR cannot assign\n-                     //[mir]~^ ERROR cannot assign to `a1` because it is borrowed\n+            //[mir]~^ ERROR cannot assign to `a1` because it is borrowed\n+            drop(b0);\n         }\n     }\n }"}, {"sha": "a0097b9f6d7df84ae0e3ce2e8e59cabc5bec13e0", "filename": "src/test/compile-fail/regions-static-bound.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -9,24 +9,24 @@\n // except according to those terms.\n \n // revisions: ll nll\n-//[nll] compile-flags: -Znll -Zborrowck=mir\n+//[nll] compile-flags:-Zborrowck=mir\n \n fn static_id<'a,'b>(t: &'a ()) -> &'static ()\n     where 'a: 'static { t }\n fn static_id_indirect<'a,'b>(t: &'a ()) -> &'static ()\n     where 'a: 'b, 'b: 'static { t }\n fn static_id_wrong_way<'a>(t: &'a ()) -> &'static () where 'static: 'a {\n     t //[ll]~ ERROR E0312\n-        //[nll]~^ WARNING not reporting region error due to -Znll\n+        //[nll]~^ WARNING not reporting region error due to nll\n         //[nll]~| ERROR free region `'a` does not outlive free region `'static`\n }\n \n fn error(u: &(), v: &()) {\n     static_id(&u); //[ll]~ ERROR explicit lifetime required in the type of `u` [E0621]\n-    //[nll]~^ WARNING not reporting region error due to -Znll\n+    //[nll]~^ WARNING not reporting region error due to nll\n     //[nll]~| ERROR explicit lifetime required in the type of `u` [E0621]\n     static_id_indirect(&v); //[ll]~ ERROR explicit lifetime required in the type of `v` [E0621]\n-    //[nll]~^ WARNING not reporting region error due to -Znll\n+    //[nll]~^ WARNING not reporting region error due to nll\n     //[nll]~| ERROR explicit lifetime required in the type of `v` [E0621]\n }\n "}, {"sha": "f41b39845a579681bf5811aa2e9fcebc4deac32b", "filename": "src/test/mir-opt/nll/liveness-call-subtlety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-call-subtlety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-call-subtlety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-call-subtlety.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:-Znll\n+// compile-flags:-Zborrowck=mir\n \n fn can_panic() -> Box<usize> {\n     Box::new(44)"}, {"sha": "073b44d6e338763ef9a8a5d63d289469b7012d8f", "filename": "src/test/mir-opt/nll/liveness-drop-intra-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-drop-intra-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-drop-intra-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-drop-intra-block.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:-Znll\n+// compile-flags:-Zborrowck=mir\n \n #![allow(warnings)]\n "}, {"sha": "6a8749084068a30fa6afcd518b5a2b0cb1f14a44", "filename": "src/test/mir-opt/nll/liveness-interblock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-interblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-interblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-interblock.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:-Znll\n+// compile-flags:-Zborrowck=mir\n \n fn cond() -> bool { false }\n "}, {"sha": "5cca3e55259d0f874ff7b81fdd0af9a401a64b69", "filename": "src/test/mir-opt/nll/named-lifetimes-basic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -13,8 +13,8 @@\n // suitable variables and that we setup the outlives relationship\n // between R0 and R1 properly.\n \n-// compile-flags:-Znll -Zverbose\n-//                     ^^^^^^^^^ force compiler to dump more region information\n+// compile-flags:-Zborrowck=mir -Zverbose\n+//                              ^^^^^^^^^ force compiler to dump more region information\n // ignore-tidy-linelength\n \n #![allow(warnings)]"}, {"sha": "b7c8d81b77fdbaf91b0caeefda1d9c578731ebcb", "filename": "src/test/mir-opt/nll/reborrow-basic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -12,8 +12,8 @@\n // in the type of `r_a` must outlive the region (`R7`) that appears in\n // the type of `r_b`\n \n-// compile-flags:-Znll -Zverbose\n-//                     ^^^^^^^^^ force compiler to dump more region information\n+// compile-flags:-Zborrowck=mir -Zverbose\n+//                              ^^^^^^^^^ force compiler to dump more region information\n \n #![allow(warnings)]\n "}, {"sha": "75d8a6a4f6ac55ca3b830ecf4a58b3e79a9bade7", "filename": "src/test/mir-opt/nll/region-liveness-basic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -12,8 +12,8 @@\n // in the type of `p` includes the points after `&v[0]` up to (but not\n // including) the call to `use_x`. The `else` branch is not included.\n \n-// compile-flags:-Znll -Zverbose\n-//                     ^^^^^^^^^ force compiler to dump more region information\n+// compile-flags:-Zborrowck=mir -Zverbose\n+//                              ^^^^^^^^^ force compiler to dump more region information\n \n #![allow(warnings)]\n "}, {"sha": "153739133ac82900258866451e2cdf16a1be753d", "filename": "src/test/mir-opt/nll/region-liveness-two-disjoint-uses.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -14,8 +14,8 @@\n // but only at a particular point, and hence they wind up including\n // distinct regions.\n \n-// compile-flags:-Znll -Zverbose\n-//                     ^^^^^^^^^ force compiler to dump more region information\n+// compile-flags:-Zborrowck=mir -Zverbose\n+//                              ^^^^^^^^^ force compiler to dump more region information\n \n #![allow(warnings)]\n "}, {"sha": "16952143d0a5bc6a294682f139da8c89adbf6795", "filename": "src/test/mir-opt/nll/region-subtyping-basic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -12,8 +12,8 @@\n // in the type of `p` includes the points after `&v[0]` up to (but not\n // including) the call to `use_x`. The `else` branch is not included.\n \n-// compile-flags:-Znll -Zverbose\n-//                     ^^^^^^^^^ force compiler to dump more region information\n+// compile-flags:-Zborrowck=mir -Zverbose\n+//                              ^^^^^^^^^ force compiler to dump more region information\n \n #![allow(warnings)]\n "}, {"sha": "ca15591a10192deee48078ca565dca0c2691d391", "filename": "src/test/run-pass/borrowck/two-phase-baseline.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Frun-pass%2Fborrowck%2Ftwo-phase-baseline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Frun-pass%2Fborrowck%2Ftwo-phase-baseline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck%2Ftwo-phase-baseline.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: lxl nll\n-//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n-//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+// compile-flags: -Z borrowck=mir -Z two-phase-borrows\n \n // This is the \"goto example\" for why we want two phase borrows.\n "}, {"sha": "e3b7322e48b6b93ac2b05050dc98417cdb818982", "filename": "src/test/run-pass/impl-trait/example-calendar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // revisions: normal nll\n-//[nll] compile-flags: -Znll -Zborrowck=mir\n+//[nll] compile-flags:-Zborrowck=mir\n \n #![feature(fn_traits,\n            step_trait,"}, {"sha": "55e73af9e6a1ba06f1a6616b76e5a46ad547d5ec", "filename": "src/test/ui/borrowck/borrowck-closures-two-mut.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -23,6 +23,7 @@ fn a() {\n     let c1 = to_fn_mut(|| x = 4);\n     let c2 = to_fn_mut(|| x = 5); //~ ERROR cannot borrow `x` as mutable more than once\n     //~| ERROR cannot borrow `x` as mutable more than once\n+    drop((c1, c2));\n }\n \n fn set(x: &mut isize) {\n@@ -34,13 +35,15 @@ fn b() {\n     let c1 = to_fn_mut(|| set(&mut x));\n     let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as mutable more than once\n     //~| ERROR cannot borrow `x` as mutable more than once\n+    drop((c1, c2));\n }\n \n fn c() {\n     let mut x = 3;\n     let c1 = to_fn_mut(|| x = 5);\n     let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as mutable more than once\n     //~| ERROR cannot borrow `x` as mutable more than once\n+    drop((c1, c2));\n }\n \n fn d() {\n@@ -49,6 +52,7 @@ fn d() {\n     let c2 = to_fn_mut(|| { let _y = to_fn_mut(|| set(&mut x)); }); // (nested closure)\n     //~^ ERROR cannot borrow `x` as mutable more than once\n     //~| ERROR cannot borrow `x` as mutable more than once\n+    drop((c1, c2));\n }\n \n fn g() {\n@@ -61,6 +65,7 @@ fn g() {\n     let c2 = to_fn_mut(|| set(&mut *x.f));\n     //~^ ERROR cannot borrow `x` as mutable more than once\n     //~| ERROR cannot borrow `x` as mutable more than once\n+    drop((c1, c2));\n }\n \n fn main() {"}, {"sha": "a4f8e8b408ba501b15e6783764e00a01b8e309f0", "filename": "src/test/ui/borrowck/borrowck-closures-two-mut.stderr", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -9,12 +9,12 @@ LL |     let c2 = to_fn_mut(|| x = 5); //~ ERROR cannot borrow `x` as mutable mo\n    |                        ^^ - borrow occurs due to use of `x` in closure\n    |                        |\n    |                        second mutable borrow occurs here\n-LL |     //~| ERROR cannot borrow `x` as mutable more than once\n+...\n LL | }\n    | - first borrow ends here\n \n error[E0499]: cannot borrow `x` as mutable more than once at a time (Ast)\n-  --> $DIR/borrowck-closures-two-mut.rs:35:24\n+  --> $DIR/borrowck-closures-two-mut.rs:36:24\n    |\n LL |     let c1 = to_fn_mut(|| set(&mut x));\n    |                        --          - previous borrow occurs due to use of `x` in closure\n@@ -24,12 +24,12 @@ LL |     let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as muta\n    |                        ^^          - borrow occurs due to use of `x` in closure\n    |                        |\n    |                        second mutable borrow occurs here\n-LL |     //~| ERROR cannot borrow `x` as mutable more than once\n+...\n LL | }\n    | - first borrow ends here\n \n error[E0499]: cannot borrow `x` as mutable more than once at a time (Ast)\n-  --> $DIR/borrowck-closures-two-mut.rs:42:24\n+  --> $DIR/borrowck-closures-two-mut.rs:44:24\n    |\n LL |     let c1 = to_fn_mut(|| x = 5);\n    |                        -- - previous borrow occurs due to use of `x` in closure\n@@ -39,12 +39,12 @@ LL |     let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as muta\n    |                        ^^          - borrow occurs due to use of `x` in closure\n    |                        |\n    |                        second mutable borrow occurs here\n-LL |     //~| ERROR cannot borrow `x` as mutable more than once\n+...\n LL | }\n    | - first borrow ends here\n \n error[E0499]: cannot borrow `x` as mutable more than once at a time (Ast)\n-  --> $DIR/borrowck-closures-two-mut.rs:49:24\n+  --> $DIR/borrowck-closures-two-mut.rs:52:24\n    |\n LL |     let c1 = to_fn_mut(|| x = 5);\n    |                        -- - previous borrow occurs due to use of `x` in closure\n@@ -59,7 +59,7 @@ LL | }\n    | - first borrow ends here\n \n error[E0499]: cannot borrow `x` as mutable more than once at a time (Ast)\n-  --> $DIR/borrowck-closures-two-mut.rs:61:24\n+  --> $DIR/borrowck-closures-two-mut.rs:65:24\n    |\n LL |     let c1 = to_fn_mut(|| set(&mut *x.f));\n    |                        --           - previous borrow occurs due to use of `x` in closure\n@@ -85,11 +85,11 @@ LL |     let c2 = to_fn_mut(|| x = 5); //~ ERROR cannot borrow `x` as mutable mo\n    |                        |\n    |                        second mutable borrow occurs here\n LL |     //~| ERROR cannot borrow `x` as mutable more than once\n-LL | }\n-   | - first borrow ends here\n+LL |     drop((c1, c2));\n+   |           -- borrow later used here\n \n error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n-  --> $DIR/borrowck-closures-two-mut.rs:35:24\n+  --> $DIR/borrowck-closures-two-mut.rs:36:24\n    |\n LL |     let c1 = to_fn_mut(|| set(&mut x));\n    |                        --          - previous borrow occurs due to use of `x` in closure\n@@ -100,11 +100,11 @@ LL |     let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as muta\n    |                        |\n    |                        second mutable borrow occurs here\n LL |     //~| ERROR cannot borrow `x` as mutable more than once\n-LL | }\n-   | - first borrow ends here\n+LL |     drop((c1, c2));\n+   |           -- borrow later used here\n \n error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n-  --> $DIR/borrowck-closures-two-mut.rs:42:24\n+  --> $DIR/borrowck-closures-two-mut.rs:44:24\n    |\n LL |     let c1 = to_fn_mut(|| x = 5);\n    |                        -- - previous borrow occurs due to use of `x` in closure\n@@ -115,11 +115,11 @@ LL |     let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as muta\n    |                        |\n    |                        second mutable borrow occurs here\n LL |     //~| ERROR cannot borrow `x` as mutable more than once\n-LL | }\n-   | - first borrow ends here\n+LL |     drop((c1, c2));\n+   |           -- borrow later used here\n \n error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n-  --> $DIR/borrowck-closures-two-mut.rs:49:24\n+  --> $DIR/borrowck-closures-two-mut.rs:52:24\n    |\n LL |     let c1 = to_fn_mut(|| x = 5);\n    |                        -- - previous borrow occurs due to use of `x` in closure\n@@ -130,11 +130,11 @@ LL |     let c2 = to_fn_mut(|| { let _y = to_fn_mut(|| set(&mut x)); }); // (nes\n    |                        |\n    |                        second mutable borrow occurs here\n ...\n-LL | }\n-   | - first borrow ends here\n+LL |     drop((c1, c2));\n+   |           -- borrow later used here\n \n error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n-  --> $DIR/borrowck-closures-two-mut.rs:61:24\n+  --> $DIR/borrowck-closures-two-mut.rs:65:24\n    |\n LL |     let c1 = to_fn_mut(|| set(&mut *x.f));\n    |                        --           - previous borrow occurs due to use of `x` in closure\n@@ -145,8 +145,8 @@ LL |     let c2 = to_fn_mut(|| set(&mut *x.f));\n    |                        |\n    |                        second mutable borrow occurs here\n ...\n-LL | }\n-   | - first borrow ends here\n+LL |     drop((c1, c2));\n+   |           -- borrow later used here\n \n error: aborting due to 10 previous errors\n "}, {"sha": "6d7ed61bdd8b550073f324894a7912a07c700e22", "filename": "src/test/ui/borrowck/two-phase-method-receivers.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-method-receivers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-method-receivers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-method-receivers.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: lxl nll\n-//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n-//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+// compile-flags: -Z borrowck=mir -Z two-phase-borrows\n \n // run-pass\n "}, {"sha": "9ea9696511b7194ba0e330dfc8e9e69137ad4535", "filename": "src/test/ui/borrowck/two-phase-multiple-activations.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-multiple-activations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-multiple-activations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-multiple-activations.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: lxl nll\n-//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n-//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+// compile-flags: -Z borrowck=mir -Z two-phase-borrows\n \n // run-pass\n "}, {"sha": "b8be209833a6e15a3c3f1dd5cda254080c6913e0", "filename": "src/test/ui/issue-45697-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fissue-45697-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fissue-45697-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-45697-1.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -30,6 +30,7 @@ fn main() {\n         *y.pointer += 1;\n         //~^ ERROR cannot assign to `*y.pointer` because it is borrowed (Ast) [E0506]\n         //~| ERROR cannot use `*y.pointer` because it was mutably borrowed (Mir) [E0503]\n+        //~| ERROR cannot assign to `*y.pointer` because it is borrowed (Mir) [E0506]\n         *z.pointer += 1;\n     }\n }"}, {"sha": "cf108691a0e4f65a2034c7ca927a1a79450e00b4", "filename": "src/test/ui/issue-45697-1.stderr", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fissue-45697-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fissue-45697-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-45697-1.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -13,8 +13,22 @@ LL |         let z = copy_borrowed_ptr(&mut y);\n    |                                   ------ borrow of `y` occurs here\n LL |         *y.pointer += 1;\n    |         ^^^^^^^^^^^^^^^ use of borrowed `y`\n+...\n+LL |         *z.pointer += 1;\n+   |         --------------- borrow later used here\n \n-error: aborting due to 2 previous errors\n+error[E0506]: cannot assign to `*y.pointer` because it is borrowed (Mir)\n+  --> $DIR/issue-45697-1.rs:30:9\n+   |\n+LL |         let z = copy_borrowed_ptr(&mut y);\n+   |                                   ------ borrow of `*y.pointer` occurs here\n+LL |         *y.pointer += 1;\n+   |         ^^^^^^^^^^^^^^^ assignment to borrowed `*y.pointer` occurs here\n+...\n+LL |         *z.pointer += 1;\n+   |         --------------- borrow later used here\n+\n+error: aborting due to 3 previous errors\n \n Some errors occurred: E0503, E0506.\n For more information about an error, try `rustc --explain E0503`."}, {"sha": "27acc2c89f75d435060f6baa2a32e40abe7b5744", "filename": "src/test/ui/issue-45697.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fissue-45697.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fissue-45697.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-45697.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -30,6 +30,7 @@ fn main() {\n         *y.pointer += 1;\n         //~^ ERROR cannot assign to `*y.pointer` because it is borrowed (Ast) [E0506]\n         //~| ERROR cannot use `*y.pointer` because it was mutably borrowed (Mir) [E0503]\n+        //~| ERROR cannot assign to `*y.pointer` because it is borrowed (Mir) [E0506]\n         *z.pointer += 1;\n     }\n }"}, {"sha": "a85972fcd7a1c05b6e24577a7352cf3ba92a7ca4", "filename": "src/test/ui/issue-45697.stderr", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fissue-45697.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fissue-45697.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-45697.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -13,8 +13,22 @@ LL |         let z = copy_borrowed_ptr(&mut y);\n    |                                   ------ borrow of `y` occurs here\n LL |         *y.pointer += 1;\n    |         ^^^^^^^^^^^^^^^ use of borrowed `y`\n+...\n+LL |         *z.pointer += 1;\n+   |         --------------- borrow later used here\n \n-error: aborting due to 2 previous errors\n+error[E0506]: cannot assign to `*y.pointer` because it is borrowed (Mir)\n+  --> $DIR/issue-45697.rs:30:9\n+   |\n+LL |         let z = copy_borrowed_ptr(&mut y);\n+   |                                   ------ borrow of `*y.pointer` occurs here\n+LL |         *y.pointer += 1;\n+   |         ^^^^^^^^^^^^^^^ assignment to borrowed `*y.pointer` occurs here\n+...\n+LL |         *z.pointer += 1;\n+   |         --------------- borrow later used here\n+\n+error: aborting due to 3 previous errors\n \n Some errors occurred: E0503, E0506.\n For more information about an error, try `rustc --explain E0503`."}, {"sha": "0108056bc7278265ae61aba0d7c536908bfcd6d8", "filename": "src/test/ui/issue-46471-1.stderr", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fissue-46471-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fissue-46471-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-46471-1.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -12,13 +12,16 @@ LL | }\n error[E0597]: `z` does not live long enough (Mir)\n   --> $DIR/issue-46471-1.rs:16:9\n    |\n-LL |         &mut z\n-   |         ^^^^^^ borrowed value does not live long enough\n-LL |     };\n-   |     - `z` dropped here while still borrowed\n-...\n-LL | }\n-   | - borrowed value needs to live until here\n+LL |       let y = {\n+   |  _____________-\n+LL | |         let mut z = 0;\n+LL | |         &mut z\n+   | |         ^^^^^^ borrowed value does not live long enough\n+LL | |     };\n+   | |     -\n+   | |     |\n+   | |_____borrowed value only lives until here\n+   |       borrow later used here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "1e168028c7c9a9c48f2be595d7eb6026ae445ccf", "filename": "src/test/ui/nll/closure-requirements/escape-argument-callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -22,7 +22,7 @@\n // that appear free in its type (hence, we see it before the closure's\n // \"external requirements\" report).\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![feature(rustc_attrs)]\n \n@@ -35,7 +35,7 @@ fn test() {\n         let y = 22;\n         let mut closure = expect_sig(|p, y| *p = y);\n         //~^ ERROR does not outlive free region\n-        //~| WARNING not reporting region error due to -Znll\n+        //~| WARNING not reporting region error due to nll\n         closure(&mut p, &y);\n     }\n "}, {"sha": "d876c751a41d2aa13e1f7c5475cacc320a39496e", "filename": "src/test/ui/nll/closure-requirements/escape-argument-callee.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,4 +1,4 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/escape-argument-callee.rs:36:50\n    |\n LL |         let mut closure = expect_sig(|p, y| *p = y);"}, {"sha": "7a28cb26f3570620998ebdff319b76249e677ac9", "filename": "src/test/ui/nll/closure-requirements/escape-argument.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -22,7 +22,7 @@\n // basically checking that the MIR type checker correctly enforces the\n // closure signature.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![feature(rustc_attrs)]\n "}, {"sha": "598839f872e01805bc1d896c3f6755754cdc8500", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -15,7 +15,7 @@\n //\n // except that the closure does so via a second closure.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![feature(rustc_attrs)]\n "}, {"sha": "49d31bbc139d73f0b88aca1551900018681a7e6c", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -19,7 +19,7 @@\n // `'b`.  This relationship is propagated to the closure creator,\n // which reports an error.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![feature(rustc_attrs)]\n "}, {"sha": "e7ec0b9684d2c980d785f8b7a6093e6e521a6ae0", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -11,7 +11,7 @@\n // Test where we fail to approximate due to demanding a postdom\n // relationship between our upper bounds.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![feature(rustc_attrs)]\n \n@@ -53,7 +53,7 @@ fn supply<'a, 'b, 'c>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>, cell_c: Cell\n         |_outlives1, _outlives2, _outlives3, x, y| {\n             // Only works if 'x: 'y:\n             let p = x.get();\n-            //~^ WARN not reporting region error due to -Znll\n+            //~^ WARN not reporting region error due to nll\n             //~| ERROR does not outlive free region\n             demand_y(x, y, p)\n         },"}, {"sha": "ef5a31e40d445afa5c9c55a615607f66fbf8c075", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,4 +1,4 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/propagate-approximated-fail-no-postdom.rs:55:21\n    |\n LL |             let p = x.get();\n@@ -16,7 +16,7 @@ note: No external requirements\n LL | /         |_outlives1, _outlives2, _outlives3, x, y| {\n LL | |             // Only works if 'x: 'y:\n LL | |             let p = x.get();\n-LL | |             //~^ WARN not reporting region error due to -Znll\n+LL | |             //~^ WARN not reporting region error due to nll\n LL | |             //~| ERROR does not outlive free region\n LL | |             demand_y(x, y, p)\n LL | |         },"}, {"sha": "da8ce55162f37e706ce35dbfb4cf9f4386449389", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -22,7 +22,7 @@\n // Note: the use of `Cell` here is to introduce invariance. One less\n // variable.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![feature(rustc_attrs)]\n \n@@ -54,7 +54,7 @@ fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n         //~^ ERROR lifetime mismatch\n \n         // Only works if 'x: 'y:\n-        demand_y(x, y, x.get()) //~ WARNING not reporting region error due to -Znll\n+        demand_y(x, y, x.get()) //~ WARNING not reporting region error due to nll\n     });\n }\n "}, {"sha": "3a3236fd16c49e03b90e7edb007867ec646b131b", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-ref.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,7 +1,7 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/propagate-approximated-ref.rs:57:9\n    |\n-LL |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to -Znll\n+LL |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to nll\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n note: External requirements\n@@ -12,7 +12,7 @@ LL |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x,\n LL | |         //~^ ERROR lifetime mismatch\n LL | |\n LL | |         // Only works if 'x: 'y:\n-LL | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to -Znll\n+LL | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to nll\n LL | |     });\n    | |_____^\n    |"}, {"sha": "84bfd6ea4f25324cb479b77ce5b01ce333e0468a", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -12,7 +12,7 @@\n // where `'x` is bound in closure type but `'a` is free. This forces\n // us to approximate `'x` one way or the other.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![feature(rustc_attrs)]\n \n@@ -29,7 +29,7 @@ fn case1() {\n     let a = 0;\n     let cell = Cell::new(&a);\n     foo(cell, |cell_a, cell_x| {\n-        //~^ WARNING not reporting region error due to -Znll\n+        //~^ WARNING not reporting region error due to nll\n         cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n         //~^ ERROR does not outlive free region\n     })"}, {"sha": "6480cbe44312785885070fecd8df69f1e508e829", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,4 +1,4 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:31:5\n    |\n LL |     foo(cell, |cell_a, cell_x| {\n@@ -15,7 +15,7 @@ note: No external requirements\n    |\n LL |       foo(cell, |cell_a, cell_x| {\n    |  _______________^\n-LL | |         //~^ WARNING not reporting region error due to -Znll\n+LL | |         //~^ WARNING not reporting region error due to nll\n LL | |         cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n LL | |         //~^ ERROR does not outlive free region\n LL | |     })"}, {"sha": "df715c52921a0de5033f0303daa4bb37b1dc33d6", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-no-bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -16,7 +16,7 @@\n // FIXME(#45827) Because of shortcomings in the MIR type checker,\n // these errors are not (yet) reported.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![feature(rustc_attrs)]\n \n@@ -46,7 +46,7 @@ fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n         //~^ ERROR does not outlive free region\n \n         // Only works if 'x: 'y:\n-        demand_y(x, y, x.get()) //~ WARNING not reporting region error due to -Znll\n+        demand_y(x, y, x.get()) //~ WARNING not reporting region error due to nll\n     });\n }\n "}, {"sha": "6dcc8421177d9cf37cd3b06b2ecc02e984597379", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-no-bound.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,7 +1,7 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:49:9\n    |\n-LL |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to -Znll\n+LL |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to nll\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n note: External requirements\n@@ -12,7 +12,7 @@ LL |       establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n LL | |         //~^ ERROR does not outlive free region\n LL | |\n LL | |         // Only works if 'x: 'y:\n-LL | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to -Znll\n+LL | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to nll\n LL | |     });\n    | |_____^\n    |\n@@ -31,7 +31,7 @@ LL |       establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n LL | |         //~^ ERROR does not outlive free region\n LL | |\n LL | |         // Only works if 'x: 'y:\n-LL | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to -Znll\n+LL | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to nll\n LL | |     });\n    | |_____^\n "}, {"sha": "fdbb312572f894dd3085ffe80490844f864b868e", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-wrong-bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -17,7 +17,7 @@\n // FIXME(#45827) Because of shortcomings in the MIR type checker,\n // these errors are not (yet) reported.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![feature(rustc_attrs)]\n \n@@ -49,7 +49,7 @@ fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n         //~^ ERROR does not outlive free region\n         // Only works if 'x: 'y:\n         demand_y(x, y, x.get())\n-        //~^ WARNING not reporting region error due to -Znll\n+        //~^ WARNING not reporting region error due to nll\n     });\n }\n "}, {"sha": "1291f2e9901b0e75880cc4245891dd2c5f8e2332", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-wrong-bound.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,4 +1,4 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:51:9\n    |\n LL |         demand_y(x, y, x.get())\n@@ -12,7 +12,7 @@ LL |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x,\n LL | |         //~^ ERROR does not outlive free region\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(x, y, x.get())\n-LL | |         //~^ WARNING not reporting region error due to -Znll\n+LL | |         //~^ WARNING not reporting region error due to nll\n LL | |     });\n    | |_____^\n    |\n@@ -31,7 +31,7 @@ LL |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x,\n LL | |         //~^ ERROR does not outlive free region\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(x, y, x.get())\n-LL | |         //~^ WARNING not reporting region error due to -Znll\n+LL | |         //~^ WARNING not reporting region error due to nll\n LL | |     });\n    | |_____^\n "}, {"sha": "0449dc1d1a75c2846134f95c52c21993c79f43c1", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-val.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -15,7 +15,7 @@\n // relationships. In the 'main' variant, there are a number of\n // anonymous regions as well.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![feature(rustc_attrs)]\n \n@@ -47,7 +47,7 @@ fn test<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n         //~^ ERROR lifetime mismatch\n \n         // Only works if 'x: 'y:\n-        demand_y(outlives1, outlives2, x.get()) //~ WARNING not reporting region error due to -Znll\n+        demand_y(outlives1, outlives2, x.get()) //~ WARNING not reporting region error due to nll\n     });\n }\n "}, {"sha": "d1824a941510266033b5750f0fe6f39f4b7cfbdc", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-val.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,7 +1,7 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/propagate-approximated-val.rs:50:9\n    |\n-LL |         demand_y(outlives1, outlives2, x.get()) //~ WARNING not reporting region error due to -Znll\n+LL |         demand_y(outlives1, outlives2, x.get()) //~ WARNING not reporting region error due to nll\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n note: External requirements\n@@ -12,7 +12,7 @@ LL |       establish_relationships(cell_a, cell_b, |outlives1, outlives2, x, y|\n LL | |         //~^ ERROR lifetime mismatch\n LL | |\n LL | |         // Only works if 'x: 'y:\n-LL | |         demand_y(outlives1, outlives2, x.get()) //~ WARNING not reporting region error due to -Znll\n+LL | |         demand_y(outlives1, outlives2, x.get()) //~ WARNING not reporting region error due to nll\n LL | |     });\n    | |_____^\n    |"}, {"sha": "c21c824b22c3bb093bf74f2c5fda51bcd94cfc73", "filename": "src/test/ui/nll/closure-requirements/propagate-despite-same-free-region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -13,7 +13,7 @@\n // need to propagate; but in fact we do because identity of free\n // regions is erased.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n // compile-pass\n \n #![feature(rustc_attrs)]"}, {"sha": "d6eeda881daf26b91920981ded1076cda25aadd9", "filename": "src/test/ui/nll/closure-requirements/propagate-despite-same-free-region.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,4 +1,4 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/propagate-despite-same-free-region.rs:54:21\n    |\n LL |             let p = x.get();"}, {"sha": "7699d101734958122ee2eca1d296521de81ddeae", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-no-bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -17,7 +17,7 @@\n // as it knows of no relationships between `'x` and any\n // non-higher-ranked regions.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![feature(rustc_attrs)]\n \n@@ -45,7 +45,7 @@ fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n         // Only works if 'x: 'y:\n         demand_y(x, y, x.get())\n-        //~^ WARN not reporting region error due to -Znll\n+        //~^ WARN not reporting region error due to nll\n         //~| ERROR does not outlive free region\n     });\n }"}, {"sha": "ffae47bd081c33119a0ab55ab012ab22e6c2f188", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-no-bounds.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,4 +1,4 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:47:9\n    |\n LL |         demand_y(x, y, x.get())\n@@ -17,7 +17,7 @@ LL |       establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n    |  _______________________________________________^\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(x, y, x.get())\n-LL | |         //~^ WARN not reporting region error due to -Znll\n+LL | |         //~^ WARN not reporting region error due to nll\n LL | |         //~| ERROR does not outlive free region\n LL | |     });\n    | |_____^"}, {"sha": "afb61b221be942394a2e011734a7a0ae1fda1bda", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-wrong-bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -17,7 +17,7 @@\n // as it only knows of regions that `'x` is outlived by, and none that\n // `'x` outlives.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![feature(rustc_attrs)]\n \n@@ -49,7 +49,7 @@ fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n         // Only works if 'x: 'y:\n         demand_y(x, y, x.get())\n-        //~^ WARN not reporting region error due to -Znll\n+        //~^ WARN not reporting region error due to nll\n         //~| ERROR does not outlive free region\n     });\n }"}, {"sha": "01af756b8332c639632b9047d6083bcc0162e3e3", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-wrong-bounds.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,4 +1,4 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:51:9\n    |\n LL |         demand_y(x, y, x.get())\n@@ -17,7 +17,7 @@ LL |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x,\n    |  _______________________________________________^\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(x, y, x.get())\n-LL | |         //~^ WARN not reporting region error due to -Znll\n+LL | |         //~^ WARN not reporting region error due to nll\n LL | |         //~| ERROR does not outlive free region\n LL | |     });\n    | |_____^"}, {"sha": "7baf24f88f8fa419b35643e9304b973decd1039e", "filename": "src/test/ui/nll/closure-requirements/propagate-from-trait-match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -14,7 +14,7 @@\n // the same `'a` for which it implements `Trait`, which can only be the `'a`\n // from the function definition.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![feature(rustc_attrs)]\n #![allow(dead_code)]\n@@ -53,7 +53,7 @@ where\n         // The latter does not hold.\n \n         require(value);\n-        //~^ WARNING not reporting region error due to -Znll\n+        //~^ WARNING not reporting region error due to nll\n     });\n }\n "}, {"sha": "a8b4ed528015fbf3c9e26a92ce0c6429d51cfd8d", "filename": "src/test/ui/nll/closure-requirements/propagate-from-trait-match.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,4 +1,4 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/propagate-from-trait-match.rs:55:9\n    |\n LL |         require(value);\n@@ -13,7 +13,7 @@ LL | |         //~^ ERROR the parameter type `T` may not live long enough\n LL | |\n LL | |         // This function call requires that\n ...  |\n-LL | |         //~^ WARNING not reporting region error due to -Znll\n+LL | |         //~^ WARNING not reporting region error due to nll\n LL | |     });\n    | |_____^\n    |\n@@ -35,7 +35,7 @@ LL | |         //~^ ERROR the parameter type `T` may not live long enough\n LL | |\n LL | |         // This function call requires that\n ...  |\n-LL | |         //~^ WARNING not reporting region error due to -Znll\n+LL | |         //~^ WARNING not reporting region error due to nll\n LL | |     });\n    | |_____^\n    |"}, {"sha": "a6b2e531ac28fcf9cb0e4d75a41cef1d921aafa5", "filename": "src/test/ui/nll/closure-requirements/region-lbr-anon-does-not-outlive-static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-anon-does-not-outlive-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-anon-does-not-outlive-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-anon-does-not-outlive-static.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -13,11 +13,11 @@\n // a variety of errors from the older, AST-based machinery (notably\n // borrowck), and then we get the NLL error at the end.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n fn foo(x: &u32) -> &'static u32 {\n     &*x\n-        //~^ WARN not reporting region error due to -Znll\n+        //~^ WARN not reporting region error due to nll\n         //~| ERROR explicit lifetime required in the type of `x`\n }\n "}, {"sha": "a823e62d3b843f76b5184a2eeb305dfd46664a7a", "filename": "src/test/ui/nll/closure-requirements/region-lbr-anon-does-not-outlive-static.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-anon-does-not-outlive-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-anon-does-not-outlive-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-anon-does-not-outlive-static.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,4 +1,4 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/region-lbr-anon-does-not-outlive-static.rs:19:5\n    |\n LL |     &*x"}, {"sha": "dedbd8df41b130ca8d771fcd71418e092cffa38e", "filename": "src/test/ui/nll/closure-requirements/region-lbr-named-does-not-outlive-static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -13,11 +13,11 @@\n // a variety of errors from the older, AST-based machinery (notably\n // borrowck), and then we get the NLL error at the end.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n fn foo<'a>(x: &'a u32) -> &'static u32 {\n     &*x\n-        //~^ WARN not reporting region error due to -Znll\n+        //~^ WARN not reporting region error due to nll\n         //~| ERROR does not outlive free region\n }\n "}, {"sha": "9520b446303c3fc8c06cef12e97ebb099734f082", "filename": "src/test/ui/nll/closure-requirements/region-lbr-named-does-not-outlive-static.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,4 +1,4 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/region-lbr-named-does-not-outlive-static.rs:19:5\n    |\n LL |     &*x"}, {"sha": "8598668bef50ea59002d5466e6d895976a97d7bc", "filename": "src/test/ui/nll/closure-requirements/region-lbr1-does-not-outlive-ebr2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-not-outlive-ebr2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-not-outlive-ebr2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-not-outlive-ebr2.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -13,11 +13,11 @@\n // a variety of errors from the older, AST-based machinery (notably\n // borrowck), and then we get the NLL error at the end.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> &'b u32 {\n     &*x\n-        //~^ WARN not reporting region error due to -Znll\n+        //~^ WARN not reporting region error due to nll\n         //~| ERROR lifetime mismatch\n }\n "}, {"sha": "415aefdeee947a97b91f71c667aa57cc82a78f64", "filename": "src/test/ui/nll/closure-requirements/region-lbr1-does-not-outlive-ebr2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-not-outlive-ebr2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-not-outlive-ebr2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-not-outlive-ebr2.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,4 +1,4 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/region-lbr1-does-not-outlive-ebr2.rs:19:5\n    |\n LL |     &*x"}, {"sha": "6d2bb30980236dd42a6655a3bfdbede99de99f4b", "filename": "src/test/ui/nll/closure-requirements/region-lbr1-does-outlive-lbr2-because-implied-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-outlive-lbr2-because-implied-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-outlive-lbr2-because-implied-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr1-does-outlive-lbr2-because-implied-bound.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -11,7 +11,7 @@\n // Basic test for free regions in the NLL code. This test does not\n // report an error because of the (implied) bound that `'b: 'a`.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n // compile-pass\n \n #![allow(warnings)]"}, {"sha": "60f82ca0eefb9a9a5add36cfb845cdb9739a6bd5", "filename": "src/test/ui/nll/closure-requirements/return-wrong-bound-region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -12,14 +12,14 @@\n // the first, but actually returns the second. This should fail within\n // the closure.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![feature(rustc_attrs)]\n \n #[rustc_regions]\n fn test() {\n     expect_sig(|a, b| b); // ought to return `a`\n-    //~^ WARN not reporting region error due to -Znll\n+    //~^ WARN not reporting region error due to nll\n     //~| ERROR does not outlive free region\n }\n "}, {"sha": "4d021fb545494c9a6ccb7798d7b8a64cab817fcd", "filename": "src/test/ui/nll/closure-requirements/return-wrong-bound-region.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,4 +1,4 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/return-wrong-bound-region.rs:21:23\n    |\n LL |     expect_sig(|a, b| b); // ought to return `a`\n@@ -26,7 +26,7 @@ note: No external requirements\n    |\n LL | / fn test() {\n LL | |     expect_sig(|a, b| b); // ought to return `a`\n-LL | |     //~^ WARN not reporting region error due to -Znll\n+LL | |     //~^ WARN not reporting region error due to nll\n LL | |     //~| ERROR does not outlive free region\n LL | | }\n    | |_^"}, {"sha": "10ce0652d43c2f6df54b6b698ff4220d7c9c74ca", "filename": "src/test/ui/nll/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fconstant.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -11,7 +11,7 @@\n // Test that MIR borrowck and NLL analysis can handle constants of\n // arbitrary types without ICEs.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n // compile-pass\n \n const HI: &str = \"hi\";"}, {"sha": "b357b3facf9bb4ab46070d7751cbad28cb58f517", "filename": "src/test/ui/nll/drop-may-dangle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fdrop-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fdrop-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fdrop-may-dangle.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -12,7 +12,7 @@\n // in the type of `p` includes the points after `&v[0]` up to (but not\n // including) the call to `use_x`. The `else` branch is not included.\n \n-// compile-flags:-Znll -Zborrowck=mir\n+// compile-flags:-Zborrowck=mir\n // compile-pass\n \n #![allow(warnings)]"}, {"sha": "513609316311a3e567bd1e7e7b86c36638b5e1bd", "filename": "src/test/ui/nll/drop-no-may-dangle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fdrop-no-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fdrop-no-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fdrop-no-may-dangle.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -13,7 +13,7 @@\n // because of destructor. (Note that the stderr also identifies this\n // destructor in the error message.)\n \n-// compile-flags:-Znll -Zborrowck=mir\n+// compile-flags:-Zborrowck=mir\n \n #![allow(warnings)]\n #![feature(dropck_eyepatch)]"}, {"sha": "728c84695eacf0e3117e8246a75ebb12b18a2c19", "filename": "src/test/ui/nll/get_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fget_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fget_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -13,7 +13,7 @@\n // a variety of errors from the older, AST-based machinery (notably\n // borrowck), and then we get the NLL error at the end.\n \n-// compile-flags:-Znll -Zborrowck=compare\n+// compile-flags:-Zborrowck=compare\n \n struct Map {\n }"}, {"sha": "5538eca362974acc261c0e35fee9d53e8a0297ce", "filename": "src/test/ui/nll/maybe-initialized-drop-implicit-fragment-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//compile-flags: -Z emit-end-regions -Zborrowck=mir -Znll\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir\n \n \n #![allow(warnings)]"}, {"sha": "ae815a5efe97c7f528ed287d9255156aabc68baf", "filename": "src/test/ui/nll/maybe-initialized-drop-uninitialized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//compile-flags: -Z emit-end-regions -Zborrowck=mir -Z nll\n+// compile-flags: -Z emit-end-regions -Zborrowck=mir\n // compile-pass\n \n #![allow(warnings)]"}, {"sha": "00d146e0f02d6b672099fe1a164e6a378d140586", "filename": "src/test/ui/nll/maybe-initialized-drop-with-fragment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//compile-flags: -Z emit-end-regions -Zborrowck=mir -Znll\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir\n \n #![allow(warnings)]\n "}, {"sha": "cd46014a7f5ca45dfbd2c1ee533f41c9c43ac9ef", "filename": "src/test/ui/nll/maybe-initialized-drop-with-uninitialized-fragments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//compile-flags: -Z emit-end-regions -Zborrowck=mir -Znll\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir\n \n #![allow(warnings)]\n "}, {"sha": "9a3aca346208d72d4b330b4f40f6b51c60abca63", "filename": "src/test/ui/nll/maybe-initialized-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//compile-flags: -Z emit-end-regions -Zborrowck=mir -Znll\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir\n \n #![allow(warnings)]\n "}, {"sha": "c1abcb434e68f8486cfdcd8742316265ec94266c", "filename": "src/test/ui/nll/projection-return.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fprojection-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fprojection-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fprojection-return.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:-Znll -Zborrowck=mir\n+// compile-flags:-Zborrowck=mir\n // compile-pass\n \n #![feature(rustc_attrs)]"}, {"sha": "f21127064d4c2ee1880b2e22300242ea85d55fa8", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![allow(warnings)]\n \n@@ -19,7 +19,7 @@ impl<'a, T> Foo<'a> for T { }\n \n fn foo<'a, T>(x: &T) -> impl Foo<'a> {\n     x\n-        //~^ WARNING not reporting region error due to -Znll\n+        //~^ WARNING not reporting region error due to nll\n         //~| ERROR explicit lifetime required in the type of `x` [E0621]\n }\n "}, {"sha": "f836960a28cf372d4b492945dd41ab6fcdb1deb7", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,4 +1,4 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/impl-trait-captures.rs:21:5\n    |\n LL |     x"}, {"sha": "182e11da082f8d367afccd1b33a8e7784caf196a", "filename": "src/test/ui/nll/ty-outlives/impl-trait-outlives.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![allow(warnings)]\n \n use std::fmt::Debug;\n \n fn no_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n where\n     T: Debug,\n {\n@@ -31,7 +31,7 @@ where\n }\n \n fn wrong_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n where\n     T: 'b + Debug,\n {"}, {"sha": "50b80282e6241daae24f6a5e1093ab0344359f4f", "filename": "src/test/ui/nll/ty-outlives/impl-trait-outlives.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,10 +1,10 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/impl-trait-outlives.rs:17:35\n    |\n LL | fn no_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n    |                                   ^^^^^^^^^^^^^^^\n \n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/impl-trait-outlives.rs:33:42\n    |\n LL | fn wrong_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a"}, {"sha": "d8f077467d9fcfca2bb4f030aa91974c7a8ec8df", "filename": "src/test/ui/nll/ty-outlives/projection-implied-bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n // Test that we can deduce when projections like `T::Item` outlive the\n // function body. Test that this does not imply that `T: 'a` holds.\n@@ -43,7 +43,7 @@ where\n #[rustc_errors]\n fn generic2<T: Iterator>(value: T) {\n     twice(value, |value_ref, item| invoke2(value_ref, item));\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| ERROR the parameter type `T` may not live long enough\n }\n "}, {"sha": "0a2bd3247655ae019783391c7b618567e64ffd21", "filename": "src/test/ui/nll/ty-outlives/projection-implied-bounds.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-implied-bounds.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,4 +1,4 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/projection-implied-bounds.rs:45:36\n    |\n LL |     twice(value, |value_ref, item| invoke2(value_ref, item));"}, {"sha": "7b3ed6a94fcbb642951a69d156517a304f03c3fd", "filename": "src/test/ui/nll/ty-outlives/projection-no-regions-closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n // Tests closures that propagate an outlives relationship to their\n // creator where the subject is a projection with no regions (`<T as\n@@ -34,7 +34,7 @@ where\n     T: Iterator,\n {\n     with_signature(x, |mut y| Box::new(y.next()))\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| ERROR the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n }\n \n@@ -52,7 +52,7 @@ where\n     T: 'b + Iterator,\n {\n     with_signature(x, |mut y| Box::new(y.next()))\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| ERROR the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n }\n "}, {"sha": "0efbbdff12a3f25627b881adbf3d6f67d8821da6", "filename": "src/test/ui/nll/ty-outlives/projection-no-regions-closure.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,10 +1,10 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/projection-no-regions-closure.rs:36:31\n    |\n LL |     with_signature(x, |mut y| Box::new(y.next()))\n    |                               ^^^^^^^^^^^^^^^^^^\n \n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/projection-no-regions-closure.rs:54:31\n    |\n LL |     with_signature(x, |mut y| Box::new(y.next()))"}, {"sha": "32b73a51e11a527c198893dd30b74ad114270e53", "filename": "src/test/ui/nll/ty-outlives/projection-no-regions-fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![allow(warnings)]\n #![feature(dyn_trait)]\n@@ -22,7 +22,7 @@ where\n     T: Iterator,\n {\n     Box::new(x.next())\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n }\n \n@@ -38,7 +38,7 @@ where\n     T: 'b + Iterator,\n {\n     Box::new(x.next())\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n }\n "}, {"sha": "b2c5f28268db893382fbc78a9741a9cfe5e8c15e", "filename": "src/test/ui/nll/ty-outlives/projection-no-regions-fn.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,10 +1,10 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/projection-no-regions-fn.rs:24:5\n    |\n LL |     Box::new(x.next())\n    |     ^^^^^^^^^^^^^^^^^^\n \n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/projection-no-regions-fn.rs:40:5\n    |\n LL |     Box::new(x.next())"}, {"sha": "cfe2880bfed476795ff5c84470c3f70444de5362", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -22,7 +22,7 @@\n //\n // Ensuring that both `T: 'a` and `'b: 'a` holds does work (`elements_outlive`).\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![allow(warnings)]\n #![feature(dyn_trait)]\n@@ -54,7 +54,7 @@ where\n     T: Anything<'b>,\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| ERROR the parameter type `T` may not live long enough\n     //~| ERROR does not outlive free region\n }\n@@ -66,7 +66,7 @@ where\n     'a: 'a,\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| ERROR the parameter type `T` may not live long enough\n     //~| ERROR does not outlive free region\n }\n@@ -88,7 +88,7 @@ where\n     // can do better here with a more involved verification step.\n \n     with_signature(cell, t, |cell, t| require(cell, t));\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| ERROR the parameter type `T` may not live long enough\n     //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n }"}, {"sha": "0d5a2dc7c559855b5138e8e9f2b3767bbe0fe48b", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,16 +1,16 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/projection-one-region-closure.rs:56:39\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                                       ^^^^^^^\n \n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/projection-one-region-closure.rs:68:39\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                                       ^^^^^^^\n \n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/projection-one-region-closure.rs:90:39\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));"}, {"sha": "16e91f2708fe94495627d0422a670af279e32d78", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -14,7 +14,7 @@\n // case, the best way to satisfy the trait bound is to show that `'b:\n // 'a`, which can be done in various ways.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![allow(warnings)]\n #![feature(dyn_trait)]\n@@ -46,7 +46,7 @@ where\n     T: Anything<'b>,\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| ERROR does not outlive free region\n }\n \n@@ -57,7 +57,7 @@ where\n     'a: 'a,\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| ERROR does not outlive free region\n }\n \n@@ -78,7 +78,7 @@ where\n     // can do better here with a more involved verification step.\n \n     with_signature(cell, t, |cell, t| require(cell, t));\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| ERROR does not outlive free region\n }\n "}, {"sha": "d4aca8380b469f2812d143a79db70f17cf7a4932", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,16 +1,16 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/projection-one-region-trait-bound-closure.rs:48:39\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                                       ^^^^^^^\n \n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/projection-one-region-trait-bound-closure.rs:59:39\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                                       ^^^^^^^\n \n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/projection-one-region-trait-bound-closure.rs:80:39\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));"}, {"sha": "0d42636c844a55acfbe54bc65a8394aa5b7cc3ce", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-static-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -12,7 +12,7 @@\n // outlive `'static`. In this case, we don't get any errors, and in fact\n // we don't even propagate constraints from the closures to the callers.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n // compile-pass\n \n #![allow(warnings)]"}, {"sha": "7c8ef140a29074296ec8cb6f885e12a343fd8090", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -15,7 +15,7 @@\n // the trait bound, and hence we propagate it to the caller as a type\n // test.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![allow(warnings)]\n #![feature(dyn_trait)]\n@@ -47,7 +47,7 @@ where\n     T: Anything<'b, 'c>,\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| ERROR associated type `<T as Anything<'_#5r, '_#6r>>::AssocType` may not live long enough\n }\n \n@@ -58,7 +58,7 @@ where\n     'a: 'a,\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| ERROR associated type `<T as Anything<'_#6r, '_#7r>>::AssocType` may not live long enough\n }\n \n@@ -79,7 +79,7 @@ where\n     // can do better here with a more involved verification step.\n \n     with_signature(cell, t, |cell, t| require(cell, t));\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| ERROR associated type `<T as Anything<'_#6r, '_#7r>>::AssocType` may not live long enough\n }\n \n@@ -107,7 +107,7 @@ where\n     T: Anything<'b, 'b>,\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| ERROR does not outlive free region\n }\n "}, {"sha": "7e36e467e4eba32ac700b48afea06ddae3016521", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,22 +1,22 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/projection-two-region-trait-bound-closure.rs:49:39\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                                       ^^^^^^^\n \n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/projection-two-region-trait-bound-closure.rs:60:39\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                                       ^^^^^^^\n \n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/projection-two-region-trait-bound-closure.rs:81:39\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                                       ^^^^^^^\n \n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/projection-two-region-trait-bound-closure.rs:109:39\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));"}, {"sha": "80b42c29563f1b5fb579a174117817032412f924", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-approximate-lower-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![allow(warnings)]\n #![feature(dyn_trait)]"}, {"sha": "c8feaddff9382ddf2d335c5e1954445256690ed4", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-approximate-lower-bound.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,16 +1,16 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/ty-param-closure-approximate-lower-bound.rs:35:31\n    |\n LL |     twice(cell, value, |a, b| invoke(a, b));\n    |                               ^^^^^^^^^^^^\n \n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/ty-param-closure-approximate-lower-bound.rs:43:31\n    |\n LL |     twice(cell, value, |a, b| invoke(a, b));\n    |                               ^^^^^^\n \n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/ty-param-closure-approximate-lower-bound.rs:43:31\n    |\n LL |     twice(cell, value, |a, b| invoke(a, b));"}, {"sha": "50763a1d5080808c6572da682d43073cbcf30cdf", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-return-type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![allow(warnings)]\n #![feature(dyn_trait)]\n@@ -35,7 +35,7 @@ where\n     // `'a` (and subsequently reports an error).\n \n     with_signature(x, |y| y)\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| ERROR the parameter type `T` may not live long enough\n }\n \n@@ -51,7 +51,7 @@ where\n     T: 'b + Debug,\n {\n     x\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| ERROR the parameter type `T` may not live long enough\n }\n "}, {"sha": "500595e0c5dcaf21e32d80fe80168cd661a86e94", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-return-type.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,10 +1,10 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/ty-param-closure-outlives-from-return-type.rs:37:27\n    |\n LL |     with_signature(x, |y| y)\n    |                           ^\n \n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/ty-param-closure-outlives-from-return-type.rs:53:5\n    |\n LL |     x"}, {"sha": "b70fc2b2ec4b40d6f0ee38e911a7e06afd4716b8", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-where-clause.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -12,7 +12,7 @@\n // `correct_region` for an explanation of how this test is setup; it's\n // somewhat intricate.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n \n #![allow(warnings)]\n #![feature(dyn_trait)]\n@@ -43,7 +43,7 @@ fn no_region<'a, T>(a: Cell<&'a ()>, b: T) {\n         // function, there is no where clause *anywhere*, and hence we\n         // get an error (but reported by the closure creator).\n         require(&x, &y)\n-        //~^ WARNING not reporting region error due to -Znll\n+        //~^ WARNING not reporting region error due to nll\n     })\n }\n \n@@ -77,7 +77,7 @@ where\n         //~^ ERROR the parameter type `T` may not live long enough\n         // See `correct_region`\n         require(&x, &y)\n-        //~^ WARNING not reporting region error due to -Znll\n+        //~^ WARNING not reporting region error due to nll\n     })\n }\n "}, {"sha": "4d8a66ba8e1c4cea182584b02fc2fda762a9383b", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-where-clause.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,10 +1,10 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/ty-param-closure-outlives-from-where-clause.rs:45:9\n    |\n LL |         require(&x, &y)\n    |         ^^^^^^^\n \n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/ty-param-closure-outlives-from-where-clause.rs:79:9\n    |\n LL |         require(&x, &y)\n@@ -19,7 +19,7 @@ LL | |         //~^ ERROR the parameter type `T` may not live long enough\n LL | |         //\n LL | |         // See `correct_region`, which explains the point of this\n ...  |\n-LL | |         //~^ WARNING not reporting region error due to -Znll\n+LL | |         //~^ WARNING not reporting region error due to nll\n LL | |     })\n    | |_____^\n    |\n@@ -40,7 +40,7 @@ LL | |         //~^ ERROR the parameter type `T` may not live long enough\n LL | |         //\n LL | |         // See `correct_region`, which explains the point of this\n ...  |\n-LL | |         //~^ WARNING not reporting region error due to -Znll\n+LL | |         //~^ WARNING not reporting region error due to nll\n LL | |     })\n    | |_____^\n    |\n@@ -109,7 +109,7 @@ LL |       with_signature(a, b, |x, y| {\n LL | |         //~^ ERROR the parameter type `T` may not live long enough\n LL | |         // See `correct_region`\n LL | |         require(&x, &y)\n-LL | |         //~^ WARNING not reporting region error due to -Znll\n+LL | |         //~^ WARNING not reporting region error due to nll\n LL | |     })\n    | |_____^\n    |\n@@ -130,7 +130,7 @@ LL |       with_signature(a, b, |x, y| {\n LL | |         //~^ ERROR the parameter type `T` may not live long enough\n LL | |         // See `correct_region`\n LL | |         require(&x, &y)\n-LL | |         //~^ WARNING not reporting region error due to -Znll\n+LL | |         //~^ WARNING not reporting region error due to nll\n LL | |     })\n    | |_____^\n    |"}, {"sha": "fb4ea63f8532cd9c24d9d63f52c3c0e40f03d6bd", "filename": "src/test/ui/nll/ty-outlives/ty-param-fn-body.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:-Znll -Zborrowck=mir\n+// compile-flags:-Zborrowck=mir\n \n // Test that we assume that universal types like `T` outlive the\n // function body.\n@@ -28,7 +28,7 @@ fn region_within_body<T>(t: T) {\n // Error here, because T: 'a is not satisfied.\n fn region_static<'a, T>(cell: Cell<&'a usize>, t: T) {\n     outlives(cell, t)\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| ERROR the parameter type `T` may not live long enough\n }\n "}, {"sha": "0596861e67b572b8bbf67e9b10a15d9d3c394bdf", "filename": "src/test/ui/nll/ty-outlives/ty-param-fn-body.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,4 +1,4 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/ty-param-fn-body.rs:30:5\n    |\n LL |     outlives(cell, t)"}, {"sha": "42d662e14193ccbce257bdb8ea6da923b8bd9366", "filename": "src/test/ui/nll/ty-outlives/ty-param-fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:-Znll -Zborrowck=mir\n+// compile-flags:-Zborrowck=mir\n \n #![allow(warnings)]\n #![feature(dyn_trait)]\n@@ -20,7 +20,7 @@ where\n     T: Debug,\n {\n     x\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| the parameter type `T` may not live long enough\n }\n \n@@ -36,7 +36,7 @@ where\n     T: 'b + Debug,\n {\n     x\n-    //~^ WARNING not reporting region error due to -Znll\n+    //~^ WARNING not reporting region error due to nll\n     //~| the parameter type `T` may not live long enough\n }\n "}, {"sha": "0d09cac8c38513da8abfeffbcdd91ffbb5a16c6a", "filename": "src/test/ui/nll/ty-outlives/ty-param-fn.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.stderr?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1,10 +1,10 @@\n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/ty-param-fn.rs:22:5\n    |\n LL |     x\n    |     ^\n \n-warning: not reporting region error due to -Znll\n+warning: not reporting region error due to nll\n   --> $DIR/ty-param-fn.rs:38:5\n    |\n LL |     x"}, {"sha": "51927d353ecc49ce12edd8bbabebd870ae716925", "filename": "src/test/ui/nll/ty-outlives/ty-param-implied-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-implied-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-implied-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-implied-bounds.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// compile-flags:-Zborrowck=mir -Zverbose\n // compile-pass\n \n // Test that we assume that universal types like `T` outlive the"}, {"sha": "e79aefb723614afd9af92ff9b51f934d84716c55", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881a7cd86ef1001bdfa9590878ca24e57794302f/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=881a7cd86ef1001bdfa9590878ca24e57794302f", "patch": "@@ -1696,7 +1696,7 @@ impl<'test> TestCx<'test> {\n \n         match self.config.compare_mode {\n             Some(CompareMode::Nll) => {\n-                rustc.args(&[\"-Znll\", \"-Zborrowck=mir\", \"-Ztwo-phase-borrows\"]);\n+                rustc.args(&[\"-Zborrowck=mir\", \"-Ztwo-phase-borrows\"]);\n             },\n             None => {},\n         }"}]}