{"sha": "8eb7f36a3ba06dbea4a44254c3e2d92455ae150f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlYjdmMzZhM2JhMDZkYmVhNGE0NDI1NGMzZTJkOTI0NTVhZTE1MGY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-06-10T15:12:14Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-06-10T17:58:44Z"}, "message": "std: Remove internal definitions of `cfg_if!` macro\n\nThis is duplicated in a few locations throughout the sysroot to work\naround issues with not exporting a macro in libstd but still wanting it\navailable to sysroot crates to define blocks. Nowadays though we can\nsimply depend on the `cfg-if` crate on crates.io, allowing us to use it\nfrom there!", "tree": {"sha": "713fd6d6cc498ca34a5292d574981b9240c1cc5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/713fd6d6cc498ca34a5292d574981b9240c1cc5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f", "html_url": "https://github.com/rust-lang/rust/commit/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a73ecb3d9c432f8f53117b1a6b6c209dc802dee7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a73ecb3d9c432f8f53117b1a6b6c209dc802dee7", "html_url": "https://github.com/rust-lang/rust/commit/a73ecb3d9c432f8f53117b1a6b6c209dc802dee7"}], "stats": {"total": 282, "additions": 49, "deletions": 233}, "files": [{"sha": "10cad11ea8ca03c5aa118ffaf53657e7ff358b65", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8eb7f36a3ba06dbea4a44254c3e2d92455ae150f", "patch": "@@ -1813,6 +1813,7 @@ name = \"panic_unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc 0.0.0\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3338,6 +3339,7 @@ dependencies = [\n  \"alloc 0.0.0\",\n  \"backtrace 0.3.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"dlmalloc 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3936,6 +3938,7 @@ name = \"unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "519212bb6cb4e034961a245b66ae89d41de6a78a", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=8eb7f36a3ba06dbea4a44254c3e2d92455ae150f", "patch": "@@ -111,31 +111,31 @@ pub fn spin_loop() {\n /// This function is a no-op, and does not even read from `dummy`.\n #[inline]\n #[unstable(feature = \"test\", issue = \"27812\")]\n+#[allow(unreachable_code)] // this makes #[cfg] a bit easier below.\n pub fn black_box<T>(dummy: T) -> T {\n-    cfg_if! {\n-        if #[cfg(any(\n-            target_arch = \"asmjs\",\n-            all(\n-                target_arch = \"wasm32\",\n-                target_os = \"emscripten\"\n-            )\n-        ))] {\n-            #[inline]\n-            unsafe fn black_box_impl<T>(d: T) -> T {\n-                // these targets do not support inline assembly\n-                let ret = crate::ptr::read_volatile(&d);\n-                crate::mem::forget(d);\n-                ret\n-            }\n-        } else {\n-            #[inline]\n-            unsafe fn black_box_impl<T>(d: T) -> T {\n-                // we need to \"use\" the argument in some way LLVM can't\n-                // introspect.\n-                asm!(\"\" : : \"r\"(&d));\n-                d\n-            }\n-        }\n+    // We need to \"use\" the argument in some way LLVM can't introspect, and on\n+    // targets that support it we can typically leverage inline assembly to do\n+    // this. LLVM's intepretation of inline assembly is that it's, well, a black\n+    // box. This isn't the greatest implementation since it probably deoptimizes\n+    // more than we want, but it's so far good enough.\n+    #[cfg(not(any(\n+        target_arch = \"asmjs\",\n+        all(\n+            target_arch = \"wasm32\",\n+            target_os = \"emscripten\"\n+        )\n+    )))]\n+    unsafe {\n+        asm!(\"\" : : \"r\"(&dummy));\n+        return dummy;\n+    }\n+\n+    // Not all platforms support inline assembly so try to do something without\n+    // inline assembly which in theory still hinders at least some optimizations\n+    // on those targets. This is the \"best effort\" scenario.\n+    unsafe {\n+        let ret = crate::ptr::read_volatile(&dummy);\n+        crate::mem::forget(dummy);\n+        ret\n     }\n-    unsafe { black_box_impl(dummy) }\n }"}, {"sha": "3acf2ec837d88cae0ca415e45d0c08af150e4686", "filename": "src/libcore/internal_macros.rs", "status": "modified", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibcore%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibcore%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Finternal_macros.rs?ref=8eb7f36a3ba06dbea4a44254c3e2d92455ae150f", "patch": "@@ -117,84 +117,3 @@ macro_rules! impl_fn_for_zst {\n         )+\n     }\n }\n-\n-/// A macro for defining `#[cfg]` if-else statements.\n-///\n-/// The macro provided by this crate, `cfg_if`, is similar to the `if/elif` C\n-/// preprocessor macro by allowing definition of a cascade of `#[cfg]` cases,\n-/// emitting the implementation which matches first.\n-///\n-/// This allows you to conveniently provide a long list `#[cfg]`'d blocks of code\n-/// without having to rewrite each clause multiple times.\n-///\n-/// # Example\n-///\n-/// ```\n-/// #[macro_use]\n-/// extern crate cfg_if;\n-///\n-/// cfg_if! {\n-///     if #[cfg(unix)] {\n-///         fn foo() { /* unix specific functionality */ }\n-///     } else if #[cfg(target_pointer_width = \"32\")] {\n-///         fn foo() { /* non-unix, 32-bit functionality */ }\n-///     } else {\n-///         fn foo() { /* fallback implementation */ }\n-///     }\n-/// }\n-///\n-/// # fn main() {}\n-/// ```\n-macro_rules! cfg_if {\n-    // match if/else chains with a final `else`\n-    ($(\n-        if #[cfg($($meta:meta),*)] { $($it:item)* }\n-    ) else * else {\n-        $($it2:item)*\n-    }) => {\n-        cfg_if! {\n-            @__items\n-            () ;\n-            $( ( ($($meta),*) ($($it)*) ), )*\n-            ( () ($($it2)*) ),\n-        }\n-    };\n-\n-    // match if/else chains lacking a final `else`\n-    (\n-        if #[cfg($($i_met:meta),*)] { $($i_it:item)* }\n-        $(\n-            else if #[cfg($($e_met:meta),*)] { $($e_it:item)* }\n-        )*\n-    ) => {\n-        cfg_if! {\n-            @__items\n-            () ;\n-            ( ($($i_met),*) ($($i_it)*) ),\n-            $( ( ($($e_met),*) ($($e_it)*) ), )*\n-            ( () () ),\n-        }\n-    };\n-\n-    // Internal and recursive macro to emit all the items\n-    //\n-    // Collects all the negated cfgs in a list at the beginning and after the\n-    // semicolon is all the remaining items\n-    (@__items ($($not:meta,)*) ; ) => {};\n-    (@__items ($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n-        // Emit all items within one block, applying an approprate #[cfg]. The\n-        // #[cfg] will require all `$m` matchers specified and must also negate\n-        // all previous matchers.\n-        cfg_if! { @__apply cfg(all($($m,)* not(any($($not),*)))), $($it)* }\n-\n-        // Recurse to emit all other items in `$rest`, and when we do so add all\n-        // our `$m` matchers to the list of `$not` matchers as future emissions\n-        // will have to negate everything we just matched as well.\n-        cfg_if! { @__items ($($not,)* $($m,)*) ; $($rest)* }\n-    };\n-\n-    // Internal macro to Apply a cfg attribute to a list of items\n-    (@__apply $m:meta, $($it:item)*) => {\n-        $(#[$m] $it)*\n-    };\n-}"}, {"sha": "47cd09f1b0510715a51b1f681c3b2c2e2e0468a8", "filename": "src/libpanic_unwind/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibpanic_unwind%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibpanic_unwind%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2FCargo.toml?ref=8eb7f36a3ba06dbea4a44254c3e2d92455ae150f", "patch": "@@ -16,3 +16,4 @@ core = { path = \"../libcore\" }\n libc = { version = \"0.2\", default-features = false }\n unwind = { path = \"../libunwind\" }\n compiler_builtins = \"0.1.0\"\n+cfg-if = \"0.1.8\""}, {"sha": "2bb9ce6ab220b650a64c950a5a84235aa1e40f8d", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=8eb7f36a3ba06dbea4a44254c3e2d92455ae150f", "patch": "@@ -38,10 +38,7 @@ use core::mem;\n use core::raw;\n use core::panic::BoxMeUp;\n \n-#[macro_use]\n-mod macros;\n-\n-cfg_if! {\n+cfg_if::cfg_if! {\n     if #[cfg(target_os = \"emscripten\")] {\n         #[path = \"emcc.rs\"]\n         mod imp;"}, {"sha": "659e977285e3567b3ed5d46a2f3fe08f4f87f5de", "filename": "src/libpanic_unwind/macros.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a73ecb3d9c432f8f53117b1a6b6c209dc802dee7/src%2Flibpanic_unwind%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ecb3d9c432f8f53117b1a6b6c209dc802dee7/src%2Flibpanic_unwind%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fmacros.rs?ref=a73ecb3d9c432f8f53117b1a6b6c209dc802dee7", "patch": "@@ -1,35 +0,0 @@\n-/// A macro for defining `#[cfg]` if-else statements.\n-///\n-/// This is similar to the `if/elif` C preprocessor macro by allowing definition\n-/// of a cascade of `#[cfg]` cases, emitting the implementation which matches\n-/// first.\n-///\n-/// This allows you to conveniently provide a long list `#[cfg]`'d blocks of code\n-/// without having to rewrite each clause multiple times.\n-macro_rules! cfg_if {\n-    ($(\n-        if #[cfg($($meta:meta),*)] { $($it:item)* }\n-    ) else * else {\n-        $($it2:item)*\n-    }) => {\n-        __cfg_if_items! {\n-            () ;\n-            $( ( ($($meta),*) ($($it)*) ), )*\n-            ( () ($($it2)*) ),\n-        }\n-    }\n-}\n-\n-macro_rules! __cfg_if_items {\n-    (($($not:meta,)*) ; ) => {};\n-    (($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n-        __cfg_if_apply! { cfg(all(not(any($($not),*)), $($m,)*)), $($it)* }\n-        __cfg_if_items! { ($($not,)* $($m,)*) ; $($rest)* }\n-    }\n-}\n-\n-macro_rules! __cfg_if_apply {\n-    ($m:meta, $($it:item)*) => {\n-        $(#[$m] $it)*\n-    }\n-}"}, {"sha": "a170dae2b08caa68b3c621eb1c0322cda8c248e4", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=8eb7f36a3ba06dbea4a44254c3e2d92455ae150f", "patch": "@@ -15,6 +15,7 @@ crate-type = [\"dylib\", \"rlib\"]\n \n [dependencies]\n alloc = { path = \"../liballoc\" }\n+cfg-if = \"0.1.8\"\n panic_unwind = { path = \"../libpanic_unwind\", optional = true }\n panic_abort = { path = \"../libpanic_abort\" }\n core = { path = \"../libcore\" }"}, {"sha": "e0ffc9ba92f11563a425c780d2f575f5660a780d", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=8eb7f36a3ba06dbea4a44254c3e2d92455ae150f", "patch": "@@ -336,6 +336,12 @@ extern crate libc;\n #[allow(unused_extern_crates)]\n extern crate unwind;\n \n+// Only needed for now for the `std_detect` module until that crate changes to\n+// use `cfg_if::cfg_if!`\n+#[macro_use]\n+#[cfg(not(test))]\n+extern crate cfg_if;\n+\n // During testing, this crate is not actually the \"real\" std library, but rather\n // it links to the real std library, which was compiled from this same source\n // code. So any lang items std defines are conditionally excluded (or else they"}, {"sha": "92b9a16f3e316595fd9360868f5c5027d8ac04c9", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=8eb7f36a3ba06dbea4a44254c3e2d92455ae150f", "patch": "@@ -896,39 +896,3 @@ mod builtin {\n         ($cond:expr, $($arg:tt)+) => ({ /* compiler built-in */ });\n     }\n }\n-\n-/// Defines `#[cfg]` if-else statements.\n-///\n-/// This is similar to the `if/elif` C preprocessor macro by allowing definition\n-/// of a cascade of `#[cfg]` cases, emitting the implementation which matches\n-/// first.\n-///\n-/// This allows you to conveniently provide a long list `#[cfg]`'d blocks of code\n-/// without having to rewrite each clause multiple times.\n-macro_rules! cfg_if {\n-    ($(\n-        if #[cfg($($meta:meta),*)] { $($it:item)* }\n-    ) else * else {\n-        $($it2:item)*\n-    }) => {\n-        __cfg_if_items! {\n-            () ;\n-            $( ( ($($meta),*) ($($it)*) ), )*\n-            ( () ($($it2)*) ),\n-        }\n-    }\n-}\n-\n-macro_rules! __cfg_if_items {\n-    (($($not:meta,)*) ; ) => {};\n-    (($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n-        __cfg_if_apply! { cfg(all(not(any($($not),*)), $($m,)*)), $($it)* }\n-        __cfg_if_items! { ($($not,)* $($m,)*) ; $($rest)* }\n-    }\n-}\n-\n-macro_rules! __cfg_if_apply {\n-    ($m:meta, $($it:item)*) => {\n-        $(#[$m] $it)*\n-    }\n-}"}, {"sha": "94e8b7805cf933325615e09a16bb6ed25aaae65b", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=8eb7f36a3ba06dbea4a44254c3e2d92455ae150f", "patch": "@@ -3,7 +3,7 @@\n #![stable(feature = \"os\", since = \"1.0.0\")]\n #![allow(missing_docs, nonstandard_style, missing_debug_implementations)]\n \n-cfg_if! {\n+cfg_if::cfg_if! {\n     if #[cfg(rustdoc)] {\n \n         // When documenting libstd we want to show unix/windows/linux modules as"}, {"sha": "21360e2e0f0286c8da5bcf8c16b30ddccd039018", "filename": "src/libstd/sys/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=8eb7f36a3ba06dbea4a44254c3e2d92455ae150f", "patch": "@@ -22,7 +22,7 @@\n \n #![allow(missing_debug_implementations)]\n \n-cfg_if! {\n+cfg_if::cfg_if! {\n     if #[cfg(unix)] {\n         mod unix;\n         pub use self::unix::*;\n@@ -54,7 +54,7 @@ cfg_if! {\n // Windows when we're compiling for Linux.\n \n #[cfg(rustdoc)]\n-cfg_if! {\n+cfg_if::cfg_if! {\n     if #[cfg(any(unix, target_os = \"redox\"))] {\n         // On unix we'll document what's already available\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -77,7 +77,7 @@ cfg_if! {\n }\n \n #[cfg(rustdoc)]\n-cfg_if! {\n+cfg_if::cfg_if! {\n     if #[cfg(windows)] {\n         // On windows we'll just be documenting what's already available\n         #[allow(missing_docs)]"}, {"sha": "7d157709eb6bf410ad1f2a3bdd0acd8df5e19820", "filename": "src/libstd/sys/wasm/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs?ref=8eb7f36a3ba06dbea4a44254c3e2d92455ae150f", "patch": "@@ -40,7 +40,7 @@ pub mod stdio;\n \n pub use crate::sys_common::os_str_bytes as os_str;\n \n-cfg_if! {\n+cfg_if::cfg_if! {\n     if #[cfg(target_feature = \"atomics\")] {\n         #[path = \"condvar_atomics.rs\"]\n         pub mod condvar;"}, {"sha": "61b4003cd3d148e473bfb2c7c31e678bef77566f", "filename": "src/libstd/sys/wasm/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs?ref=8eb7f36a3ba06dbea4a44254c3e2d92455ae150f", "patch": "@@ -59,7 +59,7 @@ pub mod guard {\n     pub unsafe fn init() -> Option<Guard> { None }\n }\n \n-cfg_if! {\n+cfg_if::cfg_if! {\n     if #[cfg(all(target_feature = \"atomics\", feature = \"wasm-bindgen-threads\"))] {\n         #[link(wasm_import_module = \"__wbindgen_thread_xform__\")]\n         extern {"}, {"sha": "13a59f66c5c2f16f4f461371a7b59d6c5505a680", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=8eb7f36a3ba06dbea4a44254c3e2d92455ae150f", "patch": "@@ -65,7 +65,7 @@ pub mod bytestring;\n pub mod process;\n pub mod fs;\n \n-cfg_if! {\n+cfg_if::cfg_if! {\n     if #[cfg(any(target_os = \"cloudabi\",\n                  target_os = \"l4re\",\n                  target_os = \"redox\","}, {"sha": "f0f1bab425d7af10c4e8d4aea1544c3d8f5fb5ce", "filename": "src/libunwind/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibunwind%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibunwind%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2FCargo.toml?ref=8eb7f36a3ba06dbea4a44254c3e2d92455ae150f", "patch": "@@ -19,6 +19,7 @@ doc = false\n core = { path = \"../libcore\" }\n libc = { version = \"0.2.43\", features = ['rustc-dep-of-std'], default-features = false }\n compiler_builtins = \"0.1.0\"\n+cfg-if = \"0.1.8\"\n \n [build-dependencies]\n cc = { optional = true, version = \"1.0.1\" }"}, {"sha": "9182e349b196ea1893d48243c952fa40e480b40d", "filename": "src/libunwind/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibunwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibunwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flib.rs?ref=8eb7f36a3ba06dbea4a44254c3e2d92455ae150f", "patch": "@@ -11,10 +11,7 @@\n \n #![cfg_attr(not(target_env = \"msvc\"), feature(libc))]\n \n-#[macro_use]\n-mod macros;\n-\n-cfg_if! {\n+cfg_if::cfg_if! {\n     if #[cfg(target_env = \"msvc\")] {\n         // no extra unwinder support needed\n     } else if #[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))] {"}, {"sha": "5794e0b7683cbf7760e2ba505043555c54ae091a", "filename": "src/libunwind/libunwind.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibunwind%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb7f36a3ba06dbea4a44254c3e2d92455ae150f/src%2Flibunwind%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flibunwind.rs?ref=8eb7f36a3ba06dbea4a44254c3e2d92455ae150f", "patch": "@@ -1,10 +1,5 @@\n #![allow(nonstandard_style)]\n \n-macro_rules! cfg_if {\n-    ( $( if #[cfg( $meta:meta )] { $($it1:item)* } else { $($it2:item)* } )* ) =>\n-        ( $( $( #[cfg($meta)] $it1)* $( #[cfg(not($meta))] $it2)* )* )\n-}\n-\n use libc::{c_int, c_void, uintptr_t};\n \n #[repr(C)]\n@@ -82,7 +77,7 @@ extern \"C\" {\n     pub fn _Unwind_GetDataRelBase(ctx: *mut _Unwind_Context) -> _Unwind_Ptr;\n }\n \n-cfg_if! {\n+cfg_if::cfg_if! {\n if #[cfg(all(any(target_os = \"ios\", target_os = \"netbsd\", not(target_arch = \"arm\"))))] {\n     // Not ARM EHABI\n     #[repr(C)]\n@@ -206,7 +201,9 @@ if #[cfg(all(any(target_os = \"ios\", target_os = \"netbsd\", not(target_arch = \"arm\n         pc\n     }\n }\n+} // cfg_if!\n \n+cfg_if::cfg_if! {\n if #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))] {\n     // Not 32-bit iOS\n     extern \"C\" {"}, {"sha": "659e977285e3567b3ed5d46a2f3fe08f4f87f5de", "filename": "src/libunwind/macros.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a73ecb3d9c432f8f53117b1a6b6c209dc802dee7/src%2Flibunwind%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ecb3d9c432f8f53117b1a6b6c209dc802dee7/src%2Flibunwind%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Fmacros.rs?ref=a73ecb3d9c432f8f53117b1a6b6c209dc802dee7", "patch": "@@ -1,35 +0,0 @@\n-/// A macro for defining `#[cfg]` if-else statements.\n-///\n-/// This is similar to the `if/elif` C preprocessor macro by allowing definition\n-/// of a cascade of `#[cfg]` cases, emitting the implementation which matches\n-/// first.\n-///\n-/// This allows you to conveniently provide a long list `#[cfg]`'d blocks of code\n-/// without having to rewrite each clause multiple times.\n-macro_rules! cfg_if {\n-    ($(\n-        if #[cfg($($meta:meta),*)] { $($it:item)* }\n-    ) else * else {\n-        $($it2:item)*\n-    }) => {\n-        __cfg_if_items! {\n-            () ;\n-            $( ( ($($meta),*) ($($it)*) ), )*\n-            ( () ($($it2)*) ),\n-        }\n-    }\n-}\n-\n-macro_rules! __cfg_if_items {\n-    (($($not:meta,)*) ; ) => {};\n-    (($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n-        __cfg_if_apply! { cfg(all(not(any($($not),*)), $($m,)*)), $($it)* }\n-        __cfg_if_items! { ($($not,)* $($m,)*) ; $($rest)* }\n-    }\n-}\n-\n-macro_rules! __cfg_if_apply {\n-    ($m:meta, $($it:item)*) => {\n-        $(#[$m] $it)*\n-    }\n-}"}]}