{"sha": "1ba7bd10c9c537687ca393eca0b323569309b83a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiYTdiZDEwYzljNTM3Njg3Y2EzOTNlY2EwYjMyMzU2OTMwOWI4M2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-19T22:31:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-19T22:31:34Z"}, "message": "auto merge of #14286 : cmr/rust/shard-benches, r=alexcrichton\n\nThis has no tests because it's near impossible to test -- since TestFn uses\n`proc`s, they can not be cloned or tested for equality. The only way to really\ntest this is making sure that for a given number of shards `a`, sharding from\n1 to `a` yields the complete set of tests. But `filter_tests` takes its vector\nby value and `proc`s cannot be compared.\n\n[breaking-change]\n\nCloses #10898", "tree": {"sha": "e951f7d1f4a3ffef8d23a7d279b0a90972c063c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e951f7d1f4a3ffef8d23a7d279b0a90972c063c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ba7bd10c9c537687ca393eca0b323569309b83a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ba7bd10c9c537687ca393eca0b323569309b83a", "html_url": "https://github.com/rust-lang/rust/commit/1ba7bd10c9c537687ca393eca0b323569309b83a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ba7bd10c9c537687ca393eca0b323569309b83a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c4a9b98b9ac7afebe88db13c028f645c5f0b922", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c4a9b98b9ac7afebe88db13c028f645c5f0b922", "html_url": "https://github.com/rust-lang/rust/commit/1c4a9b98b9ac7afebe88db13c028f645c5f0b922"}, {"sha": "2eeb4992dfabc0180e8e1a055278496fc991d3ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/2eeb4992dfabc0180e8e1a055278496fc991d3ee", "html_url": "https://github.com/rust-lang/rust/commit/2eeb4992dfabc0180e8e1a055278496fc991d3ee"}], "stats": {"total": 82, "additions": 60, "deletions": 22}, "files": [{"sha": "dc3a18b809510e2b61cc587c17a6504a8790c9a6", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/1ba7bd10c9c537687ca393eca0b323569309b83a/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba7bd10c9c537687ca393eca0b323569309b83a/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=1ba7bd10c9c537687ca393eca0b323569309b83a", "patch": "@@ -32,7 +32,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://static.rust-lang.org/doc/master\")]\n \n-#![feature(asm, macro_rules)]\n+#![feature(asm, macro_rules, phase)]\n #![deny(deprecated_owned_vector)]\n \n extern crate collections;\n@@ -83,7 +83,7 @@ pub mod stats;\n // colons. This way if some test runner wants to arrange the tests\n // hierarchically it may.\n \n-#[deriving(Clone)]\n+#[deriving(Clone, Eq, TotalEq, Hash)]\n pub enum TestName {\n     StaticTestName(&'static str),\n     DynTestName(StrBuf)\n@@ -156,6 +156,19 @@ impl TestFn {\n     }\n }\n \n+impl fmt::Show for TestFn {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write(match *self {\n+            StaticTestFn(..) => \"StaticTestFn(..)\",\n+            StaticBenchFn(..) => \"StaticBenchFn(..)\",\n+            StaticMetricFn(..) => \"StaticMetricFn(..)\",\n+            DynTestFn(..) => \"DynTestFn(..)\",\n+            DynMetricFn(..) => \"DynMetricFn(..)\",\n+            DynBenchFn(..) => \"DynBenchFn(..)\"\n+        }.as_bytes())\n+    }\n+}\n+\n /// Manager of the benchmarking runs.\n ///\n /// This is feed into functions marked with `#[bench]` to allow for\n@@ -170,13 +183,14 @@ pub struct Bencher {\n \n // The definition of a single test. A test runner will run a list of\n // these.\n-#[deriving(Clone)]\n+#[deriving(Clone, Show, Eq, TotalEq, Hash)]\n pub struct TestDesc {\n     pub name: TestName,\n     pub ignore: bool,\n     pub should_fail: bool,\n }\n \n+#[deriving(Show)]\n pub struct TestDescAndFn {\n     pub desc: TestDesc,\n     pub testfn: TestFn,\n@@ -242,15 +256,9 @@ pub fn test_main(args: &[StrBuf], tests: Vec<TestDescAndFn> ) {\n pub fn test_main_static(args: &[StrBuf], tests: &[TestDescAndFn]) {\n     let owned_tests = tests.iter().map(|t| {\n         match t.testfn {\n-            StaticTestFn(f) =>\n-            TestDescAndFn { testfn: StaticTestFn(f), desc: t.desc.clone() },\n-\n-            StaticBenchFn(f) =>\n-            TestDescAndFn { testfn: StaticBenchFn(f), desc: t.desc.clone() },\n-\n-            _ => {\n-                fail!(\"non-static tests passed to test::test_main_static\");\n-            }\n+            StaticTestFn(f) => TestDescAndFn { testfn: StaticTestFn(f), desc: t.desc.clone() },\n+            StaticBenchFn(f) => TestDescAndFn { testfn: StaticBenchFn(f), desc: t.desc.clone() },\n+            _ => fail!(\"non-static tests passed to test::test_main_static\")\n         }\n     }).collect();\n     test_main(args, owned_tests)\n@@ -419,8 +427,15 @@ pub fn opt_shard(maybestr: Option<StrBuf>) -> Option<(uint,uint)> {\n         None => None,\n         Some(s) => {\n             let mut it = s.as_slice().split('.');\n-            match (it.next().and_then(from_str), it.next().and_then(from_str), it.next()) {\n-                (Some(a), Some(b), None) => Some((a, b)),\n+            match (it.next().and_then(from_str::<uint>), it.next().and_then(from_str::<uint>),\n+                   it.next()) {\n+                (Some(a), Some(b), None) => {\n+                    if a <= 0 || a > b {\n+                        fail!(\"tried to run shard {a}.{b}, but {a} is out of bounds \\\n+                              (should be between 1 and {b}\", a=a, b=b)\n+                    }\n+                    Some((a, b))\n+                }\n                 _ => None,\n             }\n         }\n@@ -739,10 +754,9 @@ pub fn fmt_bench_samples(bs: &BenchSamples) -> StrBuf {\n }\n \n // A simple console test runner\n-pub fn run_tests_console(opts: &TestOpts,\n-                         tests: Vec<TestDescAndFn> ) -> io::IoResult<bool> {\n-    fn callback<T: Writer>(event: &TestEvent,\n-                           st: &mut ConsoleTestState<T>) -> io::IoResult<()> {\n+pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> io::IoResult<bool> {\n+\n+    fn callback<T: Writer>(event: &TestEvent, st: &mut ConsoleTestState<T>) -> io::IoResult<()> {\n         match (*event).clone() {\n             TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n             TeWait(ref test, padding) => st.write_test_start(test, padding),\n@@ -778,6 +792,7 @@ pub fn run_tests_console(opts: &TestOpts,\n             }\n         }\n     }\n+\n     let mut st = try!(ConsoleTestState::new(opts, None::<StdWriter>));\n     fn len_if_padded(t: &TestDescAndFn) -> uint {\n         match t.testfn.padding() {\n@@ -933,9 +948,7 @@ fn get_concurrency() -> uint {\n     }\n }\n \n-pub fn filter_tests(\n-    opts: &TestOpts,\n-    tests: Vec<TestDescAndFn> ) -> Vec<TestDescAndFn> {\n+pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescAndFn> {\n     let mut filtered = tests;\n \n     // Remove tests that don't match the test filter\n@@ -973,7 +986,9 @@ pub fn filter_tests(\n         None => filtered,\n         Some((a,b)) => {\n             filtered.move_iter().enumerate()\n-            .filter(|&(i,_)| i % b == a)\n+            // note: using a - 1 so that the valid shards, for example, are\n+            // 1.2 and 2.2 instead of 0.2 and 1.2\n+            .filter(|&(i,_)| i % b == (a - 1))\n             .map(|(_,t)| t)\n             .collect()\n         }"}, {"sha": "16ab12a82526cf565e5eabb801413f6b65ce9421", "filename": "src/test/run-make/test-shard-completeness/Makefile", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ba7bd10c9c537687ca393eca0b323569309b83a/src%2Ftest%2Frun-make%2Ftest-shard-completeness%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/1ba7bd10c9c537687ca393eca0b323569309b83a/src%2Ftest%2Frun-make%2Ftest-shard-completeness%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftest-shard-completeness%2FMakefile?ref=1ba7bd10c9c537687ca393eca0b323569309b83a", "patch": "@@ -0,0 +1,7 @@\n+-include ../tools.mk\n+\n+all:\n+\t# Running all the shards should hit every test\n+\t$(RUSTC) --test main.rs\n+\t$(call RUN,main) --test-shard 1.2 | grep \"test_1 ... ok\"\n+\t$(call RUN,main) --test-shard 2.2 | grep \"test_2 ... ok\""}, {"sha": "5eabd630b09318208c0d7dfa653bfcfc35282517", "filename": "src/test/run-make/test-shard-completeness/main.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1ba7bd10c9c537687ca393eca0b323569309b83a/src%2Ftest%2Frun-make%2Ftest-shard-completeness%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba7bd10c9c537687ca393eca0b323569309b83a/src%2Ftest%2Frun-make%2Ftest-shard-completeness%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftest-shard-completeness%2Fmain.rs?ref=1ba7bd10c9c537687ca393eca0b323569309b83a", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+#[test]\n+fn test_1() { }\n+#[test]\n+fn test_2() { }"}]}