{"sha": "2a2c9d38c78ece0a6c5de80e382a136173e64b14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhMmM5ZDM4Yzc4ZWNlMGE2YzVkZTgwZTM4MmExMzYxNzNlNjRiMTQ=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-08-26T16:23:42Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-09-10T15:43:27Z"}, "message": "Improve shallow `Clone` deriving", "tree": {"sha": "80079b95dd80a41e60667f133d0c4c7be2279801", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80079b95dd80a41e60667f133d0c4c7be2279801"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a2c9d38c78ece0a6c5de80e382a136173e64b14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a2c9d38c78ece0a6c5de80e382a136173e64b14", "html_url": "https://github.com/rust-lang/rust/commit/2a2c9d38c78ece0a6c5de80e382a136173e64b14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a2c9d38c78ece0a6c5de80e382a136173e64b14/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1f40f850e2546c2c187514e3d61d17544ba433f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1f40f850e2546c2c187514e3d61d17544ba433f", "html_url": "https://github.com/rust-lang/rust/commit/f1f40f850e2546c2c187514e3d61d17544ba433f"}], "stats": {"total": 299, "additions": 199, "deletions": 100}, "files": [{"sha": "3333cbfc1fc4e8a7a91a212f4b02f0e406010b5e", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2a2c9d38c78ece0a6c5de80e382a136173e64b14/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2c9d38c78ece0a6c5de80e382a136173e64b14/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=2a2c9d38c78ece0a6c5de80e382a136173e64b14", "patch": "@@ -106,10 +106,23 @@ pub trait Clone : Sized {\n     }\n }\n \n-// FIXME(aburka): this method is used solely by #[derive] to\n-// assert that every component of a type implements Clone.\n+// FIXME(aburka): these structs are used solely by #[derive] to\n+// assert that every component of a type implements Clone or Copy.\n //\n-// This should never be called by user code.\n+// These structs should never appear in user code.\n+#[doc(hidden)]\n+#[allow(missing_debug_implementations)]\n+#[unstable(feature = \"derive_clone_copy\",\n+           reason = \"deriving hack, should not be public\",\n+           issue = \"0\")]\n+pub struct AssertParamIsClone<T: Clone + ?Sized> { _field: ::marker::PhantomData<T> }\n+#[doc(hidden)]\n+#[allow(missing_debug_implementations)]\n+#[unstable(feature = \"derive_clone_copy\",\n+           reason = \"deriving hack, should not be public\",\n+           issue = \"0\")]\n+pub struct AssertParamIsCopy<T: Copy + ?Sized> { _field: ::marker::PhantomData<T> }\n+#[cfg(stage0)]\n #[doc(hidden)]\n #[inline(always)]\n #[unstable(feature = \"derive_clone_copy\","}, {"sha": "aa7c2c301dd7a918b9b7bbdf4ceb9925592e6c86", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 109, "deletions": 70, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/2a2c9d38c78ece0a6c5de80e382a136173e64b14/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2c9d38c78ece0a6c5de80e382a136173e64b14/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=2a2c9d38c78ece0a6c5de80e382a136173e64b14", "patch": "@@ -11,20 +11,14 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{Expr, Generics, ItemKind, MetaItem, VariantData};\n+use syntax::ast::{self, Expr, Generics, ItemKind, MetaItem, VariantData};\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n+use syntax::parse::token::{keywords, InternedString};\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n-#[derive(PartialEq)]\n-enum Mode {\n-    Deep,\n-    Shallow,\n-}\n-\n pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                              span: Span,\n                              mitem: &MetaItem,\n@@ -40,29 +34,38 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n     //      if we used the short form with generics, we'd have to bound the generics with\n     //      Clone + Copy, and then there'd be no Clone impl at all if the user fills in something\n     //      that is Clone but not Copy. and until specialization we can't write both impls.\n+    // - the item is a union with Copy fields\n+    //      Unions with generic parameters still can derive Clone because they require Copy\n+    //      for deriving, Clone alone is not enough.\n+    //      Whever Clone is implemented for fields is irrelevant so we don't assert it.\n     let bounds;\n-    let unify_fieldless_variants;\n     let substructure;\n+    let is_shallow;\n     match *item {\n         Annotatable::Item(ref annitem) => {\n             match annitem.node {\n                 ItemKind::Struct(_, Generics { ref ty_params, .. }) |\n                 ItemKind::Enum(_, Generics { ref ty_params, .. })\n-                    if ty_params.is_empty() &&\n-                       attr::contains_name(&annitem.attrs, \"rustc_copy_clone_marker\") => {\n-\n+                        if attr::contains_name(&annitem.attrs, \"rustc_copy_clone_marker\") &&\n+                           ty_params.is_empty() => {\n+                    bounds = vec![];\n+                    is_shallow = true;\n+                    substructure = combine_substructure(Box::new(|c, s, sub| {\n+                        cs_clone_shallow(\"Clone\", c, s, sub, false)\n+                    }));\n+                }\n+                ItemKind::Union(..) => {\n                     bounds = vec![Literal(path_std!(cx, core::marker::Copy))];\n-                    unify_fieldless_variants = true;\n+                    is_shallow = true;\n                     substructure = combine_substructure(Box::new(|c, s, sub| {\n-                        cs_clone(\"Clone\", c, s, sub, Mode::Shallow)\n+                        cs_clone_shallow(\"Clone\", c, s, sub, true)\n                     }));\n                 }\n-\n                 _ => {\n                     bounds = vec![];\n-                    unify_fieldless_variants = false;\n+                    is_shallow = false;\n                     substructure = combine_substructure(Box::new(|c, s, sub| {\n-                        cs_clone(\"Clone\", c, s, sub, Mode::Deep)\n+                        cs_clone(\"Clone\", c, s, sub)\n                     }));\n                 }\n             }\n@@ -80,7 +83,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n         additional_bounds: bounds,\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n-        supports_unions: false,\n+        supports_unions: true,\n         methods: vec![MethodDef {\n                           name: \"clone\",\n                           generics: LifetimeBounds::empty(),\n@@ -89,37 +92,85 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                           ret_ty: Self_,\n                           attributes: attrs,\n                           is_unsafe: false,\n-                          unify_fieldless_variants: unify_fieldless_variants,\n+                          unify_fieldless_variants: false,\n                           combine_substructure: substructure,\n                       }],\n         associated_types: Vec::new(),\n     };\n \n-    trait_def.expand(cx, mitem, item, push)\n+    trait_def.expand_ext(cx, mitem, item, push, is_shallow)\n+}\n+\n+fn cs_clone_shallow(name: &str,\n+                    cx: &mut ExtCtxt,\n+                    trait_span: Span,\n+                    substr: &Substructure,\n+                    is_union: bool)\n+                    -> P<Expr> {\n+    fn assert_ty_bounds(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>,\n+                        ty: P<ast::Ty>, span: Span, helper_name: &str) {\n+        // Generate statement `let _: helper_name<ty>;`,\n+        // set the expn ID so we can use the unstable struct.\n+        let span = super::allow_unstable(cx, span, \"derive(Clone)\");\n+        let assert_path = cx.path_all(span, true,\n+                                        cx.std_path(&[\"clone\", helper_name]),\n+                                        vec![], vec![ty], vec![]);\n+        let local = P(ast::Local {\n+            pat: cx.pat_wild(span),\n+            ty: Some(cx.ty_path(assert_path)),\n+            init: None,\n+            id: ast::DUMMY_NODE_ID,\n+            span: span,\n+            attrs: ast::ThinVec::new(),\n+        });\n+        let stmt = ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::StmtKind::Local(local),\n+            span: span,\n+        };\n+        stmts.push(stmt);\n+    }\n+    fn process_variant(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>, variant: &VariantData) {\n+        for field in variant.fields() {\n+            // let _: AssertParamIsClone<FieldTy>;\n+            assert_ty_bounds(cx, stmts, field.ty.clone(), field.span, \"AssertParamIsClone\");\n+        }\n+    }\n+\n+    let mut stmts = Vec::new();\n+    if is_union {\n+        // let _: AssertParamIsCopy<Self>;\n+        let self_ty = cx.ty_path(cx.path_ident(trait_span, keywords::SelfType.ident()));\n+        assert_ty_bounds(cx, &mut stmts, self_ty, trait_span, \"AssertParamIsCopy\");\n+    } else {\n+        match *substr.fields {\n+            StaticStruct(vdata, ..) => {\n+                process_variant(cx, &mut stmts, vdata);\n+            }\n+            StaticEnum(enum_def, ..) => {\n+                for variant in &enum_def.variants {\n+                    process_variant(cx, &mut stmts, &variant.node.data);\n+                }\n+            }\n+            _ => cx.span_bug(trait_span, &format!(\"unexpected substructure in \\\n+                                                    shallow `derive({})`\", name))\n+        }\n+    }\n+    stmts.push(cx.stmt_expr(cx.expr_deref(trait_span, cx.expr_self(trait_span))));\n+    cx.expr_block(cx.block(trait_span, stmts))\n }\n \n fn cs_clone(name: &str,\n             cx: &mut ExtCtxt,\n             trait_span: Span,\n-            substr: &Substructure,\n-            mode: Mode)\n+            substr: &Substructure)\n             -> P<Expr> {\n     let ctor_path;\n     let all_fields;\n-    let fn_path = match mode {\n-        Mode::Shallow => cx.std_path(&[\"clone\", \"assert_receiver_is_clone\"]),\n-        Mode::Deep => cx.std_path(&[\"clone\", \"Clone\", \"clone\"]),\n-    };\n+    let fn_path = cx.std_path(&[\"clone\", \"Clone\", \"clone\"]);\n     let subcall = |cx: &mut ExtCtxt, field: &FieldInfo| {\n         let args = vec![cx.expr_addr_of(field.span, field.self_.clone())];\n-\n-        let span = if mode == Mode::Shallow {\n-            // set the expn ID so we can call the unstable method\n-            super::allow_unstable(cx, field.span, \"derive(Clone)\")\n-        } else {\n-            field.span\n-        };\n-        cx.expr_call_global(span, fn_path.clone(), args)\n+        cx.expr_call_global(field.span, fn_path.clone(), args)\n     };\n \n     let vdata;\n@@ -145,43 +196,31 @@ fn cs_clone(name: &str,\n         }\n     }\n \n-    match mode {\n-        Mode::Shallow => {\n-            let mut stmts = all_fields.iter().map(|f| {\n-                let call = subcall(cx, f);\n-                cx.stmt_expr(call)\n-            }).collect::<Vec<_>>();\n-            stmts.push(cx.stmt_expr(cx.expr_deref(trait_span, cx.expr_self(trait_span))));\n-            cx.expr_block(cx.block(trait_span, stmts))\n-        }\n-        Mode::Deep => {\n-            match *vdata {\n-                VariantData::Struct(..) => {\n-                    let fields = all_fields.iter()\n-                        .map(|field| {\n-                            let ident = match field.name {\n-                                Some(i) => i,\n-                                None => {\n-                                    cx.span_bug(trait_span,\n-                                                &format!(\"unnamed field in normal struct in \\\n-                                                     `derive({})`\",\n-                                                         name))\n-                                }\n-                            };\n-                            let call = subcall(cx, field);\n-                            cx.field_imm(field.span, ident, call)\n-                        })\n-                        .collect::<Vec<_>>();\n+    match *vdata {\n+        VariantData::Struct(..) => {\n+            let fields = all_fields.iter()\n+                .map(|field| {\n+                    let ident = match field.name {\n+                        Some(i) => i,\n+                        None => {\n+                            cx.span_bug(trait_span,\n+                                        &format!(\"unnamed field in normal struct in \\\n+                                                `derive({})`\",\n+                                                    name))\n+                        }\n+                    };\n+                    let call = subcall(cx, field);\n+                    cx.field_imm(field.span, ident, call)\n+                })\n+                .collect::<Vec<_>>();\n \n-                    cx.expr_struct(trait_span, ctor_path, fields)\n-                }\n-                VariantData::Tuple(..) => {\n-                    let subcalls = all_fields.iter().map(|f| subcall(cx, f)).collect();\n-                    let path = cx.expr_path(ctor_path);\n-                    cx.expr_call(trait_span, path, subcalls)\n-                }\n-                VariantData::Unit(..) => cx.expr_path(ctor_path),\n-            }\n+            cx.expr_struct(trait_span, ctor_path, fields)\n+        }\n+        VariantData::Tuple(..) => {\n+            let subcalls = all_fields.iter().map(|f| subcall(cx, f)).collect();\n+            let path = cx.expr_path(ctor_path);\n+            cx.expr_call(trait_span, path, subcalls)\n         }\n+        VariantData::Unit(..) => cx.expr_path(ctor_path),\n     }\n }"}, {"sha": "339a6c477ccd5df1a55fecfd3f91a357c12d9fbc", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2a2c9d38c78ece0a6c5de80e382a136173e64b14/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2c9d38c78ece0a6c5de80e382a136173e64b14/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=2a2c9d38c78ece0a6c5de80e382a136173e64b14", "patch": "@@ -401,18 +401,29 @@ impl<'a> TraitDef<'a> {\n                   mitem: &ast::MetaItem,\n                   item: &'a Annotatable,\n                   push: &mut FnMut(Annotatable)) {\n+        self.expand_ext(cx, mitem, item, push, false);\n+    }\n+\n+    pub fn expand_ext(&self,\n+                      cx: &mut ExtCtxt,\n+                      mitem: &ast::MetaItem,\n+                      item: &'a Annotatable,\n+                      push: &mut FnMut(Annotatable),\n+                      from_scratch: bool) {\n         match *item {\n             Annotatable::Item(ref item) => {\n                 let newitem = match item.node {\n                     ast::ItemKind::Struct(ref struct_def, ref generics) => {\n-                        self.expand_struct_def(cx, &struct_def, item.ident, generics)\n+                        self.expand_struct_def(cx, &struct_def, item.ident, generics, from_scratch)\n                     }\n                     ast::ItemKind::Enum(ref enum_def, ref generics) => {\n-                        self.expand_enum_def(cx, enum_def, &item.attrs, item.ident, generics)\n+                        self.expand_enum_def(cx, enum_def, &item.attrs,\n+                                             item.ident, generics, from_scratch)\n                     }\n                     ast::ItemKind::Union(ref struct_def, ref generics) => {\n                         if self.supports_unions {\n-                            self.expand_struct_def(cx, &struct_def, item.ident, generics)\n+                            self.expand_struct_def(cx, &struct_def, item.ident,\n+                                                   generics, from_scratch)\n                         } else {\n                             cx.span_err(mitem.span,\n                                         \"this trait cannot be derived for unions\");\n@@ -661,7 +672,8 @@ impl<'a> TraitDef<'a> {\n                          cx: &mut ExtCtxt,\n                          struct_def: &'a VariantData,\n                          type_ident: Ident,\n-                         generics: &Generics)\n+                         generics: &Generics,\n+                         from_scratch: bool)\n                          -> P<ast::Item> {\n         let field_tys: Vec<P<ast::Ty>> = struct_def.fields()\n             .iter()\n@@ -674,7 +686,7 @@ impl<'a> TraitDef<'a> {\n                 let (explicit_self, self_args, nonself_args, tys) =\n                     method_def.split_self_nonself_args(cx, self, type_ident, generics);\n \n-                let body = if method_def.is_static() {\n+                let body = if from_scratch || method_def.is_static() {\n                     method_def.expand_static_struct_method_body(cx,\n                                                                 self,\n                                                                 struct_def,\n@@ -709,7 +721,8 @@ impl<'a> TraitDef<'a> {\n                        enum_def: &'a EnumDef,\n                        type_attrs: &[ast::Attribute],\n                        type_ident: Ident,\n-                       generics: &Generics)\n+                       generics: &Generics,\n+                       from_scratch: bool)\n                        -> P<ast::Item> {\n         let mut field_tys = Vec::new();\n \n@@ -727,7 +740,7 @@ impl<'a> TraitDef<'a> {\n                 let (explicit_self, self_args, nonself_args, tys) =\n                     method_def.split_self_nonself_args(cx, self, type_ident, generics);\n \n-                let body = if method_def.is_static() {\n+                let body = if from_scratch || method_def.is_static() {\n                     method_def.expand_static_enum_method_body(cx,\n                                                               self,\n                                                               enum_def,"}, {"sha": "8b6b8d9ecb08ed08c098bf2f2284a569a4df238a", "filename": "src/test/compile-fail/borrowck/borrowck-union-borrow-nested.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a2c9d38c78ece0a6c5de80e382a136173e64b14/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2c9d38c78ece0a6c5de80e382a136173e64b14/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow-nested.rs?ref=2a2c9d38c78ece0a6c5de80e382a136173e64b14", "patch": "@@ -18,16 +18,12 @@ struct S {\n     b: u16,\n }\n \n+#[derive(Clone, Copy)]\n union U {\n     s: S,\n     c: u32,\n }\n \n-impl Clone for U {\n-    fn clone(&self) -> Self { *self }\n-}\n-impl Copy for U {}\n-\n fn main() {\n     unsafe {\n         {"}, {"sha": "ecc698acc317f7f09b7223757a83b74a87f5f433", "filename": "src/test/compile-fail/borrowck/borrowck-union-borrow.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a2c9d38c78ece0a6c5de80e382a136173e64b14/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2c9d38c78ece0a6c5de80e382a136173e64b14/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs?ref=2a2c9d38c78ece0a6c5de80e382a136173e64b14", "patch": "@@ -12,16 +12,12 @@\n \n #![feature(untagged_unions)]\n \n+#[derive(Clone, Copy)]\n union U {\n     a: u8,\n     b: u64,\n }\n \n-impl Clone for U {\n-    fn clone(&self) -> Self { *self }\n-}\n-impl Copy for U {}\n-\n fn main() {\n     unsafe {\n         let mut u = U { b: 0 };"}, {"sha": "9014b3f2956b7e7751c97a44d9d49ea1ee4f6637", "filename": "src/test/compile-fail/union/union-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a2c9d38c78ece0a6c5de80e382a136173e64b14/src%2Ftest%2Fcompile-fail%2Funion%2Funion-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2c9d38c78ece0a6c5de80e382a136173e64b14/src%2Ftest%2Fcompile-fail%2Funion%2Funion-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-copy.rs?ref=2a2c9d38c78ece0a6c5de80e382a136173e64b14", "patch": "@@ -10,16 +10,16 @@\n \n #![feature(untagged_unions)]\n \n+#[derive(Clone)]\n union U {\n     a: u8\n }\n \n+#[derive(Clone)]\n union W {\n     a: String\n }\n \n-impl Clone for U { fn clone(&self) { panic!(); } }\n-impl Clone for W { fn clone(&self) { panic!(); } }\n impl Copy for U {} // OK\n impl Copy for W {} //~ ERROR the trait `Copy` may not be implemented for this type\n "}, {"sha": "6e226d7d79f9f1faa12338fb94344bc47dc09c0a", "filename": "src/test/compile-fail/union/union-derive-clone.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2a2c9d38c78ece0a6c5de80e382a136173e64b14/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2c9d38c78ece0a6c5de80e382a136173e64b14/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive-clone.rs?ref=2a2c9d38c78ece0a6c5de80e382a136173e64b14", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+#[derive(Clone)] //~ ERROR the trait bound `U1: std::marker::Copy` is not satisfied\n+union U1 {\n+    a: u8,\n+}\n+\n+#[derive(Clone)]\n+union U2 {\n+    a: u8, // OK\n+}\n+\n+impl Copy for U2 {}\n+\n+#[derive(Clone, Copy)]\n+union U3 {\n+    a: u8, // OK\n+}\n+\n+#[derive(Clone, Copy)]\n+union U4<T> {\n+    a: T, // OK\n+}\n+\n+#[derive(Clone)]\n+struct CloneNoCopy;\n+\n+fn main() {\n+    let u = U4 { a: CloneNoCopy };\n+    let w = u.clone(); //~ ERROR no method named `clone` found for type `U4<CloneNoCopy>`\n+}"}, {"sha": "01ce9696284dfb950bb0d9f6b6d54cde9d6510da", "filename": "src/test/compile-fail/union/union-derive.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a2c9d38c78ece0a6c5de80e382a136173e64b14/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2c9d38c78ece0a6c5de80e382a136173e64b14/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive.rs?ref=2a2c9d38c78ece0a6c5de80e382a136173e64b14", "patch": "@@ -13,7 +13,6 @@\n #![feature(untagged_unions)]\n \n #[derive(\n-    Clone, //~ ERROR this trait cannot be derived for unions\n     PartialEq, //~ ERROR this trait cannot be derived for unions\n     Eq, //~ ERROR this trait cannot be derived for unions\n     PartialOrd, //~ ERROR this trait cannot be derived for unions"}, {"sha": "bea4d5f923e21f314f9caa22cd725c5bf21c0319", "filename": "src/test/run-pass/union/union-c-interop.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2a2c9d38c78ece0a6c5de80e382a136173e64b14/src%2Ftest%2Frun-pass%2Funion%2Funion-c-interop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2c9d38c78ece0a6c5de80e382a136173e64b14/src%2Ftest%2Frun-pass%2Funion%2Funion-c-interop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-c-interop.rs?ref=2a2c9d38c78ece0a6c5de80e382a136173e64b14", "patch": "@@ -10,24 +10,21 @@\n \n #![feature(untagged_unions)]\n \n-#[derive(Copy)]\n+#[derive(Clone, Copy)]\n #[repr(C)]\n struct LARGE_INTEGER_U {\n     LowPart: u32,\n     HighPart: u32,\n }\n \n-#[derive(Copy)]\n+#[derive(Clone, Copy)]\n #[repr(C)]\n union LARGE_INTEGER {\n   __unnamed__: LARGE_INTEGER_U,\n   u: LARGE_INTEGER_U,\n   QuadPart: u64,\n }\n \n-impl Clone for LARGE_INTEGER_U { fn clone(&self) -> Self { *self } }\n-impl Clone for LARGE_INTEGER { fn clone(&self) -> Self { *self } }\n-\n #[link(name = \"rust_test_helpers\")]\n extern \"C\" {\n     fn increment_all_parts(_: LARGE_INTEGER) -> LARGE_INTEGER;"}, {"sha": "8314416e2b10a9a9fc2bd8eea3aa9c14b8132ebb", "filename": "src/test/run-pass/union/union-derive.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2a2c9d38c78ece0a6c5de80e382a136173e64b14/src%2Ftest%2Frun-pass%2Funion%2Funion-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a2c9d38c78ece0a6c5de80e382a136173e64b14/src%2Ftest%2Frun-pass%2Funion%2Funion-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-derive.rs?ref=2a2c9d38c78ece0a6c5de80e382a136173e64b14", "patch": "@@ -14,18 +14,23 @@\n \n #[derive(\n     Copy,\n+    Clone,\n )]\n union U {\n     a: u8,\n     b: u16,\n }\n \n-impl Clone for U {\n-    fn clone(&self) -> Self { *self }\n+#[derive(Clone, Copy)]\n+union W<T> {\n+    a: T,\n }\n \n fn main() {\n     let u = U { b: 0 };\n     let u1 = u;\n     let u2 = u.clone();\n+\n+    let w = W { a: 0 };\n+    let w1 = w.clone();\n }"}]}