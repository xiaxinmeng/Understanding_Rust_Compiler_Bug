{"sha": "1048f9abfac08c59d313e0764c909cfa0821a39e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwNDhmOWFiZmFjMDhjNTlkMzEzZTA3NjRjOTA5Y2ZhMDgyMWEzOWU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-20T04:51:44Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-23T01:00:55Z"}, "message": "rustc: Factor out struct literal typechecking in preparation for struct-like enum variants", "tree": {"sha": "8365f4d57d516000afb3deadc5ab53b1fe27451b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8365f4d57d516000afb3deadc5ab53b1fe27451b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1048f9abfac08c59d313e0764c909cfa0821a39e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1048f9abfac08c59d313e0764c909cfa0821a39e", "html_url": "https://github.com/rust-lang/rust/commit/1048f9abfac08c59d313e0764c909cfa0821a39e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1048f9abfac08c59d313e0764c909cfa0821a39e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223", "html_url": "https://github.com/rust-lang/rust/commit/ec1c60c4d6b54d30c11c79e1fa51dc6cbee61223"}], "stats": {"total": 254, "additions": 132, "deletions": 122}, "files": [{"sha": "266fd1ba4ea029248430153d52866ce10bf59015", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 132, "deletions": 122, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/1048f9abfac08c59d313e0764c909cfa0821a39e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1048f9abfac08c59d313e0764c909cfa0821a39e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=1048f9abfac08c59d313e0764c909cfa0821a39e", "patch": "@@ -1441,6 +1441,136 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         return bot;\n     }\n \n+    fn check_struct_constructor(fcx: @fn_ctxt,\n+                                id: ast::node_id,\n+                                span: syntax::codemap::span,\n+                                class_id: ast::def_id,\n+                                fields: ~[ast::field],\n+                                base_expr: Option<@ast::expr>) -> bool {\n+        let mut bot = false;\n+        let tcx = fcx.ccx.tcx;\n+\n+        // Look up the number of type parameters and the raw type, and\n+        // determine whether the class is region-parameterized.\n+        let type_parameter_count, region_parameterized, raw_type;\n+        if class_id.crate == ast::local_crate {\n+            region_parameterized =\n+                tcx.region_paramd_items.find(class_id.node);\n+            match tcx.items.find(class_id.node) {\n+                Some(ast_map::node_item(@{\n+                        node: ast::item_class(_, type_parameters),\n+                        _\n+                    }, _)) => {\n+\n+                    type_parameter_count = type_parameters.len();\n+\n+                    let self_region =\n+                        bound_self_region(region_parameterized);\n+\n+                    raw_type = ty::mk_class(tcx, class_id, {\n+                        self_r: self_region,\n+                        self_ty: None,\n+                        tps: ty::ty_params_to_tys(tcx, type_parameters)\n+                    });\n+                }\n+                _ => {\n+                    tcx.sess.span_bug(span,\n+                                      ~\"resolve didn't map this to a class\");\n+                }\n+            }\n+        } else {\n+            let item_type = ty::lookup_item_type(tcx, class_id);\n+            type_parameter_count = (*item_type.bounds).len();\n+            region_parameterized = item_type.region_param;\n+            raw_type = item_type.ty;\n+        }\n+\n+        // Generate the struct type.\n+        let self_region =\n+            fcx.region_var_if_parameterized(region_parameterized,\n+                                            span,\n+                                            ty::re_scope(id));\n+        let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n+        let substitutions = {\n+            self_r: self_region,\n+            self_ty: None,\n+            tps: type_parameters\n+        };\n+\n+        let struct_type = ty::subst(tcx, &substitutions, raw_type);\n+\n+        // Look up the class fields and build up a map.\n+        let class_fields = ty::lookup_class_fields(tcx, class_id);\n+        let class_field_map = HashMap();\n+        let mut fields_found = 0;\n+        for class_fields.each |field| {\n+            // XXX: Check visibility here.\n+            class_field_map.insert(field.ident, (field.id, false));\n+        }\n+\n+        // Typecheck each field.\n+        for fields.each |field| {\n+            match class_field_map.find(field.node.ident) {\n+                None => {\n+                    tcx.sess.span_err(\n+                        field.span,\n+                        fmt!(\"structure has no field named field named `%s`\",\n+                             tcx.sess.str_of(field.node.ident)));\n+                }\n+                Some((_, true)) => {\n+                    tcx.sess.span_err(\n+                        field.span,\n+                        fmt!(\"field `%s` specified more than once\",\n+                             tcx.sess.str_of(field.node.ident)));\n+                }\n+                Some((field_id, false)) => {\n+                    let expected_field_type =\n+                        ty::lookup_field_type(tcx, class_id, field_id,\n+                                              &substitutions);\n+                    bot |= check_expr(fcx,\n+                                      field.node.expr,\n+                                      Some(expected_field_type));\n+                    fields_found += 1;\n+                }\n+            }\n+        }\n+\n+        match base_expr {\n+            None => {\n+                // Make sure the programmer specified all the fields.\n+                assert fields_found <= class_fields.len();\n+                if fields_found < class_fields.len() {\n+                    let mut missing_fields = ~[];\n+                    for class_fields.each |class_field| {\n+                        let name = class_field.ident;\n+                        let (_, seen) = class_field_map.get(name);\n+                        if !seen {\n+                            missing_fields.push(\n+                                ~\"`\" + tcx.sess.str_of(name) + ~\"`\");\n+                        }\n+                    }\n+\n+                    tcx.sess.span_err(span,\n+                                      fmt!(\"missing field%s: %s\",\n+                                           if missing_fields.len() == 1 {\n+                                               ~\"\"\n+                                           } else {\n+                                               ~\"s\"\n+                                           },\n+                                           str::connect(missing_fields,\n+                                                        ~\", \")));\n+                }\n+            }\n+            Some(base_expr) => {\n+                // Just check the base expression.\n+                check_expr(fcx, base_expr, Some(struct_type));\n+            }\n+        }\n+\n+        // Write in the resulting type.\n+        fcx.write_ty(id, struct_type);\n+        return bot;\n+    }\n \n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n@@ -1911,136 +2041,16 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_struct(path, fields, base_expr) => {\n         // Resolve the path.\n-        let class_id;\n         match tcx.def_map.find(id) {\n             Some(ast::def_class(type_def_id)) => {\n-                class_id = type_def_id;\n+                check_struct_constructor(fcx, id, expr.span, type_def_id,\n+                                         fields, base_expr);\n             }\n             _ => {\n                 tcx.sess.span_bug(path.span, ~\"structure constructor does \\\n                                                not name a structure type\");\n             }\n         }\n-\n-        // Look up the number of type parameters and the raw type, and\n-        // determine whether the class is region-parameterized.\n-        let type_parameter_count, region_parameterized, raw_type;\n-        if class_id.crate == ast::local_crate {\n-            region_parameterized =\n-                tcx.region_paramd_items.find(class_id.node);\n-            match tcx.items.find(class_id.node) {\n-                Some(ast_map::node_item(@{\n-                        node: ast::item_class(_, type_parameters),\n-                        _\n-                    }, _)) => {\n-\n-                    type_parameter_count = type_parameters.len();\n-\n-                    let self_region =\n-                        bound_self_region(region_parameterized);\n-\n-                    raw_type = ty::mk_class(tcx, class_id, {\n-                        self_r: self_region,\n-                        self_ty: None,\n-                        tps: ty::ty_params_to_tys(tcx, type_parameters)\n-                    });\n-                }\n-                _ => {\n-                    tcx.sess.span_bug(expr.span,\n-                                      ~\"resolve didn't map this to a class\");\n-                }\n-            }\n-        } else {\n-            let item_type = ty::lookup_item_type(tcx, class_id);\n-            type_parameter_count = (*item_type.bounds).len();\n-            region_parameterized = item_type.region_param;\n-            raw_type = item_type.ty;\n-        }\n-\n-        // Generate the struct type.\n-        let self_region =\n-            fcx.region_var_if_parameterized(region_parameterized,\n-                                            expr.span,\n-                                            ty::re_scope(expr.id));\n-        let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n-        let substitutions = {\n-            self_r: self_region,\n-            self_ty: None,\n-            tps: type_parameters\n-        };\n-\n-        let struct_type = ty::subst(tcx, &substitutions, raw_type);\n-\n-        // Look up the class fields and build up a map.\n-        let class_fields = ty::lookup_class_fields(tcx, class_id);\n-        let class_field_map = HashMap();\n-        let mut fields_found = 0;\n-        for class_fields.each |field| {\n-            // XXX: Check visibility here.\n-            class_field_map.insert(field.ident, (field.id, false));\n-        }\n-\n-        // Typecheck each field.\n-        for fields.each |field| {\n-            match class_field_map.find(field.node.ident) {\n-                None => {\n-                    tcx.sess.span_err(\n-                        field.span,\n-                        fmt!(\"structure has no field named field named `%s`\",\n-                             tcx.sess.str_of(field.node.ident)));\n-                }\n-                Some((_, true)) => {\n-                    tcx.sess.span_err(\n-                        field.span,\n-                        fmt!(\"field `%s` specified more than once\",\n-                             tcx.sess.str_of(field.node.ident)));\n-                }\n-                Some((field_id, false)) => {\n-                    let expected_field_type =\n-                        ty::lookup_field_type(tcx, class_id, field_id,\n-                                              &substitutions);\n-                    bot |= check_expr(fcx,\n-                                      field.node.expr,\n-                                      Some(expected_field_type));\n-                    fields_found += 1;\n-                }\n-            }\n-        }\n-\n-        match base_expr {\n-            None => {\n-                // Make sure the programmer specified all the fields.\n-                assert fields_found <= class_fields.len();\n-                if fields_found < class_fields.len() {\n-                    let mut missing_fields = ~[];\n-                    for class_fields.each |class_field| {\n-                        let name = class_field.ident;\n-                        let (_, seen) = class_field_map.get(name);\n-                        if !seen {\n-                            missing_fields.push(\n-                                ~\"`\" + tcx.sess.str_of(name) + ~\"`\");\n-                        }\n-                    }\n-\n-                    tcx.sess.span_err(expr.span,\n-                                      fmt!(\"missing field%s: %s\",\n-                                           if missing_fields.len() == 1 {\n-                                               ~\"\"\n-                                           } else {\n-                                               ~\"s\"\n-                                           },\n-                                           str::connect(missing_fields,\n-                                                        ~\", \")));\n-                }\n-            }\n-            Some(base_expr) => {\n-                // Just check the base expression.\n-                check_expr(fcx, base_expr, Some(struct_type));\n-            }\n-        }\n-\n-        // Write in the resulting type.\n-        fcx.write_ty(id, struct_type);\n       }\n       ast::expr_field(base, field, tys) => {\n         bot = check_field(fcx, expr, false, base, field, tys);"}]}