{"sha": "9f98f725cb9ff3a31c330a4117ea1962d91d18f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmOThmNzI1Y2I5ZmYzYTMxYzMzMGE0MTE3ZWExOTYyZDkxZDE4ZjY=", "commit": {"author": {"name": "Ga\u00ebtan Cassiers", "email": "gaetan.cassiers@gmail.com", "date": "2016-01-10T14:12:15Z"}, "committer": {"name": "Ga\u00ebtan Cassiers", "email": "gaetan.cassiers@gmail.com", "date": "2016-01-10T14:20:58Z"}, "message": "Detect when comments disappear\n\nWhen the reformatted code doesn't contain the same quantity of comments\nas the original code, use the original code instead of the reformatted\ncode.\nThis is done for all expressions and `let` statements.\n\nThis should be used at the finest grained level possible, to avoid that\na small disappearing comment prevents a big chunk of code to be\nreformatted.\n\nKind of fixes (avoid disappearing comments, but prevents a good\nformatting is such case) #285 #225 #563 #743", "tree": {"sha": "a7f7ef7c47b1f594eac64fd1a644068b60a5dd7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7f7ef7c47b1f594eac64fd1a644068b60a5dd7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f98f725cb9ff3a31c330a4117ea1962d91d18f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f98f725cb9ff3a31c330a4117ea1962d91d18f6", "html_url": "https://github.com/rust-lang/rust/commit/9f98f725cb9ff3a31c330a4117ea1962d91d18f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f98f725cb9ff3a31c330a4117ea1962d91d18f6/comments", "author": {"login": "cassiersg", "id": 9348542, "node_id": "MDQ6VXNlcjkzNDg1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/9348542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cassiersg", "html_url": "https://github.com/cassiersg", "followers_url": "https://api.github.com/users/cassiersg/followers", "following_url": "https://api.github.com/users/cassiersg/following{/other_user}", "gists_url": "https://api.github.com/users/cassiersg/gists{/gist_id}", "starred_url": "https://api.github.com/users/cassiersg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cassiersg/subscriptions", "organizations_url": "https://api.github.com/users/cassiersg/orgs", "repos_url": "https://api.github.com/users/cassiersg/repos", "events_url": "https://api.github.com/users/cassiersg/events{/privacy}", "received_events_url": "https://api.github.com/users/cassiersg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cassiersg", "id": 9348542, "node_id": "MDQ6VXNlcjkzNDg1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/9348542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cassiersg", "html_url": "https://github.com/cassiersg", "followers_url": "https://api.github.com/users/cassiersg/followers", "following_url": "https://api.github.com/users/cassiersg/following{/other_user}", "gists_url": "https://api.github.com/users/cassiersg/gists{/gist_id}", "starred_url": "https://api.github.com/users/cassiersg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cassiersg/subscriptions", "organizations_url": "https://api.github.com/users/cassiersg/orgs", "repos_url": "https://api.github.com/users/cassiersg/repos", "events_url": "https://api.github.com/users/cassiersg/events{/privacy}", "received_events_url": "https://api.github.com/users/cassiersg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66abad9445efab576eecbc5aef1dd2768c801926", "url": "https://api.github.com/repos/rust-lang/rust/commits/66abad9445efab576eecbc5aef1dd2768c801926", "html_url": "https://github.com/rust-lang/rust/commit/66abad9445efab576eecbc5aef1dd2768c801926"}], "stats": {"total": 320, "additions": 277, "deletions": 43}, "files": [{"sha": "3f716d9039ca0ac31861d4de7ff1d025c5d6fa48", "filename": "src/comment.rs", "status": "modified", "additions": 225, "deletions": 37, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/9f98f725cb9ff3a31c330a4117ea1962d91d18f6/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f98f725cb9ff3a31c330a4117ea1962d91d18f6/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=9f98f725cb9ff3a31c330a4117ea1962d91d18f6", "patch": "@@ -8,13 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Format comments.\n+// Formatting and tools for comments.\n \n-use std::iter;\n+use std::{self, iter};\n+\n+use syntax::codemap::Span;\n \n use Indent;\n use config::Config;\n+use rewrite::RewriteContext;\n use string::{StringFormat, rewrite_string};\n+use utils::wrap_str;\n \n pub fn rewrite_comment(orig: &str,\n                        block_style: bool,\n@@ -150,7 +154,7 @@ impl FindUncommented for str {\n                 }\n                 Some(c) => {\n                     match kind {\n-                        CodeCharKind::Normal if b == c => {}\n+                        FullCodeCharKind::Normal if b == c => {}\n                         _ => {\n                             needle_iter = pat.chars();\n                         }\n@@ -174,7 +178,7 @@ impl FindUncommented for str {\n pub fn find_comment_end(s: &str) -> Option<usize> {\n     let mut iter = CharClasses::new(s.char_indices());\n     for (kind, (i, _c)) in &mut iter {\n-        if kind == CodeCharKind::Normal {\n+        if kind == FullCodeCharKind::Normal {\n             return Some(i);\n         }\n     }\n@@ -189,7 +193,7 @@ pub fn find_comment_end(s: &str) -> Option<usize> {\n \n /// Returns true if text contains any comment.\n pub fn contains_comment(text: &str) -> bool {\n-    CharClasses::new(text.chars()).any(|(kind, _)| kind == CodeCharKind::Comment)\n+    CharClasses::new(text.chars()).any(|(kind, _)| kind.is_comment())\n }\n \n struct CharClasses<T>\n@@ -240,6 +244,33 @@ pub enum CodeCharKind {\n     Comment,\n }\n \n+#[derive(PartialEq, Eq, Debug, Clone, Copy)]\n+enum FullCodeCharKind {\n+    Normal,\n+    StartComment,\n+    InComment,\n+    EndComment,\n+}\n+\n+impl FullCodeCharKind {\n+    fn is_comment(&self) -> bool {\n+        match *self {\n+            FullCodeCharKind::Normal => false,\n+            FullCodeCharKind::StartComment |\n+            FullCodeCharKind::InComment |\n+            FullCodeCharKind::EndComment => true,\n+        }\n+    }\n+\n+    fn to_codecharkind(&self) -> CodeCharKind {\n+        if self.is_comment() {\n+            CodeCharKind::Comment\n+        } else {\n+            CodeCharKind::Normal\n+        }\n+    }\n+}\n+\n impl<T> CharClasses<T>\n     where T: Iterator,\n           T::Item: RichChar\n@@ -256,9 +287,9 @@ impl<T> Iterator for CharClasses<T>\n     where T: Iterator,\n           T::Item: RichChar\n {\n-    type Item = (CodeCharKind, T::Item);\n+    type Item = (FullCodeCharKind, T::Item);\n \n-    fn next(&mut self) -> Option<(CodeCharKind, T::Item)> {\n+    fn next(&mut self) -> Option<(FullCodeCharKind, T::Item)> {\n         let item = try_opt!(self.base.next());\n         let chr = item.get_char();\n         self.status = match self.status {\n@@ -286,11 +317,11 @@ impl<T> Iterator for CharClasses<T>\n                         match self.base.peek() {\n                             Some(next) if next.get_char() == '*' => {\n                                 self.status = CharClassesStatus::BlockCommentOpening(1);\n-                                return Some((CodeCharKind::Comment, item));\n+                                return Some((FullCodeCharKind::StartComment, item));\n                             }\n                             Some(next) if next.get_char() == '/' => {\n                                 self.status = CharClassesStatus::LineComment;\n-                                return Some((CodeCharKind::Comment, item));\n+                                return Some((FullCodeCharKind::StartComment, item));\n                             }\n                             _ => CharClassesStatus::Normal,\n                         }\n@@ -299,12 +330,7 @@ impl<T> Iterator for CharClasses<T>\n                 }\n             }\n             CharClassesStatus::BlockComment(deepness) => {\n-                if deepness == 0 {\n-                    // This is the closing '/'\n-                    assert_eq!(chr, '/');\n-                    self.status = CharClassesStatus::Normal;\n-                    return Some((CodeCharKind::Comment, item));\n-                }\n+                assert!(deepness != 0);\n                 self.status = match self.base.peek() {\n                     Some(next) if next.get_char() == '/' && chr == '*' => {\n                         CharClassesStatus::BlockCommentClosing(deepness - 1)\n@@ -314,34 +340,92 @@ impl<T> Iterator for CharClasses<T>\n                     }\n                     _ => CharClassesStatus::BlockComment(deepness),\n                 };\n-                return Some((CodeCharKind::Comment, item));\n+                return Some((FullCodeCharKind::InComment, item));\n             }\n             CharClassesStatus::BlockCommentOpening(deepness) => {\n                 assert_eq!(chr, '*');\n                 self.status = CharClassesStatus::BlockComment(deepness);\n-                return Some((CodeCharKind::Comment, item));\n+                return Some((FullCodeCharKind::InComment, item));\n             }\n             CharClassesStatus::BlockCommentClosing(deepness) => {\n                 assert_eq!(chr, '/');\n-                self.status = if deepness == 0 {\n-                    CharClassesStatus::Normal\n+                if deepness == 0 {\n+                    self.status = CharClassesStatus::Normal;\n+                    return Some((FullCodeCharKind::EndComment, item));\n                 } else {\n-                    CharClassesStatus::BlockComment(deepness)\n-                };\n-                return Some((CodeCharKind::Comment, item));\n+                    self.status = CharClassesStatus::BlockComment(deepness);\n+                    return Some((FullCodeCharKind::InComment, item));\n+                }\n             }\n             CharClassesStatus::LineComment => {\n-                self.status = match chr {\n-                    '\\n' => CharClassesStatus::Normal,\n-                    _ => CharClassesStatus::LineComment,\n-                };\n-                return Some((CodeCharKind::Comment, item));\n+                match chr {\n+                    '\\n' => {\n+                        self.status = CharClassesStatus::Normal;\n+                        return Some((FullCodeCharKind::EndComment, item));\n+                    }\n+                    _ => {\n+                        self.status = CharClassesStatus::LineComment;\n+                        return Some((FullCodeCharKind::InComment, item));\n+                    }\n+                }\n+            }\n+        };\n+        Some((FullCodeCharKind::Normal, item))\n+    }\n+}\n+\n+/// Iterator over functional and commented parts of a string. Any part of a string is either\n+/// functional code, either *one* block comment, either *one* line comment. Whitespace between\n+/// comments is functional code. Line comments contain their ending newlines.\n+struct UngroupedCommentCodeSlices<'a> {\n+    slice: &'a str,\n+    iter: iter::Peekable<CharClasses<std::str::CharIndices<'a>>>,\n+}\n+\n+impl<'a> UngroupedCommentCodeSlices<'a> {\n+    fn new(code: &'a str) -> UngroupedCommentCodeSlices<'a> {\n+        UngroupedCommentCodeSlices {\n+            slice: code,\n+            iter: CharClasses::new(code.char_indices()).peekable(),\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator for UngroupedCommentCodeSlices<'a> {\n+    type Item = (CodeCharKind, usize, &'a str);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let (kind, (start_idx, _)) = try_opt!(self.iter.next());\n+        match kind {\n+            FullCodeCharKind::Normal => {\n+                // Consume all the Normal code\n+                while let Some(&(FullCodeCharKind::Normal, (_, _))) = self.iter.peek() {\n+                    let _ = self.iter.next();\n+                }\n             }\n+            FullCodeCharKind::StartComment => {\n+                // Consume the whole comment\n+                while let Some((FullCodeCharKind::InComment, (_, _))) = self.iter.next() {}\n+            }\n+            _ => panic!(),\n+        }\n+        let slice = match self.iter.peek() {\n+            Some(&(_, (end_idx, _))) => &self.slice[start_idx..end_idx],\n+            None => &self.slice[start_idx..],\n         };\n-        Some((CodeCharKind::Normal, item))\n+        Some((if kind.is_comment() {\n+            CodeCharKind::Comment\n+        } else {\n+            CodeCharKind::Normal\n+        },\n+              start_idx,\n+              slice))\n     }\n }\n \n+\n+\n+\n /// Iterator over an alternating sequence of functional and commented parts of\n /// a string. The first item is always a, possibly zero length, subslice of\n /// functional text. Line style comments contain their ending newlines.\n@@ -383,7 +467,7 @@ impl<'a> Iterator for CommentCodeSlices<'a> {\n                 first_whitespace = Some(i);\n             }\n \n-            if kind == self.last_slice_kind && !is_comment_connector {\n+            if kind.to_codecharkind() == self.last_slice_kind && !is_comment_connector {\n                 let last_index = match first_whitespace {\n                     Some(j) => j,\n                     None => i,\n@@ -419,20 +503,124 @@ impl<'a> Iterator for CommentCodeSlices<'a> {\n     }\n }\n \n+/// Checks is `new` didn't miss any comment from `span`, if it removed any, return previous text\n+/// (if it fits in the width/offset, else return None), else return `new`\n+pub fn recover_comment_removed(new: String,\n+                               span: Span,\n+                               context: &RewriteContext,\n+                               width: usize,\n+                               offset: Indent)\n+                               -> Option<String> {\n+    let snippet = context.snippet(span);\n+    if changed_comment_content(&snippet, &new) {\n+        // We missed some comments\n+        // Keep previous formatting if it satisfies the constrains\n+        return wrap_str(snippet, context.config.max_width, width, offset);\n+    } else {\n+        Some(new)\n+    }\n+}\n+\n+/// Return true if the two strings of code have the same payload of comments.\n+/// The payload of comments is everything in the string except:\n+/// \t- actual code (not comments)\n+/// \t- comment start/end marks\n+///\t\t- whitespace\n+///\t\t- '*' at the beginning of lines in block comments\n+fn changed_comment_content(orig: &str, new: &str) -> bool {\n+    // Cannot write this as a fn since we cannot return types containing closures\n+    let code_comment_content = |code| {\n+        let slices = UngroupedCommentCodeSlices::new(code);\n+        slices.filter(|&(ref kind, _, _)| *kind == CodeCharKind::Comment)\n+              .flat_map(|(_, _, s)| CommentReducer::new(s))\n+    };\n+    let res = code_comment_content(orig).ne(code_comment_content(new));\n+    debug!(\"comment::changed_comment_content: {}\\norig: '{}'\\nnew: '{}'\\nraw_old: {}\\nraw_new: {}\",\n+           res,\n+           orig,\n+           new,\n+           code_comment_content(orig).collect::<String>(),\n+           code_comment_content(new).collect::<String>());\n+    res\n+}\n+\n+\n+/// Iterator over the 'payload' characters of a comment.\n+/// It skips whitespace, comment start/end marks, and '*' at the beginning of lines.\n+/// The comment must be one comment, ie not more than one start mark (no multiple line comments,\n+/// for example).\n+struct CommentReducer<'a> {\n+    is_block: bool,\n+    at_start_line: bool,\n+    iter: std::str::Chars<'a>,\n+}\n+\n+impl<'a> CommentReducer<'a> {\n+    fn new(comment: &'a str) -> CommentReducer<'a> {\n+        let is_block = comment.starts_with(\"/*\");\n+        let comment = remove_comment_header(comment);\n+        CommentReducer {\n+            is_block: is_block,\n+            at_start_line: false, // There are no supplementary '*' on the first line\n+            iter: comment.chars(),\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator for CommentReducer<'a> {\n+    type Item = char;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        loop {\n+            let mut c = try_opt!(self.iter.next());\n+            if self.is_block && self.at_start_line {\n+                while c.is_whitespace() {\n+                    c = try_opt!(self.iter.next());\n+                }\n+                // Ignore leading '*'\n+                if c == '*' {\n+                    c = try_opt!(self.iter.next());\n+                }\n+            } else {\n+                if c == '\\n' {\n+                    self.at_start_line = true;\n+                }\n+            }\n+            if !c.is_whitespace() {\n+                return Some(c);\n+            }\n+        }\n+    }\n+}\n+\n+\n+fn remove_comment_header(comment: &str) -> &str {\n+    if comment.starts_with(\"///\") || comment.starts_with(\"//!\") {\n+        &comment[3..]\n+    } else if comment.starts_with(\"//\") {\n+        &comment[2..]\n+    } else if comment.starts_with(\"/**\") || comment.starts_with(\"/*!\") {\n+        &comment[3..comment.len() - 2]\n+    } else {\n+        assert!(comment.starts_with(\"/*\"),\n+                format!(\"string '{}' is not a comment\", comment));\n+        &comment[2..comment.len() - 2]\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n-    use super::{CharClasses, CodeCharKind, contains_comment, rewrite_comment, FindUncommented,\n-                CommentCodeSlices};\n+    use super::{CharClasses, CodeCharKind, FullCodeCharKind, contains_comment, rewrite_comment,\n+                FindUncommented, CommentCodeSlices};\n     use Indent;\n \n     #[test]\n     fn char_classes() {\n         let mut iter = CharClasses::new(\"//\\n\\n\".chars());\n \n-        assert_eq!((CodeCharKind::Comment, '/'), iter.next().unwrap());\n-        assert_eq!((CodeCharKind::Comment, '/'), iter.next().unwrap());\n-        assert_eq!((CodeCharKind::Comment, '\\n'), iter.next().unwrap());\n-        assert_eq!((CodeCharKind::Normal, '\\n'), iter.next().unwrap());\n+        assert_eq!((FullCodeCharKind::StartComment, '/'), iter.next().unwrap());\n+        assert_eq!((FullCodeCharKind::InComment, '/'), iter.next().unwrap());\n+        assert_eq!((FullCodeCharKind::EndComment, '\\n'), iter.next().unwrap());\n+        assert_eq!((FullCodeCharKind::Normal, '\\n'), iter.next().unwrap());\n         assert_eq!(None, iter.next());\n     }\n \n@@ -507,8 +695,8 @@ mod test {\n         CharClasses::new(text.chars())\n             .filter_map(|(s, c)| {\n                 match s {\n-                    CodeCharKind::Normal => Some(c),\n-                    CodeCharKind::Comment => None,\n+                    FullCodeCharKind::Normal => Some(c),\n+                    _ => None,\n                 }\n             })\n             .collect()"}, {"sha": "269e45f9e9fb21d26ba4d99b290e07a6b01aae87", "filename": "src/expr.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f98f725cb9ff3a31c330a4117ea1962d91d18f6/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f98f725cb9ff3a31c330a4117ea1962d91d18f6/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=9f98f725cb9ff3a31c330a4117ea1962d91d18f6", "patch": "@@ -23,7 +23,7 @@ use utils::{span_after, extra_offset, last_line_width, wrap_str, binary_search,\n             semicolon_for_stmt};\n use visitor::FmtVisitor;\n use config::{Config, StructLitStyle, MultilineStyle};\n-use comment::{FindUncommented, rewrite_comment, contains_comment};\n+use comment::{FindUncommented, rewrite_comment, contains_comment, recover_comment_removed};\n use types::rewrite_path;\n use items::{span_lo_for_arg, span_hi_for_arg};\n use chains::rewrite_chain;\n@@ -35,7 +35,7 @@ use syntax::visit::Visitor;\n \n impl Rewrite for ast::Expr {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n-        match self.node {\n+        let result = match self.node {\n             ast::Expr_::ExprVec(ref expr_vec) => {\n                 rewrite_array(expr_vec.iter().map(|e| &**e),\n                               mk_sp(span_after(self.span, \"[\", context.codemap), self.span.hi),\n@@ -207,7 +207,8 @@ impl Rewrite for ast::Expr {\n                          width,\n                          offset)\n             }\n-        }\n+        };\n+        result.and_then(|res| recover_comment_removed(res, self.span, context, width, offset))\n     }\n }\n \n@@ -478,7 +479,7 @@ impl Rewrite for ast::Block {\n \n impl Rewrite for ast::Stmt {\n     fn rewrite(&self, context: &RewriteContext, _width: usize, offset: Indent) -> Option<String> {\n-        match self.node {\n+        let result = match self.node {\n             ast::Stmt_::StmtDecl(ref decl, _) => {\n                 if let ast::Decl_::DeclLocal(ref local) = decl.node {\n                     local.rewrite(context, context.config.max_width, offset)\n@@ -499,7 +500,8 @@ impl Rewrite for ast::Stmt {\n                   .map(|s| s + suffix)\n             }\n             ast::Stmt_::StmtMac(..) => None,\n-        }\n+        };\n+        result.and_then(|res| recover_comment_removed(res, self.span, context, _width, offset))\n     }\n }\n "}, {"sha": "af61ba89b1cb613a6406171dc46719b09d3d88fb", "filename": "tests/source/paths.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f98f725cb9ff3a31c330a4117ea1962d91d18f6/tests%2Fsource%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f98f725cb9ff3a31c330a4117ea1962d91d18f6/tests%2Fsource%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fpaths.rs?ref=9f98f725cb9ff3a31c330a4117ea1962d91d18f6", "patch": "@@ -17,7 +17,8 @@ fn main() {\n \n     < *mut JSObject >:: relocate(entry);\n \n-    let x: Foo/*::*/<A   >;\n+    let x: Foo<A   >;\n+    let x: Foo/*::*/<A>;\n }\n \n fn op(foo: Bar, key : &[u8], upd : Fn(Option<&memcache::Item> , Baz  ) -> Result) -> MapResult {}"}, {"sha": "23c00c418be47d598d0dcbe800ddc49b7e96615d", "filename": "tests/target/comment-not-disappear.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9f98f725cb9ff3a31c330a4117ea1962d91d18f6/tests%2Ftarget%2Fcomment-not-disappear.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f98f725cb9ff3a31c330a4117ea1962d91d18f6/tests%2Ftarget%2Fcomment-not-disappear.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcomment-not-disappear.rs?ref=9f98f725cb9ff3a31c330a4117ea1962d91d18f6", "patch": "@@ -0,0 +1,42 @@\n+// All the comments here should not disappear.\n+\n+fn a() {\n+    match x {\n+        X |\n+        // A comment\n+        Y => {}\n+    };\n+}\n+\n+fn b() {\n+    match x {\n+        X =>\n+            // A comment\n+            y\n+    }\n+}\n+\n+fn c() {\n+    a() /* ... */;\n+}\n+\n+fn foo() -> Vec<i32> {\n+    (0..11)\n+        .map(|x|\n+        // This comment disappears.\n+        if x % 2 == 0 { x } else { x * 2 })\n+        .collect()\n+}\n+\n+fn d() {\n+    if true /* and ... */ {\n+        a();\n+    }\n+}\n+\n+fn calc_page_len(prefix_len: usize, sofar: usize) -> usize {\n+    2 // page type and flags\n+    + 1 // stored depth\n+    + 2 // stored count\n+    + prefix_len + sofar // sum of size of all the actual items\n+}"}, {"sha": "adae879e647cb957d3927cc2749fd62ed80efb71", "filename": "tests/target/paths.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f98f725cb9ff3a31c330a4117ea1962d91d18f6/tests%2Ftarget%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f98f725cb9ff3a31c330a4117ea1962d91d18f6/tests%2Ftarget%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fpaths.rs?ref=9f98f725cb9ff3a31c330a4117ea1962d91d18f6", "patch": "@@ -17,6 +17,7 @@ fn main() {\n     <*mut JSObject>::relocate(entry);\n \n     let x: Foo<A>;\n+    let x: Foo/*::*/<A>;\n }\n \n fn op(foo: Bar, key: &[u8], upd: Fn(Option<&memcache::Item>, Baz) -> Result) -> MapResult {}"}]}