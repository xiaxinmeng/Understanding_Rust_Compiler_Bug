{"sha": "cd6300e938f24f9ae830cd984b83112af0b2ccdc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNjMwMGU5MzhmMjRmOWFlODMwY2Q5ODRiODMxMTJhZjBiMmNjZGM=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-11-27T06:22:22Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-11-27T06:22:22Z"}, "message": "libstd: turn time::Tm and time::Timespec into structs\n\nThis avoids #4044 by not using the enum wrapper, and turning Tm_\ndirectly into a struct. Along the way it modernizes the codebase\nto eliminate no-implicit-copies warnings.", "tree": {"sha": "daa5068bdf37018e3759f510d5b0499dad3d545f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/daa5068bdf37018e3759f510d5b0499dad3d545f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd6300e938f24f9ae830cd984b83112af0b2ccdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6300e938f24f9ae830cd984b83112af0b2ccdc", "html_url": "https://github.com/rust-lang/rust/commit/cd6300e938f24f9ae830cd984b83112af0b2ccdc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd6300e938f24f9ae830cd984b83112af0b2ccdc/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a18f0d413c1acea7c94e7e89740f47716f8efc51", "url": "https://api.github.com/repos/rust-lang/rust/commits/a18f0d413c1acea7c94e7e89740f47716f8efc51", "html_url": "https://github.com/rust-lang/rust/commit/a18f0d413c1acea7c94e7e89740f47716f8efc51"}], "stats": {"total": 372, "additions": 177, "deletions": 195}, "files": [{"sha": "f4530a28633869c32cc4d6b91a7dab1dc846703e", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6300e938f24f9ae830cd984b83112af0b2ccdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6300e938f24f9ae830cd984b83112af0b2ccdc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=cd6300e938f24f9ae830cd984b83112af0b2ccdc", "patch": "@@ -1643,7 +1643,7 @@ fn trans_fn(ccx: @crate_ctxt,\n             impl_id: Option<ast::def_id>) {\n     let do_time = ccx.sess.trans_stats();\n     let start = if do_time { time::get_time() }\n-                else { {sec: 0i64, nsec: 0i32} };\n+                else { time::Timespec::new(0, 0) };\n     debug!(\"trans_fn(ty_self=%?)\", ty_self);\n     let _icx = ccx.insn_ctxt(\"trans_fn\");\n     ccx.stats.n_fns += 1;"}, {"sha": "6fb36aae7d4ed912f52e63b981cea37df460c66e", "filename": "src/libstd/std.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cd6300e938f24f9ae830cd984b83112af0b2ccdc/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6300e938f24f9ae830cd984b83112af0b2ccdc/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=cd6300e938f24f9ae830cd984b83112af0b2ccdc", "patch": "@@ -0,0 +1,7 @@\n+// A curious inner-module that's not exported that contains the binding\n+// 'std' so that macro-expanded references to std::serialization and such\n+// can be resolved within libcore.\n+#[doc(hidden)] // FIXME #3538\n+mod std {\n+    pub use serialization;\n+}"}, {"sha": "921fad449c2d91e22bd27ed755f682b703385c2a", "filename": "src/libstd/time.rs", "status": "modified", "additions": 169, "deletions": 194, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/cd6300e938f24f9ae830cd984b83112af0b2ccdc/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6300e938f24f9ae830cd984b83112af0b2ccdc/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=cd6300e938f24f9ae830cd984b83112af0b2ccdc", "patch": "@@ -4,10 +4,6 @@ use core::cmp::Eq;\n use libc::{c_char, c_int, c_long, size_t, time_t};\n use io::{Reader, ReaderUtil};\n use result::{Result, Ok, Err};\n-use serialization::{Serializable,\n-                         Deserializable,\n-                         Serializer,\n-                         Deserializer};\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n@@ -25,23 +21,31 @@ extern mod rustrt {\n }\n \n /// A record specifying a time value in seconds and nanoseconds.\n-pub type Timespec = {sec: i64, nsec: i32};\n+#[auto_serialize]\n+#[auto_deserialize]\n+pub struct Timespec { sec: i64, nsec: i32 }\n+\n+impl Timespec {\n+    static fn new(sec: i64, nsec: i32) -> Timespec {\n+        Timespec { sec: sec, nsec: nsec }\n+    }\n+}\n \n impl Timespec : Eq {\n     #[cfg(stage0)]\n     pure fn eq(other: &Timespec) -> bool {\n-        self.sec == (*other).sec && self.nsec == (*other).nsec\n+        self.sec == other.sec && self.nsec == other.nsec\n     }\n     #[cfg(stage1)]\n     #[cfg(stage2)]\n     pure fn eq(&self, other: &Timespec) -> bool {\n-        (*self).sec == (*other).sec && (*self).nsec == (*other).nsec\n+        self.sec == other.sec && self.nsec == other.nsec\n     }\n     #[cfg(stage0)]\n     pure fn ne(other: &Timespec) -> bool { !self.eq(other) }\n     #[cfg(stage1)]\n     #[cfg(stage2)]\n-    pure fn ne(&self, other: &Timespec) -> bool { !(*self).eq(other) }\n+    pure fn ne(&self, other: &Timespec) -> bool { !self.eq(other) }\n }\n \n /**\n@@ -52,7 +56,7 @@ pub fn get_time() -> Timespec {\n     let mut sec = 0i64;\n     let mut nsec = 0i32;\n     rustrt::get_time(&mut sec, &mut nsec);\n-    return {sec: sec, nsec: nsec};\n+    return Timespec::new(sec, nsec);\n }\n \n \n@@ -79,64 +83,26 @@ pub fn tzset() {\n     rustrt::rust_tzset();\n }\n \n-pub struct Tm_ {\n-    pub tm_sec: i32, // seconds after the minute ~[0-60]\n-    pub tm_min: i32, // minutes after the hour ~[0-59]\n-    pub tm_hour: i32, // hours after midnight ~[0-23]\n-    pub tm_mday: i32, // days of the month ~[1-31]\n-    pub tm_mon: i32, // months since January ~[0-11]\n-    pub tm_year: i32, // years since 1900\n-    pub tm_wday: i32, // days since Sunday ~[0-6]\n-    pub tm_yday: i32, // days since January 1 ~[0-365]\n-    pub tm_isdst: i32, // Daylight Savings Time flag\n-    pub tm_gmtoff: i32, // offset from UTC in seconds\n-    pub tm_zone: ~str, // timezone abbreviation\n-    pub tm_nsec: i32, // nanoseconds\n+#[auto_serialize]\n+#[auto_deserialize]\n+pub struct Tm {\n+    tm_sec: i32, // seconds after the minute ~[0-60]\n+    tm_min: i32, // minutes after the hour ~[0-59]\n+    tm_hour: i32, // hours after midnight ~[0-23]\n+    tm_mday: i32, // days of the month ~[1-31]\n+    tm_mon: i32, // months since January ~[0-11]\n+    tm_year: i32, // years since 1900\n+    tm_wday: i32, // days since Sunday ~[0-6]\n+    tm_yday: i32, // days since January 1 ~[0-365]\n+    tm_isdst: i32, // Daylight Savings Time flag\n+    tm_gmtoff: i32, // offset from UTC in seconds\n+    tm_zone: ~str, // timezone abbreviation\n+    tm_nsec: i32, // nanoseconds\n }\n \n-impl<S: Serializer> Tm_: Serializable<S> {\n-    fn serialize(&self, s: &S) {\n-       s.emit_i32(self.tm_sec);\n-        s.emit_i32(self.tm_min);\n-        s.emit_i32(self.tm_hour);\n-        s.emit_i32(self.tm_mday);\n-        s.emit_i32(self.tm_mon);\n-        s.emit_i32(self.tm_year);\n-        s.emit_i32(self.tm_wday);\n-        s.emit_i32(self.tm_yday);\n-        s.emit_i32(self.tm_isdst);\n-        s.emit_i32(self.tm_gmtoff);\n-        s.emit_owned_str(self.tm_zone);\n-        s.emit_i32(self.tm_nsec);\n-    }\n-}\n-\n-pub fn deserialize_tm_<D: Deserializer>(d: &D) -> Tm_ {\n-   Tm_ {\n-        tm_sec: d.read_i32(),\n-        tm_min: d.read_i32(),\n-        tm_hour: d.read_i32(),\n-        tm_mday: d.read_i32(),\n-        tm_mon: d.read_i32(),\n-        tm_year: d.read_i32(),\n-        tm_wday: d.read_i32(),\n-        tm_yday: d.read_i32(),\n-        tm_isdst: d.read_i32(),\n-        tm_gmtoff: d.read_i32(),\n-        tm_zone: d.read_owned_str(),\n-        tm_nsec: d.read_i32(),\n-   }\n-}\n-\n-impl<D: Deserializer> Tm_: Deserializable<D> {\n-    static fn deserialize(d: &D) -> Tm_ {\n-       deserialize_tm_(d)\n-    }\n-}\n-\n-impl Tm_ : Eq {\n+impl Tm : Eq {\n     #[cfg(stage0)]\n-    pure fn eq(other: &Tm_) -> bool {\n+    pure fn eq(other: &Tm) -> bool {\n         self.tm_sec == (*other).tm_sec &&\n         self.tm_min == (*other).tm_min &&\n         self.tm_hour == (*other).tm_hour &&\n@@ -152,63 +118,29 @@ impl Tm_ : Eq {\n     }\n     #[cfg(stage1)]\n     #[cfg(stage2)]\n-    pure fn eq(&self, other: &Tm_) -> bool {\n-        (*self).tm_sec == (*other).tm_sec &&\n-        (*self).tm_min == (*other).tm_min &&\n-        (*self).tm_hour == (*other).tm_hour &&\n-        (*self).tm_mday == (*other).tm_mday &&\n-        (*self).tm_mon == (*other).tm_mon &&\n-        (*self).tm_year == (*other).tm_year &&\n-        (*self).tm_wday == (*other).tm_wday &&\n-        (*self).tm_yday == (*other).tm_yday &&\n-        (*self).tm_isdst == (*other).tm_isdst &&\n-        (*self).tm_gmtoff == (*other).tm_gmtoff &&\n-        (*self).tm_zone == (*other).tm_zone &&\n-        (*self).tm_nsec == (*other).tm_nsec\n-    }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Tm_) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn ne(&self, other: &Tm_) -> bool { !(*self).eq(other) }\n-}\n-\n-pub enum Tm {\n-    Tm_(Tm_)\n-}\n-\n-impl<S: Serializer> Tm: Serializable<S> {\n-    fn serialize(&self, s: &S) {\n-        let t: Tm_ = **self;\n-        t.serialize(s);\n-    }\n-}\n-\n-pub fn deserialize_tm<D: Deserializer>(d: &D) -> Tm {\n-    Tm_(deserialize_tm_(d))\n-}\n-\n-impl<D: Deserializer> Tm: Deserializable<D> {\n-    static fn deserialize(d: &D) -> Tm {\n-       deserialize_tm(d)\n+    pure fn eq(&self, other: &Tm) -> bool {\n+        self.tm_sec == (*other).tm_sec &&\n+        self.tm_min == (*other).tm_min &&\n+        self.tm_hour == (*other).tm_hour &&\n+        self.tm_mday == (*other).tm_mday &&\n+        self.tm_mon == (*other).tm_mon &&\n+        self.tm_year == (*other).tm_year &&\n+        self.tm_wday == (*other).tm_wday &&\n+        self.tm_yday == (*other).tm_yday &&\n+        self.tm_isdst == (*other).tm_isdst &&\n+        self.tm_gmtoff == (*other).tm_gmtoff &&\n+        self.tm_zone == (*other).tm_zone &&\n+        self.tm_nsec == (*other).tm_nsec\n     }\n-}\n-\n-impl Tm : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Tm) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn eq(&self, other: &Tm) -> bool { *(*self) == *(*other) }\n     #[cfg(stage0)]\n-    pure fn ne(other: &Tm) -> bool { *self != *(*other) }\n+    pure fn ne(other: &Tm) -> bool { !self.eq(other) }\n     #[cfg(stage1)]\n     #[cfg(stage2)]\n-    pure fn ne(&self, other: &Tm) -> bool { *(*self) != *(*other) }\n+    pure fn ne(&self, other: &Tm) -> bool { !self.eq(other) }\n }\n \n pub pure fn empty_tm() -> Tm {\n-    Tm_(Tm_{\n+    Tm {\n         tm_sec: 0_i32,\n         tm_min: 0_i32,\n         tm_hour: 0_i32,\n@@ -221,15 +153,15 @@ pub pure fn empty_tm() -> Tm {\n         tm_gmtoff: 0_i32,\n         tm_zone: ~\"\",\n         tm_nsec: 0_i32,\n-    })\n+    }\n }\n \n /// Returns the specified time in UTC\n pub fn at_utc(clock: Timespec) -> Tm {\n-    let mut {sec, nsec} = clock;\n+    let mut Timespec { sec, nsec } = clock;\n     let mut tm = empty_tm();\n     rustrt::rust_gmtime(sec, nsec, tm);\n-    tm\n+    move tm\n }\n \n /// Returns the current time in UTC\n@@ -239,10 +171,10 @@ pub fn now_utc() -> Tm {\n \n /// Returns the specified time in the local timezone\n pub fn at(clock: Timespec) -> Tm {\n-    let mut {sec, nsec} = clock;\n+    let mut Timespec { sec, nsec } = clock;\n     let mut tm = empty_tm();\n     rustrt::rust_localtime(sec, nsec, tm);\n-    tm\n+    move tm\n }\n \n /// Returns the current time in the local timezone\n@@ -258,10 +190,10 @@ pub pure fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n }\n \n /// Formats the time according to the format string.\n-pub pure fn strftime(format: &str, tm: Tm) -> ~str {\n+pub pure fn strftime(format: &str, tm: &Tm) -> ~str {\n     // unsafe only because do_strftime is annoying to make pure\n     // (it does IO with a str_reader)\n-    unsafe {do_strftime(format, tm)}\n+    move unsafe { do_strftime(format, tm) }\n }\n \n impl Tm {\n@@ -273,7 +205,7 @@ impl Tm {\n         } else {\n             rustrt::rust_mktime(self, &mut sec);\n         }\n-        { sec: sec, nsec: self.tm_nsec }\n+        Timespec::new(sec, self.tm_nsec)\n     }\n \n     /// Convert time to the local timezone\n@@ -293,7 +225,9 @@ impl Tm {\n     pure fn ctime() -> ~str { self.strftime(~\"%c\") }\n \n     /// Formats the time according to the format string.\n-    pure fn strftime(format: &str) -> ~str { strftime(format, self) }\n+    pure fn strftime(&self, format: &str) -> ~str {\n+        move strftime(format, self)\n+    }\n \n     /**\n      * Returns a time string formatted according to RFC 822.\n@@ -354,9 +288,9 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     fn match_strs(ss: &str, pos: uint, strs: &[(~str, i32)])\n       -> Option<(i32, uint)> {\n         let mut i = 0u;\n-        let len = vec::len(strs);\n+        let len = strs.len();\n         while i < len {\n-            let (needle, value) = strs[i];\n+            let &(needle, value) = &strs[i];\n \n             if match_str(ss, pos, needle) {\n                 return Some((value, pos + str::len(needle)));\n@@ -402,7 +336,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n         }\n     }\n \n-    fn parse_type(s: &str, pos: uint, ch: char, tm: &mut Tm_)\n+    fn parse_type(s: &str, pos: uint, ch: char, tm: &mut Tm)\n       -> Result<uint, ~str> {\n         match ch {\n           'A' => match match_strs(s, pos, ~[\n@@ -472,22 +406,36 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             None => Err(~\"Invalid year\")\n           },\n           'c' => {\n-            parse_type(s, pos, 'a', tm)\n-                .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'b', tm))\n-                .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'e', tm))\n-                .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'T', tm))\n-                .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'Y', tm))\n+                // FIXME(#3724): cleanup\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                    move parse_type(s, pos, 'a', tm),\n+                    |pos| parse_char(s, pos, ' ')),\n+                    |pos| parse_type(s, pos, 'b', tm)),\n+                    |pos| parse_char(s, pos, ' ')),\n+                    |pos| parse_type(s, pos, 'e', tm)),\n+                    |pos| parse_char(s, pos, ' ')),\n+                    |pos| parse_type(s, pos, 'T', tm)),\n+                    |pos| parse_char(s, pos, ' ')),\n+                    |pos| parse_type(s, pos, 'Y', tm))\n           }\n           'D' | 'x' => {\n-            parse_type(s, pos, 'm', tm)\n-                .chain(|pos| parse_char(s, pos, '/'))\n-                .chain(|pos| parse_type(s, pos, 'd', tm))\n-                .chain(|pos| parse_char(s, pos, '/'))\n-                .chain(|pos| parse_type(s, pos, 'y', tm))\n+                // FIXME(#3724): cleanup\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                    move parse_type(s, pos, 'm', tm),\n+                    |pos| parse_char(s, pos, '/')),\n+                    |pos| parse_type(s, pos, 'd', tm)),\n+                    |pos| parse_char(s, pos, '/')),\n+                    |pos| parse_type(s, pos, 'y', tm))\n           }\n           'd' => match match_digits(s, pos, 2u, false) {\n             Some(item) => { let (v, pos) = item; tm.tm_mday = v; Ok(pos) }\n@@ -498,11 +446,16 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             None => Err(~\"Invalid day of the month\")\n           },\n           'F' => {\n-            parse_type(s, pos, 'Y', tm)\n-                .chain(|pos| parse_char(s, pos, '-'))\n-                .chain(|pos| parse_type(s, pos, 'm', tm))\n-                .chain(|pos| parse_char(s, pos, '-'))\n-                .chain(|pos| parse_type(s, pos, 'd', tm))\n+                // FIXME(#3724): cleanup\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                    move parse_type(s, pos, 'Y', tm),\n+                    |pos| parse_char(s, pos, '-')),\n+                    |pos| parse_type(s, pos, 'm', tm)),\n+                    |pos| parse_char(s, pos, '-')),\n+                    |pos| parse_type(s, pos, 'd', tm))\n           }\n           'H' => {\n             // FIXME (#2350): range check.\n@@ -583,18 +536,28 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             None => Err(~\"Invalid hour\")\n           },\n           'R' => {\n-            parse_type(s, pos, 'H', tm)\n-                .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'M', tm))\n+                // FIXME(#3724): cleanup\n+                result::chain(\n+                result::chain(\n+                    move parse_type(s, pos, 'H', tm),\n+                    |pos| parse_char(s, pos, ':')),\n+                    |pos| parse_type(s, pos, 'M', tm))\n           }\n           'r' => {\n-            parse_type(s, pos, 'I', tm)\n-                .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'M', tm))\n-                .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'S', tm))\n-                .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'p', tm))\n+                // FIXME(#3724): cleanup\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                    move parse_type(s, pos, 'I', tm),\n+                    |pos| parse_char(s, pos, ':')),\n+                    |pos| parse_type(s, pos, 'M', tm)),\n+                    |pos| parse_char(s, pos, ':')),\n+                    |pos| parse_type(s, pos, 'S', tm)),\n+                    |pos| parse_char(s, pos, ' ')),\n+                    |pos| parse_type(s, pos, 'p', tm))\n           }\n           'S' => {\n             // FIXME (#2350): range check.\n@@ -609,11 +572,16 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           }\n           //'s' {}\n           'T' | 'X' => {\n-            parse_type(s, pos, 'H', tm)\n-                .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'M', tm))\n-                .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'S', tm))\n+                // FIXME(#3724): cleanup\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                    move parse_type(s, pos, 'H', tm),\n+                    |pos| parse_char(s, pos, ':')),\n+                    |pos| parse_type(s, pos, 'M', tm)),\n+                    |pos| parse_char(s, pos, ':')),\n+                    |pos| parse_type(s, pos, 'S', tm))\n           }\n           't' => parse_char(s, pos, '\\t'),\n           'u' => {\n@@ -628,11 +596,16 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             }\n           }\n           'v' => {\n-            parse_type(s, pos, 'e', tm)\n-                .chain(|pos| parse_char(s, pos, '-'))\n-                .chain(|pos| parse_type(s, pos, 'b', tm))\n-                .chain(|pos| parse_char(s, pos, '-'))\n-                .chain(|pos| parse_type(s, pos, 'Y', tm))\n+                // FIXME(#3724): cleanup\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                    move parse_type(s, pos, 'e', tm),\n+                    |pos| parse_char(s, pos, '-')),\n+                    |pos| parse_type(s, pos, 'b', tm)),\n+                    |pos| parse_char(s, pos, '-')),\n+                    |pos| parse_type(s, pos, 'Y', tm))\n           }\n           //'W' {}\n           'w' => {\n@@ -713,7 +686,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     }\n \n     do io::with_str_reader(str::from_slice(format)) |rdr| {\n-        let mut tm = Tm_ {\n+        let mut tm = Tm {\n             tm_sec: 0_i32,\n             tm_min: 0_i32,\n             tm_hour: 0_i32,\n@@ -735,19 +708,21 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             let {ch, next} = str::char_range_at(s, pos);\n \n             match rdr.read_char() {\n-              '%' => match parse_type(s, pos, rdr.read_char(), &mut tm) {\n-                Ok(next) => pos = next,\n-                  Err(copy e) => { result = Err(e); break; }\n-              },\n-              c => {\n-                if c != ch { break }\n-                pos = next;\n-              }\n+                '%' => {\n+                    match parse_type(s, pos, rdr.read_char(), &mut tm) {\n+                        Ok(next) => pos = next,\n+                        Err(move e) => { result = Err(move e); break; }\n+                    }\n+                },\n+                c => {\n+                    if c != ch { break }\n+                    pos = next;\n+                }\n             }\n         }\n \n         if pos == len && rdr.eof() {\n-            Ok(Tm_(Tm_ {\n+            Ok(Tm {\n                 tm_sec: tm.tm_sec,\n                 tm_min: tm.tm_min,\n                 tm_hour: tm.tm_hour,\n@@ -758,14 +733,14 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 tm_yday: tm.tm_yday,\n                 tm_isdst: tm.tm_isdst,\n                 tm_gmtoff: tm.tm_gmtoff,\n-                tm_zone: tm.tm_zone,\n+                tm_zone: copy tm.tm_zone,\n                 tm_nsec: tm.tm_nsec,\n-            }))\n-        } else { result }\n+            })\n+        } else { move result }\n     }\n }\n \n-priv fn do_strftime(format: &str, tm: Tm) -> ~str {\n+priv fn do_strftime(format: &str, tm: &Tm) -> ~str {\n     fn parse_type(ch: char, tm: &Tm) -> ~str {\n         //FIXME (#2350): Implement missing types.\n       let die = || fmt!(\"strftime: can't understand this format %c \", ch);\n@@ -904,7 +879,7 @@ priv fn do_strftime(format: &str, tm: Tm) -> ~str {\n           //'x' {}\n           'Y' => int::str(tm.tm_year as int + 1900),\n           'y' => fmt!(\"%02d\", (tm.tm_year as int + 1900) % 100),\n-          'Z' => tm.tm_zone,\n+          'Z' => copy tm.tm_zone,\n           'z' => {\n             let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n             let mut m = i32::abs(tm.tm_gmtoff) / 60_i32;\n@@ -923,13 +898,13 @@ priv fn do_strftime(format: &str, tm: Tm) -> ~str {\n     do io::with_str_reader(str::from_slice(format)) |rdr| {\n         while !rdr.eof() {\n             match rdr.read_char() {\n-                '%' => buf += parse_type(rdr.read_char(), &tm),\n+                '%' => buf += parse_type(rdr.read_char(), tm),\n                 ch => str::push_char(&mut buf, ch)\n             }\n         }\n     }\n \n-    buf\n+    move buf\n }\n \n #[cfg(test)]\n@@ -983,7 +958,7 @@ mod tests {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n-        let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n+        let time = Timespec::new(1234567890, 54321);\n         let utc = at_utc(time);\n \n         assert utc.tm_sec == 30_i32;\n@@ -1005,7 +980,7 @@ mod tests {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n-        let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n+        let time = Timespec::new(1234567890, 54321);\n         let local = at(time);\n \n         error!(\"time_at: %?\", local);\n@@ -1023,8 +998,8 @@ mod tests {\n \n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n-        let zone = local.tm_zone;\n-        assert zone == ~\"PST\" || zone == ~\"Pacific Standard Time\";\n+        let zone = &local.tm_zone;\n+        assert *zone == ~\"PST\" || *zone == ~\"Pacific Standard Time\";\n \n         assert local.tm_nsec == 54321_i32;\n     }\n@@ -1034,7 +1009,7 @@ mod tests {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n-        let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n+        let time = Timespec::new(1234567890, 54321);\n         let utc = at_utc(time);\n \n         assert utc.to_timespec() == time;\n@@ -1046,7 +1021,7 @@ mod tests {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n-        let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n+        let time = Timespec::new(1234567890, 54321);\n         let utc = at_utc(time);\n         let local = at(time);\n \n@@ -1206,10 +1181,10 @@ mod tests {\n         assert test(~\"6\", ~\"%w\");\n         assert test(~\"2009\", ~\"%Y\");\n         assert test(~\"09\", ~\"%y\");\n-        assert strptime(~\"UTC\", ~\"%Z\").get().tm_zone == ~\"UTC\";\n-        assert strptime(~\"PST\", ~\"%Z\").get().tm_zone == ~\"\";\n-        assert strptime(~\"-0000\", ~\"%z\").get().tm_gmtoff == 0_i32;\n-        assert strptime(~\"-0800\", ~\"%z\").get().tm_gmtoff == 0_i32;\n+        assert result::unwrap(strptime(~\"UTC\", ~\"%Z\")).tm_zone == ~\"UTC\";\n+        assert result::unwrap(strptime(~\"PST\", ~\"%Z\")).tm_zone == ~\"\";\n+        assert result::unwrap(strptime(~\"-0000\", ~\"%z\")).tm_gmtoff == 0;\n+        assert result::unwrap(strptime(~\"-0800\", ~\"%z\")).tm_gmtoff == 0;\n         assert test(~\"%\", ~\"%%\");\n     }\n \n@@ -1218,7 +1193,7 @@ mod tests {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n-        let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n+        let time = Timespec::new(1234567890, 54321);\n         let utc   = at_utc(time);\n         let local = at(time);\n \n@@ -1233,7 +1208,7 @@ mod tests {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n-        let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n+        let time = Timespec::new(1234567890, 54321);\n         let utc = at_utc(time);\n         let local = at(time);\n "}]}