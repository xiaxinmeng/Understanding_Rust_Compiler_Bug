{"sha": "e64f64a2fc1deb955b42542fa399f2fa2b609866", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NGY2NGEyZmMxZGViOTU1YjQyNTQyZmEzOTlmMmZhMmI2MDk4NjY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-12-21T10:32:59Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-12-28T09:27:57Z"}, "message": "rustc: separate bodies for static/(associated)const and embedded constants.", "tree": {"sha": "c9b856eb84b258363a07ff747ffe8591a8251a4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9b856eb84b258363a07ff747ffe8591a8251a4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e64f64a2fc1deb955b42542fa399f2fa2b609866", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e64f64a2fc1deb955b42542fa399f2fa2b609866", "html_url": "https://github.com/rust-lang/rust/commit/e64f64a2fc1deb955b42542fa399f2fa2b609866", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e64f64a2fc1deb955b42542fa399f2fa2b609866/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "864928297d0fc0675c5eae62a58d8488941d58cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/864928297d0fc0675c5eae62a58d8488941d58cf", "html_url": "https://github.com/rust-lang/rust/commit/864928297d0fc0675c5eae62a58d8488941d58cf"}], "stats": {"total": 1292, "additions": 637, "deletions": 655}, "files": [{"sha": "4d66bba9f07ee6b135b33b57e63f08ec59cb6aa3", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -327,10 +327,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.opt_expr(base, field_cfg)\n             }\n \n-            hir::ExprRepeat(ref elem, ref count) => {\n-                self.straightline(expr, pred, [elem, count].iter().map(|&e| &**e))\n-            }\n-\n             hir::ExprAssign(ref l, ref r) |\n             hir::ExprAssignOp(_, ref l, ref r) => {\n                 self.straightline(expr, pred, [r, l].iter().map(|&e| &**e))\n@@ -347,7 +343,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             hir::ExprType(ref e, _) |\n             hir::ExprUnary(_, ref e) |\n             hir::ExprField(ref e, _) |\n-            hir::ExprTupField(ref e, _) => {\n+            hir::ExprTupField(ref e, _) |\n+            hir::ExprRepeat(ref e, _) => {\n                 self.straightline(expr, pred, Some(&**e).into_iter())\n             }\n "}, {"sha": "1990574ca9a831d3232c95b282cb854e97333f59", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -50,7 +50,6 @@ pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n             let task_id = (self.dep_node_fn)(trait_item_def_id);\n             let _task = self.tcx.dep_graph.in_task(task_id.clone());\n             debug!(\"Started task {:?}\", task_id);\n-            assert!(!self.tcx.map.is_inlined_def_id(trait_item_def_id));\n             self.tcx.dep_graph.read(DepNode::Hir(trait_item_def_id));\n             self.visitor.visit_trait_item(i);\n             debug!(\"Ended task {:?}\", task_id);"}, {"sha": "845b6473259dcc83931e24f04c3d74a9f36e2d41", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 31, "deletions": 39, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -203,10 +203,10 @@ pub trait Visitor<'v> : Sized {\n     /// visit_nested_item, does nothing by default unless you override\n     /// `nested_visit_map` to return `Some(_)`, in which case it will walk the\n     /// body.\n-    fn visit_body(&mut self, id: ExprId) {\n-        let opt_expr = self.nested_visit_map().intra().map(|map| map.expr(id));\n-        if let Some(expr) = opt_expr {\n-            self.visit_expr(expr);\n+    fn visit_nested_body(&mut self, id: BodyId) {\n+        let opt_body = self.nested_visit_map().intra().map(|map| map.body(id));\n+        if let Some(body) = opt_body {\n+            self.visit_body(body);\n         }\n     }\n \n@@ -216,6 +216,10 @@ pub trait Visitor<'v> : Sized {\n         walk_item(self, i)\n     }\n \n+    fn visit_body(&mut self, b: &'v Body) {\n+        walk_body(self, b);\n+    }\n+\n     /// When invoking `visit_all_item_likes()`, you need to supply an\n     /// item-like visitor.  This method converts a \"intra-visit\"\n     /// visitor into an item-like visitor that walks the entire tree.\n@@ -264,8 +268,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_expr(&mut self, ex: &'v Expr) {\n         walk_expr(self, ex)\n     }\n-    fn visit_expr_post(&mut self, _ex: &'v Expr) {\n-    }\n     fn visit_ty(&mut self, t: &'v Ty) {\n         walk_ty(self, t)\n     }\n@@ -278,7 +280,7 @@ pub trait Visitor<'v> : Sized {\n     fn visit_fn_decl(&mut self, fd: &'v FnDecl) {\n         walk_fn_decl(self, fd)\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: ExprId, s: Span, id: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: BodyId, s: Span, id: NodeId) {\n         walk_fn(self, fk, fd, b, s, id)\n     }\n     fn visit_trait_item(&mut self, ti: &'v TraitItem) {\n@@ -392,6 +394,10 @@ pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod, mod_node_i\n     }\n }\n \n+pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body) {\n+    visitor.visit_expr(&body.value);\n+}\n+\n pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n     visitor.visit_id(local.id);\n     visitor.visit_pat(&local.pat);\n@@ -437,11 +443,11 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_id(item.id);\n             visitor.visit_path(path, item.id);\n         }\n-        ItemStatic(ref typ, _, ref expr) |\n-        ItemConst(ref typ, ref expr) => {\n+        ItemStatic(ref typ, _, body) |\n+        ItemConst(ref typ, body) => {\n             visitor.visit_id(item.id);\n             visitor.visit_ty(typ);\n-            visitor.visit_expr(expr);\n+            visitor.visit_nested_body(body);\n         }\n         ItemFn(ref declaration, unsafety, constness, abi, ref generics, body_id) => {\n             visitor.visit_fn(FnKind::ItemFn(item.name,\n@@ -523,7 +529,7 @@ pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n                                generics,\n                                parent_item_id,\n                                variant.span);\n-    walk_list!(visitor, visit_expr, &variant.node.disr_expr);\n+    walk_list!(visitor, visit_nested_body, variant.node.disr_expr);\n     walk_list!(visitor, visit_attribute, &variant.node.attrs);\n }\n \n@@ -556,18 +562,18 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n-        TyArray(ref ty, ref expression) => {\n+        TyArray(ref ty, length) => {\n             visitor.visit_ty(ty);\n-            visitor.visit_expr(expression)\n+            visitor.visit_nested_body(length)\n         }\n         TyPolyTraitRef(ref bounds) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n         TyImplTrait(ref bounds) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n-        TyTypeof(ref expression) => {\n-            visitor.visit_expr(expression)\n+        TyTypeof(expression) => {\n+            visitor.visit_nested_body(expression)\n         }\n         TyInfer => {}\n     }\n@@ -775,35 +781,23 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'\n pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n                                    function_kind: FnKind<'v>,\n                                    function_declaration: &'v FnDecl,\n-                                   body_id: ExprId,\n+                                   body_id: BodyId,\n                                    _span: Span,\n                                    id: NodeId) {\n     visitor.visit_id(id);\n     visitor.visit_fn_decl(function_declaration);\n     walk_fn_kind(visitor, function_kind);\n-    visitor.visit_body(body_id)\n-}\n-\n-pub fn walk_fn_with_body<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                             function_kind: FnKind<'v>,\n-                                             function_declaration: &'v FnDecl,\n-                                             body: &'v Expr,\n-                                             _span: Span,\n-                                             id: NodeId) {\n-    visitor.visit_id(id);\n-    visitor.visit_fn_decl(function_declaration);\n-    walk_fn_kind(visitor, function_kind);\n-    visitor.visit_expr(body)\n+    visitor.visit_nested_body(body_id)\n }\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n     visitor.visit_name(trait_item.span, trait_item.name);\n     walk_list!(visitor, visit_attribute, &trait_item.attrs);\n     match trait_item.node {\n-        TraitItemKind::Const(ref ty, ref default) => {\n+        TraitItemKind::Const(ref ty, default) => {\n             visitor.visit_id(trait_item.id);\n             visitor.visit_ty(ty);\n-            walk_list!(visitor, visit_expr, default);\n+            walk_list!(visitor, visit_nested_body, default);\n         }\n         TraitItemKind::Method(ref sig, None) => {\n             visitor.visit_id(trait_item.id);\n@@ -846,10 +840,10 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n     visitor.visit_defaultness(defaultness);\n     walk_list!(visitor, visit_attribute, attrs);\n     match *node {\n-        ImplItemKind::Const(ref ty, ref expr) => {\n+        ImplItemKind::Const(ref ty, body) => {\n             visitor.visit_id(impl_item.id);\n             visitor.visit_ty(ty);\n-            visitor.visit_expr(expr);\n+            visitor.visit_nested_body(body);\n         }\n         ImplItemKind::Method(ref sig, body_id) => {\n             visitor.visit_fn(FnKind::Method(impl_item.name,\n@@ -928,9 +922,9 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprArray(ref subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n-        ExprRepeat(ref element, ref count) => {\n+        ExprRepeat(ref element, count) => {\n             visitor.visit_expr(element);\n-            visitor.visit_expr(count)\n+            visitor.visit_nested_body(count)\n         }\n         ExprStruct(ref qpath, ref fields, ref optional_base) => {\n             visitor.visit_qpath(qpath, expression.id, expression.span);\n@@ -1037,8 +1031,6 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             }\n         }\n     }\n-\n-    visitor.visit_expr_post(expression)\n }\n \n pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n@@ -1125,12 +1117,12 @@ impl<'a, 'ast> Visitor<'ast> for IdRangeComputingVisitor<'a, 'ast> {\n /// Computes the id range for a single fn body, ignoring nested items.\n pub fn compute_id_range_for_fn_body<'v>(fk: FnKind<'v>,\n                                         decl: &'v FnDecl,\n-                                        body: &'v Expr,\n+                                        body: BodyId,\n                                         sp: Span,\n                                         id: NodeId,\n                                         map: &map::Map<'v>)\n                                         -> IdRange {\n     let mut visitor = IdRangeComputingVisitor::new(map);\n-    walk_fn_with_body(&mut visitor, fk, decl, body, sp, id);\n+    visitor.visit_fn(fk, decl, body, sp, id);\n     visitor.result()\n }"}, {"sha": "c858436e7fc4e444f3a99b861a4d231f67fe2d5c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 39, "deletions": 23, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -46,8 +46,7 @@ use hir::map::definitions::DefPathData;\n use hir::def_id::{DefIndex, DefId};\n use hir::def::{Def, PathResolution};\n use session::Session;\n-use util::nodemap::NodeMap;\n-use rustc_data_structures::fnv::FnvHashMap;\n+use util::nodemap::{NodeMap, FxHashMap};\n \n use std::collections::BTreeMap;\n use std::iter;\n@@ -70,14 +69,14 @@ pub struct LoweringContext<'a> {\n     // the form of a DefIndex) so that if we create a new node which introduces\n     // a definition, then we can properly create the def id.\n     parent_def: Option<DefIndex>,\n-    exprs: FnvHashMap<hir::ExprId, hir::Expr>,\n     resolver: &'a mut Resolver,\n \n     /// The items being lowered are collected here.\n     items: BTreeMap<NodeId, hir::Item>,\n \n     trait_items: BTreeMap<hir::TraitItemId, hir::TraitItem>,\n     impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n+    bodies: FxHashMap<hir::BodyId, hir::Body>,\n }\n \n pub trait Resolver {\n@@ -105,11 +104,11 @@ pub fn lower_crate(sess: &Session,\n         crate_root: std_inject::injected_crate_name(krate),\n         sess: sess,\n         parent_def: None,\n-        exprs: FnvHashMap(),\n         resolver: resolver,\n         items: BTreeMap::new(),\n         trait_items: BTreeMap::new(),\n         impl_items: BTreeMap::new(),\n+        bodies: FxHashMap(),\n     }.lower_crate(krate)\n }\n \n@@ -136,7 +135,7 @@ impl<'a> LoweringContext<'a> {\n             items: self.items,\n             trait_items: self.trait_items,\n             impl_items: self.impl_items,\n-            exprs: self.exprs,\n+            bodies: self.bodies,\n         }\n     }\n \n@@ -171,9 +170,12 @@ impl<'a> LoweringContext<'a> {\n         visit::walk_crate(&mut item_lowerer, c);\n     }\n \n-    fn record_expr(&mut self, expr: hir::Expr) -> hir::ExprId {\n-        let id = hir::ExprId(expr.id);\n-        self.exprs.insert(id, expr);\n+    fn record_body(&mut self, value: hir::Expr) -> hir::BodyId {\n+        let body = hir::Body {\n+            value: value\n+        };\n+        let id = body.id();\n+        self.bodies.insert(id, body);\n         id\n     }\n \n@@ -305,11 +307,14 @@ impl<'a> LoweringContext<'a> {\n                 TyKind::ObjectSum(ref ty, ref bounds) => {\n                     hir::TyObjectSum(self.lower_ty(ty), self.lower_bounds(bounds))\n                 }\n-                TyKind::Array(ref ty, ref e) => {\n-                    hir::TyArray(self.lower_ty(ty), P(self.lower_expr(e)))\n+                TyKind::Array(ref ty, ref length) => {\n+                    let length = self.lower_expr(length);\n+                    hir::TyArray(self.lower_ty(ty),\n+                                 self.record_body(length))\n                 }\n                 TyKind::Typeof(ref expr) => {\n-                    hir::TyTypeof(P(self.lower_expr(expr)))\n+                    let expr = self.lower_expr(expr);\n+                    hir::TyTypeof(self.record_body(expr))\n                 }\n                 TyKind::PolyTraitRef(ref bounds) => {\n                     hir::TyPolyTraitRef(self.lower_bounds(bounds))\n@@ -336,7 +341,10 @@ impl<'a> LoweringContext<'a> {\n                 name: v.node.name.name,\n                 attrs: self.lower_attrs(&v.node.attrs),\n                 data: self.lower_variant_data(&v.node.data),\n-                disr_expr: v.node.disr_expr.as_ref().map(|e| P(self.lower_expr(e))),\n+                disr_expr: v.node.disr_expr.as_ref().map(|e| {\n+                    let e = self.lower_expr(e);\n+                    self.record_body(e)\n+                }),\n             },\n             span: v.span,\n         }\n@@ -858,17 +866,20 @@ impl<'a> LoweringContext<'a> {\n                 hir::ItemUse(path, kind)\n             }\n             ItemKind::Static(ref t, m, ref e) => {\n+                let value = self.lower_expr(e);\n                 hir::ItemStatic(self.lower_ty(t),\n                                 self.lower_mutability(m),\n-                                P(self.lower_expr(e)))\n+                                self.record_body(value))\n             }\n             ItemKind::Const(ref t, ref e) => {\n-                hir::ItemConst(self.lower_ty(t), P(self.lower_expr(e)))\n+                let value = self.lower_expr(e);\n+                hir::ItemConst(self.lower_ty(t),\n+                               self.record_body(value))\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n                 let body = self.lower_block(body);\n                 let body = self.expr_block(body, ThinVec::new());\n-                let body_id = self.record_expr(body);\n+                let body_id = self.record_body(body);\n                 hir::ItemFn(self.lower_fn_decl(decl),\n                             self.lower_unsafety(unsafety),\n                             self.lower_constness(constness),\n@@ -935,14 +946,17 @@ impl<'a> LoweringContext<'a> {\n                 node: match i.node {\n                     TraitItemKind::Const(ref ty, ref default) => {\n                         hir::TraitItemKind::Const(this.lower_ty(ty),\n-                                                  default.as_ref().map(|x| P(this.lower_expr(x))))\n+                                                  default.as_ref().map(|x| {\n+                            let value = this.lower_expr(x);\n+                            this.record_body(value)\n+                        }))\n                     }\n                     TraitItemKind::Method(ref sig, ref body) => {\n                         hir::TraitItemKind::Method(this.lower_method_sig(sig),\n                                                    body.as_ref().map(|x| {\n                             let body = this.lower_block(x);\n                             let expr = this.expr_block(body, ThinVec::new());\n-                            this.record_expr(expr)\n+                            this.record_body(expr)\n                         }))\n                     }\n                     TraitItemKind::Type(ref bounds, ref default) => {\n@@ -990,13 +1004,15 @@ impl<'a> LoweringContext<'a> {\n                 defaultness: this.lower_defaultness(i.defaultness, true /* [1] */),\n                 node: match i.node {\n                     ImplItemKind::Const(ref ty, ref expr) => {\n-                        hir::ImplItemKind::Const(this.lower_ty(ty), P(this.lower_expr(expr)))\n+                        let value = this.lower_expr(expr);\n+                        let body_id = this.record_body(value);\n+                        hir::ImplItemKind::Const(this.lower_ty(ty), body_id)\n                     }\n                     ImplItemKind::Method(ref sig, ref body) => {\n                         let body = this.lower_block(body);\n                         let expr = this.expr_block(body, ThinVec::new());\n-                        let expr_id = this.record_expr(expr);\n-                        hir::ImplItemKind::Method(this.lower_method_sig(sig), expr_id)\n+                        let body_id = this.record_body(expr);\n+                        hir::ImplItemKind::Method(this.lower_method_sig(sig), body_id)\n                     }\n                     ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(this.lower_ty(ty)),\n                     ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n@@ -1350,8 +1366,8 @@ impl<'a> LoweringContext<'a> {\n                 }\n                 ExprKind::Repeat(ref expr, ref count) => {\n                     let expr = P(self.lower_expr(expr));\n-                    let count = P(self.lower_expr(count));\n-                    hir::ExprRepeat(expr, count)\n+                    let count = self.lower_expr(count);\n+                    hir::ExprRepeat(expr, self.record_body(count))\n                 }\n                 ExprKind::Tup(ref elts) => {\n                     hir::ExprTup(elts.iter().map(|x| self.lower_expr(x)).collect())\n@@ -1434,7 +1450,7 @@ impl<'a> LoweringContext<'a> {\n                         let expr = this.lower_expr(body);\n                         hir::ExprClosure(this.lower_capture_clause(capture_clause),\n                                          this.lower_fn_decl(decl),\n-                                         this.record_expr(expr),\n+                                         this.record_body(expr),\n                                          fn_decl_span)\n                     })\n                 }"}, {"sha": "001a4d1526ddf7c5aea1ff9c5a241bf2d6c4f97d", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -48,7 +48,7 @@ pub trait MaybeFnLike { fn is_fn_like(&self) -> bool; }\n /// Components shared by fn-like things (fn items, methods, closures).\n pub struct FnParts<'a> {\n     pub decl: &'a FnDecl,\n-    pub body: ast::ExprId,\n+    pub body: ast::BodyId,\n     pub kind: FnKind<'a>,\n     pub span: Span,\n     pub id:   NodeId,\n@@ -115,7 +115,7 @@ struct ItemFnParts<'a> {\n     abi:      abi::Abi,\n     vis:      &'a ast::Visibility,\n     generics: &'a ast::Generics,\n-    body:     ast::ExprId,\n+    body:     ast::BodyId,\n     id:       NodeId,\n     span:     Span,\n     attrs:    &'a [Attribute],\n@@ -125,14 +125,14 @@ struct ItemFnParts<'a> {\n /// for use when implementing FnLikeNode operations.\n struct ClosureParts<'a> {\n     decl: &'a FnDecl,\n-    body: ast::ExprId,\n+    body: ast::BodyId,\n     id: NodeId,\n     span: Span,\n     attrs: &'a [Attribute],\n }\n \n impl<'a> ClosureParts<'a> {\n-    fn new(d: &'a FnDecl, b: ast::ExprId, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n+    fn new(d: &'a FnDecl, b: ast::BodyId, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n         ClosureParts {\n             decl: d,\n             body: b,\n@@ -172,9 +172,9 @@ impl<'a> FnLikeNode<'a> {\n         }\n     }\n \n-    pub fn body(self) -> ast::ExprId {\n+    pub fn body(self) -> ast::BodyId {\n         self.handle(|i: ItemFnParts<'a>|  i.body,\n-                    |_, _, _: &'a ast::MethodSig, _, body: ast::ExprId, _, _|  body,\n+                    |_, _, _: &'a ast::MethodSig, _, body: ast::BodyId, _, _|  body,\n                     |c: ClosureParts<'a>| c.body)\n     }\n \n@@ -227,7 +227,7 @@ impl<'a> FnLikeNode<'a> {\n                   Name,\n                   &'a ast::MethodSig,\n                   Option<&'a ast::Visibility>,\n-                  ast::ExprId,\n+                  ast::BodyId,\n                   Span,\n                   &'a [Attribute])\n                   -> A,"}, {"sha": "d138ffe6226dc3553ed0bae3796bf3e499a48674", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -99,15 +99,21 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     }\n \n     fn visit_nested_trait_item(&mut self, item_id: TraitItemId) {\n-        self.visit_trait_item(self.krate.trait_item(item_id))\n+        if !self.ignore_nested_items {\n+            self.visit_trait_item(self.krate.trait_item(item_id))\n+        }\n     }\n \n     fn visit_nested_impl_item(&mut self, item_id: ImplItemId) {\n-        self.visit_impl_item(self.krate.impl_item(item_id))\n+        if !self.ignore_nested_items {\n+            self.visit_impl_item(self.krate.impl_item(item_id))\n+        }\n     }\n \n-    fn visit_body(&mut self, id: ExprId) {\n-        self.visit_expr(self.krate.expr(id))\n+    fn visit_nested_body(&mut self, id: BodyId) {\n+        if !self.ignore_nested_items {\n+            self.visit_body(self.krate.body(id))\n+        }\n     }\n \n     fn visit_item(&mut self, i: &'ast Item) {\n@@ -117,11 +123,6 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n \n         self.with_parent(i.id, |this| {\n             match i.node {\n-                ItemEnum(ref enum_definition, _) => {\n-                    for v in &enum_definition.variants {\n-                        this.insert(v.node.data.id(), NodeVariant(v));\n-                    }\n-                }\n                 ItemStruct(ref struct_def, _) => {\n                     // If this is a tuple-like struct, register the constructor.\n                     if !struct_def.is_struct() {\n@@ -213,7 +214,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     }\n \n     fn visit_fn(&mut self, fk: intravisit::FnKind<'ast>, fd: &'ast FnDecl,\n-                b: ExprId, s: Span, id: NodeId) {\n+                b: BodyId, s: Span, id: NodeId) {\n         assert_eq!(self.parent_node, id);\n         intravisit::walk_fn(self, fk, fd, b, s, id);\n     }\n@@ -247,6 +248,14 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.insert_entry(macro_def.id, NotPresent);\n     }\n \n+    fn visit_variant(&mut self, v: &'ast Variant, g: &'ast Generics, item_id: NodeId) {\n+        let id = v.node.data.id();\n+        self.insert(id, NodeVariant(v));\n+        self.with_parent(id, |this| {\n+            intravisit::walk_variant(this, v, g, item_id);\n+        });\n+    }\n+\n     fn visit_struct_field(&mut self, field: &'ast StructField) {\n         self.insert(field.id, NodeField(field));\n         self.with_parent(field.id, |this| {"}, {"sha": "be8780f39b10429d6aea31bbc28cc36c69e8cdc0", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -16,7 +16,7 @@ use syntax::ext::hygiene::Mark;\n use syntax::visit;\n use syntax::symbol::{Symbol, keywords};\n \n-/// Creates def ids for nodes in the HIR.\n+/// Creates def ids for nodes in the AST.\n pub struct DefCollector<'a> {\n     definitions: &'a mut Definitions,\n     parent_def: Option<DefIndex>,"}, {"sha": "b28c5e80ea3c35bc4ddf41263ac89e4d272ce9fa", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -220,7 +220,6 @@ impl DefPath {\n     }\n }\n \n-\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum DefPathData {\n     // Root: these should only be used for the root nodes, because\n@@ -339,7 +338,7 @@ impl Definitions {\n                 data,\n                 self.table.def_key(self.node_to_def_index[&node_id]));\n \n-        assert!(parent.is_some() ^ (data == DefPathData::CrateRoot));\n+        assert_eq!(parent.is_some(), data != DefPathData::CrateRoot);\n \n         // Find a unique DefKey. This basically means incrementing the disambiguator\n         // until we get no match."}, {"sha": "ff9d12bb4f1270be332ea68d6963128f236943b0", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -266,7 +266,6 @@ impl<'ast> Map<'ast> {\n \n                     EntryTraitItem(_, item) => {\n                         let def_id = self.local_def_id(id);\n-                        assert!(!self.is_inlined_def_id(def_id));\n \n                         if let Some(last_id) = last_expr {\n                             // The body of the item may have a separate dep node\n@@ -289,8 +288,19 @@ impl<'ast> Map<'ast> {\n                         return DepNode::Hir(def_id);\n                     }\n \n+                    EntryVariant(p, v) => {\n+                        id = p;\n+\n+                        if last_expr.is_some() {\n+                            if v.node.disr_expr.map(|e| e.node_id) == last_expr {\n+                                // The enum parent holds both Hir and HirBody nodes.\n+                                let def_id = self.local_def_id(id);\n+                                return DepNode::HirBody(def_id);\n+                            }\n+                        }\n+                    }\n+\n                     EntryForeignItem(p, _) |\n-                    EntryVariant(p, _) |\n                     EntryField(p, _) |\n                     EntryStmt(p, _) |\n                     EntryTy(p, _) |\n@@ -317,7 +327,7 @@ impl<'ast> Map<'ast> {\n                         bug!(\"node {} has inlined ancestor but is not inlined\", id0),\n \n                     NotPresent =>\n-                        // Some nodes, notably struct fields, are not\n+                        // Some nodes, notably macro definitions, are not\n                         // present in the map for whatever reason, but\n                         // they *do* have def-ids. So if we encounter an\n                         // empty hole, check for that case.\n@@ -369,21 +379,25 @@ impl<'ast> Map<'ast> {\n \n     fn is_item_body(&self, node_id: NodeId, item: &Item) -> bool {\n         match item.node {\n-            ItemFn(_, _, _, _, _, body) => body.node_id() == node_id,\n+            ItemConst(_, body) |\n+            ItemStatic(.., body) |\n+            ItemFn(_, _, _, _, _, body) => body.node_id == node_id,\n             _ => false\n         }\n     }\n \n     fn is_trait_item_body(&self, node_id: NodeId, item: &TraitItem) -> bool {\n         match item.node {\n-            TraitItemKind::Method(_, Some(body)) => body.node_id() == node_id,\n+            TraitItemKind::Const(_, Some(body)) |\n+            TraitItemKind::Method(_, Some(body)) => body.node_id == node_id,\n             _ => false\n         }\n     }\n \n     fn is_impl_item_body(&self, node_id: NodeId, item: &ImplItem) -> bool {\n         match item.node {\n-            ImplItemKind::Method(_, body) => body.node_id() == node_id,\n+            ImplItemKind::Const(_, body) |\n+            ImplItemKind::Method(_, body) => body.node_id == node_id,\n             _ => false\n         }\n     }\n@@ -459,6 +473,14 @@ impl<'ast> Map<'ast> {\n         self.forest.krate.impl_item(id)\n     }\n \n+    pub fn body(&self, id: BodyId) -> &'ast Body {\n+        self.read(id.node_id);\n+\n+        // NB: intentionally bypass `self.forest.krate()` so that we\n+        // do not trigger a read of the whole krate here\n+        self.forest.krate.body(id)\n+    }\n+\n     /// Get the attributes on the krate. This is preferable to\n     /// invoking `krate.attrs` because it registers a tighter\n     /// dep-graph access.\n@@ -709,10 +731,6 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn expr(&self, id: ExprId) -> &'ast Expr {\n-        self.expect_expr(id.node_id())\n-    }\n-\n     /// Returns the name associated with the given NodeId's AST.\n     pub fn name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n@@ -793,7 +811,7 @@ impl<'ast> Map<'ast> {\n             Some(EntryVisibility(_, v)) => bug!(\"unexpected Visibility {:?}\", v),\n \n             Some(RootCrate) => self.forest.krate.span,\n-            Some(RootInlinedParent(parent)) => parent.body.span,\n+            Some(RootInlinedParent(parent)) => parent.body.value.span,\n             Some(NotPresent) | None => {\n                 bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n             }"}, {"sha": "b4a42711e4d2d08f5009af81a73e4efb3126ca4f", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -31,16 +31,15 @@ pub use self::PathParameters::*;\n \n use hir::def::Def;\n use hir::def_id::DefId;\n-use util::nodemap::{NodeMap, FxHashSet};\n-use rustc_data_structures::fnv::FnvHashMap;\n+use util::nodemap::{NodeMap, FxHashMap, FxHashSet};\n \n use syntax_pos::{Span, ExpnId, DUMMY_SP};\n use syntax::codemap::{self, Spanned};\n use syntax::abi::Abi;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::TokenTree;\n use syntax::util::ThinVec;\n \n@@ -432,7 +431,7 @@ pub struct Crate {\n \n     pub trait_items: BTreeMap<TraitItemId, TraitItem>,\n     pub impl_items: BTreeMap<ImplItemId, ImplItem>,\n-    pub exprs: FnvHashMap<ExprId, Expr>,\n+    pub bodies: FxHashMap<BodyId, Body>,\n }\n \n impl Crate {\n@@ -472,8 +471,8 @@ impl Crate {\n         }\n     }\n \n-    pub fn expr(&self, id: ExprId) -> &Expr {\n-        &self.exprs[&id]\n+    pub fn body(&self, id: BodyId) -> &Body {\n+        &self.bodies[&id]\n     }\n }\n \n@@ -862,11 +861,21 @@ pub enum UnsafeSource {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct ExprId(NodeId);\n+pub struct BodyId {\n+    pub node_id: NodeId,\n+}\n+\n+/// The body of a function or constant value.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct Body {\n+    pub value: Expr\n+}\n \n-impl ExprId {\n-    pub fn node_id(self) -> NodeId {\n-        self.0\n+impl Body {\n+    pub fn id(&self) -> BodyId {\n+        BodyId {\n+            node_id: self.value.id\n+        }\n     }\n }\n \n@@ -879,12 +888,6 @@ pub struct Expr {\n     pub attrs: ThinVec<Attribute>,\n }\n \n-impl Expr {\n-    pub fn expr_id(&self) -> ExprId {\n-        ExprId(self.id)\n-    }\n-}\n-\n impl fmt::Debug for Expr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"expr({}: {})\", self.id, print::expr_to_string(self))\n@@ -944,7 +947,7 @@ pub enum Expr_ {\n     /// A closure (for example, `move |a, b, c| {a + b + c}`).\n     ///\n     /// The final span is the span of the argument block `|...|`\n-    ExprClosure(CaptureClause, P<FnDecl>, ExprId, Span),\n+    ExprClosure(CaptureClause, P<FnDecl>, BodyId, Span),\n     /// A block (`{ ... }`)\n     ExprBlock(P<Block>),\n \n@@ -988,7 +991,7 @@ pub enum Expr_ {\n     ///\n     /// For example, `[1; 5]`. The first expression is the element\n     /// to be repeated; the second is the number of times to repeat it.\n-    ExprRepeat(P<Expr>, P<Expr>),\n+    ExprRepeat(P<Expr>, BodyId),\n }\n \n /// Optionally `Self`-qualified value/type path or associated extension.\n@@ -1104,9 +1107,9 @@ pub struct TraitItem {\n pub enum TraitItemKind {\n     /// An associated constant with an optional value (otherwise `impl`s\n     /// must contain a value)\n-    Const(P<Ty>, Option<P<Expr>>),\n+    Const(P<Ty>, Option<BodyId>),\n     /// A method with an optional body\n-    Method(MethodSig, Option<ExprId>),\n+    Method(MethodSig, Option<BodyId>),\n     /// An associated type with (possibly empty) bounds and optional concrete\n     /// type\n     Type(TyParamBounds, Option<P<Ty>>),\n@@ -1137,9 +1140,9 @@ pub struct ImplItem {\n pub enum ImplItemKind {\n     /// An associated constant of the given type, set to the constant result\n     /// of the expression\n-    Const(P<Ty>, P<Expr>),\n+    Const(P<Ty>, BodyId),\n     /// A method implementation with the given signature and body\n-    Method(MethodSig, ExprId),\n+    Method(MethodSig, BodyId),\n     /// An associated type\n     Type(P<Ty>),\n }\n@@ -1192,7 +1195,7 @@ pub enum Ty_ {\n     /// A variable length slice (`[T]`)\n     TySlice(P<Ty>),\n     /// A fixed length array (`[T; n]`)\n-    TyArray(P<Ty>, P<Expr>),\n+    TyArray(P<Ty>, BodyId),\n     /// A raw pointer (`*const T` or `*mut T`)\n     TyPtr(MutTy),\n     /// A reference (`&'a T` or `&'a mut T`)\n@@ -1216,7 +1219,7 @@ pub enum Ty_ {\n     /// An `impl TraitA+TraitB` type.\n     TyImplTrait(TyParamBounds),\n     /// Unused for now\n-    TyTypeof(P<Expr>),\n+    TyTypeof(BodyId),\n     /// TyInfer means the type should be inferred instead of it having been\n     /// specified. This can appear anywhere in a type.\n     TyInfer,\n@@ -1371,7 +1374,7 @@ pub struct Variant_ {\n     pub attrs: HirVec<Attribute>,\n     pub data: VariantData,\n     /// Explicit discriminant, eg `Foo = 1`\n-    pub disr_expr: Option<P<Expr>>,\n+    pub disr_expr: Option<BodyId>,\n }\n \n pub type Variant = Spanned<Variant_>;\n@@ -1530,11 +1533,11 @@ pub enum Item_ {\n     ItemUse(P<Path>, UseKind),\n \n     /// A `static` item\n-    ItemStatic(P<Ty>, Mutability, P<Expr>),\n+    ItemStatic(P<Ty>, Mutability, BodyId),\n     /// A `const` item\n-    ItemConst(P<Ty>, P<Expr>),\n+    ItemConst(P<Ty>, BodyId),\n     /// A function declaration\n-    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, ExprId),\n+    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, BodyId),\n     /// A module\n     ItemMod(Mod),\n     /// An external module"}, {"sha": "9518113b5a09878216f7624ba230004e8b14e959", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 37, "deletions": 42, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -462,7 +462,7 @@ impl<'a> State<'a> {\n \n     pub fn print_mod(&mut self, _mod: &hir::Mod, attrs: &[ast::Attribute]) -> io::Result<()> {\n         self.print_inner_attributes(attrs)?;\n-        for item_id in &_mod.item_ids {\n+        for &item_id in &_mod.item_ids {\n             self.print_item_id(item_id)?;\n         }\n         Ok(())\n@@ -545,16 +545,16 @@ impl<'a> State<'a> {\n             hir::TyImplTrait(ref bounds) => {\n                 self.print_bounds(\"impl \", &bounds[..])?;\n             }\n-            hir::TyArray(ref ty, ref v) => {\n+            hir::TyArray(ref ty, v) => {\n                 word(&mut self.s, \"[\")?;\n                 self.print_type(&ty)?;\n                 word(&mut self.s, \"; \")?;\n-                self.print_expr(&v)?;\n+                self.print_body_id(v)?;\n                 word(&mut self.s, \"]\")?;\n             }\n-            hir::TyTypeof(ref e) => {\n+            hir::TyTypeof(e) => {\n                 word(&mut self.s, \"typeof(\")?;\n-                self.print_expr(&e)?;\n+                self.print_body_id(e)?;\n                 word(&mut self.s, \")\")?;\n             }\n             hir::TyInfer => {\n@@ -600,7 +600,7 @@ impl<'a> State<'a> {\n     fn print_associated_const(&mut self,\n                               name: ast::Name,\n                               ty: &hir::Ty,\n-                              default: Option<&hir::Expr>,\n+                              default: Option<hir::BodyId>,\n                               vis: &hir::Visibility)\n                               -> io::Result<()> {\n         word(&mut self.s, &visibility_qualified(vis, \"\"))?;\n@@ -611,7 +611,7 @@ impl<'a> State<'a> {\n         if let Some(expr) = default {\n             space(&mut self.s)?;\n             self.word_space(\"=\")?;\n-            self.print_expr(expr)?;\n+            self.print_body_id(expr)?;\n         }\n         word(&mut self.s, \";\")\n     }\n@@ -634,7 +634,7 @@ impl<'a> State<'a> {\n         word(&mut self.s, \";\")\n     }\n \n-    pub fn print_item_id(&mut self, item_id: &hir::ItemId) -> io::Result<()> {\n+    pub fn print_item_id(&mut self, item_id: hir::ItemId) -> io::Result<()> {\n         if let Some(krate) = self.krate {\n             // skip nested items if krate context was not provided\n             let item = &krate.items[&item_id.id];\n@@ -644,9 +644,9 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_expr_id(&mut self, expr_id: &hir::ExprId) -> io::Result<()> {\n+    fn print_body_id(&mut self, body_id: hir::BodyId) -> io::Result<()> {\n         if let Some(krate) = self.krate {\n-            let expr = &krate.exprs[expr_id];\n+            let expr = &krate.body(body_id).value;\n             self.print_expr(expr)\n         } else {\n             Ok(())\n@@ -697,7 +697,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n-            hir::ItemStatic(ref ty, m, ref expr) => {\n+            hir::ItemStatic(ref ty, m, expr) => {\n                 self.head(&visibility_qualified(&item.vis, \"static\"))?;\n                 if m == hir::MutMutable {\n                     self.word_space(\"mut\")?;\n@@ -709,11 +709,11 @@ impl<'a> State<'a> {\n                 self.end()?; // end the head-ibox\n \n                 self.word_space(\"=\")?;\n-                self.print_expr(&expr)?;\n+                self.print_body_id(expr)?;\n                 word(&mut self.s, \";\")?;\n                 self.end()?; // end the outer cbox\n             }\n-            hir::ItemConst(ref ty, ref expr) => {\n+            hir::ItemConst(ref ty, expr) => {\n                 self.head(&visibility_qualified(&item.vis, \"const\"))?;\n                 self.print_name(item.name)?;\n                 self.word_space(\":\")?;\n@@ -722,11 +722,11 @@ impl<'a> State<'a> {\n                 self.end()?; // end the head-ibox\n \n                 self.word_space(\"=\")?;\n-                self.print_expr(&expr)?;\n+                self.print_body_id(expr)?;\n                 word(&mut self.s, \";\")?;\n                 self.end()?; // end the outer cbox\n             }\n-            hir::ItemFn(ref decl, unsafety, constness, abi, ref typarams, ref body) => {\n+            hir::ItemFn(ref decl, unsafety, constness, abi, ref typarams, body) => {\n                 self.head(\"\")?;\n                 self.print_fn(decl,\n                               unsafety,\n@@ -738,7 +738,7 @@ impl<'a> State<'a> {\n                 word(&mut self.s, \" \")?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n-                self.print_expr_id(body)?;\n+                self.print_body_id(body)?;\n             }\n             hir::ItemMod(ref _mod) => {\n                 self.head(&visibility_qualified(&item.vis, \"mod\"))?;\n@@ -985,14 +985,12 @@ impl<'a> State<'a> {\n         self.head(\"\")?;\n         let generics = hir::Generics::empty();\n         self.print_struct(&v.node.data, &generics, v.node.name, v.span, false)?;\n-        match v.node.disr_expr {\n-            Some(ref d) => {\n-                space(&mut self.s)?;\n-                self.word_space(\"=\")?;\n-                self.print_expr(&d)\n-            }\n-            _ => Ok(()),\n+        if let Some(d) = v.node.disr_expr {\n+            space(&mut self.s)?;\n+            self.word_space(\"=\")?;\n+            self.print_body_id(d)?;\n         }\n+        Ok(())\n     }\n     pub fn print_method_sig(&mut self,\n                             name: ast::Name,\n@@ -1024,22 +1022,19 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(ti.span.lo)?;\n         self.print_outer_attributes(&ti.attrs)?;\n         match ti.node {\n-            hir::TraitItemKind::Const(ref ty, ref default) => {\n-                self.print_associated_const(ti.name,\n-                                            &ty,\n-                                            default.as_ref().map(|expr| &**expr),\n-                                            &hir::Inherited)?;\n+            hir::TraitItemKind::Const(ref ty, default) => {\n+                self.print_associated_const(ti.name, &ty, default, &hir::Inherited)?;\n             }\n-            hir::TraitItemKind::Method(ref sig, ref body) => {\n+            hir::TraitItemKind::Method(ref sig, body) => {\n                 if body.is_some() {\n                     self.head(\"\")?;\n                 }\n                 self.print_method_sig(ti.name, sig, &hir::Inherited)?;\n-                if let Some(ref body) = *body {\n+                if let Some(body) = body {\n                     self.nbsp()?;\n                     self.end()?; // need to close a box\n                     self.end()?; // need to close a box\n-                    self.print_expr_id(body)?;\n+                    self.print_body_id(body)?;\n                 } else {\n                     word(&mut self.s, \";\")?;\n                 }\n@@ -1075,16 +1070,16 @@ impl<'a> State<'a> {\n         }\n \n         match ii.node {\n-            hir::ImplItemKind::Const(ref ty, ref expr) => {\n-                self.print_associated_const(ii.name, &ty, Some(&expr), &ii.vis)?;\n+            hir::ImplItemKind::Const(ref ty, expr) => {\n+                self.print_associated_const(ii.name, &ty, Some(expr), &ii.vis)?;\n             }\n-            hir::ImplItemKind::Method(ref sig, ref body) => {\n+            hir::ImplItemKind::Method(ref sig, body) => {\n                 self.head(\"\")?;\n                 self.print_method_sig(ii.name, sig, &ii.vis)?;\n                 self.nbsp()?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n-                self.print_expr_id(body)?;\n+                self.print_body_id(body)?;\n             }\n             hir::ImplItemKind::Type(ref ty) => {\n                 self.print_associated_type(ii.name, None, Some(ty))?;\n@@ -1256,12 +1251,12 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    fn print_expr_repeat(&mut self, element: &hir::Expr, count: &hir::Expr) -> io::Result<()> {\n+    fn print_expr_repeat(&mut self, element: &hir::Expr, count: hir::BodyId) -> io::Result<()> {\n         self.ibox(indent_unit)?;\n         word(&mut self.s, \"[\")?;\n         self.print_expr(element)?;\n         self.word_space(\";\")?;\n-        self.print_expr(count)?;\n+        self.print_body_id(count)?;\n         word(&mut self.s, \"]\")?;\n         self.end()\n     }\n@@ -1372,8 +1367,8 @@ impl<'a> State<'a> {\n             hir::ExprArray(ref exprs) => {\n                 self.print_expr_vec(exprs)?;\n             }\n-            hir::ExprRepeat(ref element, ref count) => {\n-                self.print_expr_repeat(&element, &count)?;\n+            hir::ExprRepeat(ref element, count) => {\n+                self.print_expr_repeat(&element, count)?;\n             }\n             hir::ExprStruct(ref qpath, ref fields, ref wth) => {\n                 self.print_expr_struct(qpath, &fields[..], wth)?;\n@@ -1444,14 +1439,14 @@ impl<'a> State<'a> {\n                 }\n                 self.bclose_(expr.span, indent_unit)?;\n             }\n-            hir::ExprClosure(capture_clause, ref decl, ref body, _fn_decl_span) => {\n+            hir::ExprClosure(capture_clause, ref decl, body, _fn_decl_span) => {\n                 self.print_capture_clause(capture_clause)?;\n \n                 self.print_fn_block_args(&decl)?;\n                 space(&mut self.s)?;\n \n                 // this is a bare expression\n-                self.print_expr_id(body)?;\n+                self.print_body_id(body)?;\n                 self.end()?; // need to close a box\n \n                 // a box will be closed by print_expr, but we didn't want an overall\n@@ -1625,7 +1620,7 @@ impl<'a> State<'a> {\n                 }\n                 self.end()\n             }\n-            hir::DeclItem(ref item) => {\n+            hir::DeclItem(item) => {\n                 self.print_item_id(item)\n             }\n         }"}, {"sha": "cce79820ca8da5bea21811b57aca1cb4e50004e7", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -821,6 +821,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         self.with_lint_attrs(&e.attrs, |cx| {\n             run_lints!(cx, check_expr, late_passes, e);\n             hir_visit::walk_expr(cx, e);\n+            run_lints!(cx, check_expr_post, late_passes, e);\n         })\n     }\n \n@@ -835,8 +836,8 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: hir_visit::FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n-                body_id: hir::ExprId, span: Span, id: ast::NodeId) {\n-        let body = self.tcx.map.expr(body_id);\n+                body_id: hir::BodyId, span: Span, id: ast::NodeId) {\n+        let body = self.tcx.map.body(body_id);\n         run_lints!(self, check_fn, late_passes, fk, decl, body, span, id);\n         hir_visit::walk_fn(self, fk, decl, body_id, span, id);\n         run_lints!(self, check_fn_post, late_passes, fk, decl, body, span, id);\n@@ -909,10 +910,6 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         hir_visit::walk_decl(self, d);\n     }\n \n-    fn visit_expr_post(&mut self, e: &'tcx hir::Expr) {\n-        run_lints!(self, check_expr_post, late_passes, e);\n-    }\n-\n     fn visit_generics(&mut self, g: &'tcx hir::Generics) {\n         run_lints!(self, check_generics, late_passes, g);\n         hir_visit::walk_generics(self, g);"}, {"sha": "7e0da00694c4a4280aa5722d0122f6f9fe8286ea", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -162,14 +162,14 @@ pub trait LateLintPass<'a, 'tcx>: LintPass {\n                 _: &LateContext<'a, 'tcx>,\n                 _: FnKind<'tcx>,\n                 _: &'tcx hir::FnDecl,\n-                _: &'tcx hir::Expr,\n+                _: &'tcx hir::Body,\n                 _: Span,\n                 _: ast::NodeId) { }\n     fn check_fn_post(&mut self,\n                      _: &LateContext<'a, 'tcx>,\n                      _: FnKind<'tcx>,\n                      _: &'tcx hir::FnDecl,\n-                     _: &'tcx hir::Expr,\n+                     _: &'tcx hir::Body,\n                      _: Span,\n                      _: ast::NodeId) { }\n     fn check_trait_item(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::TraitItem) { }"}, {"sha": "4c2e43f8e225f22c55dc6ca76b7f345ff62d8dba", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -38,7 +38,6 @@ use std::rc::Rc;\n use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n-use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_back::target::Target;\n@@ -140,7 +139,7 @@ pub struct NativeLibrary {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct InlinedItem {\n     pub def_id: DefId,\n-    pub body: P<hir::Expr>,\n+    pub body: hir::Body,\n     pub const_fn_args: Vec<Option<DefId>>,\n }\n \n@@ -149,7 +148,7 @@ pub struct InlinedItem {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, Hash, Debug)]\n pub struct InlinedItemRef<'a> {\n     pub def_id: DefId,\n-    pub body: &'a hir::Expr,\n+    pub body: &'a hir::Body,\n     pub const_fn_args: Vec<Option<DefId>>,\n }\n \n@@ -160,73 +159,73 @@ fn get_fn_args(decl: &hir::FnDecl) -> Vec<Option<DefId>> {\n     }).collect()\n }\n \n-impl<'a> InlinedItemRef<'a> {\n-    pub fn from_item<'b, 'tcx>(def_id: DefId,\n-                               item: &'a hir::Item,\n-                               tcx: TyCtxt<'b, 'a, 'tcx>)\n-                               -> InlinedItemRef<'a> {\n-        let (body, args) = match item.node {\n+impl<'a, 'tcx> InlinedItemRef<'tcx> {\n+    pub fn from_item(def_id: DefId,\n+                     item: &hir::Item,\n+                     tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                     -> InlinedItemRef<'tcx> {\n+        let (body_id, args) = match item.node {\n             hir::ItemFn(ref decl, _, _, _, _, body_id) =>\n-                (tcx.map.expr(body_id), get_fn_args(decl)),\n-            hir::ItemConst(_, ref body) => (&**body, Vec::new()),\n+                (body_id, get_fn_args(decl)),\n+            hir::ItemConst(_, body_id) => (body_id, vec![]),\n             _ => bug!(\"InlinedItemRef::from_item wrong kind\")\n         };\n         InlinedItemRef {\n             def_id: def_id,\n-            body: body,\n+            body: tcx.map.body(body_id),\n             const_fn_args: args\n         }\n     }\n \n     pub fn from_trait_item(def_id: DefId,\n-                           item: &'a hir::TraitItem,\n-                           _tcx: TyCtxt)\n-                           -> InlinedItemRef<'a> {\n-        let (body, args) = match item.node {\n-            hir::TraitItemKind::Const(_, Some(ref body)) =>\n-                (&**body, Vec::new()),\n+                           item: &hir::TraitItem,\n+                           tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                           -> InlinedItemRef<'tcx> {\n+        let (body_id, args) = match item.node {\n+            hir::TraitItemKind::Const(_, Some(body_id)) =>\n+                (body_id, vec![]),\n             hir::TraitItemKind::Const(_, None) => {\n                 bug!(\"InlinedItemRef::from_trait_item called for const without body\")\n             },\n             _ => bug!(\"InlinedItemRef::from_trait_item wrong kind\")\n         };\n         InlinedItemRef {\n             def_id: def_id,\n-            body: body,\n+            body: tcx.map.body(body_id),\n             const_fn_args: args\n         }\n     }\n \n-    pub fn from_impl_item<'b, 'tcx>(def_id: DefId,\n-                                    item: &'a hir::ImplItem,\n-                                    tcx: TyCtxt<'b, 'a, 'tcx>)\n-                                    -> InlinedItemRef<'a> {\n-        let (body, args) = match item.node {\n+    pub fn from_impl_item(def_id: DefId,\n+                          item: &hir::ImplItem,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                          -> InlinedItemRef<'tcx> {\n+        let (body_id, args) = match item.node {\n             hir::ImplItemKind::Method(ref sig, body_id) =>\n-                (tcx.map.expr(body_id), get_fn_args(&sig.decl)),\n-            hir::ImplItemKind::Const(_, ref body) =>\n-                (&**body, Vec::new()),\n+                (body_id, get_fn_args(&sig.decl)),\n+            hir::ImplItemKind::Const(_, body_id) =>\n+                (body_id, vec![]),\n             _ => bug!(\"InlinedItemRef::from_impl_item wrong kind\")\n         };\n         InlinedItemRef {\n             def_id: def_id,\n-            body: body,\n+            body: tcx.map.body(body_id),\n             const_fn_args: args\n         }\n     }\n \n     pub fn visit<V>(&self, visitor: &mut V)\n-        where V: Visitor<'a>\n+        where V: Visitor<'tcx>\n     {\n-        visitor.visit_expr(&self.body);\n+        visitor.visit_body(self.body);\n     }\n }\n \n impl InlinedItem {\n     pub fn visit<'ast,V>(&'ast self, visitor: &mut V)\n         where V: Visitor<'ast>\n     {\n-        visitor.visit_expr(&self.body);\n+        visitor.visit_body(&self.body);\n     }\n }\n "}, {"sha": "8705393849ae2581321a053f3af2c90f5b2a66b4", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -194,7 +194,7 @@ fn build_nodeid_to_index(decl: Option<&hir::FnDecl>,\n         intravisit::walk_fn_decl(&mut formals, decl);\n         impl<'a, 'v> intravisit::Visitor<'v> for Formals<'a> {\n             fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'v> {\n-                panic!(\"should not encounter fn bodies or items\")\n+                intravisit::NestedVisitorMap::None\n             }\n \n             fn visit_pat(&mut self, p: &hir::Pat) {\n@@ -502,7 +502,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n //                                ^^^^^^^^^^^^^ only needed for pretty printing\n-    pub fn propagate(&mut self, cfg: &cfg::CFG, body: &hir::Expr) {\n+    pub fn propagate(&mut self, cfg: &cfg::CFG, body: &hir::Body) {\n         //! Performs the data flow analysis.\n \n         if self.bits_per_id == 0 {\n@@ -534,11 +534,11 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n     }\n \n     fn pretty_print_to<'b>(&self, wr: Box<io::Write + 'b>,\n-                           body: &hir::Expr) -> io::Result<()> {\n+                           body: &hir::Body) -> io::Result<()> {\n         let mut ps = pprust::rust_printer_annotated(wr, self, None);\n         ps.cbox(pprust::indent_unit)?;\n         ps.ibox(0)?;\n-        ps.print_expr(body)?;\n+        ps.print_expr(&body.value)?;\n         pp::eof(&mut ps.s)\n     }\n }"}, {"sha": "926975d1423b0b65e533efdb78c3862983f04728", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -551,19 +551,19 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         match impl_item.node {\n-            hir::ImplItemKind::Const(_, ref expr) => {\n+            hir::ImplItemKind::Const(_, body_id) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n                     self.warn_dead_code(impl_item.id, impl_item.span,\n                                         impl_item.name, \"associated const\");\n                 }\n-                intravisit::walk_expr(self, expr)\n+                self.visit_nested_body(body_id)\n             }\n             hir::ImplItemKind::Method(_, body_id) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n                     self.warn_dead_code(impl_item.id, impl_item.span,\n                                         impl_item.name, \"method\");\n                 }\n-                self.visit_body(body_id)\n+                self.visit_nested_body(body_id)\n             }\n             hir::ImplItemKind::Type(..) => {}\n         }\n@@ -572,11 +572,9 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     // Overwrite so that we don't warn the trait item itself.\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         match trait_item.node {\n-            hir::TraitItemKind::Const(_, Some(ref body)) => {\n-                intravisit::walk_expr(self, body)\n-            }\n+            hir::TraitItemKind::Const(_, Some(body_id)) |\n             hir::TraitItemKind::Method(_, Some(body_id)) => {\n-                self.visit_body(body_id)\n+                self.visit_nested_body(body_id)\n             }\n             hir::TraitItemKind::Const(_, None) |\n             hir::TraitItemKind::Method(_, None) |"}, {"sha": "38b0b18b0129af7b7c6263505c85740c9d131eb3", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, fn_decl: &'tcx hir::FnDecl,\n-                body_id: hir::ExprId, span: Span, id: ast::NodeId) {\n+                body_id: hir::BodyId, span: Span, id: ast::NodeId) {\n \n         let (is_item_fn, is_unsafe_fn) = match fn_kind {\n             FnKind::ItemFn(_, _, unsafety, ..) =>"}, {"sha": "1efc4b37ed5a7896ad0eaf2cb8046d8c8e1bd5ff", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -289,9 +289,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n     pub fn walk_fn(&mut self,\n                    decl: &hir::FnDecl,\n-                   body: &hir::Expr) {\n-        self.walk_arg_patterns(decl, body);\n-        self.consume_expr(body);\n+                   body: &hir::Body) {\n+        self.walk_arg_patterns(decl, &body.value);\n+        self.consume_expr(&body.value);\n     }\n \n     fn walk_arg_patterns(&mut self,\n@@ -537,9 +537,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            hir::ExprRepeat(ref base, ref count) => {\n+            hir::ExprRepeat(ref base, _) => {\n                 self.consume_expr(&base);\n-                self.consume_expr(&count);\n             }\n \n             hir::ExprClosure(.., fn_decl_span) => {"}, {"sha": "d932061d42d3db4984f56ee62c9373873398416d", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -34,13 +34,13 @@ struct ItemVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> ItemVisitor<'a, 'tcx> {\n-    fn visit_const(&mut self, item_id: ast::NodeId, expr: &'tcx hir::Expr) {\n+    fn visit_const(&mut self, item_id: ast::NodeId, body: hir::BodyId) {\n         let param_env = ty::ParameterEnvironment::for_item(self.tcx, item_id);\n         self.tcx.infer_ctxt(None, Some(param_env), Reveal::All).enter(|infcx| {\n             let mut visitor = ExprVisitor {\n                 infcx: &infcx\n             };\n-            visitor.visit_expr(expr);\n+            visitor.visit_nested_body(body);\n         });\n     }\n }\n@@ -122,33 +122,33 @@ impl<'a, 'tcx> Visitor<'tcx> for ItemVisitor<'a, 'tcx> {\n     }\n \n     // const, static and N in [T; N].\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_body(&mut self, body: &'tcx hir::Body) {\n         self.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n             let mut visitor = ExprVisitor {\n                 infcx: &infcx\n             };\n-            visitor.visit_expr(expr);\n+            visitor.visit_body(body);\n         });\n     }\n \n     fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n-        if let hir::TraitItemKind::Const(_, Some(ref expr)) = item.node {\n-            self.visit_const(item.id, expr);\n+        if let hir::TraitItemKind::Const(_, Some(body)) = item.node {\n+            self.visit_const(item.id, body);\n         } else {\n             intravisit::walk_trait_item(self, item);\n         }\n     }\n \n     fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n-        if let hir::ImplItemKind::Const(_, ref expr) = item.node {\n-            self.visit_const(item.id, expr);\n+        if let hir::ImplItemKind::Const(_, body) = item.node {\n+            self.visit_const(item.id, body);\n         } else {\n             intravisit::walk_impl_item(self, item);\n         }\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n-                b: hir::ExprId, s: Span, id: ast::NodeId) {\n+                b: hir::BodyId, s: Span, id: ast::NodeId) {\n         if let FnKind::Closure(..) = fk {\n             span_bug!(s, \"intrinsicck: closure outside of function\")\n         }"}, {"sha": "ea1c897708b58a8b11f80eefdfc26ae43a9fd666", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -188,7 +188,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IrMaps<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n-                b: hir::ExprId, s: Span, id: NodeId) {\n+                b: hir::BodyId, s: Span, id: NodeId) {\n         visit_fn(self, fk, fd, b, s, id);\n     }\n     fn visit_local(&mut self, l: &'tcx hir::Local) { visit_local(self, l); }\n@@ -354,13 +354,9 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.ir.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n-    fn visit_fn(&mut self, _: FnKind<'tcx>, _: &'tcx hir::FnDecl,\n-                _: hir::ExprId, _: Span, _: NodeId) {\n-        // do not check contents of nested fns\n-    }\n     fn visit_local(&mut self, l: &'tcx hir::Local) {\n         check_local(self, l);\n     }\n@@ -375,7 +371,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n                           fk: FnKind<'tcx>,\n                           decl: &'tcx hir::FnDecl,\n-                          body_id: hir::ExprId,\n+                          body_id: hir::BodyId,\n                           sp: Span,\n                           id: ast::NodeId) {\n     debug!(\"visit_fn\");\n@@ -408,14 +404,14 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n         clean_exit_var: fn_maps.add_variable(CleanExit)\n     };\n \n-    let body = ir.tcx.map.expr(body_id);\n+    let body = ir.tcx.map.body(body_id);\n \n     // compute liveness\n     let mut lsets = Liveness::new(&mut fn_maps, specials);\n-    let entry_ln = lsets.compute(body);\n+    let entry_ln = lsets.compute(&body.value);\n \n     // check for various error conditions\n-    lsets.visit_expr(body);\n+    lsets.visit_body(body);\n     lsets.check_ret(id, sp, fk, entry_ln, body);\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n@@ -942,7 +938,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               loop. The next-node for a continue is the top of this loop.\n               */\n               let node = self.live_node(expr.id, expr.span);\n-              self.with_loop_nodes(blk_id.node_id(), succ, node, |this| {\n+              self.with_loop_nodes(blk_id.node_id, succ, node, |this| {\n \n                  // the construction of a closure itself is not important,\n                  // but we have to consider the closed over variables.\n@@ -1088,11 +1084,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_exprs(exprs, succ)\n           }\n \n-          hir::ExprRepeat(ref element, ref count) => {\n-            let succ = self.propagate_through_expr(&count, succ);\n-            self.propagate_through_expr(&element, succ)\n-          }\n-\n           hir::ExprStruct(_, ref fields, ref with_expr) => {\n             let succ = self.propagate_through_opt_expr(with_expr.as_ref().map(|e| &**e), succ);\n             fields.iter().rev().fold(succ, |succ, field| {\n@@ -1149,7 +1140,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           hir::ExprAddrOf(_, ref e) |\n           hir::ExprCast(ref e, _) |\n           hir::ExprType(ref e, _) |\n-          hir::ExprUnary(_, ref e) => {\n+          hir::ExprUnary(_, ref e) |\n+          hir::ExprRepeat(ref e, _) => {\n             self.propagate_through_expr(&e, succ)\n           }\n \n@@ -1443,7 +1435,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                  sp: Span,\n                  fk: FnKind,\n                  entry_ln: LiveNode,\n-                 body: &hir::Expr)\n+                 body: &hir::Body)\n     {\n         let fn_ty = if let FnKind::Closure(_) = fk {\n             self.ir.tcx.tables().node_id_to_type(id)\n@@ -1460,7 +1452,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // and must outlive the *call-site* of the function.\n         let fn_ret =\n             self.ir.tcx.liberate_late_bound_regions(\n-                self.ir.tcx.region_maps.call_site_extent(id, body.id),\n+                self.ir.tcx.region_maps.call_site_extent(id, body.value.id),\n                 &fn_ret);\n \n         if !fn_ret.is_never() && self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {"}, {"sha": "fdc5087ce9ba602e797491e75a0eec366ccced53", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -705,7 +705,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             };\n \n             match fn_expr.node {\n-                hir::ExprClosure(.., body_id, _) => body_id.node_id(),\n+                hir::ExprClosure(.., body_id, _) => body_id.node_id,\n                 _ => bug!()\n             }\n         };"}, {"sha": "34a42dede75899ed5f33ba270cd6d3250ca5b466", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -250,15 +250,15 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 match item.node {\n                     hir::ItemFn(.., body) => {\n                         if item_might_be_inlined(&item) {\n-                            self.visit_body(body);\n+                            self.visit_nested_body(body);\n                         }\n                     }\n \n                     // Reachable constants will be inlined into other crates\n                     // unconditionally, so we need to make sure that their\n                     // contents are also reachable.\n-                    hir::ItemConst(_, ref init) => {\n-                        self.visit_expr(&init);\n+                    hir::ItemConst(_, init) => {\n+                        self.visit_nested_body(init);\n                     }\n \n                     // These are normal, nothing reachable about these\n@@ -278,24 +278,22 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::TraitItemKind::Method(_, None) => {\n                         // Keep going, nothing to get exported\n                     }\n-                    hir::TraitItemKind::Const(_, Some(ref body)) => {\n-                        self.visit_expr(body);\n-                    }\n+                    hir::TraitItemKind::Const(_, Some(body_id)) |\n                     hir::TraitItemKind::Method(_, Some(body_id)) => {\n-                        self.visit_body(body_id);\n+                        self.visit_nested_body(body_id);\n                     }\n                     hir::TraitItemKind::Type(..) => {}\n                 }\n             }\n             ast_map::NodeImplItem(impl_item) => {\n                 match impl_item.node {\n-                    hir::ImplItemKind::Const(_, ref expr) => {\n-                        self.visit_expr(&expr);\n+                    hir::ImplItemKind::Const(_, body) => {\n+                        self.visit_nested_body(body);\n                     }\n                     hir::ImplItemKind::Method(ref sig, body) => {\n                         let did = self.tcx.map.get_parent_did(search_item);\n                         if method_might_be_inlined(self.tcx, sig, impl_item, did) {\n-                            self.visit_body(body)\n+                            self.visit_nested_body(body)\n                         }\n                     }\n                     hir::ImplItemKind::Type(_) => {}"}, {"sha": "faf4a448b7a84e5b20ea8d0ba53384044bc74a78", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -1088,7 +1088,7 @@ fn resolve_item_like<'a, 'tcx, F>(visitor: &mut RegionResolutionVisitor<'tcx, 'a\n fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n                         kind: FnKind<'tcx>,\n                         decl: &'tcx hir::FnDecl,\n-                        body_id: hir::ExprId,\n+                        body_id: hir::BodyId,\n                         sp: Span,\n                         id: ast::NodeId) {\n     debug!(\"region::resolve_fn(id={:?}, \\\n@@ -1101,22 +1101,22 @@ fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n            visitor.cx.parent);\n \n     visitor.cx.parent = visitor.new_code_extent(\n-        CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id() });\n+        CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id });\n \n     let fn_decl_scope = visitor.new_code_extent(\n-        CodeExtentData::ParameterScope { fn_id: id, body_id: body_id.node_id() });\n+        CodeExtentData::ParameterScope { fn_id: id, body_id: body_id.node_id });\n \n     if let Some(root_id) = visitor.cx.root_id {\n-        visitor.region_maps.record_fn_parent(body_id.node_id(), root_id);\n+        visitor.region_maps.record_fn_parent(body_id.node_id, root_id);\n     }\n \n     let outer_cx = visitor.cx;\n     let outer_ts = mem::replace(&mut visitor.terminating_scopes, NodeSet());\n-    visitor.terminating_scopes.insert(body_id.node_id());\n+    visitor.terminating_scopes.insert(body_id.node_id);\n \n     // The arguments and `self` are parented to the fn.\n     visitor.cx = Context {\n-        root_id: Some(body_id.node_id()),\n+        root_id: Some(body_id.node_id),\n         parent: ROOT_CODE_EXTENT,\n         var_parent: fn_decl_scope,\n     };\n@@ -1126,11 +1126,11 @@ fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n \n     // The body of the every fn is a root scope.\n     visitor.cx = Context {\n-        root_id: Some(body_id.node_id()),\n+        root_id: Some(body_id.node_id),\n         parent: fn_decl_scope,\n         var_parent: fn_decl_scope\n     };\n-    visitor.visit_body(body_id);\n+    visitor.visit_nested_body(body_id);\n \n     // Restore context we had at the start.\n     visitor.cx = outer_cx;\n@@ -1195,7 +1195,7 @@ impl<'ast, 'a> Visitor<'ast> for RegionResolutionVisitor<'ast, 'a> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'ast>, fd: &'ast FnDecl,\n-                b: hir::ExprId, s: Span, n: NodeId) {\n+                b: hir::BodyId, s: Span, n: NodeId) {\n         resolve_fn(self, fk, fd, b, s, n);\n     }\n     fn visit_arm(&mut self, a: &'ast Arm) {"}, {"sha": "9b70c522362d4262b1eab829ae7356dff353b966", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -206,7 +206,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n-                b: hir::ExprId, s: Span, fn_id: ast::NodeId) {\n+                b: hir::BodyId, s: Span, fn_id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, generics, ..) => {\n                 self.visit_early_late(fn_id,decl, generics, |this| {\n@@ -407,7 +407,7 @@ fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, sha\n \n // Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n // if one of the label shadows a lifetime or another label.\n-fn extract_labels(ctxt: &mut LifetimeContext, b: hir::ExprId) {\n+fn extract_labels(ctxt: &mut LifetimeContext, b: hir::BodyId) {\n     struct GatherLabels<'a> {\n         sess: &'a Session,\n         scope: Scope<'a>,\n@@ -419,7 +419,7 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: hir::ExprId) {\n         scope: ctxt.scope,\n         labels_in_fn: &mut ctxt.labels_in_fn,\n     };\n-    gather.visit_expr(ctxt.hir_map.expr(b));\n+    gather.visit_body(ctxt.hir_map.body(b));\n     return;\n \n     impl<'v, 'a> Visitor<'v> for GatherLabels<'a> {\n@@ -501,7 +501,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn add_scope_and_walk_fn(&mut self,\n                              fk: FnKind<'tcx>,\n                              fd: &'tcx hir::FnDecl,\n-                             fb: hir::ExprId,\n+                             fb: hir::BodyId,\n                              _span: Span,\n                              fn_id: ast::NodeId) {\n         match fk {\n@@ -522,8 +522,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // `self.labels_in_fn`.\n         extract_labels(self, fb);\n \n-        self.with(FnScope { fn_id: fn_id, body_id: fb.node_id(), s: self.scope },\n-                  |_old_scope, this| this.visit_body(fb))\n+        self.with(FnScope { fn_id: fn_id, body_id: fb.node_id, s: self.scope },\n+                  |_old_scope, this| this.visit_nested_body(fb))\n     }\n \n     // FIXME(#37666) this works around a limitation in the region inferencer"}, {"sha": "28192cd1873d3733fe0ec86c0779ff077316e441", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -1206,7 +1206,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         tcx.construct_parameter_environment(\n                             impl_item.span,\n                             tcx.map.local_def_id(id),\n-                            tcx.region_maps.call_site_extent(id, body.node_id()))\n+                            tcx.region_maps.call_site_extent(id, body.node_id))\n                     }\n                 }\n             }\n@@ -1227,7 +1227,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         // to the method id).\n                         let extent = if let Some(body_id) = *body {\n                             // default impl: use call_site extent as free_id_outlive bound.\n-                            tcx.region_maps.call_site_extent(id, body_id.node_id())\n+                            tcx.region_maps.call_site_extent(id, body_id.node_id)\n                         } else {\n                             // no default impl: use item extent as free_id_outlive bound.\n                             tcx.region_maps.item_extent(id)\n@@ -1248,7 +1248,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         tcx.construct_parameter_environment(\n                             item.span,\n                             fn_def_id,\n-                            tcx.region_maps.call_site_extent(id, body_id.node_id()))\n+                            tcx.region_maps.call_site_extent(id, body_id.node_id))\n                     }\n                     hir::ItemEnum(..) |\n                     hir::ItemStruct(..) |\n@@ -1284,7 +1284,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                     tcx.construct_parameter_environment(\n                         expr.span,\n                         base_def_id,\n-                        tcx.region_maps.call_site_extent(id, body.node_id()))\n+                        tcx.region_maps.call_site_extent(id, body.node_id))\n                 } else {\n                     tcx.empty_parameter_environment()\n                 }"}, {"sha": "e5b764be8799abfea103c58ed27d932a7cbb0212", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -190,8 +190,8 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      all_loans: &[Loan<'tcx>],\n                                      fn_id: ast::NodeId,\n                                      decl: &hir::FnDecl,\n-                                     body: &hir::Expr) {\n-    debug!(\"check_loans(body id={})\", body.id);\n+                                     body: &hir::Body) {\n+    debug!(\"check_loans(body id={})\", body.value.id);\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n     let infcx = bccx.tcx.borrowck_fake_infer_ctxt(param_env);"}, {"sha": "50b276ce694117a0b5e83631bebb8c933fb20452", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -42,13 +42,13 @@ mod move_error;\n pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                     fn_id: NodeId,\n                                     decl: &hir::FnDecl,\n-                                    body: &hir::Expr)\n+                                    body: &hir::Body)\n                                     -> (Vec<Loan<'tcx>>,\n                                         move_data::MoveData<'tcx>) {\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n         all_loans: Vec::new(),\n-        item_ub: bccx.tcx.region_maps.node_extent(body.id),\n+        item_ub: bccx.tcx.region_maps.node_extent(body.value.id),\n         move_data: MoveData::new(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n@@ -548,14 +548,14 @@ impl<'a, 'tcx> Visitor<'tcx> for StaticInitializerCtxt<'a, 'tcx> {\n \n pub fn gather_loans_in_static_initializer<'a, 'tcx>(bccx: &mut BorrowckCtxt<'a, 'tcx>,\n                                                     item_id: ast::NodeId,\n-                                                    expr: &'tcx hir::Expr) {\n+                                                    body: hir::BodyId) {\n \n-    debug!(\"gather_loans_in_static_initializer(expr={:?})\", expr);\n+    debug!(\"gather_loans_in_static_initializer(expr={:?})\", body);\n \n     let mut sicx = StaticInitializerCtxt {\n         bccx: bccx,\n         item_id: item_id\n     };\n \n-    sicx.visit_expr(expr);\n+    sicx.visit_nested_body(body);\n }"}, {"sha": "c3ff564121c567c7a70492a1f8eba21c7d754c5b", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -11,10 +11,7 @@\n use borrowck::BorrowckCtxt;\n \n use syntax::ast::{self, MetaItem};\n-use syntax_pos::{Span, DUMMY_SP};\n-\n-use rustc::hir;\n-use rustc::hir::intravisit::{FnKind};\n+use syntax_pos::DUMMY_SP;\n \n use rustc::mir::{self, BasicBlock, BasicBlockData, Mir, Statement, Terminator, Location};\n use rustc::session::Session;\n@@ -55,27 +52,14 @@ pub struct MoveDataParamEnv<'tcx> {\n }\n \n pub fn borrowck_mir(bcx: &mut BorrowckCtxt,\n-                    fk: FnKind,\n-                    _decl: &hir::FnDecl,\n-                    body: &hir::Expr,\n-                    _sp: Span,\n                     id: ast::NodeId,\n                     attributes: &[ast::Attribute]) {\n-    match fk {\n-        FnKind::ItemFn(name, ..) |\n-        FnKind::Method(name, ..) => {\n-            debug!(\"borrowck_mir({}) UNIMPLEMENTED\", name);\n-        }\n-        FnKind::Closure(_) => {\n-            debug!(\"borrowck_mir closure (body.id={}) UNIMPLEMENTED\", body.id);\n-        }\n-    }\n-\n     let tcx = bcx.tcx;\n-    let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n-\n-    let mir = &tcx.item_mir(tcx.map.local_def_id(id));\n+    let def_id = tcx.map.local_def_id(id);\n+    debug!(\"borrowck_mir({}) UNIMPLEMENTED\", tcx.item_path_str(def_id));\n \n+    let mir = &tcx.item_mir(def_id);\n+    let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n     let move_data = MoveData::gather_moves(mir, tcx, &param_env);\n     let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n     let flow_inits ="}, {"sha": "93c12fed1de278cf00601c495ca321649267a28c", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -68,7 +68,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BorrowckCtxt<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n-                b: hir::ExprId, s: Span, id: ast::NodeId) {\n+                b: hir::BodyId, s: Span, id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(..) |\n             FnKind::Method(..) => {\n@@ -88,15 +88,15 @@ impl<'a, 'tcx> Visitor<'tcx> for BorrowckCtxt<'a, 'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n-        if let hir::TraitItemKind::Const(_, Some(ref expr)) = ti.node {\n-            gather_loans::gather_loans_in_static_initializer(self, ti.id, &expr);\n+        if let hir::TraitItemKind::Const(_, Some(expr)) = ti.node {\n+            gather_loans::gather_loans_in_static_initializer(self, ti.id, expr);\n         }\n         intravisit::walk_trait_item(self, ti);\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n-        if let hir::ImplItemKind::Const(_, ref expr) = ii.node {\n-            gather_loans::gather_loans_in_static_initializer(self, ii.id, &expr);\n+        if let hir::ImplItemKind::Const(_, expr) = ii.node {\n+            gather_loans::gather_loans_in_static_initializer(self, ii.id, expr);\n         }\n         intravisit::walk_impl_item(self, ii);\n     }\n@@ -141,9 +141,9 @@ fn borrowck_item<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>, item: &'tcx hir::I\n     // loan step is intended for things that have a data\n     // flow dependent conditions.\n     match item.node {\n-        hir::ItemStatic(.., ref ex) |\n-        hir::ItemConst(_, ref ex) => {\n-            gather_loans::gather_loans_in_static_initializer(this, item.id, &ex);\n+        hir::ItemStatic(.., ex) |\n+        hir::ItemConst(_, ex) => {\n+            gather_loans::gather_loans_in_static_initializer(this, item.id, ex);\n         }\n         _ => { }\n     }\n@@ -161,21 +161,21 @@ pub struct AnalysisData<'a, 'tcx: 'a> {\n fn borrowck_fn<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                          fk: FnKind<'tcx>,\n                          decl: &'tcx hir::FnDecl,\n-                         body_id: hir::ExprId,\n+                         body_id: hir::BodyId,\n                          sp: Span,\n                          id: ast::NodeId,\n                          attributes: &[ast::Attribute]) {\n     debug!(\"borrowck_fn(id={})\", id);\n \n-    let body = this.tcx.map.expr(body_id);\n+    let body = this.tcx.map.body(body_id);\n \n     if attributes.iter().any(|item| item.check_name(\"rustc_mir_borrowck\")) {\n         this.with_temp_region_map(id, |this| {\n-            mir::borrowck_mir(this, fk, decl, body, sp, id, attributes)\n+            mir::borrowck_mir(this, id, attributes)\n         });\n     }\n \n-    let cfg = cfg::CFG::new(this.tcx, body);\n+    let cfg = cfg::CFG::new(this.tcx, &body.value);\n     let AnalysisData { all_loans,\n                        loans: loan_dfcx,\n                        move_data: flowed_moves } =\n@@ -204,14 +204,14 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                                           fk: FnKind<'tcx>,\n                                           decl: &'tcx hir::FnDecl,\n                                           cfg: &cfg::CFG,\n-                                          body: &'tcx hir::Expr,\n+                                          body: &'tcx hir::Body,\n                                           sp: Span,\n                                           id: ast::NodeId)\n                                           -> AnalysisData<'a, 'tcx>\n {\n     // Check the body of fn items.\n     let tcx = this.tcx;\n-    let id_range = intravisit::compute_id_range_for_fn_body(fk, decl, body, sp, id, &tcx.map);\n+    let id_range = intravisit::compute_id_range_for_fn_body(fk, decl, body.id(), sp, id, &tcx.map);\n     let (all_loans, move_data) =\n         gather_loans::gather_loans_in_fn(this, id, decl, body);\n \n@@ -263,7 +263,7 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n         }\n     };\n \n-    let body = tcx.map.expr(fn_parts.body);\n+    let body = tcx.map.body(fn_parts.body);\n \n     let dataflow_data = build_borrowck_dataflow_data(&mut bccx,\n                                                      fn_parts.kind,\n@@ -416,7 +416,7 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n     match tcx.map.get(closure_id) {\n         hir_map::NodeExpr(expr) => match expr.node {\n             hir::ExprClosure(.., body_id, _) => {\n-                body_id.node_id()\n+                body_id.node_id\n             }\n             _ => {\n                 bug!(\"encountered non-closure id: {}\", closure_id)"}, {"sha": "6a5ee13bb845c9c133bcd76aa26c9f898e600651", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -656,7 +656,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n                cfg: &cfg::CFG,\n                id_range: IdRange,\n                decl: &hir::FnDecl,\n-               body: &hir::Expr)\n+               body: &hir::Body)\n                -> FlowedMoveData<'a, 'tcx> {\n         let mut dfcx_moves =\n             DataFlowContext::new(tcx,"}, {"sha": "cb1d67d01c7704f459fae136eec9506d1e52a94b", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -67,7 +67,7 @@ impl<'a, 'tcx> Visitor<'tcx> for OuterVisitor<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n-                b: hir::ExprId, s: Span, id: ast::NodeId) {\n+                b: hir::BodyId, s: Span, id: ast::NodeId) {\n         if let FnKind::Closure(..) = fk {\n             span_bug!(s, \"check_match: closure outside of function\")\n         }\n@@ -120,7 +120,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n-                b: hir::ExprId, s: Span, n: ast::NodeId) {\n+                b: hir::BodyId, s: Span, n: ast::NodeId) {\n         intravisit::walk_fn(self, fk, fd, b, s, n);\n \n         for input in &fd.inputs {"}, {"sha": "b24cd261dd58474730ee98fc242ef15f222e803f", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -576,18 +576,18 @@ https://doc.rust-lang.org/reference.html#ffi-attributes\n \n \n E0306: r##\"\n-In an array literal `[x; N]`, `N` is the number of elements in the array. This\n+In an array type `[T; N]`, `N` is the number of elements in the array. This\n must be an unsigned integer. Erroneous code example:\n \n ```compile_fail,E0306\n-let x = [0i32; true]; // error: expected positive integer for repeat count,\n-                      //        found boolean\n+const X: [i32; true] = [0]; // error: expected `usize` for array length,\n+                            //        found boolean\n ```\n \n Working example:\n \n ```\n-let x = [0i32; 2];\n+const X: [i32; 1] = [0];\n ```\n \"##,\n }"}, {"sha": "c42b558830fc885118e064d38fc1299ec87f465d", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -56,15 +56,17 @@ macro_rules! math {\n fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   variant_def: DefId)\n                                   -> Option<&'tcx Expr> {\n-    fn variant_expr<'a>(variants: &'a [hir::Variant], id: ast::NodeId)\n-                        -> Option<&'a Expr> {\n+    let variant_expr = |variants: &'tcx [hir::Variant], id: ast::NodeId |\n+                        -> Option<&'tcx Expr> {\n         for variant in variants {\n             if variant.node.data.id() == id {\n-                return variant.node.disr_expr.as_ref().map(|e| &**e);\n+                return variant.node.disr_expr.map(|e| {\n+                    &tcx.map.body(e).value\n+                });\n             }\n         }\n         None\n-    }\n+    };\n \n     if let Some(variant_node_id) = tcx.map.as_local_node_id(variant_def) {\n         let enum_node_id = tcx.map.get_parent(variant_node_id);\n@@ -96,21 +98,24 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         match tcx.map.find(node_id) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n-                hir::ItemConst(ref ty, ref const_expr) => {\n-                    Some((&const_expr, tcx.ast_ty_to_prim_ty(ty)))\n+                hir::ItemConst(ref ty, body) => {\n+                    Some((&tcx.map.body(body).value,\n+                          tcx.ast_ty_to_prim_ty(ty)))\n                 }\n                 _ => None\n             },\n             Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n-                hir::TraitItemKind::Const(ref ty, ref expr_option) => {\n+                hir::TraitItemKind::Const(ref ty, default) => {\n                     if let Some(substs) = substs {\n                         // If we have a trait item and the substitutions for it,\n                         // `resolve_trait_associated_const` will select an impl\n                         // or the default.\n                         let trait_id = tcx.map.get_parent(node_id);\n                         let trait_id = tcx.map.local_def_id(trait_id);\n-                        let default_value = expr_option.as_ref()\n-                            .map(|expr| (&**expr, tcx.ast_ty_to_prim_ty(ty)));\n+                        let default_value = default.map(|body| {\n+                            (&tcx.map.body(body).value,\n+                             tcx.ast_ty_to_prim_ty(ty))\n+                        });\n                         resolve_trait_associated_const(tcx, def_id, default_value, trait_id, substs)\n                     } else {\n                         // Technically, without knowing anything about the\n@@ -125,8 +130,9 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 _ => None\n             },\n             Some(ast_map::NodeImplItem(ii)) => match ii.node {\n-                hir::ImplItemKind::Const(ref ty, ref expr) => {\n-                    Some((&expr, tcx.ast_ty_to_prim_ty(ty)))\n+                hir::ImplItemKind::Const(ref ty, body) => {\n+                    Some((&tcx.map.body(body).value,\n+                          tcx.ast_ty_to_prim_ty(ty)))\n                 }\n                 _ => None\n             },\n@@ -142,8 +148,8 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n         let mut used_substs = false;\n         let expr_ty = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n-            Some((&InlinedItem { body: ref const_expr, .. }, _)) => {\n-                Some((&**const_expr, Some(tcx.sess.cstore.item_type(tcx, def_id))))\n+            Some((&InlinedItem { ref body, .. }, _)) => {\n+                Some((&body.value, Some(tcx.sess.cstore.item_type(tcx, def_id))))\n             }\n             _ => None\n         };\n@@ -864,18 +870,18 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               Struct(_) => signal!(e, UnimplementedConstVal(\"tuple struct constructors\")),\n               callee => signal!(e, CallOn(callee)),\n           };\n-          let (arg_defs, body_id) = match lookup_const_fn_by_id(tcx, did) {\n-              Some(ConstFnNode::Inlined(ii)) => (ii.const_fn_args.clone(), ii.body.expr_id()),\n+          let (arg_defs, body) = match lookup_const_fn_by_id(tcx, did) {\n+              Some(ConstFnNode::Inlined(ii)) => (ii.const_fn_args.clone(), &ii.body),\n               Some(ConstFnNode::Local(fn_like)) =>\n                   (fn_like.decl().inputs.iter()\n                    .map(|arg| match arg.pat.node {\n                        hir::PatKind::Binding(_, def_id, _, _) => Some(def_id),\n                        _ => None\n                    }).collect(),\n-                   fn_like.body()),\n+                   tcx.map.body(fn_like.body())),\n               None => signal!(e, NonConstPath),\n           };\n-          let result = tcx.map.expr(body_id);\n+          let result = &body.value;\n           assert_eq!(arg_defs.len(), args.len());\n \n           let mut call_args = DefIdMap();\n@@ -893,7 +899,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               }\n           }\n           debug!(\"const call({:?})\", call_args);\n-          eval_const_expr_partial(tcx, &result, ty_hint, Some(&call_args))?\n+          eval_const_expr_partial(tcx, result, ty_hint, Some(&call_args))?\n       },\n       hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ety) {\n           Ok(val) => val,\n@@ -953,11 +959,12 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n       }\n       hir::ExprArray(ref v) => Array(e.id, v.len() as u64),\n-      hir::ExprRepeat(_, ref n) => {\n+      hir::ExprRepeat(_, n) => {\n           let len_hint = ty_hint.checked_or(tcx.types.usize);\n+          let n = &tcx.map.body(n).value;\n           Repeat(\n               e.id,\n-              match eval_const_expr_partial(tcx, &n, len_hint, fn_args)? {\n+              match eval_const_expr_partial(tcx, n, len_hint, fn_args)? {\n                   Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n                   Integral(_) => signal!(e, RepeatCountNotNatural),\n                   _ => signal!(e, RepeatCountNotInt),"}, {"sha": "8e77beea8e4cf8f7a9ef71169b56f07f99cdaa08", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -702,8 +702,8 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n     let cfg = match code {\n         blocks::Code::Expr(expr) => cfg::CFG::new(tcx, expr),\n         blocks::Code::FnLike(fn_like) => {\n-            let body = tcx.map.expr(fn_like.body());\n-            cfg::CFG::new(tcx, body)\n+            let body = tcx.map.body(fn_like.body());\n+            cfg::CFG::new(tcx, &body.value)\n         },\n     };\n     let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;"}, {"sha": "11ade150d1c6b2cb1c70f8a211c122dcae12c069", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -188,7 +188,7 @@ enum SawAbiComponent<'a> {\n     SawTraitItem(SawTraitOrImplItemComponent),\n     SawImplItem(SawTraitOrImplItemComponent),\n     SawStructField,\n-    SawVariant,\n+    SawVariant(bool),\n     SawQPath,\n     SawPathSegment,\n     SawPathParameters,\n@@ -584,7 +584,7 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n                      g: &'tcx Generics,\n                      item_id: NodeId) {\n         debug!(\"visit_variant: st={:?}\", self.st);\n-        SawVariant.hash(self.st);\n+        SawVariant(v.node.disr_expr.is_some()).hash(self.st);\n         hash_attrs!(self, &v.node.attrs);\n         visit::walk_variant(self, v, g, item_id)\n     }\n@@ -616,7 +616,12 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         // implicitly hashing the discriminant of SawExprComponent.\n         hash_span!(self, ex.span, force_span);\n         hash_attrs!(self, &ex.attrs);\n-        visit::walk_expr(self, ex)\n+\n+        // Always hash nested constant bodies (e.g. n in `[x; n]`).\n+        let hash_bodies = self.hash_bodies;\n+        self.hash_bodies = true;\n+        visit::walk_expr(self, ex);\n+        self.hash_bodies = hash_bodies;\n     }\n \n     fn visit_stmt(&mut self, s: &'tcx Stmt) {\n@@ -686,7 +691,12 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         debug!(\"visit_ty: st={:?}\", self.st);\n         SawTy(saw_ty(&t.node)).hash(self.st);\n         hash_span!(self, t.span);\n-        visit::walk_ty(self, t)\n+\n+        // Always hash nested constant bodies (e.g. N in `[T; N]`).\n+        let hash_bodies = self.hash_bodies;\n+        self.hash_bodies = true;\n+        visit::walk_ty(self, t);\n+        self.hash_bodies = hash_bodies;\n     }\n \n     fn visit_generics(&mut self, g: &'tcx Generics) {\n@@ -1159,7 +1169,7 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             items: _,\n             trait_items: _,\n             impl_items: _,\n-            exprs: _,\n+            bodies: _,\n         } = *krate;\n \n         visit::Visitor::visit_mod(self, module, span, ast::CRATE_NODE_ID);"}, {"sha": "5354233e57c4ba415bcec8b11c6080c05fec3e26", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -243,7 +243,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n                 cx: &LateContext,\n                 fk: FnKind,\n                 _: &hir::FnDecl,\n-                _: &hir::Expr,\n+                _: &hir::Body,\n                 span: Span,\n                 id: ast::NodeId) {\n         match fk {"}, {"sha": "501da6807280b63983737dedaec3e42713c5e80d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -222,7 +222,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnsafeCode {\n                 cx: &LateContext,\n                 fk: FnKind<'tcx>,\n                 _: &hir::FnDecl,\n-                _: &hir::Expr,\n+                _: &hir::Body,\n                 span: Span,\n                 _: ast::NodeId) {\n         match fk {\n@@ -674,7 +674,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                 cx: &LateContext,\n                 fn_kind: FnKind,\n                 _: &hir::FnDecl,\n-                blk: &hir::Expr,\n+                body: &hir::Body,\n                 sp: Span,\n                 id: ast::NodeId) {\n         let method = match fn_kind {\n@@ -712,7 +712,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n         // to have behaviour like the above, rather than\n         // e.g. accidentally recurring after an assert.\n \n-        let cfg = cfg::CFG::new(cx.tcx, blk);\n+        let cfg = cfg::CFG::new(cx.tcx, &body.value);\n \n         let mut work_queue = vec![cfg.entry];\n         let mut reached_exit_without_self_call = false;"}, {"sha": "b4c9a0672b03113d4fc486e3b947837802030e06", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedMut {\n                 cx: &LateContext,\n                 _: FnKind,\n                 decl: &hir::FnDecl,\n-                _: &hir::Expr,\n+                _: &hir::Body,\n                 _: Span,\n                 _: ast::NodeId) {\n         for a in &decl.inputs {"}, {"sha": "6132b23c720bfdd904538b65fcf41911ac3fa9c4", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -485,7 +485,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                     .insert(def_id, None);\n             }\n             Some(&InlinedItem { ref body, .. }) => {\n-                let inlined_root_node_id = find_inlined_item_root(body.id);\n+                let inlined_root_node_id = find_inlined_item_root(body.value.id);\n                 cache_inlined_item(def_id, inlined_root_node_id, inlined_root_node_id);\n             }\n         }"}, {"sha": "1c4225817a9e01066dec49452d801b0f8812c388", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -802,7 +802,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 _ => None,\n             },\n             mir: match item.node {\n-                hir::ItemStatic(..) |\n+                hir::ItemStatic(..) if self.tcx.sess.opts.debugging_opts.always_encode_mir => {\n+                    self.encode_mir(def_id)\n+                }\n                 hir::ItemConst(..) => self.encode_mir(def_id),\n                 hir::ItemFn(_, _, constness, _, ref generics, _) => {\n                     let tps_len = generics.ty_params.len();"}, {"sha": "7eefcdb15d080f2f6172ac202844da4cd4aefdc2", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -126,7 +126,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        arguments: A,\n                                        abi: Abi,\n                                        return_ty: Ty<'gcx>,\n-                                       ast_body: &'gcx hir::Expr)\n+                                       body_id: hir::BodyId)\n                                        -> Mir<'tcx>\n     where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n {\n@@ -136,17 +136,17 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let span = tcx.map.span(fn_id);\n     let mut builder = Builder::new(hir, span, arguments.len(), return_ty);\n \n-    let body_id = ast_body.id;\n     let call_site_extent =\n         tcx.region_maps.lookup_code_extent(\n-            CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id });\n+            CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id.node_id });\n     let arg_extent =\n         tcx.region_maps.lookup_code_extent(\n-            CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body_id });\n+            CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body_id.node_id });\n     let mut block = START_BLOCK;\n     unpack!(block = builder.in_scope(call_site_extent, block, |builder| {\n         unpack!(block = builder.in_scope(arg_extent, block, |builder| {\n-            builder.args_and_body(block, &arguments, arg_extent, ast_body)\n+            let ast_expr = &tcx.map.body(body_id).value;\n+            builder.args_and_body(block, &arguments, arg_extent, ast_expr)\n         }));\n         // Attribute epilogue to function's closing brace\n         let fn_end = Span { lo: span.hi, ..span };\n@@ -197,9 +197,10 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n \n pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        item_id: ast::NodeId,\n-                                       ast_expr: &'tcx hir::Expr)\n+                                       body_id: hir::BodyId)\n                                        -> Mir<'tcx> {\n     let tcx = hir.tcx();\n+    let ast_expr = &tcx.map.body(body_id).value;\n     let ty = tcx.tables().expr_ty_adjusted(ast_expr);\n     let span = tcx.map.span(item_id);\n     let mut builder = Builder::new(hir, span, 0, ty);"}, {"sha": "cc65fdede092ff042575c6b4dd388e0344c8abe7", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -575,7 +575,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         // Now comes the rote stuff:\n-        hir::ExprRepeat(ref v, ref c) => {\n+        hir::ExprRepeat(ref v, c) => {\n+            let c = &cx.tcx.map.body(c).value;\n             ExprKind::Repeat {\n                 value: v.to_ref(),\n                 count: TypedConstVal {\n@@ -585,7 +586,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         ConstVal::Integral(ConstInt::Usize(u)) => u,\n                         other => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n                     },\n-                },\n+                }\n             }\n         }\n         hir::ExprRet(ref v) => ExprKind::Return { value: v.to_ref() },\n@@ -780,7 +781,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let body_id = match cx.tcx.map.find(closure_expr_id) {\n                 Some(map::NodeExpr(expr)) => {\n                     match expr.node {\n-                        hir::ExprClosure(.., body_id, _) => body_id.node_id(),\n+                        hir::ExprClosure(.., body, _) => body.node_id,\n                         _ => {\n                             span_bug!(expr.span, \"closure expr is not a closure expr\");\n                         }"}, {"sha": "607411684e7002a1ef11a8bd5f5f42a910cd14bc", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -129,16 +129,17 @@ impl<'a, 'gcx, 'tcx> CxBuilder<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx> BuildMir<'a, 'gcx> {\n-    fn build_const_integer(&mut self, expr: &'gcx hir::Expr) {\n+    fn build_const_integer(&mut self, body: hir::BodyId) {\n+        let body = self.tcx.map.body(body);\n         // FIXME(eddyb) Closures should have separate\n         // function definition IDs and expression IDs.\n         // Type-checking should not let closures get\n         // this far in an integer constant position.\n-        if let hir::ExprClosure(..) = expr.node {\n+        if let hir::ExprClosure(..) = body.value.node {\n             return;\n         }\n-        self.cx(MirSource::Const(expr.id)).build(|cx| {\n-            build::construct_const(cx, expr.id, expr)\n+        self.cx(MirSource::Const(body.value.id)).build(|cx| {\n+            build::construct_const(cx, body.value.id, body.id())\n         });\n     }\n }\n@@ -151,12 +152,12 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     // Const and static items.\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n-            hir::ItemConst(_, ref expr) => {\n+            hir::ItemConst(_, expr) => {\n                 self.cx(MirSource::Const(item.id)).build(|cx| {\n                     build::construct_const(cx, item.id, expr)\n                 });\n             }\n-            hir::ItemStatic(_, m, ref expr) => {\n+            hir::ItemStatic(_, m, expr) => {\n                 self.cx(MirSource::Static(item.id, m)).build(|cx| {\n                     build::construct_const(cx, item.id, expr)\n                 });\n@@ -168,7 +169,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n \n     // Trait associated const defaults.\n     fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n-        if let hir::TraitItemKind::Const(_, Some(ref expr)) = item.node {\n+        if let hir::TraitItemKind::Const(_, Some(expr)) = item.node {\n             self.cx(MirSource::Const(item.id)).build(|cx| {\n                 build::construct_const(cx, item.id, expr)\n             });\n@@ -178,7 +179,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n \n     // Impl associated const.\n     fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n-        if let hir::ImplItemKind::Const(_, ref expr) = item.node {\n+        if let hir::ImplItemKind::Const(_, expr) = item.node {\n             self.cx(MirSource::Const(item.id)).build(|cx| {\n                 build::construct_const(cx, item.id, expr)\n             });\n@@ -188,15 +189,15 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n \n     // Repeat counts, i.e. [expr; constant].\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if let hir::ExprRepeat(_, ref count) = expr.node {\n+        if let hir::ExprRepeat(_, count) = expr.node {\n             self.build_const_integer(count);\n         }\n         intravisit::walk_expr(self, expr);\n     }\n \n     // Array lengths, i.e. [T; constant].\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyArray(_, ref length) = ty.node {\n+        if let hir::TyArray(_, length) = ty.node {\n             self.build_const_integer(length);\n         }\n         intravisit::walk_ty(self, ty);\n@@ -205,7 +206,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     // Enum variant discriminant values.\n     fn visit_variant(&mut self, v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics, item_id: ast::NodeId) {\n-        if let Some(ref expr) = v.node.disr_expr {\n+        if let Some(expr) = v.node.disr_expr {\n             self.build_const_integer(expr);\n         }\n         intravisit::walk_variant(self, v, g, item_id);\n@@ -214,7 +215,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 fk: FnKind<'tcx>,\n                 decl: &'tcx hir::FnDecl,\n-                body_id: hir::ExprId,\n+                body_id: hir::BodyId,\n                 span: Span,\n                 id: ast::NodeId) {\n         // fetch the fully liberated fn signature (that is, all bound\n@@ -227,7 +228,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n         };\n \n         let (abi, implicit_argument) = if let FnKind::Closure(..) = fk {\n-            (Abi::Rust, Some((closure_self_ty(self.tcx, id, body_id.node_id()), None)))\n+            (Abi::Rust, Some((closure_self_ty(self.tcx, id, body_id.node_id), None)))\n         } else {\n             let def_id = self.tcx.map.local_def_id(id);\n             (self.tcx.item_type(def_id).fn_abi(), None)\n@@ -241,11 +242,9 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n                     (fn_sig.inputs()[index], Some(&*arg.pat))\n                 });\n \n-        let body = self.tcx.map.expr(body_id);\n-\n         let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n         self.cx(MirSource::Fn(id)).build(|cx| {\n-            build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body)\n+            build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body_id)\n         });\n \n         intravisit::walk_fn(self, fk, decl, body_id, span, id);"}, {"sha": "10983aab309fc4cadd2b3fa5dae8cb704b6076ad", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -100,6 +100,11 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n             .enter(|infcx| f(&mut euv::ExprUseVisitor::new(self, &infcx)))\n     }\n \n+    fn global_body(&mut self, mode: Mode, body: hir::BodyId) -> ConstQualif {\n+        let expr = &self.tcx.map.body(body).value;\n+        self.global_expr(mode, expr)\n+    }\n+\n     fn global_expr(&mut self, mode: Mode, expr: &'gcx hir::Expr) -> ConstQualif {\n         assert!(mode != Mode::Var);\n         match self.tcx.const_qualif_map.borrow_mut().entry(expr.id) {\n@@ -134,7 +139,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     fn fn_like(&mut self,\n                fk: FnKind<'gcx>,\n                fd: &'gcx hir::FnDecl,\n-               b: hir::ExprId,\n+               b: hir::BodyId,\n                s: Span,\n                fn_id: ast::NodeId)\n                -> ConstQualif {\n@@ -160,7 +165,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n         };\n \n         let qualif = self.with_mode(mode, |this| {\n-            let body = this.tcx.map.expr(b);\n+            let body = this.tcx.map.body(b);\n             this.with_euv(Some(fn_id), |euv| euv.walk_fn(fd, body));\n             intravisit::walk_fn(this, fk, fd, b, s, fn_id);\n             this.qualif\n@@ -197,7 +202,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n                 true\n             },\n             Some(ConstFnNode::Inlined(ii)) => {\n-                let node_id = ii.body.id;\n+                let node_id = ii.body.value.id;\n \n                 let qualif = match self.tcx.const_qualif_map.borrow_mut().entry(node_id) {\n                     Entry::Occupied(entry) => *entry.get(),\n@@ -241,19 +246,19 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         debug!(\"visit_item(item={})\", self.tcx.map.node_to_string(i.id));\n         assert_eq!(self.mode, Mode::Var);\n         match i.node {\n-            hir::ItemStatic(_, hir::MutImmutable, ref expr) => {\n-                self.global_expr(Mode::Static, &expr);\n+            hir::ItemStatic(_, hir::MutImmutable, expr) => {\n+                self.global_body(Mode::Static, expr);\n             }\n-            hir::ItemStatic(_, hir::MutMutable, ref expr) => {\n-                self.global_expr(Mode::StaticMut, &expr);\n+            hir::ItemStatic(_, hir::MutMutable, expr) => {\n+                self.global_body(Mode::StaticMut, expr);\n             }\n-            hir::ItemConst(_, ref expr) => {\n-                self.global_expr(Mode::Const, &expr);\n+            hir::ItemConst(_, expr) => {\n+                self.global_body(Mode::Const, expr);\n             }\n             hir::ItemEnum(ref enum_definition, _) => {\n                 for var in &enum_definition.variants {\n-                    if let Some(ref ex) = var.node.disr_expr {\n-                        self.global_expr(Mode::Const, &ex);\n+                    if let Some(ex) = var.node.disr_expr {\n+                        self.global_body(Mode::Const, ex);\n                     }\n                 }\n             }\n@@ -265,9 +270,9 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, t: &'tcx hir::TraitItem) {\n         match t.node {\n-            hir::TraitItemKind::Const(_, ref default) => {\n-                if let Some(ref expr) = *default {\n-                    self.global_expr(Mode::Const, &expr);\n+            hir::TraitItemKind::Const(_, default) => {\n+                if let Some(expr) = default {\n+                    self.global_body(Mode::Const, expr);\n                 } else {\n                     intravisit::walk_trait_item(self, t);\n                 }\n@@ -278,8 +283,8 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n \n     fn visit_impl_item(&mut self, i: &'tcx hir::ImplItem) {\n         match i.node {\n-            hir::ImplItemKind::Const(_, ref expr) => {\n-                self.global_expr(Mode::Const, &expr);\n+            hir::ImplItemKind::Const(_, expr) => {\n+                self.global_body(Mode::Const, expr);\n             }\n             _ => self.with_mode(Mode::Var, |v| intravisit::walk_impl_item(v, i)),\n         }\n@@ -288,7 +293,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 fk: FnKind<'tcx>,\n                 fd: &'tcx hir::FnDecl,\n-                b: hir::ExprId,\n+                b: hir::BodyId,\n                 s: Span,\n                 fn_id: ast::NodeId) {\n         self.fn_like(fk, fd, b, s, fn_id);"}, {"sha": "65a60732fc8074e423790ba73597b0e387316d64", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -177,7 +177,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     fn visit_fn(&mut self,\n                 fk: hir_visit::FnKind<'v>,\n                 fd: &'v hir::FnDecl,\n-                b: hir::ExprId,\n+                b: hir::BodyId,\n                 s: Span,\n                 id: NodeId) {\n         self.record(\"FnDecl\", Id::None, fd);"}, {"sha": "df9fe00e9a88e23d99f9e248d6843b0c12610a14", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -84,7 +84,7 @@ impl<'a, 'ast> Visitor<'ast> for CheckLoopVisitor<'a, 'ast> {\n                 self.with_context(Loop(LoopKind::Loop(source)), |v| v.visit_block(&b));\n             }\n             hir::ExprClosure(.., b, _) => {\n-                self.with_context(Closure, |v| v.visit_body(b));\n+                self.with_context(Closure, |v| v.visit_nested_body(b));\n             }\n             hir::ExprBreak(label, ref opt_expr) => {\n                 if opt_expr.is_some() {"}, {"sha": "e845115cf4fd6f7ab6d051aa30eb71b01fc5973c", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RvalueContext<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 fk: intravisit::FnKind<'tcx>,\n                 fd: &'tcx hir::FnDecl,\n-                b: hir::ExprId,\n+                b: hir::BodyId,\n                 s: Span,\n                 fn_id: ast::NodeId) {\n         // FIXME (@jroesch) change this to be an inference context\n@@ -50,7 +50,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RvalueContext<'a, 'tcx> {\n                 tcx: infcx.tcx,\n                 param_env: &param_env\n             };\n-            let body = infcx.tcx.map.expr(b);\n+            let body = infcx.tcx.map.body(b);\n             let mut euv = euv::ExprUseVisitor::new(&mut delegate, &infcx);\n             euv.walk_fn(fd, body);\n         });"}, {"sha": "ba4fc57276b2ce21a2709b118ef6098d7785676b", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -30,7 +30,7 @@ struct CheckCrateVisitor<'a, 'ast: 'a> {\n     // variant definitions with the discriminant expression that applies to\n     // each one. If the variant uses the default values (starting from `0`),\n     // then `None` is stored.\n-    discriminant_map: NodeMap<Option<&'ast hir::Expr>>,\n+    discriminant_map: NodeMap<Option<hir::BodyId>>,\n     detected_recursive_ids: NodeSet,\n }\n \n@@ -108,7 +108,7 @@ struct CheckItemRecursionVisitor<'a, 'b: 'a, 'ast: 'b> {\n     root_span: &'b Span,\n     sess: &'b Session,\n     ast_map: &'b ast_map::Map<'ast>,\n-    discriminant_map: &'a mut NodeMap<Option<&'ast hir::Expr>>,\n+    discriminant_map: &'a mut NodeMap<Option<hir::BodyId>>,\n     idstack: Vec<ast::NodeId>,\n     detected_recursive_ids: &'a mut NodeSet,\n }\n@@ -189,7 +189,7 @@ impl<'a, 'b: 'a, 'ast: 'b> CheckItemRecursionVisitor<'a, 'b, 'ast> {\n             variant_stack.push(variant.node.data.id());\n             // When we find an expression, every variant currently on the stack\n             // is affected by that expression.\n-            if let Some(ref expr) = variant.node.disr_expr {\n+            if let Some(expr) = variant.node.disr_expr {\n                 for id in &variant_stack {\n                     self.discriminant_map.insert(*id, Some(expr));\n                 }\n@@ -226,19 +226,15 @@ impl<'a, 'b: 'a, 'ast: 'b> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'b, '\n                      _: &'ast hir::Generics,\n                      _: ast::NodeId) {\n         let variant_id = variant.node.data.id();\n-        let maybe_expr;\n-        if let Some(get_expr) = self.discriminant_map.get(&variant_id) {\n-            // This is necessary because we need to let the `discriminant_map`\n-            // borrow fall out of scope, so that we can reborrow farther down.\n-            maybe_expr = (*get_expr).clone();\n-        } else {\n+        let maybe_expr = *self.discriminant_map.get(&variant_id).unwrap_or_else(|| {\n             span_bug!(variant.span,\n                       \"`check_static_recursion` attempted to visit \\\n                       variant with unknown discriminant\")\n-        }\n+        });\n         // If `maybe_expr` is `None`, that's because no discriminant is\n         // specified that affects this variant. Thus, no risk of recursion.\n         if let Some(expr) = maybe_expr {\n+            let expr = &self.ast_map.body(expr).value;\n             self.with_item_id_pushed(expr.id, |v| intravisit::walk_expr(v, expr), expr.span);\n         }\n     }"}, {"sha": "865195d3db488e3914ae34ac82ec3a633c333d93", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -576,6 +576,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n             let def = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.span))\n                           .map_or(Def::Err, |d| d.def());\n             self.record_def(ty.id, PathResolution::new(def));\n+        } else if let TyKind::Array(ref element, ref length) = ty.node {\n+            self.visit_ty(element);\n+            self.with_constant_rib(|this| {\n+                this.visit_expr(length);\n+            });\n+            return;\n         }\n         visit::walk_ty(self, ty);\n     }\n@@ -2733,6 +2739,13 @@ impl<'a> Resolver<'a> {\n                     self.visit_ty(ty);\n                 }\n             }\n+\n+            ExprKind::Repeat(ref element, ref count) => {\n+                self.visit_expr(element);\n+                self.with_constant_rib(|this| {\n+                    this.visit_expr(count);\n+                });\n+            }\n             ExprKind::Call(ref callee, ref arguments) => {\n                 self.resolve_expr(callee, Some(&expr.node));\n                 for argument in arguments {"}, {"sha": "3b2520308c70de46ebb84e31a9497ed439dbe828", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -1664,8 +1664,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 };\n                 self.associated_path_def_to_ty(ast_ty.id, ast_ty.span, ty, def, segment).0\n             }\n-            hir::TyArray(ref ty, ref e) => {\n-                if let Ok(length) = eval_length(tcx.global_tcx(), &e, \"array length\") {\n+            hir::TyArray(ref ty, length) => {\n+                let e = &tcx.map.body(length).value;\n+                if let Ok(length) = eval_length(tcx.global_tcx(), e, \"array length\") {\n                     tcx.mk_array(self.ast_ty_to_ty(rscope, &ty), length)\n                 } else {\n                     self.tcx().types.err"}, {"sha": "9412c9105c7aa572758785457f3ce5c366622efe", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -25,7 +25,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               expr: &hir::Expr,\n                               _capture: hir::CaptureClause,\n                               decl: &'gcx hir::FnDecl,\n-                              body_id: hir::ExprId,\n+                              body_id: hir::BodyId,\n                               expected: Expectation<'tcx>)\n                               -> Ty<'tcx> {\n         debug!(\"check_expr_closure(expr={:?},expected={:?})\",\n@@ -39,15 +39,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Some(ty) => self.deduce_expectations_from_expected_type(ty),\n             None => (None, None),\n         };\n-        let body = self.tcx.map.expr(body_id);\n+        let body = self.tcx.map.body(body_id);\n         self.check_closure(expr, expected_kind, decl, body, expected_sig)\n     }\n \n     fn check_closure(&self,\n                      expr: &hir::Expr,\n                      opt_kind: Option<ty::ClosureKind>,\n                      decl: &'gcx hir::FnDecl,\n-                     body: &'gcx hir::Expr,\n+                     body: &'gcx hir::Body,\n                      expected_sig: Option<ty::FnSig<'tcx>>)\n                      -> Ty<'tcx> {\n         debug!(\"check_closure opt_kind={:?} expected_sig={:?}\",\n@@ -73,18 +73,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\"check_closure: expr.id={:?} closure_type={:?}\", expr.id, closure_type);\n \n-        let fn_sig = self.tcx\n-            .liberate_late_bound_regions(self.tcx.region_maps.call_site_extent(expr.id, body.id),\n-                                         &fn_ty.sig);\n-        let fn_sig = (**self).normalize_associated_types_in(body.span, body.id, &fn_sig);\n+        let extent = self.tcx.region_maps.call_site_extent(expr.id, body.value.id);\n+        let fn_sig = self.tcx.liberate_late_bound_regions(extent, &fn_ty.sig);\n+        let fn_sig = self.inh.normalize_associated_types_in(body.value.span,\n+                                                            body.value.id, &fn_sig);\n \n         check_fn(self,\n                  hir::Unsafety::Normal,\n                  expr.id,\n                  &fn_sig,\n                  decl,\n                  expr.id,\n-                 &body);\n+                 body);\n \n         // Tuple up the arguments and insert the resulting function type into\n         // the `closures` table."}, {"sha": "021aeec47f0257bccf567725844c73215f3de8a6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 52, "deletions": 61, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -550,14 +550,25 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n \n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n         match t.node {\n-            hir::TyArray(_, ref expr) => {\n-                check_const_with_type(self.ccx, &expr, self.ccx.tcx.types.usize, expr.id);\n+            hir::TyArray(_, length) => {\n+                check_const_with_type(self.ccx, length, self.ccx.tcx.types.usize, length.node_id);\n             }\n             _ => {}\n         }\n \n         intravisit::walk_ty(self, t);\n     }\n+\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n+        match e.node {\n+            hir::ExprRepeat(_, count) => {\n+                check_const_with_type(self.ccx, count, self.ccx.tcx.types.usize, count.node_id);\n+            }\n+            _ => {}\n+        }\n+\n+        intravisit::walk_expr(self, e);\n+    }\n }\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n@@ -639,28 +650,28 @@ pub fn check_drop_impls(ccx: &CrateCtxt) -> CompileResult {\n \n fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            decl: &'tcx hir::FnDecl,\n-                           body_id: hir::ExprId,\n+                           body_id: hir::BodyId,\n                            fn_id: ast::NodeId,\n                            span: Span) {\n-    let body = ccx.tcx.map.expr(body_id);\n+    let body = ccx.tcx.map.body(body_id);\n \n     let raw_fty = ccx.tcx.item_type(ccx.tcx.map.local_def_id(fn_id));\n     let fn_ty = match raw_fty.sty {\n         ty::TyFnDef(.., f) => f,\n-        _ => span_bug!(body.span, \"check_bare_fn: function type expected\")\n+        _ => span_bug!(body.value.span, \"check_bare_fn: function type expected\")\n     };\n \n     check_abi(ccx, span, fn_ty.abi);\n \n     ccx.inherited(fn_id).enter(|inh| {\n         // Compute the fty from point of view of inside fn.\n-        let fn_scope = inh.tcx.region_maps.call_site_extent(fn_id, body_id.node_id());\n+        let fn_scope = inh.tcx.region_maps.call_site_extent(fn_id, body_id.node_id);\n         let fn_sig =\n             fn_ty.sig.subst(inh.tcx, &inh.parameter_environment.free_substs);\n         let fn_sig =\n             inh.tcx.liberate_late_bound_regions(fn_scope, &fn_sig);\n         let fn_sig =\n-            inh.normalize_associated_types_in(body.span, body_id.node_id(), &fn_sig);\n+            inh.normalize_associated_types_in(body.value.span, body_id.node_id, &fn_sig);\n \n         let fcx = check_fn(&inh, fn_ty.unsafety, fn_id, &fn_sig, decl, fn_id, body);\n \n@@ -670,7 +681,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         fcx.check_casts();\n         fcx.select_all_obligations_or_error(); // Casts can introduce new obligations.\n \n-        fcx.regionck_fn(fn_id, decl, body_id);\n+        fcx.regionck_fn(fn_id, decl, body);\n         fcx.resolve_type_vars_in_fn(decl, body, fn_id);\n     });\n }\n@@ -740,21 +751,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n         intravisit::walk_pat(self, p);\n     }\n \n-    fn visit_block(&mut self, b: &'gcx hir::Block) {\n-        // non-obvious: the `blk` variable maps to region lb, so\n-        // we have to keep this up-to-date.  This\n-        // is... unfortunate.  It'd be nice to not need this.\n-        intravisit::walk_block(self, b);\n-    }\n-\n-    // Since an expr occurs as part of the type fixed size arrays we\n-    // need to record the type for that node\n     fn visit_ty(&mut self, t: &'gcx hir::Ty) {\n         match t.node {\n-            hir::TyArray(ref ty, ref count_expr) => {\n-                self.visit_ty(&ty);\n-                self.fcx.check_expr_with_hint(&count_expr, self.fcx.tcx.types.usize);\n-            }\n             hir::TyBareFn(ref function_declaration) => {\n                 intravisit::walk_fn_decl_nopat(self, &function_declaration.decl);\n                 walk_list!(self, visit_lifetime_def, &function_declaration.lifetimes);\n@@ -765,7 +763,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n \n     // Don't descend into the bodies of nested closures\n     fn visit_fn(&mut self, _: intravisit::FnKind<'gcx>, _: &'gcx hir::FnDecl,\n-                _: hir::ExprId, _: Span, _: ast::NodeId) { }\n+                _: hir::BodyId, _: Span, _: ast::NodeId) { }\n }\n \n /// Helper used by check_bare_fn and check_expr_fn. Does the grungy work of checking a function\n@@ -780,7 +778,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                             fn_sig: &ty::FnSig<'tcx>,\n                             decl: &'gcx hir::FnDecl,\n                             fn_id: ast::NodeId,\n-                            body: &'gcx hir::Expr)\n+                            body: &'gcx hir::Body)\n                             -> FnCtxt<'a, 'gcx, 'tcx>\n {\n     let mut fn_sig = fn_sig.clone();\n@@ -789,7 +787,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n-    let mut fcx = FnCtxt::new(inherited, None, body.id);\n+    let mut fcx = FnCtxt::new(inherited, None, body.value.id);\n     let ret_ty = fn_sig.output();\n     *fcx.ps.borrow_mut() = UnsafetyState::function(unsafety, unsafety_id);\n \n@@ -822,12 +820,12 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n             fcx.write_ty(input.id, arg_ty);\n         }\n \n-        visit.visit_expr(body);\n+        visit.visit_body(body);\n     }\n \n     inherited.tables.borrow_mut().liberated_fn_sigs.insert(fn_id, fn_sig);\n \n-    fcx.check_expr_coercable_to_type(body, fcx.ret_ty.unwrap());\n+    fcx.check_expr_coercable_to_type(&body.value, fcx.ret_ty.unwrap());\n \n     fcx\n }\n@@ -852,8 +850,8 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n     let _indenter = indenter();\n     match it.node {\n       // Consts can play a role in type-checking, so they are included here.\n-      hir::ItemStatic(.., ref e) |\n-      hir::ItemConst(_, ref e) => check_const(ccx, &e, it.id),\n+      hir::ItemStatic(.., e) |\n+      hir::ItemConst(_, e) => check_const(ccx, e, it.id),\n       hir::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n@@ -937,8 +935,8 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         for impl_item_ref in impl_item_refs {\n             let impl_item = ccx.tcx.map.impl_item(impl_item_ref.id);\n             match impl_item.node {\n-                hir::ImplItemKind::Const(_, ref expr) => {\n-                    check_const(ccx, &expr, impl_item.id)\n+                hir::ImplItemKind::Const(_, expr) => {\n+                    check_const(ccx, expr, impl_item.id)\n                 }\n                 hir::ImplItemKind::Method(ref sig, body_id) => {\n                     check_bare_fn(ccx, &sig.decl, body_id, impl_item.id, impl_item.span);\n@@ -953,8 +951,8 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         for trait_item_ref in trait_item_refs {\n             let trait_item = ccx.tcx.map.trait_item(trait_item_ref.id);\n             match trait_item.node {\n-                hir::TraitItemKind::Const(_, Some(ref expr)) => {\n-                    check_const(ccx, &expr, trait_item.id)\n+                hir::TraitItemKind::Const(_, Some(expr)) => {\n+                    check_const(ccx, expr, trait_item.id)\n                 }\n                 hir::TraitItemKind::Method(ref sig, Some(body_id)) => {\n                     check_bare_fn(ccx, &sig.decl, body_id, trait_item.id, trait_item.span);\n@@ -1127,7 +1125,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         compare_impl_method(ccx,\n                                             &ty_impl_item,\n                                             impl_item.span,\n-                                            body_id.node_id(),\n+                                            body_id.node_id,\n                                             &ty_trait_item,\n                                             impl_trait_ref,\n                                             trait_span,\n@@ -1137,7 +1135,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             compare_impl_method(ccx,\n                                                 &ty_impl_item,\n                                                 impl_item.span,\n-                                                body_id.node_id(),\n+                                                body_id.node_id,\n                                                 &ty_trait_item,\n                                                 impl_trait_ref,\n                                                 trait_span,\n@@ -1248,37 +1246,38 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n /// Checks a constant with a given type.\n fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n-                                   expr: &'tcx hir::Expr,\n+                                   body: hir::BodyId,\n                                    expected_type: Ty<'tcx>,\n                                    id: ast::NodeId) {\n+    let body = ccx.tcx.map.body(body);\n     ccx.inherited(id).enter(|inh| {\n-        let fcx = FnCtxt::new(&inh, None, expr.id);\n-        fcx.require_type_is_sized(expected_type, expr.span, traits::ConstSized);\n+        let fcx = FnCtxt::new(&inh, None, body.value.id);\n+        fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n \n         // Gather locals in statics (because of block expressions).\n         // This is technically unnecessary because locals in static items are forbidden,\n         // but prevents type checking from blowing up before const checking can properly\n         // emit an error.\n-        GatherLocalsVisitor { fcx: &fcx }.visit_expr(expr);\n+        GatherLocalsVisitor { fcx: &fcx }.visit_body(body);\n \n-        fcx.check_expr_coercable_to_type(expr, expected_type);\n+        fcx.check_expr_coercable_to_type(&body.value, expected_type);\n \n         fcx.select_all_obligations_and_apply_defaults();\n-        fcx.closure_analyze(expr);\n+        fcx.closure_analyze(body);\n         fcx.select_obligations_where_possible();\n         fcx.check_casts();\n         fcx.select_all_obligations_or_error();\n \n-        fcx.regionck_expr(expr);\n-        fcx.resolve_type_vars_in_expr(expr, id);\n+        fcx.regionck_expr(body);\n+        fcx.resolve_type_vars_in_expr(body, id);\n     });\n }\n \n fn check_const<'a, 'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                         expr: &'tcx hir::Expr,\n+                         body: hir::BodyId,\n                          id: ast::NodeId) {\n     let decl_ty = ccx.tcx.item_type(ccx.tcx.map.local_def_id(id));\n-    check_const_with_type(ccx, expr, decl_ty, id);\n+    check_const_with_type(ccx, body, decl_ty, id);\n }\n \n /// Checks whether a type can be represented in memory. In particular, it\n@@ -1353,8 +1352,8 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n \n     let repr_type_ty = ccx.tcx.enum_repr_type(Some(&hint)).to_ty(ccx.tcx);\n     for v in vs {\n-        if let Some(ref e) = v.node.disr_expr {\n-            check_const_with_type(ccx, e, repr_type_ty, e.id);\n+        if let Some(e) = v.node.disr_expr {\n+            check_const_with_type(ccx, e, repr_type_ty, e.node_id);\n         }\n     }\n \n@@ -1370,11 +1369,11 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             let variant_i_node_id = ccx.tcx.map.as_local_node_id(variants[i].did).unwrap();\n             let variant_i = ccx.tcx.map.expect_variant(variant_i_node_id);\n             let i_span = match variant_i.node.disr_expr {\n-                Some(ref expr) => expr.span,\n+                Some(expr) => ccx.tcx.map.span(expr.node_id),\n                 None => ccx.tcx.map.span(variant_i_node_id)\n             };\n             let span = match v.node.disr_expr {\n-                Some(ref expr) => expr.span,\n+                Some(expr) => ccx.tcx.map.span(expr.node_id),\n                 None => v.span\n             };\n             struct_span_err!(ccx.tcx.sess, span, E0081,\n@@ -1648,12 +1647,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match self.locals.borrow().get(&nid) {\n             Some(&t) => t,\n             None => {\n-                struct_span_err!(self.tcx.sess, span, E0513,\n-                                 \"no type for local variable {}\",\n-                                 self.tcx.map.node_to_string(nid))\n-                    .span_label(span, &\"no type for variable\")\n-                    .emit();\n-                self.tcx.types.err\n+                span_bug!(span, \"no type for local variable {}\",\n+                          self.tcx.map.node_to_string(nid));\n             }\n         }\n     }\n@@ -3826,10 +3821,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               self.check_method_call(expr, name, args, &tps[..], expected, lvalue_pref)\n           }\n           hir::ExprCast(ref e, ref t) => {\n-            if let hir::TyArray(_, ref count_expr) = t.node {\n-                self.check_expr_with_hint(&count_expr, tcx.types.usize);\n-            }\n-\n             // Find the type of `e`. Supply hints based on the type we are casting to,\n             // if appropriate.\n             let t_cast = self.to_ty(t);\n@@ -3891,9 +3882,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             tcx.mk_array(unified, args.len())\n           }\n-          hir::ExprRepeat(ref element, ref count_expr) => {\n-            self.check_expr_has_type(&count_expr, tcx.types.usize);\n-            let count = eval_length(self.tcx.global_tcx(), &count_expr, \"repeat count\")\n+          hir::ExprRepeat(ref element, count) => {\n+            let count_expr = &tcx.map.body(count).value;\n+            let count = eval_length(self.tcx.global_tcx(), count_expr, \"repeat count\")\n                   .unwrap_or(0);\n \n             let uty = match expected {"}, {"sha": "80b967210f98dd69b0148a62ac71fcbe496a3972", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -113,12 +113,13 @@ macro_rules! ignore_err {\n // PUBLIC ENTRY POINTS\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn regionck_expr(&self, e: &'gcx hir::Expr) {\n-        let mut rcx = RegionCtxt::new(self, RepeatingScope(e.id), e.id, Subject(e.id));\n+    pub fn regionck_expr(&self, body: &'gcx hir::Body) {\n+        let id = body.value.id;\n+        let mut rcx = RegionCtxt::new(self, RepeatingScope(id), id, Subject(id));\n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n-            rcx.visit_expr(e);\n-            rcx.visit_region_obligations(e.id);\n+            rcx.visit_body(body);\n+            rcx.visit_region_obligations(id);\n         }\n         rcx.resolve_regions_and_report_errors();\n     }\n@@ -141,14 +142,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn regionck_fn(&self,\n                        fn_id: ast::NodeId,\n                        decl: &hir::FnDecl,\n-                       body_id: hir::ExprId) {\n+                       body: &'gcx hir::Body) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n-        let node_id = body_id.node_id();\n+        let node_id = body.value.id;\n         let mut rcx = RegionCtxt::new(self, RepeatingScope(node_id), node_id, Subject(fn_id));\n \n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n-            rcx.visit_fn_body(fn_id, decl, body_id, self.tcx.map.span(fn_id));\n+            rcx.visit_fn_body(fn_id, decl, body, self.tcx.map.span(fn_id));\n         }\n \n         rcx.free_region_map.relate_free_regions_from_predicates(\n@@ -268,14 +269,16 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn visit_fn_body(&mut self,\n                      id: ast::NodeId, // the id of the fn itself\n                      fn_decl: &hir::FnDecl,\n-                     body_id: hir::ExprId,\n+                     body: &'gcx hir::Body,\n                      span: Span)\n     {\n         // When we enter a function, we can derive\n         debug!(\"visit_fn_body(id={})\", id);\n \n+        let body_id = body.id();\n+\n         let call_site = self.tcx.region_maps.lookup_code_extent(\n-            region::CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id() });\n+            region::CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id });\n         let old_call_site_scope = self.set_call_site_scope(Some(call_site));\n \n         let fn_sig = {\n@@ -298,20 +301,19 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         let fn_sig_tys: Vec<_> =\n             fn_sig.inputs().iter().cloned().chain(Some(fn_sig.output())).collect();\n \n-        let old_body_id = self.set_body_id(body_id.node_id());\n-        self.relate_free_regions(&fn_sig_tys[..], body_id.node_id(), span);\n-        self.link_fn_args(self.tcx.region_maps.node_extent(body_id.node_id()),\n+        let old_body_id = self.set_body_id(body_id.node_id);\n+        self.relate_free_regions(&fn_sig_tys[..], body_id.node_id, span);\n+        self.link_fn_args(self.tcx.region_maps.node_extent(body_id.node_id),\n                           &fn_decl.inputs[..]);\n-        let body = self.tcx.map.expr(body_id);\n-        self.visit_expr(body);\n-        self.visit_region_obligations(body_id.node_id());\n+        self.visit_body(body);\n+        self.visit_region_obligations(body_id.node_id);\n \n         let call_site_scope = self.call_site_scope.unwrap();\n-        debug!(\"visit_fn_body body.id {} call_site_scope: {:?}\",\n-               body.id, call_site_scope);\n+        debug!(\"visit_fn_body body.id {:?} call_site_scope: {:?}\",\n+               body.id(), call_site_scope);\n         let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope));\n         self.type_of_node_must_outlive(infer::CallReturn(span),\n-                                       body_id.node_id(),\n+                                       body_id.node_id,\n                                        call_site_region);\n \n         self.region_bound_pairs.truncate(old_region_bounds_pairs_len);\n@@ -478,12 +480,13 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n     // regions, until regionck, as described in #3238.\n \n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n     fn visit_fn(&mut self, _fk: intravisit::FnKind<'gcx>, fd: &'gcx hir::FnDecl,\n-                b: hir::ExprId, span: Span, id: ast::NodeId) {\n-        self.visit_fn_body(id, fd, b, span)\n+                b: hir::BodyId, span: Span, id: ast::NodeId) {\n+        let body = self.tcx.map.body(b);\n+        self.visit_fn_body(id, fd, body, span)\n     }\n \n     //visit_pat: visit_pat, // (..) see above\n@@ -826,8 +829,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_expr_fn_block(&mut self,\n                            expr: &'gcx hir::Expr,\n-                           body_id: hir::ExprId) {\n-        let repeating_scope = self.set_repeating_scope(body_id.node_id());\n+                           body_id: hir::BodyId) {\n+        let repeating_scope = self.set_repeating_scope(body_id.node_id);\n         intravisit::walk_expr(self, expr);\n         self.set_repeating_scope(repeating_scope);\n     }"}, {"sha": "0ad01a0e00d647f543587f9e7f1eae31648f5b9b", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -57,12 +57,12 @@ use rustc::util::nodemap::NodeMap;\n // PUBLIC ENTRY POINTS\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn closure_analyze(&self, body: &'gcx hir::Expr) {\n+    pub fn closure_analyze(&self, body: &'gcx hir::Body) {\n         let mut seed = SeedBorrowKind::new(self);\n-        seed.visit_expr(body);\n+        seed.visit_body(body);\n \n         let mut adjust = AdjustBorrowKind::new(self, seed.temp_closure_kinds);\n-        adjust.visit_expr(body);\n+        adjust.visit_body(body);\n \n         // it's our job to process these.\n         assert!(self.deferred_call_resolutions.borrow().is_empty());\n@@ -79,13 +79,15 @@ struct SeedBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> Visitor<'gcx> for SeedBorrowKind<'a, 'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.fcx.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n     fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n         match expr.node {\n             hir::ExprClosure(cc, _, body_id, _) => {\n-                self.check_closure(expr, cc, body_id);\n+                let body = self.fcx.tcx.map.body(body_id);\n+                self.visit_body(body);\n+                self.check_closure(expr, cc);\n             }\n \n             _ => { }\n@@ -102,8 +104,7 @@ impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n \n     fn check_closure(&mut self,\n                      expr: &hir::Expr,\n-                     capture_clause: hir::CaptureClause,\n-                     _body_id: hir::ExprId)\n+                     capture_clause: hir::CaptureClause)\n     {\n         let closure_def_id = self.fcx.tcx.map.local_def_id(expr.id);\n         if !self.fcx.tables.borrow().closure_kinds.contains_key(&closure_def_id) {\n@@ -157,15 +158,14 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                        id: ast::NodeId,\n                        span: Span,\n                        decl: &hir::FnDecl,\n-                       body_id: hir::ExprId) {\n+                       body: &hir::Body) {\n         /*!\n          * Analysis starting point.\n          */\n \n-        debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body_id);\n+        debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body.id());\n \n         {\n-            let body = self.fcx.tcx.map.expr(body_id);\n             let mut euv =\n                 euv::ExprUseVisitor::with_options(self,\n                                                   self.fcx,\n@@ -491,17 +491,20 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n \n impl<'a, 'gcx, 'tcx> Visitor<'gcx> for AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.fcx.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n     fn visit_fn(&mut self,\n                 fn_kind: intravisit::FnKind<'gcx>,\n                 decl: &'gcx hir::FnDecl,\n-                body: hir::ExprId,\n+                body: hir::BodyId,\n                 span: Span,\n                 id: ast::NodeId)\n     {\n         intravisit::walk_fn(self, fn_kind, decl, body, span, id);\n+\n+        let body = self.fcx.tcx.map.body(body);\n+        self.visit_body(body);\n         self.analyze_closure(id, span, decl, body);\n     }\n }"}, {"sha": "4955322963a14355547c15571ceeb792b61d707f", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -337,7 +337,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n     fn check_item_fn(&mut self,\n                      item: &hir::Item,\n-                     body_id: hir::ExprId)\n+                     body_id: hir::BodyId)\n     {\n         self.for_item(item).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n@@ -354,7 +354,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             let predicates = fcx.instantiate_bounds(item.span, def_id, free_substs);\n \n             let mut implied_bounds = vec![];\n-            let free_id_outlive = fcx.tcx.region_maps.call_site_extent(item.id, body_id.node_id());\n+            let free_id_outlive = fcx.tcx.region_maps.call_site_extent(item.id, body_id.node_id);\n             this.check_fn_or_method(fcx, item.span, bare_fn_ty, &predicates,\n                                     free_id_outlive, &mut implied_bounds);\n             implied_bounds"}, {"sha": "beed85297fd8aedc4de1a13155ef994969c86947", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -34,10 +34,10 @@ use rustc::hir::{self, PatKind};\n // Entry point functions\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn resolve_type_vars_in_expr(&self, e: &'gcx hir::Expr, item_id: ast::NodeId) {\n+    pub fn resolve_type_vars_in_expr(&self, body: &'gcx hir::Body, item_id: ast::NodeId) {\n         assert_eq!(self.writeback_errors.get(), false);\n         let mut wbcx = WritebackCx::new(self);\n-        wbcx.visit_expr(e);\n+        wbcx.visit_body(body);\n         wbcx.visit_upvar_borrow_map();\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n@@ -48,11 +48,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn resolve_type_vars_in_fn(&self,\n                                    decl: &'gcx hir::FnDecl,\n-                                   body: &'gcx hir::Expr,\n+                                   body: &'gcx hir::Body,\n                                    item_id: ast::NodeId) {\n         assert_eq!(self.writeback_errors.get(), false);\n         let mut wbcx = WritebackCx::new(self);\n-        wbcx.visit_expr(body);\n+        wbcx.visit_body(body);\n         for arg in &decl.inputs {\n             wbcx.visit_node_id(ResolvingPattern(arg.pat.span), arg.id);\n             wbcx.visit_pat(&arg.pat);\n@@ -188,7 +188,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.fcx.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n     fn visit_stmt(&mut self, s: &'gcx hir::Stmt) {\n@@ -211,10 +211,13 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n         self.visit_method_map_entry(ResolvingExpr(e.span),\n                                     MethodCall::expr(e.id));\n \n-        if let hir::ExprClosure(_, ref decl, ..) = e.node {\n+        if let hir::ExprClosure(_, ref decl, body, _) = e.node {\n             for input in &decl.inputs {\n                 self.visit_node_id(ResolvingExpr(e.span), input.id);\n             }\n+\n+            let body = self.fcx.tcx.map.body(body);\n+            self.visit_body(body);\n         }\n \n         intravisit::walk_expr(self, e);\n@@ -257,10 +260,6 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n \n     fn visit_ty(&mut self, t: &'gcx hir::Ty) {\n         match t.node {\n-            hir::TyArray(ref ty, ref count_expr) => {\n-                self.visit_ty(&ty);\n-                self.write_ty_to_tcx(count_expr.id, self.tcx().types.usize);\n-            }\n             hir::TyBareFn(ref function_declaration) => {\n                 intravisit::walk_fn_decl_nopat(self, &function_declaration.decl);\n                 walk_list!(self, visit_lifetime_def, &function_declaration.lifetimes);"}, {"sha": "cb9e1c989e3647e6a323a5c42dc6bd1922306386", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -1095,7 +1095,8 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let mut prev_disr = None::<ty::Disr>;\n     let variants = def.variants.iter().map(|v| {\n         let wrapped_disr = prev_disr.map_or(initial, |d| d.wrap_incr());\n-        let disr = if let Some(ref e) = v.node.disr_expr {\n+        let disr = if let Some(e) = v.node.disr_expr {\n+            let e = &tcx.map.body(e).value;\n             evaluate_disr_expr(ccx, repr_type, e)\n         } else if let Some(disr) = repr_type.disr_incr(tcx, prev_disr) {\n             Some(disr)"}, {"sha": "d3b671f2a4d6e05ee026dd921176c9cbb4bf6ae8", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -3866,45 +3866,6 @@ extern \"platform-intrinsic\" {\n ```\n \"##,\n \n-E0513: r##\"\n-The type of the variable couldn't be found out.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0513\n-use std::mem;\n-\n-unsafe {\n-    let size = mem::size_of::<u32>();\n-    mem::transmute_copy::<u32, [u8; size]>(&8_8);\n-    // error: no type for local variable\n-}\n-```\n-\n-To fix this error, please use a constant size instead of `size`. To make\n-this error more obvious, you could run:\n-\n-```compile_fail,E0080\n-use std::mem;\n-\n-unsafe {\n-    mem::transmute_copy::<u32, [u8; mem::size_of::<u32>()]>(&8_8);\n-    // error: constant evaluation error\n-}\n-```\n-\n-So now, you can fix your code by setting the size directly:\n-\n-```\n-use std::mem;\n-\n-unsafe {\n-    mem::transmute_copy::<u32, [u8; 4]>(&8_8);\n-    // `u32` is 4 bytes so we replace the `mem::size_of` call with its size\n-}\n-```\n-\"##,\n-\n E0516: r##\"\n The `typeof` keyword is currently reserved but unimplemented.\n Erroneous code example:"}, {"sha": "40f005fecbd0e3503f8f1ff8561f4d307cc4c257", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -1270,9 +1270,9 @@ impl Clean<PolyTrait> for hir::PolyTraitRef {\n impl Clean<Item> for hir::TraitItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.node {\n-            hir::TraitItemKind::Const(ref ty, ref default) => {\n+            hir::TraitItemKind::Const(ref ty, default) => {\n                 AssociatedConstItem(ty.clean(cx),\n-                                    default.as_ref().map(|e| pprust::expr_to_string(&e)))\n+                                    default.map(|e| print_const_expr(cx, e)))\n             }\n             hir::TraitItemKind::Method(ref sig, Some(_)) => {\n                 MethodItem(sig.clean(cx))\n@@ -1300,9 +1300,9 @@ impl Clean<Item> for hir::TraitItem {\n impl Clean<Item> for hir::ImplItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.node {\n-            hir::ImplItemKind::Const(ref ty, ref expr) => {\n+            hir::ImplItemKind::Const(ref ty, expr) => {\n                 AssociatedConstItem(ty.clean(cx),\n-                                    Some(pprust::expr_to_string(expr)))\n+                                    Some(print_const_expr(cx, expr)))\n             }\n             hir::ImplItemKind::Method(ref sig, _) => {\n                 MethodItem(sig.clean(cx))\n@@ -1687,11 +1687,12 @@ impl Clean<Type> for hir::Ty {\n                 BorrowedRef {lifetime: l.clean(cx), mutability: m.mutbl.clean(cx),\n                              type_: box m.ty.clean(cx)},\n             TySlice(ref ty) => Vector(box ty.clean(cx)),\n-            TyArray(ref ty, ref e) => {\n+            TyArray(ref ty, e) => {\n                 use rustc_const_math::{ConstInt, ConstUsize};\n                 use rustc_const_eval::eval_const_expr;\n                 use rustc::middle::const_val::ConstVal;\n \n+                let e = &cx.tcx.map.body(e).value;\n                 let n = match eval_const_expr(cx.tcx, e) {\n                     ConstVal::Integral(ConstInt::Usize(u)) => match u {\n                         ConstUsize::Us16(u) => u.to_string(),\n@@ -2372,7 +2373,7 @@ impl Clean<Item> for doctree::Static {\n             inner: StaticItem(Static {\n                 type_: self.type_.clean(cx),\n                 mutability: self.mutability.clean(cx),\n-                expr: pprust::expr_to_string(&self.expr),\n+                expr: print_const_expr(cx, self.expr),\n             }),\n         }\n     }\n@@ -2396,7 +2397,7 @@ impl Clean<Item> for doctree::Constant {\n             deprecation: self.depr.clean(cx),\n             inner: ConstantItem(Constant {\n                 type_: self.type_.clean(cx),\n-                expr: pprust::expr_to_string(&self.expr),\n+                expr: print_const_expr(cx, self.expr),\n             }),\n         }\n     }\n@@ -2724,6 +2725,10 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     }\n }\n \n+fn print_const_expr(cx: &DocContext, body: hir::BodyId) -> String {\n+    pprust::expr_to_string(&cx.tcx.map.body(body).value)\n+}\n+\n /// Given a type Path, resolve it to a Type using the TyCtxt\n fn resolve_type(cx: &DocContext,\n                 path: Path,"}, {"sha": "46b1ed2aa24d9a6a7e0c5a2fbd54235ba3590029", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -174,7 +174,7 @@ pub struct Typedef {\n pub struct Static {\n     pub type_: P<hir::Ty>,\n     pub mutability: hir::Mutability,\n-    pub expr: P<hir::Expr>,\n+    pub expr: hir::BodyId,\n     pub name: Name,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub vis: hir::Visibility,\n@@ -186,7 +186,7 @@ pub struct Static {\n \n pub struct Constant {\n     pub type_: P<hir::Ty>,\n-    pub expr: P<hir::Expr>,\n+    pub expr: hir::BodyId,\n     pub name: Name,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub vis: hir::Visibility,"}, {"sha": "726e23265241dac4f6ac35e5c78113466dafffbb", "filename": "src/test/compile-fail/E0513.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/864928297d0fc0675c5eae62a58d8488941d58cf/src%2Ftest%2Fcompile-fail%2FE0513.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864928297d0fc0675c5eae62a58d8488941d58cf/src%2Ftest%2Fcompile-fail%2FE0513.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0513.rs?ref=864928297d0fc0675c5eae62a58d8488941d58cf", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::mem;\n-\n-fn main() {\n-    unsafe {\n-        let size = mem::size_of::<u32>();\n-        mem::transmute_copy::<u32, [u8; size]>(&8_8); //~ ERROR E0513\n-                                                      //~| NOTE no type for variable\n-    }\n-}"}, {"sha": "7c3f7a1d574f99fea3df47f3b596ba8f4ad3a9e0", "filename": "src/test/compile-fail/associated-const-type-parameter-arrays-2.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -25,8 +25,10 @@ impl Foo for Def {\n }\n \n pub fn test<A: Foo, B: Foo>() {\n-    let _array = [4; <A as Foo>::Y]; //~ ERROR E0080\n-                                     //~| non-constant path in constant\n+    let _array = [4; <A as Foo>::Y];\n+    //~^ ERROR cannot use an outer type parameter in this context [E0402]\n+    //~| ERROR constant evaluation error [E0080]\n+    //~| non-constant path in constant\n }\n \n fn main() {"}, {"sha": "dcf87d5f0fc44b97585cd070cc9f54ceab7fa4e6", "filename": "src/test/compile-fail/associated-const-type-parameter-arrays.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -26,7 +26,9 @@ impl Foo for Def {\n \n pub fn test<A: Foo, B: Foo>() {\n     let _array: [u32; <A as Foo>::Y];\n-    //~^ ERROR the trait bound `A: Foo` is not satisfied\n+    //~^ ERROR cannot use an outer type parameter in this context [E0402]\n+    //~| ERROR constant evaluation error [E0080]\n+    //~| non-constant path in constant\n }\n \n fn main() {"}, {"sha": "f80135848e0c10fe4f8de3139b715a58fd4f82c3", "filename": "src/test/compile-fail/issue-27008.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -16,6 +16,4 @@ fn main() {\n     //~| expected type `usize`\n     //~| found type `S`\n     //~| expected usize, found struct `S`\n-    //~| ERROR expected `usize` for repeat count, found struct [E0306]\n-    //~| expected `usize`\n }"}, {"sha": "691d8d31b412d1c3934d8cbf2f7da2cff49b1788", "filename": "src/test/compile-fail/non-constant-expr-for-fixed-len-vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -12,8 +12,8 @@\n \n fn main() {\n     fn bar(n: isize) {\n-        // FIXME (#24414): This error message needs improvement.\n         let _x: [isize; n];\n-        //~^ ERROR no type for local variable\n+        //~^ ERROR attempt to use a non-constant value in a constant [E0435]\n+        //~| ERROR constant evaluation error [E0080]\n     }\n }"}, {"sha": "f4769a78587280494ea4bab4f91ca3784317f148", "filename": "src/test/compile-fail/non-constant-expr-for-vec-repeat.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -13,8 +13,9 @@\n fn main() {\n     fn bar(n: usize) {\n         let _x = [0; n];\n-        //~^ ERROR constant evaluation error\n-        //~| non-constant path in constant expression\n-        //~| NOTE `n` is a variable\n+        //~^ ERROR attempt to use a non-constant value in a constant [E0435]\n+        //~| NOTE non-constant used with constant\n+        //~| NOTE unresolved path in constant expression\n+        //~| ERROR constant evaluation error [E0080]\n     }\n }"}, {"sha": "a716f3e29d488ce62adf8503f769b5deb70f6361", "filename": "src/test/compile-fail/repeat_count.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -13,43 +13,30 @@\n fn main() {\n     let n = 1;\n     let a = [0; n];\n-    //~^ ERROR constant evaluation error\n-    //~| non-constant path in constant expression\n+    //~^ ERROR attempt to use a non-constant value in a constant [E0435]\n     let b = [0; ()];\n     //~^ ERROR mismatched types\n     //~| expected type `usize`\n     //~| found type `()`\n     //~| expected usize, found ()\n-    //~| ERROR expected `usize` for repeat count, found tuple [E0306]\n-    //~| expected `usize`\n     let c = [0; true];\n     //~^ ERROR mismatched types\n     //~| expected usize, found bool\n-    //~| ERROR expected `usize` for repeat count, found boolean [E0306]\n-    //~| expected `usize`\n     let d = [0; 0.5];\n     //~^ ERROR mismatched types\n     //~| expected type `usize`\n     //~| found type `{float}`\n     //~| expected usize, found floating-point variable\n-    //~| ERROR expected `usize` for repeat count, found float [E0306]\n-    //~| expected `usize`\n     let e = [0; \"foo\"];\n     //~^ ERROR mismatched types\n     //~| expected type `usize`\n     //~| found type `&'static str`\n     //~| expected usize, found reference\n-    //~| ERROR expected `usize` for repeat count, found string literal [E0306]\n-    //~| expected `usize`\n     let f = [0; -4_isize];\n-    //~^ ERROR constant evaluation error\n-    //~| expected usize, found isize\n-    //~| ERROR mismatched types\n+    //~^ ERROR mismatched types\n     //~| expected usize, found isize\n     let f = [0_usize; -1_isize];\n-    //~^ ERROR constant evaluation error\n-    //~| expected usize, found isize\n-    //~| ERROR mismatched types\n+    //~^ ERROR mismatched types\n     //~| expected usize, found isize\n     struct G {\n         g: (),\n@@ -59,6 +46,4 @@ fn main() {\n     //~| expected type `usize`\n     //~| found type `main::G`\n     //~| expected usize, found struct `main::G`\n-    //~| ERROR expected `usize` for repeat count, found struct [E0306]\n-    //~| expected `usize`\n }"}, {"sha": "28e85c94b664ce47882d2559402eeea53f64f259", "filename": "src/test/incremental/hashes/consts.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Fincremental%2Fhashes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Fincremental%2Fhashes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fconsts.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -66,8 +66,10 @@ const CONST_CHANGE_TYPE_2: Option<u64> = None;\n const CONST_CHANGE_VALUE_1: i16 = 1;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n const CONST_CHANGE_VALUE_1: i16 = 2;\n@@ -78,8 +80,10 @@ const CONST_CHANGE_VALUE_1: i16 = 2;\n const CONST_CHANGE_VALUE_2: i16 = 1 + 1;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n const CONST_CHANGE_VALUE_2: i16 = 1 + 2;\n@@ -89,8 +93,10 @@ const CONST_CHANGE_VALUE_2: i16 = 1 + 2;\n const CONST_CHANGE_VALUE_3: i16 = 2 + 3;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n const CONST_CHANGE_VALUE_3: i16 = 2 * 3;\n@@ -100,8 +106,10 @@ const CONST_CHANGE_VALUE_3: i16 = 2 * 3;\n const CONST_CHANGE_VALUE_4: i16 = 1 + 2 * 3;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n const CONST_CHANGE_VALUE_4: i16 = 1 + 2 * 4;"}, {"sha": "da3a953d11eaa883367ebcdedcca038947c44a7f", "filename": "src/test/incremental/hashes/enum_defs.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -108,8 +108,10 @@ enum EnumChangeValueCStyleVariant0 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumChangeValueCStyleVariant0 {\n@@ -126,6 +128,8 @@ enum EnumChangeValueCStyleVariant1 {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumChangeValueCStyleVariant1 {"}, {"sha": "7c6da3ba9fea6030f7d88d0628862c3f3c1be10e", "filename": "src/test/incremental/hashes/statics.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -119,9 +119,11 @@ static STATIC_CHANGE_TYPE_2: Option<u16> = None;\n static STATIC_CHANGE_VALUE_1: i16 = 1;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n static STATIC_CHANGE_VALUE_1: i16 = 2;\n \n@@ -131,9 +133,11 @@ static STATIC_CHANGE_VALUE_1: i16 = 2;\n static STATIC_CHANGE_VALUE_2: i16 = 1 + 1;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n static STATIC_CHANGE_VALUE_2: i16 = 1 + 2;\n \n@@ -142,9 +146,11 @@ static STATIC_CHANGE_VALUE_2: i16 = 1 + 2;\n static STATIC_CHANGE_VALUE_3: i16 = 2 + 3;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n static STATIC_CHANGE_VALUE_3: i16 = 2 * 3;\n \n@@ -153,9 +159,11 @@ static STATIC_CHANGE_VALUE_3: i16 = 2 * 3;\n static STATIC_CHANGE_VALUE_4: i16 = 1 + 2 * 3;\n \n #[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n static STATIC_CHANGE_VALUE_4: i16 = 1 + 2 * 4;\n "}, {"sha": "8651a67bae221e88a5d4e9a3e24347b259b27d6a", "filename": "src/test/incremental/string_constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Fincremental%2Fstring_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Fincremental%2Fstring_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstring_constant.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -23,14 +23,14 @@ fn main() { }\n mod x {\n     #[cfg(rpass1)]\n     pub fn x() {\n-        println!(\"1\");\n+        println!(\"{}\", \"1\");\n     }\n \n     #[cfg(rpass2)]\n     #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n     #[rustc_dirty(label=\"TransCrateItem\", cfg=\"rpass2\")]\n     pub fn x() {\n-        println!(\"2\");\n+        println!(\"{}\", \"2\");\n     }\n }\n "}, {"sha": "e1b1b441894b75eeeb087697d8e658a51b1a522c", "filename": "src/test/run-pass-fulldeps/issue-37290/auxiliary/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fauxiliary%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64f64a2fc1deb955b42542fa399f2fa2b609866/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fauxiliary%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-37290%2Fauxiliary%2Flint.rs?ref=e64f64a2fc1deb955b42542fa399f2fa2b609866", "patch": "@@ -41,12 +41,12 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_fn(&mut self, cx: &LateContext,\n-                              fk: FnKind, _: &hir::FnDecl, expr: &hir::Expr,\n+                              fk: FnKind, _: &hir::FnDecl, body: &hir::Body,\n                               span: Span, node: ast::NodeId)\n     {\n         if let FnKind::Closure(..) = fk { return }\n \n-        let mut extent = cx.tcx.region_maps.node_extent(expr.id);\n+        let mut extent = cx.tcx.region_maps.node_extent(body.value.id);\n         while let Some(parent) = cx.tcx.region_maps.opt_encl_scope(extent) {\n             extent = parent;\n         }"}]}