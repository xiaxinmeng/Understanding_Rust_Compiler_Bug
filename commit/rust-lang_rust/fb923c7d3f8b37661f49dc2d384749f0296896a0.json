{"sha": "fb923c7d3f8b37661f49dc2d384749f0296896a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiOTIzYzdkM2Y4YjM3NjYxZjQ5ZGMyZDM4NDc0OWYwMjk2ODk2YTA=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-09-20T11:47:05Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-09-22T14:11:42Z"}, "message": "std: merge rand::{Rng,RngUtil} with default methods.\n\nAlso, documentation & general clean-up:\n- remove `gen_char_from`: better served by `sample` or `choose`.\n- `gen_bytes` generalised to `gen_vec`.\n- `gen_int_range`/`gen_uint_range` merged into `gen_integer_range` and\n  made to be properly uniformly distributed. Fixes #8644.\n\nMinor adjustments to other functions.", "tree": {"sha": "00511e56a20f9d041d0697e1b5c470d7ce680f77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00511e56a20f9d041d0697e1b5c470d7ce680f77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb923c7d3f8b37661f49dc2d384749f0296896a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb923c7d3f8b37661f49dc2d384749f0296896a0", "html_url": "https://github.com/rust-lang/rust/commit/fb923c7d3f8b37661f49dc2d384749f0296896a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb923c7d3f8b37661f49dc2d384749f0296896a0/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "884c1e112de4f2d070357c9ed94543fb68de69e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/884c1e112de4f2d070357c9ed94543fb68de69e5", "html_url": "https://github.com/rust-lang/rust/commit/884c1e112de4f2d070357c9ed94543fb68de69e5"}], "stats": {"total": 696, "additions": 309, "deletions": 387}, "files": [{"sha": "191ecbe8d16b42969b9ce7e6ff5c50f95b7be28f", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=fb923c7d3f8b37661f49dc2d384749f0296896a0", "patch": "@@ -311,11 +311,11 @@ mod test {\n \n     #[test]\n     fn test_base64_random() {\n-        use std::rand::{task_rng, random, RngUtil};\n+        use std::rand::{task_rng, random, Rng};\n         use std::vec;\n \n         do 1000.times {\n-            let times = task_rng().gen_uint_range(1, 100);\n+            let times = task_rng().gen_integer_range(1u, 100);\n             let v = vec::from_fn(times, |_| random::<u8>());\n             assert_eq!(v.to_base64(STANDARD).from_base64().unwrap(), v);\n         }"}, {"sha": "c5311d210ab9bb513a3480f19ecd2c0e70129cfc", "filename": "src/libextra/container.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibextra%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibextra%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcontainer.rs?ref=fb923c7d3f8b37661f49dc2d384749f0296896a0", "patch": "@@ -43,7 +43,7 @@ pub trait Deque<T> : Mutable {\n mod bench {\n     use std::container::MutableMap;\n     use std::{vec, rand};\n-    use std::rand::RngUtil;\n+    use std::rand::Rng;\n     use test::BenchHarness;\n \n     pub fn insert_rand_n<M:MutableMap<uint,uint>>(n: uint,"}, {"sha": "4eba3e13eea5985e3978bc190cd89c733bb1d5bf", "filename": "src/libextra/crypto/cryptoutil.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs?ref=fb923c7d3f8b37661f49dc2d384749f0296896a0", "patch": "@@ -347,8 +347,7 @@ impl <T: FixedBuffer> StandardPadding for T {\n \n #[cfg(test)]\n mod test {\n-    use std::rand::IsaacRng;\n-    use std::rand::RngUtil;\n+    use std::rand::{IsaacRng, Rng};\n     use std::vec;\n \n     use cryptoutil::{add_bytes_to_bits, add_bytes_to_bits_tuple};\n@@ -365,7 +364,7 @@ mod test {\n         digest.reset();\n \n         while count < total_size {\n-            let next: uint = rng.gen_uint_range(0, 2 * blocksize + 1);\n+            let next: uint = rng.gen_integer_range(0, 2 * blocksize + 1);\n             let remaining = total_size - count;\n             let size = if next > remaining { remaining } else { next };\n             digest.input(buffer.slice_to(size));"}, {"sha": "e12ac276482436666901023a02ec63a6991c4ffc", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=fb923c7d3f8b37661f49dc2d384749f0296896a0", "patch": "@@ -106,15 +106,15 @@ pub fn inflate_bytes_zlib(bytes: &[u8]) -> ~[u8] {\n mod tests {\n     use super::*;\n     use std::rand;\n-    use std::rand::RngUtil;\n+    use std::rand::Rng;\n \n     #[test]\n     fn test_flate_round_trip() {\n         let mut r = rand::rng();\n         let mut words = ~[];\n         do 20.times {\n-            let range = r.gen_uint_range(1, 10);\n-            words.push(r.gen_bytes(range));\n+            let range = r.gen_integer_range(1u, 10);\n+            words.push(r.gen_vec::<u8>(range));\n         }\n         do 20.times {\n             let mut input = ~[];"}, {"sha": "f7462ae29438b02e850a8314ff3741baeb594eac", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=fb923c7d3f8b37661f49dc2d384749f0296896a0", "patch": "@@ -23,7 +23,7 @@ use std::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use std::int;\n use std::num;\n use std::num::{IntConvertible, Zero, One, ToStrRadix, FromStrRadix, Orderable};\n-use std::rand::{Rng, RngUtil};\n+use std::rand::Rng;\n use std::str;\n use std::uint;\n use std::vec;"}, {"sha": "bab889ff9245a42a725b8875faa50649c41117d4", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=fb923c7d3f8b37661f49dc2d384749f0296896a0", "patch": "@@ -909,7 +909,7 @@ mod tests {\n mod test_tim_sort {\n \n     use sort::tim_sort;\n-    use std::rand::RngUtil;\n+    use std::rand::Rng;\n     use std::rand;\n     use std::vec;\n \n@@ -1008,7 +1008,7 @@ mod big_tests {\n \n     use sort::*;\n \n-    use std::rand::RngUtil;\n+    use std::rand::Rng;\n     use std::rand;\n     use std::vec;\n \n@@ -1069,8 +1069,8 @@ mod big_tests {\n             isSorted(arr);\n \n             do 3.times {\n-                let i1 = rng.gen_uint_range(0, n);\n-                let i2 = rng.gen_uint_range(0, n);\n+                let i1 = rng.gen_integer_range(0u, n);\n+                let i2 = rng.gen_integer_range(0u, n);\n                 arr.swap(i1, i2);\n             }\n             tim_sort(arr); // 3sort\n@@ -1088,7 +1088,7 @@ mod big_tests {\n             isSorted(arr);\n \n             do (n/100).times {\n-                let idx = rng.gen_uint_range(0, n);\n+                let idx = rng.gen_integer_range(0u, n);\n                 arr[idx] = rng.gen();\n             }\n             tim_sort(arr);\n@@ -1141,8 +1141,8 @@ mod big_tests {\n             isSorted(arr);\n \n             do 3.times {\n-                let i1 = rng.gen_uint_range(0, n);\n-                let i2 = rng.gen_uint_range(0, n);\n+                let i1 = rng.gen_integer_range(0u, n);\n+                let i2 = rng.gen_integer_range(0u, n);\n                 arr.swap(i1, i2);\n             }\n             tim_sort(arr); // 3sort\n@@ -1160,7 +1160,7 @@ mod big_tests {\n             isSorted(arr);\n \n             do (n/100).times {\n-                let idx = rng.gen_uint_range(0, n);\n+                let idx = rng.gen_integer_range(0u, n);\n                 arr[idx] = @rng.gen();\n             }\n             tim_sort(arr);"}, {"sha": "13e0c47433f684a01f32e89c395a36ff276e0ea9", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=fb923c7d3f8b37661f49dc2d384749f0296896a0", "patch": "@@ -12,15 +12,15 @@\n \n \n use std::os;\n-use std::rand::RngUtil;\n+use std::rand::Rng;\n use std::rand;\n \n /// Attempts to make a temporary directory inside of `tmpdir` whose name will\n /// have the suffix `suffix`. If no directory can be created, None is returned.\n pub fn mkdtemp(tmpdir: &Path, suffix: &str) -> Option<Path> {\n     let mut r = rand::rng();\n     for _ in range(0u, 1000) {\n-        let p = tmpdir.push(r.gen_str(16) + suffix);\n+        let p = tmpdir.push(r.gen_ascii_str(16) + suffix);\n         if os::make_dir(&p, 0x1c0) { // 700\n             return Some(p);\n         }"}, {"sha": "8ddc0413aa3c71efe33de61e7c26f8667ce32aa1", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=fb923c7d3f8b37661f49dc2d384749f0296896a0", "patch": "@@ -874,7 +874,7 @@ mod test_treemap {\n \n     use super::*;\n \n-    use std::rand::RngUtil;\n+    use std::rand::Rng;\n     use std::rand;\n \n     #[test]\n@@ -1028,7 +1028,7 @@ mod test_treemap {\n             }\n \n             do 30.times {\n-                let r = rng.gen_uint_range(0, ctrl.len());\n+                let r = rng.gen_integer_range(0, ctrl.len());\n                 let (key, _) = ctrl.remove(r);\n                 assert!(map.remove(&key));\n                 check_structure(&map);"}, {"sha": "8eff9a022995a7f193b3ddfad52afe1aa70f31a8", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=fb923c7d3f8b37661f49dc2d384749f0296896a0", "patch": "@@ -62,7 +62,7 @@ use std::char::Char;\n use std::container::Container;\n use std::to_str::ToStr;\n use std::rand;\n-use std::rand::RngUtil;\n+use std::rand::Rng;\n use std::cmp::Eq;\n use std::cast::{transmute,transmute_copy};\n \n@@ -170,7 +170,7 @@ impl Uuid {\n     /// of random numbers. Use the rand::Rand trait to supply\n     /// a custom generator if required.\n     pub fn new_v4() -> Uuid {\n-        let ub = rand::task_rng().gen_bytes(16);\n+        let ub = rand::task_rng().gen_vec(16);\n         let mut uuid = Uuid{ bytes: [0, .. 16] };\n         vec::bytes::copy_memory(uuid.bytes, ub, 16);\n         uuid.set_variant(VariantRFC4122);\n@@ -488,7 +488,7 @@ impl TotalEq for Uuid {\n impl rand::Rand for Uuid {\n     #[inline]\n     fn rand<R: rand::Rng>(rng: &mut R) -> Uuid {\n-        let ub = rng.gen_bytes(16);\n+        let ub = rng.gen_vec(16);\n         let mut uuid = Uuid{ bytes: [0, .. 16] };\n         vec::bytes::copy_memory(uuid.bytes, ub, 16);\n         uuid.set_variant(VariantRFC4122);"}, {"sha": "f496e89acf75dfae2c5e879c221b38f52cb805ce", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=fb923c7d3f8b37661f49dc2d384749f0296896a0", "patch": "@@ -24,7 +24,7 @@ use iter::{Iterator, FromIterator, Extendable};\n use iter::{FilterMap, Chain, Repeat, Zip};\n use num;\n use option::{None, Option, Some};\n-use rand::RngUtil;\n+use rand::Rng;\n use rand;\n use uint;\n use util::replace;"}, {"sha": "ca524a255ae8630975fc04a78cf173ea5c6bf43a", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=fb923c7d3f8b37661f49dc2d384749f0296896a0", "patch": "@@ -734,7 +734,7 @@ mod test {\n #[cfg(test)]\n mod bench {\n     use extra::test::BenchHarness;\n-    use rand::{XorShiftRng,RngUtil};\n+    use rand::{XorShiftRng, Rng};\n     use float;\n     use to_str::ToStr;\n "}, {"sha": "08a1f879e7804634c50e1e9e631c170e35c3f8f0", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=fb923c7d3f8b37661f49dc2d384749f0296896a0", "patch": "@@ -1718,7 +1718,7 @@ mod tests {\n     use os::{remove_file, setenv, unsetenv};\n     use os;\n     use path::Path;\n-    use rand::RngUtil;\n+    use rand::Rng;\n     use rand;\n     use run;\n     use str::StrSlice;\n@@ -1738,7 +1738,7 @@ mod tests {\n \n     fn make_rand_name() -> ~str {\n         let mut rng = rand::rng();\n-        let n = ~\"TEST\" + rng.gen_str(10u);\n+        let n = ~\"TEST\" + rng.gen_ascii_str(10u);\n         assert!(getenv(n).is_none());\n         n\n     }"}, {"sha": "525e8a68d5812b1793b05a27518f8fad1f13ed91", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 272, "deletions": 349, "changes": 621, "blob_url": "https://github.com/rust-lang/rust/blob/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=fb923c7d3f8b37661f49dc2d384749f0296896a0", "patch": "@@ -11,7 +11,7 @@\n /*!\n Random number generation.\n \n-The key functions are `random()` and `RngUtil::gen()`. These are polymorphic\n+The key functions are `random()` and `Rng::gen()`. These are polymorphic\n and so can be used to generate any type that implements `Rand`. Type inference\n means that often a simple call to `rand::random()` or `rng.gen()` will\n suffice, but sometimes an annotation is required, e.g. `rand::random::<float>()`.\n@@ -23,7 +23,7 @@ distributions like normal and exponential.\n \n ~~~ {.rust}\n use std::rand;\n-use std::rand::RngUtil;\n+use std::rand::Rng;\n \n fn main() {\n     let mut rng = rand::rng();\n@@ -44,17 +44,16 @@ fn main () {\n */\n \n use cast;\n-use clone::Clone;\n use cmp;\n use container::Container;\n use int;\n use iter::{Iterator, range, range_step};\n use local_data;\n-use num;\n use prelude::*;\n use str;\n use sys;\n use u32;\n+use u64;\n use uint;\n use vec;\n use libc::size_t;\n@@ -248,12 +247,6 @@ pub mod rustrt {\n     }\n }\n \n-/// A random number generator\n-pub trait Rng {\n-    /// Return the next random integer\n-    fn next(&mut self) -> u32;\n-}\n-\n /// A value with a particular weight compared to other values\n pub struct Weighted<T> {\n     /// The numerical weight of this item\n@@ -262,311 +255,187 @@ pub struct Weighted<T> {\n     item: T,\n }\n \n-/// Helper functions attached to the Rng type\n-pub trait RngUtil {\n-    /// Return a random value of a Rand type\n-    fn gen<T:Rand>(&mut self) -> T;\n-    /**\n-     * Return a int randomly chosen from the range [start, end),\n-     * failing if start >= end\n-     */\n-    fn gen_int_range(&mut self, start: int, end: int) -> int;\n-    /**\n-     * Return a uint randomly chosen from the range [start, end),\n-     * failing if start >= end\n-     */\n-    fn gen_uint_range(&mut self, start: uint, end: uint) -> uint;\n-    /**\n-     * Return a char randomly chosen from chars, failing if chars is empty\n-     */\n-    fn gen_char_from(&mut self, chars: &str) -> char;\n-    /**\n-     * Return a bool with a 1 in n chance of true\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     *\n-     * use std::rand;\n-     * use std::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     let mut rng = rand::rng();\n-     *     printfln!(\"%b\", rng.gen_weighted_bool(3));\n-     * }\n-     * ~~~\n-     */\n-    fn gen_weighted_bool(&mut self, n: uint) -> bool;\n-    /**\n-     * Return a random string of the specified length composed of A-Z,a-z,0-9\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     *\n-     * use std::rand;\n-     * use std::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     let mut rng = rand::rng();\n-     *     println(rng.gen_str(8));\n-     * }\n-     * ~~~\n-     */\n-    fn gen_str(&mut self, len: uint) -> ~str;\n-    /**\n-     * Return a random byte string of the specified length\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     *\n-     * use std::rand;\n-     * use std::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     let mut rng = rand::rng();\n-     *     printfln!(rng.gen_bytes(8));\n-     * }\n-     * ~~~\n-     */\n-    fn gen_bytes(&mut self, len: uint) -> ~[u8];\n-    /**\n-     * Choose an item randomly, failing if values is empty\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     *\n-     * use std::rand;\n-     * use std::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     let mut rng = rand::rng();\n-     *     printfln!(\"%d\", rng.choose([1,2,4,8,16,32]));\n-     * }\n-     * ~~~\n-     */\n-    fn choose<T:Clone>(&mut self, values: &[T]) -> T;\n-    /// Choose Some(item) randomly, returning None if values is empty\n-    fn choose_option<T:Clone>(&mut self, values: &[T]) -> Option<T>;\n-    /**\n-     * Choose an item respecting the relative weights, failing if the sum of\n-     * the weights is 0\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     *\n-     * use std::rand;\n-     * use std::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     let mut rng = rand::rng();\n-     *     let x = [rand::Weighted {weight: 4, item: 'a'},\n-     *              rand::Weighted {weight: 2, item: 'b'},\n-     *              rand::Weighted {weight: 2, item: 'c'}];\n-     *     printfln!(\"%c\", rng.choose_weighted(x));\n-     * }\n-     * ~~~\n-     */\n-    fn choose_weighted<T:Clone>(&mut self, v : &[Weighted<T>]) -> T;\n-    /**\n-     * Choose Some(item) respecting the relative weights, returning none if\n-     * the sum of the weights is 0\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     *\n-     * use std::rand;\n-     * use std::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     let mut rng = rand::rng();\n-     *     let x = [rand::Weighted {weight: 4, item: 'a'},\n-     *              rand::Weighted {weight: 2, item: 'b'},\n-     *              rand::Weighted {weight: 2, item: 'c'}];\n-     *     printfln!(rng.choose_weighted_option(x));\n-     * }\n-     * ~~~\n-     */\n-    fn choose_weighted_option<T:Clone>(&mut self, v: &[Weighted<T>])\n-                                     -> Option<T>;\n-    /**\n-     * Return a vec containing copies of the items, in order, where\n-     * the weight of the item determines how many copies there are\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     *\n-     * use std::rand;\n-     * use std::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     let mut rng = rand::rng();\n-     *     let x = [rand::Weighted {weight: 4, item: 'a'},\n-     *              rand::Weighted {weight: 2, item: 'b'},\n-     *              rand::Weighted {weight: 2, item: 'c'}];\n-     *     printfln!(rng.weighted_vec(x));\n-     * }\n-     * ~~~\n-     */\n-    fn weighted_vec<T:Clone>(&mut self, v: &[Weighted<T>]) -> ~[T];\n-    /**\n-     * Shuffle a vec\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     *\n-     * use std::rand;\n-     * use std::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     let mut rng = rand::rng();\n-     *     printfln!(rng.shuffle([1,2,3]));\n-     * }\n-     * ~~~\n-     */\n-    fn shuffle<T:Clone>(&mut self, values: &[T]) -> ~[T];\n-    /**\n-     * Shuffle a mutable vec in place\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     *\n-     * use std::rand;\n-     * use std::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     let mut rng = rand::rng();\n-     *     let mut y = [1,2,3];\n-     *     rng.shuffle_mut(y);\n-     *     printfln!(y);\n-     *     rng.shuffle_mut(y);\n-     *     printfln!(y);\n-     * }\n-     * ~~~\n-     */\n-    fn shuffle_mut<T>(&mut self, values: &mut [T]);\n+/// A random number generator\n+pub trait Rng {\n+    /// Return the next random integer\n+    fn next(&mut self) -> u32;\n \n-    /**\n-     * Sample up to `n` values from an iterator.\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     *\n-     * use std::rand;\n-     * use std::rand::RngUtil;\n-     *\n-     * fn main() {\n-     *     let mut rng = rand::rng();\n-     *     let vals = range(1, 100).to_owned_vec();\n-     *     let sample = rng.sample(vals.iter(), 5);\n-     *     printfln!(sample);\n-     * }\n-     * ~~~\n-     */\n-    fn sample<A, T: Iterator<A>>(&mut self, iter: T, n: uint) -> ~[A];\n-}\n \n-/// Extension methods for random number generators\n-impl<R: Rng> RngUtil for R {\n-    /// Return a random value for a Rand type\n-    #[inline]\n+    /// Return a random value of a Rand type.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    ///\n+    /// fn main() {\n+    ///    let rng = rand::task_rng();\n+    ///    let x: uint = rng.gen();\n+    ///    printfln!(x);\n+    ///    printfln!(rng.gen::<(float, bool)>());\n+    /// }\n+    /// ~~~\n+    #[inline(always)]\n     fn gen<T: Rand>(&mut self) -> T {\n         Rand::rand(self)\n     }\n \n-    /**\n-     * Return an int randomly chosen from the range [start, end),\n-     * failing if start >= end\n-     */\n-    fn gen_int_range(&mut self, start: int, end: int) -> int {\n-        assert!(start < end);\n-        start + num::abs(self.gen::<int>() % (end - start))\n-    }\n-\n-    /**\n-     * Return a uint randomly chosen from the range [start, end),\n-     * failing if start >= end\n-     */\n-    fn gen_uint_range(&mut self, start: uint, end: uint) -> uint {\n-        assert!(start < end);\n-        start + (self.gen::<uint>() % (end - start))\n-    }\n-\n-    /**\n-     * Return a char randomly chosen from chars, failing if chars is empty\n-     */\n-    fn gen_char_from(&mut self, chars: &str) -> char {\n-        assert!(!chars.is_empty());\n-        let mut cs = ~[];\n-        for c in chars.iter() { cs.push(c) }\n-        self.choose(cs)\n-    }\n-\n-    /// Return a bool with a 1-in-n chance of true\n-    fn gen_weighted_bool(&mut self, n: uint) -> bool {\n-        if n == 0u {\n-            true\n-        } else {\n-            self.gen_uint_range(1u, n + 1u) == 1u\n+    /// Return a random vector of the specified length.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    ///\n+    /// fn main() {\n+    ///    let rng = rand::task_rng();\n+    ///    let x: ~[uint] = rng.gen_vec(10);\n+    ///    printfln!(x);\n+    ///    printfln!(rng.gen_vec::<(float, bool)>(5));\n+    /// }\n+    /// ~~~\n+    fn gen_vec<T: Rand>(&mut self, len: uint) -> ~[T] {\n+        vec::from_fn(len, |_| self.gen())\n+    }\n+\n+    /// Generate a random primitive integer in the range [`low`,\n+    /// `high`). Fails if `low >= high`.\n+    ///\n+    /// This gives a uniform distribution (assuming this RNG is itself\n+    /// uniform), even for edge cases like `gen_integer_range(0u8,\n+    /// 170)`, which a naive modulo operation would return numbers\n+    /// less than 85 with double the probability to those greater than\n+    /// 85.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    ///\n+    /// fn main() {\n+    ///    let rng = rand::task_rng();\n+    ///    let n: uint = rng.gen_integer_range(0u, 10);\n+    ///    printfln!(n);\n+    ///    let m: i16 = rng.gen_integer_range(-40, 400);\n+    ///    printfln!(m);\n+    /// }\n+    /// ~~~\n+    fn gen_integer_range<T: Rand + Int>(&mut self, low: T, high: T) -> T {\n+        assert!(low < high, \"RNG.gen_integer_range called with low >= high\");\n+        let range = (high - low).to_u64();\n+        let accept_zone = u64::max_value - u64::max_value % range;\n+        loop {\n+            let rand = self.gen::<u64>();\n+            if rand < accept_zone {\n+                return low + NumCast::from(rand % range);\n+            }\n         }\n     }\n \n-    /**\n-     * Return a random string of the specified length composed of A-Z,a-z,0-9\n-     */\n-    fn gen_str(&mut self, len: uint) -> ~str {\n-        let charset = ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n-                       abcdefghijklmnopqrstuvwxyz\\\n-                       0123456789\";\n-        let mut s = ~\"\";\n-        let mut i = 0u;\n-        while (i < len) {\n-            s = s + str::from_char(self.gen_char_from(charset));\n-            i += 1u;\n+    /// Return a bool with a 1 in n chance of true\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    /// use std::rand::Rng;\n+    ///\n+    /// fn main() {\n+    ///     let mut rng = rand::rng();\n+    ///     printfln!(\"%b\", rng.gen_weighted_bool(3));\n+    /// }\n+    /// ~~~\n+    fn gen_weighted_bool(&mut self, n: uint) -> bool {\n+        n == 0 || self.gen_integer_range(0, n) == 0\n+    }\n+\n+    /// Return a random string of the specified length composed of\n+    /// A-Z,a-z,0-9.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    ///\n+    /// fn main() {\n+    ///    println(rand::task_rng().gen_ascii_str(10));\n+    /// }\n+    /// ~~~\n+    fn gen_ascii_str(&mut self, len: uint) -> ~str {\n+        static GEN_ASCII_STR_CHARSET: &'static [u8] = bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n+                                                             abcdefghijklmnopqrstuvwxyz\\\n+                                                             0123456789\");\n+        let mut s = str::with_capacity(len);\n+        for _ in range(0, len) {\n+            s.push_char(self.choose(GEN_ASCII_STR_CHARSET) as char)\n         }\n         s\n     }\n \n-    /// Return a random byte string of the specified length\n-    fn gen_bytes(&mut self, len: uint) -> ~[u8] {\n-        do vec::from_fn(len) |_i| {\n-            self.gen()\n-        }\n-    }\n-\n-    /// Choose an item randomly, failing if values is empty\n-    fn choose<T:Clone>(&mut self, values: &[T]) -> T {\n-        self.choose_option(values).unwrap()\n-    }\n-\n-    /// Choose Some(item) randomly, returning None if values is empty\n-    fn choose_option<T:Clone>(&mut self, values: &[T]) -> Option<T> {\n+    /// Choose an item randomly, failing if `values` is empty.\n+    fn choose<T: Clone>(&mut self, values: &[T]) -> T {\n+        self.choose_option(values).expect(\"Rng.choose: `values` is empty\").clone()\n+    }\n+\n+    /// Choose `Some(&item)` randomly, returning `None` if values is\n+    /// empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    ///\n+    /// fn main() {\n+    ///     printfln!(rand::task_rng().choose_option([1,2,4,8,16,32]));\n+    ///     printfln!(rand::task_rng().choose_option([]));\n+    /// }\n+    /// ~~~\n+    fn choose_option<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n         if values.is_empty() {\n             None\n         } else {\n-            Some(values[self.gen_uint_range(0u, values.len())].clone())\n+            Some(&values[self.gen_integer_range(0u, values.len())])\n         }\n     }\n-    /**\n-     * Choose an item respecting the relative weights, failing if the sum of\n-     * the weights is 0\n-     */\n-    fn choose_weighted<T:Clone>(&mut self, v: &[Weighted<T>]) -> T {\n-        self.choose_weighted_option(v).unwrap()\n-    }\n \n-    /**\n-     * Choose Some(item) respecting the relative weights, returning none if\n-     * the sum of the weights is 0\n-     */\n+    /// Choose an item respecting the relative weights, failing if the sum of\n+    /// the weights is 0\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    /// use std::rand::Rng;\n+    ///\n+    /// fn main() {\n+    ///     let mut rng = rand::rng();\n+    ///     let x = [rand::Weighted {weight: 4, item: 'a'},\n+    ///              rand::Weighted {weight: 2, item: 'b'},\n+    ///              rand::Weighted {weight: 2, item: 'c'}];\n+    ///     printfln!(\"%c\", rng.choose_weighted(x));\n+    /// }\n+    /// ~~~\n+    fn choose_weighted<T:Clone>(&mut self, v: &[Weighted<T>]) -> T {\n+        self.choose_weighted_option(v).expect(\"Rng.choose_weighted: total weight is 0\")\n+    }\n+\n+    /// Choose Some(item) respecting the relative weights, returning none if\n+    /// the sum of the weights is 0\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    /// use std::rand::Rng;\n+    ///\n+    /// fn main() {\n+    ///     let mut rng = rand::rng();\n+    ///     let x = [rand::Weighted {weight: 4, item: 'a'},\n+    ///              rand::Weighted {weight: 2, item: 'b'},\n+    ///              rand::Weighted {weight: 2, item: 'c'}];\n+    ///     printfln!(rng.choose_weighted_option(x));\n+    /// }\n+    /// ~~~\n     fn choose_weighted_option<T:Clone>(&mut self, v: &[Weighted<T>])\n                                        -> Option<T> {\n         let mut total = 0u;\n@@ -576,7 +445,7 @@ impl<R: Rng> RngUtil for R {\n         if total == 0u {\n             return None;\n         }\n-        let chosen = self.gen_uint_range(0u, total);\n+        let chosen = self.gen_integer_range(0u, total);\n         let mut so_far = 0u;\n         for item in v.iter() {\n             so_far += item.weight;\n@@ -587,10 +456,23 @@ impl<R: Rng> RngUtil for R {\n         unreachable!();\n     }\n \n-    /**\n-     * Return a vec containing copies of the items, in order, where\n-     * the weight of the item determines how many copies there are\n-     */\n+    /// Return a vec containing copies of the items, in order, where\n+    /// the weight of the item determines how many copies there are\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    /// use std::rand::Rng;\n+    ///\n+    /// fn main() {\n+    ///     let mut rng = rand::rng();\n+    ///     let x = [rand::Weighted {weight: 4, item: 'a'},\n+    ///              rand::Weighted {weight: 2, item: 'b'},\n+    ///              rand::Weighted {weight: 2, item: 'c'}];\n+    ///     printfln!(rng.weighted_vec(x));\n+    /// }\n+    /// ~~~\n     fn weighted_vec<T:Clone>(&mut self, v: &[Weighted<T>]) -> ~[T] {\n         let mut r = ~[];\n         for item in v.iter() {\n@@ -602,24 +484,61 @@ impl<R: Rng> RngUtil for R {\n     }\n \n     /// Shuffle a vec\n-    fn shuffle<T:Clone>(&mut self, values: &[T]) -> ~[T] {\n-        let mut m = values.to_owned();\n-        self.shuffle_mut(m);\n-        m\n-    }\n-\n-    /// Shuffle a mutable vec in place\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    ///\n+    /// fn main() {\n+    ///     printfln!(rand::task_rng().shuffle(~[1,2,3]));\n+    /// }\n+    /// ~~~\n+    fn shuffle<T>(&mut self, values: ~[T]) -> ~[T] {\n+        let mut v = values;\n+        self.shuffle_mut(v);\n+        v\n+    }\n+\n+    /// Shuffle a mutable vector in place.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    ///\n+    /// fn main() {\n+    ///    let rng = rand::task_rng();\n+    ///    let mut y = [1,2,3];\n+    ///    rng.shuffle_mut(y);\n+    ///    printfln!(y);\n+    ///    rng.shuffle_mut(y);\n+    ///    printfln!(y);\n+    /// }\n+    /// ~~~\n     fn shuffle_mut<T>(&mut self, values: &mut [T]) {\n         let mut i = values.len();\n         while i >= 2u {\n             // invariant: elements with index >= i have been locked in place.\n             i -= 1u;\n             // lock element i in place.\n-            values.swap(i, self.gen_uint_range(0u, i + 1u));\n+            values.swap(i, self.gen_integer_range(0u, i + 1u));\n         }\n     }\n \n-    /// Randomly sample up to `n` elements from an iterator\n+    /// Randomly sample up to `n` elements from an iterator.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// use std::rand;\n+    ///\n+    /// fn main() {\n+    ///    let rng = rand::task_rng();\n+    ///    let sample = rng.sample(range(1, 100), 5);\n+    ///    printfln!(sample);\n+    /// }\n+    /// ~~~\n     fn sample<A, T: Iterator<A>>(&mut self, iter: T, n: uint) -> ~[A] {\n         let mut reservoir : ~[A] = vec::with_capacity(n);\n         for (i, elem) in iter.enumerate() {\n@@ -628,7 +547,7 @@ impl<R: Rng> RngUtil for R {\n                 loop\n             }\n \n-            let k = self.gen_uint_range(0, i + 1);\n+            let k = self.gen_integer_range(0, i + 1);\n             if k < reservoir.len() {\n                 reservoir[k] = elem\n             }\n@@ -961,7 +880,7 @@ mod test {\n         let seed = seed();\n         let mut ra = IsaacRng::new_seeded(seed);\n         let mut rb = IsaacRng::new_seeded(seed);\n-        assert_eq!(ra.gen_str(100u), rb.gen_str(100u));\n+        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n     }\n \n     #[test]\n@@ -970,7 +889,7 @@ mod test {\n         let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n         let mut ra = IsaacRng::new_seeded(seed);\n         let mut rb = IsaacRng::new_seeded(seed);\n-        assert_eq!(ra.gen_str(100u), rb.gen_str(100u));\n+        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n     }\n \n     #[test]\n@@ -985,35 +904,36 @@ mod test {\n     }\n \n     #[test]\n-    fn test_gen_int_range() {\n+    fn test_gen_integer_range() {\n         let mut r = rng();\n-        let a = r.gen_int_range(-3, 42);\n-        assert!(a >= -3 && a < 42);\n-        assert_eq!(r.gen_int_range(0, 1), 0);\n-        assert_eq!(r.gen_int_range(-12, -11), -12);\n-    }\n+        for _ in range(0, 1000) {\n+            let a = r.gen_integer_range(-3i, 42);\n+            assert!(a >= -3 && a < 42);\n+            assert_eq!(r.gen_integer_range(0, 1), 0);\n+            assert_eq!(r.gen_integer_range(-12, -11), -12);\n+        }\n+\n+        for _ in range(0, 1000) {\n+            let a = r.gen_integer_range(10, 42);\n+            assert!(a >= 10 && a < 42);\n+            assert_eq!(r.gen_integer_range(0, 1), 0);\n+            assert_eq!(r.gen_integer_range(3_000_000u, 3_000_001), 3_000_000);\n+        }\n \n-    #[test]\n-    #[should_fail]\n-    fn test_gen_int_from_fail() {\n-        let mut r = rng();\n-        r.gen_int_range(5, -2);\n     }\n \n     #[test]\n-    fn test_gen_uint_range() {\n+    #[should_fail]\n+    fn test_gen_integer_range_fail_int() {\n         let mut r = rng();\n-        let a = r.gen_uint_range(3u, 42u);\n-        assert!(a >= 3u && a < 42u);\n-        assert_eq!(r.gen_uint_range(0u, 1u), 0u);\n-        assert_eq!(r.gen_uint_range(12u, 13u), 12u);\n+        r.gen_integer_range(5i, -2);\n     }\n \n     #[test]\n     #[should_fail]\n-    fn test_gen_uint_range_fail() {\n+    fn test_gen_integer_range_fail_uint() {\n         let mut r = rng();\n-        r.gen_uint_range(5u, 2u);\n+        r.gen_integer_range(5u, 2u);\n     }\n \n     #[test]\n@@ -1032,22 +952,22 @@ mod test {\n     }\n \n     #[test]\n-    fn test_gen_str() {\n+    fn test_gen_ascii_str() {\n         let mut r = rng();\n-        debug!(r.gen_str(10u));\n-        debug!(r.gen_str(10u));\n-        debug!(r.gen_str(10u));\n-        assert_eq!(r.gen_str(0u).len(), 0u);\n-        assert_eq!(r.gen_str(10u).len(), 10u);\n-        assert_eq!(r.gen_str(16u).len(), 16u);\n+        debug!(r.gen_ascii_str(10u));\n+        debug!(r.gen_ascii_str(10u));\n+        debug!(r.gen_ascii_str(10u));\n+        assert_eq!(r.gen_ascii_str(0u).len(), 0u);\n+        assert_eq!(r.gen_ascii_str(10u).len(), 10u);\n+        assert_eq!(r.gen_ascii_str(16u).len(), 16u);\n     }\n \n     #[test]\n-    fn test_gen_bytes() {\n+    fn test_gen_vec() {\n         let mut r = rng();\n-        assert_eq!(r.gen_bytes(0u).len(), 0u);\n-        assert_eq!(r.gen_bytes(10u).len(), 10u);\n-        assert_eq!(r.gen_bytes(16u).len(), 16u);\n+        assert_eq!(r.gen_vec::<u8>(0u).len(), 0u);\n+        assert_eq!(r.gen_vec::<u8>(10u).len(), 10u);\n+        assert_eq!(r.gen_vec::<f64>(16u).len(), 16u);\n     }\n \n     #[test]\n@@ -1059,9 +979,12 @@ mod test {\n     #[test]\n     fn test_choose_option() {\n         let mut r = rng();\n-        let x: Option<int> = r.choose_option([]);\n-        assert!(x.is_none());\n-        assert_eq!(r.choose_option([1, 1, 1]), Some(1));\n+        let v: &[int] = &[];\n+        assert!(r.choose_option(v).is_none());\n+\n+        let i = 1;\n+        let v = [1,1,1];\n+        assert_eq!(r.choose_option(v), Some(&i));\n     }\n \n     #[test]\n@@ -1106,16 +1029,16 @@ mod test {\n     fn test_shuffle() {\n         let mut r = rng();\n         let empty: ~[int] = ~[];\n-        assert_eq!(r.shuffle([]), empty);\n-        assert_eq!(r.shuffle([1, 1, 1]), ~[1, 1, 1]);\n+        assert_eq!(r.shuffle(~[]), empty);\n+        assert_eq!(r.shuffle(~[1, 1, 1]), ~[1, 1, 1]);\n     }\n \n     #[test]\n     fn test_task_rng() {\n         let mut r = task_rng();\n         r.gen::<int>();\n-        assert_eq!(r.shuffle([1, 1, 1]), ~[1, 1, 1]);\n-        assert_eq!(r.gen_uint_range(0u, 1u), 0u);\n+        assert_eq!(r.shuffle(~[1, 1, 1]), ~[1, 1, 1]);\n+        assert_eq!(r.gen_integer_range(0u, 1u), 0u);\n     }\n \n     #[test]"}, {"sha": "6336b1cbe2e783dab3c9c4993ae9f5c8f8fc0ce8", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=fb923c7d3f8b37661f49dc2d384749f0296896a0", "patch": "@@ -1095,7 +1095,7 @@ mod test {\n     #[test]\n     fn megapipe_stress() {\n         use rand;\n-        use rand::RngUtil;\n+        use rand::Rng;\n \n         if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n \n@@ -1106,7 +1106,7 @@ mod test {\n             let total = stress_factor() + 10;\n             let mut rng = rand::rng();\n             do total.times {\n-                let msgs = rng.gen_uint_range(0, 10);\n+                let msgs = rng.gen_integer_range(0u, 10);\n                 let pipe_clone = pipe.clone();\n                 let end_chan_clone = end_chan.clone();\n                 do spawntask_random {"}, {"sha": "9c6c53c206497db88d04bd91ae0c289cba79172a", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=fb923c7d3f8b37661f49dc2d384749f0296896a0", "patch": "@@ -26,7 +26,7 @@ use rt::local::Local;\n use rt::rtio::{RemoteCallback, PausibleIdleCallback};\n use borrow::{to_uint};\n use cell::Cell;\n-use rand::{XorShiftRng, RngUtil};\n+use rand::{XorShiftRng, Rng};\n use iter::range;\n use vec::{OwnedVector};\n \n@@ -391,7 +391,7 @@ impl Scheduler {\n     fn try_steals(&mut self) -> Option<~Task> {\n         let work_queues = &mut self.work_queues;\n         let len = work_queues.len();\n-        let start_index = self.rng.gen_uint_range(0, len);\n+        let start_index = self.rng.gen_integer_range(0, len);\n         for index in range(0, len).map(|i| (i + start_index) % len) {\n             match work_queues[index].steal() {\n                 Some(task) => {"}, {"sha": "807f62ece7ae558051ab8672efa7aa9fdaa9abb5", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=fb923c7d3f8b37661f49dc2d384749f0296896a0", "patch": "@@ -15,7 +15,7 @@ extern mod extra;\n use extra::time::precise_time_s;\n use std::io;\n use std::os;\n-use std::rand::RngUtil;\n+use std::rand::Rng;\n use std::rand;\n use std::str;\n use std::util;\n@@ -85,7 +85,7 @@ fn vec_plus() {\n     let mut v = ~[];\n     let mut i = 0;\n     while i < 1500 {\n-        let rv = vec::from_elem(r.gen_uint_range(0, i + 1), i);\n+        let rv = vec::from_elem(r.gen_integer_range(0u, i + 1), i);\n         if r.gen() {\n             v.push_all_move(rv);\n         } else {\n@@ -101,7 +101,7 @@ fn vec_append() {\n     let mut v = ~[];\n     let mut i = 0;\n     while i < 1500 {\n-        let rv = vec::from_elem(r.gen_uint_range(0, i + 1), i);\n+        let rv = vec::from_elem(r.gen_integer_range(0u, i + 1), i);\n         if r.gen() {\n             v = vec::append(v, rv);\n         }\n@@ -117,7 +117,7 @@ fn vec_push_all() {\n \n     let mut v = ~[];\n     for i in range(0u, 1500) {\n-        let mut rv = vec::from_elem(r.gen_uint_range(0, i + 1), i);\n+        let mut rv = vec::from_elem(r.gen_integer_range(0u, i + 1), i);\n         if r.gen() {\n             v.push_all(rv);\n         }"}, {"sha": "1a3a188b86f8d5500ed7528feb00b4a24fd58cca", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb923c7d3f8b37661f49dc2d384749f0296896a0/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=fb923c7d3f8b37661f49dc2d384749f0296896a0", "patch": "@@ -1,7 +1,7 @@\n // Perlin noise benchmark from https://gist.github.com/1170424\n \n use std::float;\n-use std::rand::{Rng, RngUtil};\n+use std::rand::Rng;\n use std::rand;\n \n struct Vec2 {"}]}