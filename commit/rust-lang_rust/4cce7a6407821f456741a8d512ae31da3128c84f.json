{"sha": "4cce7a6407821f456741a8d512ae31da3128c84f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjY2U3YTY0MDc4MjFmNDU2NzQxYThkNTEyYWUzMWRhMzEyOGM4NGY=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-12T06:04:56Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-31T19:49:44Z"}, "message": "Box field detection; test #[non-exhaustive] attribute", "tree": {"sha": "e7baddfdf72bcef8477fe20de090590b34932a3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7baddfdf72bcef8477fe20de090590b34932a3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cce7a6407821f456741a8d512ae31da3128c84f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cce7a6407821f456741a8d512ae31da3128c84f", "html_url": "https://github.com/rust-lang/rust/commit/4cce7a6407821f456741a8d512ae31da3128c84f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cce7a6407821f456741a8d512ae31da3128c84f/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f46a42f73aa92ab66800c70d525ddc7e6529edd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f46a42f73aa92ab66800c70d525ddc7e6529edd6", "html_url": "https://github.com/rust-lang/rust/commit/f46a42f73aa92ab66800c70d525ddc7e6529edd6"}], "stats": {"total": 62, "additions": 52, "deletions": 10}, "files": [{"sha": "061ef754db2819b0b0b303cb5e39115b14e3aa3c", "filename": "crates/hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4cce7a6407821f456741a8d512ae31da3128c84f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cce7a6407821f456741a8d512ae31da3128c84f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=4cce7a6407821f456741a8d512ae31da3128c84f", "patch": "@@ -1090,6 +1090,42 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn enum_non_exhaustive() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:lib\n+#[non_exhaustive]\n+pub enum E { A, B }\n+fn _local() {\n+    match E::A { _ => {} }\n+    match E::A {\n+        E::A => {}\n+        E::B => {}\n+    }\n+    match E::A {\n+        E::A | E::B => {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:lib\n+use lib::E;\n+fn main() {\n+    match E::A { _ => {} }\n+    match E::A {\n+        //^^^^ Missing match arm\n+        E::A => {}\n+        E::B => {}\n+    }\n+    match E::A {\n+        //^^^^ Missing match arm\n+        E::A | E::B => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     mod false_negatives {\n         //! The implementation of match checking here is a work in progress. As we roll this out, we\n         //! prefer false negatives to false positives (ideally there would be no false positives). This"}, {"sha": "6711fbb4ae7fd87d8e739743b238fcf32eed3f7b", "filename": "crates/hir_ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4cce7a6407821f456741a8d512ae31da3128c84f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cce7a6407821f456741a8d512ae31da3128c84f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=4cce7a6407821f456741a8d512ae31da3128c84f", "patch": "@@ -513,9 +513,7 @@ impl SplitWildcard {\n                 if is_secretly_empty || is_declared_nonexhaustive {\n                     smallvec![NonExhaustive]\n                 } else if cx.feature_exhaustive_patterns() {\n-                    // If `exhaustive_patterns` is enabled, we exclude variants known to be\n-                    // uninhabited.\n-                    unhandled()\n+                    unimplemented!() // see MatchCheckCtx.feature_exhaustive_patterns()\n                 } else {\n                     enum_data\n                         .variants\n@@ -643,6 +641,7 @@ impl Fields {\n         Fields::Vec(pats)\n     }\n \n+    /// Creates a new list of wildcard fields for a given constructor.\n     pub(crate) fn wildcards(pcx: PatCtxt<'_>, constructor: &Constructor) -> Self {\n         let ty = pcx.ty;\n         let cx = pcx.cx;\n@@ -655,14 +654,13 @@ impl Fields {\n                     Fields::wildcards_from_tys(cx, tys)\n                 }\n                 TyKind::Ref(.., rty) => Fields::from_single_pattern(wildcard_from_ty(rty)),\n-                TyKind::Adt(AdtId(adt), substs) => {\n-                    let adt_is_box = false; // TODO(iDawer): implement this\n-                    if adt_is_box {\n+                &TyKind::Adt(AdtId(adt), ref substs) => {\n+                    if adt_is_box(adt, cx) {\n                         // Use T as the sub pattern type of Box<T>.\n                         let subst_ty = substs.at(&Interner, 0).assert_ty_ref(&Interner);\n                         Fields::from_single_pattern(wildcard_from_ty(subst_ty))\n                     } else {\n-                        let variant_id = constructor.variant_id_for_adt(*adt);\n+                        let variant_id = constructor.variant_id_for_adt(adt);\n                         let adt_is_local =\n                             variant_id.module(cx.db.upcast()).krate() == cx.module.krate();\n                         // Whether we must not match the fields of this variant exhaustively.\n@@ -680,7 +678,7 @@ impl Fields {\n                         if has_no_hidden_fields {\n                             Fields::wildcards_from_tys(cx, field_tys())\n                         } else {\n-                            //FIXME(iDawer): see MatchCheckCtx::is_uninhabited\n+                            //FIXME(iDawer): see MatchCheckCtx::is_uninhabited, has_no_hidden_fields is always true\n                             unimplemented!(\"exhaustive_patterns feature\")\n                         }\n                     }\n@@ -892,3 +890,11 @@ fn is_field_list_non_exhaustive(variant_id: VariantId, cx: &MatchCheckCtx<'_>) -\n     };\n     cx.db.attrs(attr_def_id).by_key(\"non_exhaustive\").exists()\n }\n+\n+fn adt_is_box(adt: hir_def::AdtId, cx: &MatchCheckCtx<'_>) -> bool {\n+    use hir_def::lang_item::LangItemTarget;\n+    match cx.db.lang_item(cx.module.krate(), \"owned_box\".into()) {\n+        Some(LangItemTarget::StructId(box_id)) => adt == box_id.into(),\n+        _ => false,\n+    }\n+}"}, {"sha": "44e08b6e9e968c938b28d6e9b6c0df18e0f58db4", "filename": "crates/hir_ty/src/diagnostics/match_check/usefulness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cce7a6407821f456741a8d512ae31da3128c84f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cce7a6407821f456741a8d512ae31da3128c84f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs?ref=4cce7a6407821f456741a8d512ae31da3128c84f", "patch": "@@ -293,7 +293,7 @@ pub(crate) struct MatchCheckCtx<'a> {\n     pub(crate) match_expr: ExprId,\n     pub(crate) infer: &'a InferenceResult,\n     pub(crate) db: &'a dyn HirDatabase,\n-    /// Lowered patterns from self.body.pats plus generated by the check.\n+    /// Lowered patterns from arms plus generated by the check.\n     pub(crate) pattern_arena: &'a RefCell<PatternArena>,\n }\n \n@@ -315,7 +315,7 @@ impl<'a> MatchCheckCtx<'a> {\n \n     // Rust feature described as \"Allows exhaustive pattern matching on types that contain uninhabited types.\"\n     pub(super) fn feature_exhaustive_patterns(&self) -> bool {\n-        // TODO\n+        // FIXME see MatchCheckCtx::is_uninhabited\n         false\n     }\n "}]}