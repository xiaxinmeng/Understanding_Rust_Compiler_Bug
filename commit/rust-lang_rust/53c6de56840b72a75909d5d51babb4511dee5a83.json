{"sha": "53c6de56840b72a75909d5d51babb4511dee5a83", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzYzZkZTU2ODQwYjcyYTc1OTA5ZDVkNTFiYWJiNDUxMWRlZTVhODM=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-08-02T17:34:33Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-08-05T19:30:28Z"}, "message": "Improve debug spew in _match.", "tree": {"sha": "a431ae685c4ed270ec96cd9d1c087d521349231a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a431ae685c4ed270ec96cd9d1c087d521349231a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53c6de56840b72a75909d5d51babb4511dee5a83", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53c6de56840b72a75909d5d51babb4511dee5a83", "html_url": "https://github.com/rust-lang/rust/commit/53c6de56840b72a75909d5d51babb4511dee5a83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53c6de56840b72a75909d5d51babb4511dee5a83/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7dbc5ae79fc55bf6d6611da271031eed8acafe4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7dbc5ae79fc55bf6d6611da271031eed8acafe4c", "html_url": "https://github.com/rust-lang/rust/commit/7dbc5ae79fc55bf6d6611da271031eed8acafe4c"}], "stats": {"total": 91, "additions": 47, "deletions": 44}, "files": [{"sha": "0a008b2215ae5fa1fd53ff868e1e9888a0ecd0a4", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/53c6de56840b72a75909d5d51babb4511dee5a83/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c6de56840b72a75909d5d51babb4511dee5a83/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=53c6de56840b72a75909d5d51babb4511dee5a83", "patch": "@@ -171,6 +171,7 @@ use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::ty;\n use util::common::indenter;\n+use util::ppaux::{Repr, vec_map_to_str};\n \n use std::hashmap::HashMap;\n use std::vec;\n@@ -179,7 +180,6 @@ use syntax::ast::ident;\n use syntax::ast_util::path_to_ident;\n use syntax::ast_util;\n use syntax::codemap::{span, dummy_sp};\n-use syntax::print::pprust::pat_to_str;\n \n // An option identifying a literal: either a unit-like struct or an\n // expression.\n@@ -353,19 +353,17 @@ pub struct Match<'self> {\n     data: ArmData<'self>\n }\n \n-pub fn match_to_str(bcx: @mut Block, m: &Match) -> ~str {\n-    if bcx.sess().verbose() {\n-        // for many programs, this just take too long to serialize\n-        fmt!(\"%?\", m.pats.map(|p| pat_to_str(*p, bcx.sess().intr())))\n-    } else {\n-        fmt!(\"%u pats\", m.pats.len())\n+impl<'self> Repr for Match<'self> {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        if tcx.sess.verbose() {\n+            // for many programs, this just take too long to serialize\n+            self.pats.repr(tcx)\n+        } else {\n+            fmt!(\"%u pats\", self.pats.len())\n+        }\n     }\n }\n \n-pub fn matches_to_str(bcx: @mut Block, m: &[Match]) -> ~str {\n-    fmt!(\"%?\", m.map(|n| match_to_str(bcx, n)))\n-}\n-\n pub fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     for br in m.iter() {\n         match br.pats[col].node {\n@@ -381,9 +379,9 @@ pub fn expand_nested_bindings<'r>(bcx: @mut Block,\n                                   col: uint,\n                                   val: ValueRef)\n                               -> ~[Match<'r>] {\n-    debug!(\"expand_nested_bindings(bcx=%s, m=%s, col=%u, val=%?)\",\n+    debug!(\"expand_nested_bindings(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n+           m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n@@ -416,7 +414,7 @@ pub fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::pat) {\n         bcx.sess().span_bug(\n             p.span,\n             fmt!(\"Expected an identifier pattern but found p: %s\",\n-                 pat_to_str(p, bcx.sess().intr())));\n+                 p.repr(bcx.tcx())));\n     }\n }\n \n@@ -429,9 +427,9 @@ pub fn enter_match<'r>(bcx: @mut Block,\n                        val: ValueRef,\n                        e: enter_pat)\n                     -> ~[Match<'r>] {\n-    debug!(\"enter_match(bcx=%s, m=%s, col=%u, val=%?)\",\n+    debug!(\"enter_match(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n+           m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n@@ -467,7 +465,7 @@ pub fn enter_match<'r>(bcx: @mut Block,\n         }\n     }\n \n-    debug!(\"result=%s\", matches_to_str(bcx, result));\n+    debug!(\"result=%s\", result.repr(bcx.tcx()));\n \n     return result;\n }\n@@ -478,9 +476,9 @@ pub fn enter_default<'r>(bcx: @mut Block,\n                          col: uint,\n                          val: ValueRef)\n                       -> ~[Match<'r>] {\n-    debug!(\"enter_default(bcx=%s, m=%s, col=%u, val=%?)\",\n+    debug!(\"enter_default(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n+           m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n@@ -525,9 +523,9 @@ pub fn enter_opt<'r>(bcx: @mut Block,\n                      variant_size: uint,\n                      val: ValueRef)\n                   -> ~[Match<'r>] {\n-    debug!(\"enter_opt(bcx=%s, m=%s, col=%u, val=%?)\",\n+    debug!(\"enter_opt(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n+           m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n@@ -637,9 +635,9 @@ pub fn enter_rec_or_struct<'r>(bcx: @mut Block,\n                                fields: &[ast::ident],\n                                val: ValueRef)\n                             -> ~[Match<'r>] {\n-    debug!(\"enter_rec_or_struct(bcx=%s, m=%s, col=%u, val=%?)\",\n+    debug!(\"enter_rec_or_struct(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n+           m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n@@ -672,9 +670,9 @@ pub fn enter_tup<'r>(bcx: @mut Block,\n                      val: ValueRef,\n                      n_elts: uint)\n                   -> ~[Match<'r>] {\n-    debug!(\"enter_tup(bcx=%s, m=%s, col=%u, val=%?)\",\n+    debug!(\"enter_tup(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n+           m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n@@ -698,9 +696,9 @@ pub fn enter_tuple_struct<'r>(bcx: @mut Block,\n                               val: ValueRef,\n                               n_elts: uint)\n                           -> ~[Match<'r>] {\n-    debug!(\"enter_tuple_struct(bcx=%s, m=%s, col=%u, val=%?)\",\n+    debug!(\"enter_tuple_struct(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n+           m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n@@ -723,9 +721,9 @@ pub fn enter_box<'r>(bcx: @mut Block,\n                      col: uint,\n                      val: ValueRef)\n                  -> ~[Match<'r>] {\n-    debug!(\"enter_box(bcx=%s, m=%s, col=%u, val=%?)\",\n+    debug!(\"enter_box(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n+           m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n@@ -750,9 +748,9 @@ pub fn enter_uniq<'r>(bcx: @mut Block,\n                       col: uint,\n                       val: ValueRef)\n                   -> ~[Match<'r>] {\n-    debug!(\"enter_uniq(bcx=%s, m=%s, col=%u, val=%?)\",\n+    debug!(\"enter_uniq(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n+           m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n@@ -777,9 +775,9 @@ pub fn enter_region<'r>(bcx: @mut Block,\n                         col: uint,\n                         val: ValueRef)\n                     -> ~[Match<'r>] {\n-    debug!(\"enter_region(bcx=%s, m=%s, col=%u, val=%?)\",\n+    debug!(\"enter_region(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n+           m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n@@ -1213,11 +1211,11 @@ pub fn compile_guard(bcx: @mut Block,\n                      vals: &[ValueRef],\n                      chk: Option<mk_fail>)\n                   -> @mut Block {\n-    debug!(\"compile_guard(bcx=%s, guard_expr=%s, m=%s, vals=%?)\",\n+    debug!(\"compile_guard(bcx=%s, guard_expr=%s, m=%s, vals=%s)\",\n            bcx.to_str(),\n            bcx.expr_to_str(guard_expr),\n-           matches_to_str(bcx, m),\n-           vals.map(|v| bcx.val_to_str(*v)));\n+           m.repr(bcx.tcx()),\n+           vec_map_to_str(vals, |v| bcx.val_to_str(*v)));\n     let _indenter = indenter();\n \n     let mut bcx = bcx;\n@@ -1267,10 +1265,10 @@ pub fn compile_submatch(bcx: @mut Block,\n                         m: &[Match],\n                         vals: &[ValueRef],\n                         chk: Option<mk_fail>) {\n-    debug!(\"compile_submatch(bcx=%s, m=%s, vals=%?)\",\n+    debug!(\"compile_submatch(bcx=%s, m=%s, vals=%s)\",\n            bcx.to_str(),\n-           matches_to_str(bcx, m),\n-           vals.map(|v| bcx.val_to_str(*v)));\n+           m.repr(bcx.tcx()),\n+           vec_map_to_str(vals, |v| bcx.val_to_str(*v)));\n     let _indenter = indenter();\n \n     /*\n@@ -1427,6 +1425,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n \n     // Decide what kind of branch we need\n     let opts = get_options(bcx, m, col);\n+    debug!(\"options=%?\", opts);\n     let mut kind = no_branch;\n     let mut test_val = val;\n     if opts.len() > 0u {\n@@ -1914,12 +1913,12 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n \n     debug!(\"bind_irrefutable_pat(bcx=%s, pat=%s, binding_mode=%?)\",\n            bcx.to_str(),\n-           pat_to_str(pat, bcx.sess().intr()),\n+           pat.repr(bcx.tcx()),\n            binding_mode);\n \n     if bcx.sess().asm_comments() {\n         add_comment(bcx, fmt!(\"bind_irrefutable_pat(pat=%s)\",\n-                              pat_to_str(pat, bcx.sess().intr())));\n+                              pat.repr(bcx.tcx())));\n     }\n \n     let _indenter = indenter();"}, {"sha": "f396ed7f510a6b0c95092a9fc0d4fc6eb66afd67", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/53c6de56840b72a75909d5d51babb4511dee5a83/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c6de56840b72a75909d5d51babb4511dee5a83/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=53c6de56840b72a75909d5d51babb4511dee5a83", "patch": "@@ -280,9 +280,13 @@ pub fn vstore_ty_to_str(cx: ctxt, mt: &mt, vs: ty::vstore) -> ~str {\n     }\n }\n \n+pub fn vec_map_to_str<T>(ts: &[T], f: &fn(t: &T) -> ~str) -> ~str {\n+    let tstrs = ts.map(f);\n+    fmt!(\"[%s]\", tstrs.connect(\", \"))\n+}\n+\n pub fn tys_to_str(cx: ctxt, ts: &[t]) -> ~str {\n-    let tstrs = ts.map(|t| ty_to_str(cx, *t));\n-    fmt!(\"(%s)\", tstrs.connect(\", \"))\n+    vec_map_to_str(ts, |t| ty_to_str(cx, *t))\n }\n \n pub fn fn_sig_to_str(cx: ctxt, typ: &ty::FnSig) -> ~str {\n@@ -529,7 +533,7 @@ impl<T:Repr> Repr for ~T {\n }\n \n fn repr_vec<T:Repr>(tcx: ctxt, v: &[T]) -> ~str {\n-    fmt!(\"[%s]\", v.map(|t| t.repr(tcx)).connect(\",\"))\n+    vec_map_to_str(v, |t| t.repr(tcx))\n }\n \n impl<'self, T:Repr> Repr for &'self [T] {"}]}