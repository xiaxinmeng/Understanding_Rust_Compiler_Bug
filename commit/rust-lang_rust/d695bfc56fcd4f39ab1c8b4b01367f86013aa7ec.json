{"sha": "d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2OTViZmM1NmZjZDRmMzlhYjFjOGI0YjAxMzY3Zjg2MDEzYWE3ZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-17T09:49:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-17T09:49:20Z"}, "message": "Auto merge of #6821 - Jarcho:write_literal_suggestion, r=flip1995\n\nWrite literal suggestion\n\nfixes: #6768\n\nchangelog: Add suggestion to `write_literal` and `print_literal` lints\nchangelog: Change `use_debug` to point only at the format string", "tree": {"sha": "ba1d4e1f3f124d0f6d52b5d202432ad04f718a00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba1d4e1f3f124d0f6d52b5d202432ad04f718a00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec", "html_url": "https://github.com/rust-lang/rust/commit/d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2ee8490f88a53dd7b24eb1cecc71adb366c5a1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2ee8490f88a53dd7b24eb1cecc71adb366c5a1c", "html_url": "https://github.com/rust-lang/rust/commit/a2ee8490f88a53dd7b24eb1cecc71adb366c5a1c"}, {"sha": "d45873b4c151898876da73746300ac29d5448e62", "url": "https://api.github.com/repos/rust-lang/rust/commits/d45873b4c151898876da73746300ac29d5448e62", "html_url": "https://github.com/rust-lang/rust/commit/d45873b4c151898876da73746300ac29d5448e62"}], "stats": {"total": 569, "additions": 454, "deletions": 115}, "files": [{"sha": "12a47a6b7036d9a3e1e707b05066f7200f360979", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 191, "deletions": 93, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec", "patch": "@@ -1,19 +1,19 @@\n use std::borrow::Cow;\n-use std::ops::Range;\n+use std::iter;\n+use std::ops::{Deref, Range};\n \n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::source::snippet_with_applicability;\n-use if_chain::if_chain;\n-use rustc_ast::ast::{Expr, ExprKind, ImplKind, Item, ItemKind, LitKind, MacCall, StrLit, StrStyle};\n-use rustc_ast::token;\n+use clippy_utils::source::{snippet_opt, snippet_with_applicability};\n+use rustc_ast::ast::{Expr, ExprKind, ImplKind, Item, ItemKind, MacCall, Path, StrLit, StrStyle};\n+use rustc_ast::token::{self, LitKind};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_errors::Applicability;\n use rustc_lexer::unescape::{self, EscapeError};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_parse::parser;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::kw;\n-use rustc_span::{sym, BytePos, Span};\n+use rustc_span::symbol::{kw, Symbol};\n+use rustc_span::{sym, BytePos, Span, DUMMY_SP};\n \n declare_clippy_lint! {\n     /// **What it does:** This lint warns when you use `println!(\"\")` to\n@@ -354,7 +354,120 @@ fn newline_span(fmtstr: &StrLit) -> Span {\n     sp.with_lo(newline_sp_hi - newline_sp_len).with_hi(newline_sp_hi)\n }\n \n+/// Stores a list of replacement spans for each argument, but only if all the replacements used an\n+/// empty format string.\n+#[derive(Default)]\n+struct SimpleFormatArgs {\n+    unnamed: Vec<Vec<Span>>,\n+    named: Vec<(Symbol, Vec<Span>)>,\n+}\n+impl SimpleFormatArgs {\n+    fn get_unnamed(&self) -> impl Iterator<Item = &[Span]> {\n+        self.unnamed.iter().map(|x| match x.as_slice() {\n+            // Ignore the dummy span added from out of order format arguments.\n+            [DUMMY_SP] => &[],\n+            x => x,\n+        })\n+    }\n+\n+    fn get_named(&self, n: &Path) -> &[Span] {\n+        self.named.iter().find(|x| *n == x.0).map_or(&[], |x| x.1.as_slice())\n+    }\n+\n+    fn push(&mut self, arg: rustc_parse_format::Argument<'_>, span: Span) {\n+        use rustc_parse_format::{\n+            AlignUnknown, ArgumentImplicitlyIs, ArgumentIs, ArgumentNamed, CountImplied, FormatSpec,\n+        };\n+\n+        const SIMPLE: FormatSpec<'_> = FormatSpec {\n+            fill: None,\n+            align: AlignUnknown,\n+            flags: 0,\n+            precision: CountImplied,\n+            precision_span: None,\n+            width: CountImplied,\n+            width_span: None,\n+            ty: \"\",\n+            ty_span: None,\n+        };\n+\n+        match arg.position {\n+            ArgumentIs(n) | ArgumentImplicitlyIs(n) => {\n+                if self.unnamed.len() <= n {\n+                    // Use a dummy span to mark all unseen arguments.\n+                    self.unnamed.resize_with(n, || vec![DUMMY_SP]);\n+                    if arg.format == SIMPLE {\n+                        self.unnamed.push(vec![span]);\n+                    } else {\n+                        self.unnamed.push(Vec::new());\n+                    }\n+                } else {\n+                    let args = &mut self.unnamed[n];\n+                    match (args.as_mut_slice(), arg.format == SIMPLE) {\n+                        // A non-empty format string has been seen already.\n+                        ([], _) => (),\n+                        // Replace the dummy span, if it exists.\n+                        ([dummy @ DUMMY_SP], true) => *dummy = span,\n+                        ([_, ..], true) => args.push(span),\n+                        ([_, ..], false) => *args = Vec::new(),\n+                    }\n+                }\n+            },\n+            ArgumentNamed(n) => {\n+                if let Some(x) = self.named.iter_mut().find(|x| x.0 == n) {\n+                    match x.1.as_slice() {\n+                        // A non-empty format string has been seen already.\n+                        [] => (),\n+                        [_, ..] if arg.format == SIMPLE => x.1.push(span),\n+                        [_, ..] => x.1 = Vec::new(),\n+                    }\n+                } else if arg.format == SIMPLE {\n+                    self.named.push((n, vec![span]));\n+                } else {\n+                    self.named.push((n, Vec::new()));\n+                }\n+            },\n+        };\n+    }\n+}\n+\n impl Write {\n+    /// Parses a format string into a collection of spans for each argument. This only keeps track\n+    /// of empty format arguments. Will also lint usages of debug format strings outside of debug\n+    /// impls.\n+    fn parse_fmt_string(&self, cx: &EarlyContext<'_>, str_lit: &StrLit) -> Option<SimpleFormatArgs> {\n+        use rustc_parse_format::{ParseMode, Parser, Piece};\n+\n+        let str_sym = str_lit.symbol_unescaped.as_str();\n+        let style = match str_lit.style {\n+            StrStyle::Cooked => None,\n+            StrStyle::Raw(n) => Some(n as usize),\n+        };\n+\n+        let mut parser = Parser::new(&str_sym, style, snippet_opt(cx, str_lit.span), false, ParseMode::Format);\n+        let mut args = SimpleFormatArgs::default();\n+\n+        while let Some(arg) = parser.next() {\n+            let arg = match arg {\n+                Piece::String(_) => continue,\n+                Piece::NextArgument(arg) => arg,\n+            };\n+            let span = parser\n+                .arg_places\n+                .last()\n+                .map_or(DUMMY_SP, |&x| str_lit.span.from_inner(x));\n+\n+            if !self.in_debug_impl && arg.format.ty == \"?\" {\n+                // FIXME: modify rustc's fmt string parser to give us the current span\n+                span_lint(cx, USE_DEBUG, span, \"use of `Debug`-based formatting\");\n+            }\n+\n+            args.push(arg, span);\n+        }\n+\n+        parser.errors.is_empty().then(move || args)\n+    }\n+\n     /// Checks the arguments of `print[ln]!` and `write[ln]!` calls. It will return a tuple of two\n     /// `Option`s. The first `Option` of the tuple is the macro's format string. It includes\n     /// the contents of the string, whether it's a raw string, and the span of the literal in the\n@@ -376,111 +489,96 @@ impl Write {\n     /// ```\n     #[allow(clippy::too_many_lines)]\n     fn check_tts<'a>(&self, cx: &EarlyContext<'a>, tts: TokenStream, is_write: bool) -> (Option<StrLit>, Option<Expr>) {\n-        use rustc_parse_format::{\n-            AlignUnknown, ArgumentImplicitlyIs, ArgumentIs, ArgumentNamed, CountImplied, FormatSpec, ParseMode, Parser,\n-            Piece,\n-        };\n-\n         let mut parser = parser::Parser::new(&cx.sess.parse_sess, tts, false, None);\n-        let mut expr: Option<Expr> = None;\n-        if is_write {\n-            expr = match parser.parse_expr().map_err(|mut err| err.cancel()) {\n-                Ok(p) => Some(p.into_inner()),\n-                Err(_) => return (None, None),\n-            };\n-            // might be `writeln!(foo)`\n-            if parser.expect(&token::Comma).map_err(|mut err| err.cancel()).is_err() {\n-                return (None, expr);\n+        let expr = if is_write {\n+            match parser\n+                .parse_expr()\n+                .map(rustc_ast::ptr::P::into_inner)\n+                .map_err(|mut e| e.cancel())\n+            {\n+                // write!(e, ...)\n+                Ok(p) if parser.eat(&token::Comma) => Some(p),\n+                // write!(e) or error\n+                e => return (None, e.ok()),\n             }\n-        }\n+        } else {\n+            None\n+        };\n \n         let fmtstr = match parser.parse_str_lit() {\n             Ok(fmtstr) => fmtstr,\n             Err(_) => return (None, expr),\n         };\n-        let tmp = fmtstr.symbol.as_str();\n-        let mut args = vec![];\n-        let mut fmt_parser = Parser::new(&tmp, None, None, false, ParseMode::Format);\n-        while let Some(piece) = fmt_parser.next() {\n-            if !fmt_parser.errors.is_empty() {\n-                return (None, expr);\n-            }\n-            if let Piece::NextArgument(arg) = piece {\n-                if !self.in_debug_impl && arg.format.ty == \"?\" {\n-                    // FIXME: modify rustc's fmt string parser to give us the current span\n-                    span_lint(cx, USE_DEBUG, parser.prev_token.span, \"use of `Debug`-based formatting\");\n-                }\n-                args.push(arg);\n-            }\n-        }\n+\n+        let args = match self.parse_fmt_string(cx, &fmtstr) {\n+            Some(args) => args,\n+            None => return (Some(fmtstr), expr),\n+        };\n+\n         let lint = if is_write { WRITE_LITERAL } else { PRINT_LITERAL };\n-        let mut idx = 0;\n+        let mut unnamed_args = args.get_unnamed();\n         loop {\n-            const SIMPLE: FormatSpec<'_> = FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountImplied,\n-                precision_span: None,\n-                width: CountImplied,\n-                width_span: None,\n-                ty: \"\",\n-                ty_span: None,\n-            };\n             if !parser.eat(&token::Comma) {\n                 return (Some(fmtstr), expr);\n             }\n+\n+            let comma_span = parser.prev_token.span;\n             let token_expr = if let Ok(expr) = parser.parse_expr().map_err(|mut err| err.cancel()) {\n                 expr\n             } else {\n                 return (Some(fmtstr), None);\n             };\n-            match &token_expr.kind {\n-                ExprKind::Lit(lit) if !matches!(lit.kind, LitKind::Int(..) | LitKind::Float(..)) => {\n-                    let mut all_simple = true;\n-                    let mut seen = false;\n-                    for arg in &args {\n-                        match arg.position {\n-                            ArgumentImplicitlyIs(n) | ArgumentIs(n) => {\n-                                if n == idx {\n-                                    all_simple &= arg.format == SIMPLE;\n-                                    seen = true;\n-                                }\n-                            },\n-                            ArgumentNamed(_) => {},\n-                        }\n-                    }\n-                    if all_simple && seen {\n-                        span_lint(cx, lint, token_expr.span, \"literal with an empty format string\");\n-                    }\n-                    idx += 1;\n+            let (fmt_spans, lit) = match &token_expr.kind {\n+                ExprKind::Lit(lit) => (unnamed_args.next().unwrap_or(&[]), lit),\n+                ExprKind::Assign(lhs, rhs, _) => match (&lhs.kind, &rhs.kind) {\n+                    (ExprKind::Path(_, p), ExprKind::Lit(lit)) => (args.get_named(p), lit),\n+                    _ => continue,\n                 },\n-                ExprKind::Assign(lhs, rhs, _) => {\n-                    if_chain! {\n-                        if let ExprKind::Lit(ref lit) = rhs.kind;\n-                        if !matches!(lit.kind, LitKind::Int(..) | LitKind::Float(..));\n-                        if let ExprKind::Path(_, p) = &lhs.kind;\n-                        then {\n-                            let mut all_simple = true;\n-                            let mut seen = false;\n-                            for arg in &args {\n-                                match arg.position {\n-                                    ArgumentImplicitlyIs(_) | ArgumentIs(_) => {},\n-                                    ArgumentNamed(name) => {\n-                                        if *p == name {\n-                                            seen = true;\n-                                            all_simple &= arg.format == SIMPLE;\n-                                        }\n-                                    },\n-                                }\n-                            }\n-                            if all_simple && seen {\n-                                span_lint(cx, lint, rhs.span, \"literal with an empty format string\");\n-                            }\n-                        }\n-                    }\n+                _ => {\n+                    unnamed_args.next();\n+                    continue;\n+                },\n+            };\n+\n+            let replacement: String = match lit.token.kind {\n+                LitKind::Integer | LitKind::Float | LitKind::Err => continue,\n+                LitKind::StrRaw(_) | LitKind::ByteStrRaw(_) if matches!(fmtstr.style, StrStyle::Raw(_)) => {\n+                    lit.token.symbol.as_str().replace(\"{\", \"{{\").replace(\"}\", \"}}\")\n                 },\n-                _ => idx += 1,\n+                LitKind::Str | LitKind::ByteStr if matches!(fmtstr.style, StrStyle::Cooked) => {\n+                    lit.token.symbol.as_str().replace(\"{\", \"{{\").replace(\"}\", \"}}\")\n+                },\n+                LitKind::StrRaw(_) | LitKind::Str | LitKind::ByteStrRaw(_) | LitKind::ByteStr => continue,\n+                LitKind::Byte | LitKind::Char => match &*lit.token.symbol.as_str() {\n+                    \"\\\"\" if matches!(fmtstr.style, StrStyle::Cooked) => \"\\\\\\\"\",\n+                    \"\\\"\" if matches!(fmtstr.style, StrStyle::Raw(0)) => continue,\n+                    \"\\\\\\\\\" if matches!(fmtstr.style, StrStyle::Raw(_)) => \"\\\\\",\n+                    \"\\\\'\" => \"'\",\n+                    \"{\" => \"{{\",\n+                    \"}\" => \"}}\",\n+                    x if matches!(fmtstr.style, StrStyle::Raw(_)) && x.starts_with('\\\\') => continue,\n+                    x => x,\n+                }\n+                .into(),\n+                LitKind::Bool => lit.token.symbol.as_str().deref().into(),\n+            };\n+\n+            if !fmt_spans.is_empty() {\n+                span_lint_and_then(\n+                    cx,\n+                    lint,\n+                    token_expr.span,\n+                    \"literal with an empty format string\",\n+                    |diag| {\n+                        diag.multipart_suggestion(\n+                            \"try this\",\n+                            iter::once((comma_span.to(token_expr.span), String::new()))\n+                                .chain(fmt_spans.iter().cloned().zip(iter::repeat(replacement)))\n+                                .collect(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    },\n+                );\n             }\n         }\n     }"}, {"sha": "1754c418381a13c4b25efaae6a02fa2532e1a7da", "filename": "tests/ui/print.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec/tests%2Fui%2Fprint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec/tests%2Fui%2Fprint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint.stderr?ref=d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec", "patch": "@@ -1,8 +1,8 @@\n error: use of `Debug`-based formatting\n-  --> $DIR/print.rs:11:19\n+  --> $DIR/print.rs:11:20\n    |\n LL |         write!(f, \"{:?}\", 43.1415)\n-   |                   ^^^^^^\n+   |                    ^^^^\n    |\n    = note: `-D clippy::use-debug` implied by `-D warnings`\n \n@@ -33,10 +33,10 @@ LL |     print!(\"Hello {:?}\", \"World\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of `Debug`-based formatting\n-  --> $DIR/print.rs:28:12\n+  --> $DIR/print.rs:28:19\n    |\n LL |     print!(\"Hello {:?}\", \"World\");\n-   |            ^^^^^^^^^^^^\n+   |                   ^^^^\n \n error: use of `print!`\n   --> $DIR/print.rs:30:5\n@@ -45,10 +45,10 @@ LL |     print!(\"Hello {:#?}\", \"#orld\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of `Debug`-based formatting\n-  --> $DIR/print.rs:30:12\n+  --> $DIR/print.rs:30:19\n    |\n LL |     print!(\"Hello {:#?}\", \"#orld\");\n-   |            ^^^^^^^^^^^^^\n+   |                   ^^^^^\n \n error: aborting due to 8 previous errors\n "}, {"sha": "54a4084c89e116f1e532c9ac76c8e5bd63d11f47", "filename": "tests/ui/print_literal.stderr", "status": "modified", "additions": 62, "deletions": 8, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec/tests%2Fui%2Fprint_literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec/tests%2Fui%2Fprint_literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_literal.stderr?ref=d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec", "patch": "@@ -5,66 +5,120 @@ LL |     print!(\"Hello {}\", \"world\");\n    |                        ^^^^^^^\n    |\n    = note: `-D clippy::print-literal` implied by `-D warnings`\n+help: try this\n+   |\n+LL |     print!(\"Hello world\");\n+   |                   ^^^^^--\n \n error: literal with an empty format string\n   --> $DIR/print_literal.rs:26:36\n    |\n LL |     println!(\"Hello {} {}\", world, \"world\");\n    |                                    ^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     println!(\"Hello {} world\", world);\n+   |                        ^^^^^       --\n \n error: literal with an empty format string\n   --> $DIR/print_literal.rs:27:26\n    |\n LL |     println!(\"Hello {}\", \"world\");\n    |                          ^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     println!(\"Hello world\");\n+   |                     ^^^^^--\n \n error: literal with an empty format string\n   --> $DIR/print_literal.rs:32:25\n    |\n LL |     println!(\"{0} {1}\", \"hello\", \"world\");\n    |                         ^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     println!(\"hello {1}\", \"world\");\n+   |               ^^^^^    --\n \n error: literal with an empty format string\n   --> $DIR/print_literal.rs:32:34\n    |\n LL |     println!(\"{0} {1}\", \"hello\", \"world\");\n    |                                  ^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     println!(\"{0} world\", \"hello\");\n+   |                   ^^^^^         --\n \n error: literal with an empty format string\n   --> $DIR/print_literal.rs:33:25\n    |\n LL |     println!(\"{1} {0}\", \"hello\", \"world\");\n    |                         ^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     println!(\"{1} hello\", \"world\");\n+   |                   ^^^^^--\n \n error: literal with an empty format string\n   --> $DIR/print_literal.rs:33:34\n    |\n LL |     println!(\"{1} {0}\", \"hello\", \"world\");\n    |                                  ^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     println!(\"world {0}\", \"hello\");\n+   |               ^^^^^             --\n \n error: literal with an empty format string\n-  --> $DIR/print_literal.rs:36:35\n+  --> $DIR/print_literal.rs:36:29\n    |\n LL |     println!(\"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n-   |                                   ^^^^^^^\n+   |                             ^^^^^^^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     println!(\"hello {bar}\", bar = \"world\");\n+   |               ^^^^^      --\n \n error: literal with an empty format string\n-  --> $DIR/print_literal.rs:36:50\n+  --> $DIR/print_literal.rs:36:44\n    |\n LL |     println!(\"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n-   |                                                  ^^^^^^^\n+   |                                            ^^^^^^^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     println!(\"{foo} world\", foo = \"hello\");\n+   |                     ^^^^^               --\n \n error: literal with an empty format string\n-  --> $DIR/print_literal.rs:37:35\n+  --> $DIR/print_literal.rs:37:29\n    |\n LL |     println!(\"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n-   |                                   ^^^^^^^\n+   |                             ^^^^^^^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     println!(\"{bar} hello\", bar = \"world\");\n+   |                     ^^^^^--\n \n error: literal with an empty format string\n-  --> $DIR/print_literal.rs:37:50\n+  --> $DIR/print_literal.rs:37:44\n    |\n LL |     println!(\"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n-   |                                                  ^^^^^^^\n+   |                                            ^^^^^^^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     println!(\"world {foo}\", foo = \"hello\");\n+   |               ^^^^^                     --\n \n error: aborting due to 11 previous errors\n "}, {"sha": "507a78e82805030cf9ae9b34be7b0228c57b3f27", "filename": "tests/ui/write_literal.stderr", "status": "modified", "additions": 62, "deletions": 8, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec/tests%2Fui%2Fwrite_literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec/tests%2Fui%2Fwrite_literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_literal.stderr?ref=d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec", "patch": "@@ -5,66 +5,120 @@ LL |     write!(&mut v, \"Hello {}\", \"world\");\n    |                                ^^^^^^^\n    |\n    = note: `-D clippy::write-literal` implied by `-D warnings`\n+help: try this\n+   |\n+LL |     write!(&mut v, \"Hello world\");\n+   |                           ^^^^^--\n \n error: literal with an empty format string\n   --> $DIR/write_literal.rs:31:44\n    |\n LL |     writeln!(&mut v, \"Hello {} {}\", world, \"world\");\n    |                                            ^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     writeln!(&mut v, \"Hello {} world\", world);\n+   |                                ^^^^^       --\n \n error: literal with an empty format string\n   --> $DIR/write_literal.rs:32:34\n    |\n LL |     writeln!(&mut v, \"Hello {}\", \"world\");\n    |                                  ^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     writeln!(&mut v, \"Hello world\");\n+   |                             ^^^^^--\n \n error: literal with an empty format string\n   --> $DIR/write_literal.rs:37:33\n    |\n LL |     writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n    |                                 ^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     writeln!(&mut v, \"hello {1}\", \"world\");\n+   |                       ^^^^^    --\n \n error: literal with an empty format string\n   --> $DIR/write_literal.rs:37:42\n    |\n LL |     writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n    |                                          ^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     writeln!(&mut v, \"{0} world\", \"hello\");\n+   |                           ^^^^^         --\n \n error: literal with an empty format string\n   --> $DIR/write_literal.rs:38:33\n    |\n LL |     writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n    |                                 ^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     writeln!(&mut v, \"{1} hello\", \"world\");\n+   |                           ^^^^^--\n \n error: literal with an empty format string\n   --> $DIR/write_literal.rs:38:42\n    |\n LL |     writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n    |                                          ^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     writeln!(&mut v, \"world {0}\", \"hello\");\n+   |                       ^^^^^             --\n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:41:43\n+  --> $DIR/write_literal.rs:41:37\n    |\n LL |     writeln!(&mut v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n-   |                                           ^^^^^^^\n+   |                                     ^^^^^^^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     writeln!(&mut v, \"hello {bar}\", bar = \"world\");\n+   |                       ^^^^^      --\n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:41:58\n+  --> $DIR/write_literal.rs:41:52\n    |\n LL |     writeln!(&mut v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n-   |                                                          ^^^^^^^\n+   |                                                    ^^^^^^^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     writeln!(&mut v, \"{foo} world\", foo = \"hello\");\n+   |                             ^^^^^               --\n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:42:43\n+  --> $DIR/write_literal.rs:42:37\n    |\n LL |     writeln!(&mut v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n-   |                                           ^^^^^^^\n+   |                                     ^^^^^^^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     writeln!(&mut v, \"{bar} hello\", bar = \"world\");\n+   |                             ^^^^^--\n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:42:58\n+  --> $DIR/write_literal.rs:42:52\n    |\n LL |     writeln!(&mut v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n-   |                                                          ^^^^^^^\n+   |                                                    ^^^^^^^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     writeln!(&mut v, \"world {foo}\", foo = \"hello\");\n+   |                       ^^^^^                     --\n \n error: aborting due to 11 previous errors\n "}, {"sha": "f341e8215e1caff9491c8963b2275b63cf4d9a1b", "filename": "tests/ui/write_literal_2.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec/tests%2Fui%2Fwrite_literal_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec/tests%2Fui%2Fwrite_literal_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_literal_2.rs?ref=d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec", "patch": "@@ -0,0 +1,27 @@\n+#![allow(unused_must_use)]\n+#![warn(clippy::write_literal)]\n+\n+use std::io::Write;\n+\n+fn main() {\n+    let mut v = Vec::new();\n+\n+    writeln!(&mut v, \"{}\", \"{hello}\");\n+    writeln!(&mut v, r\"{}\", r\"{hello}\");\n+    writeln!(&mut v, \"{}\", '\\'');\n+    writeln!(&mut v, \"{}\", '\"');\n+    writeln!(&mut v, r\"{}\", '\"'); // don't lint\n+    writeln!(&mut v, r\"{}\", '\\'');\n+    writeln!(\n+        &mut v,\n+        \"some {}\",\n+        \"hello \\\n+        world!\"\n+    );\n+    writeln!(\n+        &mut v,\n+        \"some {}\\\n+        {} \\\\ {}\",\n+        \"1\", \"2\", \"3\",\n+    );\n+}"}, {"sha": "5b4883580111b1d1cb76cdc253ec6fcd19ef7406", "filename": "tests/ui/write_literal_2.stderr", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec/tests%2Fui%2Fwrite_literal_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec/tests%2Fui%2Fwrite_literal_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_literal_2.stderr?ref=d695bfc56fcd4f39ab1c8b4b01367f86013aa7ec", "patch": "@@ -0,0 +1,106 @@\n+error: literal with an empty format string\n+  --> $DIR/write_literal_2.rs:9:28\n+   |\n+LL |     writeln!(&mut v, \"{}\", \"{hello}\");\n+   |                            ^^^^^^^^^\n+   |\n+   = note: `-D clippy::write-literal` implied by `-D warnings`\n+help: try this\n+   |\n+LL |     writeln!(&mut v, \"{{hello}}\");\n+   |                       ^^^^^^^^^--\n+\n+error: literal with an empty format string\n+  --> $DIR/write_literal_2.rs:10:29\n+   |\n+LL |     writeln!(&mut v, r\"{}\", r\"{hello}\");\n+   |                             ^^^^^^^^^^\n+   |\n+help: try this\n+   |\n+LL |     writeln!(&mut v, r\"{{hello}}\");\n+   |                        ^^^^^^^^^--\n+\n+error: literal with an empty format string\n+  --> $DIR/write_literal_2.rs:11:28\n+   |\n+LL |     writeln!(&mut v, \"{}\", '/'');\n+   |                            ^^^^\n+   |\n+help: try this\n+   |\n+LL |     writeln!(&mut v, \"'\");\n+   |                       ^--\n+\n+error: literal with an empty format string\n+  --> $DIR/write_literal_2.rs:12:28\n+   |\n+LL |     writeln!(&mut v, \"{}\", '\"');\n+   |                            ^^^\n+   |\n+help: try this\n+   |\n+LL |     writeln!(&mut v, \"/\"\");\n+   |                       ^^--\n+\n+error: literal with an empty format string\n+  --> $DIR/write_literal_2.rs:14:29\n+   |\n+LL |     writeln!(&mut v, r\"{}\", '/'');\n+   |                             ^^^^\n+   |\n+help: try this\n+   |\n+LL |     writeln!(&mut v, r\"'\");\n+   |                        ^--\n+\n+error: literal with an empty format string\n+  --> $DIR/write_literal_2.rs:18:9\n+   |\n+LL | /         \"hello /\n+LL | |         world!\"\n+   | |_______________^\n+   |\n+help: try this\n+   |\n+LL |         \"some hello /\n+LL |         world!\"\n+   |\n+\n+error: literal with an empty format string\n+  --> $DIR/write_literal_2.rs:25:9\n+   |\n+LL |         \"1\", \"2\", \"3\",\n+   |         ^^^\n+   |\n+help: try this\n+   |\n+LL |         \"some 1{} / {}\", \"2\", \"3\",\n+   |               ^        --\n+\n+error: literal with an empty format string\n+  --> $DIR/write_literal_2.rs:25:14\n+   |\n+LL |         \"1\", \"2\", \"3\",\n+   |              ^^^\n+   |\n+help: try this\n+   |\n+LL |         2 / {}\",\n+LL |         \"1\", \"3\",\n+   |\n+\n+error: literal with an empty format string\n+  --> $DIR/write_literal_2.rs:25:19\n+   |\n+LL |         \"1\", \"2\", \"3\",\n+   |                   ^^^\n+   |\n+help: try this\n+   |\n+LL |         {} / 3\",\n+LL |         \"1\", \"2\",\n+   |\n+\n+error: aborting due to 9 previous errors\n+"}]}