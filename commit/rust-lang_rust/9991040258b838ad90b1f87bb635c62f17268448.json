{"sha": "9991040258b838ad90b1f87bb635c62f17268448", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5OTEwNDAyNThiODM4YWQ5MGIxZjg3YmI2MzVjNjJmMTcyNjg0NDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-04T15:39:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-04T15:39:16Z"}, "message": "Auto merge of #7289 - camsteffen:needless-collect-shadow, r=Manishearth\n\nFix needless_collect with binding shadowing\n\nchangelog: Fix [`needless_collect`] weird output when a binding is shadowed\n\nFixes #7200", "tree": {"sha": "e0defcd3143985c56e346433cfbad2ad2663e3d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0defcd3143985c56e346433cfbad2ad2663e3d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9991040258b838ad90b1f87bb635c62f17268448", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9991040258b838ad90b1f87bb635c62f17268448", "html_url": "https://github.com/rust-lang/rust/commit/9991040258b838ad90b1f87bb635c62f17268448", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9991040258b838ad90b1f87bb635c62f17268448/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1752f616f532c068a19e8b690c31b5411be89cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1752f616f532c068a19e8b690c31b5411be89cd", "html_url": "https://github.com/rust-lang/rust/commit/b1752f616f532c068a19e8b690c31b5411be89cd"}, {"sha": "21c829e0c81697bbace7c325b47856d32fad33df", "url": "https://api.github.com/repos/rust-lang/rust/commits/21c829e0c81697bbace7c325b47856d32fad33df", "html_url": "https://github.com/rust-lang/rust/commit/21c829e0c81697bbace7c325b47856d32fad33df"}], "stats": {"total": 97, "additions": 36, "deletions": 61}, "files": [{"sha": "51d7def137e409eea10816378e774726fb29e026", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 36, "deletions": 61, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/9991040258b838ad90b1f87bb635c62f17268448/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9991040258b838ad90b1f87bb635c62f17268448/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=9991040258b838ad90b1f87bb635c62f17268448", "patch": "@@ -7,10 +7,10 @@ use clippy_utils::{is_trait_method, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Block, Expr, ExprKind, GenericArg, GenericArgs, HirId, Local, Pat, PatKind, QPath, StmtKind, Ty};\n+use rustc_hir::{Block, Expr, ExprKind, HirId, PatKind, StmtKind};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n-use rustc_span::symbol::{sym, Ident};\n+use rustc_span::sym;\n use rustc_span::{MultiSpan, Span};\n \n const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n@@ -24,10 +24,8 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n         if let ExprKind::MethodCall(method, _, args, _) = expr.kind;\n         if let ExprKind::MethodCall(chain_method, method0_span, _, _) = args[0].kind;\n         if chain_method.ident.name == sym!(collect) && is_trait_method(cx, &args[0], sym::Iterator);\n-        if let Some(generic_args) = chain_method.args;\n-        if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n-        if let Some(ty) = cx.typeck_results().node_type_opt(ty.hir_id);\n         then {\n+            let ty = cx.typeck_results().expr_ty(&args[0]);\n             let mut applicability = Applicability::MachineApplicable;\n             let is_empty_sugg = \"next().is_none()\".to_string();\n             let method_name = &*method.ident.name.as_str();\n@@ -72,40 +70,25 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n }\n \n fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n-    fn get_hir_id<'tcx>(ty: Option<&Ty<'tcx>>, method_args: Option<&GenericArgs<'tcx>>) -> Option<HirId> {\n-        if let Some(ty) = ty {\n-            return Some(ty.hir_id);\n-        }\n-\n-        if let Some(generic_args) = method_args {\n-            if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0) {\n-                return Some(ty.hir_id);\n-            }\n-        }\n-\n-        None\n-    }\n     if let ExprKind::Block(block, _) = expr.kind {\n         for stmt in block.stmts {\n             if_chain! {\n-                if let StmtKind::Local(\n-                    Local { pat: Pat { hir_id: pat_id, kind: PatKind::Binding(_, _, ident, .. ), .. },\n-                    init: Some(init_expr), ty, .. }\n-                ) = stmt.kind;\n+                if let StmtKind::Local(local) = stmt.kind;\n+                if let PatKind::Binding(_, id, ..) = local.pat.kind;\n+                if let Some(init_expr) = local.init;\n                 if let ExprKind::MethodCall(method_name, collect_span, &[ref iter_source], ..) = init_expr.kind;\n                 if method_name.ident.name == sym!(collect) && is_trait_method(cx, init_expr, sym::Iterator);\n-                if let Some(hir_id) = get_hir_id(*ty, method_name.args);\n-                if let Some(ty) = cx.typeck_results().node_type_opt(hir_id);\n+                let ty = cx.typeck_results().expr_ty(init_expr);\n                 if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n                     is_type_diagnostic_item(cx, ty, sym::vecdeque_type) ||\n                     is_type_diagnostic_item(cx, ty, sym::BinaryHeap) ||\n                     is_type_diagnostic_item(cx, ty, sym::LinkedList);\n-                if let Some(iter_calls) = detect_iter_and_into_iters(block, *ident);\n+                if let Some(iter_calls) = detect_iter_and_into_iters(block, id);\n                 if let [iter_call] = &*iter_calls;\n                 then {\n                     let mut used_count_visitor = UsedCountVisitor {\n                         cx,\n-                        id: *pat_id,\n+                        id,\n                         count: 0,\n                     };\n                     walk_block(&mut used_count_visitor, block);\n@@ -187,48 +170,40 @@ enum IterFunctionKind {\n struct IterFunctionVisitor {\n     uses: Vec<IterFunction>,\n     seen_other: bool,\n-    target: Ident,\n+    target: HirId,\n }\n impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         // Check function calls on our collection\n-        if_chain! {\n-            if let ExprKind::MethodCall(method_name, _, args, _) = &expr.kind;\n-            if let Some(Expr { kind: ExprKind::Path(QPath::Resolved(_, path)), .. }) = args.get(0);\n-            if let &[name] = &path.segments;\n-            if name.ident == self.target;\n-            then {\n-                let len = sym!(len);\n-                let is_empty = sym!(is_empty);\n-                let contains = sym!(contains);\n-                match method_name.ident.name {\n-                    sym::into_iter => self.uses.push(\n-                        IterFunction { func: IterFunctionKind::IntoIter, span: expr.span }\n-                    ),\n-                    name if name == len => self.uses.push(\n-                        IterFunction { func: IterFunctionKind::Len, span: expr.span }\n-                    ),\n-                    name if name == is_empty => self.uses.push(\n-                        IterFunction { func: IterFunctionKind::IsEmpty, span: expr.span }\n-                    ),\n-                    name if name == contains => self.uses.push(\n-                        IterFunction { func: IterFunctionKind::Contains(args[1].span), span: expr.span }\n-                    ),\n+        if let ExprKind::MethodCall(method_name, _, [recv, args @ ..], _) = &expr.kind {\n+            if path_to_local_id(recv, self.target) {\n+                match &*method_name.ident.name.as_str() {\n+                    \"into_iter\" => self.uses.push(IterFunction {\n+                        func: IterFunctionKind::IntoIter,\n+                        span: expr.span,\n+                    }),\n+                    \"len\" => self.uses.push(IterFunction {\n+                        func: IterFunctionKind::Len,\n+                        span: expr.span,\n+                    }),\n+                    \"is_empty\" => self.uses.push(IterFunction {\n+                        func: IterFunctionKind::IsEmpty,\n+                        span: expr.span,\n+                    }),\n+                    \"contains\" => self.uses.push(IterFunction {\n+                        func: IterFunctionKind::Contains(args[0].span),\n+                        span: expr.span,\n+                    }),\n                     _ => self.seen_other = true,\n                 }\n-                return\n+                return;\n             }\n         }\n         // Check if the collection is used for anything else\n-        if_chain! {\n-            if let Expr { kind: ExprKind::Path(QPath::Resolved(_, path)), .. } = expr;\n-            if let &[name] = &path.segments;\n-            if name.ident == self.target;\n-            then {\n-                self.seen_other = true;\n-            } else {\n-                walk_expr(self, expr);\n-            }\n+        if path_to_local_id(expr, self.target) {\n+            self.seen_other = true;\n+        } else {\n+            walk_expr(self, expr);\n         }\n     }\n \n@@ -262,10 +237,10 @@ impl<'a, 'tcx> Visitor<'tcx> for UsedCountVisitor<'a, 'tcx> {\n \n /// Detect the occurrences of calls to `iter` or `into_iter` for the\n /// given identifier\n-fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, identifier: Ident) -> Option<Vec<IterFunction>> {\n+fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, id: HirId) -> Option<Vec<IterFunction>> {\n     let mut visitor = IterFunctionVisitor {\n         uses: Vec::new(),\n-        target: identifier,\n+        target: id,\n         seen_other: false,\n     };\n     visitor.visit_block(block);"}]}