{"sha": "f8440d6c998b6f30fa04d6ed6f1e4f19242283af", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4NDQwZDZjOTk4YjZmMzBmYTA0ZDZlZDZmMWU0ZjE5MjQyMjgzYWY=", "commit": {"author": {"name": "Henry Boisdequin", "email": "65845077+henryboisdequin@users.noreply.github.com", "date": "2021-03-02T12:40:27Z"}, "committer": {"name": "Henry Boisdequin", "email": "65845077+henryboisdequin@users.noreply.github.com", "date": "2021-03-02T14:47:05Z"}, "message": "Add in `atomic_{min,max}_x` intrinsics\n\nCo-authored-by: Greg Bowyer <gbowyer@fastmail.co.uk>", "tree": {"sha": "ed6d7571b92cdf4e308d2c4e00716beb17675efa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed6d7571b92cdf4e308d2c4e00716beb17675efa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8440d6c998b6f30fa04d6ed6f1e4f19242283af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8440d6c998b6f30fa04d6ed6f1e4f19242283af", "html_url": "https://github.com/rust-lang/rust/commit/f8440d6c998b6f30fa04d6ed6f1e4f19242283af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8440d6c998b6f30fa04d6ed6f1e4f19242283af/comments", "author": {"login": "henryboisdequin", "id": 65845077, "node_id": "MDQ6VXNlcjY1ODQ1MDc3", "avatar_url": "https://avatars.githubusercontent.com/u/65845077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/henryboisdequin", "html_url": "https://github.com/henryboisdequin", "followers_url": "https://api.github.com/users/henryboisdequin/followers", "following_url": "https://api.github.com/users/henryboisdequin/following{/other_user}", "gists_url": "https://api.github.com/users/henryboisdequin/gists{/gist_id}", "starred_url": "https://api.github.com/users/henryboisdequin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/henryboisdequin/subscriptions", "organizations_url": "https://api.github.com/users/henryboisdequin/orgs", "repos_url": "https://api.github.com/users/henryboisdequin/repos", "events_url": "https://api.github.com/users/henryboisdequin/events{/privacy}", "received_events_url": "https://api.github.com/users/henryboisdequin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "henryboisdequin", "id": 65845077, "node_id": "MDQ6VXNlcjY1ODQ1MDc3", "avatar_url": "https://avatars.githubusercontent.com/u/65845077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/henryboisdequin", "html_url": "https://github.com/henryboisdequin", "followers_url": "https://api.github.com/users/henryboisdequin/followers", "following_url": "https://api.github.com/users/henryboisdequin/following{/other_user}", "gists_url": "https://api.github.com/users/henryboisdequin/gists{/gist_id}", "starred_url": "https://api.github.com/users/henryboisdequin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/henryboisdequin/subscriptions", "organizations_url": "https://api.github.com/users/henryboisdequin/orgs", "repos_url": "https://api.github.com/users/henryboisdequin/repos", "events_url": "https://api.github.com/users/henryboisdequin/events{/privacy}", "received_events_url": "https://api.github.com/users/henryboisdequin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d1531f3c134859fc4f733ebddcfd38a8987d5cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d1531f3c134859fc4f733ebddcfd38a8987d5cf", "html_url": "https://github.com/rust-lang/rust/commit/7d1531f3c134859fc4f733ebddcfd38a8987d5cf"}], "stats": {"total": 394, "additions": 314, "deletions": 80}, "files": [{"sha": "e8071845c7d76240046ef8c3be17023474c772ad", "filename": "src/data_race.rs", "status": "modified", "additions": 54, "deletions": 20, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f8440d6c998b6f30fa04d6ed6f1e4f19242283af/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8440d6c998b6f30fa04d6ed6f1e4f19242283af/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=f8440d6c998b6f30fa04d6ed6f1e4f19242283af", "patch": "@@ -74,9 +74,9 @@ use rustc_middle::{mir, ty::layout::TyAndLayout};\n use rustc_target::abi::Size;\n \n use crate::{\n-    ImmTy, Immediate, InterpResult, MPlaceTy, MemPlaceMeta, MiriEvalContext, MiriEvalContextExt,\n-    OpTy, Pointer, RangeMap, Scalar, ScalarMaybeUninit, Tag, ThreadId, VClock, VTimestamp,\n-    VectorIdx, MemoryKind, MiriMemoryKind\n+    ImmTy, Immediate, InterpResult, MPlaceTy, MemPlaceMeta, MemoryKind, MiriEvalContext,\n+    MiriEvalContextExt, MiriMemoryKind, OpTy, Pointer, RangeMap, Scalar, ScalarMaybeUninit, Tag,\n+    ThreadId, VClock, VTimestamp, VectorIdx,\n };\n \n pub type AllocExtra = VClockAlloc;\n@@ -542,6 +542,34 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         Ok(old)\n     }\n \n+    /// Perform an conditional atomic exchange with a memory place and a new\n+    /// scalar value, the old value is returned.\n+    fn atomic_min_max_scalar(\n+        &mut self,\n+        place: &MPlaceTy<'tcx, Tag>,\n+        rhs: ImmTy<'tcx, Tag>,\n+        min: bool,\n+        atomic: AtomicRwOp,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n+        let this = self.eval_context_mut();\n+\n+        let old = this.allow_data_races_mut(|this| this.read_immediate(&place.into()))?;\n+        let lt = this.overflowing_binary_op(mir::BinOp::Lt, &old, &rhs)?.0.to_bool()?;\n+\n+        let new_val = if min {\n+            if lt { &old } else { &rhs }\n+        } else {\n+            if lt { &rhs } else { &old }\n+        };\n+\n+        this.allow_data_races_mut(|this| this.write_immediate_to_mplace(**new_val, place))?;\n+\n+        this.validate_atomic_rmw(&place, atomic)?;\n+\n+        // Return the old value.\n+        Ok(old)\n+    }\n+\n     /// Perform an atomic compare and exchange at a given memory location.\n     /// On success an atomic RMW operation is performed and on failure\n     /// only an atomic read occurs. If `can_fail_spuriously` is true,\n@@ -687,15 +715,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         }\n     }\n \n-    fn reset_vector_clocks(\n-        &mut self,\n-        ptr: Pointer<Tag>,\n-        size: Size\n-    ) -> InterpResult<'tcx> {\n+    fn reset_vector_clocks(&mut self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         if let Some(data_race) = &mut this.memory.extra.data_race {\n             if data_race.multi_threaded.get() {\n-                let alloc_meta = this.memory.get_raw_mut(ptr.alloc_id)?.extra.data_race.as_mut().unwrap();\n+                let alloc_meta =\n+                    this.memory.get_raw_mut(ptr.alloc_id)?.extra.data_race.as_mut().unwrap();\n                 alloc_meta.reset_clocks(ptr.offset, size);\n             }\n         }\n@@ -715,28 +740,37 @@ pub struct VClockAlloc {\n \n impl VClockAlloc {\n     /// Create a new data-race detector for newly allocated memory.\n-    pub fn new_allocation(global: &MemoryExtra, len: Size, kind: MemoryKind<MiriMemoryKind>) -> VClockAlloc {\n+    pub fn new_allocation(\n+        global: &MemoryExtra,\n+        len: Size,\n+        kind: MemoryKind<MiriMemoryKind>,\n+    ) -> VClockAlloc {\n         let (alloc_timestamp, alloc_index) = match kind {\n             // User allocated and stack memory should track allocation.\n             MemoryKind::Machine(\n-                MiriMemoryKind::Rust | MiriMemoryKind::C | MiriMemoryKind::WinHeap\n-            ) | MemoryKind::Stack => {\n+                MiriMemoryKind::Rust | MiriMemoryKind::C | MiriMemoryKind::WinHeap,\n+            )\n+            | MemoryKind::Stack => {\n                 let (alloc_index, clocks) = global.current_thread_state();\n                 let alloc_timestamp = clocks.clock[alloc_index];\n                 (alloc_timestamp, alloc_index)\n             }\n             // Other global memory should trace races but be allocated at the 0 timestamp.\n             MemoryKind::Machine(\n-                MiriMemoryKind::Global | MiriMemoryKind::Machine | MiriMemoryKind::Env |\n-                MiriMemoryKind::ExternStatic | MiriMemoryKind::Tls\n-            ) | MemoryKind::CallerLocation | MemoryKind::Vtable => {\n-                (0, VectorIdx::MAX_INDEX)\n-            }\n+                MiriMemoryKind::Global\n+                | MiriMemoryKind::Machine\n+                | MiriMemoryKind::Env\n+                | MiriMemoryKind::ExternStatic\n+                | MiriMemoryKind::Tls,\n+            )\n+            | MemoryKind::CallerLocation\n+            | MemoryKind::Vtable => (0, VectorIdx::MAX_INDEX),\n         };\n         VClockAlloc {\n             global: Rc::clone(global),\n             alloc_ranges: RefCell::new(RangeMap::new(\n-                len, MemoryCellClocks::new(alloc_timestamp, alloc_index)\n+                len,\n+                MemoryCellClocks::new(alloc_timestamp, alloc_index),\n             )),\n         }\n     }\n@@ -1015,7 +1049,8 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n                                 true,\n                                 place_ptr,\n                                 size,\n-                            ).map(|_| true);\n+                            )\n+                            .map(|_| true);\n                         }\n                     }\n \n@@ -1267,7 +1302,6 @@ impl GlobalState {\n             .as_ref()\n             .expect(\"Joined with thread but thread has not terminated\");\n \n-\n         // The join thread happens-before the current thread\n         // so update the current vector clock.\n         // Is not a release operation so the clock is not incremented."}, {"sha": "66ba42c5a017b581edeeb6b9e0f3824ad843992d", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 246, "deletions": 60, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/f8440d6c998b6f30fa04d6ed6f1e4f19242283af/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8440d6c998b6f30fa04d6ed6f1e4f19242283af/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=f8440d6c998b6f30fa04d6ed6f1e4f19242283af", "patch": "@@ -10,6 +10,12 @@ use rustc_target::abi::{Align, Integer, LayoutOf};\n use crate::*;\n use helpers::check_arg_count;\n \n+pub enum AtomicOp {\n+    MirOp(mir::BinOp, bool),\n+    Max,\n+    Min,\n+}\n+\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn call_intrinsic(\n@@ -388,60 +394,226 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 AtomicReadOp::Acquire,\n             )?,\n \n-            \"atomic_or\" => this.atomic_op(args, dest, BinOp::BitOr, false, AtomicRwOp::SeqCst)?,\n-            \"atomic_or_acq\" =>\n-                this.atomic_op(args, dest, BinOp::BitOr, false, AtomicRwOp::Acquire)?,\n-            \"atomic_or_rel\" =>\n-                this.atomic_op(args, dest, BinOp::BitOr, false, AtomicRwOp::Release)?,\n-            \"atomic_or_acqrel\" =>\n-                this.atomic_op(args, dest, BinOp::BitOr, false, AtomicRwOp::AcqRel)?,\n-            \"atomic_or_relaxed\" =>\n-                this.atomic_op(args, dest, BinOp::BitOr, false, AtomicRwOp::Relaxed)?,\n-            \"atomic_xor\" => this.atomic_op(args, dest, BinOp::BitXor, false, AtomicRwOp::SeqCst)?,\n-            \"atomic_xor_acq\" =>\n-                this.atomic_op(args, dest, BinOp::BitXor, false, AtomicRwOp::Acquire)?,\n-            \"atomic_xor_rel\" =>\n-                this.atomic_op(args, dest, BinOp::BitXor, false, AtomicRwOp::Release)?,\n-            \"atomic_xor_acqrel\" =>\n-                this.atomic_op(args, dest, BinOp::BitXor, false, AtomicRwOp::AcqRel)?,\n-            \"atomic_xor_relaxed\" =>\n-                this.atomic_op(args, dest, BinOp::BitXor, false, AtomicRwOp::Relaxed)?,\n-            \"atomic_and\" => this.atomic_op(args, dest, BinOp::BitAnd, false, AtomicRwOp::SeqCst)?,\n-            \"atomic_and_acq\" =>\n-                this.atomic_op(args, dest, BinOp::BitAnd, false, AtomicRwOp::Acquire)?,\n-            \"atomic_and_rel\" =>\n-                this.atomic_op(args, dest, BinOp::BitAnd, false, AtomicRwOp::Release)?,\n-            \"atomic_and_acqrel\" =>\n-                this.atomic_op(args, dest, BinOp::BitAnd, false, AtomicRwOp::AcqRel)?,\n-            \"atomic_and_relaxed\" =>\n-                this.atomic_op(args, dest, BinOp::BitAnd, false, AtomicRwOp::Relaxed)?,\n-            \"atomic_nand\" => this.atomic_op(args, dest, BinOp::BitAnd, true, AtomicRwOp::SeqCst)?,\n-            \"atomic_nand_acq\" =>\n-                this.atomic_op(args, dest, BinOp::BitAnd, true, AtomicRwOp::Acquire)?,\n-            \"atomic_nand_rel\" =>\n-                this.atomic_op(args, dest, BinOp::BitAnd, true, AtomicRwOp::Release)?,\n-            \"atomic_nand_acqrel\" =>\n-                this.atomic_op(args, dest, BinOp::BitAnd, true, AtomicRwOp::AcqRel)?,\n-            \"atomic_nand_relaxed\" =>\n-                this.atomic_op(args, dest, BinOp::BitAnd, true, AtomicRwOp::Relaxed)?,\n-            \"atomic_xadd\" => this.atomic_op(args, dest, BinOp::Add, false, AtomicRwOp::SeqCst)?,\n-            \"atomic_xadd_acq\" =>\n-                this.atomic_op(args, dest, BinOp::Add, false, AtomicRwOp::Acquire)?,\n-            \"atomic_xadd_rel\" =>\n-                this.atomic_op(args, dest, BinOp::Add, false, AtomicRwOp::Release)?,\n-            \"atomic_xadd_acqrel\" =>\n-                this.atomic_op(args, dest, BinOp::Add, false, AtomicRwOp::AcqRel)?,\n-            \"atomic_xadd_relaxed\" =>\n-                this.atomic_op(args, dest, BinOp::Add, false, AtomicRwOp::Relaxed)?,\n-            \"atomic_xsub\" => this.atomic_op(args, dest, BinOp::Sub, false, AtomicRwOp::SeqCst)?,\n-            \"atomic_xsub_acq\" =>\n-                this.atomic_op(args, dest, BinOp::Sub, false, AtomicRwOp::Acquire)?,\n-            \"atomic_xsub_rel\" =>\n-                this.atomic_op(args, dest, BinOp::Sub, false, AtomicRwOp::Release)?,\n-            \"atomic_xsub_acqrel\" =>\n-                this.atomic_op(args, dest, BinOp::Sub, false, AtomicRwOp::AcqRel)?,\n-            \"atomic_xsub_relaxed\" =>\n-                this.atomic_op(args, dest, BinOp::Sub, false, AtomicRwOp::Relaxed)?,\n+            \"atomic_or\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::BitOr, false),\n+                AtomicRwOp::SeqCst,\n+            )?,\n+            \"atomic_or_acq\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::BitOr, false),\n+                AtomicRwOp::Acquire,\n+            )?,\n+            \"atomic_or_rel\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::BitOr, false),\n+                AtomicRwOp::Release,\n+            )?,\n+            \"atomic_or_acqrel\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::BitOr, false),\n+                AtomicRwOp::AcqRel,\n+            )?,\n+            \"atomic_or_relaxed\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::BitOr, false),\n+                AtomicRwOp::Relaxed,\n+            )?,\n+            \"atomic_xor\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::BitXor, false),\n+                AtomicRwOp::SeqCst,\n+            )?,\n+            \"atomic_xor_acq\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::BitXor, false),\n+                AtomicRwOp::Acquire,\n+            )?,\n+            \"atomic_xor_rel\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::BitXor, false),\n+                AtomicRwOp::Release,\n+            )?,\n+            \"atomic_xor_acqrel\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::BitXor, false),\n+                AtomicRwOp::AcqRel,\n+            )?,\n+            \"atomic_xor_relaxed\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::BitXor, false),\n+                AtomicRwOp::Relaxed,\n+            )?,\n+            \"atomic_and\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::BitAnd, false),\n+                AtomicRwOp::SeqCst,\n+            )?,\n+            \"atomic_and_acq\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::BitAnd, false),\n+                AtomicRwOp::Acquire,\n+            )?,\n+            \"atomic_and_rel\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::BitAnd, false),\n+                AtomicRwOp::Release,\n+            )?,\n+            \"atomic_and_acqrel\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::BitAnd, false),\n+                AtomicRwOp::AcqRel,\n+            )?,\n+            \"atomic_and_relaxed\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::BitAnd, false),\n+                AtomicRwOp::Relaxed,\n+            )?,\n+            \"atomic_nand\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::BitAnd, true),\n+                AtomicRwOp::SeqCst,\n+            )?,\n+            \"atomic_nand_acq\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::BitAnd, true),\n+                AtomicRwOp::Acquire,\n+            )?,\n+            \"atomic_nand_rel\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::BitAnd, true),\n+                AtomicRwOp::Release,\n+            )?,\n+            \"atomic_nand_acqrel\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::BitAnd, true),\n+                AtomicRwOp::AcqRel,\n+            )?,\n+            \"atomic_nand_relaxed\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::BitAnd, true),\n+                AtomicRwOp::Relaxed,\n+            )?,\n+            \"atomic_xadd\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::Add, false),\n+                AtomicRwOp::SeqCst,\n+            )?,\n+            \"atomic_xadd_acq\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::Add, false),\n+                AtomicRwOp::Acquire,\n+            )?,\n+            \"atomic_xadd_rel\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::Add, false),\n+                AtomicRwOp::Release,\n+            )?,\n+            \"atomic_xadd_acqrel\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::Add, false),\n+                AtomicRwOp::AcqRel,\n+            )?,\n+            \"atomic_xadd_relaxed\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::Add, false),\n+                AtomicRwOp::Relaxed,\n+            )?,\n+            \"atomic_xsub\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::Sub, false),\n+                AtomicRwOp::SeqCst,\n+            )?,\n+            \"atomic_xsub_acq\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::Sub, false),\n+                AtomicRwOp::Acquire,\n+            )?,\n+            \"atomic_xsub_rel\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::Sub, false),\n+                AtomicRwOp::Release,\n+            )?,\n+            \"atomic_xsub_acqrel\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::Sub, false),\n+                AtomicRwOp::AcqRel,\n+            )?,\n+            \"atomic_xsub_relaxed\" => this.atomic_op_min_max(\n+                args,\n+                dest,\n+                AtomicOp::MirOp(BinOp::Sub, false),\n+                AtomicRwOp::Relaxed,\n+            )?,\n+            \"atomic_min\" =>\n+                this.atomic_op_min_max(args, dest, AtomicOp::Min, AtomicRwOp::SeqCst)?,\n+            \"atomic_min_acq\" =>\n+                this.atomic_op_min_max(args, dest, AtomicOp::Min, AtomicRwOp::Acquire)?,\n+            \"atomic_min_rel\" =>\n+                this.atomic_op_min_max(args, dest, AtomicOp::Min, AtomicRwOp::Release)?,\n+            \"atomic_min_acqrel\" =>\n+                this.atomic_op_min_max(args, dest, AtomicOp::Min, AtomicRwOp::AcqRel)?,\n+            \"atomic_min_relaxed\" =>\n+                this.atomic_op_min_max(args, dest, AtomicOp::Min, AtomicRwOp::Relaxed)?,\n+            \"atomic_max\" =>\n+                this.atomic_op_min_max(args, dest, AtomicOp::Max, AtomicRwOp::SeqCst)?,\n+            \"atomic_max_acq\" =>\n+                this.atomic_op_min_max(args, dest, AtomicOp::Max, AtomicRwOp::Acquire)?,\n+            \"atomic_max_rel\" =>\n+                this.atomic_op_min_max(args, dest, AtomicOp::Max, AtomicRwOp::Release)?,\n+            \"atomic_max_acqrel\" =>\n+                this.atomic_op_min_max(args, dest, AtomicOp::Max, AtomicRwOp::AcqRel)?,\n+            \"atomic_max_relaxed\" =>\n+                this.atomic_op_min_max(args, dest, AtomicOp::Max, AtomicRwOp::Relaxed)?,\n+            \"atomic_umin\" =>\n+                this.atomic_op_min_max(args, dest, AtomicOp::Min, AtomicRwOp::SeqCst)?,\n+            \"atomic_umin_acq\" =>\n+                this.atomic_op_min_max(args, dest, AtomicOp::Min, AtomicRwOp::Acquire)?,\n+            \"atomic_umin_rel\" =>\n+                this.atomic_op_min_max(args, dest, AtomicOp::Min, AtomicRwOp::Release)?,\n+            \"atomic_umin_acqrel\" =>\n+                this.atomic_op_min_max(args, dest, AtomicOp::Min, AtomicRwOp::AcqRel)?,\n+            \"atomic_umin_relaxed\" =>\n+                this.atomic_op_min_max(args, dest, AtomicOp::Min, AtomicRwOp::Relaxed)?,\n+            \"atomic_umax\" =>\n+                this.atomic_op_min_max(args, dest, AtomicOp::Max, AtomicRwOp::SeqCst)?,\n+            \"atomic_umax_acq\" =>\n+                this.atomic_op_min_max(args, dest, AtomicOp::Max, AtomicRwOp::Acquire)?,\n+            \"atomic_umax_rel\" =>\n+                this.atomic_op_min_max(args, dest, AtomicOp::Max, AtomicRwOp::Release)?,\n+            \"atomic_umax_acqrel\" =>\n+                this.atomic_op_min_max(args, dest, AtomicOp::Max, AtomicRwOp::AcqRel)?,\n+            \"atomic_umax_relaxed\" =>\n+                this.atomic_op_min_max(args, dest, AtomicOp::Max, AtomicRwOp::Relaxed)?,\n \n             // Query type information\n             \"assert_zero_valid\" | \"assert_uninit_valid\" => {\n@@ -557,18 +729,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(())\n     }\n \n-    fn atomic_op(\n+    fn atomic_op_min_max(\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n         dest: &PlaceTy<'tcx, Tag>,\n-        op: mir::BinOp,\n-        neg: bool,\n+        atomic_op: AtomicOp,\n         atomic: AtomicRwOp,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n         let &[ref place, ref rhs] = check_arg_count(args)?;\n         let place = this.deref_operand(place)?;\n+\n         if !place.layout.ty.is_integral() {\n             bug!(\"Atomic arithmetic operations only work on integer types\");\n         }\n@@ -580,9 +752,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n         this.memory.check_ptr_access(place.ptr, place.layout.size, align)?;\n \n-        let old = this.atomic_op_immediate(&place, &rhs, op, neg, atomic)?;\n-        this.write_immediate(*old, dest)?; // old value is returned\n-        Ok(())\n+        match atomic_op {\n+            AtomicOp::Min => {\n+                let old = this.atomic_min_max_scalar(&place, rhs, true, atomic)?;\n+                this.write_immediate(*old, &dest)?; // old value is returned\n+                Ok(())\n+            }\n+            AtomicOp::Max => {\n+                let old = this.atomic_min_max_scalar(&place, rhs, false, atomic)?;\n+                this.write_immediate(*old, &dest)?; // old value is returned\n+                Ok(())\n+            }\n+            AtomicOp::MirOp(op, neg) => {\n+                let old = this.atomic_op_immediate(&place, &rhs, op, neg, atomic)?;\n+                this.write_immediate(*old, dest)?; // old value is returned\n+                Ok(())\n+            }\n+        }\n     }\n \n     fn atomic_exchange("}, {"sha": "9a9e852ecf50f9114386e7bcedb36b1c78ed47ec", "filename": "tests/run-pass/atomic.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f8440d6c998b6f30fa04d6ed6f1e4f19242283af/tests%2Frun-pass%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8440d6c998b6f30fa04d6ed6f1e4f19242283af/tests%2Frun-pass%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fatomic.rs?ref=f8440d6c998b6f30fa04d6ed6f1e4f19242283af", "patch": "@@ -74,6 +74,20 @@ fn atomic_u64() {\n     assert_eq!(ATOMIC.compare_exchange(0, 0x100, AcqRel, Acquire), Err(1));\n     compare_exchange_weak_loop!(ATOMIC, 1, 0x100, AcqRel, Acquire);\n     assert_eq!(ATOMIC.load(Relaxed), 0x100);\n+\n+    assert_eq!(ATOMIC.fetch_max(0x10, SeqCst), 0x100);\n+    assert_eq!(ATOMIC.fetch_max(0x100, SeqCst), 0x100);\n+    assert_eq!(ATOMIC.fetch_max(0x1000, SeqCst), 0x100);\n+    assert_eq!(ATOMIC.fetch_max(0x1000, SeqCst), 0x1000);\n+    assert_eq!(ATOMIC.fetch_max(0x2000, SeqCst), 0x1000);\n+    assert_eq!(ATOMIC.fetch_max(0x2000, SeqCst), 0x2000);\n+\n+    assert_eq!(ATOMIC.fetch_min(0x2000, SeqCst), 0x2000);\n+    assert_eq!(ATOMIC.fetch_min(0x2000, SeqCst), 0x2000);\n+    assert_eq!(ATOMIC.fetch_min(0x1000, SeqCst), 0x2000);\n+    assert_eq!(ATOMIC.fetch_min(0x1000, SeqCst), 0x1000);\n+    assert_eq!(ATOMIC.fetch_min(0x100, SeqCst), 0x1000);\n+    assert_eq!(ATOMIC.fetch_min(0x10, SeqCst), 0x100);\n }\n \n fn atomic_fences() {"}]}