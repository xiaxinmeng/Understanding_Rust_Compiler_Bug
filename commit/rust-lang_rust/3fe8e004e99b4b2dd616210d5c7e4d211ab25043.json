{"sha": "3fe8e004e99b4b2dd616210d5c7e4d211ab25043", "node_id": "C_kwDOAAsO6NoAKDNmZThlMDA0ZTk5YjRiMmRkNjE2MjEwZDVjN2U0ZDIxMWFiMjUwNDM", "commit": {"author": {"name": "Nathan Stocks", "email": "cleancut@github.com", "date": "2022-10-02T20:34:10Z"}, "committer": {"name": "Nathan Stocks", "email": "cleancut@github.com", "date": "2022-10-07T19:19:27Z"}, "message": "migrate the rest of check_attr.rs to translateable diagnostics", "tree": {"sha": "6f246f93656f88379e1f2f03c3a24d2bcfe686a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f246f93656f88379e1f2f03c3a24d2bcfe686a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fe8e004e99b4b2dd616210d5c7e4d211ab25043", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fe8e004e99b4b2dd616210d5c7e4d211ab25043", "html_url": "https://github.com/rust-lang/rust/commit/3fe8e004e99b4b2dd616210d5c7e4d211ab25043", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fe8e004e99b4b2dd616210d5c7e4d211ab25043/comments", "author": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "committer": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "parents": [{"sha": "a7aa1850b2de87e31ffa07df6f4d47e0a5f7b01e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7aa1850b2de87e31ffa07df6f4d47e0a5f7b01e", "html_url": "https://github.com/rust-lang/rust/commit/a7aa1850b2de87e31ffa07df6f4d47e0a5f7b01e"}], "stats": {"total": 172, "additions": 110, "deletions": 62}, "files": [{"sha": "217a05b43642503cf3d3b919602c4fff212bae60", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3fe8e004e99b4b2dd616210d5c7e4d211ab25043/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/3fe8e004e99b4b2dd616210d5c7e4d211ab25043/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=3fe8e004e99b4b2dd616210d5c7e4d211ab25043", "patch": "@@ -564,3 +564,39 @@ passes_useless_assignment =\n         [true] field\n         *[false] variable\n     } of type `{$ty}` to itself\n+\n+passes_only_has_effect_on =\n+    `#[{$attr_name}]` only has an effect on {$target_name ->\n+        [function] functions\n+        [module] modules\n+        [implementation_block] implementation blocks\n+        *[unspecified] (unspecified--this is a compiler bug)\n+    }\n+\n+passes_object_lifetime_err =\n+    {$repr}\n+\n+passes_unrecognized_repr_hint =\n+    unrecognized representation hint\n+    .help = valid reprs are `C`, `align`, `packed`, `transparent`, `simd`, `i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `i128`, `u128`, `isize`, `usize`\n+\n+passes_attribute_should_be_applied_to =\n+    attribute should be applied to {$what ->\n+        [enum] an enum\n+        [struct] a struct\n+        [struct-union] a struct or union\n+        [struct-enum-union] a struct, enum, or union\n+        [struct-enum-function-union] a struct, enum, function, or union\n+        *[unspecified] (unspecified--this is a compiler bug)\n+    }\n+    .label = not {$what ->\n+        [enum] an enum\n+        [struct] a struct\n+        [struct-union] a struct or union\n+        [struct-enum-union] a struct, enum, or union\n+        [struct-enum-function-union] a struct, enum, function, or union\n+        *[unspecified] (unspecified--this is a compiler bug)\n+    }\n+\n+passes_transparent_incompatible =\n+    transparent {$target} cannot have other repr hints"}, {"sha": "33eb57fe7690684c25c8d99eec97cb9cdad5489c", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 33, "deletions": 62, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/3fe8e004e99b4b2dd616210d5c7e4d211ab25043/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fe8e004e99b4b2dd616210d5c7e4d211ab25043/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=3fe8e004e99b4b2dd616210d5c7e4d211ab25043", "patch": "@@ -4,10 +4,13 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n-use crate::errors::{self, DebugVisualizerUnreadable, InvalidAttrAtCrateLevel};\n+use crate::errors::{\n+    self, AttributeShouldBeAppliedTo, DebugVisualizerUnreadable, InvalidAttrAtCrateLevel,\n+    ObjectLifetimeErr, OnlyHasEffectOn, TransparentIncompatible, UnrecognizedReprHint,\n+};\n use rustc_ast::{ast, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{fluent, struct_span_err, Applicability, MultiSpan};\n+use rustc_errors::{fluent, Applicability, MultiSpan};\n use rustc_expand::base::resolve_path;\n use rustc_feature::{AttributeDuplicates, AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use rustc_hir as hir;\n@@ -164,17 +167,17 @@ impl CheckAttrVisitor<'_> {\n                 sym::no_mangle => self.check_no_mangle(hir_id, attr, span, target),\n                 sym::deprecated => self.check_deprecated(hir_id, attr, span, target),\n                 sym::macro_use | sym::macro_escape => self.check_macro_use(hir_id, attr, target),\n-                sym::path => self.check_generic_attr(hir_id, attr, target, &[Target::Mod]),\n+                sym::path => self.check_generic_attr(hir_id, attr, target, Target::Mod),\n                 sym::plugin_registrar => self.check_plugin_registrar(hir_id, attr, target),\n                 sym::macro_export => self.check_macro_export(hir_id, attr, target),\n                 sym::ignore | sym::should_panic | sym::proc_macro_derive => {\n-                    self.check_generic_attr(hir_id, attr, target, &[Target::Fn])\n+                    self.check_generic_attr(hir_id, attr, target, Target::Fn)\n                 }\n                 sym::automatically_derived => {\n-                    self.check_generic_attr(hir_id, attr, target, &[Target::Impl])\n+                    self.check_generic_attr(hir_id, attr, target, Target::Impl)\n                 }\n                 sym::no_implicit_prelude => {\n-                    self.check_generic_attr(hir_id, attr, target, &[Target::Mod])\n+                    self.check_generic_attr(hir_id, attr, target, Target::Mod)\n                 }\n                 sym::rustc_object_lifetime_default => self.check_object_lifetime_default(hir_id),\n                 _ => {}\n@@ -351,31 +354,17 @@ impl CheckAttrVisitor<'_> {\n         hir_id: HirId,\n         attr: &Attribute,\n         target: Target,\n-        allowed_targets: &[Target],\n+        allowed_target: Target,\n     ) {\n-        if !allowed_targets.iter().any(|t| t == &target) {\n-            let name = attr.name_or_empty();\n-            let mut i = allowed_targets.iter();\n-            // Pluralize\n-            let b = i.next().map_or_else(String::new, |t| t.to_string() + \"s\");\n-            let supported_names = i.enumerate().fold(b, |mut b, (i, allowed_target)| {\n-                if allowed_targets.len() > 2 && i == allowed_targets.len() - 2 {\n-                    b.push_str(\", and \");\n-                } else if allowed_targets.len() == 2 && i == allowed_targets.len() - 2 {\n-                    b.push_str(\" and \");\n-                } else {\n-                    b.push_str(\", \");\n-                }\n-                // Pluralize\n-                b.push_str(&(allowed_target.to_string() + \"s\"));\n-                b\n-            });\n-            self.tcx.struct_span_lint_hir(\n+        if target != allowed_target {\n+            self.tcx.emit_spanned_lint(\n                 UNUSED_ATTRIBUTES,\n                 hir_id,\n                 attr.span,\n-                &format!(\"`#[{name}]` only has an effect on {}\", supported_names),\n-                |lint| lint,\n+                OnlyHasEffectOn {\n+                    attr_name: attr.name_or_empty(),\n+                    target_name: allowed_target.name().replace(\" \", \"_\"),\n+                },\n             );\n         }\n     }\n@@ -432,7 +421,7 @@ impl CheckAttrVisitor<'_> {\n                     ObjectLifetimeDefault::Param(def_id) => tcx.item_name(def_id).to_string(),\n                     ObjectLifetimeDefault::Ambiguous => \"Ambiguous\".to_owned(),\n                 };\n-                tcx.sess.span_err(p.span, &repr);\n+                tcx.sess.emit_err(ObjectLifetimeErr { span: p.span, repr });\n             }\n         }\n     }\n@@ -1605,12 +1594,12 @@ impl CheckAttrVisitor<'_> {\n                 continue;\n             }\n \n-            let (article, allowed_targets) = match hint.name_or_empty() {\n+            let what = match hint.name_or_empty() {\n                 sym::C => {\n                     is_c = true;\n                     match target {\n                         Target::Struct | Target::Union | Target::Enum => continue,\n-                        _ => (\"a\", \"struct, enum, or union\"),\n+                        _ => \"struct-enum-union\",\n                     }\n                 }\n                 sym::align => {\n@@ -1626,20 +1615,20 @@ impl CheckAttrVisitor<'_> {\n \n                     match target {\n                         Target::Struct | Target::Union | Target::Enum | Target::Fn => continue,\n-                        _ => (\"a\", \"struct, enum, function, or union\"),\n+                        _ => \"struct-enum-function-union\",\n                     }\n                 }\n                 sym::packed => {\n                     if target != Target::Struct && target != Target::Union {\n-                        (\"a\", \"struct or union\")\n+                        \"struct-union\"\n                     } else {\n                         continue;\n                     }\n                 }\n                 sym::simd => {\n                     is_simd = true;\n                     if target != Target::Struct {\n-                        (\"a\", \"struct\")\n+                        \"struct\"\n                     } else {\n                         continue;\n                     }\n@@ -1648,7 +1637,7 @@ impl CheckAttrVisitor<'_> {\n                     is_transparent = true;\n                     match target {\n                         Target::Struct | Target::Union | Target::Enum => continue,\n-                        _ => (\"a\", \"struct, enum, or union\"),\n+                        _ => \"struct-enum-union\",\n                     }\n                 }\n                 sym::i8\n@@ -1665,35 +1654,22 @@ impl CheckAttrVisitor<'_> {\n                 | sym::usize => {\n                     int_reprs += 1;\n                     if target != Target::Enum {\n-                        (\"an\", \"enum\")\n+                        \"enum\"\n                     } else {\n                         continue;\n                     }\n                 }\n                 _ => {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        hint.span(),\n-                        E0552,\n-                        \"unrecognized representation hint\"\n-                    )\n-                    .help(\"valid reprs are `C`, `align`, `packed`, `transparent`, `simd`, `i8`, `u8`, \\\n-                          `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `i128`, `u128`, `isize`, `usize`\")\n-                    .emit();\n-\n+                    self.tcx.sess.emit_err(UnrecognizedReprHint { span: hint.span() });\n                     continue;\n                 }\n             };\n \n-            struct_span_err!(\n-                self.tcx.sess,\n-                hint.span(),\n-                E0517,\n-                \"{}\",\n-                &format!(\"attribute should be applied to {article} {allowed_targets}\")\n-            )\n-            .span_label(span, &format!(\"not {article} {allowed_targets}\"))\n-            .emit();\n+            self.tcx.sess.emit_err(AttributeShouldBeAppliedTo {\n+                hint_span: hint.span(),\n+                span,\n+                what,\n+            });\n         }\n \n         // Just point at all repr hints if there are any incompatibilities.\n@@ -1703,14 +1679,9 @@ impl CheckAttrVisitor<'_> {\n         // Error on repr(transparent, <anything else>).\n         if is_transparent && hints.len() > 1 {\n             let hint_spans: Vec<_> = hint_spans.clone().collect();\n-            struct_span_err!(\n-                self.tcx.sess,\n-                hint_spans,\n-                E0692,\n-                \"transparent {} cannot have other repr hints\",\n-                target\n-            )\n-            .emit();\n+            self.tcx\n+                .sess\n+                .emit_err(TransparentIncompatible { hint_spans, target: target.to_string() });\n         }\n         // Warn on repr(u8, u16), repr(C, simd), and c-like-enum-repr(C, u8)\n         if (int_reprs > 1)"}, {"sha": "4f8c3ed6002cc07988b29f82b0e4441d1020cc1e", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3fe8e004e99b4b2dd616210d5c7e4d211ab25043/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fe8e004e99b4b2dd616210d5c7e4d211ab25043/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=3fe8e004e99b4b2dd616210d5c7e4d211ab25043", "patch": "@@ -1272,3 +1272,44 @@ pub struct UselessAssignment<'a> {\n     pub is_field_assign: bool,\n     pub ty: Ty<'a>,\n }\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes::only_has_effect_on)]\n+pub struct OnlyHasEffectOn {\n+    pub attr_name: Symbol,\n+    pub target_name: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::object_lifetime_err)]\n+pub struct ObjectLifetimeErr {\n+    #[primary_span]\n+    pub span: Span,\n+    pub repr: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unrecognized_repr_hint, code = \"E0552\")]\n+#[help]\n+pub struct UnrecognizedReprHint {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::attribute_should_be_applied_to, code = \"E0517\")]\n+pub struct AttributeShouldBeAppliedTo<'a> {\n+    #[primary_span]\n+    pub hint_span: Span,\n+    #[label]\n+    pub span: Span,\n+    pub what: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::transparent_incompatible, code = \"E0692\")]\n+pub struct TransparentIncompatible {\n+    #[primary_span]\n+    pub hint_spans: Vec<Span>,\n+    pub target: String,\n+}"}]}