{"sha": "ef1251f696b8e8d306e6a1a902502e8d75420118", "node_id": "C_kwDOAAsO6NoAKGVmMTI1MWY2OTZiOGU4ZDMwNmU2YTFhOTAyNTAyZThkNzU0MjAxMTg", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-10-09T12:23:55Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-10-09T12:23:55Z"}, "message": "feat: report errors in macro definition\n\nReporting macro *definition* error at the macro *call site* is a rather\nquestionable approach, but at least we don't erase the errors\naltogether!", "tree": {"sha": "a91bd2e488920d7b08e0d1545c01d8cec8a03f37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a91bd2e488920d7b08e0d1545c01d8cec8a03f37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef1251f696b8e8d306e6a1a902502e8d75420118", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef1251f696b8e8d306e6a1a902502e8d75420118", "html_url": "https://github.com/rust-lang/rust/commit/ef1251f696b8e8d306e6a1a902502e8d75420118", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef1251f696b8e8d306e6a1a902502e8d75420118/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3d1de93af7e572647f8d68466128ad1b8d5a36e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3d1de93af7e572647f8d68466128ad1b8d5a36e", "html_url": "https://github.com/rust-lang/rust/commit/b3d1de93af7e572647f8d68466128ad1b8d5a36e"}], "stats": {"total": 216, "additions": 121, "deletions": 95}, "files": [{"sha": "50499840a3a47a7ca6dd38081bf8c91a5dd117b5", "filename": "crates/hir_def/src/macro_expansion_tests/mbe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef1251f696b8e8d306e6a1a902502e8d75420118/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1251f696b8e8d306e6a1a902502e8d75420118/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs?ref=ef1251f696b8e8d306e6a1a902502e8d75420118", "patch": "@@ -1,5 +1,6 @@\n mod tt_conversion;\n mod matching;\n+mod meta_syntax;\n \n use expect_test::expect;\n "}, {"sha": "1c4bb9d7b84e0072490371d8eeff3bf313518200", "filename": "crates/hir_def/src/macro_expansion_tests/mbe/meta_syntax.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ef1251f696b8e8d306e6a1a902502e8d75420118/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmeta_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1251f696b8e8d306e6a1a902502e8d75420118/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmeta_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmeta_syntax.rs?ref=ef1251f696b8e8d306e6a1a902502e8d75420118", "patch": "@@ -0,0 +1,77 @@\n+use expect_test::expect;\n+\n+use crate::macro_expansion_tests::check;\n+\n+#[test]\n+fn well_formed_macro_rules() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ($i:ident) => ();\n+    ($(x),*) => ();\n+    ($(x)_*) => ();\n+    ($(x)i*) => ();\n+    ($($i:ident)*) => ($_);\n+    ($($true:ident)*) => ($true);\n+    ($($false:ident)*) => ($false);\n+    ($) => ($);\n+}\n+m!($);\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ($i:ident) => ();\n+    ($(x),*) => ();\n+    ($(x)_*) => ();\n+    ($(x)i*) => ();\n+    ($($i:ident)*) => ($_);\n+    ($($true:ident)*) => ($true);\n+    ($($false:ident)*) => ($false);\n+    ($) => ($);\n+}\n+$\n+\"#]],\n+    )\n+}\n+\n+#[test]\n+fn malformed_macro_rules() {\n+    check(\n+        r#\"\n+macro_rules! i1 { invalid }\n+i1!();\n+\n+macro_rules! e1 { $i:ident => () }\n+e1!();\n+macro_rules! e2 { ($i:ident) () }\n+e2!();\n+macro_rules! e3 { ($(i:ident)_) => () }\n+e3!();\n+\n+macro_rules! f1 { ($i) => ($i) }\n+f1!();\n+macro_rules! f2 { ($i:) => ($i) }\n+f2!();\n+macro_rules! f3 { ($i:_) => () }\n+f3!();\n+\"#,\n+        expect![[r#\"\n+macro_rules! i1 { invalid }\n+/* error: invalid macro definition: expected subtree */\n+\n+macro_rules! e1 { $i:ident => () }\n+/* error: invalid macro definition: expected subtree */\n+macro_rules! e2 { ($i:ident) () }\n+/* error: invalid macro definition: expected `=` */\n+macro_rules! e3 { ($(i:ident)_) => () }\n+/* error: invalid macro definition: invalid repeat */\n+\n+macro_rules! f1 { ($i) => ($i) }\n+/* error: invalid macro definition: bad fragment specifier 1 */\n+macro_rules! f2 { ($i:) => ($i) }\n+/* error: invalid macro definition: bad fragment specifier 1 */\n+macro_rules! f3 { ($i:_) => () }\n+/* error: invalid macro definition: bad fragment specifier 1 */\n+\"#]],\n+    )\n+}"}, {"sha": "d445d7a2c616bf40324247c990c7f30dc2456fad", "filename": "crates/hir_def/src/macro_expansion_tests/mbe/tt_conversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef1251f696b8e8d306e6a1a902502e8d75420118/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Ftt_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1251f696b8e8d306e6a1a902502e8d75420118/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Ftt_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Ftt_conversion.rs?ref=ef1251f696b8e8d306e6a1a902502e8d75420118", "patch": "@@ -72,7 +72,7 @@ m2!(x\n macro_rules! m1 { ($x:ident) => { ($x } }\n macro_rules! m2 { ($x:ident) => {} }\n \n-/* error: Failed to find macro definition */\n+/* error: invalid macro definition: expected subtree */\n /* error: Failed to lower macro args to token tree */\n \"#]],\n     )"}, {"sha": "08ad9ffd948d210de639de4d48f5570f120e66df", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 28, "deletions": 31, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ef1251f696b8e8d306e6a1a902502e8d75420118/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1251f696b8e8d306e6a1a902502e8d75420118/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=ef1251f696b8e8d306e6a1a902502e8d75420118", "patch": "@@ -8,7 +8,7 @@ use mbe::{syntax_node_to_token_tree, ExpandError, ExpandResult};\n use rustc_hash::FxHashSet;\n use syntax::{\n     algo::diff,\n-    ast::{self, HasAttrs, HasName},\n+    ast::{self, HasAttrs},\n     AstNode, GreenNode, Parse, SyntaxNode, SyntaxToken, T,\n };\n \n@@ -119,7 +119,7 @@ pub trait AstDatabase: SourceDatabase {\n     fn macro_arg_text(&self, id: MacroCallId) -> Option<GreenNode>;\n     /// Gets the expander for this macro. This compiles declarative macros, and\n     /// just fetches procedural ones.\n-    fn macro_def(&self, id: MacroDefId) -> Option<Arc<TokenExpander>>;\n+    fn macro_def(&self, id: MacroDefId) -> Result<Arc<TokenExpander>, mbe::ParseError>;\n \n     /// Expand macro call to a token tree. This query is LRUed (we keep 128 or so results in memory)\n     fn macro_expand(&self, macro_call: MacroCallId) -> ExpandResult<Option<Arc<tt::Subtree>>>;\n@@ -145,7 +145,7 @@ pub fn expand_speculative(\n     token_to_map: SyntaxToken,\n ) -> Option<(SyntaxNode, SyntaxToken)> {\n     let loc = db.lookup_intern_macro(actual_macro_call);\n-    let macro_def = db.macro_def(loc.def)?;\n+    let macro_def = db.macro_def(loc.def).ok()?;\n     let token_range = token_to_map.text_range();\n \n     // Build the subtree and token mapping for the speculative args\n@@ -360,45 +360,39 @@ fn macro_arg_text(db: &dyn AstDatabase, id: MacroCallId) -> Option<GreenNode> {\n     Some(arg.green().into())\n }\n \n-fn macro_def(db: &dyn AstDatabase, id: MacroDefId) -> Option<Arc<TokenExpander>> {\n+fn macro_def(db: &dyn AstDatabase, id: MacroDefId) -> Result<Arc<TokenExpander>, mbe::ParseError> {\n     match id.kind {\n         MacroDefKind::Declarative(ast_id) => match ast_id.to_node(db) {\n             ast::Macro::MacroRules(macro_rules) => {\n-                let arg = macro_rules.token_tree()?;\n+                let arg = macro_rules\n+                    .token_tree()\n+                    .ok_or_else(|| mbe::ParseError::Expected(\"expected a token tree\".into()))?;\n                 let (tt, def_site_token_map) = mbe::syntax_node_to_token_tree(arg.syntax());\n-                let mac = match mbe::MacroRules::parse(&tt) {\n-                    Ok(it) => it,\n-                    Err(err) => {\n-                        let name = macro_rules.name().map(|n| n.to_string()).unwrap_or_default();\n-                        tracing::warn!(\"fail on macro_def parse ({}): {:?} {:#?}\", name, err, tt);\n-                        return None;\n-                    }\n-                };\n-                Some(Arc::new(TokenExpander::MacroRules { mac, def_site_token_map }))\n+                let mac = mbe::MacroRules::parse(&tt)?;\n+                Ok(Arc::new(TokenExpander::MacroRules { mac, def_site_token_map }))\n             }\n             ast::Macro::MacroDef(macro_def) => {\n-                let arg = macro_def.body()?;\n+                let arg = macro_def\n+                    .body()\n+                    .ok_or_else(|| mbe::ParseError::Expected(\"expected a token tree\".into()))?;\n                 let (tt, def_site_token_map) = mbe::syntax_node_to_token_tree(arg.syntax());\n-                let mac = match mbe::MacroDef::parse(&tt) {\n-                    Ok(it) => it,\n-                    Err(err) => {\n-                        let name = macro_def.name().map(|n| n.to_string()).unwrap_or_default();\n-                        tracing::warn!(\"fail on macro_def parse ({}): {:?} {:#?}\", name, err, tt);\n-                        return None;\n-                    }\n-                };\n-                Some(Arc::new(TokenExpander::MacroDef { mac, def_site_token_map }))\n+                let mac = mbe::MacroDef::parse(&tt)?;\n+                Ok(Arc::new(TokenExpander::MacroDef { mac, def_site_token_map }))\n             }\n         },\n-        MacroDefKind::BuiltIn(expander, _) => Some(Arc::new(TokenExpander::Builtin(expander))),\n+        MacroDefKind::BuiltIn(expander, _) => Ok(Arc::new(TokenExpander::Builtin(expander))),\n         MacroDefKind::BuiltInAttr(expander, _) => {\n-            Some(Arc::new(TokenExpander::BuiltinAttr(expander)))\n+            Ok(Arc::new(TokenExpander::BuiltinAttr(expander)))\n         }\n         MacroDefKind::BuiltInDerive(expander, _) => {\n-            Some(Arc::new(TokenExpander::BuiltinDerive(expander)))\n+            Ok(Arc::new(TokenExpander::BuiltinDerive(expander)))\n         }\n-        MacroDefKind::BuiltInEager(..) => None,\n-        MacroDefKind::ProcMacro(expander, ..) => Some(Arc::new(TokenExpander::ProcMacro(expander))),\n+        MacroDefKind::BuiltInEager(..) => {\n+            // FIXME: Return a random error here just to make the types align.\n+            // This obviously should do something real instead.\n+            Err(mbe::ParseError::UnexpectedToken(\"unexpected eager macro\".to_string()))\n+        }\n+        MacroDefKind::ProcMacro(expander, ..) => Ok(Arc::new(TokenExpander::ProcMacro(expander))),\n     }\n }\n \n@@ -419,8 +413,11 @@ fn macro_expand(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<Option<Ar\n     };\n \n     let expander = match db.macro_def(loc.def) {\n-        Some(it) => it,\n-        None => return ExpandResult::str_err(\"Failed to find macro definition\".into()),\n+        Ok(it) => it,\n+        // FIXME: This is weird -- we effectively report macro *definition*\n+        // errors lazily, when we try to expand the macro. Instead, they should\n+        // be reported at the definition site (when we construct a def map).\n+        Err(err) => return ExpandResult::str_err(format!(\"invalid macro definition: {}\", err)),\n     };\n     let ExpandResult { value: tt, err } = expander.expand(db, id, &macro_arg.0);\n     // Set a hard limit for the expanded tt"}, {"sha": "b2879e37c35148a5949727a3cf6e2f0142667604", "filename": "crates/hir_expand/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef1251f696b8e8d306e6a1a902502e8d75420118/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1251f696b8e8d306e6a1a902502e8d75420118/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs?ref=ef1251f696b8e8d306e6a1a902502e8d75420118", "patch": "@@ -195,7 +195,7 @@ fn make_hygiene_info(\n         _ => None,\n     });\n \n-    let macro_def = db.macro_def(loc.def)?;\n+    let macro_def = db.macro_def(loc.def).ok()?;\n     let (_, exp_map) = db.parse_macro_expansion(macro_file).value?;\n     let macro_arg = db.macro_arg(macro_file.macro_call_id)?;\n "}, {"sha": "ad6b84dd17e95fe9771fff055751ac55ce18a5f8", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef1251f696b8e8d306e6a1a902502e8d75420118/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1251f696b8e8d306e6a1a902502e8d75420118/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=ef1251f696b8e8d306e6a1a902502e8d75420118", "patch": "@@ -143,7 +143,7 @@ impl HirFileId {\n                     _ => None,\n                 });\n \n-                let macro_def = db.macro_def(loc.def)?;\n+                let macro_def = db.macro_def(loc.def).ok()?;\n                 let (parse, exp_map) = db.parse_macro_expansion(macro_file).value?;\n                 let macro_arg = db.macro_arg(macro_file.macro_call_id)?;\n "}, {"sha": "61e032e0afa57bd187b87762c01c30d85bb68fdc", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ef1251f696b8e8d306e6a1a902502e8d75420118/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1251f696b8e8d306e6a1a902502e8d75420118/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=ef1251f696b8e8d306e6a1a902502e8d75420118", "patch": "@@ -30,14 +30,25 @@ use crate::{\n pub use ::parser::ParserEntryPoint;\n pub use tt::{Delimiter, DelimiterKind, Punct};\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq, Clone)]\n pub enum ParseError {\n     UnexpectedToken(String),\n     Expected(String),\n     InvalidRepeat,\n     RepetitionEmptyTokenTree,\n }\n \n+impl fmt::Display for ParseError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            ParseError::UnexpectedToken(it) => f.write_str(it),\n+            ParseError::Expected(it) => f.write_str(it),\n+            ParseError::InvalidRepeat => f.write_str(\"invalid repeat\"),\n+            ParseError::RepetitionEmptyTokenTree => f.write_str(\"empty token tree in repetition\"),\n+        }\n+    }\n+}\n+\n #[derive(Debug, PartialEq, Eq, Clone)]\n pub enum ExpandError {\n     NoMatchingRule,"}, {"sha": "247616aa1b6543c4bf376ce3c81fcb613904da73", "filename": "crates/mbe/src/subtree_source.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ef1251f696b8e8d306e6a1a902502e8d75420118/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1251f696b8e8d306e6a1a902502e8d75420118/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs?ref=ef1251f696b8e8d306e6a1a902502e8d75420118", "patch": "@@ -17,17 +17,6 @@ pub(crate) struct SubtreeTokenSource {\n     curr: (Token, usize),\n }\n \n-impl<'a> SubtreeTokenSource {\n-    // Helper function used in test\n-    #[cfg(test)]\n-    pub(crate) fn text(&self) -> SmolStr {\n-        match self.cached.get(self.curr.1) {\n-            Some(tt) => tt.text.clone(),\n-            _ => SmolStr::new(\"\"),\n-        }\n-    }\n-}\n-\n impl<'a> SubtreeTokenSource {\n     pub(crate) fn new(buffer: &TokenBuffer) -> SubtreeTokenSource {\n         let mut current = buffer.begin();"}, {"sha": "ad5ae3a32c2bd036d628b33a551ebdec851751d1", "filename": "crates/mbe/src/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef1251f696b8e8d306e6a1a902502e8d75420118/crates%2Fmbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1251f696b8e8d306e6a1a902502e8d75420118/crates%2Fmbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests.rs?ref=ef1251f696b8e8d306e6a1a902502e8d75420118", "patch": "@@ -1,5 +1,4 @@\n mod expand;\n-mod rule;\n \n use std::{fmt::Write, iter};\n "}, {"sha": "691e359e4d7a02060d75bd0bfde0521533e169cd", "filename": "crates/mbe/src/tests/rule.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b3d1de93af7e572647f8d68466128ad1b8d5a36e/crates%2Fmbe%2Fsrc%2Ftests%2Frule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3d1de93af7e572647f8d68466128ad1b8d5a36e/crates%2Fmbe%2Fsrc%2Ftests%2Frule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests%2Frule.rs?ref=b3d1de93af7e572647f8d68466128ad1b8d5a36e", "patch": "@@ -1,48 +0,0 @@\n-use syntax::{ast, AstNode};\n-\n-use super::*;\n-\n-#[test]\n-fn test_valid_arms() {\n-    fn check(macro_body: &str) {\n-        let m = parse_macro_arm(macro_body);\n-        m.unwrap();\n-    }\n-\n-    check(\"($i:ident) => ()\");\n-    check(\"($(x),*) => ()\");\n-    check(\"($(x)_*) => ()\");\n-    check(\"($(x)i*) => ()\");\n-    check(\"($($i:ident)*) => ($_)\");\n-    check(\"($($true:ident)*) => ($true)\");\n-    check(\"($($false:ident)*) => ($false)\");\n-    check(\"($) => ($)\");\n-}\n-\n-#[test]\n-fn test_invalid_arms() {\n-    fn check(macro_body: &str, err: ParseError) {\n-        let m = parse_macro_arm(macro_body);\n-        assert_eq!(m, Err(err));\n-    }\n-    check(\"invalid\", ParseError::Expected(\"expected subtree\".into()));\n-\n-    check(\"$i:ident => ()\", ParseError::Expected(\"expected subtree\".into()));\n-    check(\"($i:ident) ()\", ParseError::Expected(\"expected `=`\".into()));\n-    check(\"($($i:ident)_) => ()\", ParseError::InvalidRepeat);\n-\n-    check(\"($i) => ($i)\", ParseError::UnexpectedToken(\"bad fragment specifier 1\".into()));\n-    check(\"($i:) => ($i)\", ParseError::UnexpectedToken(\"bad fragment specifier 1\".into()));\n-    check(\"($i:_) => ()\", ParseError::UnexpectedToken(\"bad fragment specifier 1\".into()));\n-}\n-\n-fn parse_macro_arm(arm_definition: &str) -> Result<crate::MacroRules, ParseError> {\n-    let macro_definition = format!(\" macro_rules! m {{ {} }} \", arm_definition);\n-    let source_file = ast::SourceFile::parse(&macro_definition).ok().unwrap();\n-    let macro_definition =\n-        source_file.syntax().descendants().find_map(ast::MacroRules::cast).unwrap();\n-\n-    let (definition_tt, _) =\n-        syntax_node_to_token_tree(macro_definition.token_tree().unwrap().syntax());\n-    crate::MacroRules::parse(&definition_tt)\n-}"}]}