{"sha": "ae8b84bf04cddda2379b36c45a575132e6a44fb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlOGI4NGJmMDRjZGRkYTIzNzliMzZjNDVhNTc1MTMyZTZhNDRmYjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-04T20:56:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-04T20:56:49Z"}, "message": "Auto merge of #84707 - Stupremee:remove-fake-defids-in-rustdoc, r=jyn514,GuillaumeGomez\n\nGet rid of fake `DefId`s in rustdoc\n\nRight now there are *many* errors left, but I wanted to show the current state since all that is left to do is fixing the errors.\n\nResolves #83183\n\nr? `@jyn514`", "tree": {"sha": "62e54bca4d742c7fcf52dc610ae20b96d9df280e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62e54bca4d742c7fcf52dc610ae20b96d9df280e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae8b84bf04cddda2379b36c45a575132e6a44fb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae8b84bf04cddda2379b36c45a575132e6a44fb0", "html_url": "https://github.com/rust-lang/rust/commit/ae8b84bf04cddda2379b36c45a575132e6a44fb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae8b84bf04cddda2379b36c45a575132e6a44fb0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bf0bd9c7957776945f5c2404eba1edd6ae3127d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bf0bd9c7957776945f5c2404eba1edd6ae3127d", "html_url": "https://github.com/rust-lang/rust/commit/8bf0bd9c7957776945f5c2404eba1edd6ae3127d"}, {"sha": "b6120bfb354c1c1c9fdfe7ff03daa5550a8706fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6120bfb354c1c1c9fdfe7ff03daa5550a8706fc", "html_url": "https://github.com/rust-lang/rust/commit/b6120bfb354c1c1c9fdfe7ff03daa5550a8706fc"}], "stats": {"total": 604, "additions": 336, "deletions": 268}, "files": [{"sha": "647d735fb86326c09657b5a4261cfb1c2a5e60c3", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -87,11 +87,6 @@ impl DefPathTable {\n         hash\n     }\n \n-    /// Used by librustdoc for fake DefIds.\n-    pub fn num_def_ids(&self) -> usize {\n-        self.index_to_key.len()\n-    }\n-\n     pub fn enumerated_keys_and_path_hashes(\n         &self,\n     ) -> impl Iterator<Item = (DefIndex, &DefKey, &DefPathHash)> + '_ {"}, {"sha": "d74fef0045f511062eff23c98b2cece325811717", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -1885,10 +1885,6 @@ impl CrateMetadata {\n         self.root.hash\n     }\n \n-    fn num_def_ids(&self) -> usize {\n-        self.root.tables.def_keys.size()\n-    }\n-\n     fn local_def_id(&self, index: DefIndex) -> DefId {\n         DefId { krate: self.cnum, index }\n     }"}, {"sha": "8595a70dd9478a759d3bddf53c3a171a989e8b04", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -461,10 +461,6 @@ impl CStore {\n         self.get_crate_data(def_id.krate).module_expansion(def_id.index, sess)\n     }\n \n-    pub fn num_def_ids(&self, cnum: CrateNum) -> usize {\n-        self.get_crate_data(cnum).num_def_ids()\n-    }\n-\n     pub fn item_attrs(&self, def_id: DefId, sess: &Session) -> Vec<ast::Attribute> {\n         self.get_crate_data(def_id.krate).get_item_attrs(def_id.index, sess).collect()\n     }"}, {"sha": "3bfc9fea62e90ad128f17d19f978827d1ee348b0", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             name: None,\n             attrs: Default::default(),\n             visibility: Inherited,\n-            def_id: self.cx.next_def_id(item_def_id.krate),\n+            def_id: FakeDefId::new_fake(item_def_id.krate),\n             kind: box ImplItem(Impl {\n                 span: Span::dummy(),\n                 unsafety: hir::Unsafety::Normal,"}, {"sha": "68856f82fe94c95827c46f079b2f8d2ad4d3c849", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                     name: None,\n                     attrs: Default::default(),\n                     visibility: Inherited,\n-                    def_id: self.cx.next_def_id(impl_def_id.krate),\n+                    def_id: FakeDefId::new_fake(item_def_id.krate),\n                     kind: box ImplItem(Impl {\n                         span: self.cx.tcx.def_span(impl_def_id).clean(self.cx),\n                         unsafety: hir::Unsafety::Normal,"}, {"sha": "5974cd878dd0c853bd2865c8d9771a7338e270a6", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -15,7 +15,7 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n-use crate::clean::{self, Attributes, AttributesExt, GetDefId, ToSource};\n+use crate::clean::{self, Attributes, AttributesExt, FakeDefId, GetDefId, ToSource};\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n \n@@ -121,7 +121,7 @@ crate fn try_inline(\n     };\n \n     let (attrs, cfg) = merge_attrs(cx, Some(parent_module), load_attrs(cx, did), attrs_clone);\n-    cx.inlined.insert(did);\n+    cx.inlined.insert(did.into());\n     ret.push(clean::Item::from_def_id_and_attrs_and_parts(\n         did,\n         Some(name),\n@@ -332,7 +332,7 @@ crate fn build_impl(\n     attrs: Option<Attrs<'_>>,\n     ret: &mut Vec<clean::Item>,\n ) {\n-    if !cx.inlined.insert(did) {\n+    if !cx.inlined.insert(did.into()) {\n         return;\n     }\n \n@@ -470,7 +470,7 @@ fn build_module(\n                 items.push(clean::Item {\n                     name: None,\n                     attrs: box clean::Attributes::default(),\n-                    def_id: cx.next_def_id(did.krate),\n+                    def_id: FakeDefId::new_fake(did.krate),\n                     visibility: clean::Public,\n                     kind: box clean::ImportItem(clean::Import::new_simple(\n                         item.ident.name,"}, {"sha": "411cfab9f06a001f72313a5dd9def58382d82cff", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -533,7 +533,8 @@ impl Clean<Generics> for hir::Generics<'_> {\n                 match param.kind {\n                     GenericParamDefKind::Lifetime => unreachable!(),\n                     GenericParamDefKind::Type { did, ref bounds, .. } => {\n-                        cx.impl_trait_bounds.insert(did.into(), bounds.clone());\n+                        cx.impl_trait_bounds\n+                            .insert(FakeDefId::new_real(did).into(), bounds.clone());\n                     }\n                     GenericParamDefKind::Const { .. } => unreachable!(),\n                 }\n@@ -614,7 +615,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n             .collect::<Vec<GenericParamDef>>();\n \n         // param index -> [(DefId of trait, associated type name, type)]\n-        let mut impl_trait_proj = FxHashMap::<u32, Vec<(DefId, Symbol, Ty<'tcx>)>>::default();\n+        let mut impl_trait_proj = FxHashMap::<u32, Vec<(FakeDefId, Symbol, Ty<'tcx>)>>::default();\n \n         let where_predicates = preds\n             .predicates\n@@ -663,10 +664,11 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n                         if let Some(((_, trait_did, name), rhs)) =\n                             proj.as_ref().and_then(|(lhs, rhs)| Some((lhs.projection()?, rhs)))\n                         {\n-                            impl_trait_proj\n-                                .entry(param_idx)\n-                                .or_default()\n-                                .push((trait_did, name, rhs));\n+                            impl_trait_proj.entry(param_idx).or_default().push((\n+                                trait_did.into(),\n+                                name,\n+                                rhs,\n+                            ));\n                         }\n \n                         return None;\n@@ -685,7 +687,13 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n                 if let Some(proj) = impl_trait_proj.remove(&idx) {\n                     for (trait_did, name, rhs) in proj {\n                         let rhs = rhs.clean(cx);\n-                        simplify::merge_bounds(cx, &mut bounds, trait_did, name, &rhs);\n+                        simplify::merge_bounds(\n+                            cx,\n+                            &mut bounds,\n+                            trait_did.expect_real(),\n+                            name,\n+                            &rhs,\n+                        );\n                     }\n                 }\n             } else {\n@@ -1175,7 +1183,8 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n                 if let Some(new_ty) = cx.ty_substs.get(&did).cloned() {\n                     return new_ty;\n                 }\n-                if let Some(bounds) = cx.impl_trait_bounds.remove(&did.into()) {\n+                if let Some(bounds) = cx.impl_trait_bounds.remove(&FakeDefId::new_real(did).into())\n+                {\n                     return ImplTrait(bounds);\n                 }\n             }\n@@ -2006,7 +2015,7 @@ fn clean_extern_crate(\n     vec![Item {\n         name: Some(name),\n         attrs: box attrs.clean(cx),\n-        def_id: crate_def_id,\n+        def_id: crate_def_id.into(),\n         visibility: krate.vis.clean(cx),\n         kind: box ExternCrateItem { src: orig_name },\n         cfg: attrs.cfg(cx.sess().diagnostic()),"}, {"sha": "350742e8f2898e56d32f91c3a27f543ba0cc4619", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 107, "deletions": 41, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -1,6 +1,5 @@\n-use std::cell::RefCell;\n+use std::cell::{Cell, RefCell};\n use std::default::Default;\n-use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::iter::FromIterator;\n use std::lazy::SyncOnceCell as OnceCell;\n@@ -19,7 +18,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{BodyId, Mutability};\n use rustc_index::vec::IndexVec;\n@@ -49,7 +48,94 @@ use self::ItemKind::*;\n use self::SelfTy::*;\n use self::Type::*;\n \n-thread_local!(crate static MAX_DEF_IDX: RefCell<FxHashMap<CrateNum, DefIndex>> = Default::default());\n+crate type FakeDefIdSet = FxHashSet<FakeDefId>;\n+\n+#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy)]\n+crate enum FakeDefId {\n+    Real(DefId),\n+    Fake(DefIndex, CrateNum),\n+}\n+\n+impl FakeDefId {\n+    #[cfg(parallel_compiler)]\n+    crate fn new_fake(crate: CrateNum) -> Self {\n+        unimplemented!(\"\")\n+    }\n+\n+    #[cfg(not(parallel_compiler))]\n+    crate fn new_fake(krate: CrateNum) -> Self {\n+        thread_local!(static FAKE_DEF_ID_COUNTER: Cell<usize> = Cell::new(0));\n+        let id = FAKE_DEF_ID_COUNTER.with(|id| {\n+            let tmp = id.get();\n+            id.set(tmp + 1);\n+            tmp\n+        });\n+        Self::Fake(DefIndex::from(id), krate)\n+    }\n+\n+    crate fn new_real(id: DefId) -> Self {\n+        Self::Real(id)\n+    }\n+\n+    #[inline]\n+    crate fn is_local(self) -> bool {\n+        match self {\n+            FakeDefId::Real(id) => id.is_local(),\n+            FakeDefId::Fake(_, krate) => krate == LOCAL_CRATE,\n+        }\n+    }\n+\n+    #[inline]\n+    crate fn as_local(self) -> Option<LocalDefId> {\n+        match self {\n+            FakeDefId::Real(id) => id.as_local(),\n+            FakeDefId::Fake(idx, krate) => {\n+                (krate == LOCAL_CRATE).then(|| LocalDefId { local_def_index: idx })\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    crate fn expect_local(self) -> LocalDefId {\n+        self.as_local()\n+            .unwrap_or_else(|| panic!(\"FakeDefId::expect_local: `{:?}` isn't local\", self))\n+    }\n+\n+    #[inline]\n+    crate fn expect_real(self) -> rustc_hir::def_id::DefId {\n+        self.as_real().unwrap_or_else(|| panic!(\"FakeDefId::expect_real: `{:?}` isn't real\", self))\n+    }\n+\n+    #[inline]\n+    crate fn as_real(self) -> Option<DefId> {\n+        match self {\n+            FakeDefId::Real(id) => Some(id),\n+            FakeDefId::Fake(_, _) => None,\n+        }\n+    }\n+\n+    #[inline]\n+    crate fn krate(self) -> CrateNum {\n+        match self {\n+            FakeDefId::Real(id) => id.krate,\n+            FakeDefId::Fake(_, krate) => krate,\n+        }\n+    }\n+\n+    #[inline]\n+    crate fn index(self) -> Option<DefIndex> {\n+        match self {\n+            FakeDefId::Real(id) => Some(id.index),\n+            FakeDefId::Fake(_, _) => None,\n+        }\n+    }\n+}\n+\n+impl From<DefId> for FakeDefId {\n+    fn from(id: DefId) -> Self {\n+        Self::Real(id)\n+    }\n+}\n \n #[derive(Clone, Debug)]\n crate struct Crate {\n@@ -261,7 +347,7 @@ impl ExternalCrate {\n /// Anything with a source location and set of attributes and, optionally, a\n /// name. That is, anything that can be documented. This doesn't correspond\n /// directly to the AST's concept of an item; it's a strict superset.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n crate struct Item {\n     /// The name of this item.\n     /// Optional because not every item has a name, e.g. impls.\n@@ -271,7 +357,7 @@ crate struct Item {\n     /// Information about this item that is specific to what kind of item it is.\n     /// E.g., struct vs enum vs function.\n     crate kind: Box<ItemKind>,\n-    crate def_id: DefId,\n+    crate def_id: FakeDefId,\n \n     crate cfg: Option<Arc<Cfg>>,\n }\n@@ -280,21 +366,6 @@ crate struct Item {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Item, 48);\n \n-impl fmt::Debug for Item {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let def_id: &dyn fmt::Debug = if self.is_fake() { &\"**FAKE**\" } else { &self.def_id };\n-\n-        fmt.debug_struct(\"Item\")\n-            .field(\"name\", &self.name)\n-            .field(\"attrs\", &self.attrs)\n-            .field(\"kind\", &self.kind)\n-            .field(\"visibility\", &self.visibility)\n-            .field(\"def_id\", def_id)\n-            .field(\"cfg\", &self.cfg)\n-            .finish()\n-    }\n-}\n-\n crate fn rustc_span(def_id: DefId, tcx: TyCtxt<'_>) -> Span {\n     Span::from_rustc_span(def_id.as_local().map_or_else(\n         || tcx.def_span(def_id),\n@@ -307,19 +378,19 @@ crate fn rustc_span(def_id: DefId, tcx: TyCtxt<'_>) -> Span {\n \n impl Item {\n     crate fn stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<&'tcx Stability> {\n-        if self.is_fake() { None } else { tcx.lookup_stability(self.def_id) }\n+        if self.is_fake() { None } else { tcx.lookup_stability(self.def_id.expect_real()) }\n     }\n \n     crate fn const_stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<&'tcx ConstStability> {\n-        if self.is_fake() { None } else { tcx.lookup_const_stability(self.def_id) }\n+        if self.is_fake() { None } else { tcx.lookup_const_stability(self.def_id.expect_real()) }\n     }\n \n     crate fn deprecation(&self, tcx: TyCtxt<'_>) -> Option<Deprecation> {\n-        if self.is_fake() { None } else { tcx.lookup_deprecation(self.def_id) }\n+        if self.is_fake() { None } else { tcx.lookup_deprecation(self.def_id.expect_real()) }\n     }\n \n     crate fn inner_docs(&self, tcx: TyCtxt<'_>) -> bool {\n-        if self.is_fake() { false } else { tcx.get_attrs(self.def_id).inner_docs() }\n+        if self.is_fake() { false } else { tcx.get_attrs(self.def_id.expect_real()).inner_docs() }\n     }\n \n     crate fn span(&self, tcx: TyCtxt<'_>) -> Span {\n@@ -334,7 +405,7 @@ impl Item {\n         } else if self.is_fake() {\n             Span::dummy()\n         } else {\n-            rustc_span(self.def_id, tcx)\n+            rustc_span(self.def_id.expect_real(), tcx)\n         }\n     }\n \n@@ -388,7 +459,7 @@ impl Item {\n         debug!(\"name={:?}, def_id={:?}\", name, def_id);\n \n         Item {\n-            def_id,\n+            def_id: def_id.into(),\n             kind: box kind,\n             name,\n             attrs,\n@@ -412,9 +483,9 @@ impl Item {\n             .map_or(&[][..], |v| v.as_slice())\n             .iter()\n             .filter_map(|ItemLink { link: s, link_text, did, ref fragment }| {\n-                match *did {\n+                match did {\n                     Some(did) => {\n-                        if let Some((mut href, ..)) = href(did, cx) {\n+                        if let Some((mut href, ..)) = href(did.expect_real(), cx) {\n                             if let Some(ref fragment) = *fragment {\n                                 href.push('#');\n                                 href.push_str(fragment);\n@@ -433,8 +504,8 @@ impl Item {\n                     None => {\n                         let relative_to = &cx.current;\n                         if let Some(ref fragment) = *fragment {\n-                            let url = match cx.cache().extern_locations.get(&self.def_id.krate) {\n-                                Some(ExternalLocation::Local) => {\n+                            let url = match cx.cache().extern_locations.get(&self.def_id.krate()) {\n+                                Some(&ExternalLocation::Local) => {\n                                     if relative_to[0] == \"std\" {\n                                         let depth = relative_to.len() - 1;\n                                         \"../\".repeat(depth)\n@@ -473,7 +544,7 @@ impl Item {\n     }\n \n     crate fn is_crate(&self) -> bool {\n-        self.is_mod() && self.def_id.index == CRATE_DEF_INDEX\n+        self.is_mod() && self.def_id.as_real().map_or(false, |did| did.index == CRATE_DEF_INDEX)\n     }\n \n     crate fn is_mod(&self) -> bool {\n@@ -586,13 +657,8 @@ impl Item {\n         }\n     }\n \n-    /// See the documentation for [`next_def_id()`].\n-    ///\n-    /// [`next_def_id()`]: DocContext::next_def_id()\n     crate fn is_fake(&self) -> bool {\n-        MAX_DEF_IDX.with(|m| {\n-            m.borrow().get(&self.def_id.krate).map(|&idx| idx <= self.def_id.index).unwrap_or(false)\n-        })\n+        matches!(self.def_id, FakeDefId::Fake(_, _))\n     }\n }\n \n@@ -911,7 +977,7 @@ crate struct ItemLink {\n     /// This may not be the same as `link` if there was a disambiguator\n     /// in an intra-doc link (e.g. \\[`fn@f`\\])\n     pub(crate) link_text: String,\n-    pub(crate) did: Option<DefId>,\n+    pub(crate) did: Option<FakeDefId>,\n     /// The url fragment to append to the link\n     pub(crate) fragment: Option<String>,\n }\n@@ -1032,7 +1098,7 @@ impl Attributes {\n             }\n         }\n \n-        let clean_attr = |(attr, parent_module): (&ast::Attribute, _)| {\n+        let clean_attr = |(attr, parent_module): (&ast::Attribute, Option<DefId>)| {\n             if let Some(value) = attr.doc_str() {\n                 trace!(\"got doc_str={:?}\", value);\n                 let value = beautify_doc_string(value);\n@@ -1652,7 +1718,7 @@ impl Type {\n impl Type {\n     fn inner_def_id(&self, cache: Option<&Cache>) -> Option<DefId> {\n         let t: PrimitiveType = match *self {\n-            ResolvedPath { did, .. } => return Some(did),\n+            ResolvedPath { did, .. } => return Some(did.into()),\n             Primitive(p) => return cache.and_then(|c| c.primitive_locations.get(&p).cloned()),\n             BorrowedRef { type_: box Generic(..), .. } => PrimitiveType::Reference,\n             BorrowedRef { ref type_, .. } => return type_.inner_def_id(cache),"}, {"sha": "7235217e290407f646e1feeb1f3b72944af48782", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -48,9 +48,9 @@ crate fn krate(cx: &mut DocContext<'_>) -> Crate {\n                 // `#[doc(masked)]` to the injected `extern crate` because it's unstable.\n                 if it.is_extern_crate()\n                     && (it.attrs.has_doc_flag(sym::masked)\n-                        || cx.tcx.is_compiler_builtins(it.def_id.krate))\n+                        || cx.tcx.is_compiler_builtins(it.def_id.krate()))\n                 {\n-                    cx.cache.masked_crates.insert(it.def_id.krate);\n+                    cx.cache.masked_crates.insert(it.def_id.krate());\n                 }\n             }\n         }\n@@ -509,8 +509,6 @@ where\n }\n \n /// Find the nearest parent module of a [`DefId`].\n-///\n-/// **Panics if the item it belongs to [is fake][Item::is_fake].**\n crate fn find_nearest_parent_module(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     if def_id.is_top_level_module() {\n         // The crate root has no parent. Use it as the root instead."}, {"sha": "b0d163763b4bd249178bcb85ccbfa5786ec029d3", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 12, "deletions": 56, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -6,7 +6,7 @@ use rustc_errors::emitter::{Emitter, EmitterWriter};\n use rustc_errors::json::JsonEmitter;\n use rustc_feature::UnstableFeatures;\n use rustc_hir::def::Res;\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::HirId;\n use rustc_hir::{\n     intravisit::{self, NestedVisitorMap, Visitor},\n@@ -26,13 +26,11 @@ use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n use std::cell::RefCell;\n-use std::collections::hash_map::Entry;\n use std::mem;\n use std::rc::Rc;\n \n-use crate::clean;\n use crate::clean::inline::build_external_trait;\n-use crate::clean::{TraitWithExtraInfo, MAX_DEF_IDX};\n+use crate::clean::{self, FakeDefId, TraitWithExtraInfo};\n use crate::config::{Options as RustdocOptions, OutputFormat, RenderOptions};\n use crate::formats::cache::Cache;\n use crate::passes::{self, Condition::*, ConditionalPass};\n@@ -66,7 +64,6 @@ crate struct DocContext<'tcx> {\n     crate ct_substs: FxHashMap<DefId, clean::Constant>,\n     /// Table synthetic type parameter for `impl Trait` in argument position -> bounds\n     crate impl_trait_bounds: FxHashMap<ImplTraitParam, Vec<clean::GenericBound>>,\n-    crate fake_def_ids: FxHashMap<CrateNum, DefIndex>,\n     /// Auto-trait or blanket impls processed so far, as `(self_ty, trait_def_id)`.\n     // FIXME(eddyb) make this a `ty::TraitRef<'tcx>` set.\n     crate generated_synthetics: FxHashSet<(Ty<'tcx>, DefId)>,\n@@ -81,7 +78,7 @@ crate struct DocContext<'tcx> {\n     /// This same cache is used throughout rustdoc, including in [`crate::html::render`].\n     crate cache: Cache,\n     /// Used by [`clean::inline`] to tell if an item has already been inlined.\n-    crate inlined: FxHashSet<DefId>,\n+    crate inlined: FxHashSet<FakeDefId>,\n     /// Used by `calculate_doc_coverage`.\n     crate output_format: OutputFormat,\n }\n@@ -129,54 +126,14 @@ impl<'tcx> DocContext<'tcx> {\n         r\n     }\n \n-    /// Create a new \"fake\" [`DefId`].\n-    ///\n-    /// This is an ugly hack, but it's the simplest way to handle synthetic impls without greatly\n-    /// refactoring either rustdoc or [`rustc_middle`]. In particular, allowing new [`DefId`]s\n-    /// to be registered after the AST is constructed would require storing the [`DefId`] mapping\n-    /// in a [`RefCell`], decreasing the performance for normal compilation for very little gain.\n-    ///\n-    /// Instead, we construct \"fake\" [`DefId`]s, which start immediately after the last `DefId`.\n-    /// In the [`Debug`] impl for [`clean::Item`], we explicitly check for fake `DefId`s,\n-    /// as we'll end up with a panic if we use the `DefId` `Debug` impl for fake `DefId`s.\n-    ///\n-    /// [`RefCell`]: std::cell::RefCell\n-    /// [`Debug`]: std::fmt::Debug\n-    /// [`clean::Item`]: crate::clean::types::Item\n-    crate fn next_def_id(&mut self, crate_num: CrateNum) -> DefId {\n-        let def_index = match self.fake_def_ids.entry(crate_num) {\n-            Entry::Vacant(e) => {\n-                let num_def_idx = {\n-                    let num_def_idx = if crate_num == LOCAL_CRATE {\n-                        self.tcx.hir().definitions().def_path_table().num_def_ids()\n-                    } else {\n-                        self.resolver.borrow_mut().access(|r| r.cstore().num_def_ids(crate_num))\n-                    };\n-\n-                    DefIndex::from_usize(num_def_idx)\n-                };\n-\n-                MAX_DEF_IDX.with(|m| {\n-                    m.borrow_mut().insert(crate_num, num_def_idx);\n-                });\n-                e.insert(num_def_idx)\n-            }\n-            Entry::Occupied(e) => e.into_mut(),\n-        };\n-        *def_index = *def_index + 1;\n-\n-        DefId { krate: crate_num, index: *def_index }\n-    }\n-\n     /// Like `hir().local_def_id_to_hir_id()`, but skips calling it on fake DefIds.\n     /// (This avoids a slice-index-out-of-bounds panic.)\n-    crate fn as_local_hir_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<HirId> {\n-        if MAX_DEF_IDX.with(|m| {\n-            m.borrow().get(&def_id.krate).map(|&idx| idx <= def_id.index).unwrap_or(false)\n-        }) {\n-            None\n-        } else {\n-            def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n+    crate fn as_local_hir_id(tcx: TyCtxt<'_>, def_id: FakeDefId) -> Option<HirId> {\n+        match def_id {\n+            FakeDefId::Real(real_id) => {\n+                real_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n+            }\n+            FakeDefId::Fake(_, _) => None,\n         }\n     }\n }\n@@ -419,7 +376,6 @@ crate fn run_global_ctxt(\n         lt_substs: Default::default(),\n         ct_substs: Default::default(),\n         impl_trait_bounds: Default::default(),\n-        fake_def_ids: Default::default(),\n         generated_synthetics: Default::default(),\n         auto_traits: tcx\n             .all_traits(LOCAL_CRATE)\n@@ -630,12 +586,12 @@ impl<'tcx> Visitor<'tcx> for EmitIgnoredResolutionErrors<'tcx> {\n /// for `impl Trait` in argument position.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n crate enum ImplTraitParam {\n-    DefId(DefId),\n+    DefId(FakeDefId),\n     ParamIndex(u32),\n }\n \n-impl From<DefId> for ImplTraitParam {\n-    fn from(did: DefId) -> Self {\n+impl From<FakeDefId> for ImplTraitParam {\n+    fn from(did: FakeDefId) -> Self {\n         ImplTraitParam::DefId(did)\n     }\n }"}, {"sha": "50496f320096cf32a47c8159b460b41cdd665a6e", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n \n-use crate::clean::{self, GetDefId};\n+use crate::clean::{self, FakeDefId, GetDefId};\n use crate::fold::DocFolder;\n use crate::formats::item_type::ItemType;\n use crate::formats::Impl;\n@@ -67,7 +67,7 @@ crate struct Cache {\n     /// When rendering traits, it's often useful to be able to list all\n     /// implementors of the trait, and this mapping is exactly, that: a mapping\n     /// of trait ids to the list of known implementors of the trait\n-    crate implementors: FxHashMap<DefId, Vec<Impl>>,\n+    crate implementors: FxHashMap<FakeDefId, Vec<Impl>>,\n \n     /// Cache of where external crate documentation can be found.\n     crate extern_locations: FxHashMap<CrateNum, ExternalLocation>,\n@@ -122,7 +122,7 @@ crate struct Cache {\n     /// All intra-doc links resolved so far.\n     ///\n     /// Links are indexed by the DefId of the item they document.\n-    crate intra_doc_links: BTreeMap<DefId, Vec<clean::ItemLink>>,\n+    crate intra_doc_links: BTreeMap<FakeDefId, Vec<clean::ItemLink>>,\n }\n \n /// This struct is used to wrap the `cache` and `tcx` in order to run `DocFolder`.\n@@ -205,7 +205,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         // If the impl is from a masked crate or references something from a\n         // masked crate then remove it completely.\n         if let clean::ImplItem(ref i) = *item.kind {\n-            if self.cache.masked_crates.contains(&item.def_id.krate)\n+            if self.cache.masked_crates.contains(&item.def_id.krate())\n                 || i.trait_.def_id().map_or(false, |d| self.cache.masked_crates.contains(&d.krate))\n                 || i.for_.def_id().map_or(false, |d| self.cache.masked_crates.contains(&d.krate))\n             {\n@@ -216,9 +216,11 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         // Propagate a trait method's documentation to all implementors of the\n         // trait.\n         if let clean::TraitItem(ref t) = *item.kind {\n-            self.cache.traits.entry(item.def_id).or_insert_with(|| clean::TraitWithExtraInfo {\n-                trait_: t.clone(),\n-                is_notable: item.attrs.has_doc_flag(sym::notable_trait),\n+            self.cache.traits.entry(item.def_id.expect_real()).or_insert_with(|| {\n+                clean::TraitWithExtraInfo {\n+                    trait_: t.clone(),\n+                    is_notable: item.attrs.has_doc_flag(sym::notable_trait),\n+                }\n             });\n         }\n \n@@ -228,7 +230,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                 if i.blanket_impl.is_none() {\n                     self.cache\n                         .implementors\n-                        .entry(did)\n+                        .entry(did.into())\n                         .or_default()\n                         .push(Impl { impl_item: item.clone() });\n                 }\n@@ -289,15 +291,15 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                     // A crate has a module at its root, containing all items,\n                     // which should not be indexed. The crate-item itself is\n                     // inserted later on when serializing the search-index.\n-                    if item.def_id.index != CRATE_DEF_INDEX {\n+                    if item.def_id.index().map_or(false, |idx| idx != CRATE_DEF_INDEX) {\n                         self.cache.search_index.push(IndexItem {\n                             ty: item.type_(),\n                             name: s.to_string(),\n                             path: path.join(\"::\"),\n                             desc: item\n                                 .doc_value()\n                                 .map_or_else(String::new, |x| short_markdown_summary(&x.as_str())),\n-                            parent,\n+                            parent: parent.map(FakeDefId::new_real),\n                             parent_idx: None,\n                             search_type: get_index_search_type(&item, &self.empty_cache, self.tcx),\n                             aliases: item.attrs.get_doc_aliases(),\n@@ -346,17 +348,20 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                     // `public_items` map, so we can skip inserting into the\n                     // paths map if there was already an entry present and we're\n                     // not a public item.\n-                    if !self.cache.paths.contains_key(&item.def_id)\n-                        || self.cache.access_levels.is_public(item.def_id)\n+                    if !self.cache.paths.contains_key(&item.def_id.expect_real())\n+                        || self.cache.access_levels.is_public(item.def_id.expect_real())\n                     {\n-                        self.cache\n-                            .paths\n-                            .insert(item.def_id, (self.cache.stack.clone(), item.type_()));\n+                        self.cache.paths.insert(\n+                            item.def_id.expect_real(),\n+                            (self.cache.stack.clone(), item.type_()),\n+                        );\n                     }\n                 }\n             }\n             clean::PrimitiveItem(..) => {\n-                self.cache.paths.insert(item.def_id, (self.cache.stack.clone(), item.type_()));\n+                self.cache\n+                    .paths\n+                    .insert(item.def_id.expect_real(), (self.cache.stack.clone(), item.type_()));\n             }\n \n             clean::ExternCrateItem { .. }\n@@ -386,7 +391,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             | clean::StructItem(..)\n             | clean::UnionItem(..)\n             | clean::VariantItem(..) => {\n-                self.cache.parent_stack.push(item.def_id);\n+                self.cache.parent_stack.push(item.def_id.expect_real());\n                 self.cache.parent_is_trait_impl = false;\n                 true\n             }"}, {"sha": "6060b0560cf3c4669c3b7424684133389f48c412", "filename": "src/librustdoc/formats/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fformats%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fformats%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fmod.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -2,9 +2,9 @@ crate mod cache;\n crate mod item_type;\n crate mod renderer;\n \n-crate use renderer::{run_format, FormatRenderer};\n+use rustc_hir::def_id::DefId;\n \n-use rustc_span::def_id::DefId;\n+crate use renderer::{run_format, FormatRenderer};\n \n use crate::clean;\n use crate::clean::types::GetDefId;"}, {"sha": "fa57c9bda74da6492f30051969029e19ad2b7f39", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -12,11 +12,14 @@ use std::iter;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::def_id::{DefId, CRATE_DEF_INDEX};\n+use rustc_span::def_id::CRATE_DEF_INDEX;\n use rustc_target::spec::abi::Abi;\n \n-use crate::clean::{self, utils::find_nearest_parent_module, ExternalCrate, PrimitiveType};\n+use crate::clean::{\n+    self, utils::find_nearest_parent_module, ExternalCrate, FakeDefId, PrimitiveType,\n+};\n use crate::formats::item_type::ItemType;\n use crate::html::escape::Escape;\n use crate::html::render::cache::ExternalLocation;\n@@ -637,7 +640,7 @@ crate fn anchor<'a, 'cx: 'a>(\n     text: &'a str,\n     cx: &'cx Context<'_>,\n ) -> impl fmt::Display + 'a {\n-    let parts = href(did, cx);\n+    let parts = href(did.into(), cx);\n     display_fn(move |f| {\n         if let Some((url, short_ty, fqp)) = parts {\n             write!(\n@@ -865,7 +868,7 @@ fn fmt_type<'cx>(\n                 //        everything comes in as a fully resolved QPath (hard to\n                 //        look at).\n                 box clean::ResolvedPath { did, ref param_names, .. } => {\n-                    match href(did, cx) {\n+                    match href(did.into(), cx) {\n                         Some((ref url, _, ref path)) if !f.alternate() => {\n                             write!(\n                                 f,\n@@ -1143,7 +1146,7 @@ impl clean::FnDecl {\n impl clean::Visibility {\n     crate fn print_with_space<'a, 'tcx: 'a>(\n         self,\n-        item_did: DefId,\n+        item_did: FakeDefId,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         let to_print = match self {\n@@ -1153,7 +1156,7 @@ impl clean::Visibility {\n                 // FIXME(camelid): This may not work correctly if `item_did` is a module.\n                 //                 However, rustdoc currently never displays a module's\n                 //                 visibility, so it shouldn't matter.\n-                let parent_module = find_nearest_parent_module(cx.tcx(), item_did);\n+                let parent_module = find_nearest_parent_module(cx.tcx(), item_did.expect_real());\n \n                 if vis_did.index == CRATE_DEF_INDEX {\n                     \"pub(crate) \".to_owned()"}, {"sha": "57520a1a1fb46f769b0ccb4449855e6e2cd592fb", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -7,7 +7,7 @@ use serde::ser::{Serialize, SerializeStruct, Serializer};\n \n use crate::clean;\n use crate::clean::types::{\n-    FnDecl, FnRetTy, GenericBound, Generics, GetDefId, Type, WherePredicate,\n+    FakeDefId, FnDecl, FnRetTy, GenericBound, Generics, GetDefId, Type, WherePredicate,\n };\n use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n@@ -39,7 +39,7 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n                 name: item.name.unwrap().to_string(),\n                 path: fqp[..fqp.len() - 1].join(\"::\"),\n                 desc: item.doc_value().map_or_else(String::new, |s| short_markdown_summary(&s)),\n-                parent: Some(did),\n+                parent: Some(did.into()),\n                 parent_idx: None,\n                 search_type: get_index_search_type(&item, cache, tcx),\n                 aliases: item.attrs.get_doc_aliases(),\n@@ -82,7 +82,7 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n                 defid_to_pathid.insert(defid, pathid);\n                 lastpathid += 1;\n \n-                if let Some(&(ref fqp, short)) = paths.get(&defid) {\n+                if let Some(&(ref fqp, short)) = paths.get(&defid.expect_real()) {\n                     crate_paths.push((short, fqp.last().unwrap().clone()));\n                     Some(pathid)\n                 } else {\n@@ -214,7 +214,7 @@ crate fn get_index_search_type<'tcx>(\n \n fn get_index_type(clean_type: &clean::Type, cache: &Cache) -> RenderType {\n     RenderType {\n-        ty: clean_type.def_id_full(cache),\n+        ty: clean_type.def_id_full(cache).map(FakeDefId::new_real),\n         idx: None,\n         name: get_index_type_name(clean_type, true).map(|s| s.as_str().to_ascii_lowercase()),\n         generics: get_generics(clean_type, cache),\n@@ -256,7 +256,7 @@ fn get_generics(clean_type: &clean::Type, cache: &Cache) -> Option<Vec<Generic>>\n             .filter_map(|t| {\n                 get_index_type_name(t, false).map(|name| Generic {\n                     name: name.as_str().to_ascii_lowercase(),\n-                    defid: t.def_id_full(cache),\n+                    defid: t.def_id_full(cache).map(FakeDefId::new_real),\n                     idx: None,\n                 })\n             })"}, {"sha": "2f3f87215c3a1343588b7340d4274c5a513371af", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -18,7 +18,8 @@ use super::print_item::{full_path, item_path, print_item};\n use super::write_shared::write_shared;\n use super::{print_sidebar, settings, AllTypes, NameDoc, StylePath, BASIC_KEYWORDS};\n \n-use crate::clean::{self, ExternalCrate};\n+use crate::clean;\n+use crate::clean::ExternalCrate;\n use crate::config::RenderOptions;\n use crate::docfs::{DocFS, PathError};\n use crate::error::Error;\n@@ -218,7 +219,7 @@ impl<'tcx> Context<'tcx> {\n                 &self.shared.style_files,\n             )\n         } else {\n-            if let Some(&(ref names, ty)) = self.cache.paths.get(&it.def_id) {\n+            if let Some(&(ref names, ty)) = self.cache.paths.get(&it.def_id.expect_real()) {\n                 let mut path = String::new();\n                 for name in &names[..names.len() - 1] {\n                     path.push_str(name);"}, {"sha": "ea57831c0e5de07248c58858bdadb6f60f0422ce", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -54,7 +54,7 @@ use rustc_span::symbol::{kw, sym, Symbol};\n use serde::ser::SerializeSeq;\n use serde::{Serialize, Serializer};\n \n-use crate::clean::{self, GetDefId, RenderedLink, SelfTy};\n+use crate::clean::{self, FakeDefId, GetDefId, RenderedLink, SelfTy};\n use crate::docfs::PathError;\n use crate::error::Error;\n use crate::formats::cache::Cache;\n@@ -87,7 +87,7 @@ crate struct IndexItem {\n     crate name: String,\n     crate path: String,\n     crate desc: String,\n-    crate parent: Option<DefId>,\n+    crate parent: Option<FakeDefId>,\n     crate parent_idx: Option<usize>,\n     crate search_type: Option<IndexItemFunctionType>,\n     crate aliases: Box<[String]>,\n@@ -96,7 +96,7 @@ crate struct IndexItem {\n /// A type used for the search index.\n #[derive(Debug)]\n crate struct RenderType {\n-    ty: Option<DefId>,\n+    ty: Option<FakeDefId>,\n     idx: Option<usize>,\n     name: Option<String>,\n     generics: Option<Vec<Generic>>,\n@@ -128,7 +128,7 @@ impl Serialize for RenderType {\n #[derive(Debug)]\n crate struct Generic {\n     name: String,\n-    defid: Option<DefId>,\n+    defid: Option<FakeDefId>,\n     idx: Option<usize>,\n }\n \n@@ -709,7 +709,7 @@ fn render_impls(\n         .map(|i| {\n             let did = i.trait_did_full(cache).unwrap();\n             let provided_trait_methods = i.inner_impl().provided_trait_methods(tcx);\n-            let assoc_link = AssocItemLink::GotoSource(did, &provided_trait_methods);\n+            let assoc_link = AssocItemLink::GotoSource(did.into(), &provided_trait_methods);\n             let mut buffer = if w.is_for_html() { Buffer::html() } else { Buffer::new() };\n             render_impl(\n                 &mut buffer,\n@@ -747,7 +747,7 @@ fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>, cx: &Context<'_>)\n         AssocItemLink::Anchor(Some(ref id)) => format!(\"#{}\", id),\n         AssocItemLink::Anchor(None) => anchor,\n         AssocItemLink::GotoSource(did, _) => {\n-            href(did, cx).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n+            href(did.expect_real(), cx).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n         }\n     }\n }\n@@ -855,7 +855,7 @@ fn render_assoc_item(\n                     ItemType::TyMethod\n                 };\n \n-                href(did, cx)\n+                href(did.expect_real(), cx)\n                     .map(|p| format!(\"{}#{}.{}\", p.0, ty, name))\n                     .unwrap_or_else(|| format!(\"#{}.{}\", ty, name))\n             }\n@@ -979,7 +979,7 @@ fn render_attributes_in_code(w: &mut Buffer, it: &clean::Item) {\n #[derive(Copy, Clone)]\n enum AssocItemLink<'a> {\n     Anchor(Option<&'a str>),\n-    GotoSource(DefId, &'a FxHashSet<Symbol>),\n+    GotoSource(FakeDefId, &'a FxHashSet<Symbol>),\n }\n \n impl<'a> AssocItemLink<'a> {\n@@ -1217,7 +1217,7 @@ fn notable_traits_decl(decl: &clean::FnDecl, cx: &Context<'_>) -> String {\n                                 it,\n                                 &[],\n                                 Some(&tydef.type_),\n-                                AssocItemLink::GotoSource(t_did, &FxHashSet::default()),\n+                                AssocItemLink::GotoSource(t_did.into(), &FxHashSet::default()),\n                                 \"\",\n                                 cx,\n                             );\n@@ -1476,7 +1476,7 @@ fn render_impl(\n             }\n             let did = i.trait_.as_ref().unwrap().def_id_full(cx.cache()).unwrap();\n             let provided_methods = i.provided_trait_methods(cx.tcx());\n-            let assoc_link = AssocItemLink::GotoSource(did, &provided_methods);\n+            let assoc_link = AssocItemLink::GotoSource(did.into(), &provided_methods);\n \n             doc_impl_item(\n                 boring,\n@@ -1810,7 +1810,8 @@ fn small_url_encode(s: String) -> String {\n }\n \n fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n-    if let Some(v) = cx.cache.impls.get(&it.def_id) {\n+    let did = it.def_id.expect_real();\n+    if let Some(v) = cx.cache.impls.get(&did) {\n         let mut used_links = FxHashSet::default();\n         let cache = cx.cache();\n "}, {"sha": "70b5458ece89467e07c16ead66ccc2abd5c68797", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -270,14 +270,18 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                         w,\n                         \"<tr><td><code>{}extern crate {} as {};\",\n                         myitem.visibility.print_with_space(myitem.def_id, cx),\n-                        anchor(myitem.def_id, &*src.as_str(), cx),\n+                        anchor(myitem.def_id.expect_real(), &*src.as_str(), cx),\n                         myitem.name.as_ref().unwrap(),\n                     ),\n                     None => write!(\n                         w,\n                         \"<tr><td><code>{}extern crate {};\",\n                         myitem.visibility.print_with_space(myitem.def_id, cx),\n-                        anchor(myitem.def_id, &*myitem.name.as_ref().unwrap().as_str(), cx),\n+                        anchor(\n+                            myitem.def_id.expect_real(),\n+                            &*myitem.name.as_ref().unwrap().as_str(),\n+                            cx\n+                        ),\n                     ),\n                 }\n                 w.write_str(\"</code></td></tr>\");\n@@ -290,7 +294,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n \n                     // Just need an item with the correct def_id and attrs\n                     let import_item = clean::Item {\n-                        def_id: import_def_id,\n+                        def_id: import_def_id.into(),\n                         attrs: import_attrs,\n                         cfg: ast_attrs.cfg(cx.tcx().sess.diagnostic()),\n                         ..myitem.clone()\n@@ -629,7 +633,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All);\n+    render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All);\n \n     if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n         // The DefId is for the first Type found with that name. The bool is\n@@ -752,7 +756,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         path = if it.def_id.is_local() {\n             cx.current.join(\"/\")\n         } else {\n-            let (ref path, _) = cx.cache.external_paths[&it.def_id];\n+            let (ref path, _) = cx.cache.external_paths[&it.def_id.expect_real()];\n             path[..path.len() - 1].join(\"/\")\n         },\n         ty = it.type_(),\n@@ -778,7 +782,7 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clea\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All)\n }\n \n fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::OpaqueTy) {\n@@ -799,7 +803,7 @@ fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean:\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All)\n }\n \n fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n@@ -820,7 +824,7 @@ fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::T\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All)\n }\n \n fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Union) {\n@@ -866,7 +870,7 @@ fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Uni\n             document(w, cx, field, Some(it));\n         }\n     }\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All)\n }\n \n fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum) {\n@@ -1000,7 +1004,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n             render_stability_since(w, variant, it, cx.tcx());\n         }\n     }\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All)\n }\n \n fn item_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Macro) {\n@@ -1049,7 +1053,7 @@ fn item_proc_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, m: &clean\n \n fn item_primitive(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n     document(w, cx, it, None);\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All)\n }\n \n fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::Constant) {\n@@ -1137,7 +1141,7 @@ fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n             }\n         }\n     }\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All)\n }\n \n fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Static) {\n@@ -1166,7 +1170,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n \n     document(w, cx, it, None);\n \n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All)\n }\n \n fn item_keyword(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {"}, {"sha": "c493801d9907fa79666cce98493511a92623b8fd", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -464,6 +464,8 @@ pub(super) fn write_shared(\n     // Update the list of all implementors for traits\n     let dst = cx.dst.join(\"implementors\");\n     for (&did, imps) in &cx.cache.implementors {\n+        let did = did.expect_real();\n+\n         // Private modules can leak through to this phase of rustdoc, which\n         // could contain implementations for otherwise private types. In some\n         // rare cases we could find an implementation for an item which wasn't\n@@ -496,7 +498,7 @@ pub(super) fn write_shared(\n                 //\n                 // If the implementation is from another crate then that crate\n                 // should add it.\n-                if imp.impl_item.def_id.krate == did.krate || !imp.impl_item.def_id.is_local() {\n+                if imp.impl_item.def_id.krate() == did.krate || !imp.impl_item.def_id.is_local() {\n                     None\n                 } else {\n                     Some(Implementor {"}, {"sha": "e3f1c6b1e2dc4ecf34483e54b190dd4b0aff5ef4", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -9,13 +9,14 @@ use std::convert::From;\n use rustc_ast::ast;\n use rustc_hir::def::CtorKind;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::def_id::{DefId, CRATE_DEF_INDEX};\n+use rustc_span::def_id::CRATE_DEF_INDEX;\n use rustc_span::Pos;\n \n use rustdoc_json_types::*;\n \n use crate::clean;\n use crate::clean::utils::print_const_expr;\n+use crate::clean::FakeDefId;\n use crate::formats::item_type::ItemType;\n use crate::json::JsonRenderer;\n use std::collections::HashSet;\n@@ -48,7 +49,7 @@ impl JsonRenderer<'_> {\n         };\n         Some(Item {\n             id: from_def_id(def_id),\n-            crate_id: def_id.krate.as_u32(),\n+            crate_id: def_id.krate().as_u32(),\n             name: name.map(|sym| sym.to_string()),\n             span: self.convert_span(span),\n             visibility: self.convert_visibility(visibility),\n@@ -87,7 +88,7 @@ impl JsonRenderer<'_> {\n             Inherited => Visibility::Default,\n             Restricted(did) if did.index == CRATE_DEF_INDEX => Visibility::Crate,\n             Restricted(did) => Visibility::Restricted {\n-                parent: from_def_id(did),\n+                parent: from_def_id(did.into()),\n                 path: self.tcx.def_path(did).to_string_no_crate_verbose(),\n             },\n         }\n@@ -171,8 +172,13 @@ impl FromWithTcx<clean::TypeBindingKind> for TypeBindingKind {\n     }\n }\n \n-crate fn from_def_id(did: DefId) -> Id {\n-    Id(format!(\"{}:{}\", did.krate.as_u32(), u32::from(did.index)))\n+crate fn from_def_id(did: FakeDefId) -> Id {\n+    match did {\n+        FakeDefId::Real(did) => Id(format!(\"{}:{}\", did.krate.as_u32(), u32::from(did.index))),\n+        // We need to differentiate real and fake ids, because the indices might overlap for fake\n+        // and real DefId's, which would cause two different Id's treated as they were the same.\n+        FakeDefId::Fake(idx, krate) => Id(format!(\"F{}:{}\", krate.as_u32(), u32::from(idx))),\n+    }\n }\n \n fn from_clean_item(item: clean::Item, tcx: TyCtxt<'_>) -> ItemEnum {\n@@ -368,7 +374,7 @@ impl FromWithTcx<clean::Type> for Type {\n         match ty {\n             ResolvedPath { path, param_names, did, is_generic: _ } => Type::ResolvedPath {\n                 name: path.whole_name(),\n-                id: from_def_id(did),\n+                id: from_def_id(did.into()),\n                 args: path.segments.last().map(|args| Box::new(args.clone().args.into_tcx(tcx))),\n                 param_names: param_names\n                     .map(|v| v.into_iter().map(|x| x.into_tcx(tcx)).collect())\n@@ -540,13 +546,13 @@ impl FromWithTcx<clean::Import> for Import {\n             Simple(s) => Import {\n                 source: import.source.path.whole_name(),\n                 name: s.to_string(),\n-                id: import.source.did.map(from_def_id),\n+                id: import.source.did.map(FakeDefId::from).map(from_def_id),\n                 glob: false,\n             },\n             Glob => Import {\n                 source: import.source.path.whole_name(),\n                 name: import.source.path.last_name().to_string(),\n-                id: import.source.did.map(from_def_id),\n+                id: import.source.did.map(FakeDefId::from).map(from_def_id),\n                 glob: true,\n             },\n         }"}, {"sha": "d56acad60c00f7d35884126a5db5266cb83f1e3a", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -17,7 +17,8 @@ use rustc_session::Session;\n \n use rustdoc_json_types as types;\n \n-use crate::clean::{self, ExternalCrate};\n+use crate::clean;\n+use crate::clean::{ExternalCrate, FakeDefId};\n use crate::config::RenderOptions;\n use crate::error::Error;\n use crate::formats::cache::Cache;\n@@ -41,7 +42,7 @@ impl JsonRenderer<'tcx> {\n         self.tcx.sess\n     }\n \n-    fn get_trait_implementors(&mut self, id: rustc_span::def_id::DefId) -> Vec<types::Id> {\n+    fn get_trait_implementors(&mut self, id: FakeDefId) -> Vec<types::Id> {\n         Rc::clone(&self.cache)\n             .implementors\n             .get(&id)\n@@ -58,10 +59,10 @@ impl JsonRenderer<'tcx> {\n             .unwrap_or_default()\n     }\n \n-    fn get_impls(&mut self, id: rustc_span::def_id::DefId) -> Vec<types::Id> {\n+    fn get_impls(&mut self, id: FakeDefId) -> Vec<types::Id> {\n         Rc::clone(&self.cache)\n             .impls\n-            .get(&id)\n+            .get(&id.expect_real())\n             .map(|impls| {\n                 impls\n                     .iter()\n@@ -89,9 +90,9 @@ impl JsonRenderer<'tcx> {\n                     let trait_item = &trait_item.trait_;\n                     trait_item.items.clone().into_iter().for_each(|i| self.item(i).unwrap());\n                     Some((\n-                        from_def_id(id),\n+                        from_def_id(id.into()),\n                         types::Item {\n-                            id: from_def_id(id),\n+                            id: from_def_id(id.into()),\n                             crate_id: id.krate.as_u32(),\n                             name: self\n                                 .cache\n@@ -205,7 +206,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                 .chain(self.cache.external_paths.clone().into_iter())\n                 .map(|(k, (path, kind))| {\n                     (\n-                        from_def_id(k),\n+                        from_def_id(k.into()),\n                         types::ItemSummary {\n                             crate_id: k.krate.as_u32(),\n                             path,"}, {"sha": "8d07cde51880c4c2b85090bf54ef9ea6f9fcd4b9", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -111,7 +111,11 @@ impl<'a, 'tcx> DocFolder for SyntaxChecker<'a, 'tcx> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         if let Some(dox) = &item.attrs.collapsed_doc_value() {\n             let sp = item.attr_span(self.cx.tcx);\n-            let extra = crate::html::markdown::ExtraInfo::new_did(self.cx.tcx, item.def_id, sp);\n+            let extra = crate::html::markdown::ExtraInfo::new_did(\n+                self.cx.tcx,\n+                item.def_id.expect_real(),\n+                sp,\n+            );\n             for code_block in markdown::rust_code_blocks(&dox, &extra) {\n                 self.check_rust_syntax(&item, &dox, code_block);\n             }"}, {"sha": "c5fb54e52c7c471f4ed032008f35e3e4097ad948", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 60, "deletions": 36, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -30,7 +30,9 @@ use std::convert::{TryFrom, TryInto};\n use std::mem;\n use std::ops::Range;\n \n-use crate::clean::{self, utils::find_nearest_parent_module, Crate, Item, ItemLink, PrimitiveType};\n+use crate::clean::{\n+    self, utils::find_nearest_parent_module, Crate, FakeDefId, Item, ItemLink, PrimitiveType,\n+};\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::html::markdown::{markdown_links, MarkdownLink};\n@@ -246,7 +248,7 @@ enum AnchorFailure {\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n struct ResolutionInfo {\n-    module_id: DefId,\n+    module_id: FakeDefId,\n     dis: Option<Disambiguator>,\n     path_str: String,\n     extra_fragment: Option<String>,\n@@ -272,7 +274,7 @@ struct LinkCollector<'a, 'tcx> {\n     ///\n     /// The last module will be used if the parent scope of the current item is\n     /// unknown.\n-    mod_ids: Vec<DefId>,\n+    mod_ids: Vec<FakeDefId>,\n     /// This is used to store the kind of associated items,\n     /// because `clean` and the disambiguator code expect them to be different.\n     /// See the code for associated items on inherent impls for details.\n@@ -296,7 +298,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n         let tcx = self.cx.tcx;\n         let no_res = || ResolutionFailure::NotResolved {\n-            module_id,\n+            module_id: module_id.into(),\n             partial_res: None,\n             unresolved: path_str.into(),\n         };\n@@ -524,7 +526,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     // but the disambiguator logic expects the associated item.\n                     // Store the kind in a side channel so that only the disambiguator logic looks at it.\n                     if let Some((kind, id)) = side_channel {\n-                        self.kind_side_channel.set(Some((kind, id)));\n+                        self.kind_side_channel.set(Some((kind, id.into())));\n                     }\n                     Ok((res, Some(fragment)))\n                 };\n@@ -795,7 +797,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         let parent_node = if item.is_fake() {\n             None\n         } else {\n-            find_nearest_parent_module(self.cx.tcx, item.def_id)\n+            find_nearest_parent_module(self.cx.tcx, item.def_id.expect_real())\n         };\n \n         if parent_node.is_some() {\n@@ -807,31 +809,34 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         let self_id = if item.is_fake() {\n             None\n         // Checking if the item is a field in an enum variant\n-        } else if (matches!(self.cx.tcx.def_kind(item.def_id), DefKind::Field)\n+        } else if (matches!(self.cx.tcx.def_kind(item.def_id.expect_real()), DefKind::Field)\n             && matches!(\n-                self.cx.tcx.def_kind(self.cx.tcx.parent(item.def_id).unwrap()),\n+                self.cx.tcx.def_kind(self.cx.tcx.parent(item.def_id.expect_real()).unwrap()),\n                 DefKind::Variant\n             ))\n         {\n-            self.cx.tcx.parent(item.def_id).and_then(|item_id| self.cx.tcx.parent(item_id))\n+            self.cx\n+                .tcx\n+                .parent(item.def_id.expect_real())\n+                .and_then(|item_id| self.cx.tcx.parent(item_id))\n         } else if matches!(\n-            self.cx.tcx.def_kind(item.def_id),\n+            self.cx.tcx.def_kind(item.def_id.expect_real()),\n             DefKind::AssocConst\n                 | DefKind::AssocFn\n                 | DefKind::AssocTy\n                 | DefKind::Variant\n                 | DefKind::Field\n         ) {\n-            self.cx.tcx.parent(item.def_id)\n+            self.cx.tcx.parent(item.def_id.expect_real())\n         // HACK(jynelson): `clean` marks associated types as `TypedefItem`, not as `AssocTypeItem`.\n         // Fixing this breaks `fn render_deref_methods`.\n         // As a workaround, see if the parent of the item is an `impl`; if so this must be an associated item,\n         // regardless of what rustdoc wants to call it.\n-        } else if let Some(parent) = self.cx.tcx.parent(item.def_id) {\n+        } else if let Some(parent) = self.cx.tcx.parent(item.def_id.expect_real()) {\n             let parent_kind = self.cx.tcx.def_kind(parent);\n-            Some(if parent_kind == DefKind::Impl { parent } else { item.def_id })\n+            Some(if parent_kind == DefKind::Impl { parent } else { item.def_id.expect_real() })\n         } else {\n-            Some(item.def_id)\n+            Some(item.def_id.expect_real())\n         };\n \n         // FIXME(jynelson): this shouldn't go through stringification, rustdoc should just use the DefId directly\n@@ -869,7 +874,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             let (krate, parent_node) = if let Some(id) = parent_module {\n                 (id.krate, Some(id))\n             } else {\n-                (item.def_id.krate, parent_node)\n+                (item.def_id.krate(), parent_node)\n             };\n             // NOTE: if there are links that start in one crate and end in another, this will not resolve them.\n             // This is a degenerate case and it's not supported by rustdoc.\n@@ -1065,8 +1070,11 @@ impl LinkCollector<'_, '_> {\n         // we've already pushed this node onto the resolution stack but\n         // for outer comments we explicitly try and resolve against the\n         // parent_node first.\n-        let base_node =\n-            if item.is_mod() && inner_docs { self.mod_ids.last().copied() } else { parent_node };\n+        let base_node = if item.is_mod() && inner_docs {\n+            self.mod_ids.last().copied()\n+        } else {\n+            parent_node.map(|id| FakeDefId::new_real(id))\n+        };\n \n         let mut module_id = if let Some(id) = base_node {\n             id\n@@ -1111,7 +1119,7 @@ impl LinkCollector<'_, '_> {\n                 resolved_self = format!(\"self::{}\", &path_str[\"crate::\".len()..]);\n                 path_str = &resolved_self;\n             }\n-            module_id = DefId { krate, index: CRATE_DEF_INDEX };\n+            module_id = FakeDefId::new_real(DefId { krate, index: CRATE_DEF_INDEX });\n         }\n \n         let (mut res, mut fragment) = self.resolve_with_disambiguator_cached(\n@@ -1172,8 +1180,8 @@ impl LinkCollector<'_, '_> {\n             report_diagnostic(self.cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, &diag_info, callback);\n         };\n \n-        let verify = |kind: DefKind, id: DefId| {\n-            let (kind, id) = self.kind_side_channel.take().unwrap_or((kind, id));\n+        let verify = |kind: DefKind, id: FakeDefId| {\n+            let (kind, id) = self.kind_side_channel.take().unwrap_or((kind, id.expect_real()));\n             debug!(\"intra-doc link to {} resolved to {:?} (id: {:?})\", path_str, res, id);\n \n             // Disallow e.g. linking to enums with `struct@`\n@@ -1227,7 +1235,7 @@ impl LinkCollector<'_, '_> {\n                     // doesn't allow statements like `use str::trim;`, making this a (hopefully)\n                     // valid omission. See https://github.com/rust-lang/rust/pull/80660#discussion_r551585677\n                     // for discussion on the matter.\n-                    verify(kind, id)?;\n+                    verify(kind, id.into())?;\n \n                     // FIXME: it would be nice to check that the feature gate was enabled in the original crate, not just ignore it altogether.\n                     // However I'm not sure how to check that across crates.\n@@ -1265,9 +1273,9 @@ impl LinkCollector<'_, '_> {\n                 Some(ItemLink { link: ori_link.link, link_text, did: None, fragment })\n             }\n             Res::Def(kind, id) => {\n-                verify(kind, id)?;\n+                verify(kind, id.into())?;\n                 let id = clean::register_res(self.cx, rustc_hir::def::Res::Def(kind, id));\n-                Some(ItemLink { link: ori_link.link, link_text, did: Some(id), fragment })\n+                Some(ItemLink { link: ori_link.link, link_text, did: Some(id.into()), fragment })\n             }\n         }\n     }\n@@ -1333,7 +1341,7 @@ impl LinkCollector<'_, '_> {\n \n         match disambiguator.map(Disambiguator::ns) {\n             Some(expected_ns @ (ValueNS | TypeNS)) => {\n-                match self.resolve(path_str, expected_ns, base_node, extra_fragment) {\n+                match self.resolve(path_str, expected_ns, base_node.expect_real(), extra_fragment) {\n                     Ok(res) => Some(res),\n                     Err(ErrorKind::Resolve(box mut kind)) => {\n                         // We only looked in one namespace. Try to give a better error if possible.\n@@ -1342,9 +1350,12 @@ impl LinkCollector<'_, '_> {\n                             // FIXME: really it should be `resolution_failure` that does this, not `resolve_with_disambiguator`\n                             // See https://github.com/rust-lang/rust/pull/76955#discussion_r493953382 for a good approach\n                             for &new_ns in &[other_ns, MacroNS] {\n-                                if let Some(res) =\n-                                    self.check_full_res(new_ns, path_str, base_node, extra_fragment)\n-                                {\n+                                if let Some(res) = self.check_full_res(\n+                                    new_ns,\n+                                    path_str,\n+                                    base_node.expect_real(),\n+                                    extra_fragment,\n+                                ) {\n                                     kind = ResolutionFailure::WrongNamespace { res, expected_ns };\n                                     break;\n                                 }\n@@ -1366,9 +1377,14 @@ impl LinkCollector<'_, '_> {\n                 // Try everything!\n                 let mut candidates = PerNS {\n                     macro_ns: self\n-                        .resolve_macro(path_str, base_node)\n+                        .resolve_macro(path_str, base_node.expect_real())\n                         .map(|res| (res, extra_fragment.clone())),\n-                    type_ns: match self.resolve(path_str, TypeNS, base_node, extra_fragment) {\n+                    type_ns: match self.resolve(\n+                        path_str,\n+                        TypeNS,\n+                        base_node.expect_real(),\n+                        extra_fragment,\n+                    ) {\n                         Ok(res) => {\n                             debug!(\"got res in TypeNS: {:?}\", res);\n                             Ok(res)\n@@ -1379,7 +1395,12 @@ impl LinkCollector<'_, '_> {\n                         }\n                         Err(ErrorKind::Resolve(box kind)) => Err(kind),\n                     },\n-                    value_ns: match self.resolve(path_str, ValueNS, base_node, extra_fragment) {\n+                    value_ns: match self.resolve(\n+                        path_str,\n+                        ValueNS,\n+                        base_node.expect_real(),\n+                        extra_fragment,\n+                    ) {\n                         Ok(res) => Ok(res),\n                         Err(ErrorKind::AnchorFailure(msg)) => {\n                             anchor_failure(self.cx, diag, msg);\n@@ -1421,7 +1442,7 @@ impl LinkCollector<'_, '_> {\n                 }\n \n                 if len == 1 {\n-                    Some(candidates.into_iter().filter_map(|res| res.ok()).next().unwrap())\n+                    Some(candidates.into_iter().find_map(|res| res.ok()).unwrap())\n                 } else if len == 2 && is_derive_trait_collision(&candidates) {\n                     Some(candidates.type_ns.unwrap())\n                 } else {\n@@ -1435,14 +1456,17 @@ impl LinkCollector<'_, '_> {\n                 }\n             }\n             Some(MacroNS) => {\n-                match self.resolve_macro(path_str, base_node) {\n+                match self.resolve_macro(path_str, base_node.expect_real()) {\n                     Ok(res) => Some((res, extra_fragment.clone())),\n                     Err(mut kind) => {\n                         // `resolve_macro` only looks in the macro namespace. Try to give a better error if possible.\n                         for &ns in &[TypeNS, ValueNS] {\n-                            if let Some(res) =\n-                                self.check_full_res(ns, path_str, base_node, extra_fragment)\n-                            {\n+                            if let Some(res) = self.check_full_res(\n+                                ns,\n+                                path_str,\n+                                base_node.expect_real(),\n+                                extra_fragment,\n+                            ) {\n                                 kind =\n                                     ResolutionFailure::WrongNamespace { res, expected_ns: MacroNS };\n                                 break;\n@@ -1795,7 +1819,7 @@ fn resolution_failure(\n                         name = start;\n                         for &ns in &[TypeNS, ValueNS, MacroNS] {\n                             if let Some(res) =\n-                                collector.check_full_res(ns, &start, module_id, &None)\n+                                collector.check_full_res(ns, &start, module_id.into(), &None)\n                             {\n                                 debug!(\"found partial_res={:?}\", res);\n                                 *partial_res = Some(res);"}, {"sha": "90b797da24915286fa01d122688ddd65aadcb0b3", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -46,7 +46,7 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n \n                 // FIXME(eddyb) is this `doc(hidden)` check needed?\n                 if !cx.tcx.get_attrs(def_id).lists(sym::doc).has_word(sym::hidden) {\n-                    let impls = get_auto_trait_and_blanket_impls(cx, def_id);\n+                    let impls = get_auto_trait_and_blanket_impls(cx, def_id.into());\n                     new_items.extend(impls.filter(|i| cx.inlined.insert(i.def_id)));\n                 }\n             });\n@@ -117,16 +117,16 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n                     // Avoid infinite cycles\n                     return;\n                 }\n-                cleaner.items.insert(target_did);\n-                add_deref_target(map, cleaner, &target_did);\n+                cleaner.items.insert(target_did.into());\n+                add_deref_target(map, cleaner, &target_did.into());\n             }\n         }\n     }\n     for type_did in type_did_to_deref_target.keys() {\n         // Since only the `DefId` portion of the `Type` instances is known to be same for both the\n         // `Deref` target type and the impl for type positions, this map of types is keyed by\n         // `DefId` and for convenience uses a special cleaner that accepts `DefId`s directly.\n-        if cleaner.keep_impl_with_def_id(type_did) {\n+        if cleaner.keep_impl_with_def_id(&FakeDefId::new_real(*type_did)) {\n             add_deref_target(&type_did_to_deref_target, &mut cleaner, type_did);\n         }\n     }\n@@ -163,8 +163,10 @@ impl<'a, 'tcx> DocFolder for SyntheticImplCollector<'a, 'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if i.is_struct() || i.is_enum() || i.is_union() {\n             // FIXME(eddyb) is this `doc(hidden)` check needed?\n-            if !self.cx.tcx.get_attrs(i.def_id).lists(sym::doc).has_word(sym::hidden) {\n-                self.impls.extend(get_auto_trait_and_blanket_impls(self.cx, i.def_id));\n+            if !self.cx.tcx.get_attrs(i.def_id.expect_real()).lists(sym::doc).has_word(sym::hidden)\n+            {\n+                self.impls\n+                    .extend(get_auto_trait_and_blanket_impls(self.cx, i.def_id.expect_real()));\n             }\n         }\n \n@@ -174,7 +176,7 @@ impl<'a, 'tcx> DocFolder for SyntheticImplCollector<'a, 'tcx> {\n \n #[derive(Default)]\n struct ItemCollector {\n-    items: FxHashSet<DefId>,\n+    items: FxHashSet<FakeDefId>,\n }\n \n impl ItemCollector {\n@@ -193,7 +195,7 @@ impl DocFolder for ItemCollector {\n \n struct BadImplStripper {\n     prims: FxHashSet<PrimitiveType>,\n-    items: FxHashSet<DefId>,\n+    items: FxHashSet<FakeDefId>,\n }\n \n impl BadImplStripper {\n@@ -204,13 +206,13 @@ impl BadImplStripper {\n         } else if let Some(prim) = ty.primitive_type() {\n             self.prims.contains(&prim)\n         } else if let Some(did) = ty.def_id() {\n-            self.keep_impl_with_def_id(&did)\n+            self.keep_impl_with_def_id(&did.into())\n         } else {\n             false\n         }\n     }\n \n-    fn keep_impl_with_def_id(&self, did: &DefId) -> bool {\n+    fn keep_impl_with_def_id(&self, did: &FakeDefId) -> bool {\n         self.items.contains(did)\n     }\n }"}, {"sha": "7362cfcb71b7eec1e948efb5217f3ef50f468ee9", "filename": "src/librustdoc/passes/doc_test_lints.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -53,7 +53,7 @@ impl crate::doctest::Tester for Tests {\n }\n \n crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n-    if !cx.cache.access_levels.is_public(item.def_id)\n+    if !cx.cache.access_levels.is_public(item.def_id.expect_real())\n         || matches!(\n             *item.kind,\n             clean::StructFieldItem(_)\n@@ -105,7 +105,8 @@ crate fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n                 |lint| lint.build(\"missing code example in this documentation\").emit(),\n             );\n         }\n-    } else if tests.found_tests > 0 && !cx.cache.access_levels.is_public(item.def_id) {\n+    } else if tests.found_tests > 0 && !cx.cache.access_levels.is_public(item.def_id.expect_real())\n+    {\n         cx.tcx.struct_span_lint_hir(\n             crate::lint::PRIVATE_DOC_TESTS,\n             hir_id,"}, {"sha": "e5910d081a5d017deefa791411de14e84325f296", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -1,9 +1,8 @@\n-use rustc_hir::def_id::DefIdSet;\n use rustc_span::symbol::sym;\n use std::mem;\n \n use crate::clean;\n-use crate::clean::{Item, NestedAttributesExt};\n+use crate::clean::{FakeDefIdSet, Item, NestedAttributesExt};\n use crate::core::DocContext;\n use crate::fold::{DocFolder, StripItem};\n use crate::passes::{ImplStripper, Pass};\n@@ -16,7 +15,7 @@ crate const STRIP_HIDDEN: Pass = Pass {\n \n /// Strip items marked `#[doc(hidden)]`\n crate fn strip_hidden(krate: clean::Crate, _: &mut DocContext<'_>) -> clean::Crate {\n-    let mut retained = DefIdSet::default();\n+    let mut retained = FakeDefIdSet::default();\n \n     // strip all #[doc(hidden)] items\n     let krate = {\n@@ -30,7 +29,7 @@ crate fn strip_hidden(krate: clean::Crate, _: &mut DocContext<'_>) -> clean::Cra\n }\n \n struct Stripper<'a> {\n-    retained: &'a mut DefIdSet,\n+    retained: &'a mut FakeDefIdSet,\n     update_retained: bool,\n }\n "}, {"sha": "18abeb607a17f963bdfed6342ee0ac3d7570056a", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -1,6 +1,4 @@\n-use rustc_hir::def_id::DefIdSet;\n-\n-use crate::clean;\n+use crate::clean::{self, FakeDefIdSet};\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::passes::{ImplStripper, ImportStripper, Pass, Stripper};\n@@ -16,7 +14,7 @@ crate const STRIP_PRIVATE: Pass = Pass {\n /// crate, specified by the `xcrate` flag.\n crate fn strip_private(mut krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n     // This stripper collects all *retained* nodes.\n-    let mut retained = DefIdSet::default();\n+    let mut retained = FakeDefIdSet::default();\n \n     // strip all private items\n     {"}, {"sha": "87399256292a865467ac8589517fc3216e8e0425", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -1,12 +1,12 @@\n-use rustc_hir::def_id::{DefId, DefIdSet};\n+use rustc_hir::def_id::DefId;\n use rustc_middle::middle::privacy::AccessLevels;\n use std::mem;\n \n-use crate::clean::{self, GetDefId, Item};\n+use crate::clean::{self, FakeDefIdSet, GetDefId, Item};\n use crate::fold::{DocFolder, StripItem};\n \n crate struct Stripper<'a> {\n-    crate retained: &'a mut DefIdSet,\n+    crate retained: &'a mut FakeDefIdSet,\n     crate access_levels: &'a AccessLevels<DefId>,\n     crate update_retained: bool,\n }\n@@ -42,7 +42,7 @@ impl<'a> DocFolder for Stripper<'a> {\n             | clean::TraitAliasItem(..)\n             | clean::ForeignTypeItem => {\n                 if i.def_id.is_local() {\n-                    if !self.access_levels.is_exported(i.def_id) {\n+                    if !self.access_levels.is_exported(i.def_id.expect_real()) {\n                         debug!(\"Stripper: stripping {:?} {:?}\", i.type_(), i.name);\n                         return None;\n                     }\n@@ -116,7 +116,7 @@ impl<'a> DocFolder for Stripper<'a> {\n \n /// This stripper discards all impls which reference stripped items\n crate struct ImplStripper<'a> {\n-    crate retained: &'a DefIdSet,\n+    crate retained: &'a FakeDefIdSet,\n }\n \n impl<'a> DocFolder for ImplStripper<'a> {\n@@ -127,21 +127,22 @@ impl<'a> DocFolder for ImplStripper<'a> {\n                 return None;\n             }\n             if let Some(did) = imp.for_.def_id() {\n-                if did.is_local() && !imp.for_.is_generic() && !self.retained.contains(&did) {\n+                if did.is_local() && !imp.for_.is_generic() && !self.retained.contains(&did.into())\n+                {\n                     debug!(\"ImplStripper: impl item for stripped type; removing\");\n                     return None;\n                 }\n             }\n             if let Some(did) = imp.trait_.def_id() {\n-                if did.is_local() && !self.retained.contains(&did) {\n+                if did.is_local() && !self.retained.contains(&did.into()) {\n                     debug!(\"ImplStripper: impl item for stripped trait; removing\");\n                     return None;\n                 }\n             }\n             if let Some(generics) = imp.trait_.as_ref().and_then(|t| t.generics()) {\n                 for typaram in generics {\n                     if let Some(did) = typaram.def_id() {\n-                        if did.is_local() && !self.retained.contains(&did) {\n+                        if did.is_local() && !self.retained.contains(&did.into()) {\n                             debug!(\n                                 \"ImplStripper: stripped item in trait's generics; removing impl\"\n                             );"}, {"sha": "191d8d5a2ea3b8b1ceec2f37691c4afb445f3277", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b84bf04cddda2379b36c45a575132e6a44fb0/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=ae8b84bf04cddda2379b36c45a575132e6a44fb0", "patch": "@@ -191,7 +191,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     } else {\n                         // All items need to be handled here in case someone wishes to link\n                         // to them with intra-doc links\n-                        self.cx.cache.access_levels.map.insert(did, AccessLevel::Public);\n+                        self.cx.cache.access_levels.map.insert(did.into(), AccessLevel::Public);\n                     }\n                 }\n             }\n@@ -203,7 +203,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             None => return false,\n         };\n \n-        let is_private = !self.cx.cache.access_levels.is_public(res_did);\n+        let is_private = !self.cx.cache.access_levels.is_public(res_did.into());\n         let is_hidden = inherits_doc_hidden(self.cx.tcx, res_hir_id);\n \n         // Only inline if requested or if the item would otherwise be stripped."}]}