{"sha": "afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "node_id": "C_kwDOAAsO6NoAKGFmZDc5NzdjODUwZDljZTA2ZjFkZDJiZWJiNDBkYjhjYzIyMjRhNTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-13T12:08:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-13T12:08:42Z"}, "message": "Auto merge of #93563 - ibraheemdev:crossbeam-channel, r=Amanieu\n\nMerge crossbeam-channel into `std::sync::mpsc`\n\nThis PR imports the [`crossbeam-channel`](https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel#crossbeam-channel) crate into the standard library as a private module, `sync::mpmc`. `sync::mpsc` is now implemented as a thin wrapper around `sync::mpmc`. The primary purpose of this PR is to resolve https://github.com/rust-lang/rust/issues/39364. The public API intentionally remains the same.\n\nThe reason https://github.com/rust-lang/rust/issues/39364 has not been fixed in over 5 years is that the current channel is *incredibly* complex. It was written many years ago and has sat mostly untouched since. `crossbeam-channel` has become the most popular alternative on crates.io, amassing over 30 million downloads. While crossbeam's channel is also complex, like all fast concurrent data structures, it avoids some of the major issues with the current implementation around dynamic flavor upgrades. The new implementation decides on the datastructure to be used when the channel is created, and the channel retains that structure until it is dropped.\n\nReplacing `sync::mpsc` with a simpler, less performant implementation has been discussed as an alternative. However, Rust touts itself as enabling *fearless concurrency*, and having the standard library feature a subpar implementation of a core concurrency primitive doesn't feel right. The argument is that slower is better than broken, but this PR shows that we can do better.\n\nAs mentioned before, the primary purpose of this PR is to fix https://github.com/rust-lang/rust/issues/39364, and so the public API intentionally remains the same. *After* that problem is fixed, the fact that `sync::mpmc` now exists makes it easier to fix the primary limitation of `mpsc`, the fact that it only supports a single consumer. spmc and mpmc are two other common concurrency patterns, and this change enables a path to deprecating `mpsc` and exposing a general `sync::channel` module that supports multiple consumers. It also implements other useful methods such as `send_timeout`. That said, exposing MPMC and other new functionality is mostly out of scope for this PR, and it would be helpful if discussion stays on topic :)\n\nFor what it's worth, the new implementation has also been shown to be more performant in [some basic benchmarks](https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel/benchmarks#results).\n\ncc `@taiki-e`\n\nr? rust-lang/libs", "tree": {"sha": "6dfd36dc7de7eae3175474ba02d16ef7f621e4a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dfd36dc7de7eae3175474ba02d16ef7f621e4a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "html_url": "https://github.com/rust-lang/rust/commit/afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "928d14bcd1976ffd33e743aa09c7c22a063bf87c", "url": "https://api.github.com/repos/rust-lang/rust/commits/928d14bcd1976ffd33e743aa09c7c22a063bf87c", "html_url": "https://github.com/rust-lang/rust/commit/928d14bcd1976ffd33e743aa09c7c22a063bf87c"}, {"sha": "a2f58ab2cb6374ac53638ef6e0f4c4d2f07c3c02", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2f58ab2cb6374ac53638ef6e0f4c4d2f07c3c02", "html_url": "https://github.com/rust-lang/rust/commit/a2f58ab2cb6374ac53638ef6e0f4c4d2f07c3c02"}], "stats": {"total": 5601, "additions": 2739, "deletions": 2862}, "files": [{"sha": "5135f92a9d82ef47d0c4650c0f295b51dd80a3fc", "filename": ".reuse/dep5", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/.reuse%2Fdep5", "raw_url": "https://github.com/rust-lang/rust/raw/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/.reuse%2Fdep5", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.reuse%2Fdep5?ref=afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "patch": "@@ -6,11 +6,6 @@ Files: *\n Copyright: The Rust Project Developers (see https://thanks.rust-lang.org)\n License: MIT or Apache-2.0\n \n-Files: library/std/src/sync/mpsc/mpsc_queue.rs\n-       library/std/src/sync/mpsc/spsc_queue.rs\n-Copyright: 2010-2011 Dmitry Vyukov\n-License: BSD-2-Clause\n-\n Files: src/librustdoc/html/static/fonts/FiraSans*\n Copyright: 2014, Mozilla Foundation, 2014, Telefonica S.A.\n License: OFL-1.1"}, {"sha": "5f662b354cd40cd5339d5aa05d74b15405138230", "filename": "LICENSES/BSD-2-Clause.txt", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/928d14bcd1976ffd33e743aa09c7c22a063bf87c/LICENSES%2FBSD-2-Clause.txt", "raw_url": "https://github.com/rust-lang/rust/raw/928d14bcd1976ffd33e743aa09c7c22a063bf87c/LICENSES%2FBSD-2-Clause.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FBSD-2-Clause.txt?ref=928d14bcd1976ffd33e743aa09c7c22a063bf87c", "patch": "@@ -1,9 +0,0 @@\n-Copyright (c) <year> <owner> \n-\n-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n-\n-1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n-\n-2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n-\n-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."}, {"sha": "4fee8d3e92fc84b58ee1747d095f0bbbcf128d6e", "filename": "library/std/src/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs?ref=afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "patch": "@@ -182,6 +182,7 @@ pub mod mpsc;\n mod barrier;\n mod condvar;\n mod lazy_lock;\n+mod mpmc;\n mod mutex;\n mod once;\n mod once_lock;"}, {"sha": "4db7b4990b97d7465b01952334d082e2a56bf6b6", "filename": "library/std/src/sync/mpmc/array.rs", "status": "added", "additions": 513, "deletions": 0, "changes": 513, "blob_url": "https://github.com/rust-lang/rust/blob/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs?ref=afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "patch": "@@ -0,0 +1,513 @@\n+//! Bounded channel based on a preallocated array.\n+//!\n+//! This flavor has a fixed, positive capacity.\n+//!\n+//! The implementation is based on Dmitry Vyukov's bounded MPMC queue.\n+//!\n+//! Source:\n+//!   - <http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue>\n+//!   - <https://docs.google.com/document/d/1yIAYmbvL3JxOKOjuCyon7JhW4cSv1wy5hC0ApeGMV9s/pub>\n+\n+use super::context::Context;\n+use super::error::*;\n+use super::select::{Operation, Selected, Token};\n+use super::utils::{Backoff, CachePadded};\n+use super::waker::SyncWaker;\n+\n+use crate::cell::UnsafeCell;\n+use crate::mem::MaybeUninit;\n+use crate::ptr;\n+use crate::sync::atomic::{self, AtomicUsize, Ordering};\n+use crate::time::Instant;\n+\n+/// A slot in a channel.\n+struct Slot<T> {\n+    /// The current stamp.\n+    stamp: AtomicUsize,\n+\n+    /// The message in this slot.\n+    msg: UnsafeCell<MaybeUninit<T>>,\n+}\n+\n+/// The token type for the array flavor.\n+#[derive(Debug)]\n+pub(crate) struct ArrayToken {\n+    /// Slot to read from or write to.\n+    slot: *const u8,\n+\n+    /// Stamp to store into the slot after reading or writing.\n+    stamp: usize,\n+}\n+\n+impl Default for ArrayToken {\n+    #[inline]\n+    fn default() -> Self {\n+        ArrayToken { slot: ptr::null(), stamp: 0 }\n+    }\n+}\n+\n+/// Bounded channel based on a preallocated array.\n+pub(crate) struct Channel<T> {\n+    /// The head of the channel.\n+    ///\n+    /// This value is a \"stamp\" consisting of an index into the buffer, a mark bit, and a lap, but\n+    /// packed into a single `usize`. The lower bits represent the index, while the upper bits\n+    /// represent the lap. The mark bit in the head is always zero.\n+    ///\n+    /// Messages are popped from the head of the channel.\n+    head: CachePadded<AtomicUsize>,\n+\n+    /// The tail of the channel.\n+    ///\n+    /// This value is a \"stamp\" consisting of an index into the buffer, a mark bit, and a lap, but\n+    /// packed into a single `usize`. The lower bits represent the index, while the upper bits\n+    /// represent the lap. The mark bit indicates that the channel is disconnected.\n+    ///\n+    /// Messages are pushed into the tail of the channel.\n+    tail: CachePadded<AtomicUsize>,\n+\n+    /// The buffer holding slots.\n+    buffer: Box<[Slot<T>]>,\n+\n+    /// The channel capacity.\n+    cap: usize,\n+\n+    /// A stamp with the value of `{ lap: 1, mark: 0, index: 0 }`.\n+    one_lap: usize,\n+\n+    /// If this bit is set in the tail, that means the channel is disconnected.\n+    mark_bit: usize,\n+\n+    /// Senders waiting while the channel is full.\n+    senders: SyncWaker,\n+\n+    /// Receivers waiting while the channel is empty and not disconnected.\n+    receivers: SyncWaker,\n+}\n+\n+impl<T> Channel<T> {\n+    /// Creates a bounded channel of capacity `cap`.\n+    pub(crate) fn with_capacity(cap: usize) -> Self {\n+        assert!(cap > 0, \"capacity must be positive\");\n+\n+        // Compute constants `mark_bit` and `one_lap`.\n+        let mark_bit = (cap + 1).next_power_of_two();\n+        let one_lap = mark_bit * 2;\n+\n+        // Head is initialized to `{ lap: 0, mark: 0, index: 0 }`.\n+        let head = 0;\n+        // Tail is initialized to `{ lap: 0, mark: 0, index: 0 }`.\n+        let tail = 0;\n+\n+        // Allocate a buffer of `cap` slots initialized\n+        // with stamps.\n+        let buffer: Box<[Slot<T>]> = (0..cap)\n+            .map(|i| {\n+                // Set the stamp to `{ lap: 0, mark: 0, index: i }`.\n+                Slot { stamp: AtomicUsize::new(i), msg: UnsafeCell::new(MaybeUninit::uninit()) }\n+            })\n+            .collect();\n+\n+        Channel {\n+            buffer,\n+            cap,\n+            one_lap,\n+            mark_bit,\n+            head: CachePadded::new(AtomicUsize::new(head)),\n+            tail: CachePadded::new(AtomicUsize::new(tail)),\n+            senders: SyncWaker::new(),\n+            receivers: SyncWaker::new(),\n+        }\n+    }\n+\n+    /// Attempts to reserve a slot for sending a message.\n+    fn start_send(&self, token: &mut Token) -> bool {\n+        let backoff = Backoff::new();\n+        let mut tail = self.tail.load(Ordering::Relaxed);\n+\n+        loop {\n+            // Check if the channel is disconnected.\n+            if tail & self.mark_bit != 0 {\n+                token.array.slot = ptr::null();\n+                token.array.stamp = 0;\n+                return true;\n+            }\n+\n+            // Deconstruct the tail.\n+            let index = tail & (self.mark_bit - 1);\n+            let lap = tail & !(self.one_lap - 1);\n+\n+            // Inspect the corresponding slot.\n+            debug_assert!(index < self.buffer.len());\n+            let slot = unsafe { self.buffer.get_unchecked(index) };\n+            let stamp = slot.stamp.load(Ordering::Acquire);\n+\n+            // If the tail and the stamp match, we may attempt to push.\n+            if tail == stamp {\n+                let new_tail = if index + 1 < self.cap {\n+                    // Same lap, incremented index.\n+                    // Set to `{ lap: lap, mark: 0, index: index + 1 }`.\n+                    tail + 1\n+                } else {\n+                    // One lap forward, index wraps around to zero.\n+                    // Set to `{ lap: lap.wrapping_add(1), mark: 0, index: 0 }`.\n+                    lap.wrapping_add(self.one_lap)\n+                };\n+\n+                // Try moving the tail.\n+                match self.tail.compare_exchange_weak(\n+                    tail,\n+                    new_tail,\n+                    Ordering::SeqCst,\n+                    Ordering::Relaxed,\n+                ) {\n+                    Ok(_) => {\n+                        // Prepare the token for the follow-up call to `write`.\n+                        token.array.slot = slot as *const Slot<T> as *const u8;\n+                        token.array.stamp = tail + 1;\n+                        return true;\n+                    }\n+                    Err(_) => {\n+                        backoff.spin();\n+                        tail = self.tail.load(Ordering::Relaxed);\n+                    }\n+                }\n+            } else if stamp.wrapping_add(self.one_lap) == tail + 1 {\n+                atomic::fence(Ordering::SeqCst);\n+                let head = self.head.load(Ordering::Relaxed);\n+\n+                // If the head lags one lap behind the tail as well...\n+                if head.wrapping_add(self.one_lap) == tail {\n+                    // ...then the channel is full.\n+                    return false;\n+                }\n+\n+                backoff.spin();\n+                tail = self.tail.load(Ordering::Relaxed);\n+            } else {\n+                // Snooze because we need to wait for the stamp to get updated.\n+                backoff.snooze();\n+                tail = self.tail.load(Ordering::Relaxed);\n+            }\n+        }\n+    }\n+\n+    /// Writes a message into the channel.\n+    pub(crate) unsafe fn write(&self, token: &mut Token, msg: T) -> Result<(), T> {\n+        // If there is no slot, the channel is disconnected.\n+        if token.array.slot.is_null() {\n+            return Err(msg);\n+        }\n+\n+        let slot: &Slot<T> = &*(token.array.slot as *const Slot<T>);\n+\n+        // Write the message into the slot and update the stamp.\n+        slot.msg.get().write(MaybeUninit::new(msg));\n+        slot.stamp.store(token.array.stamp, Ordering::Release);\n+\n+        // Wake a sleeping receiver.\n+        self.receivers.notify();\n+        Ok(())\n+    }\n+\n+    /// Attempts to reserve a slot for receiving a message.\n+    fn start_recv(&self, token: &mut Token) -> bool {\n+        let backoff = Backoff::new();\n+        let mut head = self.head.load(Ordering::Relaxed);\n+\n+        loop {\n+            // Deconstruct the head.\n+            let index = head & (self.mark_bit - 1);\n+            let lap = head & !(self.one_lap - 1);\n+\n+            // Inspect the corresponding slot.\n+            debug_assert!(index < self.buffer.len());\n+            let slot = unsafe { self.buffer.get_unchecked(index) };\n+            let stamp = slot.stamp.load(Ordering::Acquire);\n+\n+            // If the the stamp is ahead of the head by 1, we may attempt to pop.\n+            if head + 1 == stamp {\n+                let new = if index + 1 < self.cap {\n+                    // Same lap, incremented index.\n+                    // Set to `{ lap: lap, mark: 0, index: index + 1 }`.\n+                    head + 1\n+                } else {\n+                    // One lap forward, index wraps around to zero.\n+                    // Set to `{ lap: lap.wrapping_add(1), mark: 0, index: 0 }`.\n+                    lap.wrapping_add(self.one_lap)\n+                };\n+\n+                // Try moving the head.\n+                match self.head.compare_exchange_weak(\n+                    head,\n+                    new,\n+                    Ordering::SeqCst,\n+                    Ordering::Relaxed,\n+                ) {\n+                    Ok(_) => {\n+                        // Prepare the token for the follow-up call to `read`.\n+                        token.array.slot = slot as *const Slot<T> as *const u8;\n+                        token.array.stamp = head.wrapping_add(self.one_lap);\n+                        return true;\n+                    }\n+                    Err(_) => {\n+                        backoff.spin();\n+                        head = self.head.load(Ordering::Relaxed);\n+                    }\n+                }\n+            } else if stamp == head {\n+                atomic::fence(Ordering::SeqCst);\n+                let tail = self.tail.load(Ordering::Relaxed);\n+\n+                // If the tail equals the head, that means the channel is empty.\n+                if (tail & !self.mark_bit) == head {\n+                    // If the channel is disconnected...\n+                    if tail & self.mark_bit != 0 {\n+                        // ...then receive an error.\n+                        token.array.slot = ptr::null();\n+                        token.array.stamp = 0;\n+                        return true;\n+                    } else {\n+                        // Otherwise, the receive operation is not ready.\n+                        return false;\n+                    }\n+                }\n+\n+                backoff.spin();\n+                head = self.head.load(Ordering::Relaxed);\n+            } else {\n+                // Snooze because we need to wait for the stamp to get updated.\n+                backoff.snooze();\n+                head = self.head.load(Ordering::Relaxed);\n+            }\n+        }\n+    }\n+\n+    /// Reads a message from the channel.\n+    pub(crate) unsafe fn read(&self, token: &mut Token) -> Result<T, ()> {\n+        if token.array.slot.is_null() {\n+            // The channel is disconnected.\n+            return Err(());\n+        }\n+\n+        let slot: &Slot<T> = &*(token.array.slot as *const Slot<T>);\n+\n+        // Read the message from the slot and update the stamp.\n+        let msg = slot.msg.get().read().assume_init();\n+        slot.stamp.store(token.array.stamp, Ordering::Release);\n+\n+        // Wake a sleeping sender.\n+        self.senders.notify();\n+        Ok(msg)\n+    }\n+\n+    /// Attempts to send a message into the channel.\n+    pub(crate) fn try_send(&self, msg: T) -> Result<(), TrySendError<T>> {\n+        let token = &mut Token::default();\n+        if self.start_send(token) {\n+            unsafe { self.write(token, msg).map_err(TrySendError::Disconnected) }\n+        } else {\n+            Err(TrySendError::Full(msg))\n+        }\n+    }\n+\n+    /// Sends a message into the channel.\n+    pub(crate) fn send(\n+        &self,\n+        msg: T,\n+        deadline: Option<Instant>,\n+    ) -> Result<(), SendTimeoutError<T>> {\n+        let token = &mut Token::default();\n+        loop {\n+            // Try sending a message several times.\n+            let backoff = Backoff::new();\n+            loop {\n+                if self.start_send(token) {\n+                    let res = unsafe { self.write(token, msg) };\n+                    return res.map_err(SendTimeoutError::Disconnected);\n+                }\n+\n+                if backoff.is_completed() {\n+                    break;\n+                } else {\n+                    backoff.spin();\n+                }\n+            }\n+\n+            if let Some(d) = deadline {\n+                if Instant::now() >= d {\n+                    return Err(SendTimeoutError::Timeout(msg));\n+                }\n+            }\n+\n+            Context::with(|cx| {\n+                // Prepare for blocking until a receiver wakes us up.\n+                let oper = Operation::hook(token);\n+                self.senders.register(oper, cx);\n+\n+                // Has the channel become ready just now?\n+                if !self.is_full() || self.is_disconnected() {\n+                    let _ = cx.try_select(Selected::Aborted);\n+                }\n+\n+                // Block the current thread.\n+                let sel = cx.wait_until(deadline);\n+\n+                match sel {\n+                    Selected::Waiting => unreachable!(),\n+                    Selected::Aborted | Selected::Disconnected => {\n+                        self.senders.unregister(oper).unwrap();\n+                    }\n+                    Selected::Operation(_) => {}\n+                }\n+            });\n+        }\n+    }\n+\n+    /// Attempts to receive a message without blocking.\n+    pub(crate) fn try_recv(&self) -> Result<T, TryRecvError> {\n+        let token = &mut Token::default();\n+\n+        if self.start_recv(token) {\n+            unsafe { self.read(token).map_err(|_| TryRecvError::Disconnected) }\n+        } else {\n+            Err(TryRecvError::Empty)\n+        }\n+    }\n+\n+    /// Receives a message from the channel.\n+    pub(crate) fn recv(&self, deadline: Option<Instant>) -> Result<T, RecvTimeoutError> {\n+        let token = &mut Token::default();\n+        loop {\n+            if self.start_recv(token) {\n+                let res = unsafe { self.read(token) };\n+                return res.map_err(|_| RecvTimeoutError::Disconnected);\n+            }\n+\n+            if let Some(d) = deadline {\n+                if Instant::now() >= d {\n+                    return Err(RecvTimeoutError::Timeout);\n+                }\n+            }\n+\n+            Context::with(|cx| {\n+                // Prepare for blocking until a sender wakes us up.\n+                let oper = Operation::hook(token);\n+                self.receivers.register(oper, cx);\n+\n+                // Has the channel become ready just now?\n+                if !self.is_empty() || self.is_disconnected() {\n+                    let _ = cx.try_select(Selected::Aborted);\n+                }\n+\n+                // Block the current thread.\n+                let sel = cx.wait_until(deadline);\n+\n+                match sel {\n+                    Selected::Waiting => unreachable!(),\n+                    Selected::Aborted | Selected::Disconnected => {\n+                        self.receivers.unregister(oper).unwrap();\n+                        // If the channel was disconnected, we still have to check for remaining\n+                        // messages.\n+                    }\n+                    Selected::Operation(_) => {}\n+                }\n+            });\n+        }\n+    }\n+\n+    /// Returns the current number of messages inside the channel.\n+    pub(crate) fn len(&self) -> usize {\n+        loop {\n+            // Load the tail, then load the head.\n+            let tail = self.tail.load(Ordering::SeqCst);\n+            let head = self.head.load(Ordering::SeqCst);\n+\n+            // If the tail didn't change, we've got consistent values to work with.\n+            if self.tail.load(Ordering::SeqCst) == tail {\n+                let hix = head & (self.mark_bit - 1);\n+                let tix = tail & (self.mark_bit - 1);\n+\n+                return if hix < tix {\n+                    tix - hix\n+                } else if hix > tix {\n+                    self.cap - hix + tix\n+                } else if (tail & !self.mark_bit) == head {\n+                    0\n+                } else {\n+                    self.cap\n+                };\n+            }\n+        }\n+    }\n+\n+    /// Returns the capacity of the channel.\n+    #[allow(clippy::unnecessary_wraps)] // This is intentional.\n+    pub(crate) fn capacity(&self) -> Option<usize> {\n+        Some(self.cap)\n+    }\n+\n+    /// Disconnects the channel and wakes up all blocked senders and receivers.\n+    ///\n+    /// Returns `true` if this call disconnected the channel.\n+    pub(crate) fn disconnect(&self) -> bool {\n+        let tail = self.tail.fetch_or(self.mark_bit, Ordering::SeqCst);\n+\n+        if tail & self.mark_bit == 0 {\n+            self.senders.disconnect();\n+            self.receivers.disconnect();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Returns `true` if the channel is disconnected.\n+    pub(crate) fn is_disconnected(&self) -> bool {\n+        self.tail.load(Ordering::SeqCst) & self.mark_bit != 0\n+    }\n+\n+    /// Returns `true` if the channel is empty.\n+    pub(crate) fn is_empty(&self) -> bool {\n+        let head = self.head.load(Ordering::SeqCst);\n+        let tail = self.tail.load(Ordering::SeqCst);\n+\n+        // Is the tail equal to the head?\n+        //\n+        // Note: If the head changes just before we load the tail, that means there was a moment\n+        // when the channel was not empty, so it is safe to just return `false`.\n+        (tail & !self.mark_bit) == head\n+    }\n+\n+    /// Returns `true` if the channel is full.\n+    pub(crate) fn is_full(&self) -> bool {\n+        let tail = self.tail.load(Ordering::SeqCst);\n+        let head = self.head.load(Ordering::SeqCst);\n+\n+        // Is the head lagging one lap behind tail?\n+        //\n+        // Note: If the tail changes just before we load the head, that means there was a moment\n+        // when the channel was not full, so it is safe to just return `false`.\n+        head.wrapping_add(self.one_lap) == tail & !self.mark_bit\n+    }\n+}\n+\n+impl<T> Drop for Channel<T> {\n+    fn drop(&mut self) {\n+        // Get the index of the head.\n+        let hix = self.head.load(Ordering::Relaxed) & (self.mark_bit - 1);\n+\n+        // Loop over all slots that hold a message and drop them.\n+        for i in 0..self.len() {\n+            // Compute the index of the next slot holding a message.\n+            let index = if hix + i < self.cap { hix + i } else { hix + i - self.cap };\n+\n+            unsafe {\n+                debug_assert!(index < self.buffer.len());\n+                let slot = self.buffer.get_unchecked_mut(index);\n+                let msg = &mut *slot.msg.get();\n+                msg.as_mut_ptr().drop_in_place();\n+            }\n+        }\n+    }\n+}"}, {"sha": "bbfc6ce00ffc2144da81a115f905b4f7c580a087", "filename": "library/std/src/sync/mpmc/context.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fcontext.rs?ref=afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "patch": "@@ -0,0 +1,155 @@\n+//! Thread-local channel context.\n+\n+use super::select::Selected;\n+use super::waker::current_thread_id;\n+\n+use crate::cell::Cell;\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};\n+use crate::sync::Arc;\n+use crate::thread::{self, Thread};\n+use crate::time::Instant;\n+\n+/// Thread-local context.\n+#[derive(Debug, Clone)]\n+pub struct Context {\n+    inner: Arc<Inner>,\n+}\n+\n+/// Inner representation of `Context`.\n+#[derive(Debug)]\n+struct Inner {\n+    /// Selected operation.\n+    select: AtomicUsize,\n+\n+    /// A slot into which another thread may store a pointer to its `Packet`.\n+    packet: AtomicPtr<()>,\n+\n+    /// Thread handle.\n+    thread: Thread,\n+\n+    /// Thread id.\n+    thread_id: usize,\n+}\n+\n+impl Context {\n+    /// Creates a new context for the duration of the closure.\n+    #[inline]\n+    pub fn with<F, R>(f: F) -> R\n+    where\n+        F: FnOnce(&Context) -> R,\n+    {\n+        thread_local! {\n+            /// Cached thread-local context.\n+            static CONTEXT: Cell<Option<Context>> = Cell::new(Some(Context::new()));\n+        }\n+\n+        let mut f = Some(f);\n+        let mut f = |cx: &Context| -> R {\n+            let f = f.take().unwrap();\n+            f(cx)\n+        };\n+\n+        CONTEXT\n+            .try_with(|cell| match cell.take() {\n+                None => f(&Context::new()),\n+                Some(cx) => {\n+                    cx.reset();\n+                    let res = f(&cx);\n+                    cell.set(Some(cx));\n+                    res\n+                }\n+            })\n+            .unwrap_or_else(|_| f(&Context::new()))\n+    }\n+\n+    /// Creates a new `Context`.\n+    #[cold]\n+    fn new() -> Context {\n+        Context {\n+            inner: Arc::new(Inner {\n+                select: AtomicUsize::new(Selected::Waiting.into()),\n+                packet: AtomicPtr::new(ptr::null_mut()),\n+                thread: thread::current(),\n+                thread_id: current_thread_id(),\n+            }),\n+        }\n+    }\n+\n+    /// Resets `select` and `packet`.\n+    #[inline]\n+    fn reset(&self) {\n+        self.inner.select.store(Selected::Waiting.into(), Ordering::Release);\n+        self.inner.packet.store(ptr::null_mut(), Ordering::Release);\n+    }\n+\n+    /// Attempts to select an operation.\n+    ///\n+    /// On failure, the previously selected operation is returned.\n+    #[inline]\n+    pub fn try_select(&self, select: Selected) -> Result<(), Selected> {\n+        self.inner\n+            .select\n+            .compare_exchange(\n+                Selected::Waiting.into(),\n+                select.into(),\n+                Ordering::AcqRel,\n+                Ordering::Acquire,\n+            )\n+            .map(|_| ())\n+            .map_err(|e| e.into())\n+    }\n+\n+    /// Stores a packet.\n+    ///\n+    /// This method must be called after `try_select` succeeds and there is a packet to provide.\n+    #[inline]\n+    pub fn store_packet(&self, packet: *mut ()) {\n+        if !packet.is_null() {\n+            self.inner.packet.store(packet, Ordering::Release);\n+        }\n+    }\n+\n+    /// Waits until an operation is selected and returns it.\n+    ///\n+    /// If the deadline is reached, `Selected::Aborted` will be selected.\n+    #[inline]\n+    pub fn wait_until(&self, deadline: Option<Instant>) -> Selected {\n+        loop {\n+            // Check whether an operation has been selected.\n+            let sel = Selected::from(self.inner.select.load(Ordering::Acquire));\n+            if sel != Selected::Waiting {\n+                return sel;\n+            }\n+\n+            // If there's a deadline, park the current thread until the deadline is reached.\n+            if let Some(end) = deadline {\n+                let now = Instant::now();\n+\n+                if now < end {\n+                    thread::park_timeout(end - now);\n+                } else {\n+                    // The deadline has been reached. Try aborting select.\n+                    return match self.try_select(Selected::Aborted) {\n+                        Ok(()) => Selected::Aborted,\n+                        Err(s) => s,\n+                    };\n+                }\n+            } else {\n+                thread::park();\n+            }\n+        }\n+    }\n+\n+    /// Unparks the thread this context belongs to.\n+    #[inline]\n+    pub fn unpark(&self) {\n+        self.inner.thread.unpark();\n+    }\n+\n+    /// Returns the id of the thread this context belongs to.\n+    #[inline]\n+    pub fn thread_id(&self) -> usize {\n+        self.inner.thread_id\n+    }\n+}"}, {"sha": "a5a6bdc67f13fd0f97fa150bd6582f59827e15f0", "filename": "library/std/src/sync/mpmc/counter.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fcounter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fcounter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fcounter.rs?ref=afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "patch": "@@ -0,0 +1,137 @@\n+use crate::ops;\n+use crate::process;\n+use crate::sync::atomic::{AtomicBool, AtomicUsize, Ordering};\n+\n+/// Reference counter internals.\n+struct Counter<C> {\n+    /// The number of senders associated with the channel.\n+    senders: AtomicUsize,\n+\n+    /// The number of receivers associated with the channel.\n+    receivers: AtomicUsize,\n+\n+    /// Set to `true` if the last sender or the last receiver reference deallocates the channel.\n+    destroy: AtomicBool,\n+\n+    /// The internal channel.\n+    chan: C,\n+}\n+\n+/// Wraps a channel into the reference counter.\n+pub(crate) fn new<C>(chan: C) -> (Sender<C>, Receiver<C>) {\n+    let counter = Box::into_raw(Box::new(Counter {\n+        senders: AtomicUsize::new(1),\n+        receivers: AtomicUsize::new(1),\n+        destroy: AtomicBool::new(false),\n+        chan,\n+    }));\n+    let s = Sender { counter };\n+    let r = Receiver { counter };\n+    (s, r)\n+}\n+\n+/// The sending side.\n+pub(crate) struct Sender<C> {\n+    counter: *mut Counter<C>,\n+}\n+\n+impl<C> Sender<C> {\n+    /// Returns the internal `Counter`.\n+    fn counter(&self) -> &Counter<C> {\n+        unsafe { &*self.counter }\n+    }\n+\n+    /// Acquires another sender reference.\n+    pub(crate) fn acquire(&self) -> Sender<C> {\n+        let count = self.counter().senders.fetch_add(1, Ordering::Relaxed);\n+\n+        // Cloning senders and calling `mem::forget` on the clones could potentially overflow the\n+        // counter. It's very difficult to recover sensibly from such degenerate scenarios so we\n+        // just abort when the count becomes very large.\n+        if count > isize::MAX as usize {\n+            process::abort();\n+        }\n+\n+        Sender { counter: self.counter }\n+    }\n+\n+    /// Releases the sender reference.\n+    ///\n+    /// Function `disconnect` will be called if this is the last sender reference.\n+    pub(crate) unsafe fn release<F: FnOnce(&C) -> bool>(&self, disconnect: F) {\n+        if self.counter().senders.fetch_sub(1, Ordering::AcqRel) == 1 {\n+            disconnect(&self.counter().chan);\n+\n+            if self.counter().destroy.swap(true, Ordering::AcqRel) {\n+                drop(Box::from_raw(self.counter));\n+            }\n+        }\n+    }\n+}\n+\n+impl<C> ops::Deref for Sender<C> {\n+    type Target = C;\n+\n+    fn deref(&self) -> &C {\n+        &self.counter().chan\n+    }\n+}\n+\n+impl<C> PartialEq for Sender<C> {\n+    fn eq(&self, other: &Sender<C>) -> bool {\n+        self.counter == other.counter\n+    }\n+}\n+\n+/// The receiving side.\n+pub(crate) struct Receiver<C> {\n+    counter: *mut Counter<C>,\n+}\n+\n+impl<C> Receiver<C> {\n+    /// Returns the internal `Counter`.\n+    fn counter(&self) -> &Counter<C> {\n+        unsafe { &*self.counter }\n+    }\n+\n+    /// Acquires another receiver reference.\n+    pub(crate) fn acquire(&self) -> Receiver<C> {\n+        let count = self.counter().receivers.fetch_add(1, Ordering::Relaxed);\n+\n+        // Cloning receivers and calling `mem::forget` on the clones could potentially overflow the\n+        // counter. It's very difficult to recover sensibly from such degenerate scenarios so we\n+        // just abort when the count becomes very large.\n+        if count > isize::MAX as usize {\n+            process::abort();\n+        }\n+\n+        Receiver { counter: self.counter }\n+    }\n+\n+    /// Releases the receiver reference.\n+    ///\n+    /// Function `disconnect` will be called if this is the last receiver reference.\n+    pub(crate) unsafe fn release<F: FnOnce(&C) -> bool>(&self, disconnect: F) {\n+        if self.counter().receivers.fetch_sub(1, Ordering::AcqRel) == 1 {\n+            disconnect(&self.counter().chan);\n+\n+            if self.counter().destroy.swap(true, Ordering::AcqRel) {\n+                drop(Box::from_raw(self.counter));\n+            }\n+        }\n+    }\n+}\n+\n+impl<C> ops::Deref for Receiver<C> {\n+    type Target = C;\n+\n+    fn deref(&self) -> &C {\n+        &self.counter().chan\n+    }\n+}\n+\n+impl<C> PartialEq for Receiver<C> {\n+    fn eq(&self, other: &Receiver<C>) -> bool {\n+        self.counter == other.counter\n+    }\n+}"}, {"sha": "1b8a1f387974d9152173315ad77e2b4262903a8c", "filename": "library/std/src/sync/mpmc/error.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Ferror.rs?ref=afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "patch": "@@ -0,0 +1,46 @@\n+use crate::error;\n+use crate::fmt;\n+\n+pub use crate::sync::mpsc::{RecvError, RecvTimeoutError, SendError, TryRecvError, TrySendError};\n+\n+/// An error returned from the [`send_timeout`] method.\n+///\n+/// The error contains the message being sent so it can be recovered.\n+///\n+/// [`send_timeout`]: super::Sender::send_timeout\n+#[derive(PartialEq, Eq, Clone, Copy)]\n+pub enum SendTimeoutError<T> {\n+    /// The message could not be sent because the channel is full and the operation timed out.\n+    ///\n+    /// If this is a zero-capacity channel, then the error indicates that there was no receiver\n+    /// available to receive the message and the operation timed out.\n+    Timeout(T),\n+\n+    /// The message could not be sent because the channel is disconnected.\n+    Disconnected(T),\n+}\n+\n+impl<T> fmt::Debug for SendTimeoutError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        \"SendTimeoutError(..)\".fmt(f)\n+    }\n+}\n+\n+impl<T> fmt::Display for SendTimeoutError<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            SendTimeoutError::Timeout(..) => \"timed out waiting on send operation\".fmt(f),\n+            SendTimeoutError::Disconnected(..) => \"sending on a disconnected channel\".fmt(f),\n+        }\n+    }\n+}\n+\n+impl<T: Send> error::Error for SendTimeoutError<T> {}\n+\n+impl<T> From<SendError<T>> for SendTimeoutError<T> {\n+    fn from(err: SendError<T>) -> SendTimeoutError<T> {\n+        match err {\n+            SendError(e) => SendTimeoutError::Disconnected(e),\n+        }\n+    }\n+}"}, {"sha": "2d5b2fb3b231d35c6bc86c575ae58be990e885b2", "filename": "library/std/src/sync/mpmc/list.rs", "status": "added", "additions": 638, "deletions": 0, "changes": 638, "blob_url": "https://github.com/rust-lang/rust/blob/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs?ref=afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "patch": "@@ -0,0 +1,638 @@\n+//! Unbounded channel implemented as a linked list.\n+\n+use super::context::Context;\n+use super::error::*;\n+use super::select::{Operation, Selected, Token};\n+use super::utils::{Backoff, CachePadded};\n+use super::waker::SyncWaker;\n+\n+use crate::cell::UnsafeCell;\n+use crate::marker::PhantomData;\n+use crate::mem::MaybeUninit;\n+use crate::ptr;\n+use crate::sync::atomic::{self, AtomicPtr, AtomicUsize, Ordering};\n+use crate::time::Instant;\n+\n+// Bits indicating the state of a slot:\n+// * If a message has been written into the slot, `WRITE` is set.\n+// * If a message has been read from the slot, `READ` is set.\n+// * If the block is being destroyed, `DESTROY` is set.\n+const WRITE: usize = 1;\n+const READ: usize = 2;\n+const DESTROY: usize = 4;\n+\n+// Each block covers one \"lap\" of indices.\n+const LAP: usize = 32;\n+// The maximum number of messages a block can hold.\n+const BLOCK_CAP: usize = LAP - 1;\n+// How many lower bits are reserved for metadata.\n+const SHIFT: usize = 1;\n+// Has two different purposes:\n+// * If set in head, indicates that the block is not the last one.\n+// * If set in tail, indicates that the channel is disconnected.\n+const MARK_BIT: usize = 1;\n+\n+/// A slot in a block.\n+struct Slot<T> {\n+    /// The message.\n+    msg: UnsafeCell<MaybeUninit<T>>,\n+\n+    /// The state of the slot.\n+    state: AtomicUsize,\n+}\n+\n+impl<T> Slot<T> {\n+    /// Waits until a message is written into the slot.\n+    fn wait_write(&self) {\n+        let backoff = Backoff::new();\n+        while self.state.load(Ordering::Acquire) & WRITE == 0 {\n+            backoff.snooze();\n+        }\n+    }\n+}\n+\n+/// A block in a linked list.\n+///\n+/// Each block in the list can hold up to `BLOCK_CAP` messages.\n+struct Block<T> {\n+    /// The next block in the linked list.\n+    next: AtomicPtr<Block<T>>,\n+\n+    /// Slots for messages.\n+    slots: [Slot<T>; BLOCK_CAP],\n+}\n+\n+impl<T> Block<T> {\n+    /// Creates an empty block.\n+    fn new() -> Block<T> {\n+        // SAFETY: This is safe because:\n+        //  [1] `Block::next` (AtomicPtr) may be safely zero initialized.\n+        //  [2] `Block::slots` (Array) may be safely zero initialized because of [3, 4].\n+        //  [3] `Slot::msg` (UnsafeCell) may be safely zero initialized because it\n+        //       holds a MaybeUninit.\n+        //  [4] `Slot::state` (AtomicUsize) may be safely zero initialized.\n+        unsafe { MaybeUninit::zeroed().assume_init() }\n+    }\n+\n+    /// Waits until the next pointer is set.\n+    fn wait_next(&self) -> *mut Block<T> {\n+        let backoff = Backoff::new();\n+        loop {\n+            let next = self.next.load(Ordering::Acquire);\n+            if !next.is_null() {\n+                return next;\n+            }\n+            backoff.snooze();\n+        }\n+    }\n+\n+    /// Sets the `DESTROY` bit in slots starting from `start` and destroys the block.\n+    unsafe fn destroy(this: *mut Block<T>, start: usize) {\n+        // It is not necessary to set the `DESTROY` bit in the last slot because that slot has\n+        // begun destruction of the block.\n+        for i in start..BLOCK_CAP - 1 {\n+            let slot = (*this).slots.get_unchecked(i);\n+\n+            // Mark the `DESTROY` bit if a thread is still using the slot.\n+            if slot.state.load(Ordering::Acquire) & READ == 0\n+                && slot.state.fetch_or(DESTROY, Ordering::AcqRel) & READ == 0\n+            {\n+                // If a thread is still using the slot, it will continue destruction of the block.\n+                return;\n+            }\n+        }\n+\n+        // No thread is using the block, now it is safe to destroy it.\n+        drop(Box::from_raw(this));\n+    }\n+}\n+\n+/// A position in a channel.\n+#[derive(Debug)]\n+struct Position<T> {\n+    /// The index in the channel.\n+    index: AtomicUsize,\n+\n+    /// The block in the linked list.\n+    block: AtomicPtr<Block<T>>,\n+}\n+\n+/// The token type for the list flavor.\n+#[derive(Debug)]\n+pub(crate) struct ListToken {\n+    /// The block of slots.\n+    block: *const u8,\n+\n+    /// The offset into the block.\n+    offset: usize,\n+}\n+\n+impl Default for ListToken {\n+    #[inline]\n+    fn default() -> Self {\n+        ListToken { block: ptr::null(), offset: 0 }\n+    }\n+}\n+\n+/// Unbounded channel implemented as a linked list.\n+///\n+/// Each message sent into the channel is assigned a sequence number, i.e. an index. Indices are\n+/// represented as numbers of type `usize` and wrap on overflow.\n+///\n+/// Consecutive messages are grouped into blocks in order to put less pressure on the allocator and\n+/// improve cache efficiency.\n+pub(crate) struct Channel<T> {\n+    /// The head of the channel.\n+    head: CachePadded<Position<T>>,\n+\n+    /// The tail of the channel.\n+    tail: CachePadded<Position<T>>,\n+\n+    /// Receivers waiting while the channel is empty and not disconnected.\n+    receivers: SyncWaker,\n+\n+    /// Indicates that dropping a `Channel<T>` may drop messages of type `T`.\n+    _marker: PhantomData<T>,\n+}\n+\n+impl<T> Channel<T> {\n+    /// Creates a new unbounded channel.\n+    pub(crate) fn new() -> Self {\n+        Channel {\n+            head: CachePadded::new(Position {\n+                block: AtomicPtr::new(ptr::null_mut()),\n+                index: AtomicUsize::new(0),\n+            }),\n+            tail: CachePadded::new(Position {\n+                block: AtomicPtr::new(ptr::null_mut()),\n+                index: AtomicUsize::new(0),\n+            }),\n+            receivers: SyncWaker::new(),\n+            _marker: PhantomData,\n+        }\n+    }\n+\n+    /// Attempts to reserve a slot for sending a message.\n+    fn start_send(&self, token: &mut Token) -> bool {\n+        let backoff = Backoff::new();\n+        let mut tail = self.tail.index.load(Ordering::Acquire);\n+        let mut block = self.tail.block.load(Ordering::Acquire);\n+        let mut next_block = None;\n+\n+        loop {\n+            // Check if the channel is disconnected.\n+            if tail & MARK_BIT != 0 {\n+                token.list.block = ptr::null();\n+                return true;\n+            }\n+\n+            // Calculate the offset of the index into the block.\n+            let offset = (tail >> SHIFT) % LAP;\n+\n+            // If we reached the end of the block, wait until the next one is installed.\n+            if offset == BLOCK_CAP {\n+                backoff.snooze();\n+                tail = self.tail.index.load(Ordering::Acquire);\n+                block = self.tail.block.load(Ordering::Acquire);\n+                continue;\n+            }\n+\n+            // If we're going to have to install the next block, allocate it in advance in order to\n+            // make the wait for other threads as short as possible.\n+            if offset + 1 == BLOCK_CAP && next_block.is_none() {\n+                next_block = Some(Box::new(Block::<T>::new()));\n+            }\n+\n+            // If this is the first message to be sent into the channel, we need to allocate the\n+            // first block and install it.\n+            if block.is_null() {\n+                let new = Box::into_raw(Box::new(Block::<T>::new()));\n+\n+                if self\n+                    .tail\n+                    .block\n+                    .compare_exchange(block, new, Ordering::Release, Ordering::Relaxed)\n+                    .is_ok()\n+                {\n+                    self.head.block.store(new, Ordering::Release);\n+                    block = new;\n+                } else {\n+                    next_block = unsafe { Some(Box::from_raw(new)) };\n+                    tail = self.tail.index.load(Ordering::Acquire);\n+                    block = self.tail.block.load(Ordering::Acquire);\n+                    continue;\n+                }\n+            }\n+\n+            let new_tail = tail + (1 << SHIFT);\n+\n+            // Try advancing the tail forward.\n+            match self.tail.index.compare_exchange_weak(\n+                tail,\n+                new_tail,\n+                Ordering::SeqCst,\n+                Ordering::Acquire,\n+            ) {\n+                Ok(_) => unsafe {\n+                    // If we've reached the end of the block, install the next one.\n+                    if offset + 1 == BLOCK_CAP {\n+                        let next_block = Box::into_raw(next_block.unwrap());\n+                        self.tail.block.store(next_block, Ordering::Release);\n+                        self.tail.index.fetch_add(1 << SHIFT, Ordering::Release);\n+                        (*block).next.store(next_block, Ordering::Release);\n+                    }\n+\n+                    token.list.block = block as *const u8;\n+                    token.list.offset = offset;\n+                    return true;\n+                },\n+                Err(_) => {\n+                    backoff.spin();\n+                    tail = self.tail.index.load(Ordering::Acquire);\n+                    block = self.tail.block.load(Ordering::Acquire);\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Writes a message into the channel.\n+    pub(crate) unsafe fn write(&self, token: &mut Token, msg: T) -> Result<(), T> {\n+        // If there is no slot, the channel is disconnected.\n+        if token.list.block.is_null() {\n+            return Err(msg);\n+        }\n+\n+        // Write the message into the slot.\n+        let block = token.list.block as *mut Block<T>;\n+        let offset = token.list.offset;\n+        let slot = (*block).slots.get_unchecked(offset);\n+        slot.msg.get().write(MaybeUninit::new(msg));\n+        slot.state.fetch_or(WRITE, Ordering::Release);\n+\n+        // Wake a sleeping receiver.\n+        self.receivers.notify();\n+        Ok(())\n+    }\n+\n+    /// Attempts to reserve a slot for receiving a message.\n+    fn start_recv(&self, token: &mut Token) -> bool {\n+        let backoff = Backoff::new();\n+        let mut head = self.head.index.load(Ordering::Acquire);\n+        let mut block = self.head.block.load(Ordering::Acquire);\n+\n+        loop {\n+            // Calculate the offset of the index into the block.\n+            let offset = (head >> SHIFT) % LAP;\n+\n+            // If we reached the end of the block, wait until the next one is installed.\n+            if offset == BLOCK_CAP {\n+                backoff.snooze();\n+                head = self.head.index.load(Ordering::Acquire);\n+                block = self.head.block.load(Ordering::Acquire);\n+                continue;\n+            }\n+\n+            let mut new_head = head + (1 << SHIFT);\n+\n+            if new_head & MARK_BIT == 0 {\n+                atomic::fence(Ordering::SeqCst);\n+                let tail = self.tail.index.load(Ordering::Relaxed);\n+\n+                // If the tail equals the head, that means the channel is empty.\n+                if head >> SHIFT == tail >> SHIFT {\n+                    // If the channel is disconnected...\n+                    if tail & MARK_BIT != 0 {\n+                        // ...then receive an error.\n+                        token.list.block = ptr::null();\n+                        return true;\n+                    } else {\n+                        // Otherwise, the receive operation is not ready.\n+                        return false;\n+                    }\n+                }\n+\n+                // If head and tail are not in the same block, set `MARK_BIT` in head.\n+                if (head >> SHIFT) / LAP != (tail >> SHIFT) / LAP {\n+                    new_head |= MARK_BIT;\n+                }\n+            }\n+\n+            // The block can be null here only if the first message is being sent into the channel.\n+            // In that case, just wait until it gets initialized.\n+            if block.is_null() {\n+                backoff.snooze();\n+                head = self.head.index.load(Ordering::Acquire);\n+                block = self.head.block.load(Ordering::Acquire);\n+                continue;\n+            }\n+\n+            // Try moving the head index forward.\n+            match self.head.index.compare_exchange_weak(\n+                head,\n+                new_head,\n+                Ordering::SeqCst,\n+                Ordering::Acquire,\n+            ) {\n+                Ok(_) => unsafe {\n+                    // If we've reached the end of the block, move to the next one.\n+                    if offset + 1 == BLOCK_CAP {\n+                        let next = (*block).wait_next();\n+                        let mut next_index = (new_head & !MARK_BIT).wrapping_add(1 << SHIFT);\n+                        if !(*next).next.load(Ordering::Relaxed).is_null() {\n+                            next_index |= MARK_BIT;\n+                        }\n+\n+                        self.head.block.store(next, Ordering::Release);\n+                        self.head.index.store(next_index, Ordering::Release);\n+                    }\n+\n+                    token.list.block = block as *const u8;\n+                    token.list.offset = offset;\n+                    return true;\n+                },\n+                Err(_) => {\n+                    backoff.spin();\n+                    head = self.head.index.load(Ordering::Acquire);\n+                    block = self.head.block.load(Ordering::Acquire);\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Reads a message from the channel.\n+    pub(crate) unsafe fn read(&self, token: &mut Token) -> Result<T, ()> {\n+        if token.list.block.is_null() {\n+            // The channel is disconnected.\n+            return Err(());\n+        }\n+\n+        // Read the message.\n+        let block = token.list.block as *mut Block<T>;\n+        let offset = token.list.offset;\n+        let slot = (*block).slots.get_unchecked(offset);\n+        slot.wait_write();\n+        let msg = slot.msg.get().read().assume_init();\n+\n+        // Destroy the block if we've reached the end, or if another thread wanted to destroy but\n+        // couldn't because we were busy reading from the slot.\n+        if offset + 1 == BLOCK_CAP {\n+            Block::destroy(block, 0);\n+        } else if slot.state.fetch_or(READ, Ordering::AcqRel) & DESTROY != 0 {\n+            Block::destroy(block, offset + 1);\n+        }\n+\n+        Ok(msg)\n+    }\n+\n+    /// Attempts to send a message into the channel.\n+    pub(crate) fn try_send(&self, msg: T) -> Result<(), TrySendError<T>> {\n+        self.send(msg, None).map_err(|err| match err {\n+            SendTimeoutError::Disconnected(msg) => TrySendError::Disconnected(msg),\n+            SendTimeoutError::Timeout(_) => unreachable!(),\n+        })\n+    }\n+\n+    /// Sends a message into the channel.\n+    pub(crate) fn send(\n+        &self,\n+        msg: T,\n+        _deadline: Option<Instant>,\n+    ) -> Result<(), SendTimeoutError<T>> {\n+        let token = &mut Token::default();\n+        assert!(self.start_send(token));\n+        unsafe { self.write(token, msg).map_err(SendTimeoutError::Disconnected) }\n+    }\n+\n+    /// Attempts to receive a message without blocking.\n+    pub(crate) fn try_recv(&self) -> Result<T, TryRecvError> {\n+        let token = &mut Token::default();\n+\n+        if self.start_recv(token) {\n+            unsafe { self.read(token).map_err(|_| TryRecvError::Disconnected) }\n+        } else {\n+            Err(TryRecvError::Empty)\n+        }\n+    }\n+\n+    /// Receives a message from the channel.\n+    pub(crate) fn recv(&self, deadline: Option<Instant>) -> Result<T, RecvTimeoutError> {\n+        let token = &mut Token::default();\n+        loop {\n+            if self.start_recv(token) {\n+                unsafe {\n+                    return self.read(token).map_err(|_| RecvTimeoutError::Disconnected);\n+                }\n+            }\n+\n+            if let Some(d) = deadline {\n+                if Instant::now() >= d {\n+                    return Err(RecvTimeoutError::Timeout);\n+                }\n+            }\n+\n+            // Prepare for blocking until a sender wakes us up.\n+            Context::with(|cx| {\n+                let oper = Operation::hook(token);\n+                self.receivers.register(oper, cx);\n+\n+                // Has the channel become ready just now?\n+                if !self.is_empty() || self.is_disconnected() {\n+                    let _ = cx.try_select(Selected::Aborted);\n+                }\n+\n+                // Block the current thread.\n+                let sel = cx.wait_until(deadline);\n+\n+                match sel {\n+                    Selected::Waiting => unreachable!(),\n+                    Selected::Aborted | Selected::Disconnected => {\n+                        self.receivers.unregister(oper).unwrap();\n+                        // If the channel was disconnected, we still have to check for remaining\n+                        // messages.\n+                    }\n+                    Selected::Operation(_) => {}\n+                }\n+            });\n+        }\n+    }\n+\n+    /// Returns the current number of messages inside the channel.\n+    pub(crate) fn len(&self) -> usize {\n+        loop {\n+            // Load the tail index, then load the head index.\n+            let mut tail = self.tail.index.load(Ordering::SeqCst);\n+            let mut head = self.head.index.load(Ordering::SeqCst);\n+\n+            // If the tail index didn't change, we've got consistent indices to work with.\n+            if self.tail.index.load(Ordering::SeqCst) == tail {\n+                // Erase the lower bits.\n+                tail &= !((1 << SHIFT) - 1);\n+                head &= !((1 << SHIFT) - 1);\n+\n+                // Fix up indices if they fall onto block ends.\n+                if (tail >> SHIFT) & (LAP - 1) == LAP - 1 {\n+                    tail = tail.wrapping_add(1 << SHIFT);\n+                }\n+                if (head >> SHIFT) & (LAP - 1) == LAP - 1 {\n+                    head = head.wrapping_add(1 << SHIFT);\n+                }\n+\n+                // Rotate indices so that head falls into the first block.\n+                let lap = (head >> SHIFT) / LAP;\n+                tail = tail.wrapping_sub((lap * LAP) << SHIFT);\n+                head = head.wrapping_sub((lap * LAP) << SHIFT);\n+\n+                // Remove the lower bits.\n+                tail >>= SHIFT;\n+                head >>= SHIFT;\n+\n+                // Return the difference minus the number of blocks between tail and head.\n+                return tail - head - tail / LAP;\n+            }\n+        }\n+    }\n+\n+    /// Returns the capacity of the channel.\n+    pub(crate) fn capacity(&self) -> Option<usize> {\n+        None\n+    }\n+\n+    /// Disconnects senders and wakes up all blocked receivers.\n+    ///\n+    /// Returns `true` if this call disconnected the channel.\n+    pub(crate) fn disconnect_senders(&self) -> bool {\n+        let tail = self.tail.index.fetch_or(MARK_BIT, Ordering::SeqCst);\n+\n+        if tail & MARK_BIT == 0 {\n+            self.receivers.disconnect();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Disconnects receivers.\n+    ///\n+    /// Returns `true` if this call disconnected the channel.\n+    pub(crate) fn disconnect_receivers(&self) -> bool {\n+        let tail = self.tail.index.fetch_or(MARK_BIT, Ordering::SeqCst);\n+\n+        if tail & MARK_BIT == 0 {\n+            // If receivers are dropped first, discard all messages to free\n+            // memory eagerly.\n+            self.discard_all_messages();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Discards all messages.\n+    ///\n+    /// This method should only be called when all receivers are dropped.\n+    fn discard_all_messages(&self) {\n+        let backoff = Backoff::new();\n+        let mut tail = self.tail.index.load(Ordering::Acquire);\n+        loop {\n+            let offset = (tail >> SHIFT) % LAP;\n+            if offset != BLOCK_CAP {\n+                break;\n+            }\n+\n+            // New updates to tail will be rejected by MARK_BIT and aborted unless it's\n+            // at boundary. We need to wait for the updates take affect otherwise there\n+            // can be memory leaks.\n+            backoff.snooze();\n+            tail = self.tail.index.load(Ordering::Acquire);\n+        }\n+\n+        let mut head = self.head.index.load(Ordering::Acquire);\n+        let mut block = self.head.block.load(Ordering::Acquire);\n+\n+        unsafe {\n+            // Drop all messages between head and tail and deallocate the heap-allocated blocks.\n+            while head >> SHIFT != tail >> SHIFT {\n+                let offset = (head >> SHIFT) % LAP;\n+\n+                if offset < BLOCK_CAP {\n+                    // Drop the message in the slot.\n+                    let slot = (*block).slots.get_unchecked(offset);\n+                    slot.wait_write();\n+                    let p = &mut *slot.msg.get();\n+                    p.as_mut_ptr().drop_in_place();\n+                } else {\n+                    (*block).wait_next();\n+                    // Deallocate the block and move to the next one.\n+                    let next = (*block).next.load(Ordering::Acquire);\n+                    drop(Box::from_raw(block));\n+                    block = next;\n+                }\n+\n+                head = head.wrapping_add(1 << SHIFT);\n+            }\n+\n+            // Deallocate the last remaining block.\n+            if !block.is_null() {\n+                drop(Box::from_raw(block));\n+            }\n+        }\n+        head &= !MARK_BIT;\n+        self.head.block.store(ptr::null_mut(), Ordering::Release);\n+        self.head.index.store(head, Ordering::Release);\n+    }\n+\n+    /// Returns `true` if the channel is disconnected.\n+    pub(crate) fn is_disconnected(&self) -> bool {\n+        self.tail.index.load(Ordering::SeqCst) & MARK_BIT != 0\n+    }\n+\n+    /// Returns `true` if the channel is empty.\n+    pub(crate) fn is_empty(&self) -> bool {\n+        let head = self.head.index.load(Ordering::SeqCst);\n+        let tail = self.tail.index.load(Ordering::SeqCst);\n+        head >> SHIFT == tail >> SHIFT\n+    }\n+\n+    /// Returns `true` if the channel is full.\n+    pub(crate) fn is_full(&self) -> bool {\n+        false\n+    }\n+}\n+\n+impl<T> Drop for Channel<T> {\n+    fn drop(&mut self) {\n+        let mut head = self.head.index.load(Ordering::Relaxed);\n+        let mut tail = self.tail.index.load(Ordering::Relaxed);\n+        let mut block = self.head.block.load(Ordering::Relaxed);\n+\n+        // Erase the lower bits.\n+        head &= !((1 << SHIFT) - 1);\n+        tail &= !((1 << SHIFT) - 1);\n+\n+        unsafe {\n+            // Drop all messages between head and tail and deallocate the heap-allocated blocks.\n+            while head != tail {\n+                let offset = (head >> SHIFT) % LAP;\n+\n+                if offset < BLOCK_CAP {\n+                    // Drop the message in the slot.\n+                    let slot = (*block).slots.get_unchecked(offset);\n+                    let p = &mut *slot.msg.get();\n+                    p.as_mut_ptr().drop_in_place();\n+                } else {\n+                    // Deallocate the block and move to the next one.\n+                    let next = (*block).next.load(Ordering::Relaxed);\n+                    drop(Box::from_raw(block));\n+                    block = next;\n+                }\n+\n+                head = head.wrapping_add(1 << SHIFT);\n+            }\n+\n+            // Deallocate the last remaining block.\n+            if !block.is_null() {\n+                drop(Box::from_raw(block));\n+            }\n+        }\n+    }\n+}"}, {"sha": "cef99c58843009bda1d5ddbe5b02fd64c93f32e2", "filename": "library/std/src/sync/mpmc/mod.rs", "status": "added", "additions": 430, "deletions": 0, "changes": 430, "blob_url": "https://github.com/rust-lang/rust/blob/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fmod.rs?ref=afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "patch": "@@ -0,0 +1,430 @@\n+//! Multi-producer multi-consumer channels.\n+\n+// This module is not currently exposed publicly, but is used\n+// as the implementation for the channels in `sync::mpsc`. The\n+// implementation comes from the crossbeam-channel crate:\n+//\n+// Copyright (c) 2019 The Crossbeam Project Developers\n+//\n+// Permission is hereby granted, free of charge, to any\n+// person obtaining a copy of this software and associated\n+// documentation files (the \"Software\"), to deal in the\n+// Software without restriction, including without\n+// limitation the rights to use, copy, modify, merge,\n+// publish, distribute, sublicense, and/or sell copies of\n+// the Software, and to permit persons to whom the Software\n+// is furnished to do so, subject to the following\n+// conditions:\n+//\n+// The above copyright notice and this permission notice\n+// shall be included in all copies or substantial portions\n+// of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+// ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n+// TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n+// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n+// SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n+// IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+// DEALINGS IN THE SOFTWARE.\n+\n+mod array;\n+mod context;\n+mod counter;\n+mod error;\n+mod list;\n+mod select;\n+mod utils;\n+mod waker;\n+mod zero;\n+\n+use crate::fmt;\n+use crate::panic::{RefUnwindSafe, UnwindSafe};\n+use crate::time::{Duration, Instant};\n+use error::*;\n+\n+/// Creates a channel of unbounded capacity.\n+///\n+/// This channel has a growable buffer that can hold any number of messages at a time.\n+pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n+    let (s, r) = counter::new(list::Channel::new());\n+    let s = Sender { flavor: SenderFlavor::List(s) };\n+    let r = Receiver { flavor: ReceiverFlavor::List(r) };\n+    (s, r)\n+}\n+\n+/// Creates a channel of bounded capacity.\n+///\n+/// This channel has a buffer that can hold at most `cap` messages at a time.\n+///\n+/// A special case is zero-capacity channel, which cannot hold any messages. Instead, send and\n+/// receive operations must appear at the same time in order to pair up and pass the message over.\n+pub fn sync_channel<T>(cap: usize) -> (Sender<T>, Receiver<T>) {\n+    if cap == 0 {\n+        let (s, r) = counter::new(zero::Channel::new());\n+        let s = Sender { flavor: SenderFlavor::Zero(s) };\n+        let r = Receiver { flavor: ReceiverFlavor::Zero(r) };\n+        (s, r)\n+    } else {\n+        let (s, r) = counter::new(array::Channel::with_capacity(cap));\n+        let s = Sender { flavor: SenderFlavor::Array(s) };\n+        let r = Receiver { flavor: ReceiverFlavor::Array(r) };\n+        (s, r)\n+    }\n+}\n+\n+/// The sending side of a channel.\n+pub struct Sender<T> {\n+    flavor: SenderFlavor<T>,\n+}\n+\n+/// Sender flavors.\n+enum SenderFlavor<T> {\n+    /// Bounded channel based on a preallocated array.\n+    Array(counter::Sender<array::Channel<T>>),\n+\n+    /// Unbounded channel implemented as a linked list.\n+    List(counter::Sender<list::Channel<T>>),\n+\n+    /// Zero-capacity channel.\n+    Zero(counter::Sender<zero::Channel<T>>),\n+}\n+\n+unsafe impl<T: Send> Send for Sender<T> {}\n+unsafe impl<T: Send> Sync for Sender<T> {}\n+\n+impl<T> UnwindSafe for Sender<T> {}\n+impl<T> RefUnwindSafe for Sender<T> {}\n+\n+impl<T> Sender<T> {\n+    /// Attempts to send a message into the channel without blocking.\n+    ///\n+    /// This method will either send a message into the channel immediately or return an error if\n+    /// the channel is full or disconnected. The returned error contains the original message.\n+    ///\n+    /// If called on a zero-capacity channel, this method will send the message only if there\n+    /// happens to be a receive operation on the other side of the channel at the same time.\n+    pub fn try_send(&self, msg: T) -> Result<(), TrySendError<T>> {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.try_send(msg),\n+            SenderFlavor::List(chan) => chan.try_send(msg),\n+            SenderFlavor::Zero(chan) => chan.try_send(msg),\n+        }\n+    }\n+\n+    /// Blocks the current thread until a message is sent or the channel is disconnected.\n+    ///\n+    /// If the channel is full and not disconnected, this call will block until the send operation\n+    /// can proceed. If the channel becomes disconnected, this call will wake up and return an\n+    /// error. The returned error contains the original message.\n+    ///\n+    /// If called on a zero-capacity channel, this method will wait for a receive operation to\n+    /// appear on the other side of the channel.\n+    pub fn send(&self, msg: T) -> Result<(), SendError<T>> {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.send(msg, None),\n+            SenderFlavor::List(chan) => chan.send(msg, None),\n+            SenderFlavor::Zero(chan) => chan.send(msg, None),\n+        }\n+        .map_err(|err| match err {\n+            SendTimeoutError::Disconnected(msg) => SendError(msg),\n+            SendTimeoutError::Timeout(_) => unreachable!(),\n+        })\n+    }\n+}\n+\n+// The methods below are not used by `sync::mpsc`, but\n+// are useful and we'll likely want to expose them\n+// eventually\n+#[allow(unused)]\n+impl<T> Sender<T> {\n+    /// Waits for a message to be sent into the channel, but only for a limited time.\n+    ///\n+    /// If the channel is full and not disconnected, this call will block until the send operation\n+    /// can proceed or the operation times out. If the channel becomes disconnected, this call will\n+    /// wake up and return an error. The returned error contains the original message.\n+    ///\n+    /// If called on a zero-capacity channel, this method will wait for a receive operation to\n+    /// appear on the other side of the channel.\n+    pub fn send_timeout(&self, msg: T, timeout: Duration) -> Result<(), SendTimeoutError<T>> {\n+        match Instant::now().checked_add(timeout) {\n+            Some(deadline) => self.send_deadline(msg, deadline),\n+            // So far in the future that it's practically the same as waiting indefinitely.\n+            None => self.send(msg).map_err(SendTimeoutError::from),\n+        }\n+    }\n+\n+    /// Waits for a message to be sent into the channel, but only until a given deadline.\n+    ///\n+    /// If the channel is full and not disconnected, this call will block until the send operation\n+    /// can proceed or the operation times out. If the channel becomes disconnected, this call will\n+    /// wake up and return an error. The returned error contains the original message.\n+    ///\n+    /// If called on a zero-capacity channel, this method will wait for a receive operation to\n+    /// appear on the other side of the channel.\n+    pub fn send_deadline(&self, msg: T, deadline: Instant) -> Result<(), SendTimeoutError<T>> {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.send(msg, Some(deadline)),\n+            SenderFlavor::List(chan) => chan.send(msg, Some(deadline)),\n+            SenderFlavor::Zero(chan) => chan.send(msg, Some(deadline)),\n+        }\n+    }\n+\n+    /// Returns `true` if the channel is empty.\n+    ///\n+    /// Note: Zero-capacity channels are always empty.\n+    pub fn is_empty(&self) -> bool {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.is_empty(),\n+            SenderFlavor::List(chan) => chan.is_empty(),\n+            SenderFlavor::Zero(chan) => chan.is_empty(),\n+        }\n+    }\n+\n+    /// Returns `true` if the channel is full.\n+    ///\n+    /// Note: Zero-capacity channels are always full.\n+    pub fn is_full(&self) -> bool {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.is_full(),\n+            SenderFlavor::List(chan) => chan.is_full(),\n+            SenderFlavor::Zero(chan) => chan.is_full(),\n+        }\n+    }\n+\n+    /// Returns the number of messages in the channel.\n+    pub fn len(&self) -> usize {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.len(),\n+            SenderFlavor::List(chan) => chan.len(),\n+            SenderFlavor::Zero(chan) => chan.len(),\n+        }\n+    }\n+\n+    /// If the channel is bounded, returns its capacity.\n+    pub fn capacity(&self) -> Option<usize> {\n+        match &self.flavor {\n+            SenderFlavor::Array(chan) => chan.capacity(),\n+            SenderFlavor::List(chan) => chan.capacity(),\n+            SenderFlavor::Zero(chan) => chan.capacity(),\n+        }\n+    }\n+\n+    /// Returns `true` if senders belong to the same channel.\n+    pub fn same_channel(&self, other: &Sender<T>) -> bool {\n+        match (&self.flavor, &other.flavor) {\n+            (SenderFlavor::Array(ref a), SenderFlavor::Array(ref b)) => a == b,\n+            (SenderFlavor::List(ref a), SenderFlavor::List(ref b)) => a == b,\n+            (SenderFlavor::Zero(ref a), SenderFlavor::Zero(ref b)) => a == b,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl<T> Drop for Sender<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            match &self.flavor {\n+                SenderFlavor::Array(chan) => chan.release(|c| c.disconnect()),\n+                SenderFlavor::List(chan) => chan.release(|c| c.disconnect_senders()),\n+                SenderFlavor::Zero(chan) => chan.release(|c| c.disconnect()),\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Clone for Sender<T> {\n+    fn clone(&self) -> Self {\n+        let flavor = match &self.flavor {\n+            SenderFlavor::Array(chan) => SenderFlavor::Array(chan.acquire()),\n+            SenderFlavor::List(chan) => SenderFlavor::List(chan.acquire()),\n+            SenderFlavor::Zero(chan) => SenderFlavor::Zero(chan.acquire()),\n+        };\n+\n+        Sender { flavor }\n+    }\n+}\n+\n+impl<T> fmt::Debug for Sender<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(\"Sender { .. }\")\n+    }\n+}\n+\n+/// The receiving side of a channel.\n+pub struct Receiver<T> {\n+    flavor: ReceiverFlavor<T>,\n+}\n+\n+/// Receiver flavors.\n+enum ReceiverFlavor<T> {\n+    /// Bounded channel based on a preallocated array.\n+    Array(counter::Receiver<array::Channel<T>>),\n+\n+    /// Unbounded channel implemented as a linked list.\n+    List(counter::Receiver<list::Channel<T>>),\n+\n+    /// Zero-capacity channel.\n+    Zero(counter::Receiver<zero::Channel<T>>),\n+}\n+\n+unsafe impl<T: Send> Send for Receiver<T> {}\n+unsafe impl<T: Send> Sync for Receiver<T> {}\n+\n+impl<T> UnwindSafe for Receiver<T> {}\n+impl<T> RefUnwindSafe for Receiver<T> {}\n+\n+impl<T> Receiver<T> {\n+    /// Attempts to receive a message from the channel without blocking.\n+    ///\n+    /// This method will either receive a message from the channel immediately or return an error\n+    /// if the channel is empty.\n+    ///\n+    /// If called on a zero-capacity channel, this method will receive a message only if there\n+    /// happens to be a send operation on the other side of the channel at the same time.\n+    pub fn try_recv(&self) -> Result<T, TryRecvError> {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.try_recv(),\n+            ReceiverFlavor::List(chan) => chan.try_recv(),\n+            ReceiverFlavor::Zero(chan) => chan.try_recv(),\n+        }\n+    }\n+\n+    /// Blocks the current thread until a message is received or the channel is empty and\n+    /// disconnected.\n+    ///\n+    /// If the channel is empty and not disconnected, this call will block until the receive\n+    /// operation can proceed. If the channel is empty and becomes disconnected, this call will\n+    /// wake up and return an error.\n+    ///\n+    /// If called on a zero-capacity channel, this method will wait for a send operation to appear\n+    /// on the other side of the channel.\n+    pub fn recv(&self) -> Result<T, RecvError> {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.recv(None),\n+            ReceiverFlavor::List(chan) => chan.recv(None),\n+            ReceiverFlavor::Zero(chan) => chan.recv(None),\n+        }\n+        .map_err(|_| RecvError)\n+    }\n+\n+    /// Waits for a message to be received from the channel, but only for a limited time.\n+    ///\n+    /// If the channel is empty and not disconnected, this call will block until the receive\n+    /// operation can proceed or the operation times out. If the channel is empty and becomes\n+    /// disconnected, this call will wake up and return an error.\n+    ///\n+    /// If called on a zero-capacity channel, this method will wait for a send operation to appear\n+    /// on the other side of the channel.\n+    pub fn recv_timeout(&self, timeout: Duration) -> Result<T, RecvTimeoutError> {\n+        match Instant::now().checked_add(timeout) {\n+            Some(deadline) => self.recv_deadline(deadline),\n+            // So far in the future that it's practically the same as waiting indefinitely.\n+            None => self.recv().map_err(RecvTimeoutError::from),\n+        }\n+    }\n+\n+    /// Waits for a message to be received from the channel, but only for a limited time.\n+    ///\n+    /// If the channel is empty and not disconnected, this call will block until the receive\n+    /// operation can proceed or the operation times out. If the channel is empty and becomes\n+    /// disconnected, this call will wake up and return an error.\n+    ///\n+    /// If called on a zero-capacity channel, this method will wait for a send operation to appear\n+    /// on the other side of the channel.\n+    pub fn recv_deadline(&self, deadline: Instant) -> Result<T, RecvTimeoutError> {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.recv(Some(deadline)),\n+            ReceiverFlavor::List(chan) => chan.recv(Some(deadline)),\n+            ReceiverFlavor::Zero(chan) => chan.recv(Some(deadline)),\n+        }\n+    }\n+}\n+\n+// The methods below are not used by `sync::mpsc`, but\n+// are useful and we'll likely want to expose them\n+// eventually\n+#[allow(unused)]\n+impl<T> Receiver<T> {\n+    /// Returns `true` if the channel is empty.\n+    ///\n+    /// Note: Zero-capacity channels are always empty.\n+    pub fn is_empty(&self) -> bool {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.is_empty(),\n+            ReceiverFlavor::List(chan) => chan.is_empty(),\n+            ReceiverFlavor::Zero(chan) => chan.is_empty(),\n+        }\n+    }\n+\n+    /// Returns `true` if the channel is full.\n+    ///\n+    /// Note: Zero-capacity channels are always full.\n+    pub fn is_full(&self) -> bool {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.is_full(),\n+            ReceiverFlavor::List(chan) => chan.is_full(),\n+            ReceiverFlavor::Zero(chan) => chan.is_full(),\n+        }\n+    }\n+\n+    /// Returns the number of messages in the channel.\n+    pub fn len(&self) -> usize {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.len(),\n+            ReceiverFlavor::List(chan) => chan.len(),\n+            ReceiverFlavor::Zero(chan) => chan.len(),\n+        }\n+    }\n+\n+    /// If the channel is bounded, returns its capacity.\n+    pub fn capacity(&self) -> Option<usize> {\n+        match &self.flavor {\n+            ReceiverFlavor::Array(chan) => chan.capacity(),\n+            ReceiverFlavor::List(chan) => chan.capacity(),\n+            ReceiverFlavor::Zero(chan) => chan.capacity(),\n+        }\n+    }\n+\n+    /// Returns `true` if receivers belong to the same channel.\n+    pub fn same_channel(&self, other: &Receiver<T>) -> bool {\n+        match (&self.flavor, &other.flavor) {\n+            (ReceiverFlavor::Array(a), ReceiverFlavor::Array(b)) => a == b,\n+            (ReceiverFlavor::List(a), ReceiverFlavor::List(b)) => a == b,\n+            (ReceiverFlavor::Zero(a), ReceiverFlavor::Zero(b)) => a == b,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl<T> Drop for Receiver<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            match &self.flavor {\n+                ReceiverFlavor::Array(chan) => chan.release(|c| c.disconnect()),\n+                ReceiverFlavor::List(chan) => chan.release(|c| c.disconnect_receivers()),\n+                ReceiverFlavor::Zero(chan) => chan.release(|c| c.disconnect()),\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Clone for Receiver<T> {\n+    fn clone(&self) -> Self {\n+        let flavor = match &self.flavor {\n+            ReceiverFlavor::Array(chan) => ReceiverFlavor::Array(chan.acquire()),\n+            ReceiverFlavor::List(chan) => ReceiverFlavor::List(chan.acquire()),\n+            ReceiverFlavor::Zero(chan) => ReceiverFlavor::Zero(chan.acquire()),\n+        };\n+\n+        Receiver { flavor }\n+    }\n+}\n+\n+impl<T> fmt::Debug for Receiver<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(\"Receiver { .. }\")\n+    }\n+}"}, {"sha": "56a83fee2e119c3396c394b67ca99d8599f117a2", "filename": "library/std/src/sync/mpmc/select.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fselect.rs?ref=afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "patch": "@@ -0,0 +1,71 @@\n+/// Temporary data that gets initialized during a blocking operation, and is consumed by\n+/// `read` or `write`.\n+///\n+/// Each field contains data associated with a specific channel flavor.\n+#[derive(Debug, Default)]\n+pub struct Token {\n+    pub(crate) array: super::array::ArrayToken,\n+    pub(crate) list: super::list::ListToken,\n+    #[allow(dead_code)]\n+    pub(crate) zero: super::zero::ZeroToken,\n+}\n+\n+/// Identifier associated with an operation by a specific thread on a specific channel.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub struct Operation(usize);\n+\n+impl Operation {\n+    /// Creates an operation identifier from a mutable reference.\n+    ///\n+    /// This function essentially just turns the address of the reference into a number. The\n+    /// reference should point to a variable that is specific to the thread and the operation,\n+    /// and is alive for the entire duration of a blocking operation.\n+    #[inline]\n+    pub fn hook<T>(r: &mut T) -> Operation {\n+        let val = r as *mut T as usize;\n+        // Make sure that the pointer address doesn't equal the numerical representation of\n+        // `Selected::{Waiting, Aborted, Disconnected}`.\n+        assert!(val > 2);\n+        Operation(val)\n+    }\n+}\n+\n+/// Current state of a blocking operation.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum Selected {\n+    /// Still waiting for an operation.\n+    Waiting,\n+\n+    /// The attempt to block the current thread has been aborted.\n+    Aborted,\n+\n+    /// An operation became ready because a channel is disconnected.\n+    Disconnected,\n+\n+    /// An operation became ready because a message can be sent or received.\n+    Operation(Operation),\n+}\n+\n+impl From<usize> for Selected {\n+    #[inline]\n+    fn from(val: usize) -> Selected {\n+        match val {\n+            0 => Selected::Waiting,\n+            1 => Selected::Aborted,\n+            2 => Selected::Disconnected,\n+            oper => Selected::Operation(Operation(oper)),\n+        }\n+    }\n+}\n+\n+impl Into<usize> for Selected {\n+    #[inline]\n+    fn into(self) -> usize {\n+        match self {\n+            Selected::Waiting => 0,\n+            Selected::Aborted => 1,\n+            Selected::Disconnected => 2,\n+            Selected::Operation(Operation(val)) => val,\n+        }\n+    }\n+}"}, {"sha": "d0904b4b94cbcc09cb705eca3d42de6ada989ce2", "filename": "library/std/src/sync/mpmc/utils.rs", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Futils.rs?ref=afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "patch": "@@ -0,0 +1,144 @@\n+use crate::cell::Cell;\n+use crate::ops::{Deref, DerefMut};\n+\n+/// Pads and aligns a value to the length of a cache line.\n+#[derive(Clone, Copy, Default, Hash, PartialEq, Eq)]\n+// Starting from Intel's Sandy Bridge, spatial prefetcher is now pulling pairs of 64-byte cache\n+// lines at a time, so we have to align to 128 bytes rather than 64.\n+//\n+// Sources:\n+// - https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf\n+// - https://github.com/facebook/folly/blob/1b5288e6eea6df074758f877c849b6e73bbb9fbb/folly/lang/Align.h#L107\n+//\n+// ARM's big.LITTLE architecture has asymmetric cores and \"big\" cores have 128-byte cache line size.\n+//\n+// Sources:\n+// - https://www.mono-project.com/news/2016/09/12/arm64-icache/\n+//\n+// powerpc64 has 128-byte cache line size.\n+//\n+// Sources:\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_ppc64x.go#L9\n+#[cfg_attr(\n+    any(target_arch = \"x86_64\", target_arch = \"aarch64\", target_arch = \"powerpc64\",),\n+    repr(align(128))\n+)]\n+// arm, mips, mips64, and riscv64 have 32-byte cache line size.\n+//\n+// Sources:\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_arm.go#L7\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_mips.go#L7\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_mipsle.go#L7\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_mips64x.go#L9\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_riscv64.go#L7\n+#[cfg_attr(\n+    any(\n+        target_arch = \"arm\",\n+        target_arch = \"mips\",\n+        target_arch = \"mips64\",\n+        target_arch = \"riscv64\",\n+    ),\n+    repr(align(32))\n+)]\n+// s390x has 256-byte cache line size.\n+//\n+// Sources:\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_s390x.go#L7\n+#[cfg_attr(target_arch = \"s390x\", repr(align(256)))]\n+// x86 and wasm have 64-byte cache line size.\n+//\n+// Sources:\n+// - https://github.com/golang/go/blob/dda2991c2ea0c5914714469c4defc2562a907230/src/internal/cpu/cpu_x86.go#L9\n+// - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_wasm.go#L7\n+//\n+// All others are assumed to have 64-byte cache line size.\n+#[cfg_attr(\n+    not(any(\n+        target_arch = \"x86_64\",\n+        target_arch = \"aarch64\",\n+        target_arch = \"powerpc64\",\n+        target_arch = \"arm\",\n+        target_arch = \"mips\",\n+        target_arch = \"mips64\",\n+        target_arch = \"riscv64\",\n+        target_arch = \"s390x\",\n+    )),\n+    repr(align(64))\n+)]\n+pub struct CachePadded<T> {\n+    value: T,\n+}\n+\n+impl<T> CachePadded<T> {\n+    /// Pads and aligns a value to the length of a cache line.\n+    pub fn new(value: T) -> CachePadded<T> {\n+        CachePadded::<T> { value }\n+    }\n+}\n+\n+impl<T> Deref for CachePadded<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &self.value\n+    }\n+}\n+\n+impl<T> DerefMut for CachePadded<T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut self.value\n+    }\n+}\n+\n+const SPIN_LIMIT: u32 = 6;\n+const YIELD_LIMIT: u32 = 10;\n+\n+/// Performs exponential backoff in spin loops.\n+pub struct Backoff {\n+    step: Cell<u32>,\n+}\n+\n+impl Backoff {\n+    /// Creates a new `Backoff`.\n+    pub fn new() -> Self {\n+        Backoff { step: Cell::new(0) }\n+    }\n+\n+    /// Backs off in a lock-free loop.\n+    ///\n+    /// This method should be used when we need to retry an operation because another thread made\n+    /// progress.\n+    #[inline]\n+    pub fn spin(&self) {\n+        let step = self.step.get().min(SPIN_LIMIT);\n+        for _ in 0..step.pow(2) {\n+            crate::hint::spin_loop();\n+        }\n+\n+        if self.step.get() <= SPIN_LIMIT {\n+            self.step.set(self.step.get() + 1);\n+        }\n+    }\n+\n+    /// Backs off in a blocking loop.\n+    #[inline]\n+    pub fn snooze(&self) {\n+        if self.step.get() <= SPIN_LIMIT {\n+            for _ in 0..self.step.get().pow(2) {\n+                crate::hint::spin_loop()\n+            }\n+        } else {\n+            crate::thread::yield_now();\n+        }\n+\n+        if self.step.get() <= YIELD_LIMIT {\n+            self.step.set(self.step.get() + 1);\n+        }\n+    }\n+\n+    /// Returns `true` if exponential backoff has completed and blocking the thread is advised.\n+    #[inline]\n+    pub fn is_completed(&self) -> bool {\n+        self.step.get() > YIELD_LIMIT\n+    }\n+}"}, {"sha": "4912ca4f8150bc8d3c1a56ecf6d07695015b475f", "filename": "library/std/src/sync/mpmc/waker.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fwaker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fwaker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fwaker.rs?ref=afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "patch": "@@ -0,0 +1,204 @@\n+//! Waking mechanism for threads blocked on channel operations.\n+\n+use super::context::Context;\n+use super::select::{Operation, Selected};\n+\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicBool, Ordering};\n+use crate::sync::Mutex;\n+\n+/// Represents a thread blocked on a specific channel operation.\n+pub(crate) struct Entry {\n+    /// The operation.\n+    pub(crate) oper: Operation,\n+\n+    /// Optional packet.\n+    pub(crate) packet: *mut (),\n+\n+    /// Context associated with the thread owning this operation.\n+    pub(crate) cx: Context,\n+}\n+\n+/// A queue of threads blocked on channel operations.\n+///\n+/// This data structure is used by threads to register blocking operations and get woken up once\n+/// an operation becomes ready.\n+pub(crate) struct Waker {\n+    /// A list of select operations.\n+    selectors: Vec<Entry>,\n+\n+    /// A list of operations waiting to be ready.\n+    observers: Vec<Entry>,\n+}\n+\n+impl Waker {\n+    /// Creates a new `Waker`.\n+    #[inline]\n+    pub(crate) fn new() -> Self {\n+        Waker { selectors: Vec::new(), observers: Vec::new() }\n+    }\n+\n+    /// Registers a select operation.\n+    #[inline]\n+    pub(crate) fn register(&mut self, oper: Operation, cx: &Context) {\n+        self.register_with_packet(oper, ptr::null_mut(), cx);\n+    }\n+\n+    /// Registers a select operation and a packet.\n+    #[inline]\n+    pub(crate) fn register_with_packet(&mut self, oper: Operation, packet: *mut (), cx: &Context) {\n+        self.selectors.push(Entry { oper, packet, cx: cx.clone() });\n+    }\n+\n+    /// Unregisters a select operation.\n+    #[inline]\n+    pub(crate) fn unregister(&mut self, oper: Operation) -> Option<Entry> {\n+        if let Some((i, _)) =\n+            self.selectors.iter().enumerate().find(|&(_, entry)| entry.oper == oper)\n+        {\n+            let entry = self.selectors.remove(i);\n+            Some(entry)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Attempts to find another thread's entry, select the operation, and wake it up.\n+    #[inline]\n+    pub(crate) fn try_select(&mut self) -> Option<Entry> {\n+        self.selectors\n+            .iter()\n+            .position(|selector| {\n+                // Does the entry belong to a different thread?\n+                selector.cx.thread_id() != current_thread_id()\n+                    && selector // Try selecting this operation.\n+                        .cx\n+                        .try_select(Selected::Operation(selector.oper))\n+                        .is_ok()\n+                    && {\n+                        // Provide the packet.\n+                        selector.cx.store_packet(selector.packet);\n+                        // Wake the thread up.\n+                        selector.cx.unpark();\n+                        true\n+                    }\n+            })\n+            // Remove the entry from the queue to keep it clean and improve\n+            // performance.\n+            .map(|pos| self.selectors.remove(pos))\n+    }\n+\n+    /// Notifies all operations waiting to be ready.\n+    #[inline]\n+    pub(crate) fn notify(&mut self) {\n+        for entry in self.observers.drain(..) {\n+            if entry.cx.try_select(Selected::Operation(entry.oper)).is_ok() {\n+                entry.cx.unpark();\n+            }\n+        }\n+    }\n+\n+    /// Notifies all registered operations that the channel is disconnected.\n+    #[inline]\n+    pub(crate) fn disconnect(&mut self) {\n+        for entry in self.selectors.iter() {\n+            if entry.cx.try_select(Selected::Disconnected).is_ok() {\n+                // Wake the thread up.\n+                //\n+                // Here we don't remove the entry from the queue. Registered threads must\n+                // unregister from the waker by themselves. They might also want to recover the\n+                // packet value and destroy it, if necessary.\n+                entry.cx.unpark();\n+            }\n+        }\n+\n+        self.notify();\n+    }\n+}\n+\n+impl Drop for Waker {\n+    #[inline]\n+    fn drop(&mut self) {\n+        debug_assert_eq!(self.selectors.len(), 0);\n+        debug_assert_eq!(self.observers.len(), 0);\n+    }\n+}\n+\n+/// A waker that can be shared among threads without locking.\n+///\n+/// This is a simple wrapper around `Waker` that internally uses a mutex for synchronization.\n+pub(crate) struct SyncWaker {\n+    /// The inner `Waker`.\n+    inner: Mutex<Waker>,\n+\n+    /// `true` if the waker is empty.\n+    is_empty: AtomicBool,\n+}\n+\n+impl SyncWaker {\n+    /// Creates a new `SyncWaker`.\n+    #[inline]\n+    pub(crate) fn new() -> Self {\n+        SyncWaker { inner: Mutex::new(Waker::new()), is_empty: AtomicBool::new(true) }\n+    }\n+\n+    /// Registers the current thread with an operation.\n+    #[inline]\n+    pub(crate) fn register(&self, oper: Operation, cx: &Context) {\n+        let mut inner = self.inner.lock().unwrap();\n+        inner.register(oper, cx);\n+        self.is_empty\n+            .store(inner.selectors.is_empty() && inner.observers.is_empty(), Ordering::SeqCst);\n+    }\n+\n+    /// Unregisters an operation previously registered by the current thread.\n+    #[inline]\n+    pub(crate) fn unregister(&self, oper: Operation) -> Option<Entry> {\n+        let mut inner = self.inner.lock().unwrap();\n+        let entry = inner.unregister(oper);\n+        self.is_empty\n+            .store(inner.selectors.is_empty() && inner.observers.is_empty(), Ordering::SeqCst);\n+        entry\n+    }\n+\n+    /// Attempts to find one thread (not the current one), select its operation, and wake it up.\n+    #[inline]\n+    pub(crate) fn notify(&self) {\n+        if !self.is_empty.load(Ordering::SeqCst) {\n+            let mut inner = self.inner.lock().unwrap();\n+            if !self.is_empty.load(Ordering::SeqCst) {\n+                inner.try_select();\n+                inner.notify();\n+                self.is_empty.store(\n+                    inner.selectors.is_empty() && inner.observers.is_empty(),\n+                    Ordering::SeqCst,\n+                );\n+            }\n+        }\n+    }\n+\n+    /// Notifies all threads that the channel is disconnected.\n+    #[inline]\n+    pub(crate) fn disconnect(&self) {\n+        let mut inner = self.inner.lock().unwrap();\n+        inner.disconnect();\n+        self.is_empty\n+            .store(inner.selectors.is_empty() && inner.observers.is_empty(), Ordering::SeqCst);\n+    }\n+}\n+\n+impl Drop for SyncWaker {\n+    #[inline]\n+    fn drop(&mut self) {\n+        debug_assert!(self.is_empty.load(Ordering::SeqCst));\n+    }\n+}\n+\n+/// Returns a unique id for the current thread.\n+#[inline]\n+pub fn current_thread_id() -> usize {\n+    // `u8` is not drop so this variable will be available during thread destruction,\n+    // whereas `thread::current()` would not be\n+    thread_local! { static DUMMY: u8 = 0 }\n+    DUMMY.with(|x| (x as *const u8).addr())\n+}"}, {"sha": "fccd6c29a7e462f5993bb30c72526d3fe44c0913", "filename": "library/std/src/sync/mpmc/zero.rs", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Fzero.rs?ref=afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "patch": "@@ -0,0 +1,318 @@\n+//! Zero-capacity channel.\n+//!\n+//! This kind of channel is also known as *rendezvous* channel.\n+\n+use super::context::Context;\n+use super::error::*;\n+use super::select::{Operation, Selected, Token};\n+use super::utils::Backoff;\n+use super::waker::Waker;\n+\n+use crate::cell::UnsafeCell;\n+use crate::marker::PhantomData;\n+use crate::sync::atomic::{AtomicBool, Ordering};\n+use crate::sync::Mutex;\n+use crate::time::Instant;\n+use crate::{fmt, ptr};\n+\n+/// A pointer to a packet.\n+pub(crate) struct ZeroToken(*mut ());\n+\n+impl Default for ZeroToken {\n+    fn default() -> Self {\n+        Self(ptr::null_mut())\n+    }\n+}\n+\n+impl fmt::Debug for ZeroToken {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Debug::fmt(&(self.0 as usize), f)\n+    }\n+}\n+\n+/// A slot for passing one message from a sender to a receiver.\n+struct Packet<T> {\n+    /// Equals `true` if the packet is allocated on the stack.\n+    on_stack: bool,\n+\n+    /// Equals `true` once the packet is ready for reading or writing.\n+    ready: AtomicBool,\n+\n+    /// The message.\n+    msg: UnsafeCell<Option<T>>,\n+}\n+\n+impl<T> Packet<T> {\n+    /// Creates an empty packet on the stack.\n+    fn empty_on_stack() -> Packet<T> {\n+        Packet { on_stack: true, ready: AtomicBool::new(false), msg: UnsafeCell::new(None) }\n+    }\n+\n+    /// Creates a packet on the stack, containing a message.\n+    fn message_on_stack(msg: T) -> Packet<T> {\n+        Packet { on_stack: true, ready: AtomicBool::new(false), msg: UnsafeCell::new(Some(msg)) }\n+    }\n+\n+    /// Waits until the packet becomes ready for reading or writing.\n+    fn wait_ready(&self) {\n+        let backoff = Backoff::new();\n+        while !self.ready.load(Ordering::Acquire) {\n+            backoff.snooze();\n+        }\n+    }\n+}\n+\n+/// Inner representation of a zero-capacity channel.\n+struct Inner {\n+    /// Senders waiting to pair up with a receive operation.\n+    senders: Waker,\n+\n+    /// Receivers waiting to pair up with a send operation.\n+    receivers: Waker,\n+\n+    /// Equals `true` when the channel is disconnected.\n+    is_disconnected: bool,\n+}\n+\n+/// Zero-capacity channel.\n+pub(crate) struct Channel<T> {\n+    /// Inner representation of the channel.\n+    inner: Mutex<Inner>,\n+\n+    /// Indicates that dropping a `Channel<T>` may drop values of type `T`.\n+    _marker: PhantomData<T>,\n+}\n+\n+impl<T> Channel<T> {\n+    /// Constructs a new zero-capacity channel.\n+    pub(crate) fn new() -> Self {\n+        Channel {\n+            inner: Mutex::new(Inner {\n+                senders: Waker::new(),\n+                receivers: Waker::new(),\n+                is_disconnected: false,\n+            }),\n+            _marker: PhantomData,\n+        }\n+    }\n+\n+    /// Writes a message into the packet.\n+    pub(crate) unsafe fn write(&self, token: &mut Token, msg: T) -> Result<(), T> {\n+        // If there is no packet, the channel is disconnected.\n+        if token.zero.0.is_null() {\n+            return Err(msg);\n+        }\n+\n+        let packet = &*(token.zero.0 as *const Packet<T>);\n+        packet.msg.get().write(Some(msg));\n+        packet.ready.store(true, Ordering::Release);\n+        Ok(())\n+    }\n+\n+    /// Reads a message from the packet.\n+    pub(crate) unsafe fn read(&self, token: &mut Token) -> Result<T, ()> {\n+        // If there is no packet, the channel is disconnected.\n+        if token.zero.0.is_null() {\n+            return Err(());\n+        }\n+\n+        let packet = &*(token.zero.0 as *const Packet<T>);\n+\n+        if packet.on_stack {\n+            // The message has been in the packet from the beginning, so there is no need to wait\n+            // for it. However, after reading the message, we need to set `ready` to `true` in\n+            // order to signal that the packet can be destroyed.\n+            let msg = packet.msg.get().replace(None).unwrap();\n+            packet.ready.store(true, Ordering::Release);\n+            Ok(msg)\n+        } else {\n+            // Wait until the message becomes available, then read it and destroy the\n+            // heap-allocated packet.\n+            packet.wait_ready();\n+            let msg = packet.msg.get().replace(None).unwrap();\n+            drop(Box::from_raw(token.zero.0 as *mut Packet<T>));\n+            Ok(msg)\n+        }\n+    }\n+\n+    /// Attempts to send a message into the channel.\n+    pub(crate) fn try_send(&self, msg: T) -> Result<(), TrySendError<T>> {\n+        let token = &mut Token::default();\n+        let mut inner = self.inner.lock().unwrap();\n+\n+        // If there's a waiting receiver, pair up with it.\n+        if let Some(operation) = inner.receivers.try_select() {\n+            token.zero.0 = operation.packet;\n+            drop(inner);\n+            unsafe {\n+                self.write(token, msg).ok().unwrap();\n+            }\n+            Ok(())\n+        } else if inner.is_disconnected {\n+            Err(TrySendError::Disconnected(msg))\n+        } else {\n+            Err(TrySendError::Full(msg))\n+        }\n+    }\n+\n+    /// Sends a message into the channel.\n+    pub(crate) fn send(\n+        &self,\n+        msg: T,\n+        deadline: Option<Instant>,\n+    ) -> Result<(), SendTimeoutError<T>> {\n+        let token = &mut Token::default();\n+        let mut inner = self.inner.lock().unwrap();\n+\n+        // If there's a waiting receiver, pair up with it.\n+        if let Some(operation) = inner.receivers.try_select() {\n+            token.zero.0 = operation.packet;\n+            drop(inner);\n+            unsafe {\n+                self.write(token, msg).ok().unwrap();\n+            }\n+            return Ok(());\n+        }\n+\n+        if inner.is_disconnected {\n+            return Err(SendTimeoutError::Disconnected(msg));\n+        }\n+\n+        Context::with(|cx| {\n+            // Prepare for blocking until a receiver wakes us up.\n+            let oper = Operation::hook(token);\n+            let mut packet = Packet::<T>::message_on_stack(msg);\n+            inner.senders.register_with_packet(oper, &mut packet as *mut Packet<T> as *mut (), cx);\n+            inner.receivers.notify();\n+            drop(inner);\n+\n+            // Block the current thread.\n+            let sel = cx.wait_until(deadline);\n+\n+            match sel {\n+                Selected::Waiting => unreachable!(),\n+                Selected::Aborted => {\n+                    self.inner.lock().unwrap().senders.unregister(oper).unwrap();\n+                    let msg = unsafe { packet.msg.get().replace(None).unwrap() };\n+                    Err(SendTimeoutError::Timeout(msg))\n+                }\n+                Selected::Disconnected => {\n+                    self.inner.lock().unwrap().senders.unregister(oper).unwrap();\n+                    let msg = unsafe { packet.msg.get().replace(None).unwrap() };\n+                    Err(SendTimeoutError::Disconnected(msg))\n+                }\n+                Selected::Operation(_) => {\n+                    // Wait until the message is read, then drop the packet.\n+                    packet.wait_ready();\n+                    Ok(())\n+                }\n+            }\n+        })\n+    }\n+\n+    /// Attempts to receive a message without blocking.\n+    pub(crate) fn try_recv(&self) -> Result<T, TryRecvError> {\n+        let token = &mut Token::default();\n+        let mut inner = self.inner.lock().unwrap();\n+\n+        // If there's a waiting sender, pair up with it.\n+        if let Some(operation) = inner.senders.try_select() {\n+            token.zero.0 = operation.packet;\n+            drop(inner);\n+            unsafe { self.read(token).map_err(|_| TryRecvError::Disconnected) }\n+        } else if inner.is_disconnected {\n+            Err(TryRecvError::Disconnected)\n+        } else {\n+            Err(TryRecvError::Empty)\n+        }\n+    }\n+\n+    /// Receives a message from the channel.\n+    pub(crate) fn recv(&self, deadline: Option<Instant>) -> Result<T, RecvTimeoutError> {\n+        let token = &mut Token::default();\n+        let mut inner = self.inner.lock().unwrap();\n+\n+        // If there's a waiting sender, pair up with it.\n+        if let Some(operation) = inner.senders.try_select() {\n+            token.zero.0 = operation.packet;\n+            drop(inner);\n+            unsafe {\n+                return self.read(token).map_err(|_| RecvTimeoutError::Disconnected);\n+            }\n+        }\n+\n+        if inner.is_disconnected {\n+            return Err(RecvTimeoutError::Disconnected);\n+        }\n+\n+        Context::with(|cx| {\n+            // Prepare for blocking until a sender wakes us up.\n+            let oper = Operation::hook(token);\n+            let mut packet = Packet::<T>::empty_on_stack();\n+            inner.receivers.register_with_packet(\n+                oper,\n+                &mut packet as *mut Packet<T> as *mut (),\n+                cx,\n+            );\n+            inner.senders.notify();\n+            drop(inner);\n+\n+            // Block the current thread.\n+            let sel = cx.wait_until(deadline);\n+\n+            match sel {\n+                Selected::Waiting => unreachable!(),\n+                Selected::Aborted => {\n+                    self.inner.lock().unwrap().receivers.unregister(oper).unwrap();\n+                    Err(RecvTimeoutError::Timeout)\n+                }\n+                Selected::Disconnected => {\n+                    self.inner.lock().unwrap().receivers.unregister(oper).unwrap();\n+                    Err(RecvTimeoutError::Disconnected)\n+                }\n+                Selected::Operation(_) => {\n+                    // Wait until the message is provided, then read it.\n+                    packet.wait_ready();\n+                    unsafe { Ok(packet.msg.get().replace(None).unwrap()) }\n+                }\n+            }\n+        })\n+    }\n+\n+    /// Disconnects the channel and wakes up all blocked senders and receivers.\n+    ///\n+    /// Returns `true` if this call disconnected the channel.\n+    pub(crate) fn disconnect(&self) -> bool {\n+        let mut inner = self.inner.lock().unwrap();\n+\n+        if !inner.is_disconnected {\n+            inner.is_disconnected = true;\n+            inner.senders.disconnect();\n+            inner.receivers.disconnect();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Returns the current number of messages inside the channel.\n+    pub(crate) fn len(&self) -> usize {\n+        0\n+    }\n+\n+    /// Returns the capacity of the channel.\n+    #[allow(clippy::unnecessary_wraps)] // This is intentional.\n+    pub(crate) fn capacity(&self) -> Option<usize> {\n+        Some(0)\n+    }\n+\n+    /// Returns `true` if the channel is empty.\n+    pub(crate) fn is_empty(&self) -> bool {\n+        true\n+    }\n+\n+    /// Returns `true` if the channel is full.\n+    pub(crate) fn is_full(&self) -> bool {\n+        true\n+    }\n+}"}, {"sha": "021df7b096cbc0670155fa63fcc65d8798544147", "filename": "library/std/src/sync/mpsc/blocking.rs", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/928d14bcd1976ffd33e743aa09c7c22a063bf87c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928d14bcd1976ffd33e743aa09c7c22a063bf87c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fblocking.rs?ref=928d14bcd1976ffd33e743aa09c7c22a063bf87c", "patch": "@@ -1,82 +0,0 @@\n-//! Generic support for building blocking abstractions.\n-\n-use crate::sync::atomic::{AtomicBool, Ordering};\n-use crate::sync::Arc;\n-use crate::thread::{self, Thread};\n-use crate::time::Instant;\n-\n-struct Inner {\n-    thread: Thread,\n-    woken: AtomicBool,\n-}\n-\n-unsafe impl Send for Inner {}\n-unsafe impl Sync for Inner {}\n-\n-#[derive(Clone)]\n-pub struct SignalToken {\n-    inner: Arc<Inner>,\n-}\n-\n-pub struct WaitToken {\n-    inner: Arc<Inner>,\n-}\n-\n-impl !Send for WaitToken {}\n-\n-impl !Sync for WaitToken {}\n-\n-pub fn tokens() -> (WaitToken, SignalToken) {\n-    let inner = Arc::new(Inner { thread: thread::current(), woken: AtomicBool::new(false) });\n-    let wait_token = WaitToken { inner: inner.clone() };\n-    let signal_token = SignalToken { inner };\n-    (wait_token, signal_token)\n-}\n-\n-impl SignalToken {\n-    pub fn signal(&self) -> bool {\n-        let wake = self\n-            .inner\n-            .woken\n-            .compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)\n-            .is_ok();\n-        if wake {\n-            self.inner.thread.unpark();\n-        }\n-        wake\n-    }\n-\n-    /// Converts to an unsafe raw pointer. Useful for storing in a pipe's state\n-    /// flag.\n-    #[inline]\n-    pub unsafe fn to_raw(self) -> *mut u8 {\n-        Arc::into_raw(self.inner) as *mut u8\n-    }\n-\n-    /// Converts from an unsafe raw pointer. Useful for retrieving a pipe's state\n-    /// flag.\n-    #[inline]\n-    pub unsafe fn from_raw(signal_ptr: *mut u8) -> SignalToken {\n-        SignalToken { inner: Arc::from_raw(signal_ptr as *mut Inner) }\n-    }\n-}\n-\n-impl WaitToken {\n-    pub fn wait(self) {\n-        while !self.inner.woken.load(Ordering::SeqCst) {\n-            thread::park()\n-        }\n-    }\n-\n-    /// Returns `true` if we wake up normally.\n-    pub fn wait_max_until(self, end: Instant) -> bool {\n-        while !self.inner.woken.load(Ordering::SeqCst) {\n-            let now = Instant::now();\n-            if now >= end {\n-                return false;\n-            }\n-            thread::park_timeout(end - now)\n-        }\n-        true\n-    }\n-}"}, {"sha": "9197f0d6e6c8c3a2f737096cc9f7fff29ef625fb", "filename": "library/std/src/sync/mpsc/cache_aligned.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/928d14bcd1976ffd33e743aa09c7c22a063bf87c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fcache_aligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928d14bcd1976ffd33e743aa09c7c22a063bf87c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fcache_aligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fcache_aligned.rs?ref=928d14bcd1976ffd33e743aa09c7c22a063bf87c", "patch": "@@ -1,25 +0,0 @@\n-use crate::ops::{Deref, DerefMut};\n-\n-#[derive(Copy, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-#[cfg_attr(target_arch = \"aarch64\", repr(align(128)))]\n-#[cfg_attr(not(target_arch = \"aarch64\"), repr(align(64)))]\n-pub(super) struct CacheAligned<T>(pub T);\n-\n-impl<T> Deref for CacheAligned<T> {\n-    type Target = T;\n-    fn deref(&self) -> &Self::Target {\n-        &self.0\n-    }\n-}\n-\n-impl<T> DerefMut for CacheAligned<T> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        &mut self.0\n-    }\n-}\n-\n-impl<T> CacheAligned<T> {\n-    pub(super) fn new(t: T) -> Self {\n-        CacheAligned(t)\n-    }\n-}"}, {"sha": "27fba761ada108c191ec9cbe9ddcea4c3b33ee95", "filename": "library/std/src/sync/mpsc/mod.rs", "status": "modified", "additions": 24, "deletions": 434, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs?ref=afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "patch": "@@ -143,175 +143,16 @@ mod tests;\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod sync_tests;\n \n-// A description of how Rust's channel implementation works\n-//\n-// Channels are supposed to be the basic building block for all other\n-// concurrent primitives that are used in Rust. As a result, the channel type\n-// needs to be highly optimized, flexible, and broad enough for use everywhere.\n-//\n-// The choice of implementation of all channels is to be built on lock-free data\n-// structures. The channels themselves are then consequently also lock-free data\n-// structures. As always with lock-free code, this is a very \"here be dragons\"\n-// territory, especially because I'm unaware of any academic papers that have\n-// gone into great length about channels of these flavors.\n-//\n-// ## Flavors of channels\n-//\n-// From the perspective of a consumer of this library, there is only one flavor\n-// of channel. This channel can be used as a stream and cloned to allow multiple\n-// senders. Under the hood, however, there are actually three flavors of\n-// channels in play.\n-//\n-// * Flavor::Oneshots - these channels are highly optimized for the one-send use\n-//                      case. They contain as few atomics as possible and\n-//                      involve one and exactly one allocation.\n-// * Streams - these channels are optimized for the non-shared use case. They\n-//             use a different concurrent queue that is more tailored for this\n-//             use case. The initial allocation of this flavor of channel is not\n-//             optimized.\n-// * Shared - this is the most general form of channel that this module offers,\n-//            a channel with multiple senders. This type is as optimized as it\n-//            can be, but the previous two types mentioned are much faster for\n-//            their use-cases.\n-//\n-// ## Concurrent queues\n-//\n-// The basic idea of Rust's Sender/Receiver types is that send() never blocks,\n-// but recv() obviously blocks. This means that under the hood there must be\n-// some shared and concurrent queue holding all of the actual data.\n-//\n-// With two flavors of channels, two flavors of queues are also used. We have\n-// chosen to use queues from a well-known author that are abbreviated as SPSC\n-// and MPSC (single producer, single consumer and multiple producer, single\n-// consumer). SPSC queues are used for streams while MPSC queues are used for\n-// shared channels.\n-//\n-// ### SPSC optimizations\n-//\n-// The SPSC queue found online is essentially a linked list of nodes where one\n-// half of the nodes are the \"queue of data\" and the other half of nodes are a\n-// cache of unused nodes. The unused nodes are used such that an allocation is\n-// not required on every push() and a free doesn't need to happen on every\n-// pop().\n-//\n-// As found online, however, the cache of nodes is of an infinite size. This\n-// means that if a channel at one point in its life had 50k items in the queue,\n-// then the queue will always have the capacity for 50k items. I believed that\n-// this was an unnecessary limitation of the implementation, so I have altered\n-// the queue to optionally have a bound on the cache size.\n-//\n-// By default, streams will have an unbounded SPSC queue with a small-ish cache\n-// size. The hope is that the cache is still large enough to have very fast\n-// send() operations while not too large such that millions of channels can\n-// coexist at once.\n-//\n-// ### MPSC optimizations\n-//\n-// Right now the MPSC queue has not been optimized. Like the SPSC queue, it uses\n-// a linked list under the hood to earn its unboundedness, but I have not put\n-// forth much effort into having a cache of nodes similar to the SPSC queue.\n-//\n-// For now, I believe that this is \"ok\" because shared channels are not the most\n-// common type, but soon we may wish to revisit this queue choice and determine\n-// another candidate for backend storage of shared channels.\n-//\n-// ## Overview of the Implementation\n-//\n-// Now that there's a little background on the concurrent queues used, it's\n-// worth going into much more detail about the channels themselves. The basic\n-// pseudocode for a send/recv are:\n-//\n-//\n-//      send(t)                             recv()\n-//        queue.push(t)                       return if queue.pop()\n-//        if increment() == -1                deschedule {\n-//          wakeup()                            if decrement() > 0\n-//                                                cancel_deschedule()\n-//                                            }\n-//                                            queue.pop()\n-//\n-// As mentioned before, there are no locks in this implementation, only atomic\n-// instructions are used.\n-//\n-// ### The internal atomic counter\n-//\n-// Every channel has a shared counter with each half to keep track of the size\n-// of the queue. This counter is used to abort descheduling by the receiver and\n-// to know when to wake up on the sending side.\n-//\n-// As seen in the pseudocode, senders will increment this count and receivers\n-// will decrement the count. The theory behind this is that if a sender sees a\n-// -1 count, it will wake up the receiver, and if the receiver sees a 1+ count,\n-// then it doesn't need to block.\n-//\n-// The recv() method has a beginning call to pop(), and if successful, it needs\n-// to decrement the count. It is a crucial implementation detail that this\n-// decrement does *not* happen to the shared counter. If this were the case,\n-// then it would be possible for the counter to be very negative when there were\n-// no receivers waiting, in which case the senders would have to determine when\n-// it was actually appropriate to wake up a receiver.\n-//\n-// Instead, the \"steal count\" is kept track of separately (not atomically\n-// because it's only used by receivers), and then the decrement() call when\n-// descheduling will lump in all of the recent steals into one large decrement.\n-//\n-// The implication of this is that if a sender sees a -1 count, then there's\n-// guaranteed to be a waiter waiting!\n-//\n-// ## Native Implementation\n-//\n-// A major goal of these channels is to work seamlessly on and off the runtime.\n-// All of the previous race conditions have been worded in terms of\n-// scheduler-isms (which is obviously not available without the runtime).\n-//\n-// For now, native usage of channels (off the runtime) will fall back onto\n-// mutexes/cond vars for descheduling/atomic decisions. The no-contention path\n-// is still entirely lock-free, the \"deschedule\" blocks above are surrounded by\n-// a mutex and the \"wakeup\" blocks involve grabbing a mutex and signaling on a\n-// condition variable.\n-//\n-// ## Select\n-//\n-// Being able to support selection over channels has greatly influenced this\n-// design, and not only does selection need to work inside the runtime, but also\n-// outside the runtime.\n-//\n-// The implementation is fairly straightforward. The goal of select() is not to\n-// return some data, but only to return which channel can receive data without\n-// blocking. The implementation is essentially the entire blocking procedure\n-// followed by an increment as soon as its woken up. The cancellation procedure\n-// involves an increment and swapping out of to_wake to acquire ownership of the\n-// thread to unblock.\n-//\n-// Sadly this current implementation requires multiple allocations, so I have\n-// seen the throughput of select() be much worse than it should be. I do not\n-// believe that there is anything fundamental that needs to change about these\n-// channels, however, in order to support a more efficient select().\n-//\n-// FIXME: Select is now removed, so these factors are ready to be cleaned up!\n-//\n-// # Conclusion\n-//\n-// And now that you've seen all the races that I found and attempted to fix,\n-// here's the code for you to find some more!\n-\n-use crate::cell::UnsafeCell;\n+// MPSC channels are built as a wrapper around MPMC channels, which\n+// were ported from the `crossbeam-channel` crate. MPMC channels are\n+// not exposed publicly, but if you are curious about the implementation,\n+// that's where everything is.\n+\n use crate::error;\n use crate::fmt;\n-use crate::mem;\n-use crate::sync::Arc;\n+use crate::sync::mpmc;\n use crate::time::{Duration, Instant};\n \n-mod blocking;\n-mod mpsc_queue;\n-mod oneshot;\n-mod shared;\n-mod spsc_queue;\n-mod stream;\n-mod sync;\n-\n-mod cache_aligned;\n-\n /// The receiving half of Rust's [`channel`] (or [`sync_channel`]) type.\n /// This half can only be owned by one thread.\n ///\n@@ -341,7 +182,7 @@ mod cache_aligned;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Receiver\")]\n pub struct Receiver<T> {\n-    inner: UnsafeCell<Flavor<T>>,\n+    inner: mpmc::Receiver<T>,\n }\n \n // The receiver port can be sent from place to place, so long as it\n@@ -498,7 +339,7 @@ pub struct IntoIter<T> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Sender<T> {\n-    inner: UnsafeCell<Flavor<T>>,\n+    inner: mpmc::Sender<T>,\n }\n \n // The send port can be sent from place to place, so long as it\n@@ -557,7 +398,7 @@ impl<T> !Sync for Sender<T> {}\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SyncSender<T> {\n-    inner: Arc<sync::Packet<T>>,\n+    inner: mpmc::Sender<T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -643,34 +484,6 @@ pub enum TrySendError<T> {\n     Disconnected(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n }\n \n-enum Flavor<T> {\n-    Oneshot(Arc<oneshot::Packet<T>>),\n-    Stream(Arc<stream::Packet<T>>),\n-    Shared(Arc<shared::Packet<T>>),\n-    Sync(Arc<sync::Packet<T>>),\n-}\n-\n-#[doc(hidden)]\n-trait UnsafeFlavor<T> {\n-    fn inner_unsafe(&self) -> &UnsafeCell<Flavor<T>>;\n-    unsafe fn inner_mut(&self) -> &mut Flavor<T> {\n-        &mut *self.inner_unsafe().get()\n-    }\n-    unsafe fn inner(&self) -> &Flavor<T> {\n-        &*self.inner_unsafe().get()\n-    }\n-}\n-impl<T> UnsafeFlavor<T> for Sender<T> {\n-    fn inner_unsafe(&self) -> &UnsafeCell<Flavor<T>> {\n-        &self.inner\n-    }\n-}\n-impl<T> UnsafeFlavor<T> for Receiver<T> {\n-    fn inner_unsafe(&self) -> &UnsafeCell<Flavor<T>> {\n-        &self.inner\n-    }\n-}\n-\n /// Creates a new asynchronous channel, returning the sender/receiver halves.\n /// All data sent on the [`Sender`] will become available on the [`Receiver`] in\n /// the same order as it was sent, and no [`send`] will block the calling thread\n@@ -711,8 +524,8 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n-    let a = Arc::new(oneshot::Packet::new());\n-    (Sender::new(Flavor::Oneshot(a.clone())), Receiver::new(Flavor::Oneshot(a)))\n+    let (tx, rx) = mpmc::channel();\n+    (Sender { inner: tx }, Receiver { inner: rx })\n }\n \n /// Creates a new synchronous, bounded channel.\n@@ -760,19 +573,15 @@ pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn sync_channel<T>(bound: usize) -> (SyncSender<T>, Receiver<T>) {\n-    let a = Arc::new(sync::Packet::new(bound));\n-    (SyncSender::new(a.clone()), Receiver::new(Flavor::Sync(a)))\n+    let (tx, rx) = mpmc::sync_channel(bound);\n+    (SyncSender { inner: tx }, Receiver { inner: rx })\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n // Sender\n ////////////////////////////////////////////////////////////////////////////////\n \n impl<T> Sender<T> {\n-    fn new(inner: Flavor<T>) -> Sender<T> {\n-        Sender { inner: UnsafeCell::new(inner) }\n-    }\n-\n     /// Attempts to send a value on this channel, returning it back if it could\n     /// not be sent.\n     ///\n@@ -802,40 +611,7 @@ impl<T> Sender<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n-        let (new_inner, ret) = match *unsafe { self.inner() } {\n-            Flavor::Oneshot(ref p) => {\n-                if !p.sent() {\n-                    return p.send(t).map_err(SendError);\n-                } else {\n-                    let a = Arc::new(stream::Packet::new());\n-                    let rx = Receiver::new(Flavor::Stream(a.clone()));\n-                    match p.upgrade(rx) {\n-                        oneshot::UpSuccess => {\n-                            let ret = a.send(t);\n-                            (a, ret)\n-                        }\n-                        oneshot::UpDisconnected => (a, Err(t)),\n-                        oneshot::UpWoke(token) => {\n-                            // This send cannot panic because the thread is\n-                            // asleep (we're looking at it), so the receiver\n-                            // can't go away.\n-                            a.send(t).ok().unwrap();\n-                            token.signal();\n-                            (a, Ok(()))\n-                        }\n-                    }\n-                }\n-            }\n-            Flavor::Stream(ref p) => return p.send(t).map_err(SendError),\n-            Flavor::Shared(ref p) => return p.send(t).map_err(SendError),\n-            Flavor::Sync(..) => unreachable!(),\n-        };\n-\n-        unsafe {\n-            let tmp = Sender::new(Flavor::Stream(new_inner));\n-            mem::swap(self.inner_mut(), tmp.inner_mut());\n-        }\n-        ret.map_err(SendError)\n+        self.inner.send(t)\n     }\n }\n \n@@ -847,57 +623,14 @@ impl<T> Clone for Sender<T> {\n     /// (including the original) need to be dropped in order for\n     /// [`Receiver::recv`] to stop blocking.\n     fn clone(&self) -> Sender<T> {\n-        let packet = match *unsafe { self.inner() } {\n-            Flavor::Oneshot(ref p) => {\n-                let a = Arc::new(shared::Packet::new());\n-                {\n-                    let guard = a.postinit_lock();\n-                    let rx = Receiver::new(Flavor::Shared(a.clone()));\n-                    let sleeper = match p.upgrade(rx) {\n-                        oneshot::UpSuccess | oneshot::UpDisconnected => None,\n-                        oneshot::UpWoke(task) => Some(task),\n-                    };\n-                    a.inherit_blocker(sleeper, guard);\n-                }\n-                a\n-            }\n-            Flavor::Stream(ref p) => {\n-                let a = Arc::new(shared::Packet::new());\n-                {\n-                    let guard = a.postinit_lock();\n-                    let rx = Receiver::new(Flavor::Shared(a.clone()));\n-                    let sleeper = match p.upgrade(rx) {\n-                        stream::UpSuccess | stream::UpDisconnected => None,\n-                        stream::UpWoke(task) => Some(task),\n-                    };\n-                    a.inherit_blocker(sleeper, guard);\n-                }\n-                a\n-            }\n-            Flavor::Shared(ref p) => {\n-                p.clone_chan();\n-                return Sender::new(Flavor::Shared(p.clone()));\n-            }\n-            Flavor::Sync(..) => unreachable!(),\n-        };\n-\n-        unsafe {\n-            let tmp = Sender::new(Flavor::Shared(packet.clone()));\n-            mem::swap(self.inner_mut(), tmp.inner_mut());\n-        }\n-        Sender::new(Flavor::Shared(packet))\n+        Sender { inner: self.inner.clone() }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Sender<T> {\n     fn drop(&mut self) {\n-        match *unsafe { self.inner() } {\n-            Flavor::Oneshot(ref p) => p.drop_chan(),\n-            Flavor::Stream(ref p) => p.drop_chan(),\n-            Flavor::Shared(ref p) => p.drop_chan(),\n-            Flavor::Sync(..) => unreachable!(),\n-        }\n+        let _ = self.inner;\n     }\n }\n \n@@ -913,10 +646,6 @@ impl<T> fmt::Debug for Sender<T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n impl<T> SyncSender<T> {\n-    fn new(inner: Arc<sync::Packet<T>>) -> SyncSender<T> {\n-        SyncSender { inner }\n-    }\n-\n     /// Sends a value on this synchronous channel.\n     ///\n     /// This function will *block* until space in the internal buffer becomes\n@@ -955,7 +684,7 @@ impl<T> SyncSender<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n-        self.inner.send(t).map_err(SendError)\n+        self.inner.send(t)\n     }\n \n     /// Attempts to send a value on this channel without blocking.\n@@ -1016,15 +745,14 @@ impl<T> SyncSender<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for SyncSender<T> {\n     fn clone(&self) -> SyncSender<T> {\n-        self.inner.clone_chan();\n-        SyncSender::new(self.inner.clone())\n+        SyncSender { inner: self.inner.clone() }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for SyncSender<T> {\n     fn drop(&mut self) {\n-        self.inner.drop_chan();\n+        let _ = self.inner;\n     }\n }\n \n@@ -1040,10 +768,6 @@ impl<T> fmt::Debug for SyncSender<T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n impl<T> Receiver<T> {\n-    fn new(inner: Flavor<T>) -> Receiver<T> {\n-        Receiver { inner: UnsafeCell::new(inner) }\n-    }\n-\n     /// Attempts to return a pending value on this receiver without blocking.\n     ///\n     /// This method will never block the caller in order to wait for data to\n@@ -1069,35 +793,7 @@ impl<T> Receiver<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_recv(&self) -> Result<T, TryRecvError> {\n-        loop {\n-            let new_port = match *unsafe { self.inner() } {\n-                Flavor::Oneshot(ref p) => match p.try_recv() {\n-                    Ok(t) => return Ok(t),\n-                    Err(oneshot::Empty) => return Err(TryRecvError::Empty),\n-                    Err(oneshot::Disconnected) => return Err(TryRecvError::Disconnected),\n-                    Err(oneshot::Upgraded(rx)) => rx,\n-                },\n-                Flavor::Stream(ref p) => match p.try_recv() {\n-                    Ok(t) => return Ok(t),\n-                    Err(stream::Empty) => return Err(TryRecvError::Empty),\n-                    Err(stream::Disconnected) => return Err(TryRecvError::Disconnected),\n-                    Err(stream::Upgraded(rx)) => rx,\n-                },\n-                Flavor::Shared(ref p) => match p.try_recv() {\n-                    Ok(t) => return Ok(t),\n-                    Err(shared::Empty) => return Err(TryRecvError::Empty),\n-                    Err(shared::Disconnected) => return Err(TryRecvError::Disconnected),\n-                },\n-                Flavor::Sync(ref p) => match p.try_recv() {\n-                    Ok(t) => return Ok(t),\n-                    Err(sync::Empty) => return Err(TryRecvError::Empty),\n-                    Err(sync::Disconnected) => return Err(TryRecvError::Disconnected),\n-                },\n-            };\n-            unsafe {\n-                mem::swap(self.inner_mut(), new_port.inner_mut());\n-            }\n-        }\n+        self.inner.try_recv()\n     }\n \n     /// Attempts to wait for a value on this receiver, returning an error if the\n@@ -1156,31 +852,7 @@ impl<T> Receiver<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn recv(&self) -> Result<T, RecvError> {\n-        loop {\n-            let new_port = match *unsafe { self.inner() } {\n-                Flavor::Oneshot(ref p) => match p.recv(None) {\n-                    Ok(t) => return Ok(t),\n-                    Err(oneshot::Disconnected) => return Err(RecvError),\n-                    Err(oneshot::Upgraded(rx)) => rx,\n-                    Err(oneshot::Empty) => unreachable!(),\n-                },\n-                Flavor::Stream(ref p) => match p.recv(None) {\n-                    Ok(t) => return Ok(t),\n-                    Err(stream::Disconnected) => return Err(RecvError),\n-                    Err(stream::Upgraded(rx)) => rx,\n-                    Err(stream::Empty) => unreachable!(),\n-                },\n-                Flavor::Shared(ref p) => match p.recv(None) {\n-                    Ok(t) => return Ok(t),\n-                    Err(shared::Disconnected) => return Err(RecvError),\n-                    Err(shared::Empty) => unreachable!(),\n-                },\n-                Flavor::Sync(ref p) => return p.recv(None).map_err(|_| RecvError),\n-            };\n-            unsafe {\n-                mem::swap(self.inner_mut(), new_port.inner_mut());\n-            }\n-        }\n+        self.inner.recv()\n     }\n \n     /// Attempts to wait for a value on this receiver, returning an error if the\n@@ -1198,34 +870,6 @@ impl<T> Receiver<T> {\n     /// However, since channels are buffered, messages sent before the disconnect\n     /// will still be properly received.\n     ///\n-    /// # Known Issues\n-    ///\n-    /// There is currently a known issue (see [`#39364`]) that causes `recv_timeout`\n-    /// to panic unexpectedly with the following example:\n-    ///\n-    /// ```no_run\n-    /// use std::sync::mpsc::channel;\n-    /// use std::thread;\n-    /// use std::time::Duration;\n-    ///\n-    /// let (tx, rx) = channel::<String>();\n-    ///\n-    /// thread::spawn(move || {\n-    ///     let d = Duration::from_millis(10);\n-    ///     loop {\n-    ///         println!(\"recv\");\n-    ///         let _r = rx.recv_timeout(d);\n-    ///     }\n-    /// });\n-    ///\n-    /// thread::sleep(Duration::from_millis(100));\n-    /// let _c1 = tx.clone();\n-    ///\n-    /// thread::sleep(Duration::from_secs(1));\n-    /// ```\n-    ///\n-    /// [`#39364`]: https://github.com/rust-lang/rust/issues/39364\n-    ///\n     /// # Examples\n     ///\n     /// Successfully receiving value before encountering timeout:\n@@ -1268,17 +912,7 @@ impl<T> Receiver<T> {\n     /// ```\n     #[stable(feature = \"mpsc_recv_timeout\", since = \"1.12.0\")]\n     pub fn recv_timeout(&self, timeout: Duration) -> Result<T, RecvTimeoutError> {\n-        // Do an optimistic try_recv to avoid the performance impact of\n-        // Instant::now() in the full-channel case.\n-        match self.try_recv() {\n-            Ok(result) => Ok(result),\n-            Err(TryRecvError::Disconnected) => Err(RecvTimeoutError::Disconnected),\n-            Err(TryRecvError::Empty) => match Instant::now().checked_add(timeout) {\n-                Some(deadline) => self.recv_deadline(deadline),\n-                // So far in the future that it's practically the same as waiting indefinitely.\n-                None => self.recv().map_err(RecvTimeoutError::from),\n-            },\n-        }\n+        self.inner.recv_timeout(timeout)\n     }\n \n     /// Attempts to wait for a value on this receiver, returning an error if the\n@@ -1339,46 +973,7 @@ impl<T> Receiver<T> {\n     /// ```\n     #[unstable(feature = \"deadline_api\", issue = \"46316\")]\n     pub fn recv_deadline(&self, deadline: Instant) -> Result<T, RecvTimeoutError> {\n-        use self::RecvTimeoutError::*;\n-\n-        loop {\n-            let port_or_empty = match *unsafe { self.inner() } {\n-                Flavor::Oneshot(ref p) => match p.recv(Some(deadline)) {\n-                    Ok(t) => return Ok(t),\n-                    Err(oneshot::Disconnected) => return Err(Disconnected),\n-                    Err(oneshot::Upgraded(rx)) => Some(rx),\n-                    Err(oneshot::Empty) => None,\n-                },\n-                Flavor::Stream(ref p) => match p.recv(Some(deadline)) {\n-                    Ok(t) => return Ok(t),\n-                    Err(stream::Disconnected) => return Err(Disconnected),\n-                    Err(stream::Upgraded(rx)) => Some(rx),\n-                    Err(stream::Empty) => None,\n-                },\n-                Flavor::Shared(ref p) => match p.recv(Some(deadline)) {\n-                    Ok(t) => return Ok(t),\n-                    Err(shared::Disconnected) => return Err(Disconnected),\n-                    Err(shared::Empty) => None,\n-                },\n-                Flavor::Sync(ref p) => match p.recv(Some(deadline)) {\n-                    Ok(t) => return Ok(t),\n-                    Err(sync::Disconnected) => return Err(Disconnected),\n-                    Err(sync::Empty) => None,\n-                },\n-            };\n-\n-            if let Some(new_port) = port_or_empty {\n-                unsafe {\n-                    mem::swap(self.inner_mut(), new_port.inner_mut());\n-                }\n-            }\n-\n-            // If we're already passed the deadline, and we're here without\n-            // data, return a timeout, else try again.\n-            if Instant::now() >= deadline {\n-                return Err(Timeout);\n-            }\n-        }\n+        self.inner.recv_deadline(deadline)\n     }\n \n     /// Returns an iterator that will block waiting for messages, but never\n@@ -1500,12 +1095,7 @@ impl<T> IntoIterator for Receiver<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Receiver<T> {\n     fn drop(&mut self) {\n-        match *unsafe { self.inner() } {\n-            Flavor::Oneshot(ref p) => p.drop_port(),\n-            Flavor::Stream(ref p) => p.drop_port(),\n-            Flavor::Shared(ref p) => p.drop_port(),\n-            Flavor::Sync(ref p) => p.drop_port(),\n-        }\n+        let _ = self.inner;\n     }\n }\n "}, {"sha": "7322512e3b4585346b96d8b31bf29a94f673eb7c", "filename": "library/std/src/sync/mpsc/mpsc_queue.rs", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/928d14bcd1976ffd33e743aa09c7c22a063bf87c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928d14bcd1976ffd33e743aa09c7c22a063bf87c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=928d14bcd1976ffd33e743aa09c7c22a063bf87c", "patch": "@@ -1,124 +0,0 @@\n-//! A mostly lock-free multi-producer, single consumer queue.\n-//!\n-//! This module contains an implementation of a concurrent MPSC queue. This\n-//! queue can be used to share data between threads, and is also used as the\n-//! building block of channels in rust.\n-//!\n-//! Note that the current implementation of this queue has a caveat of the `pop`\n-//! method, and see the method for more information about it. Due to this\n-//! caveat, this queue might not be appropriate for all use-cases.\n-\n-// The original implementation is based off:\n-// https://www.1024cores.net/home/lock-free-algorithms/queues/non-intrusive-mpsc-node-based-queue\n-//\n-// Note that back when the code was imported, it was licensed under the BSD-2-Clause license:\n-// http://web.archive.org/web/20110411011612/https://www.1024cores.net/home/lock-free-algorithms/queues/unbounded-spsc-queue\n-//\n-// The original author of the code agreed to relicense it under `MIT OR Apache-2.0` in 2017, so as\n-// of today the license of this file is the same as the rest of the codebase:\n-// https://github.com/rust-lang/rust/pull/42149\n-\n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n-mod tests;\n-\n-pub use self::PopResult::*;\n-\n-use core::cell::UnsafeCell;\n-use core::ptr;\n-\n-use crate::boxed::Box;\n-use crate::sync::atomic::{AtomicPtr, Ordering};\n-\n-/// A result of the `pop` function.\n-pub enum PopResult<T> {\n-    /// Some data has been popped\n-    Data(T),\n-    /// The queue is empty\n-    Empty,\n-    /// The queue is in an inconsistent state. Popping data should succeed, but\n-    /// some pushers have yet to make enough progress in order allow a pop to\n-    /// succeed. It is recommended that a pop() occur \"in the near future\" in\n-    /// order to see if the sender has made progress or not\n-    Inconsistent,\n-}\n-\n-struct Node<T> {\n-    next: AtomicPtr<Node<T>>,\n-    value: Option<T>,\n-}\n-\n-/// The multi-producer single-consumer structure. This is not cloneable, but it\n-/// may be safely shared so long as it is guaranteed that there is only one\n-/// popper at a time (many pushers are allowed).\n-pub struct Queue<T> {\n-    head: AtomicPtr<Node<T>>,\n-    tail: UnsafeCell<*mut Node<T>>,\n-}\n-\n-unsafe impl<T: Send> Send for Queue<T> {}\n-unsafe impl<T: Send> Sync for Queue<T> {}\n-\n-impl<T> Node<T> {\n-    unsafe fn new(v: Option<T>) -> *mut Node<T> {\n-        Box::into_raw(box Node { next: AtomicPtr::new(ptr::null_mut()), value: v })\n-    }\n-}\n-\n-impl<T> Queue<T> {\n-    /// Creates a new queue that is safe to share among multiple producers and\n-    /// one consumer.\n-    pub fn new() -> Queue<T> {\n-        let stub = unsafe { Node::new(None) };\n-        Queue { head: AtomicPtr::new(stub), tail: UnsafeCell::new(stub) }\n-    }\n-\n-    /// Pushes a new value onto this queue.\n-    pub fn push(&self, t: T) {\n-        unsafe {\n-            let n = Node::new(Some(t));\n-            let prev = self.head.swap(n, Ordering::AcqRel);\n-            (*prev).next.store(n, Ordering::Release);\n-        }\n-    }\n-\n-    /// Pops some data from this queue.\n-    ///\n-    /// Note that the current implementation means that this function cannot\n-    /// return `Option<T>`. It is possible for this queue to be in an\n-    /// inconsistent state where many pushes have succeeded and completely\n-    /// finished, but pops cannot return `Some(t)`. This inconsistent state\n-    /// happens when a pusher is pre-empted at an inopportune moment.\n-    ///\n-    /// This inconsistent state means that this queue does indeed have data, but\n-    /// it does not currently have access to it at this time.\n-    pub fn pop(&self) -> PopResult<T> {\n-        unsafe {\n-            let tail = *self.tail.get();\n-            let next = (*tail).next.load(Ordering::Acquire);\n-\n-            if !next.is_null() {\n-                *self.tail.get() = next;\n-                assert!((*tail).value.is_none());\n-                assert!((*next).value.is_some());\n-                let ret = (*next).value.take().unwrap();\n-                let _: Box<Node<T>> = Box::from_raw(tail);\n-                return Data(ret);\n-            }\n-\n-            if self.head.load(Ordering::Acquire) == tail { Empty } else { Inconsistent }\n-        }\n-    }\n-}\n-\n-impl<T> Drop for Queue<T> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            let mut cur = *self.tail.get();\n-            while !cur.is_null() {\n-                let next = (*cur).next.load(Ordering::Relaxed);\n-                let _: Box<Node<T>> = Box::from_raw(cur);\n-                cur = next;\n-            }\n-        }\n-    }\n-}"}, {"sha": "34b2a9a98ac36fa523fc4435fc12db5a8fe99f23", "filename": "library/std/src/sync/mpsc/mpsc_queue/tests.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/928d14bcd1976ffd33e743aa09c7c22a063bf87c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928d14bcd1976ffd33e743aa09c7c22a063bf87c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue%2Ftests.rs?ref=928d14bcd1976ffd33e743aa09c7c22a063bf87c", "patch": "@@ -1,47 +0,0 @@\n-use super::{Data, Empty, Inconsistent, Queue};\n-use crate::sync::mpsc::channel;\n-use crate::sync::Arc;\n-use crate::thread;\n-\n-#[test]\n-fn test_full() {\n-    let q: Queue<Box<_>> = Queue::new();\n-    q.push(Box::new(1));\n-    q.push(Box::new(2));\n-}\n-\n-#[test]\n-fn test() {\n-    let nthreads = 8;\n-    let nmsgs = if cfg!(miri) { 100 } else { 1000 };\n-    let q = Queue::new();\n-    match q.pop() {\n-        Empty => {}\n-        Inconsistent | Data(..) => panic!(),\n-    }\n-    let (tx, rx) = channel();\n-    let q = Arc::new(q);\n-\n-    for _ in 0..nthreads {\n-        let tx = tx.clone();\n-        let q = q.clone();\n-        thread::spawn(move || {\n-            for i in 0..nmsgs {\n-                q.push(i);\n-            }\n-            tx.send(()).unwrap();\n-        });\n-    }\n-\n-    let mut i = 0;\n-    while i < nthreads * nmsgs {\n-        match q.pop() {\n-            Empty | Inconsistent => {}\n-            Data(_) => i += 1,\n-        }\n-    }\n-    drop(tx);\n-    for _ in 0..nthreads {\n-        rx.recv().unwrap();\n-    }\n-}"}, {"sha": "0e259b8aecb9a35744ae9225ab33a41d4c7ac83d", "filename": "library/std/src/sync/mpsc/oneshot.rs", "status": "removed", "additions": 0, "deletions": 315, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/928d14bcd1976ffd33e743aa09c7c22a063bf87c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928d14bcd1976ffd33e743aa09c7c22a063bf87c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Foneshot.rs?ref=928d14bcd1976ffd33e743aa09c7c22a063bf87c", "patch": "@@ -1,315 +0,0 @@\n-/// Oneshot channels/ports\n-///\n-/// This is the initial flavor of channels/ports used for comm module. This is\n-/// an optimization for the one-use case of a channel. The major optimization of\n-/// this type is to have one and exactly one allocation when the chan/port pair\n-/// is created.\n-///\n-/// Another possible optimization would be to not use an Arc box because\n-/// in theory we know when the shared packet can be deallocated (no real need\n-/// for the atomic reference counting), but I was having trouble how to destroy\n-/// the data early in a drop of a Port.\n-///\n-/// # Implementation\n-///\n-/// Oneshots are implemented around one atomic usize variable. This variable\n-/// indicates both the state of the port/chan but also contains any threads\n-/// blocked on the port. All atomic operations happen on this one word.\n-///\n-/// In order to upgrade a oneshot channel, an upgrade is considered a disconnect\n-/// on behalf of the channel side of things (it can be mentally thought of as\n-/// consuming the port). This upgrade is then also stored in the shared packet.\n-/// The one caveat to consider is that when a port sees a disconnected channel\n-/// it must check for data because there is no \"data plus upgrade\" state.\n-pub use self::Failure::*;\n-use self::MyUpgrade::*;\n-pub use self::UpgradeResult::*;\n-\n-use crate::cell::UnsafeCell;\n-use crate::ptr;\n-use crate::sync::atomic::{AtomicPtr, Ordering};\n-use crate::sync::mpsc::blocking::{self, SignalToken};\n-use crate::sync::mpsc::Receiver;\n-use crate::time::Instant;\n-\n-// Various states you can find a port in.\n-const EMPTY: *mut u8 = ptr::invalid_mut::<u8>(0); // initial state: no data, no blocked receiver\n-const DATA: *mut u8 = ptr::invalid_mut::<u8>(1); // data ready for receiver to take\n-const DISCONNECTED: *mut u8 = ptr::invalid_mut::<u8>(2); // channel is disconnected OR upgraded\n-// Any other value represents a pointer to a SignalToken value. The\n-// protocol ensures that when the state moves *to* a pointer,\n-// ownership of the token is given to the packet, and when the state\n-// moves *from* a pointer, ownership of the token is transferred to\n-// whoever changed the state.\n-\n-pub struct Packet<T> {\n-    // Internal state of the chan/port pair (stores the blocked thread as well)\n-    state: AtomicPtr<u8>,\n-    // One-shot data slot location\n-    data: UnsafeCell<Option<T>>,\n-    // when used for the second time, a oneshot channel must be upgraded, and\n-    // this contains the slot for the upgrade\n-    upgrade: UnsafeCell<MyUpgrade<T>>,\n-}\n-\n-pub enum Failure<T> {\n-    Empty,\n-    Disconnected,\n-    Upgraded(Receiver<T>),\n-}\n-\n-pub enum UpgradeResult {\n-    UpSuccess,\n-    UpDisconnected,\n-    UpWoke(SignalToken),\n-}\n-\n-enum MyUpgrade<T> {\n-    NothingSent,\n-    SendUsed,\n-    GoUp(Receiver<T>),\n-}\n-\n-impl<T> Packet<T> {\n-    pub fn new() -> Packet<T> {\n-        Packet {\n-            data: UnsafeCell::new(None),\n-            upgrade: UnsafeCell::new(NothingSent),\n-            state: AtomicPtr::new(EMPTY),\n-        }\n-    }\n-\n-    pub fn send(&self, t: T) -> Result<(), T> {\n-        unsafe {\n-            // Sanity check\n-            match *self.upgrade.get() {\n-                NothingSent => {}\n-                _ => panic!(\"sending on a oneshot that's already sent on \"),\n-            }\n-            assert!((*self.data.get()).is_none());\n-            ptr::write(self.data.get(), Some(t));\n-            ptr::write(self.upgrade.get(), SendUsed);\n-\n-            match self.state.swap(DATA, Ordering::SeqCst) {\n-                // Sent the data, no one was waiting\n-                EMPTY => Ok(()),\n-\n-                // Couldn't send the data, the port hung up first. Return the data\n-                // back up the stack.\n-                DISCONNECTED => {\n-                    self.state.swap(DISCONNECTED, Ordering::SeqCst);\n-                    ptr::write(self.upgrade.get(), NothingSent);\n-                    Err((&mut *self.data.get()).take().unwrap())\n-                }\n-\n-                // Not possible, these are one-use channels\n-                DATA => unreachable!(),\n-\n-                // There is a thread waiting on the other end. We leave the 'DATA'\n-                // state inside so it'll pick it up on the other end.\n-                ptr => {\n-                    SignalToken::from_raw(ptr).signal();\n-                    Ok(())\n-                }\n-            }\n-        }\n-    }\n-\n-    // Just tests whether this channel has been sent on or not, this is only\n-    // safe to use from the sender.\n-    pub fn sent(&self) -> bool {\n-        unsafe { !matches!(*self.upgrade.get(), NothingSent) }\n-    }\n-\n-    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure<T>> {\n-        // Attempt to not block the thread (it's a little expensive). If it looks\n-        // like we're not empty, then immediately go through to `try_recv`.\n-        if self.state.load(Ordering::SeqCst) == EMPTY {\n-            let (wait_token, signal_token) = blocking::tokens();\n-            let ptr = unsafe { signal_token.to_raw() };\n-\n-            // race with senders to enter the blocking state\n-            if self.state.compare_exchange(EMPTY, ptr, Ordering::SeqCst, Ordering::SeqCst).is_ok() {\n-                if let Some(deadline) = deadline {\n-                    let timed_out = !wait_token.wait_max_until(deadline);\n-                    // Try to reset the state\n-                    if timed_out {\n-                        self.abort_selection().map_err(Upgraded)?;\n-                    }\n-                } else {\n-                    wait_token.wait();\n-                    debug_assert!(self.state.load(Ordering::SeqCst) != EMPTY);\n-                }\n-            } else {\n-                // drop the signal token, since we never blocked\n-                drop(unsafe { SignalToken::from_raw(ptr) });\n-            }\n-        }\n-\n-        self.try_recv()\n-    }\n-\n-    pub fn try_recv(&self) -> Result<T, Failure<T>> {\n-        unsafe {\n-            match self.state.load(Ordering::SeqCst) {\n-                EMPTY => Err(Empty),\n-\n-                // We saw some data on the channel, but the channel can be used\n-                // again to send us an upgrade. As a result, we need to re-insert\n-                // into the channel that there's no data available (otherwise we'll\n-                // just see DATA next time). This is done as a cmpxchg because if\n-                // the state changes under our feet we'd rather just see that state\n-                // change.\n-                DATA => {\n-                    let _ = self.state.compare_exchange(\n-                        DATA,\n-                        EMPTY,\n-                        Ordering::SeqCst,\n-                        Ordering::SeqCst,\n-                    );\n-                    match (&mut *self.data.get()).take() {\n-                        Some(data) => Ok(data),\n-                        None => unreachable!(),\n-                    }\n-                }\n-\n-                // There's no guarantee that we receive before an upgrade happens,\n-                // and an upgrade flags the channel as disconnected, so when we see\n-                // this we first need to check if there's data available and *then*\n-                // we go through and process the upgrade.\n-                DISCONNECTED => match (&mut *self.data.get()).take() {\n-                    Some(data) => Ok(data),\n-                    None => match ptr::replace(self.upgrade.get(), SendUsed) {\n-                        SendUsed | NothingSent => Err(Disconnected),\n-                        GoUp(upgrade) => Err(Upgraded(upgrade)),\n-                    },\n-                },\n-\n-                // We are the sole receiver; there cannot be a blocking\n-                // receiver already.\n-                _ => unreachable!(),\n-            }\n-        }\n-    }\n-\n-    // Returns whether the upgrade was completed. If the upgrade wasn't\n-    // completed, then the port couldn't get sent to the other half (it will\n-    // never receive it).\n-    pub fn upgrade(&self, up: Receiver<T>) -> UpgradeResult {\n-        unsafe {\n-            let prev = match *self.upgrade.get() {\n-                NothingSent => NothingSent,\n-                SendUsed => SendUsed,\n-                _ => panic!(\"upgrading again\"),\n-            };\n-            ptr::write(self.upgrade.get(), GoUp(up));\n-\n-            match self.state.swap(DISCONNECTED, Ordering::SeqCst) {\n-                // If the channel is empty or has data on it, then we're good to go.\n-                // Senders will check the data before the upgrade (in case we\n-                // plastered over the DATA state).\n-                DATA | EMPTY => UpSuccess,\n-\n-                // If the other end is already disconnected, then we failed the\n-                // upgrade. Be sure to trash the port we were given.\n-                DISCONNECTED => {\n-                    ptr::replace(self.upgrade.get(), prev);\n-                    UpDisconnected\n-                }\n-\n-                // If someone's waiting, we gotta wake them up\n-                ptr => UpWoke(SignalToken::from_raw(ptr)),\n-            }\n-        }\n-    }\n-\n-    pub fn drop_chan(&self) {\n-        match self.state.swap(DISCONNECTED, Ordering::SeqCst) {\n-            DATA | DISCONNECTED | EMPTY => {}\n-\n-            // If someone's waiting, we gotta wake them up\n-            ptr => unsafe {\n-                SignalToken::from_raw(ptr).signal();\n-            },\n-        }\n-    }\n-\n-    pub fn drop_port(&self) {\n-        match self.state.swap(DISCONNECTED, Ordering::SeqCst) {\n-            // An empty channel has nothing to do, and a remotely disconnected\n-            // channel also has nothing to do b/c we're about to run the drop\n-            // glue\n-            DISCONNECTED | EMPTY => {}\n-\n-            // There's data on the channel, so make sure we destroy it promptly.\n-            // This is why not using an arc is a little difficult (need the box\n-            // to stay valid while we take the data).\n-            DATA => unsafe {\n-                (&mut *self.data.get()).take().unwrap();\n-            },\n-\n-            // We're the only ones that can block on this port\n-            _ => unreachable!(),\n-        }\n-    }\n-\n-    ////////////////////////////////////////////////////////////////////////////\n-    // select implementation\n-    ////////////////////////////////////////////////////////////////////////////\n-\n-    // Remove a previous selecting thread from this port. This ensures that the\n-    // blocked thread will no longer be visible to any other threads.\n-    //\n-    // The return value indicates whether there's data on this port.\n-    pub fn abort_selection(&self) -> Result<bool, Receiver<T>> {\n-        let state = match self.state.load(Ordering::SeqCst) {\n-            // Each of these states means that no further activity will happen\n-            // with regard to abortion selection\n-            s @ (EMPTY | DATA | DISCONNECTED) => s,\n-\n-            // If we've got a blocked thread, then use an atomic to gain ownership\n-            // of it (may fail)\n-            ptr => self\n-                .state\n-                .compare_exchange(ptr, EMPTY, Ordering::SeqCst, Ordering::SeqCst)\n-                .unwrap_or_else(|x| x),\n-        };\n-\n-        // Now that we've got ownership of our state, figure out what to do\n-        // about it.\n-        match state {\n-            EMPTY => unreachable!(),\n-            // our thread used for select was stolen\n-            DATA => Ok(true),\n-\n-            // If the other end has hung up, then we have complete ownership\n-            // of the port. First, check if there was data waiting for us. This\n-            // is possible if the other end sent something and then hung up.\n-            //\n-            // We then need to check to see if there was an upgrade requested,\n-            // and if so, the upgraded port needs to have its selection aborted.\n-            DISCONNECTED => unsafe {\n-                if (*self.data.get()).is_some() {\n-                    Ok(true)\n-                } else {\n-                    match ptr::replace(self.upgrade.get(), SendUsed) {\n-                        GoUp(port) => Err(port),\n-                        _ => Ok(true),\n-                    }\n-                }\n-            },\n-\n-            // We woke ourselves up from select.\n-            ptr => unsafe {\n-                drop(SignalToken::from_raw(ptr));\n-                Ok(false)\n-            },\n-        }\n-    }\n-}\n-\n-impl<T> Drop for Packet<T> {\n-    fn drop(&mut self) {\n-        assert_eq!(self.state.load(Ordering::SeqCst), DISCONNECTED);\n-    }\n-}"}, {"sha": "51917bd96bd60a46bd7f1b96df4a0e0bbc0d9a34", "filename": "library/std/src/sync/mpsc/shared.rs", "status": "removed", "additions": 0, "deletions": 501, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/928d14bcd1976ffd33e743aa09c7c22a063bf87c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928d14bcd1976ffd33e743aa09c7c22a063bf87c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fshared.rs?ref=928d14bcd1976ffd33e743aa09c7c22a063bf87c", "patch": "@@ -1,501 +0,0 @@\n-/// Shared channels.\n-///\n-/// This is the flavor of channels which are not necessarily optimized for any\n-/// particular use case, but are the most general in how they are used. Shared\n-/// channels are cloneable allowing for multiple senders.\n-///\n-/// High level implementation details can be found in the comment of the parent\n-/// module. You'll also note that the implementation of the shared and stream\n-/// channels are quite similar, and this is no coincidence!\n-pub use self::Failure::*;\n-use self::StartResult::*;\n-\n-use core::cmp;\n-use core::intrinsics::abort;\n-\n-use crate::cell::UnsafeCell;\n-use crate::ptr;\n-use crate::sync::atomic::{AtomicBool, AtomicIsize, AtomicPtr, AtomicUsize, Ordering};\n-use crate::sync::mpsc::blocking::{self, SignalToken};\n-use crate::sync::mpsc::mpsc_queue as mpsc;\n-use crate::sync::{Mutex, MutexGuard};\n-use crate::thread;\n-use crate::time::Instant;\n-\n-const DISCONNECTED: isize = isize::MIN;\n-const FUDGE: isize = 1024;\n-const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n-#[cfg(test)]\n-const MAX_STEALS: isize = 5;\n-#[cfg(not(test))]\n-const MAX_STEALS: isize = 1 << 20;\n-const EMPTY: *mut u8 = ptr::null_mut(); // initial state: no data, no blocked receiver\n-\n-pub struct Packet<T> {\n-    queue: mpsc::Queue<T>,\n-    cnt: AtomicIsize,          // How many items are on this channel\n-    steals: UnsafeCell<isize>, // How many times has a port received without blocking?\n-    to_wake: AtomicPtr<u8>,    // SignalToken for wake up\n-\n-    // The number of channels which are currently using this packet.\n-    channels: AtomicUsize,\n-\n-    // See the discussion in Port::drop and the channel send methods for what\n-    // these are used for\n-    port_dropped: AtomicBool,\n-    sender_drain: AtomicIsize,\n-\n-    // this lock protects various portions of this implementation during\n-    // select()\n-    select_lock: Mutex<()>,\n-}\n-\n-pub enum Failure {\n-    Empty,\n-    Disconnected,\n-}\n-\n-#[derive(PartialEq, Eq)]\n-enum StartResult {\n-    Installed,\n-    Abort,\n-}\n-\n-impl<T> Packet<T> {\n-    // Creation of a packet *must* be followed by a call to postinit_lock\n-    // and later by inherit_blocker\n-    pub fn new() -> Packet<T> {\n-        Packet {\n-            queue: mpsc::Queue::new(),\n-            cnt: AtomicIsize::new(0),\n-            steals: UnsafeCell::new(0),\n-            to_wake: AtomicPtr::new(EMPTY),\n-            channels: AtomicUsize::new(2),\n-            port_dropped: AtomicBool::new(false),\n-            sender_drain: AtomicIsize::new(0),\n-            select_lock: Mutex::new(()),\n-        }\n-    }\n-\n-    // This function should be used after newly created Packet\n-    // was wrapped with an Arc\n-    // In other case mutex data will be duplicated while cloning\n-    // and that could cause problems on platforms where it is\n-    // represented by opaque data structure\n-    pub fn postinit_lock(&self) -> MutexGuard<'_, ()> {\n-        self.select_lock.lock().unwrap()\n-    }\n-\n-    // This function is used at the creation of a shared packet to inherit a\n-    // previously blocked thread. This is done to prevent spurious wakeups of\n-    // threads in select().\n-    //\n-    // This can only be called at channel-creation time\n-    pub fn inherit_blocker(&self, token: Option<SignalToken>, guard: MutexGuard<'_, ()>) {\n-        if let Some(token) = token {\n-            assert_eq!(self.cnt.load(Ordering::SeqCst), 0);\n-            assert_eq!(self.to_wake.load(Ordering::SeqCst), EMPTY);\n-            self.to_wake.store(unsafe { token.to_raw() }, Ordering::SeqCst);\n-            self.cnt.store(-1, Ordering::SeqCst);\n-\n-            // This store is a little sketchy. What's happening here is that\n-            // we're transferring a blocker from a oneshot or stream channel to\n-            // this shared channel. In doing so, we never spuriously wake them\n-            // up and rather only wake them up at the appropriate time. This\n-            // implementation of shared channels assumes that any blocking\n-            // recv() will undo the increment of steals performed in try_recv()\n-            // once the recv is complete.  This thread that we're inheriting,\n-            // however, is not in the middle of recv. Hence, the first time we\n-            // wake them up, they're going to wake up from their old port, move\n-            // on to the upgraded port, and then call the block recv() function.\n-            //\n-            // When calling this function, they'll find there's data immediately\n-            // available, counting it as a steal. This in fact wasn't a steal\n-            // because we appropriately blocked them waiting for data.\n-            //\n-            // To offset this bad increment, we initially set the steal count to\n-            // -1. You'll find some special code in abort_selection() as well to\n-            // ensure that this -1 steal count doesn't escape too far.\n-            unsafe {\n-                *self.steals.get() = -1;\n-            }\n-        }\n-\n-        // When the shared packet is constructed, we grabbed this lock. The\n-        // purpose of this lock is to ensure that abort_selection() doesn't\n-        // interfere with this method. After we unlock this lock, we're\n-        // signifying that we're done modifying self.cnt and self.to_wake and\n-        // the port is ready for the world to continue using it.\n-        drop(guard);\n-    }\n-\n-    pub fn send(&self, t: T) -> Result<(), T> {\n-        // See Port::drop for what's going on\n-        if self.port_dropped.load(Ordering::SeqCst) {\n-            return Err(t);\n-        }\n-\n-        // Note that the multiple sender case is a little trickier\n-        // semantically than the single sender case. The logic for\n-        // incrementing is \"add and if disconnected store disconnected\".\n-        // This could end up leading some senders to believe that there\n-        // wasn't a disconnect if in fact there was a disconnect. This means\n-        // that while one thread is attempting to re-store the disconnected\n-        // states, other threads could walk through merrily incrementing\n-        // this very-negative disconnected count. To prevent senders from\n-        // spuriously attempting to send when the channels is actually\n-        // disconnected, the count has a ranged check here.\n-        //\n-        // This is also done for another reason. Remember that the return\n-        // value of this function is:\n-        //\n-        //  `true` == the data *may* be received, this essentially has no\n-        //            meaning\n-        //  `false` == the data will *never* be received, this has a lot of\n-        //             meaning\n-        //\n-        // In the SPSC case, we have a check of 'queue.is_empty()' to see\n-        // whether the data was actually received, but this same condition\n-        // means nothing in a multi-producer context. As a result, this\n-        // preflight check serves as the definitive \"this will never be\n-        // received\". Once we get beyond this check, we have permanently\n-        // entered the realm of \"this may be received\"\n-        if self.cnt.load(Ordering::SeqCst) < DISCONNECTED + FUDGE {\n-            return Err(t);\n-        }\n-\n-        self.queue.push(t);\n-        match self.cnt.fetch_add(1, Ordering::SeqCst) {\n-            -1 => {\n-                self.take_to_wake().signal();\n-            }\n-\n-            // In this case, we have possibly failed to send our data, and\n-            // we need to consider re-popping the data in order to fully\n-            // destroy it. We must arbitrate among the multiple senders,\n-            // however, because the queues that we're using are\n-            // single-consumer queues. In order to do this, all exiting\n-            // pushers will use an atomic count in order to count those\n-            // flowing through. Pushers who see 0 are required to drain as\n-            // much as possible, and then can only exit when they are the\n-            // only pusher (otherwise they must try again).\n-            n if n < DISCONNECTED + FUDGE => {\n-                // see the comment in 'try' for a shared channel for why this\n-                // window of \"not disconnected\" is ok.\n-                self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n-\n-                if self.sender_drain.fetch_add(1, Ordering::SeqCst) == 0 {\n-                    loop {\n-                        // drain the queue, for info on the thread yield see the\n-                        // discussion in try_recv\n-                        loop {\n-                            match self.queue.pop() {\n-                                mpsc::Data(..) => {}\n-                                mpsc::Empty => break,\n-                                mpsc::Inconsistent => thread::yield_now(),\n-                            }\n-                        }\n-                        // maybe we're done, if we're not the last ones\n-                        // here, then we need to go try again.\n-                        if self.sender_drain.fetch_sub(1, Ordering::SeqCst) == 1 {\n-                            break;\n-                        }\n-                    }\n-\n-                    // At this point, there may still be data on the queue,\n-                    // but only if the count hasn't been incremented and\n-                    // some other sender hasn't finished pushing data just\n-                    // yet. That sender in question will drain its own data.\n-                }\n-            }\n-\n-            // Can't make any assumptions about this case like in the SPSC case.\n-            _ => {}\n-        }\n-\n-        Ok(())\n-    }\n-\n-    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure> {\n-        // This code is essentially the exact same as that found in the stream\n-        // case (see stream.rs)\n-        match self.try_recv() {\n-            Err(Empty) => {}\n-            data => return data,\n-        }\n-\n-        let (wait_token, signal_token) = blocking::tokens();\n-        if self.decrement(signal_token) == Installed {\n-            if let Some(deadline) = deadline {\n-                let timed_out = !wait_token.wait_max_until(deadline);\n-                if timed_out {\n-                    self.abort_selection(false);\n-                }\n-            } else {\n-                wait_token.wait();\n-            }\n-        }\n-\n-        match self.try_recv() {\n-            data @ Ok(..) => unsafe {\n-                *self.steals.get() -= 1;\n-                data\n-            },\n-            data => data,\n-        }\n-    }\n-\n-    // Essentially the exact same thing as the stream decrement function.\n-    // Returns true if blocking should proceed.\n-    fn decrement(&self, token: SignalToken) -> StartResult {\n-        unsafe {\n-            assert_eq!(\n-                self.to_wake.load(Ordering::SeqCst),\n-                EMPTY,\n-                \"This is a known bug in the Rust standard library. See https://github.com/rust-lang/rust/issues/39364\"\n-            );\n-            let ptr = token.to_raw();\n-            self.to_wake.store(ptr, Ordering::SeqCst);\n-\n-            let steals = ptr::replace(self.steals.get(), 0);\n-\n-            match self.cnt.fetch_sub(1 + steals, Ordering::SeqCst) {\n-                DISCONNECTED => {\n-                    self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n-                }\n-                // If we factor in our steals and notice that the channel has no\n-                // data, we successfully sleep\n-                n => {\n-                    assert!(n >= 0);\n-                    if n - steals <= 0 {\n-                        return Installed;\n-                    }\n-                }\n-            }\n-\n-            self.to_wake.store(EMPTY, Ordering::SeqCst);\n-            drop(SignalToken::from_raw(ptr));\n-            Abort\n-        }\n-    }\n-\n-    pub fn try_recv(&self) -> Result<T, Failure> {\n-        let ret = match self.queue.pop() {\n-            mpsc::Data(t) => Some(t),\n-            mpsc::Empty => None,\n-\n-            // This is a bit of an interesting case. The channel is reported as\n-            // having data available, but our pop() has failed due to the queue\n-            // being in an inconsistent state.  This means that there is some\n-            // pusher somewhere which has yet to complete, but we are guaranteed\n-            // that a pop will eventually succeed. In this case, we spin in a\n-            // yield loop because the remote sender should finish their enqueue\n-            // operation \"very quickly\".\n-            //\n-            // Avoiding this yield loop would require a different queue\n-            // abstraction which provides the guarantee that after M pushes have\n-            // succeeded, at least M pops will succeed. The current queues\n-            // guarantee that if there are N active pushes, you can pop N times\n-            // once all N have finished.\n-            mpsc::Inconsistent => {\n-                let data;\n-                loop {\n-                    thread::yield_now();\n-                    match self.queue.pop() {\n-                        mpsc::Data(t) => {\n-                            data = t;\n-                            break;\n-                        }\n-                        mpsc::Empty => panic!(\"inconsistent => empty\"),\n-                        mpsc::Inconsistent => {}\n-                    }\n-                }\n-                Some(data)\n-            }\n-        };\n-        match ret {\n-            // See the discussion in the stream implementation for why we\n-            // might decrement steals.\n-            Some(data) => unsafe {\n-                if *self.steals.get() > MAX_STEALS {\n-                    match self.cnt.swap(0, Ordering::SeqCst) {\n-                        DISCONNECTED => {\n-                            self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n-                        }\n-                        n => {\n-                            let m = cmp::min(n, *self.steals.get());\n-                            *self.steals.get() -= m;\n-                            self.bump(n - m);\n-                        }\n-                    }\n-                    assert!(*self.steals.get() >= 0);\n-                }\n-                *self.steals.get() += 1;\n-                Ok(data)\n-            },\n-\n-            // See the discussion in the stream implementation for why we try\n-            // again.\n-            None => {\n-                match self.cnt.load(Ordering::SeqCst) {\n-                    n if n != DISCONNECTED => Err(Empty),\n-                    _ => {\n-                        match self.queue.pop() {\n-                            mpsc::Data(t) => Ok(t),\n-                            mpsc::Empty => Err(Disconnected),\n-                            // with no senders, an inconsistency is impossible.\n-                            mpsc::Inconsistent => unreachable!(),\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    // Prepares this shared packet for a channel clone, essentially just bumping\n-    // a refcount.\n-    pub fn clone_chan(&self) {\n-        let old_count = self.channels.fetch_add(1, Ordering::SeqCst);\n-\n-        // See comments on Arc::clone() on why we do this (for `mem::forget`).\n-        if old_count > MAX_REFCOUNT {\n-            abort();\n-        }\n-    }\n-\n-    // Decrement the reference count on a channel. This is called whenever a\n-    // Chan is dropped and may end up waking up a receiver. It's the receiver's\n-    // responsibility on the other end to figure out that we've disconnected.\n-    pub fn drop_chan(&self) {\n-        match self.channels.fetch_sub(1, Ordering::SeqCst) {\n-            1 => {}\n-            n if n > 1 => return,\n-            n => panic!(\"bad number of channels left {n}\"),\n-        }\n-\n-        match self.cnt.swap(DISCONNECTED, Ordering::SeqCst) {\n-            -1 => {\n-                self.take_to_wake().signal();\n-            }\n-            DISCONNECTED => {}\n-            n => {\n-                assert!(n >= 0);\n-            }\n-        }\n-    }\n-\n-    // See the long discussion inside of stream.rs for why the queue is drained,\n-    // and why it is done in this fashion.\n-    pub fn drop_port(&self) {\n-        self.port_dropped.store(true, Ordering::SeqCst);\n-        let mut steals = unsafe { *self.steals.get() };\n-        while {\n-            match self.cnt.compare_exchange(\n-                steals,\n-                DISCONNECTED,\n-                Ordering::SeqCst,\n-                Ordering::SeqCst,\n-            ) {\n-                Ok(_) => false,\n-                Err(old) => old != DISCONNECTED,\n-            }\n-        } {\n-            // See the discussion in 'try_recv' for why we yield\n-            // control of this thread.\n-            loop {\n-                match self.queue.pop() {\n-                    mpsc::Data(..) => {\n-                        steals += 1;\n-                    }\n-                    mpsc::Empty | mpsc::Inconsistent => break,\n-                }\n-            }\n-        }\n-    }\n-\n-    // Consumes ownership of the 'to_wake' field.\n-    fn take_to_wake(&self) -> SignalToken {\n-        let ptr = self.to_wake.load(Ordering::SeqCst);\n-        self.to_wake.store(EMPTY, Ordering::SeqCst);\n-        assert!(ptr != EMPTY);\n-        unsafe { SignalToken::from_raw(ptr) }\n-    }\n-\n-    ////////////////////////////////////////////////////////////////////////////\n-    // select implementation\n-    ////////////////////////////////////////////////////////////////////////////\n-\n-    // increment the count on the channel (used for selection)\n-    fn bump(&self, amt: isize) -> isize {\n-        match self.cnt.fetch_add(amt, Ordering::SeqCst) {\n-            DISCONNECTED => {\n-                self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n-                DISCONNECTED\n-            }\n-            n => n,\n-        }\n-    }\n-\n-    // Cancels a previous thread waiting on this port, returning whether there's\n-    // data on the port.\n-    //\n-    // This is similar to the stream implementation (hence fewer comments), but\n-    // uses a different value for the \"steals\" variable.\n-    pub fn abort_selection(&self, _was_upgrade: bool) -> bool {\n-        // Before we do anything else, we bounce on this lock. The reason for\n-        // doing this is to ensure that any upgrade-in-progress is gone and\n-        // done with. Without this bounce, we can race with inherit_blocker\n-        // about looking at and dealing with to_wake. Once we have acquired the\n-        // lock, we are guaranteed that inherit_blocker is done.\n-        {\n-            let _guard = self.select_lock.lock().unwrap();\n-        }\n-\n-        // Like the stream implementation, we want to make sure that the count\n-        // on the channel goes non-negative. We don't know how negative the\n-        // stream currently is, so instead of using a steal value of 1, we load\n-        // the channel count and figure out what we should do to make it\n-        // positive.\n-        let steals = {\n-            let cnt = self.cnt.load(Ordering::SeqCst);\n-            if cnt < 0 && cnt != DISCONNECTED { -cnt } else { 0 }\n-        };\n-        let prev = self.bump(steals + 1);\n-\n-        if prev == DISCONNECTED {\n-            assert_eq!(self.to_wake.load(Ordering::SeqCst), EMPTY);\n-            true\n-        } else {\n-            let cur = prev + steals + 1;\n-            assert!(cur >= 0);\n-            if prev < 0 {\n-                drop(self.take_to_wake());\n-            } else {\n-                while self.to_wake.load(Ordering::SeqCst) != EMPTY {\n-                    thread::yield_now();\n-                }\n-            }\n-            unsafe {\n-                // if the number of steals is -1, it was the pre-emptive -1 steal\n-                // count from when we inherited a blocker. This is fine because\n-                // we're just going to overwrite it with a real value.\n-                let old = self.steals.get();\n-                assert!(*old == 0 || *old == -1);\n-                *old = steals;\n-                prev >= 0\n-            }\n-        }\n-    }\n-}\n-\n-impl<T> Drop for Packet<T> {\n-    fn drop(&mut self) {\n-        // Note that this load is not only an assert for correctness about\n-        // disconnection, but also a proper fence before the read of\n-        // `to_wake`, so this assert cannot be removed with also removing\n-        // the `to_wake` assert.\n-        assert_eq!(self.cnt.load(Ordering::SeqCst), DISCONNECTED);\n-        assert_eq!(self.to_wake.load(Ordering::SeqCst), EMPTY);\n-        assert_eq!(self.channels.load(Ordering::SeqCst), 0);\n-    }\n-}"}, {"sha": "61f91313ea96d79f645c4cfee272826ee5947de3", "filename": "library/std/src/sync/mpsc/spsc_queue.rs", "status": "removed", "additions": 0, "deletions": 244, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/928d14bcd1976ffd33e743aa09c7c22a063bf87c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928d14bcd1976ffd33e743aa09c7c22a063bf87c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=928d14bcd1976ffd33e743aa09c7c22a063bf87c", "patch": "@@ -1,244 +0,0 @@\n-//! A single-producer single-consumer concurrent queue\n-//!\n-//! This module contains the implementation of an SPSC queue which can be used\n-//! concurrently between two threads. This data structure is safe to use and\n-//! enforces the semantics that there is one pusher and one popper.\n-\n-// The original implementation is based off:\n-// https://www.1024cores.net/home/lock-free-algorithms/queues/unbounded-spsc-queue\n-//\n-// Note that back when the code was imported, it was licensed under the BSD-2-Clause license:\n-// http://web.archive.org/web/20110411011612/https://www.1024cores.net/home/lock-free-algorithms/queues/unbounded-spsc-queue\n-//\n-// The original author of the code agreed to relicense it under `MIT OR Apache-2.0` in 2017, so as\n-// of today the license of this file is the same as the rest of the codebase:\n-// https://github.com/rust-lang/rust/pull/42149\n-\n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n-mod tests;\n-\n-use core::cell::UnsafeCell;\n-use core::ptr;\n-\n-use crate::boxed::Box;\n-use crate::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};\n-\n-use super::cache_aligned::CacheAligned;\n-\n-// Node within the linked list queue of messages to send\n-struct Node<T> {\n-    // FIXME: this could be an uninitialized T if we're careful enough, and\n-    //      that would reduce memory usage (and be a bit faster).\n-    //      is it worth it?\n-    value: Option<T>,         // nullable for re-use of nodes\n-    cached: bool,             // This node goes into the node cache\n-    next: AtomicPtr<Node<T>>, // next node in the queue\n-}\n-\n-/// The single-producer single-consumer queue. This structure is not cloneable,\n-/// but it can be safely shared in an Arc if it is guaranteed that there\n-/// is only one popper and one pusher touching the queue at any one point in\n-/// time.\n-pub struct Queue<T, ProducerAddition = (), ConsumerAddition = ()> {\n-    // consumer fields\n-    consumer: CacheAligned<Consumer<T, ConsumerAddition>>,\n-\n-    // producer fields\n-    producer: CacheAligned<Producer<T, ProducerAddition>>,\n-}\n-\n-struct Consumer<T, Addition> {\n-    tail: UnsafeCell<*mut Node<T>>, // where to pop from\n-    tail_prev: AtomicPtr<Node<T>>,  // where to pop from\n-    cache_bound: usize,             // maximum cache size\n-    cached_nodes: AtomicUsize,      // number of nodes marked as cacheable\n-    addition: Addition,\n-}\n-\n-struct Producer<T, Addition> {\n-    head: UnsafeCell<*mut Node<T>>,      // where to push to\n-    first: UnsafeCell<*mut Node<T>>,     // where to get new nodes from\n-    tail_copy: UnsafeCell<*mut Node<T>>, // between first/tail\n-    addition: Addition,\n-}\n-\n-unsafe impl<T: Send, P: Send + Sync, C: Send + Sync> Send for Queue<T, P, C> {}\n-\n-unsafe impl<T: Send, P: Send + Sync, C: Send + Sync> Sync for Queue<T, P, C> {}\n-\n-impl<T> Node<T> {\n-    fn new() -> *mut Node<T> {\n-        Box::into_raw(box Node {\n-            value: None,\n-            cached: false,\n-            next: AtomicPtr::new(ptr::null_mut::<Node<T>>()),\n-        })\n-    }\n-}\n-\n-impl<T, ProducerAddition, ConsumerAddition> Queue<T, ProducerAddition, ConsumerAddition> {\n-    /// Creates a new queue. With given additional elements in the producer and\n-    /// consumer portions of the queue.\n-    ///\n-    /// Due to the performance implications of cache-contention,\n-    /// we wish to keep fields used mainly by the producer on a separate cache\n-    /// line than those used by the consumer.\n-    /// Since cache lines are usually 64 bytes, it is unreasonably expensive to\n-    /// allocate one for small fields, so we allow users to insert additional\n-    /// fields into the cache lines already allocated by this for the producer\n-    /// and consumer.\n-    ///\n-    /// This is unsafe as the type system doesn't enforce a single\n-    /// consumer-producer relationship. It also allows the consumer to `pop`\n-    /// items while there is a `peek` active due to all methods having a\n-    /// non-mutable receiver.\n-    ///\n-    /// # Arguments\n-    ///\n-    ///   * `bound` - This queue implementation is implemented with a linked\n-    ///               list, and this means that a push is always a malloc. In\n-    ///               order to amortize this cost, an internal cache of nodes is\n-    ///               maintained to prevent a malloc from always being\n-    ///               necessary. This bound is the limit on the size of the\n-    ///               cache (if desired). If the value is 0, then the cache has\n-    ///               no bound. Otherwise, the cache will never grow larger than\n-    ///               `bound` (although the queue itself could be much larger.\n-    pub unsafe fn with_additions(\n-        bound: usize,\n-        producer_addition: ProducerAddition,\n-        consumer_addition: ConsumerAddition,\n-    ) -> Self {\n-        let n1 = Node::new();\n-        let n2 = Node::new();\n-        (*n1).next.store(n2, Ordering::Relaxed);\n-        Queue {\n-            consumer: CacheAligned::new(Consumer {\n-                tail: UnsafeCell::new(n2),\n-                tail_prev: AtomicPtr::new(n1),\n-                cache_bound: bound,\n-                cached_nodes: AtomicUsize::new(0),\n-                addition: consumer_addition,\n-            }),\n-            producer: CacheAligned::new(Producer {\n-                head: UnsafeCell::new(n2),\n-                first: UnsafeCell::new(n1),\n-                tail_copy: UnsafeCell::new(n1),\n-                addition: producer_addition,\n-            }),\n-        }\n-    }\n-\n-    /// Pushes a new value onto this queue. Note that to use this function\n-    /// safely, it must be externally guaranteed that there is only one pusher.\n-    pub fn push(&self, t: T) {\n-        unsafe {\n-            // Acquire a node (which either uses a cached one or allocates a new\n-            // one), and then append this to the 'head' node.\n-            let n = self.alloc();\n-            assert!((*n).value.is_none());\n-            (*n).value = Some(t);\n-            (*n).next.store(ptr::null_mut(), Ordering::Relaxed);\n-            (**self.producer.head.get()).next.store(n, Ordering::Release);\n-            *(&self.producer.head).get() = n;\n-        }\n-    }\n-\n-    unsafe fn alloc(&self) -> *mut Node<T> {\n-        // First try to see if we can consume the 'first' node for our uses.\n-        if *self.producer.first.get() != *self.producer.tail_copy.get() {\n-            let ret = *self.producer.first.get();\n-            *self.producer.0.first.get() = (*ret).next.load(Ordering::Relaxed);\n-            return ret;\n-        }\n-        // If the above fails, then update our copy of the tail and try\n-        // again.\n-        *self.producer.0.tail_copy.get() = self.consumer.tail_prev.load(Ordering::Acquire);\n-        if *self.producer.first.get() != *self.producer.tail_copy.get() {\n-            let ret = *self.producer.first.get();\n-            *self.producer.0.first.get() = (*ret).next.load(Ordering::Relaxed);\n-            return ret;\n-        }\n-        // If all of that fails, then we have to allocate a new node\n-        // (there's nothing in the node cache).\n-        Node::new()\n-    }\n-\n-    /// Attempts to pop a value from this queue. Remember that to use this type\n-    /// safely you must ensure that there is only one popper at a time.\n-    pub fn pop(&self) -> Option<T> {\n-        unsafe {\n-            // The `tail` node is not actually a used node, but rather a\n-            // sentinel from where we should start popping from. Hence, look at\n-            // tail's next field and see if we can use it. If we do a pop, then\n-            // the current tail node is a candidate for going into the cache.\n-            let tail = *self.consumer.tail.get();\n-            let next = (*tail).next.load(Ordering::Acquire);\n-            if next.is_null() {\n-                return None;\n-            }\n-            assert!((*next).value.is_some());\n-            let ret = (*next).value.take();\n-\n-            *self.consumer.0.tail.get() = next;\n-            if self.consumer.cache_bound == 0 {\n-                self.consumer.tail_prev.store(tail, Ordering::Release);\n-            } else {\n-                let cached_nodes = self.consumer.cached_nodes.load(Ordering::Relaxed);\n-                if cached_nodes < self.consumer.cache_bound && !(*tail).cached {\n-                    self.consumer.cached_nodes.store(cached_nodes, Ordering::Relaxed);\n-                    (*tail).cached = true;\n-                }\n-\n-                if (*tail).cached {\n-                    self.consumer.tail_prev.store(tail, Ordering::Release);\n-                } else {\n-                    (*self.consumer.tail_prev.load(Ordering::Relaxed))\n-                        .next\n-                        .store(next, Ordering::Relaxed);\n-                    // We have successfully erased all references to 'tail', so\n-                    // now we can safely drop it.\n-                    let _: Box<Node<T>> = Box::from_raw(tail);\n-                }\n-            }\n-            ret\n-        }\n-    }\n-\n-    /// Attempts to peek at the head of the queue, returning `None` if the queue\n-    /// has no data currently\n-    ///\n-    /// # Warning\n-    /// The reference returned is invalid if it is not used before the consumer\n-    /// pops the value off the queue. If the producer then pushes another value\n-    /// onto the queue, it will overwrite the value pointed to by the reference.\n-    pub fn peek(&self) -> Option<&mut T> {\n-        // This is essentially the same as above with all the popping bits\n-        // stripped out.\n-        unsafe {\n-            let tail = *self.consumer.tail.get();\n-            let next = (*tail).next.load(Ordering::Acquire);\n-            if next.is_null() { None } else { (*next).value.as_mut() }\n-        }\n-    }\n-\n-    pub fn producer_addition(&self) -> &ProducerAddition {\n-        &self.producer.addition\n-    }\n-\n-    pub fn consumer_addition(&self) -> &ConsumerAddition {\n-        &self.consumer.addition\n-    }\n-}\n-\n-impl<T, ProducerAddition, ConsumerAddition> Drop for Queue<T, ProducerAddition, ConsumerAddition> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            let mut cur = *self.producer.first.get();\n-            while !cur.is_null() {\n-                let next = (*cur).next.load(Ordering::Relaxed);\n-                let _n: Box<Node<T>> = Box::from_raw(cur);\n-                cur = next;\n-            }\n-        }\n-    }\n-}"}, {"sha": "eb6d5c2cf66d8fc71a850d05646c1706916dfbbc", "filename": "library/std/src/sync/mpsc/spsc_queue/tests.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/928d14bcd1976ffd33e743aa09c7c22a063bf87c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928d14bcd1976ffd33e743aa09c7c22a063bf87c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue%2Ftests.rs?ref=928d14bcd1976ffd33e743aa09c7c22a063bf87c", "patch": "@@ -1,102 +0,0 @@\n-use super::Queue;\n-use crate::sync::mpsc::channel;\n-use crate::sync::Arc;\n-use crate::thread;\n-\n-#[test]\n-fn smoke() {\n-    unsafe {\n-        let queue = Queue::with_additions(0, (), ());\n-        queue.push(1);\n-        queue.push(2);\n-        assert_eq!(queue.pop(), Some(1));\n-        assert_eq!(queue.pop(), Some(2));\n-        assert_eq!(queue.pop(), None);\n-        queue.push(3);\n-        queue.push(4);\n-        assert_eq!(queue.pop(), Some(3));\n-        assert_eq!(queue.pop(), Some(4));\n-        assert_eq!(queue.pop(), None);\n-    }\n-}\n-\n-#[test]\n-fn peek() {\n-    unsafe {\n-        let queue = Queue::with_additions(0, (), ());\n-        queue.push(vec![1]);\n-\n-        // Ensure the borrowchecker works\n-        match queue.peek() {\n-            Some(vec) => {\n-                assert_eq!(&*vec, &[1]);\n-            }\n-            None => unreachable!(),\n-        }\n-\n-        match queue.pop() {\n-            Some(vec) => {\n-                assert_eq!(&*vec, &[1]);\n-            }\n-            None => unreachable!(),\n-        }\n-    }\n-}\n-\n-#[test]\n-fn drop_full() {\n-    unsafe {\n-        let q: Queue<Box<_>> = Queue::with_additions(0, (), ());\n-        q.push(Box::new(1));\n-        q.push(Box::new(2));\n-    }\n-}\n-\n-#[test]\n-fn smoke_bound() {\n-    unsafe {\n-        let q = Queue::with_additions(0, (), ());\n-        q.push(1);\n-        q.push(2);\n-        assert_eq!(q.pop(), Some(1));\n-        assert_eq!(q.pop(), Some(2));\n-        assert_eq!(q.pop(), None);\n-        q.push(3);\n-        q.push(4);\n-        assert_eq!(q.pop(), Some(3));\n-        assert_eq!(q.pop(), Some(4));\n-        assert_eq!(q.pop(), None);\n-    }\n-}\n-\n-#[test]\n-fn stress() {\n-    unsafe {\n-        stress_bound(0);\n-        stress_bound(1);\n-    }\n-\n-    unsafe fn stress_bound(bound: usize) {\n-        let count = if cfg!(miri) { 1000 } else { 100000 };\n-        let q = Arc::new(Queue::with_additions(bound, (), ()));\n-\n-        let (tx, rx) = channel();\n-        let q2 = q.clone();\n-        let _t = thread::spawn(move || {\n-            for _ in 0..count {\n-                loop {\n-                    match q2.pop() {\n-                        Some(1) => break,\n-                        Some(_) => panic!(),\n-                        None => {}\n-                    }\n-                }\n-            }\n-            tx.send(()).unwrap();\n-        });\n-        for _ in 0..count {\n-            q.push(1);\n-        }\n-        rx.recv().unwrap();\n-    }\n-}"}, {"sha": "4592e9141600e600d876a07aabe2cb6d10e70114", "filename": "library/std/src/sync/mpsc/stream.rs", "status": "removed", "additions": 0, "deletions": 457, "changes": 457, "blob_url": "https://github.com/rust-lang/rust/blob/928d14bcd1976ffd33e743aa09c7c22a063bf87c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928d14bcd1976ffd33e743aa09c7c22a063bf87c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fstream.rs?ref=928d14bcd1976ffd33e743aa09c7c22a063bf87c", "patch": "@@ -1,457 +0,0 @@\n-/// Stream channels\n-///\n-/// This is the flavor of channels which are optimized for one sender and one\n-/// receiver. The sender will be upgraded to a shared channel if the channel is\n-/// cloned.\n-///\n-/// High level implementation details can be found in the comment of the parent\n-/// module.\n-pub use self::Failure::*;\n-use self::Message::*;\n-pub use self::UpgradeResult::*;\n-\n-use core::cmp;\n-\n-use crate::cell::UnsafeCell;\n-use crate::ptr;\n-use crate::thread;\n-use crate::time::Instant;\n-\n-use crate::sync::atomic::{AtomicBool, AtomicIsize, AtomicPtr, Ordering};\n-use crate::sync::mpsc::blocking::{self, SignalToken};\n-use crate::sync::mpsc::spsc_queue as spsc;\n-use crate::sync::mpsc::Receiver;\n-\n-const DISCONNECTED: isize = isize::MIN;\n-#[cfg(test)]\n-const MAX_STEALS: isize = 5;\n-#[cfg(not(test))]\n-const MAX_STEALS: isize = 1 << 20;\n-const EMPTY: *mut u8 = ptr::null_mut(); // initial state: no data, no blocked receiver\n-\n-pub struct Packet<T> {\n-    // internal queue for all messages\n-    queue: spsc::Queue<Message<T>, ProducerAddition, ConsumerAddition>,\n-}\n-\n-struct ProducerAddition {\n-    cnt: AtomicIsize,       // How many items are on this channel\n-    to_wake: AtomicPtr<u8>, // SignalToken for the blocked thread to wake up\n-\n-    port_dropped: AtomicBool, // flag if the channel has been destroyed.\n-}\n-\n-struct ConsumerAddition {\n-    steals: UnsafeCell<isize>, // How many times has a port received without blocking?\n-}\n-\n-pub enum Failure<T> {\n-    Empty,\n-    Disconnected,\n-    Upgraded(Receiver<T>),\n-}\n-\n-pub enum UpgradeResult {\n-    UpSuccess,\n-    UpDisconnected,\n-    UpWoke(SignalToken),\n-}\n-\n-// Any message could contain an \"upgrade request\" to a new shared port, so the\n-// internal queue it's a queue of T, but rather Message<T>\n-enum Message<T> {\n-    Data(T),\n-    GoUp(Receiver<T>),\n-}\n-\n-impl<T> Packet<T> {\n-    pub fn new() -> Packet<T> {\n-        Packet {\n-            queue: unsafe {\n-                spsc::Queue::with_additions(\n-                    128,\n-                    ProducerAddition {\n-                        cnt: AtomicIsize::new(0),\n-                        to_wake: AtomicPtr::new(EMPTY),\n-\n-                        port_dropped: AtomicBool::new(false),\n-                    },\n-                    ConsumerAddition { steals: UnsafeCell::new(0) },\n-                )\n-            },\n-        }\n-    }\n-\n-    pub fn send(&self, t: T) -> Result<(), T> {\n-        // If the other port has deterministically gone away, then definitely\n-        // must return the data back up the stack. Otherwise, the data is\n-        // considered as being sent.\n-        if self.queue.producer_addition().port_dropped.load(Ordering::SeqCst) {\n-            return Err(t);\n-        }\n-\n-        match self.do_send(Data(t)) {\n-            UpSuccess | UpDisconnected => {}\n-            UpWoke(token) => {\n-                token.signal();\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn upgrade(&self, up: Receiver<T>) -> UpgradeResult {\n-        // If the port has gone away, then there's no need to proceed any\n-        // further.\n-        if self.queue.producer_addition().port_dropped.load(Ordering::SeqCst) {\n-            return UpDisconnected;\n-        }\n-\n-        self.do_send(GoUp(up))\n-    }\n-\n-    fn do_send(&self, t: Message<T>) -> UpgradeResult {\n-        self.queue.push(t);\n-        match self.queue.producer_addition().cnt.fetch_add(1, Ordering::SeqCst) {\n-            // As described in the mod's doc comment, -1 == wakeup\n-            -1 => UpWoke(self.take_to_wake()),\n-            // As described before, SPSC queues must be >= -2\n-            -2 => UpSuccess,\n-\n-            // Be sure to preserve the disconnected state, and the return value\n-            // in this case is going to be whether our data was received or not.\n-            // This manifests itself on whether we have an empty queue or not.\n-            //\n-            // Primarily, are required to drain the queue here because the port\n-            // will never remove this data. We can only have at most one item to\n-            // drain (the port drains the rest).\n-            DISCONNECTED => {\n-                self.queue.producer_addition().cnt.store(DISCONNECTED, Ordering::SeqCst);\n-                let first = self.queue.pop();\n-                let second = self.queue.pop();\n-                assert!(second.is_none());\n-\n-                match first {\n-                    Some(..) => UpSuccess,  // we failed to send the data\n-                    None => UpDisconnected, // we successfully sent data\n-                }\n-            }\n-\n-            // Otherwise we just sent some data on a non-waiting queue, so just\n-            // make sure the world is sane and carry on!\n-            n => {\n-                assert!(n >= 0);\n-                UpSuccess\n-            }\n-        }\n-    }\n-\n-    // Consumes ownership of the 'to_wake' field.\n-    fn take_to_wake(&self) -> SignalToken {\n-        let ptr = self.queue.producer_addition().to_wake.load(Ordering::SeqCst);\n-        self.queue.producer_addition().to_wake.store(EMPTY, Ordering::SeqCst);\n-        assert!(ptr != EMPTY);\n-        unsafe { SignalToken::from_raw(ptr) }\n-    }\n-\n-    // Decrements the count on the channel for a sleeper, returning the sleeper\n-    // back if it shouldn't sleep. Note that this is the location where we take\n-    // steals into account.\n-    fn decrement(&self, token: SignalToken) -> Result<(), SignalToken> {\n-        assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), EMPTY);\n-        let ptr = unsafe { token.to_raw() };\n-        self.queue.producer_addition().to_wake.store(ptr, Ordering::SeqCst);\n-\n-        let steals = unsafe { ptr::replace(self.queue.consumer_addition().steals.get(), 0) };\n-\n-        match self.queue.producer_addition().cnt.fetch_sub(1 + steals, Ordering::SeqCst) {\n-            DISCONNECTED => {\n-                self.queue.producer_addition().cnt.store(DISCONNECTED, Ordering::SeqCst);\n-            }\n-            // If we factor in our steals and notice that the channel has no\n-            // data, we successfully sleep\n-            n => {\n-                assert!(n >= 0);\n-                if n - steals <= 0 {\n-                    return Ok(());\n-                }\n-            }\n-        }\n-\n-        self.queue.producer_addition().to_wake.store(EMPTY, Ordering::SeqCst);\n-        Err(unsafe { SignalToken::from_raw(ptr) })\n-    }\n-\n-    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure<T>> {\n-        // Optimistic preflight check (scheduling is expensive).\n-        match self.try_recv() {\n-            Err(Empty) => {}\n-            data => return data,\n-        }\n-\n-        // Welp, our channel has no data. Deschedule the current thread and\n-        // initiate the blocking protocol.\n-        let (wait_token, signal_token) = blocking::tokens();\n-        if self.decrement(signal_token).is_ok() {\n-            if let Some(deadline) = deadline {\n-                let timed_out = !wait_token.wait_max_until(deadline);\n-                if timed_out {\n-                    self.abort_selection(/* was_upgrade = */ false).map_err(Upgraded)?;\n-                }\n-            } else {\n-                wait_token.wait();\n-            }\n-        }\n-\n-        match self.try_recv() {\n-            // Messages which actually popped from the queue shouldn't count as\n-            // a steal, so offset the decrement here (we already have our\n-            // \"steal\" factored into the channel count above).\n-            data @ (Ok(..) | Err(Upgraded(..))) => unsafe {\n-                *self.queue.consumer_addition().steals.get() -= 1;\n-                data\n-            },\n-\n-            data => data,\n-        }\n-    }\n-\n-    pub fn try_recv(&self) -> Result<T, Failure<T>> {\n-        match self.queue.pop() {\n-            // If we stole some data, record to that effect (this will be\n-            // factored into cnt later on).\n-            //\n-            // Note that we don't allow steals to grow without bound in order to\n-            // prevent eventual overflow of either steals or cnt as an overflow\n-            // would have catastrophic results. Sometimes, steals > cnt, but\n-            // other times cnt > steals, so we don't know the relation between\n-            // steals and cnt. This code path is executed only rarely, so we do\n-            // a pretty slow operation, of swapping 0 into cnt, taking steals\n-            // down as much as possible (without going negative), and then\n-            // adding back in whatever we couldn't factor into steals.\n-            Some(data) => unsafe {\n-                if *self.queue.consumer_addition().steals.get() > MAX_STEALS {\n-                    match self.queue.producer_addition().cnt.swap(0, Ordering::SeqCst) {\n-                        DISCONNECTED => {\n-                            self.queue\n-                                .producer_addition()\n-                                .cnt\n-                                .store(DISCONNECTED, Ordering::SeqCst);\n-                        }\n-                        n => {\n-                            let m = cmp::min(n, *self.queue.consumer_addition().steals.get());\n-                            *self.queue.consumer_addition().steals.get() -= m;\n-                            self.bump(n - m);\n-                        }\n-                    }\n-                    assert!(*self.queue.consumer_addition().steals.get() >= 0);\n-                }\n-                *self.queue.consumer_addition().steals.get() += 1;\n-                match data {\n-                    Data(t) => Ok(t),\n-                    GoUp(up) => Err(Upgraded(up)),\n-                }\n-            },\n-\n-            None => {\n-                match self.queue.producer_addition().cnt.load(Ordering::SeqCst) {\n-                    n if n != DISCONNECTED => Err(Empty),\n-\n-                    // This is a little bit of a tricky case. We failed to pop\n-                    // data above, and then we have viewed that the channel is\n-                    // disconnected. In this window more data could have been\n-                    // sent on the channel. It doesn't really make sense to\n-                    // return that the channel is disconnected when there's\n-                    // actually data on it, so be extra sure there's no data by\n-                    // popping one more time.\n-                    //\n-                    // We can ignore steals because the other end is\n-                    // disconnected and we'll never need to really factor in our\n-                    // steals again.\n-                    _ => match self.queue.pop() {\n-                        Some(Data(t)) => Ok(t),\n-                        Some(GoUp(up)) => Err(Upgraded(up)),\n-                        None => Err(Disconnected),\n-                    },\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn drop_chan(&self) {\n-        // Dropping a channel is pretty simple, we just flag it as disconnected\n-        // and then wakeup a blocker if there is one.\n-        match self.queue.producer_addition().cnt.swap(DISCONNECTED, Ordering::SeqCst) {\n-            -1 => {\n-                self.take_to_wake().signal();\n-            }\n-            DISCONNECTED => {}\n-            n => {\n-                assert!(n >= 0);\n-            }\n-        }\n-    }\n-\n-    pub fn drop_port(&self) {\n-        // Dropping a port seems like a fairly trivial thing. In theory all we\n-        // need to do is flag that we're disconnected and then everything else\n-        // can take over (we don't have anyone to wake up).\n-        //\n-        // The catch for Ports is that we want to drop the entire contents of\n-        // the queue. There are multiple reasons for having this property, the\n-        // largest of which is that if another chan is waiting in this channel\n-        // (but not received yet), then waiting on that port will cause a\n-        // deadlock.\n-        //\n-        // So if we accept that we must now destroy the entire contents of the\n-        // queue, this code may make a bit more sense. The tricky part is that\n-        // we can't let any in-flight sends go un-dropped, we have to make sure\n-        // *everything* is dropped and nothing new will come onto the channel.\n-\n-        // The first thing we do is set a flag saying that we're done for. All\n-        // sends are gated on this flag, so we're immediately guaranteed that\n-        // there are a bounded number of active sends that we'll have to deal\n-        // with.\n-        self.queue.producer_addition().port_dropped.store(true, Ordering::SeqCst);\n-\n-        // Now that we're guaranteed to deal with a bounded number of senders,\n-        // we need to drain the queue. This draining process happens atomically\n-        // with respect to the \"count\" of the channel. If the count is nonzero\n-        // (with steals taken into account), then there must be data on the\n-        // channel. In this case we drain everything and then try again. We will\n-        // continue to fail while active senders send data while we're dropping\n-        // data, but eventually we're guaranteed to break out of this loop\n-        // (because there is a bounded number of senders).\n-        let mut steals = unsafe { *self.queue.consumer_addition().steals.get() };\n-        while {\n-            match self.queue.producer_addition().cnt.compare_exchange(\n-                steals,\n-                DISCONNECTED,\n-                Ordering::SeqCst,\n-                Ordering::SeqCst,\n-            ) {\n-                Ok(_) => false,\n-                Err(old) => old != DISCONNECTED,\n-            }\n-        } {\n-            while self.queue.pop().is_some() {\n-                steals += 1;\n-            }\n-        }\n-\n-        // At this point in time, we have gated all future senders from sending,\n-        // and we have flagged the channel as being disconnected. The senders\n-        // still have some responsibility, however, because some sends might not\n-        // complete until after we flag the disconnection. There are more\n-        // details in the sending methods that see DISCONNECTED\n-    }\n-\n-    ////////////////////////////////////////////////////////////////////////////\n-    // select implementation\n-    ////////////////////////////////////////////////////////////////////////////\n-\n-    // increment the count on the channel (used for selection)\n-    fn bump(&self, amt: isize) -> isize {\n-        match self.queue.producer_addition().cnt.fetch_add(amt, Ordering::SeqCst) {\n-            DISCONNECTED => {\n-                self.queue.producer_addition().cnt.store(DISCONNECTED, Ordering::SeqCst);\n-                DISCONNECTED\n-            }\n-            n => n,\n-        }\n-    }\n-\n-    // Removes a previous thread from being blocked in this port\n-    pub fn abort_selection(&self, was_upgrade: bool) -> Result<bool, Receiver<T>> {\n-        // If we're aborting selection after upgrading from a oneshot, then\n-        // we're guarantee that no one is waiting. The only way that we could\n-        // have seen the upgrade is if data was actually sent on the channel\n-        // half again. For us, this means that there is guaranteed to be data on\n-        // this channel. Furthermore, we're guaranteed that there was no\n-        // start_selection previously, so there's no need to modify `self.cnt`\n-        // at all.\n-        //\n-        // Hence, because of these invariants, we immediately return `Ok(true)`.\n-        // Note that the data might not actually be sent on the channel just yet.\n-        // The other end could have flagged the upgrade but not sent data to\n-        // this end. This is fine because we know it's a small bounded windows\n-        // of time until the data is actually sent.\n-        if was_upgrade {\n-            assert_eq!(unsafe { *self.queue.consumer_addition().steals.get() }, 0);\n-            assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), EMPTY);\n-            return Ok(true);\n-        }\n-\n-        // We want to make sure that the count on the channel goes non-negative,\n-        // and in the stream case we can have at most one steal, so just assume\n-        // that we had one steal.\n-        let steals = 1;\n-        let prev = self.bump(steals + 1);\n-\n-        // If we were previously disconnected, then we know for sure that there\n-        // is no thread in to_wake, so just keep going\n-        let has_data = if prev == DISCONNECTED {\n-            assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), EMPTY);\n-            true // there is data, that data is that we're disconnected\n-        } else {\n-            let cur = prev + steals + 1;\n-            assert!(cur >= 0);\n-\n-            // If the previous count was negative, then we just made things go\n-            // positive, hence we passed the -1 boundary and we're responsible\n-            // for removing the to_wake() field and trashing it.\n-            //\n-            // If the previous count was positive then we're in a tougher\n-            // situation. A possible race is that a sender just incremented\n-            // through -1 (meaning it's going to try to wake a thread up), but it\n-            // hasn't yet read the to_wake. In order to prevent a future recv()\n-            // from waking up too early (this sender picking up the plastered\n-            // over to_wake), we spin loop here waiting for to_wake to be 0.\n-            // Note that this entire select() implementation needs an overhaul,\n-            // and this is *not* the worst part of it, so this is not done as a\n-            // final solution but rather out of necessity for now to get\n-            // something working.\n-            if prev < 0 {\n-                drop(self.take_to_wake());\n-            } else {\n-                while self.queue.producer_addition().to_wake.load(Ordering::SeqCst) != EMPTY {\n-                    thread::yield_now();\n-                }\n-            }\n-            unsafe {\n-                assert_eq!(*self.queue.consumer_addition().steals.get(), 0);\n-                *self.queue.consumer_addition().steals.get() = steals;\n-            }\n-\n-            // if we were previously positive, then there's surely data to\n-            // receive\n-            prev >= 0\n-        };\n-\n-        // Now that we've determined that this queue \"has data\", we peek at the\n-        // queue to see if the data is an upgrade or not. If it's an upgrade,\n-        // then we need to destroy this port and abort selection on the\n-        // upgraded port.\n-        if has_data {\n-            match self.queue.peek() {\n-                Some(&mut GoUp(..)) => match self.queue.pop() {\n-                    Some(GoUp(port)) => Err(port),\n-                    _ => unreachable!(),\n-                },\n-                _ => Ok(true),\n-            }\n-        } else {\n-            Ok(false)\n-        }\n-    }\n-}\n-\n-impl<T> Drop for Packet<T> {\n-    fn drop(&mut self) {\n-        // Note that this load is not only an assert for correctness about\n-        // disconnection, but also a proper fence before the read of\n-        // `to_wake`, so this assert cannot be removed with also removing\n-        // the `to_wake` assert.\n-        assert_eq!(self.queue.producer_addition().cnt.load(Ordering::SeqCst), DISCONNECTED);\n-        assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), EMPTY);\n-    }\n-}"}, {"sha": "733761671a041e75bffa361e8cc906a26559b4fb", "filename": "library/std/src/sync/mpsc/sync.rs", "status": "removed", "additions": 0, "deletions": 495, "changes": 495, "blob_url": "https://github.com/rust-lang/rust/blob/928d14bcd1976ffd33e743aa09c7c22a063bf87c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928d14bcd1976ffd33e743aa09c7c22a063bf87c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync.rs?ref=928d14bcd1976ffd33e743aa09c7c22a063bf87c", "patch": "@@ -1,495 +0,0 @@\n-use self::Blocker::*;\n-/// Synchronous channels/ports\n-///\n-/// This channel implementation differs significantly from the asynchronous\n-/// implementations found next to it (oneshot/stream/share). This is an\n-/// implementation of a synchronous, bounded buffer channel.\n-///\n-/// Each channel is created with some amount of backing buffer, and sends will\n-/// *block* until buffer space becomes available. A buffer size of 0 is valid,\n-/// which means that every successful send is paired with a successful recv.\n-///\n-/// This flavor of channels defines a new `send_opt` method for channels which\n-/// is the method by which a message is sent but the thread does not panic if it\n-/// cannot be delivered.\n-///\n-/// Another major difference is that send() will *always* return back the data\n-/// if it couldn't be sent. This is because it is deterministically known when\n-/// the data is received and when it is not received.\n-///\n-/// Implementation-wise, it can all be summed up with \"use a mutex plus some\n-/// logic\". The mutex used here is an OS native mutex, meaning that no user code\n-/// is run inside of the mutex (to prevent context switching). This\n-/// implementation shares almost all code for the buffered and unbuffered cases\n-/// of a synchronous channel. There are a few branches for the unbuffered case,\n-/// but they're mostly just relevant to blocking senders.\n-pub use self::Failure::*;\n-\n-use core::intrinsics::abort;\n-use core::mem;\n-use core::ptr;\n-\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n-use crate::sync::mpsc::blocking::{self, SignalToken, WaitToken};\n-use crate::sync::{Mutex, MutexGuard};\n-use crate::time::Instant;\n-\n-const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n-\n-pub struct Packet<T> {\n-    /// Only field outside of the mutex. Just done for kicks, but mainly because\n-    /// the other shared channel already had the code implemented\n-    channels: AtomicUsize,\n-\n-    lock: Mutex<State<T>>,\n-}\n-\n-unsafe impl<T: Send> Send for Packet<T> {}\n-\n-unsafe impl<T: Send> Sync for Packet<T> {}\n-\n-struct State<T> {\n-    disconnected: bool, // Is the channel disconnected yet?\n-    queue: Queue,       // queue of senders waiting to send data\n-    blocker: Blocker,   // currently blocked thread on this channel\n-    buf: Buffer<T>,     // storage for buffered messages\n-    cap: usize,         // capacity of this channel\n-\n-    /// A curious flag used to indicate whether a sender failed or succeeded in\n-    /// blocking. This is used to transmit information back to the thread that it\n-    /// must dequeue its message from the buffer because it was not received.\n-    /// This is only relevant in the 0-buffer case. This obviously cannot be\n-    /// safely constructed, but it's guaranteed to always have a valid pointer\n-    /// value.\n-    canceled: Option<&'static mut bool>,\n-}\n-\n-unsafe impl<T: Send> Send for State<T> {}\n-\n-/// Possible flavors of threads who can be blocked on this channel.\n-enum Blocker {\n-    BlockedSender(SignalToken),\n-    BlockedReceiver(SignalToken),\n-    NoneBlocked,\n-}\n-\n-/// Simple queue for threading threads together. Nodes are stack-allocated, so\n-/// this structure is not safe at all\n-struct Queue {\n-    head: *mut Node,\n-    tail: *mut Node,\n-}\n-\n-struct Node {\n-    token: Option<SignalToken>,\n-    next: *mut Node,\n-}\n-\n-unsafe impl Send for Node {}\n-\n-/// A simple ring-buffer\n-struct Buffer<T> {\n-    buf: Vec<Option<T>>,\n-    start: usize,\n-    size: usize,\n-}\n-\n-#[derive(Debug)]\n-pub enum Failure {\n-    Empty,\n-    Disconnected,\n-}\n-\n-/// Atomically blocks the current thread, placing it into `slot`, unlocking `lock`\n-/// in the meantime. This re-locks the mutex upon returning.\n-fn wait<'a, 'b, T>(\n-    lock: &'a Mutex<State<T>>,\n-    mut guard: MutexGuard<'b, State<T>>,\n-    f: fn(SignalToken) -> Blocker,\n-) -> MutexGuard<'a, State<T>> {\n-    let (wait_token, signal_token) = blocking::tokens();\n-    match mem::replace(&mut guard.blocker, f(signal_token)) {\n-        NoneBlocked => {}\n-        _ => unreachable!(),\n-    }\n-    drop(guard); // unlock\n-    wait_token.wait(); // block\n-    lock.lock().unwrap() // relock\n-}\n-\n-/// Same as wait, but waiting at most until `deadline`.\n-fn wait_timeout_receiver<'a, 'b, T>(\n-    lock: &'a Mutex<State<T>>,\n-    deadline: Instant,\n-    mut guard: MutexGuard<'b, State<T>>,\n-    success: &mut bool,\n-) -> MutexGuard<'a, State<T>> {\n-    let (wait_token, signal_token) = blocking::tokens();\n-    match mem::replace(&mut guard.blocker, BlockedReceiver(signal_token)) {\n-        NoneBlocked => {}\n-        _ => unreachable!(),\n-    }\n-    drop(guard); // unlock\n-    *success = wait_token.wait_max_until(deadline); // block\n-    let mut new_guard = lock.lock().unwrap(); // relock\n-    if !*success {\n-        abort_selection(&mut new_guard);\n-    }\n-    new_guard\n-}\n-\n-fn abort_selection<T>(guard: &mut MutexGuard<'_, State<T>>) -> bool {\n-    match mem::replace(&mut guard.blocker, NoneBlocked) {\n-        NoneBlocked => true,\n-        BlockedSender(token) => {\n-            guard.blocker = BlockedSender(token);\n-            true\n-        }\n-        BlockedReceiver(token) => {\n-            drop(token);\n-            false\n-        }\n-    }\n-}\n-\n-/// Wakes up a thread, dropping the lock at the correct time\n-fn wakeup<T>(token: SignalToken, guard: MutexGuard<'_, State<T>>) {\n-    // We need to be careful to wake up the waiting thread *outside* of the mutex\n-    // in case it incurs a context switch.\n-    drop(guard);\n-    token.signal();\n-}\n-\n-impl<T> Packet<T> {\n-    pub fn new(capacity: usize) -> Packet<T> {\n-        Packet {\n-            channels: AtomicUsize::new(1),\n-            lock: Mutex::new(State {\n-                disconnected: false,\n-                blocker: NoneBlocked,\n-                cap: capacity,\n-                canceled: None,\n-                queue: Queue { head: ptr::null_mut(), tail: ptr::null_mut() },\n-                buf: Buffer {\n-                    buf: (0..capacity + if capacity == 0 { 1 } else { 0 }).map(|_| None).collect(),\n-                    start: 0,\n-                    size: 0,\n-                },\n-            }),\n-        }\n-    }\n-\n-    // wait until a send slot is available, returning locked access to\n-    // the channel state.\n-    fn acquire_send_slot(&self) -> MutexGuard<'_, State<T>> {\n-        let mut node = Node { token: None, next: ptr::null_mut() };\n-        loop {\n-            let mut guard = self.lock.lock().unwrap();\n-            // are we ready to go?\n-            if guard.disconnected || guard.buf.size() < guard.buf.capacity() {\n-                return guard;\n-            }\n-            // no room; actually block\n-            let wait_token = guard.queue.enqueue(&mut node);\n-            drop(guard);\n-            wait_token.wait();\n-        }\n-    }\n-\n-    pub fn send(&self, t: T) -> Result<(), T> {\n-        let mut guard = self.acquire_send_slot();\n-        if guard.disconnected {\n-            return Err(t);\n-        }\n-        guard.buf.enqueue(t);\n-\n-        match mem::replace(&mut guard.blocker, NoneBlocked) {\n-            // if our capacity is 0, then we need to wait for a receiver to be\n-            // available to take our data. After waiting, we check again to make\n-            // sure the port didn't go away in the meantime. If it did, we need\n-            // to hand back our data.\n-            NoneBlocked if guard.cap == 0 => {\n-                let mut canceled = false;\n-                assert!(guard.canceled.is_none());\n-                guard.canceled = Some(unsafe { mem::transmute(&mut canceled) });\n-                let mut guard = wait(&self.lock, guard, BlockedSender);\n-                if canceled { Err(guard.buf.dequeue()) } else { Ok(()) }\n-            }\n-\n-            // success, we buffered some data\n-            NoneBlocked => Ok(()),\n-\n-            // success, someone's about to receive our buffered data.\n-            BlockedReceiver(token) => {\n-                wakeup(token, guard);\n-                Ok(())\n-            }\n-\n-            BlockedSender(..) => panic!(\"lolwut\"),\n-        }\n-    }\n-\n-    pub fn try_send(&self, t: T) -> Result<(), super::TrySendError<T>> {\n-        let mut guard = self.lock.lock().unwrap();\n-        if guard.disconnected {\n-            Err(super::TrySendError::Disconnected(t))\n-        } else if guard.buf.size() == guard.buf.capacity() {\n-            Err(super::TrySendError::Full(t))\n-        } else if guard.cap == 0 {\n-            // With capacity 0, even though we have buffer space we can't\n-            // transfer the data unless there's a receiver waiting.\n-            match mem::replace(&mut guard.blocker, NoneBlocked) {\n-                NoneBlocked => Err(super::TrySendError::Full(t)),\n-                BlockedSender(..) => unreachable!(),\n-                BlockedReceiver(token) => {\n-                    guard.buf.enqueue(t);\n-                    wakeup(token, guard);\n-                    Ok(())\n-                }\n-            }\n-        } else {\n-            // If the buffer has some space and the capacity isn't 0, then we\n-            // just enqueue the data for later retrieval, ensuring to wake up\n-            // any blocked receiver if there is one.\n-            assert!(guard.buf.size() < guard.buf.capacity());\n-            guard.buf.enqueue(t);\n-            match mem::replace(&mut guard.blocker, NoneBlocked) {\n-                BlockedReceiver(token) => wakeup(token, guard),\n-                NoneBlocked => {}\n-                BlockedSender(..) => unreachable!(),\n-            }\n-            Ok(())\n-        }\n-    }\n-\n-    // Receives a message from this channel\n-    //\n-    // When reading this, remember that there can only ever be one receiver at\n-    // time.\n-    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure> {\n-        let mut guard = self.lock.lock().unwrap();\n-\n-        let mut woke_up_after_waiting = false;\n-        // Wait for the buffer to have something in it. No need for a\n-        // while loop because we're the only receiver.\n-        if !guard.disconnected && guard.buf.size() == 0 {\n-            if let Some(deadline) = deadline {\n-                guard =\n-                    wait_timeout_receiver(&self.lock, deadline, guard, &mut woke_up_after_waiting);\n-            } else {\n-                guard = wait(&self.lock, guard, BlockedReceiver);\n-                woke_up_after_waiting = true;\n-            }\n-        }\n-\n-        // N.B., channel could be disconnected while waiting, so the order of\n-        // these conditionals is important.\n-        if guard.disconnected && guard.buf.size() == 0 {\n-            return Err(Disconnected);\n-        }\n-\n-        // Pick up the data, wake up our neighbors, and carry on\n-        assert!(guard.buf.size() > 0 || (deadline.is_some() && !woke_up_after_waiting));\n-\n-        if guard.buf.size() == 0 {\n-            return Err(Empty);\n-        }\n-\n-        let ret = guard.buf.dequeue();\n-        self.wakeup_senders(woke_up_after_waiting, guard);\n-        Ok(ret)\n-    }\n-\n-    pub fn try_recv(&self) -> Result<T, Failure> {\n-        let mut guard = self.lock.lock().unwrap();\n-\n-        // Easy cases first\n-        if guard.disconnected && guard.buf.size() == 0 {\n-            return Err(Disconnected);\n-        }\n-        if guard.buf.size() == 0 {\n-            return Err(Empty);\n-        }\n-\n-        // Be sure to wake up neighbors\n-        let ret = Ok(guard.buf.dequeue());\n-        self.wakeup_senders(false, guard);\n-        ret\n-    }\n-\n-    // Wake up pending senders after some data has been received\n-    //\n-    // * `waited` - flag if the receiver blocked to receive some data, or if it\n-    //              just picked up some data on the way out\n-    // * `guard` - the lock guard that is held over this channel's lock\n-    fn wakeup_senders(&self, waited: bool, mut guard: MutexGuard<'_, State<T>>) {\n-        let pending_sender1: Option<SignalToken> = guard.queue.dequeue();\n-\n-        // If this is a no-buffer channel (cap == 0), then if we didn't wait we\n-        // need to ACK the sender. If we waited, then the sender waking us up\n-        // was already the ACK.\n-        let pending_sender2 = if guard.cap == 0 && !waited {\n-            match mem::replace(&mut guard.blocker, NoneBlocked) {\n-                NoneBlocked => None,\n-                BlockedReceiver(..) => unreachable!(),\n-                BlockedSender(token) => {\n-                    guard.canceled.take();\n-                    Some(token)\n-                }\n-            }\n-        } else {\n-            None\n-        };\n-        mem::drop(guard);\n-\n-        // only outside of the lock do we wake up the pending threads\n-        if let Some(token) = pending_sender1 {\n-            token.signal();\n-        }\n-        if let Some(token) = pending_sender2 {\n-            token.signal();\n-        }\n-    }\n-\n-    // Prepares this shared packet for a channel clone, essentially just bumping\n-    // a refcount.\n-    pub fn clone_chan(&self) {\n-        let old_count = self.channels.fetch_add(1, Ordering::SeqCst);\n-\n-        // See comments on Arc::clone() on why we do this (for `mem::forget`).\n-        if old_count > MAX_REFCOUNT {\n-            abort();\n-        }\n-    }\n-\n-    pub fn drop_chan(&self) {\n-        // Only flag the channel as disconnected if we're the last channel\n-        match self.channels.fetch_sub(1, Ordering::SeqCst) {\n-            1 => {}\n-            _ => return,\n-        }\n-\n-        // Not much to do other than wake up a receiver if one's there\n-        let mut guard = self.lock.lock().unwrap();\n-        if guard.disconnected {\n-            return;\n-        }\n-        guard.disconnected = true;\n-        match mem::replace(&mut guard.blocker, NoneBlocked) {\n-            NoneBlocked => {}\n-            BlockedSender(..) => unreachable!(),\n-            BlockedReceiver(token) => wakeup(token, guard),\n-        }\n-    }\n-\n-    pub fn drop_port(&self) {\n-        let mut guard = self.lock.lock().unwrap();\n-\n-        if guard.disconnected {\n-            return;\n-        }\n-        guard.disconnected = true;\n-\n-        // If the capacity is 0, then the sender may want its data back after\n-        // we're disconnected. Otherwise it's now our responsibility to destroy\n-        // the buffered data. As with many other portions of this code, this\n-        // needs to be careful to destroy the data *outside* of the lock to\n-        // prevent deadlock.\n-        let _data = if guard.cap != 0 { mem::take(&mut guard.buf.buf) } else { Vec::new() };\n-        let mut queue =\n-            mem::replace(&mut guard.queue, Queue { head: ptr::null_mut(), tail: ptr::null_mut() });\n-\n-        let waiter = match mem::replace(&mut guard.blocker, NoneBlocked) {\n-            NoneBlocked => None,\n-            BlockedSender(token) => {\n-                *guard.canceled.take().unwrap() = true;\n-                Some(token)\n-            }\n-            BlockedReceiver(..) => unreachable!(),\n-        };\n-        mem::drop(guard);\n-\n-        while let Some(token) = queue.dequeue() {\n-            token.signal();\n-        }\n-        if let Some(token) = waiter {\n-            token.signal();\n-        }\n-    }\n-}\n-\n-impl<T> Drop for Packet<T> {\n-    fn drop(&mut self) {\n-        assert_eq!(self.channels.load(Ordering::SeqCst), 0);\n-        let mut guard = self.lock.lock().unwrap();\n-        assert!(guard.queue.dequeue().is_none());\n-        assert!(guard.canceled.is_none());\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Buffer, a simple ring buffer backed by Vec<T>\n-////////////////////////////////////////////////////////////////////////////////\n-\n-impl<T> Buffer<T> {\n-    fn enqueue(&mut self, t: T) {\n-        let pos = (self.start + self.size) % self.buf.len();\n-        self.size += 1;\n-        let prev = mem::replace(&mut self.buf[pos], Some(t));\n-        assert!(prev.is_none());\n-    }\n-\n-    fn dequeue(&mut self) -> T {\n-        let start = self.start;\n-        self.size -= 1;\n-        self.start = (self.start + 1) % self.buf.len();\n-        let result = &mut self.buf[start];\n-        result.take().unwrap()\n-    }\n-\n-    fn size(&self) -> usize {\n-        self.size\n-    }\n-    fn capacity(&self) -> usize {\n-        self.buf.len()\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Queue, a simple queue to enqueue threads with (stack-allocated nodes)\n-////////////////////////////////////////////////////////////////////////////////\n-\n-impl Queue {\n-    fn enqueue(&mut self, node: &mut Node) -> WaitToken {\n-        let (wait_token, signal_token) = blocking::tokens();\n-        node.token = Some(signal_token);\n-        node.next = ptr::null_mut();\n-\n-        if self.tail.is_null() {\n-            self.head = node as *mut Node;\n-            self.tail = node as *mut Node;\n-        } else {\n-            unsafe {\n-                (*self.tail).next = node as *mut Node;\n-                self.tail = node as *mut Node;\n-            }\n-        }\n-\n-        wait_token\n-    }\n-\n-    fn dequeue(&mut self) -> Option<SignalToken> {\n-        if self.head.is_null() {\n-            return None;\n-        }\n-        let node = self.head;\n-        self.head = unsafe { (*node).next };\n-        if self.head.is_null() {\n-            self.tail = ptr::null_mut();\n-        }\n-        unsafe {\n-            (*node).next = ptr::null_mut();\n-            Some((*node).token.take().unwrap())\n-        }\n-    }\n-}"}, {"sha": "82c52eb4fef45b6e2cc48bc4e893e2f08d50ee8d", "filename": "library/std/src/sync/mpsc/tests.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Ftests.rs?ref=afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "patch": "@@ -706,3 +706,17 @@ fn issue_32114() {\n     let _ = tx.send(123);\n     assert_eq!(tx.send(123), Err(SendError(123)));\n }\n+\n+#[test]\n+fn issue_39364() {\n+    let (tx, rx) = channel::<()>();\n+    let t = thread::spawn(move || {\n+        thread::sleep(Duration::from_millis(300));\n+        let _ = tx.clone();\n+        crate::mem::forget(tx);\n+    });\n+\n+    let _ = rx.recv_timeout(Duration::from_millis(500));\n+    t.join().unwrap();\n+    let _ = rx.recv_timeout(Duration::from_millis(500));\n+}"}, {"sha": "80dc4c038d615388bab3e00b9217af129ca58c5b", "filename": "library/std/src/thread/local/tests.rs", "status": "modified", "additions": 44, "deletions": 22, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fthread%2Flocal%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd7977c850d9ce06f1dd2bebb40db8cc2224a51/library%2Fstd%2Fsrc%2Fthread%2Flocal%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal%2Ftests.rs?ref=afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "patch": "@@ -1,15 +1,34 @@\n use crate::cell::{Cell, UnsafeCell};\n use crate::sync::atomic::{AtomicU8, Ordering};\n-use crate::sync::mpsc::{channel, Sender};\n+use crate::sync::{Arc, Condvar, Mutex};\n use crate::thread::{self, LocalKey};\n use crate::thread_local;\n \n-struct Foo(Sender<()>);\n+#[derive(Clone, Default)]\n+struct Signal(Arc<(Mutex<bool>, Condvar)>);\n+\n+impl Signal {\n+    fn notify(&self) {\n+        let (set, cvar) = &*self.0;\n+        *set.lock().unwrap() = true;\n+        cvar.notify_one();\n+    }\n+\n+    fn wait(&self) {\n+        let (set, cvar) = &*self.0;\n+        let mut set = set.lock().unwrap();\n+        while !*set {\n+            set = cvar.wait(set).unwrap();\n+        }\n+    }\n+}\n+\n+struct Foo(Signal);\n \n impl Drop for Foo {\n     fn drop(&mut self) {\n-        let Foo(ref s) = *self;\n-        s.send(()).unwrap();\n+        let Foo(ref f) = *self;\n+        f.notify();\n     }\n }\n \n@@ -69,14 +88,15 @@ fn smoke_dtor() {\n     run(&FOO2);\n \n     fn run(key: &'static LocalKey<UnsafeCell<Option<Foo>>>) {\n-        let (tx, rx) = channel();\n+        let signal = Signal::default();\n+        let signal2 = signal.clone();\n         let t = thread::spawn(move || unsafe {\n-            let mut tx = Some(tx);\n+            let mut signal = Some(signal2);\n             key.with(|f| {\n-                *f.get() = Some(Foo(tx.take().unwrap()));\n+                *f.get() = Some(Foo(signal.take().unwrap()));\n             });\n         });\n-        rx.recv().unwrap();\n+        signal.wait();\n         t.join().unwrap();\n     }\n }\n@@ -165,48 +185,50 @@ fn self_referential() {\n // requires the destructor to be run to pass the test).\n #[test]\n fn dtors_in_dtors_in_dtors() {\n-    struct S1(Sender<()>);\n+    struct S1(Signal);\n     thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n     thread_local!(static K2: UnsafeCell<Option<Foo>> = UnsafeCell::new(None));\n \n     impl Drop for S1 {\n         fn drop(&mut self) {\n-            let S1(ref tx) = *self;\n+            let S1(ref signal) = *self;\n             unsafe {\n-                let _ = K2.try_with(|s| *s.get() = Some(Foo(tx.clone())));\n+                let _ = K2.try_with(|s| *s.get() = Some(Foo(signal.clone())));\n             }\n         }\n     }\n \n-    let (tx, rx) = channel();\n+    let signal = Signal::default();\n+    let signal2 = signal.clone();\n     let _t = thread::spawn(move || unsafe {\n-        let mut tx = Some(tx);\n-        K1.with(|s| *s.get() = Some(S1(tx.take().unwrap())));\n+        let mut signal = Some(signal2);\n+        K1.with(|s| *s.get() = Some(S1(signal.take().unwrap())));\n     });\n-    rx.recv().unwrap();\n+    signal.wait();\n }\n \n #[test]\n fn dtors_in_dtors_in_dtors_const_init() {\n-    struct S1(Sender<()>);\n+    struct S1(Signal);\n     thread_local!(static K1: UnsafeCell<Option<S1>> = const { UnsafeCell::new(None) });\n     thread_local!(static K2: UnsafeCell<Option<Foo>> = const { UnsafeCell::new(None) });\n \n     impl Drop for S1 {\n         fn drop(&mut self) {\n-            let S1(ref tx) = *self;\n+            let S1(ref signal) = *self;\n             unsafe {\n-                let _ = K2.try_with(|s| *s.get() = Some(Foo(tx.clone())));\n+                let _ = K2.try_with(|s| *s.get() = Some(Foo(signal.clone())));\n             }\n         }\n     }\n \n-    let (tx, rx) = channel();\n+    let signal = Signal::default();\n+    let signal2 = signal.clone();\n     let _t = thread::spawn(move || unsafe {\n-        let mut tx = Some(tx);\n-        K1.with(|s| *s.get() = Some(S1(tx.take().unwrap())));\n+        let mut signal = Some(signal2);\n+        K1.with(|s| *s.get() = Some(S1(signal.take().unwrap())));\n     });\n-    rx.recv().unwrap();\n+    signal.wait();\n }\n \n // This test tests that TLS destructors have run before the thread joins. The"}]}