{"sha": "bb467b857eabb0c930316ff066b30c395d7fa63b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiNDY3Yjg1N2VhYmIwYzkzMDMxNmZmMDY2YjMwYzM5NWQ3ZmE2M2I=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-25T12:59:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-25T12:59:12Z"}, "message": "Merge #1910\n\n1910: Assists r=matklad a=matklad\n\nbors r+\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "a836a030fb899cfcff96e08fa37420560a160133", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a836a030fb899cfcff96e08fa37420560a160133"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb467b857eabb0c930316ff066b30c395d7fa63b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdi2SgCRBK7hj4Ov3rIwAAdHIIAJR5Q1NtGOxvoRF2gyPOMMb+\nsDDZzBtxgPFurHl2zEXl09iZGkdS/mjlbY9WxmtFjf7s4Bn12UqEw3L3LZ9jSCoq\nIiPnxNYc3YHIYaRHa9ziNAoDDO/HtHN7n3Msadl/4qqC4G56YCDpdOBF7ByDqfOT\nVyFnulgld4Iu/Pgr/ohEZq+ZubMRmG3BC1uP4YtQn0pXKi37vtOyaZyK6oEPSN9u\nmQKdUkZzP1q88IXjArv5SwAjgjq2PT9C+iP7QXkoZnJuw2e1fjlOgRu+MhBgVppI\ni8JLDhE5KzOutM4v9pWlvyPT28xsUvU9pTPJocUGb7WDV77a4VYjPAuaWW40db0=\n=5ats\n-----END PGP SIGNATURE-----\n", "payload": "tree a836a030fb899cfcff96e08fa37420560a160133\nparent 8f92309dbc00a0f88563030921706f205c01f452\nparent efeae82f5221d2fdeeeed0bc67a2234647e160dd\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1569416352 +0000\ncommitter GitHub <noreply@github.com> 1569416352 +0000\n\nMerge #1910\n\n1910: Assists r=matklad a=matklad\n\nbors r+\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb467b857eabb0c930316ff066b30c395d7fa63b", "html_url": "https://github.com/rust-lang/rust/commit/bb467b857eabb0c930316ff066b30c395d7fa63b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb467b857eabb0c930316ff066b30c395d7fa63b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f92309dbc00a0f88563030921706f205c01f452", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f92309dbc00a0f88563030921706f205c01f452", "html_url": "https://github.com/rust-lang/rust/commit/8f92309dbc00a0f88563030921706f205c01f452"}, {"sha": "efeae82f5221d2fdeeeed0bc67a2234647e160dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/efeae82f5221d2fdeeeed0bc67a2234647e160dd", "html_url": "https://github.com/rust-lang/rust/commit/efeae82f5221d2fdeeeed0bc67a2234647e160dd"}], "stats": {"total": 181, "additions": 84, "deletions": 97}, "files": [{"sha": "22d20909d2fca33b451a3778a48090ee072055b5", "filename": "crates/ra_assists/src/assists/add_missing_impl_members.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb467b857eabb0c930316ff066b30c395d7fa63b/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb467b857eabb0c930316ff066b30c395d7fa63b/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs?ref=bb467b857eabb0c930316ff066b30c395d7fa63b", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n     SmolStr,\n };\n \n-use crate::{ast_builder::AstBuilder, ast_editor::AstEditor, Assist, AssistCtx, AssistId};\n+use crate::{ast_builder::Make, ast_editor::AstEditor, Assist, AssistCtx, AssistId};\n \n #[derive(PartialEq)]\n enum AddMissingImplMembersMode {\n@@ -102,9 +102,7 @@ fn strip_docstring(item: ast::ImplItem) -> ast::ImplItem {\n fn add_body(fn_def: ast::FnDef) -> ast::FnDef {\n     let mut ast_editor = AstEditor::new(fn_def.clone());\n     if fn_def.body().is_none() {\n-        ast_editor.set_body(&AstBuilder::<ast::Block>::single_expr(\n-            &AstBuilder::<ast::Expr>::unimplemented(),\n-        ));\n+        ast_editor.set_body(&Make::<ast::Block>::single_expr(Make::<ast::Expr>::unimplemented()));\n     }\n     ast_editor.ast().to_owned()\n }"}, {"sha": "81743352613fc7c5745e34b58b12dc63d2cf02f6", "filename": "crates/ra_assists/src/assists/fill_match_arms.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bb467b857eabb0c930316ff066b30c395d7fa63b/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb467b857eabb0c930316ff066b30c395d7fa63b/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs?ref=bb467b857eabb0c930316ff066b30c395d7fa63b", "patch": "@@ -3,7 +3,7 @@ use std::iter;\n use hir::{db::HirDatabase, Adt, HasSource};\n use ra_syntax::ast::{self, AstNode, NameOwner};\n \n-use crate::{ast_builder::AstBuilder, Assist, AssistCtx, AssistId};\n+use crate::{ast_builder::Make, Assist, AssistCtx, AssistId};\n \n pub(crate) fn fill_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let match_expr = ctx.node_at_offset::<ast::MatchExpr>()?;\n@@ -29,13 +29,10 @@ pub(crate) fn fill_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<As\n \n     ctx.add_action(AssistId(\"fill_match_arms\"), \"fill match arms\", |edit| {\n         let variants = variant_list.variants();\n-        let arms = variants.filter_map(build_pat).map(|pat| {\n-            AstBuilder::<ast::MatchArm>::from_pieces(\n-                iter::once(pat),\n-                &AstBuilder::<ast::Expr>::unit(),\n-            )\n-        });\n-        let new_arm_list = AstBuilder::<ast::MatchArmList>::from_arms(arms);\n+        let arms = variants\n+            .filter_map(build_pat)\n+            .map(|pat| Make::<ast::MatchArm>::from(iter::once(pat), Make::<ast::Expr>::unit()));\n+        let new_arm_list = Make::<ast::MatchArmList>::from_arms(arms);\n \n         edit.target(match_expr.syntax().text_range());\n         edit.set_cursor(expr.syntax().text_range().start());\n@@ -66,21 +63,21 @@ fn resolve_enum_def(\n }\n \n fn build_pat(var: ast::EnumVariant) -> Option<ast::Pat> {\n-    let path = &AstBuilder::<ast::Path>::from_pieces(var.parent_enum().name()?, var.name()?);\n+    let path = Make::<ast::Path>::from(var.parent_enum().name()?, var.name()?);\n \n     let pat: ast::Pat = match var.kind() {\n         ast::StructKind::Tuple(field_list) => {\n-            let pats = iter::repeat(AstBuilder::<ast::PlaceholderPat>::placeholder().into())\n+            let pats = iter::repeat(Make::<ast::PlaceholderPat>::placeholder().into())\n                 .take(field_list.fields().count());\n-            AstBuilder::<ast::TupleStructPat>::from_pieces(path, pats).into()\n+            Make::<ast::TupleStructPat>::from(path, pats).into()\n         }\n         ast::StructKind::Named(field_list) => {\n             let pats = field_list\n                 .fields()\n-                .map(|f| AstBuilder::<ast::BindPat>::from_name(&f.name().unwrap()).into());\n-            AstBuilder::<ast::RecordPat>::from_pieces(path, pats).into()\n+                .map(|f| Make::<ast::BindPat>::from_name(f.name().unwrap()).into());\n+            Make::<ast::RecordPat>::from(path, pats).into()\n         }\n-        ast::StructKind::Unit => AstBuilder::<ast::PathPat>::from_path(path).into(),\n+        ast::StructKind::Unit => Make::<ast::PathPat>::from_path(path).into(),\n     };\n \n     Some(pat)"}, {"sha": "6fd2fb72bb8fd2a53df158e77c8dd1d99413ac50", "filename": "crates/ra_assists/src/assists/move_bounds.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bb467b857eabb0c930316ff066b30c395d7fa63b/crates%2Fra_assists%2Fsrc%2Fassists%2Fmove_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb467b857eabb0c930316ff066b30c395d7fa63b/crates%2Fra_assists%2Fsrc%2Fassists%2Fmove_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fmove_bounds.rs?ref=bb467b857eabb0c930316ff066b30c395d7fa63b", "patch": "@@ -6,7 +6,7 @@ use ra_syntax::{\n     TextRange,\n };\n \n-use crate::{ast_builder::AstBuilder, Assist, AssistCtx, AssistId};\n+use crate::{ast_builder::Make, Assist, AssistCtx, AssistId};\n \n pub(crate) fn move_bounds_to_where_clause(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let type_param_list = ctx.node_at_offset::<ast::TypeParamList>()?;\n@@ -52,7 +52,7 @@ pub(crate) fn move_bounds_to_where_clause(mut ctx: AssistCtx<impl HirDatabase>)\n             }\n \n             let predicates = type_params.iter().filter_map(build_predicate);\n-            let where_clause = AstBuilder::<ast::WhereClause>::from_predicates(predicates);\n+            let where_clause = Make::<ast::WhereClause>::from_predicates(predicates);\n \n             let to_insert = match anchor.prev_sibling_or_token() {\n                 Some(ref elem) if elem.kind() == WHITESPACE => {\n@@ -69,9 +69,8 @@ pub(crate) fn move_bounds_to_where_clause(mut ctx: AssistCtx<impl HirDatabase>)\n }\n \n fn build_predicate(param: &ast::TypeParam) -> Option<ast::WherePred> {\n-    let path = AstBuilder::<ast::Path>::from_name(param.name()?);\n-    let predicate =\n-        AstBuilder::<ast::WherePred>::from_pieces(path, param.type_bound_list()?.bounds());\n+    let path = Make::<ast::Path>::from_name(param.name()?);\n+    let predicate = Make::<ast::WherePred>::from(path, param.type_bound_list()?.bounds());\n     Some(predicate)\n }\n "}, {"sha": "9a62b96b3cc4191f03e8387f3fa744990aab0da3", "filename": "crates/ra_assists/src/ast_builder.rs", "status": "modified", "additions": 60, "deletions": 71, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/bb467b857eabb0c930316ff066b30c395d7fa63b/crates%2Fra_assists%2Fsrc%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb467b857eabb0c930316ff066b30c395d7fa63b/crates%2Fra_assists%2Fsrc%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_builder.rs?ref=bb467b857eabb0c930316ff066b30c395d7fa63b", "patch": "@@ -1,175 +1,164 @@\n use itertools::Itertools;\n \n-use hir::Name;\n use ra_syntax::{ast, AstNode, SourceFile};\n \n-pub struct AstBuilder<N: AstNode> {\n+pub struct Make<N: AstNode> {\n     _phantom: std::marker::PhantomData<N>,\n }\n \n-impl AstBuilder<ast::RecordField> {\n-    pub fn from_name(name: &Name) -> ast::RecordField {\n-        ast_node_from_file_text(&format!(\"fn f() {{ S {{ {}: (), }} }}\", name))\n-    }\n-\n-    fn from_text(text: &str) -> ast::RecordField {\n-        ast_node_from_file_text(&format!(\"fn f() {{ S {{ {}, }} }}\", text))\n-    }\n-\n-    pub fn from_pieces(name: &ast::NameRef, expr: Option<&ast::Expr>) -> ast::RecordField {\n+impl Make<ast::RecordField> {\n+    pub fn from(name: ast::NameRef, expr: Option<ast::Expr>) -> ast::RecordField {\n         match expr {\n             Some(expr) => Self::from_text(&format!(\"{}: {}\", name.syntax(), expr.syntax())),\n             None => Self::from_text(&name.syntax().to_string()),\n         }\n     }\n-}\n \n-impl AstBuilder<ast::Block> {\n-    fn from_text(text: &str) -> ast::Block {\n-        ast_node_from_file_text(&format!(\"fn f() {}\", text))\n+    fn from_text(text: &str) -> ast::RecordField {\n+        ast_node_from_file_text(&format!(\"fn f() {{ S {{ {}, }} }}\", text))\n     }\n+}\n \n-    pub fn single_expr(e: &ast::Expr) -> ast::Block {\n+impl Make<ast::Block> {\n+    pub fn single_expr(e: ast::Expr) -> ast::Block {\n         Self::from_text(&format!(\"{{ {} }}\", e.syntax()))\n     }\n-}\n \n-impl AstBuilder<ast::Expr> {\n-    fn from_text(text: &str) -> ast::Expr {\n-        ast_node_from_file_text(&format!(\"const C: () = {};\", text))\n+    fn from_text(text: &str) -> ast::Block {\n+        ast_node_from_file_text(&format!(\"fn f() {}\", text))\n     }\n+}\n \n+impl Make<ast::Expr> {\n     pub fn unit() -> ast::Expr {\n         Self::from_text(\"()\")\n     }\n \n     pub fn unimplemented() -> ast::Expr {\n         Self::from_text(\"unimplemented!()\")\n     }\n-}\n \n-impl AstBuilder<ast::NameRef> {\n-    pub fn new(text: &str) -> ast::NameRef {\n-        ast_node_from_file_text(&format!(\"fn f() {{ {}; }}\", text))\n+    fn from_text(text: &str) -> ast::Expr {\n+        ast_node_from_file_text(&format!(\"const C: () = {};\", text))\n     }\n }\n \n-impl AstBuilder<ast::Path> {\n-    fn from_text(text: &str) -> ast::Path {\n-        ast_node_from_file_text(text)\n+impl Make<ast::NameRef> {\n+    pub fn from(text: &str) -> ast::NameRef {\n+        ast_node_from_file_text(&format!(\"fn f() {{ {}; }}\", text))\n     }\n+}\n \n+impl Make<ast::Path> {\n     pub fn from_name(name: ast::Name) -> ast::Path {\n         let name = name.syntax().to_string();\n         Self::from_text(name.as_str())\n     }\n \n-    pub fn from_pieces(enum_name: ast::Name, var_name: ast::Name) -> ast::Path {\n+    pub fn from(enum_name: ast::Name, var_name: ast::Name) -> ast::Path {\n         Self::from_text(&format!(\"{}::{}\", enum_name.syntax(), var_name.syntax()))\n     }\n-}\n \n-impl AstBuilder<ast::BindPat> {\n-    fn from_text(text: &str) -> ast::BindPat {\n-        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n+    fn from_text(text: &str) -> ast::Path {\n+        ast_node_from_file_text(text)\n     }\n+}\n \n-    pub fn from_name(name: &ast::Name) -> ast::BindPat {\n+impl Make<ast::BindPat> {\n+    pub fn from_name(name: ast::Name) -> ast::BindPat {\n         Self::from_text(name.text())\n     }\n-}\n \n-impl AstBuilder<ast::PlaceholderPat> {\n-    fn from_text(text: &str) -> ast::PlaceholderPat {\n+    fn from_text(text: &str) -> ast::BindPat {\n         ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n     }\n+}\n \n+impl Make<ast::PlaceholderPat> {\n     pub fn placeholder() -> ast::PlaceholderPat {\n         Self::from_text(\"_\")\n     }\n-}\n \n-impl AstBuilder<ast::TupleStructPat> {\n-    fn from_text(text: &str) -> ast::TupleStructPat {\n+    fn from_text(text: &str) -> ast::PlaceholderPat {\n         ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n     }\n+}\n \n-    pub fn from_pieces(\n-        path: &ast::Path,\n-        pats: impl Iterator<Item = ast::Pat>,\n-    ) -> ast::TupleStructPat {\n+impl Make<ast::TupleStructPat> {\n+    pub fn from(path: ast::Path, pats: impl Iterator<Item = ast::Pat>) -> ast::TupleStructPat {\n         let pats_str = pats.map(|p| p.syntax().to_string()).collect::<Vec<_>>().join(\", \");\n         Self::from_text(&format!(\"{}({})\", path.syntax(), pats_str))\n     }\n-}\n \n-impl AstBuilder<ast::RecordPat> {\n-    fn from_text(text: &str) -> ast::RecordPat {\n+    fn from_text(text: &str) -> ast::TupleStructPat {\n         ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n     }\n+}\n \n-    pub fn from_pieces(path: &ast::Path, pats: impl Iterator<Item = ast::Pat>) -> ast::RecordPat {\n+impl Make<ast::RecordPat> {\n+    pub fn from(path: ast::Path, pats: impl Iterator<Item = ast::Pat>) -> ast::RecordPat {\n         let pats_str = pats.map(|p| p.syntax().to_string()).collect::<Vec<_>>().join(\", \");\n         Self::from_text(&format!(\"{}{{ {} }}\", path.syntax(), pats_str))\n     }\n-}\n \n-impl AstBuilder<ast::PathPat> {\n-    fn from_text(text: &str) -> ast::PathPat {\n+    fn from_text(text: &str) -> ast::RecordPat {\n         ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n     }\n+}\n \n-    pub fn from_path(path: &ast::Path) -> ast::PathPat {\n+impl Make<ast::PathPat> {\n+    pub fn from_path(path: ast::Path) -> ast::PathPat {\n         let path_str = path.syntax().text().to_string();\n         Self::from_text(path_str.as_str())\n     }\n-}\n \n-impl AstBuilder<ast::MatchArm> {\n-    fn from_text(text: &str) -> ast::MatchArm {\n-        ast_node_from_file_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n+    fn from_text(text: &str) -> ast::PathPat {\n+        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n     }\n+}\n \n-    pub fn from_pieces(pats: impl Iterator<Item = ast::Pat>, expr: &ast::Expr) -> ast::MatchArm {\n+impl Make<ast::MatchArm> {\n+    pub fn from(pats: impl Iterator<Item = ast::Pat>, expr: ast::Expr) -> ast::MatchArm {\n         let pats_str = pats.map(|p| p.syntax().to_string()).join(\" | \");\n         Self::from_text(&format!(\"{} => {}\", pats_str, expr.syntax()))\n     }\n-}\n \n-impl AstBuilder<ast::MatchArmList> {\n-    fn from_text(text: &str) -> ast::MatchArmList {\n+    fn from_text(text: &str) -> ast::MatchArm {\n         ast_node_from_file_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n     }\n+}\n \n+impl Make<ast::MatchArmList> {\n     pub fn from_arms(arms: impl Iterator<Item = ast::MatchArm>) -> ast::MatchArmList {\n         let arms_str = arms.map(|arm| format!(\"\\n    {}\", arm.syntax())).join(\",\");\n         Self::from_text(&format!(\"{},\\n\", arms_str))\n     }\n-}\n \n-impl AstBuilder<ast::WherePred> {\n-    fn from_text(text: &str) -> ast::WherePred {\n-        ast_node_from_file_text(&format!(\"fn f() where {} {{ }}\", text))\n+    fn from_text(text: &str) -> ast::MatchArmList {\n+        ast_node_from_file_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n     }\n+}\n \n-    pub fn from_pieces(\n-        path: ast::Path,\n-        bounds: impl Iterator<Item = ast::TypeBound>,\n-    ) -> ast::WherePred {\n+impl Make<ast::WherePred> {\n+    pub fn from(path: ast::Path, bounds: impl Iterator<Item = ast::TypeBound>) -> ast::WherePred {\n         let bounds = bounds.map(|b| b.syntax().to_string()).collect::<Vec<_>>().join(\" + \");\n         Self::from_text(&format!(\"{}: {}\", path.syntax(), bounds))\n     }\n-}\n \n-impl AstBuilder<ast::WhereClause> {\n-    fn from_text(text: &str) -> ast::WhereClause {\n+    fn from_text(text: &str) -> ast::WherePred {\n         ast_node_from_file_text(&format!(\"fn f() where {} {{ }}\", text))\n     }\n+}\n \n+impl Make<ast::WhereClause> {\n     pub fn from_predicates(preds: impl Iterator<Item = ast::WherePred>) -> ast::WhereClause {\n         let preds = preds.map(|p| p.syntax().to_string()).collect::<Vec<_>>().join(\", \");\n         Self::from_text(preds.as_str())\n     }\n+\n+    fn from_text(text: &str) -> ast::WhereClause {\n+        ast_node_from_file_text(&format!(\"fn f() where {} {{ }}\", text))\n+    }\n }\n \n fn ast_node_from_file_text<N: AstNode>(text: &str) -> N {"}, {"sha": "f07061e99c57caed9cfc20a746e92c8fc112e8c7", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bb467b857eabb0c930316ff066b30c395d7fa63b/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb467b857eabb0c930316ff066b30c395d7fa63b/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=bb467b857eabb0c930316ff066b30c395d7fa63b", "patch": "@@ -2,11 +2,11 @@ use std::cell::RefCell;\n \n use hir::diagnostics::{AstDiagnostic, Diagnostic as _, DiagnosticSink};\n use itertools::Itertools;\n-use ra_assists::{ast_builder::AstBuilder, ast_editor::AstEditor};\n+use ra_assists::{ast_builder::Make, ast_editor::AstEditor};\n use ra_db::SourceDatabase;\n use ra_prof::profile;\n use ra_syntax::{\n-    ast::{self, AstNode, RecordField},\n+    ast::{self, AstNode},\n     Location, SyntaxNode, TextRange, T,\n };\n use ra_text_edit::{TextEdit, TextEditBuilder};\n@@ -59,7 +59,11 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n         let node = d.ast(db);\n         let mut ast_editor = AstEditor::new(node);\n         for f in d.missed_fields.iter() {\n-            ast_editor.append_field(&AstBuilder::<RecordField>::from_name(f));\n+            let field = Make::<ast::RecordField>::from(\n+                Make::<ast::NameRef>::from(&f.to_string()),\n+                Some(Make::<ast::Expr>::unit()),\n+            );\n+            ast_editor.append_field(&field);\n         }\n \n         let mut builder = TextEditBuilder::default();"}]}