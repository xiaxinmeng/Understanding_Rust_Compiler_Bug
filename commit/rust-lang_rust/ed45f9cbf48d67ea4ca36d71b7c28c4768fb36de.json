{"sha": "ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNDVmOWNiZjQ4ZDY3ZWE0Y2EzNmQ3MWI3YzI4YzQ3NjhmYjM2ZGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-15T02:56:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-15T02:56:13Z"}, "message": "Auto merge of #54151 - ljedrz:cleanup_hir, r=michaelwoerister\n\nA few cleanups for hir\n\n- prefer `if let` to `match` when only 1 branch matters\n- `chain` iterable items that are looped over in sequence\n- `sort_by_key` instead of `sort_by` when possible\n- change cloning `map`s to `cloned()`\n- use `unwrap_or_else` and `ok` when applicable\n- a few other minor readability improvements\n- whitespace fixes", "tree": {"sha": "c3bacbc615bf711f7dd822e074303167d79c788c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3bacbc615bf711f7dd822e074303167d79c788c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de", "html_url": "https://github.com/rust-lang/rust/commit/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f789b6bd6dc01a4412819c0733a6c99e092446fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/f789b6bd6dc01a4412819c0733a6c99e092446fe", "html_url": "https://github.com/rust-lang/rust/commit/f789b6bd6dc01a4412819c0733a6c99e092446fe"}, {"sha": "2919ecdb5c0b74f64b2a4b71ef39cb44df6c9606", "url": "https://api.github.com/repos/rust-lang/rust/commits/2919ecdb5c0b74f64b2a4b71ef39cb44df6c9606", "html_url": "https://github.com/rust-lang/rust/commit/2919ecdb5c0b74f64b2a4b71ef39cb44df6c9606"}], "stats": {"total": 248, "additions": 93, "deletions": 155}, "files": [{"sha": "298ef67923a9c329e8c262657a676f30656d6c6e", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de", "patch": "@@ -125,7 +125,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n             .iter()\n             .filter(|attr| attr.name() == \"repr\")\n             .filter_map(|attr| attr.meta_item_list())\n-            .flat_map(|hints| hints)\n+            .flatten()\n             .collect();\n \n         let mut int_reprs = 0;\n@@ -185,7 +185,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n                         continue\n                     }\n                 }\n-                \"i8\" | \"u8\" | \"i16\" | \"u16\" |\n+                \"i8\"  | \"u8\"  | \"i16\" | \"u16\" |\n                 \"i32\" | \"u32\" | \"i64\" | \"u64\" |\n                 \"isize\" | \"usize\" => {\n                     int_reprs += 1;"}, {"sha": "76c2ebc0e4a0e36ab5265924e527fdee83bbb329", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de", "patch": "@@ -50,7 +50,6 @@ use super::itemlikevisit::DeepVisitor;\n \n use std::cmp;\n use std::u32;\n-use std::result::Result::Err;\n \n #[derive(Copy, Clone)]\n pub enum FnKind<'a> {\n@@ -1067,31 +1066,26 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprKind::Break(ref destination, ref opt_expr) => {\n             if let Some(ref label) = destination.label {\n                 visitor.visit_label(label);\n-                match destination.target_id {\n-                    Ok(node_id) => visitor.visit_def_mention(Def::Label(node_id)),\n-                    Err(_) => {},\n-                };\n+                if let Ok(node_id) = destination.target_id {\n+                    visitor.visit_def_mention(Def::Label(node_id))\n+                }\n             }\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n         ExprKind::Continue(ref destination) => {\n             if let Some(ref label) = destination.label {\n                 visitor.visit_label(label);\n-                match destination.target_id {\n-                    Ok(node_id) => visitor.visit_def_mention(Def::Label(node_id)),\n-                    Err(_) => {},\n-                };\n+                if let Ok(node_id) = destination.target_id {\n+                    visitor.visit_def_mention(Def::Label(node_id))\n+                }\n             }\n         }\n         ExprKind::Ret(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }\n         ExprKind::InlineAsm(_, ref outputs, ref inputs) => {\n-            for output in outputs {\n-                visitor.visit_expr(output)\n-            }\n-            for input in inputs {\n-                visitor.visit_expr(input)\n+            for expr in outputs.iter().chain(inputs.iter()) {\n+                visitor.visit_expr(expr)\n             }\n         }\n         ExprKind::Yield(ref subexpression) => {\n@@ -1156,7 +1150,6 @@ impl IdRange {\n         self.min = cmp::min(self.min, id);\n         self.max = cmp::max(self.max, NodeId::from_u32(id.as_u32() + 1));\n     }\n-\n }\n \n "}, {"sha": "bd8770abb135c55b0f77cc6ff0d21869a4e26af9", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de", "patch": "@@ -597,7 +597,7 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn expect_full_def_from_use(&mut self, id: NodeId) -> impl Iterator<Item=Def> {\n+    fn expect_full_def_from_use(&mut self, id: NodeId) -> impl Iterator<Item = Def> {\n         self.resolver.get_import(id).present_items().map(|pr| {\n             if pr.unresolved_segments() != 0 {\n                 bug!(\"path not fully resolved: {:?}\", pr);\n@@ -990,7 +990,7 @@ impl<'a> LoweringContext<'a> {\n             None => {\n                 self.loop_scopes\n                     .last()\n-                    .map(|innermost_loop_id| *innermost_loop_id)\n+                    .cloned()\n                     .map(|id| Ok(self.lower_node_id(id).node_id))\n                     .unwrap_or(Err(hir::LoopIdError::OutsideLoopScope))\n                     .into()"}, {"sha": "c7824d411aac6366bf745568a31d88ec5832866f", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de", "patch": "@@ -161,27 +161,27 @@ impl<'a> FnLikeNode<'a> {\n     }\n \n     pub fn body(self) -> ast::BodyId {\n-        self.handle(|i: ItemFnParts<'a>|  i.body,\n-                    |_, _, _: &'a ast::MethodSig, _, body: ast::BodyId, _, _|  body,\n+        self.handle(|i: ItemFnParts<'a>| i.body,\n+                    |_, _, _: &'a ast::MethodSig, _, body: ast::BodyId, _, _| body,\n                     |c: ClosureParts<'a>| c.body)\n     }\n \n     pub fn decl(self) -> &'a FnDecl {\n-        self.handle(|i: ItemFnParts<'a>|  &*i.decl,\n-                    |_, _, sig: &'a ast::MethodSig, _, _, _, _|  &sig.decl,\n+        self.handle(|i: ItemFnParts<'a>| &*i.decl,\n+                    |_, _, sig: &'a ast::MethodSig, _, _, _, _| &sig.decl,\n                     |c: ClosureParts<'a>| c.decl)\n     }\n \n     pub fn span(self) -> Span {\n-        self.handle(|i: ItemFnParts|     i.span,\n+        self.handle(|i: ItemFnParts| i.span,\n                     |_, _, _: &'a ast::MethodSig, _, _, span, _| span,\n-                    |c: ClosureParts|    c.span)\n+                    |c: ClosureParts| c.span)\n     }\n \n     pub fn id(self) -> NodeId {\n-        self.handle(|i: ItemFnParts|     i.id,\n+        self.handle(|i: ItemFnParts| i.id,\n                     |id, _, _: &'a ast::MethodSig, _, _, _, _| id,\n-                    |c: ClosureParts|    c.id)\n+                    |c: ClosureParts| c.id)\n     }\n \n     pub fn constness(self) -> ast::Constness {\n@@ -260,9 +260,7 @@ impl<'a> FnLikeNode<'a> {\n                     ast::ImplItemKind::Method(ref sig, body) => {\n                         method(ii.id, ii.ident, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n                     }\n-                    _ => {\n-                        bug!(\"impl method FnLikeNode that is not fn-like\")\n-                    }\n+                    _ => bug!(\"impl method FnLikeNode that is not fn-like\")\n                 }\n             },\n             map::Node::Expr(e) => match e.node {"}, {"sha": "bd12a5e0cb4d8dccd87f2df68af588b3edf0e0ba", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de", "patch": "@@ -67,7 +67,6 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                 // them explicitly here.\n                 ref attrs,\n                 span,\n-\n                 // These fields are handled separately:\n                 exported_macros: _,\n                 items: _,\n@@ -128,30 +127,27 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                                                   cstore: &dyn CrateStore,\n                                                   source_map: &SourceMap,\n                                                   commandline_args_hash: u64)\n-                                                  -> (Vec<Option<Entry<'hir>>>, Svh) {\n-        self.hir_body_nodes\n-            .sort_unstable_by(|&(ref d1, _), &(ref d2, _)| d1.cmp(d2));\n+                                                  -> (Vec<Option<Entry<'hir>>>, Svh)\n+    {\n+        self.hir_body_nodes.sort_unstable_by_key(|bn| bn.0);\n \n         let node_hashes = self\n             .hir_body_nodes\n             .iter()\n-            .fold(Fingerprint::ZERO, |fingerprint , &(def_path_hash, dep_node_index)| {\n+            .fold(Fingerprint::ZERO, |fingerprint, &(def_path_hash, dep_node_index)| {\n                 fingerprint.combine(\n                     def_path_hash.0.combine(self.dep_graph.fingerprint_of(dep_node_index))\n                 )\n             });\n \n         let mut upstream_crates: Vec<_> = cstore.crates_untracked().iter().map(|&cnum| {\n             let name = cstore.crate_name_untracked(cnum).as_str();\n-            let disambiguator = cstore.crate_disambiguator_untracked(cnum)\n-                                      .to_fingerprint();\n+            let disambiguator = cstore.crate_disambiguator_untracked(cnum).to_fingerprint();\n             let hash = cstore.crate_hash_untracked(cnum);\n             (name, disambiguator, hash)\n         }).collect();\n \n-        upstream_crates.sort_unstable_by(|&(name1, dis1, _), &(name2, dis2, _)| {\n-            (name1, dis1).cmp(&(name2, dis2))\n-        });\n+        upstream_crates.sort_unstable_by_key(|&(name, dis, _)| (name, dis));\n \n         // We hash the final, remapped names of all local source files so we\n         // don't have to include the path prefix remapping commandline args.\n@@ -229,7 +225,6 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         }\n \n         self.insert_entry(id, entry);\n-\n     }\n \n     fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_id: NodeId, f: F) {\n@@ -311,14 +306,11 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         self.with_dep_node_owner(i.hir_id.owner, i, |this| {\n             this.insert(i.id, Node::Item(i));\n             this.with_parent(i.id, |this| {\n-                match i.node {\n-                    ItemKind::Struct(ref struct_def, _) => {\n-                        // If this is a tuple-like struct, register the constructor.\n-                        if !struct_def.is_struct() {\n-                            this.insert(struct_def.id(), Node::StructCtor(struct_def));\n-                        }\n+                if let ItemKind::Struct(ref struct_def, _) = i.node {\n+                    // If this is a tuple-like struct, register the constructor.\n+                    if !struct_def.is_struct() {\n+                        this.insert(struct_def.id(), Node::StructCtor(struct_def));\n                     }\n-                    _ => {}\n                 }\n                 intravisit::walk_item(this, i);\n             });"}, {"sha": "57b3b43a338bb0a5e631132c65056c284539f15c", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de", "patch": "@@ -348,13 +348,10 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_token(&mut self, t: Token) {\n         if let Token::Interpolated(nt) = t {\n-            match nt.0 {\n-                token::NtExpr(ref expr) => {\n-                    if let ExprKind::Mac(..) = expr.node {\n-                        self.visit_macro_invoc(expr.id);\n-                    }\n+            if let token::NtExpr(ref expr) = nt.0 {\n+                if let ExprKind::Mac(..) = expr.node {\n+                    self.visit_macro_invoc(expr.id);\n                 }\n-                _ => {}\n             }\n         }\n     }"}, {"sha": "c85cee736605533781bf9a876283e1b435737ecf", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de", "patch": "@@ -317,10 +317,8 @@ pub enum DefPathData {\n     // they are treated specially by the `def_path` function.\n     /// The crate root (marker)\n     CrateRoot,\n-\n     // Catch-all for random DefId things like DUMMY_NODE_ID\n     Misc,\n-\n     // Different kinds of items and item-like things:\n     /// An impl\n     Impl,\n@@ -342,7 +340,6 @@ pub enum DefPathData {\n     MacroDef(InternedString),\n     /// A closure expression\n     ClosureExpr,\n-\n     // Subportions of items\n     /// A type parameter (generic parameter)\n     TypeParam(InternedString),\n@@ -358,7 +355,6 @@ pub enum DefPathData {\n     AnonConst,\n     /// An `impl Trait` type node\n     ImplTrait,\n-\n     /// GlobalMetaData identifies a piece of crate metadata that is global to\n     /// a whole crate (as opposed to just one item). GlobalMetaData components\n     /// are only supposed to show up right below the crate root.\n@@ -656,10 +652,8 @@ impl DefPathData {\n             GlobalMetaData(name) => {\n                 return name\n             }\n-\n             // note that this does not show up in user printouts\n             CrateRoot => \"{{root}}\",\n-\n             Impl => \"{{impl}}\",\n             Misc => \"{{?}}\",\n             ClosureExpr => \"{{closure}}\","}, {"sha": "d61b5313444f37d23eecb2bae34fc573421da2d1", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de", "patch": "@@ -100,8 +100,8 @@ impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n \n         if max != self.hir_ids_seen.len() - 1 {\n             // Collect the missing ItemLocalIds\n-            let missing: Vec<_> = (0 .. max + 1)\n-              .filter(|&i| !self.hir_ids_seen.contains_key(&ItemLocalId(i as u32)))\n+            let missing: Vec<_> = (0 .. max as u32 + 1)\n+              .filter(|&i| !self.hir_ids_seen.contains_key(&ItemLocalId(i)))\n               .collect();\n \n             // Try to map those to something more useful"}, {"sha": "31fba3ad97493158d9d3a879f514d81e0cea7dbf", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 22, "deletions": 48, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de", "patch": "@@ -291,8 +291,7 @@ impl<'hir> Map<'hir> {\n                 };\n \n                 match item.node {\n-                    ItemKind::Static(_, m, _) => Some(Def::Static(def_id(),\n-                                                            m == MutMutable)),\n+                    ItemKind::Static(_, m, _) => Some(Def::Static(def_id(), m == MutMutable)),\n                     ItemKind::Const(..) => Some(Def::Const(def_id())),\n                     ItemKind::Fn(..) => Some(Def::Fn(def_id())),\n                     ItemKind::Mod(..) => Some(Def::Mod(def_id())),\n@@ -408,7 +407,7 @@ impl<'hir> Map<'hir> {\n \n     pub fn fn_decl(&self, node_id: ast::NodeId) -> Option<FnDecl> {\n         if let Some(entry) = self.find_entry(node_id) {\n-            entry.fn_decl().map(|fd| fd.clone())\n+            entry.fn_decl().cloned()\n         } else {\n             bug!(\"no entry for node_id `{}`\", node_id)\n         }\n@@ -471,18 +470,13 @@ impl<'hir> Map<'hir> {\n         match self.get(id) {\n             Node::Item(&Item { node: ItemKind::Trait(..), .. }) => id,\n             Node::GenericParam(_) => self.get_parent_node(id),\n-            _ => {\n-                bug!(\"ty_param_owner: {} not a type parameter\",\n-                    self.node_to_string(id))\n-            }\n+            _ => bug!(\"ty_param_owner: {} not a type parameter\", self.node_to_string(id))\n         }\n     }\n \n     pub fn ty_param_name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n-            Node::Item(&Item { node: ItemKind::Trait(..), .. }) => {\n-                keywords::SelfType.name()\n-            }\n+            Node::Item(&Item { node: ItemKind::Trait(..), .. }) => keywords::SelfType.name(),\n             Node::GenericParam(param) => param.name.ident().name,\n             _ => bug!(\"ty_param_name: {} not a type parameter\", self.node_to_string(id)),\n         }\n@@ -521,10 +515,8 @@ impl<'hir> Map<'hir> {\n     /// Retrieve the Node corresponding to `id`, panicking if it cannot\n     /// be found.\n     pub fn get(&self, id: NodeId) -> Node<'hir> {\n-        match self.find(id) {\n-            Some(node) => node, // read recorded by `find`\n-            None => bug!(\"couldn't find node id {} in the AST map\", id)\n-        }\n+        // read recorded by `find`\n+        self.find(id).unwrap_or_else(|| bug!(\"couldn't find node id {} in the AST map\", id))\n     }\n \n     pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n@@ -697,10 +689,7 @@ impl<'hir> Map<'hir> {\n             }\n         };\n \n-        match self.walk_parent_nodes(id, match_fn, match_non_returning_block) {\n-            Ok(id) => Some(id),\n-            Err(_) => None,\n-        }\n+        self.walk_parent_nodes(id, match_fn, match_non_returning_block).ok()\n     }\n \n     /// Retrieve the NodeId for `id`'s parent item, or `id` itself if no\n@@ -738,17 +727,14 @@ impl<'hir> Map<'hir> {\n     /// and associated types probably shouldn't, for example. Behavior in this\n     /// regard should be expected to be highly unstable.\n     pub fn get_enclosing_scope(&self, id: NodeId) -> Option<NodeId> {\n-        match self.walk_parent_nodes(id, |node| match *node {\n+        self.walk_parent_nodes(id, |node| match *node {\n             Node::Item(_) |\n             Node::ForeignItem(_) |\n             Node::TraitItem(_) |\n             Node::ImplItem(_) |\n             Node::Block(_) => true,\n             _ => false,\n-        }, |_| false) {\n-            Ok(id) => Some(id),\n-            Err(_) => None,\n-        }\n+        }, |_| false).ok()\n     }\n \n     pub fn get_parent_did(&self, id: NodeId) -> DefId {\n@@ -758,13 +744,11 @@ impl<'hir> Map<'hir> {\n     pub fn get_foreign_abi(&self, id: NodeId) -> Abi {\n         let parent = self.get_parent(id);\n         if let Some(entry) = self.find_entry(parent) {\n-            match entry {\n-                Entry { node: Node::Item(Item { node: ItemKind::ForeignMod(ref nm), .. }), .. }\n-                    => {\n-                    self.read(id); // reveals some of the content of a node\n-                    return nm.abi;\n-                }\n-                _ => {}\n+            if let Entry {\n+                node: Node::Item(Item { node: ItemKind::ForeignMod(ref nm), .. }), .. } = entry\n+            {\n+                self.read(id); // reveals some of the content of a node\n+                return nm.abi;\n             }\n         }\n         bug!(\"expected foreign mod or inlined parent, found {}\", self.node_to_string(parent))\n@@ -797,18 +781,12 @@ impl<'hir> Map<'hir> {\n                 match i.node {\n                     ItemKind::Struct(ref struct_def, _) |\n                     ItemKind::Union(ref struct_def, _) => struct_def,\n-                    _ => {\n-                        bug!(\"struct ID bound to non-struct {}\",\n-                             self.node_to_string(id));\n-                    }\n+                    _ => bug!(\"struct ID bound to non-struct {}\", self.node_to_string(id))\n                 }\n             }\n             Some(Node::StructCtor(data)) => data,\n             Some(Node::Variant(variant)) => &variant.node.data,\n-            _ => {\n-                bug!(\"expected struct or variant, found {}\",\n-                     self.node_to_string(id));\n-            }\n+            _ => bug!(\"expected struct or variant, found {}\", self.node_to_string(id))\n         }\n     }\n \n@@ -866,9 +844,7 @@ impl<'hir> Map<'hir> {\n             Some(Node::GenericParam(param)) => Some(&param.attrs[..]),\n             // unit/tuple structs take the attributes straight from\n             // the struct definition.\n-            Some(Node::StructCtor(_)) => {\n-                return self.attrs(self.get_parent(id));\n-            }\n+            Some(Node::StructCtor(_)) => return self.attrs(self.get_parent(id)),\n             _ => None\n         };\n         attrs.unwrap_or(&[])\n@@ -917,7 +893,6 @@ impl<'hir> Map<'hir> {\n             Some(Node::Visibility(v)) => bug!(\"unexpected Visibility {:?}\", v),\n             Some(Node::Local(local)) => local.span,\n             Some(Node::MacroDef(macro_def)) => macro_def.span,\n-\n             Some(Node::Crate) => self.forest.krate.span,\n             None => bug!(\"hir::map::Map::span: id not in map: {:?}\", id),\n         }\n@@ -976,10 +951,10 @@ impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n         // chain, then returns `None`.\n         fn find_first_mod_parent<'a>(map: &'a Map, mut id: NodeId) -> Option<(NodeId, Name)> {\n             loop {\n-                match map.find(id)? {\n-                    Node::Item(item) if item_is_mod(&item) =>\n-                        return Some((id, item.name)),\n-                    _ => {}\n+                if let Node::Item(item) = map.find(id)? {\n+                    if item_is_mod(&item) {\n+                        return Some((id, item.name))\n+                    }\n                 }\n                 let parent = map.get_parent(id);\n                 if parent == id { return None }\n@@ -1041,7 +1016,6 @@ impl Named for StructField { fn name(&self) -> Name { self.ident.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.ident.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.ident.name } }\n \n-\n pub fn map_crate<'hir>(sess: &::session::Session,\n                        cstore: &dyn CrateStore,\n                        forest: &'hir mut Forest,\n@@ -1142,7 +1116,7 @@ impl<'a> print::State<'a> {\n             Node::StructCtor(_)   => bug!(\"cannot print isolated StructCtor\"),\n             Node::Local(a)        => self.print_local_decl(&a),\n             Node::MacroDef(_)     => bug!(\"cannot print MacroDef\"),\n-            Node::Crate     => bug!(\"cannot print Crate\"),\n+            Node::Crate           => bug!(\"cannot print Crate\"),\n         }\n     }\n }"}, {"sha": "de9808ffe7001b66abfb0faaa23886d8a6a76902", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de", "patch": "@@ -831,9 +831,10 @@ impl Pat {\n                 s.walk_(it)\n             }\n             PatKind::Slice(ref before, ref slice, ref after) => {\n-                before.iter().all(|p| p.walk_(it)) &&\n-                slice.iter().all(|p| p.walk_(it)) &&\n-                after.iter().all(|p| p.walk_(it))\n+                before.iter()\n+                      .chain(slice.iter())\n+                      .chain(after.iter())\n+                      .all(|p| p.walk_(it))\n             }\n             PatKind::Wild |\n             PatKind::Lit(_) |\n@@ -872,23 +873,23 @@ pub struct FieldPat {\n /// inference.\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum BindingAnnotation {\n-  /// No binding annotation given: this means that the final binding mode\n-  /// will depend on whether we have skipped through a `&` reference\n-  /// when matching. For example, the `x` in `Some(x)` will have binding\n-  /// mode `None`; if you do `let Some(x) = &Some(22)`, it will\n-  /// ultimately be inferred to be by-reference.\n-  ///\n-  /// Note that implicit reference skipping is not implemented yet (#42640).\n-  Unannotated,\n+    /// No binding annotation given: this means that the final binding mode\n+    /// will depend on whether we have skipped through a `&` reference\n+    /// when matching. For example, the `x` in `Some(x)` will have binding\n+    /// mode `None`; if you do `let Some(x) = &Some(22)`, it will\n+    /// ultimately be inferred to be by-reference.\n+    ///\n+    /// Note that implicit reference skipping is not implemented yet (#42640).\n+    Unannotated,\n \n-  /// Annotated with `mut x` -- could be either ref or not, similar to `None`.\n-  Mutable,\n+    /// Annotated with `mut x` -- could be either ref or not, similar to `None`.\n+    Mutable,\n \n-  /// Annotated as `ref`, like `ref x`\n-  Ref,\n+    /// Annotated as `ref`, like `ref x`\n+    Ref,\n \n-  /// Annotated as `ref mut x`.\n-  RefMut,\n+    /// Annotated as `ref mut x`.\n+    RefMut,\n }\n \n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n@@ -1658,7 +1659,6 @@ pub struct TypeBinding {\n     pub span: Span,\n }\n \n-\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Ty {\n     pub id: NodeId,\n@@ -2284,7 +2284,6 @@ pub type TraitMap = NodeMap<Vec<TraitCandidate>>;\n // imported.\n pub type GlobMap = NodeMap<FxHashSet<Name>>;\n \n-\n pub fn provide(providers: &mut Providers) {\n     providers.describe_def = map::describe_def;\n }"}, {"sha": "7638a2cc140c732f6e05ef7794ce075abc684f84", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de", "patch": "@@ -251,6 +251,7 @@ impl<'a> State<'a> {\n     pub fn bclose_(&mut self, span: syntax_pos::Span, indented: usize) -> io::Result<()> {\n         self.bclose_maybe_open(span, indented, true)\n     }\n+\n     pub fn bclose_maybe_open(&mut self,\n                              span: syntax_pos::Span,\n                              indented: usize,\n@@ -264,6 +265,7 @@ impl<'a> State<'a> {\n         }\n         Ok(())\n     }\n+\n     pub fn bclose(&mut self, span: syntax_pos::Span) -> io::Result<()> {\n         self.bclose_(span, indent_unit)\n     }\n@@ -274,12 +276,14 @@ impl<'a> State<'a> {\n             None => false,\n         }\n     }\n+\n     pub fn space_if_not_bol(&mut self) -> io::Result<()> {\n         if !self.is_bol() {\n             self.s.space()?;\n         }\n         Ok(())\n     }\n+\n     pub fn break_offset_if_not_bol(&mut self, n: usize, off: isize) -> io::Result<()> {\n         if !self.is_bol() {\n             self.s.break_offset(n, off)\n@@ -304,7 +308,6 @@ impl<'a> State<'a> {\n         self.s.word(\"*/\")\n     }\n \n-\n     pub fn commasep_cmnt<T, F, G>(&mut self,\n                                   b: Breaks,\n                                   elts: &[T],\n@@ -689,20 +692,14 @@ impl<'a> State<'a> {\n                     self.s.space()?;\n                 }\n \n-                match polarity {\n-                    hir::ImplPolarity::Negative => {\n-                        self.s.word(\"!\")?;\n-                    }\n-                    _ => {}\n+                if let hir::ImplPolarity::Negative = polarity {\n+                    self.s.word(\"!\")?;\n                 }\n \n-                match opt_trait {\n-                    &Some(ref t) => {\n-                        self.print_trait_ref(t)?;\n-                        self.s.space()?;\n-                        self.word_space(\"for\")?;\n-                    }\n-                    &None => {}\n+                if let Some(ref t) = opt_trait {\n+                    self.print_trait_ref(t)?;\n+                    self.s.space()?;\n+                    self.word_space(\"for\")?;\n                 }\n \n                 self.print_type(&ty)?;\n@@ -1061,13 +1058,10 @@ impl<'a> State<'a> {\n         for st in &blk.stmts {\n             self.print_stmt(st)?;\n         }\n-        match blk.expr {\n-            Some(ref expr) => {\n-                self.space_if_not_bol()?;\n-                self.print_expr(&expr)?;\n-                self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi()))?;\n-            }\n-            _ => (),\n+        if let Some(ref expr) = blk.expr {\n+            self.space_if_not_bol()?;\n+            self.print_expr(&expr)?;\n+            self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi()))?;\n         }\n         self.bclose_maybe_open(blk.span, indented, close_box)?;\n         self.ann.post(self, AnnNode::Block(blk))\n@@ -1479,12 +1473,9 @@ impl<'a> State<'a> {\n             }\n             hir::ExprKind::Ret(ref result) => {\n                 self.s.word(\"return\")?;\n-                match *result {\n-                    Some(ref expr) => {\n-                        self.s.word(\" \")?;\n-                        self.print_expr_maybe_paren(&expr, parser::PREC_JUMP)?;\n-                    }\n-                    _ => (),\n+                if let Some(ref expr) = *result {\n+                    self.s.word(\" \")?;\n+                    self.print_expr_maybe_paren(&expr, parser::PREC_JUMP)?;\n                 }\n             }\n             hir::ExprKind::InlineAsm(ref a, ref outputs, ref inputs) => {"}]}