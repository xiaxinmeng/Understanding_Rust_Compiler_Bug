{"sha": "edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkZmI4M2M5ZTI4ZGYyYThmMzI2ZDY4OGYzZDViMWY2ZmFhNzJkYjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-17T09:26:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-17T09:26:57Z"}, "message": "auto merge of #18914 : Gankro/rust/cloned, r=aturon\n\nPart of #18424. r? @aturon \r\n\r\n[breaking-change]", "tree": {"sha": "e9d163e9d31669e9b1233a1997ebc0fd148b76e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9d163e9d31669e9b1233a1997ebc0fd148b76e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "html_url": "https://github.com/rust-lang/rust/commit/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "803aacd5aef78f90fdd06ae7653fc20eec224992", "url": "https://api.github.com/repos/rust-lang/rust/commits/803aacd5aef78f90fdd06ae7653fc20eec224992", "html_url": "https://github.com/rust-lang/rust/commit/803aacd5aef78f90fdd06ae7653fc20eec224992"}, {"sha": "dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfb7a811ae0cb8c98ceed93ecc3573555cca03db", "html_url": "https://github.com/rust-lang/rust/commit/dfb7a811ae0cb8c98ceed93ecc3573555cca03db"}], "stats": {"total": 240, "additions": 121, "deletions": 119}, "files": [{"sha": "f05a681a526034cbdfdd4e4932617a6106241071", "filename": "src/libcore/option.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -150,6 +150,7 @@ use mem;\n use result::{Result, Ok, Err};\n use slice;\n use slice::AsSlice;\n+use clone::Clone;\n \n // Note that this is not a lang item per se, but it has a hidden dependency on\n // `Iterator`, which is one. The compiler assumes that the `next` method of\n@@ -691,6 +692,14 @@ impl<T> Option<T> {\n     }\n }\n \n+impl<'a, T: Clone> Option<&'a T> {\n+    /// Maps an Option<&T> to an Option<T> by cloning the contents of the Option<&T>.\n+    #[unstable = \"recently added as part of collections reform\"]\n+    pub fn cloned(self) -> Option<T> {\n+        self.map(|t| t.clone())\n+    }\n+}\n+\n impl<T: Default> Option<T> {\n     /// Returns the contained value or a default\n     ///"}, {"sha": "6138986e1d185fea67b4460e8ee66c46a7b2c040", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -11,6 +11,7 @@\n use core::option::*;\n use core::kinds::marker;\n use core::mem;\n+use core::clone::Clone;\n \n #[test]\n fn test_get_ptr() {\n@@ -239,3 +240,15 @@ fn test_collect() {\n \n     assert!(v == None);\n }\n+\n+fn test_cloned() {\n+    let s = 1u32;\n+    let n: Option<&'static u32> = None;\n+    let o = Some(&s);\n+\n+    assert_eq!(o.clone(), Some(&s));\n+    assert_eq!(o.cloned(), Some(1u32));\n+\n+    assert_eq!(n.clone(), None);\n+    assert_eq!(n.cloned(), None);\n+}\n\\ No newline at end of file"}, {"sha": "ac2f6dd9d376a5062480e827489241ba6d7d463a", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -391,7 +391,7 @@ struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     fn check_def(&mut self, sp: Span, ty_id: ast::NodeId, path_id: ast::NodeId) {\n-        match self.cx.tcx.def_map.borrow().get_copy(&path_id) {\n+        match self.cx.tcx.def_map.borrow()[path_id].clone() {\n             def::DefPrimTy(ast::TyInt(ast::TyI)) => {\n                 self.cx.span_lint(IMPROPER_CTYPES, sp,\n                                   \"found rust type `int` in foreign module, while \\\n@@ -869,7 +869,7 @@ fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n         node: m.id\n     };\n \n-    match cx.tcx.impl_or_trait_items.borrow().find_copy(&did) {\n+    match cx.tcx.impl_or_trait_items.borrow().get(&did).cloned() {\n         None => cx.sess().span_bug(m.span, \"missing method descriptor?!\"),\n         Some(md) => {\n             match md {"}, {"sha": "322191701e29012dda6374964a43f04e4c9648a4", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -1863,7 +1863,7 @@ impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n         match item.node {\n             ItemImpl(_, Some(ref trait_ref), _, _) => {\n                 let def_map = &self.ecx.tcx.def_map;\n-                let trait_def = def_map.borrow().get_copy(&trait_ref.ref_id);\n+                let trait_def = def_map.borrow()[trait_ref.ref_id].clone();\n                 let def_id = trait_def.def_id();\n \n                 // Load eagerly if this is an implementation of the Drop trait"}, {"sha": "d660cc970e7b64d0fe6962ac44d0815da5c0edcf", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -439,7 +439,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n                                          pos: pos,\n                                          len: len };\n \n-        match st.tcx.rcache.borrow().find_copy(&key) {\n+        match st.tcx.rcache.borrow().get(&key).cloned() {\n           Some(tt) => return tt,\n           None => {}\n         }"}, {"sha": "e20a7901e656a763692911ec632971d7433089b8", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -1200,8 +1200,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                                 var_id: var_id,\n                                 closure_expr_id: id\n                             };\n-                            let upvar_borrow = tcx.upvar_borrow_map.borrow()\n-                                                  .get_copy(&upvar_id);\n+                            let upvar_borrow = tcx.upvar_borrow_map.borrow()[upvar_id].clone();\n                             var_id.encode(rbml_w);\n                             upvar_borrow.encode(rbml_w);\n                         })"}, {"sha": "b38246647d6d55a9d1a556c6c372d01453c04e89", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -295,7 +295,7 @@ impl MoveData {\n \n     fn existing_move_path(&self, lp: &Rc<LoanPath>)\n                           -> Option<MovePathIndex> {\n-        self.path_map.borrow().find_copy(lp)\n+        self.path_map.borrow().get(lp).cloned()\n     }\n \n     fn existing_base_paths(&self, lp: &Rc<LoanPath>)\n@@ -312,7 +312,7 @@ impl MoveData {\n          * paths of `lp` to `result`, but does not add new move paths\n          */\n \n-        match self.path_map.borrow().find_copy(lp) {\n+        match self.path_map.borrow().get(lp).cloned() {\n             Some(index) => {\n                 self.each_base_path(index, |p| {\n                     result.push(p);"}, {"sha": "9e1e4552ee29e18777266ee48104f34d2614aa6d", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -359,7 +359,7 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         match pat.node {\n             PatIdent(..) | PatEnum(..) => {\n-                let def = self.tcx.def_map.borrow().find_copy(&pat.id);\n+                let def = self.tcx.def_map.borrow().get(&pat.id).cloned();\n                 match def {\n                     Some(DefConst(did)) => match lookup_const_by_id(self.tcx, did) {\n                         Some(const_expr) => {\n@@ -749,7 +749,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             Some(Vec::from_elem(arity, DUMMY_WILD_PAT)),\n \n         &PatIdent(_, _, _) => {\n-            let opt_def = cx.tcx.def_map.borrow().find_copy(&pat_id);\n+            let opt_def = cx.tcx.def_map.borrow().get(&pat_id).cloned();\n             match opt_def {\n                 Some(DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n@@ -764,7 +764,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         &PatEnum(_, ref args) => {\n-            let def = cx.tcx.def_map.borrow().get_copy(&pat_id);\n+            let def = cx.tcx.def_map.borrow()[pat_id].clone();\n             match def {\n                 DefConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n@@ -782,7 +782,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n \n         &PatStruct(_, ref pattern_fields, _) => {\n             // Is this a struct or an enum variant?\n-            let def = cx.tcx.def_map.borrow().get_copy(&pat_id);\n+            let def = cx.tcx.def_map.borrow()[pat_id].clone();\n             let class_id = match def {\n                 DefConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\"}, {"sha": "a626a028e2eb5e13a7591d31258727ff8c0c7239", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -85,7 +85,7 @@ pub fn join_all<It: Iterator<constness>>(mut cs: It) -> constness {\n }\n \n fn lookup_const<'a>(tcx: &'a ty::ctxt, e: &Expr) -> Option<&'a Expr> {\n-    let opt_def = tcx.def_map.borrow().find_copy(&e.id);\n+    let opt_def = tcx.def_map.borrow().get(&e.id).cloned();\n     match opt_def {\n         Some(def::DefConst(def_id)) => {\n             lookup_const_by_id(tcx, def_id)\n@@ -320,7 +320,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<Pat> {\n             PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect()),\n \n         ExprCall(ref callee, ref args) => {\n-            let def = tcx.def_map.borrow().get_copy(&callee.id);\n+            let def = tcx.def_map.borrow()[callee.id].clone();\n             match tcx.def_map.borrow_mut().entry(expr.id) {\n               Vacant(entry) => { entry.set(def); }\n               _ => {}\n@@ -352,7 +352,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<Pat> {\n         }\n \n         ExprPath(ref path) => {\n-            let opt_def = tcx.def_map.borrow().find_copy(&expr.id);\n+            let opt_def = tcx.def_map.borrow().get(&expr.id).cloned();\n             match opt_def {\n                 Some(def::DefStruct(..)) =>\n                     PatStruct(path.clone(), vec![], false),"}, {"sha": "16e8adb8adf89b59ec09aabfad948c06d92e344c", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -850,7 +850,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n-                let def = def_map.borrow().get_copy(&pat.id);\n+                let def = def_map.borrow()[pat.id].clone();\n                 match mc.cat_def(pat.id, pat.span, pat_ty, def) {\n                     Ok(binding_cmt) => {\n                         delegate.mutate(pat.id, pat.span, binding_cmt, Init);\n@@ -957,8 +957,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n             // inferred by regionbk\n             let upvar_id = ty::UpvarId { var_id: id_var,\n                                          closure_expr_id: closure_expr.id };\n-            let upvar_borrow = self.tcx().upvar_borrow_map.borrow()\n-                                   .get_copy(&upvar_id);\n+            let upvar_borrow = self.tcx().upvar_borrow_map.borrow()[upvar_id].clone();\n \n             self.delegate.borrow(closure_expr.id,\n                                  closure_expr.span,"}, {"sha": "d1f78cf0417018e6be6d6d6d54283e3fad3dc694", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -449,7 +449,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       ExprPath(_) => {\n-        let def = ir.tcx.def_map.borrow().get_copy(&expr.id);\n+        let def = ir.tcx.def_map.borrow()[expr.id].clone();\n         debug!(\"expr {}: path that leads to {}\", expr.id, def);\n         match def {\n             DefLocal(..) => ir.add_live_node_for_node(expr.id, ExprNode(expr.span)),\n@@ -1316,7 +1316,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: uint)\n                    -> LiveNode {\n-        match self.ir.tcx.def_map.borrow().get_copy(&expr.id) {\n+        match self.ir.tcx.def_map.borrow()[expr.id].clone() {\n           DefLocal(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0u {\n@@ -1582,7 +1582,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n           ExprPath(_) => {\n-            match self.ir.tcx.def_map.borrow().get_copy(&expr.id) {\n+            match self.ir.tcx.def_map.borrow()[expr.id].clone() {\n               DefLocal(nid) => {\n                 // Assignment to an immutable variable or argument: only legal\n                 // if there is no later assignment. If this local is actually"}, {"sha": "d3b70afe39b50dabbf4ea8e14448a4554acf2e89", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -245,7 +245,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             ast::ItemImpl(_, _, ref ty, ref impl_items) => {\n                 let public_ty = match ty.node {\n                     ast::TyPath(_, _, id) => {\n-                        match self.tcx.def_map.borrow().get_copy(&id) {\n+                        match self.tcx.def_map.borrow()[id].clone() {\n                             def::DefPrimTy(..) => true,\n                             def => {\n                                 let did = def.def_id();\n@@ -313,7 +313,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             ast::ItemTy(ref ty, _) if public_first => {\n                 match ty.node {\n                     ast::TyPath(_, _, id) => {\n-                        match self.tcx.def_map.borrow().get_copy(&id) {\n+                        match self.tcx.def_map.borrow()[id].clone() {\n                             def::DefPrimTy(..) | def::DefTyParam(..) => {},\n                             def => {\n                                 let did = def.def_id();\n@@ -620,7 +620,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                             ast::TyPath(_, _, id) => id,\n                             _ => return Some((err_span, err_msg, None)),\n                         };\n-                        let def = self.tcx.def_map.borrow().get_copy(&id);\n+                        let def = self.tcx.def_map.borrow()[id].clone();\n                         let did = def.def_id();\n                         assert!(is_local(did));\n                         match self.tcx.map.get(did.node) {\n@@ -706,7 +706,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     // Checks that a path is in scope.\n     fn check_path(&mut self, span: Span, path_id: ast::NodeId, path: &ast::Path) {\n         debug!(\"privacy - path {}\", self.nodestr(path_id));\n-        let orig_def = self.tcx.def_map.borrow().get_copy(&path_id);\n+        let orig_def = self.tcx.def_map.borrow()[path_id].clone();\n         let ck = |tyname: &str| {\n             let ck_public = |def: ast::DefId| {\n                 let name = token::get_ident(path.segments\n@@ -789,7 +789,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         // def map is not. Therefore the names we work out below will not always\n         // be accurate and we can get slightly wonky error messages (but type\n         // checking is always correct).\n-        match self.tcx.def_map.borrow().get_copy(&path_id) {\n+        match self.tcx.def_map.borrow()[path_id].clone() {\n             def::DefStaticMethod(..) => ck(\"static method\"),\n             def::DefFn(..) => ck(\"function\"),\n             def::DefStatic(..) => ck(\"static\"),\n@@ -873,7 +873,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n-                        match self.tcx.def_map.borrow().get_copy(&expr.id) {\n+                        match self.tcx.def_map.borrow()[expr.id].clone() {\n                             def::DefVariant(_, variant_id, _) => {\n                                 for field in fields.iter() {\n                                     self.check_field(expr.span, variant_id,\n@@ -1255,7 +1255,7 @@ struct CheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n \n impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n-        let did = match self.tcx.def_map.borrow().find_copy(&path_id) {\n+        let did = match self.tcx.def_map.borrow().get(&path_id).cloned() {\n             // `int` etc. (None doesn't seem to occur.)\n             None | Some(def::DefPrimTy(..)) => return false,\n             Some(def) => def.def_id()"}, {"sha": "fd62d0cdc11c66ac7ba00f7a9e7d2fff7946d372", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -1097,7 +1097,7 @@ impl<'a> Resolver<'a> {\n                                                                    sp);\n \n         // Add or reuse the child.\n-        let child = module_.children.borrow().find_copy(&name);\n+        let child = module_.children.borrow().get(&name).cloned();\n         match child {\n             None => {\n                 let child = Rc::new(NameBindings::new());\n@@ -1381,7 +1381,7 @@ impl<'a> Resolver<'a> {\n                         let mod_name = path.segments.last().unwrap().identifier.name;\n \n                         let parent_opt = parent.module().children.borrow()\n-                                               .find_copy(&mod_name);\n+                                               .get(&mod_name).cloned();\n                         let new_parent = match parent_opt {\n                             // It already exists\n                             Some(ref child) if child.get_module_if_available()\n@@ -2676,7 +2676,7 @@ impl<'a> Resolver<'a> {\n             BoundResult(..) => {}\n             _ => {\n                 match containing_module.external_module_children.borrow_mut()\n-                                       .find_copy(&source) {\n+                                       .get(&source).cloned() {\n                     None => {} // Continue.\n                     Some(module) => {\n                         debug!(\"(resolving single import) found external \\\n@@ -3191,7 +3191,7 @@ impl<'a> Resolver<'a> {\n         fn search_parent_externals(needle: Name, module: &Rc<Module>)\n                                 -> Option<Rc<Module>> {\n             module.external_module_children.borrow()\n-                                            .find_copy(&needle)\n+                                            .get(&needle).cloned()\n                                             .map(|_| module.clone())\n                                             .or_else(|| {\n                 match module.parent_link.clone() {\n@@ -3478,7 +3478,7 @@ impl<'a> Resolver<'a> {\n \n         // Search for external modules.\n         if namespace == TypeNS {\n-            match module_.external_module_children.borrow().find_copy(&name) {\n+            match module_.external_module_children.borrow().get(&name).cloned() {\n                 None => {}\n                 Some(module) => {\n                     let name_bindings =\n@@ -3763,7 +3763,7 @@ impl<'a> Resolver<'a> {\n \n         // Finally, search through external children.\n         if namespace == TypeNS {\n-            match module_.external_module_children.borrow().find_copy(&name) {\n+            match module_.external_module_children.borrow().get(&name).cloned() {\n                 None => {}\n                 Some(module) => {\n                     let name_bindings =\n@@ -4043,7 +4043,7 @@ impl<'a> Resolver<'a> {\n                             // item, it's ok\n                             match def {\n                                 DefTyParam(_, did, _) if {\n-                                    self.def_map.borrow().find_copy(&did.node)\n+                                    self.def_map.borrow().get(&did.node).cloned()\n                                         == Some(DefTyParamBinder(item_id))\n                                 } => {} // ok\n                                 DefSelfTy(did) if did == item_id => {} // ok\n@@ -4096,7 +4096,7 @@ impl<'a> Resolver<'a> {\n                             // item, it's ok\n                             match def {\n                                 DefTyParam(_, did, _) if {\n-                                    self.def_map.borrow().find_copy(&did.node)\n+                                    self.def_map.borrow().get(&did.node).cloned()\n                                         == Some(DefTyParamBinder(item_id))\n                                 } => {} // ok\n                                 DefSelfTy(did) if did == item_id => {} // ok\n@@ -4148,7 +4148,7 @@ impl<'a> Resolver<'a> {\n         // FIXME #4950: Try caching?\n \n         for (i, rib) in ribs.iter().enumerate().rev() {\n-            match rib.bindings.find_copy(&name) {\n+            match rib.bindings.get(&name).cloned() {\n                 Some(def_like) => {\n                     return self.upvarify(ribs[i + 1..], def_like, span);\n                 }\n@@ -5444,7 +5444,7 @@ impl<'a> Resolver<'a> {\n         // Finally, search through external children.\n         if namespace == TypeNS {\n             match containing_module.external_module_children.borrow()\n-                                   .find_copy(&name) {\n+                                   .get(&name).cloned() {\n                 None => {}\n                 Some(module) => {\n                     match module.def_id.get() {"}, {"sha": "49bbfd0be479a2422ec334123d3b5290b4d6e17e", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -139,7 +139,7 @@ pub fn lookup(tcx: &ty::ctxt, id: DefId) -> Option<Stability> {\n             lookup(tcx, trait_method_id)\n         }\n         _ if is_local(id) => {\n-            tcx.stability.borrow().local.find_copy(&id.node)\n+            tcx.stability.borrow().local.get(&id.node).cloned()\n         }\n         _ => {\n             let stab = csearch::get_stability(&tcx.sess.cstore, id);"}, {"sha": "7035df542c0713956d0ed67c4432794e89a61a52", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -568,7 +568,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             ast::PatLit(ref l) => ConstantValue(ConstantExpr(&**l)),\n             ast::PatIdent(..) | ast::PatEnum(..) | ast::PatStruct(..) => {\n                 // This is either an enum variant or a variable binding.\n-                let opt_def = tcx.def_map.borrow().find_copy(&cur.id);\n+                let opt_def = tcx.def_map.borrow().get(&cur.id).cloned();\n                 match opt_def {\n                     Some(def::DefVariant(enum_id, var_id, _)) => {\n                         let variant = ty::enum_variant_with_id(tcx, enum_id, var_id);\n@@ -1642,7 +1642,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         ast::PatEnum(_, ref sub_pats) => {\n-            let opt_def = bcx.tcx().def_map.borrow().find_copy(&pat.id);\n+            let opt_def = bcx.tcx().def_map.borrow().get(&pat.id).cloned();\n             match opt_def {\n                 Some(def::DefVariant(enum_id, var_id, _)) => {\n                     let repr = adt::represent_node(bcx, pat.id);"}, {"sha": "86fe3e7a64146a6d172dfe054c154a35a9b40eeb", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -2266,7 +2266,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                                          static\");\n               }\n \n-              let v = ccx.static_values().borrow().get_copy(&item.id);\n+              let v = ccx.static_values().borrow()[item.id].clone();\n               unsafe {\n                   if !(llvm::LLVMConstIntGetZExtValue(v) != 0) {\n                       ccx.sess().span_fatal(expr.span, \"static assertion failed\");\n@@ -2656,7 +2656,7 @@ fn contains_null(s: &str) -> bool {\n pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     debug!(\"get_item_val(id=`{}`)\", id);\n \n-    match ccx.item_vals().borrow().find_copy(&id) {\n+    match ccx.item_vals().borrow().get(&id).cloned() {\n         Some(v) => return v,\n         None => {}\n     }"}, {"sha": "dbc4c58020f62889ed02628d760ad34dd6945bd0", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -526,12 +526,12 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n     }\n \n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n-        self.tcx().upvar_borrow_map.borrow().get_copy(&upvar_id)\n+        self.tcx().upvar_borrow_map.borrow()[upvar_id].clone()\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause {\n-        self.tcx().capture_modes.borrow().get_copy(&closure_expr_id)\n+        self.tcx().capture_modes.borrow()[closure_expr_id].clone()\n     }\n }\n "}, {"sha": "1cdd681c8bc00f112811e74a355cfc60730e4f6d", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -184,15 +184,15 @@ pub fn get_const_val(cx: &CrateContext,\n         }\n     }\n \n-    cx.const_values().borrow().get_copy(&def_id.node)\n+    cx.const_values().borrow()[def_id.node].clone()\n }\n \n pub fn const_expr(cx: &CrateContext, e: &ast::Expr) -> (ValueRef, ty::t) {\n     let llconst = const_expr_unadjusted(cx, e);\n     let mut llconst = llconst;\n     let ety = ty::expr_ty(cx.tcx(), e);\n     let mut ety_adjusted = ty::expr_ty_adjusted(cx.tcx(), e);\n-    let opt_adj = cx.tcx().adjustments.borrow().find_copy(&e.id);\n+    let opt_adj = cx.tcx().adjustments.borrow().get(&e.id).cloned();\n     match opt_adj {\n         None => { }\n         Some(adj) => {\n@@ -551,7 +551,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                       _ => break,\n                   }\n               }\n-              let opt_def = cx.tcx().def_map.borrow().find_copy(&cur.id);\n+              let opt_def = cx.tcx().def_map.borrow().get(&cur.id).cloned();\n               match opt_def {\n                   Some(def::DefStatic(def_id, _)) => {\n                       let ty = ty::expr_ty(cx.tcx(), e);\n@@ -626,7 +626,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n             // Assert that there are no type parameters in this path.\n             assert!(pth.segments.iter().all(|seg| !seg.parameters.has_types()));\n \n-            let opt_def = cx.tcx().def_map.borrow().find_copy(&e.id);\n+            let opt_def = cx.tcx().def_map.borrow().get(&e.id).cloned();\n             match opt_def {\n                 Some(def::DefFn(def_id, _)) => {\n                     if !ast_util::is_local(def_id) {\n@@ -660,7 +660,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n             }\n           }\n           ast::ExprCall(ref callee, ref args) => {\n-              let opt_def = cx.tcx().def_map.borrow().find_copy(&callee.id);\n+              let opt_def = cx.tcx().def_map.borrow().get(&callee.id).cloned();\n               match opt_def {\n                   Some(def::DefStruct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n@@ -702,7 +702,7 @@ pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n         let g = base::get_item_val(ccx, id);\n         // At this point, get_item_val has already translated the\n         // constant's initializer to determine its LLVM type.\n-        let v = ccx.static_values().borrow().get_copy(&id);\n+        let v = ccx.static_values().borrow()[id].clone();\n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n         let v = if llvm::LLVMTypeOf(v) == Type::i1(ccx).to_ref() {"}, {"sha": "85700efec71d7b1f73018df85695f9cd0ceb141d", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -519,7 +519,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn get_intrinsic(&self, key: & &'static str) -> ValueRef {\n-        match self.intrinsics().borrow().find_copy(key) {\n+        match self.intrinsics().borrow().get(key).cloned() {\n             Some(v) => return v,\n             _ => {}\n         }"}, {"sha": "6e909e6532e20eb012c0f032dd0cbd846409f00b", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -301,11 +301,11 @@ impl TypeMap {\n     }\n \n     fn find_metadata_for_type(&self, type_: ty::t) -> Option<DIType> {\n-        self.type_to_metadata.find_copy(&type_)\n+        self.type_to_metadata.get(&type_).cloned()\n     }\n \n     fn find_metadata_for_unique_id(&self, unique_type_id: UniqueTypeId) -> Option<DIType> {\n-        self.unique_id_to_metadata.find_copy(&unique_type_id)\n+        self.unique_id_to_metadata.get(&unique_type_id).cloned()\n     }\n \n     // Get the string representation of a UniqueTypeId. This method will fail if\n@@ -341,7 +341,7 @@ impl TypeMap {\n         // unique vec box (~[]) -> {HEAP_VEC_BOX<:pointee-uid:>}\n         // gc box               -> {GC_BOX<:pointee-uid:>}\n \n-        match self.type_to_unique_id.find_copy(&type_) {\n+        match self.type_to_unique_id.get(&type_).cloned() {\n             Some(unique_type_id) => return unique_type_id,\n             None => { /* generate one */}\n         };\n@@ -499,7 +499,7 @@ impl TypeMap {\n             // First, find out the 'real' def_id of the type. Items inlined from\n             // other crates have to be mapped back to their source.\n             let source_def_id = if def_id.krate == ast::LOCAL_CRATE {\n-                match cx.external_srcs().borrow().find_copy(&def_id.node) {\n+                match cx.external_srcs().borrow().get(&def_id.node).cloned() {\n                     Some(source_def_id) => {\n                         // The given def_id identifies the inlined copy of a\n                         // type definition, let's take the source of the copy.\n@@ -853,7 +853,7 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n     pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, path1| {\n         let var_ident = path1.node;\n \n-        let datum = match bcx.fcx.lllocals.borrow().find_copy(&node_id) {\n+        let datum = match bcx.fcx.lllocals.borrow().get(&node_id).cloned() {\n             Some(datum) => datum,\n             None => {\n                 bcx.sess().span_bug(span,\n@@ -1016,7 +1016,7 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n \n     pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, path1| {\n-        let llarg = match bcx.fcx.lllocals.borrow().find_copy(&node_id) {\n+        let llarg = match bcx.fcx.lllocals.borrow().get(&node_id).cloned() {\n             Some(v) => v,\n             None => {\n                 bcx.sess().span_bug(span,\n@@ -1707,7 +1707,7 @@ fn scope_metadata(fcx: &FunctionContext,\n     let scope_map = &fcx.debug_context\n                         .get_ref(fcx.ccx, error_reporting_span)\n                         .scope_map;\n-    match scope_map.borrow().find_copy(&node_id) {\n+    match scope_map.borrow().get(&node_id).cloned() {\n         Some(scope_metadata) => scope_metadata,\n         None => {\n             let node = fcx.ccx.tcx().map.get(node_id);\n@@ -2417,7 +2417,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n         // this cache.\n         let cached_discriminant_type_metadata = debug_context(cx).created_enum_disr_types\n                                                                  .borrow()\n-                                                                 .find_copy(&enum_def_id);\n+                                                                 .get(&enum_def_id).cloned();\n         match cached_discriminant_type_metadata {\n             Some(discriminant_type_metadata) => discriminant_type_metadata,\n             None => {\n@@ -3987,7 +3987,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n             current_key.push(name);\n \n             let existing_node = debug_context(cx).namespace_map.borrow()\n-                                                 .find_copy(&current_key);\n+                                                 .get(&current_key).cloned();\n             let current_node = match existing_node {\n                 Some(existing_node) => existing_node,\n                 None => {"}, {"sha": "ea590a669d0f98bb82e56d6c281233713a3aedba", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -184,7 +184,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let mut bcx = bcx;\n     let mut datum = datum;\n-    let adjustment = match bcx.tcx().adjustments.borrow().find_copy(&expr.id) {\n+    let adjustment = match bcx.tcx().adjustments.borrow().get(&expr.id).cloned() {\n         None => {\n             return DatumBlock::new(bcx, datum);\n         }\n@@ -1293,7 +1293,7 @@ pub fn with_field_tys<R>(tcx: &ty::ctxt,\n                         ty.repr(tcx)).as_slice());\n                 }\n                 Some(node_id) => {\n-                    let def = tcx.def_map.borrow().get_copy(&node_id);\n+                    let def = tcx.def_map.borrow()[node_id].clone();\n                     match def {\n                         def::DefVariant(enum_id, variant_id, _) => {\n                             let variant_info = ty::enum_variant_with_id("}, {"sha": "4af4b397a6e02dab6a82473f8fec990c3516d796", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -301,7 +301,7 @@ pub fn trans_static_method_callee(bcx: Block,\n \n fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n                     -> ast::DefId {\n-    match ccx.impl_method_cache().borrow().find_copy(&(impl_id, name)) {\n+    match ccx.impl_method_cache().borrow().get(&(impl_id, name)).cloned() {\n         Some(m) => return m,\n         None => {}\n     }"}, {"sha": "c185a1ba539390d7966b5308977bf571b037ded1", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -174,7 +174,7 @@ pub fn type_of_fn_from_ty(cx: &CrateContext, fty: ty::t) -> Type {\n //     recursive types. For example, enum types rely on this behavior.\n \n pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n-    match cx.llsizingtypes().borrow().find_copy(&t) {\n+    match cx.llsizingtypes().borrow().get(&t).cloned() {\n         Some(t) => return t,\n         None => ()\n     }"}, {"sha": "059394dc8321bf70b4a1f08831469c7502ad1582", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -3189,7 +3189,7 @@ pub fn node_id_to_trait_ref(cx: &ctxt, id: ast::NodeId) -> Rc<ty::TraitRef> {\n }\n \n pub fn try_node_id_to_type(cx: &ctxt, id: ast::NodeId) -> Option<t> {\n-    cx.node_types.borrow().find_copy(&id)\n+    cx.node_types.borrow().get(&id).cloned()\n }\n \n pub fn node_id_to_type(cx: &ctxt, id: ast::NodeId) -> t {\n@@ -4051,7 +4051,7 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n      * the crate loading code (and cache the result for the future).\n      */\n \n-    match map.find_copy(&def_id) {\n+    match map.get(&def_id).cloned() {\n         Some(v) => { return v; }\n         None => { }\n     }\n@@ -4073,7 +4073,7 @@ pub fn trait_item(cx: &ctxt, trait_did: ast::DefId, idx: uint)\n pub fn trait_items(cx: &ctxt, trait_did: ast::DefId)\n                    -> Rc<Vec<ImplOrTraitItem>> {\n     let mut trait_items = cx.trait_items_cache.borrow_mut();\n-    match trait_items.find_copy(&trait_did) {\n+    match trait_items.get(&trait_did).cloned() {\n         Some(trait_items) => trait_items,\n         None => {\n             let def_ids = ty::trait_item_def_ids(cx, trait_did);\n@@ -4623,7 +4623,7 @@ pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId, substs: &Subst\n     // This may change if abstract return types of some sort are\n     // implemented.\n     assert!(closure_id.krate == ast::LOCAL_CRATE);\n-    let capture_mode = tcx.capture_modes.borrow().get_copy(&closure_id.node);\n+    let capture_mode = tcx.capture_modes.borrow()[closure_id.node].clone();\n     match tcx.freevars.borrow().get(&closure_id.node) {\n         None => vec![],\n         Some(ref freevars) => {\n@@ -4632,10 +4632,10 @@ pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId, substs: &Subst\n                 let freevar_ty = node_id_to_type(tcx, freevar_def_id.node);\n                 let mut freevar_ty = freevar_ty.subst(tcx, substs);\n                 if capture_mode == ast::CaptureByRef {\n-                    let borrow = tcx.upvar_borrow_map.borrow().get_copy(&ty::UpvarId {\n+                    let borrow = tcx.upvar_borrow_map.borrow()[ty::UpvarId {\n                         var_id: freevar_def_id.node,\n                         closure_expr_id: closure_id.node\n-                    });\n+                    }].clone();\n                     freevar_ty = mk_rptr(tcx, borrow.region, ty::mt {\n                         ty: freevar_ty,\n                         mutbl: borrow.kind.to_mutbl_lossy()\n@@ -4734,7 +4734,7 @@ pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n         fn tcx(&self) -> &ctxt<'tcx> { let TypeNormalizer(c) = *self; c }\n \n         fn fold_ty(&mut self, t: ty::t) -> ty::t {\n-            match self.tcx().normalized_cache.borrow().find_copy(&t) {\n+            match self.tcx().normalized_cache.borrow().get(&t).cloned() {\n                 None => {}\n                 Some(u) => return u\n             }\n@@ -4886,7 +4886,7 @@ pub fn required_region_bounds(tcx: &ctxt,\n \n pub fn get_tydesc_ty(tcx: &ctxt) -> Result<t, String> {\n     tcx.lang_items.require(TyDescStructLangItem).map(|tydesc_lang_item| {\n-        tcx.intrinsic_defs.borrow().find_copy(&tydesc_lang_item)\n+        tcx.intrinsic_defs.borrow().get(&tydesc_lang_item).cloned()\n             .expect(\"Failed to resolve TyDesc\")\n     })\n }\n@@ -5037,7 +5037,7 @@ pub fn impl_of_method(tcx: &ctxt, def_id: ast::DefId)\n             ImplContainer(def_id) => Some(def_id),\n         };\n     }\n-    match tcx.impl_or_trait_items.borrow().find_copy(&def_id) {\n+    match tcx.impl_or_trait_items.borrow().get(&def_id).cloned() {\n         Some(trait_item) => {\n             match trait_item.container() {\n                 TraitContainer(_) => None,\n@@ -5055,7 +5055,7 @@ pub fn trait_of_item(tcx: &ctxt, def_id: ast::DefId) -> Option<ast::DefId> {\n     if def_id.krate != LOCAL_CRATE {\n         return csearch::get_trait_of_item(&tcx.sess.cstore, def_id, tcx);\n     }\n-    match tcx.impl_or_trait_items.borrow().find_copy(&def_id) {\n+    match tcx.impl_or_trait_items.borrow().get(&def_id).cloned() {\n         Some(impl_or_trait_item) => {\n             match impl_or_trait_item.container() {\n                 TraitContainer(def_id) => Some(def_id),\n@@ -5444,12 +5444,12 @@ impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n     }\n \n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n-        self.upvar_borrow_map.borrow().get_copy(&upvar_id)\n+        self.upvar_borrow_map.borrow()[upvar_id].clone()\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause {\n-        self.capture_modes.borrow().get_copy(&closure_expr_id)\n+        self.capture_modes.borrow()[closure_expr_id].clone()\n     }\n \n     fn unboxed_closures<'a>(&'a self)"}, {"sha": "90c3d8c4f3f1d6c1a5e681f856eb2d77a230ccfe", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -71,7 +71,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n             demand::eqtype(fcx, pat.span, expected, lhs_ty);\n         }\n         ast::PatEnum(..) | ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n-            let const_did = tcx.def_map.borrow().get_copy(&pat.id).def_id();\n+            let const_did = tcx.def_map.borrow()[pat.id].clone().def_id();\n             let const_pty = ty::lookup_item_type(tcx, const_did);\n             fcx.write_ty(pat.id, const_pty.ty);\n             demand::suptype(fcx, pat.span, expected, const_pty.ty);\n@@ -296,7 +296,7 @@ pub fn check_pat_struct(pcx: &pat_ctxt, pat: &ast::Pat,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let def = tcx.def_map.borrow().get_copy(&pat.id);\n+    let def = tcx.def_map.borrow()[pat.id].clone();\n     let def_type = ty::lookup_item_type(tcx, def.def_id());\n     let (enum_def_id, variant_def_id) = match ty::get(def_type.ty).sty {\n         ty::ty_struct(struct_def_id, _) =>\n@@ -341,7 +341,7 @@ pub fn check_pat_enum(pcx: &pat_ctxt, pat: &ast::Pat,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let def = tcx.def_map.borrow().get_copy(&pat.id);\n+    let def = tcx.def_map.borrow()[pat.id].clone();\n     let enum_def = def.variant_def_ids()\n         .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n \n@@ -449,7 +449,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n             }\n             Vacant(vacant) => {\n                 vacant.set(span);\n-                field_type_map.find_copy(&field.ident.name)\n+                field_type_map.get(&field.ident.name).cloned()\n                     .unwrap_or_else(|| {\n                         span_err!(tcx.sess, span, E0026,\n                             \"struct `{}` does not have a field named `{}`\","}, {"sha": "d783286272ca0ca9dc334ae51c6997c42326246f", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -309,7 +309,7 @@ impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n         self.tcx().temporary_scope(rvalue_id)\n     }\n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n-        self.inh.upvar_borrow_map.borrow().get_copy(&upvar_id)\n+        self.inh.upvar_borrow_map.borrow()[upvar_id].clone()\n     }\n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause {\n@@ -450,7 +450,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n         debug!(\"Local variable {} is assigned type {}\",\n                self.fcx.pat_to_string(&*local.pat),\n                self.fcx.infcx().ty_to_string(\n-                   self.fcx.inh.locals.borrow().get_copy(&local.id)));\n+                   self.fcx.inh.locals.borrow()[local.id].clone()));\n         visit::walk_local(self, local);\n     }\n \n@@ -467,7 +467,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n                     debug!(\"Pattern binding {} is assigned to {} with type {}\",\n                            token::get_ident(path1.node),\n                            self.fcx.infcx().ty_to_string(\n-                               self.fcx.inh.locals.borrow().get_copy(&p.id)),\n+                               self.fcx.inh.locals.borrow()[p.id].clone()),\n                            var_ty.repr(self.fcx.tcx()));\n                 }\n             _ => {}"}, {"sha": "c63e8944dbdcac2906af9c88d8be786d6fdbc294", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -479,12 +479,12 @@ impl<'fcx, 'tcx> mc::Typer<'tcx> for Rcx<'fcx, 'tcx> {\n     }\n \n     fn upvar_borrow(&self, id: ty::UpvarId) -> ty::UpvarBorrow {\n-        self.fcx.inh.upvar_borrow_map.borrow().get_copy(&id)\n+        self.fcx.inh.upvar_borrow_map.borrow()[id].clone()\n     }\n \n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause {\n-        self.tcx().capture_modes.borrow().get_copy(&closure_expr_id)\n+        self.tcx().capture_modes.borrow()[closure_expr_id].clone()\n     }\n \n     fn unboxed_closures<'a>(&'a self)\n@@ -871,7 +871,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             });\n         }\n         ty::ty_unboxed_closure(_, region, _) => {\n-            if tcx.capture_modes.borrow().get_copy(&expr.id) == ast::CaptureByRef {\n+            if tcx.capture_modes.borrow()[expr.id].clone() == ast::CaptureByRef {\n                 ty::with_freevars(tcx, expr.id, |freevars| {\n                     if !freevars.is_empty() {\n                         // Variables being referenced must be constrained and registered\n@@ -896,7 +896,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             })\n         }\n         ty::ty_unboxed_closure(..) => {\n-            if tcx.capture_modes.borrow().get_copy(&expr.id) == ast::CaptureByRef {\n+            if tcx.capture_modes.borrow()[expr.id].clone() == ast::CaptureByRef {\n                 ty::with_freevars(tcx, expr.id, |freevars| {\n                     propagate_upupvar_borrow_kind(rcx, expr, freevars);\n                 });\n@@ -1847,7 +1847,7 @@ fn link_upvar_borrow_kind_for_nested_closures(rcx: &mut Rcx,\n            inner_upvar_id, outer_upvar_id);\n \n     let mut upvar_borrow_map = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-    let inner_borrow = upvar_borrow_map.get_copy(&inner_upvar_id);\n+    let inner_borrow = upvar_borrow_map[inner_upvar_id].clone();\n     match upvar_borrow_map.get_mut(&outer_upvar_id) {\n         Some(outer_borrow) => {\n             adjust_upvar_borrow_kind(rcx, outer_upvar_id, outer_borrow, inner_borrow.kind);"}, {"sha": "574b04c9e999330bc1a6ab9d29b6be2e9c1a4997", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -317,7 +317,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n     fn get_self_type_for_implementation(&self, impl_did: DefId)\n                                         -> Polytype {\n-        self.crate_context.tcx.tcache.borrow().get_copy(&impl_did)\n+        self.crate_context.tcx.tcache.borrow()[impl_did].clone()\n     }\n \n     // Converts an implementation in the AST to a vector of items.\n@@ -428,7 +428,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         };\n \n         let impl_items = tcx.impl_items.borrow();\n-        let trait_impls = match tcx.trait_impls.borrow().find_copy(&drop_trait) {\n+        let trait_impls = match tcx.trait_impls.borrow().get(&drop_trait).cloned() {\n             None => return, // No types with (new-style) dtors present.\n             Some(found_impls) => found_impls\n         };"}, {"sha": "d57343e004bab8896daf4606f2518cf6f5ceb75e", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -1520,7 +1520,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     ConstrainVarSubReg(_, region) => {\n                         state.result.push(RegionAndOrigin {\n                             region: region,\n-                            origin: this.constraints.borrow().get_copy(&edge.data)\n+                            origin: this.constraints.borrow()[edge.data].clone()\n                         });\n                     }\n                 }"}, {"sha": "779cd425d2a6ee70c70acf47fec846bd6590be43", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -37,7 +37,6 @@ use super::table::{\n };\n \n // FIXME(conventions): update capacity management to match other collections (no auto-shrink)\n-// FIXME(conventions): axe find_copy/get_copy in favour of Option.cloned (also implement that)\n \n const INITIAL_LOG2_CAP: uint = 5;\n pub const INITIAL_CAPACITY: uint = 1 << INITIAL_LOG2_CAP; // 2^5\n@@ -1220,36 +1219,18 @@ fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHas\n }\n \n impl<K: Eq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n-    /// Return a copy of the value corresponding to the key.\n-    ///\n-    /// # Example\n+    /// Deprecated: Use `map.get(k).cloned()`.\n     ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map: HashMap<uint, String> = HashMap::new();\n-    /// map.insert(1u, \"foo\".to_string());\n-    /// let s: String = map.find_copy(&1).unwrap();\n-    /// ```\n+    /// Return a copy of the value corresponding to the key.\n+    #[deprecated = \"Use `map.get(k).cloned()`\"]\n     pub fn find_copy(&self, k: &K) -> Option<V> {\n-        self.get(k).map(|v| (*v).clone())\n+        self.get(k).cloned()\n     }\n \n-    /// Return a copy of the value corresponding to the key.\n+    /// Deprecated: Use `map[k].clone()`.\n     ///\n-    /// # Panics\n-    ///\n-    /// Panics if the key is not present.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map: HashMap<uint, String> = HashMap::new();\n-    /// map.insert(1u, \"foo\".to_string());\n-    /// let s: String = map.get_copy(&1);\n-    /// ```\n+    /// Return a copy of the value corresponding to the key.\n+    #[deprecated = \"Use `map[k].clone()`\"]\n     pub fn get_copy(&self, k: &K) -> V {\n         self[*k].clone()\n     }\n@@ -1844,6 +1825,7 @@ mod test_map {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn test_find_copy() {\n         let mut m = HashMap::new();\n         assert!(m.get(&1i).is_none());"}, {"sha": "3cb861aac20c13c6ef5318bbb1e918f77ed6a944", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "patch": "@@ -94,7 +94,7 @@ fn lookup_cur_matched_by_matched(r: &TtReader, start: Rc<NamedMatch>) -> Rc<Name\n }\n \n fn lookup_cur_matched(r: &TtReader, name: Ident) -> Option<Rc<NamedMatch>> {\n-    let matched_opt = r.interpolations.find_copy(&name);\n+    let matched_opt = r.interpolations.get(&name).cloned();\n     matched_opt.map(|s| lookup_cur_matched_by_matched(r, s))\n }\n "}]}