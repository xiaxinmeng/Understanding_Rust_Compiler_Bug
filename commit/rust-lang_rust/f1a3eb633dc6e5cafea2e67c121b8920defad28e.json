{"sha": "f1a3eb633dc6e5cafea2e67c121b8920defad28e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxYTNlYjYzM2RjNmU1Y2FmZWEyZTY3YzEyMWI4OTIwZGVmYWQyOGU=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2016-09-25T21:38:32Z"}, "committer": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2016-09-25T21:40:16Z"}, "message": "Separate rustdoc passes into separate modules.", "tree": {"sha": "3abbb1ba2ca47a62e3968828d5c48d1212ef5315", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3abbb1ba2ca47a62e3968828d5c48d1212ef5315"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1a3eb633dc6e5cafea2e67c121b8920defad28e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1a3eb633dc6e5cafea2e67c121b8920defad28e", "html_url": "https://github.com/rust-lang/rust/commit/f1a3eb633dc6e5cafea2e67c121b8920defad28e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1a3eb633dc6e5cafea2e67c121b8920defad28e/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5495fab363f4588fd24d1fe715a17a8796bcb90a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5495fab363f4588fd24d1fe715a17a8796bcb90a", "html_url": "https://github.com/rust-lang/rust/commit/5495fab363f4588fd24d1fe715a17a8796bcb90a"}], "stats": {"total": 924, "additions": 508, "deletions": 416}, "files": [{"sha": "92f24ce099b6d874c5e72b3542581a19cf5bf671", "filename": "src/librustdoc/passes.rs", "status": "removed", "additions": 0, "deletions": 416, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/5495fab363f4588fd24d1fe715a17a8796bcb90a/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5495fab363f4588fd24d1fe715a17a8796bcb90a/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=5495fab363f4588fd24d1fe715a17a8796bcb90a", "patch": "@@ -1,416 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::hir::def_id::DefId;\n-use rustc::middle::privacy::AccessLevels;\n-use rustc::util::nodemap::DefIdSet;\n-use std::cmp;\n-use std::mem;\n-use std::string::String;\n-use std::usize;\n-\n-use clean::{self, Attributes, GetDefId};\n-use clean::Item;\n-use plugins;\n-use fold;\n-use fold::DocFolder;\n-use fold::FoldItem::Strip;\n-\n-/// Strip items marked `#[doc(hidden)]`\n-pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n-    let mut retained = DefIdSet();\n-\n-    // strip all #[doc(hidden)] items\n-    let krate = {\n-        struct Stripper<'a> {\n-            retained: &'a mut DefIdSet,\n-            update_retained: bool,\n-        }\n-        impl<'a> fold::DocFolder for Stripper<'a> {\n-            fn fold_item(&mut self, i: Item) -> Option<Item> {\n-                if i.attrs.list(\"doc\").has_word(\"hidden\") {\n-                    debug!(\"found one in strip_hidden; removing\");\n-                    // use a dedicated hidden item for given item type if any\n-                    match i.inner {\n-                        clean::StructFieldItem(..) | clean::ModuleItem(..) => {\n-                            // We need to recurse into stripped modules to\n-                            // strip things like impl methods but when doing so\n-                            // we must not add any items to the `retained` set.\n-                            let old = mem::replace(&mut self.update_retained, false);\n-                            let ret = Strip(self.fold_item_recur(i).unwrap()).fold();\n-                            self.update_retained = old;\n-                            return ret;\n-                        }\n-                        _ => return None,\n-                    }\n-                } else {\n-                    if self.update_retained {\n-                        self.retained.insert(i.def_id);\n-                    }\n-                }\n-                self.fold_item_recur(i)\n-            }\n-        }\n-        let mut stripper = Stripper{ retained: &mut retained, update_retained: true };\n-        stripper.fold_crate(krate)\n-    };\n-\n-    // strip all impls referencing stripped items\n-    let mut stripper = ImplStripper { retained: &retained };\n-    stripper.fold_crate(krate)\n-}\n-\n-/// Strip private items from the point of view of a crate or externally from a\n-/// crate, specified by the `xcrate` flag.\n-pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n-    // This stripper collects all *retained* nodes.\n-    let mut retained = DefIdSet();\n-    let access_levels = krate.access_levels.clone();\n-\n-    // strip all private items\n-    {\n-        let mut stripper = Stripper {\n-            retained: &mut retained,\n-            access_levels: &access_levels,\n-            update_retained: true,\n-        };\n-        krate = ImportStripper.fold_crate(stripper.fold_crate(krate));\n-    }\n-\n-    // strip all impls referencing private items\n-    let mut stripper = ImplStripper { retained: &retained };\n-    stripper.fold_crate(krate)\n-}\n-\n-struct Stripper<'a> {\n-    retained: &'a mut DefIdSet,\n-    access_levels: &'a AccessLevels<DefId>,\n-    update_retained: bool,\n-}\n-\n-impl<'a> fold::DocFolder for Stripper<'a> {\n-    fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        match i.inner {\n-            clean::StrippedItem(..) => {\n-                // We need to recurse into stripped modules to strip things\n-                // like impl methods but when doing so we must not add any\n-                // items to the `retained` set.\n-                let old = mem::replace(&mut self.update_retained, false);\n-                let ret = self.fold_item_recur(i);\n-                self.update_retained = old;\n-                return ret;\n-            }\n-            // These items can all get re-exported\n-            clean::TypedefItem(..) | clean::StaticItem(..) |\n-            clean::StructItem(..) | clean::EnumItem(..) |\n-            clean::TraitItem(..) | clean::FunctionItem(..) |\n-            clean::VariantItem(..) | clean::MethodItem(..) |\n-            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n-            clean::ConstantItem(..) | clean::UnionItem(..) => {\n-                if i.def_id.is_local() {\n-                    if !self.access_levels.is_exported(i.def_id) {\n-                        return None;\n-                    }\n-                }\n-            }\n-\n-            clean::StructFieldItem(..) => {\n-                if i.visibility != Some(clean::Public) {\n-                    return Strip(i).fold();\n-                }\n-            }\n-\n-            clean::ModuleItem(..) => {\n-                if i.def_id.is_local() && i.visibility != Some(clean::Public) {\n-                    let old = mem::replace(&mut self.update_retained, false);\n-                    let ret = Strip(self.fold_item_recur(i).unwrap()).fold();\n-                    self.update_retained = old;\n-                    return ret;\n-                }\n-            }\n-\n-            // handled in the `strip-priv-imports` pass\n-            clean::ExternCrateItem(..) | clean::ImportItem(..) => {}\n-\n-            clean::DefaultImplItem(..) | clean::ImplItem(..) => {}\n-\n-            // tymethods/macros have no control over privacy\n-            clean::MacroItem(..) | clean::TyMethodItem(..) => {}\n-\n-            // Primitives are never stripped\n-            clean::PrimitiveItem(..) => {}\n-\n-            // Associated consts and types are never stripped\n-            clean::AssociatedConstItem(..) |\n-            clean::AssociatedTypeItem(..) => {}\n-        }\n-\n-        let fastreturn = match i.inner {\n-            // nothing left to do for traits (don't want to filter their\n-            // methods out, visibility controlled by the trait)\n-            clean::TraitItem(..) => true,\n-\n-            // implementations of traits are always public.\n-            clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n-            // Struct variant fields have inherited visibility\n-            clean::VariantItem(clean::Variant {\n-                kind: clean::StructVariant(..)\n-            }) => true,\n-            _ => false,\n-        };\n-\n-        let i = if fastreturn {\n-            if self.update_retained {\n-                self.retained.insert(i.def_id);\n-            }\n-            return Some(i);\n-        } else {\n-            self.fold_item_recur(i)\n-        };\n-\n-        i.and_then(|i| {\n-            match i.inner {\n-                // emptied modules have no need to exist\n-                clean::ModuleItem(ref m)\n-                    if m.items.is_empty() &&\n-                       i.doc_value().is_none() => None,\n-                _ => {\n-                    if self.update_retained {\n-                        self.retained.insert(i.def_id);\n-                    }\n-                    Some(i)\n-                }\n-            }\n-        })\n-    }\n-}\n-\n-// This stripper discards all impls which reference stripped items\n-struct ImplStripper<'a> {\n-    retained: &'a DefIdSet\n-}\n-\n-impl<'a> fold::DocFolder for ImplStripper<'a> {\n-    fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        if let clean::ImplItem(ref imp) = i.inner {\n-            // emptied none trait impls can be stripped\n-            if imp.trait_.is_none() && imp.items.is_empty() {\n-                return None;\n-            }\n-            if let Some(did) = imp.for_.def_id() {\n-                if did.is_local() && !imp.for_.is_generic() &&\n-                    !self.retained.contains(&did)\n-                {\n-                    return None;\n-                }\n-            }\n-            if let Some(did) = imp.trait_.def_id() {\n-                if did.is_local() && !self.retained.contains(&did) {\n-                    return None;\n-                }\n-            }\n-        }\n-        self.fold_item_recur(i)\n-    }\n-}\n-\n-// This stripper discards all private import statements (`use`, `extern crate`)\n-struct ImportStripper;\n-impl fold::DocFolder for ImportStripper {\n-    fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        match i.inner {\n-            clean::ExternCrateItem(..) |\n-            clean::ImportItem(..) if i.visibility != Some(clean::Public) => None,\n-            _ => self.fold_item_recur(i)\n-        }\n-    }\n-}\n-\n-pub fn strip_priv_imports(krate: clean::Crate)  -> plugins::PluginResult {\n-    ImportStripper.fold_crate(krate)\n-}\n-\n-pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n-    struct CommentCleaner;\n-    impl fold::DocFolder for CommentCleaner {\n-        fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n-            let mut avec: Vec<clean::Attribute> = Vec::new();\n-            for attr in &i.attrs {\n-                match attr {\n-                    &clean::NameValue(ref x, ref s)\n-                            if \"doc\" == *x => {\n-                        avec.push(clean::NameValue(\"doc\".to_string(),\n-                                                   unindent(s)))\n-                    }\n-                    x => avec.push(x.clone())\n-                }\n-            }\n-            i.attrs = avec;\n-            self.fold_item_recur(i)\n-        }\n-    }\n-    let mut cleaner = CommentCleaner;\n-    let krate = cleaner.fold_crate(krate);\n-    krate\n-}\n-\n-pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n-    struct Collapser;\n-    impl fold::DocFolder for Collapser {\n-        fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n-            let mut docstr = String::new();\n-            for attr in &i.attrs {\n-                if let clean::NameValue(ref x, ref s) = *attr {\n-                    if \"doc\" == *x {\n-                        docstr.push_str(s);\n-                        docstr.push('\\n');\n-                    }\n-                }\n-            }\n-            let mut a: Vec<clean::Attribute> = i.attrs.iter().filter(|&a| match a {\n-                &clean::NameValue(ref x, _) if \"doc\" == *x => false,\n-                _ => true\n-            }).cloned().collect();\n-            if !docstr.is_empty() {\n-                a.push(clean::NameValue(\"doc\".to_string(), docstr));\n-            }\n-            i.attrs = a;\n-            self.fold_item_recur(i)\n-        }\n-    }\n-    let mut collapser = Collapser;\n-    let krate = collapser.fold_crate(krate);\n-    krate\n-}\n-\n-fn unindent(s: &str) -> String {\n-    let lines = s.lines().collect::<Vec<&str> >();\n-    let mut saw_first_line = false;\n-    let mut saw_second_line = false;\n-    let min_indent = lines.iter().fold(usize::MAX, |min_indent, line| {\n-\n-        // After we see the first non-whitespace line, look at\n-        // the line we have. If it is not whitespace, and therefore\n-        // part of the first paragraph, then ignore the indentation\n-        // level of the first line\n-        let ignore_previous_indents =\n-            saw_first_line &&\n-            !saw_second_line &&\n-            !line.chars().all(|c| c.is_whitespace());\n-\n-        let min_indent = if ignore_previous_indents {\n-            usize::MAX\n-        } else {\n-            min_indent\n-        };\n-\n-        if saw_first_line {\n-            saw_second_line = true;\n-        }\n-\n-        if line.chars().all(|c| c.is_whitespace()) {\n-            min_indent\n-        } else {\n-            saw_first_line = true;\n-            let mut whitespace = 0;\n-            line.chars().all(|char| {\n-                // Compare against either space or tab, ignoring whether they\n-                // are mixed or not\n-                if char == ' ' || char == '\\t' {\n-                    whitespace += 1;\n-                    true\n-                } else {\n-                    false\n-                }\n-            });\n-            cmp::min(min_indent, whitespace)\n-        }\n-    });\n-\n-    if !lines.is_empty() {\n-        let mut unindented = vec![ lines[0].trim().to_string() ];\n-        unindented.extend_from_slice(&lines[1..].iter().map(|&line| {\n-            if line.chars().all(|c| c.is_whitespace()) {\n-                line.to_string()\n-            } else {\n-                assert!(line.len() >= min_indent);\n-                line[min_indent..].to_string()\n-            }\n-        }).collect::<Vec<_>>());\n-        unindented.join(\"\\n\")\n-    } else {\n-        s.to_string()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod unindent_tests {\n-    use super::unindent;\n-\n-    #[test]\n-    fn should_unindent() {\n-        let s = \"    line1\\n    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_unindent_multiple_paragraphs() {\n-        let s = \"    line1\\n\\n    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\n\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_leave_multiple_indent_levels() {\n-        // Line 2 is indented another level beyond the\n-        // base indentation and should be preserved\n-        let s = \"    line1\\n\\n        line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\n\\n    line2\");\n-    }\n-\n-    #[test]\n-    fn should_ignore_first_line_indent() {\n-        // The first line of the first paragraph may not be indented as\n-        // far due to the way the doc string was written:\n-        //\n-        // #[doc = \"Start way over here\n-        //          and continue here\"]\n-        let s = \"line1\\n    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n-        let s = \"line1\\n\\n    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\n\\n    line2\");\n-    }\n-\n-    #[test]\n-    fn should_unindent_tabs() {\n-        let s = \"\\tline1\\n\\tline2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_trim_mixed_indentation() {\n-        let s = \"\\t    line1\\n\\t    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-\n-        let s = \"    \\tline1\\n    \\tline2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-    }\n-}"}, {"sha": "26be203ccee3708d76c940b4e5fe0f72d083a9ef", "filename": "src/librustdoc/passes/collapse_docs.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f1a3eb633dc6e5cafea2e67c121b8920defad28e/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1a3eb633dc6e5cafea2e67c121b8920defad28e/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs?ref=f1a3eb633dc6e5cafea2e67c121b8920defad28e", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::string::String;\n+\n+use clean::{self, Item};\n+use plugins;\n+use fold;\n+use fold::DocFolder;\n+\n+pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n+    struct Collapser;\n+    impl fold::DocFolder for Collapser {\n+        fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n+            let mut docstr = String::new();\n+            for attr in &i.attrs {\n+                if let clean::NameValue(ref x, ref s) = *attr {\n+                    if \"doc\" == *x {\n+                        docstr.push_str(s);\n+                        docstr.push('\\n');\n+                    }\n+                }\n+            }\n+            let mut a: Vec<clean::Attribute> = i.attrs.iter().filter(|&a| match a {\n+                &clean::NameValue(ref x, _) if \"doc\" == *x => false,\n+                _ => true\n+            }).cloned().collect();\n+            if !docstr.is_empty() {\n+                a.push(clean::NameValue(\"doc\".to_string(), docstr));\n+            }\n+            i.attrs = a;\n+            self.fold_item_recur(i)\n+        }\n+    }\n+    let mut collapser = Collapser;\n+    let krate = collapser.fold_crate(krate);\n+    krate\n+}"}, {"sha": "62a6cad0f1b0b74d9721f9700c867cb49b2fed42", "filename": "src/librustdoc/passes/mod.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/f1a3eb633dc6e5cafea2e67c121b8920defad28e/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1a3eb633dc6e5cafea2e67c121b8920defad28e/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=f1a3eb633dc6e5cafea2e67c121b8920defad28e", "patch": "@@ -0,0 +1,177 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir::def_id::DefId;\n+use rustc::middle::privacy::AccessLevels;\n+use rustc::util::nodemap::DefIdSet;\n+use std::mem;\n+\n+use clean::{self, GetDefId, Item};\n+use fold;\n+use fold::FoldItem::Strip;\n+\n+mod collapse_docs;\n+pub use self::collapse_docs::collapse_docs;\n+\n+mod strip_hidden;\n+pub use self::strip_hidden::strip_hidden;\n+\n+mod strip_private;\n+pub use self::strip_private::strip_private;\n+\n+mod strip_priv_imports;\n+pub use self::strip_priv_imports::strip_priv_imports;\n+\n+mod unindent_comments;\n+pub use self::unindent_comments::unindent_comments;\n+\n+struct Stripper<'a> {\n+    retained: &'a mut DefIdSet,\n+    access_levels: &'a AccessLevels<DefId>,\n+    update_retained: bool,\n+}\n+\n+impl<'a> fold::DocFolder for Stripper<'a> {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        match i.inner {\n+            clean::StrippedItem(..) => {\n+                // We need to recurse into stripped modules to strip things\n+                // like impl methods but when doing so we must not add any\n+                // items to the `retained` set.\n+                let old = mem::replace(&mut self.update_retained, false);\n+                let ret = self.fold_item_recur(i);\n+                self.update_retained = old;\n+                return ret;\n+            }\n+            // These items can all get re-exported\n+            clean::TypedefItem(..) | clean::StaticItem(..) |\n+            clean::StructItem(..) | clean::EnumItem(..) |\n+            clean::TraitItem(..) | clean::FunctionItem(..) |\n+            clean::VariantItem(..) | clean::MethodItem(..) |\n+            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n+            clean::ConstantItem(..) | clean::UnionItem(..) => {\n+                if i.def_id.is_local() {\n+                    if !self.access_levels.is_exported(i.def_id) {\n+                        return None;\n+                    }\n+                }\n+            }\n+\n+            clean::StructFieldItem(..) => {\n+                if i.visibility != Some(clean::Public) {\n+                    return Strip(i).fold();\n+                }\n+            }\n+\n+            clean::ModuleItem(..) => {\n+                if i.def_id.is_local() && i.visibility != Some(clean::Public) {\n+                    let old = mem::replace(&mut self.update_retained, false);\n+                    let ret = Strip(self.fold_item_recur(i).unwrap()).fold();\n+                    self.update_retained = old;\n+                    return ret;\n+                }\n+            }\n+\n+            // handled in the `strip-priv-imports` pass\n+            clean::ExternCrateItem(..) | clean::ImportItem(..) => {}\n+\n+            clean::DefaultImplItem(..) | clean::ImplItem(..) => {}\n+\n+            // tymethods/macros have no control over privacy\n+            clean::MacroItem(..) | clean::TyMethodItem(..) => {}\n+\n+            // Primitives are never stripped\n+            clean::PrimitiveItem(..) => {}\n+\n+            // Associated consts and types are never stripped\n+            clean::AssociatedConstItem(..) |\n+            clean::AssociatedTypeItem(..) => {}\n+        }\n+\n+        let fastreturn = match i.inner {\n+            // nothing left to do for traits (don't want to filter their\n+            // methods out, visibility controlled by the trait)\n+            clean::TraitItem(..) => true,\n+\n+            // implementations of traits are always public.\n+            clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n+            // Struct variant fields have inherited visibility\n+            clean::VariantItem(clean::Variant {\n+                kind: clean::StructVariant(..)\n+            }) => true,\n+            _ => false,\n+        };\n+\n+        let i = if fastreturn {\n+            if self.update_retained {\n+                self.retained.insert(i.def_id);\n+            }\n+            return Some(i);\n+        } else {\n+            self.fold_item_recur(i)\n+        };\n+\n+        i.and_then(|i| {\n+            match i.inner {\n+                // emptied modules have no need to exist\n+                clean::ModuleItem(ref m)\n+                    if m.items.is_empty() &&\n+                       i.doc_value().is_none() => None,\n+                _ => {\n+                    if self.update_retained {\n+                        self.retained.insert(i.def_id);\n+                    }\n+                    Some(i)\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+// This stripper discards all impls which reference stripped items\n+struct ImplStripper<'a> {\n+    retained: &'a DefIdSet\n+}\n+\n+impl<'a> fold::DocFolder for ImplStripper<'a> {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        if let clean::ImplItem(ref imp) = i.inner {\n+            // emptied none trait impls can be stripped\n+            if imp.trait_.is_none() && imp.items.is_empty() {\n+                return None;\n+            }\n+            if let Some(did) = imp.for_.def_id() {\n+                if did.is_local() && !imp.for_.is_generic() &&\n+                    !self.retained.contains(&did)\n+                {\n+                    return None;\n+                }\n+            }\n+            if let Some(did) = imp.trait_.def_id() {\n+                if did.is_local() && !self.retained.contains(&did) {\n+                    return None;\n+                }\n+            }\n+        }\n+        self.fold_item_recur(i)\n+    }\n+}\n+\n+// This stripper discards all private import statements (`use`, `extern crate`)\n+struct ImportStripper;\n+impl fold::DocFolder for ImportStripper {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        match i.inner {\n+            clean::ExternCrateItem(..) |\n+            clean::ImportItem(..) if i.visibility != Some(clean::Public) => None,\n+            _ => self.fold_item_recur(i)\n+        }\n+    }\n+}"}, {"sha": "5a505ba739583a7ff9ac1afedabe93eaa557f87b", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f1a3eb633dc6e5cafea2e67c121b8920defad28e/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1a3eb633dc6e5cafea2e67c121b8920defad28e/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=f1a3eb633dc6e5cafea2e67c121b8920defad28e", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::util::nodemap::DefIdSet;\n+use std::mem;\n+\n+use clean::{self, Attributes};\n+use clean::Item;\n+use plugins;\n+use fold;\n+use fold::DocFolder;\n+use fold::FoldItem::Strip;\n+use passes::ImplStripper;\n+\n+/// Strip items marked `#[doc(hidden)]`\n+pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n+    let mut retained = DefIdSet();\n+\n+    // strip all #[doc(hidden)] items\n+    let krate = {\n+        struct Stripper<'a> {\n+            retained: &'a mut DefIdSet,\n+            update_retained: bool,\n+        }\n+        impl<'a> fold::DocFolder for Stripper<'a> {\n+            fn fold_item(&mut self, i: Item) -> Option<Item> {\n+                if i.attrs.list(\"doc\").has_word(\"hidden\") {\n+                    debug!(\"found one in strip_hidden; removing\");\n+                    // use a dedicated hidden item for given item type if any\n+                    match i.inner {\n+                        clean::StructFieldItem(..) | clean::ModuleItem(..) => {\n+                            // We need to recurse into stripped modules to\n+                            // strip things like impl methods but when doing so\n+                            // we must not add any items to the `retained` set.\n+                            let old = mem::replace(&mut self.update_retained, false);\n+                            let ret = Strip(self.fold_item_recur(i).unwrap()).fold();\n+                            self.update_retained = old;\n+                            return ret;\n+                        }\n+                        _ => return None,\n+                    }\n+                } else {\n+                    if self.update_retained {\n+                        self.retained.insert(i.def_id);\n+                    }\n+                }\n+                self.fold_item_recur(i)\n+            }\n+        }\n+        let mut stripper = Stripper{ retained: &mut retained, update_retained: true };\n+        stripper.fold_crate(krate)\n+    };\n+\n+    // strip all impls referencing stripped items\n+    let mut stripper = ImplStripper { retained: &retained };\n+    stripper.fold_crate(krate)\n+}"}, {"sha": "91f8be43c281a629de133d6de245e973fc35191c", "filename": "src/librustdoc/passes/strip_priv_imports.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f1a3eb633dc6e5cafea2e67c121b8920defad28e/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1a3eb633dc6e5cafea2e67c121b8920defad28e/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs?ref=f1a3eb633dc6e5cafea2e67c121b8920defad28e", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use clean;\n+use fold::DocFolder;\n+use plugins;\n+use passes::ImportStripper;\n+\n+pub fn strip_priv_imports(krate: clean::Crate)  -> plugins::PluginResult {\n+    ImportStripper.fold_crate(krate)\n+}"}, {"sha": "acd735739e4887520b3c36a605f487239d6a7de8", "filename": "src/librustdoc/passes/strip_private.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f1a3eb633dc6e5cafea2e67c121b8920defad28e/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1a3eb633dc6e5cafea2e67c121b8920defad28e/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=f1a3eb633dc6e5cafea2e67c121b8920defad28e", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::util::nodemap::DefIdSet;\n+\n+use clean;\n+use plugins;\n+use fold::DocFolder;\n+use passes::{ImplStripper, ImportStripper, Stripper};\n+\n+/// Strip private items from the point of view of a crate or externally from a\n+/// crate, specified by the `xcrate` flag.\n+pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n+    // This stripper collects all *retained* nodes.\n+    let mut retained = DefIdSet();\n+    let access_levels = krate.access_levels.clone();\n+\n+    // strip all private items\n+    {\n+        let mut stripper = Stripper {\n+            retained: &mut retained,\n+            access_levels: &access_levels,\n+            update_retained: true,\n+        };\n+        krate = ImportStripper.fold_crate(stripper.fold_crate(krate));\n+    }\n+\n+    // strip all impls referencing private items\n+    let mut stripper = ImplStripper { retained: &retained };\n+    stripper.fold_crate(krate)\n+}"}, {"sha": "343a5cfd5f6e38215014797d808b43958f5e895d", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/f1a3eb633dc6e5cafea2e67c121b8920defad28e/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1a3eb633dc6e5cafea2e67c121b8920defad28e/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=f1a3eb633dc6e5cafea2e67c121b8920defad28e", "patch": "@@ -0,0 +1,166 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cmp;\n+use std::string::String;\n+use std::usize;\n+\n+use clean::{self, Item};\n+use plugins;\n+use fold::{self, DocFolder};\n+\n+pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n+    struct CommentCleaner;\n+    impl fold::DocFolder for CommentCleaner {\n+        fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n+            let mut avec: Vec<clean::Attribute> = Vec::new();\n+            for attr in &i.attrs {\n+                match attr {\n+                    &clean::NameValue(ref x, ref s)\n+                            if \"doc\" == *x => {\n+                        avec.push(clean::NameValue(\"doc\".to_string(),\n+                                                   unindent(s)))\n+                    }\n+                    x => avec.push(x.clone())\n+                }\n+            }\n+            i.attrs = avec;\n+            self.fold_item_recur(i)\n+        }\n+    }\n+    let mut cleaner = CommentCleaner;\n+    let krate = cleaner.fold_crate(krate);\n+    krate\n+}\n+\n+fn unindent(s: &str) -> String {\n+    let lines = s.lines().collect::<Vec<&str> >();\n+    let mut saw_first_line = false;\n+    let mut saw_second_line = false;\n+    let min_indent = lines.iter().fold(usize::MAX, |min_indent, line| {\n+\n+        // After we see the first non-whitespace line, look at\n+        // the line we have. If it is not whitespace, and therefore\n+        // part of the first paragraph, then ignore the indentation\n+        // level of the first line\n+        let ignore_previous_indents =\n+            saw_first_line &&\n+            !saw_second_line &&\n+            !line.chars().all(|c| c.is_whitespace());\n+\n+        let min_indent = if ignore_previous_indents {\n+            usize::MAX\n+        } else {\n+            min_indent\n+        };\n+\n+        if saw_first_line {\n+            saw_second_line = true;\n+        }\n+\n+        if line.chars().all(|c| c.is_whitespace()) {\n+            min_indent\n+        } else {\n+            saw_first_line = true;\n+            let mut whitespace = 0;\n+            line.chars().all(|char| {\n+                // Compare against either space or tab, ignoring whether they\n+                // are mixed or not\n+                if char == ' ' || char == '\\t' {\n+                    whitespace += 1;\n+                    true\n+                } else {\n+                    false\n+                }\n+            });\n+            cmp::min(min_indent, whitespace)\n+        }\n+    });\n+\n+    if !lines.is_empty() {\n+        let mut unindented = vec![ lines[0].trim().to_string() ];\n+        unindented.extend_from_slice(&lines[1..].iter().map(|&line| {\n+            if line.chars().all(|c| c.is_whitespace()) {\n+                line.to_string()\n+            } else {\n+                assert!(line.len() >= min_indent);\n+                line[min_indent..].to_string()\n+            }\n+        }).collect::<Vec<_>>());\n+        unindented.join(\"\\n\")\n+    } else {\n+        s.to_string()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod unindent_tests {\n+    use super::unindent;\n+\n+    #[test]\n+    fn should_unindent() {\n+        let s = \"    line1\\n    line2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\nline2\");\n+    }\n+\n+    #[test]\n+    fn should_unindent_multiple_paragraphs() {\n+        let s = \"    line1\\n\\n    line2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\n\\nline2\");\n+    }\n+\n+    #[test]\n+    fn should_leave_multiple_indent_levels() {\n+        // Line 2 is indented another level beyond the\n+        // base indentation and should be preserved\n+        let s = \"    line1\\n\\n        line2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\n\\n    line2\");\n+    }\n+\n+    #[test]\n+    fn should_ignore_first_line_indent() {\n+        // The first line of the first paragraph may not be indented as\n+        // far due to the way the doc string was written:\n+        //\n+        // #[doc = \"Start way over here\n+        //          and continue here\"]\n+        let s = \"line1\\n    line2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\nline2\");\n+    }\n+\n+    #[test]\n+    fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n+        let s = \"line1\\n\\n    line2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\n\\n    line2\");\n+    }\n+\n+    #[test]\n+    fn should_unindent_tabs() {\n+        let s = \"\\tline1\\n\\tline2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\nline2\");\n+    }\n+\n+    #[test]\n+    fn should_trim_mixed_indentation() {\n+        let s = \"\\t    line1\\n\\t    line2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\nline2\");\n+\n+        let s = \"    \\tline1\\n    \\tline2\".to_string();\n+        let r = unindent(&s);\n+        assert_eq!(r, \"line1\\nline2\");\n+    }\n+}"}]}