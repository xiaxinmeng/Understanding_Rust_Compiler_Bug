{"sha": "63cf381ca1b5246c7f54ad701e4792e0a11edaf2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzY2YzODFjYTFiNTI0NmM3ZjU0YWQ3MDFlNDc5MmUwYTExZWRhZjI=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-05-17T04:58:52Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-05-17T04:58:52Z"}, "message": "stdlib: Remove transitional extfmt.RT module", "tree": {"sha": "266cfb1000aeea2debf83c49ff52a2617829504f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/266cfb1000aeea2debf83c49ff52a2617829504f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63cf381ca1b5246c7f54ad701e4792e0a11edaf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63cf381ca1b5246c7f54ad701e4792e0a11edaf2", "html_url": "https://github.com/rust-lang/rust/commit/63cf381ca1b5246c7f54ad701e4792e0a11edaf2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63cf381ca1b5246c7f54ad701e4792e0a11edaf2/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbfd8552ab1cd4931e1f4afd9c480dfb35c99da8", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbfd8552ab1cd4931e1f4afd9c480dfb35c99da8", "html_url": "https://github.com/rust-lang/rust/commit/fbfd8552ab1cd4931e1f4afd9c480dfb35c99da8"}], "stats": {"total": 259, "additions": 3, "deletions": 256}, "files": [{"sha": "876bf1b7f9046d3385faa32617ec7477030eb2d0", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 3, "deletions": 256, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/63cf381ca1b5246c7f54ad701e4792e0a11edaf2/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63cf381ca1b5246c7f54ad701e4792e0a11edaf2/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=63cf381ca1b5246c7f54ad701e4792e0a11edaf2", "patch": "@@ -17,10 +17,10 @@ import option::none;\n import option::some;\n \n /*\n- * We have a CT (compile-time) module that parses format strings into a\n+ * We have a 'ct' (compile-time) module that parses format strings into a\n  * sequence of conversions. From those conversions AST fragments are built\n- * that call into properly-typed functions in the RT (run-time) module.  Each\n- * of those run-time conversion functions accepts another conversion\n+ * that call into properly-typed functions in the 'rt' (run-time) module.\n+ * Each of those run-time conversion functions accepts another conversion\n  * description that specifies how to format its output.\n  *\n  * The building of the AST is currently done in a module inside the compiler,\n@@ -558,259 +558,6 @@ mod rt {\n     }\n }\n \n-// FIXME: This is a temporary duplication of the rt mod that only\n-// needs to exist to accomodate the stage0 compiler until the next snapshot\n-mod RT {\n-    tag flag {\n-        flag_left_justify;\n-        flag_left_zero_pad;\n-        flag_space_for_sign;\n-        flag_sign_always;\n-        flag_alternate;\n-        // FIXME: This is a hack to avoid creating 0-length vec exprs,\n-        // which have some difficulty typechecking currently. See\n-        // comments in front::extfmt::make_flags\n-        flag_none;\n-    }\n-\n-    tag count {\n-        count_is(int);\n-        count_implied;\n-    }\n-\n-    tag ty {\n-        ty_default;\n-        ty_bits;\n-        ty_hex_upper;\n-        ty_hex_lower;\n-        ty_octal;\n-    }\n-\n-    // FIXME: May not want to use a vector here for flags;\n-    // instead just use a bool per flag\n-    type conv = rec(vec[flag] flags,\n-                    count width,\n-                    count precision,\n-                    ty ty);\n-\n-    fn conv_int(&conv cv, int i) -> str {\n-        auto radix = 10u;\n-        auto prec = get_int_precision(cv);\n-        auto s = int_to_str_prec(i, radix, prec);\n-        if (0 <= i) {\n-            if (have_flag(cv.flags, flag_sign_always)) {\n-                s = \"+\" + s;\n-            } else if (have_flag(cv.flags, flag_space_for_sign)) {\n-                s = \" \" + s;\n-            }\n-        }\n-        ret pad(cv, s, pad_signed);\n-    }\n-\n-    fn conv_uint(&conv cv, uint u) -> str {\n-        auto prec = get_int_precision(cv);\n-        auto res;\n-        alt (cv.ty) {\n-            case (ty_default) {\n-                res = uint_to_str_prec(u, 10u, prec);\n-            }\n-            case (ty_hex_lower) {\n-                res = uint_to_str_prec(u, 16u, prec);\n-            }\n-            case (ty_hex_upper) {\n-                res = _str::to_upper(uint_to_str_prec(u, 16u, prec));\n-            }\n-            case (ty_bits) {\n-                res = uint_to_str_prec(u, 2u, prec);\n-            }\n-            case (ty_octal) {\n-                res = uint_to_str_prec(u, 8u, prec);\n-            }\n-        }\n-        ret pad(cv, res, pad_unsigned);\n-    }\n-\n-    fn conv_bool(&conv cv, bool b) -> str {\n-        auto s;\n-        if (b) {\n-            s = \"true\";\n-        } else {\n-            s = \"false\";\n-        }\n-        // run the boolean conversion through the string conversion logic,\n-        // giving it the same rules for precision, etc.\n-        ret conv_str(cv, s);\n-    }\n-\n-    fn conv_char(&conv cv, char c) -> str {\n-        ret pad(cv, _str::from_char(c), pad_nozero);\n-    }\n-\n-    fn conv_str(&conv cv, str s) -> str {\n-        auto unpadded = s;\n-        alt (cv.precision) {\n-            case (count_implied) {\n-            }\n-            case (count_is(?max)) {\n-                // For strings, precision is the maximum characters displayed\n-                if (max as uint < _str::char_len(s)) {\n-                    // FIXME: substr works on bytes, not chars!\n-                    unpadded = _str::substr(s, 0u, max as uint);\n-                }\n-            }\n-        }\n-        ret pad(cv, unpadded, pad_nozero);\n-    }\n-\n-    // Convert an int to string with minimum number of digits. If precision is\n-    // 0 and num is 0 then the result is the empty string.\n-    fn int_to_str_prec(int num, uint radix, uint prec) -> str {\n-        if (num < 0) {\n-            ret \"-\" + uint_to_str_prec((-num) as uint, radix, prec);\n-        } else {\n-            ret uint_to_str_prec(num as uint, radix, prec);\n-        }\n-    }\n-\n-    // Convert a uint to string with a minimum number of digits.  If precision\n-    // is 0 and num is 0 then the result is the empty string. Could move this\n-    // to _uint: but it doesn't seem all that useful.\n-    fn uint_to_str_prec(uint num, uint radix, uint prec) -> str {\n-        auto s;\n-\n-        if (prec == 0u && num == 0u) {\n-            s = \"\";\n-        } else {\n-            s = _uint::to_str(num, radix);\n-            auto len = _str::char_len(s);\n-            if (len < prec) {\n-                auto diff = prec - len;\n-                auto pad = str_init_elt('0', diff);\n-                s = pad + s;\n-            }\n-        }\n-\n-        ret s;\n-    }\n-\n-    fn get_int_precision(&conv cv) -> uint {\n-        alt (cv.precision) {\n-            case (count_is(?c)) {\n-                ret c as uint;\n-            }\n-            case (count_implied) {\n-                ret 1u;\n-            }\n-        }\n-    }\n-\n-    // FIXME: This might be useful in _str: but needs to be utf8 safe first\n-    fn str_init_elt(char c, uint n_elts) -> str {\n-        auto svec = _vec::init_elt[u8](c as u8, n_elts);\n-        // FIXME: Using unsafe_from_bytes because rustboot\n-        // can't figure out the is_utf8 predicate on from_bytes?\n-        ret _str::unsafe_from_bytes(svec);\n-    }\n-\n-    tag pad_mode {\n-        pad_signed;\n-        pad_unsigned;\n-        pad_nozero;\n-    }\n-\n-    fn pad(&conv cv, str s, pad_mode mode) -> str {\n-        auto uwidth;\n-        alt (cv.width) {\n-            case (count_implied) {\n-                ret s;\n-            }\n-            case (count_is(?width)) {\n-                // FIXME: Maybe width should be uint\n-                uwidth = width as uint;\n-            }\n-        }\n-\n-        auto strlen = _str::char_len(s);\n-        if (uwidth <= strlen) {\n-            ret s;\n-        }\n-\n-        auto padchar = ' ';\n-        auto diff = uwidth - strlen;\n-        if (have_flag(cv.flags, flag_left_justify)) {\n-            auto padstr = str_init_elt(padchar, diff);\n-            ret s + padstr;\n-        }\n-\n-        auto might_zero_pad = false;\n-        auto signed = false;\n-\n-        alt (mode) {\n-            case (pad_nozero) {\n-                // fallthrough\n-            }\n-            case (pad_signed) {\n-                might_zero_pad = true;\n-                signed = true;\n-            }\n-            case (pad_unsigned) {\n-                might_zero_pad = true;\n-            }\n-        }\n-\n-        fn have_precision(&conv cv) -> bool {\n-            alt (cv.precision) {\n-                case (count_implied) {\n-                    ret false;\n-                }\n-                case (_) {\n-                    ret true;\n-                }\n-            }\n-        }\n-\n-        auto zero_padding = false;\n-        if (might_zero_pad\n-            && have_flag(cv.flags, flag_left_zero_pad)\n-            && !have_precision(cv)) {\n-\n-            padchar = '0';\n-            zero_padding = true;\n-        }\n-\n-        auto padstr = str_init_elt(padchar, diff);\n-\n-        // This is completely heinous. If we have a signed value then\n-        // potentially rip apart the intermediate result and insert some\n-        // zeros. It may make sense to convert zero padding to a precision\n-        // instead.\n-        if (signed\n-            && zero_padding\n-            && _str::byte_len(s) > 0u) {\n-\n-            auto head = s.(0);\n-            if (head == '+' as u8\n-                || head == '-' as u8\n-                || head == ' ' as u8) {\n-\n-                auto headstr = _str::unsafe_from_bytes([head]);\n-                auto bytelen = _str::byte_len(s);\n-                auto numpart = _str::substr(s, 1u, bytelen - 1u);\n-                ret headstr + padstr + numpart;\n-            }\n-        }\n-        ret padstr + s;\n-    }\n-\n-    fn have_flag(vec[flag] flags, flag f) -> bool {\n-        for (flag candidate in flags) {\n-            if (candidate == f) {\n-                ret true;\n-            }\n-        }\n-        ret false;\n-    }\n-}\n \n // Local Variables:\n // mode: rust;"}]}