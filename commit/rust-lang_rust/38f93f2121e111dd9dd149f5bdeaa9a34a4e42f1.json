{"sha": "38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4ZjkzZjIxMjFlMTExZGQ5ZGQxNDlmNWJkZWFhOWEzNGE0ZTQyZjE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-01T17:48:00Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-01T17:48:00Z"}, "message": "wip---work on making rooting work properly", "tree": {"sha": "925194727d087ac4c82044ffb424ed69cafb1795", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/925194727d087ac4c82044ffb424ed69cafb1795"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1", "html_url": "https://github.com/rust-lang/rust/commit/38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3159335ac308d9e3a2d3ada3b9354bf160debbdc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3159335ac308d9e3a2d3ada3b9354bf160debbdc", "html_url": "https://github.com/rust-lang/rust/commit/3159335ac308d9e3a2d3ada3b9354bf160debbdc"}], "stats": {"total": 292, "additions": 175, "deletions": 117}, "files": [{"sha": "77b4eab1338655b708f74028c46aa9400bd67a12", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1", "patch": "@@ -200,6 +200,8 @@ impl Mul<T,T> for T {\n     #[inline(always)]\n     fn mul(&self, other: &T) -> T { *self * *other }\n }\n+\n+#[cfg(notest)]\n impl Quot<T,T> for T {\n     ///\n     /// Returns the integer quotient, truncated towards 0. As this behaviour reflects\n@@ -222,6 +224,8 @@ impl Quot<T,T> for T {\n     #[inline(always)]\n     fn quot(&self, other: &T) -> T { *self / *other }\n }\n+\n+#[cfg(notest)]\n impl Rem<T,T> for T {\n     ///\n     /// Returns the integer remainder after division, satisfying:"}, {"sha": "2d2044494686515e56d44ee2e81266783e4c98f3", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1", "patch": "@@ -165,10 +165,14 @@ impl Mul<T,T> for T {\n     #[inline(always)]\n     fn mul(&self, other: &T) -> T { *self * *other }\n }\n+\n+#[cfg(notest)]\n impl Quot<T,T> for T {\n     #[inline(always)]\n     fn quot(&self, other: &T) -> T { *self / *other }\n }\n+\n+#[cfg(notest)]\n impl Rem<T,T> for T {\n     #[inline(always)]\n     fn rem(&self, other: &T) -> T { *self % *other }"}, {"sha": "d0e3c2b06787f34621f7fe7e381bb89753bd8861", "filename": "src/libcore/unstable/lang.rs", "status": "modified", "additions": 56, "deletions": 11, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1", "patch": "@@ -10,6 +10,7 @@\n \n //! Runtime calls emitted by the compiler.\n \n+use uint;\n use cast::transmute;\n use libc::{c_char, c_uchar, c_void, size_t, uintptr_t, c_int, STDERR_FILENO};\n use managed::raw::BoxRepr;\n@@ -22,10 +23,9 @@ use task::rt::rust_get_task;\n #[allow(non_camel_case_types)]\n pub type rust_task = c_void;\n \n-#[cfg(target_word_size = \"32\")]\n-pub static FROZEN_BIT: uint = 0x80000000;\n-#[cfg(target_word_size = \"64\")]\n-pub static FROZEN_BIT: uint = 0x8000000000000000;\n+pub static FROZEN_BIT: uint = 1 << (uint::bits - 1);\n+pub static MUT_BIT: uint = 1 << (uint::bits - 2);\n+static ALL_BITS: uint = FROZEN_BIT | MUT_BIT;\n \n pub mod rustrt {\n     use unstable::lang::rust_task;\n@@ -196,21 +196,51 @@ pub unsafe fn borrow_as_imm(a: *u8) {\n     (*a).header.ref_count |= FROZEN_BIT;\n }\n \n+fn add_borrow_to_task_list(a: *mut BoxRepr, file: *c_char, line: size_t) {\n+    do swap_task_borrow_list |borrow_list| {\n+        let mut borrow_list = borrow_list;\n+        borrow_list.push(BorrowRecord {box: a, file: file, line: line});\n+        borrow_list\n+    }\n+}\n+\n #[cfg(not(stage0))]\n #[lang=\"borrow_as_imm\"]\n #[inline(always)]\n-pub unsafe fn borrow_as_imm(a: *u8, file: *c_char, line: size_t) {\n+pub unsafe fn borrow_as_imm(a: *u8, file: *c_char, line: size_t) -> uint {\n     let a: *mut BoxRepr = transmute(a);\n-    (*a).header.ref_count |= FROZEN_BIT;\n-    if ::rt::env::get().debug_borrows {\n-        do swap_task_borrow_list |borrow_list| {\n-            let mut borrow_list = borrow_list;\n-            borrow_list.push(BorrowRecord {box: a, file: file, line: line});\n-            borrow_list\n+\n+    let ref_count = (*a).header.ref_count;\n+    if (ref_count & MUT_BIT) != 0 {\n+        fail_borrowed(a, file, line);\n+    } else {\n+        (*a).header.ref_count |= FROZEN_BIT;\n+        if ::rt::env::get().debug_borrows {\n+            add_borrow_to_list(a, file, line);\n         }\n     }\n+    ref_count\n }\n \n+#[cfg(not(stage0))]\n+#[lang=\"borrow_as_mut\"]\n+#[inline(always)]\n+pub unsafe fn borrow_as_mut(a: *u8, file: *c_char, line: size_t) -> uint {\n+    let a: *mut BoxRepr = transmute(a);\n+\n+    let ref_count = (*a).header.ref_count;\n+    if (ref_count & (MUT_BIT|FROZEN_BIT)) != 0 {\n+        fail_borrowed(a, file, line);\n+    } else {\n+        (*a).header.ref_count |= (MUT_BIT|FROZEN_BIT);\n+        if ::rt::env::get().debug_borrows {\n+            add_borrow_to_list(a, file, line);\n+        }\n+    }\n+    ref_count\n+}\n+\n+#[cfg(stage0)]\n #[lang=\"return_to_mut\"]\n #[inline(always)]\n pub unsafe fn return_to_mut(a: *u8) {\n@@ -222,6 +252,21 @@ pub unsafe fn return_to_mut(a: *u8) {\n     }\n }\n \n+#[cfg(not(stage0))]\n+#[lang=\"return_to_mut\"]\n+#[inline(always)]\n+pub unsafe fn return_to_mut(a: *u8, old_ref_count: uint) {\n+    // Sometimes the box is null, if it is conditionally frozen.\n+    // See e.g. #4904.\n+    if !a.is_null() {\n+        let a: *mut BoxRepr = transmute(a);\n+\n+        let ref_count = (*a).header.ref_count & !ALL_BITS;\n+        let old_bits = old_ref_count & ALL_BITS;\n+        (*a).header.ref_count = ref_count | old_bits;\n+    }\n+}\n+\n #[cfg(stage0)]\n #[lang=\"check_not_borrowed\"]\n #[inline(always)]"}, {"sha": "0266b77997e7dda2a8ba0f1040254f914d79d11e", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1", "patch": "@@ -66,11 +66,12 @@ pub enum LangItem {\n     MallocFnLangItem,           // 28\n     FreeFnLangItem,             // 29\n     BorrowAsImmFnLangItem,      // 30\n-    ReturnToMutFnLangItem,      // 31\n-    CheckNotBorrowedFnLangItem, // 32\n-    StrDupUniqFnLangItem,       // 33\n+    BorrowAsMutFnLangItem,      // 31\n+    ReturnToMutFnLangItem,      // 32\n+    CheckNotBorrowedFnLangItem, // 33\n+    StrDupUniqFnLangItem,       // 34\n \n-    StartFnLangItem,            // 34\n+    StartFnLangItem,            // 35\n }\n \n pub struct LanguageItems {\n@@ -128,11 +129,12 @@ pub impl LanguageItems {\n             28 => \"malloc\",\n             29 => \"free\",\n             30 => \"borrow_as_imm\",\n-            31 => \"return_to_mut\",\n-            32 => \"check_not_borrowed\",\n-            33 => \"strdup_uniq\",\n+            31 => \"borrow_as_mut\",\n+            32 => \"return_to_mut\",\n+            33 => \"check_not_borrowed\",\n+            34 => \"strdup_uniq\",\n \n-            34 => \"start\",\n+            35 => \"start\",\n \n             _ => \"???\"\n         }\n@@ -237,6 +239,9 @@ pub impl LanguageItems {\n     pub fn borrow_as_imm_fn(&const self) -> def_id {\n         self.items[BorrowAsImmFnLangItem as uint].get()\n     }\n+    pub fn borrow_as_mut_fn(&const self) -> def_id {\n+        self.items[BorrowAsMutFnLangItem as uint].get()\n+    }\n     pub fn return_to_mut_fn(&const self) -> def_id {\n         self.items[ReturnToMutFnLangItem as uint].get()\n     }\n@@ -292,6 +297,7 @@ fn LanguageItemCollector(crate: @crate,\n     item_refs.insert(@~\"malloc\", MallocFnLangItem as uint);\n     item_refs.insert(@~\"free\", FreeFnLangItem as uint);\n     item_refs.insert(@~\"borrow_as_imm\", BorrowAsImmFnLangItem as uint);\n+    item_refs.insert(@~\"borrow_as_mut\", BorrowAsMutFnLangItem as uint);\n     item_refs.insert(@~\"return_to_mut\", ReturnToMutFnLangItem as uint);\n     item_refs.insert(@~\"check_not_borrowed\",\n                      CheckNotBorrowedFnLangItem as uint);"}, {"sha": "7738e97779971fde2b3121ece65b952ee097cd2f", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 16, "deletions": 49, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1", "patch": "@@ -991,63 +991,30 @@ pub fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     return pad_bcx.llbb;\n }\n \n-// Arranges for the value found in `*root_loc` to be dropped once the scope\n-// associated with `scope_id` exits.  This is used to keep boxes live when\n-// there are extant region pointers pointing at the interior.\n-//\n-// Note that `root_loc` is not the value itself but rather a pointer to the\n-// value.  Generally it in alloca'd value.  The reason for this is that the\n-// value is initialized in an inner block but may be freed in some outer\n-// block, so an SSA value that is valid in the inner block may not be valid in\n-// the outer block.  In fact, the inner block may not even execute.  Rather\n-// than generate the full SSA form, we just use an alloca'd value.\n-pub fn add_root_cleanup(bcx: block,\n-                        root_info: RootInfo,\n-                        root_loc: ValueRef,\n-                        ty: ty::t) {\n-\n-    debug!(\"add_root_cleanup(bcx=%s, \\\n-                             scope=%d, \\\n-                             freezes=%?, \\\n-                             root_loc=%s, \\\n-                             ty=%s)\",\n-           bcx.to_str(),\n-           root_info.scope,\n-           root_info.freeze,\n-           val_str(bcx.ccx().tn, root_loc),\n-           ppaux::ty_to_str(bcx.ccx().tcx, ty));\n-\n-    let bcx_scope = find_bcx_for_scope(bcx, root_info.scope);\n-    if root_info.freeze.is_some() {\n-        add_clean_frozen_root(bcx_scope, root_loc, ty);\n-    } else {\n-        add_clean_temp_mem(bcx_scope, root_loc, ty);\n-    }\n-\n-    fn find_bcx_for_scope(bcx: block, scope_id: ast::node_id) -> block {\n-        let mut bcx_sid = bcx;\n-        loop {\n-            bcx_sid = match bcx_sid.node_info {\n-              Some(NodeInfo { id, _ }) if id == scope_id => {\n+pub fn find_bcx_for_scope(bcx: block, scope_id: ast::node_id) -> block {\n+    let mut bcx_sid = bcx;\n+    loop {\n+        bcx_sid = match bcx_sid.node_info {\n+            Some(NodeInfo { id, _ }) if id == scope_id => {\n                 return bcx_sid\n               }\n \n-              // NOTE This is messier than it ought to be and not really right\n-              Some(NodeInfo { callee_id: Some(id), _ }) if id == scope_id => {\n-                return bcx_sid\n-              }\n+                // NOTE This is messier than it ought to be and not really right\n+                Some(NodeInfo { callee_id: Some(id), _ }) if id == scope_id => {\n+                    return bcx_sid\n+                }\n \n-              _ => {\n-                match bcx_sid.parent {\n-                  None => bcx.tcx().sess.bug(\n-                      fmt!(\"no enclosing scope with id %d\", scope_id)),\n-                  Some(bcx_par) => bcx_par\n+                _ => {\n+                    match bcx_sid.parent {\n+                        None => bcx.tcx().sess.bug(\n+                            fmt!(\"no enclosing scope with id %d\", scope_id)),\n+                        Some(bcx_par) => bcx_par\n+                    }\n                 }\n-              }\n             }\n         }\n     }\n-}\n+\n \n pub fn do_spill(bcx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_is_bot(t) {"}, {"sha": "d0da8a2e1ee744b7bb73b6b06c53e70be3ef256b", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1", "patch": "@@ -467,28 +467,40 @@ pub fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n         scope_clean_changed(scope_info);\n     }\n }\n-pub fn add_clean_frozen_root(bcx: block, val: ValueRef, t: ty::t) {\n-    debug!(\"add_clean_frozen_root(%s, %s, %s)\",\n-           bcx.to_str(), val_str(bcx.ccx().tn, val),\n-           t.repr(bcx.tcx()));\n-    let (root, rooted) = root_for_cleanup(bcx, val, t);\n-    let cleanup_type = cleanup_type(bcx.tcx(), t);\n+pub fn add_clean_return_to_mut(bcx: block,\n+                               frozen_val_ref: ValueRef,\n+                               bits_val_ref: ValueRef) {\n+    //! When an `@mut` has been frozen, we have to\n+    //! call the lang-item `return_to_mut` when the\n+    //! freeze goes out of scope. We need to pass\n+    //! in both the value which was frozen (`frozen_val`) and\n+    //! the value (`bits_val_ref`) which was returned when the\n+    //! box was frozen initially. Here, both `frozen_val_ref` and\n+    //! `bits_val_ref` are in fact pointers to stack slots.\n+\n+    debug!(\"add_clean_return_to_mut(%s, %s, %s)\",\n+           bcx.to_str(),\n+           val_str(bcx.ccx().tn, frozen_val_ref),\n+           val_str(bcx.ccx().tn, bits_val_ref));\n     do in_scope_cx(bcx) |scope_info| {\n         scope_info.cleanups.push(\n-            clean_temp(val, |bcx| {\n-                let bcx = callee::trans_lang_call(\n-                    bcx,\n-                    bcx.tcx().lang_items.return_to_mut_fn(),\n-                    ~[\n-                        build::Load(bcx,\n-                                    build::PointerCast(bcx,\n-                                                       root,\n-                                                       T_ptr(T_ptr(T_i8()))))\n-                    ],\n-                    expr::Ignore\n-                );\n-                glue::drop_ty_root(bcx, root, rooted, t)\n-            }, cleanup_type));\n+            clean_temp(\n+                frozen_val_ref,\n+                |bcx| {\n+                    callee::trans_lang_call(\n+                        bcx,\n+                        bcx.tcx().lang_items.return_to_mut_fn(),\n+                        ~[\n+                            build::Load(bcx,\n+                                        build::PointerCast(bcx,\n+                                                           frozen_val_ref,\n+                                                           T_ptr(T_ptr(T_i8())))),\n+                            build::Load(bcx, bits_val_ref)\n+                        ],\n+                        expr::Ignore\n+                    )\n+                },\n+                normal_exit_only));\n         scope_clean_changed(scope_info);\n     }\n }"}, {"sha": "94bff65843b24cc3bddf8a318d66506cf6bf48cf", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 46, "deletions": 27, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1", "patch": "@@ -87,7 +87,7 @@\n \n use lib;\n use lib::llvm::ValueRef;\n-use middle::borrowck::{RootInfo, root_map_key};\n+use middle::borrowck::{RootInfo, root_map_key, DynaImm, DynaMut};\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -517,7 +517,7 @@ pub impl Datum {\n         }\n     }\n \n-    fn root(&self, bcx: block, span: span, root_info: RootInfo) -> block {\n+    fn root(&self, mut bcx: block, span: span, root_info: RootInfo) -> block {\n         /*!\n          *\n          * In some cases, borrowck will decide that an @T/@[]/@str\n@@ -535,34 +535,53 @@ pub impl Datum {\n                      root_info.scope));\n         }\n \n+        // First, root the datum. Note that we must zero this value,\n+        // because sometimes we root on one path but not another.\n+        // See e.g. #4904.\n         let scratch = scratch_datum(bcx, self.ty, true);\n         self.copy_to_datum(bcx, INIT, scratch);\n-        add_root_cleanup(bcx, root_info, scratch.val, scratch.ty);\n-\n-        // If we need to freeze the box, do that now.\n-        if root_info.freeze.is_some() {\n-            // NOTE distinguish the two kinds of freezing here\n-\n-            let loc = bcx.sess().parse_sess.cm.lookup_char_pos(span.lo);\n-            let line = C_int(bcx.ccx(), loc.line as int);\n-            let filename_cstr = C_cstr(bcx.ccx(), @/*bad*/copy loc.file.name);\n-            let filename = PointerCast(bcx, filename_cstr, T_ptr(T_i8()));\n-\n-            callee::trans_lang_call(\n-                bcx,\n-                bcx.tcx().lang_items.borrow_as_imm_fn(),\n-                ~[\n-                    Load(bcx,\n-                         PointerCast(bcx,\n-                                     scratch.val,\n-                                     T_ptr(T_ptr(T_i8())))),\n-                    filename,\n-                    line\n-                ],\n-                expr::Ignore)\n-        } else {\n-            bcx\n+        let cleanup_bcx = find_bcx_for_scope(bcx, root_info.scope);\n+        add_clean_temp_mem(cleanup_bcx, scratch.val, scratch.ty);\n+\n+        // Now, consider also freezing it.\n+        match root_info.freeze {\n+            None => {}\n+            Some(freeze_kind) => {\n+                let loc = bcx.sess().parse_sess.cm.lookup_char_pos(span.lo);\n+                let line = C_int(bcx.ccx(), loc.line as int);\n+                let filename_cstr = C_cstr(bcx.ccx(), @/*bad*/copy loc.file.name);\n+                let filename = PointerCast(bcx, filename_cstr, T_ptr(T_i8()));\n+\n+                // in this case, we don't have to zero, because\n+                // scratch.val will be NULL should the cleanup get\n+                // called without the freezing actually occurring, and\n+                // return_to_mut checks for this condition.\n+                let scratch_bits = scratch_datum(bcx, ty::mk_uint(), false);\n+\n+                let freeze_did = match freeze_kind {\n+                    DynaImm => bcx.tcx().lang_items.borrow_as_imm_fn(),\n+                    DynaMut => bcx.tcx().lang_items.borrow_as_mut_fn(),\n+                };\n+\n+                bcx = callee::trans_lang_call(\n+                    bcx,\n+                    freeze_did,\n+                    ~[\n+                        Load(bcx,\n+                             PointerCast(bcx,\n+                                         scratch.val,\n+                                         T_ptr(T_ptr(T_i8())))),\n+                        filename,\n+                        line\n+                    ],\n+                    expr::SaveIn(scratch_bits.val));\n+\n+                add_clean_return_to_mut(\n+                    cleanup_bcx, scratch.val, scratch_bits.val);\n+            }\n         }\n+\n+        bcx\n     }\n \n     fn perform_write_guard(&self, bcx: block, span: span) -> block {"}, {"sha": "2c4ae242fb4832c959fec2a968262c1c352fbd0c", "filename": "src/test/compile-fail/borrowck-loan-rcvr-overloaded-op.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs?ref=38f93f2121e111dd9dd149f5bdeaa9a34a4e42f1", "patch": "@@ -40,10 +40,11 @@ fn b() {\n \n     let q = &mut p;\n \n-    p + 3;  // ok for pure fns\n+    p + 3;  //~ ERROR cannot borrow `p`\n     p.times(3); //~ ERROR cannot borrow `p`\n \n-    q.x += 1;\n+    *q + 3; // OK to use the new alias `q`\n+    q.x += 1; // and OK to mutate it\n }\n \n fn c() {"}]}