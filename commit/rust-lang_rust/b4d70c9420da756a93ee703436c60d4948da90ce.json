{"sha": "b4d70c9420da756a93ee703436c60d4948da90ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0ZDcwYzk0MjBkYTc1NmE5M2VlNzAzNDM2YzYwZDQ5NDhkYTkwY2U=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-08-01T08:15:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-08-01T08:15:29Z"}, "message": "Merge pull request #1900 from jayhardee9/luckily_literals_love_lints\n\nAdd lints for digit grouping.", "tree": {"sha": "f5545c6b05b6a5bd883239a1b9e5b3206686ad72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5545c6b05b6a5bd883239a1b9e5b3206686ad72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4d70c9420da756a93ee703436c60d4948da90ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4d70c9420da756a93ee703436c60d4948da90ce", "html_url": "https://github.com/rust-lang/rust/commit/b4d70c9420da756a93ee703436c60d4948da90ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4d70c9420da756a93ee703436c60d4948da90ce/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1c3870c4ea5f8720ddc6455227ee1b25b7c8964", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1c3870c4ea5f8720ddc6455227ee1b25b7c8964", "html_url": "https://github.com/rust-lang/rust/commit/a1c3870c4ea5f8720ddc6455227ee1b25b7c8964"}, {"sha": "9d8d2d87c33c4528a781c0c36597cb80d2b00be2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d8d2d87c33c4528a781c0c36597cb80d2b00be2", "html_url": "https://github.com/rust-lang/rust/commit/9d8d2d87c33c4528a781c0c36597cb80d2b00be2"}], "stats": {"total": 533, "additions": 524, "deletions": 9}, "files": [{"sha": "425fb4670b27849607f79f0ebd6b9bad42e2e2f2", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=b4d70c9420da756a93ee703436c60d4948da90ce", "patch": "@@ -101,6 +101,7 @@ pub mod large_enum_variant;\n pub mod len_zero;\n pub mod let_if_seq;\n pub mod lifetimes;\n+pub mod literal_digit_grouping;\n pub mod loops;\n pub mod map_clone;\n pub mod matches;\n@@ -316,6 +317,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box large_enum_variant::LargeEnumVariant::new(conf.enum_variant_size_threshold));\n     reg.register_late_lint_pass(box should_assert_eq::ShouldAssertEq);\n     reg.register_late_lint_pass(box needless_pass_by_value::NeedlessPassByValue);\n+    reg.register_early_lint_pass(box literal_digit_grouping::LiteralDigitGrouping);\n \n     reg.register_lint_group(\"clippy_restrictions\", vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -418,6 +420,9 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         let_if_seq::USELESS_LET_IF_SEQ,\n         lifetimes::NEEDLESS_LIFETIMES,\n         lifetimes::UNUSED_LIFETIMES,\n+        literal_digit_grouping::UNREADABLE_LITERAL,\n+        literal_digit_grouping::INCONSISTENT_DIGIT_GROUPING,\n+        literal_digit_grouping::LARGE_DIGIT_GROUPS,\n         loops::EMPTY_LOOP,\n         loops::EXPLICIT_COUNTER_LOOP,\n         loops::EXPLICIT_INTO_ITER_LOOP,"}, {"sha": "ec80e6968f85b45e7daf194290c0d47b534baba4", "filename": "clippy_lints/src/literal_digit_grouping.rs", "status": "added", "additions": 351, "deletions": 0, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_lints%2Fsrc%2Fliteral_digit_grouping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_lints%2Fsrc%2Fliteral_digit_grouping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_digit_grouping.rs?ref=b4d70c9420da756a93ee703436c60d4948da90ce", "patch": "@@ -0,0 +1,351 @@\n+//! Lints concerned with the grouping of digits with underscores in integral or\n+//! floating-point literal expressions.\n+\n+use rustc::lint::*;\n+use syntax::ast::*;\n+use syntax_pos;\n+use utils::{span_help_and_lint, snippet_opt, in_external_macro};\n+\n+/// **What it does:** Warns if a long integral or floating-point constant does\n+/// not contain underscores.\n+///\n+/// **Why is this bad?** Reading long numbers is difficult without separators.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+///\n+/// ```rust\n+/// 61864918973511\n+/// ```\n+declare_lint! {\n+    pub UNREADABLE_LITERAL,\n+    Warn,\n+    \"long integer literal without underscores\"\n+}\n+\n+/// **What it does:** Warns if an integral or floating-point constant is\n+/// grouped inconsistently with underscores.\n+///\n+/// **Why is this bad?** Readers may incorrectly interpret inconsistently\n+/// grouped digits.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+///\n+/// ```rust\n+/// 618_64_9189_73_511\n+/// ```\n+declare_lint! {\n+    pub INCONSISTENT_DIGIT_GROUPING,\n+    Warn,\n+    \"integer literals with digits grouped inconsistently\"\n+}\n+\n+/// **What it does:** Warns if the digits of an integral or floating-point\n+/// constant are grouped into groups that\n+/// are too large.\n+///\n+/// **Why is this bad?** Negatively impacts readability.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+///\n+/// ```rust\n+/// 6186491_8973511\n+/// ```\n+declare_lint! {\n+    pub LARGE_DIGIT_GROUPS,\n+    Warn,\n+    \"grouping digits into groups that are too large\"\n+}\n+\n+#[derive(Debug)]\n+enum Radix {\n+    Binary,\n+    Octal,\n+    Decimal,\n+    Hexadecimal,\n+}\n+\n+impl Radix {\n+    /// Return a reasonable digit group size for this radix.\n+    pub fn suggest_grouping(&self) -> usize {\n+        match *self {\n+            Radix::Binary | Radix::Hexadecimal => 4,\n+            Radix::Octal | Radix::Decimal => 3,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct DigitInfo<'a> {\n+    /// Characters of a literal between the radix prefix and type suffix.\n+    pub digits: &'a str,\n+    /// Which radix the literal was represented in.\n+    pub radix: Radix,\n+    /// The radix prefix, if present.\n+    pub prefix: Option<&'a str>,\n+    /// The type suffix, including preceding underscore if present.\n+    pub suffix: Option<&'a str>,\n+    /// True for floating-point literals.\n+    pub float: bool,\n+}\n+\n+impl<'a> DigitInfo<'a> {\n+    pub fn new(lit: &str, float: bool) -> DigitInfo {\n+        // Determine delimiter for radix prefix, if present, and radix.\n+        let radix = if lit.starts_with(\"0x\") {\n+            Radix::Hexadecimal\n+        } else if lit.starts_with(\"0b\") {\n+            Radix::Binary\n+        } else if lit.starts_with(\"0o\") {\n+            Radix::Octal\n+        } else {\n+            Radix::Decimal\n+        };\n+\n+        // Grab part of the literal after prefix, if present.\n+        let (prefix, sans_prefix) = if let Radix::Decimal = radix {\n+            (None, lit)\n+        } else {\n+            let (p, s) = lit.split_at(2);\n+            (Some(p), s)\n+        };\n+\n+        let mut last_d = '\\0';\n+        for (d_idx, d) in sans_prefix.char_indices() {\n+            if !float && (d == 'i' || d == 'u') || float && d == 'f' {\n+                let suffix_start = if last_d == '_' { d_idx - 1 } else { d_idx };\n+                let (digits, suffix) = sans_prefix.split_at(suffix_start);\n+                return DigitInfo {\n+                    digits: digits,\n+                    radix: radix,\n+                    prefix: prefix,\n+                    suffix: Some(suffix),\n+                    float: float,\n+                };\n+            }\n+            last_d = d\n+        }\n+\n+        // No suffix found\n+        DigitInfo {\n+            digits: sans_prefix,\n+            radix: radix,\n+            prefix: prefix,\n+            suffix: None,\n+            float: float,\n+        }\n+    }\n+\n+    /// Returns digits grouped in a sensible way.\n+    fn grouping_hint(&self) -> String {\n+        let group_size = self.radix.suggest_grouping();\n+        if self.digits.contains('.') {\n+            let mut parts = self.digits.split('.');\n+            let int_part_hint = parts\n+                .next()\n+                .unwrap()\n+                .chars()\n+                .rev()\n+                .filter(|&c| c != '_')\n+                .collect::<Vec<_>>()\n+                .chunks(group_size)\n+                .map(|chunk| chunk.into_iter().rev().collect())\n+                .rev()\n+                .collect::<Vec<String>>()\n+                .join(\"_\");\n+            let frac_part_hint = parts\n+                .next()\n+                .unwrap()\n+                .chars()\n+                .filter(|&c| c != '_')\n+                .collect::<Vec<_>>()\n+                .chunks(group_size)\n+                .map(|chunk| chunk.into_iter().collect())\n+                .collect::<Vec<String>>()\n+                .join(\"_\");\n+            format!(\"{}.{}{}\", int_part_hint, frac_part_hint, self.suffix.unwrap_or(\"\"))\n+        } else {\n+            let hint = self.digits\n+                .chars()\n+                .rev()\n+                .filter(|&c| c != '_')\n+                .collect::<Vec<_>>()\n+                .chunks(group_size)\n+                .map(|chunk| chunk.into_iter().rev().collect())\n+                .rev()\n+                .collect::<Vec<String>>()\n+                .join(\"_\");\n+            format!(\"{}{}{}\", self.prefix.unwrap_or(\"\"), hint, self.suffix.unwrap_or(\"\"))\n+        }\n+    }\n+}\n+\n+enum WarningType {\n+    UnreadableLiteral,\n+    InconsistentDigitGrouping,\n+    LargeDigitGroups,\n+}\n+\n+\n+impl WarningType {\n+    pub fn display(&self, grouping_hint: &str, cx: &EarlyContext, span: &syntax_pos::Span) {\n+        match *self {\n+            WarningType::UnreadableLiteral => {\n+                span_help_and_lint(\n+                    cx,\n+                    UNREADABLE_LITERAL,\n+                    *span,\n+                    \"long literal lacking separators\",\n+                    &format!(\"consider: {}\", grouping_hint),\n+                )\n+            },\n+            WarningType::LargeDigitGroups => {\n+                span_help_and_lint(\n+                    cx,\n+                    LARGE_DIGIT_GROUPS,\n+                    *span,\n+                    \"digit groups should be smaller\",\n+                    &format!(\"consider: {}\", grouping_hint),\n+                )\n+            },\n+            WarningType::InconsistentDigitGrouping => {\n+                span_help_and_lint(\n+                    cx,\n+                    INCONSISTENT_DIGIT_GROUPING,\n+                    *span,\n+                    \"digits grouped inconsistently by underscores\",\n+                    &format!(\"consider: {}\", grouping_hint),\n+                )\n+            },\n+        };\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct LiteralDigitGrouping;\n+\n+impl LintPass for LiteralDigitGrouping {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNREADABLE_LITERAL, INCONSISTENT_DIGIT_GROUPING, LARGE_DIGIT_GROUPS)\n+    }\n+}\n+\n+impl EarlyLintPass for LiteralDigitGrouping {\n+    fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n+        if in_external_macro(cx, expr.span) {\n+            return;\n+        }\n+\n+        if let ExprKind::Lit(ref lit) = expr.node {\n+            self.check_lit(cx, lit)\n+        }\n+    }\n+}\n+\n+impl LiteralDigitGrouping {\n+    fn check_lit(&self, cx: &EarlyContext, lit: &Lit) {\n+        // Lint integral literals.\n+        if_let_chain! {[\n+            let LitKind::Int(..) = lit.node,\n+            let Some(src) = snippet_opt(cx, lit.span),\n+            let Some(firstch) = src.chars().next(),\n+            char::to_digit(firstch, 10).is_some()\n+        ], {\n+            let digit_info = DigitInfo::new(&src, false);\n+            let _ = LiteralDigitGrouping::do_lint(digit_info.digits).map_err(|warning_type| {\n+                warning_type.display(&digit_info.grouping_hint(), cx, &lit.span)\n+            });\n+        }}\n+\n+        // Lint floating-point literals.\n+        if_let_chain! {[\n+            let LitKind::Float(..) = lit.node,\n+            let Some(src) = snippet_opt(cx, lit.span),\n+            let Some(firstch) = src.chars().next(),\n+            char::to_digit(firstch, 10).is_some()\n+        ], {\n+            let digit_info = DigitInfo::new(&src, true);\n+            // Separate digits into integral and fractional parts.\n+            let parts: Vec<&str> = digit_info\n+                .digits\n+                .split_terminator('.')\n+                .collect();\n+\n+            // Lint integral and fractional parts separately, and then check consistency of digit\n+            // groups if both pass.\n+            let _ = LiteralDigitGrouping::do_lint(parts[0])\n+                .map(|integral_group_size| {\n+                    if parts.len() > 1 {\n+                        // Lint the fractional part of literal just like integral part, but reversed.\n+                        let fractional_part = &parts[1].chars().rev().collect::<String>();\n+                        let _ = LiteralDigitGrouping::do_lint(fractional_part)\n+                            .map(|fractional_group_size| {\n+                                let consistent = LiteralDigitGrouping::parts_consistent(integral_group_size, fractional_group_size, parts[0].len(), parts[1].len());\n+                                if !consistent {\n+                                    WarningType::InconsistentDigitGrouping.display(&digit_info.grouping_hint(), cx, &lit.span);\n+                                }\n+                            })\n+                            .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(), cx, &lit.span));\n+                    }\n+                })\n+                .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(), cx, &lit.span));\n+        }}\n+    }\n+\n+    /// Given the sizes of the digit groups of both integral and fractional\n+    /// parts, and the length\n+    /// of both parts, determine if the digits have been grouped consistently.\n+    fn parts_consistent(int_group_size: usize, frac_group_size: usize, int_size: usize, frac_size: usize) -> bool {\n+        match (int_group_size, frac_group_size) {\n+            // No groups on either side of decimal point - trivially consistent.\n+            (0, 0) => true,\n+            // Integral part has grouped digits, fractional part does not.\n+            (_, 0) => frac_size <= int_group_size,\n+            // Fractional part has grouped digits, integral part does not.\n+            (0, _) => int_size <= frac_group_size,\n+            // Both parts have grouped digits. Groups should be the same size.\n+            (_, _) => int_group_size == frac_group_size,\n+        }\n+    }\n+\n+    /// Performs lint on `digits` (no decimal point) and returns the group\n+    /// size on success or `WarningType` when emitting a warning.\n+    fn do_lint(digits: &str) -> Result<usize, WarningType> {\n+        // Grab underscore indices with respect to the units digit.\n+        let underscore_positions: Vec<usize> = digits\n+            .chars()\n+            .rev()\n+            .enumerate()\n+            .filter_map(|(idx, digit)| if digit == '_' { Some(idx) } else { None })\n+            .collect();\n+\n+        if underscore_positions.is_empty() {\n+            // Check if literal needs underscores.\n+            if digits.len() > 4 {\n+                Err(WarningType::UnreadableLiteral)\n+            } else {\n+                Ok(0)\n+            }\n+        } else {\n+            // Check consistency and the sizes of the groups.\n+            let group_size = underscore_positions[0];\n+            let consistent = underscore_positions\n+                .windows(2)\n+                .all(|ps| ps[1] - ps[0] == group_size + 1)\n+                // number of digits to the left of the last group cannot be bigger than group size.\n+                && (digits.len() - underscore_positions.last().unwrap() <= group_size + 1);\n+\n+            if !consistent {\n+                return Err(WarningType::InconsistentDigitGrouping);\n+            } else if group_size > 4 {\n+                return Err(WarningType::LargeDigitGroups);\n+            }\n+            Ok(group_size)\n+        }\n+    }\n+}"}, {"sha": "c63dff52ae92724919afb3f1e561893da2a0b712", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=b4d70c9420da756a93ee703436c60d4948da90ce", "patch": "@@ -108,7 +108,7 @@ declare_lint! {\n /// **What it does:** Warns if an integral constant literal starts with `0`.\n ///\n /// **Why is this bad?** In some languages (including the infamous C language and most of its\n-/// familly), this marks an octal constant. In Rust however, this is a decimal constant. This could\n+/// family), this marks an octal constant. In Rust however, this is a decimal constant. This could\n /// be confusing for both the writer and a reader of the constant.\n ///\n /// **Known problems:** None.\n@@ -367,12 +367,12 @@ impl MiscEarly {\n                     db.span_suggestion(\n                         lit.span,\n                         \"if you mean to use a decimal constant, remove the `0` to remove confusion\",\n-                        src.trim_left_matches('0').to_string(),\n+                        src.trim_left_matches(|c| c == '_' || c == '0').to_string(),\n                     );\n                     db.span_suggestion(\n                         lit.span,\n                         \"if you mean to use an octal constant, use `0o`\",\n-                        format!(\"0o{}\", src.trim_left_matches('0')),\n+                        format!(\"0o{}\", src.trim_left_matches(|c| c == '_' || c == '0')),\n                     );\n                 });\n             }"}, {"sha": "06e8996deb7bbbc7d8b95d4bdbca347a608ede0f", "filename": "clippy_tests/examples/inconsistent_digit_grouping.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_tests%2Fexamples%2Finconsistent_digit_grouping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_tests%2Fexamples%2Finconsistent_digit_grouping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Finconsistent_digit_grouping.rs?ref=b4d70c9420da756a93ee703436c60d4948da90ce", "patch": "@@ -0,0 +1,8 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#[warn(inconsistent_digit_grouping)]\n+#[allow(unused_variables)]\n+fn main() {\n+    let good = (123, 1_234, 1_2345_6789, 123_f32, 1_234.12_f32, 1_234.123_4_f32, 1.123_456_7_f32);\n+    let bad = (1_23_456, 1_234_5678, 1234_567, 1_234.5678_f32, 1.234_5678_f32);\n+}"}, {"sha": "ba2bc305d8d375f6628286f85436d28f1e22cb38", "filename": "clippy_tests/examples/inconsistent_digit_grouping.stderr", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_tests%2Fexamples%2Finconsistent_digit_grouping.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_tests%2Fexamples%2Finconsistent_digit_grouping.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Finconsistent_digit_grouping.stderr?ref=b4d70c9420da756a93ee703436c60d4948da90ce", "patch": "@@ -0,0 +1,45 @@\n+error: digits grouped inconsistently by underscores\n+ --> inconsistent_digit_grouping.rs:7:16\n+  |\n+7 |     let bad = (1_23_456, 1_234_5678, 1234_567, 1_234.5678_f32, 1.234_5678_f32);\n+  |                ^^^^^^^^\n+  |\n+  = note: `-D inconsistent-digit-grouping` implied by `-D warnings`\n+  = help: consider: 123_456\n+\n+error: digits grouped inconsistently by underscores\n+ --> inconsistent_digit_grouping.rs:7:26\n+  |\n+7 |     let bad = (1_23_456, 1_234_5678, 1234_567, 1_234.5678_f32, 1.234_5678_f32);\n+  |                          ^^^^^^^^^^\n+  |\n+  = help: consider: 12_345_678\n+\n+error: digits grouped inconsistently by underscores\n+ --> inconsistent_digit_grouping.rs:7:38\n+  |\n+7 |     let bad = (1_23_456, 1_234_5678, 1234_567, 1_234.5678_f32, 1.234_5678_f32);\n+  |                                      ^^^^^^^^\n+  |\n+  = help: consider: 1_234_567\n+\n+error: digits grouped inconsistently by underscores\n+ --> inconsistent_digit_grouping.rs:7:48\n+  |\n+7 |     let bad = (1_23_456, 1_234_5678, 1234_567, 1_234.5678_f32, 1.234_5678_f32);\n+  |                                                ^^^^^^^^^^^^^^\n+  |\n+  = help: consider: 1_234.567_8_f32\n+\n+error: digits grouped inconsistently by underscores\n+ --> inconsistent_digit_grouping.rs:7:64\n+  |\n+7 |     let bad = (1_23_456, 1_234_5678, 1234_567, 1_234.5678_f32, 1.234_5678_f32);\n+  |                                                                ^^^^^^^^^^^^^^\n+  |\n+  = help: consider: 1.234_567_8_f32\n+\n+error: aborting due to 5 previous errors\n+\n+\n+To learn more, run the command again with --verbose."}, {"sha": "65bcdc7435e8a7df3b789a7aed063647a18574a9", "filename": "clippy_tests/examples/large_digit_groups.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_tests%2Fexamples%2Flarge_digit_groups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_tests%2Fexamples%2Flarge_digit_groups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Flarge_digit_groups.rs?ref=b4d70c9420da756a93ee703436c60d4948da90ce", "patch": "@@ -0,0 +1,8 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#[warn(large_digit_groups)]\n+#[allow(unused_variables)]\n+fn main() {\n+    let good = (0b1011_i64, 0o1_234_u32, 0x1_234_567, 1_2345_6789, 1234_f32, 1_234.12_f32, 1_234.123_f32, 1.123_4_f32);\n+    let bad = (0b1_10110_i64, 0x1_23456_78901_usize, 1_23456_f32, 1_23456.12_f32, 1_23456.12345_f32, 1_23456.12345_6_f32);\n+}"}, {"sha": "408bff8b3cd646ca01767dbb0c20a1e31d4a051a", "filename": "clippy_tests/examples/large_digit_groups.stderr", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_tests%2Fexamples%2Flarge_digit_groups.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_tests%2Fexamples%2Flarge_digit_groups.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Flarge_digit_groups.stderr?ref=b4d70c9420da756a93ee703436c60d4948da90ce", "patch": "@@ -0,0 +1,53 @@\n+error: digit groups should be smaller\n+ --> large_digit_groups.rs:7:16\n+  |\n+7 |     let bad = (0b1_10110_i64, 0x1_23456_78901_usize, 1_23456_f32, 1_23456.12_f32, 1_23456.12345_f32, 1_23456.12345_6_f32);\n+  |                ^^^^^^^^^^^^^\n+  |\n+  = note: `-D large-digit-groups` implied by `-D warnings`\n+  = help: consider: 0b11_0110_i64\n+\n+error: digit groups should be smaller\n+ --> large_digit_groups.rs:7:31\n+  |\n+7 |     let bad = (0b1_10110_i64, 0x1_23456_78901_usize, 1_23456_f32, 1_23456.12_f32, 1_23456.12345_f32, 1_23456.12345_6_f32);\n+  |                               ^^^^^^^^^^^^^^^^^^^^^\n+  |\n+  = help: consider: 0x123_4567_8901_usize\n+\n+error: digit groups should be smaller\n+ --> large_digit_groups.rs:7:54\n+  |\n+7 |     let bad = (0b1_10110_i64, 0x1_23456_78901_usize, 1_23456_f32, 1_23456.12_f32, 1_23456.12345_f32, 1_23456.12345_6_f32);\n+  |                                                      ^^^^^^^^^^^\n+  |\n+  = help: consider: 123_456_f32\n+\n+error: digit groups should be smaller\n+ --> large_digit_groups.rs:7:67\n+  |\n+7 |     let bad = (0b1_10110_i64, 0x1_23456_78901_usize, 1_23456_f32, 1_23456.12_f32, 1_23456.12345_f32, 1_23456.12345_6_f32);\n+  |                                                                   ^^^^^^^^^^^^^^\n+  |\n+  = help: consider: 123_456.12_f32\n+\n+error: digit groups should be smaller\n+ --> large_digit_groups.rs:7:83\n+  |\n+7 |     let bad = (0b1_10110_i64, 0x1_23456_78901_usize, 1_23456_f32, 1_23456.12_f32, 1_23456.12345_f32, 1_23456.12345_6_f32);\n+  |                                                                                   ^^^^^^^^^^^^^^^^^\n+  |\n+  = help: consider: 123_456.123_45_f32\n+\n+error: digit groups should be smaller\n+ --> large_digit_groups.rs:7:102\n+  |\n+7 |     let bad = (0b1_10110_i64, 0x1_23456_78901_usize, 1_23456_f32, 1_23456.12_f32, 1_23456.12345_f32, 1_23456.12345_6_f32);\n+  |                                                                                                      ^^^^^^^^^^^^^^^^^^^\n+  |\n+  = help: consider: 123_456.123_456_f32\n+\n+error: aborting due to 6 previous errors\n+\n+\n+To learn more, run the command again with --verbose."}, {"sha": "e8105a74b5cfc7a0126bdafe433a6bca862ffb2c", "filename": "clippy_tests/examples/literals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_tests%2Fexamples%2Fliterals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_tests%2Fexamples%2Fliterals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Fliterals.rs?ref=b4d70c9420da756a93ee703436c60d4948da90ce", "patch": "@@ -14,7 +14,7 @@ fn main() {\n     let fail1 = 0xabCD;\n     let fail2 = 0xabCD_u32;\n     let fail2 = 0xabCD_isize;\n-    let fail_multi_zero = 000123usize;\n+    let fail_multi_zero = 000_123usize;\n \n     let ok6 = 1234_i32;\n     let ok7 = 1234_f32;\n@@ -30,5 +30,5 @@ fn main() {\n     let fail8 = 0123;\n \n     let ok11 = 0o123;\n-    let ok12 = 0b101010;\n+    let ok12 = 0b10_1010;\n }"}, {"sha": "05f623cae9519e19cb70ee64c61ffc19ebbd3414", "filename": "clippy_tests/examples/literals.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_tests%2Fexamples%2Fliterals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_tests%2Fexamples%2Fliterals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Fliterals.stderr?ref=b4d70c9420da756a93ee703436c60d4948da90ce", "patch": "@@ -21,16 +21,16 @@ error: inconsistent casing in hexadecimal literal\n error: integer type suffix should be separated by an underscore\n   --> literals.rs:17:27\n    |\n-17 |     let fail_multi_zero = 000123usize;\n-   |                           ^^^^^^^^^^^\n+17 |     let fail_multi_zero = 000_123usize;\n+   |                           ^^^^^^^^^^^^\n    |\n    = note: `-D unseparated-literal-suffix` implied by `-D warnings`\n \n error: this is a decimal constant\n   --> literals.rs:17:27\n    |\n-17 |     let fail_multi_zero = 000123usize;\n-   |                           ^^^^^^^^^^^\n+17 |     let fail_multi_zero = 000_123usize;\n+   |                           ^^^^^^^^^^^^\n    |\n    = note: `-D zero-prefixed-literal` implied by `-D warnings`\n help: if you mean to use a decimal constant, remove the `0` to remove confusion"}, {"sha": "45daf70b171a4be398c77ff4c2b3a19a6b63866e", "filename": "clippy_tests/examples/unreadable_literal.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_tests%2Fexamples%2Funreadable_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_tests%2Fexamples%2Funreadable_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Funreadable_literal.rs?ref=b4d70c9420da756a93ee703436c60d4948da90ce", "patch": "@@ -0,0 +1,8 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#[warn(unreadable_literal)]\n+#[allow(unused_variables)]\n+fn main() {\n+    let good = (0b1011_i64, 0o1_234_u32, 0x1_234_567, 1_2345_6789, 1234_f32, 1_234.12_f32, 1_234.123_f32, 1.123_4_f32);\n+    let bad = (0b10110_i64, 0x12345678901_usize, 12345_f32, 1.23456_f32);\n+}"}, {"sha": "e4c110915d0a1795a04e8a3b625d19ad67ce8bfb", "filename": "clippy_tests/examples/unreadable_literal.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_tests%2Fexamples%2Funreadable_literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b4d70c9420da756a93ee703436c60d4948da90ce/clippy_tests%2Fexamples%2Funreadable_literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Funreadable_literal.stderr?ref=b4d70c9420da756a93ee703436c60d4948da90ce", "patch": "@@ -0,0 +1,37 @@\n+error: long literal lacking separators\n+ --> unreadable_literal.rs:7:16\n+  |\n+7 |     let bad = (0b10110_i64, 0x12345678901_usize, 12345_f32, 1.23456_f32);\n+  |                ^^^^^^^^^^^\n+  |\n+  = note: `-D unreadable-literal` implied by `-D warnings`\n+  = help: consider: 0b1_0110_i64\n+\n+error: long literal lacking separators\n+ --> unreadable_literal.rs:7:29\n+  |\n+7 |     let bad = (0b10110_i64, 0x12345678901_usize, 12345_f32, 1.23456_f32);\n+  |                             ^^^^^^^^^^^^^^^^^^^\n+  |\n+  = help: consider: 0x123_4567_8901_usize\n+\n+error: long literal lacking separators\n+ --> unreadable_literal.rs:7:50\n+  |\n+7 |     let bad = (0b10110_i64, 0x12345678901_usize, 12345_f32, 1.23456_f32);\n+  |                                                  ^^^^^^^^^\n+  |\n+  = help: consider: 12_345_f32\n+\n+error: long literal lacking separators\n+ --> unreadable_literal.rs:7:61\n+  |\n+7 |     let bad = (0b10110_i64, 0x12345678901_usize, 12345_f32, 1.23456_f32);\n+  |                                                             ^^^^^^^^^^^\n+  |\n+  = help: consider: 1.234_56_f32\n+\n+error: aborting due to 4 previous errors\n+\n+\n+To learn more, run the command again with --verbose."}]}