{"sha": "d013e60ad479e086aae044a2e613510976bcb261", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwMTNlNjBhZDQ3OWUwODZhYWUwNDRhMmU2MTM1MTA5NzZiY2IyNjE=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2020-09-10T04:02:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-10T04:02:33Z"}, "message": "Rollup merge of #76497 - camelid:intra-doc-links-for-core-ptr, r=jyn514\n\nUse intra-doc links in `core::ptr`\n\nPart of #75080.\n\nThe only link that I did not change is a link to a function on the\n`pointer` primitive because intra-doc links for the `pointer` primitive\ndon't work yet (see #63351).\n\n---\n\n@rustbot modify labels: A-intra-doc-links T-doc", "tree": {"sha": "5f9b09f2ca46e3a7307adb171d71a92ae9513937", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f9b09f2ca46e3a7307adb171d71a92ae9513937"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d013e60ad479e086aae044a2e613510976bcb261", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfWaVZCRBK7hj4Ov3rIwAAdHIIAIKdOmoeoYvKAJ5qy0rNz/e1\n1SRxlmY9Cxcckg0RCaVnZ0yiCf3juQd4TEuuZUbNDuBi0ztjZcfw1fPjPthcxPMt\nF5bCz/lA2R6r9yHRz3R44MF9f/lRvXzcmI1WIPlPjeKN8QghypfubZ84evHP2wj1\nf4tzJ4IOeMuhFOPUz6AL74x6blQ5YJhJyVTy5QIo9hs7MJNqKbl1nGI/dCOaMZZ1\ni1LhqsnueW/POwqklm25YDt1D+GgMbmzbcWW/iILiJQDL/1gBDJK4WffiiMUWv6l\nOOSDBRpAm+uMLGPLfa/tqbaoJ6ScBXbNFJgrN+n0CMm11QOXeOhta4W/nlnSItQ=\n=H3Q2\n-----END PGP SIGNATURE-----\n", "payload": "tree 5f9b09f2ca46e3a7307adb171d71a92ae9513937\nparent 9fa079420354c4a416e1dac232dcaa09e4313117\nparent 884a1b4b9b358fcb2c12dab0aac5671c8534b29d\nauthor Tyler Mandry <tmandry@gmail.com> 1599710553 -0700\ncommitter GitHub <noreply@github.com> 1599710553 -0700\n\nRollup merge of #76497 - camelid:intra-doc-links-for-core-ptr, r=jyn514\n\nUse intra-doc links in `core::ptr`\n\nPart of #75080.\n\nThe only link that I did not change is a link to a function on the\n`pointer` primitive because intra-doc links for the `pointer` primitive\ndon't work yet (see #63351).\n\n---\n\n@rustbot modify labels: A-intra-doc-links T-doc\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d013e60ad479e086aae044a2e613510976bcb261", "html_url": "https://github.com/rust-lang/rust/commit/d013e60ad479e086aae044a2e613510976bcb261", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d013e60ad479e086aae044a2e613510976bcb261/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fa079420354c4a416e1dac232dcaa09e4313117", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fa079420354c4a416e1dac232dcaa09e4313117", "html_url": "https://github.com/rust-lang/rust/commit/9fa079420354c4a416e1dac232dcaa09e4313117"}, {"sha": "884a1b4b9b358fcb2c12dab0aac5671c8534b29d", "url": "https://api.github.com/repos/rust-lang/rust/commits/884a1b4b9b358fcb2c12dab0aac5671c8534b29d", "html_url": "https://github.com/rust-lang/rust/commit/884a1b4b9b358fcb2c12dab0aac5671c8534b29d"}], "stats": {"total": 81, "additions": 23, "deletions": 58}, "files": [{"sha": "92c4f2ccfe8a00df2876e82f121231b22f19e35b", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 23, "deletions": 58, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d013e60ad479e086aae044a2e613510976bcb261/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d013e60ad479e086aae044a2e613510976bcb261/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=d013e60ad479e086aae044a2e613510976bcb261", "patch": "@@ -54,16 +54,9 @@\n //! [aliasing]: ../../nomicon/aliasing.html\n //! [book]: ../../book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer\n //! [ub]: ../../reference/behavior-considered-undefined.html\n-//! [null]: ./fn.null.html\n //! [zst]: ../../nomicon/exotic-sizes.html#zero-sized-types-zsts\n-//! [atomic operations]: ../../std/sync/atomic/index.html\n-//! [`copy`]: ../../std/ptr/fn.copy.html\n+//! [atomic operations]: crate::sync::atomic\n //! [`offset`]: ../../std/primitive.pointer.html#method.offset\n-//! [`read_unaligned`]: ./fn.read_unaligned.html\n-//! [`write_unaligned`]: ./fn.write_unaligned.html\n-//! [`read_volatile`]: ./fn.read_volatile.html\n-//! [`write_volatile`]: ./fn.write_volatile.html\n-//! [`NonNull::dangling`]: ./struct.NonNull.html#method.dangling\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -118,9 +111,9 @@ mod mut_ptr;\n /// done automatically by the compiler. This means the fields of packed structs\n /// are not dropped in-place.\n ///\n-/// [`ptr::read`]: ../ptr/fn.read.html\n-/// [`ptr::read_unaligned`]: ../ptr/fn.read_unaligned.html\n-/// [pinned]: ../pin/index.html\n+/// [`ptr::read`]: self::read\n+/// [`ptr::read_unaligned`]: self::read_unaligned\n+/// [pinned]: crate::pin\n ///\n /// # Safety\n ///\n@@ -136,14 +129,12 @@ mod mut_ptr;\n /// Additionally, if `T` is not [`Copy`], using the pointed-to value after\n /// calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n /// foo` counts as a use because it will cause the value to be dropped\n-/// again. [`write`] can be used to overwrite data without causing it to be\n+/// again. [`write()`] can be used to overwrite data without causing it to be\n /// dropped.\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`write`]: ../ptr/fn.write.html\n+/// [valid]: self#safety\n ///\n /// # Examples\n ///\n@@ -243,9 +234,9 @@ pub(crate) struct FatPtr<T> {\n /// The `len` argument is the number of **elements**, not the number of bytes.\n ///\n /// This function is safe, but actually using the return value is unsafe.\n-/// See the documentation of [`from_raw_parts`] for slice safety requirements.\n+/// See the documentation of [`slice::from_raw_parts`] for slice safety requirements.\n ///\n-/// [`from_raw_parts`]: ../../std/slice/fn.from_raw_parts.html\n+/// [`slice::from_raw_parts`]: crate::slice::from_raw_parts\n ///\n /// # Examples\n ///\n@@ -274,10 +265,9 @@ pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n /// See the documentation of [`slice_from_raw_parts`] for more details.\n ///\n /// This function is safe, but actually using the return value is unsafe.\n-/// See the documentation of [`from_raw_parts_mut`] for slice safety requirements.\n+/// See the documentation of [`slice::from_raw_parts_mut`] for slice safety requirements.\n ///\n-/// [`slice_from_raw_parts`]: fn.slice_from_raw_parts.html\n-/// [`from_raw_parts_mut`]: ../../std/slice/fn.from_raw_parts_mut.html\n+/// [`slice::from_raw_parts_mut`]: crate::slice::from_raw_parts_mut\n ///\n /// # Examples\n ///\n@@ -316,8 +306,6 @@ pub const fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n ///   overlapping region of memory from `x` will be used. This is demonstrated\n ///   in the second example below.\n ///\n-/// [`mem::swap`]: ../mem/fn.swap.html\n-///\n /// # Safety\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n@@ -328,7 +316,7 @@ pub const fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n ///\n /// Note that even if `T` has size `0`, the pointers must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n+/// [valid]: self#safety\n ///\n /// # Examples\n ///\n@@ -406,7 +394,7 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n /// Note that even if the effectively copied size (`count * size_of::<T>()`) is `0`,\n /// the pointers must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n+/// [valid]: self#safety\n ///\n /// # Examples\n ///\n@@ -533,8 +521,6 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n /// operates on raw pointers instead of references. When references are\n /// available, [`mem::replace`] should be preferred.\n ///\n-/// [`mem::replace`]: ../mem/fn.replace.html\n-///\n /// # Safety\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n@@ -547,7 +533,7 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n+/// [valid]: self#safety\n ///\n /// # Examples\n ///\n@@ -653,7 +639,7 @@ pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n /// `*src` can violate memory safety. Note that assigning to `*src` counts as a\n /// use because it will attempt to drop the value at `*src`.\n ///\n-/// [`write`] can be used to overwrite data without causing it to be dropped.\n+/// [`write()`] can be used to overwrite data without causing it to be dropped.\n ///\n /// ```\n /// use std::ptr;\n@@ -682,11 +668,7 @@ pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n /// assert_eq!(s, \"bar\");\n /// ```\n ///\n-/// [`mem::swap`]: ../mem/fn.swap.html\n-/// [valid]: ../ptr/index.html#safety\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`read_unaligned`]: ./fn.read_unaligned.html\n-/// [`write`]: ./fn.write.html\n+/// [valid]: self#safety\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n@@ -723,11 +705,8 @@ pub unsafe fn read<T>(src: *const T) -> T {\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL.\n ///\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`read`]: ./fn.read.html\n-/// [`write_unaligned`]: ./fn.write_unaligned.html\n-/// [read-ownership]: ./fn.read.html#ownership-of-the-returned-value\n-/// [valid]: ../ptr/index.html#safety\n+/// [read-ownership]: read#ownership-of-the-returned-value\n+/// [valid]: self#safety\n ///\n /// ## On `packed` structs\n ///\n@@ -819,8 +798,6 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n /// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been [`read`] from.\n ///\n-/// [`read`]: ./fn.read.html\n-///\n /// # Safety\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n@@ -832,8 +809,7 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n-/// [`write_unaligned`]: ./fn.write_unaligned.html\n+/// [valid]: self#safety\n ///\n /// # Examples\n ///\n@@ -888,8 +864,6 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n /// assert_eq!(foo, \"bar\");\n /// assert_eq!(bar, \"foo\");\n /// ```\n-///\n-/// [`mem::swap`]: ../mem/fn.swap.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n@@ -904,7 +878,7 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///\n-/// Unlike [`write`], the pointer may be unaligned.\n+/// Unlike [`write()`], the pointer may be unaligned.\n ///\n /// `write_unaligned` does not drop the contents of `dst`. This is safe, but it\n /// could leak allocations or resources, so care should be taken not to overwrite\n@@ -916,9 +890,6 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n /// This is appropriate for initializing uninitialized memory, or overwriting\n /// memory that has previously been read with [`read_unaligned`].\n ///\n-/// [`write`]: ./fn.write.html\n-/// [`read_unaligned`]: ./fn.read_unaligned.html\n-///\n /// # Safety\n ///\n /// Behavior is undefined if any of the following conditions are violated:\n@@ -927,7 +898,7 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL.\n ///\n-/// [valid]: ../ptr/index.html#safety\n+/// [valid]: self#safety\n ///\n /// ## On `packed` structs\n ///\n@@ -1007,8 +978,6 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// to not be elided or reordered by the compiler across other volatile\n /// operations.\n ///\n-/// [`write_volatile`]: ./fn.write_volatile.html\n-///\n /// # Notes\n ///\n /// Rust does not currently have a rigorously and formally defined memory model,\n@@ -1041,10 +1010,8 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`read`]: ./fn.read.html\n-/// [read-ownership]: ./fn.read.html#ownership-of-the-returned-value\n+/// [valid]: self#safety\n+/// [read-ownership]: read#ownership-of-the-returned-value\n ///\n /// Just like in C, whether an operation is volatile has no bearing whatsoever\n /// on questions involving concurrent access from multiple threads. Volatile\n@@ -1089,8 +1056,6 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n /// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n /// location pointed to by `dst`.\n ///\n-/// [`read_volatile`]: ./fn.read_volatile.html\n-///\n /// # Notes\n ///\n /// Rust does not currently have a rigorously and formally defined memory model,\n@@ -1115,7 +1080,7 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n+/// [valid]: self#safety\n ///\n /// Just like in C, whether an operation is volatile has no bearing whatsoever\n /// on questions involving concurrent access from multiple threads. Volatile"}]}