{"sha": "737499593db6d7702de3bf9d0070ec3f8e65d71e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczNzQ5OTU5M2RiNmQ3NzAyZGUzYmY5ZDAwNzBlYzNmOGU2NWQ3MWU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-02-10T20:52:30Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-10-21T01:43:57Z"}, "message": "rustc_codegen_llvm: expose DILocation to rustc_codegen_ssa.", "tree": {"sha": "30b14ba847c56ec3a71b80f248fc42b0e2dbf014", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30b14ba847c56ec3a71b80f248fc42b0e2dbf014"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/737499593db6d7702de3bf9d0070ec3f8e65d71e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/737499593db6d7702de3bf9d0070ec3f8e65d71e", "html_url": "https://github.com/rust-lang/rust/commit/737499593db6d7702de3bf9d0070ec3f8e65d71e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/737499593db6d7702de3bf9d0070ec3f8e65d71e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88d874de6395a5422caad1f61783dadd395d49d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/88d874de6395a5422caad1f61783dadd395d49d0", "html_url": "https://github.com/rust-lang/rust/commit/88d874de6395a5422caad1f61783dadd395d49d0"}], "stats": {"total": 294, "additions": 132, "deletions": 162}, "files": [{"sha": "978ad37c0f3905c11a8c34762c047d7128474a83", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/737499593db6d7702de3bf9d0070ec3f8e65d71e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/737499593db6d7702de3bf9d0070ec3f8e65d71e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=737499593db6d7702de3bf9d0070ec3f8e65d71e", "patch": "@@ -56,6 +56,7 @@ impl BackendTypes for Builder<'_, 'll, 'tcx> {\n     type Funclet = <CodegenCx<'ll, 'tcx> as BackendTypes>::Funclet;\n \n     type DIScope = <CodegenCx<'ll, 'tcx> as BackendTypes>::DIScope;\n+    type DILocation = <CodegenCx<'ll, 'tcx> as BackendTypes>::DILocation;\n     type DIVariable = <CodegenCx<'ll, 'tcx> as BackendTypes>::DIVariable;\n }\n "}, {"sha": "7633dd0600d5f2a2b1228f874c533338df84b321", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/737499593db6d7702de3bf9d0070ec3f8e65d71e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/737499593db6d7702de3bf9d0070ec3f8e65d71e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=737499593db6d7702de3bf9d0070ec3f8e65d71e", "patch": "@@ -88,6 +88,7 @@ impl BackendTypes for CodegenCx<'ll, 'tcx> {\n     type Funclet = Funclet<'ll>;\n \n     type DIScope = &'ll llvm::debuginfo::DIScope;\n+    type DILocation = &'ll llvm::debuginfo::DILocation;\n     type DIVariable = &'ll llvm::debuginfo::DIVariable;\n }\n "}, {"sha": "f6b7f257f2f3749125bcf9846e23f75a87e83da9", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/create_scope_map.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/737499593db6d7702de3bf9d0070ec3f8e65d71e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/737499593db6d7702de3bf9d0070ec3f8e65d71e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs?ref=737499593db6d7702de3bf9d0070ec3f8e65d71e", "patch": "@@ -49,7 +49,7 @@ fn make_mir_scope(\n     debug_context: &mut FunctionDebugContext<&'ll DIScope>,\n     scope: SourceScope,\n ) {\n-    if debug_context.scopes[scope].is_valid() {\n+    if debug_context.scopes[scope].dbg_scope.is_some() {\n         return;\n     }\n \n@@ -61,7 +61,7 @@ fn make_mir_scope(\n         // The root is the function itself.\n         let loc = cx.lookup_debug_loc(mir.span.lo());\n         debug_context.scopes[scope] = DebugScope {\n-            scope_metadata: Some(fn_dbg_scope),\n+            dbg_scope: Some(fn_dbg_scope),\n             file_start_pos: loc.file.start_pos,\n             file_end_pos: loc.file.end_pos,\n         };\n@@ -78,17 +78,17 @@ fn make_mir_scope(\n     let loc = cx.lookup_debug_loc(scope_data.span.lo());\n     let file_metadata = file_metadata(cx, &loc.file);\n \n-    let scope_metadata = unsafe {\n+    let dbg_scope = unsafe {\n         Some(llvm::LLVMRustDIBuilderCreateLexicalBlock(\n             DIB(cx),\n-            parent_scope.scope_metadata.unwrap(),\n+            parent_scope.dbg_scope.unwrap(),\n             file_metadata,\n             loc.line.unwrap_or(UNKNOWN_LINE_NUMBER),\n             loc.col.unwrap_or(UNKNOWN_COLUMN_NUMBER),\n         ))\n     };\n     debug_context.scopes[scope] = DebugScope {\n-        scope_metadata,\n+        dbg_scope,\n         file_start_pos: loc.file.start_pos,\n         file_end_pos: loc.file.end_pos,\n     };"}, {"sha": "7b416f1f6adbaf885ddf99da521ca81ed8d3d51c", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 70, "deletions": 24, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/737499593db6d7702de3bf9d0070ec3f8e65d71e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/737499593db6d7702de3bf9d0070ec3f8e65d71e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=737499593db6d7702de3bf9d0070ec3f8e65d71e", "patch": "@@ -3,7 +3,8 @@ mod doc;\n \n use rustc_codegen_ssa::mir::debuginfo::VariableKind::*;\n \n-use self::metadata::{file_metadata, type_metadata, TypeMap, UNKNOWN_LINE_NUMBER};\n+use self::metadata::{file_metadata, type_metadata, TypeMap};\n+use self::metadata::{UNKNOWN_COLUMN_NUMBER, UNKNOWN_LINE_NUMBER};\n use self::namespace::mangled_name_of_instance;\n use self::type_names::compute_debuginfo_type_name;\n use self::utils::{create_DIArray, is_node_local_to_unit, DIB};\n@@ -13,14 +14,16 @@ use crate::builder::Builder;\n use crate::common::CodegenCx;\n use crate::llvm;\n use crate::llvm::debuginfo::{\n-    DIArray, DIBuilder, DIFile, DIFlags, DILexicalBlock, DISPFlags, DIScope, DIType, DIVariable,\n+    DIArray, DIBuilder, DIFile, DIFlags, DILexicalBlock, DILocation, DISPFlags, DIScope, DIType,\n+    DIVariable,\n };\n use crate::value::Value;\n \n use rustc_codegen_ssa::debuginfo::type_names;\n use rustc_codegen_ssa::mir::debuginfo::{DebugScope, FunctionDebugContext, VariableKind};\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::sync::Lrc;\n use rustc_hir::def_id::{DefId, DefIdMap, LOCAL_CRATE};\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir;\n@@ -29,7 +32,7 @@ use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, Instance, ParamEnv, Ty, TypeFoldable};\n use rustc_session::config::{self, DebugInfo};\n use rustc_span::symbol::Symbol;\n-use rustc_span::{self, BytePos, Span};\n+use rustc_span::{self, BytePos, Pos, SourceFile, SourceFileAndLine, Span};\n use rustc_target::abi::{LayoutOf, Primitive, Size};\n \n use libc::c_uint;\n@@ -41,7 +44,6 @@ mod create_scope_map;\n pub mod gdb;\n pub mod metadata;\n mod namespace;\n-mod source_loc;\n mod utils;\n \n pub use self::create_scope_map::compute_mir_scopes;\n@@ -141,14 +143,11 @@ impl DebugInfoBuilderMethods for Builder<'a, 'll, 'tcx> {\n     fn dbg_var_addr(\n         &mut self,\n         dbg_var: &'ll DIVariable,\n-        scope_metadata: &'ll DIScope,\n+        dbg_loc: &'ll DILocation,\n         variable_alloca: Self::Value,\n         direct_offset: Size,\n         indirect_offsets: &[Size],\n-        span: Span,\n     ) {\n-        let cx = self.cx();\n-\n         // Convert the direct and indirect offsets to address ops.\n         // FIXME(eddyb) use `const`s instead of getting the values via FFI,\n         // the values should match the ones in the DWARF standard anyway.\n@@ -168,14 +167,10 @@ impl DebugInfoBuilderMethods for Builder<'a, 'll, 'tcx> {\n             }\n         }\n \n-        // FIXME(eddyb) maybe this information could be extracted from `dbg_var`,\n-        // to avoid having to pass it down in both places?\n-        // NB: `var` doesn't seem to know about the column, so that's a limitation.\n-        let dbg_loc = cx.create_debug_loc(scope_metadata, span);\n         unsafe {\n             // FIXME(eddyb) replace `llvm.dbg.declare` with `llvm.dbg.addr`.\n             llvm::LLVMRustDIBuilderInsertDeclareAtEnd(\n-                DIB(cx),\n+                DIB(self.cx()),\n                 variable_alloca,\n                 dbg_var,\n                 addr_ops.as_ptr(),\n@@ -186,16 +181,13 @@ impl DebugInfoBuilderMethods for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn set_source_location(&mut self, scope: &'ll DIScope, span: Span) {\n-        debug!(\"set_source_location: {}\", self.sess().source_map().span_to_string(span));\n-\n-        let dbg_loc = self.cx().create_debug_loc(scope, span);\n-\n+    fn set_dbg_loc(&mut self, dbg_loc: &'ll DILocation) {\n         unsafe {\n             let dbg_loc_as_llval = llvm::LLVMRustMetadataAsValue(self.cx().llcx, dbg_loc);\n             llvm::LLVMSetCurrentDebugLocation(self.llbuilder, dbg_loc_as_llval);\n         }\n     }\n+\n     fn insert_reference_to_gdb_debug_scripts_section_global(&mut self) {\n         gdb::insert_reference_to_gdb_debug_scripts_section_global(self)\n     }\n@@ -224,6 +216,49 @@ impl DebugInfoBuilderMethods for Builder<'a, 'll, 'tcx> {\n     }\n }\n \n+/// A source code location used to generate debug information.\n+// FIXME(eddyb) rename this to better indicate it's a duplicate of\n+// `rustc_span::Loc` rather than `DILocation`, perhaps by making\n+// `lookup_char_pos` return the right information instead.\n+pub struct DebugLoc {\n+    /// Information about the original source file.\n+    pub file: Lrc<SourceFile>,\n+    /// The (1-based) line number.\n+    pub line: Option<u32>,\n+    /// The (1-based) column number.\n+    pub col: Option<u32>,\n+}\n+\n+impl CodegenCx<'ll, '_> {\n+    /// Looks up debug source information about a `BytePos`.\n+    // FIXME(eddyb) rename this to better indicate it's a duplicate of\n+    // `lookup_char_pos` rather than `dbg_loc`, perhaps by making\n+    // `lookup_char_pos` return the right information instead.\n+    pub fn lookup_debug_loc(&self, pos: BytePos) -> DebugLoc {\n+        let (file, line, col) = match self.sess().source_map().lookup_line(pos) {\n+            Ok(SourceFileAndLine { sf: file, line }) => {\n+                let line_pos = file.line_begin_pos(pos);\n+\n+                // Use 1-based indexing.\n+                let line = (line + 1) as u32;\n+                let col = (pos - line_pos).to_u32() + 1;\n+\n+                (file, Some(line), Some(col))\n+            }\n+            Err(file) => (file, None, None),\n+        };\n+\n+        // For MSVC, omit the column number.\n+        // Otherwise, emit it. This mimics clang behaviour.\n+        // See discussion in https://github.com/rust-lang/rust/issues/42921\n+        if self.sess().target.options.is_like_msvc {\n+            DebugLoc { file, line, col: None }\n+        } else {\n+            DebugLoc { file, line, col }\n+        }\n+    }\n+}\n+\n impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn create_function_debug_context(\n         &self,\n@@ -237,12 +272,9 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n \n         // Initialize fn debug context (including scopes).\n-        // FIXME(eddyb) figure out a way to not need `Option` for `scope_metadata`.\n-        let empty_scope = DebugScope {\n-            scope_metadata: None,\n-            file_start_pos: BytePos(0),\n-            file_end_pos: BytePos(0),\n-        };\n+        // FIXME(eddyb) figure out a way to not need `Option` for `dbg_scope`.\n+        let empty_scope =\n+            DebugScope { dbg_scope: None, file_start_pos: BytePos(0), file_end_pos: BytePos(0) };\n         let mut fn_debug_context =\n             FunctionDebugContext { scopes: IndexVec::from_elem(empty_scope, &mir.source_scopes) };\n \n@@ -505,6 +537,20 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n+    fn dbg_loc(&self, scope: &'ll DIScope, span: Span) -> &'ll DILocation {\n+        let DebugLoc { line, col, .. } = self.lookup_debug_loc(span.lo());\n+\n+        unsafe {\n+            llvm::LLVMRustDIBuilderCreateDebugLocation(\n+                utils::debug_context(self).llcontext,\n+                line.unwrap_or(UNKNOWN_LINE_NUMBER),\n+                col.unwrap_or(UNKNOWN_COLUMN_NUMBER),\n+                scope,\n+                None,\n+            )\n+        }\n+    }\n+\n     fn create_vtable_metadata(&self, ty: Ty<'tcx>, vtable: Self::Value) {\n         metadata::create_vtable_metadata(self, ty, vtable)\n     }"}, {"sha": "f1d9b8653bcb730370e67039f13992dd21a01f25", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/source_loc.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/88d874de6395a5422caad1f61783dadd395d49d0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d874de6395a5422caad1f61783dadd395d49d0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fsource_loc.rs?ref=88d874de6395a5422caad1f61783dadd395d49d0", "patch": "@@ -1,61 +0,0 @@\n-use super::metadata::{UNKNOWN_COLUMN_NUMBER, UNKNOWN_LINE_NUMBER};\n-use super::utils::debug_context;\n-\n-use crate::common::CodegenCx;\n-use crate::llvm;\n-use crate::llvm::debuginfo::{DILocation, DIScope};\n-use rustc_codegen_ssa::traits::*;\n-\n-use rustc_data_structures::sync::Lrc;\n-use rustc_span::{BytePos, Pos, SourceFile, SourceFileAndLine, Span};\n-\n-/// A source code location used to generate debug information.\n-pub struct DebugLoc {\n-    /// Information about the original source file.\n-    pub file: Lrc<SourceFile>,\n-    /// The (1-based) line number.\n-    pub line: Option<u32>,\n-    /// The (1-based) column number.\n-    pub col: Option<u32>,\n-}\n-\n-impl CodegenCx<'ll, '_> {\n-    /// Looks up debug source information about a `BytePos`.\n-    pub fn lookup_debug_loc(&self, pos: BytePos) -> DebugLoc {\n-        let (file, line, col) = match self.sess().source_map().lookup_line(pos) {\n-            Ok(SourceFileAndLine { sf: file, line }) => {\n-                let line_pos = file.line_begin_pos(pos);\n-\n-                // Use 1-based indexing.\n-                let line = (line + 1) as u32;\n-                let col = (pos - line_pos).to_u32() + 1;\n-\n-                (file, Some(line), Some(col))\n-            }\n-            Err(file) => (file, None, None),\n-        };\n-\n-        // For MSVC, omit the column number.\n-        // Otherwise, emit it. This mimics clang behaviour.\n-        // See discussion in https://github.com/rust-lang/rust/issues/42921\n-        if self.sess().target.options.is_like_msvc {\n-            DebugLoc { file, line, col: None }\n-        } else {\n-            DebugLoc { file, line, col }\n-        }\n-    }\n-\n-    pub fn create_debug_loc(&self, scope: &'ll DIScope, span: Span) -> &'ll DILocation {\n-        let DebugLoc { line, col, .. } = self.lookup_debug_loc(span.lo());\n-\n-        unsafe {\n-            llvm::LLVMRustDIBuilderCreateDebugLocation(\n-                debug_context(self).llcontext,\n-                line.unwrap_or(UNKNOWN_LINE_NUMBER),\n-                col.unwrap_or(UNKNOWN_COLUMN_NUMBER),\n-                scope,\n-                None,\n-            )\n-        }\n-    }\n-}"}, {"sha": "ddb9372cf8f73c4042cf668a4ec2b7b31b0a5e9c", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 49, "deletions": 69, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/737499593db6d7702de3bf9d0070ec3f8e65d71e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/737499593db6d7702de3bf9d0070ec3f8e65d71e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=737499593db6d7702de3bf9d0070ec3f8e65d71e", "patch": "@@ -37,71 +37,58 @@ pub struct PerLocalVarDebugInfo<'tcx, D> {\n \n #[derive(Clone, Copy, Debug)]\n pub struct DebugScope<D> {\n-    pub scope_metadata: Option<D>,\n+    // FIXME(eddyb) this should never be `None`, after initialization.\n+    pub dbg_scope: Option<D>,\n     // Start and end offsets of the file to which this DIScope belongs.\n     // These are used to quickly determine whether some span refers to the same file.\n     pub file_start_pos: BytePos,\n     pub file_end_pos: BytePos,\n }\n \n-impl<D> DebugScope<D> {\n-    pub fn is_valid(&self) -> bool {\n-        self.scope_metadata.is_some()\n-    }\n-}\n-\n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn set_debug_loc(&self, bx: &mut Bx, source_info: mir::SourceInfo) {\n-        let (scope, span) = self.debug_loc(source_info);\n-        bx.set_span(span);\n-        if let Some(scope) = scope {\n-            bx.set_source_location(scope, span);\n+        bx.set_span(source_info.span);\n+        if let Some(dbg_loc) = self.dbg_loc(source_info) {\n+            bx.set_dbg_loc(dbg_loc);\n         }\n     }\n \n-    pub fn debug_loc(&self, source_info: mir::SourceInfo) -> (Option<Bx::DIScope>, Span) {\n+    fn dbg_loc(&self, source_info: mir::SourceInfo) -> Option<Bx::DILocation> {\n+        let (scope, span) = self.dbg_scope_and_span(source_info)?;\n+        Some(self.cx.dbg_loc(scope, span))\n+    }\n+\n+    fn dbg_scope_and_span(&self, source_info: mir::SourceInfo) -> Option<(Bx::DIScope, Span)> {\n         // Bail out if debug info emission is not enabled.\n-        match self.debug_context {\n-            None => return (None, source_info.span),\n-            Some(_) => {}\n-        }\n+        let debug_context = self.debug_context.as_ref()?;\n+        let scope = &debug_context.scopes[source_info.scope];\n \n         // In order to have a good line stepping behavior in debugger, we overwrite debug\n         // locations of macro expansions with that of the outermost expansion site\n         // (unless the crate is being compiled with `-Z debug-macros`).\n-        if !source_info.span.from_expansion() || self.cx.sess().opts.debugging_opts.debug_macros {\n-            let scope = self.scope_metadata_for_loc(source_info.scope, source_info.span.lo());\n-            (scope, source_info.span)\n-        } else {\n+        let mut span = source_info.span;\n+        if span.from_expansion() && !self.cx.sess().opts.debugging_opts.debug_macros {\n             // Walk up the macro expansion chain until we reach a non-expanded span.\n             // We also stop at the function body level because no line stepping can occur\n             // at the level above that.\n-            let span = rustc_span::hygiene::walk_chain(source_info.span, self.mir.span.ctxt());\n-            let scope = self.scope_metadata_for_loc(source_info.scope, span.lo());\n             // Use span of the outermost expansion site, while keeping the original lexical scope.\n-            (scope, span)\n+            span = rustc_span::hygiene::walk_chain(span, self.mir.span.ctxt());\n         }\n-    }\n \n-    // DILocations inherit source file name from the parent DIScope.  Due to macro expansions\n-    // it may so happen that the current span belongs to a different file than the DIScope\n-    // corresponding to span's containing source scope.  If so, we need to create a DIScope\n-    // \"extension\" into that file.\n-    fn scope_metadata_for_loc(\n-        &self,\n-        scope_id: mir::SourceScope,\n-        pos: BytePos,\n-    ) -> Option<Bx::DIScope> {\n-        let debug_context = self.debug_context.as_ref()?;\n-        let scope_metadata = debug_context.scopes[scope_id].scope_metadata?;\n-        if pos < debug_context.scopes[scope_id].file_start_pos\n-            || pos >= debug_context.scopes[scope_id].file_end_pos\n-        {\n+        // FIXME(eddyb) this should never be `None`.\n+        let mut dbg_scope = scope.dbg_scope?;\n+\n+        // DILocations inherit source file name from the parent DIScope.  Due to macro expansions\n+        // it may so happen that the current span belongs to a different file than the DIScope\n+        // corresponding to span's containing source scope.  If so, we need to create a DIScope\n+        // \"extension\" into that file.\n+        let pos = span.lo();\n+        if pos < scope.file_start_pos || pos >= scope.file_end_pos {\n             let sm = self.cx.sess().source_map();\n-            Some(self.cx.extend_scope_to_file(scope_metadata, &sm.lookup_char_pos(pos).file))\n-        } else {\n-            Some(scope_metadata)\n+            dbg_scope = self.cx.extend_scope_to_file(dbg_scope, &sm.lookup_char_pos(pos).file);\n         }\n+\n+        Some((dbg_scope, span))\n     }\n \n     /// Apply debuginfo and/or name, after creating the `alloca` for a local,\n@@ -142,17 +129,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             } else {\n                 let name = kw::Invalid;\n                 let decl = &self.mir.local_decls[local];\n-                let (scope, span) = if full_debug_info {\n-                    self.debug_loc(decl.source_info)\n+                let dbg_var = if full_debug_info {\n+                    self.dbg_scope_and_span(decl.source_info).map(|(scope, span)| {\n+                        // FIXME(eddyb) is this `+ 1` needed at all?\n+                        let kind = VariableKind::ArgumentVariable(arg_index + 1);\n+\n+                        self.cx.create_dbg_var(name, self.monomorphize(&decl.ty), scope, kind, span)\n+                    })\n                 } else {\n-                    (None, decl.source_info.span)\n+                    None\n                 };\n-                let dbg_var = scope.map(|scope| {\n-                    // FIXME(eddyb) is this `+ 1` needed at all?\n-                    let kind = VariableKind::ArgumentVariable(arg_index + 1);\n-\n-                    self.cx.create_dbg_var(name, self.monomorphize(&decl.ty), scope, kind, span)\n-                });\n \n                 Some(PerLocalVarDebugInfo {\n                     name,\n@@ -233,6 +219,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let vars = vars.iter().copied().chain(fallback_var);\n \n         for var in vars {\n+            let dbg_var = match var.dbg_var {\n+                Some(dbg_var) => dbg_var,\n+                None => continue,\n+            };\n+            let dbg_loc = match self.dbg_loc(var.source_info) {\n+                Some(dbg_loc) => dbg_loc,\n+                None => continue,\n+            };\n+\n             let mut layout = base.layout;\n             let mut direct_offset = Size::ZERO;\n             // FIXME(eddyb) use smallvec here.\n@@ -269,19 +264,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n             }\n \n-            let (scope, span) = self.debug_loc(var.source_info);\n-            if let Some(scope) = scope {\n-                if let Some(dbg_var) = var.dbg_var {\n-                    bx.dbg_var_addr(\n-                        dbg_var,\n-                        scope,\n-                        base.llval,\n-                        direct_offset,\n-                        &indirect_offsets,\n-                        span,\n-                    );\n-                }\n-            }\n+            bx.dbg_var_addr(dbg_var, dbg_loc, base.llval, direct_offset, &indirect_offsets);\n         }\n     }\n \n@@ -305,12 +288,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         let mut per_local = IndexVec::from_elem(vec![], &self.mir.local_decls);\n         for var in &self.mir.var_debug_info {\n-            let (scope, span) = if full_debug_info {\n-                self.debug_loc(var.source_info)\n-            } else {\n-                (None, var.source_info.span)\n-            };\n-            let dbg_var = scope.map(|scope| {\n+            let scope_and_span =\n+                if full_debug_info { self.dbg_scope_and_span(var.source_info) } else { None };\n+            let dbg_var = scope_and_span.map(|(scope, span)| {\n                 let place = var.place;\n                 let var_ty = self.monomorphized_place_ty(place.as_ref());\n                 let var_kind = if self.mir.local_kind(place.local) == mir::LocalKind::Arg"}, {"sha": "b9c555c2eb0691fc8992eb033c1dbf60cedac826", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/737499593db6d7702de3bf9d0070ec3f8e65d71e/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/737499593db6d7702de3bf9d0070ec3f8e65d71e/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=737499593db6d7702de3bf9d0070ec3f8e65d71e", "patch": "@@ -34,6 +34,7 @@ pub trait BackendTypes {\n     // FIXME(eddyb) find a common convention for all of the debuginfo-related\n     // names (choose between `Dbg`, `Debug`, `DebugInfo`, `DI` etc.).\n     type DIScope: Copy;\n+    type DILocation: Copy;\n     type DIVariable: Copy;\n }\n "}, {"sha": "a7588eb4d14cfe4d5da6de4cfb08d9dd99eb5a41", "filename": "compiler/rustc_codegen_ssa/src/traits/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/737499593db6d7702de3bf9d0070ec3f8e65d71e/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/737499593db6d7702de3bf9d0070ec3f8e65d71e/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdebuginfo.rs?ref=737499593db6d7702de3bf9d0070ec3f8e65d71e", "patch": "@@ -30,6 +30,8 @@ pub trait DebugInfoMethods<'tcx>: BackendTypes {\n         maybe_definition_llfn: Option<Self::Function>,\n     ) -> Self::DIScope;\n \n+    fn dbg_loc(&self, scope: Self::DIScope, span: Span) -> Self::DILocation;\n+\n     fn extend_scope_to_file(\n         &self,\n         scope_metadata: Self::DIScope,\n@@ -55,14 +57,13 @@ pub trait DebugInfoBuilderMethods: BackendTypes {\n     fn dbg_var_addr(\n         &mut self,\n         dbg_var: Self::DIVariable,\n-        scope_metadata: Self::DIScope,\n+        dbg_loc: Self::DILocation,\n         variable_alloca: Self::Value,\n         direct_offset: Size,\n         // NB: each offset implies a deref (i.e. they're steps in a pointer chain).\n         indirect_offsets: &[Size],\n-        span: Span,\n     );\n-    fn set_source_location(&mut self, scope: Self::DIScope, span: Span);\n+    fn set_dbg_loc(&mut self, dbg_loc: Self::DILocation);\n     fn insert_reference_to_gdb_debug_scripts_section_global(&mut self);\n     fn set_var_name(&mut self, value: Self::Value, name: &str);\n }"}, {"sha": "8ada6c10479daff9f8cec9d444756b4b4ad7d7e1", "filename": "compiler/rustc_codegen_ssa/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/737499593db6d7702de3bf9d0070ec3f8e65d71e/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/737499593db6d7702de3bf9d0070ec3f8e65d71e/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs?ref=737499593db6d7702de3bf9d0070ec3f8e65d71e", "patch": "@@ -95,6 +95,7 @@ pub trait HasCodegen<'tcx>:\n             Type = Self::Type,\n             Funclet = Self::Funclet,\n             DIScope = Self::DIScope,\n+            DILocation = Self::DILocation,\n             DIVariable = Self::DIVariable,\n         >;\n }"}]}