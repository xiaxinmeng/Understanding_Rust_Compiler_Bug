{"sha": "c2c432289195eaf65e42566ed0b95f82a913bcb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyYzQzMjI4OTE5NWVhZjY1ZTQyNTY2ZWQwYjk1ZjgyYTkxM2JjYjM=", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-03-05T20:56:02Z"}, "committer": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-03-09T19:14:42Z"}, "message": "Make arena allocation for the THIR work", "tree": {"sha": "a8d921e446d3572864bd7709dbb7291c7e3cece4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8d921e446d3572864bd7709dbb7291c7e3cece4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2c432289195eaf65e42566ed0b95f82a913bcb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2c432289195eaf65e42566ed0b95f82a913bcb3", "html_url": "https://github.com/rust-lang/rust/commit/c2c432289195eaf65e42566ed0b95f82a913bcb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2c432289195eaf65e42566ed0b95f82a913bcb3/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9f4dfc8fa90420548bb96d2df4b0d76eea9c862", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9f4dfc8fa90420548bb96d2df4b0d76eea9c862", "html_url": "https://github.com/rust-lang/rust/commit/a9f4dfc8fa90420548bb96d2df4b0d76eea9c862"}], "stats": {"total": 909, "additions": 526, "deletions": 383}, "files": [{"sha": "e93c796c97059c88990ef266692e43dc01a34f30", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=c2c432289195eaf65e42566ed0b95f82a913bcb3", "patch": "@@ -12,7 +12,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         destination: Place<'tcx>,\n         block: BasicBlock,\n-        ast_block: &Block<'tcx>,\n+        ast_block: &Block<'_, 'tcx>,\n         source_info: SourceInfo,\n     ) -> BlockAnd<()> {\n         let Block {\n@@ -56,8 +56,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         destination: Place<'tcx>,\n         mut block: BasicBlock,\n         span: Span,\n-        stmts: &[Stmt<'tcx>],\n-        expr: Option<&Expr<'tcx>>,\n+        stmts: &[Stmt<'_, 'tcx>],\n+        expr: Option<&Expr<'_, 'tcx>>,\n         safety_mode: BlockSafety,\n     ) -> BlockAnd<()> {\n         let this = self;"}, {"sha": "ce341c0c06cdf68942919e4726c828902ff45553", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=c2c432289195eaf65e42566ed0b95f82a913bcb3", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::ty::CanonicalUserTypeAnnotation;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, yielding a compile-time constant. Assumes that\n     /// `expr` is a valid compile-time constant!\n-    crate fn as_constant(&mut self, expr: &Expr<'tcx>) -> Constant<'tcx> {\n+    crate fn as_constant(&mut self, expr: &Expr<'_, 'tcx>) -> Constant<'tcx> {\n         let this = self;\n         let Expr { ty, temp_lifetime: _, span, kind } = expr;\n         match kind {"}, {"sha": "28262287b6339d2f892e4b236441de8b0f97574d", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=c2c432289195eaf65e42566ed0b95f82a913bcb3", "patch": "@@ -17,7 +17,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn as_local_operand(\n         &mut self,\n         block: BasicBlock,\n-        expr: &Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<Operand<'tcx>> {\n         let local_scope = self.local_scope();\n         self.as_operand(block, Some(local_scope), expr)\n@@ -74,7 +74,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn as_local_call_operand(\n         &mut self,\n         block: BasicBlock,\n-        expr: &Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<Operand<'tcx>> {\n         let local_scope = self.local_scope();\n         self.as_call_operand(block, Some(local_scope), expr)\n@@ -93,7 +93,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         mut block: BasicBlock,\n         scope: Option<region::Scope>,\n-        expr: &Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<Operand<'tcx>> {\n         debug!(\"as_operand(block={:?}, expr={:?})\", block, expr);\n         let this = self;\n@@ -123,7 +123,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         mut block: BasicBlock,\n         scope: Option<region::Scope>,\n-        expr: &Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<Operand<'tcx>> {\n         debug!(\"as_call_operand(block={:?}, expr={:?})\", block, expr);\n         let this = self;"}, {"sha": "30262e164201b47cddf89deb6ceb650c58d7a30f", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=c2c432289195eaf65e42566ed0b95f82a913bcb3", "patch": "@@ -350,7 +350,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn as_place(\n         &mut self,\n         mut block: BasicBlock,\n-        expr: &Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_place_builder(block, expr));\n         block.and(place_builder.into_place(self.tcx, self.typeck_results))\n@@ -361,7 +361,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn as_place_builder(\n         &mut self,\n         block: BasicBlock,\n-        expr: &Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         self.expr_as_place(block, expr, Mutability::Mut, None)\n     }\n@@ -374,7 +374,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn as_read_only_place(\n         &mut self,\n         mut block: BasicBlock,\n-        expr: &Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_read_only_place_builder(block, expr));\n         block.and(place_builder.into_place(self.tcx, self.typeck_results))\n@@ -389,15 +389,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn as_read_only_place_builder(\n         &mut self,\n         block: BasicBlock,\n-        expr: &Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n         self.expr_as_place(block, expr, Mutability::Not, None)\n     }\n \n     fn expr_as_place(\n         &mut self,\n         mut block: BasicBlock,\n-        expr: &Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n         mutability: Mutability,\n         fake_borrow_temps: Option<&mut Vec<Local>>,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n@@ -584,8 +584,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn lower_index_expression(\n         &mut self,\n         mut block: BasicBlock,\n-        base: &Expr<'tcx>,\n-        index: &Expr<'tcx>,\n+        base: &Expr<'_, 'tcx>,\n+        index: &Expr<'_, 'tcx>,\n         mutability: Mutability,\n         fake_borrow_temps: Option<&mut Vec<Local>>,\n         temp_lifetime: Option<region::Scope>,"}, {"sha": "335ea4dca6006812b29e1f687592c2afbb7a7ab7", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=c2c432289195eaf65e42566ed0b95f82a913bcb3", "patch": "@@ -22,7 +22,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn as_local_rvalue(\n         &mut self,\n         block: BasicBlock,\n-        expr: &Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<Rvalue<'tcx>> {\n         let local_scope = self.local_scope();\n         self.as_rvalue(block, Some(local_scope), expr)\n@@ -33,7 +33,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         mut block: BasicBlock,\n         scope: Option<region::Scope>,\n-        expr: &Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<Rvalue<'tcx>> {\n         debug!(\"expr_as_rvalue(block={:?}, scope={:?}, expr={:?})\", block, scope, expr);\n \n@@ -368,7 +368,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         upvar_ty: Ty<'tcx>,\n         temp_lifetime: Option<region::Scope>,\n         mut block: BasicBlock,\n-        arg: &Expr<'tcx>,\n+        arg: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<Operand<'tcx>> {\n         let this = self;\n "}, {"sha": "12029b04a08f3391eac4d8705232518c5bdff663", "filename": "compiler/rustc_mir_build/src/build/expr/as_temp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs?ref=c2c432289195eaf65e42566ed0b95f82a913bcb3", "patch": "@@ -14,7 +14,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         block: BasicBlock,\n         temp_lifetime: Option<region::Scope>,\n-        expr: &Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n         mutability: Mutability,\n     ) -> BlockAnd<Local> {\n         // this is the only place in mir building that we need to truly need to worry about\n@@ -27,7 +27,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         mut block: BasicBlock,\n         temp_lifetime: Option<region::Scope>,\n-        expr: &Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n         mutability: Mutability,\n     ) -> BlockAnd<Local> {\n         debug!("}, {"sha": "0cadfa2f0a1afd809ca253434b826d75d3235abf", "filename": "compiler/rustc_mir_build/src/build/expr/category.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs?ref=c2c432289195eaf65e42566ed0b95f82a913bcb3", "patch": "@@ -31,7 +31,7 @@ crate enum RvalueFunc {\n /// Determines the category for a given expression. Note that scope\n /// and paren expressions have no category.\n impl Category {\n-    crate fn of(ek: &ExprKind<'_>) -> Option<Category> {\n+    crate fn of(ek: &ExprKind<'_, '_>) -> Option<Category> {\n         match *ek {\n             ExprKind::Scope { .. } => None,\n "}, {"sha": "4baf26dce6ad5caee7f8dfd7eadd46229fa0cf45", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=c2c432289195eaf65e42566ed0b95f82a913bcb3", "patch": "@@ -18,7 +18,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         destination: Place<'tcx>,\n         mut block: BasicBlock,\n-        expr: &Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<()> {\n         debug!(\"expr_into_dest(destination={:?}, block={:?}, expr={:?})\", destination, block, expr);\n "}, {"sha": "23e23f0885b77abbd45f63fe6080f5a8c28c4a40", "filename": "compiler/rustc_mir_build/src/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs?ref=c2c432289195eaf65e42566ed0b95f82a913bcb3", "patch": "@@ -13,7 +13,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn stmt_expr(\n         &mut self,\n         mut block: BasicBlock,\n-        expr: &Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n         statement_scope: Option<region::Scope>,\n     ) -> BlockAnd<()> {\n         let this = self;"}, {"sha": "098ed8b3eb8cec0b19bf53c8973d93d690a5a935", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=c2c432289195eaf65e42566ed0b95f82a913bcb3", "patch": "@@ -89,8 +89,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         destination: Place<'tcx>,\n         span: Span,\n         mut block: BasicBlock,\n-        scrutinee: &Expr<'tcx>,\n-        arms: &[Arm<'tcx>],\n+        scrutinee: &Expr<'_, 'tcx>,\n+        arms: &[Arm<'_, 'tcx>],\n     ) -> BlockAnd<()> {\n         let scrutinee_span = scrutinee.span;\n         let scrutinee_place =\n@@ -119,7 +119,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn lower_scrutinee(\n         &mut self,\n         mut block: BasicBlock,\n-        scrutinee: &Expr<'tcx>,\n+        scrutinee: &Expr<'_, 'tcx>,\n         scrutinee_span: Span,\n     ) -> BlockAnd<Place<'tcx>> {\n         let scrutinee_place = unpack!(block = self.as_place(block, scrutinee));\n@@ -149,8 +149,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn create_match_candidates<'pat>(\n         &mut self,\n         scrutinee: Place<'tcx>,\n-        arms: &'pat [Arm<'tcx>],\n-    ) -> Vec<(&'pat Arm<'tcx>, Candidate<'pat, 'tcx>)> {\n+        arms: &'pat [Arm<'pat, 'tcx>],\n+    ) -> Vec<(&'pat Arm<'pat, 'tcx>, Candidate<'pat, 'tcx>)> {\n         // Assemble a list of candidates: there is one candidate per pattern,\n         // which means there may be more than one candidate *per arm*.\n         arms.iter()\n@@ -224,7 +224,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         destination: Place<'tcx>,\n         scrutinee_place: Place<'tcx>,\n         scrutinee_span: Span,\n-        arm_candidates: Vec<(&'_ Arm<'tcx>, Candidate<'_, 'tcx>)>,\n+        arm_candidates: Vec<(&'_ Arm<'_, 'tcx>, Candidate<'_, 'tcx>)>,\n         outer_source_info: SourceInfo,\n         fake_borrow_temps: Vec<(Place<'tcx>, Local)>,\n     ) -> BlockAnd<()> {\n@@ -285,7 +285,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         outer_source_info: SourceInfo,\n         candidate: Candidate<'_, 'tcx>,\n-        guard: Option<&Guard<'tcx>>,\n+        guard: Option<&Guard<'_, 'tcx>>,\n         fake_borrow_temps: &Vec<(Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n         arm_span: Option<Span>,\n@@ -361,7 +361,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         mut block: BasicBlock,\n         irrefutable_pat: Pat<'tcx>,\n-        initializer: &Expr<'tcx>,\n+        initializer: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<()> {\n         match *irrefutable_pat.kind {\n             // Optimize the case of `let x = ...` to write directly into `x`\n@@ -1612,7 +1612,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         candidate: Candidate<'pat, 'tcx>,\n         parent_bindings: &[(Vec<Binding<'tcx>>, Vec<Ascription<'tcx>>)],\n-        guard: Option<&Guard<'tcx>>,\n+        guard: Option<&Guard<'_, 'tcx>>,\n         fake_borrows: &Vec<(Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n         arm_span: Option<Span>,"}, {"sha": "ef531a23921832e49c02ddb7e712a9f834c5e1d6", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=c2c432289195eaf65e42566ed0b95f82a913bcb3", "patch": "@@ -1,7 +1,7 @@\n use crate::build;\n use crate::build::scope::DropKind;\n-use crate::thir::cx::Cx;\n-use crate::thir::{BindingMode, Expr, LintLevel, Pat, PatKind};\n+use crate::thir::cx::build_thir;\n+use crate::thir::{Arena, BindingMode, Expr, LintLevel, Pat, PatKind};\n use rustc_attr::{self as attr, UnwindAttr};\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n@@ -43,6 +43,7 @@ crate fn mir_built<'tcx>(\n fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_> {\n     let id = tcx.hir().local_def_id_to_hir_id(def.did);\n     let body_owner_kind = tcx.hir().body_owner_kind(id);\n+    let typeck_results = tcx.typeck_opt_const_arg(def);\n \n     // Figure out what primary body this item has.\n     let (body_id, return_ty_span, span_with_body) = match tcx.hir().get(id) {\n@@ -87,15 +88,15 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n     // If we don't have a specialized span for the body, just use the\n     // normal def span.\n     let span_with_body = span_with_body.unwrap_or_else(|| tcx.hir().span(id));\n+    let arena = Arena::default();\n \n     tcx.infer_ctxt().enter(|infcx| {\n-        let mut cx = Cx::new(tcx, def);\n-        let body = if let Some(ErrorReported) = cx.typeck_results.tainted_by_errors {\n+        let body = if let Some(ErrorReported) = typeck_results.tainted_by_errors {\n             build::construct_error(&infcx, def, id, body_id, body_owner_kind)\n         } else if body_owner_kind.is_fn_or_closure() {\n             // fetch the fully liberated fn signature (that is, all bound\n             // types/lifetimes replaced)\n-            let fn_sig = cx.typeck_results.liberated_fn_sigs()[id];\n+            let fn_sig = typeck_results.liberated_fn_sigs()[id];\n             let fn_def_id = tcx.hir().local_def_id(id);\n \n             let safety = match fn_sig.unsafety {\n@@ -104,7 +105,7 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n             };\n \n             let body = tcx.hir().body(body_id);\n-            let expr = cx.mirror_expr(&body.value);\n+            let thir = build_thir(tcx, def, &arena, &body.value);\n             let ty = tcx.type_of(fn_def_id);\n             let mut abi = fn_sig.abi;\n             let implicit_argument = match ty.kind() {\n@@ -189,7 +190,7 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n                 return_ty,\n                 return_ty_span,\n                 body,\n-                expr,\n+                thir,\n                 span_with_body,\n             );\n             if yield_ty.is_some() {\n@@ -209,12 +210,12 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n             // place to be the type of the constant because NLL typeck will\n             // equate them.\n \n-            let return_ty = cx.typeck_results.node_type(id);\n+            let return_ty = typeck_results.node_type(id);\n \n             let ast_expr = &tcx.hir().body(body_id).value;\n-            let expr = cx.mirror_expr(ast_expr);\n+            let thir = build_thir(tcx, def, &arena, ast_expr);\n \n-            build::construct_const(&infcx, expr, def, id, return_ty, return_ty_span)\n+            build::construct_const(&infcx, thir, def, id, return_ty, return_ty_span)\n         };\n \n         lints::check(tcx, &body);\n@@ -601,7 +602,7 @@ fn construct_fn<'tcx, A>(\n     return_ty: Ty<'tcx>,\n     return_ty_span: Span,\n     body: &'tcx hir::Body<'tcx>,\n-    expr: Expr<'tcx>,\n+    expr: &Expr<'_, 'tcx>,\n     span_with_body: Span,\n ) -> Body<'tcx>\n where\n@@ -668,7 +669,7 @@ where\n \n fn construct_const<'a, 'tcx>(\n     infcx: &'a InferCtxt<'a, 'tcx>,\n-    expr: Expr<'tcx>,\n+    expr: &Expr<'_, 'tcx>,\n     def: ty::WithOptConstParam<LocalDefId>,\n     hir_id: hir::HirId,\n     const_ty: Ty<'tcx>,\n@@ -825,7 +826,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         fn_def_id: DefId,\n         arguments: &[ArgInfo<'tcx>],\n         argument_scope: region::Scope,\n-        expr: &Expr<'tcx>,\n+        expr: &Expr<'_, 'tcx>,\n     ) -> BlockAnd<()> {\n         // Allocate locals for the function arguments\n         for &ArgInfo(ty, _, arg_opt, _) in arguments.iter() {"}, {"sha": "b637b9b70bdc6d8c9c3461946151392a203f429a", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=c2c432289195eaf65e42566ed0b95f82a913bcb3", "patch": "@@ -574,7 +574,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn break_scope(\n         &mut self,\n         mut block: BasicBlock,\n-        value: Option<&Expr<'tcx>>,\n+        value: Option<&Expr<'_, 'tcx>>,\n         target: BreakableTarget,\n         source_info: SourceInfo,\n     ) -> BlockAnd<()> {\n@@ -918,7 +918,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn test_bool(\n         &mut self,\n         mut block: BasicBlock,\n-        condition: &Expr<'tcx>,\n+        condition: &Expr<'_, 'tcx>,\n         source_info: SourceInfo,\n     ) -> (BasicBlock, BasicBlock) {\n         let cond = unpack!(block = self.as_local_operand(block, condition));"}, {"sha": "aacc7b12a42f94bf67caf19e88b80249b5f585db", "filename": "compiler/rustc_mir_build/src/thir/arena.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Farena.rs?ref=c2c432289195eaf65e42566ed0b95f82a913bcb3", "patch": "@@ -0,0 +1,98 @@\n+use crate::thir::*;\n+\n+macro_rules! declare_arena {\n+    ([], [$($a:tt $name:ident: $ty:ty,)*]) => {\n+        #[derive(Default)]\n+        pub struct Arena<'thir, 'tcx> {\n+            pub dropless: rustc_arena::DroplessArena,\n+            drop: rustc_arena::DropArena,\n+            $($name: rustc_arena::arena_for_type!($a[$ty]),)*\n+        }\n+\n+        pub trait ArenaAllocatable<'thir, 'tcx, T = Self>: Sized {\n+            fn allocate_on(self, arena: &'thir Arena<'thir, 'tcx>) -> &'thir mut Self;\n+            fn allocate_from_iter(\n+                arena: &'thir Arena<'thir, 'tcx>,\n+                iter: impl ::std::iter::IntoIterator<Item = Self>,\n+            ) -> &'thir mut [Self];\n+        }\n+\n+        impl<'thir, 'tcx, T: Copy> ArenaAllocatable<'thir, 'tcx, ()> for T {\n+            #[inline]\n+            fn allocate_on(self, arena: &'thir Arena<'thir, 'tcx>) -> &'thir mut Self {\n+                arena.dropless.alloc(self)\n+            }\n+            #[inline]\n+            fn allocate_from_iter(\n+                arena: &'thir Arena<'thir, 'tcx>,\n+                iter: impl ::std::iter::IntoIterator<Item = Self>,\n+            ) -> &'thir mut [Self] {\n+                arena.dropless.alloc_from_iter(iter)\n+            }\n+\n+        }\n+        $(\n+            impl<'thir, 'tcx> ArenaAllocatable<'thir, 'tcx, $ty> for $ty {\n+                #[inline]\n+                fn allocate_on(self, arena: &'thir Arena<'thir, 'tcx>) -> &'thir mut Self {\n+                    if !::std::mem::needs_drop::<Self>() {\n+                        return arena.dropless.alloc(self);\n+                    }\n+                    match rustc_arena::which_arena_for_type!($a[&arena.$name]) {\n+                        ::std::option::Option::<&rustc_arena::TypedArena<Self>>::Some(ty_arena) => {\n+                            ty_arena.alloc(self)\n+                        }\n+                        ::std::option::Option::None => unsafe { arena.drop.alloc(self) },\n+                    }\n+                }\n+\n+                #[inline]\n+                fn allocate_from_iter(\n+                    arena: &'thir Arena<'thir, 'tcx>,\n+                    iter: impl ::std::iter::IntoIterator<Item = Self>,\n+                ) -> &'thir mut [Self] {\n+                    if !::std::mem::needs_drop::<Self>() {\n+                        return arena.dropless.alloc_from_iter(iter);\n+                    }\n+                    match rustc_arena::which_arena_for_type!($a[&arena.$name]) {\n+                        ::std::option::Option::<&rustc_arena::TypedArena<Self>>::Some(ty_arena) => {\n+                            ty_arena.alloc_from_iter(iter)\n+                        }\n+                        ::std::option::Option::None => unsafe { arena.drop.alloc_from_iter(iter) },\n+                    }\n+                }\n+            }\n+        )*\n+\n+        impl<'thir, 'tcx> Arena<'thir, 'tcx> {\n+            #[inline]\n+            pub fn alloc<T: ArenaAllocatable<'thir, 'tcx, U>, U>(&'thir self, value: T) -> &'thir mut T {\n+                value.allocate_on(self)\n+            }\n+\n+            #[allow(dead_code)] // function is never used\n+            #[inline]\n+            pub fn alloc_slice<T: ::std::marker::Copy>(&'thir self, value: &[T]) -> &'thir mut [T] {\n+                if value.is_empty() {\n+                    return &mut [];\n+                }\n+                self.dropless.alloc_slice(value)\n+            }\n+\n+            pub fn alloc_from_iter<T: ArenaAllocatable<'thir, 'tcx, U>, U>(\n+                &'thir self,\n+                iter: impl ::std::iter::IntoIterator<Item = T>,\n+            ) -> &'thir mut [T] {\n+                T::allocate_from_iter(self, iter)\n+            }\n+        }\n+    }\n+}\n+\n+declare_arena!([], [\n+    [] arm: Arm<'thir, 'tcx>,\n+    [] expr: Expr<'thir, 'tcx>,\n+    [] field_expr: FieldExpr<'thir, 'tcx>,\n+    [few] inline_asm_operand: InlineAsmOperand<'thir, 'tcx>,\n+    [] stmt: Stmt<'thir, 'tcx>,\n+]);"}, {"sha": "2ec102282c28e854972db1f7f3b44cf59a123434", "filename": "compiler/rustc_mir_build/src/thir/cx/block.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs?ref=c2c432289195eaf65e42566ed0b95f82a913bcb3", "patch": "@@ -7,8 +7,8 @@ use rustc_middle::ty;\n \n use rustc_index::vec::Idx;\n \n-impl<'tcx> Cx<'tcx> {\n-    crate fn mirror_block(&mut self, block: &'tcx hir::Block<'tcx>) -> Block<'tcx> {\n+impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n+    crate fn mirror_block(&mut self, block: &'tcx hir::Block<'tcx>) -> Block<'thir, 'tcx> {\n         // We have to eagerly lower the \"spine\" of the statements\n         // in order to get the lexical scoping correctly.\n         let stmts = self.mirror_stmts(block.hir_id.local_id, &*block.stmts);\n@@ -23,7 +23,7 @@ impl<'tcx> Cx<'tcx> {\n             opt_destruction_scope,\n             span: block.span,\n             stmts,\n-            expr: block.expr.as_ref().map(|expr| self.mirror_expr_boxed(expr)),\n+            expr: block.expr.as_ref().map(|expr| self.mirror_expr(expr)),\n             safety_mode: match block.rules {\n                 hir::BlockCheckMode::DefaultBlock => BlockSafety::Safe,\n                 hir::BlockCheckMode::UnsafeBlock(..) => BlockSafety::ExplicitUnsafe(block.hir_id),\n@@ -37,26 +37,21 @@ impl<'tcx> Cx<'tcx> {\n         &mut self,\n         block_id: hir::ItemLocalId,\n         stmts: &'tcx [hir::Stmt<'tcx>],\n-    ) -> Vec<Stmt<'tcx>> {\n-        let mut result = vec![];\n-        for (index, stmt) in stmts.iter().enumerate() {\n+    ) -> &'thir [Stmt<'thir, 'tcx>] {\n+        self.arena.alloc_from_iter(stmts.iter().enumerate().filter_map(|(index, stmt)| {\n             let hir_id = stmt.hir_id;\n             let opt_dxn_ext = self.region_scope_tree.opt_destruction_scope(hir_id.local_id);\n             match stmt.kind {\n-                hir::StmtKind::Expr(ref expr) | hir::StmtKind::Semi(ref expr) => {\n-                    result.push(Stmt {\n-                        kind: StmtKind::Expr {\n-                            scope: region::Scope {\n-                                id: hir_id.local_id,\n-                                data: region::ScopeData::Node,\n-                            },\n-                            expr: self.mirror_expr_boxed(expr),\n-                        },\n-                        opt_destruction_scope: opt_dxn_ext,\n-                    })\n-                }\n+                hir::StmtKind::Expr(ref expr) | hir::StmtKind::Semi(ref expr) => Some(Stmt {\n+                    kind: StmtKind::Expr {\n+                        scope: region::Scope { id: hir_id.local_id, data: region::ScopeData::Node },\n+                        expr: self.mirror_expr(expr),\n+                    },\n+                    opt_destruction_scope: opt_dxn_ext,\n+                }),\n                 hir::StmtKind::Item(..) => {\n                     // ignore for purposes of the MIR\n+                    None\n                 }\n                 hir::StmtKind::Local(ref local) => {\n                     let remainder_scope = region::Scope {\n@@ -86,22 +81,21 @@ impl<'tcx> Cx<'tcx> {\n                         }\n                     }\n \n-                    result.push(Stmt {\n+                    Some(Stmt {\n                         kind: StmtKind::Let {\n                             remainder_scope,\n                             init_scope: region::Scope {\n                                 id: hir_id.local_id,\n                                 data: region::ScopeData::Node,\n                             },\n                             pattern,\n-                            initializer: local.init.map(|init| self.mirror_expr_boxed(init)),\n+                            initializer: local.init.map(|init| self.mirror_expr(init)),\n                             lint_level: LintLevel::Explicit(local.hir_id),\n                         },\n                         opt_destruction_scope: opt_dxn_ext,\n-                    });\n+                    })\n                 }\n             }\n-        }\n-        result\n+        }))\n     }\n }"}, {"sha": "73ec9ac4dcf860d3d393887d900d7fbad7d155fe", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 264, "deletions": 230, "changes": 494, "blob_url": "https://github.com/rust-lang/rust/blob/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=c2c432289195eaf65e42566ed0b95f82a913bcb3", "patch": "@@ -15,8 +15,33 @@ use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n use rustc_middle::ty::{self, AdtKind, Ty};\n use rustc_span::Span;\n \n-impl<'tcx> Cx<'tcx> {\n-    crate fn mirror_expr(&mut self, hir_expr: &'tcx hir::Expr<'tcx>) -> Expr<'tcx> {\n+use std::iter;\n+\n+impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n+    /// Mirrors and allocates a single [`hir::Expr`]. If you need to mirror a whole slice\n+    /// of expressions, prefer using [`mirror_exprs`].\n+    ///\n+    /// [`mirror_exprs`]: Self::mirror_exprs\n+    crate fn mirror_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) -> &'thir Expr<'thir, 'tcx> {\n+        self.arena.alloc(self.mirror_expr_inner(expr))\n+    }\n+\n+    /// Mirrors and allocates a slice of [`hir::Expr`]s. They will be allocated as a\n+    /// contiguous sequence in memory.\n+    crate fn mirror_exprs(&mut self, exprs: &'tcx [hir::Expr<'tcx>]) -> &'thir [Expr<'thir, 'tcx>] {\n+        self.arena.alloc_from_iter(exprs.iter().map(|expr| self.mirror_expr_inner(expr)))\n+    }\n+\n+    /// Mirrors a [`hir::Expr`] without allocating it into the arena.\n+    /// This is a separate, private function so that [`mirror_expr`] and [`mirror_exprs`] can\n+    /// decide how to allocate this expression (alone or within a slice).\n+    ///\n+    /// [`mirror_expr`]: Self::mirror_expr\n+    /// [`mirror_exprs`]: Self::mirror_exprs\n+    pub(super) fn mirror_expr_inner(\n+        &mut self,\n+        hir_expr: &'tcx hir::Expr<'tcx>,\n+    ) -> Expr<'thir, 'tcx> {\n         let temp_lifetime = self.region_scope_tree.temporary_scope(hir_expr.hir_id.local_id);\n         let expr_scope =\n             region::Scope { id: hir_expr.hir_id.local_id, data: region::ScopeData::Node };\n@@ -38,7 +63,7 @@ impl<'tcx> Cx<'tcx> {\n             span: hir_expr.span,\n             kind: ExprKind::Scope {\n                 region_scope: expr_scope,\n-                value: Box::new(expr),\n+                value: self.arena.alloc(expr),\n                 lint_level: LintLevel::Explicit(hir_expr.hir_id),\n             },\n         };\n@@ -53,7 +78,7 @@ impl<'tcx> Cx<'tcx> {\n                 span: hir_expr.span,\n                 kind: ExprKind::Scope {\n                     region_scope,\n-                    value: Box::new(expr),\n+                    value: self.arena.alloc(expr),\n                     lint_level: LintLevel::Inherited,\n                 },\n             };\n@@ -63,20 +88,12 @@ impl<'tcx> Cx<'tcx> {\n         expr\n     }\n \n-    crate fn mirror_exprs(&mut self, exprs: &'tcx [hir::Expr<'tcx>]) -> Vec<Expr<'tcx>> {\n-        exprs.iter().map(|expr| self.mirror_expr(expr)).collect()\n-    }\n-\n-    crate fn mirror_expr_boxed(&mut self, expr: &'tcx hir::Expr<'tcx>) -> Box<Expr<'tcx>> {\n-        Box::new(self.mirror_expr(expr))\n-    }\n-\n     fn apply_adjustment(\n         &mut self,\n         hir_expr: &'tcx hir::Expr<'tcx>,\n-        mut expr: Expr<'tcx>,\n+        mut expr: Expr<'thir, 'tcx>,\n         adjustment: &Adjustment<'tcx>,\n-    ) -> Expr<'tcx> {\n+    ) -> Expr<'thir, 'tcx> {\n         let Expr { temp_lifetime, mut span, .. } = expr;\n \n         // Adjust the span from the block, to the last expression of the\n@@ -89,7 +106,7 @@ impl<'tcx> Cx<'tcx> {\n         //      x\n         //   // ^ error message points at this expression.\n         // }\n-        let mut adjust_span = |expr: &mut Expr<'tcx>| {\n+        let mut adjust_span = |expr: &mut Expr<'thir, 'tcx>| {\n             if let ExprKind::Block { body } = &expr.kind {\n                 if let Some(ref last_expr) = body.expr {\n                     span = last_expr.span;\n@@ -101,13 +118,13 @@ impl<'tcx> Cx<'tcx> {\n         let kind = match adjustment.kind {\n             Adjust::Pointer(PointerCast::Unsize) => {\n                 adjust_span(&mut expr);\n-                ExprKind::Pointer { cast: PointerCast::Unsize, source: Box::new(expr) }\n+                ExprKind::Pointer { cast: PointerCast::Unsize, source: self.arena.alloc(expr) }\n             }\n-            Adjust::Pointer(cast) => ExprKind::Pointer { cast, source: Box::new(expr) },\n-            Adjust::NeverToAny => ExprKind::NeverToAny { source: Box::new(expr) },\n+            Adjust::Pointer(cast) => ExprKind::Pointer { cast, source: self.arena.alloc(expr) },\n+            Adjust::NeverToAny => ExprKind::NeverToAny { source: self.arena.alloc(expr) },\n             Adjust::Deref(None) => {\n                 adjust_span(&mut expr);\n-                ExprKind::Deref { arg: Box::new(expr) }\n+                ExprKind::Deref { arg: self.arena.alloc(expr) }\n             }\n             Adjust::Deref(Some(deref)) => {\n                 // We don't need to do call adjust_span here since\n@@ -122,30 +139,30 @@ impl<'tcx> Cx<'tcx> {\n                     span,\n                     kind: ExprKind::Borrow {\n                         borrow_kind: deref.mutbl.to_borrow_kind(),\n-                        arg: Box::new(expr),\n+                        arg: self.arena.alloc(expr),\n                     },\n                 };\n \n                 self.overloaded_place(\n                     hir_expr,\n                     adjustment.target,\n                     Some(call),\n-                    vec![expr],\n+                    self.arena.alloc_from_iter(iter::once(expr)),\n                     deref.span,\n                 )\n             }\n             Adjust::Borrow(AutoBorrow::Ref(_, m)) => {\n-                ExprKind::Borrow { borrow_kind: m.to_borrow_kind(), arg: Box::new(expr) }\n+                ExprKind::Borrow { borrow_kind: m.to_borrow_kind(), arg: self.arena.alloc(expr) }\n             }\n             Adjust::Borrow(AutoBorrow::RawPtr(mutability)) => {\n-                ExprKind::AddressOf { mutability, arg: Box::new(expr) }\n+                ExprKind::AddressOf { mutability, arg: self.arena.alloc(expr) }\n             }\n         };\n \n         Expr { temp_lifetime, ty: adjustment.target, span, kind }\n     }\n \n-    fn make_mirror_unadjusted(&mut self, expr: &'tcx hir::Expr<'tcx>) -> Expr<'tcx> {\n+    fn make_mirror_unadjusted(&mut self, expr: &'tcx hir::Expr<'tcx>) -> Expr<'thir, 'tcx> {\n         let expr_ty = self.typeck_results().expr_ty(expr);\n         let temp_lifetime = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n@@ -157,7 +174,7 @@ impl<'tcx> Cx<'tcx> {\n                 let args = self.mirror_exprs(args);\n                 ExprKind::Call {\n                     ty: expr.ty,\n-                    fun: Box::new(expr),\n+                    fun: self.arena.alloc(expr),\n                     args,\n                     from_hir_call: true,\n                     fn_span,\n@@ -185,8 +202,10 @@ impl<'tcx> Cx<'tcx> {\n \n                     ExprKind::Call {\n                         ty: method.ty,\n-                        fun: Box::new(method),\n-                        args: vec![self.mirror_expr(fun), tupled_args],\n+                        fun: self.arena.alloc(method),\n+                        args: &*self\n+                            .arena\n+                            .alloc_from_iter(vec![self.mirror_expr_inner(fun), tupled_args]),\n                         from_hir_call: true,\n                         fn_span: expr.span,\n                     }\n@@ -216,26 +235,22 @@ impl<'tcx> Cx<'tcx> {\n                             });\n                         debug!(\"make_mirror_unadjusted: (call) user_ty={:?}\", user_ty);\n \n-                        let field_refs = args\n-                            .iter()\n-                            .enumerate()\n-                            .map(|(idx, e)| FieldExpr {\n-                                name: Field::new(idx),\n-                                expr: self.mirror_expr(e),\n-                            })\n-                            .collect();\n+                        let field_refs =\n+                            self.arena.alloc_from_iter(args.iter().enumerate().map(|(idx, e)| {\n+                                FieldExpr { name: Field::new(idx), expr: self.mirror_expr(e) }\n+                            }));\n                         ExprKind::Adt {\n                             adt_def,\n                             substs,\n                             variant_index: index,\n-                            fields: field_refs,\n+                            fields: &*field_refs,\n                             user_ty,\n                             base: None,\n                         }\n                     } else {\n                         ExprKind::Call {\n                             ty: self.typeck_results().node_type(fun.hir_id),\n-                            fun: self.mirror_expr_boxed(fun),\n+                            fun: self.mirror_expr(fun),\n                             args: self.mirror_exprs(args),\n                             from_hir_call: true,\n                             fn_span: expr.span,\n@@ -244,32 +259,30 @@ impl<'tcx> Cx<'tcx> {\n                 }\n             }\n \n-            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, mutbl, ref arg) => ExprKind::Borrow {\n-                borrow_kind: mutbl.to_borrow_kind(),\n-                arg: self.mirror_expr_boxed(arg),\n-            },\n+            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, mutbl, ref arg) => {\n+                ExprKind::Borrow { borrow_kind: mutbl.to_borrow_kind(), arg: self.mirror_expr(arg) }\n+            }\n \n             hir::ExprKind::AddrOf(hir::BorrowKind::Raw, mutability, ref arg) => {\n-                ExprKind::AddressOf { mutability, arg: self.mirror_expr_boxed(arg) }\n+                ExprKind::AddressOf { mutability, arg: self.mirror_expr(arg) }\n             }\n \n             hir::ExprKind::Block(ref blk, _) => ExprKind::Block { body: self.mirror_block(blk) },\n \n-            hir::ExprKind::Assign(ref lhs, ref rhs, _) => ExprKind::Assign {\n-                lhs: self.mirror_expr_boxed(lhs),\n-                rhs: self.mirror_expr_boxed(rhs),\n-            },\n+            hir::ExprKind::Assign(ref lhs, ref rhs, _) => {\n+                ExprKind::Assign { lhs: self.mirror_expr(lhs), rhs: self.mirror_expr(rhs) }\n+            }\n \n             hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                 if self.typeck_results().is_method_call(expr) {\n-                    let lhs = self.mirror_expr(lhs);\n-                    let rhs = self.mirror_expr(rhs);\n-                    self.overloaded_operator(expr, vec![lhs, rhs])\n+                    let lhs = self.mirror_expr_inner(lhs);\n+                    let rhs = self.mirror_expr_inner(rhs);\n+                    self.overloaded_operator(expr, &*self.arena.alloc_from_iter(vec![lhs, rhs]))\n                 } else {\n                     ExprKind::AssignOp {\n                         op: bin_op(op.node),\n-                        lhs: self.mirror_expr_boxed(lhs),\n-                        rhs: self.mirror_expr_boxed(rhs),\n+                        lhs: self.mirror_expr(lhs),\n+                        rhs: self.mirror_expr(rhs),\n                     }\n                 }\n             }\n@@ -282,29 +295,29 @@ impl<'tcx> Cx<'tcx> {\n \n             hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n                 if self.typeck_results().is_method_call(expr) {\n-                    let lhs = self.mirror_expr(lhs);\n-                    let rhs = self.mirror_expr(rhs);\n-                    self.overloaded_operator(expr, vec![lhs, rhs])\n+                    let lhs = self.mirror_expr_inner(lhs);\n+                    let rhs = self.mirror_expr_inner(rhs);\n+                    self.overloaded_operator(expr, &*self.arena.alloc_from_iter(vec![lhs, rhs]))\n                 } else {\n                     // FIXME overflow\n                     match op.node {\n                         hir::BinOpKind::And => ExprKind::LogicalOp {\n                             op: LogicalOp::And,\n-                            lhs: self.mirror_expr_boxed(lhs),\n-                            rhs: self.mirror_expr_boxed(rhs),\n+                            lhs: self.mirror_expr(lhs),\n+                            rhs: self.mirror_expr(rhs),\n                         },\n                         hir::BinOpKind::Or => ExprKind::LogicalOp {\n                             op: LogicalOp::Or,\n-                            lhs: self.mirror_expr_boxed(lhs),\n-                            rhs: self.mirror_expr_boxed(rhs),\n+                            lhs: self.mirror_expr(lhs),\n+                            rhs: self.mirror_expr(rhs),\n                         },\n \n                         _ => {\n                             let op = bin_op(op.node);\n                             ExprKind::Binary {\n                                 op,\n-                                lhs: self.mirror_expr_boxed(lhs),\n-                                rhs: self.mirror_expr_boxed(rhs),\n+                                lhs: self.mirror_expr(lhs),\n+                                rhs: self.mirror_expr(rhs),\n                             }\n                         }\n                     }\n@@ -313,47 +326,56 @@ impl<'tcx> Cx<'tcx> {\n \n             hir::ExprKind::Index(ref lhs, ref index) => {\n                 if self.typeck_results().is_method_call(expr) {\n-                    let lhs = self.mirror_expr(lhs);\n-                    let index = self.mirror_expr(index);\n-                    self.overloaded_place(expr, expr_ty, None, vec![lhs, index], expr.span)\n+                    let lhs = self.mirror_expr_inner(lhs);\n+                    let index = self.mirror_expr_inner(index);\n+                    self.overloaded_place(\n+                        expr,\n+                        expr_ty,\n+                        None,\n+                        &*self.arena.alloc_from_iter(vec![lhs, index]),\n+                        expr.span,\n+                    )\n                 } else {\n-                    ExprKind::Index {\n-                        lhs: self.mirror_expr_boxed(lhs),\n-                        index: self.mirror_expr_boxed(index),\n-                    }\n+                    ExprKind::Index { lhs: self.mirror_expr(lhs), index: self.mirror_expr(index) }\n                 }\n             }\n \n             hir::ExprKind::Unary(hir::UnOp::Deref, ref arg) => {\n                 if self.typeck_results().is_method_call(expr) {\n-                    let arg = self.mirror_expr(arg);\n-                    self.overloaded_place(expr, expr_ty, None, vec![arg], expr.span)\n+                    let arg = self.mirror_expr_inner(arg);\n+                    self.overloaded_place(\n+                        expr,\n+                        expr_ty,\n+                        None,\n+                        &*self.arena.alloc_from_iter(iter::once(arg)),\n+                        expr.span,\n+                    )\n                 } else {\n-                    ExprKind::Deref { arg: self.mirror_expr_boxed(arg) }\n+                    ExprKind::Deref { arg: self.mirror_expr(arg) }\n                 }\n             }\n \n             hir::ExprKind::Unary(hir::UnOp::Not, ref arg) => {\n                 if self.typeck_results().is_method_call(expr) {\n-                    let arg = self.mirror_expr(arg);\n-                    self.overloaded_operator(expr, vec![arg])\n+                    let arg = self.mirror_expr_inner(arg);\n+                    self.overloaded_operator(expr, &*self.arena.alloc_from_iter(iter::once(arg)))\n                 } else {\n-                    ExprKind::Unary { op: UnOp::Not, arg: self.mirror_expr_boxed(arg) }\n+                    ExprKind::Unary { op: UnOp::Not, arg: self.mirror_expr(arg) }\n                 }\n             }\n \n             hir::ExprKind::Unary(hir::UnOp::Neg, ref arg) => {\n                 if self.typeck_results().is_method_call(expr) {\n-                    let arg = self.mirror_expr(arg);\n-                    self.overloaded_operator(expr, vec![arg])\n+                    let arg = self.mirror_expr_inner(arg);\n+                    self.overloaded_operator(expr, &*self.arena.alloc_from_iter(iter::once(arg)))\n                 } else if let hir::ExprKind::Lit(ref lit) = arg.kind {\n                     ExprKind::Literal {\n                         literal: self.const_eval_literal(&lit.node, expr_ty, lit.span, true),\n                         user_ty: None,\n                         const_id: None,\n                     }\n                 } else {\n-                    ExprKind::Unary { op: UnOp::Neg, arg: self.mirror_expr_boxed(arg) }\n+                    ExprKind::Unary { op: UnOp::Neg, arg: self.mirror_expr(arg) }\n                 }\n             }\n \n@@ -370,9 +392,12 @@ impl<'tcx> Cx<'tcx> {\n                             user_ty,\n                             fields: self.field_refs(fields),\n                             base: base.as_ref().map(|base| FruInfo {\n-                                base: self.mirror_expr_boxed(base),\n-                                field_types: self.typeck_results().fru_field_types()[expr.hir_id]\n-                                    .clone(),\n+                                base: self.mirror_expr(base),\n+                                field_types: self.arena.alloc_from_iter(\n+                                    self.typeck_results().fru_field_types()[expr.hir_id]\n+                                        .iter()\n+                                        .cloned(),\n+                                ),\n                             }),\n                         }\n                     }\n@@ -419,12 +444,12 @@ impl<'tcx> Cx<'tcx> {\n                     }\n                 };\n \n-                let upvars = self\n-                    .typeck_results\n-                    .closure_min_captures_flattened(def_id)\n-                    .zip(substs.upvar_tys())\n-                    .map(|(captured_place, ty)| self.capture_upvar(expr, captured_place, ty))\n-                    .collect();\n+                let upvars = self.arena.alloc_from_iter(\n+                    self.typeck_results\n+                        .closure_min_captures_flattened(def_id)\n+                        .zip(substs.upvar_tys())\n+                        .map(|(captured_place, ty)| self.capture_upvar(expr, captured_place, ty)),\n+                );\n                 ExprKind::Closure { closure_id: def_id, substs, upvars, movability }\n             }\n \n@@ -435,100 +460,95 @@ impl<'tcx> Cx<'tcx> {\n \n             hir::ExprKind::InlineAsm(ref asm) => ExprKind::InlineAsm {\n                 template: asm.template,\n-                operands: asm\n-                    .operands\n-                    .iter()\n-                    .map(|(op, _op_sp)| {\n-                        match *op {\n-                            hir::InlineAsmOperand::In { reg, ref expr } => {\n-                                InlineAsmOperand::In { reg, expr: self.mirror_expr(expr) }\n-                            }\n-                            hir::InlineAsmOperand::Out { reg, late, ref expr } => {\n-                                InlineAsmOperand::Out {\n-                                    reg,\n-                                    late,\n-                                    expr: expr.as_ref().map(|expr| self.mirror_expr(expr)),\n-                                }\n-                            }\n-                            hir::InlineAsmOperand::InOut { reg, late, ref expr } => {\n-                                InlineAsmOperand::InOut { reg, late, expr: self.mirror_expr(expr) }\n-                            }\n-                            hir::InlineAsmOperand::SplitInOut {\n-                                reg,\n-                                late,\n-                                ref in_expr,\n-                                ref out_expr,\n-                            } => InlineAsmOperand::SplitInOut {\n+                operands: self.arena.alloc_from_iter(asm.operands.iter().map(|(op, _op_sp)| {\n+                    match *op {\n+                        hir::InlineAsmOperand::In { reg, ref expr } => {\n+                            InlineAsmOperand::In { reg, expr: self.mirror_expr(expr) }\n+                        }\n+                        hir::InlineAsmOperand::Out { reg, late, ref expr } => {\n+                            InlineAsmOperand::Out {\n                                 reg,\n                                 late,\n-                                in_expr: self.mirror_expr(in_expr),\n-                                out_expr: out_expr.as_ref().map(|expr| self.mirror_expr(expr)),\n-                            },\n-                            hir::InlineAsmOperand::Const { ref expr } => {\n-                                InlineAsmOperand::Const { expr: self.mirror_expr(expr) }\n+                                expr: expr.as_ref().map(|expr| self.mirror_expr(expr)),\n                             }\n-                            hir::InlineAsmOperand::Sym { ref expr } => {\n-                                let qpath = match expr.kind {\n-                                    hir::ExprKind::Path(ref qpath) => qpath,\n-                                    _ => span_bug!(\n-                                        expr.span,\n-                                        \"asm `sym` operand should be a path, found {:?}\",\n-                                        expr.kind\n-                                    ),\n-                                };\n-                                let temp_lifetime =\n-                                    self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-                                let res = self.typeck_results().qpath_res(qpath, expr.hir_id);\n-                                let ty;\n-                                match res {\n-                                    Res::Def(DefKind::Fn, _) | Res::Def(DefKind::AssocFn, _) => {\n-                                        ty = self.typeck_results().node_type(expr.hir_id);\n-                                        let user_ty =\n-                                            self.user_substs_applied_to_res(expr.hir_id, res);\n-                                        InlineAsmOperand::SymFn {\n-                                            expr: Expr {\n-                                                ty,\n-                                                temp_lifetime,\n-                                                span: expr.span,\n-                                                kind: ExprKind::Literal {\n-                                                    literal: ty::Const::zero_sized(self.tcx, ty),\n-                                                    user_ty,\n-                                                    const_id: None,\n-                                                },\n+                        }\n+                        hir::InlineAsmOperand::InOut { reg, late, ref expr } => {\n+                            InlineAsmOperand::InOut { reg, late, expr: self.mirror_expr(expr) }\n+                        }\n+                        hir::InlineAsmOperand::SplitInOut {\n+                            reg,\n+                            late,\n+                            ref in_expr,\n+                            ref out_expr,\n+                        } => InlineAsmOperand::SplitInOut {\n+                            reg,\n+                            late,\n+                            in_expr: self.mirror_expr(in_expr),\n+                            out_expr: out_expr.as_ref().map(|expr| self.mirror_expr(expr)),\n+                        },\n+                        hir::InlineAsmOperand::Const { ref expr } => {\n+                            InlineAsmOperand::Const { expr: self.mirror_expr(expr) }\n+                        }\n+                        hir::InlineAsmOperand::Sym { ref expr } => {\n+                            let qpath = match expr.kind {\n+                                hir::ExprKind::Path(ref qpath) => qpath,\n+                                _ => span_bug!(\n+                                    expr.span,\n+                                    \"asm `sym` operand should be a path, found {:?}\",\n+                                    expr.kind\n+                                ),\n+                            };\n+                            let temp_lifetime =\n+                                self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+                            let res = self.typeck_results().qpath_res(qpath, expr.hir_id);\n+                            let ty;\n+                            match res {\n+                                Res::Def(DefKind::Fn, _) | Res::Def(DefKind::AssocFn, _) => {\n+                                    ty = self.typeck_results().node_type(expr.hir_id);\n+                                    let user_ty = self.user_substs_applied_to_res(expr.hir_id, res);\n+                                    InlineAsmOperand::SymFn {\n+                                        expr: self.arena.alloc(Expr {\n+                                            ty,\n+                                            temp_lifetime,\n+                                            span: expr.span,\n+                                            kind: ExprKind::Literal {\n+                                                literal: ty::Const::zero_sized(self.tcx, ty),\n+                                                user_ty,\n+                                                const_id: None,\n                                             },\n-                                        }\n+                                        }),\n                                     }\n+                                }\n \n-                                    Res::Def(DefKind::Static, def_id) => {\n-                                        InlineAsmOperand::SymStatic { def_id }\n-                                    }\n+                                Res::Def(DefKind::Static, def_id) => {\n+                                    InlineAsmOperand::SymStatic { def_id }\n+                                }\n \n-                                    _ => {\n-                                        self.tcx.sess.span_err(\n-                                            expr.span,\n-                                            \"asm `sym` operand must point to a fn or static\",\n-                                        );\n-\n-                                        // Not a real fn, but we're not reaching codegen anyways...\n-                                        ty = self.tcx.ty_error();\n-                                        InlineAsmOperand::SymFn {\n-                                            expr: Expr {\n-                                                ty,\n-                                                temp_lifetime,\n-                                                span: expr.span,\n-                                                kind: ExprKind::Literal {\n-                                                    literal: ty::Const::zero_sized(self.tcx, ty),\n-                                                    user_ty: None,\n-                                                    const_id: None,\n-                                                },\n+                                _ => {\n+                                    self.tcx.sess.span_err(\n+                                        expr.span,\n+                                        \"asm `sym` operand must point to a fn or static\",\n+                                    );\n+\n+                                    // Not a real fn, but we're not reaching codegen anyways...\n+                                    ty = self.tcx.ty_error();\n+                                    InlineAsmOperand::SymFn {\n+                                        expr: self.arena.alloc(Expr {\n+                                            ty,\n+                                            temp_lifetime,\n+                                            span: expr.span,\n+                                            kind: ExprKind::Literal {\n+                                                literal: ty::Const::zero_sized(self.tcx, ty),\n+                                                user_ty: None,\n+                                                const_id: None,\n                                             },\n-                                        }\n+                                        }),\n                                     }\n                                 }\n                             }\n                         }\n-                    })\n-                    .collect(),\n+                    }\n+                })),\n                 options: asm.options,\n                 line_spans: asm.line_spans,\n             },\n@@ -550,15 +570,15 @@ impl<'tcx> Cx<'tcx> {\n                 let count_def_id = self.tcx.hir().local_def_id(count.hir_id);\n                 let count = ty::Const::from_anon_const(self.tcx, count_def_id);\n \n-                ExprKind::Repeat { value: self.mirror_expr_boxed(v), count }\n+                ExprKind::Repeat { value: self.mirror_expr(v), count }\n             }\n             hir::ExprKind::Ret(ref v) => {\n-                ExprKind::Return { value: v.as_ref().map(|v| self.mirror_expr_boxed(v)) }\n+                ExprKind::Return { value: v.as_ref().map(|v| self.mirror_expr(v)) }\n             }\n             hir::ExprKind::Break(dest, ref value) => match dest.target_id {\n                 Ok(target_id) => ExprKind::Break {\n                     label: region::Scope { id: target_id.local_id, data: region::ScopeData::Node },\n-                    value: value.as_ref().map(|value| self.mirror_expr_boxed(value)),\n+                    value: value.as_ref().map(|value| self.mirror_expr(value)),\n                 },\n                 Err(err) => bug!(\"invalid loop id for break: {}\", err),\n             },\n@@ -569,19 +589,19 @@ impl<'tcx> Cx<'tcx> {\n                 Err(err) => bug!(\"invalid loop id for continue: {}\", err),\n             },\n             hir::ExprKind::If(cond, then, else_opt) => ExprKind::If {\n-                cond: self.mirror_expr_boxed(cond),\n-                then: self.mirror_expr_boxed(then),\n-                else_opt: else_opt.map(|el| self.mirror_expr_boxed(el)),\n+                cond: self.mirror_expr(cond),\n+                then: self.mirror_expr(then),\n+                else_opt: else_opt.map(|el| self.mirror_expr(el)),\n             },\n             hir::ExprKind::Match(ref discr, ref arms, _) => ExprKind::Match {\n-                scrutinee: self.mirror_expr_boxed(discr),\n-                arms: arms.iter().map(|a| self.convert_arm(a)).collect(),\n+                scrutinee: self.mirror_expr(discr),\n+                arms: self.arena.alloc_from_iter(arms.iter().map(|a| self.convert_arm(a))),\n             },\n             hir::ExprKind::Loop(ref body, ..) => {\n                 let block_ty = self.typeck_results().node_type(body.hir_id);\n                 let temp_lifetime = self.region_scope_tree.temporary_scope(body.hir_id.local_id);\n                 let block = self.mirror_block(body);\n-                let body = Box::new(Expr {\n+                let body = self.arena.alloc(Expr {\n                     ty: block_ty,\n                     temp_lifetime,\n                     span: block.span,\n@@ -590,7 +610,7 @@ impl<'tcx> Cx<'tcx> {\n                 ExprKind::Loop { body }\n             }\n             hir::ExprKind::Field(ref source, ..) => ExprKind::Field {\n-                lhs: self.mirror_expr_boxed(source),\n+                lhs: self.mirror_expr(source),\n                 name: Field::new(self.tcx.field_index(expr.hir_id, self.typeck_results)),\n             },\n             hir::ExprKind::Cast(ref source, ref cast_ty) => {\n@@ -607,13 +627,13 @@ impl<'tcx> Cx<'tcx> {\n                 // using a coercion (or is a no-op).\n                 let cast = if self.typeck_results().is_coercion_cast(source.hir_id) {\n                     // Convert the lexpr to a vexpr.\n-                    ExprKind::Use { source: self.mirror_expr_boxed(source) }\n+                    ExprKind::Use { source: self.mirror_expr(source) }\n                 } else if self.typeck_results().expr_ty(source).is_region_ptr() {\n                     // Special cased so that we can type check that the element\n                     // type of the source matches the pointed to type of the\n                     // destination.\n                     ExprKind::Pointer {\n-                        source: self.mirror_expr_boxed(source),\n+                        source: self.mirror_expr(source),\n                         cast: PointerCast::ArrayToPointer,\n                     }\n                 } else {\n@@ -651,11 +671,13 @@ impl<'tcx> Cx<'tcx> {\n                     };\n \n                     let source = if let Some((did, offset, var_ty)) = var {\n-                        let mk_const = |literal| Expr {\n-                            temp_lifetime,\n-                            ty: var_ty,\n-                            span: expr.span,\n-                            kind: ExprKind::Literal { literal, user_ty: None, const_id: None },\n+                        let mk_const = |literal| {\n+                            self.arena.alloc(Expr {\n+                                temp_lifetime,\n+                                ty: var_ty,\n+                                span: expr.span,\n+                                kind: ExprKind::Literal { literal, user_ty: None, const_id: None },\n+                            })\n                         };\n                         let offset = mk_const(ty::Const::from_bits(\n                             self.tcx,\n@@ -675,27 +697,33 @@ impl<'tcx> Cx<'tcx> {\n                                     ),\n                                     ty: var_ty,\n                                 }));\n-                                let bin = ExprKind::Binary {\n-                                    op: BinOp::Add,\n-                                    lhs: Box::new(lhs),\n-                                    rhs: Box::new(offset),\n-                                };\n-                                Expr { temp_lifetime, ty: var_ty, span: expr.span, kind: bin }\n+                                let bin =\n+                                    ExprKind::Binary { op: BinOp::Add, lhs: lhs, rhs: offset };\n+                                self.arena.alloc(Expr {\n+                                    temp_lifetime,\n+                                    ty: var_ty,\n+                                    span: expr.span,\n+                                    kind: bin,\n+                                })\n                             }\n                             None => offset,\n                         }\n                     } else {\n                         self.mirror_expr(source)\n                     };\n \n-                    ExprKind::Cast { source: Box::new(source) }\n+                    ExprKind::Cast { source: source }\n                 };\n \n                 if let Some(user_ty) = user_ty {\n                     // NOTE: Creating a new Expr and wrapping a Cast inside of it may be\n                     //       inefficient, revisit this when performance becomes an issue.\n-                    let cast_expr =\n-                        Box::new(Expr { temp_lifetime, ty: expr_ty, span: expr.span, kind: cast });\n+                    let cast_expr = self.arena.alloc(Expr {\n+                        temp_lifetime,\n+                        ty: expr_ty,\n+                        span: expr.span,\n+                        kind: cast,\n+                    });\n                     debug!(\"make_mirror_unadjusted: (cast) user_ty={:?}\", user_ty);\n \n                     ExprKind::ValueTypeAscription { source: cast_expr, user_ty: Some(*user_ty) }\n@@ -707,25 +735,23 @@ impl<'tcx> Cx<'tcx> {\n                 let user_provided_types = self.typeck_results.user_provided_types();\n                 let user_ty = user_provided_types.get(ty.hir_id).copied();\n                 debug!(\"make_mirror_unadjusted: (type) user_ty={:?}\", user_ty);\n-                let mirrored = self.mirror_expr_boxed(source);\n+                let mirrored = self.mirror_expr(source);\n                 if source.is_syntactic_place_expr() {\n                     ExprKind::PlaceTypeAscription { source: mirrored, user_ty }\n                 } else {\n                     ExprKind::ValueTypeAscription { source: mirrored, user_ty }\n                 }\n             }\n             hir::ExprKind::DropTemps(ref source) => {\n-                ExprKind::Use { source: self.mirror_expr_boxed(source) }\n+                ExprKind::Use { source: self.mirror_expr(source) }\n             }\n-            hir::ExprKind::Box(ref value) => ExprKind::Box { value: self.mirror_expr_boxed(value) },\n-            hir::ExprKind::Array(ref fields) => ExprKind::Array {\n-                fields: fields.iter().map(|field| self.mirror_expr(field)).collect(),\n-            },\n-            hir::ExprKind::Tup(ref fields) => ExprKind::Tuple {\n-                fields: fields.iter().map(|field| self.mirror_expr(field)).collect(),\n-            },\n+            hir::ExprKind::Box(ref value) => ExprKind::Box { value: self.mirror_expr(value) },\n+            hir::ExprKind::Array(ref fields) => {\n+                ExprKind::Array { fields: self.mirror_exprs(fields) }\n+            }\n+            hir::ExprKind::Tup(ref fields) => ExprKind::Tuple { fields: self.mirror_exprs(fields) },\n \n-            hir::ExprKind::Yield(ref v, _) => ExprKind::Yield { value: self.mirror_expr_boxed(v) },\n+            hir::ExprKind::Yield(ref v, _) => ExprKind::Yield { value: self.mirror_expr(v) },\n             hir::ExprKind::Err => unreachable!(),\n         };\n \n@@ -772,7 +798,7 @@ impl<'tcx> Cx<'tcx> {\n         expr: &hir::Expr<'_>,\n         span: Span,\n         overloaded_callee: Option<(DefId, SubstsRef<'tcx>)>,\n-    ) -> Expr<'tcx> {\n+    ) -> Expr<'thir, 'tcx> {\n         let temp_lifetime = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n         let (def_id, substs, user_ty) = match overloaded_callee {\n             Some((def_id, substs)) => (def_id, substs, None),\n@@ -799,13 +825,13 @@ impl<'tcx> Cx<'tcx> {\n         }\n     }\n \n-    fn convert_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) -> Arm<'tcx> {\n+    fn convert_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) -> Arm<'thir, 'tcx> {\n         Arm {\n             pattern: self.pattern_from_hir(&arm.pat),\n             guard: arm.guard.as_ref().map(|g| match g {\n-                hir::Guard::If(ref e) => Guard::If(self.mirror_expr_boxed(e)),\n+                hir::Guard::If(ref e) => Guard::If(self.mirror_expr(e)),\n                 hir::Guard::IfLet(ref pat, ref e) => {\n-                    Guard::IfLet(self.pattern_from_hir(pat), self.mirror_expr_boxed(e))\n+                    Guard::IfLet(self.pattern_from_hir(pat), self.mirror_expr(e))\n                 }\n             }),\n             body: self.mirror_expr(arm.body),\n@@ -815,7 +841,11 @@ impl<'tcx> Cx<'tcx> {\n         }\n     }\n \n-    fn convert_path_expr(&mut self, expr: &'tcx hir::Expr<'tcx>, res: Res) -> ExprKind<'tcx> {\n+    fn convert_path_expr(\n+        &mut self,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        res: Res,\n+    ) -> ExprKind<'thir, 'tcx> {\n         let substs = self.typeck_results().node_substs(expr.hir_id);\n         match res {\n             // A regular function, constructor function or a constant.\n@@ -883,7 +913,7 @@ impl<'tcx> Cx<'tcx> {\n                         variant_index: adt_def.variant_index_with_ctor_id(def_id),\n                         substs,\n                         user_ty: user_provided_type,\n-                        fields: vec![],\n+                        fields: self.arena.alloc_from_iter(iter::empty()),\n                         base: None,\n                     },\n                     _ => bug!(\"unexpected ty: {:?}\", ty),\n@@ -904,7 +934,9 @@ impl<'tcx> Cx<'tcx> {\n                         def_id: id,\n                     }\n                 };\n-                ExprKind::Deref { arg: Box::new(Expr { ty, temp_lifetime, span: expr.span, kind }) }\n+                ExprKind::Deref {\n+                    arg: self.arena.alloc(Expr { ty, temp_lifetime, span: expr.span, kind }),\n+                }\n             }\n \n             Res::Local(var_hir_id) => self.convert_var(var_hir_id),\n@@ -913,7 +945,7 @@ impl<'tcx> Cx<'tcx> {\n         }\n     }\n \n-    fn convert_var(&mut self, var_hir_id: hir::HirId) -> ExprKind<'tcx> {\n+    fn convert_var(&mut self, var_hir_id: hir::HirId) -> ExprKind<'thir, 'tcx> {\n         // We want upvars here not captures.\n         // Captures will be handled in MIR.\n         let is_upvar = self\n@@ -936,9 +968,9 @@ impl<'tcx> Cx<'tcx> {\n     fn overloaded_operator(\n         &mut self,\n         expr: &'tcx hir::Expr<'tcx>,\n-        args: Vec<Expr<'tcx>>,\n-    ) -> ExprKind<'tcx> {\n-        let fun = Box::new(self.method_callee(expr, expr.span, None));\n+        args: &'thir [Expr<'thir, 'tcx>],\n+    ) -> ExprKind<'thir, 'tcx> {\n+        let fun = self.arena.alloc(self.method_callee(expr, expr.span, None));\n         ExprKind::Call { ty: fun.ty, fun, args, from_hir_call: false, fn_span: expr.span }\n     }\n \n@@ -947,9 +979,9 @@ impl<'tcx> Cx<'tcx> {\n         expr: &'tcx hir::Expr<'tcx>,\n         place_ty: Ty<'tcx>,\n         overloaded_callee: Option<(DefId, SubstsRef<'tcx>)>,\n-        args: Vec<Expr<'tcx>>,\n+        args: &'thir [Expr<'thir, 'tcx>],\n         span: Span,\n-    ) -> ExprKind<'tcx> {\n+    ) -> ExprKind<'thir, 'tcx> {\n         // For an overloaded *x or x[y] expression of type T, the method\n         // call returns an &T and we must add the deref so that the types\n         // line up (this is because `*x` and `x[y]` represent places):\n@@ -966,8 +998,8 @@ impl<'tcx> Cx<'tcx> {\n         // construct the complete expression `foo()` for the overloaded call,\n         // which will yield the &T type\n         let temp_lifetime = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-        let fun = Box::new(self.method_callee(expr, span, overloaded_callee));\n-        let ref_expr = Box::new(Expr {\n+        let fun = self.arena.alloc(self.method_callee(expr, span, overloaded_callee));\n+        let ref_expr = self.arena.alloc(Expr {\n             temp_lifetime,\n             ty: ref_ty,\n             span,\n@@ -983,7 +1015,7 @@ impl<'tcx> Cx<'tcx> {\n         closure_expr: &'tcx hir::Expr<'tcx>,\n         captured_place: &'tcx ty::CapturedPlace<'tcx>,\n         upvar_ty: Ty<'tcx>,\n-    ) -> Expr<'tcx> {\n+    ) -> Expr<'thir, 'tcx> {\n         let upvar_capture = captured_place.info.capture_kind;\n         let temp_lifetime = self.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n         let var_ty = captured_place.place.base_ty;\n@@ -1007,12 +1039,14 @@ impl<'tcx> Cx<'tcx> {\n \n         for proj in captured_place.place.projections.iter() {\n             let kind = match proj.kind {\n-                HirProjectionKind::Deref => ExprKind::Deref { arg: Box::new(captured_place_expr) },\n+                HirProjectionKind::Deref => {\n+                    ExprKind::Deref { arg: self.arena.alloc(captured_place_expr) }\n+                }\n                 HirProjectionKind::Field(field, ..) => {\n                     // Variant index will always be 0, because for multi-variant\n                     // enums, we capture the enum entirely.\n                     ExprKind::Field {\n-                        lhs: Box::new(captured_place_expr),\n+                        lhs: self.arena.alloc(captured_place_expr),\n                         name: Field::new(field as usize),\n                     }\n                 }\n@@ -1038,21 +1072,21 @@ impl<'tcx> Cx<'tcx> {\n                     temp_lifetime,\n                     ty: upvar_ty,\n                     span: closure_expr.span,\n-                    kind: ExprKind::Borrow { borrow_kind, arg: Box::new(captured_place_expr) },\n+                    kind: ExprKind::Borrow {\n+                        borrow_kind,\n+                        arg: self.arena.alloc(captured_place_expr),\n+                    },\n                 }\n             }\n         }\n     }\n \n     /// Converts a list of named fields (i.e., for struct-like struct/enum ADTs) into FieldExpr.\n-    fn field_refs(&mut self, fields: &'tcx [hir::Field<'tcx>]) -> Vec<FieldExpr<'tcx>> {\n-        fields\n-            .iter()\n-            .map(|field| FieldExpr {\n-                name: Field::new(self.tcx.field_index(field.hir_id, self.typeck_results)),\n-                expr: self.mirror_expr(field.expr),\n-            })\n-            .collect()\n+    fn field_refs(&mut self, fields: &'tcx [hir::Field<'tcx>]) -> &'thir [FieldExpr<'thir, 'tcx>] {\n+        self.arena.alloc_from_iter(fields.iter().map(|field| FieldExpr {\n+            name: Field::new(self.tcx.field_index(field.hir_id, self.typeck_results)),\n+            expr: self.mirror_expr(field.expr),\n+        }))\n     }\n }\n "}, {"sha": "66c11ea95286d242e8f5902fdd3db11d0d4c6f38", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=c2c432289195eaf65e42566ed0b95f82a913bcb3", "patch": "@@ -2,6 +2,7 @@\n //! structures into the THIR. The `builder` is generally ignorant of the tcx,\n //! etc., and instead goes through the `Cx` for most of its work.\n \n+use crate::thir::arena::Arena;\n use crate::thir::util::UserAnnotatedTyHelpers;\n use crate::thir::*;\n \n@@ -13,9 +14,18 @@ use rustc_middle::middle::region;\n use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n-#[derive(Clone)]\n-crate struct Cx<'tcx> {\n+crate fn build_thir<'thir, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n+    owner_def: ty::WithOptConstParam<LocalDefId>,\n+    arena: &'thir Arena<'thir, 'tcx>,\n+    expr: &'tcx hir::Expr<'tcx>,\n+) -> &'thir Expr<'thir, 'tcx> {\n+    Cx::new(tcx, owner_def, &arena).mirror_expr(expr)\n+}\n+\n+struct Cx<'thir, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    arena: &'thir Arena<'thir, 'tcx>,\n \n     crate param_env: ty::ParamEnv<'tcx>,\n \n@@ -26,20 +36,23 @@ crate struct Cx<'tcx> {\n     body_owner: DefId,\n }\n \n-impl<'tcx> Cx<'tcx> {\n-    crate fn new(tcx: TyCtxt<'tcx>, def: ty::WithOptConstParam<LocalDefId>) -> Cx<'tcx> {\n+impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        def: ty::WithOptConstParam<LocalDefId>,\n+        arena: &'thir Arena<'thir, 'tcx>,\n+    ) -> Cx<'thir, 'tcx> {\n         let typeck_results = tcx.typeck_opt_const_arg(def);\n         Cx {\n             tcx,\n+            arena,\n             param_env: tcx.param_env(def.did),\n             region_scope_tree: tcx.region_scope_tree(def.did),\n             typeck_results,\n             body_owner: def.did.to_def_id(),\n         }\n     }\n-}\n \n-impl<'tcx> Cx<'tcx> {\n     crate fn const_eval_literal(\n         &mut self,\n         lit: &'tcx ast::LitKind,\n@@ -74,7 +87,7 @@ impl<'tcx> Cx<'tcx> {\n     }\n }\n \n-impl<'tcx> UserAnnotatedTyHelpers<'tcx> for Cx<'tcx> {\n+impl<'tcx> UserAnnotatedTyHelpers<'tcx> for Cx<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }"}, {"sha": "27a7e99951c3b0d989490608511f6f508d0621cd", "filename": "compiler/rustc_mir_build/src/thir/mod.rs", "status": "modified", "additions": 79, "deletions": 76, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c432289195eaf65e42566ed0b95f82a913bcb3/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs?ref=c2c432289195eaf65e42566ed0b95f82a913bcb3", "patch": "@@ -24,6 +24,9 @@ crate mod pattern;\n crate use self::pattern::PatTyProj;\n crate use self::pattern::{BindingMode, FieldPat, Pat, PatKind, PatRange};\n \n+mod arena;\n+crate use arena::Arena;\n+\n mod util;\n \n #[derive(Copy, Clone, Debug)]\n@@ -33,13 +36,13 @@ crate enum LintLevel {\n }\n \n #[derive(Debug)]\n-crate struct Block<'tcx> {\n+crate struct Block<'thir, 'tcx> {\n     crate targeted_by_break: bool,\n     crate region_scope: region::Scope,\n     crate opt_destruction_scope: Option<region::Scope>,\n     crate span: Span,\n-    crate stmts: Vec<Stmt<'tcx>>,\n-    crate expr: Option<Box<Expr<'tcx>>>,\n+    crate stmts: &'thir [Stmt<'thir, 'tcx>],\n+    crate expr: Option<&'thir Expr<'thir, 'tcx>>,\n     crate safety_mode: BlockSafety,\n }\n \n@@ -52,19 +55,19 @@ crate enum BlockSafety {\n }\n \n #[derive(Debug)]\n-crate struct Stmt<'tcx> {\n-    crate kind: StmtKind<'tcx>,\n+crate struct Stmt<'thir, 'tcx> {\n+    crate kind: StmtKind<'thir, 'tcx>,\n     crate opt_destruction_scope: Option<region::Scope>,\n }\n \n #[derive(Debug)]\n-crate enum StmtKind<'tcx> {\n+crate enum StmtKind<'thir, 'tcx> {\n     Expr {\n         /// scope for this statement; may be used as lifetime of temporaries\n         scope: region::Scope,\n \n         /// expression being evaluated in this statement\n-        expr: Box<Expr<'tcx>>,\n+        expr: &'thir Expr<'thir, 'tcx>,\n     },\n \n     Let {\n@@ -82,7 +85,7 @@ crate enum StmtKind<'tcx> {\n         pattern: Pat<'tcx>,\n \n         /// let pat: ty = <INIT> ...\n-        initializer: Option<Box<Expr<'tcx>>>,\n+        initializer: Option<&'thir Expr<'thir, 'tcx>>,\n \n         /// the lint level for this let-statement\n         lint_level: LintLevel,\n@@ -91,12 +94,12 @@ crate enum StmtKind<'tcx> {\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Expr<'_>, 160);\n+rustc_data_structures::static_assert_size!(Expr<'_, '_>, 144);\n \n /// The Thir trait implementor lowers their expressions (`&'tcx H::Expr`)\n /// into instances of this `Expr` enum. This lowering can be done\n /// basically as lazily or as eagerly as desired: every recursive\n-/// reference to an expression in this enum is an `Box<Expr<'tcx>>`, which\n+/// reference to an expression in this enum is an `&'thir Expr<'thir, 'tcx>`, which\n /// may in turn be another instance of this enum (boxed), or else an\n /// unlowered `&'tcx H::Expr`. Note that instances of `Expr` are very\n /// short-lived. They are created by `Thir::to_expr`, analyzed and\n@@ -108,7 +111,7 @@ rustc_data_structures::static_assert_size!(Expr<'_>, 160);\n /// example, method calls and overloaded operators are absent: they are\n /// expected to be converted into `Expr::Call` instances.\n #[derive(Debug)]\n-crate struct Expr<'tcx> {\n+crate struct Expr<'thir, 'tcx> {\n     /// type of this expression\n     crate ty: Ty<'tcx>,\n \n@@ -120,28 +123,28 @@ crate struct Expr<'tcx> {\n     crate span: Span,\n \n     /// kind of expression\n-    crate kind: ExprKind<'tcx>,\n+    crate kind: ExprKind<'thir, 'tcx>,\n }\n \n #[derive(Debug)]\n-crate enum ExprKind<'tcx> {\n+crate enum ExprKind<'thir, 'tcx> {\n     Scope {\n         region_scope: region::Scope,\n         lint_level: LintLevel,\n-        value: Box<Expr<'tcx>>,\n+        value: &'thir Expr<'thir, 'tcx>,\n     },\n     Box {\n-        value: Box<Expr<'tcx>>,\n+        value: &'thir Expr<'thir, 'tcx>,\n     },\n     If {\n-        cond: Box<Expr<'tcx>>,\n-        then: Box<Expr<'tcx>>,\n-        else_opt: Option<Box<Expr<'tcx>>>,\n+        cond: &'thir Expr<'thir, 'tcx>,\n+        then: &'thir Expr<'thir, 'tcx>,\n+        else_opt: Option<&'thir Expr<'thir, 'tcx>>,\n     },\n     Call {\n         ty: Ty<'tcx>,\n-        fun: Box<Expr<'tcx>>,\n-        args: Vec<Expr<'tcx>>,\n+        fun: &'thir Expr<'thir, 'tcx>,\n+        args: &'thir [Expr<'thir, 'tcx>],\n         /// Whether this is from a call in HIR, rather than from an overloaded\n         /// operator. `true` for overloaded function call.\n         from_hir_call: bool,\n@@ -150,62 +153,62 @@ crate enum ExprKind<'tcx> {\n         fn_span: Span,\n     },\n     Deref {\n-        arg: Box<Expr<'tcx>>,\n+        arg: &'thir Expr<'thir, 'tcx>,\n     }, // NOT overloaded!\n     Binary {\n         op: BinOp,\n-        lhs: Box<Expr<'tcx>>,\n-        rhs: Box<Expr<'tcx>>,\n+        lhs: &'thir Expr<'thir, 'tcx>,\n+        rhs: &'thir Expr<'thir, 'tcx>,\n     }, // NOT overloaded!\n     LogicalOp {\n         op: LogicalOp,\n-        lhs: Box<Expr<'tcx>>,\n-        rhs: Box<Expr<'tcx>>,\n+        lhs: &'thir Expr<'thir, 'tcx>,\n+        rhs: &'thir Expr<'thir, 'tcx>,\n     }, // NOT overloaded!\n     // LogicalOp is distinct from BinaryOp because of lazy evaluation of the operands.\n     Unary {\n         op: UnOp,\n-        arg: Box<Expr<'tcx>>,\n+        arg: &'thir Expr<'thir, 'tcx>,\n     }, // NOT overloaded!\n     Cast {\n-        source: Box<Expr<'tcx>>,\n+        source: &'thir Expr<'thir, 'tcx>,\n     },\n     Use {\n-        source: Box<Expr<'tcx>>,\n+        source: &'thir Expr<'thir, 'tcx>,\n     }, // Use a lexpr to get a vexpr.\n     NeverToAny {\n-        source: Box<Expr<'tcx>>,\n+        source: &'thir Expr<'thir, 'tcx>,\n     },\n     Pointer {\n         cast: PointerCast,\n-        source: Box<Expr<'tcx>>,\n+        source: &'thir Expr<'thir, 'tcx>,\n     },\n     Loop {\n-        body: Box<Expr<'tcx>>,\n+        body: &'thir Expr<'thir, 'tcx>,\n     },\n     Match {\n-        scrutinee: Box<Expr<'tcx>>,\n-        arms: Vec<Arm<'tcx>>,\n+        scrutinee: &'thir Expr<'thir, 'tcx>,\n+        arms: &'thir [Arm<'thir, 'tcx>],\n     },\n     Block {\n-        body: Block<'tcx>,\n+        body: Block<'thir, 'tcx>,\n     },\n     Assign {\n-        lhs: Box<Expr<'tcx>>,\n-        rhs: Box<Expr<'tcx>>,\n+        lhs: &'thir Expr<'thir, 'tcx>,\n+        rhs: &'thir Expr<'thir, 'tcx>,\n     },\n     AssignOp {\n         op: BinOp,\n-        lhs: Box<Expr<'tcx>>,\n-        rhs: Box<Expr<'tcx>>,\n+        lhs: &'thir Expr<'thir, 'tcx>,\n+        rhs: &'thir Expr<'thir, 'tcx>,\n     },\n     Field {\n-        lhs: Box<Expr<'tcx>>,\n+        lhs: &'thir Expr<'thir, 'tcx>,\n         name: Field,\n     },\n     Index {\n-        lhs: Box<Expr<'tcx>>,\n-        index: Box<Expr<'tcx>>,\n+        lhs: &'thir Expr<'thir, 'tcx>,\n+        index: &'thir Expr<'thir, 'tcx>,\n     },\n     VarRef {\n         id: hir::HirId,\n@@ -220,35 +223,35 @@ crate enum ExprKind<'tcx> {\n     },\n     Borrow {\n         borrow_kind: BorrowKind,\n-        arg: Box<Expr<'tcx>>,\n+        arg: &'thir Expr<'thir, 'tcx>,\n     },\n     /// A `&raw [const|mut] $place_expr` raw borrow resulting in type `*[const|mut] T`.\n     AddressOf {\n         mutability: hir::Mutability,\n-        arg: Box<Expr<'tcx>>,\n+        arg: &'thir Expr<'thir, 'tcx>,\n     },\n     Break {\n         label: region::Scope,\n-        value: Option<Box<Expr<'tcx>>>,\n+        value: Option<&'thir Expr<'thir, 'tcx>>,\n     },\n     Continue {\n         label: region::Scope,\n     },\n     Return {\n-        value: Option<Box<Expr<'tcx>>>,\n+        value: Option<&'thir Expr<'thir, 'tcx>>,\n     },\n     ConstBlock {\n         value: &'tcx Const<'tcx>,\n     },\n     Repeat {\n-        value: Box<Expr<'tcx>>,\n+        value: &'thir Expr<'thir, 'tcx>,\n         count: &'tcx Const<'tcx>,\n     },\n     Array {\n-        fields: Vec<Expr<'tcx>>,\n+        fields: &'thir [Expr<'thir, 'tcx>],\n     },\n     Tuple {\n-        fields: Vec<Expr<'tcx>>,\n+        fields: &'thir [Expr<'thir, 'tcx>],\n     },\n     Adt {\n         adt_def: &'tcx AdtDef,\n@@ -259,23 +262,23 @@ crate enum ExprKind<'tcx> {\n         /// Bar::<T> { ... }`.\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n \n-        fields: Vec<FieldExpr<'tcx>>,\n-        base: Option<FruInfo<'tcx>>,\n+        fields: &'thir [FieldExpr<'thir, 'tcx>],\n+        base: Option<FruInfo<'thir, 'tcx>>,\n     },\n     PlaceTypeAscription {\n-        source: Box<Expr<'tcx>>,\n+        source: &'thir Expr<'thir, 'tcx>,\n         /// Type that the user gave to this expression\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n     },\n     ValueTypeAscription {\n-        source: Box<Expr<'tcx>>,\n+        source: &'thir Expr<'thir, 'tcx>,\n         /// Type that the user gave to this expression\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n     },\n     Closure {\n         closure_id: DefId,\n         substs: UpvarSubsts<'tcx>,\n-        upvars: Vec<Expr<'tcx>>,\n+        upvars: &'thir [Expr<'thir, 'tcx>],\n         movability: Option<hir::Movability>,\n     },\n     Literal {\n@@ -296,48 +299,48 @@ crate enum ExprKind<'tcx> {\n     },\n     InlineAsm {\n         template: &'tcx [InlineAsmTemplatePiece],\n-        operands: Vec<InlineAsmOperand<'tcx>>,\n+        operands: &'thir [InlineAsmOperand<'thir, 'tcx>],\n         options: InlineAsmOptions,\n         line_spans: &'tcx [Span],\n     },\n     /// An expression taking a reference to a thread local.\n     ThreadLocalRef(DefId),\n     LlvmInlineAsm {\n         asm: &'tcx hir::LlvmInlineAsmInner,\n-        outputs: Vec<Expr<'tcx>>,\n-        inputs: Vec<Expr<'tcx>>,\n+        outputs: &'thir [Expr<'thir, 'tcx>],\n+        inputs: &'thir [Expr<'thir, 'tcx>],\n     },\n     Yield {\n-        value: Box<Expr<'tcx>>,\n+        value: &'thir Expr<'thir, 'tcx>,\n     },\n }\n \n #[derive(Debug)]\n-crate struct FieldExpr<'tcx> {\n+crate struct FieldExpr<'thir, 'tcx> {\n     crate name: Field,\n-    crate expr: Expr<'tcx>,\n+    crate expr: &'thir Expr<'thir, 'tcx>,\n }\n \n #[derive(Debug)]\n-crate struct FruInfo<'tcx> {\n-    crate base: Box<Expr<'tcx>>,\n-    crate field_types: Vec<Ty<'tcx>>,\n+crate struct FruInfo<'thir, 'tcx> {\n+    crate base: &'thir Expr<'thir, 'tcx>,\n+    crate field_types: &'thir [Ty<'tcx>],\n }\n \n #[derive(Debug)]\n-crate struct Arm<'tcx> {\n+crate struct Arm<'thir, 'tcx> {\n     crate pattern: Pat<'tcx>,\n-    crate guard: Option<Guard<'tcx>>,\n-    crate body: Expr<'tcx>,\n+    crate guard: Option<Guard<'thir, 'tcx>>,\n+    crate body: &'thir Expr<'thir, 'tcx>,\n     crate lint_level: LintLevel,\n     crate scope: region::Scope,\n     crate span: Span,\n }\n \n #[derive(Debug)]\n-crate enum Guard<'tcx> {\n-    If(Box<Expr<'tcx>>),\n-    IfLet(Pat<'tcx>, Box<Expr<'tcx>>),\n+crate enum Guard<'thir, 'tcx> {\n+    If(&'thir Expr<'thir, 'tcx>),\n+    IfLet(Pat<'tcx>, &'thir Expr<'thir, 'tcx>),\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -347,32 +350,32 @@ crate enum LogicalOp {\n }\n \n #[derive(Debug)]\n-crate enum InlineAsmOperand<'tcx> {\n+crate enum InlineAsmOperand<'thir, 'tcx> {\n     In {\n         reg: InlineAsmRegOrRegClass,\n-        expr: Expr<'tcx>,\n+        expr: &'thir Expr<'thir, 'tcx>,\n     },\n     Out {\n         reg: InlineAsmRegOrRegClass,\n         late: bool,\n-        expr: Option<Expr<'tcx>>,\n+        expr: Option<&'thir Expr<'thir, 'tcx>>,\n     },\n     InOut {\n         reg: InlineAsmRegOrRegClass,\n         late: bool,\n-        expr: Expr<'tcx>,\n+        expr: &'thir Expr<'thir, 'tcx>,\n     },\n     SplitInOut {\n         reg: InlineAsmRegOrRegClass,\n         late: bool,\n-        in_expr: Expr<'tcx>,\n-        out_expr: Option<Expr<'tcx>>,\n+        in_expr: &'thir Expr<'thir, 'tcx>,\n+        out_expr: Option<&'thir Expr<'thir, 'tcx>>,\n     },\n     Const {\n-        expr: Expr<'tcx>,\n+        expr: &'thir Expr<'thir, 'tcx>,\n     },\n     SymFn {\n-        expr: Expr<'tcx>,\n+        expr: &'thir Expr<'thir, 'tcx>,\n     },\n     SymStatic {\n         def_id: DefId,"}]}