{"sha": "3bbcac322669cff3abde5be937cc4ec3860f3985", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiYmNhYzMyMjY2OWNmZjNhYmRlNWJlOTM3Y2M0ZWMzODYwZjM5ODU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-08T16:45:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-08T16:45:43Z"}, "message": "auto merge of #5279 : alexcrichton/rust/no-dvec, r=pcwalton\n\nCloses #4985 by removing the `dvec` module and all use cases throughout the compiler.\r\n\r\nA number of uses were directly convertible to `let mut foo = ~[];`, while others in hash maps and some fields had to be converted to `@mut ~[T]`. A small number of `DVec` instances in fields were able to be converted directly to `~[T]` without the `@`, but this was a difficult thing to do.", "tree": {"sha": "70dd00fbb69807cc2dcab84b9ad5803fe06e57bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70dd00fbb69807cc2dcab84b9ad5803fe06e57bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bbcac322669cff3abde5be937cc4ec3860f3985", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bbcac322669cff3abde5be937cc4ec3860f3985", "html_url": "https://github.com/rust-lang/rust/commit/3bbcac322669cff3abde5be937cc4ec3860f3985", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bbcac322669cff3abde5be937cc4ec3860f3985/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "647a94d01a54a75e08fd1b6fa74761f70874bafe", "url": "https://api.github.com/repos/rust-lang/rust/commits/647a94d01a54a75e08fd1b6fa74761f70874bafe", "html_url": "https://github.com/rust-lang/rust/commit/647a94d01a54a75e08fd1b6fa74761f70874bafe"}, {"sha": "62651df2b482af4dc98b0aec6c5f1ad112fab8ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/62651df2b482af4dc98b0aec6c5f1ad112fab8ec", "html_url": "https://github.com/rust-lang/rust/commit/62651df2b482af4dc98b0aec6c5f1ad112fab8ec"}], "stats": {"total": 1229, "additions": 327, "deletions": 902}, "files": [{"sha": "79a5d297178e3e1644fa3fc9b00ec61fd3417a7c", "filename": "src/libcore/core.rc", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -21,10 +21,10 @@ used features.\n the floating point types, the `bool` type, tuples, characters, strings,\n vectors (`vec`), managed boxes (`managed`), owned boxes (`owned`), and unsafe\n and borrowed pointers (`ptr`).  Additionally, `core` provides task management\n-and creation (`task`), communication primitives (`comm` and `pipes`), an\n-efficient vector builder (`dvec`), platform abstractions (`os` and `path`),\n-basic I/O abstractions (`io`), common traits (`cmp`, `num`, `to_str`), and\n-complete bindings to the C standard library (`libc`).\n+and creation (`task`), communication primitives (`comm` and `pipes`), platform\n+abstractions (`os` and `path`), basic I/O abstractions (`io`), common traits\n+(`cmp`, `num`, `to_str`), and complete bindings to the C standard library\n+(`libc`).\n \n `core` is linked to all crates by default and its contents imported.\n Implicitly, all crates behave as if they included the following prologue:\n@@ -141,9 +141,6 @@ pub mod container;\n pub mod option;\n pub mod result;\n pub mod either;\n-pub mod dvec;\n-#[path=\"iter-trait.rs\"] #[merge = \"iter-trait/dvec.rs\"]\n-pub mod dvec_iter;\n pub mod dlist;\n #[path=\"iter-trait.rs\"] #[merge = \"iter-trait/dlist.rs\"]\n pub mod dlist_iter;"}, {"sha": "43daf5fa6a5daa2332d6830b77cd3e69399b4413", "filename": "src/libcore/dvec.rs", "status": "removed", "additions": 0, "deletions": 355, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -1,355 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Dynamic vector\n-\n-A growable vector that makes use of unique pointers so that the\n-result can be sent between tasks and so forth.\n-\n-Note that recursive use is not permitted.\n-\n-*/\n-\n-use cast;\n-use prelude::*;\n-use ptr::null;\n-use vec;\n-\n-/**\n- * A growable, modifiable vector type that accumulates elements into a\n- * unique vector.\n- *\n- * # Limitations on recursive use\n- *\n- * This class works by swapping the unique vector out of the data\n- * structure whenever it is to be used.  Therefore, recursive use is not\n- * permitted.  That is, while iterating through a vector, you cannot\n- * access the vector in any other way or else the program will fail.  If\n- * you wish, you can use the `swap()` method to gain access to the raw\n- * vector and transform it or use it any way you like.  Eventually, we\n- * may permit read-only access during iteration or other use.\n- *\n- * # WARNING\n- *\n- * For maximum performance, this type is implemented using some rather\n- * unsafe code.  In particular, this innocent looking `~[mut A]` pointer\n- * *may be null!*  Therefore, it is important you not reach into the\n- * data structure manually but instead use the provided extensions.\n- *\n- * The reason that I did not use an unsafe pointer in the structure\n- * itself is that I wanted to ensure that the vector would be freed when\n- * the dvec is dropped.  The reason that I did not use an `Option<T>`\n- * instead of a nullable pointer is that I found experimentally that it\n- * becomes approximately 50% slower. This can probably be improved\n- * through optimization.  You can run your own experiments using\n- * `src/test/bench/vec-append.rs`. My own tests found that using null\n- * pointers achieved about 103 million pushes/second.  Using an option\n- * type could only produce 47 million pushes/second.\n- */\n-pub struct DVec<A> {\n-    mut data: ~[A]\n-}\n-\n-/// Creates a new, empty dvec\n-pub pure fn DVec<A>() -> DVec<A> {\n-    DVec {data: ~[]}\n-}\n-\n-/// Creates a new dvec with a single element\n-pub pure fn from_elem<A>(e: A) -> DVec<A> {\n-    DVec {data: ~[e]}\n-}\n-\n-/// Creates a new dvec with the contents of a vector\n-pub pure fn from_vec<A>(v: ~[A]) -> DVec<A> {\n-    DVec {data: v}\n-}\n-\n-/// Consumes the vector and returns its contents\n-pub pure fn unwrap<A>(d: DVec<A>) -> ~[A] {\n-    let DVec {data: v} = d;\n-    v\n-}\n-\n-priv impl<A> DVec<A> {\n-    #[inline(always)]\n-    pure fn check_not_borrowed(&self) {\n-        unsafe {\n-            let data: *() = cast::reinterpret_cast(&self.data);\n-            if data.is_null() {\n-                fail!(~\"Recursive use of dvec\");\n-            }\n-        }\n-    }\n-\n-    #[inline(always)]\n-    fn give_back(&self, data: ~[A]) {\n-        unsafe {\n-            self.data = data;\n-        }\n-    }\n-\n-    #[inline(always)]\n-    fn unwrap(self) -> ~[A] { unwrap(self) }\n-}\n-\n-// In theory, most everything should work with any A, but in practice\n-// almost nothing works without the copy bound due to limitations\n-// around closures.\n-pub impl<A> DVec<A> {\n-    // FIXME (#3758): This should not need to be public.\n-    #[inline(always)]\n-    fn check_out<B>(&self, f: &fn(v: ~[A]) -> B) -> B {\n-        unsafe {\n-            let mut data = cast::reinterpret_cast(&null::<()>());\n-            data <-> self.data;\n-            let data_ptr: *() = cast::reinterpret_cast(&data);\n-            if data_ptr.is_null() { fail!(~\"Recursive use of dvec\"); }\n-            return f(data);\n-        }\n-    }\n-\n-    /// Reserves space for N elements\n-    fn reserve(&self, count: uint) {\n-        vec::reserve(&mut self.data, count)\n-    }\n-\n-    /**\n-     * Swaps out the current vector and hands it off to a user-provided\n-     * function `f`.  The function should transform it however is desired\n-     * and return a new vector to replace it with.\n-     */\n-    #[inline(always)]\n-    fn swap(&self, f: &fn(v: ~[A]) -> ~[A]) {\n-        self.check_out(|v| self.give_back(f(v)))\n-    }\n-\n-    /// Returns the number of elements currently in the dvec\n-    #[inline(always)]\n-    pure fn len(&self) -> uint {\n-        self.check_not_borrowed();\n-        return self.data.len();\n-    }\n-\n-    /// Overwrite the current contents\n-    #[inline(always)]\n-    fn set(&self, w: ~[A]) {\n-        self.check_not_borrowed();\n-        self.data = w;\n-    }\n-\n-    /// Remove and return the last element\n-    fn pop(&self) -> A {\n-        do self.check_out |v| {\n-            let mut v = v;\n-            let result = v.pop();\n-            self.give_back(v);\n-            result\n-        }\n-    }\n-\n-    /// Insert a single item at the front of the list\n-    fn unshift(&self, t: A) {\n-        unsafe {\n-            let mut data = cast::reinterpret_cast(&null::<()>());\n-            data <-> self.data;\n-            let data_ptr: *() = cast::reinterpret_cast(&data);\n-            if data_ptr.is_null() { fail!(~\"Recursive use of dvec\"); }\n-            self.data = ~[t];\n-            self.data.push_all_move(data);\n-        }\n-    }\n-\n-    /// Append a single item to the end of the list\n-    #[inline(always)]\n-    fn push(&self, t: A) {\n-        self.check_not_borrowed();\n-        self.data.push(t);\n-    }\n-\n-    /// Remove and return the first element\n-    fn shift(&self) -> A {\n-        do self.check_out |v| {\n-            let mut v = v;\n-            let result = v.shift();\n-            self.give_back(v);\n-            result\n-        }\n-    }\n-\n-    /// Reverse the elements in the list, in place\n-    fn reverse(&self) {\n-        do self.check_out |v| {\n-            let mut v = v;\n-            vec::reverse(v);\n-            self.give_back(v);\n-        }\n-    }\n-\n-    /// Gives access to the vector as a slice with immutable contents\n-    fn borrow<R>(&self, op: fn(x: &[A]) -> R) -> R {\n-        do self.check_out |v| {\n-            let result = op(v);\n-            self.give_back(v);\n-            result\n-        }\n-    }\n-\n-    /// Gives access to the vector as a slice with mutable contents\n-    fn borrow_mut<R>(&self, op: &fn(x: &mut [A]) -> R) -> R {\n-        do self.check_out |v| {\n-            let mut v = v;\n-            let result = op(v);\n-            self.give_back(v);\n-            result\n-        }\n-    }\n-}\n-\n-pub impl<A:Copy> DVec<A> {\n-    /**\n-     * Append all elements of a vector to the end of the list\n-     *\n-     * Equivalent to `append_iter()` but potentially more efficient.\n-     */\n-    fn push_all(&self, ts: &[const A]) {\n-        self.push_slice(ts, 0u, vec::len(ts));\n-    }\n-\n-    /// Appends elements from `from_idx` to `to_idx` (exclusive)\n-    fn push_slice(&self, ts: &[const A], from_idx: uint, to_idx: uint) {\n-        do self.swap |v| {\n-            let mut v = v;\n-            let new_len = vec::len(v) + to_idx - from_idx;\n-            vec::reserve(&mut v, new_len);\n-            let mut i = from_idx;\n-            while i < to_idx {\n-                v.push(ts[i]);\n-                i += 1u;\n-            }\n-            v\n-        }\n-    }\n-\n-    /**\n-     * Append all elements of an iterable.\n-     *\n-     * Failure will occur if the iterable's `each()` method\n-     * attempts to access this vector.\n-     */\n-    /*\n-    fn append_iter<A, I:iter::base_iter<A>>(ts: I) {\n-        do self.swap |v| {\n-           let mut v = match ts.size_hint() {\n-             none { v }\n-             Some(h) {\n-               let len = v.len() + h;\n-               let mut v = v;\n-               vec::reserve(v, len);\n-               v\n-            }\n-           };\n-\n-        for ts.each |t| { v.push(*t) };\n-           v\n-        }\n-    }\n-    */\n-\n-    /**\n-     * Gets a copy of the current contents.\n-     *\n-     * See `unwrap()` if you do not wish to copy the contents.\n-     */\n-    pure fn get(&self) -> ~[A] {\n-        unsafe {\n-            do self.check_out |v| {\n-                let w = copy v;\n-                self.give_back(v);\n-                w\n-            }\n-        }\n-    }\n-\n-    /// Copy out an individual element\n-    #[inline(always)]\n-    pure fn get_elt(&self, idx: uint) -> A {\n-        self.check_not_borrowed();\n-        return self.data[idx];\n-    }\n-\n-    /// Overwrites the contents of the element at `idx` with `a`\n-    fn set_elt(&self, idx: uint, a: A) {\n-        self.check_not_borrowed();\n-        self.data[idx] = a;\n-    }\n-\n-    /**\n-     * Overwrites the contents of the element at `idx` with `a`,\n-     * growing the vector if necessary.  New elements will be initialized\n-     * with `initval`\n-     */\n-    fn grow_set_elt(&self, idx: uint, initval: &A, val: A) {\n-        do self.swap |v| {\n-            let mut v = v;\n-            v.grow_set(idx, initval, val);\n-            v\n-        }\n-    }\n-\n-    /// Returns the last element, failing if the vector is empty\n-    #[inline(always)]\n-    pure fn last(&self) -> A {\n-        self.check_not_borrowed();\n-\n-        let length = self.len();\n-        if length == 0 {\n-            fail!(~\"attempt to retrieve the last element of an empty vector\");\n-        }\n-\n-        return self.data[length - 1];\n-    }\n-\n-    /// Iterates over the elements in reverse order\n-    #[inline(always)]\n-    fn rev_each(&self, f: fn(v: &A) -> bool) {\n-        do self.swap |v| {\n-            // FIXME(#2263)---we should be able to write\n-            // `vec::rev_each(v, f);` but we cannot write now\n-            for vec::rev_each(v) |e| {\n-                if !f(e) { break; }\n-            }\n-            v\n-        }\n-    }\n-\n-    /// Iterates over the elements and indices in reverse order\n-    #[inline(always)]\n-    fn rev_eachi(&self, f: fn(uint, v: &A) -> bool) {\n-        do self.swap |v| {\n-            // FIXME(#2263)---we should be able to write\n-            // `vec::rev_eachi(v, f);` but we cannot write now\n-            for vec::rev_eachi(v) |i, e| {\n-                if !f(i, e) { break; }\n-            }\n-            v\n-        }\n-    }\n-}\n-\n-impl<A:Copy> Index<uint,A> for DVec<A> {\n-    #[inline(always)]\n-    pure fn index(&self, idx: uint) -> A {\n-        self.get_elt(idx)\n-    }\n-}\n-"}, {"sha": "4634eb8793d952ccf4daff6a54f3aa2cbf4c4ba5", "filename": "src/libcore/io.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -16,7 +16,6 @@ Basic input/output\n \n use result::Result;\n \n-use dvec::DVec;\n use int;\n use libc;\n use libc::{c_int, c_long, c_uint, c_void, size_t, ssize_t};\n@@ -1109,30 +1108,25 @@ pub fn print(s: &str) { stdout().write_str(s); }\n pub fn println(s: &str) { stdout().write_line(s); }\n \n pub struct BytesWriter {\n-    bytes: DVec<u8>,\n+    mut bytes: ~[u8],\n     mut pos: uint,\n }\n \n impl Writer for BytesWriter {\n     fn write(&self, v: &[const u8]) {\n-        do self.bytes.swap |bytes| {\n-            let mut bytes = bytes;\n-            let v_len = v.len();\n-            let bytes_len = bytes.len();\n-\n-            let count = uint::max(bytes_len, self.pos + v_len);\n-            vec::reserve(&mut bytes, count);\n-            unsafe { vec::raw::set_len(&mut bytes, count); }\n-\n-            {\n-                let view = vec::mut_slice(bytes, self.pos, count);\n-                vec::bytes::copy_memory(view, v, v_len);\n-            }\n+        let v_len = v.len();\n+        let bytes_len = self.bytes.len();\n \n-            self.pos += v_len;\n+        let count = uint::max(bytes_len, self.pos + v_len);\n+        vec::reserve(&mut self.bytes, count);\n \n-            bytes\n+        unsafe {\n+            vec::raw::set_len(&mut self.bytes, count);\n+            let view = vec::mut_slice(self.bytes, self.pos, count);\n+            vec::bytes::copy_memory(view, v, v_len);\n         }\n+\n+        self.pos += v_len;\n     }\n     fn seek(&self, offset: int, whence: SeekStyle) {\n         let pos = self.pos;\n@@ -1145,14 +1139,14 @@ impl Writer for BytesWriter {\n }\n \n pub pure fn BytesWriter() -> BytesWriter {\n-    BytesWriter { bytes: DVec(), mut pos: 0u }\n+    BytesWriter { bytes: ~[], mut pos: 0u }\n }\n \n pub pure fn with_bytes_writer(f: fn(Writer)) -> ~[u8] {\n     let wr = @BytesWriter();\n     f(wr as Writer);\n-    // FIXME (#3758): This should not be needed.\n-    unsafe { wr.bytes.check_out(|bytes| bytes) }\n+    let @BytesWriter{bytes, _} = wr;\n+    return bytes;\n }\n \n pub pure fn with_str_writer(f: fn(Writer)) -> ~str {\n@@ -1448,17 +1442,15 @@ mod tests {\n     fn bytes_buffer_overwrite() {\n         let wr = BytesWriter();\n         wr.write(~[0u8, 1u8, 2u8, 3u8]);\n-        fail_unless!(wr.bytes.borrow(|bytes| bytes == ~[0u8, 1u8, 2u8, 3u8]));\n+        fail_unless!(wr.bytes == ~[0u8, 1u8, 2u8, 3u8]);\n         wr.seek(-2, SeekCur);\n         wr.write(~[4u8, 5u8, 6u8, 7u8]);\n-        fail_unless!(wr.bytes.borrow(|bytes| bytes ==\n-            ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]));\n+        fail_unless!(wr.bytes == ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]);\n         wr.seek(-2, SeekEnd);\n         wr.write(~[8u8]);\n         wr.seek(1, SeekSet);\n         wr.write(~[9u8]);\n-        fail_unless!(wr.bytes.borrow(|bytes| bytes ==\n-            ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]));\n+        fail_unless!(wr.bytes == ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]);\n     }\n \n     #[test]"}, {"sha": "986aa18ad4ab18274de18e2c9a3fc26f926df44c", "filename": "src/libcore/iter-trait/dvec.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdvec.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -1,37 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-mod inst {\n-    use dvec;\n-    use option::{Option, Some};\n-\n-    #[allow(non_camel_case_types)]\n-    pub type IMPL_T<A> = dvec::DVec<A>;\n-\n-    /**\n-    * Iterates through the current contents.\n-    *\n-    * Attempts to access this dvec during iteration will fail.\n-    */\n-    #[inline(always)]\n-    pub pure fn EACH<A>(self: &IMPL_T<A>, f: fn(v: &A) -> bool) {\n-        unsafe {\n-            do self.swap |v| {\n-                v.each(f);\n-                v\n-            }\n-        }\n-    }\n-\n-    #[inline(always)]\n-    pub pure fn SIZE_HINT<A>(self: &IMPL_T<A>) -> Option<uint> {\n-        Some(self.len())\n-    }\n-}"}, {"sha": "2f575ce7d28119ae1fd2025c3f563dd3f9fa13ff", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -50,7 +50,6 @@ pub use bool;\n pub use cast;\n pub use char;\n pub use cmp;\n-pub use dvec;\n pub use either;\n pub use f32;\n pub use f64;"}, {"sha": "e9122754eb42a10871160fcf935883ccd5628349", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -16,7 +16,6 @@ More runtime type reflection\n \n use cast::transmute;\n use char;\n-use dvec::DVec;\n use intrinsic;\n use intrinsic::{TyDesc, TyVisitor, visit_tydesc};\n use io::{Writer, WriterUtil};\n@@ -147,14 +146,14 @@ enum VariantState {\n \n pub struct ReprVisitor {\n     mut ptr: *c_void,\n-    ptr_stk: DVec<*c_void>,\n-    var_stk: DVec<VariantState>,\n+    mut ptr_stk: ~[*c_void],\n+    mut var_stk: ~[VariantState],\n     writer: @Writer\n }\n pub fn ReprVisitor(ptr: *c_void, writer: @Writer) -> ReprVisitor {\n     ReprVisitor { ptr: ptr,\n-                  ptr_stk: DVec(),\n-                  var_stk: DVec(),\n+                  ptr_stk: ~[],\n+                  var_stk: ~[],\n                   writer: writer }\n }\n \n@@ -500,7 +499,7 @@ impl TyVisitor for ReprVisitor {\n     }\n \n     fn visit_enum_variant_field(&self, i: uint, inner: *TyDesc) -> bool {\n-        match self.var_stk.last() {\n+        match self.var_stk[self.var_stk.len() - 1] {\n             Degenerate | TagMatch => {\n                 if i != 0 {\n                     self.writer.write_str(\", \");\n@@ -518,7 +517,7 @@ impl TyVisitor for ReprVisitor {\n                                 _disr_val: int,\n                                 n_fields: uint,\n                                 _name: &str) -> bool {\n-        match self.var_stk.last() {\n+        match self.var_stk[self.var_stk.len() - 1] {\n             Degenerate | TagMatch => {\n                 if n_fields > 0 {\n                     self.writer.write_char(')');"}, {"sha": "f035916f59423aaf6d45ac9d6121481806ee659a", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -12,7 +12,6 @@\n \n use cast;\n use cmp::Eq;\n-use dvec;\n use libc;\n use option;\n use prelude::*;\n@@ -35,11 +34,11 @@ impl Eq for LocalData {\n     pure fn ne(&self, other: &@LocalData) -> bool { !(*self).eq(other) }\n }\n \n-// We use dvec because it's the best data structure in core. If TLS is used\n-// heavily in future, this could be made more efficient with a proper map.\n+// If TLS is used heavily in future, this could be made more efficient with a\n+// proper map.\n type TaskLocalElement = (*libc::c_void, *libc::c_void, LocalData);\n // Has to be a pointer at outermost layer; the foreign call returns void *.\n-type TaskLocalMap = @dvec::DVec<Option<TaskLocalElement>>;\n+type TaskLocalMap = @mut ~[Option<TaskLocalElement>];\n \n extern fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n     unsafe {\n@@ -60,17 +59,21 @@ unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n     // drop when they finish. No \"re-storing after modifying\" is needed.\n     let map_ptr = rt::rust_get_task_local_data(task);\n     if map_ptr.is_null() {\n-        let map: TaskLocalMap = @dvec::DVec();\n+        let map: TaskLocalMap = @mut ~[];\n         // Use reinterpret_cast -- transmute would take map away from us also.\n         rt::rust_set_task_local_data(\n             task, cast::reinterpret_cast(&map));\n         rt::rust_task_local_data_atexit(task, cleanup_task_local_map);\n         // Also need to reference it an extra time to keep it for now.\n-        cast::bump_box_refcount(map);\n+        let nonmut = cast::transmute::<TaskLocalMap,\n+                                       @~[Option<TaskLocalElement>]>(map);\n+        cast::bump_box_refcount(nonmut);\n         map\n     } else {\n         let map = cast::transmute(map_ptr);\n-        cast::bump_box_refcount(map);\n+        let nonmut = cast::transmute::<TaskLocalMap,\n+                                       @~[Option<TaskLocalElement>]>(map);\n+        cast::bump_box_refcount(nonmut);\n         map\n     }\n }\n@@ -118,7 +121,7 @@ unsafe fn local_get_helper<T:Durable>(\n         let data: @T = cast::transmute(data_ptr);\n         cast::bump_box_refcount(data);\n         if do_pop {\n-            (*map).set_elt(index, None);\n+            map[index] = None;\n         }\n         data\n     }\n@@ -159,13 +162,13 @@ pub unsafe fn local_set<T:Durable>(\n         Some((index, _old_data_ptr)) => {\n             // Key already had a value set, _old_data_ptr, whose reference\n             // will get dropped when the local_data box is overwritten.\n-            (*map).set_elt(index, new_entry);\n+            map[index] = new_entry;\n         }\n         None => {\n             // Find an empty slot. If not, grow the vector.\n             match (*map).position(|x| x.is_none()) {\n-                Some(empty_index) => (*map).set_elt(empty_index, new_entry),\n-                None => (*map).push(new_entry)\n+                Some(empty_index) => { map[empty_index] = new_entry; }\n+                None => { map.push(new_entry); }\n             }\n         }\n     }"}, {"sha": "00cb977b50c8332e8dd62f709ac25394fbf959e9", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -19,7 +19,6 @@ use metadata::decoder;\n use metadata;\n use middle::{ty, resolve};\n \n-use core::dvec::DVec;\n use core::vec;\n use reader = std::ebml::reader;\n use syntax::ast;\n@@ -136,7 +135,7 @@ pub fn get_supertraits(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::t] {\n \n pub fn get_method_names_if_trait(cstore: @mut cstore::CStore,\n                                  def: ast::def_id)\n-                              -> Option<@DVec<(ast::ident, ast::self_ty_)>> {\n+                              -> Option<~[(ast::ident, ast::self_ty_)]> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     return decoder::get_method_names_if_trait(cstore.intr, cdata, def.node);\n }"}, {"sha": "4fe708d1020cd8b0a7aea70c44885bdbbe40ec80", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -22,8 +22,6 @@ use metadata::decoder;\n use metadata::tydecode::{parse_ty_data, parse_def_id, parse_bounds_data};\n use middle::{ty, resolve};\n \n-use core::dvec;\n-use core::dvec::DVec;\n use core::hash::{Hash, HashUtil};\n use core::int;\n use core::io::WriterUtil;\n@@ -766,27 +764,27 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n /// Returns the supertraits of the given trait.\n pub fn get_supertraits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n                     -> ~[ty::t] {\n-    let results = dvec::DVec();\n+    let mut results = ~[];\n     let item_doc = lookup_item(id, cdata.data);\n     for reader::tagged_docs(item_doc, tag_impl_trait) |trait_doc| {\n         results.push(doc_type(trait_doc, tcx, cdata));\n     }\n-    return dvec::unwrap(results);\n+    return results;\n }\n \n // If the item in question is a trait, returns its set of methods and\n // their self types. Otherwise, returns none. This overlaps in an\n // annoying way with get_trait_methods.\n pub fn get_method_names_if_trait(intr: @ident_interner, cdata: cmd,\n                                  node_id: ast::node_id)\n-                              -> Option<@DVec<(ast::ident, ast::self_ty_)>> {\n+                              -> Option<~[(ast::ident, ast::self_ty_)]> {\n \n     let item = lookup_item(node_id, cdata.data);\n     if item_family(item) != Trait {\n         return None;\n     }\n \n-    let resulting_methods = @DVec();\n+    let mut resulting_methods = ~[];\n     for reader::tagged_docs(item, tag_item_trait_method) |method| {\n         resulting_methods.push(\n             (item_name(intr, method), get_self_ty(method)));\n@@ -823,12 +821,12 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n         return None;\n     }\n \n-    let impl_method_ids = DVec();\n+    let mut impl_method_ids = ~[];\n     for reader::tagged_docs(item, tag_item_impl_method) |impl_method_doc| {\n         impl_method_ids.push(parse_def_id(reader::doc_data(impl_method_doc)));\n     }\n \n-    let static_impl_methods = DVec();\n+    let mut static_impl_methods = ~[];\n     for impl_method_ids.each |impl_method_id| {\n         let impl_method_doc = lookup_item(impl_method_id.node, cdata.data);\n         let family = item_family(impl_method_doc);\n@@ -852,7 +850,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n         }\n     }\n \n-    return Some(dvec::unwrap(static_impl_methods));\n+    return Some(static_impl_methods);\n }\n \n pub fn get_item_attrs(cdata: cmd,"}, {"sha": "414aa035b549743318307de3a4f8dafd2adb5d8a", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -22,7 +22,6 @@ use middle::ty;\n use middle;\n use util::ppaux::ty_to_str;\n \n-use core::dvec;\n use core::flate;\n use core::hash::{Hash, HashUtil};\n use core::int;\n@@ -857,7 +856,7 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         }\n       }\n       item_trait(ref generics, ref traits, ref ms) => {\n-        let provided_methods = dvec::DVec();\n+        let mut provided_methods = ~[];\n \n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n@@ -1366,13 +1365,11 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n \n     if (parms.tcx.sess.meta_stats()) {\n \n-        do wr.bytes.borrow |v| {\n-            do v.each |e| {\n-                if *e == 0 {\n-                    ecx.stats.zero_bytes += 1;\n-                }\n-                true\n+        do wr.bytes.each |e| {\n+            if *e == 0 {\n+                ecx.stats.zero_bytes += 1;\n             }\n+            true\n         }\n \n         io::println(\"metadata stats:\");\n@@ -1401,7 +1398,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n \n     (do str::as_bytes(&~\"rust\\x00\\x00\\x00\\x01\") |bytes| {\n         vec::slice(*bytes, 0, 8).to_vec()\n-    }) + flate::deflate_bytes(wr.bytes.check_out(|buf| buf))\n+    }) + flate::deflate_bytes(wr.bytes)\n }\n \n // Get the encoded string for a type"}, {"sha": "6f0bfbb197facfeb46d54542c133f072f62bdd79", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -25,7 +25,6 @@ use middle::{ty, typeck, moves};\n use middle;\n use util::ppaux::ty_to_str;\n \n-use core::{dvec, io, option, vec};\n use std::ebml::reader;\n use std::ebml;\n use std::serialize;\n@@ -912,11 +911,11 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n         }\n     }\n \n-    for maps.last_use_map.find(&id).each |m| {\n+    for maps.last_use_map.find(&id).each |&m| {\n         do ebml_w.tag(c::tag_table_last_use) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                do ebml_w.emit_from_vec((*m).get()) |id| {\n+                do ebml_w.emit_from_vec(/*bad*/ copy *m) |id| {\n                     id.encode(&ebml_w);\n                 }\n             }\n@@ -1131,8 +1130,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                 let ids = val_dsr.read_to_vec(|| {\n                     xcx.tr_id(val_dsr.read_int())\n                 });\n-                let dvec = @dvec::from_vec(ids);\n-                dcx.maps.last_use_map.insert(id, dvec);\n+                dcx.maps.last_use_map.insert(id, @mut ids);\n             } else if tag == (c::tag_table_method_map as uint) {\n                 dcx.maps.method_map.insert(\n                     id,\n@@ -1211,6 +1209,7 @@ fn mk_ctxt() -> fake_ext_ctxt {\n \n #[cfg(test)]\n fn roundtrip(in_item: Option<@ast::item>) {\n+    use core::io;\n     use std::prettyprint;\n \n     let in_item = in_item.get();"}, {"sha": "94c266ab44fcb296c8e2056f270e500feed36ebb", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -32,7 +32,6 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::{expr_repr, region_to_str};\n \n-use core::dvec;\n use core::hashmap::linear::LinearSet;\n use core::vec;\n use std::oldmap::HashMap;\n@@ -575,9 +574,8 @@ pub impl GatherLoanCtxt {\n                 req_loans.push_all(loans);\n             }\n             None => {\n-                let dvec = @dvec::from_vec(loans);\n                 let req_loan_map = self.req_maps.req_loan_map;\n-                req_loan_map.insert(scope_id, dvec);\n+                req_loan_map.insert(scope_id, @mut loans);\n             }\n         }\n     }"}, {"sha": "5462ec87014e262e98b90573c5266535c94771de", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -234,7 +234,6 @@ use middle::moves;\n use util::common::{indenter, stmt_set};\n use util::ppaux::note_and_explain_region;\n \n-use core::dvec::DVec;\n use core::io;\n use core::result::{Result, Ok, Err};\n use core::to_bytes;\n@@ -406,7 +405,7 @@ pub struct Loan {\n /// - `pure_map`: map from block/expr that must be pure to the error message\n ///   that should be reported if they are not pure\n pub struct ReqMaps {\n-    req_loan_map: HashMap<ast::node_id, @DVec<Loan>>,\n+    req_loan_map: HashMap<ast::node_id, @mut ~[Loan]>,\n     pure_map: HashMap<ast::node_id, bckerr>\n }\n "}, {"sha": "f0c06ceca989c410caa527f898f2d28d64c7d52f", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -112,7 +112,6 @@ use middle::moves;\n use util::ppaux::ty_to_str;\n \n use core::cmp;\n-use core::dvec::DVec;\n use core::io::WriterUtil;\n use core::io;\n use core::ptr;\n@@ -136,7 +135,7 @@ use syntax::{visit, ast_util};\n //\n // Very subtle (#2633): borrowck will remove entries from this table\n // if it detects an outstanding loan (that is, the addr is taken).\n-pub type last_use_map = HashMap<node_id, @DVec<node_id>>;\n+pub type last_use_map = HashMap<node_id, @mut ~[node_id]>;\n \n enum Variable = uint;\n enum LiveNode = uint;\n@@ -419,13 +418,13 @@ pub impl IrMaps {\n             let v = match self.last_use_map.find(&expr_id) {\n               Some(v) => v,\n               None => {\n-                let v = @DVec();\n+                let v = @mut ~[];\n                 self.last_use_map.insert(expr_id, v);\n                 v\n               }\n             };\n \n-            (*v).push(id);\n+            v.push(id);\n           }\n           Arg(_, _, by_ref) |\n           Arg(_, _, by_val) | ImplicitRet => {\n@@ -667,7 +666,7 @@ struct Liveness {\n     users: @mut ~[Users],\n     // The list of node IDs for the nested loop scopes\n     // we're in.\n-    loop_scope: DVec<node_id>,\n+    loop_scope: @mut ~[node_id],\n     // mappings from loop node ID to LiveNode\n     // (\"break\" label should map to loop node ID,\n     // it probably doesn't now)\n@@ -683,7 +682,7 @@ fn Liveness(ir: @mut IrMaps, specials: Specials) -> Liveness {\n         successors: @mut vec::from_elem(ir.num_live_nodes, invalid_node()),\n         users: @mut vec::from_elem(ir.num_live_nodes * ir.num_vars,\n                                    invalid_users()),\n-        loop_scope: DVec(),\n+        loop_scope: @mut ~[],\n         break_ln: HashMap(),\n         cont_ln: HashMap()\n     }\n@@ -856,11 +855,16 @@ pub impl Liveness {\n                     self.tcx.sess.span_bug(sp, ~\"break outside loop\");\n                 }\n                 else {\n-                    self.loop_scope.last()\n+                    // FIXME(#5275): this shouldn't have to be a method...\n+                    self.last_loop_scope()\n                 }\n         }\n     }\n \n+    fn last_loop_scope(&self) -> node_id {\n+        *self.loop_scope.last()\n+    }\n+\n     fn ln_str(&self, ln: LiveNode) -> ~str {\n         do io::with_str_writer |wr| {\n             wr.write_str(~\"[ln(\");"}, {"sha": "3e3b1eb207109e851e5f48a45348a98a9c7511e5", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -21,7 +21,6 @@ use middle::typeck::{method_map, method_origin, method_param, method_self};\n use middle::typeck::{method_super};\n use middle::typeck::{method_static, method_trait};\n \n-use core::dvec::DVec;\n use core::util::ignore;\n use syntax::ast::{def_variant, expr_field, expr_method_call, expr_struct};\n use syntax::ast::{expr_unary, ident, item_struct, item_enum, item_impl};\n@@ -38,7 +37,7 @@ use syntax::visit;\n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: &method_map,\n                    crate: @ast::crate) {\n-    let privileged_items = @DVec();\n+    let privileged_items = @mut ~[];\n \n     // Adds structs that are privileged to this scope.\n     let add_privileged_items: @fn(&[@ast::item]) -> uint = |items| {"}, {"sha": "12c08ffb435851a543dceaf060467d87235eee71", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -26,7 +26,6 @@ use middle::ty::{region_variance, rv_covariant, rv_invariant};\n use middle::ty::{rv_contravariant};\n use middle::ty;\n \n-use core::dvec::DVec;\n use core::vec;\n use std::oldmap::HashMap;\n use syntax::ast_map;\n@@ -395,7 +394,7 @@ pub struct region_dep {\n     id: ast::node_id\n }\n \n-pub type dep_map = HashMap<ast::node_id, @DVec<region_dep>>;\n+pub type dep_map = HashMap<ast::node_id, @mut ~[region_dep]>;\n \n pub struct DetermineRpCtxt {\n     sess: Session,\n@@ -498,7 +497,7 @@ pub impl DetermineRpCtxt {\n         let vec = match self.dep_map.find(&from) {\n             Some(vec) => vec,\n             None => {\n-                let vec = @DVec();\n+                let vec = @mut ~[];\n                 let dep_map = self.dep_map;\n                 dep_map.insert(from, vec);\n                 vec"}, {"sha": "391990eed95de92d66bf61ec966b55ff9bf2c1fc", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 103, "deletions": 98, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -75,7 +75,6 @@ use syntax::visit::{visit_foreign_item, visit_item, visit_method_helper};\n use syntax::visit::{visit_mod, visit_ty, vt};\n use syntax::opt_vec::OptVec;\n \n-use core::dvec::DVec;\n use core::option::{Some, get, is_some, is_none};\n use core::str::{connect, split_str};\n use std::oldmap::HashMap;\n@@ -110,7 +109,7 @@ pub struct Impl {\n }\n \n // Trait method resolution\n-pub type TraitMap = @HashMap<node_id,@DVec<def_id>>;\n+pub type TraitMap = @HashMap<node_id,@mut ~[def_id]>;\n \n // This is the replacement export map. It maps a module to all of the exports\n // within.\n@@ -350,13 +349,13 @@ pub fn Rib(kind: RibKind) -> Rib {\n /// One import directive.\n pub struct ImportDirective {\n     privacy: Privacy,\n-    module_path: @DVec<ident>,\n+    module_path: ~[ident],\n     subclass: @ImportDirectiveSubclass,\n     span: span,\n }\n \n pub fn ImportDirective(privacy: Privacy,\n-                       module_path: @DVec<ident>,\n+                       +module_path: ~[ident],\n                        subclass: @ImportDirectiveSubclass,\n                        span: span)\n                     -> ImportDirective {\n@@ -458,7 +457,7 @@ pub struct Module {\n     kind: ModuleKind,\n \n     children: @HashMap<ident,@mut NameBindings>,\n-    imports: @DVec<@ImportDirective>,\n+    imports: ~[@ImportDirective],\n \n     // The anonymous children of this node. Anonymous children are pseudo-\n     // modules that are implicitly created around items contained within\n@@ -496,7 +495,7 @@ pub fn Module(parent_link: ParentLink,\n         def_id: def_id,\n         kind: kind,\n         children: @HashMap(),\n-        imports: @DVec(),\n+        imports: ~[],\n         anonymous_children: @HashMap(),\n         import_resolutions: @HashMap(),\n         glob_count: 0,\n@@ -781,9 +780,9 @@ pub fn Resolver(session: Session,\n         unresolved_imports: 0,\n \n         current_module: current_module,\n-        value_ribs: @DVec(),\n-        type_ribs: @DVec(),\n-        label_ribs: @DVec(),\n+        value_ribs: ~[],\n+        type_ribs: ~[],\n+        label_ribs: ~[],\n \n         xray_context: NoXray,\n         current_trait_refs: None,\n@@ -830,20 +829,20 @@ pub struct Resolver {\n \n     // The current set of local scopes, for values.\n     // FIXME #4948: Reuse ribs to avoid allocation.\n-    value_ribs: @DVec<@Rib>,\n+    value_ribs: ~[@Rib],\n \n     // The current set of local scopes, for types.\n-    type_ribs: @DVec<@Rib>,\n+    type_ribs: ~[@Rib],\n \n     // The current set of local scopes, for labels.\n-    label_ribs: @DVec<@Rib>,\n+    label_ribs: ~[@Rib],\n \n     // Whether the current context is an X-ray context. An X-ray context is\n     // allowed to access private names of any module.\n     xray_context: XrayFlag,\n \n     // The trait that the current context can refer to.\n-    current_trait_refs: Option<@DVec<def_id>>,\n+    current_trait_refs: Option<~[def_id]>,\n \n     // The ident for the keyword \"self\".\n     self_ident: ident,\n@@ -1407,23 +1406,23 @@ pub impl Resolver {\n                     // globs and lists, the path is found directly in the AST;\n                     // for simple paths we have to munge the path a little.\n \n-                    let module_path = @DVec();\n+                    let mut module_path = ~[];\n                     match view_path.node {\n                         view_path_simple(_, full_path, _, _) => {\n                             let path_len = full_path.idents.len();\n                             fail_unless!(path_len != 0);\n \n                             for full_path.idents.eachi |i, ident| {\n                                 if i != path_len - 1 {\n-                                    (*module_path).push(*ident);\n+                                    module_path.push(*ident);\n                                 }\n                             }\n                         }\n \n                         view_path_glob(module_ident_path, _) |\n                         view_path_list(module_ident_path, _, _) => {\n                             for module_ident_path.idents.each |ident| {\n-                                (*module_path).push(*ident);\n+                                module_path.push(*ident);\n                             }\n                         }\n                     }\n@@ -1457,7 +1456,7 @@ pub impl Resolver {\n                                                              AnyNS);\n                                 self.build_import_directive(privacy,\n                                                             module_,\n-                                                            module_path,\n+                                                            copy module_path,\n                                                             subclass,\n                                                             view_path.span,\n                                                             state);\n@@ -1857,7 +1856,7 @@ pub impl Resolver {\n     fn build_import_directive(@mut self,\n                               privacy: Privacy,\n                               module_: @mut Module,\n-                              module_path: @DVec<ident>,\n+                              +module_path: ~[ident],\n                               subclass: @ImportDirectiveSubclass,\n                               span: span,\n                               state: @mut ImportState) {\n@@ -1873,7 +1872,7 @@ pub impl Resolver {\n                 debug!(\"(building import directive) building import \\\n                         directive: privacy %? %s::%s\",\n                        privacy,\n-                       self.idents_to_str(module_path.get()),\n+                       self.idents_to_str(directive.module_path),\n                        *self.session.str_of(target));\n \n                 match module_.import_resolutions.find(&target) {\n@@ -1887,7 +1886,7 @@ pub impl Resolver {\n                         let resolution = @mut ImportResolution(privacy,\n                                                                span,\n                                                                state);\n-                        let name = self.idents_to_str(module_path.get());\n+                        let name = self.idents_to_str(directive.module_path);\n                         // Don't warn about unused intrinsics because they're\n                         // automatically appended to all files\n                         if name == ~\"intrinsic::rusti\" {\n@@ -1982,13 +1981,13 @@ pub impl Resolver {\n         let import_count = module.imports.len();\n         while module.resolved_import_count < import_count {\n             let import_index = module.resolved_import_count;\n-            let import_directive = module.imports.get_elt(import_index);\n+            let import_directive = module.imports[import_index];\n             match self.resolve_import_for_module(module, import_directive) {\n                 Failed => {\n                     // We presumably emitted an error. Continue.\n-                    let idents = import_directive.module_path.get();\n                     let msg = fmt!(\"failed to resolve import: %s\",\n-                                   *self.import_path_to_str(idents,\n+                                   *self.import_path_to_str(\n+                                       import_directive.module_path,\n                                        *import_directive.subclass));\n                     self.session.span_err(import_directive.span, msg);\n                 }\n@@ -2005,7 +2004,7 @@ pub impl Resolver {\n         }\n     }\n \n-    fn idents_to_str(@mut self, idents: ~[ident]) -> ~str {\n+    fn idents_to_str(@mut self, idents: &[ident]) -> ~str {\n         let ident_strs = do idents.map |ident| {\n             /*bad*/ copy *self.session.str_of(*ident)\n         };\n@@ -2043,11 +2042,11 @@ pub impl Resolver {\n                                  import_directive: @ImportDirective)\n                               -> ResolveResult<()> {\n         let mut resolution_result = Failed;\n-        let module_path = import_directive.module_path;\n+        let module_path = &import_directive.module_path;\n \n         debug!(\"(resolving import for module) resolving import `%s::...` in \\\n                 `%s`\",\n-               self.idents_to_str(module_path.get()),\n+               self.idents_to_str(*module_path),\n                self.module_to_str(module_));\n \n         // First, resolve the module path for the directive, if necessary.\n@@ -2056,7 +2055,7 @@ pub impl Resolver {\n             Some(self.graph_root.get_module())\n         } else {\n             match self.resolve_module_path_for_import(module_,\n-                                                      module_path,\n+                                                      *module_path,\n                                                       DontUseLexicalScope,\n                                                       import_directive.span) {\n \n@@ -2574,21 +2573,21 @@ pub impl Resolver {\n     /// Resolves the given module path from the given root `module_`.\n     fn resolve_module_path_from_root(@mut self,\n                                      module_: @mut Module,\n-                                     module_path: @DVec<ident>,\n+                                     module_path: ~[ident],\n                                      index: uint,\n                                      span: span,\n                                      mut name_search_type: NameSearchType)\n                                   -> ResolveResult<@mut Module> {\n         let mut search_module = module_;\n         let mut index = index;\n-        let module_path_len = (*module_path).len();\n+        let module_path_len = module_path.len();\n \n         // Resolve the module part of the path. This does not involve looking\n         // upward though scope chains; we simply resolve names directly in\n         // modules as we go.\n \n         while index < module_path_len {\n-            let name = (*module_path).get_elt(index);\n+            let name = module_path[index];\n             match self.resolve_name_in_module(search_module,\n                                               name,\n                                               TypeNS,\n@@ -2659,7 +2658,7 @@ pub impl Resolver {\n     /// rooted at the given module.\n     fn resolve_module_path_for_import(@mut self,\n                                       module_: @mut Module,\n-                                      module_path: @DVec<ident>,\n+                                      module_path: ~[ident],\n                                       use_lexical_scope: UseLexicalScopeFlag,\n                                       span: span)\n                                    -> ResolveResult<@mut Module> {\n@@ -2668,7 +2667,7 @@ pub impl Resolver {\n \n         debug!(\"(resolving module path for import) processing `%s` rooted at \\\n                `%s`\",\n-               self.idents_to_str((*module_path).get()),\n+               self.idents_to_str(module_path),\n                self.module_to_str(module_));\n \n         // Resolve the module prefix, if any.\n@@ -2704,7 +2703,7 @@ pub impl Resolver {\n                         // scope and then proceed to resolve below that.\n                         let result = self.resolve_module_in_lexical_scope(\n                             module_,\n-                            module_path.get_elt(0));\n+                            module_path[0]);\n                         match result {\n                             Failed => {\n                                 self.session.span_err(span,\n@@ -2945,19 +2944,19 @@ pub impl Resolver {\n      */\n     fn resolve_module_prefix(@mut self,\n                              module_: @mut Module,\n-                             module_path: @DVec<ident>)\n+                             module_path: ~[ident])\n                           -> ResolveResult<ModulePrefixResult> {\n         let interner = self.session.parse_sess.interner;\n \n         // Start at the current module if we see `self` or `super`, or at the\n         // top of the crate otherwise.\n         let mut containing_module;\n         let mut i;\n-        if *interner.get(module_path.get_elt(0)) == ~\"self\" {\n+        if *interner.get(module_path[0]) == ~\"self\" {\n             containing_module =\n                 self.get_nearest_normal_module_parent_or_self(module_);\n             i = 1;\n-        } else if *interner.get(module_path.get_elt(0)) == ~\"super\" {\n+        } else if *interner.get(module_path[0]) == ~\"super\" {\n             containing_module =\n                 self.get_nearest_normal_module_parent_or_self(module_);\n             i = 0;  // We'll handle `super` below.\n@@ -2967,7 +2966,7 @@ pub impl Resolver {\n \n         // Now loop through all the `super`s we find.\n         while i < module_path.len() &&\n-                *interner.get(module_path.get_elt(i)) == ~\"super\" {\n+                *interner.get(module_path[i]) == ~\"super\" {\n             debug!(\"(resolving module prefix) resolving `super` at %s\",\n                    self.module_to_str(containing_module));\n             match self.get_nearest_normal_module_parent(containing_module) {\n@@ -3064,7 +3063,7 @@ pub impl Resolver {\n         let index = module_.resolved_import_count;\n         let import_count = module_.imports.len();\n         if index != import_count {\n-            self.session.span_err(module_.imports.get_elt(index).span,\n+            self.session.span_err(module_.imports[index].span,\n                                   ~\"unresolved import\");\n         }\n \n@@ -3283,7 +3282,7 @@ pub impl Resolver {\n     // wrappers.\n \n     fn upvarify(@mut self,\n-                ribs: @DVec<@Rib>,\n+                ribs: &mut ~[@Rib],\n                 rib_index: uint,\n                 def_like: def_like,\n                 span: span,\n@@ -3313,9 +3312,8 @@ pub impl Resolver {\n         }\n \n         let mut rib_index = rib_index + 1;\n-        while rib_index < (*ribs).len() {\n-            let rib = (*ribs).get_elt(rib_index);\n-            match rib.kind {\n+        while rib_index < ribs.len() {\n+            match ribs[rib_index].kind {\n                 NormalRibKind => {\n                     // Nothing to do. Continue.\n                 }\n@@ -3393,22 +3391,21 @@ pub impl Resolver {\n     }\n \n     fn search_ribs(@mut self,\n-                   ribs: @DVec<@Rib>,\n+                   ribs: &mut ~[@Rib],\n                    name: ident,\n                    span: span,\n                    allow_capturing_self: AllowCapturingSelfFlag)\n                 -> Option<def_like> {\n         // FIXME #4950: This should not use a while loop.\n         // FIXME #4950: Try caching?\n \n-        let mut i = (*ribs).len();\n+        let mut i = ribs.len();\n         while i != 0 {\n             i -= 1;\n-            let rib = (*ribs).get_elt(i);\n-            match rib.bindings.find(&name) {\n+            match ribs[i].bindings.find(&name) {\n                 Some(def_like) => {\n                     return self.upvarify(ribs, i, def_like, span,\n-                                      allow_capturing_self);\n+                                         allow_capturing_self);\n                 }\n                 None => {\n                     // Continue.\n@@ -3502,7 +3499,7 @@ pub impl Resolver {\n             item_trait(ref generics, ref traits, ref methods) => {\n                 // Create a new rib for the self type.\n                 let self_type_rib = @Rib(NormalRibKind);\n-                (*self.type_ribs).push(self_type_rib);\n+                self.type_ribs.push(self_type_rib);\n                 self_type_rib.bindings.insert(self.type_self_ident,\n                                               dl_def(def_self_ty(item.id)));\n \n@@ -3573,7 +3570,7 @@ pub impl Resolver {\n                     }\n                 }\n \n-                (*self.type_ribs).pop();\n+                self.type_ribs.pop();\n             }\n \n             item_struct(struct_def, ref generics) => {\n@@ -3706,15 +3703,15 @@ pub impl Resolver {\n     }\n \n     fn with_label_rib(@mut self, f: fn()) {\n-        (*self.label_ribs).push(@Rib(NormalRibKind));\n+        self.label_ribs.push(@Rib(NormalRibKind));\n         f();\n-        (*self.label_ribs).pop();\n+        self.label_ribs.pop();\n     }\n \n     fn with_constant_rib(@mut self, f: fn()) {\n-        (*self.value_ribs).push(@Rib(ConstantItemRibKind));\n+        self.value_ribs.push(@Rib(ConstantItemRibKind));\n         f();\n-        (*self.value_ribs).pop();\n+        self.value_ribs.pop();\n     }\n \n     fn resolve_function(@mut self,\n@@ -3726,11 +3723,11 @@ pub impl Resolver {\n                         visitor: ResolveVisitor) {\n         // Create a value rib for the function.\n         let function_value_rib = @Rib(rib_kind);\n-        (*self.value_ribs).push(function_value_rib);\n+        self.value_ribs.push(function_value_rib);\n \n         // Create a label rib for the function.\n         let function_label_rib = @Rib(rib_kind);\n-        (*self.label_ribs).push(function_label_rib);\n+        self.label_ribs.push(function_label_rib);\n \n         // If this function has type parameters, add them now.\n         do self.with_type_parameter_rib(type_parameters) {\n@@ -3790,8 +3787,8 @@ pub impl Resolver {\n             debug!(\"(resolving function) leaving function\");\n         }\n \n-        (*self.label_ribs).pop();\n-        (*self.value_ribs).pop();\n+        self.label_ribs.pop();\n+        self.value_ribs.pop();\n     }\n \n     fn resolve_type_parameters(@mut self,\n@@ -3891,10 +3888,10 @@ pub impl Resolver {\n                                          visitor);\n \n             // Resolve the trait reference, if necessary.\n-            let original_trait_refs = self.current_trait_refs;\n+            let original_trait_refs;\n             match opt_trait_reference {\n                 Some(trait_reference) => {\n-                    let new_trait_refs = @DVec();\n+                    let mut new_trait_refs = ~[];\n                     match self.resolve_path(\n                         trait_reference.path, TypeNS, true, visitor) {\n                         None => {\n@@ -3906,13 +3903,17 @@ pub impl Resolver {\n                             self.record_def(trait_reference.ref_id, def);\n \n                             // Record the current trait reference.\n-                            (*new_trait_refs).push(def_id_of_def(def));\n+                            new_trait_refs.push(def_id_of_def(def));\n                         }\n                     }\n                     // Record the current set of trait references.\n-                    self.current_trait_refs = Some(new_trait_refs);\n+                    let mut old = Some(new_trait_refs);\n+                    self.current_trait_refs <-> old;\n+                    original_trait_refs = Some(old);\n+                }\n+                None => {\n+                    original_trait_refs = None;\n                 }\n-                None => ()\n             }\n \n             // Resolve the self type.\n@@ -3945,7 +3946,10 @@ pub impl Resolver {\n             }\n \n             // Restore the original trait references.\n-            self.current_trait_refs = original_trait_refs;\n+            match original_trait_refs {\n+                Some(r) => { self.current_trait_refs = r; }\n+                None => ()\n+            }\n         }\n     }\n \n@@ -4032,7 +4036,7 @@ pub impl Resolver {\n     }\n \n     fn resolve_arm(@mut self, arm: &arm, visitor: ResolveVisitor) {\n-        (*self.value_ribs).push(@Rib(NormalRibKind));\n+        self.value_ribs.push(@Rib(NormalRibKind));\n \n         let bindings_list = HashMap();\n         for arm.pats.each |pattern| {\n@@ -4047,12 +4051,12 @@ pub impl Resolver {\n         visit_expr_opt(arm.guard, (), visitor);\n         self.resolve_block(&arm.body, visitor);\n \n-        (*self.value_ribs).pop();\n+        self.value_ribs.pop();\n     }\n \n     fn resolve_block(@mut self, block: &blk, visitor: ResolveVisitor) {\n         debug!(\"(resolving block) entering block\");\n-        (*self.value_ribs).push(@Rib(NormalRibKind));\n+        self.value_ribs.push(@Rib(NormalRibKind));\n \n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module;\n@@ -4071,7 +4075,7 @@ pub impl Resolver {\n         // Move back up.\n         self.current_module = orig_module;\n \n-        (*self.value_ribs).pop();\n+        self.value_ribs.pop();\n         debug!(\"(resolving block) leaving block\");\n     }\n \n@@ -4251,7 +4255,8 @@ pub impl Resolver {\n                                 Some(bindings_list)\n                                 if !bindings_list.contains_key(&ident)\n                                     => {\n-                                    let last_rib = (*self.value_ribs).last();\n+                                    let last_rib = self.value_ribs[\n+                                            self.value_ribs.len() - 1];\n                                     last_rib.bindings.insert(ident,\n                                                              dl_def(def));\n                                     bindings_list.insert(ident, pat_id);\n@@ -4270,7 +4275,8 @@ pub impl Resolver {\n                                   // Not bound in the same pattern: do nothing\n                                 }\n                                 None => {\n-                                    let last_rib = (*self.value_ribs).last();\n+                                    let last_rib = self.value_ribs[\n+                                            self.value_ribs.len() - 1];\n                                     last_rib.bindings.insert(ident,\n                                                              dl_def(def));\n                                 }\n@@ -4510,14 +4516,14 @@ pub impl Resolver {\n         }\n     }\n \n-    fn intern_module_part_of_path(@mut self, path: @path) -> @DVec<ident> {\n-        let module_path_idents = @DVec();\n+    fn intern_module_part_of_path(@mut self, path: @path) -> ~[ident] {\n+        let mut module_path_idents = ~[];\n         for path.idents.eachi |index, ident| {\n             if index == path.idents.len() - 1 {\n                 break;\n             }\n \n-            (*module_path_idents).push(*ident);\n+            module_path_idents.push(*ident);\n         }\n \n         return module_path_idents;\n@@ -4539,7 +4545,7 @@ pub impl Resolver {\n                 self.session.span_err(path.span,\n                                       fmt!(\"use of undeclared module `%s`\",\n                                            self.idents_to_str(\n-                                               (*module_path_idents).get())));\n+                                               module_path_idents)));\n                 return None;\n             }\n \n@@ -4587,8 +4593,8 @@ pub impl Resolver {\n             Failed => {\n                 self.session.span_err(path.span,\n                                       fmt!(\"use of undeclared module `::%s`\",\n-                                            self.idents_to_str\n-                                              ((*module_path_idents).get())));\n+                                            self.idents_to_str(\n+                                              module_path_idents)));\n                 return None;\n             }\n \n@@ -4625,12 +4631,13 @@ pub impl Resolver {\n         let mut search_result;\n         match namespace {\n             ValueNS => {\n-                search_result = self.search_ribs(self.value_ribs, ident, span,\n+                search_result = self.search_ribs(&mut self.value_ribs, ident,\n+                                                 span,\n                                                  DontAllowCapturingSelf);\n             }\n             TypeNS => {\n-                search_result = self.search_ribs(self.type_ribs, ident, span,\n-                                                 AllowCapturingSelf);\n+                search_result = self.search_ribs(&mut self.type_ribs, ident,\n+                                                 span, AllowCapturingSelf);\n             }\n         }\n \n@@ -4688,8 +4695,7 @@ pub impl Resolver {\n         let mut j = self.value_ribs.len();\n         while j != 0 {\n             j -= 1;\n-            let rib = self.value_ribs.get_elt(j);\n-            for rib.bindings.each_entry |e| {\n+            for self.value_ribs[j].bindings.each_entry |e| {\n                 vec::push(&mut maybes, copy *self.session.str_of(e.key));\n                 vec::push(&mut values, uint::max_value);\n             }\n@@ -4721,8 +4727,7 @@ pub impl Resolver {\n         let mut i = self.type_ribs.len();\n         while i != 0 {\n           i -= 1;\n-          let rib = self.type_ribs.get_elt(i);\n-          match rib.kind {\n+          match self.type_ribs[i].kind {\n             MethodRibKind(node_id, _) =>\n               for self.crate.node.module.items.each |item| {\n                 if item.id == node_id {\n@@ -4839,14 +4844,15 @@ pub impl Resolver {\n             expr_loop(_, Some(label)) => {\n                 do self.with_label_rib {\n                     let def_like = dl_def(def_label(expr.id));\n-                    self.label_ribs.last().bindings.insert(label, def_like);\n+                    let rib = self.label_ribs[self.label_ribs.len() - 1];\n+                    rib.bindings.insert(label, def_like);\n \n                     visit_expr(expr, (), visitor);\n                 }\n             }\n \n             expr_break(Some(label)) | expr_again(Some(label)) => {\n-                match self.search_ribs(self.label_ribs, label, expr.span,\n+                match self.search_ribs(&mut self.label_ribs, label, expr.span,\n                                        DontAllowCapturingSelf) {\n                     None =>\n                         self.session.span_err(expr.span,\n@@ -4873,11 +4879,11 @@ pub impl Resolver {\n         match expr.node {\n             expr_field(_, ident, _) => {\n                 let traits = self.search_for_traits_containing_method(ident);\n-                self.trait_map.insert(expr.id, traits);\n+                self.trait_map.insert(expr.id, @mut traits);\n             }\n             expr_method_call(_, ident, _, _, _) => {\n                 let traits = self.search_for_traits_containing_method(ident);\n-                self.trait_map.insert(expr.id, traits);\n+                self.trait_map.insert(expr.id, @mut traits);\n             }\n             expr_binary(add, _, _) | expr_assign_op(add, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n@@ -4948,19 +4954,19 @@ pub impl Resolver {\n \n     fn search_for_traits_containing_method(@mut self,\n                                            name: ident)\n-                                        -> @DVec<def_id> {\n+                                        -> ~[def_id] {\n         debug!(\"(searching for traits containing method) looking for '%s'\",\n                *self.session.str_of(name));\n \n-        let found_traits = @DVec();\n+        let mut found_traits = ~[];\n         let mut search_module = self.current_module;\n         loop {\n             // Look for the current trait.\n             match copy self.current_trait_refs {\n                 Some(trait_def_ids) => {\n                     for trait_def_ids.each |trait_def_id| {\n                         self.add_trait_info_if_containing_method(\n-                            found_traits, *trait_def_id, name);\n+                            &mut found_traits, *trait_def_id, name);\n                     }\n                 }\n                 None => {\n@@ -4975,7 +4981,7 @@ pub impl Resolver {\n                         match def {\n                             def_ty(trait_def_id) => {\n                                 self.add_trait_info_if_containing_method(\n-                                    found_traits, trait_def_id, name);\n+                                    &mut found_traits, trait_def_id, name);\n                             }\n                             _ => {\n                                 // Continue.\n@@ -5003,7 +5009,8 @@ pub impl Resolver {\n                                     def_ty(trait_def_id) => {\n                                         let added = self.\n                                         add_trait_info_if_containing_method(\n-                                        found_traits, trait_def_id, name);\n+                                            &mut found_traits,\n+                                            trait_def_id, name);\n                                         if added {\n                                             import_resolution.state.used =\n                                                 true;\n@@ -5039,7 +5046,7 @@ pub impl Resolver {\n     }\n \n     fn add_trait_info_if_containing_method(@mut self,\n-                                           found_traits: @DVec<def_id>,\n+                                           found_traits: &mut ~[def_id],\n                                            trait_def_id: def_id,\n                                            name: ident)\n                                         -> bool {\n@@ -5056,7 +5063,7 @@ pub impl Resolver {\n                        trait_def_id.crate,\n                        trait_def_id.node,\n                        *self.session.str_of(name));\n-                (*found_traits).push(trait_def_id);\n+                found_traits.push(trait_def_id);\n                 true\n             }\n             Some(_) | None => {\n@@ -5068,9 +5075,7 @@ pub impl Resolver {\n     fn add_fixed_trait_for_expr(@mut self,\n                                 expr_id: node_id,\n                                 +trait_id: def_id) {\n-        let traits = @DVec();\n-        traits.push(trait_id);\n-        self.trait_map.insert(expr_id, traits);\n+        self.trait_map.insert(expr_id, @mut ~[trait_id]);\n     }\n \n     fn record_def(@mut self, node_id: node_id, def: def) {\n@@ -5225,7 +5230,7 @@ pub impl Resolver {\n \n     /// A somewhat inefficient routine to obtain the name of a module.\n     fn module_to_str(@mut self, module_: @mut Module) -> ~str {\n-        let idents = DVec();\n+        let mut idents = ~[];\n         let mut current_module = module_;\n         loop {\n             match current_module.parent_link {\n@@ -5246,7 +5251,7 @@ pub impl Resolver {\n         if idents.len() == 0 {\n             return ~\"???\";\n         }\n-        return self.idents_to_str(vec::reversed(idents.get()));\n+        return self.idents_to_str(vec::reversed(idents));\n     }\n \n     fn dump_module(@mut self, module_: @mut Module) {"}, {"sha": "8411064c57aefb26501fad3d5f6462e58a23a152", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -167,8 +167,6 @@ use middle::trans::type_of;\n use middle::ty;\n use util::common::indenter;\n \n-use core::dvec::DVec;\n-use core::dvec;\n use std::oldmap::HashMap;\n use syntax::ast;\n use syntax::ast::ident;\n@@ -553,7 +551,7 @@ pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n                     // Reorder the patterns into the same order they were\n                     // specified in the struct definition. Also fill in\n                     // unspecified fields with dummy.\n-                    let reordered_patterns = dvec::DVec();\n+                    let mut reordered_patterns = ~[];\n                     for ty::lookup_struct_fields(tcx, struct_id).each\n                         |field| {\n                             match field_pats.find(|p|\n@@ -562,7 +560,7 @@ pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n                                 Some(fp) => reordered_patterns.push(fp.pat)\n                             }\n                     }\n-                    Some(dvec::unwrap(reordered_patterns))\n+                    Some(reordered_patterns)\n                 } else {\n                     None\n                 }\n@@ -764,32 +762,32 @@ pub fn enter_region(bcx: block,\n // on a set of enum variants or a literal.\n pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n     let ccx = bcx.ccx();\n-    fn add_to_set(tcx: ty::ctxt, set: &DVec<Opt>, +val: Opt) {\n+    fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], +val: Opt) {\n         if set.any(|l| opt_eq(tcx, l, &val)) {return;}\n         set.push(val);\n     }\n \n-    let found = DVec();\n-    for vec::each(m) |br| {\n+    let mut found = ~[];\n+    for m.each |br| {\n         let cur = br.pats[col];\n         match /*bad*/copy cur.node {\n             ast::pat_lit(l) => {\n-                add_to_set(ccx.tcx, &found, lit(ExprLit(l)));\n+                add_to_set(ccx.tcx, &mut found, lit(ExprLit(l)));\n             }\n             ast::pat_ident(*) => {\n                 // This is one of: an enum variant, a unit-like struct, or a\n                 // variable binding.\n                 match ccx.tcx.def_map.find(&cur.id) {\n                     Some(ast::def_variant(*)) => {\n-                        add_to_set(ccx.tcx, &found,\n+                        add_to_set(ccx.tcx, &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n                     Some(ast::def_struct(*)) => {\n-                        add_to_set(ccx.tcx, &found,\n+                        add_to_set(ccx.tcx, &mut found,\n                                    lit(UnitLikeStructLit(cur.id)));\n                     }\n                     Some(ast::def_const(const_did)) => {\n-                        add_to_set(ccx.tcx, &found,\n+                        add_to_set(ccx.tcx, &mut found,\n                                    lit(ConstLit(const_did)));\n                     }\n                     _ => {}\n@@ -800,26 +798,26 @@ pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n                 // struct-like enum variant, or a struct.\n                 match ccx.tcx.def_map.find(&cur.id) {\n                     Some(ast::def_variant(*)) => {\n-                        add_to_set(ccx.tcx, &found,\n+                        add_to_set(ccx.tcx, &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n                     _ => {}\n                 }\n             }\n             ast::pat_range(l1, l2) => {\n-                add_to_set(ccx.tcx, &found, range(l1, l2));\n+                add_to_set(ccx.tcx, &mut found, range(l1, l2));\n             }\n             ast::pat_vec(elems, tail) => {\n                 let opt = match tail {\n                     None => vec_len_eq(elems.len()),\n                     Some(_) => vec_len_ge(elems.len())\n                 };\n-                add_to_set(ccx.tcx, &found, opt);\n+                add_to_set(ccx.tcx, &mut found, opt);\n             }\n             _ => {}\n         }\n     }\n-    return dvec::unwrap(found);\n+    return found;\n }\n \n pub struct ExtractedBlock {\n@@ -1074,7 +1072,7 @@ pub fn compare_values(cx: block,\n \n pub fn store_non_ref_bindings(bcx: block,\n                               data: &ArmData,\n-                              opt_temp_cleanups: Option<&DVec<ValueRef>>)\n+                              opt_temp_cleanups: Option<&mut ~[ValueRef]>)\n                            -> block {\n     /*!\n      *\n@@ -1166,8 +1164,8 @@ pub fn compile_guard(bcx: block,\n     let _indenter = indenter();\n \n     let mut bcx = bcx;\n-    let temp_cleanups = DVec();\n-    bcx = store_non_ref_bindings(bcx, data, Some(&temp_cleanups));\n+    let mut temp_cleanups = ~[];\n+    bcx = store_non_ref_bindings(bcx, data, Some(&mut temp_cleanups));\n     bcx = insert_lllocals(bcx, data, false);\n \n     let val = unpack_result!(bcx, {\n@@ -1627,7 +1625,7 @@ pub fn trans_match_inner(scope_cx: block,\n     let lldiscr = discr_datum.to_ref_llval(bcx);\n     compile_submatch(bcx, matches, ~[lldiscr], chk);\n \n-    let arm_cxs = DVec();\n+    let mut arm_cxs = ~[];\n     for arm_datas.each |arm_data| {\n         let mut bcx = arm_data.bodycx;\n \n@@ -1647,7 +1645,7 @@ pub fn trans_match_inner(scope_cx: block,\n         arm_cxs.push(bcx);\n     }\n \n-    bcx = controlflow::join_blocks(scope_cx, dvec::unwrap(arm_cxs));\n+    bcx = controlflow::join_blocks(scope_cx, arm_cxs);\n     return bcx;\n \n     fn mk_fail(bcx: block, sp: span, msg: @~str,"}, {"sha": "978b1ed16d8414afbf4c04f49e6835af738b9f18", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -29,8 +29,6 @@ use util::common::{indenter};\n \n use core::cast;\n use core::cmp;\n-use core::dvec::DVec;\n-use core::dvec;\n use core::ops;\n use core::option;\n use core::ptr::to_unsafe_ptr;\n@@ -213,7 +211,7 @@ pub enum AutoRefKind {\n // This is a map from ID of each implementation to the method info and trait\n // method ID of each of the default methods belonging to the trait that that\n // implementation implements.\n-pub type ProvidedMethodsMap = HashMap<def_id,@DVec<@ProvidedMethodInfo>>;\n+pub type ProvidedMethodsMap = HashMap<def_id,@mut ~[@ProvidedMethodInfo]>;\n \n // Stores the method info and definition ID of the associated trait method for\n // each instantiation of each provided method.\n@@ -3522,7 +3520,7 @@ pub fn trait_supertraits(cx: ctxt,\n \n     // Get the supertraits out of the metadata and create the\n     // InstantiatedTraitRef for each.\n-    let result = dvec::DVec();\n+    let mut result = ~[];\n     for csearch::get_supertraits(cx, id).each |trait_type| {\n         match get(*trait_type).sty {\n             ty_trait(def_id, ref substs, _) => {\n@@ -3539,7 +3537,7 @@ pub fn trait_supertraits(cx: ctxt,\n     }\n \n     // Unwrap and return the result.\n-    return @dvec::unwrap(result);\n+    return @result;\n }\n \n pub fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {"}, {"sha": "0bcbb3012cf1004b01a964e50b56b696df32f3c7", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -95,7 +95,6 @@ use middle::typeck::{method_self, method_static, method_trait, method_super};\n use util::common::indenter;\n use util::ppaux::expr_repr;\n \n-use core::dvec::DVec;\n use core::result;\n use core::uint;\n use core::vec;\n@@ -127,8 +126,8 @@ pub fn lookup(\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n         impl_dups: HashMap(),\n-        inherent_candidates: DVec(),\n-        extension_candidates: DVec(),\n+        inherent_candidates: @mut ~[],\n+        extension_candidates: @mut ~[],\n         deref_args: deref_args,\n     };\n     let mme = lcx.do_lookup(self_ty);\n@@ -145,8 +144,8 @@ pub struct LookupContext {\n     m_name: ast::ident,\n     supplied_tps: &self/[ty::t],\n     impl_dups: HashMap<def_id, ()>,\n-    inherent_candidates: DVec<Candidate>,\n-    extension_candidates: DVec<Candidate>,\n+    inherent_candidates: @mut ~[Candidate],\n+    extension_candidates: @mut ~[Candidate],\n     deref_args: check::DerefArgs,\n }\n \n@@ -188,7 +187,7 @@ pub impl LookupContext/&self {\n         self.push_inherent_candidates(self_ty);\n         self.push_extension_candidates(self_ty);\n \n-        let enum_dids = DVec();\n+        let mut enum_dids = ~[];\n         let mut self_ty = self_ty;\n         let mut autoderefs = 0;\n         loop {\n@@ -224,7 +223,7 @@ pub impl LookupContext/&self {\n                 }\n             }\n \n-            match self.deref(self_ty, &enum_dids) {\n+            match self.deref(self_ty, &mut enum_dids) {\n                 None => { break; }\n                 Some(ty) => {\n                     self_ty = ty;\n@@ -236,7 +235,7 @@ pub impl LookupContext/&self {\n         self.search_for_autosliced_method(self_ty, autoderefs)\n     }\n \n-    fn deref(ty: ty::t, enum_dids: &DVec<ast::def_id>) -> Option<ty::t> {\n+    fn deref(ty: ty::t, enum_dids: &mut ~[ast::def_id]) -> Option<ty::t> {\n         match ty::get(ty).sty {\n             ty_enum(did, _) => {\n                 // Watch out for newtype'd enums like \"enum t = @T\".\n@@ -272,7 +271,7 @@ pub impl LookupContext/&self {\n          * example, if the receiver is @@C where `C` is a struct type,\n          * we'll want to find the inherent impls for `C`. */\n \n-        let enum_dids = DVec();\n+        let mut enum_dids = ~[];\n         let mut self_ty = self_ty;\n         loop {\n             match get(self_ty).sty {\n@@ -307,7 +306,7 @@ pub impl LookupContext/&self {\n             // n.b.: Generally speaking, we only loop if we hit the\n             // fallthrough case in the match above.  The exception\n             // would be newtype enums.\n-            self_ty = match self.deref(self_ty, &enum_dids) {\n+            self_ty = match self.deref(self_ty, &mut enum_dids) {\n                 None => { return; }\n                 Some(ty) => { ty }\n             }\n@@ -330,15 +329,15 @@ pub impl LookupContext/&self {\n                 for opt_impl_infos.each |impl_infos| {\n                     for impl_infos.each |impl_info| {\n                         self.push_candidates_from_impl(\n-                            &self.extension_candidates, *impl_info);\n+                            self.extension_candidates, *impl_info);\n                     }\n                 }\n \n                 // Look for default methods.\n                 match self.tcx().provided_methods.find(trait_did) {\n                     Some(methods) => {\n                         self.push_candidates_from_provided_methods(\n-                            &self.extension_candidates, self_ty, *trait_did,\n+                            self.extension_candidates, self_ty, *trait_did,\n                             methods);\n                     }\n                     None => {}\n@@ -606,12 +605,12 @@ pub impl LookupContext/&self {\n         for opt_impl_infos.each |impl_infos| {\n             for impl_infos.each |impl_info| {\n                 self.push_candidates_from_impl(\n-                    &self.inherent_candidates, *impl_info);\n+                    self.inherent_candidates, *impl_info);\n             }\n         }\n     }\n \n-    fn push_candidates_from_impl(&self, candidates: &DVec<Candidate>,\n+    fn push_candidates_from_impl(&self, candidates: &mut ~[Candidate],\n                                  impl_info: &resolve::Impl) {\n         if !self.impl_dups.insert(impl_info.did, ()) {\n             return; // already visited\n@@ -657,10 +656,10 @@ pub impl LookupContext/&self {\n \n     fn push_candidates_from_provided_methods(\n             &self,\n-            candidates: &DVec<Candidate>,\n+            candidates: &mut ~[Candidate],\n             self_ty: ty::t,\n             trait_def_id: def_id,\n-            methods: @DVec<@ProvidedMethodInfo>) {\n+            methods: &mut ~[@ProvidedMethodInfo]) {\n         debug!(\"(pushing candidates from provided methods) considering trait \\\n                 id %d:%d\",\n                trait_def_id.crate,\n@@ -970,15 +969,15 @@ pub impl LookupContext/&self {\n         // existing code.\n \n         debug!(\"searching inherent candidates\");\n-        match self.consider_candidates(self_ty, &self.inherent_candidates) {\n+        match self.consider_candidates(self_ty, self.inherent_candidates) {\n             None => {}\n             Some(mme) => {\n                 return Some(mme);\n             }\n         }\n \n         debug!(\"searching extension candidates\");\n-        match self.consider_candidates(self_ty, &self.extension_candidates) {\n+        match self.consider_candidates(self_ty, self.extension_candidates) {\n             None => {\n                 return None;\n             }\n@@ -990,7 +989,7 @@ pub impl LookupContext/&self {\n \n     fn consider_candidates(&self,\n                            self_ty: ty::t,\n-                           candidates: &DVec<Candidate>)\n+                           candidates: &mut ~[Candidate])\n         -> Option<method_map_entry>\n     {\n         let relevant_candidates ="}, {"sha": "3e45323807212ac77485270d26d608cd1e02d24d", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -55,7 +55,6 @@ use syntax::visit::{Visitor, SimpleVisitor};\n use syntax::visit::{visit_mod};\n use util::ppaux::ty_to_str;\n \n-use core::dvec::DVec;\n use core::result::Ok;\n use core::hashmap::linear::LinearSet;\n use core::uint;\n@@ -151,11 +150,11 @@ pub fn method_to_MethodInfo(ast_method: @method) -> @MethodInfo {\n pub struct CoherenceInfo {\n     // Contains implementations of methods that are inherent to a type.\n     // Methods in these implementations don't need to be exported.\n-    inherent_methods: HashMap<def_id,@DVec<@Impl>>,\n+    inherent_methods: HashMap<def_id,@mut ~[@Impl]>,\n \n     // Contains implementations of methods associated with a trait. For these,\n     // the associated trait must be imported at the call site.\n-    extension_methods: HashMap<def_id,@DVec<@Impl>>,\n+    extension_methods: HashMap<def_id,@mut ~[@Impl]>,\n \n }\n \n@@ -372,9 +371,8 @@ pub impl CoherenceChecker {\n                             for method `%s`\",\n                             *self.crate_context.tcx.sess.str_of(\n                                 provided_method_info.method_info.ident));\n-                    let method_infos = @DVec();\n-                    method_infos.push(provided_method_info);\n-                    pmm.insert(local_def(impl_id), method_infos);\n+                    pmm.insert(local_def(impl_id),\n+                               @mut ~[provided_method_info]);\n                 }\n             }\n         }\n@@ -386,7 +384,7 @@ pub impl CoherenceChecker {\n         match self.crate_context.coherence_info.inherent_methods\n                   .find(&base_def_id) {\n             None => {\n-                implementation_list = @DVec();\n+                implementation_list = @mut ~[];\n                 self.crate_context.coherence_info.inherent_methods\n                     .insert(base_def_id, implementation_list);\n             }\n@@ -403,7 +401,7 @@ pub impl CoherenceChecker {\n         match self.crate_context.coherence_info.extension_methods\n                   .find(&trait_id) {\n             None => {\n-                implementation_list = @DVec();\n+                implementation_list = @mut ~[];\n                 self.crate_context.coherence_info.extension_methods\n                     .insert(trait_id, implementation_list);\n             }\n@@ -741,13 +739,13 @@ pub impl CoherenceChecker {\n     // Converts an implementation in the AST to an Impl structure.\n     fn create_impl_from_item(&self, item: @item) -> @Impl {\n         fn add_provided_methods(all_methods: &mut ~[@MethodInfo],\n-                                all_provided_methods: ~[@ProvidedMethodInfo],\n-                                sess: driver::session::Session) {\n+                            all_provided_methods: &mut ~[@ProvidedMethodInfo],\n+                            sess: driver::session::Session) {\n             for all_provided_methods.each |provided_method| {\n                 debug!(\n                     \"(creating impl) adding provided method `%s` to impl\",\n                     *sess.str_of(provided_method.method_info.ident));\n-                vec::push(&mut *all_methods, provided_method.method_info);\n+                vec::push(all_methods, provided_method.method_info);\n             }\n         }\n \n@@ -790,7 +788,7 @@ pub impl CoherenceChecker {\n                             // Add all provided methods.\n                             add_provided_methods(\n                                 &mut methods,\n-                                all_provided.get(),\n+                                all_provided,\n                                 self.crate_context.tcx.sess);\n                         }\n                     }\n@@ -943,9 +941,7 @@ pub impl CoherenceChecker {\n                     trait_method_def_id: trait_method_info.def_id\n                 };\n \n-            let method_infos = @DVec();\n-            method_infos.push(provided_method_info);\n-            pmm.insert(trait_def_id, method_infos);\n+            pmm.insert(trait_def_id, @mut ~[provided_method_info]);\n         }\n     }\n "}, {"sha": "6c8bfdb041ddd4c8f2ce169aae952e8f2d884270", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -46,7 +46,6 @@ use middle::typeck::{CrateCtxt, lookup_def_tcx, no_params, write_ty_to_tcx};\n use util::common::{indenter, pluralize};\n use util::ppaux;\n \n-use core::dvec;\n use core::vec;\n use syntax::ast::{RegionTyParamBound, TraitTyParamBound};\n use syntax::ast;\n@@ -321,7 +320,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n     if tcx.supertraits.contains_key(&local_def(id)) { return; }\n \n-    let instantiated = dvec::DVec();\n+    let mut instantiated = ~[];\n     for trait_refs.each |trait_ref| {\n         let (did, tpt) = instantiate_trait_ref(ccx, *trait_ref, rp);\n         if instantiated.any(|other_trait: &InstantiatedTraitRef|\n@@ -334,8 +333,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n         }\n         instantiated.push(InstantiatedTraitRef { def_id: did, tpt: tpt });\n     }\n-    tcx.supertraits.insert(local_def(id),\n-                               @dvec::unwrap(instantiated));\n+    tcx.supertraits.insert(local_def(id), @instantiated);\n }\n \n /**"}, {"sha": "35c901c7528de637114309aae38f38c7dede0112", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -549,7 +549,6 @@ use util::ppaux::note_and_explain_region;\n \n use core::cell::{Cell, empty_cell};\n use core::cmp;\n-use core::dvec::DVec;\n use core::result::{Err, Ok, Result};\n use core::to_bytes;\n use core::uint;\n@@ -627,7 +626,7 @@ type CombineMap = HashMap<TwoRegions, RegionVid>;\n \n pub struct RegionVarBindings {\n     tcx: ty::ctxt,\n-    var_spans: DVec<span>,\n+    var_spans: ~[span],\n     constraints: HashMap<Constraint, span>,\n     lubs: CombineMap,\n     glbs: CombineMap,\n@@ -653,7 +652,7 @@ pub struct RegionVarBindings {\n pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n     RegionVarBindings {\n         tcx: tcx,\n-        var_spans: DVec(),\n+        var_spans: ~[],\n         values: empty_cell(),\n         constraints: HashMap(),\n         lubs: CombineMap(),"}, {"sha": "897cb4c2034034af04b277db61e96de0379c3bae", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -452,12 +452,10 @@ pub mod flatteners {\n \n     pub fn serialize_value<D: Encoder + FromWriter,\n                            T: Encodable<D>>(val: &T) -> ~[u8] {\n-        let bytes_writer = @BytesWriter();\n-        let writer = bytes_writer as @Writer;\n-        let ser = FromWriter::from_writer(writer);\n-        val.encode(&ser);\n-        let bytes = bytes_writer.bytes.check_out(|bytes| bytes);\n-        return bytes;\n+        do io::with_bytes_writer |writer| {\n+            let ser = FromWriter::from_writer(writer);\n+            val.encode(&ser);\n+        }\n     }\n \n     pub trait FromReader {\n@@ -651,7 +649,7 @@ mod test {\n \n         chan.send(10);\n \n-        let bytes = chan.byte_chan.writer.bytes.get();\n+        let bytes = copy chan.byte_chan.writer.bytes;\n \n         let reader = BufReader::new(bytes);\n         let port = serial::reader_port(reader);\n@@ -697,7 +695,7 @@ mod test {\n \n         chan.send(10);\n \n-        let bytes = chan.byte_chan.writer.bytes.get();\n+        let bytes = copy chan.byte_chan.writer.bytes;\n \n         let reader = BufReader::new(bytes);\n         let port = pod::reader_port(reader);"}, {"sha": "9208d415971c6f0cbce35ea5d35792aa25d195fe", "filename": "src/libstd/json.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -27,7 +27,6 @@ use core::prelude::*;\n use core::hashmap::linear::LinearMap;\n use core::str;\n use core::to_str;\n-use core::vec;\n \n /// Represents a json value\n pub enum Json {\n@@ -1312,8 +1311,7 @@ mod tests {\n                 }\n             }\n         }\n-        check_equal(str::from_bytes(bw.bytes.data),\n-                    ~\"[\\\"frog\\\",[\\\"Henry\\\",349]]\");\n+        check_equal(str::from_bytes(bw.bytes), ~\"[\\\"frog\\\",[\\\"Henry\\\",349]]\");\n     }\n \n     #[test]\n@@ -1328,8 +1326,7 @@ mod tests {\n                 }\n             }\n         }\n-        check_equal(str::from_bytes(bw.bytes.data),\n-                    ~\"\\\"jodhpurs\\\"\");\n+        check_equal(str::from_bytes(bw.bytes), ~\"\\\"jodhpurs\\\"\");\n     }\n \n     #[test]\n@@ -1341,8 +1338,7 @@ mod tests {\n             do encoder.emit_enum_variant (~\"None\",37,1242) {\n             }\n         }\n-        check_equal(str::from_bytes(bw.bytes.data),\n-                    ~\"null\");\n+        check_equal(str::from_bytes(bw.bytes), ~\"null\");\n     }\n \n     #[test]"}, {"sha": "50de528762f26e716dcc553140ee0ccb6c2db6fa", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 46, "deletions": 54, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -11,7 +11,6 @@\n //! Sorting methods\n \n use core::cmp::{Eq, Ord};\n-use core::dvec::DVec;\n use core::prelude::*;\n use core::util;\n use core::vec::{len, push};\n@@ -189,7 +188,7 @@ pub fn tim_sort<T:Copy + Ord>(array: &mut [T]) {\n         return;\n     }\n \n-    let ms = &MergeState();\n+    let mut ms = MergeState();\n     let min_run = min_run_length(size);\n \n     let mut idx = 0;\n@@ -392,66 +391,63 @@ struct RunState {\n }\n \n struct MergeState<T> {\n-    mut min_gallop: uint,\n-    runs: DVec<RunState>,\n+    min_gallop: uint,\n+    runs: ~[RunState],\n }\n \n // Fixme (#3853) Move into MergeState\n fn MergeState<T>() -> MergeState<T> {\n     MergeState {\n         min_gallop: MIN_GALLOP,\n-        runs: DVec(),\n+        runs: ~[],\n     }\n }\n \n-pub impl<T:Copy + Ord> MergeState<T> {\n-    fn push_run(&self, run_base: uint, run_len: uint) {\n+impl<T:Copy + Ord> MergeState<T> {\n+    fn push_run(&mut self, run_base: uint, run_len: uint) {\n         let tmp = RunState{base: run_base, len: run_len};\n         self.runs.push(tmp);\n     }\n \n-    fn merge_at(&self, n: uint, array: &mut [T]) {\n+    fn merge_at(&mut self, n: uint, array: &mut [T]) {\n         let mut size = self.runs.len();\n         fail_unless!(size >= 2);\n         fail_unless!(n == size-2 || n == size-3);\n \n-        do self.runs.borrow_mut |arr| {\n+        let mut b1 = self.runs[n].base;\n+        let mut l1 = self.runs[n].len;\n+        let b2 = self.runs[n+1].base;\n+        let l2 = self.runs[n+1].len;\n \n-            let mut b1 = arr[n].base;\n-            let mut l1 = arr[n].len;\n-            let b2 = arr[n+1].base;\n-            let l2 = arr[n+1].len;\n+        fail_unless!(l1 > 0 && l2 > 0);\n+        fail_unless!(b1 + l1 == b2);\n \n-            fail_unless!(l1 > 0 && l2 > 0);\n-            fail_unless!(b1 + l1 == b2);\n-\n-            arr[n].len = l1 + l2;\n-            if n == size-3 {\n-                arr[n+1].base = arr[n+2].base;\n-                arr[n+1].len = arr[n+2].len;\n-            }\n+        self.runs[n].len = l1 + l2;\n+        if n == size-3 {\n+            self.runs[n+1].base = self.runs[n+2].base;\n+            self.runs[n+1].len = self.runs[n+2].len;\n+        }\n \n-            let slice = vec::mut_slice(array, b1, b1+l1);\n-            let k = gallop_right(&const array[b2], slice, 0);\n-            b1 += k;\n-            l1 -= k;\n-            if l1 != 0 {\n-                let slice = vec::mut_slice(array, b2, b2+l2);\n-                let l2 = gallop_left(\n-                    &const array[b1+l1-1],slice,l2-1);\n-                if l2 > 0 {\n-                    if l1 <= l2 {\n-                        self.merge_lo(array, b1, l1, b2, l2);\n-                    } else {\n-                        self.merge_hi(array, b1, l1, b2, l2);\n-                    }\n+        let slice = vec::mut_slice(array, b1, b1+l1);\n+        let k = gallop_right(&const array[b2], slice, 0);\n+        b1 += k;\n+        l1 -= k;\n+        if l1 != 0 {\n+            let slice = vec::mut_slice(array, b2, b2+l2);\n+            let l2 = gallop_left(\n+                &const array[b1+l1-1],slice,l2-1);\n+            if l2 > 0 {\n+                if l1 <= l2 {\n+                    self.merge_lo(array, b1, l1, b2, l2);\n+                } else {\n+                    self.merge_hi(array, b1, l1, b2, l2);\n                 }\n             }\n         }\n         self.runs.pop();\n     }\n \n-    fn merge_lo(&self, array: &mut [T], base1: uint, len1: uint,\n+    fn merge_lo(&mut self, array: &mut [T], base1: uint, len1: uint,\n                 base2: uint, len2: uint) {\n         fail_unless!(len1 != 0 && len2 != 0 && base1+len1 == base2);\n \n@@ -554,7 +550,7 @@ pub impl<T:Copy + Ord> MergeState<T> {\n         }\n     }\n \n-    fn merge_hi(&self, array: &mut [T], base1: uint, len1: uint,\n+    fn merge_hi(&mut self, array: &mut [T], base1: uint, len1: uint,\n                 base2: uint, len2: uint) {\n         fail_unless!(len1 != 1 && len2 != 0 && base1 + len1 == base2);\n \n@@ -672,32 +668,28 @@ pub impl<T:Copy + Ord> MergeState<T> {\n         }\n     }\n \n-    fn merge_collapse(&self, array: &mut [T]) {\n+    fn merge_collapse(&mut self, array: &mut [T]) {\n         while self.runs.len() > 1 {\n             let mut n = self.runs.len()-2;\n-            let chk = do self.runs.borrow |arr| {\n-                if n > 0 && arr[n-1].len <= arr[n].len + arr[n+1].len {\n-                    if arr[n-1].len < arr[n+1].len { n -= 1; }\n-                    true\n-                } else if arr[n].len <= arr[n+1].len {\n-                    true\n-                } else {\n-                    false\n-                }\n-            };\n-            if !chk { break; }\n+            if n > 0 &&\n+                self.runs[n-1].len <= self.runs[n].len + self.runs[n+1].len\n+            {\n+                if self.runs[n-1].len < self.runs[n+1].len { n -= 1; }\n+            } else if self.runs[n].len <= self.runs[n+1].len {\n+                /* keep going */\n+            } else {\n+                break;\n+            }\n             self.merge_at(n, array);\n         }\n     }\n \n-    fn merge_force_collapse(&self, array: &mut [T]) {\n+    fn merge_force_collapse(&mut self, array: &mut [T]) {\n         while self.runs.len() > 1 {\n             let mut n = self.runs.len()-2;\n             if n > 0 {\n-                do self.runs.borrow |arr| {\n-                    if arr[n-1].len < arr[n+1].len {\n-                        n -= 1;\n-                    }\n+                if self.runs[n-1].len < self.runs[n+1].len {\n+                    n -= 1;\n                 }\n             }\n             self.merge_at(n, array);"}, {"sha": "3397ca91c9624f6d6e05fc310d771015141a063c", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -24,7 +24,6 @@ source code snippets, etc.\n use core::prelude::*;\n \n use core::cmp;\n-use core::dvec::DVec;\n use core::str;\n use core::to_bytes;\n use core::uint;\n@@ -242,7 +241,7 @@ pub struct FileMap {\n     /// Locations of lines beginnings in the source code\n     lines: @mut ~[BytePos],\n     /// Locations of multi-byte characters in the source code\n-    multibyte_chars: DVec<MultiByteChar>\n+    multibyte_chars: @mut ~[MultiByteChar],\n }\n \n pub impl FileMap {\n@@ -282,13 +281,13 @@ pub impl FileMap {\n }\n \n pub struct CodeMap {\n-    files: DVec<@FileMap>\n+    files: @mut ~[@FileMap]\n }\n \n pub impl CodeMap {\n     static pub fn new() -> CodeMap {\n         CodeMap {\n-            files: DVec()\n+            files: @mut ~[],\n         }\n     }\n \n@@ -315,7 +314,7 @@ pub impl CodeMap {\n             name: filename, substr: substr, src: src,\n             start_pos: BytePos(start_pos),\n             lines: @mut ~[],\n-            multibyte_chars: DVec()\n+            multibyte_chars: @mut ~[],\n         };\n \n         self.files.push(filemap);"}, {"sha": "33e734fbd64ccea14eabffd06c17a02f99850521", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -18,7 +18,6 @@ use core::io;\n use core::option;\n use core::str;\n use core::vec;\n-use core::dvec::DVec;\n \n use std::term;\n \n@@ -203,7 +202,7 @@ fn print_diagnostic(topic: ~str, lvl: level, msg: &str) {\n     io::stderr().write_str(fmt!(\" %s\\n\", msg));\n }\n \n-pub fn collect(messages: @DVec<~str>)\n+pub fn collect(messages: @mut ~[~str])\n             -> @fn(Option<(@codemap::CodeMap, span)>, &str, level) {\n     let f: @fn(Option<(@codemap::CodeMap, span)>, &str, level) =\n         |_o, msg: &str, _l| { messages.push(msg.to_str()); };"}, {"sha": "a1514bc3eabdb9c0e27da817e3626ab56cf838a9", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -29,7 +29,6 @@ use parse::token::special_idents::clownshoes_extensions;\n use ast_util;\n use opt_vec;\n \n-use core::dvec;\n use core::uint;\n \n enum Junction {\n@@ -99,7 +98,7 @@ fn expand_deriving(cx: ext_ctxt,\n                    expand_deriving_struct_def: ExpandDerivingStructDefFn,\n                    expand_deriving_enum_def: ExpandDerivingEnumDefFn)\n                 -> ~[@item] {\n-    let result = dvec::DVec();\n+    let mut result = ~[];\n     for in_items.each |item| {\n         result.push(copy *item);\n         match item.node {\n@@ -120,7 +119,7 @@ fn expand_deriving(cx: ext_ctxt,\n             _ => ()\n         }\n     }\n-    dvec::unwrap(result)\n+    result\n }\n \n fn create_impl_item(cx: ext_ctxt, span: span, +item: item_) -> @item {\n@@ -202,14 +201,13 @@ fn create_self_type_with_params(cx: ext_ctxt,\n                                 generics: &Generics)\n                              -> @Ty {\n     // Create the type parameters on the `self` path.\n-    let self_ty_params = dvec::DVec();\n+    let mut self_ty_params = ~[];\n     for generics.ty_params.each |ty_param| {\n         let self_ty_param = build::mk_simple_ty_path(cx,\n                                                      span,\n                                                      ty_param.ident);\n         self_ty_params.push(self_ty_param);\n     }\n-    let self_ty_params = dvec::unwrap(self_ty_params);\n \n     // Create the type of `self`.\n     let self_type = build::mk_raw_path_(span,\n@@ -433,7 +431,7 @@ fn create_subpatterns(cx: ext_ctxt,\n                       prefix: ~str,\n                       n: uint)\n                    -> ~[@pat] {\n-    let subpats = dvec::DVec();\n+    let mut subpats = ~[];\n     for uint::range(0, n) |_i| {\n         // Create the subidentifier.\n         let index = subpats.len().to_str();\n@@ -445,7 +443,7 @@ fn create_subpatterns(cx: ext_ctxt,\n         let subpat = build::mk_pat(cx, span, subpat);\n         subpats.push(subpat);\n     }\n-    return dvec::unwrap(subpats);\n+    return subpats;\n }\n \n fn is_struct_tuple(struct_def: &struct_def) -> bool {\n@@ -809,7 +807,7 @@ fn expand_deriving_iter_bytes_struct_method(cx: ext_ctxt,\n     let self_ident = cx.ident_of(~\"self\");\n \n     // Create the body of the method.\n-    let statements = dvec::DVec();\n+    let mut statements = ~[];\n     for struct_def.fields.each |struct_field| {\n         match struct_field.node.kind {\n             named_field(ident, _, _) => {\n@@ -833,7 +831,6 @@ fn expand_deriving_iter_bytes_struct_method(cx: ext_ctxt,\n     }\n \n     // Create the method itself.\n-    let statements = dvec::unwrap(statements);\n     return create_iter_bytes_method(cx, span, statements);\n }\n \n@@ -942,9 +939,9 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n     }\n \n     // Create the arms of the self match in the method body.\n-    let self_arms = dvec::DVec();\n+    let mut self_arms = ~[];\n     for enum_definition.variants.each |self_variant| {\n-        let other_arms = dvec::DVec();\n+        let mut other_arms = ~[];\n \n         // Create the matching pattern.\n         let matching_pat = create_enum_variant_pattern(cx,\n@@ -1026,7 +1023,6 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n         // Create the self pattern body.\n         let other_expr = build::mk_path(cx, span, ~[ other_ident ]);\n         let other_expr = build::mk_unary(cx, span, deref, other_expr);\n-        let other_arms = dvec::unwrap(other_arms);\n         let other_match_expr = expr_match(other_expr, other_arms);\n         let other_match_expr = build::mk_expr(cx,\n                                               span,\n@@ -1047,7 +1043,6 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n     // Create the method body.\n     let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n     let self_expr = build::mk_unary(cx, span, deref, self_expr);\n-    let self_arms = dvec::unwrap(self_arms);\n     let self_match_expr = expr_match(self_expr, self_arms);\n     let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n \n@@ -1148,7 +1143,7 @@ fn expand_deriving_iter_bytes_enum_method(cx: ext_ctxt,\n         }\n \n         // Feed the discriminant to the byte iteration function.\n-        let stmts = dvec::DVec();\n+        let mut stmts = ~[];\n         let discrim_stmt = call_substructure_iter_bytes_method(cx,\n                                                                span,\n                                                                discriminant);\n@@ -1167,7 +1162,6 @@ fn expand_deriving_iter_bytes_enum_method(cx: ext_ctxt,\n         }\n \n         // Create the pattern body.\n-        let stmts = dvec::unwrap(stmts);\n         let match_body_block = build::mk_block_(cx, span, stmts);\n \n         // Create the arm."}, {"sha": "88797a152066a9045e322d4f341242294b49de9a", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -19,8 +19,6 @@ use parse::parser::Parser;\n use parse::token::{Token, EOF, to_str, nonterminal};\n use parse::token;\n \n-use core::dvec::DVec;\n-use core::dvec;\n use core::option::{Option, Some, None};\n use core::str;\n use core::uint;\n@@ -115,7 +113,7 @@ pub struct MatcherPos {\n     sep: Option<Token>,\n     idx: uint,\n     up: matcher_pos_up, // mutable for swapping only\n-    matches: ~[DVec<@named_match>],\n+    matches: ~[~[@named_match]],\n     match_lo: uint, match_hi: uint,\n     sp_lo: BytePos,\n }\n@@ -151,7 +149,7 @@ pub fn initial_matcher_pos(+ms: ~[matcher], +sep: Option<Token>, lo: BytePos)\n           }\n         }\n     }\n-    let matches = vec::from_fn(count_names(ms), |_i| dvec::DVec());\n+    let matches = vec::from_fn(count_names(ms), |_i| ~[]);\n     ~MatcherPos {\n         elts: ms,\n         sep: sep,\n@@ -283,7 +281,7 @@ pub fn parse(\n \n                         // Only touch the binders we have actually bound\n                         for uint::range(ei.match_lo, ei.match_hi) |idx| {\n-                            let sub = ei.matches[idx].get();\n+                            let sub = ei.matches[idx];\n                             new_pos.matches[idx]\n                                 .push(@matched_seq(sub,\n                                                    mk_sp(ei.sp_lo,\n@@ -331,7 +329,7 @@ pub fn parse(\n                     }\n \n                     let matches = vec::map(ei.matches, // fresh, same size:\n-                                           |_m| DVec::<@named_match>());\n+                                           |_m| ~[]);\n                     let ei_t = ei;\n                     cur_eis.push(~MatcherPos {\n                         elts: copy *matchers,\n@@ -358,9 +356,11 @@ pub fn parse(\n         /* error messages here could be improved with links to orig. rules */\n         if tok == EOF {\n             if eof_eis.len() == 1u {\n-                return success(\n-                    nameize(sess, ms,\n-                            eof_eis[0u].matches.map(|dv| dv.pop())));\n+                let mut v = ~[];\n+                for vec::each_mut(eof_eis[0u].matches) |dv| {\n+                    v.push(dv.pop());\n+                }\n+                return success(nameize(sess, ms, v));\n             } else if eof_eis.len() > 1u {\n                 return error(sp, ~\"Ambiguity: multiple successful parses\");\n             } else {"}, {"sha": "a1fc7230dd1f040ed71ee9d5e5251c8b812b956c", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -303,9 +303,9 @@ mod test {\n     use util::testing::*;\n \n     #[test] fn to_json_str (val: Encodable<std::json::Encoder>) -> ~str {\n-        let bw = @io::BytesWriter();\n-        val.encode(~std::json::Encoder(bw as io::Writer));\n-        str::from_bytes(bw.bytes.data)\n+        do io::with_str_writer |writer| {\n+            val.encode(~std::json::Encoder(writer));\n+        }\n     }\n \n     #[test] fn alltts () {"}, {"sha": "c68341c20fa4c273b38f058be092e4ee2213f1b1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -28,7 +28,6 @@ use print::pp;\n use print::pprust;\n \n use core::char;\n-use core::dvec::DVec;\n use core::io;\n use core::str;\n use core::u64;\n@@ -63,7 +62,7 @@ pub struct ps {\n     comments: Option<~[comments::cmnt]>,\n     literals: Option<~[comments::lit]>,\n     cur_cmnt_and_lit: @mut CurrentCommentAndLiteral,\n-    boxes: DVec<pp::breaks>,\n+    boxes: @mut ~[pp::breaks],\n     ann: pp_ann\n }\n \n@@ -88,7 +87,7 @@ pub fn rust_printer(writer: io::Writer, intr: @ident_interner) -> @ps {\n             cur_cmnt: 0,\n             cur_lit: 0\n         },\n-        boxes: DVec(),\n+        boxes: @mut ~[],\n         ann: no_ann()\n     };\n }\n@@ -123,7 +122,7 @@ pub fn print_crate(cm: @CodeMap, intr: @ident_interner,\n             cur_cmnt: 0,\n             cur_lit: 0\n         },\n-        boxes: DVec(),\n+        boxes: @mut ~[],\n         ann: ann\n     };\n     print_crate_(s, crate);"}, {"sha": "7a5708049e9f400bc63a84672baf7ccde58e0f3a", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -13,20 +13,19 @@\n // type, and vice versa.\n \n use core::prelude::*;\n-use core::dvec::DVec;\n use core::hashmap::linear::LinearMap;\n \n pub struct Interner<T> {\n     priv map: @mut LinearMap<T, uint>,\n-    priv vect: DVec<T>,\n+    priv vect: @mut ~[T],\n }\n \n // when traits can extend traits, we should extend index<uint,T> to get []\n pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n     static fn new() -> Interner<T> {\n         Interner {\n             map: @mut LinearMap::new(),\n-            vect: DVec(),\n+            vect: @mut ~[],\n         }\n     }\n \n@@ -58,7 +57,7 @@ pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n     // this isn't \"pure\" in the traditional sense, because it can go from\n     // failing to returning a value as items are interned. But for typestate,\n     // where we first check a pred and then rely on it, ceasing to fail is ok.\n-    pure fn get(&self, idx: uint) -> T { self.vect.get_elt(idx) }\n+    pure fn get(&self, idx: uint) -> T { self.vect[idx] }\n \n     fn len(&self) -> uint { self.vect.len() }\n }"}, {"sha": "ab9dc29441a96914315c83aabd04e5b926ce3c2b", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -10,11 +10,9 @@\n \n #[legacy_modes];\n \n-use core::dvec::DVec;\n-\n pub struct Entry<A,B> {key: A, value: B}\n \n-pub struct alist<A,B> { eq_fn: @fn(A,A) -> bool, data: DVec<Entry<A,B>> }\n+pub struct alist<A,B> { eq_fn: @fn(A,A) -> bool, data: @mut ~[Entry<A,B>] }\n \n pub fn alist_add<A:Copy,B:Copy>(lst: alist<A,B>, k: A, v: B) {\n     lst.data.push(Entry{key:k, value:v});\n@@ -31,12 +29,12 @@ pub fn alist_get<A:Copy,B:Copy>(lst: alist<A,B>, k: A) -> B {\n #[inline]\n pub fn new_int_alist<B:Copy>() -> alist<int, B> {\n     fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n-    return alist {eq_fn: eq_int, data: DVec()};\n+    return alist {eq_fn: eq_int, data: @mut ~[]};\n }\n \n #[inline]\n pub fn new_int_alist_2<B:Copy>() -> alist<int, B> {\n     #[inline]\n     fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n-    return alist {eq_fn: eq_int, data: DVec()};\n+    return alist {eq_fn: eq_int, data: @mut ~[]};\n }"}, {"sha": "f7788c7d57aeb17e5958c866e21b780c07d8c28f", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -13,10 +13,9 @@\n \n extern mod std;\n \n-use core::dvec::*;\n use std::oldmap::HashMap;\n \n-pub type header_map = HashMap<~str, @DVec<@~str>>;\n+pub type header_map = HashMap<~str, @mut ~[@~str]>;\n \n // the unused ty param is necessary so this gets monomorphized\n pub fn request<T:Copy>(req: header_map) {"}, {"sha": "4117add8926a0cda2058a8babc0917fe4c91d148", "filename": "src/test/bench/core-vec-append.rs", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-vec-append.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -1,76 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// A raw test of vector appending performance.\n-\n-extern mod std;\n-use core::dvec::DVec;\n-use core::io::WriterUtil;\n-\n-fn collect_raw(num: uint) -> ~[uint] {\n-    let mut result = ~[];\n-    for uint::range(0u, num) |i| {\n-        result.push(i);\n-    }\n-    return result;\n-}\n-\n-fn collect_dvec(num: uint) -> ~[uint] {\n-    let result = DVec();\n-    for uint::range(0u, num) |i| {\n-        result.push(i);\n-    }\n-    return dvec::unwrap(result);\n-}\n-\n-fn main() {\n-    let args = os::args();\n-    let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n-        ~[~\"\", ~\"50000000\"]\n-    } else if args.len() <= 1u {\n-        ~[~\"\", ~\"100000\"]\n-    } else {\n-        args\n-    };\n-    let max = uint::from_str(args[1]).get();\n-    let start = std::time::precise_time_s();\n-    let raw_v = collect_raw(max);\n-    let mid = std::time::precise_time_s();\n-    let dvec_v = collect_dvec(max);\n-    let end = std::time::precise_time_s();\n-\n-    // check each vector\n-    fail_unless!(raw_v.len() == max);\n-    for raw_v.eachi |i, v| { fail_unless!(i == *v); }\n-    fail_unless!(dvec_v.len() == max);\n-    for dvec_v.eachi |i, v| { fail_unless!(i == *v); }\n-\n-    let raw = mid - start;\n-    let dvec = end - mid;\n-\n-    let maxf = max as float;\n-    let rawf = raw as float;\n-    let dvecf = dvec as float;\n-    \n-    io::stdout().write_str(fmt!(\"Raw     : %? seconds\\n\", raw));\n-    io::stdout().write_str(fmt!(\"        : %f op/sec\\n\", maxf/rawf));\n-    io::stdout().write_str(fmt!(\"\\n\"));\n-    io::stdout().write_str(fmt!(\"Dvec    : %? seconds\\n\", dvec));\n-    io::stdout().write_str(fmt!(\"        : %f op/sec\\n\", maxf/dvecf));\n-    io::stdout().write_str(fmt!(\"\\n\"));\n-    \n-    if dvec < raw {\n-        io::stdout().write_str(fmt!(\"Dvec is %f%% faster than raw\\n\",\n-                                    (rawf - dvecf) / rawf * 100.0));\n-    } else {\n-        io::stdout().write_str(fmt!(\"Raw is %f%% faster than dvec\\n\",\n-                                    (dvecf - rawf) / dvecf * 100.0));\n-    }\n-}"}, {"sha": "5f26adfcdc770d5c2b12d15d6bfe2b01b0d4eae5", "filename": "src/test/compile-fail/issue-2590.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::dvec::DVec;\n-\n struct parser {\n-    tokens: DVec<int>,\n+    tokens: ~[int],\n }\n \n trait parse {\n@@ -20,7 +18,7 @@ trait parse {\n \n impl parse for parser {\n     fn parse() -> ~[int] {\n-        ::core::dvec::unwrap(self.tokens) //~ ERROR moving out of immutable field\n+        self.tokens //~ ERROR moving out of immutable field\n     }\n }\n "}, {"sha": "39864059fcd4802129bbc9ac743063b20c483a50", "filename": "src/test/run-pass/call-closure-from-overloaded-op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Ftest%2Frun-pass%2Fcall-closure-from-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Ftest%2Frun-pass%2Fcall-closure-from-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcall-closure-from-overloaded-op.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -11,7 +11,7 @@\n fn foo() -> int { 22 }\n \n pub fn main() {\n-    let x = dvec::DVec::<@fn() -> int>();\n+    let mut x: ~[@fn() -> int] = ~[];\n     x.push(foo);\n     fail_unless!((x[0])() == 22);\n }"}, {"sha": "e061464c7b2b68f7efe9cde0c1c2f696ad5f9422", "filename": "src/test/run-pass/dvec-index-op.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Frun-pass%2Fdvec-index-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Frun-pass%2Fdvec-index-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdvec-index-op.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn main() {\n-    let x = dvec::DVec();\n-    x.push(1);\n-    io::println(fmt!(\"%d\", x[0]));\n-}\n-"}, {"sha": "dff37af9a593663aed6691adaff7c816437c294e", "filename": "src/test/run-pass/dvec-test.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Frun-pass%2Fdvec-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647a94d01a54a75e08fd1b6fa74761f70874bafe/src%2Ftest%2Frun-pass%2Fdvec-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdvec-test.rs?ref=647a94d01a54a75e08fd1b6fa74761f70874bafe", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn main() {\n-    let d = dvec::DVec();\n-    d.push(3);\n-    d.push(4);\n-    fail_unless!(d.get() == ~[3, 4]);\n-    d.set(~[5]);\n-    d.push(6);\n-    d.push(7);\n-    d.push(8);\n-    d.push(9);\n-    d.push(10);\n-    d.push_all(~[11, 12, 13]);\n-    d.push_slice(~[11, 12, 13], 1u, 2u);\n-\n-    let exp = ~[5, 6, 7, 8, 9, 10, 11, 12, 13, 12];\n-    fail_unless!(d.get() == exp);\n-    fail_unless!(d.get() == exp);\n-    fail_unless!(d.len() == exp.len());\n-\n-    for d.eachi |i, e| {\n-        fail_unless!(*e == exp[i]);\n-    }\n-\n-    let v = dvec::unwrap(d);\n-    fail_unless!(v == exp);\n-}"}, {"sha": "5f5e2f9fc308411aeb0ac343bef4abd54daed244", "filename": "src/test/run-pass/issue-2631-b.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbcac322669cff3abde5be937cc4ec3860f3985/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs?ref=3bbcac322669cff3abde5be937cc4ec3860f3985", "patch": "@@ -15,12 +15,11 @@ extern mod req;\n extern mod std;\n \n use req::*;\n-use std::oldmap::*;\n use std::oldmap::HashMap;\n \n pub fn main() {\n   let v = ~[@~\"hi\"];\n   let m: req::header_map = HashMap();\n-  m.insert(~\"METHOD\", @dvec::from_vec(v));\n+  m.insert(~\"METHOD\", @mut v);\n   request::<int>(m);\n }"}]}