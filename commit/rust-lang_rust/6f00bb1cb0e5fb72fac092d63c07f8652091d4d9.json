{"sha": "6f00bb1cb0e5fb72fac092d63c07f8652091d4d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmMDBiYjFjYjBlNWZiNzJmYWMwOTJkNjNjMDdmODY1MjA5MWQ0ZDk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-25T08:49:38Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-25T08:49:38Z"}, "message": "introduce SingleFileChange", "tree": {"sha": "e001a5ca6beb12dd41cc046fbec88f872f3ce036", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e001a5ca6beb12dd41cc046fbec88f872f3ce036"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f00bb1cb0e5fb72fac092d63c07f8652091d4d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f00bb1cb0e5fb72fac092d63c07f8652091d4d9", "html_url": "https://github.com/rust-lang/rust/commit/6f00bb1cb0e5fb72fac092d63c07f8652091d4d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f00bb1cb0e5fb72fac092d63c07f8652091d4d9/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b112430ca73f646b6cb779ab09a3f691aad22442", "url": "https://api.github.com/repos/rust-lang/rust/commits/b112430ca73f646b6cb779ab09a3f691aad22442", "html_url": "https://github.com/rust-lang/rust/commit/b112430ca73f646b6cb779ab09a3f691aad22442"}], "stats": {"total": 99, "additions": 64, "deletions": 35}, "files": [{"sha": "4e63bbf6f0c891c7e259cb61d3e11c83867fa8da", "filename": "crates/ra_ide_api/src/source_change.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6f00bb1cb0e5fb72fac092d63c07f8652091d4d9/crates%2Fra_ide_api%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f00bb1cb0e5fb72fac092d63c07f8652091d4d9/crates%2Fra_ide_api%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsource_change.rs?ref=6f00bb1cb0e5fb72fac092d63c07f8652091d4d9", "patch": "@@ -6,7 +6,7 @@\n use ra_text_edit::TextEdit;\n use relative_path::RelativePathBuf;\n \n-use crate::{FileId, FilePosition, SourceRootId};\n+use crate::{FileId, FilePosition, SourceRootId, TextUnit};\n \n #[derive(Debug)]\n pub struct SourceChange {\n@@ -100,3 +100,20 @@ pub enum FileSystemEdit {\n     CreateFile { source_root: SourceRootId, path: RelativePathBuf },\n     MoveFile { src: FileId, dst_source_root: SourceRootId, dst_path: RelativePathBuf },\n }\n+\n+pub(crate) struct SingleFileChange {\n+    pub label: String,\n+    pub edit: TextEdit,\n+    pub cursor_position: Option<TextUnit>,\n+}\n+\n+impl SingleFileChange {\n+    pub(crate) fn into_source_change(self, file_id: FileId) -> SourceChange {\n+        SourceChange {\n+            label: self.label,\n+            source_file_edits: vec![SourceFileEdit { file_id, edit: self.edit }],\n+            file_system_edits: Vec::new(),\n+            cursor_position: self.cursor_position.map(|offset| FilePosition { file_id, offset }),\n+        }\n+    }\n+}"}, {"sha": "c5ec6c1c184fd52e2dfb55ec5730cdc0ea29151e", "filename": "crates/ra_ide_api/src/typing.rs", "status": "modified", "additions": 28, "deletions": 34, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6f00bb1cb0e5fb72fac092d63c07f8652091d4d9/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f00bb1cb0e5fb72fac092d63c07f8652091d4d9/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Ftyping.rs?ref=6f00bb1cb0e5fb72fac092d63c07f8652091d4d9", "patch": "@@ -24,7 +24,7 @@ use ra_syntax::{\n };\n use ra_text_edit::{TextEdit, TextEditBuilder};\n \n-use crate::{db::RootDatabase, SourceChange, SourceFileEdit};\n+use crate::{db::RootDatabase, source_change::SingleFileChange, SourceChange, SourceFileEdit};\n \n pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<SourceChange> {\n     let parse = db.parse(position.file_id);\n@@ -88,32 +88,19 @@ pub(crate) fn on_char_typed(\n ) -> Option<SourceChange> {\n     let file = &db.parse(position.file_id).tree();\n     assert_eq!(file.syntax().text().char_at(position.offset), Some(char_typed));\n-    match char_typed {\n-        '=' => {\n-            let edit = on_eq_typed(file, position.offset)?;\n-            Some(SourceChange::source_file_edit(\n-                \"add semicolon\",\n-                SourceFileEdit { edit, file_id: position.file_id },\n-            ))\n-        }\n-        '.' => {\n-            let (edit, cursor_offset) = on_dot_typed(file, position.offset)?;\n-            Some(\n-                SourceChange::source_file_edit(\n-                    \"reindent dot\",\n-                    SourceFileEdit { edit, file_id: position.file_id },\n-                )\n-                .with_cursor(FilePosition { file_id: position.file_id, offset: cursor_offset }),\n-            )\n-        }\n-        _ => None,\n-    }\n+    let single_file_change = match char_typed {\n+        '=' => on_eq_typed(file, position.offset)?,\n+        '.' => on_dot_typed(file, position.offset)?,\n+        _ => return None,\n+    };\n+\n+    Some(single_file_change.into_source_change(position.file_id))\n }\n \n /// Returns an edit which should be applied after `=` was typed. Primarily,\n /// this works when adding `let =`.\n // FIXME: use a snippet completion instead of this hack here.\n-fn on_eq_typed(file: &SourceFile, offset: TextUnit) -> Option<TextEdit> {\n+fn on_eq_typed(file: &SourceFile, offset: TextUnit) -> Option<SingleFileChange> {\n     assert_eq!(file.syntax().text().char_at(offset), Some('='));\n     let let_stmt: ast::LetStmt = find_node_at_offset(file.syntax(), offset)?;\n     if let_stmt.has_semi() {\n@@ -131,13 +118,15 @@ fn on_eq_typed(file: &SourceFile, offset: TextUnit) -> Option<TextEdit> {\n         return None;\n     }\n     let offset = let_stmt.syntax().text_range().end();\n-    let mut edit = TextEditBuilder::default();\n-    edit.insert(offset, \";\".to_string());\n-    Some(edit.finish())\n+    Some(SingleFileChange {\n+        label: \"add semicolon\".to_string(),\n+        edit: TextEdit::insert(offset, \";\".to_string()),\n+        cursor_position: None,\n+    })\n }\n \n /// Returns an edit which should be applied when a dot ('.') is typed on a blank line, indenting the line appropriately.\n-fn on_dot_typed(file: &SourceFile, offset: TextUnit) -> Option<(TextEdit, TextUnit)> {\n+fn on_dot_typed(file: &SourceFile, offset: TextUnit) -> Option<SingleFileChange> {\n     assert_eq!(file.syntax().text().char_at(offset), Some('.'));\n     let whitespace =\n         file.syntax().token_at_offset(offset).left_biased().and_then(ast::Whitespace::cast)?;\n@@ -157,12 +146,17 @@ fn on_dot_typed(file: &SourceFile, offset: TextUnit) -> Option<(TextEdit, TextUn\n     if current_indent_len == target_indent_len {\n         return None;\n     }\n-    let mut edit = TextEditBuilder::default();\n-    edit.replace(TextRange::from_to(offset - current_indent_len, offset), target_indent);\n-\n-    let cursor_offset = offset + target_indent_len - current_indent_len + TextUnit::of_char('.');\n \n-    Some((edit.finish(), cursor_offset))\n+    Some(SingleFileChange {\n+        label: \"reindent dot\".to_string(),\n+        edit: TextEdit::replace(\n+            TextRange::from_to(offset - current_indent_len, offset),\n+            target_indent,\n+        ),\n+        cursor_position: Some(\n+            offset + target_indent_len - current_indent_len + TextUnit::of_char('.'),\n+        ),\n+    })\n }\n \n #[cfg(test)]\n@@ -182,7 +176,7 @@ mod tests {\n             let before = edit.finish().apply(&before);\n             let parse = SourceFile::parse(&before);\n             if let Some(result) = on_eq_typed(&parse.tree(), offset) {\n-                let actual = result.apply(&before);\n+                let actual = result.edit.apply(&before);\n                 assert_eq_text!(after, &actual);\n             } else {\n                 assert_eq_text!(&before, after)\n@@ -230,8 +224,8 @@ fn foo() {\n         let before = edit.finish().apply(&before);\n         let (analysis, file_id) = single_file(&before);\n         let file = analysis.parse(file_id).unwrap();\n-        if let Some((edit, _cursor_offset)) = on_dot_typed(&file, offset) {\n-            let actual = edit.apply(&before);\n+        if let Some(result) = on_dot_typed(&file, offset) {\n+            let actual = result.edit.apply(&before);\n             assert_eq_text!(after, &actual);\n         } else {\n             assert_eq_text!(&before, after)"}, {"sha": "413c7d782eb588464a778ce177346fae87f12fc1", "filename": "crates/ra_text_edit/src/text_edit.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6f00bb1cb0e5fb72fac092d63c07f8652091d4d9/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f00bb1cb0e5fb72fac092d63c07f8652091d4d9/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs?ref=6f00bb1cb0e5fb72fac092d63c07f8652091d4d9", "patch": "@@ -32,6 +32,24 @@ impl TextEditBuilder {\n }\n \n impl TextEdit {\n+    pub fn insert(offset: TextUnit, text: String) -> TextEdit {\n+        let mut builder = TextEditBuilder::default();\n+        builder.insert(offset, text);\n+        builder.finish()\n+    }\n+\n+    pub fn delete(range: TextRange) -> TextEdit {\n+        let mut builder = TextEditBuilder::default();\n+        builder.delete(range);\n+        builder.finish()\n+    }\n+\n+    pub fn replace(range: TextRange, replace_with: String) -> TextEdit {\n+        let mut builder = TextEditBuilder::default();\n+        builder.replace(range, replace_with);\n+        builder.finish()\n+    }\n+\n     pub(crate) fn from_atoms(mut atoms: Vec<AtomTextEdit>) -> TextEdit {\n         atoms.sort_by_key(|a| (a.delete.start(), a.delete.end()));\n         for (a1, a2) in atoms.iter().zip(atoms.iter().skip(1)) {"}]}