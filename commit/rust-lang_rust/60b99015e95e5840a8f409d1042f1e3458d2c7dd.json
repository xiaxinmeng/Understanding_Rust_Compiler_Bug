{"sha": "60b99015e95e5840a8f409d1042f1e3458d2c7dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwYjk5MDE1ZTk1ZTU4NDBhOGY0MDlkMTA0MmYxZTM0NThkMmM3ZGQ=", "commit": {"author": {"name": "ecstatic-morse", "email": "ecstaticmorse@gmail.com", "date": "2020-09-22T03:40:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-22T03:40:53Z"}, "message": "Rollup merge of #76807 - ecstatic-morse:const-checking-staged-api, r=oli-obk\n\nUse const-checking to forbid use of unstable features in const-stable functions\n\nFirst step towards #76618.\n\nCurrently this code isn't ever hit because `qualify_min_const_fn` runs first and catches pretty much everything. One exception is `const_precise_live_drops`, which does not use the newly added code since it runs as part of a separate pass.\n\nAlso contains some unrelated refactoring, which is split into separate commits.\n\nr? @oli-obk", "tree": {"sha": "10f057001298389a6f56fba2b8e0d4e014004756", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10f057001298389a6f56fba2b8e0d4e014004756"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60b99015e95e5840a8f409d1042f1e3458d2c7dd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfaXJGCRBK7hj4Ov3rIwAAdHIIAFwl3bw5Q5ybkLmrbjDl08GX\nHDxZZXA9qzoDIS+op79rAQvYOQcdEcwK9glPkYvJnpHtAVV+1qg1QT/L6du7Xkcb\nKAF4Gm3lzQEAcWYsaCASp8Wu9W2mcFkk9LxVXbPHX/jdn3YrK3cd9AtuhPFq5DOu\nUoWOyz4kMfmbDLoUNRblCUHQfPpdJVfghBHzPY/1vlCxNBYs2dAjTx/SSC5dl98n\ntDlHVrwJFZzLneH1zU4LFBXTtgQxiH8zJ7qipbFAYLzR/66rRAIWp/yOgYShZcoq\nCRZ/BtWJgGoACMeuQnS0jq+NKMkwQUmYJF+dQkR4RFprNkamn6tqZbHTClEYl5c=\n=Dzjm\n-----END PGP SIGNATURE-----\n", "payload": "tree 10f057001298389a6f56fba2b8e0d4e014004756\nparent b3433c7cc9811639ca2cb137da146222cc8bde55\nparent abc71677da866fd36c70790e768f36d2f809c493\nauthor ecstatic-morse <ecstaticmorse@gmail.com> 1600746053 -0700\ncommitter GitHub <noreply@github.com> 1600746053 -0700\n\nRollup merge of #76807 - ecstatic-morse:const-checking-staged-api, r=oli-obk\n\nUse const-checking to forbid use of unstable features in const-stable functions\n\nFirst step towards #76618.\n\nCurrently this code isn't ever hit because `qualify_min_const_fn` runs first and catches pretty much everything. One exception is `const_precise_live_drops`, which does not use the newly added code since it runs as part of a separate pass.\n\nAlso contains some unrelated refactoring, which is split into separate commits.\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60b99015e95e5840a8f409d1042f1e3458d2c7dd", "html_url": "https://github.com/rust-lang/rust/commit/60b99015e95e5840a8f409d1042f1e3458d2c7dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60b99015e95e5840a8f409d1042f1e3458d2c7dd/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3433c7cc9811639ca2cb137da146222cc8bde55", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3433c7cc9811639ca2cb137da146222cc8bde55", "html_url": "https://github.com/rust-lang/rust/commit/b3433c7cc9811639ca2cb137da146222cc8bde55"}, {"sha": "abc71677da866fd36c70790e768f36d2f809c493", "url": "https://api.github.com/repos/rust-lang/rust/commits/abc71677da866fd36c70790e768f36d2f809c493", "html_url": "https://github.com/rust-lang/rust/commit/abc71677da866fd36c70790e768f36d2f809c493"}], "stats": {"total": 243, "additions": 172, "deletions": 71}, "files": [{"sha": "c1b4cb5f1a8d54f7ab4ec4be441e3c5c8414a577", "filename": "compiler/rustc_mir/src/transform/check_consts/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60b99015e95e5840a8f409d1042f1e3458d2c7dd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60b99015e95e5840a8f409d1042f1e3458d2c7dd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=60b99015e95e5840a8f409d1042f1e3458d2c7dd", "patch": "@@ -4,10 +4,12 @@\n //! has interior mutability or needs to be dropped, as well as the visitor that emits errors when\n //! it finds operations that are invalid in a certain context.\n \n+use rustc_attr as attr;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::mir;\n use rustc_middle::ty::{self, TyCtxt};\n+use rustc_span::Symbol;\n \n pub use self::qualifs::Qualif;\n \n@@ -55,3 +57,9 @@ impl ConstCx<'mir, 'tcx> {\n pub fn is_lang_panic_fn(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n     Some(def_id) == tcx.lang_items().panic_fn() || Some(def_id) == tcx.lang_items().begin_panic_fn()\n }\n+\n+pub fn allow_internal_unstable(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbol) -> bool {\n+    let attrs = tcx.get_attrs(def_id);\n+    attr::allow_internal_unstable(&tcx.sess, attrs)\n+        .map_or(false, |mut features| features.any(|name| name == feature_gate))\n+}"}, {"sha": "032cbc23a3f52d8c552224d289443ca767011854", "filename": "compiler/rustc_mir/src/transform/check_consts/ops.rs", "status": "modified", "additions": 88, "deletions": 54, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/60b99015e95e5840a8f409d1042f1e3458d2c7dd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60b99015e95e5840a8f409d1042f1e3458d2c7dd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=60b99015e95e5840a8f409d1042f1e3458d2c7dd", "patch": "@@ -1,6 +1,6 @@\n //! Concrete error types for all operations which may be invalid in a certain const context.\n \n-use rustc_errors::struct_span_err;\n+use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_session::config::nightly_options;\n@@ -14,35 +14,54 @@ use super::ConstCx;\n pub fn non_const<O: NonConstOp>(ccx: &ConstCx<'_, '_>, op: O, span: Span) {\n     debug!(\"illegal_op: op={:?}\", op);\n \n-    if op.is_allowed_in_item(ccx) {\n-        return;\n-    }\n+    let gate = match op.status_in_item(ccx) {\n+        Status::Allowed => return,\n+\n+        Status::Unstable(gate) if ccx.tcx.features().enabled(gate) => {\n+            let unstable_in_stable = ccx.const_kind() == hir::ConstContext::ConstFn\n+                && ccx.tcx.features().enabled(sym::staged_api)\n+                && !ccx.tcx.has_attr(ccx.def_id.to_def_id(), sym::rustc_const_unstable)\n+                && !super::allow_internal_unstable(ccx.tcx, ccx.def_id.to_def_id(), gate);\n+\n+            if unstable_in_stable {\n+                ccx.tcx.sess\n+                    .struct_span_err(span, &format!(\"`#[feature({})]` cannot be depended on in a const-stable function\", gate.as_str()))\n+                    .span_suggestion(\n+                        ccx.body.span,\n+                        \"if it is not part of the public API, make this function unstably const\",\n+                        concat!(r#\"#[rustc_const_unstable(feature = \"...\", issue = \"...\")]\"#, '\\n').to_owned(),\n+                        Applicability::HasPlaceholders,\n+                    )\n+                    .help(\"otherwise `#[allow_internal_unstable]` can be used to bypass stability checks\")\n+                    .emit();\n+            }\n+\n+            return;\n+        }\n+\n+        Status::Unstable(gate) => Some(gate),\n+        Status::Forbidden => None,\n+    };\n \n     if ccx.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-        ccx.tcx.sess.miri_unleashed_feature(span, O::feature_gate());\n+        ccx.tcx.sess.miri_unleashed_feature(span, gate);\n         return;\n     }\n \n     op.emit_error(ccx, span);\n }\n \n+pub enum Status {\n+    Allowed,\n+    Unstable(Symbol),\n+    Forbidden,\n+}\n+\n /// An operation that is not *always* allowed in a const context.\n pub trait NonConstOp: std::fmt::Debug {\n-    /// Returns the `Symbol` corresponding to the feature gate that would enable this operation,\n-    /// or `None` if such a feature gate does not exist.\n-    fn feature_gate() -> Option<Symbol> {\n-        None\n-    }\n-\n-    /// Returns `true` if this operation is allowed in the given item.\n-    ///\n-    /// This check should assume that we are not in a non-const `fn`, where all operations are\n-    /// legal.\n-    ///\n-    /// By default, it returns `true` if and only if this operation has a corresponding feature\n-    /// gate and that gate is enabled.\n-    fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n-        Self::feature_gate().map_or(false, |gate| ccx.tcx.features().enabled(gate))\n+    /// Returns an enum indicating whether this operation is allowed within the given item.\n+    fn status_in_item(&self, _ccx: &ConstCx<'_, '_>) -> Status {\n+        Status::Forbidden\n     }\n \n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n@@ -53,9 +72,13 @@ pub trait NonConstOp: std::fmt::Debug {\n             \"{} contains unimplemented expression type\",\n             ccx.const_kind()\n         );\n-        if let Some(feat) = Self::feature_gate() {\n-            err.help(&format!(\"add `#![feature({})]` to the crate attributes to enable\", feat));\n+\n+        if let Status::Unstable(gate) = self.status_in_item(ccx) {\n+            if !ccx.tcx.features().enabled(gate) && nightly_options::is_nightly_build() {\n+                err.help(&format!(\"add `#![feature({})]` to the crate attributes to enable\", gate));\n+            }\n         }\n+\n         if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"A function call isn't allowed in the const's initialization expression \\\n@@ -147,7 +170,9 @@ pub struct InlineAsm;\n impl NonConstOp for InlineAsm {}\n \n #[derive(Debug)]\n-pub struct LiveDrop(pub Option<Span>);\n+pub struct LiveDrop {\n+    pub dropped_at: Option<Span>,\n+}\n impl NonConstOp for LiveDrop {\n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let mut diagnostic = struct_span_err!(\n@@ -157,7 +182,7 @@ impl NonConstOp for LiveDrop {\n             \"destructors cannot be evaluated at compile-time\"\n         );\n         diagnostic.span_label(span, format!(\"{}s cannot evaluate destructors\", ccx.const_kind()));\n-        if let Some(span) = self.0 {\n+        if let Some(span) = self.dropped_at {\n             diagnostic.span_label(span, \"value is dropped here\");\n         }\n         diagnostic.emit();\n@@ -182,14 +207,13 @@ impl NonConstOp for CellBorrow {\n #[derive(Debug)]\n pub struct MutBorrow;\n impl NonConstOp for MutBorrow {\n-    fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n-        // Forbid everywhere except in const fn\n-        ccx.const_kind() == hir::ConstContext::ConstFn\n-            && ccx.tcx.features().enabled(Self::feature_gate().unwrap())\n-    }\n-\n-    fn feature_gate() -> Option<Symbol> {\n-        Some(sym::const_mut_refs)\n+    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        // Forbid everywhere except in const fn with a feature gate\n+        if ccx.const_kind() == hir::ConstContext::ConstFn {\n+            Status::Unstable(sym::const_mut_refs)\n+        } else {\n+            Status::Forbidden\n+        }\n     }\n \n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n@@ -201,15 +225,16 @@ impl NonConstOp for MutBorrow {\n                 &format!(\"mutable references are not allowed in {}s\", ccx.const_kind()),\n             )\n         } else {\n-            struct_span_err!(\n+            let mut err = struct_span_err!(\n                 ccx.tcx.sess,\n                 span,\n                 E0764,\n                 \"mutable references are not allowed in {}s\",\n                 ccx.const_kind(),\n-            )\n+            );\n+            err.span_label(span, format!(\"`&mut` is only allowed in `const fn`\"));\n+            err\n         };\n-        err.span_label(span, \"`&mut` is only allowed in `const fn`\".to_string());\n         if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"References in statics and constants may only refer \\\n@@ -226,11 +251,17 @@ impl NonConstOp for MutBorrow {\n     }\n }\n \n+// FIXME(ecstaticmorse): Unify this with `MutBorrow`. It has basically the same issues.\n #[derive(Debug)]\n pub struct MutAddressOf;\n impl NonConstOp for MutAddressOf {\n-    fn feature_gate() -> Option<Symbol> {\n-        Some(sym::const_mut_refs)\n+    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        // Forbid everywhere except in const fn with a feature gate\n+        if ccx.const_kind() == hir::ConstContext::ConstFn {\n+            Status::Unstable(sym::const_mut_refs)\n+        } else {\n+            Status::Forbidden\n+        }\n     }\n \n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n@@ -247,16 +278,16 @@ impl NonConstOp for MutAddressOf {\n #[derive(Debug)]\n pub struct MutDeref;\n impl NonConstOp for MutDeref {\n-    fn feature_gate() -> Option<Symbol> {\n-        Some(sym::const_mut_refs)\n+    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+        Status::Unstable(sym::const_mut_refs)\n     }\n }\n \n #[derive(Debug)]\n pub struct Panic;\n impl NonConstOp for Panic {\n-    fn feature_gate() -> Option<Symbol> {\n-        Some(sym::const_panic)\n+    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+        Status::Unstable(sym::const_panic)\n     }\n \n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n@@ -289,8 +320,8 @@ impl NonConstOp for RawPtrComparison {\n #[derive(Debug)]\n pub struct RawPtrDeref;\n impl NonConstOp for RawPtrDeref {\n-    fn feature_gate() -> Option<Symbol> {\n-        Some(sym::const_raw_ptr_deref)\n+    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+        Status::Unstable(sym::const_raw_ptr_deref)\n     }\n \n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n@@ -307,8 +338,8 @@ impl NonConstOp for RawPtrDeref {\n #[derive(Debug)]\n pub struct RawPtrToIntCast;\n impl NonConstOp for RawPtrToIntCast {\n-    fn feature_gate() -> Option<Symbol> {\n-        Some(sym::const_raw_ptr_to_usize_cast)\n+    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+        Status::Unstable(sym::const_raw_ptr_to_usize_cast)\n     }\n \n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n@@ -326,8 +357,12 @@ impl NonConstOp for RawPtrToIntCast {\n #[derive(Debug)]\n pub struct StaticAccess;\n impl NonConstOp for StaticAccess {\n-    fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n-        matches!(ccx.const_kind(), hir::ConstContext::Static(_))\n+    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        if let hir::ConstContext::Static(_) = ccx.const_kind() {\n+            Status::Allowed\n+        } else {\n+            Status::Forbidden\n+        }\n     }\n \n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n@@ -371,14 +406,13 @@ impl NonConstOp for ThreadLocalAccess {\n #[derive(Debug)]\n pub struct UnionAccess;\n impl NonConstOp for UnionAccess {\n-    fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n+    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n         // Union accesses are stable in all contexts except `const fn`.\n-        ccx.const_kind() != hir::ConstContext::ConstFn\n-            || ccx.tcx.features().enabled(Self::feature_gate().unwrap())\n-    }\n-\n-    fn feature_gate() -> Option<Symbol> {\n-        Some(sym::const_fn_union)\n+        if ccx.const_kind() != hir::ConstContext::ConstFn {\n+            Status::Allowed\n+        } else {\n+            Status::Unstable(sym::const_fn_union)\n+        }\n     }\n \n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {"}, {"sha": "0228f2d7de023f87f7eb440e4b8bc597344ac230", "filename": "compiler/rustc_mir/src/transform/check_consts/post_drop_elaboration.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/60b99015e95e5840a8f409d1042f1e3458d2c7dd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60b99015e95e5840a8f409d1042f1e3458d2c7dd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=60b99015e95e5840a8f409d1042f1e3458d2c7dd", "patch": "@@ -2,7 +2,7 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::{self, BasicBlock, Location};\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n \n use super::ops;\n use super::qualifs::{NeedsDrop, Qualif};\n@@ -11,7 +11,12 @@ use super::ConstCx;\n \n /// Returns `true` if we should use the more precise live drop checker that runs after drop\n /// elaboration.\n-pub fn checking_enabled(tcx: TyCtxt<'tcx>) -> bool {\n+pub fn checking_enabled(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> bool {\n+    // Const-stable functions must always use the stable live drop checker.\n+    if tcx.features().staged_api && !tcx.has_attr(def_id.to_def_id(), sym::rustc_const_unstable) {\n+        return false;\n+    }\n+\n     tcx.features().const_precise_live_drops\n }\n \n@@ -25,7 +30,7 @@ pub fn check_live_drops(tcx: TyCtxt<'tcx>, def_id: LocalDefId, body: &mir::Body<\n         return;\n     }\n \n-    if !checking_enabled(tcx) {\n+    if !checking_enabled(tcx, def_id) {\n         return;\n     }\n \n@@ -52,7 +57,7 @@ impl std::ops::Deref for CheckLiveDrops<'mir, 'tcx> {\n \n impl CheckLiveDrops<'mir, 'tcx> {\n     fn check_live_drop(&self, span: Span) {\n-        ops::non_const(self.ccx, ops::LiveDrop(None), span);\n+        ops::non_const(self.ccx, ops::LiveDrop { dropped_at: None }, span);\n     }\n }\n "}, {"sha": "0501302b7610a089c0552f389b0f54895b1fd52b", "filename": "compiler/rustc_mir/src/transform/check_consts/validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60b99015e95e5840a8f409d1042f1e3458d2c7dd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60b99015e95e5840a8f409d1042f1e3458d2c7dd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=60b99015e95e5840a8f409d1042f1e3458d2c7dd", "patch": "@@ -551,7 +551,7 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n             | TerminatorKind::DropAndReplace { place: dropped_place, .. } => {\n                 // If we are checking live drops after drop-elaboration, don't emit duplicate\n                 // errors here.\n-                if super::post_drop_elaboration::checking_enabled(self.tcx) {\n+                if super::post_drop_elaboration::checking_enabled(self.tcx, self.def_id) {\n                     return;\n                 }\n \n@@ -576,7 +576,7 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n \n                 if needs_drop {\n                     self.check_op_spanned(\n-                        ops::LiveDrop(Some(terminator.source_info.span)),\n+                        ops::LiveDrop { dropped_at: Some(terminator.source_info.span) },\n                         err_span,\n                     );\n                 }"}, {"sha": "f15a7f7c2c889c545b2808fe9e1793953377e32e", "filename": "compiler/rustc_mir/src/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/60b99015e95e5840a8f409d1042f1e3458d2c7dd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60b99015e95e5840a8f409d1042f1e3458d2c7dd/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fqualify_min_const_fn.rs?ref=60b99015e95e5840a8f409d1042f1e3458d2c7dd", "patch": "@@ -1,4 +1,3 @@\n-use rustc_attr as attr;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::*;\n@@ -344,8 +343,7 @@ fn feature_allowed(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbol) -> bo\n \n     // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n     // opt-in via `allow_internal_unstable`.\n-    attr::allow_internal_unstable(&tcx.sess, &tcx.get_attrs(def_id))\n-        .map_or(false, |mut features| features.any(|name| name == feature_gate))\n+    super::check_consts::allow_internal_unstable(tcx, def_id, feature_gate)\n }\n \n /// Returns `true` if the given library feature gate is allowed within the function with the given `DefId`.\n@@ -364,8 +362,7 @@ pub fn lib_feature_allowed(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbo\n \n     // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n     // opt-in via `allow_internal_unstable`.\n-    attr::allow_internal_unstable(&tcx.sess, &tcx.get_attrs(def_id))\n-        .map_or(false, |mut features| features.any(|name| name == feature_gate))\n+    super::check_consts::allow_internal_unstable(tcx, def_id, feature_gate)\n }\n \n fn check_terminator("}, {"sha": "66ea9d5924dfb6157740e1aa7386534e36226f48", "filename": "src/test/ui/consts/miri_unleashed/box.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60b99015e95e5840a8f409d1042f1e3458d2c7dd/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fbox.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/60b99015e95e5840a8f409d1042f1e3458d2c7dd/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fbox.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fbox.stderr?ref=60b99015e95e5840a8f409d1042f1e3458d2c7dd", "patch": "@@ -21,7 +21,7 @@ help: skipping check for `const_mut_refs` feature\n    |\n LL |     &mut *(box 0)\n    |     ^^^^^^^^^^^^^\n-help: skipping check for `const_mut_refs` feature\n+help: skipping check that does not even have a feature gate\n   --> $DIR/box.rs:10:5\n    |\n LL |     &mut *(box 0)"}, {"sha": "c6180c1e0041c97bf9b5a77bf958fd5376ad5da1", "filename": "src/test/ui/consts/miri_unleashed/mutable_references.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60b99015e95e5840a8f409d1042f1e3458d2c7dd/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/60b99015e95e5840a8f409d1042f1e3458d2c7dd/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr?ref=60b99015e95e5840a8f409d1042f1e3458d2c7dd", "patch": "@@ -6,17 +6,17 @@ LL |     *OH_YES = 99;\n \n warning: skipping const checks\n    |\n-help: skipping check for `const_mut_refs` feature\n+help: skipping check that does not even have a feature gate\n   --> $DIR/mutable_references.rs:9:26\n    |\n LL | static FOO: &&mut u32 = &&mut 42;\n    |                          ^^^^^^^\n-help: skipping check for `const_mut_refs` feature\n+help: skipping check that does not even have a feature gate\n   --> $DIR/mutable_references.rs:13:23\n    |\n LL | static BAR: &mut () = &mut ();\n    |                       ^^^^^^^\n-help: skipping check for `const_mut_refs` feature\n+help: skipping check that does not even have a feature gate\n   --> $DIR/mutable_references.rs:18:28\n    |\n LL | static BOO: &mut Foo<()> = &mut Foo(());\n@@ -26,7 +26,7 @@ help: skipping check that does not even have a feature gate\n    |\n LL |     x: &UnsafeCell::new(42),\n    |        ^^^^^^^^^^^^^^^^^^^^\n-help: skipping check for `const_mut_refs` feature\n+help: skipping check that does not even have a feature gate\n   --> $DIR/mutable_references.rs:30:27\n    |\n LL | static OH_YES: &mut i32 = &mut 42;"}, {"sha": "7647a9ff4f6e4c69271047dc8a53b8157dad24c8", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_err.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60b99015e95e5840a8f409d1042f1e3458d2c7dd/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/60b99015e95e5840a8f409d1042f1e3458d2c7dd/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr?ref=60b99015e95e5840a8f409d1042f1e3458d2c7dd", "patch": "@@ -30,7 +30,7 @@ help: skipping check that does not even have a feature gate\n    |\n LL | const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: skipping check for `const_mut_refs` feature\n+help: skipping check that does not even have a feature gate\n   --> $DIR/mutable_references_err.rs:30:25\n    |\n LL | const BLUNT: &mut i32 = &mut 42;"}, {"sha": "651462d7ef19c4476e10e5b34f7d1dc2f9e2b630", "filename": "src/test/ui/consts/stable-precise-live-drops-in-libcore.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/60b99015e95e5840a8f409d1042f1e3458d2c7dd/src%2Ftest%2Fui%2Fconsts%2Fstable-precise-live-drops-in-libcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60b99015e95e5840a8f409d1042f1e3458d2c7dd/src%2Ftest%2Fui%2Fconsts%2Fstable-precise-live-drops-in-libcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstable-precise-live-drops-in-libcore.rs?ref=60b99015e95e5840a8f409d1042f1e3458d2c7dd", "patch": "@@ -0,0 +1,22 @@\n+#![stable(feature = \"core\", since = \"1.6.0\")]\n+#![feature(staged_api)]\n+#![feature(const_precise_live_drops, const_fn)]\n+\n+enum Either<T, S> {\n+    Left(T),\n+    Right(S),\n+}\n+\n+impl<T> Either<T, T> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_stable(feature = \"foo\", since = \"1.0.0\")]\n+    pub const fn unwrap(self) -> T {\n+        //~^ ERROR destructors cannot be evaluated at compile-time\n+        match self {\n+            Self::Left(t) => t,\n+            Self::Right(t) => t,\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a3f513541dd6a6ebd2b73c49458c7537326a4afd", "filename": "src/test/ui/consts/stable-precise-live-drops-in-libcore.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60b99015e95e5840a8f409d1042f1e3458d2c7dd/src%2Ftest%2Fui%2Fconsts%2Fstable-precise-live-drops-in-libcore.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/60b99015e95e5840a8f409d1042f1e3458d2c7dd/src%2Ftest%2Fui%2Fconsts%2Fstable-precise-live-drops-in-libcore.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstable-precise-live-drops-in-libcore.stderr?ref=60b99015e95e5840a8f409d1042f1e3458d2c7dd", "patch": "@@ -0,0 +1,12 @@\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/stable-precise-live-drops-in-libcore.rs:13:25\n+   |\n+LL |     pub const fn unwrap(self) -> T {\n+   |                         ^^^^ constant functions cannot evaluate destructors\n+...\n+LL |     }\n+   |     - value is dropped here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0493`."}, {"sha": "619084eaa517a1895a5d286b93a996840c77557c", "filename": "src/test/ui/consts/unstable-precise-live-drops-in-libcore.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/60b99015e95e5840a8f409d1042f1e3458d2c7dd/src%2Ftest%2Fui%2Fconsts%2Funstable-precise-live-drops-in-libcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60b99015e95e5840a8f409d1042f1e3458d2c7dd/src%2Ftest%2Fui%2Fconsts%2Funstable-precise-live-drops-in-libcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funstable-precise-live-drops-in-libcore.rs?ref=60b99015e95e5840a8f409d1042f1e3458d2c7dd", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+\n+#![stable(feature = \"core\", since = \"1.6.0\")]\n+#![feature(staged_api)]\n+#![feature(const_precise_live_drops)]\n+\n+enum Either<T, S> {\n+    Left(T),\n+    Right(S),\n+}\n+\n+impl<T> Either<T, T> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"foo\", issue = \"none\")]\n+    pub const fn unwrap(self) -> T {\n+        match self {\n+            Self::Left(t) => t,\n+            Self::Right(t) => t,\n+        }\n+    }\n+}\n+\n+fn main() {}"}]}