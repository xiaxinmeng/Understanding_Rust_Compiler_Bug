{"sha": "d57f25907bc4247b4d98efce5ab6948c35baa12d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1N2YyNTkwN2JjNDI0N2I0ZDk4ZWZjZTVhYjY5NDhjMzViYWExMmQ=", "commit": {"author": {"name": "Clark Gaebel", "email": "cg.wowus.cg@gmail.com", "date": "2014-12-16T22:45:03Z"}, "committer": {"name": "Clark Gaebel", "email": "cg.wowus.cg@gmail.com", "date": "2014-12-19T03:16:51Z"}, "message": "[collections] Adds `drain`: a way to sneak out the elements while clearing.\n\nIt is useful to move all the elements out of some collections without\ndeallocating the underlying buffer. It came up in IRC, and this patch\nimplements it as `drain`. This has been discussed as part of RFC 509.\n\nr? @Gankro\ncc: @frankmcsherry", "tree": {"sha": "9b070bff1206ecc45e21bc1beb2e9b82d4baeaf8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b070bff1206ecc45e21bc1beb2e9b82d4baeaf8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d57f25907bc4247b4d98efce5ab6948c35baa12d", "comment_count": 14, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d57f25907bc4247b4d98efce5ab6948c35baa12d", "html_url": "https://github.com/rust-lang/rust/commit/d57f25907bc4247b4d98efce5ab6948c35baa12d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d57f25907bc4247b4d98efce5ab6948c35baa12d/comments", "author": null, "committer": null, "parents": [{"sha": "f9a48492a82f805aa40d8b6fea290badbab0d1b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9a48492a82f805aa40d8b6fea290badbab0d1b1", "html_url": "https://github.com/rust-lang/rust/commit/f9a48492a82f805aa40d8b6fea290badbab0d1b1"}], "stats": {"total": 488, "additions": 470, "deletions": 18}, "files": [{"sha": "f362abcc4e5b60b7280adda76b82338783143fbc", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d57f25907bc4247b4d98efce5ab6948c35baa12d/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d57f25907bc4247b4d98efce5ab6948c35baa12d/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=d57f25907bc4247b4d98efce5ab6948c35baa12d", "patch": "@@ -553,9 +553,18 @@ impl<T: Ord> BinaryHeap<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n+    /// Clears the queue, returning an iterator over the removed elements.\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n+        Drain {\n+            iter: self.data.drain(),\n+        }\n+    }\n+\n     /// Drops all items from the queue.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn clear(&mut self) { self.data.truncate(0) }\n+    pub fn clear(&mut self) { self.drain(); }\n }\n \n /// `BinaryHeap` iterator.\n@@ -598,6 +607,26 @@ impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n \n impl<T> ExactSizeIterator<T> for MoveItems<T> {}\n \n+/// An iterator that drains a `BinaryHeap`.\n+pub struct Drain<'a, T: 'a> {\n+    iter: vec::Drain<'a, T>,\n+}\n+\n+impl<'a, T: 'a> Iterator<T> for Drain<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<T> { self.iter.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n+impl<'a, T: 'a> DoubleEndedIterator<T> for Drain<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n+}\n+\n+impl<'a, T: 'a> ExactSizeIterator<T> for Drain<'a, T> {}\n+\n impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n     fn from_iter<Iter: Iterator<T>>(iter: Iter) -> BinaryHeap<T> {\n         let vec: Vec<T> = iter.collect();\n@@ -822,4 +851,14 @@ mod tests {\n             assert_eq!(q.pop().unwrap(), x);\n         }\n     }\n+\n+    #[test]\n+    fn test_drain() {\n+        let mut q: BinaryHeap<_> =\n+            [9u, 8, 7, 6, 5, 4, 3, 2, 1].iter().cloned().collect();\n+\n+        assert_eq!(q.drain().take(5).count(), 5);\n+\n+        assert!(q.is_empty());\n+    }\n }"}, {"sha": "a282d4ea8e22834f64b8e9ec4c7e23d747d05ca6", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 126, "deletions": 4, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/d57f25907bc4247b4d98efce5ab6948c35baa12d/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d57f25907bc4247b4d98efce5ab6948c35baa12d/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=d57f25907bc4247b4d98efce5ab6948c35baa12d", "patch": "@@ -443,6 +443,27 @@ impl<T> RingBuf<T> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n+    /// Creates a draining iterator that clears the `RingBuf` and iterates over\n+    /// the removed items from start to end.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut v = RingBuf::new();\n+    /// v.push_back(1i);\n+    /// assert_eq!(v.drain().next(), Some(1));\n+    /// assert!(v.is_empty());\n+    /// ```\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n+        Drain {\n+            inner: self,\n+        }\n+    }\n+\n     /// Clears the buffer, removing all values.\n     ///\n     /// # Examples\n@@ -456,10 +477,9 @@ impl<T> RingBuf<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[inline]\n     pub fn clear(&mut self) {\n-        while self.pop_front().is_some() {}\n-        self.head = 0;\n-        self.tail = 0;\n+        self.drain();\n     }\n \n     /// Provides a reference to the front element, or `None` if the sequence is\n@@ -1177,9 +1197,44 @@ impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n     }\n }\n \n-\n impl<T> ExactSizeIterator<T> for MoveItems<T> {}\n \n+/// A draining RingBuf iterator\n+pub struct Drain<'a, T: 'a> {\n+    inner: &'a mut RingBuf<T>,\n+}\n+\n+#[unsafe_destructor]\n+impl<'a, T: 'a> Drop for Drain<'a, T> {\n+    fn drop(&mut self) {\n+        for _ in *self {}\n+        self.inner.head = 0;\n+        self.inner.tail = 0;\n+    }\n+}\n+\n+impl<'a, T: 'a> Iterator<T> for Drain<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        self.inner.pop_front()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let len = self.inner.len();\n+        (len, Some(len))\n+    }\n+}\n+\n+impl<'a, T: 'a> DoubleEndedIterator<T> for Drain<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> {\n+        self.inner.pop_back()\n+    }\n+}\n+\n+impl<'a, T: 'a> ExactSizeIterator<T> for Drain<'a, T> {}\n+\n impl<A: PartialEq> PartialEq for RingBuf<A> {\n     fn eq(&self, other: &RingBuf<A>) -> bool {\n         self.len() == other.len() &&\n@@ -1789,6 +1844,73 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_drain() {\n+\n+        // Empty iter\n+        {\n+            let mut d: RingBuf<int> = RingBuf::new();\n+\n+            {\n+                let mut iter = d.drain();\n+\n+                assert_eq!(iter.size_hint(), (0, Some(0)));\n+                assert_eq!(iter.next(), None);\n+                assert_eq!(iter.size_hint(), (0, Some(0)));\n+            }\n+\n+            assert!(d.is_empty());\n+        }\n+\n+        // simple iter\n+        {\n+            let mut d = RingBuf::new();\n+            for i in range(0i, 5) {\n+                d.push_back(i);\n+            }\n+\n+            assert_eq!(d.drain().collect::<Vec<int>>(), [0, 1, 2, 3, 4]);\n+            assert!(d.is_empty());\n+        }\n+\n+        // wrapped iter\n+        {\n+            let mut d = RingBuf::new();\n+            for i in range(0i, 5) {\n+                d.push_back(i);\n+            }\n+            for i in range(6, 9) {\n+                d.push_front(i);\n+            }\n+\n+            assert_eq!(d.drain().collect::<Vec<int>>(), [8,7,6,0,1,2,3,4]);\n+            assert!(d.is_empty());\n+        }\n+\n+        // partially used\n+        {\n+            let mut d = RingBuf::new();\n+            for i in range(0i, 5) {\n+                d.push_back(i);\n+            }\n+            for i in range(6, 9) {\n+                d.push_front(i);\n+            }\n+\n+            {\n+                let mut it = d.drain();\n+                assert_eq!(it.size_hint(), (8, Some(8)));\n+                assert_eq!(it.next(), Some(8));\n+                assert_eq!(it.size_hint(), (7, Some(7)));\n+                assert_eq!(it.next_back(), Some(4));\n+                assert_eq!(it.size_hint(), (6, Some(6)));\n+                assert_eq!(it.next(), Some(7));\n+                assert_eq!(it.size_hint(), (5, Some(5)));\n+            }\n+            assert!(d.is_empty());\n+        }\n+    }\n+\n     #[test]\n     fn test_from_iter() {\n         use std::iter;"}, {"sha": "41f3eb81ff75ac422fa7b14dfff4c9233f3630e5", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 147, "deletions": 3, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/d57f25907bc4247b4d98efce5ab6948c35baa12d/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d57f25907bc4247b4d98efce5ab6948c35baa12d/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=d57f25907bc4247b4d98efce5ab6948c35baa12d", "patch": "@@ -1128,6 +1128,38 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Creates a draining iterator that clears the `Vec` and iterates over\n+    /// the removed items from start to end.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = vec![\"a\".to_string(), \"b\".to_string()];\n+    /// for s in v.drain() {\n+    ///     // s has type String, not &String\n+    ///     println!(\"{}\", s);\n+    /// }\n+    /// assert!(v.is_empty());\n+    /// ```\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n+        unsafe {\n+            let begin = self.ptr as *const T;\n+            let end = if mem::size_of::<T>() == 0 {\n+                (self.ptr as uint + self.len()) as *const T\n+            } else {\n+                self.ptr.offset(self.len() as int) as *const T\n+            };\n+            self.set_len(0);\n+            Drain {\n+                ptr: begin,\n+                end: end,\n+                marker: ContravariantLifetime,\n+            }\n+        }\n+    }\n+\n     /// Clears the vector, removing all values.\n     ///\n     /// # Examples\n@@ -1384,8 +1416,9 @@ pub struct MoveItems<T> {\n }\n \n impl<T> MoveItems<T> {\n-    #[inline]\n     /// Drops all items that have not yet been moved and returns the empty vector.\n+    #[inline]\n+    #[unstable]\n     pub fn into_inner(mut self) -> Vec<T> {\n         unsafe {\n             for _x in self { }\n@@ -1395,8 +1428,8 @@ impl<T> MoveItems<T> {\n         }\n     }\n \n-    /// Deprecated, use into_inner() instead\n-    #[deprecated = \"renamed to into_inner()\"]\n+    /// Deprecated, use .into_inner() instead\n+    #[deprecated = \"use .into_inner() instead\"]\n     pub fn unwrap(self) -> Vec<T> { self.into_inner() }\n }\n \n@@ -1472,6 +1505,84 @@ impl<T> Drop for MoveItems<T> {\n     }\n }\n \n+/// An iterator that drains a vector.\n+#[unsafe_no_drop_flag]\n+pub struct Drain<'a, T> {\n+    ptr: *const T,\n+    end: *const T,\n+    marker: ContravariantLifetime<'a>,\n+}\n+\n+impl<'a, T> Iterator<T> for Drain<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        unsafe {\n+            if self.ptr == self.end {\n+                None\n+            } else {\n+                if mem::size_of::<T>() == 0 {\n+                    // purposefully don't use 'ptr.offset' because for\n+                    // vectors with 0-size elements this would return the\n+                    // same pointer.\n+                    self.ptr = mem::transmute(self.ptr as uint + 1);\n+\n+                    // Use a non-null pointer value\n+                    Some(ptr::read(mem::transmute(1u)))\n+                } else {\n+                    let old = self.ptr;\n+                    self.ptr = self.ptr.offset(1);\n+\n+                    Some(ptr::read(old))\n+                }\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let diff = (self.end as uint) - (self.ptr as uint);\n+        let size = mem::size_of::<T>();\n+        let exact = diff / (if size == 0 {1} else {size});\n+        (exact, Some(exact))\n+    }\n+}\n+\n+impl<'a, T> DoubleEndedIterator<T> for Drain<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> {\n+        unsafe {\n+            if self.end == self.ptr {\n+                None\n+            } else {\n+                if mem::size_of::<T>() == 0 {\n+                    // See above for why 'ptr.offset' isn't used\n+                    self.end = mem::transmute(self.end as uint - 1);\n+\n+                    // Use a non-null pointer value\n+                    Some(ptr::read(mem::transmute(1u)))\n+                } else {\n+                    self.end = self.end.offset(-1);\n+\n+                    Some(ptr::read(self.end))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, T> ExactSizeIterator<T> for Drain<'a, T> {}\n+\n+#[unsafe_destructor]\n+impl<'a, T> Drop for Drain<'a, T> {\n+    fn drop(&mut self) {\n+        // self.ptr == self.end == null if drop has already been called,\n+        // so we can use #[unsafe_no_drop_flag].\n+\n+        // destroy the remaining elements\n+        for _x in *self {}\n+    }\n+}\n+\n /// Converts an iterator of pairs into a pair of vectors.\n ///\n /// Returns a tuple containing two vectors where the i-th element of the first vector contains the\n@@ -2280,6 +2391,39 @@ mod tests {\n         assert!(vec2 == vec![(), (), ()]);\n     }\n \n+    #[test]\n+    fn test_drain_items() {\n+        let mut vec = vec![1, 2, 3];\n+        let mut vec2: Vec<i32> = vec![];\n+        for i in vec.drain() {\n+            vec2.push(i);\n+        }\n+        assert_eq!(vec, []);\n+        assert_eq!(vec2, [ 1, 2, 3 ]);\n+    }\n+\n+    #[test]\n+    fn test_drain_items_reverse() {\n+        let mut vec = vec![1, 2, 3];\n+        let mut vec2: Vec<i32> = vec![];\n+        for i in vec.drain().rev() {\n+            vec2.push(i);\n+        }\n+        assert_eq!(vec, []);\n+        assert_eq!(vec2, [ 3, 2, 1 ]);\n+    }\n+\n+    #[test]\n+    fn test_drain_items_zero_sized() {\n+        let mut vec = vec![(), (), ()];\n+        let mut vec2: Vec<()> = vec![];\n+        for i in vec.drain() {\n+            vec2.push(i);\n+        }\n+        assert_eq!(vec, []);\n+        assert_eq!(vec2, [(), (), ()]);\n+    }\n+\n     #[test]\n     fn test_into_boxed_slice() {\n         let xs = vec![1u, 2, 3];"}, {"sha": "2020897fb3f30cdec24f1628a6a475cb01577be2", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d57f25907bc4247b4d98efce5ab6948c35baa12d/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d57f25907bc4247b4d98efce5ab6948c35baa12d/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=d57f25907bc4247b4d98efce5ab6948c35baa12d", "patch": "@@ -982,6 +982,35 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n+    /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n+    /// allocated memory for reuse.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut a = HashMap::new();\n+    /// a.insert(1u, \"a\");\n+    /// a.insert(2u, \"b\");\n+    ///\n+    /// for (k, v) in a.drain().take(1) {\n+    ///     assert!(k == 1 || k == 2);\n+    ///     assert!(v == \"a\" || v == \"b\");\n+    /// }\n+    ///\n+    /// assert!(a.is_empty());\n+    /// ```\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn drain(&mut self) -> Drain<K, V> {\n+        fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n+\n+        Drain {\n+            inner: self.table.drain().map(last_two),\n+        }\n+    }\n+\n     /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n     /// for reuse.\n     ///\n@@ -996,16 +1025,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert!(a.is_empty());\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    #[inline]\n     pub fn clear(&mut self) {\n-        let cap = self.table.capacity();\n-        let mut buckets = Bucket::first(&mut self.table);\n-\n-        while buckets.index() != cap {\n-            buckets = match buckets.peek() {\n-                Empty(b)   => b.next(),\n-                Full(full) => full.take().0.next(),\n-            };\n-        }\n+        self.drain();\n     }\n \n     /// Deprecated: Renamed to `get`.\n@@ -1306,6 +1328,16 @@ pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a V, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n \n+/// HashMap drain iterator\n+pub struct Drain<'a, K: 'a, V: 'a> {\n+    inner: iter::Map<\n+        (SafeHash, K, V),\n+        (K, V),\n+        table::Drain<'a, K, V>,\n+        fn((SafeHash, K, V)) -> (K, V),\n+    >\n+}\n+\n /// A view into a single occupied location in a HashMap\n pub struct OccupiedEntry<'a, K:'a, V:'a> {\n     elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n@@ -1360,6 +1392,17 @@ impl<'a, K, V> Iterator<&'a V> for Values<'a, K, V> {\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n+impl<'a, K: 'a, V: 'a> Iterator<(K, V)> for Drain<'a, K, V> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(K, V)> {\n+        self.inner.next()\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the value in the entry\n     pub fn get(&self) -> &V {"}, {"sha": "d75602a2716ad7daa8b54cc646ca0f0c2778d46e", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 56, "deletions": 1, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d57f25907bc4247b4d98efce5ab6948c35baa12d/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d57f25907bc4247b4d98efce5ab6948c35baa12d/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=d57f25907bc4247b4d98efce5ab6948c35baa12d", "patch": "@@ -21,7 +21,7 @@ use iter::{Iterator, IteratorExt, FromIterator, Map, FilterMap, Chain, Repeat, Z\n use option::Option::{Some, None, mod};\n use result::Result::{Ok, Err};\n \n-use super::map::{HashMap, MoveEntries, Keys, INITIAL_CAPACITY};\n+use super::map::{mod, HashMap, MoveEntries, Keys, INITIAL_CAPACITY};\n \n // FIXME(conventions): implement BitOr, BitAnd, BitXor, and Sub\n \n@@ -420,6 +420,14 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.map.len() == 0 }\n \n+    /// Clears the set, returning all elements in an iterator.\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn drain(&mut self) -> Drain<T> {\n+        fn first<A, B>((a, _): (A, B)) -> A { a }\n+        Drain { iter: self.map.drain().map(first) }\n+    }\n+\n     /// Clears the set, removing all values.\n     ///\n     /// # Example\n@@ -626,6 +634,11 @@ pub struct SetMoveItems<K> {\n     iter: Map<(K, ()), K, MoveEntries<K, ()>, fn((K, ())) -> K>\n }\n \n+/// HashSet drain iterator\n+pub struct Drain<'a, K: 'a> {\n+    iter: Map<(K, ()), K, map::Drain<'a, K, ()>, fn((K, ())) -> K>,\n+}\n+\n // `Repeat` is used to feed the filter closure an explicit capture\n // of a reference to the other set\n /// Set operations iterator, used directly for intersection and difference\n@@ -658,6 +671,11 @@ impl<K> Iterator<K> for SetMoveItems<K> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n+impl<'a, K: 'a> Iterator<K> for Drain<'a, K> {\n+    fn next(&mut self) -> Option<K> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n impl<'a, T, H> Iterator<&'a T> for SetAlgebraItems<'a, T, H> {\n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n@@ -914,4 +932,41 @@ mod test_set {\n         assert!(set_str == \"{1, 2}\" || set_str == \"{2, 1}\");\n         assert_eq!(format!(\"{}\", empty), \"{}\");\n     }\n+\n+    #[test]\n+    fn test_trivial_drain() {\n+        let mut s = HashSet::<int>::new();\n+        for _ in s.drain() {}\n+        assert!(s.is_empty());\n+        drop(s);\n+\n+        let mut s = HashSet::<int>::new();\n+        drop(s.drain());\n+        assert!(s.is_empty());\n+    }\n+\n+    #[test]\n+    fn test_drain() {\n+        let mut s: HashSet<int> = range(1, 100).collect();\n+\n+        // try this a bunch of times to make sure we don't screw up internal state.\n+        for _ in range(0i, 20) {\n+            assert_eq!(s.len(), 99);\n+\n+            {\n+                let mut last_i = 0;\n+                let mut d = s.drain();\n+                for (i, x) in d.by_ref().take(50).enumerate() {\n+                    last_i = i;\n+                    assert!(x != 0);\n+                }\n+                assert_eq!(last_i, 49);\n+            }\n+\n+            for _ in s.iter() { panic!(\"s should be empty!\"); }\n+\n+            // reset to try again.\n+            s.extend(range(1, 100));\n+        }\n+    }\n }"}, {"sha": "115edcabca1e9847af4de61b6a091ef8af71b383", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d57f25907bc4247b4d98efce5ab6948c35baa12d/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d57f25907bc4247b4d98efce5ab6948c35baa12d/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=d57f25907bc4247b4d98efce5ab6948c35baa12d", "patch": "@@ -684,6 +684,19 @@ impl<K, V> RawTable<K, V> {\n         }\n     }\n \n+    pub fn drain(&mut self) -> Drain<K, V> {\n+        let RawBuckets { raw, hashes_end, .. } = self.raw_buckets();\n+        // Replace the marker regardless of lifetime bounds on parameters.\n+        Drain {\n+            iter: RawBuckets {\n+                raw: raw,\n+                hashes_end: hashes_end,\n+                marker: marker::ContravariantLifetime::<'static>,\n+            },\n+            table: self,\n+        }\n+    }\n+\n     /// Returns an iterator that copies out each entry. Used while the table\n     /// is being dropped.\n     unsafe fn rev_move_buckets(&mut self) -> RevMoveBuckets<K, V> {\n@@ -774,6 +787,12 @@ pub struct MoveEntries<K, V> {\n     iter: RawBuckets<'static, K, V>\n }\n \n+/// Iterator over the entries in a table, clearing the table.\n+pub struct Drain<'a, K: 'a, V: 'a> {\n+    table: &'a mut RawTable<K, V>,\n+    iter: RawBuckets<'static, K, V>,\n+}\n+\n impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a V)> {\n         self.iter.next().map(|bucket| {\n@@ -828,6 +847,36 @@ impl<K, V> Iterator<(SafeHash, K, V)> for MoveEntries<K, V> {\n     }\n }\n \n+impl<'a, K: 'a, V: 'a> Iterator<(SafeHash, K, V)> for Drain<'a, K, V> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(SafeHash, K, V)> {\n+        self.iter.next().map(|bucket| {\n+            self.table.size -= 1;\n+            unsafe {\n+                (\n+                    SafeHash {\n+                        hash: ptr::replace(bucket.hash, EMPTY_BUCKET),\n+                    },\n+                    ptr::read(bucket.key as *const K),\n+                    ptr::read(bucket.val as *const V)\n+                )\n+            }\n+        })\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let size = self.table.size();\n+        (size, Some(size))\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<'a, K: 'a, V: 'a> Drop for Drain<'a, K, V> {\n+    fn drop(&mut self) {\n+        for _ in *self {}\n+    }\n+}\n+\n impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n     fn clone(&self) -> RawTable<K, V> {\n         unsafe {"}]}