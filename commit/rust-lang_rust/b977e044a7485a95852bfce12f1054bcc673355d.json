{"sha": "b977e044a7485a95852bfce12f1054bcc673355d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NzdlMDQ0YTc0ODVhOTU4NTJiZmNlMTJmMTA1NGJjYzY3MzM1NWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-06T11:52:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-06T11:52:16Z"}, "message": "Auto merge of #48611 - michaelwoerister:share-generics2, r=alexcrichton\n\nDon't recompute SymbolExportLevel for upstream crates.\n\nThe data collected in #48373 suggests that we can avoid generating up to 30% of the LLVM definitions by only instantiating function monomorphizations once with a given crate graph. Some more data, collected with a [proof-of-concept implementation](https://github.com/michaelwoerister/rust/commits/share-generics) of re-using monomorphizations, which is less efficient than the MIR-only RLIB approach, suggests that it's still around 25% LLVM definitions that we can save.\n\nSo far, this PR only cleans up handling of symbol export status. Too early to review still.", "tree": {"sha": "d3fd34041981c111b25ac0afd73d0fce69f0a699", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3fd34041981c111b25ac0afd73d0fce69f0a699"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b977e044a7485a95852bfce12f1054bcc673355d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b977e044a7485a95852bfce12f1054bcc673355d", "html_url": "https://github.com/rust-lang/rust/commit/b977e044a7485a95852bfce12f1054bcc673355d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b977e044a7485a95852bfce12f1054bcc673355d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f2100b92cb14fbea2102701af6a3ac5814bd06c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f2100b92cb14fbea2102701af6a3ac5814bd06c", "html_url": "https://github.com/rust-lang/rust/commit/6f2100b92cb14fbea2102701af6a3ac5814bd06c"}, {"sha": "f5ab4d4cdd1a8eda860628e97b619da8c10ac7b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5ab4d4cdd1a8eda860628e97b619da8c10ac7b3", "html_url": "https://github.com/rust-lang/rust/commit/f5ab4d4cdd1a8eda860628e97b619da8c10ac7b3"}], "stats": {"total": 684, "additions": 413, "deletions": 271}, "files": [{"sha": "84fdeba4ab3ccbe3742c52c591f306490979484b", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -556,7 +556,7 @@ define_dep_nodes!( <'tcx>\n     [] RvaluePromotableMap(DefId),\n     [] ImplParent(DefId),\n     [] TraitOfItem(DefId),\n-    [] IsExportedSymbol(DefId),\n+    [] IsReachableNonGeneric(DefId),\n     [] IsMirAvailable(DefId),\n     [] ItemAttrs(DefId),\n     [] FnArgNames(DefId),\n@@ -574,7 +574,7 @@ define_dep_nodes!( <'tcx>\n     [] GetPanicStrategy(CrateNum),\n     [] IsNoBuiltins(CrateNum),\n     [] ImplDefaultness(DefId),\n-    [] ExportedSymbolIds(CrateNum),\n+    [] ReachableNonGenerics(CrateNum),\n     [] NativeLibraries(CrateNum),\n     [] PluginRegistrarFn(CrateNum),\n     [] DeriveRegistrarFn(CrateNum),"}, {"sha": "5dbe2ef516cf7c2ab7406f0832b02a2e3d9d3027", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -32,7 +32,6 @@ use ich;\n use ty::{self, TyCtxt};\n use session::{Session, CrateDisambiguator};\n use session::search_paths::PathKind;\n-use util::nodemap::NodeSet;\n \n use std::any::Any;\n use std::collections::BTreeMap;\n@@ -258,8 +257,7 @@ pub trait CrateStore {\n     // utility functions\n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 link_meta: &LinkMeta,\n-                                 reachable: &NodeSet)\n+                                 link_meta: &LinkMeta)\n                                  -> EncodedMetadata;\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n@@ -342,8 +340,7 @@ impl CrateStore for DummyCrateStore {\n     fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum> { None }\n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 link_meta: &LinkMeta,\n-                                 reachable: &NodeSet)\n+                                 link_meta: &LinkMeta)\n                                  -> EncodedMetadata {\n         bug!(\"encode_metadata\")\n     }"}, {"sha": "b1418792490fcc3d40c832f62aec98ca9c050080", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -8,12 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use hir::def_id::{DefId, LOCAL_CRATE};\n+use std::cmp;\n+use ty;\n+\n /// The SymbolExportLevel of a symbols specifies from which kinds of crates\n /// the symbol will be exported. `C` symbols will be exported from any\n /// kind of crate, including cdylibs which export very few things.\n /// `Rust` will only be exported if the crate produced is a Rust\n /// dylib.\n-#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+#[derive(Eq, PartialEq, Debug, Copy, Clone, RustcEncodable, RustcDecodable)]\n pub enum SymbolExportLevel {\n     C,\n     Rust,\n@@ -34,3 +38,58 @@ impl SymbolExportLevel {\n         }\n     }\n }\n+\n+#[derive(Eq, PartialEq, Debug, Copy, Clone, RustcEncodable, RustcDecodable)]\n+pub enum ExportedSymbol {\n+    NonGeneric(DefId),\n+    NoDefId(ty::SymbolName),\n+}\n+\n+impl ExportedSymbol {\n+    pub fn symbol_name(&self, tcx: ty::TyCtxt) -> ty::SymbolName {\n+        match *self {\n+            ExportedSymbol::NonGeneric(def_id) => {\n+                tcx.symbol_name(ty::Instance::mono(tcx, def_id))\n+            }\n+            ExportedSymbol::NoDefId(symbol_name) => {\n+                symbol_name\n+            }\n+        }\n+    }\n+\n+    pub fn compare_stable(&self, tcx: ty::TyCtxt, other: &ExportedSymbol) -> cmp::Ordering {\n+        match *self {\n+            ExportedSymbol::NonGeneric(self_def_id) => {\n+                match *other {\n+                    ExportedSymbol::NonGeneric(other_def_id) => {\n+                        tcx.def_path_hash(self_def_id).cmp(&tcx.def_path_hash(other_def_id))\n+                    }\n+                    ExportedSymbol::NoDefId(_) => {\n+                        cmp::Ordering::Less\n+                    }\n+                }\n+            }\n+            ExportedSymbol::NoDefId(self_symbol_name) => {\n+                match *other {\n+                    ExportedSymbol::NonGeneric(_) => {\n+                        cmp::Ordering::Greater\n+                    }\n+                    ExportedSymbol::NoDefId(ref other_symbol_name) => {\n+                        self_symbol_name.cmp(other_symbol_name)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum self::ExportedSymbol {\n+    NonGeneric(def_id),\n+    NoDefId(symbol_name)\n+});\n+\n+pub fn metadata_symbol_name(tcx: ty::TyCtxt) -> String {\n+    format!(\"rust_metadata_{}_{}\",\n+            tcx.original_crate_name(LOCAL_CRATE),\n+            tcx.crate_disambiguator(LOCAL_CRATE).to_fingerprint().to_hex())\n+}"}, {"sha": "47a3580e8676974f80c03b809ab5ddddbb21118a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -46,7 +46,7 @@ use ty::layout::{LayoutDetails, TargetDataLayout};\n use ty::maps;\n use ty::steal::Steal;\n use ty::BindingMode;\n-use util::nodemap::{NodeMap, NodeSet, DefIdSet, ItemLocalMap};\n+use util::nodemap::{NodeMap, DefIdSet, ItemLocalMap};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n@@ -1417,10 +1417,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n-    pub fn encode_metadata(self, link_meta: &LinkMeta, reachable: &NodeSet)\n+    pub fn encode_metadata(self, link_meta: &LinkMeta)\n         -> EncodedMetadata\n     {\n-        self.cstore.encode_metadata(self, link_meta, reachable)\n+        self.cstore.encode_metadata(self, link_meta)\n     }\n }\n \n@@ -2460,4 +2460,12 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         assert_eq!(cnum, LOCAL_CRATE);\n         Lrc::new(tcx.sess.features_untracked().clone())\n     };\n+    providers.is_panic_runtime = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        attr::contains_name(tcx.hir.krate_attrs(), \"panic_runtime\")\n+    };\n+    providers.is_compiler_builtins = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        attr::contains_name(tcx.hir.krate_attrs(), \"compiler_builtins\")\n+    };\n }"}, {"sha": "cfc552bdc85c56a84a0b65aee363c43e75edd565", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -212,9 +212,9 @@ impl<'tcx> QueryDescription<'tcx> for queries::item_attrs<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::is_exported_symbol<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::is_reachable_non_generic<'tcx> {\n     fn describe(_: TyCtxt, _: DefId) -> String {\n-        bug!(\"is_exported_symbol\")\n+        bug!(\"is_reachable_non_generic\")\n     }\n }\n \n@@ -383,7 +383,7 @@ impl<'tcx> QueryDescription<'tcx> for queries::is_sanitizer_runtime<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::exported_symbol_ids<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::reachable_non_generics<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"looking up the exported symbols of a crate\")\n     }"}, {"sha": "2ef97b2673d6efddb6456aa8a2af8f1418cd8f47", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -26,7 +26,7 @@ use middle::region;\n use middle::resolve_lifetime::{ResolveLifetimes, Region, ObjectLifetimeDefault};\n use middle::stability::{self, DeprecationEntry};\n use middle::lang_items::{LanguageItems, LangItem};\n-use middle::exported_symbols::SymbolExportLevel;\n+use middle::exported_symbols::{SymbolExportLevel, ExportedSymbol};\n use mir::mono::{CodegenUnit, Stats};\n use mir;\n use session::{CompileResult, CrateDisambiguator};\n@@ -238,7 +238,6 @@ define_maps! { <'tcx>\n     [] fn fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n     [] fn impl_parent: ImplParent(DefId) -> Option<DefId>,\n     [] fn trait_of_item: TraitOfItem(DefId) -> Option<DefId>,\n-    [] fn is_exported_symbol: IsExportedSymbol(DefId) -> bool,\n     [] fn item_body_nested_bodies: ItemBodyNestedBodies(DefId) -> ExternBodyNestedBodies,\n     [] fn const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n     [] fn rvalue_promotable_map: RvaluePromotableMap(DefId) -> Lrc<ItemLocalSet>,\n@@ -290,7 +289,23 @@ define_maps! { <'tcx>\n     [] fn lint_levels: lint_levels_node(CrateNum) -> Lrc<lint::LintLevelMap>,\n \n     [] fn impl_defaultness: ImplDefaultness(DefId) -> hir::Defaultness,\n-    [] fn exported_symbol_ids: ExportedSymbolIds(CrateNum) -> Lrc<DefIdSet>,\n+\n+    // The DefIds of all non-generic functions and statics in the given crate\n+    // that can be reached from outside the crate.\n+    //\n+    // We expect this items to be available for being linked to.\n+    //\n+    // This query can also be called for LOCAL_CRATE. In this case it will\n+    // compute which items will be reachable to other crates, taking into account\n+    // the kind of crate that is currently compiled. Crates with only a\n+    // C interface have fewer reachable things.\n+    //\n+    // Does not include external symbols that don't have a corresponding DefId,\n+    // like the compiler-generated `main` function and so on.\n+    [] fn reachable_non_generics: ReachableNonGenerics(CrateNum) -> Lrc<DefIdSet>,\n+    [] fn is_reachable_non_generic: IsReachableNonGeneric(DefId) -> bool,\n+\n+\n     [] fn native_libraries: NativeLibraries(CrateNum) -> Lrc<Vec<NativeLibrary>>,\n     [] fn plugin_registrar_fn: PluginRegistrarFn(CrateNum) -> Option<DefId>,\n     [] fn derive_registrar_fn: DeriveRegistrarFn(CrateNum) -> Option<DefId>,\n@@ -343,7 +358,7 @@ define_maps! { <'tcx>\n     [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Lrc<Vec<CrateNum>>,\n \n     [] fn exported_symbols: ExportedSymbols(CrateNum)\n-        -> Arc<Vec<(String, Option<DefId>, SymbolExportLevel)>>,\n+        -> Arc<Vec<(ExportedSymbol, SymbolExportLevel)>>,\n     [] fn collect_and_partition_translation_items:\n         collect_and_partition_translation_items_node(CrateNum)\n         -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>),"}, {"sha": "13f286d6a26868250d6fb7d1b5b8eb2c7dfe8553", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -851,7 +851,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::RvaluePromotableMap => { force!(rvalue_promotable_map, def_id!()); }\n         DepKind::ImplParent => { force!(impl_parent, def_id!()); }\n         DepKind::TraitOfItem => { force!(trait_of_item, def_id!()); }\n-        DepKind::IsExportedSymbol => { force!(is_exported_symbol, def_id!()); }\n+        DepKind::IsReachableNonGeneric => { force!(is_reachable_non_generic, def_id!()); }\n         DepKind::IsMirAvailable => { force!(is_mir_available, def_id!()); }\n         DepKind::ItemAttrs => { force!(item_attrs, def_id!()); }\n         DepKind::FnArgNames => { force!(fn_arg_names, def_id!()); }\n@@ -868,7 +868,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::GetPanicStrategy => { force!(panic_strategy, krate!()); }\n         DepKind::IsNoBuiltins => { force!(is_no_builtins, krate!()); }\n         DepKind::ImplDefaultness => { force!(impl_defaultness, def_id!()); }\n-        DepKind::ExportedSymbolIds => { force!(exported_symbol_ids, krate!()); }\n+        DepKind::ReachableNonGenerics => { force!(reachable_non_generics, krate!()); }\n         DepKind::NativeLibraries => { force!(native_libraries, krate!()); }\n         DepKind::PluginRegistrarFn => { force!(plugin_registrar_fn, krate!()); }\n         DepKind::DeriveRegistrarFn => { force!(derive_registrar_fn, krate!()); }"}, {"sha": "a7c55880e2e17681ad69ac6454c79387dd822940", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -2806,7 +2806,7 @@ impl<'tcx> DtorckConstraint<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n pub struct SymbolName {\n     // FIXME: we don't rely on interning or equality here - better have\n     // this be a `&'tcx str`.\n@@ -2817,6 +2817,14 @@ impl_stable_hash_for!(struct self::SymbolName {\n     name\n });\n \n+impl SymbolName {\n+    pub fn new(name: &str) -> SymbolName {\n+        SymbolName {\n+            name: Symbol::intern(name).as_str()\n+        }\n+    }\n+}\n+\n impl Deref for SymbolName {\n     type Target = str;\n \n@@ -2828,3 +2836,9 @@ impl fmt::Display for SymbolName {\n         fmt::Display::fmt(&self.name, fmt)\n     }\n }\n+\n+impl fmt::Debug for SymbolName {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.name, fmt)\n+    }\n+}"}, {"sha": "789ecd0f6136b1766436313795d9a85da1d8913c", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -225,9 +225,6 @@ impl<'a> CrateLoader<'a> {\n             crate_root.def_path_table.decode((&metadata, self.sess))\n         });\n \n-        let exported_symbols = crate_root.exported_symbols\n-                                         .decode((&metadata, self.sess))\n-                                         .collect();\n         let trait_impls = crate_root\n             .impls\n             .decode((&metadata, self.sess))\n@@ -238,7 +235,6 @@ impl<'a> CrateLoader<'a> {\n             name,\n             extern_crate: Cell::new(None),\n             def_path_table: Lrc::new(def_path_table),\n-            exported_symbols,\n             trait_impls,\n             proc_macros: crate_root.macro_derive_registrar.map(|_| {\n                 self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)"}, {"sha": "2e95c23b4aed1f3a63b29a5bb0b19e4b79a63dc1", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -78,8 +78,6 @@ pub struct CrateMetadata {\n     /// compilation support.\n     pub def_path_table: Lrc<DefPathTable>,\n \n-    pub exported_symbols: FxHashSet<DefIndex>,\n-\n     pub trait_impls: FxHashMap<(u32, DefIndex), schema::LazySeq<DefIndex>>,\n \n     pub dep_kind: Cell<DepKind>,"}, {"sha": "0b50f5c44962b7dfdd766a5fd716bd3751a87527", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -18,6 +18,7 @@ use rustc::ty::maps::QueryConfig;\n use rustc::middle::cstore::{CrateStore, DepKind,\n                             MetadataLoader, LinkMeta,\n                             LoadedMacro, EncodedMetadata, NativeLibraryKind};\n+use rustc::middle::exported_symbols::ExportedSymbol;\n use rustc::middle::stability::DeprecationEntry;\n use rustc::hir::def;\n use rustc::session::{CrateDisambiguator, Session};\n@@ -27,10 +28,11 @@ use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n use rustc::hir::map::{DefKey, DefPath, DefPathHash};\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::hir::map::definitions::DefPathTable;\n-use rustc::util::nodemap::{NodeSet, DefIdMap};\n+use rustc::util::nodemap::DefIdMap;\n \n use std::any::Any;\n use rustc_data_structures::sync::Lrc;\n+use std::sync::Arc;\n \n use syntax::ast;\n use syntax::attr;\n@@ -160,9 +162,6 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     fn_arg_names => { cdata.get_fn_arg_names(def_id.index) }\n     impl_parent => { cdata.get_parent_impl(def_id.index) }\n     trait_of_item => { cdata.get_trait_of_item(def_id.index) }\n-    is_exported_symbol => {\n-        cdata.exported_symbols.contains(&def_id.index)\n-    }\n     item_body_nested_bodies => { cdata.item_body_nested_bodies(def_id.index) }\n     const_is_rvalue_promotable_to_static => {\n         cdata.const_is_rvalue_promotable_to_static(def_id.index)\n@@ -179,7 +178,21 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     extern_crate => { Lrc::new(cdata.extern_crate.get()) }\n     is_no_builtins => { cdata.is_no_builtins(tcx.sess) }\n     impl_defaultness => { cdata.get_impl_defaultness(def_id.index) }\n-    exported_symbol_ids => { Lrc::new(cdata.get_exported_symbols()) }\n+    reachable_non_generics => {\n+        let reachable_non_generics = tcx\n+            .exported_symbols(cdata.cnum)\n+            .iter()\n+            .filter_map(|&(exported_symbol, _)| {\n+                if let ExportedSymbol::NonGeneric(def_id) = exported_symbol {\n+                    return Some(def_id)\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect();\n+\n+        Lrc::new(reachable_non_generics)\n+    }\n     native_libraries => { Lrc::new(cdata.get_native_libraries(tcx.sess)) }\n     plugin_registrar_fn => {\n         cdata.root.plugin_registrar_fn.map(|index| {\n@@ -238,6 +251,19 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n \n     has_copy_closures => { cdata.has_copy_closures(tcx.sess) }\n     has_clone_closures => { cdata.has_clone_closures(tcx.sess) }\n+\n+    exported_symbols => {\n+        let cnum = cdata.cnum;\n+        assert!(cnum != LOCAL_CRATE);\n+\n+        // If this crate is a custom derive crate, then we're not even going to\n+        // link those in so we skip those crates.\n+        if cdata.root.macro_derive_registrar.is_some() {\n+            return Arc::new(Vec::new())\n+        }\n+\n+        Arc::new(cdata.exported_symbols())\n+    }\n }\n \n pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n@@ -520,11 +546,10 @@ impl CrateStore for cstore::CStore {\n \n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 link_meta: &LinkMeta,\n-                                 reachable: &NodeSet)\n+                                 link_meta: &LinkMeta)\n                                  -> EncodedMetadata\n     {\n-        encoder::encode_metadata(tcx, link_meta, reachable)\n+        encoder::encode_metadata(tcx, link_meta)\n     }\n \n     fn metadata_encoding_version(&self) -> &[u8]"}, {"sha": "60a0d4e03b54a549371cced1ed272efaef180e2b", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -18,6 +18,7 @@ use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir;\n use rustc::middle::cstore::{LinkagePreference, ExternConstBody,\n                             ExternBodyNestedBodies};\n+use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex,\n                          CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -27,7 +28,6 @@ use rustc::mir;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::codec::TyDecoder;\n-use rustc::util::nodemap::DefIdSet;\n use rustc::mir::Mir;\n \n use std::cell::Ref;\n@@ -1006,10 +1006,10 @@ impl<'a, 'tcx> CrateMetadata {\n         arg_names.decode(self).collect()\n     }\n \n-    pub fn get_exported_symbols(&self) -> DefIdSet {\n-        self.exported_symbols\n-            .iter()\n-            .map(|&index| self.local_def_id(index))\n+    pub fn exported_symbols(&self) -> Vec<(ExportedSymbol, SymbolExportLevel)> {\n+        self.root\n+            .exported_symbols\n+            .decode(self)\n             .collect()\n     }\n "}, {"sha": "d19ab89459146401069d45c7488d7fa80697c983", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -20,14 +20,16 @@ use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LOCAL_CRATE\n use rustc::hir::map::definitions::DefPathTable;\n use rustc::ich::Fingerprint;\n use rustc::middle::dependency_format::Linkage;\n+use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel,\n+                                      metadata_symbol_name};\n use rustc::middle::lang_items;\n use rustc::mir;\n use rustc::traits::specialization_graph;\n-use rustc::ty::{self, Ty, TyCtxt, ReprOptions};\n+use rustc::ty::{self, Ty, TyCtxt, ReprOptions, SymbolName};\n use rustc::ty::codec::{self as ty_codec, TyEncoder};\n \n use rustc::session::config::{self, CrateTypeProcMacro};\n-use rustc::util::nodemap::{FxHashMap, NodeSet};\n+use rustc::util::nodemap::FxHashMap;\n \n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_serialize::{Encodable, Encoder, SpecializedEncoder, opaque};\n@@ -53,7 +55,6 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Encoder<'a>,\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     link_meta: &'a LinkMeta,\n-    exported_symbols: &'a NodeSet,\n \n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n@@ -395,9 +396,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         // Encode exported symbols info.\n         i = self.position();\n+        let exported_symbols = self.tcx.exported_symbols(LOCAL_CRATE);\n         let exported_symbols = self.tracked(\n             IsolatedEncoder::encode_exported_symbols,\n-            self.exported_symbols);\n+            &exported_symbols);\n         let exported_symbols_bytes = self.position() - i;\n \n         // Encode and index the items.\n@@ -1388,9 +1390,25 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     // middle::reachable module but filters out items that either don't have a\n     // symbol associated with them (they weren't translated) or if they're an FFI\n     // definition (as that's not defined in this crate).\n-    fn encode_exported_symbols(&mut self, exported_symbols: &NodeSet) -> LazySeq<DefIndex> {\n-        let tcx = self.tcx;\n-        self.lazy_seq(exported_symbols.iter().map(|&id| tcx.hir.local_def_id(id).index))\n+    fn encode_exported_symbols(&mut self,\n+                               exported_symbols: &[(ExportedSymbol, SymbolExportLevel)])\n+                               -> LazySeq<(ExportedSymbol, SymbolExportLevel)> {\n+\n+        // The metadata symbol name is special. It should not show up in\n+        // downstream crates.\n+        let metadata_symbol_name = SymbolName::new(&metadata_symbol_name(self.tcx));\n+\n+        self.lazy_seq(exported_symbols\n+            .iter()\n+            .filter(|&&(ref exported_symbol, _)| {\n+                match *exported_symbol {\n+                    ExportedSymbol::NoDefId(symbol_name) => {\n+                        symbol_name != metadata_symbol_name\n+                    },\n+                    _ => true,\n+                }\n+            })\n+            .cloned())\n     }\n \n     fn encode_dylib_dependency_formats(&mut self, _: ()) -> LazySeq<Option<LinkagePreference>> {\n@@ -1663,8 +1681,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n // generated regardless of trailing bytes that end up in it.\n \n pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 link_meta: &LinkMeta,\n-                                 exported_symbols: &NodeSet)\n+                                 link_meta: &LinkMeta)\n                                  -> EncodedMetadata\n {\n     let mut cursor = Cursor::new(vec![]);\n@@ -1678,7 +1695,6 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             opaque: opaque::Encoder::new(&mut cursor),\n             tcx,\n             link_meta,\n-            exported_symbols,\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),"}, {"sha": "ce94e4f912f4f9e1012fd729ea967f222503163f", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -16,6 +16,7 @@ use rustc::hir::def::{self, CtorKind};\n use rustc::hir::def_id::{DefIndex, DefId, CrateNum};\n use rustc::ich::StableHashingContext;\n use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary};\n+use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::middle::lang_items;\n use rustc::mir;\n use rustc::session::CrateDisambiguator;\n@@ -202,7 +203,8 @@ pub struct CrateRoot {\n     pub codemap: LazySeq<syntax_pos::FileMap>,\n     pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n     pub impls: LazySeq<TraitImpls>,\n-    pub exported_symbols: LazySeq<DefIndex>,\n+    pub exported_symbols: LazySeq<(ExportedSymbol, SymbolExportLevel)>,\n+\n     pub index: LazySeq<index::Index>,\n }\n "}, {"sha": "10c2f9f758f14a07eb376222ad2a4c17a918d1ab", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -736,7 +736,7 @@ fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance:\n         }\n         Some(_) => true,\n         None => {\n-            if tcx.is_exported_symbol(def_id) ||\n+            if tcx.is_reachable_non_generic(def_id) ||\n                 tcx.is_foreign_item(def_id)\n             {\n                 // We can link to the item in question, no instance needed\n@@ -984,7 +984,7 @@ impl<'b, 'a, 'v> RootCollector<'b, 'a, 'v> {\n             }\n             MonoItemCollectionMode::Lazy => {\n                 self.entry_fn == Some(def_id) ||\n-                self.tcx.is_exported_symbol(def_id) ||\n+                self.tcx.is_reachable_non_generic(def_id) ||\n                 attr::contains_name(&self.tcx.get_attrs(def_id),\n                                     \"rustc_std_internal_symbol\")\n             }"}, {"sha": "d65c1e03298a1cee8041f795bb08d3ebaf190215", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -363,7 +363,7 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     can_be_internalized = false;\n                                     Visibility::Hidden\n                                 } else if def_id.is_local() {\n-                                    if tcx.is_exported_symbol(def_id) {\n+                                    if tcx.is_reachable_non_generic(def_id) {\n                                         can_be_internalized = false;\n                                         default_visibility(def_id)\n                                     } else {\n@@ -385,7 +385,7 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         (Linkage::External, visibility)\n                     }\n                     MonoItem::Static(def_id) => {\n-                        let visibility = if tcx.is_exported_symbol(def_id) {\n+                        let visibility = if tcx.is_reachable_non_generic(def_id) {\n                             can_be_internalized = false;\n                             default_visibility(def_id)\n                         } else {\n@@ -395,7 +395,7 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     }\n                     MonoItem::GlobalAsm(node_id) => {\n                         let def_id = tcx.hir.local_def_id(node_id);\n-                        let visibility = if tcx.is_exported_symbol(def_id) {\n+                        let visibility = if tcx.is_reachable_non_generic(def_id) {\n                             can_be_internalized = false;\n                             default_visibility(def_id)\n                         } else {"}, {"sha": "3fe667f154372df68eed2eb96efbfdb562b02313", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -768,9 +768,9 @@ fn exported_symbols(tcx: TyCtxt, crate_type: CrateType) -> Vec<String> {\n     let mut symbols = Vec::new();\n \n     let export_threshold = symbol_export::crates_export_threshold(&[crate_type]);\n-    for &(ref name, _, level) in tcx.exported_symbols(LOCAL_CRATE).iter() {\n+    for &(symbol, level) in tcx.exported_symbols(LOCAL_CRATE).iter() {\n         if level.is_below_threshold(export_threshold) {\n-            symbols.push(name.clone());\n+            symbols.push(symbol.symbol_name(tcx).to_string());\n         }\n     }\n \n@@ -782,9 +782,9 @@ fn exported_symbols(tcx: TyCtxt, crate_type: CrateType) -> Vec<String> {\n         // For each dependency that we are linking to statically ...\n         if *dep_format == Linkage::Static {\n             // ... we add its symbol list to our export list.\n-            for &(ref name, _, level) in tcx.exported_symbols(cnum).iter() {\n+            for &(symbol, level) in tcx.exported_symbols(cnum).iter() {\n                 if level.is_below_threshold(export_threshold) {\n-                    symbols.push(name.clone());\n+                    symbols.push(symbol.symbol_name(tcx).to_string());\n                 }\n             }\n         }"}, {"sha": "f79651cef3ec8a58343537ed9390feadf20ce115", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -113,7 +113,7 @@ pub(crate) fn run(cgcx: &CodegenContext,\n         Lto::No => panic!(\"didn't request LTO but we're doing LTO\"),\n     };\n \n-    let symbol_filter = &|&(ref name, _, level): &(String, _, SymbolExportLevel)| {\n+    let symbol_filter = &|&(ref name, level): &(String, SymbolExportLevel)| {\n         if level.is_below_threshold(export_threshold) {\n             let mut bytes = Vec::with_capacity(name.len() + 1);\n             bytes.extend(name.bytes());"}, {"sha": "739ae768ca29ca3b9de94e131c9c47fa99f21b63", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 186, "deletions": 129, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -11,33 +11,27 @@\n use rustc_data_structures::sync::Lrc;\n use std::sync::Arc;\n \n-use base;\n use monomorphize::Instance;\n+use rustc::hir;\n use rustc::hir::def_id::CrateNum;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc::middle::exported_symbols::SymbolExportLevel;\n+use rustc::middle::exported_symbols::{SymbolExportLevel, ExportedSymbol, metadata_symbol_name};\n use rustc::session::config;\n-use rustc::ty::TyCtxt;\n+use rustc::ty::{TyCtxt, SymbolName};\n use rustc::ty::maps::Providers;\n-use rustc::util::nodemap::FxHashMap;\n+use rustc::util::nodemap::{FxHashMap, DefIdSet};\n use rustc_allocator::ALLOCATOR_METHODS;\n use syntax::attr;\n \n pub type ExportedSymbols = FxHashMap<\n     CrateNum,\n-    Arc<Vec<(String, Option<DefId>, SymbolExportLevel)>>,\n+    Arc<Vec<(String, SymbolExportLevel)>>,\n >;\n \n pub fn threshold(tcx: TyCtxt) -> SymbolExportLevel {\n     crates_export_threshold(&tcx.sess.crate_types.borrow())\n }\n \n-pub fn metadata_symbol_name(tcx: TyCtxt) -> String {\n-    format!(\"rust_metadata_{}_{}\",\n-            tcx.crate_name(LOCAL_CRATE),\n-            tcx.crate_disambiguator(LOCAL_CRATE).to_fingerprint().to_hex())\n-}\n-\n fn crate_export_threshold(crate_type: config::CrateType) -> SymbolExportLevel {\n     match crate_type {\n         config::CrateTypeExecutable |\n@@ -60,140 +54,203 @@ pub fn crates_export_threshold(crate_types: &[config::CrateType])\n     }\n }\n \n-pub fn provide(providers: &mut Providers) {\n-    providers.exported_symbol_ids = |tcx, cnum| {\n-        let export_threshold = threshold(tcx);\n-        Lrc::new(tcx.exported_symbols(cnum)\n-            .iter()\n-            .filter_map(|&(_, id, level)| {\n-                id.and_then(|id| {\n-                    if level.is_below_threshold(export_threshold) {\n-                        Some(id)\n+fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                             cnum: CrateNum)\n+                                             -> Lrc<DefIdSet>\n+{\n+    assert_eq!(cnum, LOCAL_CRATE);\n+\n+    if !tcx.sess.opts.output_types.should_trans() {\n+        return Lrc::new(DefIdSet())\n+    }\n+\n+    let export_threshold = threshold(tcx);\n+\n+    // We already collect all potentially reachable non-generic items for\n+    // `exported_symbols`. Now we just filter them down to what is actually\n+    // exported for the given crate we are compiling.\n+    let reachable_non_generics = tcx\n+        .exported_symbols(LOCAL_CRATE)\n+        .iter()\n+        .filter_map(|&(exported_symbol, level)| {\n+            if let ExportedSymbol::NonGeneric(def_id) = exported_symbol {\n+                if level.is_below_threshold(export_threshold) {\n+                    return Some(def_id)\n+                }\n+            }\n+\n+            None\n+        })\n+        .collect();\n+\n+    Lrc::new(reachable_non_generics)\n+}\n+\n+fn is_reachable_non_generic_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                               def_id: DefId)\n+                                               -> bool {\n+    tcx.reachable_non_generics(def_id.krate).contains(&def_id)\n+}\n+\n+fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                             cnum: CrateNum)\n+                                             -> Arc<Vec<(ExportedSymbol,\n+                                                         SymbolExportLevel)>>\n+{\n+    assert_eq!(cnum, LOCAL_CRATE);\n+\n+    if !tcx.sess.opts.output_types.should_trans() {\n+        return Arc::new(vec![])\n+    }\n+\n+    // Check to see if this crate is a \"special runtime crate\". These\n+    // crates, implementation details of the standard library, typically\n+    // have a bunch of `pub extern` and `#[no_mangle]` functions as the\n+    // ABI between them. We don't want their symbols to have a `C`\n+    // export level, however, as they're just implementation details.\n+    // Down below we'll hardwire all of the symbols to the `Rust` export\n+    // level instead.\n+    let special_runtime_crate = tcx.is_panic_runtime(LOCAL_CRATE) ||\n+        tcx.is_compiler_builtins(LOCAL_CRATE);\n+\n+    let reachable_non_generics: DefIdSet = tcx.reachable_set(LOCAL_CRATE).0\n+        .iter()\n+        .filter_map(|&node_id| {\n+            // We want to ignore some FFI functions that are not exposed from\n+            // this crate. Reachable FFI functions can be lumped into two\n+            // categories:\n+            //\n+            // 1. Those that are included statically via a static library\n+            // 2. Those included otherwise (e.g. dynamically or via a framework)\n+            //\n+            // Although our LLVM module is not literally emitting code for the\n+            // statically included symbols, it's an export of our library which\n+            // needs to be passed on to the linker and encoded in the metadata.\n+            //\n+            // As a result, if this id is an FFI item (foreign item) then we only\n+            // let it through if it's included statically.\n+            match tcx.hir.get(node_id) {\n+                hir::map::NodeForeignItem(..) => {\n+                    let def_id = tcx.hir.local_def_id(node_id);\n+                    if tcx.is_statically_included_foreign_item(def_id) {\n+                        Some(def_id)\n                     } else {\n                         None\n                     }\n-                })\n-            })\n-            .collect())\n-    };\n-\n-    providers.is_exported_symbol = |tcx, id| {\n-        tcx.exported_symbol_ids(id.krate).contains(&id)\n-    };\n-\n-    providers.exported_symbols = |tcx, cnum| {\n-        assert_eq!(cnum, LOCAL_CRATE);\n-        let local_exported_symbols = base::find_exported_symbols(tcx);\n-\n-        let mut local_crate: Vec<_> = local_exported_symbols\n-            .iter()\n-            .map(|&node_id| {\n-                tcx.hir.local_def_id(node_id)\n-            })\n-            .map(|def_id| {\n-                let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n-                let export_level = export_level(tcx, def_id);\n-                debug!(\"EXPORTED SYMBOL (local): {} ({:?})\", name, export_level);\n-                (str::to_owned(&name), Some(def_id), export_level)\n-            })\n-            .collect();\n-\n-        if let Some(_) = *tcx.sess.entry_fn.borrow() {\n-            local_crate.push((\"main\".to_string(),\n-                              None,\n-                              SymbolExportLevel::C));\n-        }\n+                }\n+\n+                // Only consider nodes that actually have exported symbols.\n+                hir::map::NodeItem(&hir::Item {\n+                    node: hir::ItemStatic(..),\n+                    ..\n+                }) |\n+                hir::map::NodeItem(&hir::Item {\n+                    node: hir::ItemFn(..), ..\n+                }) |\n+                hir::map::NodeImplItem(&hir::ImplItem {\n+                    node: hir::ImplItemKind::Method(..),\n+                    ..\n+                }) => {\n+                    let def_id = tcx.hir.local_def_id(node_id);\n+                    let generics = tcx.generics_of(def_id);\n+                    if (generics.parent_types == 0 && generics.types.is_empty()) &&\n+                        // Functions marked with #[inline] are only ever translated\n+                        // with \"internal\" linkage and are never exported.\n+                        !Instance::mono(tcx, def_id).def.requires_local(tcx) {\n+                        Some(def_id)\n+                    } else {\n+                        None\n+                    }\n+                }\n \n-        if tcx.sess.allocator_kind.get().is_some() {\n-            for method in ALLOCATOR_METHODS {\n-                local_crate.push((format!(\"__rust_{}\", method.name),\n-                                  None,\n-                                  SymbolExportLevel::Rust));\n+                _ => None\n             }\n-        }\n+        })\n+        .collect();\n \n-        if let Some(id) = tcx.sess.derive_registrar_fn.get() {\n-            let def_id = tcx.hir.local_def_id(id);\n-            let disambiguator = tcx.sess.local_crate_disambiguator();\n-            let registrar = tcx.sess.generate_derive_registrar_symbol(disambiguator);\n-            local_crate.push((registrar, Some(def_id), SymbolExportLevel::C));\n-        }\n+    let mut symbols: Vec<_> = reachable_non_generics\n+        .iter()\n+        .map(|&def_id| {\n+            let export_level = if special_runtime_crate {\n+                let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n+                // We can probably do better here by just ensuring that\n+                // it has hidden visibility rather than public\n+                // visibility, as this is primarily here to ensure it's\n+                // not stripped during LTO.\n+                //\n+                // In general though we won't link right if these\n+                // symbols are stripped, and LTO currently strips them.\n+                if &*name == \"rust_eh_personality\" ||\n+                   &*name == \"rust_eh_register_frames\" ||\n+                   &*name == \"rust_eh_unregister_frames\" {\n+                    SymbolExportLevel::C\n+                } else {\n+                    SymbolExportLevel::Rust\n+                }\n+            } else {\n+                tcx.symbol_export_level(def_id)\n+            };\n+            debug!(\"EXPORTED SYMBOL (local): {} ({:?})\",\n+                   tcx.symbol_name(Instance::mono(tcx, def_id)),\n+                   export_level);\n+            (ExportedSymbol::NonGeneric(def_id), export_level)\n+        })\n+        .collect();\n+\n+    if let Some(id) = tcx.sess.derive_registrar_fn.get() {\n+        let def_id = tcx.hir.local_def_id(id);\n+        symbols.push((ExportedSymbol::NonGeneric(def_id), SymbolExportLevel::C));\n+    }\n+\n+    if let Some(id) = tcx.sess.plugin_registrar_fn.get() {\n+        let def_id = tcx.hir.local_def_id(id);\n+        symbols.push((ExportedSymbol::NonGeneric(def_id), SymbolExportLevel::C));\n+    }\n+\n+    if let Some(_) = *tcx.sess.entry_fn.borrow() {\n+        let symbol_name = \"main\".to_string();\n+        let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(&symbol_name));\n+\n+        symbols.push((exported_symbol, SymbolExportLevel::C));\n+    }\n+\n+    if tcx.sess.allocator_kind.get().is_some() {\n+        for method in ALLOCATOR_METHODS {\n+            let symbol_name = format!(\"__rust_{}\", method.name);\n+            let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(&symbol_name));\n \n-        if tcx.sess.crate_types.borrow().contains(&config::CrateTypeDylib) {\n-            local_crate.push((metadata_symbol_name(tcx),\n-                              None,\n-                              SymbolExportLevel::Rust));\n+            symbols.push((exported_symbol, SymbolExportLevel::Rust));\n         }\n+    }\n+\n+    if tcx.sess.crate_types.borrow().contains(&config::CrateTypeDylib) {\n+        let symbol_name = metadata_symbol_name(tcx);\n+        let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(&symbol_name));\n \n-        // Sort so we get a stable incr. comp. hash.\n-        local_crate.sort_unstable_by(|&(ref name1, ..), &(ref name2, ..)| {\n-            name1.cmp(name2)\n-        });\n+        symbols.push((exported_symbol, SymbolExportLevel::Rust));\n+    }\n \n-        Arc::new(local_crate)\n-    };\n+    // Sort so we get a stable incr. comp. hash.\n+    symbols.sort_unstable_by(|&(ref symbol1, ..), &(ref symbol2, ..)| {\n+        symbol1.compare_stable(tcx, symbol2)\n+    });\n \n-    providers.symbol_export_level = export_level;\n+    Arc::new(symbols)\n }\n \n-pub fn provide_extern(providers: &mut Providers) {\n-    providers.exported_symbols = |tcx, cnum| {\n-        // If this crate is a plugin and/or a custom derive crate, then\n-        // we're not even going to link those in so we skip those crates.\n-        if tcx.plugin_registrar_fn(cnum).is_some() ||\n-           tcx.derive_registrar_fn(cnum).is_some() {\n-            return Arc::new(Vec::new())\n-        }\n+pub fn provide(providers: &mut Providers) {\n+    providers.reachable_non_generics = reachable_non_generics_provider;\n+    providers.is_reachable_non_generic = is_reachable_non_generic_provider;\n+    providers.exported_symbols = exported_symbols_provider_local;\n+    providers.symbol_export_level = symbol_export_level_provider;\n+}\n \n-        // Check to see if this crate is a \"special runtime crate\". These\n-        // crates, implementation details of the standard library, typically\n-        // have a bunch of `pub extern` and `#[no_mangle]` functions as the\n-        // ABI between them. We don't want their symbols to have a `C`\n-        // export level, however, as they're just implementation details.\n-        // Down below we'll hardwire all of the symbols to the `Rust` export\n-        // level instead.\n-        let special_runtime_crate =\n-            tcx.is_panic_runtime(cnum) || tcx.is_compiler_builtins(cnum);\n-\n-        let mut crate_exports: Vec<_> = tcx\n-            .exported_symbol_ids(cnum)\n-            .iter()\n-            .map(|&def_id| {\n-                let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n-                let export_level = if special_runtime_crate {\n-                    // We can probably do better here by just ensuring that\n-                    // it has hidden visibility rather than public\n-                    // visibility, as this is primarily here to ensure it's\n-                    // not stripped during LTO.\n-                    //\n-                    // In general though we won't link right if these\n-                    // symbols are stripped, and LTO currently strips them.\n-                    if &*name == \"rust_eh_personality\" ||\n-                       &*name == \"rust_eh_register_frames\" ||\n-                       &*name == \"rust_eh_unregister_frames\" {\n-                        SymbolExportLevel::C\n-                    } else {\n-                        SymbolExportLevel::Rust\n-                    }\n-                } else {\n-                    export_level(tcx, def_id)\n-                };\n-                debug!(\"EXPORTED SYMBOL (re-export): {} ({:?})\", name, export_level);\n-                (str::to_owned(&name), Some(def_id), export_level)\n-            })\n-            .collect();\n-\n-        // Sort so we get a stable incr. comp. hash.\n-        crate_exports.sort_unstable_by(|&(ref name1, ..), &(ref name2, ..)| {\n-            name1.cmp(name2)\n-        });\n-\n-        Arc::new(crate_exports)\n-    };\n-    providers.symbol_export_level = export_level;\n+pub fn provide_extern(providers: &mut Providers) {\n+    providers.is_reachable_non_generic = is_reachable_non_generic_provider;\n+    providers.symbol_export_level = symbol_export_level_provider;\n }\n \n-fn export_level(tcx: TyCtxt, sym_def_id: DefId) -> SymbolExportLevel {\n+fn symbol_export_level_provider(tcx: TyCtxt, sym_def_id: DefId) -> SymbolExportLevel {\n     // We export anything that's not mangled at the \"C\" layer as it probably has\n     // to do with ABI concerns. We do not, however, apply such treatment to\n     // special symbols in the standard library for various plumbing between"}, {"sha": "c0561ff0c17316e0e411d9d26daf1c2eb247ae4c", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -1332,20 +1332,31 @@ fn start_executing_work(tcx: TyCtxt,\n     let coordinator_send = tcx.tx_to_llvm_workers.clone();\n     let sess = tcx.sess;\n \n-    let exported_symbols = match sess.lto() {\n-        Lto::No => None,\n-        Lto::ThinLocal => {\n-            let mut exported_symbols = FxHashMap();\n-            exported_symbols.insert(LOCAL_CRATE, tcx.exported_symbols(LOCAL_CRATE));\n-            Some(Arc::new(exported_symbols))\n-        }\n-        Lto::Yes | Lto::Fat | Lto::Thin => {\n-            let mut exported_symbols = FxHashMap();\n-            exported_symbols.insert(LOCAL_CRATE, tcx.exported_symbols(LOCAL_CRATE));\n-            for &cnum in tcx.crates().iter() {\n-                exported_symbols.insert(cnum, tcx.exported_symbols(cnum));\n+    // Compute the set of symbols we need to retain when doing LTO (if we need to)\n+    let exported_symbols = {\n+        let mut exported_symbols = FxHashMap();\n+\n+        let copy_symbols = |cnum| {\n+            let symbols = tcx.exported_symbols(cnum)\n+                             .iter()\n+                             .map(|&(s, lvl)| (s.symbol_name(tcx).to_string(), lvl))\n+                             .collect();\n+            Arc::new(symbols)\n+        };\n+\n+        match sess.lto() {\n+            Lto::No => None,\n+            Lto::ThinLocal => {\n+                exported_symbols.insert(LOCAL_CRATE, copy_symbols(LOCAL_CRATE));\n+                Some(Arc::new(exported_symbols))\n+            }\n+            Lto::Yes | Lto::Fat | Lto::Thin => {\n+                exported_symbols.insert(LOCAL_CRATE, copy_symbols(LOCAL_CRATE));\n+                for &cnum in tcx.crates().iter() {\n+                    exported_symbols.insert(cnum, copy_symbols(cnum));\n+                }\n+                Some(Arc::new(exported_symbols))\n             }\n-            Some(Arc::new(exported_symbols))\n         }\n     };\n "}, {"sha": "beb7a091bdcfe29ddd1d4254c4fc65fddf398df4", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -30,7 +30,6 @@ use super::ModuleKind;\n \n use abi;\n use back::link;\n-use back::symbol_export;\n use back::write::{self, OngoingCrateTranslation, create_target_machine};\n use llvm::{ContextRef, ModuleRef, ValueRef, Vector, get_param};\n use llvm;\n@@ -45,6 +44,7 @@ use rustc::ty::maps::Providers;\n use rustc::dep_graph::{DepNode, DepConstructor};\n use rustc::ty::subst::Kind;\n use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n+use rustc::middle::exported_symbols;\n use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, NoDebugInfo};\n use rustc::session::Session;\n@@ -70,7 +70,7 @@ use time_graph;\n use trans_item::{MonoItem, BaseMonoItemExt, MonoItemExt, DefPathBasedNames};\n use type_::Type;\n use type_of::LayoutLlvmExt;\n-use rustc::util::nodemap::{NodeSet, FxHashMap, FxHashSet, DefIdSet};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet, DefIdSet};\n use CrateInfo;\n \n use std::any::Any;\n@@ -89,7 +89,7 @@ use syntax::ast;\n \n use mir::operand::OperandValue;\n \n-pub use rustc_trans_utils::{find_exported_symbols, check_for_rustc_errors_attr};\n+pub use rustc_trans_utils::check_for_rustc_errors_attr;\n pub use rustc_mir::monomorphize::item::linkage_by_name;\n \n pub struct StatRecorder<'a, 'tcx: 'a> {\n@@ -606,8 +606,7 @@ fn contains_null(s: &str) -> bool {\n \n fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n                             llmod_id: &str,\n-                            link_meta: &LinkMeta,\n-                            exported_symbols: &NodeSet)\n+                            link_meta: &LinkMeta)\n                             -> (ContextRef, ModuleRef, EncodedMetadata) {\n     use std::io::Write;\n     use flate2::Compression;\n@@ -643,7 +642,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n                 EncodedMetadata::new());\n     }\n \n-    let metadata = tcx.encode_metadata(link_meta, exported_symbols);\n+    let metadata = tcx.encode_metadata(link_meta);\n     if kind == MetadataKind::Uncompressed {\n         return (metadata_llcx, metadata_llmod, metadata);\n     }\n@@ -655,7 +654,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n \n     let llmeta = C_bytes_in_context(metadata_llcx, &compressed);\n     let llconst = C_struct_in_context(metadata_llcx, &[llmeta], false);\n-    let name = symbol_export::metadata_symbol_name(tcx);\n+    let name = exported_symbols::metadata_symbol_name(tcx);\n     let buf = CString::new(name).unwrap();\n     let llglobal = unsafe {\n         llvm::LLVMAddGlobal(metadata_llmod, val_ty(llconst).to_ref(), buf.as_ptr())\n@@ -718,13 +717,12 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n     let link_meta = link::build_link_meta(crate_hash);\n-    let exported_symbol_node_ids = find_exported_symbols(tcx);\n \n     // Translate the metadata.\n     let llmod_id = \"metadata\";\n     let (metadata_llcx, metadata_llmod, metadata) =\n         time(tcx.sess.time_passes(), \"write metadata\", || {\n-            write_metadata(tcx, llmod_id, &link_meta, &exported_symbol_node_ids)\n+            write_metadata(tcx, llmod_id, &link_meta)\n         });\n \n     let metadata_module = ModuleTranslation {"}, {"sha": "54cc561e8041505065d1eae557cacb52072dec58", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -151,7 +151,7 @@ pub fn get_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n             if cx.tcx.is_translated_item(instance_def_id) {\n                 if instance_def_id.is_local() {\n-                    if !cx.tcx.is_exported_symbol(instance_def_id) {\n+                    if !cx.tcx.is_reachable_non_generic(instance_def_id) {\n                         llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n                     }\n                 } else {"}, {"sha": "fd9cb8c5a6bed38ff33bf598ca72b64ce75cd0f0", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -134,7 +134,7 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n \n                 let g = declare::define_global(cx, &sym[..], llty).unwrap();\n \n-                if !cx.tcx.is_exported_symbol(def_id) {\n+                if !cx.tcx.is_reachable_non_generic(def_id) {\n                     unsafe {\n                         llvm::LLVMRustSetVisibility(g, llvm::Visibility::Hidden);\n                     }"}, {"sha": "0a3f06b55f1e87af8e395c8ce5711e60673407a9", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -32,7 +32,7 @@ pub fn is_node_local_to_unit(cx: &CodegenCx, def_id: DefId) -> bool\n     // visible). It might better to use the `exported_items` set from\n     // `driver::CrateAnalysis` in the future, but (atm) this set is not\n     // available in the translation pass.\n-    !cx.tcx.is_exported_symbol(def_id)\n+    !cx.tcx.is_reachable_non_generic(def_id)\n }\n \n #[allow(non_snake_case)]"}, {"sha": "d636a5f2e64b732cf43c8ff8666974e116308866", "filename": "src/librustc_trans_utils/lib.rs", "status": "modified", "additions": 1, "deletions": 54, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_trans_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_trans_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flib.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -44,11 +44,7 @@ extern crate rustc_data_structures;\n \n pub extern crate rustc as __rustc;\n \n-use rustc::ty::{TyCtxt, Instance};\n-use rustc::hir;\n-use rustc::hir::def_id::LOCAL_CRATE;\n-use rustc::hir::map as hir_map;\n-use rustc::util::nodemap::NodeSet;\n+use rustc::ty::TyCtxt;\n \n pub mod diagnostics;\n pub mod link;\n@@ -70,53 +66,4 @@ pub fn check_for_rustc_errors_attr(tcx: TyCtxt) {\n     }\n }\n \n-/// The context provided lists a set of reachable ids as calculated by\n-/// middle::reachable, but this contains far more ids and symbols than we're\n-/// actually exposing from the object file. This function will filter the set in\n-/// the context to the set of ids which correspond to symbols that are exposed\n-/// from the object file being generated.\n-///\n-/// This list is later used by linkers to determine the set of symbols needed to\n-/// be exposed from a dynamic library and it's also encoded into the metadata.\n-pub fn find_exported_symbols<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> NodeSet {\n-    tcx.reachable_set(LOCAL_CRATE).0.iter().cloned().filter(|&id| {\n-        // Next, we want to ignore some FFI functions that are not exposed from\n-        // this crate. Reachable FFI functions can be lumped into two\n-        // categories:\n-        //\n-        // 1. Those that are included statically via a static library\n-        // 2. Those included otherwise (e.g. dynamically or via a framework)\n-        //\n-        // Although our LLVM module is not literally emitting code for the\n-        // statically included symbols, it's an export of our library which\n-        // needs to be passed on to the linker and encoded in the metadata.\n-        //\n-        // As a result, if this id is an FFI item (foreign item) then we only\n-        // let it through if it's included statically.\n-        match tcx.hir.get(id) {\n-            hir_map::NodeForeignItem(..) => {\n-                let def_id = tcx.hir.local_def_id(id);\n-                tcx.is_statically_included_foreign_item(def_id)\n-            }\n-\n-            // Only consider nodes that actually have exported symbols.\n-            hir_map::NodeItem(&hir::Item {\n-                node: hir::ItemStatic(..), .. }) |\n-            hir_map::NodeItem(&hir::Item {\n-                node: hir::ItemFn(..), .. }) |\n-            hir_map::NodeImplItem(&hir::ImplItem {\n-                node: hir::ImplItemKind::Method(..), .. }) => {\n-                let def_id = tcx.hir.local_def_id(id);\n-                let generics = tcx.generics_of(def_id);\n-                (generics.parent_types == 0 && generics.types.is_empty()) &&\n-                // Functions marked with #[inline] are only ever translated\n-                // with \"internal\" linkage and are never exported.\n-                !Instance::mono(tcx, def_id).def.requires_local(tcx)\n-            }\n-\n-            _ => false\n-        }\n-    }).collect()\n-}\n-\n __build_diagnostic_array! { librustc_trans_utils, DIAGNOSTICS }"}, {"sha": "7b2cbe140aebfbe288a6207630b6c126388fc71f", "filename": "src/librustc_trans_utils/trans_crate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977e044a7485a95852bfce12f1054bcc673355d/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Ftrans_crate.rs?ref=b977e044a7485a95852bfce12f1054bcc673355d", "patch": "@@ -247,8 +247,7 @@ impl TransCrate for MetadataOnlyTransCrate {\n         tcx.sess.abort_if_errors();\n \n         let link_meta = build_link_meta(tcx.crate_hash(LOCAL_CRATE));\n-        let exported_symbols = ::find_exported_symbols(tcx);\n-        let metadata = tcx.encode_metadata(&link_meta, &exported_symbols);\n+        let metadata = tcx.encode_metadata(&link_meta);\n \n         box OngoingCrateTranslation {\n             metadata: metadata,"}]}