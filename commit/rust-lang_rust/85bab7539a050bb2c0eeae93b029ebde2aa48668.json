{"sha": "85bab7539a050bb2c0eeae93b029ebde2aa48668", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1YmFiNzUzOWEwNTBiYjJjMGVlYWU5M2IwMjllYmRlMmFhNDg2Njg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-23T13:37:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-23T13:37:48Z"}, "message": "Merge #8317\n\n8317: Convert tuple struct to named struct assist r=Veykril a=unexge\n\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/8192\n\nCo-authored-by: unexge <unexge@gmail.com>", "tree": {"sha": "3ebc0618f8525327ce83addec3ada6ea120f46be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ebc0618f8525327ce83addec3ada6ea120f46be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85bab7539a050bb2c0eeae93b029ebde2aa48668", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJggs2sCRBK7hj4Ov3rIwAApX4IACSKHEsy2m+tCEj8x5rAC9W0\n7LtIopDplI1RmInDqwiRg3/ZAkZpckLTHjO1+lD+GtXY+V6SWDHIPsR+iq2Vln0r\njRqYr1VxaEWGWCUs/8YWbtIEvBwh94uhAWw5Lg0ObjMSJh9rComldL58BxDuXP/G\nfjmEur2oVossMgpaOU9KvTjGJSNwWbjYwF6pBLWpbz6RHqBedy2BuIDiAwyEXl0b\n+cb8XWBNmXBADkiI6xdcBuFGhlnKH1B3ql4boSRH30LjajdVANFtn/gUHIxk3UCB\n/OmYWPsc03m50D3q/U8slUZzLSgSjNn7RlUGwLnORzqPfatVpAmJgQk4xK3qU4M=\n=PGUQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 3ebc0618f8525327ce83addec3ada6ea120f46be\nparent 07fb65abb83c1e06fbdb8b3616ede59921d70f8c\nparent 5e765895cf6fea42649a846c0297d95a9aa7b162\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1619185068 +0000\ncommitter GitHub <noreply@github.com> 1619185068 +0000\n\nMerge #8317\n\n8317: Convert tuple struct to named struct assist r=Veykril a=unexge\n\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/8192\n\nCo-authored-by: unexge <unexge@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85bab7539a050bb2c0eeae93b029ebde2aa48668", "html_url": "https://github.com/rust-lang/rust/commit/85bab7539a050bb2c0eeae93b029ebde2aa48668", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85bab7539a050bb2c0eeae93b029ebde2aa48668/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07fb65abb83c1e06fbdb8b3616ede59921d70f8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/07fb65abb83c1e06fbdb8b3616ede59921d70f8c", "html_url": "https://github.com/rust-lang/rust/commit/07fb65abb83c1e06fbdb8b3616ede59921d70f8c"}, {"sha": "5e765895cf6fea42649a846c0297d95a9aa7b162", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e765895cf6fea42649a846c0297d95a9aa7b162", "html_url": "https://github.com/rust-lang/rust/commit/5e765895cf6fea42649a846c0297d95a9aa7b162"}], "stats": {"total": 643, "additions": 636, "deletions": 7}, "files": [{"sha": "b5b5ada5e757a609e2b951bfe6b8e0fc952b5a1b", "filename": "crates/ide_assists/src/handlers/convert_tuple_struct_to_named_struct.rs", "status": "added", "additions": 516, "deletions": 0, "changes": 516, "blob_url": "https://github.com/rust-lang/rust/blob/85bab7539a050bb2c0eeae93b029ebde2aa48668/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85bab7539a050bb2c0eeae93b029ebde2aa48668/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs?ref=85bab7539a050bb2c0eeae93b029ebde2aa48668", "patch": "@@ -0,0 +1,516 @@\n+use ide_db::defs::{Definition, NameRefClass};\n+use syntax::{\n+    ast::{self, AstNode, GenericParamsOwner, VisibilityOwner},\n+    match_ast, SyntaxNode,\n+};\n+\n+use crate::{assist_context::AssistBuilder, AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: convert_tuple_struct_to_named_struct\n+//\n+// Converts tuple struct to struct with named fields.\n+//\n+// ```\n+// struct Point$0(f32, f32);\n+//\n+// impl Point {\n+//     pub fn new(x: f32, y: f32) -> Self {\n+//         Point(x, y)\n+//     }\n+//\n+//     pub fn x(&self) -> f32 {\n+//         self.0\n+//     }\n+//\n+//     pub fn y(&self) -> f32 {\n+//         self.1\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// struct Point { field1: f32, field2: f32 }\n+//\n+// impl Point {\n+//     pub fn new(x: f32, y: f32) -> Self {\n+//         Point { field1: x, field2: y }\n+//     }\n+//\n+//     pub fn x(&self) -> f32 {\n+//         self.field1\n+//     }\n+//\n+//     pub fn y(&self) -> f32 {\n+//         self.field2\n+//     }\n+// }\n+// ```\n+pub(crate) fn convert_tuple_struct_to_named_struct(\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n+) -> Option<()> {\n+    let strukt = ctx.find_node_at_offset::<ast::Struct>()?;\n+    let tuple_fields = match strukt.field_list()? {\n+        ast::FieldList::TupleFieldList(it) => it,\n+        ast::FieldList::RecordFieldList(_) => return None,\n+    };\n+    let strukt_def = ctx.sema.to_def(&strukt)?;\n+\n+    let target = strukt.syntax().text_range();\n+    acc.add(\n+        AssistId(\"convert_tuple_struct_to_named_struct\", AssistKind::RefactorRewrite),\n+        \"Convert to named struct\",\n+        target,\n+        |edit| {\n+            let names = generate_names(tuple_fields.fields());\n+            edit_field_references(ctx, edit, tuple_fields.fields(), &names);\n+            edit_struct_references(ctx, edit, strukt_def, &names);\n+            edit_struct_def(ctx, edit, &strukt, tuple_fields, names);\n+        },\n+    )\n+}\n+\n+fn edit_struct_def(\n+    ctx: &AssistContext,\n+    edit: &mut AssistBuilder,\n+    strukt: &ast::Struct,\n+    tuple_fields: ast::TupleFieldList,\n+    names: Vec<ast::Name>,\n+) {\n+    let record_fields = tuple_fields\n+        .fields()\n+        .zip(names)\n+        .filter_map(|(f, name)| Some(ast::make::record_field(f.visibility(), name, f.ty()?)));\n+    let record_fields = ast::make::record_field_list(record_fields);\n+    let tuple_fields_text_range = tuple_fields.syntax().text_range();\n+\n+    edit.edit_file(ctx.frange.file_id);\n+\n+    if let Some(w) = strukt.where_clause() {\n+        edit.delete(w.syntax().text_range());\n+        edit.insert(tuple_fields_text_range.start(), ast::make::tokens::single_newline().text());\n+        edit.insert(tuple_fields_text_range.start(), w.syntax().text());\n+        edit.insert(tuple_fields_text_range.start(), \",\");\n+        edit.insert(tuple_fields_text_range.start(), ast::make::tokens::single_newline().text());\n+    } else {\n+        edit.insert(tuple_fields_text_range.start(), ast::make::tokens::single_space().text());\n+    }\n+\n+    edit.replace(tuple_fields_text_range, record_fields.to_string());\n+    strukt.semicolon_token().map(|t| edit.delete(t.text_range()));\n+}\n+\n+fn edit_struct_references(\n+    ctx: &AssistContext,\n+    edit: &mut AssistBuilder,\n+    strukt: hir::Struct,\n+    names: &[ast::Name],\n+) {\n+    let strukt_def = Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Struct(strukt)));\n+    let usages = strukt_def.usages(&ctx.sema).include_self_kw_refs(true).all();\n+\n+    let edit_node = |edit: &mut AssistBuilder, node: SyntaxNode| -> Option<()> {\n+        match_ast! {\n+            match node {\n+                ast::TupleStructPat(tuple_struct_pat) => {\n+                    edit.replace(\n+                        tuple_struct_pat.syntax().text_range(),\n+                        ast::make::record_pat_with_fields(\n+                            tuple_struct_pat.path()?,\n+                            ast::make::record_pat_field_list(tuple_struct_pat.fields().zip(names).map(\n+                                |(pat, name)| {\n+                                    ast::make::record_pat_field(\n+                                        ast::make::name_ref(&name.to_string()),\n+                                        pat,\n+                                    )\n+                                },\n+                            )),\n+                        )\n+                        .to_string(),\n+                    );\n+                },\n+                // for tuple struct creations like Foo(42)\n+                ast::CallExpr(call_expr) => {\n+                    let path = call_expr.syntax().descendants().find_map(ast::PathExpr::cast).and_then(|expr| expr.path())?;\n+\n+                    // this also includes method calls like Foo::new(42), we should skip them\n+                    if let Some(name_ref) = path.segment().and_then(|s| s.name_ref()) {\n+                        match NameRefClass::classify(&ctx.sema, &name_ref) {\n+                            Some(NameRefClass::Definition(Definition::SelfType(_))) => {},\n+                            Some(NameRefClass::Definition(def)) if def == strukt_def => {},\n+                            _ => return None,\n+                        };\n+                    }\n+\n+                    let arg_list = call_expr.syntax().descendants().find_map(ast::ArgList::cast)?;\n+\n+                    edit.replace(\n+                        call_expr.syntax().text_range(),\n+                        ast::make::record_expr(\n+                            path,\n+                            ast::make::record_expr_field_list(arg_list.args().zip(names).map(\n+                                |(expr, name)| {\n+                                    ast::make::record_expr_field(\n+                                        ast::make::name_ref(&name.to_string()),\n+                                        Some(expr),\n+                                    )\n+                                },\n+                            )),\n+                        )\n+                        .to_string(),\n+                    );\n+                },\n+                _ => return None,\n+            }\n+        }\n+        Some(())\n+    };\n+\n+    for (file_id, refs) in usages {\n+        edit.edit_file(file_id);\n+        for r in refs {\n+            for node in r.name.syntax().ancestors() {\n+                if edit_node(edit, node).is_some() {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn edit_field_references(\n+    ctx: &AssistContext,\n+    edit: &mut AssistBuilder,\n+    fields: impl Iterator<Item = ast::TupleField>,\n+    names: &[ast::Name],\n+) {\n+    for (field, name) in fields.zip(names) {\n+        let field = match ctx.sema.to_def(&field) {\n+            Some(it) => it,\n+            None => continue,\n+        };\n+        let def = Definition::Field(field);\n+        let usages = def.usages(&ctx.sema).all();\n+        for (file_id, refs) in usages {\n+            edit.edit_file(file_id);\n+            for r in refs {\n+                if let Some(name_ref) = r.name.as_name_ref() {\n+                    edit.replace(name_ref.syntax().text_range(), name.text());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn generate_names(fields: impl Iterator<Item = ast::TupleField>) -> Vec<ast::Name> {\n+    fields.enumerate().map(|(i, _)| ast::make::name(&format!(\"field{}\", i + 1))).collect()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn not_applicable_other_than_tuple_struct() {\n+        check_assist_not_applicable(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"struct Foo$0 { bar: u32 };\"#,\n+        );\n+        check_assist_not_applicable(convert_tuple_struct_to_named_struct, r#\"struct Foo$0;\"#);\n+    }\n+\n+    #[test]\n+    fn convert_simple_struct() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+struct Inner;\n+struct A$0(Inner);\n+\n+impl A {\n+    fn new(inner: Inner) -> A {\n+        A(inner)\n+    }\n+\n+    fn new_with_default() -> A {\n+        A::new(Inner)\n+    }\n+\n+    fn into_inner(self) -> Inner {\n+        self.0\n+    }\n+}\"#,\n+            r#\"\n+struct Inner;\n+struct A { field1: Inner }\n+\n+impl A {\n+    fn new(inner: Inner) -> A {\n+        A { field1: inner }\n+    }\n+\n+    fn new_with_default() -> A {\n+        A::new(Inner)\n+    }\n+\n+    fn into_inner(self) -> Inner {\n+        self.field1\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_referenced_via_self_kw() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+struct Inner;\n+struct A$0(Inner);\n+\n+impl A {\n+    fn new(inner: Inner) -> Self {\n+        Self(inner)\n+    }\n+\n+    fn new_with_default() -> Self {\n+        Self::new(Inner)\n+    }\n+\n+    fn into_inner(self) -> Inner {\n+        self.0\n+    }\n+}\"#,\n+            r#\"\n+struct Inner;\n+struct A { field1: Inner }\n+\n+impl A {\n+    fn new(inner: Inner) -> Self {\n+        Self { field1: inner }\n+    }\n+\n+    fn new_with_default() -> Self {\n+        Self::new(Inner)\n+    }\n+\n+    fn into_inner(self) -> Inner {\n+        self.field1\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_destructured_struct() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+struct Inner;\n+struct A$0(Inner);\n+\n+impl A {\n+    fn into_inner(self) -> Inner {\n+        let A(first) = self;\n+        first\n+    }\n+\n+    fn into_inner_via_self(self) -> Inner {\n+        let Self(first) = self;\n+        first\n+    }\n+}\"#,\n+            r#\"\n+struct Inner;\n+struct A { field1: Inner }\n+\n+impl A {\n+    fn into_inner(self) -> Inner {\n+        let A { field1: first } = self;\n+        first\n+    }\n+\n+    fn into_inner_via_self(self) -> Inner {\n+        let Self { field1: first } = self;\n+        first\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_with_visibility() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+struct A$0(pub u32, pub(crate) u64);\n+\n+impl A {\n+    fn new() -> A {\n+        A(42, 42)\n+    }\n+\n+    fn into_first(self) -> u32 {\n+        self.0\n+    }\n+\n+    fn into_second(self) -> u64 {\n+        self.1\n+    }\n+}\"#,\n+            r#\"\n+struct A { pub field1: u32, pub(crate) field2: u64 }\n+\n+impl A {\n+    fn new() -> A {\n+        A { field1: 42, field2: 42 }\n+    }\n+\n+    fn into_first(self) -> u32 {\n+        self.field1\n+    }\n+\n+    fn into_second(self) -> u64 {\n+        self.field2\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_with_wrapped_references() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+struct Inner$0(u32);\n+struct Outer(Inner);\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self(Inner(42))\n+    }\n+\n+    fn into_inner(self) -> u32 {\n+        (self.0).0\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer(Inner(x)) = self;\n+        x\n+    }\n+}\"#,\n+            r#\"\n+struct Inner { field1: u32 }\n+struct Outer(Inner);\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self(Inner { field1: 42 })\n+    }\n+\n+    fn into_inner(self) -> u32 {\n+        (self.0).field1\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer(Inner { field1: x }) = self;\n+        x\n+    }\n+}\"#,\n+        );\n+\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+struct Inner(u32);\n+struct Outer$0(Inner);\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self(Inner(42))\n+    }\n+\n+    fn into_inner(self) -> u32 {\n+        (self.0).0\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer(Inner(x)) = self;\n+        x\n+    }\n+}\"#,\n+            r#\"\n+struct Inner(u32);\n+struct Outer { field1: Inner }\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self { field1: Inner(42) }\n+    }\n+\n+    fn into_inner(self) -> u32 {\n+        (self.field1).0\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer { field1: Inner(x) } = self;\n+        x\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_with_multi_file_references() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+struct A$0(Inner);\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A, Inner};\n+fn f() {\n+    let a = A(Inner);\n+}\n+\"#,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+struct A { field1: Inner }\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A, Inner};\n+fn f() {\n+    let a = A { field1: Inner };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_with_where_clause() {\n+        check_assist(\n+            convert_tuple_struct_to_named_struct,\n+            r#\"\n+struct Wrap$0<T>(T)\n+where\n+    T: Display;\n+\"#,\n+            r#\"\n+struct Wrap<T>\n+where\n+    T: Display,\n+{ field1: T }\n+\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "88ae5c9a935e54f7a593b1153912ef89a1a4c99e", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85bab7539a050bb2c0eeae93b029ebde2aa48668/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85bab7539a050bb2c0eeae93b029ebde2aa48668/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=85bab7539a050bb2c0eeae93b029ebde2aa48668", "patch": "@@ -120,6 +120,7 @@ mod handlers {\n     mod convert_comment_block;\n     mod convert_iter_for_each_to_for;\n     mod convert_into_to_from;\n+    mod convert_tuple_struct_to_named_struct;\n     mod early_return;\n     mod expand_glob_import;\n     mod extract_function;\n@@ -190,6 +191,7 @@ mod handlers {\n             convert_comment_block::convert_comment_block,\n             convert_iter_for_each_to_for::convert_iter_for_each_to_for,\n             convert_into_to_from::convert_into_to_from,\n+            convert_tuple_struct_to_named_struct::convert_tuple_struct_to_named_struct,\n             early_return::convert_to_guarded_return,\n             expand_glob_import::expand_glob_import,\n             extract_struct_from_enum_variant::extract_struct_from_enum_variant,"}, {"sha": "59bcef8fb0bafe2ba115dbebebca3dab3ace7006", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/85bab7539a050bb2c0eeae93b029ebde2aa48668/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85bab7539a050bb2c0eeae93b029ebde2aa48668/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=85bab7539a050bb2c0eeae93b029ebde2aa48668", "patch": "@@ -291,6 +291,47 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_convert_tuple_struct_to_named_struct() {\n+    check_doc_test(\n+        \"convert_tuple_struct_to_named_struct\",\n+        r#####\"\n+struct Point$0(f32, f32);\n+\n+impl Point {\n+    pub fn new(x: f32, y: f32) -> Self {\n+        Point(x, y)\n+    }\n+\n+    pub fn x(&self) -> f32 {\n+        self.0\n+    }\n+\n+    pub fn y(&self) -> f32 {\n+        self.1\n+    }\n+}\n+\"#####,\n+        r#####\"\n+struct Point { field1: f32, field2: f32 }\n+\n+impl Point {\n+    pub fn new(x: f32, y: f32) -> Self {\n+        Point { field1: x, field2: y }\n+    }\n+\n+    pub fn x(&self) -> f32 {\n+        self.field1\n+    }\n+\n+    pub fn y(&self) -> f32 {\n+        self.field2\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_expand_glob_import() {\n     check_doc_test("}, {"sha": "8f899ea56b03e39b9a01d9a25251be627a32cad1", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 51, "deletions": 7, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/85bab7539a050bb2c0eeae93b029ebde2aa48668/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85bab7539a050bb2c0eeae93b029ebde2aa48668/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=85bab7539a050bb2c0eeae93b029ebde2aa48668", "patch": "@@ -7,7 +7,9 @@\n use std::{convert::TryInto, mem};\n \n use base_db::{FileId, FileRange, SourceDatabase, SourceDatabaseExt};\n-use hir::{DefWithBody, HasAttrs, HasSource, InFile, ModuleSource, Semantics, Visibility};\n+use hir::{\n+    DefWithBody, HasAttrs, HasSource, InFile, ModuleDef, ModuleSource, Semantics, Visibility,\n+};\n use once_cell::unsync::Lazy;\n use rustc_hash::FxHashMap;\n use syntax::{ast, match_ast, AstNode, TextRange, TextSize};\n@@ -295,17 +297,23 @@ impl Definition {\n     }\n \n     pub fn usages<'a>(&'a self, sema: &'a Semantics<RootDatabase>) -> FindUsages<'a> {\n-        FindUsages { def: self, sema, scope: None }\n+        FindUsages { def: self, sema, scope: None, include_self_kw_refs: false }\n     }\n }\n \n pub struct FindUsages<'a> {\n     def: &'a Definition,\n     sema: &'a Semantics<'a, RootDatabase>,\n     scope: Option<SearchScope>,\n+    include_self_kw_refs: bool,\n }\n \n impl<'a> FindUsages<'a> {\n+    pub fn include_self_kw_refs(mut self, include: bool) -> FindUsages<'a> {\n+        self.include_self_kw_refs = include;\n+        self\n+    }\n+\n     pub fn in_scope(self, scope: SearchScope) -> FindUsages<'a> {\n         self.set_scope(Some(scope))\n     }\n@@ -352,38 +360,56 @@ impl<'a> FindUsages<'a> {\n         };\n \n         let pat = name.as_str();\n+        let search_for_self = self.include_self_kw_refs;\n+\n         for (file_id, search_range) in search_scope {\n             let text = sema.db.file_text(file_id);\n             let search_range =\n                 search_range.unwrap_or_else(|| TextRange::up_to(TextSize::of(text.as_str())));\n \n             let tree = Lazy::new(|| sema.parse(file_id).syntax().clone());\n \n-            for (idx, _) in text.match_indices(pat) {\n+            let mut handle_match = |idx: usize| -> bool {\n                 let offset: TextSize = idx.try_into().unwrap();\n                 if !search_range.contains_inclusive(offset) {\n-                    continue;\n+                    return false;\n                 }\n \n                 if let Some(name) = sema.find_node_at_offset_with_descend(&tree, offset) {\n                     match name {\n                         ast::NameLike::NameRef(name_ref) => {\n                             if self.found_name_ref(&name_ref, sink) {\n-                                return;\n+                                return true;\n                             }\n                         }\n                         ast::NameLike::Name(name) => {\n                             if self.found_name(&name, sink) {\n-                                return;\n+                                return true;\n                             }\n                         }\n                         ast::NameLike::Lifetime(lifetime) => {\n                             if self.found_lifetime(&lifetime, sink) {\n-                                return;\n+                                return true;\n                             }\n                         }\n                     }\n                 }\n+\n+                return false;\n+            };\n+\n+            for (idx, _) in text.match_indices(pat) {\n+                if handle_match(idx) {\n+                    return;\n+                }\n+            }\n+\n+            if search_for_self {\n+                for (idx, _) in text.match_indices(\"Self\") {\n+                    if handle_match(idx) {\n+                        return;\n+                    }\n+                }\n             }\n         }\n     }\n@@ -422,6 +448,24 @@ impl<'a> FindUsages<'a> {\n                 };\n                 sink(file_id, reference)\n             }\n+            Some(NameRefClass::Definition(Definition::SelfType(impl_))) => {\n+                let ty = impl_.self_ty(self.sema.db);\n+\n+                if let Some(adt) = ty.as_adt() {\n+                    if &Definition::ModuleDef(ModuleDef::Adt(adt)) == self.def {\n+                        let FileRange { file_id, range } =\n+                            self.sema.original_range(name_ref.syntax());\n+                        let reference = FileReference {\n+                            range,\n+                            name: ast::NameLike::NameRef(name_ref.clone()),\n+                            access: None,\n+                        };\n+                        return sink(file_id, reference);\n+                    }\n+                }\n+\n+                false\n+            }\n             Some(NameRefClass::FieldShorthand { local_ref: local, field_ref: field }) => {\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n                 let reference = match self.def {"}, {"sha": "222b7e212b375f1b368231c918d3756f1ff6fef8", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/85bab7539a050bb2c0eeae93b029ebde2aa48668/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85bab7539a050bb2c0eeae93b029ebde2aa48668/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=85bab7539a050bb2c0eeae93b029ebde2aa48668", "patch": "@@ -137,6 +137,17 @@ pub fn use_(visibility: Option<ast::Visibility>, use_tree: ast::UseTree) -> ast:\n     ast_from_text(&format!(\"{}use {};\", visibility, use_tree))\n }\n \n+pub fn record_expr(path: ast::Path, fields: ast::RecordExprFieldList) -> ast::RecordExpr {\n+    ast_from_text(&format!(\"fn f() {{ {} {} }}\", path, fields))\n+}\n+\n+pub fn record_expr_field_list(\n+    fields: impl IntoIterator<Item = ast::RecordExprField>,\n+) -> ast::RecordExprFieldList {\n+    let fields = fields.into_iter().join(\", \");\n+    ast_from_text(&format!(\"fn f() {{ S {{ {} }} }}\", fields))\n+}\n+\n pub fn record_expr_field(name: ast::NameRef, expr: Option<ast::Expr>) -> ast::RecordExprField {\n     return match expr {\n         Some(expr) => from_text(&format!(\"{}: {}\", name, expr)),\n@@ -339,6 +350,21 @@ pub fn record_pat(path: ast::Path, pats: impl IntoIterator<Item = ast::Pat>) ->\n     }\n }\n \n+pub fn record_pat_with_fields(path: ast::Path, fields: ast::RecordPatFieldList) -> ast::RecordPat {\n+    ast_from_text(&format!(\"fn f({} {}: ()))\", path, fields))\n+}\n+\n+pub fn record_pat_field_list(\n+    fields: impl IntoIterator<Item = ast::RecordPatField>,\n+) -> ast::RecordPatFieldList {\n+    let fields = fields.into_iter().join(\", \");\n+    ast_from_text(&format!(\"fn f(S {{ {} }}: ()))\", fields))\n+}\n+\n+pub fn record_pat_field(name_ref: ast::NameRef, pat: ast::Pat) -> ast::RecordPatField {\n+    ast_from_text(&format!(\"fn f(S {{ {}: {} }}: ()))\", name_ref, pat))\n+}\n+\n /// Returns a `BindPat` if the path has just one segment, a `PathPat` otherwise.\n pub fn path_pat(path: ast::Path) -> ast::Pat {\n     return from_text(&path.to_string());"}]}