{"sha": "699315e4f5295f31de3888792733e0459cf5fcdc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5OTMxNWU0ZjUyOTVmMzFkZTM4ODg3OTI3MzNlMDQ1OWNmNWZjZGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-23T11:20:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-23T11:20:51Z"}, "message": "Auto merge of #26519 - oli-obk:camel_case_const_val, r=eddyb", "tree": {"sha": "5232896ea57804c8dc21f100a6f13dd33058e6f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5232896ea57804c8dc21f100a6f13dd33058e6f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/699315e4f5295f31de3888792733e0459cf5fcdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/699315e4f5295f31de3888792733e0459cf5fcdc", "html_url": "https://github.com/rust-lang/rust/commit/699315e4f5295f31de3888792733e0459cf5fcdc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/699315e4f5295f31de3888792733e0459cf5fcdc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ffeb2e32d135b6328999702873a6ffa86a78bc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ffeb2e32d135b6328999702873a6ffa86a78bc9", "html_url": "https://github.com/rust-lang/rust/commit/4ffeb2e32d135b6328999702873a6ffa86a78bc9"}, {"sha": "88b03f349e1c2e33e6c04a5bac9994612d779765", "url": "https://api.github.com/repos/rust-lang/rust/commits/88b03f349e1c2e33e6c04a5bac9994612d779765", "html_url": "https://github.com/rust-lang/rust/commit/88b03f349e1c2e33e6c04a5bac9994612d779765"}], "stats": {"total": 287, "additions": 142, "deletions": 145}, "files": [{"sha": "1ec6e0d6d80d0b6595ce8acc0b1867fdef74714c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/699315e4f5295f31de3888792733e0459cf5fcdc/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/699315e4f5295f31de3888792733e0459cf5fcdc/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=699315e4f5295f31de3888792733e0459cf5fcdc", "patch": "@@ -12,7 +12,7 @@ pub use self::Constructor::*;\n use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n-use middle::const_eval::{compare_const_vals, const_bool, const_float, const_val};\n+use middle::const_eval::{compare_const_vals, ConstVal};\n use middle::const_eval::{eval_const_expr, eval_const_expr_partial};\n use middle::const_eval::{const_expr_to_pat, lookup_const_by_id};\n use middle::def::*;\n@@ -111,9 +111,9 @@ pub enum Constructor {\n     /// Enum variants.\n     Variant(ast::DefId),\n     /// Literal values.\n-    ConstantValue(const_val),\n+    ConstantValue(ConstVal),\n     /// Ranges of literal values (2..5).\n-    ConstantRange(const_val, const_val),\n+    ConstantRange(ConstVal, ConstVal),\n     /// Array patterns of length n.\n     Slice(usize),\n     /// Array patterns with a subslice.\n@@ -262,7 +262,7 @@ fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n     ast_util::walk_pat(pat, |p| {\n         if let ast::PatLit(ref expr) = p.node {\n             match eval_const_expr_partial(cx.tcx, &**expr, None) {\n-                Ok(const_float(f)) if f.is_nan() => {\n+                Ok(ConstVal::Float(f)) if f.is_nan() => {\n                     span_warn!(cx.tcx.sess, p.span, E0003,\n                                \"unmatchable NaN in pattern, \\\n                                 use the is_nan method in a guard instead\");\n@@ -391,9 +391,9 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: ast:\n     }\n }\n \n-fn const_val_to_expr(value: &const_val) -> P<ast::Expr> {\n+fn const_val_to_expr(value: &ConstVal) -> P<ast::Expr> {\n     let node = match value {\n-        &const_bool(b) => ast::LitBool(b),\n+        &ConstVal::Bool(b) => ast::LitBool(b),\n         _ => unreachable!()\n     };\n     P(ast::Expr {\n@@ -596,7 +596,7 @@ fn all_constructors(cx: &MatchCheckCtxt, left_ty: Ty,\n                     max_slice_length: usize) -> Vec<Constructor> {\n     match left_ty.sty {\n         ty::TyBool =>\n-            [true, false].iter().map(|b| ConstantValue(const_bool(*b))).collect(),\n+            [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n \n         ty::TyRef(_, ty::mt { ty, .. }) => match ty.sty {\n             ty::TySlice(_) =>\n@@ -826,7 +826,7 @@ pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usi\n }\n \n fn range_covered_by_constructor(ctor: &Constructor,\n-                                from: &const_val, to: &const_val) -> Option<bool> {\n+                                from: &ConstVal, to: &ConstVal) -> Option<bool> {\n     let (c_from, c_to) = match *ctor {\n         ConstantValue(ref value)        => (value, value),\n         ConstantRange(ref from, ref to) => (from, to),"}, {"sha": "ed06ccf1ec649990b8f82f2942eade35761da25f", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 112, "deletions": 116, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/699315e4f5295f31de3888792733e0459cf5fcdc/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/699315e4f5295f31de3888792733e0459cf5fcdc/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=699315e4f5295f31de3888792733e0459cf5fcdc", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_camel_case_types)]\n #![allow(unsigned_negation)]\n \n-pub use self::const_val::*;\n+use self::ConstVal::*;\n \n use self::ErrKind::*;\n \n@@ -262,15 +262,15 @@ pub fn lookup_const_fn_by_id<'tcx>(tcx: &ty::ctxt<'tcx>, def_id: ast::DefId)\n }\n \n #[derive(Clone, PartialEq)]\n-pub enum const_val {\n-    const_float(f64),\n-    const_int(i64),\n-    const_uint(u64),\n-    const_str(InternedString),\n-    const_binary(Rc<Vec<u8>>),\n-    const_bool(bool),\n+pub enum ConstVal {\n+    Float(f64),\n+    Int(i64),\n+    Uint(u64),\n+    Str(InternedString),\n+    Binary(Rc<Vec<u8>>),\n+    Bool(bool),\n     Struct(ast::NodeId),\n-    Tuple(ast::NodeId)\n+    Tuple(ast::NodeId),\n }\n \n pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat> {\n@@ -330,7 +330,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n     P(ast::Pat { id: expr.id, node: pat, span: span })\n }\n \n-pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n+pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> ConstVal {\n     match eval_const_expr_partial(tcx, e, None) {\n         Ok(r) => r,\n         Err(s) => tcx.sess.span_fatal(s.span, &s.description())\n@@ -433,8 +433,8 @@ impl ConstEvalErr {\n     }\n }\n \n-pub type EvalResult = Result<const_val, ConstEvalErr>;\n-pub type CastResult = Result<const_val, ErrKind>;\n+pub type EvalResult = Result<ConstVal, ConstEvalErr>;\n+pub type CastResult = Result<ConstVal, ErrKind>;\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum IntTy { I8, I16, I32, I64 }\n@@ -514,24 +514,24 @@ pub fn const_int_checked_neg<'a>(\n     if oflo {\n         signal!(e, NegateWithOverflow(a));\n     } else {\n-        Ok(const_int(-a))\n+        Ok(Int(-a))\n     }\n }\n \n pub fn const_uint_checked_neg<'a>(\n     a: u64, _e: &'a Expr, _opt_ety: Option<UintTy>) -> EvalResult {\n     // This always succeeds, and by definition, returns `(!a)+1`.\n-    Ok(const_uint((!a).wrapping_add(1)))\n+    Ok(Uint((!a).wrapping_add(1)))\n }\n \n-fn const_uint_not(a: u64, opt_ety: Option<UintTy>) -> const_val {\n+fn const_uint_not(a: u64, opt_ety: Option<UintTy>) -> ConstVal {\n     let mask = match opt_ety {\n         Some(UintTy::U8) => u8::MAX as u64,\n         Some(UintTy::U16) => u16::MAX as u64,\n         Some(UintTy::U32) => u32::MAX as u64,\n         None | Some(UintTy::U64) => u64::MAX,\n     };\n-    const_uint(!a & mask)\n+    Uint(!a & mask)\n }\n \n macro_rules! overflow_checking_body {\n@@ -623,87 +623,87 @@ macro_rules! pub_fn_checked_op {\n }\n \n pub_fn_checked_op!{ const_int_checked_add(a: i64, b: i64,.. IntTy) {\n-           int_arith_body overflowing_add const_int AddiWithOverflow(a, b)\n+           int_arith_body overflowing_add Int AddiWithOverflow(a, b)\n }}\n \n pub_fn_checked_op!{ const_int_checked_sub(a: i64, b: i64,.. IntTy) {\n-           int_arith_body overflowing_sub const_int SubiWithOverflow(a, b)\n+           int_arith_body overflowing_sub Int SubiWithOverflow(a, b)\n }}\n \n pub_fn_checked_op!{ const_int_checked_mul(a: i64, b: i64,.. IntTy) {\n-           int_arith_body overflowing_mul const_int MuliWithOverflow(a, b)\n+           int_arith_body overflowing_mul Int MuliWithOverflow(a, b)\n }}\n \n pub fn const_int_checked_div<'a>(\n     a: i64, b: i64, e: &'a Expr, opt_ety: Option<IntTy>) -> EvalResult {\n     if b == 0 { signal!(e, DivideByZero); }\n     let (ret, oflo) = int_arith_body!(a, b, opt_ety, overflowing_div);\n-    if !oflo { Ok(const_int(ret)) } else { signal!(e, DivideWithOverflow) }\n+    if !oflo { Ok(Int(ret)) } else { signal!(e, DivideWithOverflow) }\n }\n \n pub fn const_int_checked_rem<'a>(\n     a: i64, b: i64, e: &'a Expr, opt_ety: Option<IntTy>) -> EvalResult {\n     if b == 0 { signal!(e, ModuloByZero); }\n     let (ret, oflo) = int_arith_body!(a, b, opt_ety, overflowing_rem);\n-    if !oflo { Ok(const_int(ret)) } else { signal!(e, ModuloWithOverflow) }\n+    if !oflo { Ok(Int(ret)) } else { signal!(e, ModuloWithOverflow) }\n }\n \n pub_fn_checked_op!{ const_int_checked_shl(a: i64, b: i64,.. IntTy) {\n-           int_shift_body overflowing_shl const_int ShiftLeftWithOverflow\n+           int_shift_body overflowing_shl Int ShiftLeftWithOverflow\n }}\n \n pub_fn_checked_op!{ const_int_checked_shl_via_uint(a: i64, b: u64,.. IntTy) {\n-           int_shift_body overflowing_shl const_int ShiftLeftWithOverflow\n+           int_shift_body overflowing_shl Int ShiftLeftWithOverflow\n }}\n \n pub_fn_checked_op!{ const_int_checked_shr(a: i64, b: i64,.. IntTy) {\n-           int_shift_body overflowing_shr const_int ShiftRightWithOverflow\n+           int_shift_body overflowing_shr Int ShiftRightWithOverflow\n }}\n \n pub_fn_checked_op!{ const_int_checked_shr_via_uint(a: i64, b: u64,.. IntTy) {\n-           int_shift_body overflowing_shr const_int ShiftRightWithOverflow\n+           int_shift_body overflowing_shr Int ShiftRightWithOverflow\n }}\n \n pub_fn_checked_op!{ const_uint_checked_add(a: u64, b: u64,.. UintTy) {\n-           uint_arith_body overflowing_add const_uint AdduWithOverflow(a, b)\n+           uint_arith_body overflowing_add Uint AdduWithOverflow(a, b)\n }}\n \n pub_fn_checked_op!{ const_uint_checked_sub(a: u64, b: u64,.. UintTy) {\n-           uint_arith_body overflowing_sub const_uint SubuWithOverflow(a, b)\n+           uint_arith_body overflowing_sub Uint SubuWithOverflow(a, b)\n }}\n \n pub_fn_checked_op!{ const_uint_checked_mul(a: u64, b: u64,.. UintTy) {\n-           uint_arith_body overflowing_mul const_uint MuluWithOverflow(a, b)\n+           uint_arith_body overflowing_mul Uint MuluWithOverflow(a, b)\n }}\n \n pub fn const_uint_checked_div<'a>(\n     a: u64, b: u64, e: &'a Expr, opt_ety: Option<UintTy>) -> EvalResult {\n     if b == 0 { signal!(e, DivideByZero); }\n     let (ret, oflo) = uint_arith_body!(a, b, opt_ety, overflowing_div);\n-    if !oflo { Ok(const_uint(ret)) } else { signal!(e, DivideWithOverflow) }\n+    if !oflo { Ok(Uint(ret)) } else { signal!(e, DivideWithOverflow) }\n }\n \n pub fn const_uint_checked_rem<'a>(\n     a: u64, b: u64, e: &'a Expr, opt_ety: Option<UintTy>) -> EvalResult {\n     if b == 0 { signal!(e, ModuloByZero); }\n     let (ret, oflo) = uint_arith_body!(a, b, opt_ety, overflowing_rem);\n-    if !oflo { Ok(const_uint(ret)) } else { signal!(e, ModuloWithOverflow) }\n+    if !oflo { Ok(Uint(ret)) } else { signal!(e, ModuloWithOverflow) }\n }\n \n pub_fn_checked_op!{ const_uint_checked_shl(a: u64, b: u64,.. UintTy) {\n-           uint_shift_body overflowing_shl const_uint ShiftLeftWithOverflow\n+           uint_shift_body overflowing_shl Uint ShiftLeftWithOverflow\n }}\n \n pub_fn_checked_op!{ const_uint_checked_shl_via_int(a: u64, b: i64,.. UintTy) {\n-           uint_shift_body overflowing_shl const_uint ShiftLeftWithOverflow\n+           uint_shift_body overflowing_shl Uint ShiftLeftWithOverflow\n }}\n \n pub_fn_checked_op!{ const_uint_checked_shr(a: u64, b: u64,.. UintTy) {\n-           uint_shift_body overflowing_shr const_uint ShiftRightWithOverflow\n+           uint_shift_body overflowing_shr Uint ShiftRightWithOverflow\n }}\n \n pub_fn_checked_op!{ const_uint_checked_shr_via_int(a: u64, b: i64,.. UintTy) {\n-           uint_shift_body overflowing_shr const_uint ShiftRightWithOverflow\n+           uint_shift_body overflowing_shr Uint ShiftRightWithOverflow\n }}\n \n // After type checking, `eval_const_expr_partial` should always suffice. The\n@@ -723,7 +723,7 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n                                             ty_hint: Option<Ty<'tcx>>,\n                                             get_substs: S) -> EvalResult\n         where S: Fn(ast::NodeId) -> subst::Substs<'tcx> {\n-    fn fromb(b: bool) -> const_val { const_int(b as i64) }\n+    fn fromb(b: bool) -> ConstVal { Int(b as i64) }\n \n     let ety = ty_hint.or_else(|| ty::expr_ty_opt(tcx, e));\n \n@@ -742,9 +742,9 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n     let result = match e.node {\n       ast::ExprUnary(ast::UnNeg, ref inner) => {\n         match try!(eval_const_expr_partial(tcx, &**inner, ety)) {\n-          const_float(f) => const_float(-f),\n-          const_int(n) =>  try!(const_int_checked_neg(n, e, expr_int_type)),\n-          const_uint(i) => {\n+          Float(f) => Float(-f),\n+          Int(n) =>  try!(const_int_checked_neg(n, e, expr_int_type)),\n+          Uint(i) => {\n               if !tcx.sess.features.borrow().negate_unsigned {\n                   feature_gate::emit_feature_err(\n                       &tcx.sess.parse_sess.span_diagnostic,\n@@ -754,23 +754,23 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n               }\n               try!(const_uint_checked_neg(i, e, expr_uint_type))\n           }\n-          const_str(_) => signal!(e, NegateOnString),\n-          const_bool(_) => signal!(e, NegateOnBoolean),\n-          const_binary(_) => signal!(e, NegateOnBinary),\n-          const_val::Tuple(_) => signal!(e, NegateOnTuple),\n-          const_val::Struct(..) => signal!(e, NegateOnStruct),\n+          Str(_) => signal!(e, NegateOnString),\n+          Bool(_) => signal!(e, NegateOnBoolean),\n+          Binary(_) => signal!(e, NegateOnBinary),\n+          Tuple(_) => signal!(e, NegateOnTuple),\n+          Struct(..) => signal!(e, NegateOnStruct),\n         }\n       }\n       ast::ExprUnary(ast::UnNot, ref inner) => {\n         match try!(eval_const_expr_partial(tcx, &**inner, ety)) {\n-          const_int(i) => const_int(!i),\n-          const_uint(i) => const_uint_not(i, expr_uint_type),\n-          const_bool(b) => const_bool(!b),\n-          const_str(_) => signal!(e, NotOnString),\n-          const_float(_) => signal!(e, NotOnFloat),\n-          const_binary(_) => signal!(e, NotOnBinary),\n-          const_val::Tuple(_) => signal!(e, NotOnTuple),\n-          const_val::Struct(..) => signal!(e, NotOnStruct),\n+          Int(i) => Int(!i),\n+          Uint(i) => const_uint_not(i, expr_uint_type),\n+          Bool(b) => Bool(!b),\n+          Str(_) => signal!(e, NotOnString),\n+          Float(_) => signal!(e, NotOnFloat),\n+          Binary(_) => signal!(e, NotOnBinary),\n+          Tuple(_) => signal!(e, NotOnTuple),\n+          Struct(..) => signal!(e, NotOnStruct),\n         }\n       }\n       ast::ExprBinary(op, ref a, ref b) => {\n@@ -780,13 +780,13 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n         };\n         match (try!(eval_const_expr_partial(tcx, &**a, ety)),\n                try!(eval_const_expr_partial(tcx, &**b, b_ty))) {\n-          (const_float(a), const_float(b)) => {\n+          (Float(a), Float(b)) => {\n             match op.node {\n-              ast::BiAdd => const_float(a + b),\n-              ast::BiSub => const_float(a - b),\n-              ast::BiMul => const_float(a * b),\n-              ast::BiDiv => const_float(a / b),\n-              ast::BiRem => const_float(a % b),\n+              ast::BiAdd => Float(a + b),\n+              ast::BiSub => Float(a - b),\n+              ast::BiMul => Float(a * b),\n+              ast::BiDiv => Float(a / b),\n+              ast::BiRem => Float(a % b),\n               ast::BiEq => fromb(a == b),\n               ast::BiLt => fromb(a < b),\n               ast::BiLe => fromb(a <= b),\n@@ -796,16 +796,16 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n               _ => signal!(e, InvalidOpForFloats(op.node))\n             }\n           }\n-          (const_int(a), const_int(b)) => {\n+          (Int(a), Int(b)) => {\n             match op.node {\n               ast::BiAdd => try!(const_int_checked_add(a,b,e,expr_int_type)),\n               ast::BiSub => try!(const_int_checked_sub(a,b,e,expr_int_type)),\n               ast::BiMul => try!(const_int_checked_mul(a,b,e,expr_int_type)),\n               ast::BiDiv => try!(const_int_checked_div(a,b,e,expr_int_type)),\n               ast::BiRem => try!(const_int_checked_rem(a,b,e,expr_int_type)),\n-              ast::BiAnd | ast::BiBitAnd => const_int(a & b),\n-              ast::BiOr | ast::BiBitOr => const_int(a | b),\n-              ast::BiBitXor => const_int(a ^ b),\n+              ast::BiAnd | ast::BiBitAnd => Int(a & b),\n+              ast::BiOr | ast::BiBitOr => Int(a | b),\n+              ast::BiBitXor => Int(a ^ b),\n               ast::BiShl => try!(const_int_checked_shl(a,b,e,expr_int_type)),\n               ast::BiShr => try!(const_int_checked_shr(a,b,e,expr_int_type)),\n               ast::BiEq => fromb(a == b),\n@@ -816,16 +816,16 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n               ast::BiGt => fromb(a > b)\n             }\n           }\n-          (const_uint(a), const_uint(b)) => {\n+          (Uint(a), Uint(b)) => {\n             match op.node {\n               ast::BiAdd => try!(const_uint_checked_add(a,b,e,expr_uint_type)),\n               ast::BiSub => try!(const_uint_checked_sub(a,b,e,expr_uint_type)),\n               ast::BiMul => try!(const_uint_checked_mul(a,b,e,expr_uint_type)),\n               ast::BiDiv => try!(const_uint_checked_div(a,b,e,expr_uint_type)),\n               ast::BiRem => try!(const_uint_checked_rem(a,b,e,expr_uint_type)),\n-              ast::BiAnd | ast::BiBitAnd => const_uint(a & b),\n-              ast::BiOr | ast::BiBitOr => const_uint(a | b),\n-              ast::BiBitXor => const_uint(a ^ b),\n+              ast::BiAnd | ast::BiBitAnd => Uint(a & b),\n+              ast::BiOr | ast::BiBitOr => Uint(a | b),\n+              ast::BiBitXor => Uint(a ^ b),\n               ast::BiShl => try!(const_uint_checked_shl(a,b,e,expr_uint_type)),\n               ast::BiShr => try!(const_uint_checked_shr(a,b,e,expr_uint_type)),\n               ast::BiEq => fromb(a == b),\n@@ -837,22 +837,22 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n             }\n           }\n           // shifts can have any integral type as their rhs\n-          (const_int(a), const_uint(b)) => {\n+          (Int(a), Uint(b)) => {\n             match op.node {\n               ast::BiShl => try!(const_int_checked_shl_via_uint(a,b,e,expr_int_type)),\n               ast::BiShr => try!(const_int_checked_shr_via_uint(a,b,e,expr_int_type)),\n               _ => signal!(e, InvalidOpForIntUint(op.node)),\n             }\n           }\n-          (const_uint(a), const_int(b)) => {\n+          (Uint(a), Int(b)) => {\n             match op.node {\n               ast::BiShl => try!(const_uint_checked_shl_via_int(a,b,e,expr_uint_type)),\n               ast::BiShr => try!(const_uint_checked_shr_via_int(a,b,e,expr_uint_type)),\n               _ => signal!(e, InvalidOpForUintInt(op.node)),\n             }\n           }\n-          (const_bool(a), const_bool(b)) => {\n-            const_bool(match op.node {\n+          (Bool(a), Bool(b)) => {\n+            Bool(match op.node {\n               ast::BiAnd => a && b,\n               ast::BiOr => a || b,\n               ast::BiBitXor => a ^ b,\n@@ -957,18 +957,14 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n       ast::ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => try!(eval_const_expr_partial(tcx, &**expr, ety)),\n-            None => const_int(0)\n+            None => Int(0)\n         }\n       }\n-      ast::ExprTup(_) => {\n-        const_val::Tuple(e.id)\n-      }\n-      ast::ExprStruct(..) => {\n-        const_val::Struct(e.id)\n-      }\n+      ast::ExprTup(_) => Tuple(e.id),\n+      ast::ExprStruct(..) => Struct(e.id),\n       ast::ExprTupField(ref base, index) => {\n         if let Ok(c) = eval_const_expr_partial(tcx, base, None) {\n-            if let const_val::Tuple(tup_id) = c {\n+            if let Tuple(tup_id) = c {\n                 if let ast::ExprTup(ref fields) = tcx.map.expect_expr(tup_id).node {\n                     if index.node < fields.len() {\n                         return eval_const_expr_partial(tcx, &fields[index.node], None)\n@@ -988,7 +984,7 @@ pub fn eval_const_expr_with_substs<'tcx, S>(tcx: &ty::ctxt<'tcx>,\n       ast::ExprField(ref base, field_name) => {\n         // Get the base expression if it is a struct and it is constant\n         if let Ok(c) = eval_const_expr_partial(tcx, base, None) {\n-            if let const_val::Struct(struct_id) = c {\n+            if let Struct(struct_id) = c {\n                 if let ast::ExprStruct(_, ref fields, _) = tcx.map.expect_expr(struct_id).node {\n                     // Check that the given field exists and evaluate it\n                     if let Some(f) = fields.iter().find(|f| f.ident.node.as_str()\n@@ -1077,27 +1073,27 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n     }\n }\n \n-fn cast_const<'tcx>(tcx: &ty::ctxt<'tcx>, val: const_val, ty: Ty) -> CastResult {\n+fn cast_const<'tcx>(tcx: &ty::ctxt<'tcx>, val: ConstVal, ty: Ty) -> CastResult {\n     macro_rules! convert_val {\n         ($intermediate_ty:ty, $const_type:ident, $target_ty:ty) => {\n             match val {\n-                const_bool(b) => Ok($const_type(b as u64 as $intermediate_ty as $target_ty)),\n-                const_uint(u) => Ok($const_type(u as $intermediate_ty as $target_ty)),\n-                const_int(i) => Ok($const_type(i as $intermediate_ty as $target_ty)),\n-                const_float(f) => Ok($const_type(f as $intermediate_ty as $target_ty)),\n+                Bool(b) => Ok($const_type(b as u64 as $intermediate_ty as $target_ty)),\n+                Uint(u) => Ok($const_type(u as $intermediate_ty as $target_ty)),\n+                Int(i) => Ok($const_type(i as $intermediate_ty as $target_ty)),\n+                Float(f) => Ok($const_type(f as $intermediate_ty as $target_ty)),\n                 _ => Err(ErrKind::CannotCastTo(stringify!($const_type))),\n             }\n         }\n     }\n \n     // Issue #23890: If isize/usize, then dispatch to appropriate target representation type\n     match (&ty.sty, tcx.sess.target.int_type, tcx.sess.target.uint_type) {\n-        (&ty::TyInt(ast::TyIs), ast::TyI32, _) => return convert_val!(i32, const_int, i64),\n-        (&ty::TyInt(ast::TyIs), ast::TyI64, _) => return convert_val!(i64, const_int, i64),\n+        (&ty::TyInt(ast::TyIs), ast::TyI32, _) => return convert_val!(i32, Int, i64),\n+        (&ty::TyInt(ast::TyIs), ast::TyI64, _) => return convert_val!(i64, Int, i64),\n         (&ty::TyInt(ast::TyIs), _, _) => panic!(\"unexpected target.int_type\"),\n \n-        (&ty::TyUint(ast::TyUs), _, ast::TyU32) => return convert_val!(u32, const_uint, u64),\n-        (&ty::TyUint(ast::TyUs), _, ast::TyU64) => return convert_val!(u64, const_uint, u64),\n+        (&ty::TyUint(ast::TyUs), _, ast::TyU32) => return convert_val!(u32, Uint, u64),\n+        (&ty::TyUint(ast::TyUs), _, ast::TyU64) => return convert_val!(u64, Uint, u64),\n         (&ty::TyUint(ast::TyUs), _, _) => panic!(\"unexpected target.uint_type\"),\n \n         _ => {}\n@@ -1107,53 +1103,53 @@ fn cast_const<'tcx>(tcx: &ty::ctxt<'tcx>, val: const_val, ty: Ty) -> CastResult\n         ty::TyInt(ast::TyIs) => unreachable!(),\n         ty::TyUint(ast::TyUs) => unreachable!(),\n \n-        ty::TyInt(ast::TyI8) => convert_val!(i8, const_int, i64),\n-        ty::TyInt(ast::TyI16) => convert_val!(i16, const_int, i64),\n-        ty::TyInt(ast::TyI32) => convert_val!(i32, const_int, i64),\n-        ty::TyInt(ast::TyI64) => convert_val!(i64, const_int, i64),\n+        ty::TyInt(ast::TyI8) => convert_val!(i8, Int, i64),\n+        ty::TyInt(ast::TyI16) => convert_val!(i16, Int, i64),\n+        ty::TyInt(ast::TyI32) => convert_val!(i32, Int, i64),\n+        ty::TyInt(ast::TyI64) => convert_val!(i64, Int, i64),\n \n-        ty::TyUint(ast::TyU8) => convert_val!(u8, const_uint, u64),\n-        ty::TyUint(ast::TyU16) => convert_val!(u16, const_uint, u64),\n-        ty::TyUint(ast::TyU32) => convert_val!(u32, const_uint, u64),\n-        ty::TyUint(ast::TyU64) => convert_val!(u64, const_uint, u64),\n+        ty::TyUint(ast::TyU8) => convert_val!(u8, Uint, u64),\n+        ty::TyUint(ast::TyU16) => convert_val!(u16, Uint, u64),\n+        ty::TyUint(ast::TyU32) => convert_val!(u32, Uint, u64),\n+        ty::TyUint(ast::TyU64) => convert_val!(u64, Uint, u64),\n \n-        ty::TyFloat(ast::TyF32) => convert_val!(f32, const_float, f64),\n-        ty::TyFloat(ast::TyF64) => convert_val!(f64, const_float, f64),\n+        ty::TyFloat(ast::TyF32) => convert_val!(f32, Float, f64),\n+        ty::TyFloat(ast::TyF64) => convert_val!(f64, Float, f64),\n         _ => Err(ErrKind::CannotCast),\n     }\n }\n \n-fn lit_to_const(lit: &ast::Lit, ty_hint: Option<Ty>) -> const_val {\n+fn lit_to_const(lit: &ast::Lit, ty_hint: Option<Ty>) -> ConstVal {\n     match lit.node {\n-        ast::LitStr(ref s, _) => const_str((*s).clone()),\n+        ast::LitStr(ref s, _) => Str((*s).clone()),\n         ast::LitBinary(ref data) => {\n-            const_binary(data.clone())\n+            Binary(data.clone())\n         }\n-        ast::LitByte(n) => const_uint(n as u64),\n-        ast::LitChar(n) => const_uint(n as u64),\n-        ast::LitInt(n, ast::SignedIntLit(_, ast::Plus)) => const_int(n as i64),\n+        ast::LitByte(n) => Uint(n as u64),\n+        ast::LitChar(n) => Uint(n as u64),\n+        ast::LitInt(n, ast::SignedIntLit(_, ast::Plus)) => Int(n as i64),\n         ast::LitInt(n, ast::UnsuffixedIntLit(ast::Plus)) => {\n             match ty_hint.map(|ty| &ty.sty) {\n-                Some(&ty::TyUint(_)) => const_uint(n),\n-                _ => const_int(n as i64)\n+                Some(&ty::TyUint(_)) => Uint(n),\n+                _ => Int(n as i64)\n             }\n         }\n         ast::LitInt(n, ast::SignedIntLit(_, ast::Minus)) |\n-        ast::LitInt(n, ast::UnsuffixedIntLit(ast::Minus)) => const_int(-(n as i64)),\n-        ast::LitInt(n, ast::UnsignedIntLit(_)) => const_uint(n),\n+        ast::LitInt(n, ast::UnsuffixedIntLit(ast::Minus)) => Int(-(n as i64)),\n+        ast::LitInt(n, ast::UnsignedIntLit(_)) => Uint(n),\n         ast::LitFloat(ref n, _) |\n         ast::LitFloatUnsuffixed(ref n) => {\n-            const_float(n.parse::<f64>().unwrap() as f64)\n+            Float(n.parse::<f64>().unwrap() as f64)\n         }\n-        ast::LitBool(b) => const_bool(b)\n+        ast::LitBool(b) => Bool(b)\n     }\n }\n \n-pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<Ordering> {\n+pub fn compare_const_vals(a: &ConstVal, b: &ConstVal) -> Option<Ordering> {\n     Some(match (a, b) {\n-        (&const_int(a), &const_int(b)) => a.cmp(&b),\n-        (&const_uint(a), &const_uint(b)) => a.cmp(&b),\n-        (&const_float(a), &const_float(b)) => {\n+        (&Int(a), &Int(b)) => a.cmp(&b),\n+        (&Uint(a), &Uint(b)) => a.cmp(&b),\n+        (&Float(a), &Float(b)) => {\n             // This is pretty bad but it is the existing behavior.\n             if a == b {\n                 Ordering::Equal\n@@ -1163,9 +1159,9 @@ pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<Ordering> {\n                 Ordering::Greater\n             }\n         }\n-        (&const_str(ref a), &const_str(ref b)) => a.cmp(b),\n-        (&const_bool(a), &const_bool(b)) => a.cmp(&b),\n-        (&const_binary(ref a), &const_binary(ref b)) => a.cmp(b),\n+        (&Str(ref a), &Str(ref b)) => a.cmp(b),\n+        (&Bool(a), &Bool(b)) => a.cmp(&b),\n+        (&Binary(ref a), &Binary(ref b)) => a.cmp(b),\n         _ => return None\n     })\n }"}, {"sha": "53851d0f2a4e871e1f4ecb49e68f24060f91885a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/699315e4f5295f31de3888792733e0459cf5fcdc/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/699315e4f5295f31de3888792733e0459cf5fcdc/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=699315e4f5295f31de3888792733e0459cf5fcdc", "patch": "@@ -46,7 +46,7 @@ use metadata::csearch;\n use middle;\n use middle::cast;\n use middle::check_const;\n-use middle::const_eval;\n+use middle::const_eval::{self, ConstVal};\n use middle::def::{self, DefMap, ExportMap};\n use middle::dependency_format;\n use middle::fast_reject;\n@@ -6026,8 +6026,8 @@ fn compute_enum_variants<'tcx>(cx: &ctxt<'tcx>,\n                 // more robust (on case-by-case basis).\n \n                 match const_eval::eval_const_expr_partial(cx, &**e, Some(repr_type_ty)) {\n-                    Ok(const_eval::const_int(val)) => current_disr_val = val as Disr,\n-                    Ok(const_eval::const_uint(val)) => current_disr_val = val as Disr,\n+                    Ok(ConstVal::Int(val)) => current_disr_val = val as Disr,\n+                    Ok(ConstVal::Uint(val)) => current_disr_val = val as Disr,\n                     Ok(_) => {\n                         let sign_desc = if repr_type.is_signed() { \"signed\" } else { \"unsigned\" };\n                         span_err!(cx.sess, e.span, E0079,\n@@ -6400,15 +6400,15 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> usize {\n     match const_eval::eval_const_expr_partial(tcx, count_expr, Some(tcx.types.usize)) {\n         Ok(val) => {\n             let found = match val {\n-                const_eval::const_uint(count) => return count as usize,\n-                const_eval::const_int(count) if count >= 0 => return count as usize,\n-                const_eval::const_int(_) => \"negative integer\",\n-                const_eval::const_float(_) => \"float\",\n-                const_eval::const_str(_) => \"string\",\n-                const_eval::const_bool(_) => \"boolean\",\n-                const_eval::const_binary(_) => \"binary array\",\n-                const_eval::Struct(..) => \"struct\",\n-                const_eval::Tuple(_) => \"tuple\"\n+                ConstVal::Uint(count) => return count as usize,\n+                ConstVal::Int(count) if count >= 0 => return count as usize,\n+                ConstVal::Int(_) => \"negative integer\",\n+                ConstVal::Float(_) => \"float\",\n+                ConstVal::Str(_) => \"string\",\n+                ConstVal::Bool(_) => \"boolean\",\n+                ConstVal::Binary(_) => \"binary array\",\n+                ConstVal::Struct(..) => \"struct\",\n+                ConstVal::Tuple(_) => \"tuple\"\n             };\n             span_err!(tcx.sess, count_expr.span, E0306,\n                 \"expected positive integer for repeat count, found {}\","}, {"sha": "ffb860283dd7e01b85aa511561889138c06eef2e", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/699315e4f5295f31de3888792733e0459cf5fcdc/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/699315e4f5295f31de3888792733e0459cf5fcdc/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=699315e4f5295f31de3888792733e0459cf5fcdc", "patch": "@@ -33,7 +33,7 @@ use middle::def::*;\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use middle::{def, pat_util, stability};\n-use middle::const_eval::{eval_const_expr_partial, const_int, const_uint};\n+use middle::const_eval::{eval_const_expr_partial, ConstVal};\n use middle::cfg;\n use rustc::ast_map;\n use util::nodemap::{FnvHashMap, NodeSet};\n@@ -180,8 +180,8 @@ impl LintPass for TypeLimits {\n                             else { false }\n                         } else {\n                             match eval_const_expr_partial(cx.tcx, &**r, Some(cx.tcx.types.usize)) {\n-                                Ok(const_int(shift)) => { shift as u64 >= bits },\n-                                Ok(const_uint(shift)) => { shift >= bits },\n+                                Ok(ConstVal::Int(shift)) => { shift as u64 >= bits },\n+                                Ok(ConstVal::Uint(shift)) => { shift >= bits },\n                                 _ => { false }\n                             }\n                         };"}, {"sha": "7fbc86d7a8a3efaa334f90e844054999f059075a", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/699315e4f5295f31de3888792733e0459cf5fcdc/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/699315e4f5295f31de3888792733e0459cf5fcdc/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=699315e4f5295f31de3888792733e0459cf5fcdc", "patch": "@@ -13,7 +13,8 @@ use back::abi;\n use llvm;\n use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n use llvm::{InternalLinkage, ValueRef, Bool, True};\n-use middle::{check_const, const_eval, def};\n+use middle::{check_const, def};\n+use middle::const_eval::{self, ConstVal};\n use middle::const_eval::{const_int_checked_neg, const_uint_checked_neg};\n use middle::const_eval::{const_int_checked_add, const_uint_checked_add};\n use middle::const_eval::{const_int_checked_sub, const_uint_checked_sub};\n@@ -602,8 +603,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           ast::ExprIndex(ref base, ref index) => {\n               let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n               let iv = match const_eval::eval_const_expr_partial(cx.tcx(), &**index, None) {\n-                  Ok(const_eval::const_int(i)) => i as u64,\n-                  Ok(const_eval::const_uint(u)) => u,\n+                  Ok(ConstVal::Int(i)) => i as u64,\n+                  Ok(ConstVal::Uint(u)) => u,\n                   _ => cx.sess().span_bug(index.span,\n                                           \"index is not an integer-constant expression\")\n               };"}, {"sha": "5e434eae2b4ab359c16d996e5d02dd9eb3583005", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/699315e4f5295f31de3888792733e0459cf5fcdc/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/699315e4f5295f31de3888792733e0459cf5fcdc/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=699315e4f5295f31de3888792733e0459cf5fcdc", "patch": "@@ -49,7 +49,7 @@\n //! an rptr (`&r.T`) use the region `r` that appears in the rptr.\n \n use middle::astconv_util::{prim_ty_to_ty, check_path_args, NO_TPS, NO_REGIONS};\n-use middle::const_eval;\n+use middle::const_eval::{self, ConstVal};\n use middle::def;\n use middle::implicator::object_region_bounds;\n use middle::resolve_lifetime as rl;\n@@ -1601,10 +1601,10 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n             match const_eval::eval_const_expr_partial(tcx, &**e, Some(tcx.types.usize)) {\n                 Ok(r) => {\n                     match r {\n-                        const_eval::const_int(i) =>\n+                        ConstVal::Int(i) =>\n                             ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n                                         Some(i as usize)),\n-                        const_eval::const_uint(i) =>\n+                        ConstVal::Uint(i) =>\n                             ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n                                         Some(i as usize)),\n                         _ => {"}]}