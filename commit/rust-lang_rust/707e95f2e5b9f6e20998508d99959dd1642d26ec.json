{"sha": "707e95f2e5b9f6e20998508d99959dd1642d26ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwN2U5NWYyZTViOWY2ZTIwOTk4NTA4ZDk5OTU5ZGQxNjQyZDI2ZWM=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-21T16:40:36Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-21T17:21:19Z"}, "message": "types: use middle::ty types instead of ast types\n\nThis gets rid of the match_ty_unwrap function.", "tree": {"sha": "da7872d5e9309d8d4756b2412109b7df3faa9c65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da7872d5e9309d8d4756b2412109b7df3faa9c65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/707e95f2e5b9f6e20998508d99959dd1642d26ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/707e95f2e5b9f6e20998508d99959dd1642d26ec", "html_url": "https://github.com/rust-lang/rust/commit/707e95f2e5b9f6e20998508d99959dd1642d26ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/707e95f2e5b9f6e20998508d99959dd1642d26ec/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2df15d65a7baf1f8d9b8b776027a34dd6e1db10", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2df15d65a7baf1f8d9b8b776027a34dd6e1db10", "html_url": "https://github.com/rust-lang/rust/commit/b2df15d65a7baf1f8d9b8b776027a34dd6e1db10"}], "stats": {"total": 73, "additions": 24, "deletions": 49}, "files": [{"sha": "986fb1016ed914156123a2728419c16efcc4a7cc", "filename": "src/types.rs", "status": "modified", "additions": 23, "deletions": 48, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/707e95f2e5b9f6e20998508d99959dd1642d26ec/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707e95f2e5b9f6e20998508d99959dd1642d26ec/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=707e95f2e5b9f6e20998508d99959dd1642d26ec", "patch": "@@ -2,11 +2,10 @@ use rustc::lint::*;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::ast_util::{is_comparison_binop, binop_to_string};\n-use syntax::ptr::P;\n use rustc::middle::ty;\n use syntax::codemap::ExpnInfo;\n \n-use utils::{in_macro, snippet, span_lint, span_help_and_lint, in_external_macro};\n+use utils::{in_macro, match_def_path, snippet, span_lint, span_help_and_lint, in_external_macro};\n \n /// Handles all the linting of funky types\n #[allow(missing_copy_implementations)]\n@@ -18,61 +17,37 @@ declare_lint!(pub LINKEDLIST, Warn,\n               \"usage of LinkedList, usually a vector is faster, or a more specialized data \\\n                structure like a RingBuf\");\n \n-/// Matches a type with a provided string, and returns its type parameters if successful\n-pub fn match_ty_unwrap<'a>(ty: &'a Ty, segments: &[&str]) -> Option<&'a [P<Ty>]> {\n-    match ty.node {\n-        TyPath(_, Path {segments: ref seg, ..}) => {\n-            // So ast::Path isn't the full path, just the tokens that were provided.\n-            // I could muck around with the maps and find the full path\n-            // however the more efficient way is to simply reverse the iterators and zip them\n-            // which will compare them in reverse until one of them runs out of segments\n-            if seg.iter().rev().zip(segments.iter().rev()).all(|(a,b)| a.identifier.name == b) {\n-                match seg[..].last() {\n-                    Some(&PathSegment {parameters: AngleBracketedParameters(ref a), ..}) => {\n-                        Some(&a.types[..])\n-                    }\n-                    _ => None\n-                }\n-            } else {\n-                None\n-            }\n-        },\n-        _ => None\n-    }\n-}\n-\n #[allow(unused_imports)]\n impl LintPass for TypePass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(BOX_VEC, LINKEDLIST)\n     }\n \n-    fn check_ty(&mut self, cx: &Context, ty: &ast::Ty) {\n+    fn check_ty(&mut self, cx: &Context, ast_ty: &ast::Ty) {\n         {\n             // In case stuff gets moved around\n-            use std::boxed::Box;\n-            use std::vec::Vec;\n+            use collections::vec::Vec;\n+            use collections::linked_list::LinkedList;\n         }\n-        match_ty_unwrap(ty, &[\"std\", \"boxed\", \"Box\"]).and_then(|t| t.first())\n-          .and_then(|t| match_ty_unwrap(&**t, &[\"std\", \"vec\", \"Vec\"]))\n-          .map(|_| {\n-            span_help_and_lint(cx, BOX_VEC, ty.span,\n-                              \"you seem to be trying to use `Box<Vec<T>>`. Did you mean to use `Vec<T>`?\",\n-                              \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation\");\n-          });\n-        {\n-            // In case stuff gets moved around\n-            use collections::linked_list::LinkedList as DL1;\n-            use std::collections::linked_list::LinkedList as DL2;\n-        }\n-        let dlists = [vec![\"std\",\"collections\",\"linked_list\",\"LinkedList\"],\n-                      vec![\"collections\",\"linked_list\",\"LinkedList\"]];\n-        for path in &dlists {\n-            if match_ty_unwrap(ty, &path[..]).is_some() {\n-                span_help_and_lint(cx, LINKEDLIST, ty.span,\n-                                   \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n-                                   \"a RingBuf might work\");\n-                return;\n+        if let Some(ty) = cx.tcx.ast_ty_to_ty_cache.borrow().get(&ast_ty.id) {\n+            if let ty::TyBox(ref inner) = ty.sty {\n+                if let ty::TyStruct(did, _) = inner.sty {\n+                    if match_def_path(cx, did.did, &[\"collections\", \"vec\", \"Vec\"]) {\n+                        span_help_and_lint(\n+                            cx, BOX_VEC, ast_ty.span,\n+                            \"you seem to be trying to use `Box<Vec<T>>`. Did you mean to use `Vec<T>`?\",\n+                            \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation\");\n+                    }\n+                }\n+            }\n+            if let ty::TyStruct(did, _) = ty.sty {\n+                if match_def_path(cx, did.did, &[\"collections\", \"linked_list\", \"LinkedList\"]) {\n+                    span_help_and_lint(\n+                        cx, LINKEDLIST, ast_ty.span,\n+                        \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n+                        \"a RingBuf might work\");\n+                    return;\n+                }\n             }\n         }\n     }"}, {"sha": "a800c045a502a8e6843792e30fab3b3d4b3bca73", "filename": "tests/compile-fail/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/707e95f2e5b9f6e20998508d99959dd1642d26ec/tests%2Fcompile-fail%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/707e95f2e5b9f6e20998508d99959dd1642d26ec/tests%2Fcompile-fail%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdlist.rs?ref=707e95f2e5b9f6e20998508d99959dd1642d26ec", "patch": "@@ -12,4 +12,4 @@ pub fn test(foo: LinkedList<u8>) {  //~ ERROR I see you're using a LinkedList!\n \n fn main(){\n     test(LinkedList::new());\n-}\n\\ No newline at end of file\n+}"}]}