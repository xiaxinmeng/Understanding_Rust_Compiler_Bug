{"sha": "dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYzNjZmRkMjVjY2Q1NmVkZjNlYTM2NGY4NmFiMzI5Njc2MzZjMjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-10T13:05:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-10T13:05:05Z"}, "message": "Auto merge of #70983 - Centril:rollup-npabk7c, r=Centril\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #70784 (Consider methods on fundamental `impl` when method is not found on numeric type)\n - #70843 (Remove the Ord bound that was plaguing drain_filter)\n - #70913 (Replace \"rc\"/\"arc\" lang items with Rc/Arc diagnostic items.)\n - #70932 (De-abuse TyKind::Error in pattern type checking)\n - #70952 (Clean up E0511 explanation)\n - #70964 (rustc_session CLI lint parsing: mark a temporary hack as such)\n - #70969 (Fix JSON file_name documentation for macros.)\n - #70975 (Fix internal doc comment nits.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "a75c01452eed404a4610f586ab4efd89938b6107", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a75c01452eed404a4610f586ab4efd89938b6107"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "html_url": "https://github.com/rust-lang/rust/commit/dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "167510f776891f2b0b18d1168ed42377a63493a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/167510f776891f2b0b18d1168ed42377a63493a7", "html_url": "https://github.com/rust-lang/rust/commit/167510f776891f2b0b18d1168ed42377a63493a7"}, {"sha": "68e0e6ba848087734be581afe5478635a647aa7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/68e0e6ba848087734be581afe5478635a647aa7c", "html_url": "https://github.com/rust-lang/rust/commit/68e0e6ba848087734be581afe5478635a647aa7c"}], "stats": {"total": 303, "additions": 150, "deletions": 153}, "files": [{"sha": "5dee603142dcd006067653828627192ac6023f52", "filename": "src/doc/rustc/src/json.md", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -59,8 +59,11 @@ Diagnostics have the following format:\n     \"spans\": [\n         {\n             /* The file where the span is located.\n-               For spans located within a macro expansion, this will be the\n-               name of the expanded macro in the format \"<MACRONAME macros>\".\n+               Note that this path may not exist. For example, if the path\n+               points to the standard library, and the rust src is not\n+               available in the sysroot, then it may point to a non-existent\n+               file. Beware that this may also point to the source of an\n+               external crate.\n             */\n             \"file_name\": \"lib.rs\",\n             /* The byte offset where the span starts (0-based, inclusive). */"}, {"sha": "fc7e91ce47b52e9114cbd076065bcfc6ba32ada3", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 12, "deletions": 29, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -1727,52 +1727,44 @@ impl<K, V> Clone for Values<'_, K, V> {\n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n pub struct DrainFilter<'a, K, V, F>\n where\n-    K: 'a + Ord, // This Ord bound should be removed before stabilization.\n+    K: 'a,\n     V: 'a,\n     F: 'a + FnMut(&K, &mut V) -> bool,\n {\n     pred: F,\n     inner: DrainFilterInner<'a, K, V>,\n }\n-pub(super) struct DrainFilterInner<'a, K, V>\n-where\n-    K: 'a + Ord,\n-    V: 'a,\n-{\n+pub(super) struct DrainFilterInner<'a, K: 'a, V: 'a> {\n     length: &'a mut usize,\n     cur_leaf_edge: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<'a, K, V, F> Drop for DrainFilter<'a, K, V, F>\n+impl<K, V, F> Drop for DrainFilter<'_, K, V, F>\n where\n-    K: 'a + Ord,\n-    V: 'a,\n-    F: 'a + FnMut(&K, &mut V) -> bool,\n+    F: FnMut(&K, &mut V) -> bool,\n {\n     fn drop(&mut self) {\n         self.for_each(drop);\n     }\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<'a, K, V, F> fmt::Debug for DrainFilter<'a, K, V, F>\n+impl<K, V, F> fmt::Debug for DrainFilter<'_, K, V, F>\n where\n-    K: 'a + fmt::Debug + Ord,\n-    V: 'a + fmt::Debug,\n-    F: 'a + FnMut(&K, &mut V) -> bool,\n+    K: fmt::Debug,\n+    V: fmt::Debug,\n+    F: FnMut(&K, &mut V) -> bool,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"DrainFilter\").field(&self.inner.peek()).finish()\n     }\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<'a, K, V, F> Iterator for DrainFilter<'a, K, V, F>\n+impl<K, V, F> Iterator for DrainFilter<'_, K, V, F>\n where\n-    K: 'a + Ord,\n-    V: 'a,\n-    F: 'a + FnMut(&K, &mut V) -> bool,\n+    F: FnMut(&K, &mut V) -> bool,\n {\n     type Item = (K, V);\n \n@@ -1785,11 +1777,7 @@ where\n     }\n }\n \n-impl<'a, K, V> DrainFilterInner<'a, K, V>\n-where\n-    K: 'a + Ord,\n-    V: 'a,\n-{\n+impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n     /// Allow Debug implementations to predict the next element.\n     pub(super) fn peek(&self) -> Option<(&K, &V)> {\n         let edge = self.cur_leaf_edge.as_ref()?;\n@@ -1828,12 +1816,7 @@ where\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<K, V, F> FusedIterator for DrainFilter<'_, K, V, F>\n-where\n-    K: Ord,\n-    F: FnMut(&K, &mut V) -> bool,\n-{\n-}\n+impl<K, V, F> FusedIterator for DrainFilter<'_, K, V, F> where F: FnMut(&K, &mut V) -> bool {}\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> Iterator for Range<'a, K, V> {"}, {"sha": "9bf483f269f6e6785913dd199619def693dc69e6", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -1094,40 +1094,38 @@ impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n pub struct DrainFilter<'a, T, F>\n where\n-    T: 'a + Ord,\n+    T: 'a,\n     F: 'a + FnMut(&T) -> bool,\n {\n     pred: F,\n     inner: super::map::DrainFilterInner<'a, T, ()>,\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<'a, T, F> Drop for DrainFilter<'a, T, F>\n+impl<T, F> Drop for DrainFilter<'_, T, F>\n where\n-    T: 'a + Ord,\n-    F: 'a + FnMut(&T) -> bool,\n+    F: FnMut(&T) -> bool,\n {\n     fn drop(&mut self) {\n         self.for_each(drop);\n     }\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<'a, T, F> fmt::Debug for DrainFilter<'a, T, F>\n+impl<T, F> fmt::Debug for DrainFilter<'_, T, F>\n where\n-    T: 'a + Ord + fmt::Debug,\n-    F: 'a + FnMut(&T) -> bool,\n+    T: fmt::Debug,\n+    F: FnMut(&T) -> bool,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"DrainFilter\").field(&self.inner.peek().map(|(k, _)| k)).finish()\n     }\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<'a, 'f, T, F> Iterator for DrainFilter<'a, T, F>\n+impl<'a, T, F> Iterator for DrainFilter<'_, T, F>\n where\n-    T: 'a + Ord,\n-    F: 'a + 'f + FnMut(&T) -> bool,\n+    F: 'a + FnMut(&T) -> bool,\n {\n     type Item = T;\n \n@@ -1143,12 +1141,7 @@ where\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n-impl<'a, T, F> FusedIterator for DrainFilter<'a, T, F>\n-where\n-    T: 'a + Ord,\n-    F: 'a + FnMut(&T) -> bool,\n-{\n-}\n+impl<T, F> FusedIterator for DrainFilter<'_, T, F> where F: FnMut(&T) -> bool {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BTreeSet<T> {"}, {"sha": "abc4056cf5695746d93fa37e992972146ab9781f", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -279,7 +279,8 @@ struct RcBox<T: ?Sized> {\n /// type `T`.\n ///\n /// [get_mut]: #method.get_mut\n-#[cfg_attr(not(test), lang = \"rc\")]\n+#[cfg_attr(all(bootstrap, not(test)), lang = \"rc\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"Rc\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T: ?Sized> {\n     ptr: NonNull<RcBox<T>>,"}, {"sha": "b1b22e46a7c2fd0766b9e5ee671a9e11d3641010", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -207,7 +207,8 @@ macro_rules! acquire {\n /// counting in general.\n ///\n /// [rc_examples]: ../../std/rc/index.html#examples\n-#[cfg_attr(not(test), lang = \"arc\")]\n+#[cfg_attr(all(bootstrap, not(test)), lang = \"arc\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"Arc\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Arc<T: ?Sized> {\n     ptr: NonNull<ArcInner<T>>,"}, {"sha": "120c96b421104b4d2de741fc9e8f691c0db492ec", "filename": "src/librustc_error_codes/error_codes/E0152.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_error_codes%2Ferror_codes%2FE0152.md", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_error_codes%2Ferror_codes%2FE0152.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0152.md?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -5,8 +5,8 @@ Erroneous code example:\n ```compile_fail,E0152\n #![feature(lang_items)]\n \n-#[lang = \"arc\"]\n-struct Foo; // error: duplicate lang item found: `arc`\n+#[lang = \"owned_box\"]\n+struct Foo; // error: duplicate lang item found: `owned_box`\n ```\n \n Lang items are already implemented in the standard library. Unless you are"}, {"sha": "5351a685eb512e4d86ef33550bbddf7a8b88954c", "filename": "src/librustc_error_codes/error_codes/E0511.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_error_codes%2Ferror_codes%2FE0511.md", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_error_codes%2Ferror_codes%2FE0511.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0511.md?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -1,5 +1,6 @@\n-Invalid monomorphization of an intrinsic function was used. Erroneous code\n-example:\n+Invalid monomorphization of an intrinsic function was used.\n+\n+Erroneous code example:\n \n ```compile_fail,E0511\n #![feature(platform_intrinsics)]"}, {"sha": "e7ae51ca58835b12ca488205978f56b914c21fd7", "filename": "src/librustc_error_codes/error_codes/E0718.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_error_codes%2Ferror_codes%2FE0718.md", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_error_codes%2Ferror_codes%2FE0718.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0718.md?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -6,6 +6,6 @@ Examples of erroneous code:\n ```compile_fail,E0718\n #![feature(lang_items)]\n \n-#[lang = \"arc\"]\n+#[lang = \"owned_box\"]\n static X: u32 = 42;\n ```"}, {"sha": "5a3a9cabeb450d252c211f525da4363e47a04e4a", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -254,7 +254,4 @@ language_item_table! {\n     AlignOffsetLangItem,         \"align_offset\",       align_offset_fn,         Target::Fn;\n \n     TerminationTraitLangItem,    \"termination\",        termination,             Target::Trait;\n-\n-    Arc,                         \"arc\",                arc,                     Target::Struct;\n-    Rc,                          \"rc\",                 rc,                      Target::Struct;\n }"}, {"sha": "b336a30e3d338fa2f7f9ff9872682ca203fc7ac0", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -2209,6 +2209,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         Some(self.mk_generic_adt(def_id, ty))\n     }\n \n+    #[inline]\n+    pub fn mk_diagnostic_item(self, ty: Ty<'tcx>, name: Symbol) -> Option<Ty<'tcx>> {\n+        let def_id = self.get_diagnostic_item(name)?;\n+        Some(self.mk_generic_adt(def_id, ty))\n+    }\n+\n     #[inline]\n     pub fn mk_maybe_uninit(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let def_id = self.require_lang_item(lang_items::MaybeUninitLangItem, None);"}, {"sha": "8dbf27b0ed872c85f0a7a3545f5c75da5d517e4e", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -1829,14 +1829,9 @@ bitflags! {\n         const IS_BOX              = 1 << 6;\n         /// Indicates whether the type is `ManuallyDrop`.\n         const IS_MANUALLY_DROP    = 1 << 7;\n-        // FIXME(matthewjasper) replace these with diagnostic items\n-        /// Indicates whether the type is an `Arc`.\n-        const IS_ARC              = 1 << 8;\n-        /// Indicates whether the type is an `Rc`.\n-        const IS_RC               = 1 << 9;\n         /// Indicates whether the variant list of this ADT is `#[non_exhaustive]`.\n         /// (i.e., this flag is never set unless this ADT is an enum).\n-        const IS_VARIANT_LIST_NON_EXHAUSTIVE = 1 << 10;\n+        const IS_VARIANT_LIST_NON_EXHAUSTIVE = 1 << 8;\n     }\n }\n \n@@ -2221,12 +2216,6 @@ impl<'tcx> AdtDef {\n         if Some(did) == tcx.lang_items().manually_drop() {\n             flags |= AdtFlags::IS_MANUALLY_DROP;\n         }\n-        if Some(did) == tcx.lang_items().arc() {\n-            flags |= AdtFlags::IS_ARC;\n-        }\n-        if Some(did) == tcx.lang_items().rc() {\n-            flags |= AdtFlags::IS_RC;\n-        }\n \n         AdtDef { did, variants, flags, repr }\n     }\n@@ -2305,16 +2294,6 @@ impl<'tcx> AdtDef {\n         self.flags.contains(AdtFlags::IS_PHANTOM_DATA)\n     }\n \n-    /// Returns `true` if this is `Arc<T>`.\n-    pub fn is_arc(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_ARC)\n-    }\n-\n-    /// Returns `true` if this is `Rc<T>`.\n-    pub fn is_rc(&self) -> bool {\n-        self.flags.contains(AdtFlags::IS_RC)\n-    }\n-\n     /// Returns `true` if this is Box<T>.\n     #[inline]\n     pub fn is_box(&self) -> bool {"}, {"sha": "081e6f06b331155b01e8909e20b83dcc1ecaedbb", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -1864,24 +1864,6 @@ impl<'tcx> TyS<'tcx> {\n         self.is_region_ptr() || self.is_unsafe_ptr() || self.is_fn_ptr()\n     }\n \n-    /// Returns `true` if this type is an `Arc<T>`.\n-    #[inline]\n-    pub fn is_arc(&self) -> bool {\n-        match self.kind {\n-            Adt(def, _) => def.is_arc(),\n-            _ => false,\n-        }\n-    }\n-\n-    /// Returns `true` if this type is an `Rc<T>`.\n-    #[inline]\n-    pub fn is_rc(&self) -> bool {\n-        match self.kind {\n-            Adt(def, _) => def.is_rc(),\n-            _ => false,\n-        }\n-    }\n-\n     #[inline]\n     pub fn is_box(&self) -> bool {\n         match self.kind {"}, {"sha": "404cc0c74679fb16591c6739598f8c10b04b16c3", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::mir::{\n };\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt};\n-use rustc_span::Span;\n+use rustc_span::{symbol::sym, Span};\n use rustc_target::abi::VariantIdx;\n \n use super::borrow_set::BorrowData;\n@@ -632,20 +632,20 @@ pub(super) enum BorrowedContentSource<'tcx> {\n }\n \n impl BorrowedContentSource<'tcx> {\n-    pub(super) fn describe_for_unnamed_place(&self) -> String {\n+    pub(super) fn describe_for_unnamed_place(&self, tcx: TyCtxt<'_>) -> String {\n         match *self {\n             BorrowedContentSource::DerefRawPointer => \"a raw pointer\".to_string(),\n             BorrowedContentSource::DerefSharedRef => \"a shared reference\".to_string(),\n             BorrowedContentSource::DerefMutableRef => \"a mutable reference\".to_string(),\n-            BorrowedContentSource::OverloadedDeref(ty) => {\n-                if ty.is_rc() {\n+            BorrowedContentSource::OverloadedDeref(ty) => match ty.kind {\n+                ty::Adt(def, _) if tcx.is_diagnostic_item(sym::Rc, def.did) => {\n                     \"an `Rc`\".to_string()\n-                } else if ty.is_arc() {\n+                }\n+                ty::Adt(def, _) if tcx.is_diagnostic_item(sym::Arc, def.did) => {\n                     \"an `Arc`\".to_string()\n-                } else {\n-                    format!(\"dereference of `{}`\", ty)\n                 }\n-            }\n+                _ => format!(\"dereference of `{}`\", ty),\n+            },\n             BorrowedContentSource::OverloadedIndex(ty) => format!(\"index of `{}`\", ty),\n         }\n     }\n@@ -662,22 +662,22 @@ impl BorrowedContentSource<'tcx> {\n         }\n     }\n \n-    pub(super) fn describe_for_immutable_place(&self) -> String {\n+    pub(super) fn describe_for_immutable_place(&self, tcx: TyCtxt<'_>) -> String {\n         match *self {\n             BorrowedContentSource::DerefRawPointer => \"a `*const` pointer\".to_string(),\n             BorrowedContentSource::DerefSharedRef => \"a `&` reference\".to_string(),\n             BorrowedContentSource::DerefMutableRef => {\n                 bug!(\"describe_for_immutable_place: DerefMutableRef isn't immutable\")\n             }\n-            BorrowedContentSource::OverloadedDeref(ty) => {\n-                if ty.is_rc() {\n+            BorrowedContentSource::OverloadedDeref(ty) => match ty.kind {\n+                ty::Adt(def, _) if tcx.is_diagnostic_item(sym::Rc, def.did) => {\n                     \"an `Rc`\".to_string()\n-                } else if ty.is_arc() {\n+                }\n+                ty::Adt(def, _) if tcx.is_diagnostic_item(sym::Arc, def.did) => {\n                     \"an `Arc`\".to_string()\n-                } else {\n-                    format!(\"a dereference of `{}`\", ty)\n                 }\n-            }\n+                _ => format!(\"a dereference of `{}`\", ty),\n+            },\n             BorrowedContentSource::OverloadedIndex(ty) => format!(\"an index of `{}`\", ty),\n         }\n     }"}, {"sha": "1fbecb75dff531b3787bd5bbbeb2d1086177500e", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -377,7 +377,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         span,\n                         &format!(\"`{}` which is behind a {}\", place_desc, source_desc),\n                     ),\n-                    (_, _) => self.cannot_move_out_of(span, &source.describe_for_unnamed_place()),\n+                    (_, _) => self.cannot_move_out_of(\n+                        span,\n+                        &source.describe_for_unnamed_place(self.infcx.tcx),\n+                    ),\n                 }\n             }\n         };"}, {"sha": "635c299cf81364c0a5f82a5e2d3e96d17a20851d", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         local: the_place_err.local,\n                         projection: proj_base,\n                     });\n-                    let pointer_type = source.describe_for_immutable_place();\n+                    let pointer_type = source.describe_for_immutable_place(self.infcx.tcx);\n                     opt_source = Some(source);\n                     if let Some(desc) = access_place_desc {\n                         item_msg = format!(\"`{}`\", desc);"}, {"sha": "aaf30c583e263eda6b0d26f3ae94baa0fd996488", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -1019,7 +1019,9 @@ pub fn get_cmd_lint_options(\n     for &level in &[lint::Allow, lint::Warn, lint::Deny, lint::Forbid] {\n         for (passed_arg_pos, lint_name) in matches.opt_strs_pos(level.as_str()) {\n             let arg_pos = if let lint::Forbid = level {\n-                // forbid is always specified last, so it can't be overridden\n+                // HACK: forbid is always specified last, so it can't be overridden.\n+                // FIXME: remove this once <https://github.com/rust-lang/rust/issues/70819> is\n+                // fixed and `forbid` works as expected.\n                 usize::max_value()\n             } else {\n                 passed_arg_pos"}, {"sha": "6845cb3b9a35258477360e67c5c64b84134856f7", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -144,6 +144,7 @@ symbols! {\n         any,\n         arbitrary_enum_discriminant,\n         arbitrary_self_types,\n+        Arc,\n         Arguments,\n         ArgumentV1,\n         arm_target_feature,\n@@ -582,6 +583,7 @@ symbols! {\n         raw_dylib,\n         raw_identifiers,\n         raw_ref_op,\n+        Rc,\n         Ready,\n         reason,\n         recursion_limit,"}, {"sha": "57e2349bb2e803f037d66cc6e98d22399636f7db", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -902,8 +902,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         error: MethodError<'tcx>,\n     ) {\n         let rcvr = &args[0];\n-        let try_alt_rcvr = |err: &mut DiagnosticBuilder<'_>, rcvr_t, lang_item| {\n-            if let Some(new_rcvr_t) = self.tcx.mk_lang_item(rcvr_t, lang_item) {\n+        let try_alt_rcvr = |err: &mut DiagnosticBuilder<'_>, new_rcvr_t| {\n+            if let Some(new_rcvr_t) = new_rcvr_t {\n                 if let Ok(pick) = self.lookup_probe(\n                     span,\n                     segment.ident,\n@@ -931,10 +931,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Try alternative arbitrary self types that could fulfill this call.\n                 // FIXME: probe for all types that *could* be arbitrary self-types, not\n                 // just this whitelist.\n-                try_alt_rcvr(&mut err, rcvr_t, lang_items::OwnedBoxLangItem);\n-                try_alt_rcvr(&mut err, rcvr_t, lang_items::PinTypeLangItem);\n-                try_alt_rcvr(&mut err, rcvr_t, lang_items::Arc);\n-                try_alt_rcvr(&mut err, rcvr_t, lang_items::Rc);\n+                try_alt_rcvr(&mut err, self.tcx.mk_lang_item(rcvr_t, lang_items::OwnedBoxLangItem));\n+                try_alt_rcvr(&mut err, self.tcx.mk_lang_item(rcvr_t, lang_items::PinTypeLangItem));\n+                try_alt_rcvr(&mut err, self.tcx.mk_diagnostic_item(rcvr_t, sym::Arc));\n+                try_alt_rcvr(&mut err, self.tcx.mk_diagnostic_item(rcvr_t, sym::Rc));\n             }\n             err.emit();\n         }"}, {"sha": "f075d1e74d455df26ab62f9eb7fd81e379a0eef3", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -271,11 +271,35 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let mut candidates = all_traits(self.tcx).into_iter().filter_map(|info| {\n                         self.associated_item(info.def_id, item_name, Namespace::ValueNS)\n                     });\n-                    if let (true, false, SelfSource::MethodCall(expr), Some(_)) = (\n+                    // There are methods that are defined on the primitive types and won't be\n+                    // found when exploring `all_traits`, but we also need them to be acurate on\n+                    // our suggestions (#47759).\n+                    let fund_assoc = |opt_def_id: Option<DefId>| {\n+                        opt_def_id\n+                            .and_then(|id| self.associated_item(id, item_name, Namespace::ValueNS))\n+                            .is_some()\n+                    };\n+                    let lang_items = tcx.lang_items();\n+                    let found_candidate = candidates.next().is_some()\n+                        || fund_assoc(lang_items.i8_impl())\n+                        || fund_assoc(lang_items.i16_impl())\n+                        || fund_assoc(lang_items.i32_impl())\n+                        || fund_assoc(lang_items.i64_impl())\n+                        || fund_assoc(lang_items.i128_impl())\n+                        || fund_assoc(lang_items.u8_impl())\n+                        || fund_assoc(lang_items.u16_impl())\n+                        || fund_assoc(lang_items.u32_impl())\n+                        || fund_assoc(lang_items.u64_impl())\n+                        || fund_assoc(lang_items.u128_impl())\n+                        || fund_assoc(lang_items.f32_impl())\n+                        || fund_assoc(lang_items.f32_runtime_impl())\n+                        || fund_assoc(lang_items.f64_impl())\n+                        || fund_assoc(lang_items.f64_runtime_impl());\n+                    if let (true, false, SelfSource::MethodCall(expr), true) = (\n                         actual.is_numeric(),\n                         actual.has_concrete_skeleton(),\n                         source,\n-                        candidates.next(),\n+                        found_candidate,\n                     ) {\n                         let mut err = struct_span_err!(\n                             tcx.sess,"}, {"sha": "a5490696ba0b4355ba18f2b4cc6c7b0d98c58ad1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -1161,7 +1161,7 @@ impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n     fn assign(&mut self, span: Span, nid: hir::HirId, ty_opt: Option<LocalTy<'tcx>>) -> Ty<'tcx> {\n         match ty_opt {\n             None => {\n-                // infer the variable's type\n+                // Infer the variable's type.\n                 let var_ty = self.fcx.next_ty_var(TypeVariableOrigin {\n                     kind: TypeVariableOriginKind::TypeInference,\n                     span,\n@@ -1173,7 +1173,7 @@ impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n                 var_ty\n             }\n             Some(typ) => {\n-                // take type that the user specified\n+                // Take type that the user specified.\n                 self.fcx.locals.borrow_mut().insert(nid, typ);\n                 typ.revealed_ty\n             }\n@@ -1244,7 +1244,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n         intravisit::walk_pat(self, p);\n     }\n \n-    // Don't descend into the bodies of nested closures\n+    // Don't descend into the bodies of nested closures.\n     fn visit_fn(\n         &mut self,\n         _: intravisit::FnKind<'tcx>,\n@@ -1292,7 +1292,7 @@ fn check_fn<'a, 'tcx>(\n \n     debug!(\"check_fn(sig={:?}, fn_id={}, param_env={:?})\", fn_sig, fn_id, param_env);\n \n-    // Create the function context.  This is either derived from scratch or,\n+    // Create the function context. This is either derived from scratch or,\n     // in the case of closures, based on the outer context.\n     let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n     *fcx.ps.borrow_mut() = UnsafetyState::function(fn_sig.unsafety, fn_id);"}, {"sha": "0335aba914460150bff0ca9710e618c5c412e393", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -1353,23 +1353,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         def_bm: BindingMode,\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n-        let err = self.tcx.types.err;\n         let expected = self.structurally_resolved_type(span, expected);\n-        let (element_ty, slice_ty, inferred) = match expected.kind {\n+        let (element_ty, opt_slice_ty, inferred) = match expected.kind {\n             // An array, so we might have something like `let [a, b, c] = [0, 1, 2];`.\n             ty::Array(element_ty, len) => {\n                 let min = before.len() as u64 + after.len() as u64;\n-                let (slice_ty, expected) =\n+                let (opt_slice_ty, expected) =\n                     self.check_array_pat_len(span, element_ty, expected, slice, len, min);\n-                (element_ty, slice_ty, expected)\n+                // `opt_slice_ty.is_none()` => `slice.is_none()`.\n+                // Note, though, that opt_slice_ty could be `Some(error_ty)`.\n+                assert!(opt_slice_ty.is_some() || slice.is_none());\n+                (element_ty, opt_slice_ty, expected)\n             }\n-            ty::Slice(element_ty) => (element_ty, expected, expected),\n+            ty::Slice(element_ty) => (element_ty, Some(expected), expected),\n             // The expected type must be an array or slice, but was neither, so error.\n             _ => {\n                 if !expected.references_error() {\n                     self.error_expected_array_or_slice(span, expected);\n                 }\n-                (err, err, err)\n+                let err = self.tcx.types.err;\n+                (err, Some(err), err)\n             }\n         };\n \n@@ -1379,7 +1382,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         // Type check the `slice`, if present, against its expected type.\n         if let Some(slice) = slice {\n-            self.check_pat(&slice, slice_ty, def_bm, ti);\n+            self.check_pat(&slice, opt_slice_ty.unwrap(), def_bm, ti);\n         }\n         // Type check the elements after `slice`, if present.\n         for elt in after {\n@@ -1390,9 +1393,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Type check the length of an array pattern.\n     ///\n-    /// Returns both the type of the variable length pattern\n-    /// (or `tcx.err` in case there is none),\n-    /// and the potentially inferred array type.\n+    /// Returns both the type of the variable length pattern (or `None`), and the potentially\n+    /// inferred array type. We only return `None` for the slice type if `slice.is_none()`.\n     fn check_array_pat_len(\n         &self,\n         span: Span,\n@@ -1401,20 +1403,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         slice: Option<&'tcx Pat<'tcx>>,\n         len: &ty::Const<'tcx>,\n         min_len: u64,\n-    ) -> (Ty<'tcx>, Ty<'tcx>) {\n+    ) -> (Option<Ty<'tcx>>, Ty<'tcx>) {\n         if let Some(len) = len.try_eval_usize(self.tcx, self.param_env) {\n             // Now we know the length...\n             if slice.is_none() {\n                 // ...and since there is no variable-length pattern,\n                 // we require an exact match between the number of elements\n                 // in the array pattern and as provided by the matched type.\n-                if min_len != len {\n-                    self.error_scrutinee_inconsistent_length(span, min_len, len);\n+                if min_len == len {\n+                    return (None, arr_ty);\n                 }\n+\n+                self.error_scrutinee_inconsistent_length(span, min_len, len);\n             } else if let Some(pat_len) = len.checked_sub(min_len) {\n                 // The variable-length pattern was there,\n                 // so it has an array type with the remaining elements left as its size...\n-                return (self.tcx.mk_array(element_ty, pat_len), arr_ty);\n+                return (Some(self.tcx.mk_array(element_ty, pat_len)), arr_ty);\n             } else {\n                 // ...however, in this case, there were no remaining elements.\n                 // That is, the slice pattern requires more than the array type offers.\n@@ -1425,14 +1429,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // which we can use to infer the length of the array.\n             let updated_arr_ty = self.tcx.mk_array(element_ty, min_len);\n             self.demand_eqtype(span, updated_arr_ty, arr_ty);\n-            return (self.tcx.types.err, updated_arr_ty);\n+            return (None, updated_arr_ty);\n         } else {\n             // We have a variable-length pattern and don't know the array length.\n             // This happens if we have e.g.,\n             // `let [a, b, ..] = arr` where `arr: [T; N]` where `const N: usize`.\n             self.error_scrutinee_unfixed_length(span);\n         }\n-        (self.tcx.types.err, arr_ty)\n+\n+        // If we get here, we must have emitted an error.\n+        (Some(self.tcx.types.err), arr_ty)\n     }\n \n     fn error_scrutinee_inconsistent_length(&self, span: Span, min_len: u64, size: u64) {"}, {"sha": "146fc04bc27cbf9fba34ce1533f03bcc16f98e92", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -40,7 +40,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let item_def_id = self.tcx.hir().local_def_id(item_id);\n \n         // This attribute causes us to dump some writeback information\n-        // in the form of errors, which is uSymbolfor unit tests.\n+        // in the form of errors, which is uSymbol for unit tests.\n         let rustc_dump_user_substs = self.tcx.has_attr(item_def_id, sym::rustc_dump_user_substs);\n \n         let mut wbcx = WritebackCx::new(self, body, rustc_dump_user_substs);"}, {"sha": "94467b9bddeb0a900d314e889cef8bbb652dec99", "filename": "src/test/ui/error-codes/E0152.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Ftest%2Fui%2Ferror-codes%2FE0152.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Ftest%2Fui%2Ferror-codes%2FE0152.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0152.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -1,6 +1,6 @@\n #![feature(lang_items)]\n \n-#[lang = \"arc\"]\n+#[lang = \"owned_box\"]\n struct Foo; //~ ERROR E0152\n \n fn main() {"}, {"sha": "fbaa276ce1093cad78379e3e96a033cf9421cd76", "filename": "src/test/ui/error-codes/E0152.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Ftest%2Fui%2Ferror-codes%2FE0152.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Ftest%2Fui%2Ferror-codes%2FE0152.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0152.stderr?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -1,4 +1,4 @@\n-error[E0152]: found duplicate lang item `arc`\n+error[E0152]: found duplicate lang item `owned_box`\n   --> $DIR/E0152.rs:4:1\n    |\n LL | struct Foo;"}, {"sha": "909cae0ba25a210d2380acc48118a6c92058c5de", "filename": "src/test/ui/error-codes/E0718.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Ftest%2Fui%2Ferror-codes%2FE0718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Ftest%2Fui%2Ferror-codes%2FE0718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0718.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -1,7 +1,7 @@\n #![feature(lang_items)]\n \n-// Arc is expected to be a struct, so this will error.\n-#[lang = \"arc\"] //~ ERROR language item must be applied to a struct\n+// Box is expected to be a struct, so this will error.\n+#[lang = \"owned_box\"] //~ ERROR language item must be applied to a struct\n static X: u32 = 42;\n \n fn main() {}"}, {"sha": "30378dd167457dcd3cb74aaf3f2fd868733d3077", "filename": "src/test/ui/error-codes/E0718.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Ftest%2Fui%2Ferror-codes%2FE0718.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Ftest%2Fui%2Ferror-codes%2FE0718.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0718.stderr?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -1,8 +1,8 @@\n-error[E0718]: `arc` language item must be applied to a struct\n+error[E0718]: `owned_box` language item must be applied to a struct\n   --> $DIR/E0718.rs:4:1\n    |\n-LL | #[lang = \"arc\"]\n-   | ^^^^^^^^^^^^^^^ attribute should be applied to a struct, not a static item\n+LL | #[lang = \"owned_box\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^ attribute should be applied to a struct, not a static item\n \n error: aborting due to previous error\n "}, {"sha": "70e5bc0192086e3ffb8890a47cab7e1e6ff77b00", "filename": "src/test/ui/issues/issue-29181.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Ftest%2Fui%2Fissues%2Fissue-29181.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Ftest%2Fui%2Fissues%2Fissue-29181.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-29181.rs?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -4,4 +4,6 @@ extern crate issue_29181 as foo;\n \n fn main() {\n     0.homura(); //~ ERROR no method named `homura` found\n+    // Issue #47759, detect existing method on the fundamental impl:\n+    let _ = |x: f64| x * 2.0.exp(); //~ ERROR can't call method `exp` on ambiguous numeric type\n }"}, {"sha": "b66dcb88d00625adcb17534f04743d7a578fb3c5", "filename": "src/test/ui/issues/issue-29181.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Ftest%2Fui%2Fissues%2Fissue-29181.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dbc3cfdd25ccd56edf3ea364f86ab32967636c26/src%2Ftest%2Fui%2Fissues%2Fissue-29181.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-29181.stderr?ref=dbc3cfdd25ccd56edf3ea364f86ab32967636c26", "patch": "@@ -4,6 +4,18 @@ error[E0599]: no method named `homura` found for type `{integer}` in the current\n LL |     0.homura();\n    |       ^^^^^^ method not found in `{integer}`\n \n-error: aborting due to previous error\n+error[E0689]: can't call method `exp` on ambiguous numeric type `{float}`\n+  --> $DIR/issue-29181.rs:8:30\n+   |\n+LL |     let _ = |x: f64| x * 2.0.exp();\n+   |                              ^^^\n+   |\n+help: you must specify a concrete type for this numeric value, like `f32`\n+   |\n+LL |     let _ = |x: f64| x * 2.0_f32.exp();\n+   |                          ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0599`.\n+Some errors have detailed explanations: E0599, E0689.\n+For more information about an error, try `rustc --explain E0599`."}]}