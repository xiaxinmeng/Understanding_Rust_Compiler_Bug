{"sha": "6b8358d4d9317c13593ae15e6065d67eecb85296", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiODM1OGQ0ZDkzMTdjMTM1OTNhZTE1ZTYwNjVkNjdlZWNiODUyOTY=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-29T18:11:28Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-29T18:11:28Z"}, "message": "Remove code duplication in highlight injection", "tree": {"sha": "9669492c1f60e7501447f32971c3829f74499d9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9669492c1f60e7501447f32971c3829f74499d9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b8358d4d9317c13593ae15e6065d67eecb85296", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b8358d4d9317c13593ae15e6065d67eecb85296", "html_url": "https://github.com/rust-lang/rust/commit/6b8358d4d9317c13593ae15e6065d67eecb85296", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b8358d4d9317c13593ae15e6065d67eecb85296/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dd6b931388dac00d272a41a139c4f0cc3c449dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dd6b931388dac00d272a41a139c4f0cc3c449dc", "html_url": "https://github.com/rust-lang/rust/commit/5dd6b931388dac00d272a41a139c4f0cc3c449dc"}], "stats": {"total": 95, "additions": 35, "deletions": 60}, "files": [{"sha": "99276168fb498e7b5a806c619d2eba1ccce4504d", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6b8358d4d9317c13593ae15e6065d67eecb85296/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8358d4d9317c13593ae15e6065d67eecb85296/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=6b8358d4d9317c13593ae15e6065d67eecb85296", "patch": "@@ -98,6 +98,29 @@ pub(crate) fn remove_links(markdown: &str) -> String {\n     out\n }\n \n+/// Retrieve a link to documentation for the given symbol.\n+pub(crate) fn external_docs(\n+    db: &RootDatabase,\n+    position: &FilePosition,\n+) -> Option<DocumentationLink> {\n+    let sema = Semantics::new(db);\n+    let file = sema.parse(position.file_id).syntax().clone();\n+    let token = pick_best(file.token_at_offset(position.offset))?;\n+    let token = sema.descend_into_macros(token);\n+\n+    let node = token.parent()?;\n+    let definition = match_ast! {\n+        match node {\n+            ast::NameRef(name_ref) => NameRefClass::classify(&sema, &name_ref).map(|d| d.referenced(sema.db)),\n+            ast::Name(name) => NameClass::classify(&sema, &name).map(|d| d.referenced_or_defined(sema.db)),\n+            _ => None,\n+        }\n+    };\n+\n+    get_doc_link(db, definition?)\n+}\n+\n+/// Extracts all links from a given markdown text.\n pub(crate) fn extract_definitions_from_markdown(\n     markdown: &str,\n ) -> Vec<(Range<usize>, String, Option<hir::Namespace>)> {\n@@ -178,15 +201,15 @@ pub(crate) fn resolve_doc_path_for_def(\n ) -> Option<hir::ModuleDef> {\n     match def {\n         Definition::ModuleDef(def) => match def {\n-            ModuleDef::Module(it) => it.resolve_doc_path(db, &link, ns),\n-            ModuleDef::Function(it) => it.resolve_doc_path(db, &link, ns),\n-            ModuleDef::Adt(it) => it.resolve_doc_path(db, &link, ns),\n-            ModuleDef::Variant(it) => it.resolve_doc_path(db, &link, ns),\n-            ModuleDef::Const(it) => it.resolve_doc_path(db, &link, ns),\n-            ModuleDef::Static(it) => it.resolve_doc_path(db, &link, ns),\n-            ModuleDef::Trait(it) => it.resolve_doc_path(db, &link, ns),\n-            ModuleDef::TypeAlias(it) => it.resolve_doc_path(db, &link, ns),\n-            ModuleDef::BuiltinType(_) => None,\n+            hir::ModuleDef::Module(it) => it.resolve_doc_path(db, &link, ns),\n+            hir::ModuleDef::Function(it) => it.resolve_doc_path(db, &link, ns),\n+            hir::ModuleDef::Adt(it) => it.resolve_doc_path(db, &link, ns),\n+            hir::ModuleDef::Variant(it) => it.resolve_doc_path(db, &link, ns),\n+            hir::ModuleDef::Const(it) => it.resolve_doc_path(db, &link, ns),\n+            hir::ModuleDef::Static(it) => it.resolve_doc_path(db, &link, ns),\n+            hir::ModuleDef::Trait(it) => it.resolve_doc_path(db, &link, ns),\n+            hir::ModuleDef::TypeAlias(it) => it.resolve_doc_path(db, &link, ns),\n+            hir::ModuleDef::BuiltinType(_) => None,\n         },\n         Definition::Macro(it) => it.resolve_doc_path(db, &link, ns),\n         Definition::Field(it) => it.resolve_doc_path(db, &link, ns),\n@@ -328,28 +351,6 @@ fn rewrite_url_link(db: &RootDatabase, def: ModuleDef, target: &str) -> Option<S\n         .map(|url| url.into_string())\n }\n \n-/// Retrieve a link to documentation for the given symbol.\n-pub(crate) fn external_docs(\n-    db: &RootDatabase,\n-    position: &FilePosition,\n-) -> Option<DocumentationLink> {\n-    let sema = Semantics::new(db);\n-    let file = sema.parse(position.file_id).syntax().clone();\n-    let token = pick_best(file.token_at_offset(position.offset))?;\n-    let token = sema.descend_into_macros(token);\n-\n-    let node = token.parent()?;\n-    let definition = match_ast! {\n-        match node {\n-            ast::NameRef(name_ref) => NameRefClass::classify(&sema, &name_ref).map(|d| d.referenced(sema.db)),\n-            ast::Name(name) => NameClass::classify(&sema, &name).map(|d| d.referenced_or_defined(sema.db)),\n-            _ => None,\n-        }\n-    };\n-\n-    get_doc_link(db, definition?)\n-}\n-\n /// Rewrites a markdown document, applying 'callback' to each link.\n fn map_links<'e>(\n     events: impl Iterator<Item = Event<'e>>,"}, {"sha": "b62d43256ccb4a97814d56d8226f1ad35de7da14", "filename": "crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6b8358d4d9317c13593ae15e6065d67eecb85296/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8358d4d9317c13593ae15e6065d67eecb85296/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=6b8358d4d9317c13593ae15e6065d67eecb85296", "patch": "@@ -11,7 +11,8 @@ use syntax::{\n };\n \n use crate::{\n-    doc_links::extract_definitions_from_markdown, Analysis, HlMod, HlRange, HlTag, RootDatabase,\n+    doc_links::{extract_definitions_from_markdown, resolve_doc_path_for_def},\n+    Analysis, HlMod, HlRange, HlTag, RootDatabase,\n };\n \n use super::{highlights::Highlights, injector::Injector};\n@@ -190,7 +191,7 @@ pub(super) fn doc_comment(\n                         extract_definitions_from_markdown(line)\n                             .into_iter()\n                             .filter_map(|(range, link, ns)| {\n-                                Some(range).zip(validate_intra_doc_link(sema.db, &def, &link, ns))\n+                                Some(range).zip(resolve_doc_path_for_def(sema.db, def, &link, ns))\n                             })\n                             .map(|(Range { start, end }, def)| {\n                                 (\n@@ -283,33 +284,6 @@ fn find_doc_string_in_attr(attr: &hir::Attr, it: &ast::Attr) -> Option<ast::Stri\n     }\n }\n \n-fn validate_intra_doc_link(\n-    db: &RootDatabase,\n-    def: &Definition,\n-    link: &str,\n-    ns: Option<hir::Namespace>,\n-) -> Option<hir::ModuleDef> {\n-    match def {\n-        Definition::ModuleDef(def) => match def {\n-            hir::ModuleDef::Module(it) => it.resolve_doc_path(db, &link, ns),\n-            hir::ModuleDef::Function(it) => it.resolve_doc_path(db, &link, ns),\n-            hir::ModuleDef::Adt(it) => it.resolve_doc_path(db, &link, ns),\n-            hir::ModuleDef::Variant(it) => it.resolve_doc_path(db, &link, ns),\n-            hir::ModuleDef::Const(it) => it.resolve_doc_path(db, &link, ns),\n-            hir::ModuleDef::Static(it) => it.resolve_doc_path(db, &link, ns),\n-            hir::ModuleDef::Trait(it) => it.resolve_doc_path(db, &link, ns),\n-            hir::ModuleDef::TypeAlias(it) => it.resolve_doc_path(db, &link, ns),\n-            hir::ModuleDef::BuiltinType(_) => None,\n-        },\n-        Definition::Macro(it) => it.resolve_doc_path(db, &link, ns),\n-        Definition::Field(it) => it.resolve_doc_path(db, &link, ns),\n-        Definition::SelfType(_)\n-        | Definition::Local(_)\n-        | Definition::GenericParam(_)\n-        | Definition::Label(_) => None,\n-    }\n-}\n-\n fn module_def_to_hl_tag(def: hir::ModuleDef) -> HlTag {\n     let symbol = match def {\n         hir::ModuleDef::Module(_) => SymbolKind::Module,"}]}