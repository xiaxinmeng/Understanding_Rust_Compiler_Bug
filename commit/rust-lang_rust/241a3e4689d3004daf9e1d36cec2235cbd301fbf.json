{"sha": "241a3e4689d3004daf9e1d36cec2235cbd301fbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0MWEzZTQ2ODlkMzAwNGRhZjllMWQzNmNlYzIyMzVjYmQzMDFmYmY=", "commit": {"author": {"name": "Johannes Oertel", "email": "johannes.oertel@uni-due.de", "date": "2016-03-24T14:39:46Z"}, "committer": {"name": "Johannes Oertel", "email": "johannes.oertel@uni-due.de", "date": "2016-04-22T10:30:43Z"}, "message": "Implement `append` for b-trees.\n\nThe algorithm implemented here is linear in the size of the two b-trees. It\nfirsts creates a `MergeIter` from the two b-trees and then builds a new b-tree\nby pushing key-value pairs from the `MergeIter` into nodes at the right heights.\n\nThree functions for stealing have been added to the implementation of `Handle` as\nwell as a getter for the height of a `NodeRef`.\n\nThe docs have been updated with performance information about `BTreeMap::append` and\nthe remark about B has been removed now that it is the same for all instances of `BTreeMap`.", "tree": {"sha": "2271c120af812b64ca3beab24c2c19ce98f53398", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2271c120af812b64ca3beab24c2c19ce98f53398"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/241a3e4689d3004daf9e1d36cec2235cbd301fbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/241a3e4689d3004daf9e1d36cec2235cbd301fbf", "html_url": "https://github.com/rust-lang/rust/commit/241a3e4689d3004daf9e1d36cec2235cbd301fbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/241a3e4689d3004daf9e1d36cec2235cbd301fbf/comments", "author": {"login": "jooert", "id": 1774713, "node_id": "MDQ6VXNlcjE3NzQ3MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1774713?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jooert", "html_url": "https://github.com/jooert", "followers_url": "https://api.github.com/users/jooert/followers", "following_url": "https://api.github.com/users/jooert/following{/other_user}", "gists_url": "https://api.github.com/users/jooert/gists{/gist_id}", "starred_url": "https://api.github.com/users/jooert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jooert/subscriptions", "organizations_url": "https://api.github.com/users/jooert/orgs", "repos_url": "https://api.github.com/users/jooert/repos", "events_url": "https://api.github.com/users/jooert/events{/privacy}", "received_events_url": "https://api.github.com/users/jooert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jooert", "id": 1774713, "node_id": "MDQ6VXNlcjE3NzQ3MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1774713?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jooert", "html_url": "https://github.com/jooert", "followers_url": "https://api.github.com/users/jooert/followers", "following_url": "https://api.github.com/users/jooert/following{/other_user}", "gists_url": "https://api.github.com/users/jooert/gists{/gist_id}", "starred_url": "https://api.github.com/users/jooert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jooert/subscriptions", "organizations_url": "https://api.github.com/users/jooert/orgs", "repos_url": "https://api.github.com/users/jooert/repos", "events_url": "https://api.github.com/users/jooert/events{/privacy}", "received_events_url": "https://api.github.com/users/jooert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "887e9471783ff3f5edc920a85b6110486dc063c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/887e9471783ff3f5edc920a85b6110486dc063c0", "html_url": "https://github.com/rust-lang/rust/commit/887e9471783ff3f5edc920a85b6110486dc063c0"}], "stats": {"total": 450, "additions": 420, "deletions": 30}, "files": [{"sha": "20ef2738de1151d24cdd9e2423a1efee7ff70deb", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 165, "deletions": 24, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/241a3e4689d3004daf9e1d36cec2235cbd301fbf/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/241a3e4689d3004daf9e1d36cec2235cbd301fbf/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=241a3e4689d3004daf9e1d36cec2235cbd301fbf", "patch": "@@ -11,7 +11,7 @@\n use core::cmp::Ordering;\n use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n-use core::iter::FromIterator;\n+use core::iter::{FromIterator, Peekable};\n use core::marker::PhantomData;\n use core::ops::Index;\n use core::{fmt, intrinsics, mem, ptr};\n@@ -348,6 +348,12 @@ pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     _marker: PhantomData<&'a mut (K, V)>,\n }\n \n+// An iterator for merging two sorted sequences into one\n+struct MergeIter<K, V, I: Iterator<Item=(K, V)>> {\n+    left: Peekable<I>,\n+    right: Peekable<I>,\n+}\n+\n impl<K: Ord, V> BTreeMap<K, V> {\n     /// Makes a new empty BTreeMap with a reasonable choice for B.\n     ///\n@@ -535,6 +541,62 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n     }\n \n+    /// Moves all elements from `other` into `Self`, leaving `other` empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(btree_append)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    /// a.insert(3, \"c\");\n+    ///\n+    /// let mut b = BTreeMap::new();\n+    /// b.insert(3, \"d\");\n+    /// b.insert(4, \"e\");\n+    /// b.insert(5, \"f\");\n+    ///\n+    /// a.append(&mut b);\n+    ///\n+    /// assert_eq!(a.len(), 5);\n+    /// assert_eq!(b.len(), 0);\n+    ///\n+    /// assert_eq!(a[&1], \"a\");\n+    /// assert_eq!(a[&2], \"b\");\n+    /// assert_eq!(a[&3], \"d\");\n+    /// assert_eq!(a[&4], \"e\");\n+    /// assert_eq!(a[&5], \"f\");\n+    /// ```\n+    #[unstable(feature = \"btree_append\", reason = \"recently added as part of collections reform 2\",\n+               issue = \"19986\")]\n+    pub fn append(&mut self, other: &mut Self) {\n+        // Do we have to append anything at all?\n+        if other.len() == 0 {\n+            return;\n+        }\n+\n+        // We can just swap `self` and `other` if `self` is empty.\n+        if self.len() == 0 {\n+            mem::swap(self, other);\n+            return;\n+        }\n+\n+        // First, we merge `self` and `other` into a sorted sequence in linear time.\n+        let self_iter = mem::replace(self, BTreeMap::new()).into_iter();\n+        let other_iter = mem::replace(other, BTreeMap::new()).into_iter();\n+        let iter = MergeIter {\n+            left: self_iter.peekable(),\n+            right: other_iter.peekable(),\n+        };\n+\n+        // Second, we build a tree from the sorted sequence in linear time.\n+        self.from_sorted_iter(iter);\n+        self.fix_right_edge();\n+    }\n+\n     /// Constructs a double-ended iterator over a sub-range of elements in the map, starting\n     /// at min, and ending at max. If min is `Unbounded`, then it will be treated as \"negative\n     /// infinity\", and if max is `Unbounded`, then it will be treated as \"positive infinity\".\n@@ -724,6 +786,76 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             })\n         }\n     }\n+\n+    fn from_sorted_iter<I: Iterator<Item=(K, V)>>(&mut self, iter: I) {\n+        let mut cur_node = last_leaf_edge(self.root.as_mut()).into_node();\n+        // Iterate through all key-value pairs, pushing them into nodes at the right level.\n+        for (key, value) in iter {\n+            // Try to push key-value pair into the current leaf node.\n+            if cur_node.len() < node::CAPACITY {\n+                cur_node.push(key, value);\n+            } else {\n+                // No space left, go up and push there.\n+                let mut open_node;\n+                let mut test_node = cur_node.forget_type();\n+                loop {\n+                    match test_node.ascend() {\n+                        Ok(parent) => {\n+                            let parent = parent.into_node();\n+                            if parent.len() < node::CAPACITY {\n+                                // Found a node with space left, push here.\n+                                open_node = parent;\n+                                break;\n+                            } else {\n+                                // Go up again.\n+                                test_node = parent.forget_type();\n+                            }\n+                        },\n+                        Err(node) => {\n+                            // We are at the top, create a new root node and push there.\n+                            open_node = node.into_root_mut().push_level();\n+                            break;\n+                        },\n+                    }\n+                }\n+\n+                // Push key-value pair and new right subtree.\n+                let tree_height = open_node.height() - 1;\n+                let mut right_tree = node::Root::new_leaf();\n+                for _ in 0..tree_height {\n+                    right_tree.push_level();\n+                }\n+                open_node.push(key, value, right_tree);\n+\n+                // Go down to the right-most leaf again.\n+                cur_node = last_leaf_edge(open_node.forget_type()).into_node();\n+            }\n+\n+            self.length += 1;\n+        }\n+    }\n+\n+    fn fix_right_edge(&mut self) {\n+        // Handle underfull nodes, start from the top.\n+        let mut cur_node = self.root.as_mut();\n+        while let Internal(internal) = cur_node.force() {\n+            // Check if right-most child is underfull.\n+            let mut last_edge = internal.last_edge();\n+            let right_child_len = last_edge.reborrow().descend().len();\n+            if right_child_len < node::CAPACITY / 2 {\n+                // We need to steal.\n+                let mut last_kv = match last_edge.left_kv() {\n+                    Ok(left) => left,\n+                    Err(_) => unreachable!(),\n+                };\n+                last_kv.bulk_steal_left(node::CAPACITY/2 - right_child_len);\n+                last_edge = last_kv.right_edge();\n+            }\n+\n+            // Go further down.\n+            cur_node = last_edge.descend();\n+        }\n+    }\n }\n \n impl<'a, K: 'a, V: 'a> IntoIterator for &'a BTreeMap<K, V> {\n@@ -1690,32 +1822,41 @@ fn handle_underfull_node<'a, K, V>(node: NodeRef<marker::Mut<'a>,\n     };\n \n     if handle.can_merge() {\n-        return Merged(handle.merge().into_node());\n+        Merged(handle.merge().into_node())\n     } else {\n-        unsafe {\n-            let (k, v, edge) = if is_left {\n-                handle.reborrow_mut().left_edge().descend().pop()\n-            } else {\n-                handle.reborrow_mut().right_edge().descend().pop_front()\n-            };\n+        if is_left {\n+            handle.steal_left();\n+        } else {\n+            handle.steal_right();\n+        }\n+        Stole(handle.into_node())\n+    }\n+}\n \n-            let k = mem::replace(handle.reborrow_mut().into_kv_mut().0, k);\n-            let v = mem::replace(handle.reborrow_mut().into_kv_mut().1, v);\n+impl<K: Ord, V, I: Iterator<Item=(K, V)>> Iterator for MergeIter<K, V, I> {\n+    type Item = (K, V);\n \n-            // FIXME: reuse cur_node?\n-            if is_left {\n-                match handle.reborrow_mut().right_edge().descend().force() {\n-                    Leaf(mut leaf) => leaf.push_front(k, v),\n-                    Internal(mut internal) => internal.push_front(k, v, edge.unwrap())\n-                }\n-            } else {\n-                match handle.reborrow_mut().left_edge().descend().force() {\n-                    Leaf(mut leaf) => leaf.push(k, v),\n-                    Internal(mut internal) => internal.push(k, v, edge.unwrap())\n-                }\n-            }\n-        }\n+    fn next(&mut self) -> Option<(K, V)> {\n+        let res = match (self.left.peek(), self.right.peek()) {\n+            (Some(&(ref left_key, _)), Some(&(ref right_key, _))) => left_key.cmp(right_key),\n+            (Some(_), None) => Ordering::Less,\n+            (None, Some(_)) => Ordering::Greater,\n+            (None, None) => return None,\n+        };\n \n-        return Stole(handle.into_node());\n+        // Check which elements comes first and only advance the corresponding iterator.\n+        // If two keys are equal, take the value from `right`.\n+        match res {\n+            Ordering::Less => {\n+                self.left.next()\n+            },\n+            Ordering::Greater => {\n+                self.right.next()\n+            },\n+            Ordering::Equal => {\n+                self.left.next();\n+                self.right.next()\n+            },\n+        }\n     }\n }"}, {"sha": "ca1cf6bcc50280c81fe56a4445a6df2f13f72968", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/241a3e4689d3004daf9e1d36cec2235cbd301fbf/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/241a3e4689d3004daf9e1d36cec2235cbd301fbf/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=241a3e4689d3004daf9e1d36cec2235cbd301fbf", "patch": "@@ -328,6 +328,12 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         self.as_leaf().len as usize\n     }\n \n+    /// Returns the height of this node in the whole tree. Zero height denotes the\n+    /// leaf level.\n+    pub fn height(&self) -> usize {\n+        self.height\n+    }\n+\n     /// Removes any static information about whether this node is a `Leaf` or an\n     /// `Internal` node.\n     pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n@@ -1233,6 +1239,139 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             Handle::new_edge(self.node, self.idx)\n         }\n     }\n+\n+    /// This removes a key/value pair from the left child and replaces it with the key/value pair\n+    /// pointed to by this handle while pushing the old key/value pair of this handle into the right\n+    /// child.\n+    pub fn steal_left(&mut self) {\n+        unsafe {\n+            let (k, v, edge) = self.reborrow_mut().left_edge().descend().pop();\n+\n+            let k = mem::replace(self.reborrow_mut().into_kv_mut().0, k);\n+            let v = mem::replace(self.reborrow_mut().into_kv_mut().1, v);\n+\n+            match self.reborrow_mut().right_edge().descend().force() {\n+                ForceResult::Leaf(mut leaf) => leaf.push_front(k, v),\n+                ForceResult::Internal(mut internal) => internal.push_front(k, v, edge.unwrap())\n+            }\n+        }\n+    }\n+\n+    /// This removes a key/value pair from the right child and replaces it with the key/value pair\n+    /// pointed to by this handle while pushing the old key/value pair of this handle into the left\n+    /// child.\n+    pub fn steal_right(&mut self) {\n+        unsafe {\n+            let (k, v, edge) = self.reborrow_mut().right_edge().descend().pop_front();\n+\n+            let k = mem::replace(self.reborrow_mut().into_kv_mut().0, k);\n+            let v = mem::replace(self.reborrow_mut().into_kv_mut().1, v);\n+\n+            match self.reborrow_mut().left_edge().descend().force() {\n+                ForceResult::Leaf(mut leaf) => leaf.push(k, v),\n+                ForceResult::Internal(mut internal) => internal.push(k, v, edge.unwrap())\n+            }\n+        }\n+    }\n+\n+    /// This does stealing similar to `steal_left` but steals multiple elements at once.\n+    pub fn bulk_steal_left(&mut self, n: usize) {\n+        unsafe {\n+            // Get raw pointers to left child's keys, values and edges.\n+            let (left_len, left_k, left_v, left_e) = {\n+                let mut left = self.reborrow_mut().left_edge().descend();\n+\n+                (left.len(),\n+                 left.keys_mut().as_mut_ptr(),\n+                 left.vals_mut().as_mut_ptr(),\n+                 match left.force() {\n+                     ForceResult::Leaf(_) => None,\n+                     ForceResult::Internal(mut i) => Some(i.as_internal_mut().edges.as_mut_ptr()),\n+                 })\n+            };\n+\n+            // Get raw pointers to right child's keys, values and edges.\n+            let (right_len, right_k, right_v, right_e) = {\n+                let mut right = self.reborrow_mut().right_edge().descend();\n+\n+                (right.len(),\n+                 right.keys_mut().as_mut_ptr(),\n+                 right.vals_mut().as_mut_ptr(),\n+                 match right.force() {\n+                     ForceResult::Leaf(_) => None,\n+                     ForceResult::Internal(mut i) => Some(i.as_internal_mut().edges.as_mut_ptr()),\n+                 })\n+            };\n+\n+            // Get raw pointers to parent's key and value.\n+            let (parent_k, parent_v) = {\n+                let kv = self.reborrow_mut().into_kv_mut();\n+                (kv.0 as *mut K, kv.1 as *mut V)\n+            };\n+\n+            // Make sure that we may steal safely.\n+            debug_assert!(right_len + n <= CAPACITY);\n+            debug_assert!(left_len >= n);\n+\n+            // Make room for stolen elements in right child.\n+            ptr::copy(right_k,\n+                      right_k.offset(n as isize),\n+                      right_len);\n+            ptr::copy(right_v,\n+                      right_v.offset(n as isize),\n+                      right_len);\n+            if let Some(edges) = right_e {\n+                ptr::copy(edges,\n+                          edges.offset(n as isize),\n+                          right_len+1);\n+            }\n+\n+            // Move elements from the left child to the right one.\n+            let left_ind = (left_len - n) as isize;\n+            ptr::copy_nonoverlapping(left_k.offset(left_ind + 1),\n+                                     right_k,\n+                                     n - 1);\n+            ptr::copy_nonoverlapping(left_v.offset(left_ind + 1),\n+                                     right_v,\n+                                     n - 1);\n+            match (left_e, right_e) {\n+                (Some(left), Some(right)) => {\n+                    ptr::copy_nonoverlapping(left.offset(left_ind + 1),\n+                                             right,\n+                                             n);\n+                },\n+                (Some(_), None) => unreachable!(),\n+                (None, Some(_)) => unreachable!(),\n+                (None, None) => {},\n+            }\n+\n+            // Copy parent key/value pair to right child.\n+            ptr::copy_nonoverlapping(parent_k,\n+                                     right_k.offset(n as isize - 1),\n+                                     1);\n+            ptr::copy_nonoverlapping(parent_v,\n+                                     right_v.offset(n as isize - 1),\n+                                     1);\n+            // Copy left-most stolen pair to parent.\n+            ptr::copy_nonoverlapping(left_k.offset(left_ind),\n+                                     parent_k,\n+                                     1);\n+            ptr::copy_nonoverlapping(left_v.offset(left_ind),\n+                                     parent_v,\n+                                     1);\n+\n+            // Fix lengths of left and right child and parent pointers in children of the right\n+            // child.\n+            self.reborrow_mut().left_edge().descend().as_leaf_mut().len -= n as u16;\n+            let mut right = self.reborrow_mut().right_edge().descend();\n+            right.as_leaf_mut().len += n as u16;\n+            if let ForceResult::Internal(mut node) = right.force() {\n+                for i in 0..(right_len+n+1) {\n+                    Handle::new_edge(node.reborrow_mut(), i as usize).correct_parent_link();\n+                }\n+            }\n+        }\n+    }\n }\n \n impl<BorrowType, K, V, HandleType>"}, {"sha": "5419d7a301a00d581043203d7ae513d42a9a9618", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/241a3e4689d3004daf9e1d36cec2235cbd301fbf/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/241a3e4689d3004daf9e1d36cec2235cbd301fbf/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=241a3e4689d3004daf9e1d36cec2235cbd301fbf", "patch": "@@ -545,6 +545,41 @@ impl<T: Ord> BTreeSet<T> {\n     {\n         Recover::take(&mut self.map, value)\n     }\n+\n+    /// Moves all elements from `other` into `Self`, leaving `other` empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(btree_append)]\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut a = BTreeSet::new();\n+    /// a.insert(1);\n+    /// a.insert(2);\n+    /// a.insert(3);\n+    ///\n+    /// let mut b = BTreeSet::new();\n+    /// b.insert(3);\n+    /// b.insert(4);\n+    /// b.insert(5);\n+    ///\n+    /// a.append(&mut b);\n+    ///\n+    /// assert_eq!(a.len(), 5);\n+    /// assert_eq!(b.len(), 0);\n+    ///\n+    /// assert!(a.contains(&1));\n+    /// assert!(a.contains(&2));\n+    /// assert!(a.contains(&3));\n+    /// assert!(a.contains(&4));\n+    /// assert!(a.contains(&5));\n+    /// ```\n+    #[unstable(feature = \"btree_append\", reason = \"recently added as part of collections reform 2\",\n+               issue = \"19986\")]\n+    pub fn append(&mut self, other: &mut Self) {\n+        self.map.append(&mut other.map);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "1858791776f0e305b6caffc7b6231dbfd1d37107", "filename": "src/libcollectionstest/btree/map.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/241a3e4689d3004daf9e1d36cec2235cbd301fbf/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/241a3e4689d3004daf9e1d36cec2235cbd301fbf/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmap.rs?ref=241a3e4689d3004daf9e1d36cec2235cbd301fbf", "patch": "@@ -446,6 +446,58 @@ fn test_vacant_entry_key() {\n     assert_eq!(a[key], value);\n }\n \n+macro_rules! create_append_test {\n+    ($name:ident, $len:expr) => {\n+        #[test]\n+        fn $name() {\n+            let mut a = BTreeMap::new();\n+            for i in 0..8 {\n+                a.insert(i, i);\n+            }\n+\n+            let mut b = BTreeMap::new();\n+            for i in 5..$len {\n+                b.insert(i, 2*i);\n+            }\n+\n+            a.append(&mut b);\n+\n+            assert_eq!(a.len(), $len);\n+            assert_eq!(b.len(), 0);\n+\n+            for i in 0..$len {\n+                if i < 5 {\n+                    assert_eq!(a[&i], i);\n+                } else {\n+                    assert_eq!(a[&i], 2*i);\n+                }\n+            }\n+\n+            assert_eq!(a.remove(&($len-1)), Some(2*($len-1)));\n+            assert_eq!(a.insert($len-1, 20), None);\n+        }\n+    };\n+}\n+\n+// These are mostly for testing the algorithm that \"fixes\" the right edge after insertion.\n+// Single node.\n+create_append_test!(test_append_9, 9);\n+// Two leafs that don't need fixing.\n+create_append_test!(test_append_17, 17);\n+// Two leafs where the second one ends up underfull and needs stealing at the end.\n+create_append_test!(test_append_14, 14);\n+// Two leafs where the second one ends up empty because the insertion finished at the root.\n+create_append_test!(test_append_12, 12);\n+// Three levels; insertion finished at the root.\n+create_append_test!(test_append_144, 144);\n+// Three levels; insertion finished at leaf while there is an empty node on the second level.\n+create_append_test!(test_append_145, 145);\n+// Tests for several randomly chosen sizes.\n+create_append_test!(test_append_170, 170);\n+create_append_test!(test_append_181, 181);\n+create_append_test!(test_append_239, 239);\n+create_append_test!(test_append_1700, 1700);\n+\n mod bench {\n     use std::collections::BTreeMap;\n     use std::__rand::{Rng, thread_rng};"}, {"sha": "53ccfd5b4e26dc0c4dbd3325457b46828cf03616", "filename": "src/libcollectionstest/btree/set.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/241a3e4689d3004daf9e1d36cec2235cbd301fbf/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/241a3e4689d3004daf9e1d36cec2235cbd301fbf/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fset.rs?ref=241a3e4689d3004daf9e1d36cec2235cbd301fbf", "patch": "@@ -265,3 +265,27 @@ fn test_variance() {\n     fn into_iter<'new>(v: IntoIter<&'static str>) -> IntoIter<&'new str> { v }\n     fn range<'a, 'new>(v: Range<'a, &'static str>) -> Range<'a, &'new str> { v }\n }\n+\n+#[test]\n+fn test_append() {\n+    let mut a = BTreeSet::new();\n+    a.insert(1);\n+    a.insert(2);\n+    a.insert(3);\n+\n+    let mut b = BTreeSet::new();\n+    b.insert(3);\n+    b.insert(4);\n+    b.insert(5);\n+\n+    a.append(&mut b);\n+\n+    assert_eq!(a.len(), 5);\n+    assert_eq!(b.len(), 0);\n+\n+    assert_eq!(a.contains(&1), true);\n+    assert_eq!(a.contains(&2), true);\n+    assert_eq!(a.contains(&3), true);\n+    assert_eq!(a.contains(&4), true);\n+    assert_eq!(a.contains(&5), true);\n+}"}, {"sha": "e4152b99d2c6fefc3642b043eb4aa8f6c821ffc4", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/241a3e4689d3004daf9e1d36cec2235cbd301fbf/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/241a3e4689d3004daf9e1d36cec2235cbd301fbf/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=241a3e4689d3004daf9e1d36cec2235cbd301fbf", "patch": "@@ -13,6 +13,7 @@\n #![feature(binary_heap_extras)]\n #![feature(binary_heap_append)]\n #![feature(box_syntax)]\n+#![feature(btree_append)]\n #![feature(btree_range)]\n #![feature(collections)]\n #![feature(collections_bound)]"}, {"sha": "44613d776712f82e5fcc56e60f02912c49cda0ef", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/241a3e4689d3004daf9e1d36cec2235cbd301fbf/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/241a3e4689d3004daf9e1d36cec2235cbd301fbf/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=241a3e4689d3004daf9e1d36cec2235cbd301fbf", "patch": "@@ -120,12 +120,10 @@\n //!\n //! For Sets, all operations have the cost of the equivalent Map operation.\n //!\n-//! |          | get       | insert   | remove   | predecessor |\n-//! |----------|-----------|----------|----------|-------------|\n-//! | HashMap  | O(1)~     | O(1)~*   | O(1)~    | N/A         |\n-//! | BTreeMap | O(log n)  | O(log n) | O(log n) | O(log n)    |\n-//!\n-//! Note that BTreeMap's precise performance depends on the value of B.\n+//! |          | get       | insert   | remove   | predecessor | append |\n+//! |----------|-----------|----------|----------|-------------|--------|\n+//! | HashMap  | O(1)~     | O(1)~*   | O(1)~    | N/A         | N/A    |\n+//! | BTreeMap | O(log n)  | O(log n) | O(log n) | O(log n)    | O(n+m) |\n //!\n //! # Correct and Efficient Usage of Collections\n //!"}]}