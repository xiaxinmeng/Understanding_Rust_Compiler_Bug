{"sha": "cf1fa94be1e98dba2ce1755e1c86acef50daf599", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMWZhOTRiZTFlOThkYmEyY2UxNzU1ZTFjODZhY2VmNTBkYWY1OTk=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2016-12-02T18:19:52Z"}, "committer": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2016-12-02T18:19:52Z"}, "message": "down to for-loops not comparing as equal", "tree": {"sha": "fbb7b7e39570241bf6da3cebaf947b3f26f337ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbb7b7e39570241bf6da3cebaf947b3f26f337ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf1fa94be1e98dba2ce1755e1c86acef50daf599", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf1fa94be1e98dba2ce1755e1c86acef50daf599", "html_url": "https://github.com/rust-lang/rust/commit/cf1fa94be1e98dba2ce1755e1c86acef50daf599", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf1fa94be1e98dba2ce1755e1c86acef50daf599/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16aab716886b9d00ca6e58d502faefdc55477cc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/16aab716886b9d00ca6e58d502faefdc55477cc6", "html_url": "https://github.com/rust-lang/rust/commit/16aab716886b9d00ca6e58d502faefdc55477cc6"}], "stats": {"total": 101, "additions": 41, "deletions": 60}, "files": [{"sha": "ac6c0cb98e26eabd6aeb0653f2e844638909c95f", "filename": "clippy_lints/src/utils/hir.rs", "status": "modified", "additions": 37, "deletions": 58, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/cf1fa94be1e98dba2ce1755e1c86acef50daf599/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf1fa94be1e98dba2ce1755e1c86acef50daf599/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir.rs?ref=cf1fa94be1e98dba2ce1755e1c86acef50daf599", "patch": "@@ -1,6 +1,7 @@\n use consts::constant;\n use rustc::lint::*;\n use rustc::hir::*;\n+use rustc::hir::def::Def;\n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n use syntax::ast::{Name, NodeId};\n@@ -103,8 +104,8 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&ExprLoop(ref lb, ref ll, ref lls), &ExprLoop(ref rb, ref rl, ref rls)) => {\n                 self.eq_block(lb, rb) && both(ll, rl, |l, r| l.node.as_str() == r.node.as_str()) && lls == rls\n             }\n-            (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n-                ls == rs && self.eq_expr(le, re) &&\n+            (&ExprMatch(ref le, ref la, _), &ExprMatch(ref re, ref ra, _)) => {\n+                self.eq_expr(le, re) &&\n                 over(la, ra, |l, r| {\n                     self.eq_expr(&l.body, &r.body) && both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r)) &&\n                     over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n@@ -118,9 +119,10 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             }\n             (&ExprRepeat(ref le, ref ll), &ExprRepeat(ref re, ref rl)) => self.eq_expr(le, re) && self.eq_expr(ll, rl),\n             (&ExprRet(ref l), &ExprRet(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n-            (&ExprPath(ref l), &ExprPath(ref r)) => self.eq_qpath(l, r),\n+            (&ExprPath(ref l), &ExprPath(ref r)) => self.eq_qpath(l, left.id, r, right.id),\n             (&ExprStruct(ref l_path, ref lf, ref lo), &ExprStruct(ref r_path, ref rf, ref ro)) => {\n-                self.eq_qpath(l_path, r_path) && both(lo, ro, |l, r| self.eq_expr(l, r)) &&\n+                self.eq_qpath(l_path, left.id, r_path, right.id) &&\n+                both(lo, ro, |l, r| self.eq_expr(l, r)) &&\n                 over(lf, rf, |l, r| self.eq_field(l, r))\n             }\n             (&ExprTup(ref l_tup), &ExprTup(ref r_tup)) => self.eq_exprs(l_tup, r_tup),\n@@ -142,21 +144,17 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         left.name.node == right.name.node && self.eq_expr(&left.expr, &right.expr)\n     }\n \n-    fn eq_lifetime(&self, left: &Lifetime, right: &Lifetime) -> bool {\n-        left.name == right.name\n-    }\n-\n     /// Check whether two patterns are the same.\n     pub fn eq_pat(&self, left: &Pat, right: &Pat) -> bool {\n         match (&left.node, &right.node) {\n             (&PatKind::Box(ref l), &PatKind::Box(ref r)) => self.eq_pat(l, r),\n             (&PatKind::TupleStruct(ref lp, ref la, ls), &PatKind::TupleStruct(ref rp, ref ra, rs)) => {\n-                self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n+                self.eq_qpath(lp, left.id, rp, right.id) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n             }\n-            (&PatKind::Binding(ref lb, ref ld, ref li, ref lp), &PatKind::Binding(ref rb, ref rd, ref ri, ref rp)) => {\n-                lb == rb && ld == rd && li.node.as_str() == ri.node.as_str() && both(lp, rp, |l, r| self.eq_pat(l, r))\n+            (&PatKind::Binding(ref lb, _, ref li, ref lp), &PatKind::Binding(ref rb, _, ref ri, ref rp)) => {\n+                lb == rb && li.node.as_str() == ri.node.as_str() && both(lp, rp, |l, r| self.eq_pat(l, r))\n             }\n-            (&PatKind::Path(ref l), &PatKind::Path(ref r)) => self.eq_qpath(l, r),\n+            (&PatKind::Path(ref l), &PatKind::Path(ref r)) => self.eq_qpath(l, left.id, r, right.id),\n             (&PatKind::Lit(ref l), &PatKind::Lit(ref r)) => self.eq_expr(l, r),\n             (&PatKind::Tuple(ref l, ls), &PatKind::Tuple(ref r, rs)) => {\n                 ls == rs && over(l, r, |l, r| self.eq_pat(l, r))\n@@ -174,48 +172,23 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_qpath(&self, left: &QPath, right: &QPath) -> bool {\n-        match (left, right) {\n-            (&QPath::Resolved(ref lty, ref lpath), &QPath::Resolved(ref rty, ref rpath)) => {\n-                both(lty, rty, |l, r| self.eq_ty(l, r)) && self.eq_path(lpath, rpath)\n-            },\n-            (&QPath::TypeRelative(ref lty, ref lseg), &QPath::TypeRelative(ref rty, ref rseg)) => {\n-                self.eq_ty(lty, rty) && self.eq_path_segment(lseg, rseg)\n-            },\n-            _ => false,\n-        }\n-    }\n-\n-    fn eq_path(&self, left: &Path, right: &Path) -> bool {\n-        left.global == right.global &&\n-        over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n-    }\n+    fn eq_qpath(&self, left: &QPath, lid: NodeId, right: &QPath, rid: NodeId) -> bool {\n+        let l = self.cx.tcx.tables().qpath_def(left, lid);\n+        let r = self.cx.tcx.tables().qpath_def(right, rid);\n \n-    fn eq_path_parameters(&self, left: &PathParameters, right: &PathParameters) -> bool {\n-        match (left, right) {\n-            (&AngleBracketedParameters(ref left), &AngleBracketedParameters(ref right)) => {\n-                over(&left.lifetimes, &right.lifetimes, |l, r| self.eq_lifetime(l, r)) &&\n-                over(&left.types, &right.types, |l, r| self.eq_ty(l, r)) &&\n-                over(&left.bindings, &right.bindings, |l, r| self.eq_type_binding(l, r))\n-            }\n-            (&ParenthesizedParameters(ref left), &ParenthesizedParameters(ref right)) => {\n-                over(&left.inputs, &right.inputs, |l, r| self.eq_ty(l, r)) &&\n-                both(&left.output, &right.output, |l, r| self.eq_ty(l, r))\n-            }\n-            (&AngleBracketedParameters(_), &ParenthesizedParameters(_)) |\n-            (&ParenthesizedParameters(_), &AngleBracketedParameters(_)) => {\n-                false\n+        if let (Def::Local(_), Def::Local(_)) = (l, r) {\n+            if let (&QPath::Resolved(None, ref l), &QPath::Resolved(None, ref r)) = (left, right) {\n+                assert_eq!(l.segments.len(), 1);\n+                assert_eq!(r.segments.len(), 1);\n+                l.segments[0].name == r.segments[0].name\n+            } else {\n+                unreachable!();\n             }\n+        } else {\n+            l == r\n         }\n     }\n \n-    fn eq_path_segment(&self, left: &PathSegment, right: &PathSegment) -> bool {\n-        // The == of idents doesn't work with different contexts,\n-        // we have to be explicit about hygiene\n-        left.name.as_str() == right.name.as_str() &&\n-        self.eq_path_parameters(&left.parameters, &right.parameters)\n-    }\n-\n     fn eq_ty(&self, left: &Ty, right: &Ty) -> bool {\n         match (&left.node, &right.node) {\n             (&TySlice(ref l_vec), &TySlice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n@@ -226,16 +199,12 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&TyRptr(_, ref l_rmut), &TyRptr(_, ref r_rmut)) => {\n                 l_rmut.mutbl == r_rmut.mutbl && self.eq_ty(&*l_rmut.ty, &*r_rmut.ty)\n             }\n-            (&TyPath(ref l), &TyPath(ref r)) => self.eq_qpath(l, r),\n+            (&TyPath(ref l), &TyPath(ref r)) => self.eq_qpath(l, left.id, r, right.id),\n             (&TyTup(ref l), &TyTup(ref r)) => over(l, r, |l, r| self.eq_ty(l, r)),\n             (&TyInfer, &TyInfer) => true,\n             _ => false,\n         }\n     }\n-\n-    fn eq_type_binding(&self, left: &TypeBinding, right: &TypeBinding) -> bool {\n-        left.name == right.name && self.eq_ty(&left.ty, &right.ty)\n-    }\n }\n \n fn swap_binop<'a>(binop: BinOp_, lhs: &'a Expr, rhs: &'a Expr) -> Option<(BinOp_, &'a Expr, &'a Expr)> {\n@@ -420,7 +389,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 }\n                 j.hash(&mut self.s);\n             }\n-            ExprMatch(ref e, ref arms, ref s) => {\n+            ExprMatch(ref e, ref arms, _) => {\n                 let c: fn(_, _, _) -> _ = ExprMatch;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n@@ -432,8 +401,6 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                     }\n                     self.hash_expr(&arm.body);\n                 }\n-\n-                s.hash(&mut self.s);\n             }\n             ExprMethodCall(ref name, ref _tys, ref args) => {\n                 let c: fn(_, _, _) -> _ = ExprMethodCall;\n@@ -529,7 +496,19 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n     }\n \n     pub fn hash_qpath(&mut self, p: &QPath, id: NodeId) {\n-        self.cx.tcx.tables().qpath_def(p, id).hash(&mut self.s);\n+        let def = self.cx.tcx.tables().qpath_def(p, id);\n+        if let Def::Local(_) = def {\n+            true.hash(&mut self.s);\n+            if let QPath::Resolved(None, ref seq) = *p {\n+                assert_eq!(seq.segments.len(), 1);\n+                self.hash_name(&seq.segments[0].name);\n+            } else {\n+                unreachable!();\n+            }\n+        } else {\n+            false.hash(&mut self.s);\n+            def.hash(&mut self.s);\n+        }\n     }\n \n     pub fn hash_path(&mut self, p: &Path) {"}, {"sha": "ed343c3ba7a85d898485b9829d135f4e60266465", "filename": "tests/compile-fail/copies.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf1fa94be1e98dba2ce1755e1c86acef50daf599/tests%2Fcompile-fail%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf1fa94be1e98dba2ce1755e1c86acef50daf599/tests%2Fcompile-fail%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopies.rs?ref=cf1fa94be1e98dba2ce1755e1c86acef50daf599", "patch": "@@ -224,16 +224,18 @@ fn if_same_then_else() -> Result<&'static str, ()> {\n     }\n \n     if true {\n+        //~^NOTE same as this\n         if let Some(42) = None {}\n     }\n-    else {\n+    else { //~ERROR this `if` has identical blocks\n         if let Option::Some(42) = None {}\n     }\n \n     if true {\n+        //~^NOTE same as this\n         if let Some(42) = None::<u8> {}\n     }\n-    else {\n+    else { //~ERROR this `if` has identical blocks\n         if let Some(42) = None {}\n     }\n "}]}