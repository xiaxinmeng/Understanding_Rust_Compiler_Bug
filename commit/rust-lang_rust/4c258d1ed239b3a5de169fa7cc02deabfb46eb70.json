{"sha": "4c258d1ed239b3a5de169fa7cc02deabfb46eb70", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMjU4ZDFlZDIzOWIzYTVkZTE2OWZhN2NjMDJkZWFiZmI0NmViNzA=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-07-07T11:17:08Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-07-07T11:17:08Z"}, "message": "Merge remote-tracking branch 'origin/master' into alignment", "tree": {"sha": "86bf2cbf97a3ecf0e51dd5f3d3bf2ab8a14b8d32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86bf2cbf97a3ecf0e51dd5f3d3bf2ab8a14b8d32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c258d1ed239b3a5de169fa7cc02deabfb46eb70", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXfjo2AAoJEFbW7qD8Z6xGawYP/2WiN2qiyB5EC19b8UXrXu3D\nhi0Wj9/Q8Uv5tJCXe+XyKS/Lw9YivXP5YMwxw8/EPyir4QUt1KI3MZEGhxuk2z7Z\np1rOKT3GS4HU83vKrPFiZc/XWTmvCACYGGllsxFBKw6o2lSZm9Zjo314rnoSGA/M\nj7S2x7oD3cLSi8RNuOQHF0ui6XyyJQnhQWg9ty36kLDyZX8PZzQ10h3O8+pvkZ84\n3SXZ6mPUM9ceCkLwDP46hChYrnQ8sUN1q6pbgwixQLXDH0HfM5hNVRGO0KRE08NR\nTGEJ3Nla5DDelkNZ2f5TmU0T3nTp95DH0oqdb6RfFcLVIVv0bEaSQoX7kuyzxgZg\nFtRP8J1YWxPU0VRR1151spKexgB66Z0LfRuitxy8Ax6+LNYwaHzQ3agfGhYCyKsO\nh79aut9tg/yWDlhTFKrZDGddGMKp+IJ/nwbWfAfggnYBGP8tXSpLCB92VM9Tbpx/\n0BXvqR6Wvgd7gzmNS2ItuESwbyIttTZriLMxEu2CzJFCQPppZ9/RhFJ//yOnccaE\ntkTJc3U4WKqN4jDWUup8q1OmKxDp5oFGzgrj+T6RsM7dOe8o56Fehou6DyEWbZv4\nAJBts7qfmIzywgclywzc6qWD71Lp2w/Ab32MgWYNmpuKkJNuNGJlawgWQqs2PsJh\n4cPCUnXhoBHeNsscdUFY\n=O/xP\n-----END PGP SIGNATURE-----", "payload": "tree 86bf2cbf97a3ecf0e51dd5f3d3bf2ab8a14b8d32\nparent aca691160dbeae0c18049d1c23091e644261b528\nparent 0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1467890228 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1467890228 +0200\n\nMerge remote-tracking branch 'origin/master' into alignment\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c258d1ed239b3a5de169fa7cc02deabfb46eb70", "html_url": "https://github.com/rust-lang/rust/commit/4c258d1ed239b3a5de169fa7cc02deabfb46eb70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c258d1ed239b3a5de169fa7cc02deabfb46eb70/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aca691160dbeae0c18049d1c23091e644261b528", "url": "https://api.github.com/repos/rust-lang/rust/commits/aca691160dbeae0c18049d1c23091e644261b528", "html_url": "https://github.com/rust-lang/rust/commit/aca691160dbeae0c18049d1c23091e644261b528"}, {"sha": "0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06", "url": "https://api.github.com/repos/rust-lang/rust/commits/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06", "html_url": "https://github.com/rust-lang/rust/commit/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06"}], "stats": {"total": 162, "additions": 138, "deletions": 24}, "files": [{"sha": "14a947302c65e0e3eb528c7ade72011a8dcb2a2d", "filename": "src/bin/miri.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c258d1ed239b3a5de169fa7cc02deabfb46eb70/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c258d1ed239b3a5de169fa7cc02deabfb46eb70/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=4c258d1ed239b3a5de169fa7cc02deabfb46eb70", "patch": "@@ -4,7 +4,6 @@ extern crate getopts;\n extern crate miri;\n extern crate rustc;\n extern crate rustc_driver;\n-extern crate rustc_plugin;\n extern crate env_logger;\n extern crate log_settings;\n extern crate syntax;\n@@ -54,9 +53,9 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n                         match item.node {\n                             MetaItemKind::NameValue(ref name, ref value) => {\n                                 match &**name {\n-                                    \"memory_size\" => memory_size = extract_str(value).parse::<u64>().expect(\"not a number\"),\n-                                    \"step_limit\" => step_limit = extract_str(value).parse::<u64>().expect(\"not a number\"),\n-                                    \"stack_limit\" => stack_limit = extract_str(value).parse::<u64>().expect(\"not a number\"),\n+                                    \"memory_size\" => memory_size = extract_str(value).parse().expect(\"not a number\"),\n+                                    \"step_limit\" => step_limit = extract_str(value).parse().expect(\"not a number\"),\n+                                    \"stack_limit\" => stack_limit = extract_str(value).parse().expect(\"not a number\"),\n                                     _ => state.session.span_err(item.span, \"unknown miri attribute\"),\n                                 }\n                             }"}, {"sha": "5b39399070c22cefa799f6550b0f95092873dfa1", "filename": "src/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c258d1ed239b3a5de169fa7cc02deabfb46eb70/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c258d1ed239b3a5de169fa7cc02deabfb46eb70/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=4c258d1ed239b3a5de169fa7cc02deabfb46eb70", "patch": "@@ -30,9 +30,9 @@ pub enum EvalError<'tcx> {\n     Math(Span, ConstMathErr),\n     InvalidChar(u32),\n     OutOfMemory {\n-        allocation_size: u64,\n-        memory_size: u64,\n-        memory_usage: u64,\n+        allocation_size: usize,\n+        memory_size: usize,\n+        memory_usage: usize,\n     },\n     ExecutionTimeLimitReached,\n     StackFrameLimitReached,"}, {"sha": "16f2608528083aa1ede49fa8b49c34bee6a112a6", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4c258d1ed239b3a5de169fa7cc02deabfb46eb70/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c258d1ed239b3a5de169fa7cc02deabfb46eb70/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=4c258d1ed239b3a5de169fa7cc02deabfb46eb70", "patch": "@@ -136,16 +136,15 @@ enum ConstantKind {\n }\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir_map: &'a MirMap<'tcx>, memory_size: u64, stack_limit: u64) -> Self {\n-        assert_eq!(stack_limit as usize as u64, stack_limit);\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir_map: &'a MirMap<'tcx>, memory_size: usize, stack_limit: usize) -> Self {\n         EvalContext {\n             tcx: tcx,\n             mir_map: mir_map,\n             mir_cache: RefCell::new(DefIdMap()),\n             memory: Memory::new(&tcx.data_layout, memory_size),\n             statics: HashMap::new(),\n             stack: Vec::new(),\n-            stack_limit: stack_limit as usize,\n+            stack_limit: stack_limit,\n         }\n     }\n \n@@ -175,7 +174,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     // TODO(solson): Try making const_to_primval instead.\n     fn const_to_ptr(&mut self, const_val: &const_val::ConstVal) -> EvalResult<'tcx, Pointer> {\n         use rustc::middle::const_val::ConstVal::*;\n-        use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n+        use rustc_const_math::{ConstInt, ConstIsize, ConstUsize, ConstFloat};\n         macro_rules! i2p {\n             ($i:ident, $n:expr) => {{\n                 let ptr = self.memory.allocate($n, $n)?;\n@@ -184,7 +183,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }}\n         }\n         match *const_val {\n-            Float(_f) => unimplemented!(),\n+            Float(ConstFloat::F32(f)) => {\n+                let ptr = self.memory.allocate(4, 4)?;\n+                self.memory.write_f32(ptr, f)?;\n+                Ok(ptr)\n+            },\n+            Float(ConstFloat::F64(f)) => {\n+                let ptr = self.memory.allocate(8, 8)?;\n+                self.memory.write_f64(ptr, f)?;\n+                Ok(ptr)\n+            },\n+            Float(ConstFloat::FInfer{..}) => unreachable!(),\n             Integral(ConstInt::Infer(_)) => unreachable!(),\n             Integral(ConstInt::InferSigned(_)) => unreachable!(),\n             Integral(ConstInt::I8(i)) => i2p!(i, 1),\n@@ -856,7 +865,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     pub fn read_primval(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n-        use syntax::ast::{IntTy, UintTy};\n+        use syntax::ast::{IntTy, UintTy, FloatTy};\n         let val = match (self.memory.pointer_size(), &ty.sty) {\n             (_, &ty::TyBool)              => PrimVal::Bool(self.memory.read_bool(ptr)?),\n             (_, &ty::TyChar)              => {\n@@ -881,6 +890,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             (8, &ty::TyUint(UintTy::Us)) |\n             (_, &ty::TyUint(UintTy::U64)) => PrimVal::U64(self.memory.read_uint(ptr, 8)? as u64),\n \n+            (_, &ty::TyFloat(FloatTy::F32)) => PrimVal::F32(self.memory.read_f32(ptr)?),\n+            (_, &ty::TyFloat(FloatTy::F64)) => PrimVal::F64(self.memory.read_f64(ptr)?),\n+\n             (_, &ty::TyFnDef(def_id, substs, fn_ty)) => {\n                 PrimVal::FnPtr(self.memory.create_fn_ptr(def_id, substs, fn_ty))\n             },\n@@ -954,9 +966,9 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir_map: &'a MirMap<'tcx>,\n     node_id: ast::NodeId,\n-    memory_size: u64,\n+    memory_size: usize,\n     step_limit: u64,\n-    stack_limit: u64,\n+    stack_limit: usize,\n ) {\n     let mir = mir_map.map.get(&node_id).expect(\"no mir for main function\");\n     let def_id = tcx.map.local_def_id(node_id);"}, {"sha": "534276b7378c3f64a277082b4d2f1160634b9236", "filename": "src/memory.rs", "status": "modified", "additions": 68, "deletions": 9, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/4c258d1ed239b3a5de169fa7cc02deabfb46eb70/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c258d1ed239b3a5de169fa7cc02deabfb46eb70/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=4c258d1ed239b3a5de169fa7cc02deabfb46eb70", "patch": "@@ -87,9 +87,9 @@ pub struct Memory<'a, 'tcx> {\n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations)\n     alloc_map: HashMap<AllocId, Allocation>,\n     /// Number of virtual bytes allocated\n-    memory_usage: u64,\n+    memory_usage: usize,\n     /// Maximum number of virtual bytes that may be allocated\n-    memory_size: u64,\n+    memory_size: usize,\n     /// Function \"allocations\". They exist solely so pointers have something to point to, and\n     /// we can figure out what they point to.\n     functions: HashMap<AllocId, FunctionDefinition<'tcx>>,\n@@ -102,7 +102,7 @@ pub struct Memory<'a, 'tcx> {\n const ZST_ALLOC_ID: AllocId = AllocId(0);\n \n impl<'a, 'tcx> Memory<'a, 'tcx> {\n-    pub fn new(layout: &'a TargetDataLayout, max_memory: u64) -> Self {\n+    pub fn new(layout: &'a TargetDataLayout, max_memory: usize) -> Self {\n         let mut mem = Memory {\n             alloc_map: HashMap::new(),\n             functions: HashMap::new(),\n@@ -161,14 +161,14 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         // make sure we can offset the result pointer by the worst possible alignment\n         // this allows cheaply checking for alignment directly in the pointer\n         let least_aligned_size = size + align;\n-        if self.memory_size - self.memory_usage < size as u64 {\n+        if self.memory_size - self.memory_usage < size {\n             return Err(EvalError::OutOfMemory {\n-                allocation_size: least_aligned_size as u64,\n+                allocation_size: least_aligned_size,\n                 memory_size: self.memory_size,\n                 memory_usage: self.memory_usage,\n             });\n         }\n-        self.memory_usage += size as u64;\n+        self.memory_usage += size;\n         let alloc = Allocation {\n             bytes: vec![0; least_aligned_size],\n             relocations: BTreeMap::new(),\n@@ -201,14 +201,14 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n         if least_aligned_size > size {\n             let amount = least_aligned_size - size;\n-            self.memory_usage += amount as u64;\n+            self.memory_usage += amount;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n             alloc.bytes.extend(iter::repeat(0).take(amount));\n             alloc.undef_mask.grow(amount, false);\n         } else if size > least_aligned_size {\n             // it's possible to cause miri to use arbitrary amounts of memory that aren't detectable\n             // through the memory_usage value, by allocating a lot and reallocating to zero\n-            self.memory_usage -= (size - least_aligned_size) as u64;\n+            self.memory_usage -= size - least_aligned_size;\n             self.clear_relocations(ptr.offset(least_aligned_size as isize), size - least_aligned_size)?;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n             alloc.bytes.truncate(least_aligned_size);\n@@ -232,7 +232,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n \n         if let Some(alloc) = self.alloc_map.remove(&ptr.alloc_id) {\n-            self.memory_usage -= alloc.bytes.len() as u64;\n+            self.memory_usage -= alloc.bytes.len();\n         } else {\n             debug!(\"deallocated a pointer twice: {}\", ptr.alloc_id);\n             // TODO(solson): Report error about erroneous free. This is blocked on properly tracking\n@@ -457,6 +457,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             PrimVal::U64(n)  => self.write_uint(ptr, n as u64, 8),\n             PrimVal::Char(c) => self.write_uint(ptr, c as u64, 4),\n             PrimVal::IntegerPtr(n) => self.write_uint(ptr, n as u64, pointer_size),\n+            PrimVal::F32(f) => self.write_f32(ptr, f),\n+            PrimVal::F64(f) => self.write_f64(ptr, f),\n             PrimVal::FnPtr(_p) |\n             PrimVal::AbstractPtr(_p) => unimplemented!(),\n         }\n@@ -530,6 +532,32 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         let size = self.pointer_size();\n         self.write_uint(ptr, n, size)\n     }\n+\n+    pub fn write_f32(&mut self, ptr: Pointer, f: f32) -> EvalResult<'tcx, ()> {\n+        ptr.check_align(self.layout.f32_align.abi() as usize)?;\n+        let endianess = self.endianess();\n+        let b = self.get_bytes_mut(ptr, 4)?;\n+        write_target_f32(endianess, b, f).unwrap();\n+        Ok(())\n+    }\n+\n+    pub fn write_f64(&mut self, ptr: Pointer, f: f64) -> EvalResult<'tcx, ()> {\n+        ptr.check_align(self.layout.f64_align.abi() as usize)?;\n+        let endianess = self.endianess();\n+        let b = self.get_bytes_mut(ptr, 8)?;\n+        write_target_f64(endianess, b, f).unwrap();\n+        Ok(())\n+    }\n+\n+    pub fn read_f32(&self, ptr: Pointer) -> EvalResult<'tcx, f32> {\n+        ptr.check_align(self.layout.f32_align.abi() as usize)?;\n+        self.get_bytes(ptr, 4).map(|b| read_target_f32(self.endianess(), b).unwrap())\n+    }\n+\n+    pub fn read_f64(&self, ptr: Pointer) -> EvalResult<'tcx, f64> {\n+        ptr.check_align(self.layout.f64_align.abi() as usize)?;\n+        self.get_bytes(ptr, 8).map(|b| read_target_f64(self.endianess(), b).unwrap())\n+    }\n }\n \n /// Relocations\n@@ -652,6 +680,36 @@ fn read_target_int(endianess: layout::Endian, mut source: &[u8]) -> Result<i64,\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Methods to access floats in the target endianess\n+////////////////////////////////////////////////////////////////////////////////\n+\n+fn write_target_f32(endianess: layout::Endian, mut target: &mut [u8], data: f32) -> Result<(), byteorder::Error> {\n+    match endianess {\n+        layout::Endian::Little => target.write_f32::<LittleEndian>(data),\n+        layout::Endian::Big => target.write_f32::<BigEndian>(data),\n+    }\n+}\n+fn write_target_f64(endianess: layout::Endian, mut target: &mut [u8], data: f64) -> Result<(), byteorder::Error> {\n+    match endianess {\n+        layout::Endian::Little => target.write_f64::<LittleEndian>(data),\n+        layout::Endian::Big => target.write_f64::<BigEndian>(data),\n+    }\n+}\n+\n+fn read_target_f32(endianess: layout::Endian, mut source: &[u8]) -> Result<f32, byteorder::Error> {\n+    match endianess {\n+        layout::Endian::Little => source.read_f32::<LittleEndian>(),\n+        layout::Endian::Big => source.read_f32::<BigEndian>(),\n+    }\n+}\n+fn read_target_f64(endianess: layout::Endian, mut source: &[u8]) -> Result<f64, byteorder::Error> {\n+    match endianess {\n+        layout::Endian::Little => source.read_f64::<LittleEndian>(),\n+        layout::Endian::Big => source.read_f64::<BigEndian>(),\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Undefined byte tracking\n ////////////////////////////////////////////////////////////////////////////////\n@@ -722,6 +780,7 @@ impl UndefMask {\n     fn truncate(&mut self, length: usize) {\n         self.len = length;\n         self.blocks.truncate(self.len / BLOCK_SIZE + 1);\n+        self.blocks.shrink_to_fit();\n     }\n }\n "}, {"sha": "966196d8d1a5f65a3aa1e9d3a9fe6154bf57ef7a", "filename": "src/primval.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4c258d1ed239b3a5de169fa7cc02deabfb46eb70/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c258d1ed239b3a5de169fa7cc02deabfb46eb70/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=4c258d1ed239b3a5de169fa7cc02deabfb46eb70", "patch": "@@ -13,6 +13,8 @@ pub enum PrimVal {\n     FnPtr(Pointer),\n     IntegerPtr(u64),\n     Char(char),\n+\n+    F32(f32), F64(f64),\n }\n \n /// returns the result of the operation and whether the operation overflowed\n@@ -57,6 +59,32 @@ pub fn binary_op<'tcx>(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> Eva\n         })\n     }\n \n+    macro_rules! float_binops {\n+        ($v:ident, $l:ident, $r:ident) => ({\n+            match bin_op {\n+                Add    => $v($l + $r),\n+                Sub    => $v($l - $r),\n+                Mul    => $v($l * $r),\n+                Div    => $v($l / $r),\n+                Rem    => $v($l % $r),\n+\n+                // invalid float ops\n+                BitXor => unreachable!(),\n+                BitAnd => unreachable!(),\n+                BitOr  => unreachable!(),\n+                Shl => unreachable!(),\n+                Shr => unreachable!(),\n+\n+                Eq => Bool($l == $r),\n+                Ne => Bool($l != $r),\n+                Lt => Bool($l < $r),\n+                Le => Bool($l <= $r),\n+                Gt => Bool($l > $r),\n+                Ge => Bool($l >= $r),\n+            }\n+        })\n+    }\n+\n     fn unrelated_ptr_ops<'tcx>(bin_op: mir::BinOp) -> EvalResult<'tcx, PrimVal> {\n         use rustc::mir::repr::BinOp::*;\n         match bin_op {\n@@ -128,6 +156,8 @@ pub fn binary_op<'tcx>(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> Eva\n         (U16(l), U16(r)) => int_binops!(U16, l, r),\n         (U32(l), U32(r)) => int_binops!(U32, l, r),\n         (U64(l), U64(r)) => int_binops!(U64, l, r),\n+        (F32(l), F32(r)) => float_binops!(F32, l, r),\n+        (F64(l), F64(r)) => float_binops!(F64, l, r),\n         (Char(l), Char(r)) => match bin_op {\n             Eq => Bool(l == r),\n             Ne => Bool(l != r),\n@@ -211,6 +241,9 @@ pub fn unary_op<'tcx>(un_op: mir::UnOp, val: PrimVal) -> EvalResult<'tcx, PrimVa\n         (Not, U16(n)) => Ok(U16(!n)),\n         (Not, U32(n)) => Ok(U32(!n)),\n         (Not, U64(n)) => Ok(U64(!n)),\n+\n+        (Neg, F64(n)) => Ok(F64(-n)),\n+        (Neg, F32(n)) => Ok(F32(-n)),\n         _ => Err(EvalError::Unimplemented(format!(\"unimplemented unary op: {:?}, {:?}\", un_op, val))),\n     }\n }"}, {"sha": "9c4d0594d1c9916dac909bcdd5087008a2b79e6c", "filename": "tests/run-pass/floats.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4c258d1ed239b3a5de169fa7cc02deabfb46eb70/tests%2Frun-pass%2Ffloats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c258d1ed239b3a5de169fa7cc02deabfb46eb70/tests%2Frun-pass%2Ffloats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffloats.rs?ref=4c258d1ed239b3a5de169fa7cc02deabfb46eb70", "patch": "@@ -0,0 +1,11 @@\n+\n+fn main() {\n+    assert_eq!(6.0_f32*6.0_f32, 36.0_f32);\n+    assert_eq!(6.0_f64*6.0_f64, 36.0_f64);\n+    assert_eq!(-{5.0_f32}, -5.0_f32);\n+    assert!((5.0_f32/0.0).is_infinite());\n+    assert!((-5.0_f32).sqrt().is_nan());\n+    let x: u64 = unsafe { std::mem::transmute(42.0_f64) };\n+    let y: f64 = unsafe { std::mem::transmute(x) };\n+    assert_eq!(y, 42.0_f64);\n+}"}]}