{"sha": "1d9646228d8198d9c41eaa00c765de8c7bf62d69", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkOTY0NjIyOGQ4MTk4ZDljNDFlYWEwMGM3NjVkZThjN2JmNjJkNjk=", "commit": {"author": {"name": "Jonathan Turner", "email": "jonathandturner@users.noreply.github.com", "date": "2016-09-27T00:29:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-27T00:29:47Z"}, "message": "Rollup merge of #36662 - jseyfried:parse_macro_invoc_paths, r=nrc\n\nparser: support paths in bang macro invocations (e.g. `path::to::macro!()`)\n\nr? @nrc", "tree": {"sha": "3418fba851d6d6ffe1152302caa570a2202d9c99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3418fba851d6d6ffe1152302caa570a2202d9c99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d9646228d8198d9c41eaa00c765de8c7bf62d69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d9646228d8198d9c41eaa00c765de8c7bf62d69", "html_url": "https://github.com/rust-lang/rust/commit/1d9646228d8198d9c41eaa00c765de8c7bf62d69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d9646228d8198d9c41eaa00c765de8c7bf62d69/comments", "author": {"login": "jonathandturner", "id": 111457284, "node_id": "O_kgDOBqS0BA", "avatar_url": "https://avatars.githubusercontent.com/u/111457284?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonathandturner", "html_url": "https://github.com/jonathandturner", "followers_url": "https://api.github.com/users/jonathandturner/followers", "following_url": "https://api.github.com/users/jonathandturner/following{/other_user}", "gists_url": "https://api.github.com/users/jonathandturner/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonathandturner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonathandturner/subscriptions", "organizations_url": "https://api.github.com/users/jonathandturner/orgs", "repos_url": "https://api.github.com/users/jonathandturner/repos", "events_url": "https://api.github.com/users/jonathandturner/events{/privacy}", "received_events_url": "https://api.github.com/users/jonathandturner/received_events", "type": "Organization", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3775be853ec7da01d515d25117dc3272f343a017", "url": "https://api.github.com/repos/rust-lang/rust/commits/3775be853ec7da01d515d25117dc3272f343a017", "html_url": "https://github.com/rust-lang/rust/commit/3775be853ec7da01d515d25117dc3272f343a017"}, {"sha": "34f4ad1b717feb604bf5818d726d3472d6aca48d", "url": "https://api.github.com/repos/rust-lang/rust/commits/34f4ad1b717feb604bf5818d726d3472d6aca48d", "html_url": "https://github.com/rust-lang/rust/commit/34f4ad1b717feb604bf5818d726d3472d6aca48d"}], "stats": {"total": 525, "additions": 265, "deletions": 260}, "files": [{"sha": "7d503953645c0edff8aaf208b03d2c43a6af72b2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 222, "deletions": 252, "changes": 474, "blob_url": "https://github.com/rust-lang/rust/blob/1d9646228d8198d9c41eaa00c765de8c7bf62d69/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9646228d8198d9c41eaa00c765de8c7bf62d69/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1d9646228d8198d9c41eaa00c765de8c7bf62d69", "patch": "@@ -542,11 +542,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_ident_into_path(&mut self) -> PResult<'a, ast::Path> {\n-        let ident = self.parse_ident()?;\n-        Ok(ast::Path::from_ident(self.last_span, ident))\n-    }\n-\n     /// Check if the next token is `tok`, and return `true` if so.\n     ///\n     /// This method will automatically add `tok` to `expected_tokens` if `tok` is not\n@@ -1202,94 +1197,87 @@ impl<'a> Parser<'a> {\n                 None\n             };\n             (ident, TraitItemKind::Const(ty, default))\n-        } else if !self.token.is_any_keyword()\n-            && self.look_ahead(1, |t| *t == token::Not)\n-            && (self.look_ahead(2, |t| *t == token::OpenDelim(token::Paren))\n-                || self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))) {\n-                // trait item macro.\n-                // code copied from parse_macro_use_or_failure... abstraction!\n-                let lo = self.span.lo;\n-                let pth = self.parse_ident_into_path()?;\n-                self.expect(&token::Not)?;\n+        } else if self.token.is_path_start() {\n+            // trait item macro.\n+            // code copied from parse_macro_use_or_failure... abstraction!\n+            let lo = self.span.lo;\n+            let pth = self.parse_path(PathStyle::Mod)?;\n+            self.expect(&token::Not)?;\n \n-                // eat a matched-delimiter token tree:\n-                let delim = self.expect_open_delim()?;\n-                let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n-                                             SeqSep::none(),\n-                                             |pp| pp.parse_token_tree())?;\n-                let m_ = Mac_ { path: pth, tts: tts };\n-                let m: ast::Mac = codemap::Spanned { node: m_,\n-                                                     span: mk_sp(lo,\n-                                                                 self.last_span.hi) };\n-                if delim != token::Brace {\n-                    self.expect(&token::Semi)?\n-                }\n-                (keywords::Invalid.ident(), ast::TraitItemKind::Macro(m))\n-            } else {\n-                let (constness, unsafety, abi) = match self.parse_fn_front_matter() {\n-                    Ok(cua) => cua,\n-                    Err(e) => {\n-                        loop {\n-                            match self.token {\n-                                token::Eof => break,\n-                                token::CloseDelim(token::Brace) |\n-                                token::Semi => {\n-                                    self.bump();\n-                                    break;\n-                                }\n-                                token::OpenDelim(token::Brace) => {\n-                                    self.parse_token_tree()?;\n-                                    break;\n-                                }\n-                                _ => self.bump()\n+            // eat a matched-delimiter token tree:\n+            let delim = self.expect_open_delim()?;\n+            let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n+                                            SeqSep::none(),\n+                                            |pp| pp.parse_token_tree())?;\n+            if delim != token::Brace {\n+                self.expect(&token::Semi)?\n+            }\n+\n+            let mac = spanned(lo, self.last_span.hi, Mac_ { path: pth, tts: tts });\n+            (keywords::Invalid.ident(), ast::TraitItemKind::Macro(mac))\n+        } else {\n+            let (constness, unsafety, abi) = match self.parse_fn_front_matter() {\n+                Ok(cua) => cua,\n+                Err(e) => {\n+                    loop {\n+                        match self.token {\n+                            token::Eof => break,\n+                            token::CloseDelim(token::Brace) |\n+                            token::Semi => {\n+                                self.bump();\n+                                break;\n+                            }\n+                            token::OpenDelim(token::Brace) => {\n+                                self.parse_token_tree()?;\n+                                break;\n                             }\n+                            _ => self.bump(),\n                         }\n-\n-                        return Err(e);\n                     }\n-                };\n \n-                let ident = self.parse_ident()?;\n-                let mut generics = self.parse_generics()?;\n+                    return Err(e);\n+                }\n+            };\n \n-                let d = self.parse_fn_decl_with_self(|p: &mut Parser<'a>|{\n-                    // This is somewhat dubious; We don't want to allow\n-                    // argument names to be left off if there is a\n-                    // definition...\n-                    p.parse_arg_general(false)\n-                })?;\n+            let ident = self.parse_ident()?;\n+            let mut generics = self.parse_generics()?;\n \n-                generics.where_clause = self.parse_where_clause()?;\n-                let sig = ast::MethodSig {\n-                    unsafety: unsafety,\n-                    constness: constness,\n-                    decl: d,\n-                    generics: generics,\n-                    abi: abi,\n-                };\n+            let d = self.parse_fn_decl_with_self(|p: &mut Parser<'a>|{\n+                // This is somewhat dubious; We don't want to allow\n+                // argument names to be left off if there is a\n+                // definition...\n+                p.parse_arg_general(false)\n+            })?;\n \n-                let body = match self.token {\n-                    token::Semi => {\n-                        self.bump();\n-                        debug!(\"parse_trait_methods(): parsing required method\");\n-                        None\n-                    }\n-                    token::OpenDelim(token::Brace) => {\n-                        debug!(\"parse_trait_methods(): parsing provided method\");\n-                        let (inner_attrs, body) =\n-                            self.parse_inner_attrs_and_block()?;\n-                        attrs.extend(inner_attrs.iter().cloned());\n-                        Some(body)\n-                    }\n+            generics.where_clause = self.parse_where_clause()?;\n+            let sig = ast::MethodSig {\n+                unsafety: unsafety,\n+                constness: constness,\n+                decl: d,\n+                generics: generics,\n+                abi: abi,\n+            };\n \n-                    _ => {\n-                        let token_str = self.this_token_to_string();\n-                        return Err(self.fatal(&format!(\"expected `;` or `{{`, found `{}`\",\n-                                                    token_str)[..]))\n-                    }\n-                };\n-                (ident, ast::TraitItemKind::Method(sig, body))\n+            let body = match self.token {\n+                token::Semi => {\n+                    self.bump();\n+                    debug!(\"parse_trait_methods(): parsing required method\");\n+                    None\n+                }\n+                token::OpenDelim(token::Brace) => {\n+                    debug!(\"parse_trait_methods(): parsing provided method\");\n+                    let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+                    attrs.extend(inner_attrs.iter().cloned());\n+                    Some(body)\n+                }\n+                _ => {\n+                    let token_str = self.this_token_to_string();\n+                    return Err(self.fatal(&format!(\"expected `;` or `{{`, found `{}`\", token_str)));\n+                }\n             };\n+            (ident, ast::TraitItemKind::Method(sig, body))\n+        };\n+\n         Ok(TraitItem {\n             id: ast::DUMMY_NODE_ID,\n             ident: name,\n@@ -1430,9 +1418,8 @@ impl<'a> Parser<'a> {\n             TyKind::Path(Some(qself), path)\n         } else if self.token.is_path_start() {\n             let path = self.parse_path(PathStyle::Type)?;\n-            if self.check(&token::Not) {\n+            if self.eat(&token::Not) {\n                 // MACRO INVOCATION\n-                self.bump();\n                 let delim = self.expect_open_delim()?;\n                 let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n                                                 SeqSep::none(),\n@@ -2310,21 +2297,14 @@ impl<'a> Parser<'a> {\n                     let pth = self.parse_path(PathStyle::Expr)?;\n \n                     // `!`, as an operator, is prefix, so we know this isn't that\n-                    if self.check(&token::Not) {\n+                    if self.eat(&token::Not) {\n                         // MACRO INVOCATION expression\n-                        self.bump();\n-\n                         let delim = self.expect_open_delim()?;\n-                        let tts = self.parse_seq_to_end(\n-                            &token::CloseDelim(delim),\n-                            SeqSep::none(),\n-                            |p| p.parse_token_tree())?;\n+                        let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n+                                                        SeqSep::none(),\n+                                                        |p| p.parse_token_tree())?;\n                         let hi = self.last_span.hi;\n-\n-                        return Ok(self.mk_mac_expr(lo,\n-                                                   hi,\n-                                                   Mac_ { path: pth, tts: tts },\n-                                                   attrs));\n+                        return Ok(self.mk_mac_expr(lo, hi, Mac_ { path: pth, tts: tts }, attrs));\n                     }\n                     if self.check(&token::OpenDelim(token::Brace)) {\n                         // This is a struct literal, unless we're prohibited\n@@ -2333,51 +2313,7 @@ impl<'a> Parser<'a> {\n                             Restrictions::RESTRICTION_NO_STRUCT_LITERAL\n                         );\n                         if !prohibited {\n-                            // It's a struct literal.\n-                            self.bump();\n-                            let mut fields = Vec::new();\n-                            let mut base = None;\n-\n-                            attrs.extend(self.parse_inner_attributes()?);\n-\n-                            while self.token != token::CloseDelim(token::Brace) {\n-                                if self.eat(&token::DotDot) {\n-                                    match self.parse_expr() {\n-                                        Ok(e) => {\n-                                            base = Some(e);\n-                                        }\n-                                        Err(mut e) => {\n-                                            e.emit();\n-                                            self.recover_stmt();\n-                                        }\n-                                    }\n-                                    break;\n-                                }\n-\n-                                match self.parse_field() {\n-                                    Ok(f) => fields.push(f),\n-                                    Err(mut e) => {\n-                                        e.emit();\n-                                        self.recover_stmt();\n-                                        break;\n-                                    }\n-                                }\n-\n-                                match self.expect_one_of(&[token::Comma],\n-                                                         &[token::CloseDelim(token::Brace)]) {\n-                                    Ok(()) => {}\n-                                    Err(mut e) => {\n-                                        e.emit();\n-                                        self.recover_stmt();\n-                                        break;\n-                                    }\n-                                }\n-                            }\n-\n-                            hi = self.span.hi;\n-                            self.expect(&token::CloseDelim(token::Brace))?;\n-                            ex = ExprKind::Struct(pth, fields, base);\n-                            return Ok(self.mk_expr(lo, hi, ex, attrs));\n+                            return self.parse_struct_expr(lo, pth, attrs);\n                         }\n                     }\n \n@@ -2403,6 +2339,53 @@ impl<'a> Parser<'a> {\n         return Ok(self.mk_expr(lo, hi, ex, attrs));\n     }\n \n+    fn parse_struct_expr(&mut self, lo: BytePos, pth: ast::Path, mut attrs: ThinVec<Attribute>)\n+                         -> PResult<'a, P<Expr>> {\n+        self.bump();\n+        let mut fields = Vec::new();\n+        let mut base = None;\n+\n+        attrs.extend(self.parse_inner_attributes()?);\n+\n+        while self.token != token::CloseDelim(token::Brace) {\n+            if self.eat(&token::DotDot) {\n+                match self.parse_expr() {\n+                    Ok(e) => {\n+                        base = Some(e);\n+                    }\n+                    Err(mut e) => {\n+                        e.emit();\n+                        self.recover_stmt();\n+                    }\n+                }\n+                break;\n+            }\n+\n+            match self.parse_field() {\n+                Ok(f) => fields.push(f),\n+                Err(mut e) => {\n+                    e.emit();\n+                    self.recover_stmt();\n+                    break;\n+                }\n+            }\n+\n+            match self.expect_one_of(&[token::Comma],\n+                                     &[token::CloseDelim(token::Brace)]) {\n+                Ok(()) => {}\n+                Err(mut e) => {\n+                    e.emit();\n+                    self.recover_stmt();\n+                    break;\n+                }\n+            }\n+        }\n+\n+        let hi = self.span.hi;\n+        self.expect(&token::CloseDelim(token::Brace))?;\n+        return Ok(self.mk_expr(lo, hi, ExprKind::Struct(pth, fields, base), attrs));\n+    }\n+\n     fn parse_or_use_outer_attributes(&mut self,\n                                      already_parsed_attrs: Option<ThinVec<Attribute>>)\n                                      -> PResult<'a, ThinVec<Attribute>> {\n@@ -3577,39 +3560,37 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n         let pat;\n         match self.token {\n-          token::Underscore => {\n-            // Parse _\n-            self.bump();\n-            pat = PatKind::Wild;\n-          }\n-          token::BinOp(token::And) | token::AndAnd => {\n-            // Parse &pat / &mut pat\n-            self.expect_and()?;\n-            let mutbl = self.parse_mutability()?;\n-            if let token::Lifetime(ident) = self.token {\n-                return Err(self.fatal(&format!(\"unexpected lifetime `{}` in pattern\", ident)));\n+            token::Underscore => {\n+                // Parse _\n+                self.bump();\n+                pat = PatKind::Wild;\n+            }\n+            token::BinOp(token::And) | token::AndAnd => {\n+                // Parse &pat / &mut pat\n+                self.expect_and()?;\n+                let mutbl = self.parse_mutability()?;\n+                if let token::Lifetime(ident) = self.token {\n+                    return Err(self.fatal(&format!(\"unexpected lifetime `{}` in pattern\", ident)));\n+                }\n+                let subpat = self.parse_pat()?;\n+                pat = PatKind::Ref(subpat, mutbl);\n+            }\n+            token::OpenDelim(token::Paren) => {\n+                // Parse (pat,pat,pat,...) as tuple pattern\n+                self.bump();\n+                let (fields, ddpos) = self.parse_pat_tuple_elements(true)?;\n+                self.expect(&token::CloseDelim(token::Paren))?;\n+                pat = PatKind::Tuple(fields, ddpos);\n+            }\n+            token::OpenDelim(token::Bracket) => {\n+                // Parse [pat,pat,...] as slice pattern\n+                self.bump();\n+                let (before, slice, after) = self.parse_pat_vec_elements()?;\n+                self.expect(&token::CloseDelim(token::Bracket))?;\n+                pat = PatKind::Vec(before, slice, after);\n             }\n-\n-            let subpat = self.parse_pat()?;\n-            pat = PatKind::Ref(subpat, mutbl);\n-          }\n-          token::OpenDelim(token::Paren) => {\n-            // Parse (pat,pat,pat,...) as tuple pattern\n-            self.bump();\n-            let (fields, ddpos) = self.parse_pat_tuple_elements(true)?;\n-            self.expect(&token::CloseDelim(token::Paren))?;\n-            pat = PatKind::Tuple(fields, ddpos);\n-          }\n-          token::OpenDelim(token::Bracket) => {\n-            // Parse [pat,pat,...] as slice pattern\n-            self.bump();\n-            let (before, slice, after) = self.parse_pat_vec_elements()?;\n-            self.expect(&token::CloseDelim(token::Bracket))?;\n-            pat = PatKind::Vec(before, slice, after);\n-          }\n-          _ => {\n             // At this point, token != _, &, &&, (, [\n-            if self.eat_keyword(keywords::Mut) {\n+            _ => if self.eat_keyword(keywords::Mut) {\n                 // Parse mut ident @ pat\n                 pat = self.parse_pat_ident(BindingMode::ByValue(Mutability::Mutable))?;\n             } else if self.eat_keyword(keywords::Ref) {\n@@ -3620,53 +3601,49 @@ impl<'a> Parser<'a> {\n                 // Parse box pat\n                 let subpat = self.parse_pat()?;\n                 pat = PatKind::Box(subpat);\n+            } else if self.token.is_ident() && self.token.is_path_start() &&\n+                      self.look_ahead(1, |t| match *t {\n+                          token::OpenDelim(token::Paren) | token::OpenDelim(token::Brace) |\n+                          token::DotDotDot | token::ModSep | token::Not => false,\n+                          _ => true,\n+                      }) {\n+                // Parse ident @ pat\n+                // This can give false positives and parse nullary enums,\n+                // they are dealt with later in resolve\n+                let binding_mode = BindingMode::ByValue(Mutability::Immutable);\n+                pat = self.parse_pat_ident(binding_mode)?;\n             } else if self.token.is_path_start() {\n                 // Parse pattern starting with a path\n-                if self.token.is_ident() && self.look_ahead(1, |t| *t != token::DotDotDot &&\n-                        *t != token::OpenDelim(token::Brace) &&\n-                        *t != token::OpenDelim(token::Paren) &&\n-                        *t != token::ModSep) {\n-                    // Plain idents have some extra abilities here compared to general paths\n-                    if self.look_ahead(1, |t| *t == token::Not) {\n+                let (qself, path) = if self.eat_lt() {\n+                    // Parse a qualified path\n+                    let (qself, path) = self.parse_qualified_path(PathStyle::Expr)?;\n+                    (Some(qself), path)\n+                } else {\n+                    // Parse an unqualified path\n+                    (None, self.parse_path(PathStyle::Expr)?)\n+                };\n+                match self.token {\n+                    token::Not if qself.is_none() => {\n                         // Parse macro invocation\n-                        let path = self.parse_ident_into_path()?;\n                         self.bump();\n                         let delim = self.expect_open_delim()?;\n-                        let tts = self.parse_seq_to_end(\n-                            &token::CloseDelim(delim),\n-                            SeqSep::none(), |p| p.parse_token_tree())?;\n-                        let mac = Mac_ { path: path, tts: tts };\n-                        pat = PatKind::Mac(codemap::Spanned {node: mac,\n-                                                               span: mk_sp(lo, self.last_span.hi)});\n-                    } else {\n-                        // Parse ident @ pat\n-                        // This can give false positives and parse nullary enums,\n-                        // they are dealt with later in resolve\n-                        let binding_mode = BindingMode::ByValue(Mutability::Immutable);\n-                        pat = self.parse_pat_ident(binding_mode)?;\n+                        let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n+                                                        SeqSep::none(),\n+                                                        |p| p.parse_token_tree())?;\n+                        let mac = spanned(lo, self.last_span.hi, Mac_ { path: path, tts: tts });\n+                        pat = PatKind::Mac(mac);\n                     }\n-                } else {\n-                    let (qself, path) = if self.eat_lt() {\n-                        // Parse a qualified path\n-                        let (qself, path) =\n-                            self.parse_qualified_path(PathStyle::Expr)?;\n-                        (Some(qself), path)\n-                    } else {\n-                        // Parse an unqualified path\n-                        (None, self.parse_path(PathStyle::Expr)?)\n-                    };\n-                    match self.token {\n-                      token::DotDotDot => {\n+                    token::DotDotDot => {\n                         // Parse range\n                         let hi = self.last_span.hi;\n                         let begin =\n                               self.mk_expr(lo, hi, ExprKind::Path(qself, path), ThinVec::new());\n                         self.bump();\n                         let end = self.parse_pat_range_end()?;\n                         pat = PatKind::Range(begin, end);\n-                      }\n-                      token::OpenDelim(token::Brace) => {\n-                         if qself.is_some() {\n+                    }\n+                    token::OpenDelim(token::Brace) => {\n+                        if qself.is_some() {\n                             return Err(self.fatal(\"unexpected `{` after qualified path\"));\n                         }\n                         // Parse struct pattern\n@@ -3678,8 +3655,8 @@ impl<'a> Parser<'a> {\n                         });\n                         self.bump();\n                         pat = PatKind::Struct(path, fields, etc);\n-                      }\n-                      token::OpenDelim(token::Paren) => {\n+                    }\n+                    token::OpenDelim(token::Paren) => {\n                         if qself.is_some() {\n                             return Err(self.fatal(\"unexpected `(` after qualified path\"));\n                         }\n@@ -3688,11 +3665,8 @@ impl<'a> Parser<'a> {\n                         let (fields, ddpos) = self.parse_pat_tuple_elements(false)?;\n                         self.expect(&token::CloseDelim(token::Paren))?;\n                         pat = PatKind::TupleStruct(path, fields, ddpos)\n-                      }\n-                      _ => {\n-                        pat = PatKind::Path(qself, path);\n-                      }\n                     }\n+                    _ => pat = PatKind::Path(qself, path),\n                 }\n             } else {\n                 // Try to parse everything else as literal with optional minus\n@@ -3712,7 +3686,6 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n             }\n-          }\n         }\n \n         let hi = self.last_span.hi;\n@@ -3894,16 +3867,33 @@ impl<'a> Parser<'a> {\n                 node: StmtKind::Local(self.parse_local(attrs.into())?),\n                 span: mk_sp(lo, self.last_span.hi),\n             }\n-        } else if self.token.is_ident()\n-            && !self.token.is_any_keyword()\n-            && self.look_ahead(1, |t| *t == token::Not) {\n-            // it's a macro invocation:\n+        } else if self.token.is_path_start() && self.token != token::Lt && {\n+            !self.check_keyword(keywords::Union) ||\n+            self.look_ahead(1, |t| *t == token::Not || *t == token::ModSep)\n+        } {\n+            let pth = self.parse_path(PathStyle::Expr)?;\n \n-            // Potential trouble: if we allow macros with paths instead of\n-            // idents, we'd need to look ahead past the whole path here...\n-            let pth = self.parse_ident_into_path()?;\n-            self.bump();\n+            if !self.eat(&token::Not) {\n+                let expr = if self.check(&token::OpenDelim(token::Brace)) {\n+                    self.parse_struct_expr(lo, pth, ThinVec::new())?\n+                } else {\n+                    let hi = self.last_span.hi;\n+                    self.mk_expr(lo, hi, ExprKind::Path(None, pth), ThinVec::new())\n+                };\n+\n+                let expr = self.with_res(Restrictions::RESTRICTION_STMT_EXPR, |this| {\n+                    let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs.into())?;\n+                    this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n+                })?;\n \n+                return Ok(Some(Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: StmtKind::Expr(expr),\n+                    span: mk_sp(lo, self.last_span.hi),\n+                }));\n+            }\n+\n+            // it's a macro invocation\n             let id = match self.token {\n                 token::OpenDelim(_) => keywords::Invalid.ident(), // no special identifier\n                 _ => self.parse_ident()?,\n@@ -4857,32 +4847,27 @@ impl<'a> Parser<'a> {\n     fn parse_impl_method(&mut self, vis: &Visibility)\n                          -> PResult<'a, (Ident, Vec<ast::Attribute>, ast::ImplItemKind)> {\n         // code copied from parse_macro_use_or_failure... abstraction!\n-        if !self.token.is_any_keyword()\n-            && self.look_ahead(1, |t| *t == token::Not)\n-            && (self.look_ahead(2, |t| *t == token::OpenDelim(token::Paren))\n-                || self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))) {\n+        if self.token.is_path_start() {\n             // method macro.\n \n             let last_span = self.last_span;\n             self.complain_if_pub_macro(&vis, last_span);\n \n             let lo = self.span.lo;\n-            let pth = self.parse_ident_into_path()?;\n+            let pth = self.parse_path(PathStyle::Mod)?;\n             self.expect(&token::Not)?;\n \n             // eat a matched-delimiter token tree:\n             let delim = self.expect_open_delim()?;\n             let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n                                             SeqSep::none(),\n                                             |p| p.parse_token_tree())?;\n-            let m_ = Mac_ { path: pth, tts: tts };\n-            let m: ast::Mac = codemap::Spanned { node: m_,\n-                                                    span: mk_sp(lo,\n-                                                                self.last_span.hi) };\n             if delim != token::Brace {\n                 self.expect(&token::Semi)?\n             }\n-            Ok((keywords::Invalid.ident(), vec![], ast::ImplItemKind::Macro(m)))\n+\n+            let mac = spanned(lo, self.last_span.hi, Mac_ { path: pth, tts: tts });\n+            Ok((keywords::Invalid.ident(), vec![], ast::ImplItemKind::Macro(mac)))\n         } else {\n             let (constness, unsafety, abi) = self.parse_fn_front_matter()?;\n             let ident = self.parse_ident()?;\n@@ -5979,11 +5964,7 @@ impl<'a> Parser<'a> {\n         lo: BytePos,\n         visibility: Visibility\n     ) -> PResult<'a, Option<P<Item>>> {\n-        if macros_allowed && !self.token.is_any_keyword()\n-                && self.look_ahead(1, |t| *t == token::Not)\n-                && (self.look_ahead(2, |t| t.is_ident())\n-                    || self.look_ahead(2, |t| *t == token::OpenDelim(token::Paren))\n-                    || self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))) {\n+        if macros_allowed && self.token.is_path_start() {\n             // MACRO INVOCATION ITEM\n \n             let last_span = self.last_span;\n@@ -5992,7 +5973,7 @@ impl<'a> Parser<'a> {\n             let mac_lo = self.span.lo;\n \n             // item macro.\n-            let pth = self.parse_ident_into_path()?;\n+            let pth = self.parse_path(PathStyle::Mod)?;\n             self.expect(&token::Not)?;\n \n             // a 'special' identifier (like what `macro_rules!` uses)\n@@ -6008,12 +5989,6 @@ impl<'a> Parser<'a> {\n             let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n                                             SeqSep::none(),\n                                             |p| p.parse_token_tree())?;\n-            // single-variant-enum... :\n-            let m = Mac_ { path: pth, tts: tts };\n-            let m: ast::Mac = codemap::Spanned { node: m,\n-                                                 span: mk_sp(mac_lo,\n-                                                             self.last_span.hi) };\n-\n             if delim != token::Brace {\n                 if !self.eat(&token::Semi) {\n                     let last_span = self.last_span;\n@@ -6024,14 +5999,9 @@ impl<'a> Parser<'a> {\n                 }\n             }\n \n-            let item_ = ItemKind::Mac(m);\n-            let last_span = self.last_span;\n-            let item = self.mk_item(lo,\n-                                    last_span.hi,\n-                                    id,\n-                                    item_,\n-                                    visibility,\n-                                    attrs);\n+            let hi = self.last_span.hi;\n+            let mac = spanned(mac_lo, hi, Mac_ { path: pth, tts: tts });\n+            let item = self.mk_item(lo, hi, id, ItemKind::Mac(mac), visibility, attrs);\n             return Ok(Some(item));\n         }\n "}, {"sha": "457d40e62b0371ebc3ea09ba0d601413d74cf17d", "filename": "src/test/compile-fail/issue-21146.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d9646228d8198d9c41eaa00c765de8c7bf62d69/src%2Ftest%2Fcompile-fail%2Fissue-21146.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9646228d8198d9c41eaa00c765de8c7bf62d69/src%2Ftest%2Fcompile-fail%2Fissue-21146.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21146.rs?ref=1d9646228d8198d9c41eaa00c765de8c7bf62d69", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: expected item, found `parse_error`\n+// error-pattern: expected one of `!` or `::`, found `<eof>`\n include!(\"auxiliary/issue-21146-inc.rs\");\n fn main() {}"}, {"sha": "80802e19f8401de8c6344d2aee2dde3fc4b9050f", "filename": "src/test/compile-fail/macro-context.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d9646228d8198d9c41eaa00c765de8c7bf62d69/src%2Ftest%2Fcompile-fail%2Fmacro-context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9646228d8198d9c41eaa00c765de8c7bf62d69/src%2Ftest%2Fcompile-fail%2Fmacro-context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-context.rs?ref=1d9646228d8198d9c41eaa00c765de8c7bf62d69", "patch": "@@ -14,11 +14,8 @@ macro_rules! m {\n                             //~| ERROR macro expansion ignores token `typeof`\n                             //~| ERROR macro expansion ignores token `;`\n                             //~| ERROR macro expansion ignores token `;`\n-                            //~| ERROR macro expansion ignores token `i`\n }\n \n-m!();               //~ NOTE the usage of `m!` is likely invalid in item context\n-\n fn main() {\n     let a: m!();    //~ NOTE the usage of `m!` is likely invalid in type context\n     let i = m!();   //~ NOTE the usage of `m!` is likely invalid in expression context"}, {"sha": "c69b7e526cc3b1a53b2495ec735b9928fa8ae543", "filename": "src/test/compile-fail/paths-in-macro-invocations.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1d9646228d8198d9c41eaa00c765de8c7bf62d69/src%2Ftest%2Fcompile-fail%2Fpaths-in-macro-invocations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9646228d8198d9c41eaa00c765de8c7bf62d69/src%2Ftest%2Fcompile-fail%2Fpaths-in-macro-invocations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpaths-in-macro-invocations.rs?ref=1d9646228d8198d9c41eaa00c765de8c7bf62d69", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+::foo::bar!(); //~ ERROR expected macro name without module separators\n+foo::bar!(); //~ ERROR expected macro name without module separators\n+\n+trait T {\n+    foo::bar!(); //~ ERROR expected macro name without module separators\n+    ::foo::bar!(); //~ ERROR expected macro name without module separators\n+}\n+\n+struct S {\n+    x: foo::bar!(), //~ ERROR expected macro name without module separators\n+    y: ::foo::bar!(), //~ ERROR expected macro name without module separators\n+}\n+\n+impl S {\n+    foo::bar!(); //~ ERROR expected macro name without module separators\n+    ::foo::bar!(); //~ ERROR expected macro name without module separators\n+}\n+\n+fn main() {\n+    foo::bar!(); //~ ERROR expected macro name without module separators\n+    ::foo::bar!(); //~ ERROR expected macro name without module separators\n+\n+    let _ = foo::bar!(); //~ ERROR expected macro name without module separators\n+    let _ = ::foo::bar!(); //~ ERROR expected macro name without module separators\n+\n+    let foo::bar!() = 0; //~ ERROR expected macro name without module separators\n+    let ::foo::bar!() = 0; //~ ERROR expected macro name without module separators\n+}"}, {"sha": "911606ef01213e17c518d8b9f6be9ef5fc57c8c8", "filename": "src/test/compile-fail/self_type_keyword.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d9646228d8198d9c41eaa00c765de8c7bf62d69/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9646228d8198d9c41eaa00c765de8c7bf62d69/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs?ref=1d9646228d8198d9c41eaa00c765de8c7bf62d69", "patch": "@@ -30,8 +30,7 @@ pub fn main() {\n         ref mut Self => (),\n         //~^ ERROR expected identifier, found keyword `Self`\n         Self!() => (),\n-        //~^ ERROR expected identifier, found keyword `Self`\n-        //~^^ ERROR macro undefined: 'Self!'\n+        //~^ ERROR macro undefined: 'Self!'\n         Foo { x: Self } => (),\n         //~^ ERROR expected identifier, found keyword `Self`\n         Foo { Self } => (),"}, {"sha": "ff3fefde40ece69c6005601d7fd513b09afba3f8", "filename": "src/test/parse-fail/extern-no-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d9646228d8198d9c41eaa00c765de8c7bf62d69/src%2Ftest%2Fparse-fail%2Fextern-no-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9646228d8198d9c41eaa00c765de8c7bf62d69/src%2Ftest%2Fparse-fail%2Fextern-no-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fextern-no-fn.rs?ref=1d9646228d8198d9c41eaa00c765de8c7bf62d69", "patch": "@@ -11,7 +11,7 @@\n // compile-flags: -Z parse-only\n \n extern {\n-    f(); //~ ERROR expected one of `fn`, `pub`, `static`, or `}`, found `f`\n+    f(); //~ ERROR expected one of `!` or `::`, found `(`\n }\n \n fn main() {"}, {"sha": "c03e0ef73217c5acee45a4012275acbff2f997bb", "filename": "src/test/parse-fail/issue-21153.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d9646228d8198d9c41eaa00c765de8c7bf62d69/src%2Ftest%2Fparse-fail%2Fissue-21153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9646228d8198d9c41eaa00c765de8c7bf62d69/src%2Ftest%2Fparse-fail%2Fissue-21153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-21153.rs?ref=1d9646228d8198d9c41eaa00c765de8c7bf62d69", "patch": "@@ -11,5 +11,6 @@\n // compile-flags: -Z parse-only\n \n trait MyTrait<T>: Iterator {\n-    Item = T; //~ ERROR expected one of `const`, `extern`, `fn`, `type`, or `unsafe`, found `Item`\n+    Item = T; //~ ERROR expected one of `!` or `::`, found `=`\n+              //~| ERROR expected item, found `=`\n }"}]}