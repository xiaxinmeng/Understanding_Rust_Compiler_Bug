{"sha": "330be7766f6d89e127a63ae81ee1a2f032c53910", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzMGJlNzc2NmY2ZDg5ZTEyN2E2M2FlODFlZTFhMmYwMzJjNTM5MTA=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-10-20T10:42:19Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-10-20T10:42:19Z"}, "message": "Represent PrimVals as \"bitbags\".\n\nNow instead of holding a native type based on the tag, all PrimVals\nstore a u64 (the `bits`), along with a `kind` corresponding to the\nvariant as it would be in the old PrimVal representation.\n\nThis commit makes no major optimizations and attempts to not change any\nbehaviour. There will be commits to follow that make use of this\nrepresentation to eliminate unnecessary allocation hacks like in\n`value_to_primval`.\n\nA number of places could be even more cleaned up after this commit,\nparticularly in `cast.rs`.", "tree": {"sha": "177a871f355fe67d8184fc798414f20360ba01a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/177a871f355fe67d8184fc798414f20360ba01a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/330be7766f6d89e127a63ae81ee1a2f032c53910", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/330be7766f6d89e127a63ae81ee1a2f032c53910", "html_url": "https://github.com/rust-lang/rust/commit/330be7766f6d89e127a63ae81ee1a2f032c53910", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/330be7766f6d89e127a63ae81ee1a2f032c53910/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6b4e1aba61cda101493bcc6842a6396623541df", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6b4e1aba61cda101493bcc6842a6396623541df", "html_url": "https://github.com/rust-lang/rust/commit/d6b4e1aba61cda101493bcc6842a6396623541df"}], "stats": {"total": 1103, "additions": 601, "deletions": 502}, "files": [{"sha": "427b8aed0f191484a03d2186743d63ac77879698", "filename": "src/interpreter/cast.rs", "status": "modified", "additions": 80, "deletions": 69, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/330be7766f6d89e127a63ae81ee1a2f032c53910/src%2Finterpreter%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330be7766f6d89e127a63ae81ee1a2f032c53910/src%2Finterpreter%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fcast.rs?ref=330be7766f6d89e127a63ae81ee1a2f032c53910", "patch": "@@ -8,96 +8,107 @@ use primval::PrimVal;\n use memory::Pointer;\n \n use rustc::ty::Ty;\n-use syntax::ast::{self, IntTy, UintTy};\n+use syntax::ast::{FloatTy, IntTy, UintTy};\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn cast_primval(&self, val: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n-        use primval::PrimVal::*;\n-        match val {\n-            Bool(b) => self.cast_const_int(b as u64, ty, false),\n-            F32(f) => self.cast_const_float(f as f64, ty),\n-            F64(f) => self.cast_const_float(f, ty),\n-            I8(i) => self.cast_signed_int(i as i64, ty),\n-            I16(i) => self.cast_signed_int(i as i64, ty),\n-            I32(i) => self.cast_signed_int(i as i64, ty),\n-            I64(i) => self.cast_signed_int(i, ty),\n-            U8(u) => self.cast_const_int(u as u64, ty, false),\n-            U16(u) => self.cast_const_int(u as u64, ty, false),\n-            U32(u) => self.cast_const_int(u as u64, ty, false),\n-            Char(c) => self.cast_const_int(c as u64, ty, false),\n-            U64(u) => self.cast_const_int(u, ty, false),\n-            FnPtr(ptr) |\n-            Ptr(ptr) => self.cast_ptr(ptr, ty),\n-        }\n-    }\n+        use primval::PrimValKind::*;\n+        match val.kind {\n+            F32 => self.cast_float(val.to_f32() as f64, ty),\n+            F64 => self.cast_float(val.to_f64(), ty),\n \n-    fn cast_ptr(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n-        use primval::PrimVal::*;\n-        match ty.sty {\n-            ty::TyRef(..) |\n-            ty::TyRawPtr(_) => Ok(Ptr(ptr)),\n-            ty::TyFnPtr(_) => Ok(FnPtr(ptr)),\n-            ty::TyInt(IntTy::I8) => Ok(I8(ptr.to_int()? as i8)),\n-            ty::TyInt(IntTy::I16) => Ok(I16(ptr.to_int()? as i16)),\n-            ty::TyInt(IntTy::I32) => Ok(I32(ptr.to_int()? as i32)),\n-            ty::TyInt(IntTy::I64) => Ok(I64(ptr.to_int()? as i64)),\n-            ty::TyUint(UintTy::U8) => Ok(U8(ptr.to_int()? as u8)),\n-            ty::TyUint(UintTy::U16) => Ok(U16(ptr.to_int()? as u16)),\n-            ty::TyUint(UintTy::U32) => Ok(U32(ptr.to_int()? as u32)),\n-            ty::TyUint(UintTy::U64) => Ok(U64(ptr.to_int()? as u64)),\n-            _ => Err(EvalError::Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n+            I8 | I16 | I32 | I64 => self.cast_signed_int(val.bits as i64, ty),\n+\n+            Bool | Char | U8 | U16 | U32 | U64 => self.cast_int(val.bits, ty, false),\n+\n+            FnPtr(alloc) | Ptr(alloc) => {\n+                let ptr = Pointer::new(alloc, val.bits as usize);\n+                self.cast_ptr(ptr, ty)\n+            }\n         }\n     }\n \n     fn cast_signed_int(&self, val: i64, ty: ty::Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n-        self.cast_const_int(val as u64, ty, val < 0)\n+        self.cast_int(val as u64, ty, val < 0)\n     }\n \n-    fn cast_const_int(&self, v: u64, ty: ty::Ty<'tcx>, negative: bool) -> EvalResult<'tcx, PrimVal> {\n-        use primval::PrimVal::*;\n+    fn cast_int(&self, v: u64, ty: ty::Ty<'tcx>, negative: bool) -> EvalResult<'tcx, PrimVal> {\n+        use primval::PrimValKind::*;\n+        use rustc::ty::TypeVariants::*;\n         match ty.sty {\n-            ty::TyBool if v == 0 => Ok(Bool(false)),\n-            ty::TyBool if v == 1 => Ok(Bool(true)),\n-            ty::TyBool => Err(EvalError::InvalidBool),\n-            ty::TyInt(ast::IntTy::I8) => Ok(I8(v as i64 as i8)),\n-            ty::TyInt(ast::IntTy::I16) => Ok(I16(v as i64 as i16)),\n-            ty::TyInt(ast::IntTy::I32) => Ok(I32(v as i64 as i32)),\n-            ty::TyInt(ast::IntTy::I64) => Ok(I64(v as i64)),\n-            ty::TyInt(ast::IntTy::Is) => {\n+            TyBool if v == 0 => Ok(PrimVal::from_bool(false)),\n+            TyBool if v == 1 => Ok(PrimVal::from_bool(true)),\n+            TyBool => Err(EvalError::InvalidBool),\n+\n+            TyInt(IntTy::I8)  => Ok(PrimVal::new(v as i64 as i8  as u64, I8)),\n+            TyInt(IntTy::I16) => Ok(PrimVal::new(v as i64 as i16 as u64, I16)),\n+            TyInt(IntTy::I32) => Ok(PrimVal::new(v as i64 as i32 as u64, I32)),\n+            TyInt(IntTy::I64) => Ok(PrimVal::new(v as i64 as i64 as u64, I64)),\n+\n+            TyUint(UintTy::U8)  => Ok(PrimVal::new(v as u8  as u64, U8)),\n+            TyUint(UintTy::U16) => Ok(PrimVal::new(v as u16 as u64, U16)),\n+            TyUint(UintTy::U32) => Ok(PrimVal::new(v as u32 as u64, U32)),\n+            TyUint(UintTy::U64) => Ok(PrimVal::new(v, U64)),\n+\n+            TyInt(IntTy::Is) => {\n                 let int_ty = self.tcx.sess.target.int_type;\n                 let ty = self.tcx.mk_mach_int(int_ty);\n-                self.cast_const_int(v, ty, negative)\n-            },\n-            ty::TyUint(ast::UintTy::U8) => Ok(U8(v as u8)),\n-            ty::TyUint(ast::UintTy::U16) => Ok(U16(v as u16)),\n-            ty::TyUint(ast::UintTy::U32) => Ok(U32(v as u32)),\n-            ty::TyUint(ast::UintTy::U64) => Ok(U64(v)),\n-            ty::TyUint(ast::UintTy::Us) => {\n+                self.cast_int(v, ty, negative)\n+            }\n+\n+            TyUint(UintTy::Us) => {\n                 let uint_ty = self.tcx.sess.target.uint_type;\n                 let ty = self.tcx.mk_mach_uint(uint_ty);\n-                self.cast_const_int(v, ty, negative)\n-            },\n-            ty::TyFloat(ast::FloatTy::F64) if negative => Ok(F64(v as i64 as f64)),\n-            ty::TyFloat(ast::FloatTy::F64) => Ok(F64(v as f64)),\n-            ty::TyFloat(ast::FloatTy::F32) if negative => Ok(F32(v as i64 as f32)),\n-            ty::TyFloat(ast::FloatTy::F32) => Ok(F32(v as f32)),\n-            ty::TyRawPtr(_) => Ok(Ptr(Pointer::from_int(v as usize))),\n-            ty::TyChar if v as u8 as u64 == v => Ok(Char(v as u8 as char)),\n-            ty::TyChar => Err(EvalError::InvalidChar(v)),\n+                self.cast_int(v, ty, negative)\n+            }\n+\n+            TyFloat(FloatTy::F64) if negative => Ok(PrimVal::from_f64(v as i64 as f64)),\n+            TyFloat(FloatTy::F64)             => Ok(PrimVal::from_f64(v as f64)),\n+            TyFloat(FloatTy::F32) if negative => Ok(PrimVal::from_f32(v as i64 as f32)),\n+            TyFloat(FloatTy::F32)             => Ok(PrimVal::from_f32(v as f32)),\n+\n+            TyChar if v as u8 as u64 == v => Ok(PrimVal::new(v, Char)),\n+            TyChar => Err(EvalError::InvalidChar(v)),\n+\n+            TyRawPtr(_) => Ok(PrimVal::from_ptr(Pointer::from_int(v as usize))),\n+\n             _ => Err(EvalError::Unimplemented(format!(\"int to {:?} cast\", ty))),\n         }\n     }\n \n-    fn cast_const_float(&self, val: f64, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n-        use primval::PrimVal::*;\n+    fn cast_float(&self, val: f64, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+        use rustc::ty::TypeVariants::*;\n         match ty.sty {\n-            // casting negative floats to unsigned integers yields zero\n-            ty::TyUint(_) if val < 0.0 => self.cast_const_int(0, ty, false),\n-            ty::TyInt(_) if val < 0.0 => self.cast_const_int(val as i64 as u64, ty, true),\n-            ty::TyInt(_) | ty::TyUint(_) => self.cast_const_int(val as u64, ty, false),\n-            ty::TyFloat(ast::FloatTy::F64) => Ok(F64(val)),\n-            ty::TyFloat(ast::FloatTy::F32) => Ok(F32(val as f32)),\n+            // Casting negative floats to unsigned integers yields zero.\n+            TyUint(_) if val < 0.0 => self.cast_int(0, ty, false),\n+            TyInt(_)  if val < 0.0 => self.cast_int(val as i64 as u64, ty, true),\n+\n+            TyInt(_) | ty::TyUint(_) => self.cast_int(val as u64, ty, false),\n+\n+            TyFloat(FloatTy::F64) => Ok(PrimVal::from_f64(val)),\n+            TyFloat(FloatTy::F32) => Ok(PrimVal::from_f32(val as f32)),\n             _ => Err(EvalError::Unimplemented(format!(\"float to {:?} cast\", ty))),\n         }\n     }\n+\n+    fn cast_ptr(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+        use primval::PrimValKind::*;\n+        use rustc::ty::TypeVariants::*;\n+        match ty.sty {\n+            TyRef(..) | TyRawPtr(_) => Ok(PrimVal::from_ptr(ptr)),\n+            TyFnPtr(_) => Ok(PrimVal::from_fn_ptr(ptr)),\n+\n+            TyInt(IntTy::I8)  => Ok(PrimVal::new(ptr.to_int()? as u64, I8)),\n+            TyInt(IntTy::I16) => Ok(PrimVal::new(ptr.to_int()? as u64, I16)),\n+            TyInt(IntTy::I32) => Ok(PrimVal::new(ptr.to_int()? as u64, I32)),\n+            TyInt(IntTy::I64) => Ok(PrimVal::new(ptr.to_int()? as u64, I64)),\n+\n+            TyUint(UintTy::U8)  => Ok(PrimVal::new(ptr.to_int()? as u64, U8)),\n+            TyUint(UintTy::U16) => Ok(PrimVal::new(ptr.to_int()? as u64, U16)),\n+            TyUint(UintTy::U32) => Ok(PrimVal::new(ptr.to_int()? as u64, U32)),\n+            TyUint(UintTy::U64) => Ok(PrimVal::new(ptr.to_int()? as u64, U64)),\n+\n+            _ => Err(EvalError::Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n+        }\n+    }\n }"}, {"sha": "463b9bf006392a734f7a85bc9717dfd383e2bdc9", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 80, "deletions": 67, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/330be7766f6d89e127a63ae81ee1a2f032c53910/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330be7766f6d89e127a63ae81ee1a2f032c53910/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=330be7766f6d89e127a63ae81ee1a2f032c53910", "patch": "@@ -16,7 +16,7 @@ use syntax::codemap::{self, DUMMY_SP};\n \n use error::{EvalError, EvalResult};\n use memory::{Memory, Pointer, AllocId};\n-use primval::{self, PrimVal};\n+use primval::{self, PrimVal, PrimValKind};\n use self::value::Value;\n \n use std::collections::HashMap;\n@@ -202,65 +202,64 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &self.stack\n     }\n \n-    fn isize_primval(&self, n: i64) -> PrimVal {\n-        match self.memory.pointer_size() {\n-            1 => PrimVal::I8(n as i8),\n-            2 => PrimVal::I16(n as i16),\n-            4 => PrimVal::I32(n as i32),\n-            8 => PrimVal::I64(n as i64),\n-            p => bug!(\"unsupported target pointer size: {}\", p),\n-        }\n+    fn usize_primval(&self, n: u64) -> PrimVal {\n+        PrimVal::from_uint_with_size(n, self.memory.pointer_size())\n     }\n \n-    fn usize_primval(&self, n: u64) -> PrimVal {\n-        match self.memory.pointer_size() {\n-            1 => PrimVal::U8(n as u8),\n-            2 => PrimVal::U16(n as u16),\n-            4 => PrimVal::U32(n as u32),\n-            8 => PrimVal::U64(n as u64),\n-            p => bug!(\"unsupported target pointer size: {}\", p),\n-        }\n+    fn isize_primval(&self, n: i64) -> PrimVal {\n+        PrimVal::from_int_with_size(n, self.memory.pointer_size())\n     }\n \n     fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n         // FIXME: cache these allocs\n         let ptr = self.memory.allocate(s.len(), 1)?;\n         self.memory.write_bytes(ptr, s.as_bytes())?;\n         self.memory.freeze(ptr.alloc_id)?;\n-        Ok(Value::ByValPair(PrimVal::Ptr(ptr), self.usize_primval(s.len() as u64)))\n+        Ok(Value::ByValPair(PrimVal::from_ptr(ptr), self.usize_primval(s.len() as u64)))\n     }\n \n     fn const_to_value(&mut self, const_val: &ConstVal) -> EvalResult<'tcx, Value> {\n         use rustc::middle::const_val::ConstVal::*;\n-        use rustc_const_math::{ConstInt, ConstIsize, ConstUsize, ConstFloat};\n+        use rustc_const_math::ConstFloat;\n \n         let primval = match *const_val {\n-            Integral(ConstInt::I8(i)) => PrimVal::I8(i),\n-            Integral(ConstInt::U8(i)) => PrimVal::U8(i),\n-            Integral(ConstInt::Isize(ConstIsize::Is16(i))) |\n-            Integral(ConstInt::I16(i)) => PrimVal::I16(i),\n-            Integral(ConstInt::Usize(ConstUsize::Us16(i))) |\n-            Integral(ConstInt::U16(i)) => PrimVal::U16(i),\n-            Integral(ConstInt::Isize(ConstIsize::Is32(i))) |\n-            Integral(ConstInt::I32(i)) => PrimVal::I32(i),\n-            Integral(ConstInt::Usize(ConstUsize::Us32(i))) |\n-            Integral(ConstInt::U32(i)) => PrimVal::U32(i),\n-            Integral(ConstInt::Isize(ConstIsize::Is64(i))) |\n-            Integral(ConstInt::I64(i)) => PrimVal::I64(i),\n-            Integral(ConstInt::Usize(ConstUsize::Us64(i))) |\n-            Integral(ConstInt::U64(i)) => PrimVal::U64(i),\n-            Float(ConstFloat::F32(f)) => PrimVal::F32(f),\n-            Float(ConstFloat::F64(f)) => PrimVal::F64(f),\n-            Bool(b) => PrimVal::Bool(b),\n-            Char(c) => PrimVal::Char(c),\n+            Integral(const_int) => {\n+                use rustc_const_math::ConstInt::*;\n+                use rustc_const_math::ConstIsize::*;\n+                use rustc_const_math::ConstUsize::*;\n+\n+                let kind = match const_int {\n+                    I8(_)                   => PrimValKind::I8,\n+                    I16(_) | Isize(Is16(_)) => PrimValKind::I16,\n+                    I32(_) | Isize(Is32(_)) => PrimValKind::I32,\n+                    I64(_) | Isize(Is64(_)) => PrimValKind::I64,\n+                    U8(_)                   => PrimValKind::U8,\n+                    U16(_) | Usize(Us16(_)) => PrimValKind::U16,\n+                    U32(_) | Usize(Us32(_)) => PrimValKind::U32,\n+                    U64(_) | Usize(Us64(_)) => PrimValKind::U64,\n+\n+                    Infer(_) | InferSigned(_) =>\n+                        bug!(\"uninferred constants only exist before typeck\"),\n+                };\n+\n+                PrimVal::new(const_int.to_u64_unchecked(), kind)\n+            }\n+\n+            Float(ConstFloat::F32(f)) => PrimVal::from_f32(f),\n+            Float(ConstFloat::F64(f)) => PrimVal::from_f64(f),\n+            Float(ConstFloat::FInfer { .. }) =>\n+                bug!(\"uninferred constants only exist before typeck\"),\n+\n+            Bool(b) => PrimVal::from_bool(b),\n+            Char(c) => PrimVal::from_char(c),\n \n             Str(ref s) => return self.str_to_value(s),\n \n             ByteStr(ref bs) => {\n                 let ptr = self.memory.allocate(bs.len(), 1)?;\n                 self.memory.write_bytes(ptr, bs)?;\n                 self.memory.freeze(ptr.alloc_id)?;\n-                PrimVal::Ptr(ptr)\n+                PrimVal::from_ptr(ptr)\n             }\n \n             Struct(_)    => unimplemented!(),\n@@ -269,11 +268,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Array(_, _)  => unimplemented!(),\n             Repeat(_, _) => unimplemented!(),\n             Dummy        => unimplemented!(),\n-\n-            Float(ConstFloat::FInfer{..}) |\n-            Integral(ConstInt::Infer(_)) |\n-            Integral(ConstInt::InferSigned(_)) =>\n-                bug!(\"uninferred constants only exist before typeck\"),\n         };\n \n         Ok(Value::ByVal(primval))\n@@ -416,7 +410,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, ()> {\n         let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n-        let val = Value::ByValPair(val, PrimVal::Bool(overflowed));\n+        let val = Value::ByValPair(val, PrimVal::from_bool(overflowed));\n         self.write_value(val, dest, dest_ty)\n     }\n \n@@ -572,9 +566,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             let size = discr.size().bytes() as usize;\n \n                             let val = if signed {\n-                                PrimVal::int_with_size(n as i64, size)\n+                                PrimVal::from_int_with_size(n as i64, size)\n                             } else {\n-                                PrimVal::uint_with_size(n, size)\n+                                PrimVal::from_uint_with_size(n, size)\n                             };\n \n                             self.write_primval(dest, val)?;\n@@ -615,12 +609,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Ref(_, _, ref lvalue) => {\n                 let src = self.eval_lvalue(lvalue)?;\n                 let (raw_ptr, extra) = self.force_allocation(src)?.to_ptr_and_extra();\n-                let ptr = PrimVal::Ptr(raw_ptr);\n+                let ptr = PrimVal::from_ptr(raw_ptr);\n \n                 let val = match extra {\n                     LvalueExtra::None => Value::ByVal(ptr),\n                     LvalueExtra::Length(len) => Value::ByValPair(ptr, self.usize_primval(len)),\n-                    LvalueExtra::Vtable(vtable) => Value::ByValPair(ptr, PrimVal::Ptr(vtable)),\n+                    LvalueExtra::Vtable(vtable) => Value::ByValPair(ptr, PrimVal::from_ptr(vtable)),\n                     LvalueExtra::DowncastVariant(..) =>\n                         bug!(\"attempted to take a reference to an enum downcast lvalue\"),\n                 };\n@@ -630,7 +624,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Box(ty) => {\n                 let ptr = self.alloc_ptr(ty)?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr))?;\n+                self.write_primval(dest, PrimVal::from_ptr(ptr))?;\n             }\n \n             Cast(kind, ref operand, cast_ty) => {\n@@ -699,6 +693,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             InlineAsm { .. } => return Err(EvalError::InlineAsm),\n         }\n \n+        if log_enabled!(::log::LogLevel::Trace) {\n+            self.dump_local(dest);\n+        }\n+\n         Ok(())\n     }\n \n@@ -974,7 +972,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Deref => {\n-                use primval::PrimVal::*;\n+                use primval::PrimValKind::*;\n                 use interpreter::value::Value::*;\n \n                 let val = match self.eval_and_read_lvalue(&proj.base)? {\n@@ -983,10 +981,25 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n \n                 match val {\n-                    ByValPair(Ptr(ptr), Ptr(vptr)) => (ptr, LvalueExtra::Vtable(vptr)),\n-                    ByValPair(Ptr(ptr), n) =>\n-                        (ptr, LvalueExtra::Length(n.expect_uint(\"slice length\"))),\n-                    ByVal(Ptr(ptr)) => (ptr, LvalueExtra::None),\n+                    ByValPair(\n+                        PrimVal { kind: Ptr(ptr_alloc), bits: ptr_offset },\n+                        PrimVal { kind: Ptr(vtable_alloc), bits: vtable_offset },\n+                    ) => {\n+                        let ptr = Pointer::new(ptr_alloc, ptr_offset as usize);\n+                        let vtable = Pointer::new(vtable_alloc, vtable_offset as usize);\n+                        (ptr, LvalueExtra::Vtable(vtable))\n+                    }\n+\n+                    ByValPair(PrimVal { kind: Ptr(alloc), bits: offset }, n) => {\n+                        let ptr = Pointer::new(alloc, offset as usize);\n+                        (ptr, LvalueExtra::Length(n.expect_uint(\"slice length\")))\n+                    }\n+\n+                    ByVal(PrimVal { kind: Ptr(alloc), bits: offset }) => {\n+                        let ptr = Pointer::new(alloc, offset as usize);\n+                        (ptr, LvalueExtra::None)\n+                    }\n+\n                     _ => bug!(\"can't deref non pointer types\"),\n                 }\n             }\n@@ -1243,11 +1256,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         use syntax::ast::FloatTy;\n \n         let val = match ty.sty {\n-            ty::TyBool => PrimVal::Bool(self.memory.read_bool(ptr)?),\n+            ty::TyBool => PrimVal::from_bool(self.memory.read_bool(ptr)?),\n             ty::TyChar => {\n                 let c = self.memory.read_uint(ptr, 4)? as u32;\n                 match ::std::char::from_u32(c) {\n-                    Some(ch) => PrimVal::Char(ch),\n+                    Some(ch) => PrimVal::from_char(ch),\n                     None => return Err(EvalError::InvalidChar(c as u64)),\n                 }\n             }\n@@ -1262,7 +1275,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Is => self.memory.pointer_size(),\n                 };\n                 let n = self.memory.read_int(ptr, size)?;\n-                PrimVal::int_with_size(n, size)\n+                PrimVal::from_int_with_size(n, size)\n             }\n \n             ty::TyUint(uint_ty) => {\n@@ -1275,32 +1288,32 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Us => self.memory.pointer_size(),\n                 };\n                 let n = self.memory.read_uint(ptr, size)?;\n-                PrimVal::uint_with_size(n, size)\n+                PrimVal::from_uint_with_size(n, size)\n             }\n \n-            ty::TyFloat(FloatTy::F32) => PrimVal::F32(self.memory.read_f32(ptr)?),\n-            ty::TyFloat(FloatTy::F64) => PrimVal::F64(self.memory.read_f64(ptr)?),\n+            ty::TyFloat(FloatTy::F32) => PrimVal::from_f32(self.memory.read_f32(ptr)?),\n+            ty::TyFloat(FloatTy::F64) => PrimVal::from_f64(self.memory.read_f64(ptr)?),\n \n             ty::TyFnDef(def_id, substs, fn_ty) => {\n-                PrimVal::FnPtr(self.memory.create_fn_ptr(def_id, substs, fn_ty))\n+                PrimVal::from_fn_ptr(self.memory.create_fn_ptr(def_id, substs, fn_ty))\n             },\n-            ty::TyFnPtr(_) => self.memory.read_ptr(ptr).map(PrimVal::FnPtr)?,\n+            ty::TyFnPtr(_) => self.memory.read_ptr(ptr).map(PrimVal::from_fn_ptr)?,\n             ty::TyBox(ty) |\n             ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n             ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n                 let p = self.memory.read_ptr(ptr)?;\n                 if self.type_is_sized(ty) {\n-                    PrimVal::Ptr(p)\n+                    PrimVal::from_ptr(p)\n                 } else {\n                     // FIXME: extract the offset to the tail field for `Box<(i64, i32, [u8])>`\n                     let extra = ptr.offset(self.memory.pointer_size() as isize);\n                     let extra = match self.tcx.struct_tail(ty).sty {\n-                        ty::TyTrait(..) => PrimVal::Ptr(self.memory.read_ptr(extra)?),\n+                        ty::TyTrait(..) => PrimVal::from_ptr(self.memory.read_ptr(extra)?),\n                         ty::TySlice(..) |\n                         ty::TyStr => self.usize_primval(self.memory.read_usize(extra)?),\n                         _ => bug!(\"unsized primval ptr read from {:?}\", ty),\n                     };\n-                    return Ok(Value::ByValPair(PrimVal::Ptr(p), extra));\n+                    return Ok(Value::ByValPair(PrimVal::from_ptr(p), extra));\n                 }\n             }\n \n@@ -1310,10 +1323,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let size = discr.size().bytes() as usize;\n                     if signed {\n                         let n = self.memory.read_int(ptr, size)?;\n-                        PrimVal::int_with_size(n, size)\n+                        PrimVal::from_int_with_size(n, size)\n                     } else {\n                         let n = self.memory.read_uint(ptr, size)?;\n-                        PrimVal::uint_with_size(n, size)\n+                        PrimVal::from_uint_with_size(n, size)\n                     }\n                 } else {\n                     bug!(\"primitive read of non-clike enum: {:?}\", ty);"}, {"sha": "c3327dd76f9d0b8440f57c08d84c73238974901c", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "modified", "additions": 38, "deletions": 58, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/330be7766f6d89e127a63ae81ee1a2f032c53910/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330be7766f6d89e127a63ae81ee1a2f032c53910/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=330be7766f6d89e127a63ae81ee1a2f032c53910", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::{self, Ty};\n use error::{EvalError, EvalResult};\n use interpreter::value::Value;\n use interpreter::{EvalContext, Lvalue};\n-use primval::{self, PrimVal};\n+use primval::{self, PrimVal, PrimValKind};\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn call_intrinsic(\n@@ -46,7 +46,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let offset = self.value_to_primval(args_ptrs[1], isize)?\n                     .expect_int(\"arith_offset second arg not isize\");\n                 let new_ptr = ptr.offset(offset as isize);\n-                self.write_primval(dest, PrimVal::Ptr(new_ptr))?;\n+                self.write_primval(dest, PrimVal::from_ptr(new_ptr))?;\n             }\n \n             \"assume\" => {\n@@ -99,19 +99,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty = substs.type_at(0);\n                 let adt_ptr = args_ptrs[0].read_ptr(&self.memory)?;\n                 let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n-                self.write_primval(dest, PrimVal::U64(discr_val))?;\n+                self.write_primval(dest, PrimVal::new(discr_val, PrimValKind::U64))?;\n             }\n \n             \"fabsf32\" => {\n                 let f = self.value_to_primval(args_ptrs[2], f32)?\n                     .expect_f32(\"fabsf32 read non f32\");\n-                self.write_primval(dest, PrimVal::F32(f.abs()))?;\n+                self.write_primval(dest, PrimVal::from_f32(f.abs()))?;\n             }\n \n             \"fabsf64\" => {\n                 let f = self.value_to_primval(args_ptrs[2], f64)?\n                     .expect_f64(\"fabsf64 read non f64\");\n-                self.write_primval(dest, PrimVal::F64(f.abs()))?;\n+                self.write_primval(dest, PrimVal::from_f64(f.abs()))?;\n             }\n \n             \"fadd_fast\" => {\n@@ -159,7 +159,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty = substs.type_at(0);\n                 let env = self.tcx.empty_parameter_environment();\n                 let needs_drop = self.tcx.type_needs_drop_given_env(ty, &env);\n-                self.write_primval(dest, PrimVal::Bool(needs_drop))?;\n+                self.write_primval(dest, PrimVal::from_bool(needs_drop))?;\n             }\n \n             \"offset\" => {\n@@ -170,7 +170,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let ptr = args_ptrs[0].read_ptr(&self.memory)?;\n                 let result_ptr = ptr.offset(offset as isize * pointee_size);\n-                self.write_primval(dest, PrimVal::Ptr(result_ptr))?;\n+                self.write_primval(dest, PrimVal::from_ptr(result_ptr))?;\n             }\n \n             \"overflowing_sub\" => {\n@@ -190,27 +190,27 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     .expect_f32(\"powif32 first arg not f32\");\n                 let i = self.value_to_primval(args_ptrs[1], i32)?\n                     .expect_int(\"powif32 second arg not i32\");\n-                self.write_primval(dest, PrimVal::F32(f.powi(i as i32)))?;\n+                self.write_primval(dest, PrimVal::from_f32(f.powi(i as i32)))?;\n             }\n \n             \"powif64\" => {\n                 let f = self.value_to_primval(args_ptrs[0], f64)?\n                     .expect_f64(\"powif64 first arg not f64\");\n                 let i = self.value_to_primval(args_ptrs[1], i32)?\n                     .expect_int(\"powif64 second arg not i32\");\n-                self.write_primval(dest, PrimVal::F64(f.powi(i as i32)))?;\n+                self.write_primval(dest, PrimVal::from_f64(f.powi(i as i32)))?;\n             }\n \n             \"sqrtf32\" => {\n                 let f = self.value_to_primval(args_ptrs[0], f32)?\n                     .expect_f32(\"sqrtf32 first arg not f32\");\n-                self.write_primval(dest, PrimVal::F32(f.sqrt()))?;\n+                self.write_primval(dest, PrimVal::from_f32(f.sqrt()))?;\n             }\n \n             \"sqrtf64\" => {\n                 let f = self.value_to_primval(args_ptrs[0], f64)?\n                     .expect_f64(\"sqrtf64 first arg not f64\");\n-                self.write_primval(dest, PrimVal::F64(f.sqrt()))?;\n+                self.write_primval(dest, PrimVal::from_f64(f.sqrt()))?;\n             }\n \n             \"size_of\" => {\n@@ -235,7 +235,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"type_id\" => {\n                 let ty = substs.type_at(0);\n                 let n = self.tcx.type_id_hash(ty);\n-                self.write_primval(dest, PrimVal::U64(n))?;\n+                self.write_primval(dest, PrimVal::new(n, PrimValKind::U64))?;\n             }\n \n             \"transmute\" => {\n@@ -362,53 +362,33 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n }\n \n+macro_rules! integer_intrinsic {\n+    ($name:expr, $val:expr, $method:ident) => ({\n+        let val = $val;\n+\n+        use primval::PrimValKind::*;\n+        let bits = match val.kind {\n+            I8 => (val.bits as i8).$method() as u64,\n+            U8 => (val.bits as u8).$method() as u64,\n+            I16 => (val.bits as i16).$method() as u64,\n+            U16 => (val.bits as u16).$method() as u64,\n+            I32 => (val.bits as i32).$method() as u64,\n+            U32 => (val.bits as u32).$method() as u64,\n+            I64 => (val.bits as i64).$method() as u64,\n+            U64 => (val.bits as u64).$method() as u64,\n+            _ => bug!(\"invalid `{}` argument: {:?}\", $name, val),\n+        };\n+\n+        PrimVal::new(bits, val.kind)\n+    });\n+}\n+\n fn numeric_intrinsic(name: &str, val: PrimVal) -> PrimVal {\n-    use primval::PrimVal::*;\n     match name {\n-        \"ctpop\" => match val {\n-            I8(i) => I8(i.count_ones() as i8),\n-            U8(i) => U8(i.count_ones() as u8),\n-            I16(i) => I16(i.count_ones() as i16),\n-            U16(i) => U16(i.count_ones() as u16),\n-            I32(i) => I32(i.count_ones() as i32),\n-            U32(i) => U32(i.count_ones() as u32),\n-            I64(i) => I64(i.count_ones() as i64),\n-            U64(i) => U64(i.count_ones() as u64),\n-            other => bug!(\"invalid `ctpop` argument: {:?}\", other),\n-        },\n-        \"cttz\" => match val {\n-            I8(i) => I8(i.trailing_zeros() as i8),\n-            U8(i) => U8(i.trailing_zeros() as u8),\n-            I16(i) => I16(i.trailing_zeros() as i16),\n-            U16(i) => U16(i.trailing_zeros() as u16),\n-            I32(i) => I32(i.trailing_zeros() as i32),\n-            U32(i) => U32(i.trailing_zeros() as u32),\n-            I64(i) => I64(i.trailing_zeros() as i64),\n-            U64(i) => U64(i.trailing_zeros() as u64),\n-            other => bug!(\"invalid `cttz` argument: {:?}\", other),\n-        },\n-        \"ctlz\" => match val {\n-            I8(i) => I8(i.leading_zeros() as i8),\n-            U8(i) => U8(i.leading_zeros() as u8),\n-            I16(i) => I16(i.leading_zeros() as i16),\n-            U16(i) => U16(i.leading_zeros() as u16),\n-            I32(i) => I32(i.leading_zeros() as i32),\n-            U32(i) => U32(i.leading_zeros() as u32),\n-            I64(i) => I64(i.leading_zeros() as i64),\n-            U64(i) => U64(i.leading_zeros() as u64),\n-            other => bug!(\"invalid `ctlz` argument: {:?}\", other),\n-        },\n-        \"bswap\" => match val {\n-            I8(i) => I8(i.swap_bytes() as i8),\n-            U8(i) => U8(i.swap_bytes() as u8),\n-            I16(i) => I16(i.swap_bytes() as i16),\n-            U16(i) => U16(i.swap_bytes() as u16),\n-            I32(i) => I32(i.swap_bytes() as i32),\n-            U32(i) => U32(i.swap_bytes() as u32),\n-            I64(i) => I64(i.swap_bytes() as i64),\n-            U64(i) => U64(i.swap_bytes() as u64),\n-            other => bug!(\"invalid `bswap` argument: {:?}\", other),\n-        },\n-        _ => bug!(\"not a numeric intrinsic: {}\", name),\n+        \"bswap\" => integer_intrinsic!(\"bswap\", val, swap_bytes),\n+        \"ctlz\"  => integer_intrinsic!(\"ctlz\", val, leading_zeros),\n+        \"ctpop\" => integer_intrinsic!(\"ctpop\", val, count_ones),\n+        \"cttz\"  => integer_intrinsic!(\"cttz\", val, trailing_zeros),\n+        _       => bug!(\"not a numeric intrinsic: {}\", name),\n     }\n }"}, {"sha": "be6147f8b742c529b8ffa82841b153ccc5633523", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/330be7766f6d89e127a63ae81ee1a2f032c53910/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330be7766f6d89e127a63ae81ee1a2f032c53910/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=330be7766f6d89e127a63ae81ee1a2f032c53910", "patch": "@@ -87,7 +87,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 match func_ty.sty {\n                     ty::TyFnPtr(bare_fn_ty) => {\n                         let fn_ptr = self.eval_operand_to_primval(func)?\n-                            .expect_fn_ptr(\"TyFnPtr callee did not evaluate to PrimVal::FnPtr\");\n+                            .expect_fn_ptr(\"TyFnPtr callee did not evaluate to FnPtr\");\n                         let (def_id, substs, fn_ty) = self.memory.get_fn(fn_ptr.alloc_id)?;\n                         if fn_ty != bare_fn_ty {\n                             return Err(EvalError::FunctionPointerTyMismatch(fn_ty, bare_fn_ty));\n@@ -293,15 +293,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let align = self.value_to_primval(args[1], usize)?\n                     .expect_uint(\"__rust_allocate second arg not usize\");\n                 let ptr = self.memory.allocate(size as usize, align as usize)?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr))?;\n+                self.write_primval(dest, PrimVal::from_ptr(ptr))?;\n             }\n \n             \"__rust_reallocate\" => {\n                 let ptr = args[0].read_ptr(&self.memory)?;\n                 let size = self.value_to_primval(args[2], usize)?.expect_uint(\"__rust_reallocate third arg not usize\");\n                 let align = self.value_to_primval(args[3], usize)?.expect_uint(\"__rust_reallocate fourth arg not usize\");\n                 let new_ptr = self.memory.reallocate(ptr, size as usize, align as usize)?;\n-                self.write_primval(dest, PrimVal::Ptr(new_ptr))?;\n+                self.write_primval(dest, PrimVal::from_ptr(new_ptr))?;\n             }\n \n             \"memcmp\" => {\n@@ -321,7 +321,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                 };\n \n-                self.write_primval(dest, PrimVal::int_with_size(result, dest_size))?;\n+                self.write_primval(dest, PrimVal::from_int_with_size(result, dest_size))?;\n             }\n \n             _ => {\n@@ -430,7 +430,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         // FIXME: this is a memory leak, should probably add the pointer to the\n                         // current stack.\n                         let first = self.value_to_ptr_dont_use(args[0].0, args[0].1)?;\n-                        args[0].0 = Value::ByVal(PrimVal::Ptr(first));\n+                        args[0].0 = Value::ByVal(PrimVal::from_ptr(first));\n                         args[0].1 = self.tcx.mk_mut_ptr(args[0].1);\n                     }\n \n@@ -453,7 +453,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let idx = self.tcx.get_vtable_index_of_object_method(data, def_id);\n                 if let Some(&mut(ref mut first_arg, ref mut first_ty)) = args.get_mut(0) {\n                     let (self_ptr, vtable) = first_arg.expect_ptr_vtable_pair(&self.memory)?;\n-                    *first_arg = Value::ByVal(PrimVal::Ptr(self_ptr));\n+                    *first_arg = Value::ByVal(PrimVal::from_ptr(self_ptr));\n                     let idx = idx + 3;\n                     let offset = idx * self.memory.pointer_size();\n                     let fn_ptr = self.memory.read_ptr(vtable.offset(offset as isize))?;"}, {"sha": "09b0f8345d878995250f6e4544ccd4457c65d2ad", "filename": "src/interpreter/value.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/330be7766f6d89e127a63ae81ee1a2f032c53910/src%2Finterpreter%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330be7766f6d89e127a63ae81ee1a2f032c53910/src%2Finterpreter%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fvalue.rs?ref=330be7766f6d89e127a63ae81ee1a2f032c53910", "patch": "@@ -1,6 +1,6 @@\n use error::EvalResult;\n use memory::{Memory, Pointer};\n-use primval::PrimVal;\n+use primval::{PrimVal, PrimValKind};\n \n /// A `Value` represents a single self-contained Rust value.\n ///\n@@ -22,8 +22,13 @@ impl<'a, 'tcx: 'a> Value {\n         use self::Value::*;\n         match *self {\n             ByRef(ptr) => mem.read_ptr(ptr),\n-            ByVal(PrimVal::Ptr(ptr)) |\n-            ByVal(PrimVal::FnPtr(ptr)) => Ok(ptr),\n+\n+            ByVal(PrimVal { kind: PrimValKind::Ptr(alloc), bits: offset }) |\n+            ByVal(PrimVal { kind: PrimValKind::FnPtr(alloc), bits: offset }) => {\n+                let ptr = Pointer::new(alloc, offset as usize);\n+                Ok(ptr)\n+            }\n+\n             ByValPair(..) => unimplemented!(),\n             ByVal(_other) => unimplemented!(),\n         }\n@@ -40,7 +45,16 @@ impl<'a, 'tcx: 'a> Value {\n                 let vtable = mem.read_ptr(ptr.offset(mem.pointer_size() as isize))?;\n                 Ok((ptr, vtable))\n             }\n-            ByValPair(PrimVal::Ptr(ptr), PrimVal::Ptr(vtable)) => Ok((ptr, vtable)),\n+\n+            ByValPair(\n+                PrimVal { kind: PrimValKind::Ptr(ptr_alloc), bits: ptr_offset },\n+                PrimVal { kind: PrimValKind::Ptr(vtable_alloc), bits: vtable_offset },\n+            ) => {\n+                let ptr = Pointer::new(ptr_alloc, ptr_offset as usize);\n+                let vtable = Pointer::new(vtable_alloc, vtable_offset as usize);\n+                Ok((ptr, vtable))\n+            }\n+\n             _ => bug!(\"expected ptr and vtable, got {:?}\", self),\n         }\n     }\n@@ -49,10 +63,7 @@ impl<'a, 'tcx: 'a> Value {\n         use self::Value::*;\n         match *self {\n             ByRef(ptr) => mem.read_usize(ptr.offset(mem.pointer_size() as isize)),\n-            ByValPair(_, PrimVal::U8(len)) => Ok(len as u64),\n-            ByValPair(_, PrimVal::U16(len)) => Ok(len as u64),\n-            ByValPair(_, PrimVal::U32(len)) => Ok(len as u64),\n-            ByValPair(_, PrimVal::U64(len)) => Ok(len),\n+            ByValPair(_, val) if val.kind.is_int() => Ok(val.bits),\n             _ => unimplemented!(),\n         }\n     }"}, {"sha": "6979d7ef3397ef2095515418358272a56379ccfa", "filename": "src/memory.rs", "status": "modified", "additions": 33, "deletions": 45, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/330be7766f6d89e127a63ae81ee1a2f032c53910/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330be7766f6d89e127a63ae81ee1a2f032c53910/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=330be7766f6d89e127a63ae81ee1a2f032c53910", "patch": "@@ -49,8 +49,13 @@ pub struct Pointer {\n }\n \n impl Pointer {\n+    pub fn new(alloc_id: AllocId, offset: usize) -> Self {\n+        Pointer { alloc_id: alloc_id, offset: offset }\n+    }\n+\n     pub fn offset(self, i: isize) -> Self {\n-        Pointer { offset: (self.offset as isize + i) as usize, ..self }\n+        let new_offset = (self.offset as isize + i) as usize;\n+        Pointer::new(self.alloc_id, new_offset)\n     }\n \n     pub fn points_to_zst(&self) -> bool {\n@@ -65,25 +70,18 @@ impl Pointer {\n         }\n     }\n \n+    // FIXME(solson): Integer pointers should use u64, not usize. Target pointers can be larger\n+    // than host usize.\n     pub fn from_int(i: usize) -> Self {\n-        Pointer {\n-            alloc_id: ZST_ALLOC_ID,\n-            offset: i,\n-        }\n+        Pointer::new(ZST_ALLOC_ID, i)\n     }\n \n     pub fn zst_ptr() -> Self {\n-        Pointer {\n-            alloc_id: ZST_ALLOC_ID,\n-            offset: 0,\n-        }\n+        Pointer::new(ZST_ALLOC_ID, 0)\n     }\n \n     pub fn never_ptr() -> Self {\n-        Pointer {\n-            alloc_id: NEVER_ALLOC_ID,\n-            offset: 0,\n-        }\n+        Pointer::new(NEVER_ALLOC_ID, 0)\n     }\n }\n \n@@ -167,20 +165,14 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     fn create_fn_alloc(&mut self, def: FunctionDefinition<'tcx>) -> Pointer {\n         if let Some(&alloc_id) = self.function_alloc_cache.get(&def) {\n-            return Pointer {\n-                alloc_id: alloc_id,\n-                offset: 0,\n-            };\n+            return Pointer::new(alloc_id, 0);\n         }\n         let id = self.next_id;\n         debug!(\"creating fn ptr: {}\", id);\n         self.next_id.0 += 1;\n         self.functions.insert(id, def.clone());\n         self.function_alloc_cache.insert(def, id);\n-        Pointer {\n-            alloc_id: id,\n-            offset: 0,\n-        }\n+        Pointer::new(id, 0)\n     }\n \n     pub fn allocate(&mut self, size: usize, align: usize) -> EvalResult<'tcx, Pointer> {\n@@ -207,10 +199,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         let id = self.next_id;\n         self.next_id.0 += 1;\n         self.alloc_map.insert(id, alloc);\n-        Ok(Pointer {\n-            alloc_id: id,\n-            offset: 0,\n-        })\n+        Ok(Pointer::new(id, 0))\n     }\n \n     // TODO(solson): Track which allocations were returned from __rust_allocate and report an error\n@@ -241,10 +230,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             alloc.undef_mask.truncate(new_size);\n         }\n \n-        Ok(Pointer {\n-            alloc_id: ptr.alloc_id,\n-            offset: 0,\n-        })\n+        Ok(Pointer::new(ptr.alloc_id, 0))\n     }\n \n     // TODO(solson): See comment on `reallocate`.\n@@ -535,7 +521,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         let offset = read_target_uint(endianess, bytes).unwrap() as usize;\n         let alloc = self.get(ptr.alloc_id)?;\n         match alloc.relocations.get(&ptr.offset) {\n-            Some(&alloc_id) => Ok(Pointer { alloc_id: alloc_id, offset: offset }),\n+            Some(&alloc_id) => Ok(Pointer::new(alloc_id, offset)),\n             None => Ok(Pointer::from_int(offset)),\n         }\n     }\n@@ -547,22 +533,24 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     pub fn write_primval(&mut self, ptr: Pointer, val: PrimVal) -> EvalResult<'tcx, ()> {\n-        match val {\n-            PrimVal::Bool(b) => self.write_bool(ptr, b),\n-            PrimVal::I8(n)   => self.write_int(ptr, n as i64, 1),\n-            PrimVal::I16(n)  => self.write_int(ptr, n as i64, 2),\n-            PrimVal::I32(n)  => self.write_int(ptr, n as i64, 4),\n-            PrimVal::I64(n)  => self.write_int(ptr, n as i64, 8),\n-            PrimVal::U8(n)   => self.write_uint(ptr, n as u64, 1),\n-            PrimVal::U16(n)  => self.write_uint(ptr, n as u64, 2),\n-            PrimVal::U32(n)  => self.write_uint(ptr, n as u64, 4),\n-            PrimVal::U64(n)  => self.write_uint(ptr, n as u64, 8),\n-            PrimVal::Char(c) => self.write_uint(ptr, c as u64, 4),\n-            PrimVal::F32(f) => self.write_f32(ptr, f),\n-            PrimVal::F64(f) => self.write_f64(ptr, f),\n-            PrimVal::FnPtr(p) |\n-            PrimVal::Ptr(p) => self.write_ptr(ptr, p),\n+        use primval::PrimValKind::*;\n+        match val.kind {\n+            FnPtr(alloc_id) | Ptr(alloc_id) => {\n+                let p = Pointer::new(alloc_id, val.bits as usize);\n+                return self.write_ptr(ptr, p);\n+            }\n+            _ => {}\n         }\n+\n+        let (size, bits) = match val.kind {\n+            I8 | U8 | Bool         => (1, val.bits as u8  as u64),\n+            I16 | U16              => (2, val.bits as u16 as u64),\n+            I32 | U32 | F32 | Char => (4, val.bits as u32 as u64),\n+            I64 | U64 | F64        => (8, val.bits),\n+            FnPtr(_) | Ptr(_)      => bug!(\"handled above\"),\n+        };\n+\n+        self.write_uint(ptr, bits, size)\n     }\n \n     pub fn read_bool(&self, ptr: Pointer) -> EvalResult<'tcx, bool> {"}, {"sha": "5008aa24a2a0362b30c6f7de05f304ddb37bc697", "filename": "src/primval.rs", "status": "modified", "additions": 345, "deletions": 249, "changes": 594, "blob_url": "https://github.com/rust-lang/rust/blob/330be7766f6d89e127a63ae81ee1a2f032c53910/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/330be7766f6d89e127a63ae81ee1a2f032c53910/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=330be7766f6d89e127a63ae81ee1a2f032c53910", "patch": "@@ -1,306 +1,402 @@\n #![allow(unknown_lints)]\n #![allow(float_cmp)]\n \n+use std::mem::transmute;\n+\n use rustc::mir::repr as mir;\n \n use error::{EvalError, EvalResult};\n-use memory::Pointer;\n+use memory::{AllocId, Pointer};\n \n-#[derive(Clone, Copy, Debug, PartialEq)]\n-pub enum PrimVal {\n-    Bool(bool),\n-    I8(i8), I16(i16), I32(i32), I64(i64),\n-    U8(u8), U16(u16), U32(u32), U64(u64),\n+fn bits_to_f32(bits: u64) -> f32 {\n+    unsafe { transmute::<u32, f32>(bits as u32) }\n+}\n \n-    Ptr(Pointer),\n-    FnPtr(Pointer),\n-    Char(char),\n+fn bits_to_f64(bits: u64) -> f64 {\n+    unsafe { transmute::<u64, f64>(bits) }\n+}\n \n-    F32(f32), F64(f64),\n+fn f32_to_bits(f: f32) -> u64 {\n+    unsafe { transmute::<f32, u32>(f) as u64 }\n }\n \n-macro_rules! declare_expect_fn {\n-    ($name:ident, $variant:ident, $t:ty) => (\n-        pub fn $name(self, error_msg: &str) -> $t {\n-            match self {\n-                PrimVal::$variant(x) => x,\n-                _ => bug!(\"{}\", error_msg),\n-            }\n+fn f64_to_bits(f: f64) -> u64 {\n+    unsafe { transmute::<f64, u64>(f) }\n+}\n+\n+fn bits_to_bool(n: u64) -> bool {\n+    // FIXME(solson): Can we reach here due to user error?\n+    debug_assert!(n == 0 || n == 1, \"bits interpreted as bool were {}\", n);\n+    n & 1 == 1\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq)]\n+pub struct PrimVal {\n+    pub bits: u64,\n+    pub kind: PrimValKind,\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq)]\n+pub enum PrimValKind {\n+    I8, I16, I32, I64,\n+    U8, U16, U32, U64,\n+    F32, F64,\n+    Bool,\n+    Char,\n+    Ptr(AllocId),\n+    FnPtr(AllocId),\n+}\n+\n+impl PrimValKind {\n+    pub fn is_int(self) -> bool {\n+        use self::PrimValKind::*;\n+        match self {\n+            I8 | I16 | I32 | I64 | U8 | U16 | U32 | U64 => true,\n+            _ => false,\n         }\n-    );\n+    }\n }\n \n impl PrimVal {\n-    declare_expect_fn!(expect_bool, Bool, bool);\n-    declare_expect_fn!(expect_f32, F32, f32);\n-    declare_expect_fn!(expect_f64, F64, f64);\n-    declare_expect_fn!(expect_fn_ptr, FnPtr, Pointer);\n-    declare_expect_fn!(expect_ptr, Ptr, Pointer);\n+    pub fn new(bits: u64, kind: PrimValKind) -> Self {\n+        PrimVal { bits: bits, kind: kind }\n+    }\n+\n+    pub fn from_ptr(ptr: Pointer) -> Self {\n+        PrimVal::new(ptr.offset as u64, PrimValKind::Ptr(ptr.alloc_id))\n+    }\n+\n+    pub fn from_fn_ptr(ptr: Pointer) -> Self {\n+        PrimVal::new(ptr.offset as u64, PrimValKind::FnPtr(ptr.alloc_id))\n+    }\n+\n+    pub fn from_bool(b: bool) -> Self {\n+        PrimVal::new(b as u64, PrimValKind::Bool)\n+    }\n+\n+    pub fn from_char(c: char) -> Self {\n+        PrimVal::new(c as u64, PrimValKind::Char)\n+    }\n+\n+    pub fn from_f32(f: f32) -> Self {\n+        PrimVal::new(f32_to_bits(f), PrimValKind::F32)\n+    }\n+\n+    pub fn from_f64(f: f64) -> Self {\n+        PrimVal::new(f64_to_bits(f), PrimValKind::F64)\n+    }\n+\n+    pub fn from_uint_with_size(n: u64, size: usize) -> Self {\n+        let kind = match size {\n+            1 => PrimValKind::U8,\n+            2 => PrimValKind::U16,\n+            4 => PrimValKind::U32,\n+            8 => PrimValKind::U64,\n+            _ => bug!(\"can't make uint ({}) with size {}\", n, size),\n+        };\n+        PrimVal::new(n, kind)\n+    }\n+\n+    pub fn from_int_with_size(n: i64, size: usize) -> Self {\n+        let kind = match size {\n+            1 => PrimValKind::I8,\n+            2 => PrimValKind::I16,\n+            4 => PrimValKind::I32,\n+            8 => PrimValKind::I64,\n+            _ => bug!(\"can't make int ({}) with size {}\", n, size),\n+        };\n+        PrimVal::new(n as u64, kind)\n+    }\n+\n+    pub fn to_f32(self) -> f32 {\n+        bits_to_f32(self.bits)\n+    }\n+\n+    pub fn to_f64(self) -> f64 {\n+        bits_to_f64(self.bits)\n+    }\n \n     pub fn expect_uint(self, error_msg: &str) -> u64 {\n-        use self::PrimVal::*;\n-        match self {\n-            U8(u)  => u as u64,\n-            U16(u) => u as u64,\n-            U32(u) => u as u64,\n-            U64(u) => u,\n-            Ptr(ptr) => ptr.to_int().expect(\"non abstract ptr\") as u64,\n+        use self::PrimValKind::*;\n+        match self.kind {\n+            U8 | U16 | U32 | U64 => self.bits,\n+            Ptr(alloc_id) => {\n+                let ptr = Pointer::new(alloc_id, self.bits as usize);\n+                ptr.to_int().expect(\"non abstract ptr\") as u64\n+            }\n             _ => bug!(\"{}\", error_msg),\n         }\n     }\n \n     pub fn expect_int(self, error_msg: &str) -> i64 {\n-        use self::PrimVal::*;\n-        match self {\n-            I8(i)  => i as i64,\n-            I16(i) => i as i64,\n-            I32(i) => i as i64,\n-            I64(i) => i,\n-            Ptr(ptr) => ptr.to_int().expect(\"non abstract ptr\") as i64,\n+        use self::PrimValKind::*;\n+        match self.kind {\n+            I8 | I16 | I32 | I64 => self.bits as i64,\n+            Ptr(alloc_id) => {\n+                let ptr = Pointer::new(alloc_id, self.bits as usize);\n+                ptr.to_int().expect(\"non abstract ptr\") as i64\n+            }\n             _ => bug!(\"{}\", error_msg),\n         }\n     }\n \n-    pub fn uint_with_size(n: u64, size: usize) -> Self {\n-        use self::PrimVal::*;\n-        match size {\n-            1 => U8(n as u8),\n-            2 => U16(n as u16),\n-            4 => U32(n as u32),\n-            8 => U64(n),\n-            _ => bug!(\"can't make uint ({}) with size {}\", n, size),\n+    pub fn expect_bool(self, error_msg: &str) -> bool {\n+        match (self.kind, self.bits) {\n+            (PrimValKind::Bool, 0) => false,\n+            (PrimValKind::Bool, 1) => true,\n+            _ => bug!(\"{}\", error_msg),\n         }\n     }\n \n-    pub fn int_with_size(n: i64, size: usize) -> Self {\n-        use self::PrimVal::*;\n-        match size {\n-            1 => I8(n as i8),\n-            2 => I16(n as i16),\n-            4 => I32(n as i32),\n-            8 => I64(n),\n-            _ => bug!(\"can't make int ({}) with size {}\", n, size),\n+    pub fn expect_f32(self, error_msg: &str) -> f32 {\n+        match self.kind {\n+            PrimValKind::F32 => bits_to_f32(self.bits),\n+            _ => bug!(\"{}\", error_msg),\n         }\n     }\n-}\n \n-/// returns the result of the operation and whether the operation overflowed\n-pub fn binary_op<'tcx>(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> EvalResult<'tcx, (PrimVal, bool)> {\n-    use rustc::mir::repr::BinOp::*;\n-    use self::PrimVal::*;\n-\n-    macro_rules! overflow {\n-        ($v:ident, $v2:ident, $l:ident, $op:ident, $r:ident) => ({\n-            let (val, of) = $l.$op($r);\n-            if of {\n-                return Ok(($v(val), true));\n-            } else {\n-                $v(val)\n-            }\n-        })\n-    }\n-\n-    macro_rules! int_binops {\n-        ($v:ident, $l:ident, $r:ident) => ({\n-            match bin_op {\n-                Add    => overflow!($v, $v, $l, overflowing_add, $r),\n-                Sub    => overflow!($v, $v, $l, overflowing_sub, $r),\n-                Mul    => overflow!($v, $v, $l, overflowing_mul, $r),\n-                Div    => overflow!($v, $v, $l, overflowing_div, $r),\n-                Rem    => overflow!($v, $v, $l, overflowing_rem, $r),\n-                BitXor => $v($l ^ $r),\n-                BitAnd => $v($l & $r),\n-                BitOr  => $v($l | $r),\n-\n-                // these have already been handled\n-                Shl | Shr => bug!(\"`{}` operation should already have been handled\", bin_op.to_hir_binop().as_str()),\n-\n-                Eq => Bool($l == $r),\n-                Ne => Bool($l != $r),\n-                Lt => Bool($l < $r),\n-                Le => Bool($l <= $r),\n-                Gt => Bool($l > $r),\n-                Ge => Bool($l >= $r),\n-            }\n-        })\n+    pub fn expect_f64(self, error_msg: &str) -> f64 {\n+        match self.kind {\n+            PrimValKind::F32 => bits_to_f64(self.bits),\n+            _ => bug!(\"{}\", error_msg),\n+        }\n     }\n \n-    macro_rules! float_binops {\n-        ($v:ident, $l:ident, $r:ident) => ({\n-            match bin_op {\n-                Add    => $v($l + $r),\n-                Sub    => $v($l - $r),\n-                Mul    => $v($l * $r),\n-                Div    => $v($l / $r),\n-                Rem    => $v($l % $r),\n-\n-                // invalid float ops\n-                BitXor | BitAnd | BitOr |\n-                Shl | Shr => bug!(\"`{}` is not a valid operation on floats\", bin_op.to_hir_binop().as_str()),\n-\n-                Eq => Bool($l == $r),\n-                Ne => Bool($l != $r),\n-                Lt => Bool($l < $r),\n-                Le => Bool($l <= $r),\n-                Gt => Bool($l > $r),\n-                Ge => Bool($l >= $r),\n-            }\n-        })\n+    pub fn expect_ptr(self, error_msg: &str) -> Pointer {\n+        match self.kind {\n+            PrimValKind::Ptr(alloc_id) => Pointer::new(alloc_id, self.bits as usize),\n+            _ => bug!(\"{}\", error_msg),\n+        }\n     }\n \n-    fn unrelated_ptr_ops<'tcx>(bin_op: mir::BinOp) -> EvalResult<'tcx, PrimVal> {\n-        use rustc::mir::repr::BinOp::*;\n-        match bin_op {\n-            Eq => Ok(Bool(false)),\n-            Ne => Ok(Bool(true)),\n-            Lt | Le | Gt | Ge => Err(EvalError::InvalidPointerMath),\n-            _ => unimplemented!(),\n+    pub fn expect_fn_ptr(self, error_msg: &str) -> Pointer {\n+        match self.kind {\n+            PrimValKind::FnPtr(alloc_id) => Pointer::new(alloc_id, self.bits as usize),\n+            _ => bug!(\"{}\", error_msg),\n         }\n     }\n+}\n \n-    match bin_op {\n-        // can have rhs with a different numeric type\n-        Shl | Shr => {\n-            // these numbers are the maximum number a bitshift rhs could possibly have\n-            // e.g. u16 can be bitshifted by 0..16, so masking with 0b1111 (16 - 1) will ensure we are in that range\n-            let type_bits: u32 = match left {\n-                I8(_) | U8(_) => 8,\n-                I16(_) | U16(_) => 16,\n-                I32(_) | U32(_) => 32,\n-                I64(_) | U64(_) => 64,\n-                _ => bug!(\"bad MIR: bitshift lhs is not integral\"),\n-            };\n-            assert!(type_bits.is_power_of_two());\n-            // turn into `u32` because `overflowing_sh{l,r}` only take `u32`\n-            let r = match right {\n-                I8(i) => i as u32,\n-                I16(i) => i as u32,\n-                I32(i) => i as u32,\n-                I64(i) => i as u32,\n-                U8(i) => i as u32,\n-                U16(i) => i as u32,\n-                U32(i) => i as u32,\n-                U64(i) => i as u32,\n-                _ => bug!(\"bad MIR: bitshift rhs is not integral\"),\n-            };\n-            // apply mask\n-            let r = r & (type_bits - 1);\n-            macro_rules! shift {\n-                ($v:ident, $l:ident, $r:ident) => ({\n-                    match bin_op {\n-                        Shl => overflow!($v, U32, $l, overflowing_shl, $r),\n-                        Shr => overflow!($v, U32, $l, overflowing_shr, $r),\n-                        _ => bug!(\"it has already been checked that this is a shift op\"),\n-                    }\n-                })\n-            }\n-            let val = match left {\n-                I8(l) => shift!(I8, l, r),\n-                I16(l) => shift!(I16, l, r),\n-                I32(l) => shift!(I32, l, r),\n-                I64(l) => shift!(I64, l, r),\n-                U8(l) => shift!(U8, l, r),\n-                U16(l) => shift!(U16, l, r),\n-                U32(l) => shift!(U32, l, r),\n-                U64(l) => shift!(U64, l, r),\n-                _ => bug!(\"bad MIR: bitshift lhs is not integral (should already have been checked)\"),\n-            };\n-            return Ok((val, false));\n-        },\n-        _ => {},\n-    }\n+////////////////////////////////////////////////////////////////////////////////\n+// MIR operator evaluation\n+////////////////////////////////////////////////////////////////////////////////\n+\n+macro_rules! overflow {\n+    ($kind:expr, $op:ident, $l:expr, $r:expr) => ({\n+        let (val, overflowed) = $l.$op($r);\n+        let primval = PrimVal::new(val as u64, $kind);\n+        Ok((primval, overflowed))\n+    })\n+}\n \n-    let val = match (left, right) {\n-        (I8(l),  I8(r))  => int_binops!(I8, l, r),\n-        (I16(l), I16(r)) => int_binops!(I16, l, r),\n-        (I32(l), I32(r)) => int_binops!(I32, l, r),\n-        (I64(l), I64(r)) => int_binops!(I64, l, r),\n-        (U8(l),  U8(r))  => int_binops!(U8, l, r),\n-        (U16(l), U16(r)) => int_binops!(U16, l, r),\n-        (U32(l), U32(r)) => int_binops!(U32, l, r),\n-        (U64(l), U64(r)) => int_binops!(U64, l, r),\n-        (F32(l), F32(r)) => float_binops!(F32, l, r),\n-        (F64(l), F64(r)) => float_binops!(F64, l, r),\n-        (Char(l), Char(r)) => match bin_op {\n-            Eq => Bool(l == r),\n-            Ne => Bool(l != r),\n-            Lt => Bool(l < r),\n-            Le => Bool(l <= r),\n-            Gt => Bool(l > r),\n-            Ge => Bool(l >= r),\n-            _ => bug!(\"invalid char op: {:?}\", bin_op),\n-        },\n-\n-        (Bool(l), Bool(r)) => {\n-            Bool(match bin_op {\n-                Eq => l == r,\n-                Ne => l != r,\n-                Lt => l < r,\n-                Le => l <= r,\n-                Gt => l > r,\n-                Ge => l >= r,\n-                BitOr => l | r,\n-                BitXor => l ^ r,\n-                BitAnd => l & r,\n-                Add | Sub | Mul | Div | Rem | Shl | Shr => return Err(EvalError::InvalidBoolOp(bin_op)),\n-            })\n+macro_rules! int_arithmetic {\n+    ($kind:expr, $int_op:ident, $l:expr, $r:expr) => ({\n+        let l = $l;\n+        let r = $r;\n+        match $kind {\n+            I8  => overflow!(I8,  $int_op, l as i8,  r as i8),\n+            I16 => overflow!(I16, $int_op, l as i16, r as i16),\n+            I32 => overflow!(I32, $int_op, l as i32, r as i32),\n+            I64 => overflow!(I64, $int_op, l as i64, r as i64),\n+            U8  => overflow!(U8,  $int_op, l as u8,  r as u8),\n+            U16 => overflow!(U16, $int_op, l as u16, r as u16),\n+            U32 => overflow!(U32, $int_op, l as u32, r as u32),\n+            U64 => overflow!(U64, $int_op, l as u64, r as u64),\n+            _ => bug!(\"int_arithmetic should only be called on int primvals\"),\n         }\n+    })\n+}\n+\n+macro_rules! int_shift {\n+    ($kind:expr, $int_op:ident, $l:expr, $r:expr) => ({\n+        let l = $l;\n+        let r = $r;\n+        match $kind {\n+            I8  => overflow!(I8,  $int_op, l as i8,  r),\n+            I16 => overflow!(I16, $int_op, l as i16, r),\n+            I32 => overflow!(I32, $int_op, l as i32, r),\n+            I64 => overflow!(I64, $int_op, l as i64, r),\n+            U8  => overflow!(U8,  $int_op, l as u8,  r),\n+            U16 => overflow!(U16, $int_op, l as u16, r),\n+            U32 => overflow!(U32, $int_op, l as u32, r),\n+            U64 => overflow!(U64, $int_op, l as u64, r),\n+            _ => bug!(\"int_shift should only be called on int primvals\"),\n+        }\n+    })\n+}\n+\n+macro_rules! float_arithmetic {\n+    ($kind:expr, $from_bits:ident, $to_bits:ident, $float_op:tt, $l:expr, $r:expr) => ({\n+        let l = $from_bits($l);\n+        let r = $from_bits($r);\n+        let bits = $to_bits(l $float_op r);\n+        PrimVal::new(bits, $kind)\n+    })\n+}\n+\n+macro_rules! f32_arithmetic {\n+    ($float_op:tt, $l:expr, $r:expr) => (\n+        float_arithmetic!(F32, bits_to_f32, f32_to_bits, $float_op, $l, $r)\n+    )\n+}\n+\n+macro_rules! f64_arithmetic {\n+    ($float_op:tt, $l:expr, $r:expr) => (\n+        float_arithmetic!(F64, bits_to_f64, f64_to_bits, $float_op, $l, $r)\n+    )\n+}\n \n+/// Returns the result of the specified operation and whether it overflowed.\n+pub fn binary_op<'tcx>(\n+    bin_op: mir::BinOp,\n+    left: PrimVal,\n+    right: PrimVal\n+) -> EvalResult<'tcx, (PrimVal, bool)> {\n+    use rustc::mir::repr::BinOp::*;\n+    use self::PrimValKind::*;\n+\n+    match (left.kind, right.kind) {\n         (FnPtr(_), Ptr(_)) |\n-        (Ptr(_), FnPtr(_)) =>\n-            unrelated_ptr_ops(bin_op)?,\n-\n-        (FnPtr(l_ptr), FnPtr(r_ptr)) => match bin_op {\n-            Eq => Bool(l_ptr == r_ptr),\n-            Ne => Bool(l_ptr != r_ptr),\n-            _ => return Err(EvalError::Unimplemented(format!(\"unimplemented fn ptr comparison: {:?}\", bin_op))),\n-        },\n-\n-        (Ptr(l_ptr), Ptr(r_ptr)) => {\n-            if l_ptr.alloc_id != r_ptr.alloc_id {\n-                return Ok((unrelated_ptr_ops(bin_op)?, false));\n-            }\n+        (Ptr(_), FnPtr(_)) => return Ok((unrelated_ptr_ops(bin_op)?, false)),\n \n-            let l = l_ptr.offset;\n-            let r = r_ptr.offset;\n+        (Ptr(l_alloc), Ptr(r_alloc)) if l_alloc != r_alloc\n+            => return Ok((unrelated_ptr_ops(bin_op)?, false)),\n \n+        (FnPtr(l_alloc), FnPtr(r_alloc)) => {\n             match bin_op {\n-                Eq => Bool(l == r),\n-                Ne => Bool(l != r),\n-                Lt => Bool(l < r),\n-                Le => Bool(l <= r),\n-                Gt => Bool(l > r),\n-                Ge => Bool(l >= r),\n-                _ => return Err(EvalError::Unimplemented(format!(\"unimplemented ptr op: {:?}\", bin_op))),\n+                Eq => return Ok((PrimVal::from_bool(l_alloc == r_alloc), false)),\n+                Ne => return Ok((PrimVal::from_bool(l_alloc != r_alloc), false)),\n+                _ => {}\n             }\n         }\n \n-        (l, r) => return Err(EvalError::Unimplemented(format!(\"unimplemented binary op: {:?}, {:?}, {:?}\", l, r, bin_op))),\n+        _ => {}\n+    }\n+\n+    let (l, r) = (left.bits, right.bits);\n+\n+    // These ops can have an RHS with a different numeric type.\n+    if bin_op == Shl || bin_op == Shr {\n+        // These are the maximum values a bitshift RHS could possibly have. For example, u16\n+        // can be bitshifted by 0..16, so masking with 0b1111 (16 - 1) will ensure we are in\n+        // that range.\n+        let type_bits: u32 = match left.kind {\n+            I8  | U8  => 8,\n+            I16 | U16 => 16,\n+            I32 | U32 => 32,\n+            I64 | U64 => 64,\n+            _ => bug!(\"bad MIR: bitshift lhs is not integral\"),\n+        };\n+\n+        // Cast to `u32` because `overflowing_sh{l,r}` only take `u32`, then apply the bitmask\n+        // to ensure it's within the valid shift value range.\n+        let r = (right.bits as u32) & (type_bits - 1);\n+\n+        return match bin_op {\n+            Shl => int_shift!(left.kind, overflowing_shl, l, r),\n+            Shr => int_shift!(left.kind, overflowing_shr, l, r),\n+            _ => bug!(\"it has already been checked that this is a shift op\"),\n+        };\n+    }\n+\n+    if left.kind != right.kind {\n+        let msg = format!(\"unimplemented binary op: {:?}, {:?}, {:?}\", left, right, bin_op);\n+        return Err(EvalError::Unimplemented(msg));\n+    }\n+\n+    let val = match (bin_op, left.kind) {\n+        (Eq, F32) => PrimVal::from_bool(bits_to_f32(l) == bits_to_f32(r)),\n+        (Ne, F32) => PrimVal::from_bool(bits_to_f32(l) != bits_to_f32(r)),\n+        (Lt, F32) => PrimVal::from_bool(bits_to_f32(l) <  bits_to_f32(r)),\n+        (Le, F32) => PrimVal::from_bool(bits_to_f32(l) <= bits_to_f32(r)),\n+        (Gt, F32) => PrimVal::from_bool(bits_to_f32(l) >  bits_to_f32(r)),\n+        (Ge, F32) => PrimVal::from_bool(bits_to_f32(l) >= bits_to_f32(r)),\n+\n+        (Eq, F64) => PrimVal::from_bool(bits_to_f64(l) == bits_to_f64(r)),\n+        (Ne, F64) => PrimVal::from_bool(bits_to_f64(l) != bits_to_f64(r)),\n+        (Lt, F64) => PrimVal::from_bool(bits_to_f64(l) <  bits_to_f64(r)),\n+        (Le, F64) => PrimVal::from_bool(bits_to_f64(l) <= bits_to_f64(r)),\n+        (Gt, F64) => PrimVal::from_bool(bits_to_f64(l) >  bits_to_f64(r)),\n+        (Ge, F64) => PrimVal::from_bool(bits_to_f64(l) >= bits_to_f64(r)),\n+\n+        (Add, F32) => f32_arithmetic!(+, l, r),\n+        (Sub, F32) => f32_arithmetic!(-, l, r),\n+        (Mul, F32) => f32_arithmetic!(*, l, r),\n+        (Div, F32) => f32_arithmetic!(/, l, r),\n+        (Rem, F32) => f32_arithmetic!(%, l, r),\n+\n+        (Add, F64) => f64_arithmetic!(+, l, r),\n+        (Sub, F64) => f64_arithmetic!(-, l, r),\n+        (Mul, F64) => f64_arithmetic!(*, l, r),\n+        (Div, F64) => f64_arithmetic!(/, l, r),\n+        (Rem, F64) => f64_arithmetic!(%, l, r),\n+\n+        (Eq, _) => PrimVal::from_bool(l == r),\n+        (Ne, _) => PrimVal::from_bool(l != r),\n+        (Lt, _) => PrimVal::from_bool(l <  r),\n+        (Le, _) => PrimVal::from_bool(l <= r),\n+        (Gt, _) => PrimVal::from_bool(l >  r),\n+        (Ge, _) => PrimVal::from_bool(l >= r),\n+\n+        (BitOr,  k) => PrimVal::new(l | r, k),\n+        (BitAnd, k) => PrimVal::new(l & r, k),\n+        (BitXor, k) => PrimVal::new(l ^ r, k),\n+\n+        (Add, k) if k.is_int() => return int_arithmetic!(k, overflowing_add, l, r),\n+        (Sub, k) if k.is_int() => return int_arithmetic!(k, overflowing_sub, l, r),\n+        (Mul, k) if k.is_int() => return int_arithmetic!(k, overflowing_mul, l, r),\n+        (Div, k) if k.is_int() => return int_arithmetic!(k, overflowing_div, l, r),\n+        (Rem, k) if k.is_int() => return int_arithmetic!(k, overflowing_rem, l, r),\n+\n+        _ => {\n+            let msg = format!(\"unimplemented binary op: {:?}, {:?}, {:?}\", left, right, bin_op);\n+            return Err(EvalError::Unimplemented(msg));\n+        }\n     };\n \n     Ok((val, false))\n }\n \n+fn unrelated_ptr_ops<'tcx>(bin_op: mir::BinOp) -> EvalResult<'tcx, PrimVal> {\n+    use rustc::mir::repr::BinOp::*;\n+    match bin_op {\n+        Eq => Ok(PrimVal::from_bool(false)),\n+        Ne => Ok(PrimVal::from_bool(true)),\n+        Lt | Le | Gt | Ge => Err(EvalError::InvalidPointerMath),\n+        _ => bug!(),\n+    }\n+}\n+\n pub fn unary_op<'tcx>(un_op: mir::UnOp, val: PrimVal) -> EvalResult<'tcx, PrimVal> {\n     use rustc::mir::repr::UnOp::*;\n-    use self::PrimVal::*;\n-    match (un_op, val) {\n-        (Not, Bool(b)) => Ok(Bool(!b)),\n-        (Not, I8(n))  => Ok(I8(!n)),\n-        (Neg, I8(n))  => Ok(I8(-n)),\n-        (Not, I16(n)) => Ok(I16(!n)),\n-        (Neg, I16(n)) => Ok(I16(-n)),\n-        (Not, I32(n)) => Ok(I32(!n)),\n-        (Neg, I32(n)) => Ok(I32(-n)),\n-        (Not, I64(n)) => Ok(I64(!n)),\n-        (Neg, I64(n)) => Ok(I64(-n)),\n-        (Not, U8(n))  => Ok(U8(!n)),\n-        (Not, U16(n)) => Ok(U16(!n)),\n-        (Not, U32(n)) => Ok(U32(!n)),\n-        (Not, U64(n)) => Ok(U64(!n)),\n-\n-        (Neg, F64(n)) => Ok(F64(-n)),\n-        (Neg, F32(n)) => Ok(F32(-n)),\n-        _ => Err(EvalError::Unimplemented(format!(\"unimplemented unary op: {:?}, {:?}\", un_op, val))),\n-    }\n+    use self::PrimValKind::*;\n+\n+    let bits = match (un_op, val.kind) {\n+        (Not, Bool) => !bits_to_bool(val.bits) as u64,\n+\n+        (Not, U8)  => !(val.bits as u8) as u64,\n+        (Not, U16) => !(val.bits as u16) as u64,\n+        (Not, U32) => !(val.bits as u32) as u64,\n+        (Not, U64) => !val.bits,\n+\n+        (Not, I8)  => !(val.bits as i8) as u64,\n+        (Not, I16) => !(val.bits as i16) as u64,\n+        (Not, I32) => !(val.bits as i32) as u64,\n+        (Not, I64) => !(val.bits as i64) as u64,\n+\n+        (Neg, I8)  => -(val.bits as i8) as u64,\n+        (Neg, I16) => -(val.bits as i16) as u64,\n+        (Neg, I32) => -(val.bits as i32) as u64,\n+        (Neg, I64) => -(val.bits as i64) as u64,\n+\n+        (Neg, F32) => f32_to_bits(-bits_to_f32(val.bits)),\n+        (Neg, F64) => f64_to_bits(-bits_to_f64(val.bits)),\n+\n+        _ => {\n+            let msg = format!(\"unimplemented unary op: {:?}, {:?}\", un_op, val);\n+            return Err(EvalError::Unimplemented(msg));\n+        }\n+    };\n+\n+    Ok(PrimVal::new(bits, val.kind))\n }"}]}