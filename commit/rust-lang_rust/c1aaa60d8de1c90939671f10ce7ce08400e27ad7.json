{"sha": "c1aaa60d8de1c90939671f10ce7ce08400e27ad7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxYWFhNjBkOGRlMWM5MDkzOTY3MWYxMGNlN2NlMDg0MDBlMjdhZDc=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2017-04-20T23:09:54Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2017-04-21T04:16:31Z"}, "message": "Remove float_extras\n\n[unstable, deprecated since 1.11.0]", "tree": {"sha": "331d9df08d1ebe634920b05c326f4db94e889a5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/331d9df08d1ebe634920b05c326f4db94e889a5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1aaa60d8de1c90939671f10ce7ce08400e27ad7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1aaa60d8de1c90939671f10ce7ce08400e27ad7", "html_url": "https://github.com/rust-lang/rust/commit/c1aaa60d8de1c90939671f10ce7ce08400e27ad7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c903ac64e58241a71ec42e791b0cc1451ffc3840", "url": "https://api.github.com/repos/rust-lang/rust/commits/c903ac64e58241a71ec42e791b0cc1451ffc3840", "html_url": "https://github.com/rust-lang/rust/commit/c903ac64e58241a71ec42e791b0cc1451ffc3840"}], "stats": {"total": 633, "additions": 74, "deletions": 559}, "files": [{"sha": "9fbd4e300f8f8602a9f7dd32b847b9cc323c052c", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=c1aaa60d8de1c90939671f10ce7ce08400e27ad7", "patch": "@@ -133,7 +133,6 @@\n     - [fd_read](library-features/fd-read.md)\n     - [fixed_size_array](library-features/fixed-size-array.md)\n     - [float_bits_conv](library-features/float-bits-conv.md)\n-    - [float_extras](library-features/float-extras.md)\n     - [flt2dec](library-features/flt2dec.md)\n     - [fmt_flags_align](library-features/fmt-flags-align.md)\n     - [fmt_internals](library-features/fmt-internals.md)"}, {"sha": "ff2d20a545fe5d1dfc4f5daadf332e113411ce81", "filename": "src/doc/unstable-book/src/library-features/float-extras.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c903ac64e58241a71ec42e791b0cc1451ffc3840/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffloat-extras.md", "raw_url": "https://github.com/rust-lang/rust/raw/c903ac64e58241a71ec42e791b0cc1451ffc3840/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffloat-extras.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffloat-extras.md?ref=c903ac64e58241a71ec42e791b0cc1451ffc3840", "patch": "@@ -1,7 +0,0 @@\n-# `float_extras`\n-\n-The tracking issue for this feature is: [#27752]\n-\n-[#27752]: https://github.com/rust-lang/rust/issues/27752\n-\n-------------------------"}, {"sha": "2a60292d0232e1e525606edc20ecc0a9821abc68", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=c1aaa60d8de1c90939671f10ce7ce08400e27ad7", "patch": "@@ -63,11 +63,8 @@ pub trait RawFloat : Float + Copy + Debug + LowerExp\n     const NAN: Self;\n     const ZERO: Self;\n \n-    // suffix of \"2\" because Float::integer_decode is deprecated\n-    #[allow(deprecated)]\n-    fn integer_decode2(self) -> (u64, i16, i8) {\n-        Float::integer_decode(self)\n-    }\n+    /// Returns the mantissa, exponent and sign as integers.\n+    fn integer_decode(self) -> (u64, i16, i8);\n \n     /// Get the raw binary representation of the float.\n     fn transmute(self) -> u64;\n@@ -160,6 +157,21 @@ impl RawFloat for f32 {\n     const ZERO_CUTOFF: i64 = -48;\n     other_constants!(f32);\n \n+    /// Returns the mantissa, exponent and sign as integers.\n+    fn integer_decode(self) -> (u64, i16, i8) {\n+        let bits: u32 = unsafe { transmute(self) };\n+        let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n+        let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n+        let mantissa = if exponent == 0 {\n+            (bits & 0x7fffff) << 1\n+        } else {\n+            (bits & 0x7fffff) | 0x800000\n+        };\n+        // Exponent bias + mantissa shift\n+        exponent -= 127 + 23;\n+        (mantissa as u64, exponent, sign)\n+    }\n+\n     fn transmute(self) -> u64 {\n         let bits: u32 = unsafe { transmute(self) };\n         bits as u64\n@@ -171,7 +183,7 @@ impl RawFloat for f32 {\n     }\n \n     fn unpack(self) -> Unpacked {\n-        let (sig, exp, _sig) = self.integer_decode2();\n+        let (sig, exp, _sig) = self.integer_decode();\n         Unpacked::new(sig, exp)\n     }\n \n@@ -196,6 +208,21 @@ impl RawFloat for f64 {\n     const ZERO_CUTOFF: i64 = -326;\n     other_constants!(f64);\n \n+    /// Returns the mantissa, exponent and sign as integers.\n+    fn integer_decode(self) -> (u64, i16, i8) {\n+        let bits: u64 = unsafe { transmute(self) };\n+        let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n+        let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n+        let mantissa = if exponent == 0 {\n+            (bits & 0xfffffffffffff) << 1\n+        } else {\n+            (bits & 0xfffffffffffff) | 0x10000000000000\n+        };\n+        // Exponent bias + mantissa shift\n+        exponent -= 1023 + 52;\n+        (mantissa, exponent, sign)\n+    }\n+\n     fn transmute(self) -> u64 {\n         let bits: u64 = unsafe { transmute(self) };\n         bits\n@@ -206,7 +233,7 @@ impl RawFloat for f64 {\n     }\n \n     fn unpack(self) -> Unpacked {\n-        let (sig, exp, _sig) = self.integer_decode2();\n+        let (sig, exp, _sig) = self.integer_decode();\n         Unpacked::new(sig, exp)\n     }\n "}, {"sha": "91ca213e96e0d19b84c38b83668d193790804020", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=c1aaa60d8de1c90939671f10ce7ce08400e27ad7", "patch": "@@ -143,36 +143,6 @@ pub mod consts {\n            reason = \"stable interface is via `impl f{32,64}` in later crates\",\n            issue = \"32110\")]\n impl Float for f32 {\n-    #[inline]\n-    fn nan() -> f32 {\n-        NAN\n-    }\n-\n-    #[inline]\n-    fn infinity() -> f32 {\n-        INFINITY\n-    }\n-\n-    #[inline]\n-    fn neg_infinity() -> f32 {\n-        NEG_INFINITY\n-    }\n-\n-    #[inline]\n-    fn zero() -> f32 {\n-        0.0\n-    }\n-\n-    #[inline]\n-    fn neg_zero() -> f32 {\n-        -0.0\n-    }\n-\n-    #[inline]\n-    fn one() -> f32 {\n-        1.0\n-    }\n-\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool {\n@@ -214,21 +184,6 @@ impl Float for f32 {\n         }\n     }\n \n-    /// Returns the mantissa, exponent and sign as integers.\n-    fn integer_decode(self) -> (u64, i16, i8) {\n-        let bits: u32 = unsafe { mem::transmute(self) };\n-        let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n-        let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n-        let mantissa = if exponent == 0 {\n-            (bits & 0x7fffff) << 1\n-        } else {\n-            (bits & 0x7fffff) | 0x800000\n-        };\n-        // Exponent bias + mantissa shift\n-        exponent -= 127 + 23;\n-        (mantissa as u64, exponent, sign)\n-    }\n-\n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n     /// number is `Float::nan()`.\n     #[inline]"}, {"sha": "7d6d6cef049772f3f2d267a394cf44125015ad69", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=c1aaa60d8de1c90939671f10ce7ce08400e27ad7", "patch": "@@ -143,36 +143,6 @@ pub mod consts {\n            reason = \"stable interface is via `impl f{32,64}` in later crates\",\n            issue = \"32110\")]\n impl Float for f64 {\n-    #[inline]\n-    fn nan() -> f64 {\n-        NAN\n-    }\n-\n-    #[inline]\n-    fn infinity() -> f64 {\n-        INFINITY\n-    }\n-\n-    #[inline]\n-    fn neg_infinity() -> f64 {\n-        NEG_INFINITY\n-    }\n-\n-    #[inline]\n-    fn zero() -> f64 {\n-        0.0\n-    }\n-\n-    #[inline]\n-    fn neg_zero() -> f64 {\n-        -0.0\n-    }\n-\n-    #[inline]\n-    fn one() -> f64 {\n-        1.0\n-    }\n-\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool {\n@@ -214,21 +184,6 @@ impl Float for f64 {\n         }\n     }\n \n-    /// Returns the mantissa, exponent and sign as integers.\n-    fn integer_decode(self) -> (u64, i16, i8) {\n-        let bits: u64 = unsafe { mem::transmute(self) };\n-        let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n-        let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n-        let mantissa = if exponent == 0 {\n-            (bits & 0xfffffffffffff) << 1\n-        } else {\n-            (bits & 0xfffffffffffff) | 0x10000000000000\n-        };\n-        // Exponent bias + mantissa shift\n-        exponent -= 1023 + 52;\n-        (mantissa, exponent, sign)\n-    }\n-\n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n     /// number is `Float::nan()`.\n     #[inline]"}, {"sha": "b779eefce5752c1bf100488f35106454c83c7770", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=c1aaa60d8de1c90939671f10ce7ce08400e27ad7", "patch": "@@ -67,7 +67,7 @@ impl DecodableFloat for f64 {\n /// Returns a sign (true when negative) and `FullDecoded` value\n /// from given floating point number.\n pub fn decode<T: DecodableFloat>(v: T) -> (/*negative?*/ bool, FullDecoded) {\n-    let (mant, exp, sign) = v.integer_decode2();\n+    let (mant, exp, sign) = v.integer_decode();\n     let even = (mant & 1) == 0;\n     let decoded = match v.classify() {\n         FpCategory::Nan => FullDecoded::Nan,\n@@ -81,7 +81,7 @@ pub fn decode<T: DecodableFloat>(v: T) -> (/*negative?*/ bool, FullDecoded) {\n                                           exp: exp, inclusive: even })\n         }\n         FpCategory::Normal => {\n-            let minnorm = <T as DecodableFloat>::min_pos_norm_value().integer_decode2();\n+            let minnorm = <T as DecodableFloat>::min_pos_norm_value().integer_decode();\n             if mant == minnorm.0 {\n                 // neighbors: (maxmant, exp - 1) -- (minnormmant, exp) -- (minnormmant + 1, exp)\n                 // where maxmant = minnormmant * 2 - 1"}, {"sha": "5c4a43fbd110a4e4a86202146e8d0ddb05abdde2", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=c1aaa60d8de1c90939671f10ce7ce08400e27ad7", "patch": "@@ -2453,49 +2453,6 @@ pub enum FpCategory {\n            reason = \"stable interface is via `impl f{32,64}` in later crates\",\n            issue = \"32110\")]\n pub trait Float: Sized {\n-    /// Returns the NaN value.\n-    #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn nan() -> Self;\n-    /// Returns the infinite value.\n-    #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn infinity() -> Self;\n-    /// Returns the negative infinite value.\n-    #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn neg_infinity() -> Self;\n-    /// Returns -0.0.\n-    #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn neg_zero() -> Self;\n-    /// Returns 0.0.\n-    #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn zero() -> Self;\n-    /// Returns 1.0.\n-    #[unstable(feature = \"float_extras\", reason = \"needs removal\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn one() -> Self;\n-\n     /// Returns `true` if this value is NaN and false otherwise.\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_nan(self) -> bool;\n@@ -2513,14 +2470,6 @@ pub trait Float: Sized {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn classify(self) -> FpCategory;\n \n-    /// Returns the mantissa, exponent and sign as integers, respectively.\n-    #[unstable(feature = \"float_extras\", reason = \"signature is undecided\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    fn integer_decode(self) -> (u64, i16, i8);\n-\n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n     /// number is `Float::nan()`.\n     #[stable(feature = \"core\", since = \"1.6.0\")]"}, {"sha": "2b0afc402027f11f1c999846583241f231ed66d0", "filename": "src/libcore/tests/num/dec2flt/rawfp.rs", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs?ref=c1aaa60d8de1c90939671f10ce7ce08400e27ad7", "patch": "@@ -8,23 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::f32;\n use std::f64;\n-use std::mem;\n use core::num::diy_float::Fp;\n use core::num::dec2flt::rawfp::{fp_to_float, prev_float, next_float, round_normal};\n+use core::num::dec2flt::rawfp::RawFloat;\n \n fn integer_decode(f: f64) -> (u64, i16, i8) {\n-    let bits: u64 = unsafe { mem::transmute(f) };\n-    let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n-    let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n-    let mantissa = if exponent == 0 {\n-        (bits & 0xfffffffffffff) << 1\n-    } else {\n-        (bits & 0xfffffffffffff) | 0x10000000000000\n-    };\n-    // Exponent bias + mantissa shift\n-    exponent -= 1023 + 52;\n-    (mantissa, exponent, sign)\n+    RawFloat::integer_decode(f)\n }\n \n #[test]\n@@ -152,3 +143,35 @@ fn next_float_monotonic() {\n     }\n     assert!(x > 0.5);\n }\n+\n+#[test]\n+fn test_f32_integer_decode() {\n+    assert_eq!(3.14159265359f32.integer_decode(), (13176795, -22, 1));\n+    assert_eq!((-8573.5918555f32).integer_decode(), (8779358, -10, -1));\n+    assert_eq!(2f32.powf(100.0).integer_decode(), (8388608, 77, 1));\n+    assert_eq!(0f32.integer_decode(), (0, -150, 1));\n+    assert_eq!((-0f32).integer_decode(), (0, -150, -1));\n+    assert_eq!(f32::INFINITY.integer_decode(), (8388608, 105, 1));\n+    assert_eq!(f32::NEG_INFINITY.integer_decode(), (8388608, 105, -1));\n+\n+    // Ignore the \"sign\" (quiet / signalling flag) of NAN.\n+    // It can vary between runtime operations and LLVM folding.\n+    let (nan_m, nan_e, _nan_s) = f32::NAN.integer_decode();\n+    assert_eq!((nan_m, nan_e), (12582912, 105));\n+}\n+\n+#[test]\n+fn test_f64_integer_decode() {\n+    assert_eq!(3.14159265359f64.integer_decode(), (7074237752028906, -51, 1));\n+    assert_eq!((-8573.5918555f64).integer_decode(), (4713381968463931, -39, -1));\n+    assert_eq!(2f64.powf(100.0).integer_decode(), (4503599627370496, 48, 1));\n+    assert_eq!(0f64.integer_decode(), (0, -1075, 1));\n+    assert_eq!((-0f64).integer_decode(), (0, -1075, -1));\n+    assert_eq!(f64::INFINITY.integer_decode(), (4503599627370496, 972, 1));\n+    assert_eq!(f64::NEG_INFINITY.integer_decode(), (4503599627370496, 972, -1));\n+\n+    // Ignore the \"sign\" (quiet / signalling flag) of NAN.\n+    // It can vary between runtime operations and LLVM folding.\n+    let (nan_m, nan_e, _nan_s) = f64::NAN.integer_decode();\n+    assert_eq!((nan_m, nan_e), (6755399441055744, 972));\n+}"}, {"sha": "4ed0afcfc2357d7cca92bec811fa1069a0ea85e2", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 0, "deletions": 204, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=c1aaa60d8de1c90939671f10ce7ce08400e27ad7", "patch": "@@ -22,8 +22,6 @@ use core::num;\n #[cfg(not(test))]\n use intrinsics;\n #[cfg(not(test))]\n-use libc::c_int;\n-#[cfg(not(test))]\n use num::FpCategory;\n \n \n@@ -73,8 +71,6 @@ mod cmath {\n         pub fn atan2f(a: c_float, b: c_float) -> c_float;\n         pub fn atanf(n: c_float) -> c_float;\n         pub fn coshf(n: c_float) -> c_float;\n-        pub fn frexpf(n: c_float, value: &mut c_int) -> c_float;\n-        pub fn ldexpf(x: c_float, n: c_int) -> c_float;\n         pub fn sinhf(n: c_float) -> c_float;\n         pub fn tanf(n: c_float) -> c_float;\n         pub fn tanhf(n: c_float) -> c_float;\n@@ -111,20 +107,6 @@ mod cmath {\n             f64::cosh(n as f64) as c_float\n         }\n \n-        #[inline]\n-        #[allow(deprecated)]\n-        pub unsafe fn frexpf(x: c_float, value: &mut c_int) -> c_float {\n-            let (a, b) = f64::frexp(x as f64);\n-            *value = b as c_int;\n-            a as c_float\n-        }\n-\n-        #[inline]\n-        #[allow(deprecated)]\n-        pub unsafe fn ldexpf(x: c_float, n: c_int) -> c_float {\n-            f64::ldexp(x as f64, n as isize) as c_float\n-        }\n-\n         #[inline]\n         pub unsafe fn sinhf(n: c_float) -> c_float {\n             f64::sinh(n as f64) as c_float\n@@ -244,40 +226,6 @@ impl f32 {\n     #[inline]\n     pub fn classify(self) -> FpCategory { num::Float::classify(self) }\n \n-    /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.\n-    /// The original number can be recovered by `sign * mantissa * 2 ^ exponent`.\n-    /// The floating point encoding is documented in the [Reference][floating-point].\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// use std::f32;\n-    ///\n-    /// let num = 2.0f32;\n-    ///\n-    /// // (8388608, -22, 1)\n-    /// let (mantissa, exponent, sign) = num.integer_decode();\n-    /// let sign_f = sign as f32;\n-    /// let mantissa_f = mantissa as f32;\n-    /// let exponent_f = num.powf(exponent as f32);\n-    ///\n-    /// // 1 * 8388608 * 2^(-22) == 2\n-    /// let abs_difference = (sign_f * mantissa_f * exponent_f - num).abs();\n-    ///\n-    /// assert!(abs_difference <= f32::EPSILON);\n-    /// ```\n-    /// [floating-point]: ../reference/types.html#machine-types\n-    #[unstable(feature = \"float_extras\", reason = \"signature is undecided\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    #[allow(deprecated)]\n-    pub fn integer_decode(self) -> (u64, i16, i8) {\n-        num::Float::integer_decode(self)\n-    }\n-\n     /// Returns the largest integer less than or equal to a number.\n     ///\n     /// ```\n@@ -712,89 +660,6 @@ impl f32 {\n     #[inline]\n     pub fn to_radians(self) -> f32 { num::Float::to_radians(self) }\n \n-    /// Constructs a floating point number of `x*2^exp`.\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// use std::f32;\n-    /// // 3*2^2 - 12 == 0\n-    /// let abs_difference = (f32::ldexp(3.0, 2) - 12.0).abs();\n-    ///\n-    /// assert!(abs_difference <= f32::EPSILON);\n-    /// ```\n-    #[unstable(feature = \"float_extras\",\n-               reason = \"pending integer conventions\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    pub fn ldexp(x: f32, exp: isize) -> f32 {\n-        unsafe { cmath::ldexpf(x, exp as c_int) }\n-    }\n-\n-    /// Breaks the number into a normalized fraction and a base-2 exponent,\n-    /// satisfying:\n-    ///\n-    ///  * `self = x * 2^exp`\n-    ///  * `0.5 <= abs(x) < 1.0`\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// use std::f32;\n-    ///\n-    /// let x = 4.0f32;\n-    ///\n-    /// // (1/2)*2^3 -> 1 * 8/2 -> 4.0\n-    /// let f = x.frexp();\n-    /// let abs_difference_0 = (f.0 - 0.5).abs();\n-    /// let abs_difference_1 = (f.1 as f32 - 3.0).abs();\n-    ///\n-    /// assert!(abs_difference_0 <= f32::EPSILON);\n-    /// assert!(abs_difference_1 <= f32::EPSILON);\n-    /// ```\n-    #[unstable(feature = \"float_extras\",\n-               reason = \"pending integer conventions\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    pub fn frexp(self) -> (f32, isize) {\n-        unsafe {\n-            let mut exp = 0;\n-            let x = cmath::frexpf(self, &mut exp);\n-            (x, exp as isize)\n-        }\n-    }\n-\n-    /// Returns the next representable floating-point value in the direction of\n-    /// `other`.\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// use std::f32;\n-    ///\n-    /// let x = 1.0f32;\n-    ///\n-    /// let abs_diff = (x.next_after(2.0) - 1.00000011920928955078125_f32).abs();\n-    ///\n-    /// assert!(abs_diff <= f32::EPSILON);\n-    /// ```\n-    #[unstable(feature = \"float_extras\",\n-               reason = \"unsure about its place in the world\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    pub fn next_after(self, other: f32) -> f32 {\n-        unsafe { cmath::nextafterf(self, other) }\n-    }\n-\n     /// Returns the maximum of the two numbers.\n     ///\n     /// ```\n@@ -1462,23 +1327,6 @@ mod tests {\n         assert_eq!(1e-38f32.classify(), Fp::Subnormal);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_integer_decode() {\n-        assert_eq!(3.14159265359f32.integer_decode(), (13176795, -22, 1));\n-        assert_eq!((-8573.5918555f32).integer_decode(), (8779358, -10, -1));\n-        assert_eq!(2f32.powf(100.0).integer_decode(), (8388608, 77, 1));\n-        assert_eq!(0f32.integer_decode(), (0, -150, 1));\n-        assert_eq!((-0f32).integer_decode(), (0, -150, -1));\n-        assert_eq!(INFINITY.integer_decode(), (8388608, 105, 1));\n-        assert_eq!(NEG_INFINITY.integer_decode(), (8388608, 105, -1));\n-\n-        // Ignore the \"sign\" (quiet / signalling flag) of NAN.\n-        // It can vary between runtime operations and LLVM folding.\n-        let (nan_m, nan_e, _nan_s) = NAN.integer_decode();\n-        assert_eq!((nan_m, nan_e), (12582912, 105));\n-    }\n-\n     #[test]\n     fn test_floor() {\n         assert_approx_eq!(1.0f32.floor(), 1.0f32);\n@@ -1790,58 +1638,6 @@ mod tests {\n         assert_eq!(neg_inf.to_radians(), neg_inf);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_ldexp() {\n-        let f1 = 2.0f32.powi(-123);\n-        let f2 = 2.0f32.powi(-111);\n-        let f3 = 1.75 * 2.0f32.powi(-12);\n-        assert_eq!(f32::ldexp(1f32, -123), f1);\n-        assert_eq!(f32::ldexp(1f32, -111), f2);\n-        assert_eq!(f32::ldexp(1.75f32, -12), f3);\n-\n-        assert_eq!(f32::ldexp(0f32, -123), 0f32);\n-        assert_eq!(f32::ldexp(-0f32, -123), -0f32);\n-\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        let nan: f32 = f32::NAN;\n-        assert_eq!(f32::ldexp(inf, -123), inf);\n-        assert_eq!(f32::ldexp(neg_inf, -123), neg_inf);\n-        assert!(f32::ldexp(nan, -123).is_nan());\n-    }\n-\n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_frexp() {\n-        let f1 = 2.0f32.powi(-123);\n-        let f2 = 2.0f32.powi(-111);\n-        let f3 = 1.75 * 2.0f32.powi(-123);\n-        let (x1, exp1) = f1.frexp();\n-        let (x2, exp2) = f2.frexp();\n-        let (x3, exp3) = f3.frexp();\n-        assert_eq!((x1, exp1), (0.5f32, -122));\n-        assert_eq!((x2, exp2), (0.5f32, -110));\n-        assert_eq!((x3, exp3), (0.875f32, -122));\n-        assert_eq!(f32::ldexp(x1, exp1), f1);\n-        assert_eq!(f32::ldexp(x2, exp2), f2);\n-        assert_eq!(f32::ldexp(x3, exp3), f3);\n-\n-        assert_eq!(0f32.frexp(), (0f32, 0));\n-        assert_eq!((-0f32).frexp(), (-0f32, 0));\n-    }\n-\n-    #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n-    #[allow(deprecated)]\n-    fn test_frexp_nowin() {\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        let nan: f32 = f32::NAN;\n-        assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n-        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n-        assert!(match nan.frexp() { (x, _) => x.is_nan() })\n-    }\n-\n     #[test]\n     fn test_asinh() {\n         assert_eq!(0.0f32.asinh(), 0.0f32);"}, {"sha": "82e3903eec7b13d8270b39115d3402fa7ee9a689", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=c1aaa60d8de1c90939671f10ce7ce08400e27ad7", "patch": "@@ -22,8 +22,6 @@ use core::num;\n #[cfg(not(test))]\n use intrinsics;\n #[cfg(not(test))]\n-use libc::c_int;\n-#[cfg(not(test))]\n use num::FpCategory;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -188,36 +186,6 @@ impl f64 {\n     #[inline]\n     pub fn classify(self) -> FpCategory { num::Float::classify(self) }\n \n-    /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.\n-    /// The original number can be recovered by `sign * mantissa * 2 ^ exponent`.\n-    /// The floating point encoding is documented in the [Reference][floating-point].\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// let num = 2.0f64;\n-    ///\n-    /// // (8388608, -22, 1)\n-    /// let (mantissa, exponent, sign) = num.integer_decode();\n-    /// let sign_f = sign as f64;\n-    /// let mantissa_f = mantissa as f64;\n-    /// let exponent_f = num.powf(exponent as f64);\n-    ///\n-    /// // 1 * 8388608 * 2^(-22) == 2\n-    /// let abs_difference = (sign_f * mantissa_f * exponent_f - num).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    /// [floating-point]: ../reference/types.html#machine-types\n-    #[unstable(feature = \"float_extras\", reason = \"signature is undecided\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    #[allow(deprecated)]\n-    pub fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }\n-\n     /// Returns the largest integer less than or equal to a number.\n     ///\n     /// ```\n@@ -606,84 +574,6 @@ impl f64 {\n     #[inline]\n     pub fn to_radians(self) -> f64 { num::Float::to_radians(self) }\n \n-    /// Constructs a floating point number of `x*2^exp`.\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// // 3*2^2 - 12 == 0\n-    /// let abs_difference = (f64::ldexp(3.0, 2) - 12.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"float_extras\",\n-               reason = \"pending integer conventions\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    pub fn ldexp(x: f64, exp: isize) -> f64 {\n-        unsafe { cmath::ldexp(x, exp as c_int) }\n-    }\n-\n-    /// Breaks the number into a normalized fraction and a base-2 exponent,\n-    /// satisfying:\n-    ///\n-    ///  * `self = x * 2^exp`\n-    ///  * `0.5 <= abs(x) < 1.0`\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// let x = 4.0_f64;\n-    ///\n-    /// // (1/2)*2^3 -> 1 * 8/2 -> 4.0\n-    /// let f = x.frexp();\n-    /// let abs_difference_0 = (f.0 - 0.5).abs();\n-    /// let abs_difference_1 = (f.1 as f64 - 3.0).abs();\n-    ///\n-    /// assert!(abs_difference_0 < 1e-10);\n-    /// assert!(abs_difference_1 < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"float_extras\",\n-               reason = \"pending integer conventions\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    pub fn frexp(self) -> (f64, isize) {\n-        unsafe {\n-            let mut exp = 0;\n-            let x = cmath::frexp(self, &mut exp);\n-            (x, exp as isize)\n-        }\n-    }\n-\n-    /// Returns the next representable floating-point value in the direction of\n-    /// `other`.\n-    ///\n-    /// ```\n-    /// #![feature(float_extras)]\n-    ///\n-    /// let x = 1.0f64;\n-    ///\n-    /// let abs_diff = (x.next_after(2.0) - 1.0000000000000002220446049250313_f64).abs();\n-    ///\n-    /// assert!(abs_diff < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"float_extras\",\n-               reason = \"unsure about its place in the world\",\n-               issue = \"27752\")]\n-    #[rustc_deprecated(since = \"1.11.0\",\n-                       reason = \"never really came to fruition and easily \\\n-                                 implementable outside the standard library\")]\n-    #[inline]\n-    pub fn next_after(self, other: f64) -> f64 {\n-        unsafe { cmath::nextafter(self, other) }\n-    }\n-\n     /// Returns the maximum of the two numbers.\n     ///\n     /// ```\n@@ -1353,23 +1243,6 @@ mod tests {\n         assert_eq!(1e-308f64.classify(), Fp::Subnormal);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_integer_decode() {\n-        assert_eq!(3.14159265359f64.integer_decode(), (7074237752028906, -51, 1));\n-        assert_eq!((-8573.5918555f64).integer_decode(), (4713381968463931, -39, -1));\n-        assert_eq!(2f64.powf(100.0).integer_decode(), (4503599627370496, 48, 1));\n-        assert_eq!(0f64.integer_decode(), (0, -1075, 1));\n-        assert_eq!((-0f64).integer_decode(), (0, -1075, -1));\n-        assert_eq!(INFINITY.integer_decode(), (4503599627370496, 972, 1));\n-        assert_eq!(NEG_INFINITY.integer_decode(), (4503599627370496, 972, -1));\n-\n-        // Ignore the \"sign\" (quiet / signalling flag) of NAN.\n-        // It can vary between runtime operations and LLVM folding.\n-        let (nan_m, nan_e, _nan_s) = NAN.integer_decode();\n-        assert_eq!((nan_m, nan_e), (6755399441055744, 972));\n-    }\n-\n     #[test]\n     fn test_floor() {\n         assert_approx_eq!(1.0f64.floor(), 1.0f64);\n@@ -1681,58 +1554,6 @@ mod tests {\n         assert_eq!(neg_inf.to_radians(), neg_inf);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_ldexp() {\n-        let f1 = 2.0f64.powi(-123);\n-        let f2 = 2.0f64.powi(-111);\n-        let f3 = 1.75 * 2.0f64.powi(-12);\n-        assert_eq!(f64::ldexp(1f64, -123), f1);\n-        assert_eq!(f64::ldexp(1f64, -111), f2);\n-        assert_eq!(f64::ldexp(1.75f64, -12), f3);\n-\n-        assert_eq!(f64::ldexp(0f64, -123), 0f64);\n-        assert_eq!(f64::ldexp(-0f64, -123), -0f64);\n-\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n-        let nan: f64 = NAN;\n-        assert_eq!(f64::ldexp(inf, -123), inf);\n-        assert_eq!(f64::ldexp(neg_inf, -123), neg_inf);\n-        assert!(f64::ldexp(nan, -123).is_nan());\n-    }\n-\n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_frexp() {\n-        let f1 = 2.0f64.powi(-123);\n-        let f2 = 2.0f64.powi(-111);\n-        let f3 = 1.75 * 2.0f64.powi(-123);\n-        let (x1, exp1) = f1.frexp();\n-        let (x2, exp2) = f2.frexp();\n-        let (x3, exp3) = f3.frexp();\n-        assert_eq!((x1, exp1), (0.5f64, -122));\n-        assert_eq!((x2, exp2), (0.5f64, -110));\n-        assert_eq!((x3, exp3), (0.875f64, -122));\n-        assert_eq!(f64::ldexp(x1, exp1), f1);\n-        assert_eq!(f64::ldexp(x2, exp2), f2);\n-        assert_eq!(f64::ldexp(x3, exp3), f3);\n-\n-        assert_eq!(0f64.frexp(), (0f64, 0));\n-        assert_eq!((-0f64).frexp(), (-0f64, 0));\n-    }\n-\n-    #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n-    #[allow(deprecated)]\n-    fn test_frexp_nowin() {\n-        let inf: f64 = INFINITY;\n-        let neg_inf: f64 = NEG_INFINITY;\n-        let nan: f64 = NAN;\n-        assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n-        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n-        assert!(match nan.frexp() { (x, _) => x.is_nan() })\n-    }\n-\n     #[test]\n     fn test_asinh() {\n         assert_eq!(0.0f64.asinh(), 0.0f64);"}, {"sha": "70225da5f3355c2150b722b4a3bdc20f15deaa7d", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=c1aaa60d8de1c90939671f10ce7ce08400e27ad7", "patch": "@@ -262,7 +262,6 @@\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n-#![feature(float_extras)]\n #![feature(float_from_str_radix)]\n #![feature(fn_traits)]\n #![feature(fnbox)]"}, {"sha": "7a0b4c6aaca4922b62eddf73c0ab65a0096b2fca", "filename": "src/test/run-pass/union/union-transmute.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Ftest%2Frun-pass%2Funion%2Funion-transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aaa60d8de1c90939671f10ce7ce08400e27ad7/src%2Ftest%2Frun-pass%2Funion%2Funion-transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-transmute.rs?ref=c1aaa60d8de1c90939671f10ce7ce08400e27ad7", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core_float)]\n-#![feature(float_extras)]\n #![feature(untagged_unions)]\n \n extern crate core;\n-use core::num::Float;\n+use core::f32;\n \n union U {\n     a: (u8, u8),\n@@ -33,8 +31,8 @@ fn main() {\n         assert_eq!(u.a, (2, 2));\n \n         let mut w = W { a: 0b0_11111111_00000000000000000000000 };\n-        assert_eq!(w.b, f32::infinity());\n-        w.b = f32::neg_infinity();\n+        assert_eq!(w.b, f32::INFINITY);\n+        w.b = f32::NEG_INFINITY;\n         assert_eq!(w.a, 0b1_11111111_00000000000000000000000);\n     }\n }"}]}