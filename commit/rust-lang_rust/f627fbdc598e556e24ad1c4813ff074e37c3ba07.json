{"sha": "f627fbdc598e556e24ad1c4813ff074e37c3ba07", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2MjdmYmRjNTk4ZTU1NmUyNGFkMWM0ODEzZmYwNzRlMzdjM2JhMDc=", "commit": {"author": {"name": "pJunger", "email": "pJunger@users.noreply.github.com", "date": "2019-05-18T08:54:03Z"}, "committer": {"name": "pJunger", "email": "pJunger@users.noreply.github.com", "date": "2019-05-18T08:54:03Z"}, "message": "Removed symbols again.", "tree": {"sha": "6dfd12897cb8bc6bd5a8d25c4f68a65bfe4844ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dfd12897cb8bc6bd5a8d25c4f68a65bfe4844ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f627fbdc598e556e24ad1c4813ff074e37c3ba07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f627fbdc598e556e24ad1c4813ff074e37c3ba07", "html_url": "https://github.com/rust-lang/rust/commit/f627fbdc598e556e24ad1c4813ff074e37c3ba07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f627fbdc598e556e24ad1c4813ff074e37c3ba07/comments", "author": {"login": "pJunger", "id": 16426009, "node_id": "MDQ6VXNlcjE2NDI2MDA5", "avatar_url": "https://avatars.githubusercontent.com/u/16426009?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pJunger", "html_url": "https://github.com/pJunger", "followers_url": "https://api.github.com/users/pJunger/followers", "following_url": "https://api.github.com/users/pJunger/following{/other_user}", "gists_url": "https://api.github.com/users/pJunger/gists{/gist_id}", "starred_url": "https://api.github.com/users/pJunger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pJunger/subscriptions", "organizations_url": "https://api.github.com/users/pJunger/orgs", "repos_url": "https://api.github.com/users/pJunger/repos", "events_url": "https://api.github.com/users/pJunger/events{/privacy}", "received_events_url": "https://api.github.com/users/pJunger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pJunger", "id": 16426009, "node_id": "MDQ6VXNlcjE2NDI2MDA5", "avatar_url": "https://avatars.githubusercontent.com/u/16426009?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pJunger", "html_url": "https://github.com/pJunger", "followers_url": "https://api.github.com/users/pJunger/followers", "following_url": "https://api.github.com/users/pJunger/following{/other_user}", "gists_url": "https://api.github.com/users/pJunger/gists{/gist_id}", "starred_url": "https://api.github.com/users/pJunger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pJunger/subscriptions", "organizations_url": "https://api.github.com/users/pJunger/orgs", "repos_url": "https://api.github.com/users/pJunger/repos", "events_url": "https://api.github.com/users/pJunger/events{/privacy}", "received_events_url": "https://api.github.com/users/pJunger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e0f2e3f1e6b2425e515f931a88f6ead570b28d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e0f2e3f1e6b2425e515f931a88f6ead570b28d3", "html_url": "https://github.com/rust-lang/rust/commit/7e0f2e3f1e6b2425e515f931a88f6ead570b28d3"}], "stats": {"total": 65, "additions": 26, "deletions": 39}, "files": [{"sha": "3c335acb4d3a74952f97e5f46f6d54789145718f", "filename": "clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 26, "deletions": 39, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f627fbdc598e556e24ad1c4813ff074e37c3ba07/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f627fbdc598e556e24ad1c4813ff074e37c3ba07/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=f627fbdc598e556e24ad1c4813ff074e37c3ba07", "patch": "@@ -1,15 +1,13 @@\n //! lint on manually implemented checked conversions that could be transformed into `try_from`\n \n use if_chain::if_chain;\n-use lazy_static::lazy_static;\n use rustc::hir::*;\n use rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use rustc::{declare_lint_pass, declare_tool_lint};\n use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n-use syntax::symbol::Symbol;\n \n-use crate::utils::{snippet_with_applicability, span_lint_and_sugg, sym, SpanlessEq};\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg, SpanlessEq};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for explicit bounds checking when casting.\n@@ -104,7 +102,7 @@ fn double_check<'a>(cx: &LateContext<'_, '_>, left: &'a Expr, right: &'a Expr) -\n struct Conversion<'a> {\n     cvt: ConversionType,\n     expr_to_cast: &'a Expr,\n-    to_type: Option<Symbol>,\n+    to_type: Option<&'a str>,\n }\n \n /// The kind of conversion that is checked\n@@ -140,7 +138,7 @@ impl<'a> Conversion<'a> {\n     }\n \n     /// Try to construct a new conversion if the conversion type is valid\n-    fn try_new(expr_to_cast: &'a Expr, from_type: Symbol, to_type: Symbol) -> Option<Conversion<'a>> {\n+    fn try_new(expr_to_cast: &'a Expr, from_type: &str, to_type: &'a str) -> Option<Conversion<'a>> {\n         ConversionType::try_new(from_type, to_type).map(|cvt| Conversion {\n             cvt,\n             expr_to_cast,\n@@ -160,7 +158,7 @@ impl<'a> Conversion<'a> {\n \n impl ConversionType {\n     /// Creates a conversion type if the type is allowed & conversion is valid\n-    fn try_new(from: Symbol, to: Symbol) -> Option<Self> {\n+    fn try_new(from: &str, to: &str) -> Option<Self> {\n         if UINTS.contains(&from) {\n             Some(ConversionType::FromUnsigned)\n         } else if SINTS.contains(&from) {\n@@ -182,7 +180,7 @@ fn check_upper_bound(expr: &Expr) -> Option<Conversion<'_>> {\n     if_chain! {\n          if let ExprKind::Binary(ref op, ref left, ref right) = &expr.node;\n          if let Some((candidate, check)) = normalize_le_ge(op, left, right);\n-         if let Some((from, to)) = get_types_from_cast(check, *sym::max_value, &*INTS);\n+         if let Some((from, to)) = get_types_from_cast(check, MAX_VALUE, INTS);\n \n          then {\n              Conversion::try_new(candidate, from, to)\n@@ -222,17 +220,17 @@ fn check_lower_bound_zero<'a>(candidate: &'a Expr, check: &'a Expr) -> Option<Co\n \n /// Check for `expr >= (to_type::min_value() as from_type)`\n fn check_lower_bound_min<'a>(candidate: &'a Expr, check: &'a Expr) -> Option<Conversion<'a>> {\n-    if let Some((from, to)) = get_types_from_cast(check, *sym::min_value, &*SINTS) {\n+    if let Some((from, to)) = get_types_from_cast(check, MIN_VALUE, SINTS) {\n         Conversion::try_new(candidate, from, to)\n     } else {\n         None\n     }\n }\n \n /// Tries to extract the from- and to-type from a cast expression\n-fn get_types_from_cast(expr: &Expr, func: Symbol, types: &[Symbol]) -> Option<(Symbol, Symbol)> {\n+fn get_types_from_cast<'a>(expr: &'a Expr, func: &'a str, types: &'a [&str]) -> Option<(&'a str, &'a str)> {\n     // `to_type::maxmin_value() as from_type`\n-    let call_from_cast: Option<(&Expr, Symbol)> = if_chain! {\n+    let call_from_cast: Option<(&Expr, &str)> = if_chain! {\n         // to_type::maxmin_value(), from_type\n         if let ExprKind::Cast(ref limit, ref from_type) = &expr.node;\n         if let TyKind::Path(ref from_type_path) = &from_type.node;\n@@ -246,7 +244,7 @@ fn get_types_from_cast(expr: &Expr, func: Symbol, types: &[Symbol]) -> Option<(S\n     };\n \n     // `from_type::from(to_type::maxmin_value())`\n-    let limit_from: Option<(&Expr, Symbol)> = call_from_cast.or_else(|| {\n+    let limit_from: Option<(&Expr, &str)> = call_from_cast.or_else(|| {\n         if_chain! {\n             // `from_type::from, to_type::maxmin_value()`\n             if let ExprKind::Call(ref from_func, ref args) = &expr.node;\n@@ -255,7 +253,7 @@ fn get_types_from_cast(expr: &Expr, func: Symbol, types: &[Symbol]) -> Option<(S\n             if let limit = &args[0];\n             // `from_type::from`\n             if let ExprKind::Path(ref path) = &from_func.node;\n-            if let Some(from_sym) = get_implementing_type(path, &*INTS, *sym::from);\n+            if let Some(from_sym) = get_implementing_type(path, INTS, FROM);\n \n             then {\n                 Some((limit, from_sym))\n@@ -285,34 +283,31 @@ fn get_types_from_cast(expr: &Expr, func: Symbol, types: &[Symbol]) -> Option<(S\n }\n \n /// Gets the type which implements the called function\n-fn get_implementing_type(path: &QPath, candidates: &[Symbol], function: Symbol) -> Option<Symbol> {\n+fn get_implementing_type<'a>(path: &QPath, candidates: &'a [&str], function: &str) -> Option<&'a str> {\n     if_chain! {\n         if let QPath::TypeRelative(ref ty, ref path) = &path;\n-        if path.ident.name == function;\n+        if path.ident.name.as_str() == function;\n         if let TyKind::Path(QPath::Resolved(None, ref tp)) = &ty.node;\n         if let [int] = &*tp.segments;\n-        let name = int.ident.name;\n-        if candidates.contains(&name);\n+        let name = &int.ident.name.as_str();\n \n         then {\n-            Some(name)\n+            candidates.iter().find(|c| name == *c).cloned()\n         } else {\n             None\n         }\n     }\n }\n \n /// Gets the type as a string, if it is a supported integer\n-fn int_ty_to_sym(path: &QPath) -> Option<Symbol> {\n+fn int_ty_to_sym(path: &QPath) -> Option<&str> {\n     if_chain! {\n         if let QPath::Resolved(_, ref path) = *path;\n         if let [ty] = &*path.segments;\n+        let name = &ty.ident.name.as_str();\n \n         then {\n-            INTS\n-                .iter()\n-                .find(|c| ty.ident.name == **c)\n-                .cloned()\n+            INTS.iter().find(|c| name == *c).cloned()\n         } else {\n             None\n         }\n@@ -328,27 +323,19 @@ fn transpose<T, U>(lhs: Option<T>, rhs: Option<U>) -> Option<(T, U)> {\n }\n \n /// Will return the expressions as if they were expr1 <= expr2\n-fn normalize_le_ge<'a>(op: &'a BinOp, left: &'a Expr, right: &'a Expr) -> Option<(&'a Expr, &'a Expr)> {\n+fn normalize_le_ge<'a>(op: &BinOp, left: &'a Expr, right: &'a Expr) -> Option<(&'a Expr, &'a Expr)> {\n     match op.node {\n         BinOpKind::Le => Some((left, right)),\n         BinOpKind::Ge => Some((right, left)),\n         _ => None,\n     }\n }\n \n-lazy_static! {\n-    static ref UINTS: [Symbol; 5] = [*sym::u8, *sym::u16, *sym::u32, *sym::u64, *sym::usize];\n-    static ref SINTS: [Symbol; 5] = [*sym::i8, *sym::i16, *sym::i32, *sym::i64, *sym::isize];\n-    static ref INTS: [Symbol; 10] = [\n-        *sym::u8,\n-        *sym::u16,\n-        *sym::u32,\n-        *sym::u64,\n-        *sym::usize,\n-        *sym::i8,\n-        *sym::i16,\n-        *sym::i32,\n-        *sym::i64,\n-        *sym::isize\n-    ];\n-}\n+// Constants\n+const FROM: &str = \"from\";\n+const MAX_VALUE: &str = \"max_value\";\n+const MIN_VALUE: &str = \"min_value\";\n+\n+const UINTS: &[&str] = &[\"u8\", \"u16\", \"u32\", \"u64\", \"usize\"];\n+const SINTS: &[&str] = &[\"i8\", \"i16\", \"i32\", \"i64\", \"isize\"];\n+const INTS: &[&str] = &[\"u8\", \"u16\", \"u32\", \"u64\", \"usize\", \"i8\", \"i16\", \"i32\", \"i64\", \"isize\"];"}]}