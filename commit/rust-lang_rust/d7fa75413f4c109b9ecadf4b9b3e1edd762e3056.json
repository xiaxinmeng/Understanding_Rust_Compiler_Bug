{"sha": "d7fa75413f4c109b9ecadf4b9b3e1edd762e3056", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZmE3NTQxM2Y0YzEwOWI5ZWNhZGY0YjliM2UxZWRkNzYyZTMwNTY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-26T22:36:18Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T22:54:44Z"}, "message": "Convert rustc::lib::llvm to istr::sbufs. Issue #855", "tree": {"sha": "3ef1954d35a2958550a637d986cab49e7e332fd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ef1954d35a2958550a637d986cab49e7e332fd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056", "html_url": "https://github.com/rust-lang/rust/commit/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "138973335aba835a451ce7c9914c7ca020bcc753", "url": "https://api.github.com/repos/rust-lang/rust/commits/138973335aba835a451ce7c9914c7ca020bcc753", "html_url": "https://github.com/rust-lang/rust/commit/138973335aba835a451ce7c9914c7ca020bcc753"}], "stats": {"total": 683, "additions": 447, "deletions": 236}, "files": [{"sha": "6007bd9eea13fd9dca8f437b40eaa3966a1b14d1", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 48, "deletions": 36, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=d7fa75413f4c109b9ecadf4b9b3e1edd762e3056", "patch": "@@ -34,23 +34,23 @@ tag output_type {\n \n fn llvm_err(sess: session::session, msg: &istr) {\n     let buf = llvm::LLVMRustGetLastError();\n-    if buf as uint == 0u {\n+    if buf == std::ptr::null() {\n         sess.fatal(istr::to_estr(msg));\n     } else {\n         sess.fatal(\n-            istr::to_estr(msg) + \": \" + str::str_from_cstr(buf));\n+            istr::to_estr(msg + ~\": \" + istr::str_from_cstr(buf)));\n     }\n }\n \n fn link_intrinsics(sess: session::session, llmod: ModuleRef) {\n-    let path = istr::to_estr(\n+    let path =\n         fs::connect(istr::from_estr(sess.get_opts().sysroot),\n-                    ~\"lib/intrinsics.bc\"));\n-    let membuf =\n-        llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(str::buf(path));\n+                    ~\"lib/intrinsics.bc\");\n+    let membuf = istr::as_buf(path, { |buf|\n+        llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n+    });\n     if membuf as uint == 0u {\n-        llvm_err(sess, ~\"installation problem: couldn't open \"\n-                 + istr::from_estr(path));\n+        llvm_err(sess, ~\"installation problem: couldn't open \" + path);\n         fail;\n     }\n     let llintrinsicsmod = llvm::LLVMRustParseBitcode(membuf);\n@@ -104,14 +104,16 @@ mod write {\n               output_type_bitcode. {\n                 if opts.optimize != 0u {\n                     let filename = mk_intermediate_name(output, ~\"no-opt.bc\");\n-                    let filename = istr::to_estr(filename);\n-                    llvm::LLVMWriteBitcodeToFile(llmod, str::buf(filename));\n+                    istr::as_buf(filename, { |buf|\n+                        llvm::LLVMWriteBitcodeToFile(llmod, buf)\n+                    });\n                 }\n               }\n               _ {\n                 let filename = mk_intermediate_name(output, ~\"bc\");\n-                let filename = istr::to_estr(filename);\n-                llvm::LLVMWriteBitcodeToFile(llmod, str::buf(filename));\n+                istr::as_buf(filename, { |buf|\n+                    llvm::LLVMWriteBitcodeToFile(llmod, buf)\n+                });\n               }\n             }\n         }\n@@ -183,45 +185,54 @@ mod write {\n                 // Always output the bitcode file with --save-temps\n \n                 let filename = mk_intermediate_name(output, ~\"opt.bc\");\n-                let filename = istr::to_estr(filename);\n                 llvm::LLVMRunPassManager(pm.llpm, llmod);\n-                llvm::LLVMWriteBitcodeToFile(llmod, str::buf(filename));\n+                istr::as_buf(filename, { |buf|\n+                    llvm::LLVMWriteBitcodeToFile(llmod, buf)\n+                });\n                 pm = mk_pass_manager();\n                 // Save the assembly file if -S is used\n \n                 if opts.output_type == output_type_assembly {\n-                    let triple = istr::to_estr(x86::get_target_triple());\n-                    let output = istr::to_estr(output);\n-                    llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n-                                                  str::buf(triple),\n-                                                  str::buf(output),\n-                                                  LLVMAssemblyFile,\n-                                                  CodeGenOptLevel);\n+                    let _: () =\n+                        istr::as_buf(x86::get_target_triple(), { |buf_t|\n+                            istr::as_buf(output, { |buf_o|\n+                                llvm::LLVMRustWriteOutputFile(\n+                                    pm.llpm, llmod,\n+                                    buf_t,\n+                                    buf_o,\n+                                    LLVMAssemblyFile,\n+                                    CodeGenOptLevel)\n+                                                 })});\n                 }\n \n \n                 // Save the object file for -c or --save-temps alone\n                 // This .o is needed when an exe is built\n                 if opts.output_type == output_type_object ||\n                        opts.output_type == output_type_exe {\n-                    let triple = istr::to_estr(x86::get_target_triple());\n-                    let output = istr::to_estr(output);\n-                    llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n-                                                  str::buf(triple),\n-                                                  str::buf(output),\n-                                                  LLVMObjectFile,\n-                                                  CodeGenOptLevel);\n+                    let _: () =\n+                        istr::as_buf(x86::get_target_triple(), { |buf_t|\n+                            istr::as_buf(output, { |buf_o|\n+                                llvm::LLVMRustWriteOutputFile(\n+                                    pm.llpm, llmod,\n+                                    buf_t,\n+                                    buf_o,\n+                                    LLVMObjectFile,\n+                                    CodeGenOptLevel)\n+                                                 })});\n                 }\n             } else {\n                 // If we aren't saving temps then just output the file\n                 // type corresponding to the '-c' or '-S' flag used\n \n-                let triple = istr::to_estr(x86::get_target_triple());\n-                let output = istr::to_estr(output);\n-                llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n-                                              str::buf(triple),\n-                                              str::buf(output), FileType,\n-                                              CodeGenOptLevel);\n+                let _: () = istr::as_buf(x86::get_target_triple(), { |buf_t|\n+                    istr::as_buf(output, { |buf_o|\n+                        llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n+                                                      buf_t,\n+                                                      buf_o,\n+                                                      FileType,\n+                                                      CodeGenOptLevel)\n+                                         })});\n             }\n             // Clean up and return\n \n@@ -233,8 +244,9 @@ mod write {\n         // flag, then output it here\n \n         llvm::LLVMRunPassManager(pm.llpm, llmod);\n-        let output = istr::to_estr(output);\n-        llvm::LLVMWriteBitcodeToFile(llmod, str::buf(output));\n+        istr::as_buf(output, { |buf|\n+            llvm::LLVMWriteBitcodeToFile(llmod, buf)\n+        });\n         llvm::LLVMDisposeModule(llmod);\n         if opts.time_llvm_passes { llvm::LLVMRustPrintPassTimings(); }\n     }"}, {"sha": "748576482f44e20573039197ef5c0bf931e2d1bc", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=d7fa75413f4c109b9ecadf4b9b3e1edd762e3056", "patch": "@@ -325,8 +325,8 @@ fn get_default_sysroot(binary: str) -> str {\n }\n \n fn build_target_config() -> @session::config {\n-    let triple: str =\n-        std::str::rustrt::str_from_cstr(llvm::llvm::LLVMRustGetHostTriple());\n+    let triple: str = istr::to_estr(\n+        istr::str_from_cstr(llvm::llvm::LLVMRustGetHostTriple()));\n     let target_cfg: @session::config =\n         @{os: get_os(triple),\n           arch: get_arch(triple),"}, {"sha": "a090f7cc66752276dc897ddb7b627008234f9385", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=d7fa75413f4c109b9ecadf4b9b3e1edd762e3056", "patch": "@@ -1,7 +1,6 @@\n import std::vec;\n-import std::str;\n import std::istr;\n-import std::str::rustrt::sbuf;\n+import std::istr::sbuf;\n \n import llvm::ModuleRef;\n import llvm::ContextRef;\n@@ -1070,7 +1069,9 @@ resource target_data_res(TD: TargetDataRef) {\n type target_data = {lltd: TargetDataRef, dtor: @target_data_res};\n \n fn mk_target_data(string_rep: str) -> target_data {\n-    let lltd = llvm::LLVMCreateTargetData(str::buf(string_rep));\n+    let lltd = istr::as_buf(istr::from_estr(string_rep), { |buf|\n+        llvm::LLVMCreateTargetData(buf)\n+    });\n     ret {lltd: lltd, dtor: @target_data_res(lltd)};\n }\n "}, {"sha": "00cdd808179ef07f2cff33a4b4ae19ed49e6f800", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=d7fa75413f4c109b9ecadf4b9b3e1edd762e3056", "patch": "@@ -192,15 +192,16 @@ fn find_library_crate_aux(nn: &{prefix: str, suffix: str}, crate_name: str,\n }\n \n fn get_metadata_section(filename: str) -> option::t<@[u8]> {\n-    let b = str::buf(filename);\n-    let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(b);\n+    let mb = istr::as_buf(istr::from_estr(filename), { |buf|\n+        llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n+    });\n     if mb as int == 0 { ret option::none::<@[u8]>; }\n     let of = mk_object_file(mb);\n     let si = mk_section_iter(of.llof);\n     while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n         let name_buf = llvm::LLVMGetSectionName(si.llsi);\n-        let name = str::str_from_cstr(name_buf);\n-        if str::eq(name, istr::to_estr(x86::get_meta_sect_name())) {\n+        let name = istr::str_from_cstr(name_buf);\n+        if istr::eq(name, x86::get_meta_sect_name()) {\n             let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n             let csz = llvm::LLVMGetSectionSize(si.llsi);\n             let cvbuf: *u8 = std::unsafe::reinterpret_cast(cbuf);"}, {"sha": "fec0d434ab982a1abe22a3460546bf58eb0bbd99", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=d7fa75413f4c109b9ecadf4b9b3e1edd762e3056", "patch": "@@ -11,6 +11,7 @@ import std::option::none;\n import std::option::some;\n import std::ptr;\n import std::str;\n+import std::istr;\n import std::unsafe;\n import std::vec;\n \n@@ -22,8 +23,9 @@ type ctxt = @{mutable next_tydesc_num: uint};\n fn mk_ctxt() -> ctxt { ret @{mutable next_tydesc_num: 0u}; }\n \n fn add_global(ccx: &@crate_ctxt, llval: ValueRef, name: str) -> ValueRef {\n-    let llglobal =\n-        lll::LLVMAddGlobal(ccx.llmod, val_ty(llval), str::buf(name));\n+    let llglobal = istr::as_buf(istr::from_estr(name), { |buf|\n+        lll::LLVMAddGlobal(ccx.llmod, val_ty(llval), buf)\n+    });\n     lll::LLVMSetInitializer(llglobal, llval);\n     lll::LLVMSetGlobalConstant(llglobal, True);\n     ret llglobal;"}, {"sha": "8a1201b4d830ec4072e41bc0a29dec42e36b4bef", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=d7fa75413f4c109b9ecadf4b9b3e1edd762e3056", "patch": "@@ -31,6 +31,7 @@ import std::map::hashmap;\n import std::option::none;\n import std::option::some;\n import std::str;\n+import std::istr;\n \n import ty_ctxt = middle::ty::ctxt;\n \n@@ -86,9 +87,9 @@ fn eq_res_info(a: &res_info, b: &res_info) -> bool {\n \n fn mk_global(ccx: &@crate_ctxt, name: &str, llval: ValueRef,\n              internal: bool) -> ValueRef {\n-    let llglobal =\n-        lib::llvm::llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval),\n-                                       str::buf(name));\n+    let llglobal = istr::as_buf(istr::from_estr(name), { |buf|\n+        lib::llvm::llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval), buf)\n+    });\n     lib::llvm::llvm::LLVMSetInitializer(llglobal, llval);\n     lib::llvm::llvm::LLVMSetGlobalConstant(llglobal, True);\n \n@@ -248,9 +249,9 @@ fn s_float(_tcx: &ty_ctxt) -> u8 {\n \n fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n     let llshapetablesty = trans_common::T_named_struct(\"shapes\");\n-    let llshapetables =\n-        lib::llvm::llvm::LLVMAddGlobal(llmod, llshapetablesty,\n-                                       str::buf(\"shapes\"));\n+    let llshapetables = istr::as_buf(~\"shapes\", { |buf|\n+        lib::llvm::llvm::LLVMAddGlobal(llmod, llshapetablesty, buf)\n+    });\n \n     ret {mutable next_tag_id: 0u16,\n          pad: 0u16,"}, {"sha": "351cbdc1817dc573af34e259d53477a4ba50c672", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 101, "deletions": 70, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=d7fa75413f4c109b9ecadf4b9b3e1edd762e3056", "patch": "@@ -324,7 +324,9 @@ fn log_fn_time(ccx: &@crate_ctxt, name: str, start: &time::timeval,\n \n fn decl_fn(llmod: ModuleRef, name: &str, cc: uint, llty: TypeRef) ->\n    ValueRef {\n-    let llfn: ValueRef = llvm::LLVMAddFunction(llmod, str::buf(name), llty);\n+    let llfn: ValueRef = istr::as_buf(istr::from_estr(name), { |buf|\n+        llvm::LLVMAddFunction(llmod, buf, llty)\n+    });\n     llvm::LLVMSetFunctionCallConv(llfn, cc);\n     ret llfn;\n }\n@@ -335,7 +337,9 @@ fn decl_cdecl_fn(llmod: ModuleRef, name: &str, llty: TypeRef) -> ValueRef {\n \n fn decl_fastcall_fn(llmod: ModuleRef, name: &str, llty: TypeRef) -> ValueRef {\n     let llfn = decl_fn(llmod, name, lib::llvm::LLVMFastCallConv, llty);\n-    llvm::LLVMSetGC(llfn, str::buf(\"rust\"));\n+    let _: () = istr::as_buf(~\"rust\", { |buf|\n+        llvm::LLVMSetGC(llfn, buf)\n+    });\n     ret llfn;\n }\n \n@@ -347,7 +351,9 @@ fn decl_internal_fastcall_fn(llmod: ModuleRef, name: &str, llty: TypeRef) ->\n     let llfn = decl_fn(llmod, name, lib::llvm::LLVMFastCallConv, llty);\n     llvm::LLVMSetLinkage(llfn,\n                          lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n-    llvm::LLVMSetGC(llfn, str::buf(\"rust\"));\n+    let _: () = istr::as_buf(~\"rust\", { |buf|\n+        llvm::LLVMSetGC(llfn, buf)\n+    });\n     ret llfn;\n }\n \n@@ -370,7 +376,9 @@ fn get_extern_const(externs: &hashmap<istr, ValueRef>, llmod: ModuleRef,\n     if externs.contains_key(istr::from_estr(name)) {\n         ret externs.get(istr::from_estr(name));\n     }\n-    let c = llvm::LLVMAddGlobal(llmod, ty, str::buf(name));\n+    let c = istr::as_buf(istr::from_estr(name), { |buf|\n+        llvm::LLVMAddGlobal(llmod, ty, buf)\n+    });\n     externs.insert(istr::from_estr(name), c);\n     ret c;\n }\n@@ -1140,9 +1148,9 @@ fn declare_tydesc(cx: &@local_ctxt, sp: &span, t: ty::t, ty_params: &[uint])\n         name = mangle_internal_name_by_type_only(cx.ccx, t, ~\"tydesc\");\n         name = sanitize(name);\n     } else { name = mangle_internal_name_by_seq(cx.ccx, ~\"tydesc\"); }\n-    let name = istr::to_estr(name);\n-    let gvar =\n-        llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, str::buf(name));\n+    let gvar = istr::as_buf(name, { |buf|\n+        llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, buf)\n+    });\n     let info =\n         @{ty: t,\n           tydesc: gvar,\n@@ -1575,7 +1583,9 @@ fn decr_refcnt_maybe_free(cx: &@block_ctxt, box_ptr_alias: ValueRef,\n // Structural comparison: a rather involved form of glue.\n fn maybe_name_value(cx: &@crate_ctxt, v: ValueRef, s: &str) {\n     if cx.sess.get_opts().save_temps {\n-        llvm::LLVMSetValueName(v, str::buf(s));\n+        let _: () = istr::as_buf(istr::from_estr(s), { |buf|\n+            llvm::LLVMSetValueName(v, buf)\n+        });\n     }\n }\n \n@@ -3316,7 +3326,9 @@ fn lookup_discriminant(lcx: &@local_ctxt, vid: &ast::def_id) -> ValueRef {\n         // It's an external discriminant that we haven't seen yet.\n         assert (vid.crate != ast::local_crate);\n         let sym = csearch::get_symbol(lcx.ccx.sess.get_cstore(), vid);\n-        let gvar = llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(), str::buf(sym));\n+        let gvar = istr::as_buf(istr::from_estr(sym), { |buf|\n+            llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(), buf)\n+        });\n         llvm::LLVMSetLinkage(gvar,\n                              lib::llvm::LLVMExternalLinkage as llvm::Linkage);\n         llvm::LLVMSetGlobalConstant(gvar, True);\n@@ -4547,8 +4559,9 @@ fn trans_log(lvl: int, cx: &@block_ctxt, e: &@ast::expr) -> result {\n                 lcx.ccx,\n                 istr::from_estrs(lcx.module_path),\n                 ~\"loglevel\");\n-        let s = istr::to_estr(s);\n-        global = llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(), str::buf(s));\n+        global = istr::as_buf(s, { |buf|\n+            llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(), buf)\n+        });\n         llvm::LLVMSetGlobalConstant(global, False);\n         llvm::LLVMSetInitializer(global, C_null(T_int()));\n         llvm::LLVMSetLinkage(global,\n@@ -4911,14 +4924,14 @@ fn trans_stmt(cx: &@block_ctxt, s: &ast::stmt) -> result {\n // next three functions instead.\n fn new_block_ctxt(cx: &@fn_ctxt, parent: &block_parent, kind: block_kind,\n                   name: &str) -> @block_ctxt {\n-    let s = str::buf(\"\");\n-    let held_name; //HACK for str::buf, which doesn't keep its value alive\n+    let s = \"\";\n     if cx.lcx.ccx.sess.get_opts().save_temps ||\n            cx.lcx.ccx.sess.get_opts().debuginfo {\n-        held_name = cx.lcx.ccx.names.next(name);\n-        s = str::buf(held_name);\n+        s = cx.lcx.ccx.names.next(name);\n     }\n-    let llbb: BasicBlockRef = llvm::LLVMAppendBasicBlock(cx.llfn, s);\n+    let llbb: BasicBlockRef = istr::as_buf(istr::from_estr(s), { |buf|\n+        llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n+    });\n     ret @{llbb: llbb,\n           mutable terminated: false,\n           parent: parent,\n@@ -5073,8 +5086,9 @@ fn alloc_local(cx: &@block_ctxt, local: &@ast::local) -> result {\n     alt local.node.pat.node {\n       ast::pat_bind(ident) {\n         if bcx_ccx(cx).sess.get_opts().debuginfo {\n-            let ident = istr::to_estr(ident);\n-            llvm::LLVMSetValueName(r.val, str::buf(ident));\n+            let _: () = istr::as_buf(ident, { |buf|\n+                llvm::LLVMSetValueName(r.val, buf)\n+            });\n         }\n       }\n       _ { }\n@@ -5158,11 +5172,21 @@ fn mk_standard_basic_blocks(llfn: ValueRef) ->\n     dt: BasicBlockRef,\n     da: BasicBlockRef,\n     rt: BasicBlockRef} {\n-    ret {sa: llvm::LLVMAppendBasicBlock(llfn, str::buf(\"static_allocas\")),\n-         ca: llvm::LLVMAppendBasicBlock(llfn, str::buf(\"copy_args\")),\n-         dt: llvm::LLVMAppendBasicBlock(llfn, str::buf(\"derived_tydescs\")),\n-         da: llvm::LLVMAppendBasicBlock(llfn, str::buf(\"dynamic_allocas\")),\n-         rt: llvm::LLVMAppendBasicBlock(llfn, str::buf(\"return\"))};\n+    ret {sa: istr::as_buf(~\"statuc_allocas\", { |buf|\n+             llvm::LLVMAppendBasicBlock(llfn, buf)\n+                                             }),\n+         ca: istr::as_buf(~\"copy_args\", { |buf|\n+             llvm::LLVMAppendBasicBlock(llfn, buf)\n+                                        }),\n+         dt: istr::as_buf(~\"derived_tydescs\", { |buf|\n+             llvm::LLVMAppendBasicBlock(llfn, buf)\n+                                              }),\n+         da: istr::as_buf(~\"dynamic_allocas\", { |buf|\n+             llvm::LLVMAppendBasicBlock(llfn, buf)\n+                                              }),\n+         rt: istr::as_buf(~\"return\", { |buf|\n+             llvm::LLVMAppendBasicBlock(llfn, buf)\n+                                     })};\n }\n \n \n@@ -5796,8 +5820,9 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span, main_llfn: ValueRef,\n // space for the function's environment.\n fn create_fn_pair(cx: &@crate_ctxt, ps: str, llfnty: TypeRef, llfn: ValueRef,\n                   external: bool) -> ValueRef {\n-    let gvar =\n-        llvm::LLVMAddGlobal(cx.llmod, T_fn_pair(*cx, llfnty), str::buf(ps));\n+    let gvar = istr::as_buf(istr::from_estr(ps), { |buf|\n+        llvm::LLVMAddGlobal(cx.llmod, T_fn_pair(*cx, llfnty), buf)\n+    });\n     let pair = C_struct([llfn, C_null(T_opaque_closure_ptr(*cx))]);\n     llvm::LLVMSetInitializer(gvar, pair);\n     llvm::LLVMSetGlobalConstant(gvar, True);\n@@ -6072,11 +6097,10 @@ fn collect_item_1(ccx: @crate_ctxt, i: &@ast::item, pt: &[str],\n         let s =\n             mangle_exported_name(ccx, istr::from_estrs(pt) + [i.ident],\n                                  node_id_type(ccx, i.id));\n-        let s = istr::to_estr(s);\n-        let g =\n-            llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, i.span, typ),\n-                                str::buf(s));\n-        ccx.item_symbols.insert(i.id, s);\n+        let g = istr::as_buf(s, { |buf|\n+            llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, i.span, typ), buf)\n+        });\n+        ccx.item_symbols.insert(i.id, istr::to_estr(s));\n         ccx.consts.insert(i.id, g);\n       }\n       _ { }\n@@ -6165,15 +6189,15 @@ fn trans_constant(ccx: @crate_ctxt, it: &@ast::item, pt: &[str],\n                                                 ~\"discrim\"];\n             let s = mangle_exported_name(ccx, p,\n                                          ty::mk_int(ccx.tcx));\n-            let s = istr::to_estr(s);\n-            let discrim_gvar =\n-                llvm::LLVMAddGlobal(ccx.llmod, T_int(), str::buf(s));\n+            let discrim_gvar = istr::as_buf(s, { |buf|\n+                llvm::LLVMAddGlobal(ccx.llmod, T_int(), buf)\n+            });\n             if n_variants != 1u {\n                 llvm::LLVMSetInitializer(discrim_gvar, C_int(i as int));\n                 llvm::LLVMSetGlobalConstant(discrim_gvar, True);\n             }\n             ccx.discrims.insert(variant.node.id, discrim_gvar);\n-            ccx.discrim_symbols.insert(variant.node.id, s);\n+            ccx.discrim_symbols.insert(variant.node.id, istr::to_estr(s));\n             i += 1u;\n         }\n       }\n@@ -6272,29 +6296,31 @@ fn make_common_glue(sess: &session::session, output: &str) {\n     let task_type = T_task();\n     let taskptr_type = T_ptr(task_type);\n \n-    let llmod =\n-        llvm::LLVMModuleCreateWithNameInContext(str::buf(\"rust_out\"),\n-                                                llvm::LLVMGetGlobalContext());\n-    let dat_layt = istr::to_estr(\n-        x86::get_data_layout()); //HACK (buf lifetime issue)\n-    llvm::LLVMSetDataLayout(llmod, str::buf(dat_layt));\n-    let targ_trip = istr::to_estr(\n-        x86::get_target_triple()); //HACK (buf lifetime issue)\n-    llvm::LLVMSetTarget(llmod, str::buf(targ_trip));\n+    let llmod = istr::as_buf(~\"rust_out\", { |buf|\n+        llvm::LLVMModuleCreateWithNameInContext(buf,\n+                                                llvm::LLVMGetGlobalContext())\n+    });\n+    let _: () = istr::as_buf(x86::get_data_layout(), { |buf|\n+        llvm::LLVMSetDataLayout(llmod, buf)\n+    });\n+    let _: () = istr::as_buf(x86::get_target_triple(), { |buf|\n+        llvm::LLVMSetTarget(llmod, buf)\n+    });\n     mk_target_data(istr::to_estr(x86::get_data_layout()));\n     declare_intrinsics(llmod);\n-    let modl_asm = istr::to_estr(\n-        x86::get_module_asm()); //HACK (buf lifetime issue)\n-    llvm::LLVMSetModuleInlineAsm(llmod, str::buf(modl_asm));\n+    let _: () = istr::as_buf(x86::get_module_asm(), { |buf|\n+        llvm::LLVMSetModuleInlineAsm(llmod, buf)\n+    });\n     make_glues(llmod, taskptr_type);\n     link::write::run_passes(sess, llmod, istr::from_estr(output));\n }\n \n fn create_module_map(ccx: &@crate_ctxt) -> ValueRef {\n     let elttype = T_struct([T_int(), T_int()]);\n     let maptype = T_array(elttype, ccx.module_data.size() + 1u);\n-    let map =\n-        llvm::LLVMAddGlobal(ccx.llmod, maptype, str::buf(\"_rust_mod_map\"));\n+    let map = istr::as_buf(~\"_rust_mod_map\", { |buf|\n+        llvm::LLVMAddGlobal(ccx.llmod, maptype, buf)\n+    });\n     llvm::LLVMSetLinkage(map,\n                          lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n     let elts: [ValueRef] = [];\n@@ -6317,7 +6343,9 @@ fn create_crate_map(ccx: &@crate_ctxt) -> ValueRef {\n     let cstore = ccx.sess.get_cstore();\n     while cstore::have_crate_data(cstore, i) {\n         let nm = \"_rust_crate_map_\" + cstore::get_crate_data(cstore, i).name;\n-        let cr = llvm::LLVMAddGlobal(ccx.llmod, T_int(), str::buf(nm));\n+        let cr = istr::as_buf(istr::from_estr(nm), { |buf|\n+            llvm::LLVMAddGlobal(ccx.llmod, T_int(), buf)\n+        });\n         subcrates += [p2i(cr)];\n         i += 1;\n     }\n@@ -6326,10 +6354,12 @@ fn create_crate_map(ccx: &@crate_ctxt) -> ValueRef {\n     if ccx.sess.get_opts().library {\n         mapname = ccx.link_meta.name;\n     } else { mapname = ~\"toplevel\"; }\n-    let sym_name = istr::to_estr(~\"_rust_crate_map_\" + mapname);\n+    let sym_name = ~\"_rust_crate_map_\" + mapname;\n     let arrtype = T_array(T_int(), std::vec::len::<ValueRef>(subcrates));\n     let maptype = T_struct([T_int(), arrtype]);\n-    let map = llvm::LLVMAddGlobal(ccx.llmod, maptype, str::buf(sym_name));\n+    let map = istr::as_buf(sym_name, { |buf|\n+        llvm::LLVMAddGlobal(ccx.llmod, maptype, buf)\n+    });\n     llvm::LLVMSetLinkage(map,\n                          lib::llvm::LLVMExternalLinkage as llvm::Linkage);\n     llvm::LLVMSetInitializer(map,\n@@ -6342,21 +6372,21 @@ fn write_metadata(cx: &@crate_ctxt, crate: &@ast::crate) {\n     if !cx.sess.get_opts().library { ret; }\n     let llmeta = C_postr(metadata::encoder::encode_metadata(cx, crate));\n     let llconst = trans_common::C_struct([llmeta]);\n-    let llglobal =\n-        llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst),\n-                            str::buf(\"rust_metadata\"));\n+    let llglobal = istr::as_buf(~\"rust_metadata\", { |buf|\n+        llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst), buf)\n+    });\n     llvm::LLVMSetInitializer(llglobal, llconst);\n-    let met_sct_nm = istr::to_estr(\n-        x86::get_meta_sect_name()); //HACK (buf lifetime issue)\n-    llvm::LLVMSetSection(llglobal, str::buf(met_sct_nm));\n+    let _: () = istr::as_buf(x86::get_meta_sect_name(), { |buf|\n+        llvm::LLVMSetSection(llglobal, buf)\n+    });\n     llvm::LLVMSetLinkage(llglobal,\n                          lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n \n     let t_ptr_i8 = T_ptr(T_i8());\n     llglobal = llvm::LLVMConstBitCast(llglobal, t_ptr_i8);\n-    let llvm_used =\n-        llvm::LLVMAddGlobal(cx.llmod, T_array(t_ptr_i8, 1u),\n-                            str::buf(\"llvm.used\"));\n+    let llvm_used = istr::as_buf(~\"llvm.used\", { |buf|\n+        llvm::LLVMAddGlobal(cx.llmod, T_array(t_ptr_i8, 1u), buf)\n+    });\n     llvm::LLVMSetLinkage(llvm_used,\n                          lib::llvm::LLVMAppendingLinkage as llvm::Linkage);\n     llvm::LLVMSetInitializer(llvm_used, C_array(t_ptr_i8, [llglobal]));\n@@ -6371,16 +6401,17 @@ fn write_abi_version(ccx: &@crate_ctxt) {\n fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n                output: &str, amap: &ast_map::map, mut_map: alias::mut_map)\n     -> ModuleRef {\n-    let llmod =\n-        llvm::LLVMModuleCreateWithNameInContext(str::buf(\"rust_out\"),\n-                                                llvm::LLVMGetGlobalContext());\n-    let dat_layt = istr::to_estr(\n-        x86::get_data_layout()); //HACK (buf lifetime issue)\n-    llvm::LLVMSetDataLayout(llmod, str::buf(dat_layt));\n-    let targ_trip = istr::to_estr(\n-        x86::get_target_triple()); //HACK (buf lifetime issue)\n-    llvm::LLVMSetTarget(llmod, str::buf(targ_trip));\n-    let td = mk_target_data(dat_layt);\n+    let llmod = istr::as_buf(~\"rust_out\", { |buf|\n+        llvm::LLVMModuleCreateWithNameInContext(buf,\n+                                                llvm::LLVMGetGlobalContext())\n+    });\n+    let _: () = istr::as_buf(x86::get_data_layout(), { |buf|\n+        llvm::LLVMSetDataLayout(llmod, buf)\n+    });\n+    let _: () = istr::as_buf(x86::get_target_triple(), { |buf|\n+        llvm::LLVMSetTarget(llmod, buf)\n+    });\n+    let td = mk_target_data(istr::to_estr(x86::get_data_layout()));\n     let tn = mk_type_names();\n     let intrinsics = declare_intrinsics(llmod);\n     let task_type = T_task();"}, {"sha": "604fd20f52861a60f4001d1b1a55638e4d00734f", "filename": "src/comp/middle/trans_build.rs", "status": "modified", "additions": 244, "deletions": 93, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_build.rs?ref=d7fa75413f4c109b9ecadf4b9b3e1edd762e3056", "patch": "@@ -1,5 +1,5 @@\n-import std::{vec, str};\n-import str::rustrt::sbuf;\n+import std::{vec, str, istr};\n+import std::istr::sbuf;\n import lib::llvm::llvm;\n import llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef,\n               Opcode, ModuleRef};\n@@ -71,8 +71,10 @@ fn Invoke(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef],\n     cx.terminated = true;\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildInvoke(B, Fn, vec::to_ptr(Args),\n-                              vec::len(Args), Then, Catch, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildInvoke(B, Fn, vec::to_ptr(Args),\n+                              vec::len(Args), Then, Catch, buf)\n+    });\n }\n \n fn Unreachable(cx: &@block_ctxt) -> ValueRef {\n@@ -87,211 +89,282 @@ fn Unreachable(cx: &@block_ctxt) -> ValueRef {\n fn Add(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildAdd(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildAdd(B, LHS, RHS, buf)\n+    });\n }\n \n fn NSWAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildNSWAdd(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildNSWAdd(B, LHS, RHS, buf)\n+    });\n }\n \n fn NUWAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildNUWAdd(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildNUWAdd(B, LHS, RHS, buf)\n+    });\n }\n \n fn FAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildFAdd(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildFAdd(B, LHS, RHS, buf)\n+    });\n }\n \n fn Sub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildSub(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildSub(B, LHS, RHS, buf)\n+    });\n }\n \n fn NSWSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildNSWSub(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildNSWSub(B, LHS, RHS, buf)\n+    });\n }\n \n fn NUWSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildNUWSub(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildNUWSub(B, LHS, RHS, buf)\n+    });\n }\n \n fn FSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildFSub(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildFSub(B, LHS, RHS, buf)\n+    });\n }\n \n fn Mul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildMul(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildMul(B, LHS, RHS, buf)\n+    });\n }\n \n fn NSWMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildNSWMul(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildNSWMul(B, LHS, RHS, buf)\n+    });\n }\n \n fn NUWMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildNUWMul(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildNUWMul(B, LHS, RHS, buf)\n+    });\n }\n \n fn FMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildFMul(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildFMul(B, LHS, RHS, buf)\n+    });\n }\n \n fn UDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildUDiv(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildUDiv(B, LHS, RHS, buf)\n+    });\n }\n \n fn SDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildSDiv(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildSDiv(B, LHS, RHS, buf)\n+    });\n }\n \n fn ExactSDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildExactSDiv(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildExactSDiv(B, LHS, RHS, buf)\n+    });\n }\n \n fn FDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildFDiv(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildFDiv(B, LHS, RHS, buf)\n+    });\n }\n \n fn URem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildURem(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildURem(B, LHS, RHS, buf)\n+    });\n }\n \n fn SRem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildSRem(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildSRem(B, LHS, RHS, buf)\n+    });\n }\n \n fn FRem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildFRem(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildFRem(B, LHS, RHS, buf)\n+    });\n }\n \n fn Shl(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildShl(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildShl(B, LHS, RHS, buf)\n+    });\n }\n \n fn LShr(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildLShr(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildLShr(B, LHS, RHS, buf)\n+    });\n }\n \n fn AShr(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildAShr(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildAShr(B, LHS, RHS, buf)\n+    });\n }\n \n fn And(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildAnd(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildAnd(B, LHS, RHS, buf)\n+    });\n }\n \n fn Or(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildOr(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildOr(B, LHS, RHS, buf)\n+    });\n }\n \n fn Xor(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildXor(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildXor(B, LHS, RHS, buf)\n+    });\n }\n \n fn BinOp(cx: &@block_ctxt, Op: Opcode, LHS: ValueRef,\n          RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildBinOp(B, Op, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildBinOp(B, Op, LHS, RHS, buf)\n+    });\n }\n \n fn Neg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildNeg(B, V, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildNeg(B, V, buf)\n+    });\n }\n \n fn NSWNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildNSWNeg(B, V, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildNSWNeg(B, V, buf)\n+    });\n }\n \n fn NUWNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildNUWNeg(B, V, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildNUWNeg(B, V, buf)\n+    });\n }\n fn FNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildFNeg(B, V, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildFNeg(B, V, buf)\n+    });\n }\n+\n fn Not(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildNot(B, V, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildNot(B, V, buf)\n+    });\n }\n \n /* Memory */\n fn Malloc(cx: &@block_ctxt, Ty: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildMalloc(B, Ty, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildMalloc(B, Ty, buf)\n+    });\n }\n \n fn ArrayMalloc(cx: &@block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildArrayMalloc(B, Ty, Val, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildArrayMalloc(B, Ty, Val, buf)\n+    });\n }\n \n fn Alloca(cx: &@block_ctxt, Ty: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildAlloca(B, Ty, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildAlloca(B, Ty, buf)\n+    });\n }\n \n fn ArrayAlloca(cx: &@block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildArrayAlloca(B, Ty, Val, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildArrayAlloca(B, Ty, Val, buf)\n+    });\n }\n \n fn Free(cx: &@block_ctxt, PointerVal: ValueRef) -> ValueRef {\n@@ -303,7 +376,9 @@ fn Free(cx: &@block_ctxt, PointerVal: ValueRef) -> ValueRef {\n fn Load(cx: &@block_ctxt, PointerVal: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildLoad(B, PointerVal, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildLoad(B, PointerVal, buf)\n+    });\n }\n \n fn Store(cx: &@block_ctxt, Val: ValueRef, Ptr: ValueRef) -> ValueRef {\n@@ -316,156 +391,204 @@ fn GEP(cx: &@block_ctxt, Pointer: ValueRef,\n        Indices: &[ValueRef]) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildGEP(B, Pointer, vec::to_ptr(Indices),\n-                           vec::len(Indices), str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildGEP(B, Pointer, vec::to_ptr(Indices),\n+                           vec::len(Indices), buf)\n+    });\n }\n \n fn InBoundsGEP(cx: &@block_ctxt, Pointer: ValueRef,\n                Indices: &[ValueRef]) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildInBoundsGEP(B, Pointer, vec::to_ptr(Indices),\n-                                   vec::len(Indices), str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildInBoundsGEP(B, Pointer, vec::to_ptr(Indices),\n+                                   vec::len(Indices), buf)\n+    });\n }\n \n fn StructGEP(cx: &@block_ctxt, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildStructGEP(B, Pointer, Idx, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildStructGEP(B, Pointer, Idx, buf)\n+    });\n }\n \n fn GlobalString(cx: &@block_ctxt, _Str: sbuf) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildGlobalString(B, _Str, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildGlobalString(B, _Str, buf)\n+    });\n }\n \n fn GlobalStringPtr(cx: &@block_ctxt, _Str: sbuf) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildGlobalStringPtr(B, _Str, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildGlobalStringPtr(B, _Str, buf)\n+    });\n }\n \n /* Casts */\n fn Trunc(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildTrunc(B, Val, DestTy, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildTrunc(B, Val, DestTy, buf)\n+    });\n }\n \n fn ZExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildZExt(B, Val, DestTy, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildZExt(B, Val, DestTy, buf)\n+    });\n }\n \n fn SExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildSExt(B, Val, DestTy, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildSExt(B, Val, DestTy, buf)\n+    });\n }\n \n fn FPToUI(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildFPToUI(B, Val, DestTy, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildFPToUI(B, Val, DestTy, buf)\n+    });\n }\n \n fn FPToSI(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildFPToSI(B, Val, DestTy, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildFPToSI(B, Val, DestTy, buf)\n+    });\n }\n \n fn UIToFP(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildUIToFP(B, Val, DestTy, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildUIToFP(B, Val, DestTy, buf)\n+    });\n }\n \n fn SIToFP(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildSIToFP(B, Val, DestTy, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildSIToFP(B, Val, DestTy, buf)\n+    });\n }\n \n fn FPTrunc(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildFPTrunc(B, Val, DestTy, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildFPTrunc(B, Val, DestTy, buf)\n+    });\n }\n \n fn FPExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildFPExt(B, Val, DestTy, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildFPExt(B, Val, DestTy, buf)\n+    });\n }\n \n fn PtrToInt(cx: &@block_ctxt, Val: ValueRef,\n             DestTy: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildPtrToInt(B, Val, DestTy, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildPtrToInt(B, Val, DestTy, buf)\n+    });\n }\n \n fn IntToPtr(cx: &@block_ctxt, Val: ValueRef,\n             DestTy: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildIntToPtr(B, Val, DestTy, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildIntToPtr(B, Val, DestTy, buf)\n+    });\n }\n \n fn BitCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildBitCast(B, Val, DestTy, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildBitCast(B, Val, DestTy, buf)\n+    });\n }\n \n fn ZExtOrBitCast(cx: &@block_ctxt, Val: ValueRef,\n                  DestTy: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildZExtOrBitCast(B, Val, DestTy, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildZExtOrBitCast(B, Val, DestTy, buf)\n+    });\n }\n \n fn SExtOrBitCast(cx: &@block_ctxt, Val: ValueRef,\n                  DestTy: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildSExtOrBitCast(B, Val, DestTy, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildSExtOrBitCast(B, Val, DestTy, buf)\n+    });\n }\n \n fn TruncOrBitCast(cx: &@block_ctxt, Val: ValueRef,\n                   DestTy: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildTruncOrBitCast(B, Val, DestTy, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildTruncOrBitCast(B, Val, DestTy, buf)\n+    });\n }\n \n fn Cast(cx: &@block_ctxt, Op: Opcode, Val: ValueRef,\n         DestTy: TypeRef, _Name: sbuf) ->\n     ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildCast(B, Op, Val, DestTy, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildCast(B, Op, Val, DestTy, buf)\n+    });\n }\n \n fn PointerCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildPointerCast(B, Val, DestTy, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildPointerCast(B, Val, DestTy, buf)\n+    });\n }\n \n fn IntCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildIntCast(B, Val, DestTy, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildIntCast(B, Val, DestTy, buf)\n+    });\n }\n \n fn FPCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildFPCast(B, Val, DestTy, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildFPCast(B, Val, DestTy, buf)\n+    });\n }\n \n \n@@ -474,14 +597,18 @@ fn ICmp(cx: &@block_ctxt, Op: uint, LHS: ValueRef,\n         RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildICmp(B, Op, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildICmp(B, Op, LHS, RHS, buf)\n+    });\n }\n \n fn FCmp(cx: &@block_ctxt, Op: uint, LHS: ValueRef,\n         RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildFCmp(B, Op, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildFCmp(B, Op, LHS, RHS, buf)\n+    });\n }\n \n \n@@ -490,7 +617,9 @@ fn Phi(cx: &@block_ctxt, Ty: TypeRef, vals: &[ValueRef],\n        bbs: &[BasicBlockRef]) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    let phi = llvm::LLVMBuildPhi(B, Ty, str::buf(\"\"));\n+    let phi = istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildPhi(B, Ty, buf)\n+    });\n     assert (vec::len::<ValueRef>(vals) == vec::len::<BasicBlockRef>(bbs));\n     llvm::LLVMAddIncoming(phi, vec::to_ptr(vals), vec::to_ptr(bbs),\n                           vec::len(vals));\n@@ -506,16 +635,18 @@ fn AddIncomingToPhi(phi: ValueRef, vals: &[ValueRef], bbs: &[BasicBlockRef]) {\n fn Call(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildCall(B, Fn, vec::to_ptr(Args), vec::len(Args),\n-                            str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildCall(B, Fn, vec::to_ptr(Args),\n+                            vec::len(Args), buf)\n+    });\n }\n \n fn FastCall(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    let v =\n-        llvm::LLVMBuildCall(B, Fn, vec::to_ptr(Args), vec::len(Args),\n-                            str::buf(\"\"));\n+    let v = istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildCall(B, Fn, vec::to_ptr(Args), vec::len(Args), buf)\n+    });\n     llvm::LLVMSetInstructionCallConv(v, lib::llvm::LLVMFastCallConv);\n     ret v;\n }\n@@ -524,9 +655,9 @@ fn CallWithConv(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef],\n                 Conv: uint) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    let v =\n-        llvm::LLVMBuildCall(B, Fn, vec::to_ptr(Args), vec::len(Args),\n-                            str::buf(\"\"));\n+    let v = istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildCall(B, Fn, vec::to_ptr(Args), vec::len(Args), buf)\n+    });\n     llvm::LLVMSetInstructionCallConv(v, Conv);\n     ret v;\n }\n@@ -535,68 +666,86 @@ fn Select(cx: &@block_ctxt, If: ValueRef, Then: ValueRef,\n           Else: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildSelect(B, If, Then, Else, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildSelect(B, If, Then, Else, buf)\n+    });\n }\n \n fn VAArg(cx: &@block_ctxt, list: ValueRef, Ty: TypeRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildVAArg(B, list, Ty, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildVAArg(B, list, Ty, buf)\n+    });\n }\n \n fn ExtractElement(cx: &@block_ctxt, VecVal: ValueRef,\n                   Index: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildExtractElement(B, VecVal, Index, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildExtractElement(B, VecVal, Index, buf)\n+    });\n }\n \n fn InsertElement(cx: &@block_ctxt, VecVal: ValueRef, EltVal: ValueRef,\n                  Index: ValueRef) ->\n     ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildInsertElement(B, VecVal, EltVal, Index,\n-                                     str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildInsertElement(B, VecVal, EltVal, Index, buf)\n+    });\n }\n \n fn ShuffleVector(cx: &@block_ctxt, V1: ValueRef, V2: ValueRef,\n                  Mask: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildShuffleVector(B, V1, V2, Mask, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildShuffleVector(B, V1, V2, Mask, buf)\n+    });\n }\n \n fn ExtractValue(cx: &@block_ctxt, AggVal: ValueRef, Index: uint) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildExtractValue(B, AggVal, Index, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildExtractValue(B, AggVal, Index, buf)\n+    });\n }\n \n fn InsertValue(cx: &@block_ctxt, AggVal: ValueRef,\n                EltVal: ValueRef, Index: uint) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildInsertValue(B, AggVal, EltVal, Index,\n-                                   str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildInsertValue(B, AggVal, EltVal, Index, buf)\n+    });\n }\n \n fn IsNull(cx: &@block_ctxt, Val: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildIsNull(B, Val, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildIsNull(B, Val, buf)\n+    });\n }\n \n fn IsNotNull(cx: &@block_ctxt, Val: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildIsNotNull(B, Val, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildIsNotNull(B, Val, buf)\n+    });\n }\n \n fn PtrDiff(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let B = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildPtrDiff(B, LHS, RHS, str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildPtrDiff(B, LHS, RHS, buf)\n+    });\n }\n \n fn Trap(cx: &@block_ctxt) -> ValueRef {\n@@ -605,12 +754,14 @@ fn Trap(cx: &@block_ctxt) -> ValueRef {\n     let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(B);\n     let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n     let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n-    let T: ValueRef =\n-        llvm::LLVMGetNamedFunction(M, str::buf(\"llvm.trap\"));\n+    let T: ValueRef = istr::as_buf(~\"llvm.trap\", { |buf|\n+        llvm::LLVMGetNamedFunction(M, buf)\n+    });\n     assert (T as int != 0);\n     let Args: [ValueRef] = [];\n-    ret llvm::LLVMBuildCall(B, T, vec::to_ptr(Args), vec::len(Args),\n-                            str::buf(\"\"));\n+    ret istr::as_buf(~\"\", { |buf|\n+        llvm::LLVMBuildCall(B, T, vec::to_ptr(Args), vec::len(Args), buf)\n+    });\n }\n \n //"}, {"sha": "5d43c022c813519365209725ad662a1a9e06849a", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=d7fa75413f4c109b9ecadf4b9b3e1edd762e3056", "patch": "@@ -553,7 +553,9 @@ fn T_struct(elts: &[TypeRef]) -> TypeRef {\n \n fn T_named_struct(name: &str) -> TypeRef {\n     let c = llvm::LLVMGetGlobalContext();\n-    ret llvm::LLVMStructCreateNamed(c, str::buf(name));\n+    ret istr::as_buf(istr::from_estr(name), { |buf|\n+        llvm::LLVMStructCreateNamed(c, buf)\n+    });\n }\n \n fn set_struct_body(t: TypeRef, elts: &[TypeRef]) {\n@@ -816,11 +818,15 @@ fn C_integral(t: TypeRef, u: uint, sign_extend: Bool) -> ValueRef {\n }\n \n fn C_float(s: &str) -> ValueRef {\n-    ret llvm::LLVMConstRealOfString(T_float(), str::buf(s));\n+    ret istr::as_buf(istr::from_estr(s), { |buf|\n+        llvm::LLVMConstRealOfString(T_float(), buf)\n+    });\n }\n \n fn C_floating(s: &str, t: TypeRef) -> ValueRef {\n-    ret llvm::LLVMConstRealOfString(t, str::buf(s));\n+    ret istr::as_buf(istr::from_estr(s), { |buf|\n+        llvm::LLVMConstRealOfString(t, buf)\n+    });\n }\n \n fn C_nil() -> ValueRef {\n@@ -845,11 +851,12 @@ fn C_u8(i: uint) -> ValueRef { ret C_integral(T_i8(), i, False); }\n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n fn C_cstr(cx: &@crate_ctxt, s: &str) -> ValueRef {\n-    let sc = llvm::LLVMConstString(str::buf(s), str::byte_len(s), False);\n-    let gname = cx.names.next(\"str\");\n-    let g =\n-        llvm::LLVMAddGlobal(cx.llmod, val_ty(sc),\n-                            str::buf(gname));\n+    let sc = istr::as_buf(istr::from_estr(s), { |buf|\n+        llvm::LLVMConstString(buf, str::byte_len(s), False)\n+    });\n+    let g = istr::as_buf(istr::from_estr(cx.names.next(\"str\")), { |buf|\n+        llvm::LLVMAddGlobal(cx.llmod, val_ty(sc), buf)\n+    });\n     llvm::LLVMSetInitializer(g, sc);\n     llvm::LLVMSetGlobalConstant(g, True);\n     llvm::LLVMSetLinkage(g, lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n@@ -864,13 +871,15 @@ fn C_str(cx: &@crate_ctxt, s: &str) -> ValueRef {\n                           // 'fill'\n                           // 'pad'\n \n+    let cstr = istr::as_buf(istr::from_estr(s), { |buf|\n+        llvm::LLVMConstString(buf, len, False)\n+    });\n     let box =\n         C_struct([C_int(abi::const_refcount as int), C_int(len + 1u as int),\n-                  C_int(len + 1u as int), C_int(0),\n-                  llvm::LLVMConstString(str::buf(s), len, False)]);\n-    let gname = cx.names.next(\"str\");\n-    let g =\n-        llvm::LLVMAddGlobal(cx.llmod, val_ty(box), str::buf(gname));\n+                  C_int(len + 1u as int), C_int(0), cstr]);\n+    let g = istr::as_buf(istr::from_estr(cx.names.next(\"str\")), { |buf|\n+        llvm::LLVMAddGlobal(cx.llmod, val_ty(box), buf)\n+    });\n     llvm::LLVMSetInitializer(g, box);\n     llvm::LLVMSetGlobalConstant(g, True);\n     llvm::LLVMSetLinkage(g, lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n@@ -879,7 +888,9 @@ fn C_str(cx: &@crate_ctxt, s: &str) -> ValueRef {\n \n // Returns a Plain Old LLVM String:\n fn C_postr(s: &str) -> ValueRef {\n-    ret llvm::LLVMConstString(str::buf(s), str::byte_len(s), False);\n+    ret istr::as_buf(istr::from_estr(s), { |buf|\n+        llvm::LLVMConstString(buf, str::byte_len(s), False)\n+    });\n }\n \n fn C_zero_byte_arr(size: uint) -> ValueRef {\n@@ -911,9 +922,10 @@ fn C_bytes(bytes: &[u8]) -> ValueRef {\n \n fn C_shape(ccx: &@crate_ctxt, bytes: &[u8]) -> ValueRef {\n     let llshape = C_bytes(bytes);\n-    let gname = ccx.names.next(\"shape\");\n-    let llglobal =\n-        llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), str::buf(gname));\n+    let llglobal = istr::as_buf(\n+        istr::from_estr(ccx.names.next(\"shape\")), { |buf|\n+        llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n+    });\n     llvm::LLVMSetInitializer(llglobal, llshape);\n     llvm::LLVMSetGlobalConstant(llglobal, True);\n     llvm::LLVMSetLinkage(llglobal,"}, {"sha": "862bb8a20ff875990e0c0837c8b4bd42b80ecf43", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7fa75413f4c109b9ecadf4b9b3e1edd762e3056/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=d7fa75413f4c109b9ecadf4b9b3e1edd762e3056", "patch": "@@ -571,9 +571,9 @@ fn finish_vtbl(cx: @local_ctxt, llmethods: [ValueRef], name: str) ->\n     let vtbl = C_struct(llmethods);\n     let vtbl_name = mangle_internal_name_by_path(\n         cx.ccx, istr::from_estrs(cx.path + [name]));\n-    let vtbl_name = istr::to_estr(vtbl_name);\n-    let gvar =\n-        llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl), str::buf(vtbl_name));\n+    let gvar = istr::as_buf(vtbl_name, { |buf|\n+        llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl), buf)\n+    });\n     llvm::LLVMSetInitializer(gvar, vtbl);\n     llvm::LLVMSetGlobalConstant(gvar, True);\n     llvm::LLVMSetLinkage(gvar,"}]}