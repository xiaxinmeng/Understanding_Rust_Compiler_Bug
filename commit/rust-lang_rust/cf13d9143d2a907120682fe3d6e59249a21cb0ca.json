{"sha": "cf13d9143d2a907120682fe3d6e59249a21cb0ca", "node_id": "C_kwDOAAsO6NoAKGNmMTNkOTE0M2QyYTkwNzEyMDY4MmZlM2Q2ZTU5MjQ5YTIxY2IwY2E", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-10-09T23:50:14Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-10-19T06:37:48Z"}, "message": "Clarify `run_in_thread_pool_with_globals`.\n\n- Make the structure of the two variants more similar.\n- Add some comments.\n- Move various conditional `use` items inside the function that uses\n  them.\n- Inline some closures.", "tree": {"sha": "da0ad2c4d0e27b154265040874ee08e26198f2ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da0ad2c4d0e27b154265040874ee08e26198f2ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf13d9143d2a907120682fe3d6e59249a21cb0ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf13d9143d2a907120682fe3d6e59249a21cb0ca", "html_url": "https://github.com/rust-lang/rust/commit/cf13d9143d2a907120682fe3d6e59249a21cb0ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf13d9143d2a907120682fe3d6e59249a21cb0ca/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2efc90e7381721df57348b61518b15794b75d189", "url": "https://api.github.com/repos/rust-lang/rust/commits/2efc90e7381721df57348b61518b15794b75d189", "html_url": "https://github.com/rust-lang/rust/commit/2efc90e7381721df57348b61518b15794b75d189"}], "stats": {"total": 90, "additions": 46, "deletions": 44}, "files": [{"sha": "7edbb6f757ce16bba13623d69c73062f54aa3393", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf13d9143d2a907120682fe3d6e59249a21cb0ca/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf13d9143d2a907120682fe3d6e59249a21cb0ca/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=cf13d9143d2a907120682fe3d6e59249a21cb0ca", "patch": "@@ -190,6 +190,7 @@ impl<'a, 'b> RunCompiler<'a, 'b> {\n         run_compiler(self.at_args, self.callbacks, self.file_loader, self.make_codegen_backend)\n     }\n }\n+\n fn run_compiler(\n     at_args: &[String],\n     callbacks: &mut (dyn Callbacks + Send),"}, {"sha": "519b8a7fc7c378ba8fe855fe5af803a22f1818a4", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/cf13d9143d2a907120682fe3d6e59249a21cb0ca/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf13d9143d2a907120682fe3d6e59249a21cb0ca/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=cf13d9143d2a907120682fe3d6e59249a21cb0ca", "patch": "@@ -3,14 +3,8 @@ use libloading::Library;\n use rustc_ast as ast;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-#[cfg(parallel_compiler)]\n-use rustc_data_structures::jobserver;\n use rustc_errors::registry::Registry;\n-#[cfg(parallel_compiler)]\n-use rustc_middle::ty::tls;\n use rustc_parse::validate_attr;\n-#[cfg(parallel_compiler)]\n-use rustc_query_impl::{QueryContext, QueryCtxt};\n use rustc_session as session;\n use rustc_session::config::CheckCfg;\n use rustc_session::config::{self, CrateType};\n@@ -25,8 +19,6 @@ use rustc_span::symbol::{sym, Symbol};\n use std::env;\n use std::env::consts::{DLL_PREFIX, DLL_SUFFIX};\n use std::mem;\n-#[cfg(not(parallel_compiler))]\n-use std::panic;\n use std::path::{Path, PathBuf};\n use std::sync::atomic::{AtomicBool, Ordering};\n use std::sync::OnceLock;\n@@ -135,13 +127,20 @@ pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n     _threads: usize,\n     f: F,\n ) -> R {\n-    // The thread pool is a single thread in the non-parallel compiler.\n-    thread::scope(|s| {\n-        let mut builder = thread::Builder::new().name(\"rustc\".to_string());\n-        if let Some(size) = get_stack_size() {\n-            builder = builder.stack_size(size);\n-        }\n+    // The \"thread pool\" is a single spawned thread in the non-parallel\n+    // compiler. We run on a spawned thread instead of the main thread (a) to\n+    // provide control over the stack size, and (b) to increase similarity with\n+    // the parallel compiler, in particular to ensure there is no accidental\n+    // sharing of data between the main thread and the compilation thread\n+    // (which might cause problems for the parallel compiler).\n+    let mut builder = thread::Builder::new().name(\"rustc\".to_string());\n+    if let Some(size) = get_stack_size() {\n+        builder = builder.stack_size(size);\n+    }\n \n+    // We build the session globals and run `f` on the spawned thread, because\n+    // `SessionGlobals` does not impl `Send` in the non-parallel compiler.\n+    thread::scope(|s| {\n         // `unwrap` is ok here because `spawn_scoped` only panics if the thread\n         // name contains null bytes.\n         let r = builder\n@@ -151,55 +150,57 @@ pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n \n         match r {\n             Ok(v) => v,\n-            Err(e) => panic::resume_unwind(e),\n+            Err(e) => std::panic::resume_unwind(e),\n         }\n     })\n }\n \n-/// Creates a new thread and forwards information in thread locals to it.\n-/// The new thread runs the deadlock handler.\n-/// Must only be called when a deadlock is about to happen.\n-#[cfg(parallel_compiler)]\n-unsafe fn handle_deadlock() {\n-    let registry = rustc_rayon_core::Registry::current();\n-\n-    let query_map = tls::with(|tcx| {\n-        QueryCtxt::from_tcx(tcx)\n-            .try_collect_active_jobs()\n-            .expect(\"active jobs shouldn't be locked in deadlock handler\")\n-    });\n-    thread::spawn(move || rustc_query_impl::deadlock(query_map, &registry));\n-}\n-\n #[cfg(parallel_compiler)]\n pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n     edition: Edition,\n     threads: usize,\n     f: F,\n ) -> R {\n-    let mut config = rayon::ThreadPoolBuilder::new()\n+    use rustc_data_structures::jobserver;\n+    use rustc_middle::ty::tls;\n+    use rustc_query_impl::{deadlock, QueryContext, QueryCtxt};\n+\n+    let mut builder = rayon::ThreadPoolBuilder::new()\n         .thread_name(|_| \"rustc\".to_string())\n         .acquire_thread_handler(jobserver::acquire_thread)\n         .release_thread_handler(jobserver::release_thread)\n         .num_threads(threads)\n-        .deadlock_handler(|| unsafe { handle_deadlock() });\n-\n+        .deadlock_handler(|| {\n+            // On deadlock, creates a new thread and forwards information in thread\n+            // locals to it. The new thread runs the deadlock handler.\n+            let query_map = tls::with(|tcx| {\n+                QueryCtxt::from_tcx(tcx)\n+                    .try_collect_active_jobs()\n+                    .expect(\"active jobs shouldn't be locked in deadlock handler\")\n+            });\n+            let registry = rustc_rayon_core::Registry::current();\n+            thread::spawn(move || deadlock(query_map, &registry));\n+        });\n     if let Some(size) = get_stack_size() {\n-        config = config.stack_size(size);\n+        builder = builder.stack_size(size);\n     }\n \n-    let with_pool = move |pool: &rayon::ThreadPool| pool.install(f);\n-\n+    // We create the session globals on the main thread, then create the thread\n+    // pool. Upon creation, each worker thread created gets a copy of the\n+    // session globals in TLS. This is possible because `SessionGlobals` impls\n+    // `Send` in the parallel compiler.\n     rustc_span::create_session_globals_then(edition, || {\n         rustc_span::with_session_globals(|session_globals| {\n-            // The main handler runs for each Rayon worker thread and sets up\n-            // the thread local rustc uses. `session_globals` is captured and set\n-            // on the new threads.\n-            let main_handler = move |thread: rayon::ThreadBuilder| {\n-                rustc_span::set_session_globals_then(session_globals, || thread.run())\n-            };\n-\n-            config.build_scoped(main_handler, with_pool).unwrap()\n+            builder\n+                .build_scoped(\n+                    // Initialize each new worker thread when created.\n+                    move |thread: rayon::ThreadBuilder| {\n+                        rustc_span::set_session_globals_then(session_globals, || thread.run())\n+                    },\n+                    // Run `f` on the first thread in the thread pool.\n+                    move |pool: &rayon::ThreadPool| pool.install(f),\n+                )\n+                .unwrap()\n         })\n     })\n }"}]}