{"sha": "1e6c1996533d279f87d047be6fc771662a38af72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNmMxOTk2NTMzZDI3OWY4N2QwNDdiZTZmYzc3MTY2MmEzOGFmNzI=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-08T12:11:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-08T12:11:44Z"}, "message": "Rollup merge of #71989 - ecstatic-morse:const-context-enum, r=oli-obk\n\nUse a single enum for the kind of a const context\n\nThis adds a `ConstContext` enum to the `rustc_hir` crate and method that can be called via `tcx.hir()` to get the `ConstContext` for a given body owner. This arose from discussion in #71824.\n\nr? @oli-obk", "tree": {"sha": "97c27f834d4843ed1242dc83c5e05d603c3b0847", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97c27f834d4843ed1242dc83c5e05d603c3b0847"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e6c1996533d279f87d047be6fc771662a38af72", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJetUyACRBK7hj4Ov3rIwAAdHIIACMQAPhj97NeM3PdeJ4CPd6B\nEOIAinC/1u2hfGL0S3hMD1qwAn0glsBZVceomxn0tfcSR2X9RDq03A1DaL7H3SkC\n1klLuwLOwGI369nYIwf3Bov30wp94lcc03pl86UM2qQXZNwB3I9jKYeLdxiR7BhP\nhuPXOQG96e8Yt+6XBbi/P56WQfc9VJb+BVsoUVqVa/kKD2IdJHSGz9Zfw70eaZCQ\nBpjyu4MtPO+8xlx7lUDINR2druCv+aTREJRqcP3yKlr4ffNnPFOnJYcWfFsgA/Pb\n9QkDR3aiTE0w1fuENJOLIlQuelbKR0Cd2GEDf1ZhfQG+w39bWIL2/awYOHv6P9c=\n=jhzo\n-----END PGP SIGNATURE-----\n", "payload": "tree 97c27f834d4843ed1242dc83c5e05d603c3b0847\nparent a51e004e1bf7f9bba151dd9104a217c1ace6a0a2\nparent e356d5c489e8e43ce8ca7453c98ea9343ce2264c\nauthor Dylan DPC <dylan.dpc@gmail.com> 1588939904 +0200\ncommitter GitHub <noreply@github.com> 1588939904 +0200\n\nRollup merge of #71989 - ecstatic-morse:const-context-enum, r=oli-obk\n\nUse a single enum for the kind of a const context\n\nThis adds a `ConstContext` enum to the `rustc_hir` crate and method that can be called via `tcx.hir()` to get the `ConstContext` for a given body owner. This arose from discussion in #71824.\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e6c1996533d279f87d047be6fc771662a38af72", "html_url": "https://github.com/rust-lang/rust/commit/1e6c1996533d279f87d047be6fc771662a38af72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e6c1996533d279f87d047be6fc771662a38af72/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a51e004e1bf7f9bba151dd9104a217c1ace6a0a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a51e004e1bf7f9bba151dd9104a217c1ace6a0a2", "html_url": "https://github.com/rust-lang/rust/commit/a51e004e1bf7f9bba151dd9104a217c1ace6a0a2"}, {"sha": "e356d5c489e8e43ce8ca7453c98ea9343ce2264c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e356d5c489e8e43ce8ca7453c98ea9343ce2264c", "html_url": "https://github.com/rust-lang/rust/commit/e356d5c489e8e43ce8ca7453c98ea9343ce2264c"}], "stats": {"total": 235, "additions": 101, "deletions": 134}, "files": [{"sha": "75a5c198ec7851d5c3e6e357b0311d2d44b90b58", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1e6c1996533d279f87d047be6fc771662a38af72/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6c1996533d279f87d047be6fc771662a38af72/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=1e6c1996533d279f87d047be6fc771662a38af72", "patch": "@@ -1291,6 +1291,53 @@ impl BodyOwnerKind {\n     }\n }\n \n+/// The kind of an item that requires const-checking.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub enum ConstContext {\n+    /// A `const fn`.\n+    ConstFn,\n+\n+    /// A `static` or `static mut`.\n+    Static(Mutability),\n+\n+    /// A `const`, associated `const`, or other const context.\n+    ///\n+    /// Other contexts include:\n+    /// - Array length expressions\n+    /// - Enum discriminants\n+    /// - Const generics\n+    ///\n+    /// For the most part, other contexts are treated just like a regular `const`, so they are\n+    /// lumped into the same category.\n+    Const,\n+}\n+\n+impl ConstContext {\n+    /// A description of this const context that can appear between backticks in an error message.\n+    ///\n+    /// E.g. `const` or `static mut`.\n+    pub fn keyword_name(self) -> &'static str {\n+        match self {\n+            Self::Const => \"const\",\n+            Self::Static(Mutability::Not) => \"static\",\n+            Self::Static(Mutability::Mut) => \"static mut\",\n+            Self::ConstFn => \"const fn\",\n+        }\n+    }\n+}\n+\n+/// A colloquial, trivially pluralizable description of this const context for use in error\n+/// messages.\n+impl fmt::Display for ConstContext {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            Self::Const => write!(f, \"constant\"),\n+            Self::Static(_) => write!(f, \"static\"),\n+            Self::ConstFn => write!(f, \"constant function\"),\n+        }\n+    }\n+}\n+\n /// A literal.\n pub type Lit = Spanned<LitKind>;\n "}, {"sha": "235d1d80192c883805d9cfefe229f0b201049757", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1e6c1996533d279f87d047be6fc771662a38af72/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6c1996533d279f87d047be6fc771662a38af72/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=1e6c1996533d279f87d047be6fc771662a38af72", "patch": "@@ -408,6 +408,9 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n+    /// Returns the `BodyOwnerKind` of this `LocalDefId`.\n+    ///\n+    /// Panics if `LocalDefId` does not have an associated body.\n     pub fn body_owner_kind(&self, id: HirId) -> BodyOwnerKind {\n         match self.get(id) {\n             Node::Item(&Item { kind: ItemKind::Const(..), .. })\n@@ -424,6 +427,23 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    /// Returns the `ConstContext` of the body associated with this `LocalDefId`.\n+    ///\n+    /// Panics if `LocalDefId` does not have an associated body.\n+    pub fn body_const_context(&self, did: LocalDefId) -> Option<ConstContext> {\n+        let hir_id = self.local_def_id_to_hir_id(did);\n+        let ccx = match self.body_owner_kind(hir_id) {\n+            BodyOwnerKind::Const => ConstContext::Const,\n+            BodyOwnerKind::Static(mt) => ConstContext::Static(mt),\n+\n+            BodyOwnerKind::Fn if self.tcx.is_constructor(did.to_def_id()) => return None,\n+            BodyOwnerKind::Fn if self.tcx.is_const_fn_raw(did.to_def_id()) => ConstContext::ConstFn,\n+            BodyOwnerKind::Fn | BodyOwnerKind::Closure => return None,\n+        };\n+\n+        Some(ccx)\n+    }\n+\n     pub fn ty_param_owner(&self, id: HirId) -> HirId {\n         match self.get(id) {\n             Node::Item(&Item { kind: ItemKind::Trait(..) | ItemKind::TraitAlias(..), .. }) => id,"}, {"sha": "7c439f80ef6add339b216b83d56e5bc700237551", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 3, "deletions": 65, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1e6c1996533d279f87d047be6fc771662a38af72/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6c1996533d279f87d047be6fc771662a38af72/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=1e6c1996533d279f87d047be6fc771662a38af72", "patch": "@@ -9,8 +9,6 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::mir;\n use rustc_middle::ty::{self, TyCtxt};\n \n-use std::fmt;\n-\n pub use self::qualifs::Qualif;\n \n mod ops;\n@@ -25,7 +23,7 @@ pub struct ConstCx<'mir, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n     pub def_id: DefId,\n     pub param_env: ty::ParamEnv<'tcx>,\n-    pub const_kind: Option<ConstKind>,\n+    pub const_kind: Option<hir::ConstContext>,\n }\n \n impl ConstCx<'mir, 'tcx> {\n@@ -40,78 +38,18 @@ impl ConstCx<'mir, 'tcx> {\n         body: &'mir mir::Body<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n-        let const_kind = ConstKind::for_item(tcx, def_id);\n-\n+        let const_kind = tcx.hir().body_const_context(def_id);\n         ConstCx { body, tcx, def_id: def_id.to_def_id(), param_env, const_kind }\n     }\n \n     /// Returns the kind of const context this `Item` represents (`const`, `static`, etc.).\n     ///\n     /// Panics if this `Item` is not const.\n-    pub fn const_kind(&self) -> ConstKind {\n+    pub fn const_kind(&self) -> hir::ConstContext {\n         self.const_kind.expect(\"`const_kind` must not be called on a non-const fn\")\n     }\n }\n \n-/// The kinds of items which require compile-time evaluation.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum ConstKind {\n-    /// A `static` item.\n-    Static,\n-    /// A `static mut` item.\n-    StaticMut,\n-    /// A `const fn` item.\n-    ConstFn,\n-    /// A `const` item or an anonymous constant (e.g. in array lengths).\n-    Const,\n-}\n-\n-impl ConstKind {\n-    /// Returns the validation mode for the item with the given `DefId`, or `None` if this item\n-    /// does not require validation (e.g. a non-const `fn`).\n-    pub fn for_item(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Option<Self> {\n-        use hir::BodyOwnerKind as HirKind;\n-\n-        let hir_id = tcx.hir().as_local_hir_id(def_id);\n-\n-        let mode = match tcx.hir().body_owner_kind(hir_id) {\n-            HirKind::Closure => return None,\n-\n-            // Note: this is deliberately checking for `is_const_fn_raw`, as the `is_const_fn`\n-            // checks take into account the `rustc_const_unstable` attribute combined with enabled\n-            // feature gates. Otherwise, const qualification would _not check_ whether this\n-            // function body follows the `const fn` rules, as an unstable `const fn` would\n-            // be considered \"not const\". More details are available in issue #67053.\n-            HirKind::Fn if tcx.is_const_fn_raw(def_id) => ConstKind::ConstFn,\n-            HirKind::Fn => return None,\n-\n-            HirKind::Const => ConstKind::Const,\n-\n-            HirKind::Static(hir::Mutability::Not) => ConstKind::Static,\n-            HirKind::Static(hir::Mutability::Mut) => ConstKind::StaticMut,\n-        };\n-\n-        Some(mode)\n-    }\n-\n-    pub fn is_static(self) -> bool {\n-        match self {\n-            ConstKind::Static | ConstKind::StaticMut => true,\n-            ConstKind::ConstFn | ConstKind::Const => false,\n-        }\n-    }\n-}\n-\n-impl fmt::Display for ConstKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            ConstKind::Const => write!(f, \"constant\"),\n-            ConstKind::Static | ConstKind::StaticMut => write!(f, \"static\"),\n-            ConstKind::ConstFn => write!(f, \"constant function\"),\n-        }\n-    }\n-}\n-\n /// Returns `true` if this `DefId` points to one of the official `panic` lang items.\n pub fn is_lang_panic_fn(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n     Some(def_id) == tcx.lang_items().panic_fn() || Some(def_id) == tcx.lang_items().begin_panic_fn()"}, {"sha": "28743ee8e363696ee33d9076d28907d940de3314", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1e6c1996533d279f87d047be6fc771662a38af72/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6c1996533d279f87d047be6fc771662a38af72/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=1e6c1996533d279f87d047be6fc771662a38af72", "patch": "@@ -1,13 +1,14 @@\n //! Concrete error types for all operations which may be invalid in a certain const context.\n \n use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_session::config::nightly_options;\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, Symbol};\n \n-use super::{ConstCx, ConstKind};\n+use super::ConstCx;\n \n /// An operation that is not *always* allowed in a const context.\n pub trait NonConstOp: std::fmt::Debug {\n@@ -326,7 +327,7 @@ impl NonConstOp for RawPtrToIntCast {\n pub struct StaticAccess;\n impl NonConstOp for StaticAccess {\n     fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n-        ccx.const_kind().is_static()\n+        matches!(ccx.const_kind(), hir::ConstContext::Static(_))\n     }\n \n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n@@ -374,7 +375,7 @@ pub struct UnionAccess;\n impl NonConstOp for UnionAccess {\n     fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n         // Union accesses are stable in all contexts except `const fn`.\n-        ccx.const_kind() != ConstKind::ConstFn\n+        ccx.const_kind() != hir::ConstContext::ConstFn\n             || ccx.tcx.features().enabled(Self::feature_gate().unwrap())\n     }\n "}, {"sha": "896ce981f92274520bcc18255dfab355a4a13d26", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1e6c1996533d279f87d047be6fc771662a38af72/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6c1996533d279f87d047be6fc771662a38af72/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=1e6c1996533d279f87d047be6fc771662a38af72", "patch": "@@ -1,7 +1,7 @@\n //! The `Visitor` responsible for actually checking a `mir::Body` for invalid operations.\n \n use rustc_errors::struct_span_err;\n-use rustc_hir::lang_items;\n+use rustc_hir::{self as hir, lang_items};\n use rustc_hir::{def_id::DefId, HirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n@@ -18,7 +18,7 @@ use std::ops::Deref;\n use super::ops::{self, NonConstOp};\n use super::qualifs::{self, CustomEq, HasMutInterior, NeedsDrop};\n use super::resolver::FlowSensitiveAnalysis;\n-use super::{is_lang_panic_fn, ConstCx, ConstKind, Qualif};\n+use super::{is_lang_panic_fn, ConstCx, Qualif};\n use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n use crate::dataflow::impls::MaybeMutBorrowedLocals;\n use crate::dataflow::{self, Analysis};\n@@ -145,17 +145,13 @@ impl Qualifs<'mir, 'tcx> {\n             // We don't care whether a `const fn` returns a value that is not structurally\n             // matchable. Functions calls are opaque and always use type-based qualification, so\n             // this value should never be used.\n-            ConstKind::ConstFn => true,\n+            hir::ConstContext::ConstFn => true,\n \n             // If we know that all values of the return type are structurally matchable, there's no\n             // need to run dataflow.\n-            ConstKind::Const | ConstKind::Static | ConstKind::StaticMut\n-                if !CustomEq::in_any_value_of_ty(ccx, ccx.body.return_ty()) =>\n-            {\n-                false\n-            }\n+            _ if !CustomEq::in_any_value_of_ty(ccx, ccx.body.return_ty()) => false,\n \n-            ConstKind::Const | ConstKind::Static | ConstKind::StaticMut => {\n+            hir::ConstContext::Const | hir::ConstContext::Static(_) => {\n                 let mut cursor = FlowSensitiveAnalysis::new(CustomEq, ccx)\n                     .into_engine(ccx.tcx, &ccx.body, ccx.def_id)\n                     .iterate_to_fixpoint()\n@@ -198,7 +194,7 @@ impl Validator<'mir, 'tcx> {\n     pub fn check_body(&mut self) {\n         let ConstCx { tcx, body, def_id, const_kind, .. } = *self.ccx;\n \n-        let use_min_const_fn_checks = (const_kind == Some(ConstKind::ConstFn)\n+        let use_min_const_fn_checks = (const_kind == Some(hir::ConstContext::ConstFn)\n             && crate::const_eval::is_min_const_fn(tcx, def_id))\n             && !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you;\n \n@@ -222,8 +218,9 @@ impl Validator<'mir, 'tcx> {\n         self.visit_body(&body);\n \n         // Ensure that the end result is `Sync` in a non-thread local `static`.\n-        let should_check_for_sync =\n-            const_kind == Some(ConstKind::Static) && !tcx.is_thread_local_static(def_id);\n+        let should_check_for_sync = const_kind\n+            == Some(hir::ConstContext::Static(hir::Mutability::Not))\n+            && !tcx.is_thread_local_static(def_id);\n \n         if should_check_for_sync {\n             let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n@@ -351,7 +348,9 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                 let ty = place.ty(self.body, self.tcx).ty;\n                 let is_allowed = match ty.kind {\n                     // Inside a `static mut`, `&mut [...]` is allowed.\n-                    ty::Array(..) | ty::Slice(_) if self.const_kind() == ConstKind::StaticMut => {\n+                    ty::Array(..) | ty::Slice(_)\n+                        if self.const_kind() == hir::ConstContext::Static(hir::Mutability::Mut) =>\n+                    {\n                         true\n                     }\n "}, {"sha": "02356a43699e3e7684619349fc408f0bae26182b", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e6c1996533d279f87d047be6fc771662a38af72/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6c1996533d279f87d047be6fc771662a38af72/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=1e6c1996533d279f87d047be6fc771662a38af72", "patch": "@@ -182,7 +182,7 @@ pub fn run_passes(\n }\n \n fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n-    let const_kind = check_consts::ConstKind::for_item(tcx, def_id.expect_local());\n+    let const_kind = tcx.hir().body_const_context(def_id.expect_local());\n \n     // No need to const-check a non-const `fn`.\n     if const_kind.is_none() {"}, {"sha": "467e4188814aa87319ca151bcfbfe14037769861", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1e6c1996533d279f87d047be6fc771662a38af72/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6c1996533d279f87d047be6fc771662a38af72/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=1e6c1996533d279f87d047be6fc771662a38af72", "patch": "@@ -13,6 +13,7 @@\n //! move analysis runs after promotion on broken MIR.\n \n use rustc_ast::ast::LitKind;\n+use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::traversal::ReversePostorder;\n use rustc_middle::mir::visit::{MutVisitor, MutatingUseContext, PlaceContext, Visitor};\n@@ -30,7 +31,7 @@ use std::cell::Cell;\n use std::{cmp, iter, mem};\n \n use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n-use crate::transform::check_consts::{is_lang_panic_fn, qualifs, ConstCx, ConstKind};\n+use crate::transform::check_consts::{is_lang_panic_fn, qualifs, ConstCx};\n use crate::transform::{MirPass, MirSource};\n \n /// A `MirPass` for promotion.\n@@ -352,7 +353,9 @@ impl<'tcx> Validator<'_, 'tcx> {\n                             // In theory, any zero-sized value could be borrowed\n                             // mutably without consequences. However, only &mut []\n                             // is allowed right now, and only in functions.\n-                            if self.const_kind == Some(ConstKind::StaticMut) {\n+                            if self.const_kind\n+                                == Some(hir::ConstContext::Static(hir::Mutability::Mut))\n+                            {\n                                 // Inside a `static mut`, &mut [...] is also allowed.\n                                 match ty.kind {\n                                     ty::Array(..) | ty::Slice(_) => {}\n@@ -517,7 +520,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 if let Some(def_id) = c.check_static_ptr(self.tcx) {\n                     // Only allow statics (not consts) to refer to other statics.\n                     // FIXME(eddyb) does this matter at all for promotion?\n-                    let is_static = self.const_kind.map_or(false, |k| k.is_static());\n+                    let is_static = matches!(self.const_kind, Some(hir::ConstContext::Static(_)));\n                     if !is_static {\n                         return Err(Unpromotable);\n                     }\n@@ -607,7 +610,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     // In theory, any zero-sized value could be borrowed\n                     // mutably without consequences. However, only &mut []\n                     // is allowed right now, and only in functions.\n-                    if self.const_kind == Some(ConstKind::StaticMut) {\n+                    if self.const_kind == Some(hir::ConstContext::Static(hir::Mutability::Mut)) {\n                         // Inside a `static mut`, &mut [...] is also allowed.\n                         match ty.kind {\n                             ty::Array(..) | ty::Slice(_) => {}"}, {"sha": "94f9c619a3a26493a5ad649406a1a723bb4b4861", "filename": "src/librustc_passes/check_const.rs", "status": "modified", "additions": 7, "deletions": 48, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1e6c1996533d279f87d047be6fc771662a38af72/src%2Flibrustc_passes%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6c1996533d279f87d047be6fc771662a38af72/src%2Flibrustc_passes%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_const.rs?ref=1e6c1996533d279f87d047be6fc771662a38af72", "patch": "@@ -7,7 +7,6 @@\n //! errors. We still look for those primitives in the MIR const-checker to ensure nothing slips\n //! through, but errors for structured control flow in a `const` should be emitted here.\n \n-use rustc_ast::ast::Mutability;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -19,8 +18,6 @@ use rustc_session::config::nightly_options;\n use rustc_session::parse::feature_err;\n use rustc_span::{sym, Span, Symbol};\n \n-use std::fmt;\n-\n /// An expression that is not *always* legal in a const context.\n #[derive(Clone, Copy)]\n enum NonConstExpr {\n@@ -65,46 +62,6 @@ impl NonConstExpr {\n     }\n }\n \n-#[derive(Copy, Clone)]\n-enum ConstKind {\n-    Static,\n-    StaticMut,\n-    ConstFn,\n-    Const,\n-    AnonConst,\n-}\n-\n-impl ConstKind {\n-    fn for_body(body: &hir::Body<'_>, tcx: TyCtxt<'_>) -> Option<Self> {\n-        let owner = tcx.hir().body_owner(body.id());\n-        let const_kind = match tcx.hir().body_owner_kind(owner) {\n-            hir::BodyOwnerKind::Const => Self::Const,\n-            hir::BodyOwnerKind::Static(Mutability::Mut) => Self::StaticMut,\n-            hir::BodyOwnerKind::Static(Mutability::Not) => Self::Static,\n-\n-            hir::BodyOwnerKind::Fn if tcx.is_const_fn_raw(tcx.hir().local_def_id(owner)) => {\n-                Self::ConstFn\n-            }\n-            hir::BodyOwnerKind::Fn | hir::BodyOwnerKind::Closure => return None,\n-        };\n-\n-        Some(const_kind)\n-    }\n-}\n-\n-impl fmt::Display for ConstKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let s = match self {\n-            Self::Static => \"static\",\n-            Self::StaticMut => \"static mut\",\n-            Self::Const | Self::AnonConst => \"const\",\n-            Self::ConstFn => \"const fn\",\n-        };\n-\n-        write!(f, \"{}\", s)\n-    }\n-}\n-\n fn check_mod_const_bodies(tcx: TyCtxt<'_>, module_def_id: DefId) {\n     let mut vis = CheckConstVisitor::new(tcx);\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut vis.as_deep_visitor());\n@@ -117,7 +74,7 @@ pub(crate) fn provide(providers: &mut Providers<'_>) {\n #[derive(Copy, Clone)]\n struct CheckConstVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    const_kind: Option<ConstKind>,\n+    const_kind: Option<hir::ConstContext>,\n }\n \n impl<'tcx> CheckConstVisitor<'tcx> {\n@@ -147,7 +104,8 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n         let const_kind = self\n             .const_kind\n             .expect(\"`const_check_violated` may only be called inside a const context\");\n-        let msg = format!(\"{} is not allowed in a `{}`\", expr.name(), const_kind);\n+\n+        let msg = format!(\"{} is not allowed in a `{}`\", expr.name(), const_kind.keyword_name());\n \n         let required_gates = required_gates.unwrap_or(&[]);\n         let missing_gates: Vec<_> =\n@@ -191,7 +149,7 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n     }\n \n     /// Saves the parent `const_kind` before calling `f` and restores it afterwards.\n-    fn recurse_into(&mut self, kind: Option<ConstKind>, f: impl FnOnce(&mut Self)) {\n+    fn recurse_into(&mut self, kind: Option<hir::ConstContext>, f: impl FnOnce(&mut Self)) {\n         let parent_kind = self.const_kind;\n         self.const_kind = kind;\n         f(self);\n@@ -207,12 +165,13 @@ impl<'tcx> Visitor<'tcx> for CheckConstVisitor<'tcx> {\n     }\n \n     fn visit_anon_const(&mut self, anon: &'tcx hir::AnonConst) {\n-        let kind = Some(ConstKind::AnonConst);\n+        let kind = Some(hir::ConstContext::Const);\n         self.recurse_into(kind, |this| intravisit::walk_anon_const(this, anon));\n     }\n \n     fn visit_body(&mut self, body: &'tcx hir::Body<'tcx>) {\n-        let kind = ConstKind::for_body(body, self.tcx);\n+        let owner = self.tcx.hir().body_owner_def_id(body.id());\n+        let kind = self.tcx.hir().body_const_context(owner);\n         self.recurse_into(kind, |this| intravisit::walk_body(this, body));\n     }\n "}]}