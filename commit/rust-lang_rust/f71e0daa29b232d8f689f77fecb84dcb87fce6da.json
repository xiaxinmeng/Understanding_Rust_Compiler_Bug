{"sha": "f71e0daa29b232d8f689f77fecb84dcb87fce6da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3MWUwZGFhMjliMjMyZDhmNjg5Zjc3ZmVjYjg0ZGNiODdmY2U2ZGE=", "commit": {"author": {"name": "Xiang Fan", "email": "sfanxiang@gmail.com", "date": "2019-06-06T00:39:20Z"}, "committer": {"name": "Xiang Fan", "email": "sfanxiang@gmail.com", "date": "2019-09-27T20:45:08Z"}, "message": "Add llvm.sideeffect to potential infinite loops and recursions\n\nLLVM assumes that a thread will eventually cause side effect. This is\nnot true in Rust if a loop or recursion does nothing in its body,\ncausing undefined behavior even in common cases like `loop {}`.\nInserting llvm.sideeffect fixes the undefined behavior.\n\nAs a micro-optimization, only insert llvm.sideeffect when jumping back\nin blocks or calling a function.\n\nA patch for LLVM is expected to allow empty non-terminate code by\ndefault and fix this issue from LLVM side.\n\nhttps://github.com/rust-lang/rust/issues/28728", "tree": {"sha": "7e450a5f114b0973aad2b5b7799bc7f54c6776c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e450a5f114b0973aad2b5b7799bc7f54c6776c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f71e0daa29b232d8f689f77fecb84dcb87fce6da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f71e0daa29b232d8f689f77fecb84dcb87fce6da", "html_url": "https://github.com/rust-lang/rust/commit/f71e0daa29b232d8f689f77fecb84dcb87fce6da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f71e0daa29b232d8f689f77fecb84dcb87fce6da/comments", "author": {"login": "sfanxiang", "id": 5893440, "node_id": "MDQ6VXNlcjU4OTM0NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/5893440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfanxiang", "html_url": "https://github.com/sfanxiang", "followers_url": "https://api.github.com/users/sfanxiang/followers", "following_url": "https://api.github.com/users/sfanxiang/following{/other_user}", "gists_url": "https://api.github.com/users/sfanxiang/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfanxiang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfanxiang/subscriptions", "organizations_url": "https://api.github.com/users/sfanxiang/orgs", "repos_url": "https://api.github.com/users/sfanxiang/repos", "events_url": "https://api.github.com/users/sfanxiang/events{/privacy}", "received_events_url": "https://api.github.com/users/sfanxiang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfanxiang", "id": 5893440, "node_id": "MDQ6VXNlcjU4OTM0NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/5893440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfanxiang", "html_url": "https://github.com/sfanxiang", "followers_url": "https://api.github.com/users/sfanxiang/followers", "following_url": "https://api.github.com/users/sfanxiang/following{/other_user}", "gists_url": "https://api.github.com/users/sfanxiang/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfanxiang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfanxiang/subscriptions", "organizations_url": "https://api.github.com/users/sfanxiang/orgs", "repos_url": "https://api.github.com/users/sfanxiang/repos", "events_url": "https://api.github.com/users/sfanxiang/events{/privacy}", "received_events_url": "https://api.github.com/users/sfanxiang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a37fe2de697bb1a9d304e4e811836e125f944cd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a37fe2de697bb1a9d304e4e811836e125f944cd5", "html_url": "https://github.com/rust-lang/rust/commit/a37fe2de697bb1a9d304e4e811836e125f944cd5"}], "stats": {"total": 145, "additions": 127, "deletions": 18}, "files": [{"sha": "bac37369a29a81456f1e54098b4075cd76a2e7e1", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=f71e0daa29b232d8f689f77fecb84dcb87fce6da", "patch": "@@ -537,6 +537,7 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.trap\", fn() -> void);\n         ifn!(\"llvm.debugtrap\", fn() -> void);\n         ifn!(\"llvm.frameaddress\", fn(t_i32) -> i8p);\n+        ifn!(\"llvm.sideeffect\", fn() -> void);\n \n         ifn!(\"llvm.powi.f32\", fn(t_f32, t_i32) -> t_f32);\n         ifn!(\"llvm.powi.v2f32\", fn(t_v2f32, t_i32) -> t_v2f32);"}, {"sha": "a8734d338df17e746c1534be886efd1d42c17539", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=f71e0daa29b232d8f689f77fecb84dcb87fce6da", "patch": "@@ -124,6 +124,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 self.call(expect, &[args[0].immediate(), self.const_bool(false)], None)\n             }\n             \"try\" => {\n+                self.sideeffect();\n                 try_intrinsic(self,\n                               args[0].immediate(),\n                               args[1].immediate(),\n@@ -724,6 +725,11 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         self.call(expect, &[cond, self.const_bool(expected)], None)\n     }\n \n+    fn sideeffect(&mut self) {\n+        let fnname = self.get_intrinsic(&(\"llvm.sideeffect\"));\n+        self.call(fnname, &[], None);\n+    }\n+\n     fn va_start(&mut self, va_list: &'ll Value) -> &'ll Value {\n         let intrinsic = self.cx().get_intrinsic(\"llvm.va_start\");\n         self.call(intrinsic, &[va_list], None)"}, {"sha": "99d70e6bb82532c578fcc606713ef038a781d390", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=f71e0daa29b232d8f689f77fecb84dcb87fce6da", "patch": "@@ -148,6 +148,24 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    // Generate sideeffect intrinsic if jumping to any of the targets can form\n+    // a loop.\n+    fn maybe_sideeffect<'b, 'tcx2: 'b, Bx: BuilderMethods<'b, 'tcx2>>(\n+        &self,\n+        mir: &'b mir::Body<'tcx>,\n+        bx: &mut Bx,\n+        targets: &[mir::BasicBlock],\n+    ) {\n+        if targets.iter().any(|target| {\n+            *target <= *self.bb\n+                && target\n+                    .start_location()\n+                    .is_predecessor_of(self.bb.start_location(), mir)\n+        }) {\n+            bx.sideeffect();\n+        }\n+    }\n }\n \n /// Codegen implementations for some terminator variants.\n@@ -196,6 +214,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let lltrue = helper.llblock(self, targets[0]);\n             let llfalse = helper.llblock(self, targets[1]);\n             if switch_ty == bx.tcx().types.bool {\n+                helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n                 // Don't generate trivial icmps when switching on bool\n                 if let [0] = values[..] {\n                     bx.cond_br(discr.immediate(), llfalse, lltrue);\n@@ -209,9 +228,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 );\n                 let llval = bx.const_uint_big(switch_llty, values[0]);\n                 let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n+                helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n                 bx.cond_br(cmp, lltrue, llfalse);\n             }\n         } else {\n+            helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n             let (otherwise, targets) = targets.split_last().unwrap();\n             bx.switch(\n                 discr.immediate(),\n@@ -310,6 +331,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n             // we don't actually need to drop anything.\n+            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n             helper.funclet_br(self, &mut bx, target);\n             return\n         }\n@@ -340,6 +362,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                  FnType::of_instance(&bx, drop_fn))\n             }\n         };\n+        bx.sideeffect();\n         helper.do_call(self, &mut bx, fn_ty, drop_fn, args,\n                        Some((ReturnDest::Nothing, target)),\n                        unwind);\n@@ -375,6 +398,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Don't codegen the panic block if success if known.\n         if const_cond == Some(expected) {\n+            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n             helper.funclet_br(self, &mut bx, target);\n             return;\n         }\n@@ -385,6 +409,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Create the failure block and the conditional branch to it.\n         let lltarget = helper.llblock(self, target);\n         let panic_block = self.new_block(\"panic\");\n+        helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n         if expected {\n             bx.cond_br(cond, lltarget, panic_block.llbb());\n         } else {\n@@ -437,6 +462,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let fn_ty = FnType::of_instance(&bx, instance);\n         let llfn = bx.get_fn(instance);\n \n+        bx.sideeffect();\n         // Codegen the actual panic invoke/call.\n         helper.do_call(self, &mut bx, fn_ty, llfn, &args, None, cleanup);\n     }\n@@ -488,6 +514,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             if let Some(destination_ref) = destination.as_ref() {\n                 let &(ref dest, target) = destination_ref;\n                 self.codegen_transmute(&mut bx, &args[0], dest);\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n             } else {\n                 // If we are trying to transmute to an uninhabited type,\n@@ -518,6 +545,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             Some(ty::InstanceDef::DropGlue(_, None)) => {\n                 // Empty drop glue; a no-op.\n                 let &(_, target) = destination.as_ref().unwrap();\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n                 return;\n             }\n@@ -554,6 +582,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let fn_ty = FnType::of_instance(&bx, instance);\n                 let llfn = bx.get_fn(instance);\n \n+                bx.sideeffect();\n                 // Codegen the actual panic invoke/call.\n                 helper.do_call(\n                     self,\n@@ -566,7 +595,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 );\n             } else {\n                 // a NOP\n-                helper.funclet_br(self, &mut bx, destination.as_ref().unwrap().1)\n+                let target = destination.as_ref().unwrap().1;\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+                helper.funclet_br(self, &mut bx, target);\n             }\n             return;\n         }\n@@ -675,6 +706,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             if let Some((_, target)) = *destination {\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n             } else {\n                 bx.unreachable();\n@@ -786,6 +818,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             _ => span_bug!(span, \"no llfn for call\"),\n         };\n \n+        bx.sideeffect();\n         helper.do_call(self, &mut bx, fn_ty, fn_ptr, &llargs,\n                        destination.as_ref().map(|&(_, target)| (ret_dest, target)),\n                        cleanup);\n@@ -835,6 +868,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::TerminatorKind::Goto { target } => {\n+                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n             }\n "}, {"sha": "11a75c6f38c7f73ff23ca2179a0486395cf5f47c", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=f71e0daa29b232d8f689f77fecb84dcb87fce6da", "patch": "@@ -486,6 +486,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 };\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n                 let r = bx.cx().get_fn(instance);\n+                bx.sideeffect();\n                 let call = bx.call(r, &[llsize, llalign], None);\n                 let val = bx.pointercast(call, llty_ptr);\n "}, {"sha": "2c484084c4a20e063bc0c67d51423501b16eb787", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=f71e0daa29b232d8f689f77fecb84dcb87fce6da", "patch": "@@ -20,6 +20,7 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n     fn abort(&mut self);\n     fn assume(&mut self, val: Self::Value);\n     fn expect(&mut self, cond: Self::Value, expected: bool) -> Self::Value;\n+    fn sideeffect(&mut self);\n     /// Trait method used to inject `va_start` on the \"spoofed\" `VaListImpl` in\n     /// Rust defined C-variadic functions.\n     fn va_start(&mut self, val: Self::Value) -> Self::Value;"}, {"sha": "c1e36a17ec291e53ff42854d9b1133261f2bf028", "filename": "src/test/codegen/alloc-optimisation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Falloc-optimisation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Falloc-optimisation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Falloc-optimisation.rs?ref=f71e0daa29b232d8f689f77fecb84dcb87fce6da", "patch": "@@ -7,7 +7,8 @@\n pub fn alloc_test(data: u32) {\n     // CHECK-LABEL: @alloc_test\n     // CHECK-NEXT: start:\n-    // CHECK-NEXT: ret void\n+    // CHECK-NOT: alloc\n+    // CHECK: ret void\n     let x = Box::new(data);\n     drop(x);\n }"}, {"sha": "f8fc663169d9b484c9fc7fc3c3c1e39db170a2d6", "filename": "src/test/codegen/dealloc-no-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Fdealloc-no-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Fdealloc-no-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fdealloc-no-unwind.rs?ref=f71e0daa29b232d8f689f77fecb84dcb87fce6da", "patch": "@@ -17,7 +17,7 @@ impl Drop for A {\n pub fn a(a: Box<i32>) {\n     // CHECK-LABEL: define void @a\n     // CHECK: call void @__rust_dealloc\n-    // CHECK-NEXT: call void @foo\n+    // CHECK: call void @foo\n     let _a = A;\n     drop(a);\n }"}, {"sha": "bd8b79adf43b698dfa7b76866cee9b4cec2e6a7e", "filename": "src/test/codegen/issue-34947-pow-i32.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Fissue-34947-pow-i32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Fissue-34947-pow-i32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-34947-pow-i32.rs?ref=f71e0daa29b232d8f689f77fecb84dcb87fce6da", "patch": "@@ -6,8 +6,11 @@\n #[no_mangle]\n pub fn issue_34947(x: i32) -> i32 {\n     // CHECK: mul\n-    // CHECK-NEXT: mul\n-    // CHECK-NEXT: mul\n-    // CHECK-NEXT: ret\n+    // CHECK-NOT: br label\n+    // CHECK: mul\n+    // CHECK-NOT: br label\n+    // CHECK: mul\n+    // CHECK-NOT: br label\n+    // CHECK: ret\n     x.pow(5)\n }"}, {"sha": "894927c5c33512cc5129d31c6474c8cddfb9e307", "filename": "src/test/codegen/issue-45222.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Fissue-45222.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Fissue-45222.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-45222.rs?ref=f71e0daa29b232d8f689f77fecb84dcb87fce6da", "patch": "@@ -1,3 +1,9 @@\n+// ignore-test\n+\n+// FIXME:\n+// LLVM can't optimize some loops with a large number of iterations because of\n+// @llvm.sideeffect() (see also #59546)\n+\n // compile-flags: -O\n // ignore-debug: the debug assertions get in the way\n "}, {"sha": "fb683a49a8a809a6067db5b2c5d6a379585e7288", "filename": "src/test/codegen/naked-functions.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Fnaked-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Fnaked-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnaked-functions.rs?ref=f71e0daa29b232d8f689f77fecb84dcb87fce6da", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-linelength\n-\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n@@ -53,27 +51,27 @@ pub fn naked_with_args_and_return(a: isize) -> isize {\n #[naked]\n pub fn naked_recursive() {\n     // CHECK-NEXT: {{.+}}:\n-    // CHECK-NEXT: call void @naked_empty()\n+    // CHECK: call void @naked_empty()\n \n     // FIXME(#39685) Avoid one block per call.\n     // CHECK-NEXT: br label %bb1\n     // CHECK: bb1:\n \n     naked_empty();\n \n-    // CHECK-NEXT: %{{[0-9]+}} = call i{{[0-9]+}} @naked_with_return()\n+    // CHECK: %{{[0-9]+}} = call i{{[0-9]+}} @naked_with_return()\n \n     // FIXME(#39685) Avoid one block per call.\n     // CHECK-NEXT: br label %bb2\n     // CHECK: bb2:\n \n-    // CHECK-NEXT: %{{[0-9]+}} = call i{{[0-9]+}} @naked_with_args_and_return(i{{[0-9]+}} %{{[0-9]+}})\n+    // CHECK: %{{[0-9]+}} = call i{{[0-9]+}} @naked_with_args_and_return(i{{[0-9]+}} %{{[0-9]+}})\n \n     // FIXME(#39685) Avoid one block per call.\n     // CHECK-NEXT: br label %bb3\n     // CHECK: bb3:\n \n-    // CHECK-NEXT: call void @naked_with_args(i{{[0-9]+}} %{{[0-9]+}})\n+    // CHECK: call void @naked_with_args(i{{[0-9]+}} %{{[0-9]+}})\n \n     // FIXME(#39685) Avoid one block per call.\n     // CHECK-NEXT: br label %bb4"}, {"sha": "fa9c66b47c0a47d475233733bf2f7b69ba4fbd20", "filename": "src/test/codegen/non-terminate/infinite-loop-1.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-loop-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-loop-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-loop-1.rs?ref=f71e0daa29b232d8f689f77fecb84dcb87fce6da", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -C opt-level=3\n+\n+#![crate_type = \"lib\"]\n+\n+fn infinite_loop() -> u8 {\n+    loop {}\n+}\n+\n+// CHECK-LABEL: @test\n+#[no_mangle]\n+fn test() -> u8 {\n+    // CHECK-NOT: unreachable\n+    // CHECK: br label %{{.+}}\n+    // CHECK-NOT: unreachable\n+    let x = infinite_loop();\n+    x\n+}"}, {"sha": "81d62ab33d77855628ddb9e716fa3016ad91c118", "filename": "src/test/codegen/non-terminate/infinite-loop-2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-loop-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-loop-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-loop-2.rs?ref=f71e0daa29b232d8f689f77fecb84dcb87fce6da", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: -C opt-level=3\n+\n+#![crate_type = \"lib\"]\n+\n+fn infinite_loop() -> u8 {\n+    let i = 2;\n+    while i > 1 {}\n+    1\n+}\n+\n+// CHECK-LABEL: @test\n+#[no_mangle]\n+fn test() -> u8 {\n+    // CHECK-NOT: unreachable\n+    // CHECK: br label %{{.+}}\n+    // CHECK-NOT: unreachable\n+    let x = infinite_loop();\n+    x\n+}"}, {"sha": "6d1f2d4bf8f4ad5ab60c8de9a56ffb6028e11a93", "filename": "src/test/codegen/non-terminate/infinite-recursion.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-recursion.rs?ref=f71e0daa29b232d8f689f77fecb84dcb87fce6da", "patch": "@@ -0,0 +1,14 @@\n+// compile-flags: -C opt-level=3\n+\n+#![crate_type = \"lib\"]\n+\n+#![allow(unconditional_recursion)]\n+\n+// CHECK-LABEL: @infinite_recursion\n+#[no_mangle]\n+fn infinite_recursion() -> u8 {\n+    // CHECK-NOT: ret i8 undef\n+    // CHECK: br label %{{.+}}\n+    // CHECK-NOT: ret i8 undef\n+    infinite_recursion()\n+}"}, {"sha": "40399e8f76f016ef61428e0cc38cab9776a10b5a", "filename": "src/test/codegen/repeat-trusted-len.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Frepeat-trusted-len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Frepeat-trusted-len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frepeat-trusted-len.rs?ref=f71e0daa29b232d8f689f77fecb84dcb87fce6da", "patch": "@@ -14,6 +14,10 @@ pub fn helper(_: usize) {\n // CHECK-LABEL: @repeat_take_collect\n #[no_mangle]\n pub fn repeat_take_collect() -> Vec<u8> {\n-// CHECK: call void @llvm.memset.p0i8.[[USIZE]](i8* {{(nonnull )?}}align 1 %{{[0-9]+}}, i8 42, [[USIZE]] 100000, i1 false)\n+// FIXME: At the time of writing LLVM transforms this loop into a single\n+// `store` and then a `memset` with size = 99999. The correct check should be:\n+//        call void @llvm.memset.p0i8.[[USIZE]](i8* {{(nonnull )?}}align 1 %{{[a-z0-9.]+}}, i8 42, [[USIZE]] 100000, i1 false)\n+\n+// CHECK: call void @llvm.memset.p0i8.[[USIZE]](i8* {{(nonnull )?}}align 1 %{{[a-z0-9.]+}}, i8 42, [[USIZE]] 99999, i1 false)\n     iter::repeat(42).take(100000).collect()\n }"}, {"sha": "22e1248907a76b44ee353660fb48f32b785f2f11", "filename": "src/test/codegen/vec-clear.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Fvec-clear.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Fvec-clear.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fvec-clear.rs?ref=f71e0daa29b232d8f689f77fecb84dcb87fce6da", "patch": "@@ -1,3 +1,9 @@\n+// ignore-test\n+\n+// FIXME:\n+// LLVM can't optimize some loops with unknown number of iterations because of\n+// @llvm.sideeffect() (see also #59546)\n+\n // ignore-debug: the debug assertions get in the way\n // compile-flags: -O\n "}, {"sha": "893d1b50a4a9781cc9d4848b6708a6895a45bae4", "filename": "src/test/codegen/vec-iter-collect-len.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Fvec-iter-collect-len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Fvec-iter-collect-len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fvec-iter-collect-len.rs?ref=f71e0daa29b232d8f689f77fecb84dcb87fce6da", "patch": "@@ -5,8 +5,6 @@\n \n #[no_mangle]\n pub fn get_len() -> usize {\n-    // CHECK-LABEL: @get_len\n-    // CHECK-NOT: call\n-    // CHECK-NOT: invoke\n+    // CHECK-COUNT-1: {{^define}}\n     [1, 2, 3].iter().collect::<Vec<_>>().len()\n }"}, {"sha": "08d0332651cb78495c259b3fa75759ee776a2802", "filename": "src/test/codegen/vec-optimizes-away.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Fvec-optimizes-away.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Fcodegen%2Fvec-optimizes-away.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fvec-optimizes-away.rs?ref=f71e0daa29b232d8f689f77fecb84dcb87fce6da", "patch": "@@ -8,6 +8,6 @@\n pub fn sum_me() -> i32 {\n     // CHECK-LABEL: @sum_me\n     // CHECK-NEXT: {{^.*:$}}\n-    // CHECK-NEXT: ret i32 6\n+    // CHECK: ret i32 6\n     vec![1, 2, 3].iter().sum::<i32>()\n }"}, {"sha": "fd09df78ffa8d790c3ec063e90b5674f8c8621b7", "filename": "src/test/run-make-fulldeps/inline-always-many-cgu/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Frun-make-fulldeps%2Finline-always-many-cgu%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/f71e0daa29b232d8f689f77fecb84dcb87fce6da/src%2Ftest%2Frun-make-fulldeps%2Finline-always-many-cgu%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Finline-always-many-cgu%2FMakefile?ref=f71e0daa29b232d8f689f77fecb84dcb87fce6da", "patch": "@@ -2,7 +2,7 @@\n \n all:\n \t$(RUSTC) foo.rs --emit llvm-ir -C codegen-units=2\n-\tif cat $(TMPDIR)/*.ll | $(CGREP) -e '\\bcall\\b'; then \\\n+\tif cat $(TMPDIR)/*.ll | grep -v 'call void @llvm.sideeffect()' | $(CGREP) -e '\\bcall\\b'; then \\\n \t\techo \"found call instruction when one wasn't expected\"; \\\n \t\texit 1; \\\n \tfi"}]}