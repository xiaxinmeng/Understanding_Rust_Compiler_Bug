{"sha": "c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyYmU5MWVkZTBhNmYxY2JkYTNjMTQ0ODhjOTNhYmU2YzdlZTVmOWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-05T20:02:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-05T20:02:02Z"}, "message": "Auto merge of #28847 - Ms2ger:typos, r=steveklabnik", "tree": {"sha": "fafcffdb44456ab417f1a0bfcfa15102d30222cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fafcffdb44456ab417f1a0bfcfa15102d30222cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c", "html_url": "https://github.com/rust-lang/rust/commit/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be96988cf89b116e93e2e6db87c92400809c78a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/be96988cf89b116e93e2e6db87c92400809c78a3", "html_url": "https://github.com/rust-lang/rust/commit/be96988cf89b116e93e2e6db87c92400809c78a3"}, {"sha": "6b5349a45effa1e0da35f9ae937c83e9d32c2618", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b5349a45effa1e0da35f9ae937c83e9d32c2618", "html_url": "https://github.com/rust-lang/rust/commit/6b5349a45effa1e0da35f9ae937c83e9d32c2618"}], "stats": {"total": 34, "additions": 17, "deletions": 17}, "files": [{"sha": "1feb085ba52e630dbf0109fbaaf9202f1ca95872", "filename": "src/doc/nomicon/destructors.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c/src%2Fdoc%2Fnomicon%2Fdestructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c/src%2Fdoc%2Fnomicon%2Fdestructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fdestructors.md?ref=c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c", "patch": "@@ -17,7 +17,7 @@ boilerplate\" to drop children. If a struct has no special logic for being\n dropped other than dropping its children, then it means `Drop` doesn't need to\n be implemented at all!\n \n-**There is no stable way to prevent this behaviour in Rust 1.0.**\n+**There is no stable way to prevent this behavior in Rust 1.0.**\n \n Note that taking `&mut self` means that even if you could suppress recursive\n Drop, Rust will prevent you from e.g. moving fields out of self. For most types,\n@@ -101,7 +101,7 @@ After we deallocate the `box`'s ptr in SuperBox's destructor, Rust will\n happily proceed to tell the box to Drop itself and everything will blow up with\n use-after-frees and double-frees.\n \n-Note that the recursive drop behaviour applies to all structs and enums\n+Note that the recursive drop behavior applies to all structs and enums\n regardless of whether they implement Drop. Therefore something like\n \n ```rust"}, {"sha": "cfceafe1bdf23ec4294224720c13bc98bece967c", "filename": "src/doc/nomicon/drop-flags.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c/src%2Fdoc%2Fnomicon%2Fdrop-flags.md", "raw_url": "https://github.com/rust-lang/rust/raw/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c/src%2Fdoc%2Fnomicon%2Fdrop-flags.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fdrop-flags.md?ref=c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c", "patch": "@@ -40,7 +40,7 @@ y = x;                   // y was init; Drop y, overwrite it, and make x uninit!\n                          // x goes out of scope; x was uninit; do nothing.\n ```\n \n-Similarly, branched code where all branches have the same behaviour with respect\n+Similarly, branched code where all branches have the same behavior with respect\n to initialization has static drop semantics:\n \n ```rust"}, {"sha": "445349b406593681f90e40bd4f24e514a0a50487", "filename": "src/doc/nomicon/leaking.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c/src%2Fdoc%2Fnomicon%2Fleaking.md", "raw_url": "https://github.com/rust-lang/rust/raw/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c/src%2Fdoc%2Fnomicon%2Fleaking.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fleaking.md?ref=c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c", "patch": "@@ -93,13 +93,13 @@ println!(\"{}\", vec[0]);\n This is pretty clearly Not Good. Unfortunately, we're kind've stuck between a\n rock and a hard place: maintaining consistent state at every step has an\n enormous cost (and would negate any benefits of the API). Failing to maintain\n-consistent state gives us Undefined Behaviour in safe code (making the API\n+consistent state gives us Undefined Behavior in safe code (making the API\n unsound).\n \n So what can we do? Well, we can pick a trivially consistent state: set the Vec's\n len to be 0 when we start the iteration, and fix it up if necessary in the\n destructor. That way, if everything executes like normal we get the desired\n-behaviour with minimal overhead. But if someone has the *audacity* to\n+behavior with minimal overhead. But if someone has the *audacity* to\n mem::forget us in the middle of the iteration, all that does is *leak even more*\n (and possibly leave the Vec in an unexpected but otherwise consistent state).\n Since we've accepted that mem::forget is safe, this is definitely safe. We call"}, {"sha": "e361fbb7ae868ecaa668da896110d076b9de68e5", "filename": "src/doc/nomicon/other-reprs.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c/src%2Fdoc%2Fnomicon%2Fother-reprs.md", "raw_url": "https://github.com/rust-lang/rust/raw/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c/src%2Fdoc%2Fnomicon%2Fother-reprs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fother-reprs.md?ref=c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c", "patch": "@@ -19,8 +19,8 @@ kept in mind. Due to its dual purpose as \"for FFI\" and \"for layout control\",\n `repr(C)` can be applied to types that will be nonsensical or problematic if\n passed through the FFI boundary.\n \n-* ZSTs are still zero-sized, even though this is not a standard behaviour in\n-C, and is explicitly contrary to the behaviour of an empty type in C++, which\n+* ZSTs are still zero-sized, even though this is not a standard behavior in\n+C, and is explicitly contrary to the behavior of an empty type in C++, which\n still consumes a byte of space.\n \n * DSTs, tuples, and tagged unions are not a concept in C and as such are never\n@@ -65,7 +65,7 @@ compiler might be able to paper over alignment issues with shifts and masks.\n However if you take a reference to a packed field, it's unlikely that the\n compiler will be able to emit code to avoid an unaligned load.\n \n-**[As of Rust 1.0 this can cause undefined behaviour.][ub loads]**\n+**[As of Rust 1.0 this can cause undefined behavior.][ub loads]**\n \n `repr(packed)` is not to be used lightly. Unless you have extreme requirements,\n this should not be used."}, {"sha": "effeaf872bbeef5dbc932e3c8ec2ea8a56a44676", "filename": "src/doc/nomicon/repr-rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c/src%2Fdoc%2Fnomicon%2Frepr-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c/src%2Fdoc%2Fnomicon%2Frepr-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Frepr-rust.md?ref=c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c", "patch": "@@ -6,7 +6,7 @@ value of alignment `n` must only be stored at an address that is a multiple of\n `n`. So alignment 2 means you must be stored at an even address, and 1 means\n that you can be stored anywhere. Alignment is at least 1, and always a power of\n 2. Most primitives are generally aligned to their size, although this is\n-platform-specific behaviour. In particular, on x86 `u64` and `f64` may be only\n+platform-specific behavior. In particular, on x86 `u64` and `f64` may be only\n aligned to 32 bits.\n \n A type's size must always be a multiple of its alignment. This ensures that an"}, {"sha": "9b1abf383f7175003f2997cda1d11713355e5669", "filename": "src/doc/nomicon/vec-zsts.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c/src%2Fdoc%2Fnomicon%2Fvec-zsts.md", "raw_url": "https://github.com/rust-lang/rust/raw/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c/src%2Fdoc%2Fnomicon%2Fvec-zsts.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fvec-zsts.md?ref=c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c", "patch": "@@ -5,7 +5,7 @@ It's time. We're going to fight the spectre that is zero-sized types. Safe Rust\n raw allocations, which are exactly the two things that care about\n zero-sized types. We need to be careful of two things:\n \n-* The raw allocator API has undefined behaviour if you pass in 0 for an\n+* The raw allocator API has undefined behavior if you pass in 0 for an\n   allocation size.\n * raw pointer offsets are no-ops for zero-sized types, which will break our\n   C-style pointer iterator."}, {"sha": "face6d629340db1aaf6aef013984b1f38828c870", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c", "patch": "@@ -10,7 +10,7 @@\n \n //! This file handles the relationships between free regions --\n //! meaning lifetime parameters. Ordinarily, free regions are\n-//! unrelated to one another, but they can be related vai implied or\n+//! unrelated to one another, but they can be related via implied or\n //! explicit bounds.  In that case, we track the bounds using the\n //! `TransitiveRelation` type and use that to decide when one free\n //! region outlives another and so forth."}, {"sha": "18f2dd6dc6ec020e530b6257458c531feb160180", "filename": "src/librustc_mir/hair.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c/src%2Flibrustc_mir%2Fhair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c/src%2Flibrustc_mir%2Fhair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair.rs?ref=c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c", "patch": "@@ -56,7 +56,7 @@ pub trait Hair: Sized+Debug+Clone+Eq+Hash { // (*)\n     /// Returns the type `usize`.\n     fn usize_ty(&mut self) -> Self::Ty;\n \n-    /// Returns the literal for `true`\n+    /// Returns the literal for `value` as a `usize`.\n     fn usize_literal(&mut self, value: usize) -> Literal<Self>;\n \n     /// Returns the type `bool`.\n@@ -65,7 +65,7 @@ pub trait Hair: Sized+Debug+Clone+Eq+Hash { // (*)\n     /// Returns the literal for `true`\n     fn true_literal(&mut self) -> Literal<Self>;\n \n-    /// Returns the literal for `true`\n+    /// Returns the literal for `false`\n     fn false_literal(&mut self) -> Literal<Self>;\n \n     /// Returns a reference to `PartialEq::<T,T>::eq`"}, {"sha": "8408e9c0c70e7c532d7af27e93d7b93aa6a876d1", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=c2be91ede0a6f1cbda3c14488c93abe6c7ee5f9c", "patch": "@@ -1819,7 +1819,7 @@ fn bar(foo: Foo) -> u32 {\n }\n ```\n \n-Try using `{}` isntead:\n+Try using `{}` instead:\n \n ```\n fn bar(foo: Foo) -> u32 {\n@@ -2010,8 +2010,8 @@ wrapped type `T` implements `Clone`. The `where` clause is important because\n some types will not implement `Clone`, and thus will not get this method.\n \n In our erroneous example, however, we're referencing a single concrete type.\n-Since we know for certain that Wrapper<u32> implements Clone, there's no reason\n-to also specify it in a `where` clause.\n+Since we know for certain that `Wrapper<u32>` implements `Clone`, there's no\n+reason to also specify it in a `where` clause.\n \"##,\n \n E0194: r##\"\n@@ -2581,7 +2581,7 @@ In this example, we're attempting to take a type of `Foo::Bar` in the\n do_something function. This is not legal: `Foo::Bar` is a value of type `Foo`,\n not a distinct static type. Likewise, it's not legal to attempt to\n `impl Foo::Bar`: instead, you must `impl Foo` and then pattern match to specify\n-behaviour for specific enum variants.\n+behavior for specific enum variants.\n \"##,\n \n E0249: r##\""}]}