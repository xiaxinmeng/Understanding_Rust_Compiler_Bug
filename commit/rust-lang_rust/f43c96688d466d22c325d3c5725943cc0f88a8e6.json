{"sha": "f43c96688d466d22c325d3c5725943cc0f88a8e6", "node_id": "C_kwDOAAsO6NoAKGY0M2M5NjY4OGQ0NjZkMjJjMzI1ZDNjNTcyNTk0M2NjMGY4OGE4ZTY", "commit": {"author": {"name": "Caleb Cartwright", "email": "caleb.cartwright@outlook.com", "date": "2022-06-23T00:28:27Z"}, "committer": {"name": "Caleb Cartwright", "email": "caleb.cartwright@outlook.com", "date": "2022-06-23T00:28:27Z"}, "message": "Merge remote-tracking branch 'upstream/master' into subtree-sync-2022-06-22", "tree": {"sha": "5a599169fb541089cef32e1f53a7cd8e4199a6c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a599169fb541089cef32e1f53a7cd8e4199a6c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f43c96688d466d22c325d3c5725943cc0f88a8e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f43c96688d466d22c325d3c5725943cc0f88a8e6", "html_url": "https://github.com/rust-lang/rust/commit/f43c96688d466d22c325d3c5725943cc0f88a8e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f43c96688d466d22c325d3c5725943cc0f88a8e6/comments", "author": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac2b7a261c94d2d7d718bede54fc93c7f2fdd641", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac2b7a261c94d2d7d718bede54fc93c7f2fdd641", "html_url": "https://github.com/rust-lang/rust/commit/ac2b7a261c94d2d7d718bede54fc93c7f2fdd641"}, {"sha": "08105e80b7c48782cfd7acbf3695c7f14c839cfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/08105e80b7c48782cfd7acbf3695c7f14c839cfd", "html_url": "https://github.com/rust-lang/rust/commit/08105e80b7c48782cfd7acbf3695c7f14c839cfd"}], "stats": {"total": 677, "additions": 502, "deletions": 175}, "files": [{"sha": "bce9b0c8d5a95ed1659c4906be6647d20369babe", "filename": ".github/workflows/linux.yml", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/.github%2Fworkflows%2Flinux.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/.github%2Fworkflows%2Flinux.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Flinux.yml?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -35,15 +35,5 @@ jobs:\n         sh rustup-init.sh -y --default-toolchain none\n         rustup target add ${{ matrix.target }}\n \n-    - name: build\n-      run: |\n-        rustc -Vv\n-        cargo -V\n-        cargo build\n-      env:\n-        RUSTFLAGS: '-D warnings'\n-\n-    - name: test\n-      run: cargo test\n-      env:\n-        RUSTFLAGS: '-D warnings'\n+    - name: Build and Test\n+      run: ./ci/build_and_test.sh"}, {"sha": "89a980c42c5a09cbc17d600ad31099726832e4c4", "filename": ".github/workflows/mac.yml", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/.github%2Fworkflows%2Fmac.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/.github%2Fworkflows%2Fmac.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fmac.yml?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -32,11 +32,5 @@ jobs:\n         sh rustup-init.sh -y --default-toolchain none\n         rustup target add ${{ matrix.target }}\n \n-    - name: build\n-      run: |\n-        rustc -Vv\n-        cargo -V\n-        cargo build\n-\n-    - name: test\n-      run: cargo test\n+    - name: Build and Test\n+      run: ./ci/build_and_test.sh"}, {"sha": "ec37c714b085106d0fbbbe9d65ff9c5ed2f44159", "filename": ".github/workflows/windows.yml", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/.github%2Fworkflows%2Fwindows.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/.github%2Fworkflows%2Fwindows.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fwindows.yml?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -57,13 +57,6 @@ jobs:\n       if: matrix.target == 'x86_64-pc-windows-gnu' && matrix.channel == 'nightly'\n       shell: bash\n \n-    - name: build\n-      run: |\n-        rustc -Vv\n-        cargo -V\n-        cargo build\n-      shell: cmd\n-\n-    - name: test\n-      run: cargo test\n+    - name: Build and Test\n       shell: cmd\n+      run: ci\\build_and_test.bat"}, {"sha": "4f5127e1de2abc1b5baafe59c9634da9560af225", "filename": "Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -65,3 +65,7 @@ rustfmt-config_proc_macro = { version = \"0.2\", path = \"config_proc_macro\" }\n rustc-workspace-hack = \"1.0.0\"\n \n # Rustc dependencies are loaded from the sysroot, Cargo doesn't know about them.\n+\n+[package.metadata.rust-analyzer]\n+# This package uses #[feature(rustc_private)]\n+rustc_private = true"}, {"sha": "8b96b9d36892ae0494b72aeef42f409f34597e88", "filename": "Configurations.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/Configurations.md", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/Configurations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Configurations.md?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -926,6 +926,14 @@ fn add_one(x: i32) -> i32 {\n }\n ```\n \n+## `doc_comment_code_block_width`\n+\n+Max width for code snippets included in doc comments. Only used if [`format_code_in_doc_comments`](#format_code_in_doc_comments) is true.\n+\n+- **Default value**: `100`\n+- **Possible values**: any positive integer that is less than or equal to the value specified for [`max_width`](#max_width)\n+- **Stable**: No (tracking issue: [#5359](https://github.com/rust-lang/rustfmt/issues/5359))\n+\n ## `format_generated_files`\n \n Format generated files. A file is considered generated"}, {"sha": "ef41017783feb6e44f576f3bc3e58b8a8bdfa1c3", "filename": "ci/build_and_test.bat", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/ci%2Fbuild_and_test.bat", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/ci%2Fbuild_and_test.bat", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ci%2Fbuild_and_test.bat?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -0,0 +1,14 @@\n+set \"RUSTFLAGS=-D warnings\"\n+\n+:: Print version information\n+rustc -Vv || exit /b 1\n+cargo -V || exit /b 1\n+\n+:: Build and test main crate\n+cargo build --locked || exit /b 1\n+cargo test || exit /b 1\n+\n+:: Build and test other crates\n+cd config_proc_macro || exit /b 1\n+cargo build --locked || exit /b 1\n+cargo test || exit /b 1"}, {"sha": "8fa0f67b0d02184e63d299bfcf0befb7ee82ce9a", "filename": "ci/build_and_test.sh", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/ci%2Fbuild_and_test.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/ci%2Fbuild_and_test.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ci%2Fbuild_and_test.sh?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -0,0 +1,18 @@\n+#!/bin/bash\n+\n+set -euo pipefail\n+\n+export RUSTFLAGS=\"-D warnings\"\n+\n+# Print version information\n+rustc -Vv\n+cargo -V\n+\n+# Build and test main crate\n+cargo build --locked\n+cargo test\n+\n+# Build and test other crates\n+cd config_proc_macro\n+cargo build --locked\n+cargo test"}, {"sha": "562d5d70c70ba63a5dbfcfc3d4709897efed615a", "filename": "ci/integration.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/ci%2Fintegration.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/ci%2Fintegration.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ci%2Fintegration.sh?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -15,7 +15,7 @@ set -ex\n # it again.\n #\n #which cargo-fmt || cargo install --force\n-CFG_RELEASE=nightly CFG_RELEASE_CHANNEL=nightly cargo install --path . --force\n+CFG_RELEASE=nightly CFG_RELEASE_CHANNEL=nightly cargo install --path . --force --locked\n \n echo \"Integration tests for: ${INTEGRATION}\"\n cargo fmt -- --version"}, {"sha": "ecf561f28fb6aa5e64cffedfdefd2a146e61b1d5", "filename": "config_proc_macro/Cargo.lock", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/config_proc_macro%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/config_proc_macro%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2FCargo.lock?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -1,68 +1,68 @@\n # This file is automatically @generated by Cargo.\n # It is not intended for manual editing.\n+version = 3\n+\n [[package]]\n name = \"proc-macro2\"\n version = \"1.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e98a83a9f9b331f54b924e68a66acb1bb35cb01fb0a23645139967abefb697e8\"\n dependencies = [\n- \"unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-xid\",\n ]\n \n [[package]]\n name = \"quote\"\n version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"053a8c8bcc71fcce321828dc897a98ab9760bef03a4fc36693c231e5b3216cfe\"\n dependencies = [\n- \"proc-macro2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2\",\n ]\n \n [[package]]\n name = \"rustfmt-config_proc_macro\"\n-version = \"0.1.2\"\n+version = \"0.2.0\"\n dependencies = [\n- \"proc-macro2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.99 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"serde\",\n+ \"syn\",\n ]\n \n [[package]]\n name = \"serde\"\n version = \"1.0.99\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fec2851eb56d010dc9a21b89ca53ee75e6528bab60c11e89d38390904982da9f\"\n dependencies = [\n- \"serde_derive 1.0.99 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n version = \"1.0.99\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cb4dc18c61206b08dc98216c98faa0232f4337e1e1b8574551d5bad29ea1b425\"\n dependencies = [\n- \"proc-macro2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n name = \"syn\"\n version = \"1.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"66850e97125af79138385e9b88339cbcd037e3f28ceab8c5ad98e64f0f1f80bf\"\n dependencies = [\n- \"proc-macro2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"unicode-xid\",\n ]\n \n [[package]]\n name = \"unicode-xid\"\n version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[metadata]\n-\"checksum proc-macro2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e98a83a9f9b331f54b924e68a66acb1bb35cb01fb0a23645139967abefb697e8\"\n-\"checksum quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"053a8c8bcc71fcce321828dc897a98ab9760bef03a4fc36693c231e5b3216cfe\"\n-\"checksum serde 1.0.99 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fec2851eb56d010dc9a21b89ca53ee75e6528bab60c11e89d38390904982da9f\"\n-\"checksum serde_derive 1.0.99 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cb4dc18c61206b08dc98216c98faa0232f4337e1e1b8574551d5bad29ea1b425\"\n-\"checksum syn 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"66850e97125af79138385e9b88339cbcd037e3f28ceab8c5ad98e64f0f1f80bf\"\n-\"checksum unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"826e7639553986605ec5979c7dd957c7895e93eabed50ab2ffa7f6128a75097c\"\n+checksum = \"826e7639553986605ec5979c7dd957c7895e93eabed50ab2ffa7f6128a75097c\""}, {"sha": "e772c53f42361f94131e0e67294b107ae532a0cd", "filename": "config_proc_macro/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/config_proc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/config_proc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2Fsrc%2Flib.rs?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -29,6 +29,8 @@ pub fn config_type(_args: TokenStream, input: TokenStream) -> TokenStream {\n /// Used to conditionally output the TokenStream for tests that need to be run on nightly only.\n ///\n /// ```rust\n+/// # use rustfmt_config_proc_macro::nightly_only_test;\n+///\n /// #[nightly_only_test]\n /// #[test]\n /// fn test_needs_nightly_rustfmt() {\n@@ -49,6 +51,8 @@ pub fn nightly_only_test(_args: TokenStream, input: TokenStream) -> TokenStream\n /// Used to conditionally output the TokenStream for tests that need to be run on stable only.\n ///\n /// ```rust\n+/// # use rustfmt_config_proc_macro::stable_only_test;\n+///\n /// #[stable_only_test]\n /// #[test]\n /// fn test_needs_stable_rustfmt() {"}, {"sha": "9031d29b45f7ff3e7b3f3a4c0b58a8a465ae9ebf", "filename": "src/cargo-fmt/main.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/src%2Fcargo-fmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/src%2Fcargo-fmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo-fmt%2Fmain.rs?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -14,14 +14,15 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::str;\n \n-use clap::{CommandFactory, Parser};\n+use clap::{AppSettings, CommandFactory, Parser};\n \n #[path = \"test/mod.rs\"]\n #[cfg(test)]\n mod cargo_fmt_tests;\n \n #[derive(Parser)]\n #[clap(\n+    global_setting(AppSettings::NoAutoVersion),\n     bin_name = \"cargo fmt\",\n     about = \"This utility formats all bin and lib files of \\\n              the current crate using rustfmt.\""}, {"sha": "4d565afc1e0266c7544f2a5be85912856c26cd98", "filename": "src/comment.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -730,6 +730,10 @@ impl<'a> CommentRewrite<'a> {\n                     {\n                         let mut config = self.fmt.config.clone();\n                         config.set().wrap_comments(false);\n+                        let comment_max_width = config\n+                            .doc_comment_code_block_width()\n+                            .min(config.max_width());\n+                        config.set().max_width(comment_max_width);\n                         if let Some(s) =\n                             crate::format_code_block(&self.code_block_buffer, &config, false)\n                         {"}, {"sha": "f49c18d3a4603a9804168664629c314181d7838f", "filename": "src/config/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/src%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/src%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fmod.rs?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -57,6 +57,8 @@ create_config! {\n     // Comments. macros, and strings\n     wrap_comments: bool, false, false, \"Break comments to fit on the line\";\n     format_code_in_doc_comments: bool, false, false, \"Format the code snippet in doc comments.\";\n+    doc_comment_code_block_width: usize, 100, false, \"Maximum width for code snippets in doc \\\n+        comments. No effect unless format_code_in_doc_comments = true\";\n     comment_width: usize, 80, false,\n         \"Maximum length of comments. No effect unless wrap_comments = true\";\n     normalize_comments: bool, false, false, \"Convert /* */ comments to // comments where possible\";\n@@ -532,6 +534,7 @@ chain_width = 60\n single_line_if_else_max_width = 50\n wrap_comments = false\n format_code_in_doc_comments = false\n+doc_comment_code_block_width = 100\n comment_width = 80\n normalize_comments = false\n normalize_doc_attributes = false"}, {"sha": "8d41c881589e5564c97fd3220a4c72b1ff0b63d0", "filename": "src/imports.rs", "status": "modified", "additions": 227, "deletions": 116, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -15,7 +15,7 @@ use rustc_span::{\n use crate::comment::combine_strs_with_missing_comments;\n use crate::config::lists::*;\n use crate::config::ImportGranularity;\n-use crate::config::{Edition, IndentStyle};\n+use crate::config::{Edition, IndentStyle, Version};\n use crate::lists::{\n     definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator,\n };\n@@ -92,7 +92,7 @@ impl<'a> FmtVisitor<'a> {\n \n // FIXME we do a lot of allocation to make our own representation.\n #[derive(Clone, Eq, Hash, PartialEq)]\n-pub(crate) enum UseSegment {\n+pub(crate) enum UseSegmentKind {\n     Ident(String, Option<String>),\n     Slf(Option<String>),\n     Super(Option<String>),\n@@ -101,6 +101,12 @@ pub(crate) enum UseSegment {\n     List(Vec<UseTree>),\n }\n \n+#[derive(Clone, Eq, PartialEq)]\n+pub(crate) struct UseSegment {\n+    pub(crate) kind: UseSegmentKind,\n+    pub(crate) version: Version,\n+}\n+\n #[derive(Clone)]\n pub(crate) struct UseTree {\n     pub(crate) path: Vec<UseSegment>,\n@@ -134,34 +140,38 @@ impl Spanned for UseTree {\n impl UseSegment {\n     // Clone a version of self with any top-level alias removed.\n     fn remove_alias(&self) -> UseSegment {\n-        match *self {\n-            UseSegment::Ident(ref s, _) => UseSegment::Ident(s.clone(), None),\n-            UseSegment::Slf(_) => UseSegment::Slf(None),\n-            UseSegment::Super(_) => UseSegment::Super(None),\n-            UseSegment::Crate(_) => UseSegment::Crate(None),\n-            _ => self.clone(),\n+        let kind = match self.kind {\n+            UseSegmentKind::Ident(ref s, _) => UseSegmentKind::Ident(s.clone(), None),\n+            UseSegmentKind::Slf(_) => UseSegmentKind::Slf(None),\n+            UseSegmentKind::Super(_) => UseSegmentKind::Super(None),\n+            UseSegmentKind::Crate(_) => UseSegmentKind::Crate(None),\n+            _ => return self.clone(),\n+        };\n+        UseSegment {\n+            kind,\n+            version: self.version,\n         }\n     }\n \n     // Check if self == other with their aliases removed.\n     fn equal_except_alias(&self, other: &Self) -> bool {\n-        match (self, other) {\n-            (UseSegment::Ident(ref s1, _), UseSegment::Ident(ref s2, _)) => s1 == s2,\n-            (UseSegment::Slf(_), UseSegment::Slf(_))\n-            | (UseSegment::Super(_), UseSegment::Super(_))\n-            | (UseSegment::Crate(_), UseSegment::Crate(_))\n-            | (UseSegment::Glob, UseSegment::Glob) => true,\n-            (UseSegment::List(ref list1), UseSegment::List(ref list2)) => list1 == list2,\n+        match (&self.kind, &other.kind) {\n+            (UseSegmentKind::Ident(ref s1, _), UseSegmentKind::Ident(ref s2, _)) => s1 == s2,\n+            (UseSegmentKind::Slf(_), UseSegmentKind::Slf(_))\n+            | (UseSegmentKind::Super(_), UseSegmentKind::Super(_))\n+            | (UseSegmentKind::Crate(_), UseSegmentKind::Crate(_))\n+            | (UseSegmentKind::Glob, UseSegmentKind::Glob) => true,\n+            (UseSegmentKind::List(ref list1), UseSegmentKind::List(ref list2)) => list1 == list2,\n             _ => false,\n         }\n     }\n \n     fn get_alias(&self) -> Option<&str> {\n-        match self {\n-            UseSegment::Ident(_, a)\n-            | UseSegment::Slf(a)\n-            | UseSegment::Super(a)\n-            | UseSegment::Crate(a) => a.as_deref(),\n+        match &self.kind {\n+            UseSegmentKind::Ident(_, a)\n+            | UseSegmentKind::Slf(a)\n+            | UseSegmentKind::Super(a)\n+            | UseSegmentKind::Crate(a) => a.as_deref(),\n             _ => None,\n         }\n     }\n@@ -175,19 +185,24 @@ impl UseSegment {\n         if name.is_empty() || name == \"{{root}}\" {\n             return None;\n         }\n-        Some(match name {\n-            \"self\" => UseSegment::Slf(None),\n-            \"super\" => UseSegment::Super(None),\n-            \"crate\" => UseSegment::Crate(None),\n+        let kind = match name {\n+            \"self\" => UseSegmentKind::Slf(None),\n+            \"super\" => UseSegmentKind::Super(None),\n+            \"crate\" => UseSegmentKind::Crate(None),\n             _ => {\n                 let mod_sep = if modsep { \"::\" } else { \"\" };\n-                UseSegment::Ident(format!(\"{}{}\", mod_sep, name), None)\n+                UseSegmentKind::Ident(format!(\"{}{}\", mod_sep, name), None)\n             }\n+        };\n+\n+        Some(UseSegment {\n+            kind,\n+            version: context.config.version(),\n         })\n     }\n \n     fn contains_comment(&self) -> bool {\n-        if let UseSegment::List(list) = self {\n+        if let UseSegmentKind::List(list) = &self.kind {\n             list.iter().any(|subtree| subtree.contains_comment())\n         } else {\n             false\n@@ -254,20 +269,38 @@ impl fmt::Debug for UseTree {\n \n impl fmt::Debug for UseSegment {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n+        fmt::Display::fmt(&self.kind, f)\n     }\n }\n \n impl fmt::Display for UseSegment {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(&self.kind, f)\n+    }\n+}\n+\n+impl Hash for UseSegment {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.kind.hash(state);\n+    }\n+}\n+\n+impl fmt::Debug for UseSegmentKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Display for UseSegmentKind {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            UseSegment::Glob => write!(f, \"*\"),\n-            UseSegment::Ident(ref s, Some(ref alias)) => write!(f, \"{} as {}\", s, alias),\n-            UseSegment::Ident(ref s, None) => write!(f, \"{}\", s),\n-            UseSegment::Slf(..) => write!(f, \"self\"),\n-            UseSegment::Super(..) => write!(f, \"super\"),\n-            UseSegment::Crate(..) => write!(f, \"crate\"),\n-            UseSegment::List(ref list) => {\n+            UseSegmentKind::Glob => write!(f, \"*\"),\n+            UseSegmentKind::Ident(ref s, Some(ref alias)) => write!(f, \"{} as {}\", s, alias),\n+            UseSegmentKind::Ident(ref s, None) => write!(f, \"{}\", s),\n+            UseSegmentKind::Slf(..) => write!(f, \"self\"),\n+            UseSegmentKind::Super(..) => write!(f, \"super\"),\n+            UseSegmentKind::Crate(..) => write!(f, \"crate\"),\n+            UseSegmentKind::List(ref list) => {\n                 write!(f, \"{{\")?;\n                 for (i, item) in list.iter().enumerate() {\n                     if i != 0 {\n@@ -411,13 +444,19 @@ impl UseTree {\n             }\n         }\n \n+        let version = context.config.version();\n+\n         match a.kind {\n             UseTreeKind::Glob => {\n                 // in case of a global path and the glob starts at the root, e.g., \"::*\"\n                 if a.prefix.segments.len() == 1 && leading_modsep {\n-                    result.path.push(UseSegment::Ident(\"\".to_owned(), None));\n+                    let kind = UseSegmentKind::Ident(\"\".to_owned(), None);\n+                    result.path.push(UseSegment { kind, version });\n                 }\n-                result.path.push(UseSegment::Glob);\n+                result.path.push(UseSegment {\n+                    kind: UseSegmentKind::Glob,\n+                    version,\n+                });\n             }\n             UseTreeKind::Nested(ref list) => {\n                 // Extract comments between nested use items.\n@@ -438,16 +477,18 @@ impl UseTree {\n                 // in case of a global path and the nested list starts at the root,\n                 // e.g., \"::{foo, bar}\"\n                 if a.prefix.segments.len() == 1 && leading_modsep {\n-                    result.path.push(UseSegment::Ident(\"\".to_owned(), None));\n+                    let kind = UseSegmentKind::Ident(\"\".to_owned(), None);\n+                    result.path.push(UseSegment { kind, version });\n                 }\n-                result.path.push(UseSegment::List(\n+                let kind = UseSegmentKind::List(\n                     list.iter()\n                         .zip(items)\n                         .map(|(t, list_item)| {\n                             Self::from_ast(context, &t.0, Some(list_item), None, None, None)\n                         })\n                         .collect(),\n-                ));\n+                );\n+                result.path.push(UseSegment { kind, version });\n             }\n             UseTreeKind::Simple(ref rename, ..) => {\n                 // If the path has leading double colons and is composed of only 2 segments, then we\n@@ -469,13 +510,15 @@ impl UseTree {\n                         Some(rewrite_ident(context, ident).to_owned())\n                     }\n                 });\n-                let segment = match name.as_ref() {\n-                    \"self\" => UseSegment::Slf(alias),\n-                    \"super\" => UseSegment::Super(alias),\n-                    \"crate\" => UseSegment::Crate(alias),\n-                    _ => UseSegment::Ident(name, alias),\n+                let kind = match name.as_ref() {\n+                    \"self\" => UseSegmentKind::Slf(alias),\n+                    \"super\" => UseSegmentKind::Super(alias),\n+                    \"crate\" => UseSegmentKind::Crate(alias),\n+                    _ => UseSegmentKind::Ident(name, alias),\n                 };\n \n+                let segment = UseSegment { kind, version };\n+\n                 // `name` is already in result.\n                 result.path.pop();\n                 result.path.push(segment);\n@@ -492,39 +535,46 @@ impl UseTree {\n         let mut aliased_self = false;\n \n         // Remove foo::{} or self without attributes.\n-        match last {\n+        match last.kind {\n             _ if self.attrs.is_some() => (),\n-            UseSegment::List(ref list) if list.is_empty() => {\n+            UseSegmentKind::List(ref list) if list.is_empty() => {\n                 self.path = vec![];\n                 return self;\n             }\n-            UseSegment::Slf(None) if self.path.is_empty() && self.visibility.is_some() => {\n+            UseSegmentKind::Slf(None) if self.path.is_empty() && self.visibility.is_some() => {\n                 self.path = vec![];\n                 return self;\n             }\n             _ => (),\n         }\n \n         // Normalise foo::self -> foo.\n-        if let UseSegment::Slf(None) = last {\n+        if let UseSegmentKind::Slf(None) = last.kind {\n             if !self.path.is_empty() {\n                 return self;\n             }\n         }\n \n         // Normalise foo::self as bar -> foo as bar.\n-        if let UseSegment::Slf(_) = last {\n-            if let Some(UseSegment::Ident(_, None)) = self.path.last() {\n+        if let UseSegmentKind::Slf(_) = last.kind {\n+            if let Some(UseSegment {\n+                kind: UseSegmentKind::Ident(_, None),\n+                ..\n+            }) = self.path.last()\n+            {\n                 aliased_self = true;\n             }\n         }\n \n         let mut done = false;\n         if aliased_self {\n             match self.path.last_mut() {\n-                Some(UseSegment::Ident(_, ref mut old_rename)) => {\n+                Some(UseSegment {\n+                    kind: UseSegmentKind::Ident(_, ref mut old_rename),\n+                    ..\n+                }) => {\n                     assert!(old_rename.is_none());\n-                    if let UseSegment::Slf(Some(rename)) = last.clone() {\n+                    if let UseSegmentKind::Slf(Some(rename)) = last.clone().kind {\n                         *old_rename = Some(rename);\n                         done = true;\n                     }\n@@ -538,15 +588,15 @@ impl UseTree {\n         }\n \n         // Normalise foo::{bar} -> foo::bar\n-        if let UseSegment::List(ref list) = last {\n+        if let UseSegmentKind::List(ref list) = last.kind {\n             if list.len() == 1 && list[0].to_string() != \"self\" {\n                 normalize_sole_list = true;\n             }\n         }\n \n         if normalize_sole_list {\n-            match last {\n-                UseSegment::List(list) => {\n+            match last.kind {\n+                UseSegmentKind::List(list) => {\n                     for seg in &list[0].path {\n                         self.path.push(seg.clone());\n                     }\n@@ -557,10 +607,13 @@ impl UseTree {\n         }\n \n         // Recursively normalize elements of a list use (including sorting the list).\n-        if let UseSegment::List(list) = last {\n+        if let UseSegmentKind::List(list) = last.kind {\n             let mut list = list.into_iter().map(UseTree::normalize).collect::<Vec<_>>();\n             list.sort();\n-            last = UseSegment::List(list);\n+            last = UseSegment {\n+                kind: UseSegmentKind::List(list),\n+                version: last.version,\n+            };\n         }\n \n         self.path.push(last);\n@@ -620,10 +673,10 @@ impl UseTree {\n         if self.path.is_empty() || self.contains_comment() {\n             return vec![self];\n         }\n-        match self.path.clone().last().unwrap() {\n-            UseSegment::List(list) => {\n+        match &self.path.clone().last().unwrap().kind {\n+            UseSegmentKind::List(list) => {\n                 if list.len() == 1 && list[0].path.len() == 1 {\n-                    if let UseSegment::Slf(..) = list[0].path[0] {\n+                    if let UseSegmentKind::Slf(..) = list[0].path[0].kind {\n                         return vec![self];\n                     };\n                 }\n@@ -671,12 +724,15 @@ impl UseTree {\n \n     /// If this tree ends in `::self`, rewrite it to `::{self}`.\n     fn nest_trailing_self(mut self) -> UseTree {\n-        if let Some(UseSegment::Slf(..)) = self.path.last() {\n+        if let Some(UseSegment {\n+            kind: UseSegmentKind::Slf(..),\n+            ..\n+        }) = self.path.last()\n+        {\n             let self_segment = self.path.pop().unwrap();\n-            self.path.push(UseSegment::List(vec![UseTree::from_path(\n-                vec![self_segment],\n-                DUMMY_SP,\n-            )]));\n+            let version = self_segment.version;\n+            let kind = UseSegmentKind::List(vec![UseTree::from_path(vec![self_segment], DUMMY_SP)]);\n+            self.path.push(UseSegment { kind, version });\n         }\n         self\n     }\n@@ -692,15 +748,17 @@ fn merge_rest(\n         return None;\n     }\n     if a.len() != len && b.len() != len {\n-        if let UseSegment::List(ref list) = a[len] {\n+        let version = a[len].version;\n+        if let UseSegmentKind::List(ref list) = a[len].kind {\n             let mut list = list.clone();\n             merge_use_trees_inner(\n                 &mut list,\n                 UseTree::from_path(b[len..].to_vec(), DUMMY_SP),\n                 merge_by,\n             );\n             let mut new_path = b[..len].to_vec();\n-            new_path.push(UseSegment::List(list));\n+            let kind = UseSegmentKind::List(list);\n+            new_path.push(UseSegment { kind, version });\n             return Some(new_path);\n         }\n     } else if len == 1 {\n@@ -709,15 +767,28 @@ fn merge_rest(\n         } else {\n             (&b[0], &a[1..])\n         };\n+        let kind = UseSegmentKind::Slf(common.get_alias().map(ToString::to_string));\n+        let version = a[0].version;\n         let mut list = vec![UseTree::from_path(\n-            vec![UseSegment::Slf(common.get_alias().map(ToString::to_string))],\n+            vec![UseSegment { kind, version }],\n             DUMMY_SP,\n         )];\n         match rest {\n-            [UseSegment::List(rest_list)] => list.extend(rest_list.clone()),\n+            [\n+                UseSegment {\n+                    kind: UseSegmentKind::List(rest_list),\n+                    ..\n+                },\n+            ] => list.extend(rest_list.clone()),\n             _ => list.push(UseTree::from_path(rest.to_vec(), DUMMY_SP)),\n         }\n-        return Some(vec![b[0].clone(), UseSegment::List(list)]);\n+        return Some(vec![\n+            b[0].clone(),\n+            UseSegment {\n+                kind: UseSegmentKind::List(list),\n+                version,\n+            },\n+        ]);\n     } else {\n         len -= 1;\n     }\n@@ -727,7 +798,9 @@ fn merge_rest(\n     ];\n     list.sort();\n     let mut new_path = b[..len].to_vec();\n-    new_path.push(UseSegment::List(list));\n+    let kind = UseSegmentKind::List(list);\n+    let version = a[0].version;\n+    new_path.push(UseSegment { kind, version });\n     Some(new_path)\n }\n \n@@ -805,19 +878,33 @@ impl PartialOrd for UseTree {\n }\n impl Ord for UseSegment {\n     fn cmp(&self, other: &UseSegment) -> Ordering {\n-        use self::UseSegment::*;\n+        use self::UseSegmentKind::*;\n \n         fn is_upper_snake_case(s: &str) -> bool {\n             s.chars()\n                 .all(|c| c.is_uppercase() || c == '_' || c.is_numeric())\n         }\n \n-        match (self, other) {\n-            (&Slf(ref a), &Slf(ref b))\n-            | (&Super(ref a), &Super(ref b))\n-            | (&Crate(ref a), &Crate(ref b)) => a.cmp(b),\n-            (&Glob, &Glob) => Ordering::Equal,\n-            (&Ident(ref ia, ref aa), &Ident(ref ib, ref ab)) => {\n+        match (&self.kind, &other.kind) {\n+            (Slf(ref a), Slf(ref b))\n+            | (Super(ref a), Super(ref b))\n+            | (Crate(ref a), Crate(ref b)) => match (a, b) {\n+                (Some(sa), Some(sb)) => {\n+                    if self.version == Version::Two {\n+                        sa.trim_start_matches(\"r#\").cmp(sb.trim_start_matches(\"r#\"))\n+                    } else {\n+                        a.cmp(b)\n+                    }\n+                }\n+                (_, _) => a.cmp(b),\n+            },\n+            (Glob, Glob) => Ordering::Equal,\n+            (Ident(ref pia, ref aa), Ident(ref pib, ref ab)) => {\n+                let (ia, ib) = if self.version == Version::Two {\n+                    (pia.trim_start_matches(\"r#\"), pib.trim_start_matches(\"r#\"))\n+                } else {\n+                    (pia.as_str(), pib.as_str())\n+                };\n                 // snake_case < CamelCase < UPPER_SNAKE_CASE\n                 if ia.starts_with(char::is_uppercase) && ib.starts_with(char::is_lowercase) {\n                     return Ordering::Greater;\n@@ -835,15 +922,21 @@ impl Ord for UseSegment {\n                 if ident_ord != Ordering::Equal {\n                     return ident_ord;\n                 }\n-                if aa.is_none() && ab.is_some() {\n-                    return Ordering::Less;\n-                }\n-                if aa.is_some() && ab.is_none() {\n-                    return Ordering::Greater;\n+                match (aa, ab) {\n+                    (None, Some(_)) => Ordering::Less,\n+                    (Some(_), None) => Ordering::Greater,\n+                    (Some(aas), Some(abs)) => {\n+                        if self.version == Version::Two {\n+                            aas.trim_start_matches(\"r#\")\n+                                .cmp(abs.trim_start_matches(\"r#\"))\n+                        } else {\n+                            aas.cmp(abs)\n+                        }\n+                    }\n+                    (None, None) => Ordering::Equal,\n                 }\n-                aa.cmp(ab)\n             }\n-            (&List(ref a), &List(ref b)) => {\n+            (List(ref a), List(ref b)) => {\n                 for (a, b) in a.iter().zip(b.iter()) {\n                     let ord = a.cmp(b);\n                     if ord != Ordering::Equal {\n@@ -853,16 +946,16 @@ impl Ord for UseSegment {\n \n                 a.len().cmp(&b.len())\n             }\n-            (&Slf(_), _) => Ordering::Less,\n-            (_, &Slf(_)) => Ordering::Greater,\n-            (&Super(_), _) => Ordering::Less,\n-            (_, &Super(_)) => Ordering::Greater,\n-            (&Crate(_), _) => Ordering::Less,\n-            (_, &Crate(_)) => Ordering::Greater,\n-            (&Ident(..), _) => Ordering::Less,\n-            (_, &Ident(..)) => Ordering::Greater,\n-            (&Glob, _) => Ordering::Less,\n-            (_, &Glob) => Ordering::Greater,\n+            (Slf(_), _) => Ordering::Less,\n+            (_, Slf(_)) => Ordering::Greater,\n+            (Super(_), _) => Ordering::Less,\n+            (_, Super(_)) => Ordering::Greater,\n+            (Crate(_), _) => Ordering::Less,\n+            (_, Crate(_)) => Ordering::Greater,\n+            (Ident(..), _) => Ordering::Less,\n+            (_, Ident(..)) => Ordering::Greater,\n+            (Glob, _) => Ordering::Less,\n+            (_, Glob) => Ordering::Greater,\n         }\n     }\n }\n@@ -906,7 +999,7 @@ fn rewrite_nested_use_tree(\n     }\n     let has_nested_list = use_tree_list.iter().any(|use_segment| {\n         use_segment.path.last().map_or(false, |last_segment| {\n-            matches!(last_segment, UseSegment::List(..))\n+            matches!(last_segment.kind, UseSegmentKind::List(..))\n         })\n     });\n \n@@ -957,17 +1050,19 @@ fn rewrite_nested_use_tree(\n \n impl Rewrite for UseSegment {\n     fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n-        Some(match self {\n-            UseSegment::Ident(ref ident, Some(ref rename)) => format!(\"{} as {}\", ident, rename),\n-            UseSegment::Ident(ref ident, None) => ident.clone(),\n-            UseSegment::Slf(Some(ref rename)) => format!(\"self as {}\", rename),\n-            UseSegment::Slf(None) => \"self\".to_owned(),\n-            UseSegment::Super(Some(ref rename)) => format!(\"super as {}\", rename),\n-            UseSegment::Super(None) => \"super\".to_owned(),\n-            UseSegment::Crate(Some(ref rename)) => format!(\"crate as {}\", rename),\n-            UseSegment::Crate(None) => \"crate\".to_owned(),\n-            UseSegment::Glob => \"*\".to_owned(),\n-            UseSegment::List(ref use_tree_list) => rewrite_nested_use_tree(\n+        Some(match self.kind {\n+            UseSegmentKind::Ident(ref ident, Some(ref rename)) => {\n+                format!(\"{} as {}\", ident, rename)\n+            }\n+            UseSegmentKind::Ident(ref ident, None) => ident.clone(),\n+            UseSegmentKind::Slf(Some(ref rename)) => format!(\"self as {}\", rename),\n+            UseSegmentKind::Slf(None) => \"self\".to_owned(),\n+            UseSegmentKind::Super(Some(ref rename)) => format!(\"super as {}\", rename),\n+            UseSegmentKind::Super(None) => \"super\".to_owned(),\n+            UseSegmentKind::Crate(Some(ref rename)) => format!(\"crate as {}\", rename),\n+            UseSegmentKind::Crate(None) => \"crate\".to_owned(),\n+            UseSegmentKind::Glob => \"*\".to_owned(),\n+            UseSegmentKind::List(ref use_tree_list) => rewrite_nested_use_tree(\n                 context,\n                 use_tree_list,\n                 // 1 = \"{\" and \"}\"\n@@ -1016,6 +1111,7 @@ mod test {\n \n         struct Parser<'a> {\n             input: Peekable<Chars<'a>>,\n+            version: Version,\n         }\n \n         impl<'a> Parser<'a> {\n@@ -1028,34 +1124,40 @@ mod test {\n             }\n \n             fn push_segment(\n+                &self,\n                 result: &mut Vec<UseSegment>,\n                 buf: &mut String,\n                 alias_buf: &mut Option<String>,\n             ) {\n+                let version = self.version;\n                 if !buf.is_empty() {\n                     let mut alias = None;\n                     swap(alias_buf, &mut alias);\n \n                     match buf.as_ref() {\n                         \"self\" => {\n-                            result.push(UseSegment::Slf(alias));\n+                            let kind = UseSegmentKind::Slf(alias);\n+                            result.push(UseSegment { kind, version });\n                             *buf = String::new();\n                             *alias_buf = None;\n                         }\n                         \"super\" => {\n-                            result.push(UseSegment::Super(alias));\n+                            let kind = UseSegmentKind::Super(alias);\n+                            result.push(UseSegment { kind, version });\n                             *buf = String::new();\n                             *alias_buf = None;\n                         }\n                         \"crate\" => {\n-                            result.push(UseSegment::Crate(alias));\n+                            let kind = UseSegmentKind::Crate(alias);\n+                            result.push(UseSegment { kind, version });\n                             *buf = String::new();\n                             *alias_buf = None;\n                         }\n                         _ => {\n                             let mut name = String::new();\n                             swap(buf, &mut name);\n-                            result.push(UseSegment::Ident(name, alias));\n+                            let kind = UseSegmentKind::Ident(name, alias);\n+                            result.push(UseSegment { kind, version });\n                         }\n                     }\n                 }\n@@ -1070,21 +1172,29 @@ mod test {\n                         '{' => {\n                             assert!(buf.is_empty());\n                             self.bump();\n-                            result.push(UseSegment::List(self.parse_list()));\n+                            let kind = UseSegmentKind::List(self.parse_list());\n+                            result.push(UseSegment {\n+                                kind,\n+                                version: self.version,\n+                            });\n                             self.eat('}');\n                         }\n                         '*' => {\n                             assert!(buf.is_empty());\n                             self.bump();\n-                            result.push(UseSegment::Glob);\n+                            let kind = UseSegmentKind::Glob;\n+                            result.push(UseSegment {\n+                                kind,\n+                                version: self.version,\n+                            });\n                         }\n                         ':' => {\n                             self.bump();\n                             self.eat(':');\n-                            Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n+                            self.push_segment(&mut result, &mut buf, &mut alias_buf);\n                         }\n                         '}' | ',' => {\n-                            Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n+                            self.push_segment(&mut result, &mut buf, &mut alias_buf);\n                             return UseTree {\n                                 path: result,\n                                 span: DUMMY_SP,\n@@ -1110,7 +1220,7 @@ mod test {\n                         }\n                     }\n                 }\n-                Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n+                self.push_segment(&mut result, &mut buf, &mut alias_buf);\n                 UseTree {\n                     path: result,\n                     span: DUMMY_SP,\n@@ -1136,6 +1246,7 @@ mod test {\n \n         let mut parser = Parser {\n             input: s.chars().peekable(),\n+            version: Version::One,\n         };\n         parser.parse_in_list()\n     }"}, {"sha": "495010a297df04939a9068777ce42e2e3a29ffcb", "filename": "src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -3,7 +3,6 @@\n #![warn(unreachable_pub)]\n #![recursion_limit = \"256\"]\n #![allow(clippy::match_like_matches_macro)]\n-#![allow(unreachable_pub)]\n \n #[macro_use]\n extern crate derive_new;"}, {"sha": "9e4a668aa49301319ace07e9bb21dad53d4b3393", "filename": "src/reorder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/src%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/src%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freorder.rs?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -12,7 +12,7 @@ use rustc_ast::ast;\n use rustc_span::{symbol::sym, Span};\n \n use crate::config::{Config, GroupImportsTactic};\n-use crate::imports::{normalize_use_trees_with_granularity, UseSegment, UseTree};\n+use crate::imports::{normalize_use_trees_with_granularity, UseSegmentKind, UseTree};\n use crate::items::{is_mod_decl, rewrite_extern_crate, rewrite_mod};\n use crate::lists::{itemize_list, write_list, ListFormatting, ListItem};\n use crate::rewrite::RewriteContext;\n@@ -182,16 +182,16 @@ fn group_imports(uts: Vec<UseTree>) -> Vec<Vec<UseTree>> {\n             external_imports.push(ut);\n             continue;\n         }\n-        match &ut.path[0] {\n-            UseSegment::Ident(id, _) => match id.as_ref() {\n+        match &ut.path[0].kind {\n+            UseSegmentKind::Ident(id, _) => match id.as_ref() {\n                 \"std\" | \"alloc\" | \"core\" => std_imports.push(ut),\n                 _ => external_imports.push(ut),\n             },\n-            UseSegment::Slf(_) | UseSegment::Super(_) | UseSegment::Crate(_) => {\n+            UseSegmentKind::Slf(_) | UseSegmentKind::Super(_) | UseSegmentKind::Crate(_) => {\n                 local_imports.push(ut)\n             }\n             // These are probably illegal here\n-            UseSegment::Glob | UseSegment::List(_) => external_imports.push(ut),\n+            UseSegmentKind::Glob | UseSegmentKind::List(_) => external_imports.push(ut),\n         }\n     }\n "}, {"sha": "515780761670c1049a3f1249d4cf48fe2fce9786", "filename": "tests/source/configs/doc_comment_code_block_width/100.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Fsource%2Fconfigs%2Fdoc_comment_code_block_width%2F100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Fsource%2Fconfigs%2Fdoc_comment_code_block_width%2F100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fconfigs%2Fdoc_comment_code_block_width%2F100.rs?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -0,0 +1,16 @@\n+// rustfmt-format_code_in_doc_comments: true\n+// rustfmt-doc_comment_code_block_width: 100\n+\n+/// ```rust\n+/// impl Test {\n+///     pub const fn from_bytes(v: &[u8]) -> Result<Self, ParserError> {\n+///         Self::from_bytes_manual_slice(v, 0, v.len()      )\n+///     }\n+/// }\n+/// ```\n+\n+impl Test {\n+    pub const fn from_bytes(v: &[u8]) -> Result<Self, ParserError> {\n+        Self::from_bytes_manual_slice(v, 0, v.len()       )\n+    }\n+}"}, {"sha": "96505c69714e5ce570a1efae27e01ae7db5154ac", "filename": "tests/source/configs/doc_comment_code_block_width/100_greater_max_width.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Fsource%2Fconfigs%2Fdoc_comment_code_block_width%2F100_greater_max_width.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Fsource%2Fconfigs%2Fdoc_comment_code_block_width%2F100_greater_max_width.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fconfigs%2Fdoc_comment_code_block_width%2F100_greater_max_width.rs?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -0,0 +1,17 @@\n+// rustfmt-max_width: 50\n+// rustfmt-format_code_in_doc_comments: true\n+// rustfmt-doc_comment_code_block_width: 100\n+\n+/// ```rust\n+/// impl Test {\n+///     pub const fn from_bytes(v: &[u8]) -> Result<Self, ParserError> {\n+///         Self::from_bytes_manual_slice(v, 0, v.len()      )\n+///     }\n+/// }\n+/// ```\n+\n+impl Test {\n+    pub const fn from_bytes(v: &[u8]) -> Result<Self, ParserError> {\n+        Self::from_bytes_manual_slice(v, 0, v.len()       )\n+    }\n+}"}, {"sha": "2c6307951c84eee5bfacb23a6e2daf64d6a62a85", "filename": "tests/source/configs/doc_comment_code_block_width/50.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Fsource%2Fconfigs%2Fdoc_comment_code_block_width%2F50.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Fsource%2Fconfigs%2Fdoc_comment_code_block_width%2F50.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fconfigs%2Fdoc_comment_code_block_width%2F50.rs?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -0,0 +1,16 @@\n+// rustfmt-format_code_in_doc_comments: true\n+// rustfmt-doc_comment_code_block_width: 50\n+\n+/// ```rust\n+/// impl Test {\n+///     pub const fn from_bytes(v: &[u8]) -> Result<Self, ParserError> {\n+///         Self::from_bytes_manual_slice(v, 0, v.len()      )\n+///     }\n+/// }\n+/// ```\n+\n+impl Test {\n+    pub const fn from_bytes(v: &[u8]) -> Result<Self, ParserError> {\n+        Self::from_bytes_manual_slice(v, 0, v.len()       )\n+    }\n+}"}, {"sha": "bc4b5b135696a9791f8e1cef8b4853496e55f008", "filename": "tests/source/imports_raw_identifiers/version_One.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Fsource%2Fimports_raw_identifiers%2Fversion_One.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Fsource%2Fimports_raw_identifiers%2Fversion_One.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fimports_raw_identifiers%2Fversion_One.rs?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -0,0 +1,5 @@\n+// rustfmt-version:One\n+\n+use websocket::client::ClientBuilder;\n+use websocket::r#async::futures::Stream;\n+use websocket::result::WebSocketError;"}, {"sha": "88e7fbd01ca6e5b9b0c750bab1a47c1b0566a921", "filename": "tests/source/imports_raw_identifiers/version_Two.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Fsource%2Fimports_raw_identifiers%2Fversion_Two.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Fsource%2Fimports_raw_identifiers%2Fversion_Two.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fimports_raw_identifiers%2Fversion_Two.rs?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -0,0 +1,5 @@\n+// rustfmt-version:Two\n+\n+use websocket::client::ClientBuilder;\n+use websocket::r#async::futures::Stream;\n+use websocket::result::WebSocketError;"}, {"sha": "c010a28aab61550bffcfc2637c1f199c3d1fc913", "filename": "tests/target/configs/doc_comment_code_block_width/100.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Ftarget%2Fconfigs%2Fdoc_comment_code_block_width%2F100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Ftarget%2Fconfigs%2Fdoc_comment_code_block_width%2F100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs%2Fdoc_comment_code_block_width%2F100.rs?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -0,0 +1,16 @@\n+// rustfmt-format_code_in_doc_comments: true\n+// rustfmt-doc_comment_code_block_width: 100\n+\n+/// ```rust\n+/// impl Test {\n+///     pub const fn from_bytes(v: &[u8]) -> Result<Self, ParserError> {\n+///         Self::from_bytes_manual_slice(v, 0, v.len())\n+///     }\n+/// }\n+/// ```\n+\n+impl Test {\n+    pub const fn from_bytes(v: &[u8]) -> Result<Self, ParserError> {\n+        Self::from_bytes_manual_slice(v, 0, v.len())\n+    }\n+}"}, {"sha": "6bcb99b915ff958c10477a38bfa3578eeca9bda7", "filename": "tests/target/configs/doc_comment_code_block_width/100_greater_max_width.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Ftarget%2Fconfigs%2Fdoc_comment_code_block_width%2F100_greater_max_width.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Ftarget%2Fconfigs%2Fdoc_comment_code_block_width%2F100_greater_max_width.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs%2Fdoc_comment_code_block_width%2F100_greater_max_width.rs?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -0,0 +1,29 @@\n+// rustfmt-max_width: 50\n+// rustfmt-format_code_in_doc_comments: true\n+// rustfmt-doc_comment_code_block_width: 100\n+\n+/// ```rust\n+/// impl Test {\n+///     pub const fn from_bytes(\n+///         v: &[u8],\n+///     ) -> Result<Self, ParserError> {\n+///         Self::from_bytes_manual_slice(\n+///             v,\n+///             0,\n+///             v.len(),\n+///         )\n+///     }\n+/// }\n+/// ```\n+\n+impl Test {\n+    pub const fn from_bytes(\n+        v: &[u8],\n+    ) -> Result<Self, ParserError> {\n+        Self::from_bytes_manual_slice(\n+            v,\n+            0,\n+            v.len(),\n+        )\n+    }\n+}"}, {"sha": "e8ab6f28bdc5ab4b88e5a617eced4492ffb4466a", "filename": "tests/target/configs/doc_comment_code_block_width/50.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Ftarget%2Fconfigs%2Fdoc_comment_code_block_width%2F50.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Ftarget%2Fconfigs%2Fdoc_comment_code_block_width%2F50.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs%2Fdoc_comment_code_block_width%2F50.rs?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -0,0 +1,22 @@\n+// rustfmt-format_code_in_doc_comments: true\n+// rustfmt-doc_comment_code_block_width: 50\n+\n+/// ```rust\n+/// impl Test {\n+///     pub const fn from_bytes(\n+///         v: &[u8],\n+///     ) -> Result<Self, ParserError> {\n+///         Self::from_bytes_manual_slice(\n+///             v,\n+///             0,\n+///             v.len(),\n+///         )\n+///     }\n+/// }\n+/// ```\n+\n+impl Test {\n+    pub const fn from_bytes(v: &[u8]) -> Result<Self, ParserError> {\n+        Self::from_bytes_manual_slice(v, 0, v.len())\n+    }\n+}"}, {"sha": "bc4b5b135696a9791f8e1cef8b4853496e55f008", "filename": "tests/target/imports_raw_identifiers/version_One.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Ftarget%2Fimports_raw_identifiers%2Fversion_One.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Ftarget%2Fimports_raw_identifiers%2Fversion_One.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimports_raw_identifiers%2Fversion_One.rs?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -0,0 +1,5 @@\n+// rustfmt-version:One\n+\n+use websocket::client::ClientBuilder;\n+use websocket::r#async::futures::Stream;\n+use websocket::result::WebSocketError;"}, {"sha": "22bfe93122f95aa383c9fd6dab7d4ea1f9247bcb", "filename": "tests/target/imports_raw_identifiers/version_Two.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Ftarget%2Fimports_raw_identifiers%2Fversion_Two.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Ftarget%2Fimports_raw_identifiers%2Fversion_Two.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimports_raw_identifiers%2Fversion_Two.rs?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -0,0 +1,5 @@\n+// rustfmt-version:Two\n+\n+use websocket::r#async::futures::Stream;\n+use websocket::client::ClientBuilder;\n+use websocket::result::WebSocketError;"}, {"sha": "17364c38919a2696f426d97dd2d19e7b12cd8390", "filename": "tests/target/issue_5399.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Ftarget%2Fissue_5399.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f43c96688d466d22c325d3c5725943cc0f88a8e6/tests%2Ftarget%2Fissue_5399.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue_5399.rs?ref=f43c96688d466d22c325d3c5725943cc0f88a8e6", "patch": "@@ -0,0 +1,48 @@\n+// rustfmt-max_width: 140\n+\n+impl NotificationRepository {\n+    fn set_status_changed(\n+        &self,\n+        repo_tx_conn: &RepoTxConn,\n+        rid: &RoutableId,\n+        changed_at: NaiveDateTime,\n+    ) -> NukeResult<Option<NotificationStatus>> {\n+        repo_tx_conn.run(move |conn| {\n+            let res = diesel::update(client_notification::table)\n+                .filter(\n+                    client_notification::routable_id.eq(DieselRoutableId(rid.clone())).and(\n+                        client_notification::changed_at\n+                            .lt(changed_at)\n+                            .or(client_notification::changed_at.is_null()),\n+                    ),\n+                )\n+                .set(client_notification::changed_at.eq(changed_at))\n+                .returning((\n+                    client_notification::id,\n+                    client_notification::changed_at,\n+                    client_notification::polled_at,\n+                    client_notification::notified_at,\n+                ))\n+                .get_result::<(Uuid, Option<NaiveDateTime>, Option<NaiveDateTime>, Option<NaiveDateTime>)>(conn)\n+                .optional()?;\n+\n+            match res {\n+                Some(row) => {\n+                    let client_id = client_contract::table\n+                        .inner_join(client_notification::table)\n+                        .filter(client_notification::id.eq(row.0))\n+                        .select(client_contract::client_id)\n+                        .get_result::<Uuid>(conn)?;\n+\n+                    Ok(Some(NotificationStatus {\n+                        client_id: client_id.into(),\n+                        changed_at: row.1,\n+                        polled_at: row.2,\n+                        notified_at: row.3,\n+                    }))\n+                }\n+                None => Ok(None),\n+            }\n+        })\n+    }\n+}"}]}