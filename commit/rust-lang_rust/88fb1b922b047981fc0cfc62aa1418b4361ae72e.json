{"sha": "88fb1b922b047981fc0cfc62aa1418b4361ae72e", "node_id": "C_kwDOAAsO6NoAKDg4ZmIxYjkyMmIwNDc5ODFmYzBjZmM2MmFhMTQxOGI0MzYxYWU3MmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-10T19:38:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-10T19:38:48Z"}, "message": "Auto merge of #108698 - IntQuant:issue-100717-infer-6, r=davidtwco\n\nMigrating rustc_infer to session diagnostics (part 5)\n\n`@rustbot` label +A-translation\ncc https://github.com/rust-lang/rust/issues/100717", "tree": {"sha": "448efc3576b60dd386661865cf2d1a358316a8c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/448efc3576b60dd386661865cf2d1a358316a8c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88fb1b922b047981fc0cfc62aa1418b4361ae72e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88fb1b922b047981fc0cfc62aa1418b4361ae72e", "html_url": "https://github.com/rust-lang/rust/commit/88fb1b922b047981fc0cfc62aa1418b4361ae72e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88fb1b922b047981fc0cfc62aa1418b4361ae72e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a73288371e3fa0a610fbc11e7e8418017bdfde42", "url": "https://api.github.com/repos/rust-lang/rust/commits/a73288371e3fa0a610fbc11e7e8418017bdfde42", "html_url": "https://github.com/rust-lang/rust/commit/a73288371e3fa0a610fbc11e7e8418017bdfde42"}, {"sha": "d07b1cd4a8e0f88b2b93090172ec4d257210d172", "url": "https://api.github.com/repos/rust-lang/rust/commits/d07b1cd4a8e0f88b2b93090172ec4d257210d172", "html_url": "https://github.com/rust-lang/rust/commit/d07b1cd4a8e0f88b2b93090172ec4d257210d172"}], "stats": {"total": 1123, "additions": 767, "deletions": 356}, "files": [{"sha": "c97fcc928561963abba71d6db3372e6676c84631", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88fb1b922b047981fc0cfc62aa1418b4361ae72e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88fb1b922b047981fc0cfc62aa1418b4361ae72e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=88fb1b922b047981fc0cfc62aa1418b4361ae72e", "patch": "@@ -768,7 +768,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let (provided_ty, provided_span) = provided_arg_tys[*provided_idx];\n             let trace =\n                 mk_trace(provided_span, formal_and_expected_inputs[*expected_idx], provided_ty);\n-            if !matches!(trace.cause.as_failure_code(*e), FailureCode::Error0308(_)) {\n+            if !matches!(trace.cause.as_failure_code(*e), FailureCode::Error0308) {\n                 self.err_ctxt().report_and_explain_type_error(trace, *e).emit();\n                 return true;\n             }"}, {"sha": "4d4a7880b0019e625b1aaa7d91a06bf171a01db2", "filename": "compiler/rustc_infer/messages.ftl", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/88fb1b922b047981fc0cfc62aa1418b4361ae72e/compiler%2Frustc_infer%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/88fb1b922b047981fc0cfc62aa1418b4361ae72e/compiler%2Frustc_infer%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fmessages.ftl?ref=88fb1b922b047981fc0cfc62aa1418b4361ae72e", "patch": "@@ -348,3 +348,47 @@ infer_prlf_known_limitation = this is a known limitation that will be removed in\n \n infer_opaque_captures_lifetime = hidden type for `{$opaque_ty}` captures lifetime that does not appear in bounds\n     .label = opaque type defined here\n+\n+infer_fps_use_ref = consider using a reference\n+infer_fps_remove_ref = consider removing the reference\n+infer_fps_cast = consider casting to a fn pointer\n+infer_fps_items_are_distinct = fn items are distinct from fn pointers\n+infer_fps_cast_both = consider casting both fn items to fn pointers using `as {$expected_sig}`\n+\n+infer_fn_uniq_types = different fn items have unique types, even if their signatures are the same\n+infer_fn_consider_casting = consider casting the fn item to a fn pointer: `{$casting}`\n+\n+infer_sarwa_option = you can convert from `&Option<T>` to `Option<&T>` using `.as_ref()`\n+infer_sarwa_result = you can convert from `&Result<T, E>` to `Result<&T, &E>` using `.as_ref()`\n+\n+infer_suggest_accessing_field = you might have meant to use field `{$name}` whose type is `{$ty}`\n+\n+infer_sbfrit_change_return_type = you could change the return type to be a boxed trait object\n+infer_sbfrit_box_return_expr = if you change the return type to expect trait objects, box the returned expressions\n+\n+infer_stp_wrap_one = try wrapping the pattern in `{$variant}`\n+infer_stp_wrap_many = try wrapping the pattern in a variant of `{$path}`\n+\n+infer_tuple_trailing_comma = use a trailing comma to create a tuple with one element\n+\n+infer_oc_method_compat = method not compatible with trait\n+infer_oc_type_compat = type not compatible with trait\n+infer_oc_const_compat = const not compatible with trait\n+infer_oc_try_compat = `?` operator has incompatible types\n+infer_oc_match_compat = `match` arms have incompatible types\n+infer_oc_if_else_different = `if` and `else` have incompatible types\n+infer_oc_no_else = `if` may be missing an `else` clause\n+infer_oc_no_diverge = `else` clause of `let...else` does not diverge\n+infer_oc_fn_main_correct_type = `main` function has wrong type\n+infer_oc_fn_start_correct_type = `#[start]` function has wrong type\n+infer_oc_intristic_correct_type = intrinsic has wrong type\n+infer_oc_method_correct_type = mismatched `self` parameter type\n+infer_oc_closure_selfref = closure/generator type that references itself\n+infer_oc_cant_coerce = cannot coerce intrinsics to function pointers\n+infer_oc_generic = mismatched types\n+\n+infer_meant_byte_literal = if you meant to write a byte literal, prefix with `b`\n+infer_meant_char_literal = if you meant to write a `char` literal, use single quotes\n+infer_meant_str_literal = if you meant to write a `str` literal, use double quotes\n+infer_consider_specifying_length = consider specifying the actual array length\n+infer_try_cannot_convert = `?` operator cannot convert from `{$found}` to `{$expected}`"}, {"sha": "b129621130d4d8b34a27504999bca62a5b13bf46", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 377, "deletions": 12, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/88fb1b922b047981fc0cfc62aa1418b4361ae72e/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88fb1b922b047981fc0cfc62aa1418b4361ae72e/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=88fb1b922b047981fc0cfc62aa1418b4361ae72e", "patch": "@@ -184,18 +184,6 @@ pub enum SourceKindMultiSuggestion<'a> {\n     },\n }\n \n-#[derive(Subdiagnostic)]\n-#[suggestion(\n-    infer_suggest_add_let_for_letchains,\n-    style = \"verbose\",\n-    applicability = \"machine-applicable\",\n-    code = \"let \"\n-)]\n-pub(crate) struct SuggAddLetForLetChains {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n impl<'a> SourceKindMultiSuggestion<'a> {\n     pub fn new_fully_qualified(\n         span: Span,\n@@ -1157,3 +1145,380 @@ pub struct OpaqueCapturesLifetime<'tcx> {\n     pub opaque_ty_span: Span,\n     pub opaque_ty: Ty<'tcx>,\n }\n+\n+#[derive(Subdiagnostic)]\n+pub enum FunctionPointerSuggestion<'a> {\n+    #[suggestion(\n+        infer_fps_use_ref,\n+        code = \"&{fn_name}\",\n+        style = \"verbose\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    UseRef {\n+        #[primary_span]\n+        span: Span,\n+        #[skip_arg]\n+        fn_name: String,\n+    },\n+    #[suggestion(\n+        infer_fps_remove_ref,\n+        code = \"{fn_name}\",\n+        style = \"verbose\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    RemoveRef {\n+        #[primary_span]\n+        span: Span,\n+        #[skip_arg]\n+        fn_name: String,\n+    },\n+    #[suggestion(\n+        infer_fps_cast,\n+        code = \"&({fn_name} as {sig})\",\n+        style = \"verbose\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    CastRef {\n+        #[primary_span]\n+        span: Span,\n+        #[skip_arg]\n+        fn_name: String,\n+        #[skip_arg]\n+        sig: Binder<'a, FnSig<'a>>,\n+    },\n+    #[suggestion(\n+        infer_fps_cast,\n+        code = \"{fn_name} as {sig}\",\n+        style = \"verbose\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    Cast {\n+        #[primary_span]\n+        span: Span,\n+        #[skip_arg]\n+        fn_name: String,\n+        #[skip_arg]\n+        sig: Binder<'a, FnSig<'a>>,\n+    },\n+    #[suggestion(\n+        infer_fps_cast_both,\n+        code = \"{fn_name} as {found_sig}\",\n+        style = \"hidden\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    CastBoth {\n+        #[primary_span]\n+        span: Span,\n+        #[skip_arg]\n+        fn_name: String,\n+        #[skip_arg]\n+        found_sig: Binder<'a, FnSig<'a>>,\n+        expected_sig: Binder<'a, FnSig<'a>>,\n+    },\n+    #[suggestion(\n+        infer_fps_cast_both,\n+        code = \"&({fn_name} as {found_sig})\",\n+        style = \"hidden\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    CastBothRef {\n+        #[primary_span]\n+        span: Span,\n+        #[skip_arg]\n+        fn_name: String,\n+        #[skip_arg]\n+        found_sig: Binder<'a, FnSig<'a>>,\n+        expected_sig: Binder<'a, FnSig<'a>>,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(infer_fps_items_are_distinct)]\n+pub struct FnItemsAreDistinct;\n+\n+#[derive(Subdiagnostic)]\n+#[note(infer_fn_uniq_types)]\n+pub struct FnUniqTypes;\n+\n+#[derive(Subdiagnostic)]\n+#[help(infer_fn_consider_casting)]\n+pub struct FnConsiderCasting {\n+    pub casting: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum SuggestAsRefWhereAppropriate<'a> {\n+    #[suggestion(\n+        infer_sarwa_option,\n+        code = \"{snippet}.as_ref()\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Option {\n+        #[primary_span]\n+        span: Span,\n+        snippet: &'a str,\n+    },\n+    #[suggestion(\n+        infer_sarwa_result,\n+        code = \"{snippet}.as_ref()\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Result {\n+        #[primary_span]\n+        span: Span,\n+        snippet: &'a str,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum SuggestAccessingField<'a> {\n+    #[suggestion(\n+        infer_suggest_accessing_field,\n+        code = \"{snippet}.{name}\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    Safe {\n+        #[primary_span]\n+        span: Span,\n+        snippet: String,\n+        name: Symbol,\n+        ty: Ty<'a>,\n+    },\n+    #[suggestion(\n+        infer_suggest_accessing_field,\n+        code = \"unsafe {{ {snippet}.{name} }}\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    Unsafe {\n+        #[primary_span]\n+        span: Span,\n+        snippet: String,\n+        name: Symbol,\n+        ty: Ty<'a>,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum SuggestBoxingForReturnImplTrait {\n+    #[multipart_suggestion(infer_sbfrit_change_return_type, applicability = \"maybe-incorrect\")]\n+    ChangeReturnType {\n+        #[suggestion_part(code = \"Box<dyn\")]\n+        start_sp: Span,\n+        #[suggestion_part(code = \">\")]\n+        end_sp: Span,\n+    },\n+    #[multipart_suggestion(infer_sbfrit_box_return_expr, applicability = \"maybe-incorrect\")]\n+    BoxReturnExpr {\n+        #[suggestion_part(code = \"Box::new(\")]\n+        starts: Vec<Span>,\n+        #[suggestion_part(code = \")\")]\n+        ends: Vec<Span>,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(infer_stp_wrap_one, applicability = \"maybe-incorrect\")]\n+pub struct SuggestTuplePatternOne {\n+    pub variant: String,\n+    #[suggestion_part(code = \"{variant}(\")]\n+    pub span_low: Span,\n+    #[suggestion_part(code = \")\")]\n+    pub span_high: Span,\n+}\n+\n+pub struct SuggestTuplePatternMany {\n+    pub path: String,\n+    pub cause_span: Span,\n+    pub compatible_variants: Vec<String>,\n+}\n+\n+impl AddToDiagnostic for SuggestTuplePatternMany {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, f: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        diag.set_arg(\"path\", self.path);\n+        let message = f(diag, crate::fluent_generated::infer_stp_wrap_many.into());\n+        diag.multipart_suggestions(\n+            message,\n+            self.compatible_variants.into_iter().map(|variant| {\n+                vec![\n+                    (self.cause_span.shrink_to_lo(), format!(\"{}(\", variant)),\n+                    (self.cause_span.shrink_to_hi(), \")\".to_string()),\n+                ]\n+            }),\n+            rustc_errors::Applicability::MaybeIncorrect,\n+        );\n+    }\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum TypeErrorAdditionalDiags {\n+    #[suggestion(\n+        infer_meant_byte_literal,\n+        code = \"b'{code}'\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    MeantByteLiteral {\n+        #[primary_span]\n+        span: Span,\n+        code: String,\n+    },\n+    #[suggestion(\n+        infer_meant_char_literal,\n+        code = \"'{code}'\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    MeantCharLiteral {\n+        #[primary_span]\n+        span: Span,\n+        code: String,\n+    },\n+    #[suggestion(\n+        infer_meant_str_literal,\n+        code = \"\\\"{code}\\\"\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    MeantStrLiteral {\n+        #[primary_span]\n+        span: Span,\n+        code: String,\n+    },\n+    #[suggestion(\n+        infer_consider_specifying_length,\n+        code = \"{length}\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    ConsiderSpecifyingLength {\n+        #[primary_span]\n+        span: Span,\n+        length: u64,\n+    },\n+    #[note(infer_try_cannot_convert)]\n+    TryCannotConvert { found: String, expected: String },\n+    #[suggestion(infer_tuple_trailing_comma, code = \",\", applicability = \"machine-applicable\")]\n+    TupleOnlyComma {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[multipart_suggestion(infer_tuple_trailing_comma, applicability = \"machine-applicable\")]\n+    TupleAlsoParentheses {\n+        #[suggestion_part(code = \"(\")]\n+        span_low: Span,\n+        #[suggestion_part(code = \",)\")]\n+        span_high: Span,\n+    },\n+    #[suggestion(\n+        infer_suggest_add_let_for_letchains,\n+        style = \"verbose\",\n+        applicability = \"machine-applicable\",\n+        code = \"let \"\n+    )]\n+    AddLetForLetChains {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+pub enum ObligationCauseFailureCode {\n+    #[diag(infer_oc_method_compat, code = \"E0308\")]\n+    MethodCompat {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_type_compat, code = \"E0308\")]\n+    TypeCompat {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_const_compat, code = \"E0308\")]\n+    ConstCompat {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_try_compat, code = \"E0308\")]\n+    TryCompat {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_match_compat, code = \"E0308\")]\n+    MatchCompat {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_if_else_different, code = \"E0308\")]\n+    IfElseDifferent {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_no_else, code = \"E0317\")]\n+    NoElse {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[diag(infer_oc_no_diverge, code = \"E0308\")]\n+    NoDiverge {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_fn_main_correct_type, code = \"E0580\")]\n+    FnMainCorrectType {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[diag(infer_oc_fn_start_correct_type, code = \"E0308\")]\n+    FnStartCorrectType {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_intristic_correct_type, code = \"E0308\")]\n+    IntristicCorrectType {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_method_correct_type, code = \"E0308\")]\n+    MethodCorrectType {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_closure_selfref, code = \"E0644\")]\n+    ClosureSelfref {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[diag(infer_oc_cant_coerce, code = \"E0308\")]\n+    CantCoerce {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+    #[diag(infer_oc_generic, code = \"E0308\")]\n+    Generic {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    },\n+}"}, {"sha": "7901bc9402122bffe3d3b1f09a2e9af58f8c5b98", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 226, "deletions": 222, "changes": 448, "blob_url": "https://github.com/rust-lang/rust/blob/88fb1b922b047981fc0cfc62aa1418b4361ae72e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88fb1b922b047981fc0cfc62aa1418b4361ae72e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=88fb1b922b047981fc0cfc62aa1418b4361ae72e", "patch": "@@ -49,11 +49,10 @@ use super::lexical_region_resolve::RegionResolutionError;\n use super::region_constraints::GenericKind;\n use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n \n-use crate::errors;\n+use crate::errors::{self, ObligationCauseFailureCode, TypeErrorAdditionalDiags};\n use crate::infer;\n use crate::infer::error_reporting::nice_region_error::find_anon_type::find_anon_type;\n use crate::infer::ExpectedFound;\n-use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n     PredicateObligation,\n@@ -90,6 +89,28 @@ pub use need_type_info::TypeAnnotationNeeded;\n \n pub mod nice_region_error;\n \n+/// Makes a valid string literal from a string by escaping special characters (\" and \\),\n+/// unless they are already escaped.\n+fn escape_literal(s: &str) -> String {\n+    let mut escaped = String::with_capacity(s.len());\n+    let mut chrs = s.chars().peekable();\n+    while let Some(first) = chrs.next() {\n+        match (first, chrs.peek()) {\n+            ('\\\\', Some(&delim @ '\"') | Some(&delim @ '\\'')) => {\n+                escaped.push('\\\\');\n+                escaped.push(delim);\n+                chrs.next();\n+            }\n+            ('\"' | '\\'', _) => {\n+                escaped.push('\\\\');\n+                escaped.push(first)\n+            }\n+            (c, _) => escaped.push(c),\n+        };\n+    }\n+    escaped\n+}\n+\n /// A helper for building type related errors. The `typeck_results`\n /// field is only populated during an in-progress typeck.\n /// Get an instance by calling `InferCtxt::err` or `FnCtxt::infer_err`.\n@@ -1899,233 +1920,182 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         debug!(?diag);\n     }\n \n-    pub fn report_and_explain_type_error(\n+    pub fn type_error_additional_suggestions(\n         &self,\n-        trace: TypeTrace<'tcx>,\n+        trace: &TypeTrace<'tcx>,\n         terr: TypeError<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+    ) -> Vec<TypeErrorAdditionalDiags> {\n         use crate::traits::ObligationCauseCode::MatchExpressionArm;\n-\n-        debug!(\"report_and_explain_type_error(trace={:?}, terr={:?})\", trace, terr);\n-\n+        let mut suggestions = Vec::new();\n         let span = trace.cause.span();\n-        let failure_code = trace.cause.as_failure_code(terr);\n-        let mut diag = match failure_code {\n-            FailureCode::Error0038(did) => {\n-                let violations = self.tcx.object_safety_violations(did);\n-                report_object_safety_error(self.tcx, span, did, violations)\n-            }\n-            FailureCode::Error0317(failure_str) => {\n-                struct_span_err!(self.tcx.sess, span, E0317, \"{}\", failure_str)\n-            }\n-            FailureCode::Error0580(failure_str) => {\n-                struct_span_err!(self.tcx.sess, span, E0580, \"{}\", failure_str)\n-            }\n-            FailureCode::Error0308(failure_str) => {\n-                fn escape_literal(s: &str) -> String {\n-                    let mut escaped = String::with_capacity(s.len());\n-                    let mut chrs = s.chars().peekable();\n-                    while let Some(first) = chrs.next() {\n-                        match (first, chrs.peek()) {\n-                            ('\\\\', Some(&delim @ '\"') | Some(&delim @ '\\'')) => {\n-                                escaped.push('\\\\');\n-                                escaped.push(delim);\n-                                chrs.next();\n-                            }\n-                            ('\"' | '\\'', _) => {\n-                                escaped.push('\\\\');\n-                                escaped.push(first)\n-                            }\n-                            (c, _) => escaped.push(c),\n-                        };\n+        let values = self.resolve_vars_if_possible(trace.values);\n+        if let Some((expected, found)) = values.ty() {\n+            match (expected.kind(), found.kind()) {\n+                (ty::Tuple(_), ty::Tuple(_)) => {}\n+                // If a tuple of length one was expected and the found expression has\n+                // parentheses around it, perhaps the user meant to write `(expr,)` to\n+                // build a tuple (issue #86100)\n+                (ty::Tuple(fields), _) => {\n+                    suggestions.extend(self.suggest_wrap_to_build_a_tuple( span, found, fields))\n+                }\n+                // If a byte was expected and the found expression is a char literal\n+                // containing a single ASCII character, perhaps the user meant to write `b'c'` to\n+                // specify a byte literal\n+                (ty::Uint(ty::UintTy::U8), ty::Char) => {\n+                    if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n+                        && let Some(code) = code.strip_prefix('\\'').and_then(|s| s.strip_suffix('\\''))\n+                        && !code.starts_with(\"\\\\u\") // forbid all Unicode escapes\n+                        && code.chars().next().map_or(false, |c| c.is_ascii()) // forbids literal Unicode characters beyond ASCII\n+                    {\n+                        suggestions.push(TypeErrorAdditionalDiags::MeantByteLiteral { span, code: escape_literal(code) })\n                     }\n-                    escaped\n                 }\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0308, \"{}\", failure_str);\n-                let values = self.resolve_vars_if_possible(trace.values);\n-                if let Some((expected, found)) = values.ty() {\n-                    match (expected.kind(), found.kind()) {\n-                        (ty::Tuple(_), ty::Tuple(_)) => {}\n-                        // If a tuple of length one was expected and the found expression has\n-                        // parentheses around it, perhaps the user meant to write `(expr,)` to\n-                        // build a tuple (issue #86100)\n-                        (ty::Tuple(fields), _) => {\n-                            self.emit_tuple_wrap_err(&mut err, span, found, fields)\n-                        }\n-                        // If a byte was expected and the found expression is a char literal\n-                        // containing a single ASCII character, perhaps the user meant to write `b'c'` to\n-                        // specify a byte literal\n-                        (ty::Uint(ty::UintTy::U8), ty::Char) => {\n-                            if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n-                                && let Some(code) = code.strip_prefix('\\'').and_then(|s| s.strip_suffix('\\''))\n-                                && !code.starts_with(\"\\\\u\") // forbid all Unicode escapes\n-                                && code.chars().next().map_or(false, |c| c.is_ascii()) // forbids literal Unicode characters beyond ASCII\n-                            {\n-                                err.span_suggestion(\n-                                    span,\n-                                    \"if you meant to write a byte literal, prefix with `b`\",\n-                                    format!(\"b'{}'\", escape_literal(code)),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                        }\n-                        // If a character was expected and the found expression is a string literal\n-                        // containing a single character, perhaps the user meant to write `'c'` to\n-                        // specify a character literal (issue #92479)\n-                        (ty::Char, ty::Ref(_, r, _)) if r.is_str() => {\n-                            if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n-                                && let Some(code) = code.strip_prefix('\"').and_then(|s| s.strip_suffix('\"'))\n-                                && code.chars().count() == 1\n-                            {\n-                                err.span_suggestion(\n-                                    span,\n-                                    \"if you meant to write a `char` literal, use single quotes\",\n-                                    format!(\"'{}'\", escape_literal(code)),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                        }\n-                        // If a string was expected and the found expression is a character literal,\n-                        // perhaps the user meant to write `\"s\"` to specify a string literal.\n-                        (ty::Ref(_, r, _), ty::Char) if r.is_str() => {\n-                            if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span) {\n-                                if let Some(code) =\n-                                    code.strip_prefix('\\'').and_then(|s| s.strip_suffix('\\''))\n-                                {\n-                                    err.span_suggestion(\n-                                        span,\n-                                        \"if you meant to write a `str` literal, use double quotes\",\n-                                        format!(\"\\\"{}\\\"\", escape_literal(code)),\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                }\n-                            }\n-                        }\n-                        // For code `if Some(..) = expr `, the type mismatch may be expected `bool` but found `()`,\n-                        // we try to suggest to add the missing `let` for `if let Some(..) = expr`\n-                        (ty::Bool, ty::Tuple(list)) => if list.len() == 0 {\n-                            self.suggest_let_for_letchains(&mut err, &trace.cause, span);\n-                        }\n-                        (ty::Array(_, _), ty::Array(_, _)) => 'block: {\n-                            let hir = self.tcx.hir();\n-                            let TypeError::FixedArraySize(sz) = terr else {\n-                                break 'block;\n-                            };\n-                            let tykind = match hir.find_by_def_id(trace.cause.body_id) {\n-                                Some(hir::Node::Item(hir::Item {\n-                                    kind: hir::ItemKind::Fn(_, _, body_id),\n-                                    ..\n-                                })) => {\n-                                    let body = hir.body(*body_id);\n-                                    struct LetVisitor<'v> {\n-                                        span: Span,\n-                                        result: Option<&'v hir::Ty<'v>>,\n-                                    }\n-                                    impl<'v> Visitor<'v> for LetVisitor<'v> {\n-                                        fn visit_stmt(&mut self, s: &'v hir::Stmt<'v>) {\n-                                            if self.result.is_some() {\n-                                                return;\n-                                            }\n-                                            // Find a local statement where the initializer has\n-                                            // the same span as the error and the type is specified.\n-                                            if let hir::Stmt {\n-                                                kind: hir::StmtKind::Local(hir::Local {\n-                                                    init: Some(hir::Expr {\n-                                                        span: init_span,\n-                                                        ..\n-                                                    }),\n-                                                    ty: Some(array_ty),\n-                                                    ..\n-                                                }),\n-                                                ..\n-                                            } = s\n-                                            && init_span == &self.span {\n-                                                self.result = Some(*array_ty);\n-                                            }\n-                                        }\n-                                    }\n-                                    let mut visitor = LetVisitor {span, result: None};\n-                                    visitor.visit_body(body);\n-                                    visitor.result.map(|r| &r.peel_refs().kind)\n-                                }\n-                                Some(hir::Node::Item(hir::Item {\n-                                    kind: hir::ItemKind::Const(ty, _),\n-                                    ..\n-                                })) => {\n-                                    Some(&ty.peel_refs().kind)\n-                                }\n-                                _ => None\n-                            };\n-\n-                            if let Some(tykind) = tykind\n-                                && let hir::TyKind::Array(_, length) = tykind\n-                                && let hir::ArrayLen::Body(hir::AnonConst { hir_id, .. }) = length\n-                                && let Some(span) = self.tcx.hir().opt_span(*hir_id)\n-                            {\n-                                err.span_suggestion(\n-                                    span,\n-                                    \"consider specifying the actual array length\",\n-                                    sz.found,\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            }\n+                // If a character was expected and the found expression is a string literal\n+                // containing a single character, perhaps the user meant to write `'c'` to\n+                // specify a character literal (issue #92479)\n+                (ty::Char, ty::Ref(_, r, _)) if r.is_str() => {\n+                    if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n+                        && let Some(code) = code.strip_prefix('\"').and_then(|s| s.strip_suffix('\"'))\n+                        && code.chars().count() == 1\n+                    {\n+                        suggestions.push(TypeErrorAdditionalDiags::MeantCharLiteral { span, code: escape_literal(code) })\n+                    }\n+                }\n+                // If a string was expected and the found expression is a character literal,\n+                // perhaps the user meant to write `\"s\"` to specify a string literal.\n+                (ty::Ref(_, r, _), ty::Char) if r.is_str() => {\n+                    if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span) {\n+                        if let Some(code) =\n+                            code.strip_prefix('\\'').and_then(|s| s.strip_suffix('\\''))\n+                        {\n+                            suggestions.push(TypeErrorAdditionalDiags::MeantStrLiteral { span, code: escape_literal(code) })\n                         }\n-                        _ => {}\n                     }\n                 }\n-                let code = trace.cause.code();\n-                if let &MatchExpressionArm(box MatchExpressionArmCause { source, .. }) = code\n+                // For code `if Some(..) = expr `, the type mismatch may be expected `bool` but found `()`,\n+                // we try to suggest to add the missing `let` for `if let Some(..) = expr`\n+                (ty::Bool, ty::Tuple(list)) => if list.len() == 0 {\n+                    suggestions.extend(self.suggest_let_for_letchains(&trace.cause, span));\n+                }\n+                (ty::Array(_, _), ty::Array(_, _)) => suggestions.extend(self.suggest_specify_actual_length(terr, trace, span)),\n+                _ => {}\n+            }\n+        }\n+        let code = trace.cause.code();\n+        if let &MatchExpressionArm(box MatchExpressionArmCause { source, .. }) = code\n                     && let hir::MatchSource::TryDesugar = source\n                     && let Some((expected_ty, found_ty, _, _)) = self.values_str(trace.values)\n                 {\n-                    err.note(&format!(\n-                        \"`?` operator cannot convert from `{}` to `{}`\",\n-                        found_ty.content(),\n-                        expected_ty.content(),\n-                    ));\n+                    suggestions.push(TypeErrorAdditionalDiags::TryCannotConvert { found: found_ty.content(), expected: expected_ty.content() });\n                 }\n-                err\n+        suggestions\n+    }\n+\n+    fn suggest_specify_actual_length(\n+        &self,\n+        terr: TypeError<'_>,\n+        trace: &TypeTrace<'_>,\n+        span: Span,\n+    ) -> Option<TypeErrorAdditionalDiags> {\n+        let hir = self.tcx.hir();\n+        let TypeError::FixedArraySize(sz) = terr else {\n+            return None;\n+        };\n+        let tykind = match hir.find_by_def_id(trace.cause.body_id) {\n+            Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body_id), .. })) => {\n+                let body = hir.body(*body_id);\n+                struct LetVisitor<'v> {\n+                    span: Span,\n+                    result: Option<&'v hir::Ty<'v>>,\n+                }\n+                impl<'v> Visitor<'v> for LetVisitor<'v> {\n+                    fn visit_stmt(&mut self, s: &'v hir::Stmt<'v>) {\n+                        if self.result.is_some() {\n+                            return;\n+                        }\n+                        // Find a local statement where the initializer has\n+                        // the same span as the error and the type is specified.\n+                        if let hir::Stmt {\n+                            kind: hir::StmtKind::Local(hir::Local {\n+                                init: Some(hir::Expr {\n+                                    span: init_span,\n+                                    ..\n+                                }),\n+                                ty: Some(array_ty),\n+                                ..\n+                            }),\n+                            ..\n+                        } = s\n+                        && init_span == &self.span {\n+                            self.result = Some(*array_ty);\n+                        }\n+                    }\n+                }\n+                let mut visitor = LetVisitor { span, result: None };\n+                visitor.visit_body(body);\n+                visitor.result.map(|r| &r.peel_refs().kind)\n             }\n-            FailureCode::Error0644(failure_str) => {\n-                struct_span_err!(self.tcx.sess, span, E0644, \"{}\", failure_str)\n+            Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Const(ty, _), .. })) => {\n+                Some(&ty.peel_refs().kind)\n             }\n+            _ => None,\n         };\n+        if let Some(tykind) = tykind\n+            && let hir::TyKind::Array(_, length) = tykind\n+            && let hir::ArrayLen::Body(hir::AnonConst { hir_id, .. }) = length\n+            && let Some(span) = self.tcx.hir().opt_span(*hir_id)\n+        {\n+            Some(TypeErrorAdditionalDiags::ConsiderSpecifyingLength { span, length: sz.found })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn report_and_explain_type_error(\n+        &self,\n+        trace: TypeTrace<'tcx>,\n+        terr: TypeError<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        debug!(\"report_and_explain_type_error(trace={:?}, terr={:?})\", trace, terr);\n+\n+        let span = trace.cause.span();\n+        let failure_code = trace.cause.as_failure_code_diag(\n+            terr,\n+            span,\n+            self.type_error_additional_suggestions(&trace, terr),\n+        );\n+        let mut diag = self.tcx.sess.create_err(failure_code);\n         self.note_type_err(&mut diag, &trace.cause, None, Some(trace.values), terr, false, false);\n         diag\n     }\n \n-    fn emit_tuple_wrap_err(\n+    fn suggest_wrap_to_build_a_tuple(\n         &self,\n-        err: &mut Diagnostic,\n         span: Span,\n         found: Ty<'tcx>,\n         expected_fields: &List<Ty<'tcx>>,\n-    ) {\n-        let [expected_tup_elem] = expected_fields[..] else { return };\n+    ) -> Option<TypeErrorAdditionalDiags> {\n+        let [expected_tup_elem] = expected_fields[..] else { return None};\n \n         if !self.same_type_modulo_infer(expected_tup_elem, found) {\n-            return;\n+            return None;\n         }\n \n         let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n-            else { return };\n+            else { return None };\n \n-        let msg = \"use a trailing comma to create a tuple with one element\";\n-        if code.starts_with('(') && code.ends_with(')') {\n+        let sugg = if code.starts_with('(') && code.ends_with(')') {\n             let before_close = span.hi() - BytePos::from_u32(1);\n-            err.span_suggestion(\n-                span.with_hi(before_close).shrink_to_hi(),\n-                msg,\n-                \",\",\n-                Applicability::MachineApplicable,\n-            );\n+            TypeErrorAdditionalDiags::TupleOnlyComma {\n+                span: span.with_hi(before_close).shrink_to_hi(),\n+            }\n         } else {\n-            err.multipart_suggestion(\n-                msg,\n-                vec![(span.shrink_to_lo(), \"(\".into()), (span.shrink_to_hi(), \",)\".into())],\n-                Applicability::MachineApplicable,\n-            );\n-        }\n+            TypeErrorAdditionalDiags::TupleAlsoParentheses {\n+                span_low: span.shrink_to_lo(),\n+                span_high: span.shrink_to_hi(),\n+            }\n+        };\n+        Some(sugg)\n     }\n \n     fn values_str(\n@@ -2828,57 +2798,91 @@ impl<'tcx> InferCtxt<'tcx> {\n }\n \n pub enum FailureCode {\n-    Error0038(DefId),\n-    Error0317(&'static str),\n-    Error0580(&'static str),\n-    Error0308(&'static str),\n-    Error0644(&'static str),\n+    Error0317,\n+    Error0580,\n+    Error0308,\n+    Error0644,\n }\n \n pub trait ObligationCauseExt<'tcx> {\n     fn as_failure_code(&self, terr: TypeError<'tcx>) -> FailureCode;\n+\n+    fn as_failure_code_diag(\n+        &self,\n+        terr: TypeError<'tcx>,\n+        span: Span,\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    ) -> ObligationCauseFailureCode;\n     fn as_requirement_str(&self) -> &'static str;\n }\n \n impl<'tcx> ObligationCauseExt<'tcx> for ObligationCause<'tcx> {\n     fn as_failure_code(&self, terr: TypeError<'tcx>) -> FailureCode {\n         use self::FailureCode::*;\n+        use crate::traits::ObligationCauseCode::*;\n+        match self.code() {\n+            IfExpressionWithNoElse => Error0317,\n+            MainFunctionType => Error0580,\n+            CompareImplItemObligation { .. }\n+            | MatchExpressionArm(_)\n+            | IfExpression { .. }\n+            | LetElse\n+            | StartFunctionType\n+            | IntrinsicType\n+            | MethodReceiver => Error0308,\n+\n+            // In the case where we have no more specific thing to\n+            // say, also take a look at the error code, maybe we can\n+            // tailor to that.\n+            _ => match terr {\n+                TypeError::CyclicTy(ty) if ty.is_closure() || ty.is_generator() => Error0644,\n+                TypeError::IntrinsicCast => Error0308,\n+                _ => Error0308,\n+            },\n+        }\n+    }\n+    fn as_failure_code_diag(\n+        &self,\n+        terr: TypeError<'tcx>,\n+        span: Span,\n+        subdiags: Vec<TypeErrorAdditionalDiags>,\n+    ) -> ObligationCauseFailureCode {\n         use crate::traits::ObligationCauseCode::*;\n         match self.code() {\n             CompareImplItemObligation { kind: ty::AssocKind::Fn, .. } => {\n-                Error0308(\"method not compatible with trait\")\n+                ObligationCauseFailureCode::MethodCompat { span, subdiags }\n             }\n             CompareImplItemObligation { kind: ty::AssocKind::Type, .. } => {\n-                Error0308(\"type not compatible with trait\")\n+                ObligationCauseFailureCode::TypeCompat { span, subdiags }\n             }\n             CompareImplItemObligation { kind: ty::AssocKind::Const, .. } => {\n-                Error0308(\"const not compatible with trait\")\n-            }\n-            MatchExpressionArm(box MatchExpressionArmCause { source, .. }) => {\n-                Error0308(match source {\n-                    hir::MatchSource::TryDesugar => \"`?` operator has incompatible types\",\n-                    _ => \"`match` arms have incompatible types\",\n-                })\n-            }\n-            IfExpression { .. } => Error0308(\"`if` and `else` have incompatible types\"),\n-            IfExpressionWithNoElse => Error0317(\"`if` may be missing an `else` clause\"),\n-            LetElse => Error0308(\"`else` clause of `let...else` does not diverge\"),\n-            MainFunctionType => Error0580(\"`main` function has wrong type\"),\n-            StartFunctionType => Error0308(\"`#[start]` function has wrong type\"),\n-            IntrinsicType => Error0308(\"intrinsic has wrong type\"),\n-            MethodReceiver => Error0308(\"mismatched `self` parameter type\"),\n+                ObligationCauseFailureCode::ConstCompat { span, subdiags }\n+            }\n+            MatchExpressionArm(box MatchExpressionArmCause { source, .. }) => match source {\n+                hir::MatchSource::TryDesugar => {\n+                    ObligationCauseFailureCode::TryCompat { span, subdiags }\n+                }\n+                _ => ObligationCauseFailureCode::MatchCompat { span, subdiags },\n+            },\n+            IfExpression { .. } => ObligationCauseFailureCode::IfElseDifferent { span, subdiags },\n+            IfExpressionWithNoElse => ObligationCauseFailureCode::NoElse { span },\n+            LetElse => ObligationCauseFailureCode::NoDiverge { span, subdiags },\n+            MainFunctionType => ObligationCauseFailureCode::FnMainCorrectType { span },\n+            StartFunctionType => ObligationCauseFailureCode::FnStartCorrectType { span, subdiags },\n+            IntrinsicType => ObligationCauseFailureCode::IntristicCorrectType { span, subdiags },\n+            MethodReceiver => ObligationCauseFailureCode::MethodCorrectType { span, subdiags },\n \n             // In the case where we have no more specific thing to\n             // say, also take a look at the error code, maybe we can\n             // tailor to that.\n             _ => match terr {\n                 TypeError::CyclicTy(ty) if ty.is_closure() || ty.is_generator() => {\n-                    Error0644(\"closure/generator type that references itself\")\n+                    ObligationCauseFailureCode::ClosureSelfref { span }\n                 }\n                 TypeError::IntrinsicCast => {\n-                    Error0308(\"cannot coerce intrinsics to function pointers\")\n+                    ObligationCauseFailureCode::CantCoerce { span, subdiags }\n                 }\n-                _ => Error0308(\"mismatched types\"),\n+                _ => ObligationCauseFailureCode::Generic { span, subdiags },\n             },\n         }\n     }"}, {"sha": "b5aeca12a1f0c67c24e070ab57df6f57d977c929", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 95, "deletions": 113, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/88fb1b922b047981fc0cfc62aa1418b4361ae72e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88fb1b922b047981fc0cfc62aa1418b4361ae72e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=88fb1b922b047981fc0cfc62aa1418b4361ae72e", "patch": "@@ -1,7 +1,7 @@\n use hir::def::CtorKind;\n use hir::intravisit::{walk_expr, walk_stmt, Visitor};\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_errors::{Applicability, Diagnostic};\n+use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_middle::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n@@ -13,11 +13,20 @@ use rustc_span::{sym, BytePos, Span};\n use rustc_target::abi::FieldIdx;\n \n use crate::errors::{\n-    ConsiderAddingAwait, SuggAddLetForLetChains, SuggestRemoveSemiOrReturnBinding,\n+    ConsiderAddingAwait, FnConsiderCasting, FnItemsAreDistinct, FnUniqTypes,\n+    FunctionPointerSuggestion, SuggestAccessingField, SuggestAsRefWhereAppropriate,\n+    SuggestBoxingForReturnImplTrait, SuggestRemoveSemiOrReturnBinding, SuggestTuplePatternMany,\n+    SuggestTuplePatternOne, TypeErrorAdditionalDiags,\n };\n \n use super::TypeErrCtxt;\n \n+#[derive(Clone, Copy)]\n+pub enum SuggestAsRefKind {\n+    Option,\n+    Result,\n+}\n+\n impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     pub(super) fn suggest_remove_semi_or_return_binding(\n         &self,\n@@ -72,25 +81,20 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         return_sp: Span,\n         arm_spans: impl Iterator<Item = Span>,\n     ) {\n-        err.multipart_suggestion(\n-            \"you could change the return type to be a boxed trait object\",\n-            vec![\n-                (return_sp.with_hi(return_sp.lo() + BytePos(4)), \"Box<dyn\".to_string()),\n-                (return_sp.shrink_to_hi(), \">\".to_string()),\n-            ],\n-            Applicability::MaybeIncorrect,\n-        );\n-        let sugg = arm_spans\n-            .flat_map(|sp| {\n-                [(sp.shrink_to_lo(), \"Box::new(\".to_string()), (sp.shrink_to_hi(), \")\".to_string())]\n-                    .into_iter()\n-            })\n-            .collect::<Vec<_>>();\n-        err.multipart_suggestion(\n-            \"if you change the return type to expect trait objects, box the returned expressions\",\n-            sugg,\n-            Applicability::MaybeIncorrect,\n-        );\n+        let sugg = SuggestBoxingForReturnImplTrait::ChangeReturnType {\n+            start_sp: return_sp.with_hi(return_sp.lo() + BytePos(4)),\n+            end_sp: return_sp.shrink_to_hi(),\n+        };\n+        err.subdiagnostic(sugg);\n+\n+        let mut starts = Vec::new();\n+        let mut ends = Vec::new();\n+        for span in arm_spans {\n+            starts.push(span.shrink_to_lo());\n+            ends.push(span.shrink_to_hi());\n+        }\n+        let sugg = SuggestBoxingForReturnImplTrait::BoxReturnExpr { starts, ends };\n+        err.subdiagnostic(sugg);\n     }\n \n     pub(super) fn suggest_tuple_pattern(\n@@ -130,30 +134,21 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 match &compatible_variants[..] {\n                     [] => {}\n                     [variant] => {\n-                        diag.multipart_suggestion_verbose(\n-                            &format!(\"try wrapping the pattern in `{}`\", variant),\n-                            vec![\n-                                (cause.span.shrink_to_lo(), format!(\"{}(\", variant)),\n-                                (cause.span.shrink_to_hi(), \")\".to_string()),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                        let sugg = SuggestTuplePatternOne {\n+                            variant: variant.to_owned(),\n+                            span_low: cause.span.shrink_to_lo(),\n+                            span_high: cause.span.shrink_to_hi(),\n+                        };\n+                        diag.subdiagnostic(sugg);\n                     }\n                     _ => {\n                         // More than one matching variant.\n-                        diag.multipart_suggestions(\n-                            &format!(\n-                                \"try wrapping the pattern in a variant of `{}`\",\n-                                self.tcx.def_path_str(expected_adt.did())\n-                            ),\n-                            compatible_variants.into_iter().map(|variant| {\n-                                vec![\n-                                    (cause.span.shrink_to_lo(), format!(\"{}(\", variant)),\n-                                    (cause.span.shrink_to_hi(), \")\".to_string()),\n-                                ]\n-                            }),\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                        let sugg = SuggestTuplePatternMany {\n+                            path: self.tcx.def_path_str(expected_adt.did()),\n+                            cause_span: cause.span,\n+                            compatible_variants,\n+                        };\n+                        diag.subdiagnostic(sugg);\n                     }\n                 }\n             }\n@@ -256,15 +251,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         }\n     }\n \n-    pub fn suggest_await_on_future(&self, diag: &mut Diagnostic, sp: Span) {\n-        diag.span_suggestion_verbose(\n-            sp.shrink_to_hi(),\n-            \"consider `await`ing on the `Future`\",\n-            \".await\",\n-            Applicability::MaybeIncorrect,\n-        );\n-    }\n-\n     pub(super) fn suggest_accessing_field_where_appropriate(\n         &self,\n         cause: &ObligationCause<'tcx>,\n@@ -291,21 +277,13 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 if let ObligationCauseCode::Pattern { span: Some(span), .. } = *cause.code() {\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         let suggestion = if expected_def.is_struct() {\n-                            format!(\"{}.{}\", snippet, name)\n+                            SuggestAccessingField::Safe { span, snippet, name, ty }\n                         } else if expected_def.is_union() {\n-                            format!(\"unsafe {{ {}.{} }}\", snippet, name)\n+                            SuggestAccessingField::Unsafe { span, snippet, name, ty }\n                         } else {\n                             return;\n                         };\n-                        diag.span_suggestion(\n-                            span,\n-                            &format!(\n-                                \"you might have meant to use field `{}` whose type is `{}`\",\n-                                name, ty\n-                            ),\n-                            suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                        diag.subdiagnostic(suggestion);\n                     }\n                 }\n             }\n@@ -321,15 +299,15 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         diag: &mut Diagnostic,\n     ) {\n         if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n-            && let Some(msg) = self.should_suggest_as_ref(exp_found.expected, exp_found.found)\n+            && let Some(msg) = self.should_suggest_as_ref_kind(exp_found.expected, exp_found.found)\n         {\n-            diag.span_suggestion(\n-                span,\n-                msg,\n-                // HACK: fix issue# 100605, suggesting convert from &Option<T> to Option<&T>, remove the extra `&`\n-                format!(\"{}.as_ref()\", snippet.trim_start_matches('&')),\n-                Applicability::MachineApplicable,\n-            );\n+            // HACK: fix issue# 100605, suggesting convert from &Option<T> to Option<&T>, remove the extra `&`\n+            let snippet = snippet.trim_start_matches('&');\n+            let subdiag = match msg {\n+                SuggestAsRefKind::Option => SuggestAsRefWhereAppropriate::Option { span, snippet },\n+                SuggestAsRefKind::Result => SuggestAsRefWhereAppropriate::Result { span, snippet },\n+            };\n+            diag.subdiagnostic(subdiag);\n         }\n     }\n \n@@ -362,31 +340,19 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     return;\n                 }\n \n-                let (msg, sug) = match (expected.is_ref(), found.is_ref()) {\n-                    (true, false) => {\n-                        let msg = \"consider using a reference\";\n-                        let sug = format!(\"&{fn_name}\");\n-                        (msg, sug)\n-                    }\n-                    (false, true) => {\n-                        let msg = \"consider removing the reference\";\n-                        let sug = format!(\"{fn_name}\");\n-                        (msg, sug)\n-                    }\n+                let sugg = match (expected.is_ref(), found.is_ref()) {\n+                    (true, false) => FunctionPointerSuggestion::UseRef { span, fn_name },\n+                    (false, true) => FunctionPointerSuggestion::RemoveRef { span, fn_name },\n                     (true, true) => {\n-                        diag.note(\"fn items are distinct from fn pointers\");\n-                        let msg = \"consider casting to a fn pointer\";\n-                        let sug = format!(\"&({fn_name} as {sig})\");\n-                        (msg, sug)\n+                        diag.subdiagnostic(FnItemsAreDistinct);\n+                        FunctionPointerSuggestion::CastRef { span, fn_name, sig: *sig }\n                     }\n                     (false, false) => {\n-                        diag.note(\"fn items are distinct from fn pointers\");\n-                        let msg = \"consider casting to a fn pointer\";\n-                        let sug = format!(\"{fn_name} as {sig}\");\n-                        (msg, sug)\n+                        diag.subdiagnostic(FnItemsAreDistinct);\n+                        FunctionPointerSuggestion::Cast { span, fn_name, sig: *sig }\n                     }\n                 };\n-                diag.span_suggestion_verbose(span, msg, sug, Applicability::MaybeIncorrect);\n+                diag.subdiagnostic(sugg);\n             }\n             (ty::FnDef(did1, substs1), ty::FnDef(did2, substs2)) => {\n                 let expected_sig =\n@@ -395,7 +361,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     &(self.normalize_fn_sig)(self.tcx.fn_sig(*did2).subst(self.tcx, substs2));\n \n                 if self.same_type_modulo_infer(*expected_sig, *found_sig) {\n-                    diag.note(\"different fn items have unique types, even if their signatures are the same\");\n+                    diag.subdiagnostic(FnUniqTypes);\n                 }\n \n                 if !self.same_type_modulo_infer(*found_sig, *expected_sig)\n@@ -409,16 +375,22 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n \n                 let fn_name = self.tcx.def_path_str_with_substs(*did2, substs2);\n                 let sug = if found.is_ref() {\n-                    format!(\"&({fn_name} as {found_sig})\")\n+                    FunctionPointerSuggestion::CastBothRef {\n+                        span,\n+                        fn_name,\n+                        found_sig: *found_sig,\n+                        expected_sig: *expected_sig,\n+                    }\n                 } else {\n-                    format!(\"{fn_name} as {found_sig}\")\n+                    FunctionPointerSuggestion::CastBoth {\n+                        span,\n+                        fn_name,\n+                        found_sig: *found_sig,\n+                        expected_sig: *expected_sig,\n+                    }\n                 };\n \n-                let msg = format!(\n-                    \"consider casting both fn items to fn pointers using `as {expected_sig}`\"\n-                );\n-\n-                diag.span_suggestion_hidden(span, msg, sug, Applicability::MaybeIncorrect);\n+                diag.subdiagnostic(sug);\n             }\n             (ty::FnDef(did, substs), ty::FnPtr(sig)) => {\n                 let expected_sig =\n@@ -437,31 +409,27 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     format!(\"{fn_name} as {found_sig}\")\n                 };\n \n-                diag.help(&format!(\"consider casting the fn item to a fn pointer: `{}`\", casting));\n+                diag.subdiagnostic(FnConsiderCasting { casting });\n             }\n             _ => {\n                 return;\n             }\n         };\n     }\n \n-    pub fn should_suggest_as_ref(&self, expected: Ty<'tcx>, found: Ty<'tcx>) -> Option<&str> {\n+    pub fn should_suggest_as_ref_kind(\n+        &self,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) -> Option<SuggestAsRefKind> {\n         if let (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) =\n             (expected.kind(), found.kind())\n         {\n             if let ty::Adt(found_def, found_substs) = *found_ty.kind() {\n                 if exp_def == &found_def {\n                     let have_as_ref = &[\n-                        (\n-                            sym::Option,\n-                            \"you can convert from `&Option<T>` to `Option<&T>` using \\\n-                        `.as_ref()`\",\n-                        ),\n-                        (\n-                            sym::Result,\n-                            \"you can convert from `&Result<T, E>` to \\\n-                        `Result<&T, &E>` using `.as_ref()`\",\n-                        ),\n+                        (sym::Option, SuggestAsRefKind::Option),\n+                        (sym::Result, SuggestAsRefKind::Result),\n                     ];\n                     if let Some(msg) = have_as_ref.iter().find_map(|(name, msg)| {\n                         self.tcx.is_diagnostic_item(*name, exp_def.did()).then_some(msg)\n@@ -495,15 +463,28 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         None\n     }\n \n+    // FIXME: Remove once `rustc_hir_typeck` is migrated to diagnostic structs\n+    pub fn should_suggest_as_ref(&self, expected: Ty<'tcx>, found: Ty<'tcx>) -> Option<&str> {\n+        match self.should_suggest_as_ref_kind(expected, found) {\n+            Some(SuggestAsRefKind::Option) => Some(\n+                \"you can convert from `&Option<T>` to `Option<&T>` using \\\n+            `.as_ref()`\",\n+            ),\n+            Some(SuggestAsRefKind::Result) => Some(\n+                \"you can convert from `&Result<T, E>` to \\\n+            `Result<&T, &E>` using `.as_ref()`\",\n+            ),\n+            None => None,\n+        }\n+    }\n     /// Try to find code with pattern `if Some(..) = expr`\n     /// use a `visitor` to mark the `if` which its span contains given error span,\n     /// and then try to find a assignment in the `cond` part, which span is equal with error span\n     pub(super) fn suggest_let_for_letchains(\n         &self,\n-        err: &mut Diagnostic,\n         cause: &ObligationCause<'_>,\n         span: Span,\n-    ) {\n+    ) -> Option<TypeErrorAdditionalDiags> {\n         let hir = self.tcx.hir();\n         if let Some(node) = self.tcx.hir().find_by_def_id(cause.body_id) &&\n             let hir::Node::Item(hir::Item {\n@@ -550,9 +531,10 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         let mut visitor = IfVisitor { err_span: span, found_if: false, result: false };\n         visitor.visit_body(&body);\n         if visitor.result {\n-                err.subdiagnostic(SuggAddLetForLetChains{span: span.shrink_to_lo()});\n+                return Some(TypeErrorAdditionalDiags::AddLetForLetChains{span: span.shrink_to_lo()});\n             }\n         }\n+        None\n     }\n }\n "}, {"sha": "24cbe8e8281b6dd4a180104197c2602ddfc3553e", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/88fb1b922b047981fc0cfc62aa1418b4361ae72e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88fb1b922b047981fc0cfc62aa1418b4361ae72e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=88fb1b922b047981fc0cfc62aa1418b4361ae72e", "patch": "@@ -15,6 +15,7 @@ use hir::def::DefKind;\n use polonius_engine::Atom;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::intern::Interned;\n+use rustc_errors::{DiagnosticArgValue, IntoDiagnosticArg};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem;\n@@ -864,8 +865,8 @@ impl<'tcx> PolyTraitRef<'tcx> {\n     }\n }\n \n-impl rustc_errors::IntoDiagnosticArg for PolyTraitRef<'_> {\n-    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+impl<'tcx> IntoDiagnosticArg for TraitRef<'tcx> {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         self.to_string().into_diagnostic_arg()\n     }\n }\n@@ -910,6 +911,12 @@ impl<'tcx> ExistentialTraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> IntoDiagnosticArg for ExistentialTraitRef<'tcx> {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        self.to_string().into_diagnostic_arg()\n+    }\n+}\n+\n pub type PolyExistentialTraitRef<'tcx> = Binder<'tcx, ExistentialTraitRef<'tcx>>;\n \n impl<'tcx> PolyExistentialTraitRef<'tcx> {\n@@ -926,12 +933,6 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n     }\n }\n \n-impl rustc_errors::IntoDiagnosticArg for PolyExistentialTraitRef<'_> {\n-    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n-        self.to_string().into_diagnostic_arg()\n-    }\n-}\n-\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub enum BoundVariableKind {\n@@ -1146,6 +1147,15 @@ impl<'tcx, T: IntoIterator> Binder<'tcx, T> {\n     }\n }\n \n+impl<'tcx, T> IntoDiagnosticArg for Binder<'tcx, T>\n+where\n+    T: IntoDiagnosticArg,\n+{\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        self.0.into_diagnostic_arg()\n+    }\n+}\n+\n struct SkipBindersAt<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     index: ty::DebruijnIndex,\n@@ -1362,6 +1372,12 @@ impl<'tcx> FnSig<'tcx> {\n     }\n }\n \n+impl<'tcx> IntoDiagnosticArg for FnSig<'tcx> {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        self.to_string().into_diagnostic_arg()\n+    }\n+}\n+\n pub type PolyFnSig<'tcx> = Binder<'tcx, FnSig<'tcx>>;\n \n impl<'tcx> PolyFnSig<'tcx> {"}]}