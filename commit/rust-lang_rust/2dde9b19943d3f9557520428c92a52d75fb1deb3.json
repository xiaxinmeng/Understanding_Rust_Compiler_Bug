{"sha": "2dde9b19943d3f9557520428c92a52d75fb1deb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkZGU5YjE5OTQzZDNmOTU1NzUyMDQyOGM5MmE1MmQ3NWZiMWRlYjM=", "commit": {"author": {"name": "vsrs", "email": "vit@conrlab.com", "date": "2020-05-16T10:17:21Z"}, "committer": {"name": "vsrs", "email": "vit@conrlab.com", "date": "2020-05-16T10:17:21Z"}, "message": "Use FixtureMeta in MockAnalysis", "tree": {"sha": "b787e8591b185c8fdc0947358b337e5462ba0d33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b787e8591b185c8fdc0947358b337e5462ba0d33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2dde9b19943d3f9557520428c92a52d75fb1deb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2dde9b19943d3f9557520428c92a52d75fb1deb3", "html_url": "https://github.com/rust-lang/rust/commit/2dde9b19943d3f9557520428c92a52d75fb1deb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2dde9b19943d3f9557520428c92a52d75fb1deb3/comments", "author": {"login": "vsrs", "id": 62505555, "node_id": "MDQ6VXNlcjYyNTA1NTU1", "avatar_url": "https://avatars.githubusercontent.com/u/62505555?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vsrs", "html_url": "https://github.com/vsrs", "followers_url": "https://api.github.com/users/vsrs/followers", "following_url": "https://api.github.com/users/vsrs/following{/other_user}", "gists_url": "https://api.github.com/users/vsrs/gists{/gist_id}", "starred_url": "https://api.github.com/users/vsrs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vsrs/subscriptions", "organizations_url": "https://api.github.com/users/vsrs/orgs", "repos_url": "https://api.github.com/users/vsrs/repos", "events_url": "https://api.github.com/users/vsrs/events{/privacy}", "received_events_url": "https://api.github.com/users/vsrs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vsrs", "id": 62505555, "node_id": "MDQ6VXNlcjYyNTA1NTU1", "avatar_url": "https://avatars.githubusercontent.com/u/62505555?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vsrs", "html_url": "https://github.com/vsrs", "followers_url": "https://api.github.com/users/vsrs/followers", "following_url": "https://api.github.com/users/vsrs/following{/other_user}", "gists_url": "https://api.github.com/users/vsrs/gists{/gist_id}", "starred_url": "https://api.github.com/users/vsrs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vsrs/subscriptions", "organizations_url": "https://api.github.com/users/vsrs/orgs", "repos_url": "https://api.github.com/users/vsrs/repos", "events_url": "https://api.github.com/users/vsrs/events{/privacy}", "received_events_url": "https://api.github.com/users/vsrs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "256fb7556e9f4a329e673851427942c6403bacb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/256fb7556e9f4a329e673851427942c6403bacb6", "html_url": "https://github.com/rust-lang/rust/commit/256fb7556e9f4a329e673851427942c6403bacb6"}], "stats": {"total": 102, "additions": 85, "deletions": 17}, "files": [{"sha": "8d8e30714854cca48f41354d447b9ce5f8357604", "filename": "crates/ra_ide/src/mock_analysis.rs", "status": "modified", "additions": 77, "deletions": 16, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/2dde9b19943d3f9557520428c92a52d75fb1deb3/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dde9b19943d3f9557520428c92a52d75fb1deb3/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs?ref=2dde9b19943d3f9557520428c92a52d75fb1deb3", "patch": "@@ -4,18 +4,61 @@ use std::sync::Arc;\n \n use ra_cfg::CfgOptions;\n use ra_db::{CrateName, Env, RelativePathBuf};\n-use test_utils::{extract_offset, extract_range, parse_fixture, CURSOR_MARKER};\n+use test_utils::{extract_offset, extract_range, parse_fixture, FixtureEntry, CURSOR_MARKER};\n \n use crate::{\n     Analysis, AnalysisChange, AnalysisHost, CrateGraph, Edition::Edition2018, FileId, FilePosition,\n     FileRange, SourceRootId,\n };\n \n+#[derive(Debug)]\n+enum MockFileData {\n+    Plain { path: String, content: String },\n+    Fixture(FixtureEntry),\n+}\n+\n+impl MockFileData {\n+    fn new(path: String, content: String) -> Self {\n+        // `Self::Plain` causes a false warning: 'variant is never constructed: `Plain` '\n+        // see https://github.com/rust-lang/rust/issues/69018\n+        MockFileData::Plain { path, content }\n+    }\n+\n+    fn path(&self) -> &str {\n+        match self {\n+            MockFileData::Plain { path, .. } => path.as_str(),\n+            MockFileData::Fixture(f) => f.meta.path().as_str(),\n+        }\n+    }\n+\n+    fn content(&self) -> &str {\n+        match self {\n+            MockFileData::Plain { content, .. } => content,\n+            MockFileData::Fixture(f) => f.text.as_str(),\n+        }\n+    }\n+\n+    fn cfg_options(&self) -> CfgOptions {\n+        match self {\n+            MockFileData::Fixture(f) => {\n+                f.meta.cfg_options().map_or_else(Default::default, |o| o.clone())\n+            }\n+            _ => CfgOptions::default(),\n+        }\n+    }\n+}\n+\n+impl From<FixtureEntry> for MockFileData {\n+    fn from(fixture: FixtureEntry) -> Self {\n+        Self::Fixture(fixture)\n+    }\n+}\n+\n /// Mock analysis is used in test to bootstrap an AnalysisHost/Analysis\n /// from a set of in-memory files.\n #[derive(Debug, Default)]\n pub struct MockAnalysis {\n-    files: Vec<(String, String)>,\n+    files: Vec<MockFileData>,\n }\n \n impl MockAnalysis {\n@@ -35,7 +78,7 @@ impl MockAnalysis {\n     pub fn with_files(fixture: &str) -> MockAnalysis {\n         let mut res = MockAnalysis::new();\n         for entry in parse_fixture(fixture) {\n-            res.add_file(entry.meta.path().as_str(), &entry.text);\n+            res.add_file_fixture(entry);\n         }\n         res\n     }\n@@ -48,39 +91,52 @@ impl MockAnalysis {\n         for entry in parse_fixture(fixture) {\n             if entry.text.contains(CURSOR_MARKER) {\n                 assert!(position.is_none(), \"only one marker (<|>) per fixture is allowed\");\n-                position =\n-                    Some(res.add_file_with_position(&entry.meta.path().as_str(), &entry.text));\n+                position = Some(res.add_file_fixture_with_position(entry));\n             } else {\n-                res.add_file(&entry.meta.path().as_str(), &entry.text);\n+                res.add_file_fixture(entry);\n             }\n         }\n         let position = position.expect(\"expected a marker (<|>)\");\n         (res, position)\n     }\n \n+    pub fn add_file_fixture(&mut self, fixture: FixtureEntry) -> FileId {\n+        let file_id = self.next_id();\n+        self.files.push(MockFileData::from(fixture));\n+        file_id\n+    }\n+\n+    pub fn add_file_fixture_with_position(&mut self, mut fixture: FixtureEntry) -> FilePosition {\n+        let (offset, text) = extract_offset(&fixture.text);\n+        fixture.text = text;\n+        let file_id = self.next_id();\n+        self.files.push(MockFileData::from(fixture));\n+        FilePosition { file_id, offset }\n+    }\n+\n     pub fn add_file(&mut self, path: &str, text: &str) -> FileId {\n-        let file_id = FileId((self.files.len() + 1) as u32);\n-        self.files.push((path.to_string(), text.to_string()));\n+        let file_id = self.next_id();\n+        self.files.push(MockFileData::new(path.to_string(), text.to_string()));\n         file_id\n     }\n     pub fn add_file_with_position(&mut self, path: &str, text: &str) -> FilePosition {\n         let (offset, text) = extract_offset(text);\n-        let file_id = FileId((self.files.len() + 1) as u32);\n-        self.files.push((path.to_string(), text));\n+        let file_id = self.next_id();\n+        self.files.push(MockFileData::new(path.to_string(), text));\n         FilePosition { file_id, offset }\n     }\n     pub fn add_file_with_range(&mut self, path: &str, text: &str) -> FileRange {\n         let (range, text) = extract_range(text);\n-        let file_id = FileId((self.files.len() + 1) as u32);\n-        self.files.push((path.to_string(), text));\n+        let file_id = self.next_id();\n+        self.files.push(MockFileData::new(path.to_string(), text));\n         FileRange { file_id, range }\n     }\n     pub fn id_of(&self, path: &str) -> FileId {\n         let (idx, _) = self\n             .files\n             .iter()\n             .enumerate()\n-            .find(|(_, (p, _text))| path == p)\n+            .find(|(_, data)| path == data.path())\n             .expect(\"no file in this mock\");\n         FileId(idx as u32 + 1)\n     }\n@@ -91,11 +147,12 @@ impl MockAnalysis {\n         change.add_root(source_root, true);\n         let mut crate_graph = CrateGraph::default();\n         let mut root_crate = None;\n-        for (i, (path, contents)) in self.files.into_iter().enumerate() {\n+        for (i, data) in self.files.into_iter().enumerate() {\n+            let path = data.path();\n             assert!(path.starts_with('/'));\n             let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n+            let cfg_options = data.cfg_options();\n             let file_id = FileId(i as u32 + 1);\n-            let cfg_options = CfgOptions::default();\n             if path == \"/lib.rs\" || path == \"/main.rs\" {\n                 root_crate = Some(crate_graph.add_crate_root(\n                     file_id,\n@@ -123,7 +180,7 @@ impl MockAnalysis {\n                         .unwrap();\n                 }\n             }\n-            change.add_file(source_root, file_id, path, Arc::new(contents));\n+            change.add_file(source_root, file_id, path, Arc::new(data.content().to_owned()));\n         }\n         change.set_crate_graph(crate_graph);\n         host.apply_change(change);\n@@ -132,6 +189,10 @@ impl MockAnalysis {\n     pub fn analysis(self) -> Analysis {\n         self.analysis_host().analysis()\n     }\n+\n+    fn next_id(&self) -> FileId {\n+        FileId((self.files.len() + 1) as u32)\n+    }\n }\n \n /// Creates analysis from a multi-file fixture, returns positions marked with <|>."}, {"sha": "584ca5c391552235540bc2c49b4ca32339fb648f", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2dde9b19943d3f9557520428c92a52d75fb1deb3/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dde9b19943d3f9557520428c92a52d75fb1deb3/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=2dde9b19943d3f9557520428c92a52d75fb1deb3", "patch": "@@ -176,7 +176,7 @@ pub struct FileMeta {\n     pub path: RelativePathBuf,\n     pub krate: Option<String>,\n     pub deps: Vec<String>,\n-    pub cfg: ra_cfg::CfgOptions,\n+    pub cfg: CfgOptions,\n     pub edition: Option<String>,\n     pub env: FxHashMap<String, String>,\n }\n@@ -188,6 +188,13 @@ impl FixtureMeta {\n             FixtureMeta::File(f) => &f.path,\n         }\n     }\n+\n+    pub fn cfg_options(&self) -> Option<&CfgOptions> {\n+        match self {\n+            FixtureMeta::File(f) => Some(&f.cfg),\n+            _ => None,\n+        }\n+    }\n }\n \n /// Parses text which looks like this:"}]}