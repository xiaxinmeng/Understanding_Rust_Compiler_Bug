{"sha": "f0c8058f1236474b22b69971524015558384c077", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwYzgwNThmMTIzNjQ3NGIyMmI2OTk3MTUyNDAxNTU1ODM4NGMwNzc=", "commit": {"author": {"name": "adamrk", "email": "ark.email@gmail.com", "date": "2020-06-20T09:04:46Z"}, "committer": {"name": "adamrk", "email": "ark.email@gmail.com", "date": "2020-06-20T09:04:46Z"}, "message": "Fixes to callable_sig_from_fn_trait", "tree": {"sha": "600ce31914c990f04a2e3f359eb7d6c0c04e0411", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/600ce31914c990f04a2e3f359eb7d6c0c04e0411"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0c8058f1236474b22b69971524015558384c077", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0c8058f1236474b22b69971524015558384c077", "html_url": "https://github.com/rust-lang/rust/commit/f0c8058f1236474b22b69971524015558384c077", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0c8058f1236474b22b69971524015558384c077/comments", "author": {"login": "adamrk", "id": 16367467, "node_id": "MDQ6VXNlcjE2MzY3NDY3", "avatar_url": "https://avatars.githubusercontent.com/u/16367467?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adamrk", "html_url": "https://github.com/adamrk", "followers_url": "https://api.github.com/users/adamrk/followers", "following_url": "https://api.github.com/users/adamrk/following{/other_user}", "gists_url": "https://api.github.com/users/adamrk/gists{/gist_id}", "starred_url": "https://api.github.com/users/adamrk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adamrk/subscriptions", "organizations_url": "https://api.github.com/users/adamrk/orgs", "repos_url": "https://api.github.com/users/adamrk/repos", "events_url": "https://api.github.com/users/adamrk/events{/privacy}", "received_events_url": "https://api.github.com/users/adamrk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "adamrk", "id": 16367467, "node_id": "MDQ6VXNlcjE2MzY3NDY3", "avatar_url": "https://avatars.githubusercontent.com/u/16367467?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adamrk", "html_url": "https://github.com/adamrk", "followers_url": "https://api.github.com/users/adamrk/followers", "following_url": "https://api.github.com/users/adamrk/following{/other_user}", "gists_url": "https://api.github.com/users/adamrk/gists{/gist_id}", "starred_url": "https://api.github.com/users/adamrk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adamrk/subscriptions", "organizations_url": "https://api.github.com/users/adamrk/orgs", "repos_url": "https://api.github.com/users/adamrk/repos", "events_url": "https://api.github.com/users/adamrk/events{/privacy}", "received_events_url": "https://api.github.com/users/adamrk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38f6cdbc8a83b081ad1cef9171e28431be09db01", "url": "https://api.github.com/repos/rust-lang/rust/commits/38f6cdbc8a83b081ad1cef9171e28431be09db01", "html_url": "https://github.com/rust-lang/rust/commit/38f6cdbc8a83b081ad1cef9171e28431be09db01"}], "stats": {"total": 139, "additions": 72, "deletions": 67}, "files": [{"sha": "359befe4f14b98ef370b957aa1c39d58b11ece2d", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/f0c8058f1236474b22b69971524015558384c077/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c8058f1236474b22b69971524015558384c077/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=f0c8058f1236474b22b69971524015558384c077", "patch": "@@ -15,10 +15,10 @@ use ra_syntax::ast::RangeOp;\n \n use crate::{\n     autoderef, method_resolution, op,\n-    traits::{FnTrait, InEnvironment, SolutionVariables},\n+    traits::{FnTrait, Guidance, InEnvironment, SolutionVariables},\n     utils::{generics, variant_data, Generics},\n-    ApplicationTy, Binders, CallableDef, FnSig, InferTy, IntTy, Mutability, Obligation, Rawness,\n-    Substs, TraitRef, Ty, TypeCtor,\n+    ApplicationTy, Binders, CallableDef, InferTy, IntTy, Mutability, Obligation, Rawness, Substs,\n+    TraitRef, Ty, TypeCtor,\n };\n \n use super::{\n@@ -63,72 +63,70 @@ impl<'a> InferenceContext<'a> {\n         self.resolve_ty_as_possible(ty)\n     }\n \n-    fn callable_sig_from_fn_trait(&mut self, ty: &Ty) -> Option<FnSig> {\n-        if let Some(krate) = self.resolver.krate() {\n-            let fn_traits: Vec<crate::TraitId> = [FnTrait::FnOnce, FnTrait::FnMut, FnTrait::Fn]\n-                .iter()\n-                .filter_map(|f| f.get_id(self.db, krate))\n-                .collect();\n-            for fn_trait in fn_traits {\n-                let fn_trait_data = self.db.trait_data(fn_trait);\n-                let generic_params = generics(self.db.upcast(), fn_trait.into());\n-                if generic_params.len() != 2 {\n-                    continue;\n-                }\n-\n-                let arg_ty = self.table.new_type_var();\n-                let substs = Substs::build_for_generics(&generic_params)\n-                    .push(ty.clone())\n-                    .push(arg_ty.clone())\n-                    .build();\n-\n-                let trait_ref = TraitRef { trait_: fn_trait, substs: substs.clone() };\n-                let trait_env = Arc::clone(&self.trait_env);\n-                let implements_fn_goal =\n-                    self.canonicalizer().canonicalize_obligation(InEnvironment {\n-                        value: Obligation::Trait(trait_ref),\n-                        environment: trait_env,\n-                    });\n-                if let Some(Solution::Unique(SolutionVariables(solution))) =\n-                    self.db.trait_solve(krate, implements_fn_goal.value.clone())\n-                {\n-                    match solution.value.as_slice() {\n-                        [Ty::Apply(ApplicationTy {\n-                            ctor: TypeCtor::Tuple { cardinality: _ },\n-                            parameters,\n-                        })] => {\n-                            let output_assoc_type = match fn_trait_data\n-                                .associated_types()\n-                                .collect::<Vec<hir_def::TypeAliasId>>()\n-                                .as_slice()\n-                            {\n-                                [output] => *output,\n-                                _ => {\n-                                    continue;\n-                                }\n-                            };\n-                            let output_proj_ty = crate::ProjectionTy {\n-                                associated_ty: output_assoc_type,\n-                                parameters: substs,\n-                            };\n-                            let return_ty = self.normalize_projection_ty(output_proj_ty);\n-                            return Some(FnSig::from_params_and_return(\n-                                parameters.into_iter().map(|ty| ty.clone()).collect(),\n-                                return_ty,\n-                            ));\n-                        }\n-                        _ => (),\n-                    }\n-                }\n+    fn callable_sig_from_fn_trait(&mut self, ty: &Ty, num_args: usize) -> Option<(Vec<Ty>, Ty)> {\n+        let krate = self.resolver.krate()?;\n+        let fn_traits: Vec<crate::TraitId> = [FnTrait::FnOnce, FnTrait::FnMut, FnTrait::Fn]\n+            .iter()\n+            .filter_map(|f| f.get_id(self.db, krate))\n+            .collect();\n+        let fn_once_trait = FnTrait::FnOnce.get_id(self.db, krate)?;\n+        let output_assoc_type = match self\n+            .db\n+            .trait_data(fn_once_trait)\n+            .associated_types()\n+            .collect::<Vec<hir_def::TypeAliasId>>()\n+            .as_slice()\n+        {\n+            [output] => *output,\n+            _ => {\n+                return None;\n             }\n         };\n+        for fn_trait in fn_traits {\n+            let generic_params = generics(self.db.upcast(), fn_trait.into());\n+            if generic_params.len() != 2 {\n+                continue;\n+            }\n+\n+            let mut param_builder = Substs::builder(num_args);\n+            for _ in 0..num_args {\n+                param_builder = param_builder.push(self.table.new_type_var());\n+            }\n+            let arg_ty = Ty::Apply(ApplicationTy {\n+                ctor: TypeCtor::Tuple { cardinality: num_args as u16 },\n+                parameters: param_builder.build(),\n+            });\n+            let substs = Substs::build_for_generics(&generic_params)\n+                .push(ty.clone())\n+                .push(arg_ty.clone())\n+                .build();\n+\n+            let trait_ref = TraitRef { trait_: fn_trait, substs: substs.clone() };\n+            let trait_env = Arc::clone(&self.trait_env);\n+            let implements_fn_goal = self.canonicalizer().canonicalize_obligation(InEnvironment {\n+                value: Obligation::Trait(trait_ref),\n+                environment: trait_env,\n+            });\n+            let solution = match self.db.trait_solve(krate, implements_fn_goal.value.clone()) {\n+                Some(Solution::Unique(SolutionVariables(solution)))\n+                | Some(Solution::Ambig(Guidance::Definite(SolutionVariables(solution))))\n+                | Some(Solution::Ambig(Guidance::Suggested(SolutionVariables(solution)))) => {\n+                    solution\n+                }\n+                _ => continue,\n+            };\n+            let output_proj_ty =\n+                crate::ProjectionTy { associated_ty: output_assoc_type, parameters: substs };\n+            let return_ty = self.normalize_projection_ty(output_proj_ty);\n+            return Some((solution.value, return_ty));\n+        }\n         None\n     }\n \n-    pub fn callable_sig(&mut self, ty: &Ty) -> Option<FnSig> {\n+    pub fn callable_sig(&mut self, ty: &Ty, num_args: usize) -> Option<(Vec<Ty>, Ty)> {\n         match ty.callable_sig(self.db) {\n-            result @ Some(_) => result,\n-            None => self.callable_sig_from_fn_trait(ty),\n+            Some(sig) => Some((sig.params().to_vec(), sig.ret().clone())),\n+            None => self.callable_sig_from_fn_trait(ty, num_args),\n         }\n     }\n \n@@ -278,8 +276,10 @@ impl<'a> InferenceContext<'a> {\n                 );\n                 let (param_tys, ret_ty): (Vec<Ty>, Ty) = derefs\n                     .find_map(|callee_deref_ty| {\n-                        self.callable_sig(&canonicalized.decanonicalize_ty(callee_deref_ty.value))\n-                            .map(|sig| (sig.params().to_vec(), sig.ret().clone()))\n+                        self.callable_sig(\n+                            &canonicalized.decanonicalize_ty(callee_deref_ty.value),\n+                            args.len(),\n+                        )\n                     })\n                     .unwrap_or((Vec::new(), Ty::Unknown));\n                 self.register_obligations_for_call(&callee_ty);"}, {"sha": "a03024d090bc955540f33c8f27d9f3d87af647ed", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f0c8058f1236474b22b69971524015558384c077/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c8058f1236474b22b69971524015558384c077/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=f0c8058f1236474b22b69971524015558384c077", "patch": "@@ -2438,10 +2438,15 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             r#\"\n             //- /lib.rs deps:std\n \n-            #[lang = \"fn\"]\n-            pub trait Fn<Args> {\n+            #[lang = \"fn_once\"]\n+            pub trait FnOnce<Args> {\n                 type Output;\n \n+                extern \"rust-call\" fn call_once(&self, args: Args) -> Self::Output;\n+            }\n+\n+            #[lang = \"fn\"]\n+            pub trait Fn<Args>:FnOnce<Args> {\n                 extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n             }\n "}]}