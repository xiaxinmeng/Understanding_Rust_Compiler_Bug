{"sha": "63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "node_id": "C_kwDOAAsO6NoAKDYzYjhmMDFiYjVjYTI3N2U3ZGY4ZDdlZmUwOTRlZDQyNDRjMTc5MGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-24T20:22:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-24T20:22:27Z"}, "message": "Auto merge of #94934 - Lireer:const-prop-lint, r=oli-obk\n\nSeparate const prop lints from optimizations\n\nr? `@oli-obk`\n\nSeparates lints and optimizations during const prop by moving the lints into their own file and checking them during post borrowck cleanup.\nThanks to `@oli-obk` for mentoring me.", "tree": {"sha": "f4246d5d6dda964e54872e7cc58af2c7fe6b74ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4246d5d6dda964e54872e7cc58af2c7fe6b74ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "html_url": "https://github.com/rust-lang/rust/commit/63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b133a7e27c32e822e9ff774e4436f184f5a9752", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b133a7e27c32e822e9ff774e4436f184f5a9752", "html_url": "https://github.com/rust-lang/rust/commit/4b133a7e27c32e822e9ff774e4436f184f5a9752"}, {"sha": "440946af11391c50cda9f691fda0a507981d0268", "url": "https://api.github.com/repos/rust-lang/rust/commits/440946af11391c50cda9f691fda0a507981d0268", "html_url": "https://github.com/rust-lang/rust/commit/440946af11391c50cda9f691fda0a507981d0268"}], "stats": {"total": 1547, "additions": 1308, "deletions": 239}, "files": [{"sha": "4f5fc38917f4350c788807e40828fd053dfaa5d4", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 23, "deletions": 177, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -6,30 +6,25 @@ use std::cell::Cell;\n use rustc_ast::Mutability;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::DefKind;\n-use rustc_hir::HirId;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::visit::{\n     MutVisitor, MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor,\n };\n use rustc_middle::mir::{\n-    AssertKind, BasicBlock, BinOp, Body, Constant, ConstantKind, Local, LocalDecl, LocalKind,\n-    Location, Operand, Place, Rvalue, SourceInfo, SourceScope, SourceScopeData, Statement,\n-    StatementKind, Terminator, TerminatorKind, UnOp, RETURN_PLACE,\n+    BasicBlock, BinOp, Body, Constant, ConstantKind, Local, LocalDecl, LocalKind, Location,\n+    Operand, Place, Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UnOp,\n+    RETURN_PLACE,\n };\n use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n-use rustc_middle::ty::{\n-    self, ConstInt, ConstKind, Instance, ParamEnv, ScalarInt, Ty, TyCtxt, TypeFoldable,\n-};\n-use rustc_session::lint;\n+use rustc_middle::ty::{self, ConstKind, Instance, ParamEnv, Ty, TyCtxt, TypeFoldable};\n use rustc_span::{def_id::DefId, Span};\n use rustc_target::abi::{HasDataLayout, Size, TargetDataLayout};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n \n use crate::MirPass;\n-use rustc_const_eval::const_eval::ConstEvalErr;\n use rustc_const_eval::interpret::{\n     self, compile_time_machine, AllocId, ConstAllocation, ConstValue, CtfeValidationMode, Frame,\n     ImmTy, Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemPlace, MemoryKind, OpTy,\n@@ -318,9 +313,8 @@ struct ConstPropagator<'mir, 'tcx> {\n     ecx: InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>,\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n-    // FIXME(eddyb) avoid cloning these two fields more than once,\n-    // by accessing them through `ecx` instead.\n-    source_scopes: IndexVec<SourceScope, SourceScopeData<'tcx>>,\n+    // FIXME(eddyb) avoid cloning this field more than once,\n+    // by accessing it through `ecx` instead.\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     // Because we have `MutVisitor` we can't obtain the `SourceInfo` from a `Location`. So we store\n     // the last known `SourceInfo` here and just keep revisiting it.\n@@ -412,9 +406,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             ecx,\n             tcx,\n             param_env,\n-            // FIXME(eddyb) avoid cloning these two fields more than once,\n-            // by accessing them through `ecx` instead.\n-            source_scopes: body.source_scopes.clone(),\n+            // FIXME(eddyb) avoid cloning this field more than once,\n+            // by accessing it through `ecx` instead.\n             //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_body()` needs it\n             local_decls: body.local_decls.clone(),\n             source_info: None,\n@@ -445,10 +438,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             LocalState { value: LocalValue::Unallocated, layout: Cell::new(None) };\n     }\n \n-    fn lint_root(&self, source_info: SourceInfo) -> Option<HirId> {\n-        source_info.scope.lint_root(&self.source_scopes)\n-    }\n-\n     fn use_ecx<F, T>(&mut self, f: F) -> Option<T>\n     where\n         F: FnOnce(&mut Self) -> InterpResult<'tcx, T>,\n@@ -471,45 +460,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n \n     /// Returns the value, if any, of evaluating `c`.\n-    fn eval_constant(&mut self, c: &Constant<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n+    fn eval_constant(&mut self, c: &Constant<'tcx>) -> Option<OpTy<'tcx>> {\n         // FIXME we need to revisit this for #67176\n         if c.needs_subst() {\n             return None;\n         }\n \n-        match self.ecx.mir_const_to_op(&c.literal, None) {\n-            Ok(op) => Some(op),\n-            Err(error) => {\n-                let tcx = self.ecx.tcx.at(c.span);\n-                let err = ConstEvalErr::new(&self.ecx, error, Some(c.span));\n-                if let Some(lint_root) = self.lint_root(source_info) {\n-                    let lint_only = match c.literal {\n-                        ConstantKind::Ty(ct) => match ct.val() {\n-                            // Promoteds must lint and not error as the user didn't ask for them\n-                            ConstKind::Unevaluated(ty::Unevaluated {\n-                                def: _,\n-                                substs: _,\n-                                promoted: Some(_),\n-                            }) => true,\n-                            // Out of backwards compatibility we cannot report hard errors in unused\n-                            // generic functions using associated constants of the generic parameters.\n-                            _ => c.literal.needs_subst(),\n-                        },\n-                        ConstantKind::Val(_, ty) => ty.needs_subst(),\n-                    };\n-                    if lint_only {\n-                        // Out of backwards compatibility we cannot report hard errors in unused\n-                        // generic functions using associated constants of the generic parameters.\n-                        err.report_as_lint(tcx, \"erroneous constant used\", lint_root, Some(c.span));\n-                    } else {\n-                        err.report_as_error(tcx, \"erroneous constant used\");\n-                    }\n-                } else {\n-                    err.report_as_error(tcx, \"erroneous constant used\");\n-                }\n-                None\n-            }\n-        }\n+        self.ecx.mir_const_to_op(&c.literal, None).ok()\n     }\n \n     /// Returns the value, if any, of evaluating `place`.\n@@ -520,49 +477,22 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n     /// Returns the value, if any, of evaluating `op`. Calls upon `eval_constant`\n     /// or `eval_place`, depending on the variant of `Operand` used.\n-    fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n+    fn eval_operand(&mut self, op: &Operand<'tcx>) -> Option<OpTy<'tcx>> {\n         match *op {\n-            Operand::Constant(ref c) => self.eval_constant(c, source_info),\n+            Operand::Constant(ref c) => self.eval_constant(c),\n             Operand::Move(place) | Operand::Copy(place) => self.eval_place(place),\n         }\n     }\n \n-    fn report_assert_as_lint(\n-        &self,\n-        lint: &'static lint::Lint,\n-        source_info: SourceInfo,\n-        message: &'static str,\n-        panic: AssertKind<impl std::fmt::Debug>,\n-    ) {\n-        if let Some(lint_root) = self.lint_root(source_info) {\n-            self.tcx.struct_span_lint_hir(lint, lint_root, source_info.span, |lint| {\n-                let mut err = lint.build(message);\n-                err.span_label(source_info.span, format!(\"{:?}\", panic));\n-                err.emit();\n-            });\n-        }\n-    }\n-\n-    fn check_unary_op(\n-        &mut self,\n-        op: UnOp,\n-        arg: &Operand<'tcx>,\n-        source_info: SourceInfo,\n-    ) -> Option<()> {\n-        if let (val, true) = self.use_ecx(|this| {\n+    fn check_unary_op(&mut self, op: UnOp, arg: &Operand<'tcx>) -> Option<()> {\n+        if self.use_ecx(|this| {\n             let val = this.ecx.read_immediate(&this.ecx.eval_operand(arg, None)?)?;\n             let (_res, overflow, _ty) = this.ecx.overflowing_unary_op(op, &val)?;\n-            Ok((val, overflow))\n+            Ok(overflow)\n         })? {\n             // `AssertKind` only has an `OverflowNeg` variant, so make sure that is\n             // appropriate to use.\n             assert_eq!(op, UnOp::Neg, \"Neg is the only UnOp that can overflow\");\n-            self.report_assert_as_lint(\n-                lint::builtin::ARITHMETIC_OVERFLOW,\n-                source_info,\n-                \"this arithmetic operation will overflow\",\n-                AssertKind::OverflowNeg(val.to_const_int()),\n-            );\n             return None;\n         }\n \n@@ -574,7 +504,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         op: BinOp,\n         left: &Operand<'tcx>,\n         right: &Operand<'tcx>,\n-        source_info: SourceInfo,\n     ) -> Option<()> {\n         let r = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(right, None)?));\n         let l = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?));\n@@ -589,25 +518,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             let r_bits = r.to_scalar().ok();\n             let r_bits = r_bits.and_then(|r| r.to_bits(right_size).ok());\n             if r_bits.map_or(false, |b| b >= left_size.bits() as u128) {\n-                debug!(\"check_binary_op: reporting assert for {:?}\", source_info);\n-                self.report_assert_as_lint(\n-                    lint::builtin::ARITHMETIC_OVERFLOW,\n-                    source_info,\n-                    \"this arithmetic operation will overflow\",\n-                    AssertKind::Overflow(\n-                        op,\n-                        match l {\n-                            Some(l) => l.to_const_int(),\n-                            // Invent a dummy value, the diagnostic ignores it anyway\n-                            None => ConstInt::new(\n-                                ScalarInt::try_from_uint(1_u8, left_size).unwrap(),\n-                                left_ty.is_signed(),\n-                                left_ty.is_ptr_sized_integral(),\n-                            ),\n-                        },\n-                        r.to_const_int(),\n-                    ),\n-                );\n                 return None;\n             }\n         }\n@@ -618,12 +528,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n                 Ok(overflow)\n             })? {\n-                self.report_assert_as_lint(\n-                    lint::builtin::ARITHMETIC_OVERFLOW,\n-                    source_info,\n-                    \"this arithmetic operation will overflow\",\n-                    AssertKind::Overflow(op, l.to_const_int(), r.to_const_int()),\n-                );\n                 return None;\n             }\n         }\n@@ -656,12 +560,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn const_prop(\n-        &mut self,\n-        rvalue: &Rvalue<'tcx>,\n-        source_info: SourceInfo,\n-        place: Place<'tcx>,\n-    ) -> Option<()> {\n+    fn const_prop(&mut self, rvalue: &Rvalue<'tcx>, place: Place<'tcx>) -> Option<()> {\n         // Perform any special handling for specific Rvalue types.\n         // Generally, checks here fall into one of two categories:\n         //   1. Additional checking to provide useful lints to the user\n@@ -676,11 +575,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // lint.\n             Rvalue::UnaryOp(op, arg) => {\n                 trace!(\"checking UnaryOp(op = {:?}, arg = {:?})\", op, arg);\n-                self.check_unary_op(*op, arg, source_info)?;\n+                self.check_unary_op(*op, arg)?;\n             }\n             Rvalue::BinaryOp(op, box (left, right)) => {\n                 trace!(\"checking BinaryOp(op = {:?}, left = {:?}, right = {:?})\", op, left, right);\n-                self.check_binary_op(*op, left, right, source_info)?;\n+                self.check_binary_op(*op, left, right)?;\n             }\n             Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n                 trace!(\n@@ -689,7 +588,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     left,\n                     right\n                 );\n-                self.check_binary_op(*op, left, right, source_info)?;\n+                self.check_binary_op(*op, left, right)?;\n             }\n \n             // Do not try creating references (#67862)\n@@ -1071,7 +970,7 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n     fn visit_constant(&mut self, constant: &mut Constant<'tcx>, location: Location) {\n         trace!(\"visit_constant: {:?}\", constant);\n         self.super_constant(constant, location);\n-        self.eval_constant(constant, self.source_info.unwrap());\n+        self.eval_constant(constant);\n     }\n \n     fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n@@ -1080,7 +979,7 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         self.source_info = Some(source_info);\n         if let StatementKind::Assign(box (place, ref mut rval)) = statement.kind {\n             let can_const_prop = self.ecx.machine.can_const_prop[place.local];\n-            if let Some(()) = self.const_prop(rval, source_info, place) {\n+            if let Some(()) = self.const_prop(rval, place) {\n                 // This will return None if the above `const_prop` invocation only \"wrote\" a\n                 // type whose creation requires no write. E.g. a generator whose initial state\n                 // consists solely of uninitialized memory (so it doesn't capture any locals).\n@@ -1164,57 +1063,12 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         self.source_info = Some(source_info);\n         self.super_terminator(terminator, location);\n         match &mut terminator.kind {\n-            TerminatorKind::Assert { expected, ref msg, ref mut cond, .. } => {\n-                if let Some(ref value) = self.eval_operand(&cond, source_info) {\n+            TerminatorKind::Assert { expected, ref mut cond, .. } => {\n+                if let Some(ref value) = self.eval_operand(&cond) {\n                     trace!(\"assertion on {:?} should be {:?}\", value, expected);\n                     let expected = ScalarMaybeUninit::from(Scalar::from_bool(*expected));\n                     let value_const = self.ecx.read_scalar(&value).unwrap();\n                     if expected != value_const {\n-                        enum DbgVal<T> {\n-                            Val(T),\n-                            Underscore,\n-                        }\n-                        impl<T: std::fmt::Debug> std::fmt::Debug for DbgVal<T> {\n-                            fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-                                match self {\n-                                    Self::Val(val) => val.fmt(fmt),\n-                                    Self::Underscore => fmt.write_str(\"_\"),\n-                                }\n-                            }\n-                        }\n-                        let mut eval_to_int = |op| {\n-                            // This can be `None` if the lhs wasn't const propagated and we just\n-                            // triggered the assert on the value of the rhs.\n-                            self.eval_operand(op, source_info).map_or(DbgVal::Underscore, |op| {\n-                                DbgVal::Val(self.ecx.read_immediate(&op).unwrap().to_const_int())\n-                            })\n-                        };\n-                        let msg = match msg {\n-                            AssertKind::DivisionByZero(op) => {\n-                                Some(AssertKind::DivisionByZero(eval_to_int(op)))\n-                            }\n-                            AssertKind::RemainderByZero(op) => {\n-                                Some(AssertKind::RemainderByZero(eval_to_int(op)))\n-                            }\n-                            AssertKind::Overflow(bin_op @ (BinOp::Div | BinOp::Rem), op1, op2) => {\n-                                // Division overflow is *UB* in the MIR, and different than the\n-                                // other overflow checks.\n-                                Some(AssertKind::Overflow(\n-                                    *bin_op,\n-                                    eval_to_int(op1),\n-                                    eval_to_int(op2),\n-                                ))\n-                            }\n-                            AssertKind::BoundsCheck { ref len, ref index } => {\n-                                let len = eval_to_int(len);\n-                                let index = eval_to_int(index);\n-                                Some(AssertKind::BoundsCheck { len, index })\n-                            }\n-                            // Remaining overflow errors are already covered by checks on the binary operators.\n-                            AssertKind::Overflow(..) | AssertKind::OverflowNeg(_) => None,\n-                            // Need proper const propagator for these.\n-                            _ => None,\n-                        };\n                         // Poison all places this operand references so that further code\n                         // doesn't use the invalid value\n                         match cond {\n@@ -1223,14 +1077,6 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                             }\n                             Operand::Constant(_) => {}\n                         }\n-                        if let Some(msg) = msg {\n-                            self.report_assert_as_lint(\n-                                lint::builtin::UNCONDITIONAL_PANIC,\n-                                source_info,\n-                                \"this operation will panic at runtime\",\n-                                msg,\n-                            );\n-                        }\n                     } else {\n                         if self.should_const_prop(value) {\n                             if let ScalarMaybeUninit::Scalar(scalar) = value_const {"}, {"sha": "5be745bc1de38aa0977bd02a8332851828529b64", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "added", "additions": 1035, "deletions": 0, "changes": 1035, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -0,0 +1,1035 @@\n+//! Propagates constants for early reporting of statically known\n+//! assertion failures\n+\n+use std::cell::Cell;\n+\n+use rustc_ast::Mutability;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::def::DefKind;\n+use rustc_hir::HirId;\n+use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n+use rustc_middle::mir::{\n+    AssertKind, BasicBlock, BinOp, Body, Constant, ConstantKind, Local, LocalDecl, LocalKind,\n+    Location, Operand, Place, Rvalue, SourceInfo, SourceScope, SourceScopeData, Statement,\n+    StatementKind, Terminator, TerminatorKind, UnOp, RETURN_PLACE,\n+};\n+use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n+use rustc_middle::ty::subst::{InternalSubsts, Subst};\n+use rustc_middle::ty::{\n+    self, ConstInt, ConstKind, Instance, ParamEnv, ScalarInt, Ty, TyCtxt, TypeFoldable,\n+};\n+use rustc_session::lint;\n+use rustc_span::{def_id::DefId, Span};\n+use rustc_target::abi::{HasDataLayout, Size, TargetDataLayout};\n+use rustc_target::spec::abi::Abi;\n+use rustc_trait_selection::traits;\n+\n+use crate::MirLint;\n+use rustc_const_eval::const_eval::ConstEvalErr;\n+use rustc_const_eval::interpret::{\n+    self, compile_time_machine, AllocId, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n+    LocalState, LocalValue, MemPlace, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Scalar,\n+    ScalarMaybeUninit, StackPopCleanup, StackPopUnwind,\n+};\n+\n+/// The maximum number of bytes that we'll allocate space for a local or the return value.\n+/// Needed for #66397, because otherwise we eval into large places and that can cause OOM or just\n+/// Severely regress performance.\n+const MAX_ALLOC_LIMIT: u64 = 1024;\n+\n+/// Macro for machine-specific `InterpError` without allocation.\n+/// (These will never be shown to the user, but they help diagnose ICEs.)\n+macro_rules! throw_machine_stop_str {\n+    ($($tt:tt)*) => {{\n+        // We make a new local type for it. The type itself does not carry any information,\n+        // but its vtable (for the `MachineStopType` trait) does.\n+        struct Zst;\n+        // Printing this type shows the desired string.\n+        impl std::fmt::Display for Zst {\n+            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+                write!(f, $($tt)*)\n+            }\n+        }\n+        impl rustc_middle::mir::interpret::MachineStopType for Zst {}\n+        throw_machine_stop!(Zst)\n+    }};\n+}\n+\n+pub struct ConstProp;\n+\n+impl<'tcx> MirLint<'tcx> for ConstProp {\n+    fn run_lint(&self, tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n+        // will be evaluated by miri and produce its errors there\n+        if body.source.promoted.is_some() {\n+            return;\n+        }\n+\n+        let def_id = body.source.def_id().expect_local();\n+        let is_fn_like = tcx.hir().get_by_def_id(def_id).fn_kind().is_some();\n+        let is_assoc_const = tcx.def_kind(def_id) == DefKind::AssocConst;\n+\n+        // Only run const prop on functions, methods, closures and associated constants\n+        if !is_fn_like && !is_assoc_const {\n+            // skip anon_const/statics/consts because they'll be evaluated by miri anyway\n+            trace!(\"ConstProp skipped for {:?}\", def_id);\n+            return;\n+        }\n+\n+        let is_generator = tcx.type_of(def_id.to_def_id()).is_generator();\n+        // FIXME(welseywiser) const prop doesn't work on generators because of query cycles\n+        // computing their layout.\n+        if is_generator {\n+            trace!(\"ConstProp skipped for generator {:?}\", def_id);\n+            return;\n+        }\n+\n+        // Check if it's even possible to satisfy the 'where' clauses\n+        // for this item.\n+        // This branch will never be taken for any normal function.\n+        // However, it's possible to `#!feature(trivial_bounds)]` to write\n+        // a function with impossible to satisfy clauses, e.g.:\n+        // `fn foo() where String: Copy {}`\n+        //\n+        // We don't usually need to worry about this kind of case,\n+        // since we would get a compilation error if the user tried\n+        // to call it. However, since we can do const propagation\n+        // even without any calls to the function, we need to make\n+        // sure that it even makes sense to try to evaluate the body.\n+        // If there are unsatisfiable where clauses, then all bets are\n+        // off, and we just give up.\n+        //\n+        // We manually filter the predicates, skipping anything that's not\n+        // \"global\". We are in a potentially generic context\n+        // (e.g. we are evaluating a function without substituting generic\n+        // parameters, so this filtering serves two purposes:\n+        //\n+        // 1. We skip evaluating any predicates that we would\n+        // never be able prove are unsatisfiable (e.g. `<T as Foo>`\n+        // 2. We avoid trying to normalize predicates involving generic\n+        // parameters (e.g. `<T as Foo>::MyItem`). This can confuse\n+        // the normalization code (leading to cycle errors), since\n+        // it's usually never invoked in this way.\n+        let predicates = tcx\n+            .predicates_of(def_id.to_def_id())\n+            .predicates\n+            .iter()\n+            .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n+        if traits::impossible_predicates(\n+            tcx,\n+            traits::elaborate_predicates(tcx, predicates).map(|o| o.predicate).collect(),\n+        ) {\n+            trace!(\"ConstProp skipped for {:?}: found unsatisfiable predicates\", def_id);\n+            return;\n+        }\n+\n+        trace!(\"ConstProp starting for {:?}\", def_id);\n+\n+        let dummy_body = &Body::new(\n+            body.source,\n+            body.basic_blocks().clone(),\n+            body.source_scopes.clone(),\n+            body.local_decls.clone(),\n+            Default::default(),\n+            body.arg_count,\n+            Default::default(),\n+            body.span,\n+            body.generator_kind(),\n+            body.tainted_by_errors,\n+        );\n+\n+        // FIXME(oli-obk, eddyb) Optimize locals (or even local paths) to hold\n+        // constants, instead of just checking for const-folding succeeding.\n+        // That would require a uniform one-def no-mutation analysis\n+        // and RPO (or recursing when needing the value of a local).\n+        let mut optimization_finder = ConstPropagator::new(body, dummy_body, tcx);\n+        optimization_finder.visit_body(body);\n+\n+        trace!(\"ConstProp done for {:?}\", def_id);\n+    }\n+}\n+\n+struct ConstPropMachine<'mir, 'tcx> {\n+    /// The virtual call stack.\n+    stack: Vec<Frame<'mir, 'tcx>>,\n+    /// `OnlyInsideOwnBlock` locals that were written in the current block get erased at the end.\n+    written_only_inside_own_block_locals: FxHashSet<Local>,\n+    /// Locals that need to be cleared after every block terminates.\n+    only_propagate_inside_block_locals: BitSet<Local>,\n+    can_const_prop: IndexVec<Local, ConstPropMode>,\n+}\n+\n+impl ConstPropMachine<'_, '_> {\n+    fn new(\n+        only_propagate_inside_block_locals: BitSet<Local>,\n+        can_const_prop: IndexVec<Local, ConstPropMode>,\n+    ) -> Self {\n+        Self {\n+            stack: Vec::new(),\n+            written_only_inside_own_block_locals: Default::default(),\n+            only_propagate_inside_block_locals,\n+            can_const_prop,\n+        }\n+    }\n+}\n+\n+impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx> {\n+    compile_time_machine!(<'mir, 'tcx>);\n+    const PANIC_ON_ALLOC_FAIL: bool = true; // all allocations are small (see `MAX_ALLOC_LIMIT`)\n+\n+    type MemoryKind = !;\n+\n+    type MemoryExtra = ();\n+\n+    fn load_mir(\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        _instance: ty::InstanceDef<'tcx>,\n+    ) -> InterpResult<'tcx, &'tcx Body<'tcx>> {\n+        throw_machine_stop_str!(\"calling functions isn't supported in ConstProp\")\n+    }\n+\n+    fn find_mir_or_eval_fn(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _instance: ty::Instance<'tcx>,\n+        _abi: Abi,\n+        _args: &[OpTy<'tcx>],\n+        _ret: Option<(&PlaceTy<'tcx>, BasicBlock)>,\n+        _unwind: StackPopUnwind,\n+    ) -> InterpResult<'tcx, Option<(&'mir Body<'tcx>, ty::Instance<'tcx>)>> {\n+        Ok(None)\n+    }\n+\n+    fn call_intrinsic(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _instance: ty::Instance<'tcx>,\n+        _args: &[OpTy<'tcx>],\n+        _ret: Option<(&PlaceTy<'tcx>, BasicBlock)>,\n+        _unwind: StackPopUnwind,\n+    ) -> InterpResult<'tcx> {\n+        throw_machine_stop_str!(\"calling intrinsics isn't supported in ConstProp\")\n+    }\n+\n+    fn assert_panic(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _msg: &rustc_middle::mir::AssertMessage<'tcx>,\n+        _unwind: Option<rustc_middle::mir::BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        bug!(\"panics terminators are not evaluated in ConstProp\")\n+    }\n+\n+    fn binary_ptr_op(\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        _bin_op: BinOp,\n+        _left: &ImmTy<'tcx>,\n+        _right: &ImmTy<'tcx>,\n+    ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n+        // We can't do this because aliasing of memory can differ between const eval and llvm\n+        throw_machine_stop_str!(\"pointer arithmetic or comparisons aren't supported in ConstProp\")\n+    }\n+\n+    fn access_local(\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        frame: &Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n+        local: Local,\n+    ) -> InterpResult<'tcx, InterpOperand<Self::PointerTag>> {\n+        let l = &frame.locals[local];\n+\n+        if l.value == LocalValue::Unallocated {\n+            throw_machine_stop_str!(\"tried to access an uninitialized local\")\n+        }\n+\n+        l.access()\n+    }\n+\n+    fn access_local_mut<'a>(\n+        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n+        frame: usize,\n+        local: Local,\n+    ) -> InterpResult<'tcx, Result<&'a mut LocalValue<Self::PointerTag>, MemPlace<Self::PointerTag>>>\n+    {\n+        if ecx.machine.can_const_prop[local] == ConstPropMode::NoPropagation {\n+            throw_machine_stop_str!(\"tried to write to a local that is marked as not propagatable\")\n+        }\n+        if frame == 0 && ecx.machine.only_propagate_inside_block_locals.contains(local) {\n+            trace!(\n+                \"mutating local {:?} which is restricted to its block. \\\n+                Will remove it from const-prop after block is finished.\",\n+                local\n+            );\n+            ecx.machine.written_only_inside_own_block_locals.insert(local);\n+        }\n+        ecx.machine.stack[frame].locals[local].access_mut()\n+    }\n+\n+    fn before_access_global(\n+        _memory_extra: &(),\n+        _alloc_id: AllocId,\n+        alloc: ConstAllocation<'tcx, Self::PointerTag, Self::AllocExtra>,\n+        _static_def_id: Option<DefId>,\n+        is_write: bool,\n+    ) -> InterpResult<'tcx> {\n+        if is_write {\n+            throw_machine_stop_str!(\"can't write to global\");\n+        }\n+        // If the static allocation is mutable, then we can't const prop it as its content\n+        // might be different at runtime.\n+        if alloc.inner().mutability == Mutability::Mut {\n+            throw_machine_stop_str!(\"can't access mutable globals in ConstProp\");\n+        }\n+\n+        Ok(())\n+    }\n+\n+    #[inline(always)]\n+    fn init_frame_extra(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        frame: Frame<'mir, 'tcx>,\n+    ) -> InterpResult<'tcx, Frame<'mir, 'tcx>> {\n+        Ok(frame)\n+    }\n+\n+    #[inline(always)]\n+    fn stack<'a>(\n+        ecx: &'a InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a [Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>] {\n+        &ecx.machine.stack\n+    }\n+\n+    #[inline(always)]\n+    fn stack_mut<'a>(\n+        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n+    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>> {\n+        &mut ecx.machine.stack\n+    }\n+}\n+\n+/// Finds optimization opportunities on the MIR.\n+struct ConstPropagator<'mir, 'tcx> {\n+    ecx: InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>,\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    // FIXME(eddyb) avoid cloning these two fields more than once,\n+    // by accessing them through `ecx` instead.\n+    source_scopes: IndexVec<SourceScope, SourceScopeData<'tcx>>,\n+    local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n+    // Because we have `MutVisitor` we can't obtain the `SourceInfo` from a `Location`. So we store\n+    // the last known `SourceInfo` here and just keep revisiting it.\n+    source_info: Option<SourceInfo>,\n+}\n+\n+impl<'tcx> LayoutOfHelpers<'tcx> for ConstPropagator<'_, 'tcx> {\n+    type LayoutOfResult = Result<TyAndLayout<'tcx>, LayoutError<'tcx>>;\n+\n+    #[inline]\n+    fn handle_layout_err(&self, err: LayoutError<'tcx>, _: Span, _: Ty<'tcx>) -> LayoutError<'tcx> {\n+        err\n+    }\n+}\n+\n+impl HasDataLayout for ConstPropagator<'_, '_> {\n+    #[inline]\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        &self.tcx.data_layout\n+    }\n+}\n+\n+impl<'tcx> ty::layout::HasTyCtxt<'tcx> for ConstPropagator<'_, 'tcx> {\n+    #[inline]\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+}\n+\n+impl<'tcx> ty::layout::HasParamEnv<'tcx> for ConstPropagator<'_, 'tcx> {\n+    #[inline]\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.param_env\n+    }\n+}\n+\n+impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n+    fn new(\n+        body: &Body<'tcx>,\n+        dummy_body: &'mir Body<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> ConstPropagator<'mir, 'tcx> {\n+        let def_id = body.source.def_id();\n+        let substs = &InternalSubsts::identity_for_item(tcx, def_id);\n+        let param_env = tcx.param_env_reveal_all_normalized(def_id);\n+\n+        let span = tcx.def_span(def_id);\n+        // FIXME: `CanConstProp::check` computes the layout of all locals, return those layouts\n+        // so we can write them to `ecx.frame_mut().locals.layout, reducing the duplication in\n+        // `layout_of` query invocations.\n+        let can_const_prop = CanConstProp::check(tcx, param_env, body);\n+        let mut only_propagate_inside_block_locals = BitSet::new_empty(can_const_prop.len());\n+        for (l, mode) in can_const_prop.iter_enumerated() {\n+            if *mode == ConstPropMode::OnlyInsideOwnBlock {\n+                only_propagate_inside_block_locals.insert(l);\n+            }\n+        }\n+        let mut ecx = InterpCx::new(\n+            tcx,\n+            span,\n+            param_env,\n+            ConstPropMachine::new(only_propagate_inside_block_locals, can_const_prop),\n+            (),\n+        );\n+\n+        let ret = ecx\n+            .layout_of(body.return_ty().subst(tcx, substs))\n+            .ok()\n+            // Don't bother allocating memory for ZST types which have no values\n+            // or for large values.\n+            .filter(|ret_layout| {\n+                !ret_layout.is_zst() && ret_layout.size < Size::from_bytes(MAX_ALLOC_LIMIT)\n+            })\n+            .map(|ret_layout| {\n+                ecx.allocate(ret_layout, MemoryKind::Stack)\n+                    .expect(\"couldn't perform small allocation\")\n+                    .into()\n+            });\n+\n+        ecx.push_stack_frame(\n+            Instance::new(def_id, substs),\n+            dummy_body,\n+            ret.as_ref(),\n+            StackPopCleanup::Root { cleanup: false },\n+        )\n+        .expect(\"failed to push initial stack frame\");\n+\n+        ConstPropagator {\n+            ecx,\n+            tcx,\n+            param_env,\n+            // FIXME(eddyb) avoid cloning these two fields more than once,\n+            // by accessing them through `ecx` instead.\n+            source_scopes: body.source_scopes.clone(),\n+            //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_body()` needs it\n+            local_decls: body.local_decls.clone(),\n+            source_info: None,\n+        }\n+    }\n+\n+    fn get_const(&self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n+        let op = match self.ecx.eval_place_to_op(place, None) {\n+            Ok(op) => op,\n+            Err(e) => {\n+                trace!(\"get_const failed: {}\", e);\n+                return None;\n+            }\n+        };\n+\n+        // Try to read the local as an immediate so that if it is representable as a scalar, we can\n+        // handle it as such, but otherwise, just return the value as is.\n+        Some(match self.ecx.try_read_immediate(&op) {\n+            Ok(Ok(imm)) => imm.into(),\n+            _ => op,\n+        })\n+    }\n+\n+    /// Remove `local` from the pool of `Locals`. Allows writing to them,\n+    /// but not reading from them anymore.\n+    fn remove_const(ecx: &mut InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>, local: Local) {\n+        ecx.frame_mut().locals[local] =\n+            LocalState { value: LocalValue::Unallocated, layout: Cell::new(None) };\n+    }\n+\n+    fn lint_root(&self, source_info: SourceInfo) -> Option<HirId> {\n+        source_info.scope.lint_root(&self.source_scopes)\n+    }\n+\n+    fn use_ecx<F, T>(&mut self, f: F) -> Option<T>\n+    where\n+        F: FnOnce(&mut Self) -> InterpResult<'tcx, T>,\n+    {\n+        match f(self) {\n+            Ok(val) => Some(val),\n+            Err(error) => {\n+                trace!(\"InterpCx operation failed: {:?}\", error);\n+                // Some errors shouldn't come up because creating them causes\n+                // an allocation, which we should avoid. When that happens,\n+                // dedicated error variants should be introduced instead.\n+                assert!(\n+                    !error.kind().formatted_string(),\n+                    \"const-prop encountered formatting error: {}\",\n+                    error\n+                );\n+                None\n+            }\n+        }\n+    }\n+\n+    /// Returns the value, if any, of evaluating `c`.\n+    fn eval_constant(&mut self, c: &Constant<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n+        // FIXME we need to revisit this for #67176\n+        if c.needs_subst() {\n+            return None;\n+        }\n+\n+        match self.ecx.mir_const_to_op(&c.literal, None) {\n+            Ok(op) => Some(op),\n+            Err(error) => {\n+                let tcx = self.ecx.tcx.at(c.span);\n+                let err = ConstEvalErr::new(&self.ecx, error, Some(c.span));\n+                if let Some(lint_root) = self.lint_root(source_info) {\n+                    let lint_only = match c.literal {\n+                        ConstantKind::Ty(ct) => match ct.val() {\n+                            // Promoteds must lint and not error as the user didn't ask for them\n+                            ConstKind::Unevaluated(ty::Unevaluated {\n+                                def: _,\n+                                substs: _,\n+                                promoted: Some(_),\n+                            }) => true,\n+                            // Out of backwards compatibility we cannot report hard errors in unused\n+                            // generic functions using associated constants of the generic parameters.\n+                            _ => c.literal.needs_subst(),\n+                        },\n+                        ConstantKind::Val(_, ty) => ty.needs_subst(),\n+                    };\n+                    if lint_only {\n+                        // Out of backwards compatibility we cannot report hard errors in unused\n+                        // generic functions using associated constants of the generic parameters.\n+                        err.report_as_lint(tcx, \"erroneous constant used\", lint_root, Some(c.span));\n+                    } else {\n+                        err.report_as_error(tcx, \"erroneous constant used\");\n+                    }\n+                } else {\n+                    err.report_as_error(tcx, \"erroneous constant used\");\n+                }\n+                None\n+            }\n+        }\n+    }\n+\n+    /// Returns the value, if any, of evaluating `place`.\n+    fn eval_place(&mut self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n+        trace!(\"eval_place(place={:?})\", place);\n+        self.use_ecx(|this| this.ecx.eval_place_to_op(place, None))\n+    }\n+\n+    /// Returns the value, if any, of evaluating `op`. Calls upon `eval_constant`\n+    /// or `eval_place`, depending on the variant of `Operand` used.\n+    fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n+        match *op {\n+            Operand::Constant(ref c) => self.eval_constant(c, source_info),\n+            Operand::Move(place) | Operand::Copy(place) => self.eval_place(place),\n+        }\n+    }\n+\n+    fn report_assert_as_lint(\n+        &self,\n+        lint: &'static lint::Lint,\n+        source_info: SourceInfo,\n+        message: &'static str,\n+        panic: AssertKind<impl std::fmt::Debug>,\n+    ) {\n+        if let Some(lint_root) = self.lint_root(source_info) {\n+            self.tcx.struct_span_lint_hir(lint, lint_root, source_info.span, |lint| {\n+                let mut err = lint.build(message);\n+                err.span_label(source_info.span, format!(\"{:?}\", panic));\n+                err.emit();\n+            });\n+        }\n+    }\n+\n+    fn check_unary_op(\n+        &mut self,\n+        op: UnOp,\n+        arg: &Operand<'tcx>,\n+        source_info: SourceInfo,\n+    ) -> Option<()> {\n+        if let (val, true) = self.use_ecx(|this| {\n+            let val = this.ecx.read_immediate(&this.ecx.eval_operand(arg, None)?)?;\n+            let (_res, overflow, _ty) = this.ecx.overflowing_unary_op(op, &val)?;\n+            Ok((val, overflow))\n+        })? {\n+            // `AssertKind` only has an `OverflowNeg` variant, so make sure that is\n+            // appropriate to use.\n+            assert_eq!(op, UnOp::Neg, \"Neg is the only UnOp that can overflow\");\n+            self.report_assert_as_lint(\n+                lint::builtin::ARITHMETIC_OVERFLOW,\n+                source_info,\n+                \"this arithmetic operation will overflow\",\n+                AssertKind::OverflowNeg(val.to_const_int()),\n+            );\n+            return None;\n+        }\n+\n+        Some(())\n+    }\n+\n+    fn check_binary_op(\n+        &mut self,\n+        op: BinOp,\n+        left: &Operand<'tcx>,\n+        right: &Operand<'tcx>,\n+        source_info: SourceInfo,\n+    ) -> Option<()> {\n+        let r = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(right, None)?));\n+        let l = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?));\n+        // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n+        if op == BinOp::Shr || op == BinOp::Shl {\n+            let r = r?;\n+            // We need the type of the LHS. We cannot use `place_layout` as that is the type\n+            // of the result, which for checked binops is not the same!\n+            let left_ty = left.ty(&self.local_decls, self.tcx);\n+            let left_size = self.ecx.layout_of(left_ty).ok()?.size;\n+            let right_size = r.layout.size;\n+            let r_bits = r.to_scalar().ok();\n+            let r_bits = r_bits.and_then(|r| r.to_bits(right_size).ok());\n+            if r_bits.map_or(false, |b| b >= left_size.bits() as u128) {\n+                debug!(\"check_binary_op: reporting assert for {:?}\", source_info);\n+                self.report_assert_as_lint(\n+                    lint::builtin::ARITHMETIC_OVERFLOW,\n+                    source_info,\n+                    \"this arithmetic operation will overflow\",\n+                    AssertKind::Overflow(\n+                        op,\n+                        match l {\n+                            Some(l) => l.to_const_int(),\n+                            // Invent a dummy value, the diagnostic ignores it anyway\n+                            None => ConstInt::new(\n+                                ScalarInt::try_from_uint(1_u8, left_size).unwrap(),\n+                                left_ty.is_signed(),\n+                                left_ty.is_ptr_sized_integral(),\n+                            ),\n+                        },\n+                        r.to_const_int(),\n+                    ),\n+                );\n+                return None;\n+            }\n+        }\n+\n+        if let (Some(l), Some(r)) = (&l, &r) {\n+            // The remaining operators are handled through `overflowing_binary_op`.\n+            if self.use_ecx(|this| {\n+                let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n+                Ok(overflow)\n+            })? {\n+                self.report_assert_as_lint(\n+                    lint::builtin::ARITHMETIC_OVERFLOW,\n+                    source_info,\n+                    \"this arithmetic operation will overflow\",\n+                    AssertKind::Overflow(op, l.to_const_int(), r.to_const_int()),\n+                );\n+                return None;\n+            }\n+        }\n+        Some(())\n+    }\n+\n+    fn const_prop(\n+        &mut self,\n+        rvalue: &Rvalue<'tcx>,\n+        source_info: SourceInfo,\n+        place: Place<'tcx>,\n+    ) -> Option<()> {\n+        // Perform any special handling for specific Rvalue types.\n+        // Generally, checks here fall into one of two categories:\n+        //   1. Additional checking to provide useful lints to the user\n+        //        - In this case, we will do some validation and then fall through to the\n+        //          end of the function which evals the assignment.\n+        //   2. Working around bugs in other parts of the compiler\n+        //        - In this case, we'll return `None` from this function to stop evaluation.\n+        match rvalue {\n+            // Additional checking: give lints to the user if an overflow would occur.\n+            // We do this here and not in the `Assert` terminator as that terminator is\n+            // only sometimes emitted (overflow checks can be disabled), but we want to always\n+            // lint.\n+            Rvalue::UnaryOp(op, arg) => {\n+                trace!(\"checking UnaryOp(op = {:?}, arg = {:?})\", op, arg);\n+                self.check_unary_op(*op, arg, source_info)?;\n+            }\n+            Rvalue::BinaryOp(op, box (left, right)) => {\n+                trace!(\"checking BinaryOp(op = {:?}, left = {:?}, right = {:?})\", op, left, right);\n+                self.check_binary_op(*op, left, right, source_info)?;\n+            }\n+            Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n+                trace!(\n+                    \"checking CheckedBinaryOp(op = {:?}, left = {:?}, right = {:?})\",\n+                    op,\n+                    left,\n+                    right\n+                );\n+                self.check_binary_op(*op, left, right, source_info)?;\n+            }\n+\n+            // Do not try creating references (#67862)\n+            Rvalue::AddressOf(_, place) | Rvalue::Ref(_, _, place) => {\n+                trace!(\"skipping AddressOf | Ref for {:?}\", place);\n+\n+                // This may be creating mutable references or immutable references to cells.\n+                // If that happens, the pointed to value could be mutated via that reference.\n+                // Since we aren't tracking references, the const propagator loses track of what\n+                // value the local has right now.\n+                // Thus, all locals that have their reference taken\n+                // must not take part in propagation.\n+                Self::remove_const(&mut self.ecx, place.local);\n+\n+                return None;\n+            }\n+            Rvalue::ThreadLocalRef(def_id) => {\n+                trace!(\"skipping ThreadLocalRef({:?})\", def_id);\n+\n+                return None;\n+            }\n+\n+            // There's no other checking to do at this time.\n+            Rvalue::Aggregate(..)\n+            | Rvalue::Use(..)\n+            | Rvalue::Repeat(..)\n+            | Rvalue::Len(..)\n+            | Rvalue::Cast(..)\n+            | Rvalue::ShallowInitBox(..)\n+            | Rvalue::Discriminant(..)\n+            | Rvalue::NullaryOp(..) => {}\n+        }\n+\n+        // FIXME we need to revisit this for #67176\n+        if rvalue.needs_subst() {\n+            return None;\n+        }\n+\n+        self.use_ecx(|this| this.ecx.eval_rvalue_into_place(rvalue, place))\n+    }\n+}\n+\n+/// The mode that `ConstProp` is allowed to run in for a given `Local`.\n+#[derive(Clone, Copy, Debug, PartialEq)]\n+enum ConstPropMode {\n+    /// The `Local` can be propagated into and reads of this `Local` can also be propagated.\n+    FullConstProp,\n+    /// The `Local` can only be propagated into and from its own block.\n+    OnlyInsideOwnBlock,\n+    /// The `Local` can be propagated into but reads cannot be propagated.\n+    OnlyPropagateInto,\n+    /// The `Local` cannot be part of propagation at all. Any statement\n+    /// referencing it either for reading or writing will not get propagated.\n+    NoPropagation,\n+}\n+\n+struct CanConstProp {\n+    can_const_prop: IndexVec<Local, ConstPropMode>,\n+    // False at the beginning. Once set, no more assignments are allowed to that local.\n+    found_assignment: BitSet<Local>,\n+    // Cache of locals' information\n+    local_kinds: IndexVec<Local, LocalKind>,\n+}\n+\n+impl CanConstProp {\n+    /// Returns true if `local` can be propagated\n+    fn check<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+        body: &Body<'tcx>,\n+    ) -> IndexVec<Local, ConstPropMode> {\n+        let mut cpv = CanConstProp {\n+            can_const_prop: IndexVec::from_elem(ConstPropMode::FullConstProp, &body.local_decls),\n+            found_assignment: BitSet::new_empty(body.local_decls.len()),\n+            local_kinds: IndexVec::from_fn_n(\n+                |local| body.local_kind(local),\n+                body.local_decls.len(),\n+            ),\n+        };\n+        for (local, val) in cpv.can_const_prop.iter_enumerated_mut() {\n+            let ty = body.local_decls[local].ty;\n+            match tcx.layout_of(param_env.and(ty)) {\n+                Ok(layout) if layout.size < Size::from_bytes(MAX_ALLOC_LIMIT) => {}\n+                // Either the layout fails to compute, then we can't use this local anyway\n+                // or the local is too large, then we don't want to.\n+                _ => {\n+                    *val = ConstPropMode::NoPropagation;\n+                    continue;\n+                }\n+            }\n+            // Cannot use args at all\n+            // Cannot use locals because if x < y { y - x } else { x - y } would\n+            //        lint for x != y\n+            // FIXME(oli-obk): lint variables until they are used in a condition\n+            // FIXME(oli-obk): lint if return value is constant\n+            if cpv.local_kinds[local] == LocalKind::Arg {\n+                *val = ConstPropMode::OnlyPropagateInto;\n+                trace!(\n+                    \"local {:?} can't be const propagated because it's a function argument\",\n+                    local\n+                );\n+            } else if cpv.local_kinds[local] == LocalKind::Var {\n+                *val = ConstPropMode::OnlyInsideOwnBlock;\n+                trace!(\n+                    \"local {:?} will only be propagated inside its block, because it's a user variable\",\n+                    local\n+                );\n+            }\n+        }\n+        cpv.visit_body(&body);\n+        cpv.can_const_prop\n+    }\n+}\n+\n+impl Visitor<'_> for CanConstProp {\n+    fn visit_local(&mut self, &local: &Local, context: PlaceContext, _: Location) {\n+        use rustc_middle::mir::visit::PlaceContext::*;\n+        match context {\n+            // Projections are fine, because `&mut foo.x` will be caught by\n+            // `MutatingUseContext::Borrow` elsewhere.\n+            MutatingUse(MutatingUseContext::Projection)\n+            // These are just stores, where the storing is not propagatable, but there may be later\n+            // mutations of the same local via `Store`\n+            | MutatingUse(MutatingUseContext::Call)\n+            | MutatingUse(MutatingUseContext::AsmOutput)\n+            // Actual store that can possibly even propagate a value\n+            | MutatingUse(MutatingUseContext::Store) => {\n+                if !self.found_assignment.insert(local) {\n+                    match &mut self.can_const_prop[local] {\n+                        // If the local can only get propagated in its own block, then we don't have\n+                        // to worry about multiple assignments, as we'll nuke the const state at the\n+                        // end of the block anyway, and inside the block we overwrite previous\n+                        // states as applicable.\n+                        ConstPropMode::OnlyInsideOwnBlock => {}\n+                        ConstPropMode::NoPropagation => {}\n+                        ConstPropMode::OnlyPropagateInto => {}\n+                        other @ ConstPropMode::FullConstProp => {\n+                            trace!(\n+                                \"local {:?} can't be propagated because of multiple assignments. Previous state: {:?}\",\n+                                local, other,\n+                            );\n+                            *other = ConstPropMode::OnlyInsideOwnBlock;\n+                        }\n+                    }\n+                }\n+            }\n+            // Reading constants is allowed an arbitrary number of times\n+            NonMutatingUse(NonMutatingUseContext::Copy)\n+            | NonMutatingUse(NonMutatingUseContext::Move)\n+            | NonMutatingUse(NonMutatingUseContext::Inspect)\n+            | NonMutatingUse(NonMutatingUseContext::Projection)\n+            | NonUse(_) => {}\n+\n+            // These could be propagated with a smarter analysis or just some careful thinking about\n+            // whether they'd be fine right now.\n+            MutatingUse(MutatingUseContext::Yield)\n+            | MutatingUse(MutatingUseContext::Drop)\n+            | MutatingUse(MutatingUseContext::Retag)\n+            // These can't ever be propagated under any scheme, as we can't reason about indirect\n+            // mutation.\n+            | NonMutatingUse(NonMutatingUseContext::SharedBorrow)\n+            | NonMutatingUse(NonMutatingUseContext::ShallowBorrow)\n+            | NonMutatingUse(NonMutatingUseContext::UniqueBorrow)\n+            | NonMutatingUse(NonMutatingUseContext::AddressOf)\n+            | MutatingUse(MutatingUseContext::Borrow)\n+            | MutatingUse(MutatingUseContext::AddressOf) => {\n+                trace!(\"local {:?} can't be propagaged because it's used: {:?}\", local, context);\n+                self.can_const_prop[local] = ConstPropMode::NoPropagation;\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n+    fn visit_body(&mut self, body: &Body<'tcx>) {\n+        for (bb, data) in body.basic_blocks().iter_enumerated() {\n+            self.visit_basic_block_data(bb, data);\n+        }\n+    }\n+\n+    fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n+        self.super_operand(operand, location);\n+    }\n+\n+    fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n+        trace!(\"visit_constant: {:?}\", constant);\n+        self.super_constant(constant, location);\n+        self.eval_constant(constant, self.source_info.unwrap());\n+    }\n+\n+    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n+        trace!(\"visit_statement: {:?}\", statement);\n+        let source_info = statement.source_info;\n+        self.source_info = Some(source_info);\n+        if let StatementKind::Assign(box (place, ref rval)) = statement.kind {\n+            let can_const_prop = self.ecx.machine.can_const_prop[place.local];\n+            if let Some(()) = self.const_prop(rval, source_info, place) {\n+                match can_const_prop {\n+                    ConstPropMode::OnlyInsideOwnBlock => {\n+                        trace!(\n+                            \"found local restricted to its block. \\\n+                                Will remove it from const-prop after block is finished. Local: {:?}\",\n+                            place.local\n+                        );\n+                    }\n+                    ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n+                        trace!(\"can't propagate into {:?}\", place);\n+                        if place.local != RETURN_PLACE {\n+                            Self::remove_const(&mut self.ecx, place.local);\n+                        }\n+                    }\n+                    ConstPropMode::FullConstProp => {}\n+                }\n+            } else {\n+                // Const prop failed, so erase the destination, ensuring that whatever happens\n+                // from here on, does not know about the previous value.\n+                // This is important in case we have\n+                // ```rust\n+                // let mut x = 42;\n+                // x = SOME_MUTABLE_STATIC;\n+                // // x must now be uninit\n+                // ```\n+                // FIXME: we overzealously erase the entire local, because that's easier to\n+                // implement.\n+                trace!(\n+                    \"propagation into {:?} failed.\n+                        Nuking the entire site from orbit, it's the only way to be sure\",\n+                    place,\n+                );\n+                Self::remove_const(&mut self.ecx, place.local);\n+            }\n+        } else {\n+            match statement.kind {\n+                StatementKind::SetDiscriminant { ref place, .. } => {\n+                    match self.ecx.machine.can_const_prop[place.local] {\n+                        ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n+                            if self.use_ecx(|this| this.ecx.statement(statement)).is_some() {\n+                                trace!(\"propped discriminant into {:?}\", place);\n+                            } else {\n+                                Self::remove_const(&mut self.ecx, place.local);\n+                            }\n+                        }\n+                        ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n+                            Self::remove_const(&mut self.ecx, place.local);\n+                        }\n+                    }\n+                }\n+                StatementKind::StorageLive(local) | StatementKind::StorageDead(local) => {\n+                    let frame = self.ecx.frame_mut();\n+                    frame.locals[local].value =\n+                        if let StatementKind::StorageLive(_) = statement.kind {\n+                            LocalValue::Unallocated\n+                        } else {\n+                            LocalValue::Dead\n+                        };\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        self.super_statement(statement, location);\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        let source_info = terminator.source_info;\n+        self.source_info = Some(source_info);\n+        self.super_terminator(terminator, location);\n+        match &terminator.kind {\n+            TerminatorKind::Assert { expected, ref msg, ref cond, .. } => {\n+                if let Some(ref value) = self.eval_operand(&cond, source_info) {\n+                    trace!(\"assertion on {:?} should be {:?}\", value, expected);\n+                    let expected = ScalarMaybeUninit::from(Scalar::from_bool(*expected));\n+                    let value_const = self.ecx.read_scalar(&value).unwrap();\n+                    if expected != value_const {\n+                        enum DbgVal<T> {\n+                            Val(T),\n+                            Underscore,\n+                        }\n+                        impl<T: std::fmt::Debug> std::fmt::Debug for DbgVal<T> {\n+                            fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+                                match self {\n+                                    Self::Val(val) => val.fmt(fmt),\n+                                    Self::Underscore => fmt.write_str(\"_\"),\n+                                }\n+                            }\n+                        }\n+                        let mut eval_to_int = |op| {\n+                            // This can be `None` if the lhs wasn't const propagated and we just\n+                            // triggered the assert on the value of the rhs.\n+                            self.eval_operand(op, source_info).map_or(DbgVal::Underscore, |op| {\n+                                DbgVal::Val(self.ecx.read_immediate(&op).unwrap().to_const_int())\n+                            })\n+                        };\n+                        let msg = match msg {\n+                            AssertKind::DivisionByZero(op) => {\n+                                Some(AssertKind::DivisionByZero(eval_to_int(op)))\n+                            }\n+                            AssertKind::RemainderByZero(op) => {\n+                                Some(AssertKind::RemainderByZero(eval_to_int(op)))\n+                            }\n+                            AssertKind::Overflow(bin_op @ (BinOp::Div | BinOp::Rem), op1, op2) => {\n+                                // Division overflow is *UB* in the MIR, and different than the\n+                                // other overflow checks.\n+                                Some(AssertKind::Overflow(\n+                                    *bin_op,\n+                                    eval_to_int(op1),\n+                                    eval_to_int(op2),\n+                                ))\n+                            }\n+                            AssertKind::BoundsCheck { ref len, ref index } => {\n+                                let len = eval_to_int(len);\n+                                let index = eval_to_int(index);\n+                                Some(AssertKind::BoundsCheck { len, index })\n+                            }\n+                            // Remaining overflow errors are already covered by checks on the binary operators.\n+                            AssertKind::Overflow(..) | AssertKind::OverflowNeg(_) => None,\n+                            // Need proper const propagator for these.\n+                            _ => None,\n+                        };\n+                        // Poison all places this operand references so that further code\n+                        // doesn't use the invalid value\n+                        match cond {\n+                            Operand::Move(ref place) | Operand::Copy(ref place) => {\n+                                Self::remove_const(&mut self.ecx, place.local);\n+                            }\n+                            Operand::Constant(_) => {}\n+                        }\n+                        if let Some(msg) = msg {\n+                            self.report_assert_as_lint(\n+                                lint::builtin::UNCONDITIONAL_PANIC,\n+                                source_info,\n+                                \"this operation will panic at runtime\",\n+                                msg,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+            // None of these have Operands to const-propagate.\n+            TerminatorKind::Goto { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::Drop { .. }\n+            | TerminatorKind::DropAndReplace { .. }\n+            | TerminatorKind::Yield { .. }\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::FalseEdge { .. }\n+            | TerminatorKind::FalseUnwind { .. }\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::Call { .. }\n+            | TerminatorKind::InlineAsm { .. } => {}\n+        }\n+\n+        // We remove all Locals which are restricted in propagation to their containing blocks and\n+        // which were modified in the current block.\n+        // Take it out of the ecx so we can get a mutable reference to the ecx for `remove_const`.\n+        let mut locals = std::mem::take(&mut self.ecx.machine.written_only_inside_own_block_locals);\n+        for &local in locals.iter() {\n+            Self::remove_const(&mut self.ecx, local);\n+        }\n+        locals.clear();\n+        // Put it back so we reuse the heap of the storage\n+        self.ecx.machine.written_only_inside_own_block_locals = locals;\n+        if cfg!(debug_assertions) {\n+            // Ensure we are correctly erasing locals with the non-debug-assert logic.\n+            for local in self.ecx.machine.only_propagate_inside_block_locals.iter() {\n+                assert!(\n+                    self.get_const(local.into()).is_none()\n+                        || self\n+                            .layout_of(self.local_decls[local].ty)\n+                            .map_or(true, |layout| layout.is_zst())\n+                )\n+            }\n+        }\n+    }\n+}"}, {"sha": "45b8febf9f63ccba263072d65932bd2d88fd97e3", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -49,6 +49,7 @@ pub mod cleanup_post_borrowck;\n mod const_debuginfo;\n mod const_goto;\n mod const_prop;\n+mod const_prop_lint;\n mod coverage;\n mod deaggregator;\n mod deduplicate_blocks;\n@@ -430,6 +431,7 @@ fn run_post_borrowck_cleanup_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tc\n         // `Deaggregator` is conceptually part of MIR building, some backends rely on it happening\n         // and it can help optimizations.\n         &deaggregator::Deaggregator,\n+        &Lint(const_prop_lint::ConstProp),\n     ];\n \n     pm::run_passes(tcx, body, post_borrowck_cleanup);"}, {"sha": "e6afbe49864ba1042a62f139b464d6015201ef11", "filename": "src/test/codegen/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fcodegen%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fcodegen%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fconsts.rs?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -10,7 +10,7 @@\n // CHECK: @STATIC = {{.*}}, align 4\n \n // This checks the constants from inline_enum_const\n-// CHECK: @alloc9 = {{.*}}, align 2\n+// CHECK: @alloc12 = {{.*}}, align 2\n \n // This checks the constants from {low,high}_align_const, they share the same\n // constant, but the alignment differs, so the higher one should be used"}, {"sha": "0315938a7eda60034184c049e4100fe61cfbfa9e", "filename": "src/test/ui/associated-consts/issue-24949-assoc-const-static-recursion-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-impl.rs?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -4,12 +4,12 @@ trait Foo {\n     const BAR: u32;\n }\n \n-const IMPL_REF_BAR: u32 = GlobalImplRef::BAR; //~ ERROR E0391\n+const IMPL_REF_BAR: u32 = GlobalImplRef::BAR;\n \n struct GlobalImplRef;\n \n impl GlobalImplRef {\n-    const BAR: u32 = IMPL_REF_BAR;\n+    const BAR: u32 = IMPL_REF_BAR; //~ ERROR E0391\n }\n \n fn main() {}"}, {"sha": "3d696bb049cd986b7e2d8388ba7d15b049c1e5d5", "filename": "src/test/ui/associated-consts/issue-24949-assoc-const-static-recursion-impl.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-impl.stderr?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -1,9 +1,15 @@\n-error[E0391]: cycle detected when simplifying constant for the type system `IMPL_REF_BAR`\n+error[E0391]: cycle detected when elaborating drops for `<impl at $DIR/issue-24949-assoc-const-static-recursion-impl.rs:11:1: 13:2>::BAR`\n+  --> $DIR/issue-24949-assoc-const-static-recursion-impl.rs:12:5\n+   |\n+LL |     const BAR: u32 = IMPL_REF_BAR;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: ...which requires normalizing `IMPL_REF_BAR`...\n+note: ...which requires simplifying constant for the type system `IMPL_REF_BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-impl.rs:7:1\n    |\n LL | const IMPL_REF_BAR: u32 = GlobalImplRef::BAR;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n note: ...which requires simplifying constant for the type system `IMPL_REF_BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-impl.rs:7:1\n    |\n@@ -35,8 +41,7 @@ note: ...which requires caching mir of `<impl at $DIR/issue-24949-assoc-const-st\n    |\n LL |     const BAR: u32 = IMPL_REF_BAR;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `IMPL_REF_BAR`...\n-   = note: ...which again requires simplifying constant for the type system `IMPL_REF_BAR`, completing the cycle\n+   = note: ...which again requires elaborating drops for `<impl at $DIR/issue-24949-assoc-const-static-recursion-impl.rs:11:1: 13:2>::BAR`, completing the cycle\n    = note: cycle used when running analysis passes on this crate\n \n error: aborting due to previous error"}, {"sha": "4e89f68628810f1544b107588a2ce236affa0987", "filename": "src/test/ui/associated-consts/issue-24949-assoc-const-static-recursion-trait-default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait-default.rs?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -5,10 +5,10 @@ trait Foo {\n }\n \n trait FooDefault {\n-    const BAR: u32 = DEFAULT_REF_BAR;\n+    const BAR: u32 = DEFAULT_REF_BAR; //~ ERROR E0391\n }\n \n-const DEFAULT_REF_BAR: u32 = <GlobalDefaultRef>::BAR; //~ ERROR E0391\n+const DEFAULT_REF_BAR: u32 = <GlobalDefaultRef>::BAR;\n \n struct GlobalDefaultRef;\n "}, {"sha": "71e26245e16af486c80049684235e3f8e6614af4", "filename": "src/test/ui/associated-consts/issue-24949-assoc-const-static-recursion-trait-default.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait-default.stderr?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -1,9 +1,15 @@\n-error[E0391]: cycle detected when simplifying constant for the type system `DEFAULT_REF_BAR`\n+error[E0391]: cycle detected when elaborating drops for `FooDefault::BAR`\n+  --> $DIR/issue-24949-assoc-const-static-recursion-trait-default.rs:8:5\n+   |\n+LL |     const BAR: u32 = DEFAULT_REF_BAR;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: ...which requires normalizing `DEFAULT_REF_BAR`...\n+note: ...which requires simplifying constant for the type system `DEFAULT_REF_BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-trait-default.rs:11:1\n    |\n LL | const DEFAULT_REF_BAR: u32 = <GlobalDefaultRef>::BAR;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n note: ...which requires simplifying constant for the type system `DEFAULT_REF_BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-trait-default.rs:11:1\n    |\n@@ -35,8 +41,7 @@ note: ...which requires caching mir of `FooDefault::BAR` for CTFE...\n    |\n LL |     const BAR: u32 = DEFAULT_REF_BAR;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `DEFAULT_REF_BAR`...\n-   = note: ...which again requires simplifying constant for the type system `DEFAULT_REF_BAR`, completing the cycle\n+   = note: ...which again requires elaborating drops for `FooDefault::BAR`, completing the cycle\n    = note: cycle used when running analysis passes on this crate\n \n error: aborting due to previous error"}, {"sha": "68b653ff3c52b812b47b7710b91d3168b84fafc8", "filename": "src/test/ui/associated-consts/issue-24949-assoc-const-static-recursion-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait.rs?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -4,12 +4,12 @@ trait Foo {\n     const BAR: u32;\n }\n \n-const TRAIT_REF_BAR: u32 = <GlobalTraitRef>::BAR; //~ ERROR E0391\n+const TRAIT_REF_BAR: u32 = <GlobalTraitRef>::BAR;\n \n struct GlobalTraitRef;\n \n impl Foo for GlobalTraitRef {\n-    const BAR: u32 = TRAIT_REF_BAR;\n+    const BAR: u32 = TRAIT_REF_BAR; //~ ERROR E0391\n }\n \n fn main() {}"}, {"sha": "020d758e153c2fcc8064bb8ece6df5d87d9770da", "filename": "src/test/ui/associated-consts/issue-24949-assoc-const-static-recursion-trait.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-24949-assoc-const-static-recursion-trait.stderr?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -1,9 +1,15 @@\n-error[E0391]: cycle detected when simplifying constant for the type system `TRAIT_REF_BAR`\n+error[E0391]: cycle detected when elaborating drops for `<impl at $DIR/issue-24949-assoc-const-static-recursion-trait.rs:11:1: 13:2>::BAR`\n+  --> $DIR/issue-24949-assoc-const-static-recursion-trait.rs:12:5\n+   |\n+LL |     const BAR: u32 = TRAIT_REF_BAR;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: ...which requires normalizing `TRAIT_REF_BAR`...\n+note: ...which requires simplifying constant for the type system `TRAIT_REF_BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-trait.rs:7:1\n    |\n LL | const TRAIT_REF_BAR: u32 = <GlobalTraitRef>::BAR;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n note: ...which requires simplifying constant for the type system `TRAIT_REF_BAR`...\n   --> $DIR/issue-24949-assoc-const-static-recursion-trait.rs:7:1\n    |\n@@ -35,8 +41,7 @@ note: ...which requires caching mir of `<impl at $DIR/issue-24949-assoc-const-st\n    |\n LL |     const BAR: u32 = TRAIT_REF_BAR;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires normalizing `TRAIT_REF_BAR`...\n-   = note: ...which again requires simplifying constant for the type system `TRAIT_REF_BAR`, completing the cycle\n+   = note: ...which again requires elaborating drops for `<impl at $DIR/issue-24949-assoc-const-static-recursion-trait.rs:11:1: 13:2>::BAR`, completing the cycle\n    = note: cycle used when running analysis passes on this crate\n \n error: aborting due to previous error"}, {"sha": "504f27811564b50bf4228f3c5ba1a8ef3d59e08f", "filename": "src/test/ui/const_prop/inline_spans.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconst_prop%2Finline_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconst_prop%2Finline_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst_prop%2Finline_spans.rs?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -1,18 +1,15 @@\n-// build-fail\n+// build-pass\n // compile-flags: -Zmir-opt-level=3\n+// Overflow can't be detected by const prop\n+// could only be detected after optimizations\n \n #![deny(warnings)]\n \n fn main() {\n     let _ = add(u8::MAX, 1);\n-    //~^ NOTE in this expansion of inlined source\n-    //~| NOTE in this expansion of inlined source\n }\n \n #[inline(always)]\n fn add(x: u8, y: u8) -> u8 {\n     x + y\n-    //~^ ERROR this arithmetic operation will overflow\n-    //~| NOTE attempt to compute `u8::MAX + 1_u8`, which would overflow\n-    //~| NOTE `#[deny(arithmetic_overflow)]` on by default\n }"}, {"sha": "f99a314238681418f7073e7a35b922ed0f19a7f6", "filename": "src/test/ui/const_prop/inline_spans.stderr", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4b133a7e27c32e822e9ff774e4436f184f5a9752/src%2Ftest%2Fui%2Fconst_prop%2Finline_spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b133a7e27c32e822e9ff774e4436f184f5a9752/src%2Ftest%2Fui%2Fconst_prop%2Finline_spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst_prop%2Finline_spans.stderr?ref=4b133a7e27c32e822e9ff774e4436f184f5a9752", "patch": "@@ -1,13 +0,0 @@\n-error: this arithmetic operation will overflow\n-  --> $DIR/inline_spans.rs:14:5\n-   |\n-LL |     let _ = add(u8::MAX, 1);\n-   |             --------------- in this inlined function call\n-...\n-LL |     x + y\n-   |     ^^^^^ attempt to compute `u8::MAX + 1_u8`, which would overflow\n-   |\n-   = note: `#[deny(arithmetic_overflow)]` on by default\n-\n-error: aborting due to previous error\n-"}, {"sha": "8bd5c08dc4649703ea896da727669de20f27ad76", "filename": "src/test/ui/consts/const-eval/const-eval-query-stack.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -21,6 +21,7 @@ LL |     let x: &'static i32 = &X;\n    |                            ^ referenced constant has errors\n query stack during panic:\n #0 [try_normalize_mir_const_after_erasing_regions] normalizing `main::promoted[1]`\n-#1 [optimized_mir] optimizing MIR for `main`\n-#2 [collect_and_partition_mono_items] collect_and_partition_mono_items\n+#1 [mir_drops_elaborated_and_const_checked] elaborating drops for `main`\n+#2 [optimized_mir] optimizing MIR for `main`\n+#3 [collect_and_partition_mono_items] collect_and_partition_mono_items\n end of query stack"}, {"sha": "cc4f1594c32ecc2f7e1a0b3da9dc9c402c305e97", "filename": "src/test/ui/consts/const-eval/issue-49296.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-49296.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-49296.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-49296.stderr?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -2,7 +2,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/issue-49296.rs:9:16\n    |\n LL | const X: u64 = *wat(42);\n-   |                ^^^^^^^^ pointer to alloc2 was dereferenced after this allocation got freed\n+   |                ^^^^^^^^ pointer to alloc3 was dereferenced after this allocation got freed\n \n error: aborting due to previous error\n "}, {"sha": "80b0a1432fbbb3bd37d747fab2e526560064f936", "filename": "src/test/ui/consts/const-eval/panic-assoc-never-type.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpanic-assoc-never-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpanic-assoc-never-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpanic-assoc-never-type.rs?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -13,4 +13,5 @@ impl PrintName {\n \n fn main() {\n     let _ = PrintName::VOID;\n+    //~^ ERROR erroneous constant used [E0080]\n }"}, {"sha": "0116a83910d6c9985dd9b3a635ee5c61cd5740e4", "filename": "src/test/ui/consts/const-eval/panic-assoc-never-type.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpanic-assoc-never-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpanic-assoc-never-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpanic-assoc-never-type.stderr?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -6,6 +6,12 @@ LL |     const VOID: ! = panic!();\n    |\n    = note: this error originates in the macro `$crate::panic::panic_2015` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to previous error\n+error[E0080]: erroneous constant used\n+  --> $DIR/panic-assoc-never-type.rs:15:13\n+   |\n+LL |     let _ = PrintName::VOID;\n+   |             ^^^^^^^^^^^^^^^ referenced constant has errors\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "5bfd4ef92a975cedb937a2e3d42c438e58fc0aa6", "filename": "src/test/ui/consts/const-eval/promoted_errors.noopt.stderr", "status": "modified", "additions": 45, "deletions": 3, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.noopt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.noopt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.noopt.stderr?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -1,3 +1,45 @@\n+warning: this arithmetic operation will overflow\n+  --> $DIR/promoted_errors.rs:15:5\n+   |\n+LL |     0 - 1\n+   |     ^^^^^ attempt to compute `0_u32 - 1_u32`, which would overflow\n+   |\n+note: the lint level is defined here\n+  --> $DIR/promoted_errors.rs:11:20\n+   |\n+LL | #![warn(const_err, arithmetic_overflow, unconditional_panic)]\n+   |                    ^^^^^^^^^^^^^^^^^^^\n+\n+warning: this operation will panic at runtime\n+  --> $DIR/promoted_errors.rs:21:5\n+   |\n+LL |     1 / 0\n+   |     ^^^^^ attempt to divide `1_i32` by zero\n+   |\n+note: the lint level is defined here\n+  --> $DIR/promoted_errors.rs:11:41\n+   |\n+LL | #![warn(const_err, arithmetic_overflow, unconditional_panic)]\n+   |                                         ^^^^^^^^^^^^^^^^^^^\n+\n+warning: this operation will panic at runtime\n+  --> $DIR/promoted_errors.rs:27:5\n+   |\n+LL |     1 / (1 - 1)\n+   |     ^^^^^^^^^^^ attempt to divide `1_i32` by zero\n+\n+warning: this operation will panic at runtime\n+  --> $DIR/promoted_errors.rs:31:5\n+   |\n+LL |     1 / (false as i32)\n+   |     ^^^^^^^^^^^^^^^^^^ attempt to divide `1_i32` by zero\n+\n+warning: this operation will panic at runtime\n+  --> $DIR/promoted_errors.rs:35:5\n+   |\n+LL |     [1, 2, 3][4]\n+   |     ^^^^^^^^^^^^ index out of bounds: the length is 3 but the index is 4\n+\n warning: any use of this value will cause an error\n   --> $DIR/promoted_errors.rs:15:5\n    |\n@@ -6,7 +48,7 @@ LL |       0 - 1\n    |       |\n    |       attempt to compute `0_u32 - 1_u32`, which would overflow\n    |       inside `overflow` at $DIR/promoted_errors.rs:15:5\n-   |       inside `X` at $DIR/promoted_errors.rs:38:29\n+   |       inside `X` at $DIR/promoted_errors.rs:43:29\n ...\n LL | / const X: () = {\n LL | |     let _x: &'static u32 = &overflow();\n@@ -26,7 +68,7 @@ LL | #![warn(const_err, arithmetic_overflow, unconditional_panic)]\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n warning: any use of this value will cause an error\n-  --> $DIR/promoted_errors.rs:38:28\n+  --> $DIR/promoted_errors.rs:43:28\n    |\n LL | / const X: () = {\n LL | |     let _x: &'static u32 = &overflow();\n@@ -41,5 +83,5 @@ LL | | };\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n-warning: 2 warnings emitted\n+warning: 7 warnings emitted\n "}, {"sha": "0a8a8aef3cf8f21303e1ff02ce1c7930cf1533c0", "filename": "src/test/ui/consts/const-eval/promoted_errors.opt.stderr", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.opt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.opt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.opt.stderr?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -1,12 +1,54 @@\n+warning: this arithmetic operation will overflow\n+  --> $DIR/promoted_errors.rs:15:5\n+   |\n+LL |     0 - 1\n+   |     ^^^^^ attempt to compute `0_u32 - 1_u32`, which would overflow\n+   |\n+note: the lint level is defined here\n+  --> $DIR/promoted_errors.rs:11:20\n+   |\n+LL | #![warn(const_err, arithmetic_overflow, unconditional_panic)]\n+   |                    ^^^^^^^^^^^^^^^^^^^\n+\n+warning: this operation will panic at runtime\n+  --> $DIR/promoted_errors.rs:21:5\n+   |\n+LL |     1 / 0\n+   |     ^^^^^ attempt to divide `1_i32` by zero\n+   |\n+note: the lint level is defined here\n+  --> $DIR/promoted_errors.rs:11:41\n+   |\n+LL | #![warn(const_err, arithmetic_overflow, unconditional_panic)]\n+   |                                         ^^^^^^^^^^^^^^^^^^^\n+\n+warning: this operation will panic at runtime\n+  --> $DIR/promoted_errors.rs:27:5\n+   |\n+LL |     1 / (1 - 1)\n+   |     ^^^^^^^^^^^ attempt to divide `1_i32` by zero\n+\n+warning: this operation will panic at runtime\n+  --> $DIR/promoted_errors.rs:31:5\n+   |\n+LL |     1 / (false as i32)\n+   |     ^^^^^^^^^^^^^^^^^^ attempt to divide `1_i32` by zero\n+\n+warning: this operation will panic at runtime\n+  --> $DIR/promoted_errors.rs:35:5\n+   |\n+LL |     [1, 2, 3][4]\n+   |     ^^^^^^^^^^^^ index out of bounds: the length is 3 but the index is 4\n+\n warning: any use of this value will cause an error\n-  --> $DIR/promoted_errors.rs:20:5\n+  --> $DIR/promoted_errors.rs:21:5\n    |\n LL |       1 / 0\n    |       ^^^^^\n    |       |\n    |       attempt to divide `1_i32` by zero\n-   |       inside `div_by_zero1` at $DIR/promoted_errors.rs:20:5\n-   |       inside `X` at $DIR/promoted_errors.rs:41:29\n+   |       inside `div_by_zero1` at $DIR/promoted_errors.rs:21:5\n+   |       inside `X` at $DIR/promoted_errors.rs:46:29\n ...\n LL | / const X: () = {\n LL | |     let _x: &'static u32 = &overflow();\n@@ -26,7 +68,7 @@ LL | #![warn(const_err, arithmetic_overflow, unconditional_panic)]\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n warning: any use of this value will cause an error\n-  --> $DIR/promoted_errors.rs:41:28\n+  --> $DIR/promoted_errors.rs:46:28\n    |\n LL | / const X: () = {\n LL | |     let _x: &'static u32 = &overflow();\n@@ -42,5 +84,5 @@ LL | | };\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n-warning: 2 warnings emitted\n+warning: 7 warnings emitted\n "}, {"sha": "5bfd4ef92a975cedb937a2e3d42c438e58fc0aa6", "filename": "src/test/ui/consts/const-eval/promoted_errors.opt_with_overflow_checks.stderr", "status": "modified", "additions": 45, "deletions": 3, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.opt_with_overflow_checks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.opt_with_overflow_checks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.opt_with_overflow_checks.stderr?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -1,3 +1,45 @@\n+warning: this arithmetic operation will overflow\n+  --> $DIR/promoted_errors.rs:15:5\n+   |\n+LL |     0 - 1\n+   |     ^^^^^ attempt to compute `0_u32 - 1_u32`, which would overflow\n+   |\n+note: the lint level is defined here\n+  --> $DIR/promoted_errors.rs:11:20\n+   |\n+LL | #![warn(const_err, arithmetic_overflow, unconditional_panic)]\n+   |                    ^^^^^^^^^^^^^^^^^^^\n+\n+warning: this operation will panic at runtime\n+  --> $DIR/promoted_errors.rs:21:5\n+   |\n+LL |     1 / 0\n+   |     ^^^^^ attempt to divide `1_i32` by zero\n+   |\n+note: the lint level is defined here\n+  --> $DIR/promoted_errors.rs:11:41\n+   |\n+LL | #![warn(const_err, arithmetic_overflow, unconditional_panic)]\n+   |                                         ^^^^^^^^^^^^^^^^^^^\n+\n+warning: this operation will panic at runtime\n+  --> $DIR/promoted_errors.rs:27:5\n+   |\n+LL |     1 / (1 - 1)\n+   |     ^^^^^^^^^^^ attempt to divide `1_i32` by zero\n+\n+warning: this operation will panic at runtime\n+  --> $DIR/promoted_errors.rs:31:5\n+   |\n+LL |     1 / (false as i32)\n+   |     ^^^^^^^^^^^^^^^^^^ attempt to divide `1_i32` by zero\n+\n+warning: this operation will panic at runtime\n+  --> $DIR/promoted_errors.rs:35:5\n+   |\n+LL |     [1, 2, 3][4]\n+   |     ^^^^^^^^^^^^ index out of bounds: the length is 3 but the index is 4\n+\n warning: any use of this value will cause an error\n   --> $DIR/promoted_errors.rs:15:5\n    |\n@@ -6,7 +48,7 @@ LL |       0 - 1\n    |       |\n    |       attempt to compute `0_u32 - 1_u32`, which would overflow\n    |       inside `overflow` at $DIR/promoted_errors.rs:15:5\n-   |       inside `X` at $DIR/promoted_errors.rs:38:29\n+   |       inside `X` at $DIR/promoted_errors.rs:43:29\n ...\n LL | / const X: () = {\n LL | |     let _x: &'static u32 = &overflow();\n@@ -26,7 +68,7 @@ LL | #![warn(const_err, arithmetic_overflow, unconditional_panic)]\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n warning: any use of this value will cause an error\n-  --> $DIR/promoted_errors.rs:38:28\n+  --> $DIR/promoted_errors.rs:43:28\n    |\n LL | / const X: () = {\n LL | |     let _x: &'static u32 = &overflow();\n@@ -41,5 +83,5 @@ LL | | };\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n-warning: 2 warnings emitted\n+warning: 7 warnings emitted\n "}, {"sha": "eb891de33c498bb44835b74bfbf1b02bdb3e543d", "filename": "src/test/ui/consts/const-eval/promoted_errors.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.rs?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -15,20 +15,25 @@ const fn overflow() -> u32 {\n     0 - 1\n     //[opt_with_overflow_checks,noopt]~^ WARN any use of this value will cause an error\n     //[opt_with_overflow_checks,noopt]~| WARN this was previously accepted by the compiler\n+    //~^^^ WARN this arithmetic operation will overflow\n }\n const fn div_by_zero1() -> i32 {\n     1 / 0\n     //[opt]~^ WARN any use of this value will cause an error\n     //[opt]~| WARN this was previously accepted by the compiler but is being phased out\n+    //~^^^ WARN this operation will panic at runtime\n }\n const fn div_by_zero2() -> i32 {\n     1 / (1 - 1)\n+    //~^ WARN this operation will panic at runtime\n }\n const fn div_by_zero3() -> i32 {\n     1 / (false as i32)\n+    //~^ WARN this operation will panic at runtime\n }\n const fn oob() -> i32 {\n     [1, 2, 3][4]\n+    //~^ WARN this operation will panic at runtime\n }\n \n // An unused constant containing failing promoteds."}, {"sha": "a1e48cac4faf719125b2bb54e202f1f26797a899", "filename": "src/test/ui/consts/const-eval/union-const-eval-field.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.rs?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -28,6 +28,7 @@ const fn read_field3() -> Field3 {\n     const FIELD3: Field3 = unsafe { UNION.field3 };\n     //~^ ERROR it is undefined behavior to use this value\n     FIELD3\n+    //~^ ERROR erroneous constant used [E0080]\n }\n \n fn main() {"}, {"sha": "8f8184627817a2e20f3d5f40b2830cbc550d07cb", "filename": "src/test/ui/consts/const-eval/union-const-eval-field.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.stderr?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -9,6 +9,12 @@ LL |     const FIELD3: Field3 = unsafe { UNION.field3 };\n                __ __ __ __ __ __ __ __                         \u2502 \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n            }\n \n-error: aborting due to previous error\n+error[E0080]: erroneous constant used\n+  --> $DIR/union-const-eval-field.rs:30:5\n+   |\n+LL |     FIELD3\n+   |     ^^^^^^ referenced constant has errors\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "094ca377e031bcec74d3c08e86a2c363b13f0ca1", "filename": "src/test/ui/consts/issue-56164.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.rs?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -1,5 +1,7 @@\n const fn foo() { (||{})() }\n //~^ ERROR cannot call non-const closure\n+//~| ERROR erroneous constant used [const_err]\n+//~| WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n const fn bad(input: fn()) {\n     input()"}, {"sha": "b997aff0e837cfa7b7b8870dc1e19f7836682ff3", "filename": "src/test/ui/consts/issue-56164.stderr", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.stderr?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -8,11 +8,21 @@ LL | const fn foo() { (||{})() }\n    = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error: function pointers are not allowed in const fn\n-  --> $DIR/issue-56164.rs:5:5\n+  --> $DIR/issue-56164.rs:7:5\n    |\n LL |     input()\n    |     ^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: erroneous constant used\n+  --> $DIR/issue-56164.rs:1:18\n+   |\n+LL | const fn foo() { (||{})() }\n+   |                  ^^^^^^ referenced constant has errors\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0015`."}, {"sha": "99d28eb773f84f0f651ed8a63f4a144f72cdd618", "filename": "src/test/ui/consts/issue-66693.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fissue-66693.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fissue-66693.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-66693.rs?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -8,7 +8,10 @@ static _FOO: () = panic!(true);\n //~^ ERROR: argument to `panic!()` in a const context must have type `&str`\n \n const fn _foo() {\n-    panic!(&1); //~ ERROR: argument to `panic!()` in a const context must have type `&str`\n+    panic!(&1);\n+    //~^ ERROR: argument to `panic!()` in a const context must have type `&str`\n+    //~| ERROR: erroneous constant used [const_err]\n+    //~| WARNING: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n }\n \n // ensure that conforming panics don't cause an error"}, {"sha": "b82576849838632a9abf0121bc40e6ce7096042f", "filename": "src/test/ui/consts/issue-66693.stderr", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fissue-66693.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fissue-66693.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-66693.stderr?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -22,5 +22,15 @@ LL |     panic!(&1);\n    |\n    = note: this error originates in the macro `$crate::panic::panic_2015` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 3 previous errors\n+error: erroneous constant used\n+  --> $DIR/issue-66693.rs:11:12\n+   |\n+LL |     panic!(&1);\n+   |            ^^ referenced constant has errors\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "e379e3aea13d4f4ea657781c91bd483e4a6f95c8", "filename": "src/test/ui/consts/promotion.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fpromotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Fconsts%2Fpromotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpromotion.rs?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -4,11 +4,13 @@\n //[opt_with_overflow_checks]compile-flags: -C overflow-checks=on -O\n \n // build-pass\n-#[allow(arithmetic_overflow)]\n \n const fn assert_static<T>(_: &'static T) {}\n \n-const fn fail() -> i32 { 1/0 }\n+#[allow(unconditional_panic)]\n+const fn fail() -> i32 {\n+    1/0\n+}\n const C: i32 = {\n     // Promoted that fails to evaluate in dead code -- this must work\n     // (for backwards compatibility reasons)."}, {"sha": "366ea7d3b3fdaabb3f268704ba8ca36708cf4a30", "filename": "src/test/ui/recursion/issue-26548-recursion-via-normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.rs?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -2,7 +2,6 @@\n //~| NOTE ...which requires computing layout of `core::option::Option<<S as Mirror>::It>`...\n //~| NOTE ...which requires computing layout of `core::option::Option<S>`...\n //~| NOTE ...which again requires computing layout of `S`, completing the cycle\n-//~| NOTE cycle used when computing layout of `core::option::Option<S>`\n \n // build-fail\n \n@@ -15,5 +14,6 @@ impl<T: ?Sized> Mirror for T {\n struct S(Option<<S as Mirror>::It>);\n \n fn main() {\n+    //~^ NOTE cycle used when elaborating drops for `main`\n     let _s = S(None);\n }"}, {"sha": "5b675dc9f81fc7a6da6be9837e538e9d0ce01491", "filename": "src/test/ui/recursion/issue-26548-recursion-via-normalize.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Fissue-26548-recursion-via-normalize.stderr?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -3,7 +3,11 @@ error[E0391]: cycle detected when computing layout of `S`\n    = note: ...which requires computing layout of `core::option::Option<<S as Mirror>::It>`...\n    = note: ...which requires computing layout of `core::option::Option<S>`...\n    = note: ...which again requires computing layout of `S`, completing the cycle\n-   = note: cycle used when computing layout of `core::option::Option<S>`\n+note: cycle used when elaborating drops for `main`\n+  --> $DIR/issue-26548-recursion-via-normalize.rs:16:1\n+   |\n+LL | fn main() {\n+   | ^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "e75e7dc913673f56f1faaab0ec72b667c6d583dc", "filename": "src/tools/clippy/tests/ui/crashes/ice-5497.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-5497.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-5497.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-5497.stderr?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -0,0 +1,10 @@\n+error: this operation will panic at runtime\n+  --> $DIR/ice-5497.rs:9:22\n+   |\n+LL |     const OOB: i32 = [1][1] + T::OOB;\n+   |                      ^^^^^^ index out of bounds: the length is 1 but the index is 1\n+   |\n+   = note: `#[deny(unconditional_panic)]` on by default\n+\n+error: aborting due to previous error\n+"}]}