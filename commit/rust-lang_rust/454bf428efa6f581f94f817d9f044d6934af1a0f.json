{"sha": "454bf428efa6f581f94f817d9f044d6934af1a0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1NGJmNDI4ZWZhNmY1ODFmOTRmODE3ZDlmMDQ0ZDY5MzRhZjFhMGY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-30T00:27:13Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-30T00:27:19Z"}, "message": "Remove LLVM rustboot backend.", "tree": {"sha": "e8726997e920a608d80526ea06fa7db9bd599594", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8726997e920a608d80526ea06fa7db9bd599594"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/454bf428efa6f581f94f817d9f044d6934af1a0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/454bf428efa6f581f94f817d9f044d6934af1a0f", "html_url": "https://github.com/rust-lang/rust/commit/454bf428efa6f581f94f817d9f044d6934af1a0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/454bf428efa6f581f94f817d9f044d6934af1a0f/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a634b21563fde802e2424bbef086ce541bb6ad8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a634b21563fde802e2424bbef086ce541bb6ad8c", "html_url": "https://github.com/rust-lang/rust/commit/a634b21563fde802e2424bbef086ce541bb6ad8c"}], "stats": {"total": 1792, "additions": 3, "deletions": 1789}, "files": [{"sha": "a16277f87f8707e123ba08731fdee215717c97e6", "filename": "src/Makefile", "status": "modified", "additions": 3, "deletions": 159, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/454bf428efa6f581f94f817d9f044d6934af1a0f/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/454bf428efa6f581f94f817d9f044d6934af1a0f/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=454bf428efa6f581f94f817d9f044d6934af1a0f", "patch": "@@ -23,10 +23,6 @@ CFG_GCC_CFLAGS :=\n CFG_GCC_LINK_FLAGS :=\n CFG_VALGRIND :=\n \n-# Disable the ocaml backend on rustboot. It's too frustrating at this\n-# point.\n-NO_OCAML_LLVM := 1\n-\n CFG_LLVM_CONFIG ?= llvm-config\n CFG_BOOT_FLAGS := $(FLAGS)\n CFG_RUSTC_FLAGS := -nowarn\n@@ -145,7 +141,6 @@ ifdef PROFILE\n   $(info cfg: building with profiling info (forcing native output))\n   CFG_NATIVE := 1\n   CFG_OCAMLOPT_PROFILE_FLAGS := -p\n-  NO_LLVM := 1\n endif\n \n ifdef DEBUG\n@@ -182,52 +177,13 @@ ifneq ($(CFG_LLVM_CONFIG),)\n       expected one of $(CFG_LLVM_ALLOWED_VERSIONS))\n   endif\n endif\n-ifneq ($(CFG_LLVM_CONFIG),)\n-  CFG_OCAML_LIBPATH := $(lastword \\\n-    $(shell ocamlc$(OPT) -config | grep standard_library:))\n-  CFG_OCAML_LLVM := $(shell \\\n-      for path in $(shell $(CFG_LLVM_CONFIG) --libdir)/ocaml \\\n-          $(CFG_OCAML_LIBPATH) \\\n-          $(CFG_OCAML_LIBPATH)/llvm \\\n-          $(CFG_OCAML_LIBPATH)/llvm-$(CFG_LLVM_VERSION) ; do \\\n-        if test -e $${path}/llvm.cma; then echo $${path}; break; fi \\\n-      done)\n-  ifneq ($(CFG_OCAML_LLVM),)\n-    $(info cfg: found LLVM ocaml bindings in $(CFG_OCAML_LLVM))\n-  endif\n-endif\n \n-ifdef NO_OCAML_LLVM\n-    $(info cfg: disabling LLVM ocaml bindings)\n-    CFG_OCAML_LLVM :=\n-endif\n+VARIANT=x86\n \n ifdef CFG_LLVM_CONFIG\n   LLC := \"$(shell $(CFG_LLVM_CONFIG) --bindir)/llc\"\n   CFG_LLC_CFLAGS := -march=x86\n   LLVM-DIS := \"$(shell $(CFG_LLVM_CONFIG) --bindir)/llvm-dis\"\n-  ifneq ($(CFG_OCAML_LLVM),)\n-    VARIANT=llvm\n-    LLVM_LIBS := llvm.cma llvm_bitwriter.cma\n-    LLVM_NATIVE_LIBS := llvm.cmxa llvm_bitwriter.cmxa\n-    LLVM_CLIBS := $(shell for c in `$(CFG_LLVM_CONFIG) --ldflags --libs` \\\n-      -lllvm -lllvm_bitwriter; do echo -cclib && echo $$c; done | xargs echo)\n-    LLVM_INCS := -I boot/llvm -I $(CFG_OCAML_LLVM)\n-    LLVM_MLS := $(addprefix boot/llvm/, llabi.ml llasm.ml llfinal.ml \\\n-      lltrans.ml llemit.ml)\n-  else\n-    VARIANT=x86\n-    LLVM_CLIBS :=\n-    LLVM_INCS :=\n-    LLVM_MLS :=\n-    $(info cfg: disabling LLVM ocaml backend)\n-  endif\n-else\n-  VARIANT=x86\n-  LLVM_CLIBS :=\n-  LLVM_INCS :=\n-  LLVM_MLS :=\n-  $(info cfg: disabling LLVM backend)\n endif\n \n MKFILES := Makefile\n@@ -241,19 +197,14 @@ CFG_BOOT_FLAGS += -L .\n ######################################################################\n \n ML_DEP_INCS := -I boot/fe -I boot/me -I boot/be -I boot/driver/$(VARIANT) \\\n-  -I boot/driver -I boot/util -I boot/llvm\n+  -I boot/driver -I boot/util\n ML_INCS := $(ML_DEP_INCS) $(LLVM_INCS)\n ML_LIBS := unix.cma nums.cma bigarray.cma\n ML_NATIVE_LIBS := unix.cmxa nums.cmxa bigarray.cmxa\n OCAMLC_FLAGS := -g $(ML_INCS) -w Ael -warn-error Ael\n OCAMLOPT_FLAGS := $(ML_INCS) -w Ael -warn-error Ael \\\n                     $(CFG_OCAMLOPT_PROFILE_FLAGS)\n \n-ifdef CFG_LLVM_CONFIG\n-  ML_LIBS += $(LLVM_LIBS) -custom -cclib -lstdc++ $(LLVM_CLIBS)\n-  ML_NATIVE_LIBS += $(LLVM_NATIVE_LIBS) -cclib -lstdc++ $(LLVM_CLIBS)\n-endif\n-\n # List them in link order.\n # Nobody calculates the link-order DAG automatically, sadly.\n \n@@ -270,7 +221,7 @@ FE_MLS := $(addprefix boot/fe/, ast.ml token.ml lexer.ml parser.ml \\\n DRIVER_TOP_MLS := $(addprefix boot/driver/, lib.ml $(VARIANT)/glue.ml main.ml)\n \n BOOT_MLS := $(UTIL_BOT_MLS) $(DRIVER_BOT_MLS) $(FE_MLS) $(IL_MLS) $(ME_MLS) \\\n-  $(BE_MLS) $(LLVM_MLS) $(DRIVER_TOP_MLS)\n+  $(BE_MLS) $(DRIVER_TOP_MLS)\n BOOT_CMOS := $(BOOT_MLS:.ml=.cmo)\n BOOT_CMXS := $(BOOT_MLS:.ml=.cmx)\n BOOT_OBJS := $(BOOT_MLS:.ml=.o)\n@@ -458,59 +409,6 @@ TEST_XFAILS_X86 :=  $(TASK_XFAILS) \\\n                     test/compile-fail/infinite-vec-type-recursion.rs \\\n                     test/compile-fail/writing-through-read-alias.rs\n \n-# Most tests fail on the boot-llvm backend, so we list the run-pass\n-# xfails inside-out, by listing those that *don't* fail. A bit\n-# double-negative-y but it's a bit unwieldy the other way just now.\n-\n-TEST_XFAILS_LLVM := $(TASK_XFAILS) \\\n-                    $(NOMINAL_TAG_XFAILS) \\\n-                    $(CONST_TAG_XFAILS) \\\n-                    $(filter-out \\\n-                      $(addprefix test/run-pass/, \\\n-                        arith-0.rs \\\n-                        arith-2.rs \\\n-                        box.rs \\\n-                        char.rs \\\n-                        dead-code-one-arm-if.rs \\\n-                        div-mod.rs \\\n-                        drop-on-ret.rs \\\n-                        else-if.rs \\\n-                        fact.rs \\\n-                        generic-fn-twice.rs \\\n-                        generic-type.rs \\\n-                        generic-type-synonym.rs \\\n-                        hello.rs \\\n-                        inner-module.rs \\\n-                        int.rs \\\n-                        item-name-overload.rs \\\n-                        multiline-comment.rs \\\n-                        native.rs \\\n-                        native-mod.rs \\\n-                        native-opaque-type.rs \\\n-                        opeq.rs \\\n-                        return-nil.rs \\\n-                        syntax-extension-shell.rs \\\n-                        tup.rs), \\\n-                      $(wildcard test/run-pass/*.rs) ) \\\n-                    $(addprefix test/run-fail/, \\\n-                      explicit-fail.rs \\\n-                      fail.rs \\\n-                      linked-failure.rs \\\n-                      non-exhaustive-match.rs \\\n-                      pred.rs \\\n-                      str-overrun.rs \\\n-                      vec-overrun.rs \\\n-                      vec-underrun.rs \\\n-                      task-comm-14.rs \\\n-                     ) \\\n-                    $(addprefix test/compile-fail/, \\\n-                      bad-recv.rs \\\n-                      bad-send.rs \\\n-                      infinite-vec-type-recursion.rs \\\n-                      rec-missing-fields.rs \\\n-                      writing-through-read-alias.rs \\\n-                     )\n-\n # Same strategy here for the time being: just list the ones that\n # work and assume the others don't. Invert this when we're closer\n # to actually bootstrapping.\n@@ -578,12 +476,10 @@ TEST_XFAILS_SELF := $(filter-out \\\n \n ifdef MINGW_CROSS\n TEST_XFAILS_X86 += test/run-pass/native-mod.rc\n-TEST_XFAILS_LLVM += test/run-pass/native-mod.rc\n TEST_XFAILS_SELF += test/run-pass/native-mod.rc\n endif\n ifdef CFG_WINDOWSY\n TEST_XFAILS_X86 += test/run-pass/native-mod.rc\n-TEST_XFAILS_LLVM += test/run-pass/native-mod.rc\n TEST_XFAILS_SELF += test/run-pass/native-mod.rc\n endif\n \n@@ -596,105 +492,76 @@ CFAIL_RS := $(wildcard test/compile-fail/*.rs)\n \n ifdef CHECK_XFAILS\n TEST_RPASS_CRATES_X86 := $(filter $(TEST_XFAILS_X86), $(RPASS_RC))\n-TEST_RPASS_CRATES_LLVM := $(filter $(TEST_XFAILS_LLVM), $(RPASS_RC))\n TEST_RPASS_CRATES_SELF := $(filter $(TEST_XFAILS_SELF), $(RPASS_RC))\n TEST_RPASS_SOURCES_X86 := $(filter $(TEST_XFAILS_X86), $(RPASS_RS))\n-TEST_RPASS_SOURCES_LLVM := $(filter $(TEST_XFAILS_LLVM), $(RPASS_RS))\n TEST_RPASS_SOURCES_SELF := $(filter $(TEST_XFAILS_SELF), $(RPASS_RS))\n else\n TEST_RPASS_CRATES_X86 := $(filter-out $(TEST_XFAILS_X86), $(RPASS_RC))\n-TEST_RPASS_CRATES_LLVM := $(filter-out $(TEST_XFAILS_LLVM), $(RPASS_RC))\n TEST_RPASS_CRATES_SELF := $(filter-out $(TEST_XFAILS_SELF), $(RPASS_RC))\n TEST_RPASS_SOURCES_X86 := $(filter-out $(TEST_XFAILS_X86), $(RPASS_RS))\n-TEST_RPASS_SOURCES_LLVM := $(filter-out $(TEST_XFAILS_LLVM), $(RPASS_RS))\n TEST_RPASS_SOURCES_SELF := $(filter-out $(TEST_XFAILS_SELF), $(RPASS_RS))\n endif\n \n TEST_RPASS_EXES_X86 := \\\n               $(TEST_RPASS_CRATES_X86:.rc=-boot.x86$(CFG_EXE_SUFFIX)) \\\n               $(TEST_RPASS_SOURCES_X86:.rs=-boot.x86$(CFG_EXE_SUFFIX))\n-TEST_RPASS_EXES_LLVM := \\\n-              $(TEST_RPASS_CRATES_LLVM:.rc=-boot.llvm$(CFG_EXE_SUFFIX)) \\\n-              $(TEST_RPASS_SOURCES_LLVM:.rs=-boot.llvm$(CFG_EXE_SUFFIX))\n TEST_RPASS_EXES_SELF := \\\n               $(TEST_RPASS_CRATES_SELF:.rc=.llvm$(CFG_EXE_SUFFIX)) \\\n               $(TEST_RPASS_SOURCES_SELF:.rs=.llvm$(CFG_EXE_SUFFIX))\n \n TEST_RPASS_OUTS_X86  := \\\n                     $(TEST_RPASS_EXES_X86:.x86$(CFG_EXE_SUFFIX)=.x86.out)\n-TEST_RPASS_OUTS_LLVM := \\\n-                    $(TEST_RPASS_EXES_LLVM:.llvm$(CFG_EXE_SUFFIX)=.llvm.out)\n TEST_RPASS_OUTS_SELF := \\\n                     $(TEST_RPASS_EXES_SELF:.llvm$(CFG_EXE_SUFFIX)=.llvm.out)\n \n TEST_RPASS_TMPS_X86  := \\\n     $(TEST_RPASS_EXES_X86:.x86$(CFG_EXE_SUFFIX)=.x86$(CFG_EXE_SUFFIX).tmp)\n-TEST_RPASS_TMPS_LLVM := \\\n-    $(TEST_RPASS_EXES_LLVM:.llvm$(CFG_EXE_SUFFIX)=.llvm$(CFG_EXE_SUFFIX).tmp)\n TEST_RPASS_TMPS_SELF := \\\n     $(TEST_RPASS_EXES_SELF:.llvm$(CFG_EXE_SUFFIX)=.llvm$(CFG_EXE_SUFFIX).tmp)\n \n \n TEST_RFAIL_CRATES_X86 := $(filter-out $(TEST_XFAILS_X86), $(RFAIL_RC))\n-TEST_RFAIL_CRATES_LLVM := $(filter-out $(TEST_XFAILS_LLVM), $(RFAIL_RC))\n TEST_RFAIL_CRATES_SELF := $(filter-out $(TEST_XFAILS_SELF), $(RFAIL_RC))\n TEST_RFAIL_SOURCES_X86 := $(filter-out $(TEST_XFAILS_X86), $(RFAIL_RS))\n-TEST_RFAIL_SOURCES_LLVM := $(filter-out $(TEST_XFAILS_LLVM), $(RFAIL_RS))\n TEST_RFAIL_SOURCES_SELF := $(filter-out $(TEST_XFAILS_SELF), $(RFAIL_RS))\n \n TEST_RFAIL_EXES_X86 := \\\n               $(TEST_RFAIL_CRATES_X86:.rc=-boot.x86$(CFG_EXE_SUFFIX)) \\\n               $(TEST_RFAIL_SOURCES_X86:.rs=-boot.x86$(CFG_EXE_SUFFIX))\n-TEST_RFAIL_EXES_LLVM := \\\n-              $(TEST_RFAIL_CRATES_LLVM:.rc=-boot.llvm$(CFG_EXE_SUFFIX)) \\\n-              $(TEST_RFAIL_SOURCES_LLVM:.rs=-boot.llvm$(CFG_EXE_SUFFIX))\n TEST_RFAIL_EXES_SELF := \\\n               $(TEST_RFAIL_CRATES_SELF:.rc=-boot.llvm$(CFG_EXE_SUFFIX)) \\\n               $(TEST_RFAIL_SOURCES_SELF:.rs=-boot.llvm$(CFG_EXE_SUFFIX))\n \n TEST_RFAIL_OUTS_X86  := \\\n                     $(TEST_RFAIL_EXES_X86:.x86$(CFG_EXE_SUFFIX)=.x86.out)\n-TEST_RFAIL_OUTS_LLVM := \\\n-                    $(TEST_RFAIL_EXES_LLVM:.llvm$(CFG_EXE_SUFFIX)=.llvm.out)\n TEST_RFAIL_OUTS_SELF := \\\n                     $(TEST_RFAIL_EXES_SELF:.llvm$(CFG_EXE_SUFFIX)=.llvm.out)\n \n TEST_RFAIL_TMPS_X86  := \\\n     $(TEST_RFAIL_EXES_X86:.x86$(CFG_EXE_SUFFIX)=.x86$(CFG_EXE_SUFFIX).tmp)\n-TEST_RFAIL_TMPS_LLVM := \\\n-    $(TEST_RFAIL_EXES_LLVM:.llvm$(CFG_EXE_SUFFIX)=.llvm$(CFG_EXE_SUFFIX).tmp)\n TEST_RFAIL_TMPS_SELF := \\\n     $(TEST_RFAIL_EXES_SELF:.llvm$(CFG_EXE_SUFFIX)=.llvm$(CFG_EXE_SUFFIX).tmp)\n \n \n TEST_CFAIL_CRATES_X86 := $(filter-out $(TEST_XFAILS_X86), $(CFAIL_RC))\n-TEST_CFAIL_CRATES_LLVM := $(filter-out $(TEST_XFAILS_LLVM), $(CFAIL_RC))\n TEST_CFAIL_CRATES_SELF := $(filter-out $(TEST_XFAILS_SELF), $(CFAIL_RC))\n TEST_CFAIL_SOURCES_X86 := $(filter-out $(TEST_XFAILS_X86), $(CFAIL_RS))\n-TEST_CFAIL_SOURCES_LLVM := $(filter-out $(TEST_XFAILS_LLVM), $(CFAIL_RS))\n TEST_CFAIL_SOURCES_SELF := $(filter-out $(TEST_XFAILS_SELF), $(CFAIL_RS))\n \n TEST_CFAIL_EXES_X86 := \\\n               $(TEST_CFAIL_CRATES_X86:.rc=-boot.x86$(CFG_EXE_SUFFIX)) \\\n               $(TEST_CFAIL_SOURCES_X86:.rs=-boot.x86$(CFG_EXE_SUFFIX))\n-TEST_CFAIL_EXES_LLVM := \\\n-              $(TEST_CFAIL_CRATES_LLVM:.rc=-boot.llvm$(CFG_EXE_SUFFIX)) \\\n-              $(TEST_CFAIL_SOURCES_LLVM:.rs=-boot.llvm$(CFG_EXE_SUFFIX))\n TEST_CFAIL_EXES_SELF := \\\n               $(TEST_CFAIL_CRATES_SELF:.rc=.llvm$(CFG_EXE_SUFFIX)) \\\n               $(TEST_CFAIL_SOURCES_SELF:.rs=.llvm$(CFG_EXE_SUFFIX))\n \n TEST_CFAIL_OUTS_X86 := \\\n                 $(TEST_CFAIL_EXES_X86:.x86$(CFG_EXE_SUFFIX)=.x86.out)\n-TEST_CFAIL_OUTS_LLVM := \\\n-                $(TEST_CFAIL_EXES_LLVM:.llvm$(CFG_EXE_SUFFIX)=.llvm.out)\n TEST_CFAIL_OUTS_SELF := \\\n                 $(TEST_CFAIL_EXES_SELF:.llvm$(CFG_EXE_SUFFIX)=.llvm.out)\n \n TEST_CFAIL_TMPS_X86 := \\\n     $(TEST_CFAIL_EXES_X86:.x86$(CFG_EXE_SUFFIX)=.x86$(CFG_EXE_SUFFIX).tmp)\n-TEST_CFAIL_TMPS_LLVM := \\\n-    $(TEST_CFAIL_EXES_LLVM:.llvm$(CFG_EXE_SUFFIX)=.llvm$(CFG_EXE_SUFFIX).tmp)\n TEST_CFAIL_TMPS_SELF := \\\n     $(TEST_CFAIL_EXES_SELF:.llvm$(CFG_EXE_SUFFIX)=.llvm$(CFG_EXE_SUFFIX).tmp)\n \n@@ -723,28 +590,6 @@ compile-check: tidy \\\n \n ifdef CFG_LLVM_CONFIG\n \n-ifneq ($(CFG_OCAML_LLVM),)\n-\n-ALL_TEST_CRATES += $(TEST_CFAIL_CRATES_LLVM) \\\n-                   $(TEST_RFAIL_CRATES_LLVM) \\\n-                   $(TEST_RPASS_CRATES_LLVM)\n-\n-ALL_TEST_SOURCES += $(TEST_CFAIL_SOURCES_LLVM) \\\n-                    $(TEST_RFAIL_SOURCES_LLVM) \\\n-                    $(TEST_RPASS_SOURCES_LLVM)\n-\n-check_nocompile: $(TEST_CFAIL_OUTS_LLVM)\n-\n-check:\ttidy \\\n-        $(TEST_RPASS_EXES_LLVM) $(TEST_RFAIL_EXES_LLVM) \\\n-        $(TEST_RPASS_OUTS_LLVM) $(TEST_RFAIL_OUTS_LLVM) \\\n-        $(TEST_CFAIL_OUTS_LLVM)\n-\n-compile-check: tidy \\\n-       $(TEST_RPASS_EXES_LLVM) $(TEST_RFAIL_EXES_LLVM)\n-\n-endif\n-\n ALL_TEST_CRATES += $(TEST_CFAIL_CRATES_SELF) \\\n                    $(TEST_RFAIL_CRATES_SELF) \\\n                    $(TEST_RPASS_CRATES_SELF)\n@@ -761,7 +606,6 @@ check:  tidy \\\n         $(TEST_CFAIL_OUTS_SELF)\n \n compile-check: tidy \\\n-       $(TEST_RPASS_EXES_LLVM) $(TEST_RFAIL_EXES_LLVM) \\\n        $(TEST_RPASS_EXES_SELF) $(TEST_RFAIL_EXES_SELF)\n \n endif"}, {"sha": "c1dc2894adea21287679f1db5bbc430d616264aa", "filename": "src/boot/driver/llvm/glue.ml", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a634b21563fde802e2424bbef086ce541bb6ad8c/src%2Fboot%2Fdriver%2Fllvm%2Fglue.ml", "raw_url": "https://github.com/rust-lang/rust/raw/a634b21563fde802e2424bbef086ce541bb6ad8c/src%2Fboot%2Fdriver%2Fllvm%2Fglue.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Fllvm%2Fglue.ml?ref=a634b21563fde802e2424bbef086ce541bb6ad8c", "patch": "@@ -1,39 +0,0 @@\n-(*\n- * Glue for the LLVM backend.\n- *)\n-\n-let alt_argspecs sess = [\n-  (\"-llvm\", Arg.Unit (fun _ -> sess.Session.sess_alt_backend <- true),\n-    \"emit LLVM bitcode\")\n-];;\n-\n-let alt_pipeline sess sem_cx crate =\n-  let process processor =\n-    processor sem_cx crate;\n-    if sess.Session.sess_failed then exit 1 else ()\n-  in\n-  Array.iter process\n-    [|\n-      Resolve.process_crate;\n-      Simplify.process_crate;\n-      Type.process_crate;\n-      Typestate.process_crate;\n-      Layer.process_crate;\n-      Effect.process_crate;\n-      Loop.process_crate;\n-      Alias.process_crate;\n-      Dead.process_crate;\n-      Layout.process_crate\n-    |];\n-  Llemit.trans_and_process_crate sess sem_cx crate\n-;;\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C ../../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)\n-"}, {"sha": "5ff63ba50a2b44220ad9134c4c92a5b9366ef6cd", "filename": "src/boot/llvm/llabi.ml", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/a634b21563fde802e2424bbef086ce541bb6ad8c/src%2Fboot%2Fllvm%2Fllabi.ml", "raw_url": "https://github.com/rust-lang/rust/raw/a634b21563fde802e2424bbef086ce541bb6ad8c/src%2Fboot%2Fllvm%2Fllabi.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fllvm%2Fllabi.ml?ref=a634b21563fde802e2424bbef086ce541bb6ad8c", "patch": "@@ -1,94 +0,0 @@\n-(*\n- * LLVM integration with the Rust runtime.\n- *)\n-\n-type abi = {\n-  crate_ty:   Llvm.lltype;\n-  task_ty:    Llvm.lltype;\n-  word_ty:    Llvm.lltype;\n-  tydesc_ty:  Llvm.lltype;\n-  rust_start: Llvm.llvalue;\n-};;\n-\n-let declare_abi (llctx:Llvm.llcontext) (llmod:Llvm.llmodule) : abi =\n-  let i32 = Llvm.i32_type llctx in\n-  (* FIXME: Use Llvm_target.intptr_type for more platform support. *)\n-  let word_ty = i32 in\n-  let p ty = Llvm.pointer_type ty in\n-\n-  let crate_ty =\n-    (* TODO: other architectures besides x86 *)\n-    let crate_opaque_ty = Llvm.opaque_type llctx in\n-    let crate_tyhandle = Llvm.handle_to_type (Llvm.struct_type llctx [|\n-        i32;                              (* ptrdiff_t image_base_off *)\n-        Llvm.pointer_type crate_opaque_ty;(* uintptr_t self_addr *)\n-        i32;                              (* ptrdiff_t debug_abbrev_off *)\n-        i32;                              (* size_t debug_abbrev_sz *)\n-        i32;                              (* ptrdiff_t debug_info_off *)\n-        i32;                              (* size_t debug_info_sz *)\n-        i32;                              (* size_t activate_glue_off *)\n-        i32;                              (* size_t yield_glue_off *)\n-        i32;                              (* size_t unwind_glue_off *)\n-        i32;                              (* size_t gc_glue_off *)\n-        i32;                              (* size_t main_exit_task_glue_off *)\n-        i32;                              (* int n_rust_syms *)\n-        i32;                              (* int n_c_syms *)\n-        i32                               (* int n_libs *)\n-      |])\n-    in\n-    Llvm.refine_type crate_opaque_ty (Llvm.type_of_handle crate_tyhandle);\n-    Llvm.type_of_handle crate_tyhandle\n-  in\n-  ignore (Llvm.define_type_name \"rust_crate\" crate_ty llmod);\n-\n-  let task_ty =\n-    (* TODO: other architectures besides x86 *)\n-    Llvm.struct_type llctx [|\n-      i32;                    (* size_t refcnt *)\n-      Llvm.pointer_type i32;  (* rust_task *_delegate *)\n-      Llvm.pointer_type i32;  (* stk_seg *stk *)\n-      Llvm.pointer_type i32;  (* uintptr_t runtime_sp *)\n-      Llvm.pointer_type i32;  (* uintptr_t rust_sp *)\n-      Llvm.pointer_type i32;  (* rust_rt *rt *)\n-      Llvm.pointer_type i32   (* rust_crate_cache *cache *)\n-    |]\n-  in\n-  ignore (Llvm.define_type_name \"rust_task\" task_ty llmod);\n-\n-    (* This is the type_desc struct in rust_internal.h *)\n-  let tydesc_ty =\n-    (* TODO: other architectures besides x86 *)\n-    let tydesc_opaque_ty = Llvm.opaque_type llctx in\n-    let tydesc_tyhandle = Llvm.handle_to_type (Llvm.struct_type llctx [|\n-        p (p tydesc_opaque_ty);  (* const type_desc **first_param *)\n-        word_ty;                 (* size_t size *)\n-        word_ty;                 (* size_t align *)\n-        word_ty;                 (* uintptr_t copy_glue_off *)\n-        word_ty;                 (* uintptr_t drop_glue_off *)\n-        word_ty;                 (* uintptr_t free_glue_off *)\n-        word_ty;                 (* uintptr_t sever_glue_off *)\n-        word_ty;                 (* uintptr_t mark_glue_off *)\n-        word_ty;                 (* uintptr_t obj_drop_glue_off *)\n-      |])\n-    in\n-    Llvm.refine_type tydesc_opaque_ty (Llvm.type_of_handle tydesc_tyhandle);\n-    Llvm.type_of_handle tydesc_tyhandle\n-  in\n-  ignore (Llvm.define_type_name \"type_desc\" tydesc_ty llmod);\n-\n-  let rust_start_ty =\n-    (* Rust's main function can have several types, so we cast them\n-       all to uintptr_t. *)\n-    let main_ty = word_ty in\n-    let args_ty = [| main_ty; Llvm.pointer_type crate_ty; i32; i32 |] in\n-      Llvm.function_type i32 args_ty\n-  in\n-  {\n-    crate_ty = crate_ty;\n-    task_ty = task_ty;\n-    word_ty = word_ty;\n-    tydesc_ty = tydesc_ty;\n-    rust_start = Llvm.declare_function \"rust_start\" rust_start_ty llmod\n-  }\n-;;\n-"}, {"sha": "70cf24706713d41883225c4bcee2324d07afafc2", "filename": "src/boot/llvm/llasm.ml", "status": "removed", "additions": 0, "deletions": 208, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/a634b21563fde802e2424bbef086ce541bb6ad8c/src%2Fboot%2Fllvm%2Fllasm.ml", "raw_url": "https://github.com/rust-lang/rust/raw/a634b21563fde802e2424bbef086ce541bb6ad8c/src%2Fboot%2Fllvm%2Fllasm.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fllvm%2Fllasm.ml?ref=a634b21563fde802e2424bbef086ce541bb6ad8c", "patch": "@@ -1,208 +0,0 @@\n-(*\n- * machine-specific assembler routines.\n- *)\n-\n-open Common;;\n-\n-type asm_glue =\n-    {\n-      asm_activate_glue : Llvm.llvalue;\n-      asm_yield_glue : Llvm.llvalue;\n-      asm_upcall_glues : Llvm.llvalue array;\n-    }\n-;;\n-\n-let n_upcall_glues = 7\n-;;\n-\n-(* x86-specific asm. *)\n-\n-let x86_glue\n-  (llctx:Llvm.llcontext)\n-  (llmod:Llvm.llmodule)\n-  (abi:Llabi.abi)\n-  (sess:Session.sess)\n-  : asm_glue =\n-  let (prefix,align) =\n-    match sess.Session.sess_targ with\n-        Linux_x86_elf -> (\"\", 4)\n-      | Win32_x86_pe -> (\"_\",4)\n-      | MacOS_x86_macho -> (\"_\", 16)\n-  in\n-  let save_callee_saves =\n-    [\"pushl %ebp\";\n-     \"pushl %edi\";\n-     \"pushl %esi\";\n-     \"pushl %ebx\";]\n-  in\n-  let restore_callee_saves =\n-    [\"popl  %ebx\";\n-     \"popl  %esi\";\n-     \"popl  %edi\";\n-     \"popl  %ebp\";]\n-  in\n-  let load_esp_from_rust_sp =\n-    [ Printf.sprintf \"movl  %d(%%edx), %%esp\"\n-        (Abi.task_field_rust_sp * 4)]\n-  in\n-  let load_esp_from_runtime_sp =\n-    [ Printf.sprintf \"movl  %d(%%edx), %%esp\"\n-        (Abi.task_field_runtime_sp * 4) ]\n-  in\n-  let store_esp_to_rust_sp     =\n-    [ Printf.sprintf \"movl  %%esp, %d(%%edx)\"\n-        (Abi.task_field_rust_sp * 4) ]\n-  in\n-  let store_esp_to_runtime_sp  =\n-    [ Printf.sprintf \"movl  %%esp, %d(%%edx)\"\n-        (Abi.task_field_runtime_sp * 4) ]\n-  in\n-\n-  let list_init i f = (Array.to_list (Array.init i f)) in\n-  let list_init_concat i f = List.concat (list_init i f) in\n-\n-  let glue =\n-    [\n-      (\"rust_activate_glue\",\n-       String.concat \"\\n\\t\"\n-         ([\"movl  4(%esp), %edx    # edx = rust_task\"]\n-          @ save_callee_saves\n-          @ store_esp_to_runtime_sp\n-          @ load_esp_from_rust_sp\n-            (* \n-             * This 'add' instruction is a bit surprising.\n-             * See lengthy comment in boot/be/x86.ml activate_glue.\n-             *)\n-          @ [ Printf.sprintf\n-                \"addl  $20, %d(%%edx)\"\n-                (Abi.task_field_rust_sp * 4) ]\n-\n-          @ restore_callee_saves\n-          @ [\"ret\"]));\n-\n-      (\"rust_yield_glue\",\n-       String.concat \"\\n\\t\"\n-\n-         ([\"movl  0(%esp), %edx    # edx = rust_task\"]\n-          @ load_esp_from_rust_sp\n-          @ save_callee_saves\n-          @ store_esp_to_rust_sp\n-          @ load_esp_from_runtime_sp\n-          @ restore_callee_saves\n-          @ [\"ret\"]))\n-    ]\n-    @ list_init n_upcall_glues\n-      begin\n-        fun i ->\n-          (* \n-           * 0, 4, 8, 12 are callee-saves\n-           * 16 is retpc\n-           * 20 is taskptr\n-           * 24 is callee\n-           * 28 .. (7+i) * 4 are args\n-           *)\n-\n-          ((Printf.sprintf \"rust_upcall_%d\" i),\n-           String.concat \"\\n\\t\"\n-             (save_callee_saves\n-              @ [\"movl  %esp, %ebp     # ebp = rust_sp\";\n-                 \"movl  20(%esp), %edx # edx = rust_task\"]\n-              @ store_esp_to_rust_sp\n-              @ load_esp_from_runtime_sp\n-              @ [Printf.sprintf\n-                   \"subl  $%d, %%esp   # esp -= args\" ((i+1)*4);\n-                 \"andl  $~0xf, %esp    # align esp down\";\n-                 \"movl  %edx, (%esp)   # arg[0] = rust_task \"]\n-\n-              @ (list_init_concat i\n-                   begin\n-                     fun j ->\n-                       [ Printf.sprintf \"movl  %d(%%ebp),%%edx\" ((j+7)*4);\n-                         Printf.sprintf \"movl  %%edx,%d(%%esp)\" ((j+1)*4) ]\n-                   end)\n-\n-              @ [\"movl  24(%ebp), %edx # edx = callee\";\n-                 \"call  *%edx          # call *%edx\";\n-                 \"movl  20(%ebp), %edx # edx = rust_task\"]\n-              @ load_esp_from_rust_sp\n-              @ restore_callee_saves\n-              @ [\"ret\"]))\n-      end\n-  in\n-\n-  let _ =\n-    Llvm.set_module_inline_asm llmod\n-      begin\n-        String.concat \"\\n\"\n-          begin\n-            List.map\n-              begin\n-                fun (sym,asm) ->\n-                  Printf.sprintf\n-                    \"\\t.globl %s%s\\n\\t.balign %d\\n%s%s:\\n\\t%s\"\n-                    prefix sym align prefix sym asm\n-              end\n-              glue\n-          end\n-      end\n-  in\n-\n-  let decl_cdecl_fn name out_ty arg_tys =\n-    let ty = Llvm.function_type out_ty arg_tys in\n-    let fn = Llvm.declare_function name ty llmod in\n-      Llvm.set_function_call_conv Llvm.CallConv.c fn;\n-      fn\n-  in\n-\n-  let decl_glue s =\n-    let task_ptr_ty = Llvm.pointer_type abi.Llabi.task_ty in\n-    let void_ty = Llvm.void_type llctx in\n-      decl_cdecl_fn s void_ty [| task_ptr_ty |]\n-  in\n-\n-  let decl_upcall n =\n-    let task_ptr_ty = Llvm.pointer_type abi.Llabi.task_ty in\n-    let word_ty = abi.Llabi.word_ty in\n-    let callee_ty = word_ty in\n-    let args_ty =\n-      Array.append\n-        [| task_ptr_ty; callee_ty |]\n-        (Array.init n (fun _ -> word_ty))\n-    in\n-    let name = Printf.sprintf \"rust_upcall_%d\" n in\n-      decl_cdecl_fn name word_ty args_ty\n-  in\n-    {\n-      asm_activate_glue = decl_glue \"rust_activate_glue\";\n-      asm_yield_glue = decl_glue \"rust_yield_glue\";\n-      asm_upcall_glues = Array.init n_upcall_glues decl_upcall;\n-    }\n-;;\n-\n-(* x64-specific asm. *)\n-(* arm-specific asm. *)\n-(* ... *)\n-\n-\n-let get_glue\n-  (llctx:Llvm.llcontext)\n-  (llmod:Llvm.llmodule)\n-  (abi:Llabi.abi)\n-  (sess:Session.sess)\n-  : asm_glue =\n-  match sess.Session.sess_targ with\n-      Linux_x86_elf\n-    | Win32_x86_pe\n-    | MacOS_x86_macho ->\n-        x86_glue llctx llmod abi sess\n-;;\n-\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "2b229fde12e5c70f394498c0ebb0c6dd249ace34", "filename": "src/boot/llvm/llemit.ml", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a634b21563fde802e2424bbef086ce541bb6ad8c/src%2Fboot%2Fllvm%2Fllemit.ml", "raw_url": "https://github.com/rust-lang/rust/raw/a634b21563fde802e2424bbef086ce541bb6ad8c/src%2Fboot%2Fllvm%2Fllemit.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fllvm%2Fllemit.ml?ref=a634b21563fde802e2424bbef086ce541bb6ad8c", "patch": "@@ -1,36 +0,0 @@\n-(*\n- * LLVM emitter.\n- *)\n-\n-(* The top-level interface to the LLVM translation subsystem. *)\n-let trans_and_process_crate\n-    (sess:Session.sess)\n-    (sem_cx:Semant.ctxt)\n-    (crate:Ast.crate)\n-    : unit =\n-  let llcontext = Llvm.create_context () in\n-  let emit_file (llmod:Llvm.llmodule) : unit =\n-    let filename = Session.filename_of sess.Session.sess_out in\n-    if not (Llvm_bitwriter.write_bitcode_file llmod filename)\n-    then raise (Failure (\"failed to write the LLVM bitcode '\" ^ filename\n-      ^ \"'\"))\n-  in\n-  let llmod = Lltrans.trans_crate sem_cx llcontext sess crate in\n-  begin\n-    try\n-      emit_file llmod\n-    with e -> Llvm.dispose_module llmod; raise e\n-  end;\n-  Llvm.dispose_module llmod;\n-  Llvm.dispose_context llcontext\n-;;\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)\n-"}, {"sha": "a7e190cd9c186f1793fd4545d96360fe86bc6d7c", "filename": "src/boot/llvm/llfinal.ml", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/a634b21563fde802e2424bbef086ce541bb6ad8c/src%2Fboot%2Fllvm%2Fllfinal.ml", "raw_url": "https://github.com/rust-lang/rust/raw/a634b21563fde802e2424bbef086ce541bb6ad8c/src%2Fboot%2Fllvm%2Fllfinal.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fllvm%2Fllfinal.ml?ref=a634b21563fde802e2424bbef086ce541bb6ad8c", "patch": "@@ -1,105 +0,0 @@\n-(*\n- * LLVM ABI-level stuff that needs to happen after modules have been\n- * translated.\n- *)\n-\n-let finalize_module\n-    (sess:Session.sess)\n-    (llctx:Llvm.llcontext)\n-    (llmod:Llvm.llmodule)\n-    (abi:Llabi.abi)\n-    (asm_glue:Llasm.asm_glue)\n-    (exit_task_glue:Llvm.llvalue)\n-    (crate_ptr:Llvm.llvalue)\n-    : unit =\n-  let i32 = Llvm.i32_type llctx in\n-\n-  (*\n-   * Count the number of Rust functions and the number of C functions by\n-   * simply (and crudely) testing whether each function in the module begins\n-   * with \"_rust_\".\n-   *)\n-\n-  let (rust_fn_count, c_fn_count) =\n-    let count (rust_fn_count, c_fn_count) fn =\n-      let begins_with prefix str =\n-        let (str_len, prefix_len) =\n-          (String.length str, String.length prefix)\n-        in\n-        prefix_len <= str_len && (String.sub str 0 prefix_len) = prefix\n-      in\n-      if begins_with \"_rust_\" (Llvm.value_name fn) then\n-        (rust_fn_count + 1, c_fn_count)\n-      else\n-        (rust_fn_count, c_fn_count + 1)\n-    in\n-    Llvm.fold_left_functions count (0, 0) llmod\n-  in\n-\n-  let crate_val =\n-    let crate_addr = Llvm.const_ptrtoint crate_ptr i32 in\n-    let glue_off glue =\n-      let addr = Llvm.const_ptrtoint glue i32 in\n-        Llvm.const_sub addr crate_addr\n-    in\n-    let activate_glue_off = glue_off asm_glue.Llasm.asm_activate_glue in\n-    let yield_glue_off = glue_off asm_glue.Llasm.asm_yield_glue in\n-    let exit_task_glue_off = glue_off exit_task_glue in\n-\n-    Llvm.const_struct llctx [|\n-      Llvm.const_int i32 0;             (* ptrdiff_t image_base_off *)\n-      crate_ptr;                        (* uintptr_t self_addr *)\n-      Llvm.const_int i32 0;             (* ptrdiff_t debug_abbrev_off *)\n-      Llvm.const_int i32 0;             (* size_t debug_abbrev_sz *)\n-      Llvm.const_int i32 0;             (* ptrdiff_t debug_info_off *)\n-      Llvm.const_int i32 0;             (* size_t debug_info_sz *)\n-      activate_glue_off;                (* size_t activate_glue_off *)\n-      yield_glue_off;                   (* size_t yield_glue_off *)\n-      Llvm.const_int i32 0;             (* size_t unwind_glue_off *)\n-      Llvm.const_int i32 0;             (* size_t gc_glue_off *)\n-      exit_task_glue_off;               (* size_t main_exit_task_glue_off *)\n-      Llvm.const_int i32 rust_fn_count; (* int n_rust_syms *)\n-      Llvm.const_int i32 c_fn_count;    (* int n_c_syms *)\n-      Llvm.const_int i32 0              (* int n_libs *)\n-    |]\n-  in\n-\n-  Llvm.set_initializer crate_val crate_ptr;\n-\n-  (* Define the main function for crt0 to call. *)\n-  let main_fn =\n-    let main_ty = Llvm.function_type i32 [| i32; i32 |] in\n-    let main_name =\n-      match sess.Session.sess_targ with\n-          Common.Win32_x86_pe -> \"WinMain@16\"\n-        | Common.Linux_x86_elf\n-        | Common.MacOS_x86_macho -> \"main\"\n-  in\n-    Llvm.define_function main_name main_ty llmod\n-  in\n-  let argc = Llvm.param main_fn 0 in\n-  let argv = Llvm.param main_fn 1 in\n-  let main_builder = Llvm.builder_at_end llctx (Llvm.entry_block main_fn) in\n-  let rust_main_fn =\n-    match Llvm.lookup_function \"_rust_main\" llmod with\n-        None -> raise (Failure \"no main function found\")\n-      | Some fn -> fn\n-  in\n-  let rust_start = abi.Llabi.rust_start in\n-  let rust_start_args = [| Llvm.const_ptrtoint rust_main_fn abi.Llabi.word_ty;\n-                           crate_ptr; argc; argv |] in\n-    ignore (Llvm.build_call\n-              rust_start rust_start_args \"start_rust\" main_builder);\n-    ignore (Llvm.build_ret (Llvm.const_int i32 0) main_builder)\n-;;\n-\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)\n-"}, {"sha": "22c1557e7c7d938fa749a57d1a8c7ce860b40000", "filename": "src/boot/llvm/lltrans.ml", "status": "removed", "additions": 0, "deletions": 1148, "changes": 1148, "blob_url": "https://github.com/rust-lang/rust/blob/a634b21563fde802e2424bbef086ce541bb6ad8c/src%2Fboot%2Fllvm%2Flltrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/a634b21563fde802e2424bbef086ce541bb6ad8c/src%2Fboot%2Fllvm%2Flltrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fllvm%2Flltrans.ml?ref=a634b21563fde802e2424bbef086ce541bb6ad8c", "patch": "@@ -1,1148 +0,0 @@\n-(*\n- * LLVM translator.\n- *)\n-\n-open Common;;\n-open Semant;;\n-open Transutil;;\n-\n-let log cx = Session.log \"trans\"\n-  cx.Semant.ctxt_sess.Session.sess_log_trans\n-  cx.Semant.ctxt_sess.Session.sess_log_out\n-;;\n-\n-(* Returns a new LLVM IRBuilder positioned at the end of llblock.  If\n-   debug_loc isn't None, the IRBuilder's debug location is set to its\n-   contents, which should be a DILocation mdnode.  (See\n-   http://llvm.org/docs/SourceLevelDebugging.html, or get it from an existing\n-   llbuilder with Llvm.current_debug_location.) *)\n-let llbuilder_at_end_with_debug_loc\n-    (llctx:Llvm.llcontext) (llblock:Llvm.llbasicblock)\n-    (debug_loc:Llvm.llvalue option) =\n-  let llbuilder = Llvm.builder_at_end llctx llblock in\n-    may (Llvm.set_current_debug_location llbuilder) debug_loc;\n-    llbuilder\n-\n-let trans_crate\n-    (sem_cx:Semant.ctxt)\n-    (llctx:Llvm.llcontext)\n-    (sess:Session.sess)\n-    (crate:Ast.crate)\n-    : Llvm.llmodule =\n-\n-  let iflog thunk =\n-    if sess.Session.sess_log_trans\n-    then thunk ()\n-    else ()\n-  in\n-\n-  (* Helpers for adding metadata. *)\n-  let md_str (s:string) : Llvm.llvalue = Llvm.mdstring llctx s in\n-  let md_node (vals:Llvm.llvalue array) : Llvm.llvalue =\n-    Llvm.mdnode llctx vals\n-  in\n-  let const_i32 (i:int) : Llvm.llvalue =\n-    Llvm.const_int (Llvm.i32_type llctx) i\n-  in\n-  let const_i1 (i:int) : Llvm.llvalue =\n-    Llvm.const_int (Llvm.i1_type llctx) i\n-  in\n-  let llvm_debug_version : int = 0x8 lsl 16 in\n-  let const_dw_tag (tag:Dwarf.dw_tag) : Llvm.llvalue =\n-    const_i32 (llvm_debug_version lor (Dwarf.dw_tag_to_int tag))\n-  in\n-\n-  (* See http://llvm.org/docs/SourceLevelDebugging.html. *)\n-  let crate_compile_unit : Llvm.llvalue =\n-    let name = Hashtbl.find sem_cx.Semant.ctxt_item_files crate.id in\n-    md_node [| const_dw_tag Dwarf.DW_TAG_compile_unit;\n-               const_i32 0;  (* Unused. *)\n-               const_i32 2;  (* DW_LANG_C. FIXME: Pick a Rust DW_LANG code. *)\n-               md_str (Filename.basename name);\n-               md_str (Filename.concat\n-                            (Sys.getcwd()) (Filename.dirname name));\n-               md_str (\"Rustboot \" ^ Version.version);\n-               (* This is the main compile unit. There must be exactly one of\n-                  these in an LLVM module for it to emit debug info. *)\n-               const_i1 1;\n-               (* There are a couple more supported fields, which we ignore\n-                  here. *)\n-            |]\n-  in\n-  let di_file (filepath:string) =\n-    md_node [| const_dw_tag Dwarf.DW_TAG_file_type;\n-               md_str (Filename.basename filepath);\n-               md_str (Filename.concat\n-                            (Sys.getcwd()) (Filename.dirname filepath));\n-               crate_compile_unit\n-            |]\n-  in\n-  let di_subprogram (scope:Llvm.llvalue) (name:string) (fullname:string)\n-      (di_file:Llvm.llvalue) (line:int) (llfunction:Llvm.llvalue)\n-      : Llvm.llvalue =\n-    (* 'scope' is generally a compile unit or other subprogram.  *)\n-    md_node [| const_dw_tag Dwarf.DW_TAG_subprogram;\n-               const_i32 0;  (* Unused. *)\n-               scope;\n-               md_str name;\n-               md_str fullname;  (* Display name *)\n-               md_str fullname;  (* Linkage name *)\n-               di_file;\n-               const_i32 line;\n-               (* FIXME: Fill in the following fields. *)\n-               md_node [||];\n-               const_i1 1;\n-               const_i1 1;\n-               const_i32 0;\n-               const_i32 0;\n-               md_node [||];\n-               const_i1 0;\n-               const_i1 0;\n-               llfunction  (* The llvm::Function this reflects. *)\n-            |]\n-  in\n-  let di_location (line:int) (col:int) (scope:Llvm.llvalue) : Llvm.llvalue =\n-    (* 'scope' is generally a subprogram or block. *)\n-    md_node [| const_i32 line; const_i32 col; scope; const_i32 0 |]\n-  in\n-\n-  let di_location_from_id (scope:Llvm.llvalue) (id:node_id)\n-      : Llvm.llvalue option =\n-    match Session.get_span sess id with\n-        None -> None\n-      | Some span ->\n-          let (_, line, col) = span.lo in\n-            Some (di_location line col scope)\n-  in\n-\n-  (* Sets the 'llbuilder's current location (which it attaches to all\n-     instructions) to the location of the start of the 'id' node within\n-     'scope', usually a subprogram or lexical block. *)\n-  let set_debug_location\n-      (llbuilder:Llvm.llbuilder) (scope:Llvm.llvalue) (id:node_id)\n-      : unit =\n-    may (Llvm.set_current_debug_location llbuilder)\n-      (di_location_from_id scope id)\n-  in\n-\n-  (* Translation of our node_ids into LLVM identifiers, which are strings. *)\n-  let next_anon_llid = ref 0 in\n-  let num_llid num klass = Printf.sprintf \"%s%d\" klass num in\n-  let anon_llid klass =\n-    let llid = num_llid !next_anon_llid klass in\n-    next_anon_llid := !next_anon_llid + 1;\n-    llid\n-  in\n-  let node_llid (node_id_opt:node_id option) : (string -> string) =\n-    match node_id_opt with\n-        None -> anon_llid\n-      | Some (Node num) -> num_llid num\n-  in\n-\n-  let llnilty = Llvm.array_type (Llvm.i1_type llctx) 0 in\n-  let llnil = Llvm.const_array (Llvm.i1_type llctx) [| |] in\n-\n-  let ty_of_item = Hashtbl.find sem_cx.Semant.ctxt_all_item_types in\n-  let ty_of_slot n = Semant.slot_ty (Semant.get_slot sem_cx n) in\n-\n-  let filename = Session.filename_of sess.Session.sess_in in\n-  let llmod = Llvm.create_module llctx filename in\n-\n-  let (abi:Llabi.abi) = Llabi.declare_abi llctx llmod in\n-  let (crate_ptr:Llvm.llvalue) =\n-    Llvm.declare_global abi.Llabi.crate_ty \"rust_crate\" llmod\n-  in\n-\n-  let (void_ty:Llvm.lltype) = Llvm.void_type llctx in\n-  let (word_ty:Llvm.lltype) = abi.Llabi.word_ty in\n-  let (wordptr_ty:Llvm.lltype) = Llvm.pointer_type word_ty in\n-  let (task_ty:Llvm.lltype) = abi.Llabi.task_ty in\n-  let (task_ptr_ty:Llvm.lltype) = Llvm.pointer_type task_ty in\n-  let fn_ty (out:Llvm.lltype) (args:Llvm.lltype array) : Llvm.lltype =\n-    Llvm.function_type out args\n-  in\n-\n-  let imm (i:int64) : Llvm.llvalue =\n-    Llvm.const_int word_ty (Int64.to_int i)\n-  in\n-\n-  let asm_glue = Llasm.get_glue llctx llmod abi sess in\n-\n-  let llty_str llty =\n-    Llvm.string_of_lltype llty\n-  in\n-\n-  let llval_str llv =\n-    let ts = llty_str (Llvm.type_of llv) in\n-      match Llvm.value_name llv with\n-          \"\" ->\n-            Printf.sprintf \"<anon=%s>\" ts\n-        | s -> Printf.sprintf \"<%s=%s>\" s ts\n-  in\n-\n-  let llvals_str llvals =\n-    (String.concat \", \"\n-       (Array.to_list\n-          (Array.map llval_str llvals)))\n-  in\n-\n-  let build_call callee args rvid builder =\n-    iflog\n-      begin\n-        fun _ ->\n-          let name = Llvm.value_name callee in\n-          log sem_cx \"build_call: %s(%s)\" name (llvals_str args);\n-          log sem_cx \"build_call: typeof(%s) = %s\"\n-            name (llty_str (Llvm.type_of callee))\n-      end;\n-    Llvm.build_call callee args rvid builder\n-  in\n-\n-  (* Upcall translation *)\n-\n-  let extern_upcalls = Hashtbl.create 0 in\n-  let trans_upcall\n-      (llbuilder:Llvm.llbuilder)\n-      (lltask:Llvm.llvalue)\n-      (name:string)\n-      (lldest:Llvm.llvalue option)\n-      (llargs:Llvm.llvalue array) =\n-    let n = Array.length llargs in\n-    let llglue = asm_glue.Llasm.asm_upcall_glues.(n) in\n-    let llupcall = htab_search_or_add extern_upcalls name\n-      begin\n-        fun _ ->\n-          let args_ty =\n-            Array.append\n-              [| task_ptr_ty |]\n-              (Array.init n (fun i -> Llvm.type_of llargs.(i)))\n-          in\n-          let out_ty = match lldest with\n-              None -> void_ty\n-            | Some v -> Llvm.type_of v\n-          in\n-          let fty = fn_ty out_ty args_ty in\n-            (* \n-             * NB: At this point it actually doesn't matter what type\n-             * we gave the upcall function, as we're just going to\n-             * pointercast it to a word and pass it to the upcall-glue\n-             * for now. But possibly in the future it might matter if\n-             * we develop a proper upcall calling convention.\n-             *)\n-            Llvm.declare_function name fty llmod\n-      end\n-    in\n-      (* Cast everything to plain words so we can hand off to the glue. *)\n-    let llupcall = Llvm.const_pointercast llupcall word_ty in\n-    let llargs =\n-      Array.map\n-        (fun arg ->\n-           Llvm.build_pointercast arg word_ty\n-             (anon_llid \"arg\") llbuilder)\n-        llargs\n-    in\n-    let llallargs = Array.append [| lltask; llupcall |] llargs in\n-    let llid = anon_llid \"rv\" in\n-    let llrv = build_call llglue llallargs llid llbuilder in\n-      Llvm.set_instruction_call_conv Llvm.CallConv.c llrv;\n-      match lldest with\n-          None -> ()\n-        | Some lldest ->\n-            let lldest =\n-              Llvm.build_pointercast lldest wordptr_ty \"\" llbuilder\n-            in\n-              ignore (Llvm.build_store llrv lldest llbuilder);\n-  in\n-\n-  let upcall\n-      (llbuilder:Llvm.llbuilder)\n-      (lltask:Llvm.llvalue)\n-      (name:string)\n-      (lldest:Llvm.llvalue option)\n-      (llargs:Llvm.llvalue array)\n-      : unit =\n-    trans_upcall llbuilder lltask name lldest llargs\n-  in\n-\n-  let trans_free\n-      (llbuilder:Llvm.llbuilder)\n-      (lltask:Llvm.llvalue)\n-      (src:Llvm.llvalue)\n-      : unit =\n-    upcall llbuilder lltask \"upcall_free\" None [| src; const_i32 0 |]\n-  in\n-\n-  (*\n-   * let trans_malloc (llbuilder:Llvm.llbuilder)\n-   *                  (dst:Llvm.llvalue) (nbytes:int64) : unit =\n-   *   upcall llbuilder \"upcall_malloc\" (Some dst) [| imm nbytes |]\n-   * in\n-   *)\n-\n-  (* Type translation *)\n-\n-  let lltys = Hashtbl.create 0 in\n-\n-  let trans_mach_ty (mty:ty_mach) : Llvm.lltype =\n-    let tycon =\n-      match mty with\n-          TY_u8 | TY_i8 -> Llvm.i8_type\n-        | TY_u16 | TY_i16 -> Llvm.i16_type\n-        | TY_u32 | TY_i32 -> Llvm.i32_type\n-        | TY_u64 | TY_i64 -> Llvm.i64_type\n-        | TY_f32 -> Llvm.float_type\n-        | TY_f64 -> Llvm.double_type\n-    in\n-      tycon llctx\n-  in\n-\n-\n-  let rec trans_ty_full (ty:Ast.ty) : Llvm.lltype =\n-    let p t = Llvm.pointer_type t in\n-    let s ts = Llvm.struct_type llctx ts in\n-    let opaque _ = Llvm.opaque_type llctx in\n-    let vec_body_ty _ =\n-      s [| word_ty; word_ty; word_ty; (opaque()) |]\n-    in\n-    let rc_opaque_ty =\n-      s [| word_ty; (opaque()) |]\n-    in\n-    match ty with\n-        Ast.TY_any -> opaque ()\n-      | Ast.TY_nil -> llnilty\n-      | Ast.TY_bool -> Llvm.i1_type llctx\n-      | Ast.TY_mach mty -> trans_mach_ty mty\n-      | Ast.TY_int -> word_ty\n-      | Ast.TY_uint -> word_ty\n-      | Ast.TY_char -> Llvm.i32_type llctx\n-      | Ast.TY_vec _\n-      | Ast.TY_str -> p (vec_body_ty())\n-\n-      | Ast.TY_fn tfn ->\n-          let (tsig, _) = tfn in\n-          let lloutptr = p (trans_slot None tsig.Ast.sig_output_slot) in\n-          let lltaskty = p abi.Llabi.task_ty in\n-          let llins = Array.map (trans_slot None) tsig.Ast.sig_input_slots in\n-            fn_ty void_ty (Array.append [| lloutptr; lltaskty |] llins)\n-\n-      | Ast.TY_tup slots ->\n-          s (Array.map trans_ty slots)\n-\n-      | Ast.TY_rec entries ->\n-          s (Array.map (fun (_, e) -> trans_ty e) entries)\n-\n-      | Ast.TY_constrained (ty', _) -> trans_ty ty'\n-\n-      | Ast.TY_chan _ | Ast.TY_port _ | Ast.TY_task  ->\n-          p rc_opaque_ty\n-\n-      | Ast.TY_box t ->\n-          (* FIXME: wrong, this needs to point to a refcounted cell. *)\n-          p (trans_ty t)\n-\n-      | Ast.TY_mutable t ->\n-          (* FIXME: No idea if 'mutable' translates to LLVM-type. *)\n-          (trans_ty t)\n-\n-      | Ast.TY_native _ ->\n-          word_ty\n-\n-      | Ast.TY_param _ ->\n-          abi.Llabi.tydesc_ty\n-\n-      | Ast.TY_tag _\n-      | Ast.TY_obj _ | Ast.TY_type | Ast.TY_named _ ->\n-          Common.unimpl None \"LLVM type translation for: %a\" Ast.sprintf_ty ty\n-\n-\n-  and trans_ty t =\n-    htab_search_or_add lltys t (fun _ -> trans_ty_full t)\n-\n-  (* Translates the type of a slot into the corresponding LLVM type. If the\n-   * id_opt parameter is specified, then the type will be fetched from the\n-   * context. *)\n-  and trans_slot (id_opt:node_id option) (slot:Ast.slot) : Llvm.lltype =\n-    let ty =\n-      match id_opt with\n-          Some id -> ty_of_slot id\n-        | None -> Semant.slot_ty slot\n-    in\n-    let base_llty = trans_ty ty in\n-      match slot.Ast.slot_mode with\n-        | Ast.MODE_alias  ->\n-            Llvm.pointer_type base_llty\n-        | Ast.MODE_local  -> base_llty\n-  in\n-\n-  let get_element_ptr\n-      (llbuilder:Llvm.llbuilder)\n-      (ptr:Llvm.llvalue)\n-      (i:int)\n-      : Llvm.llvalue =\n-    (* \n-     * GEP takes a first-index of zero. Because it must! And this is\n-     * sufficiently surprising that the GEP FAQ exists. And you must\n-     * read it.\n-     *)\n-    let deref_ptr = Llvm.const_int (Llvm.i32_type llctx) 0 in\n-    let idx = Llvm.const_int (Llvm.i32_type llctx) i in\n-      Llvm.build_gep ptr [| deref_ptr; idx |] (anon_llid \"gep\") llbuilder\n-  in\n-\n-  let free_ty\n-      (llbuilder:Llvm.llbuilder)\n-      (lltask:Llvm.llvalue)\n-      (ty:Ast.ty)\n-      (ptr:Llvm.llvalue)\n-      : unit =\n-    match ty with\n-        Ast.TY_port _\n-      | Ast.TY_chan _\n-      | Ast.TY_task ->\n-          Common.unimpl None \"ty %a in Lltrans.free_ty\" Ast.sprintf_ty ty\n-      | _ -> trans_free llbuilder lltask ptr\n-  in\n-\n-  let rec iter_ty_parts_full\n-      (llbuilder:Llvm.llbuilder ref)\n-      (ty:Ast.ty)\n-      (dst_ptr:Llvm.llvalue)\n-      (src_ptr:Llvm.llvalue)\n-      (f:(Llvm.llvalue\n-          -> Llvm.llvalue\n-            -> Ast.ty\n-              -> unit))\n-      : unit =\n-\n-    (* NB: must deref llbuilder at call-time; don't curry this. *)\n-    let gep p i = get_element_ptr (!llbuilder) p i in\n-\n-    match ty with\n-        Ast.TY_rec entries ->\n-          iter_rec_parts gep dst_ptr src_ptr entries f\n-\n-      | Ast.TY_tup tys ->\n-          iter_tup_parts gep dst_ptr src_ptr tys f\n-\n-      | Ast.TY_tag _\n-      | Ast.TY_fn _\n-      | Ast.TY_obj _ ->\n-          Common.unimpl None\n-            \"ty %a in Lltrans.iter_ty_parts_full\" Ast.sprintf_ty ty\n-\n-      | _ -> ()\n-\n-  and iter_ty_parts\n-      (llbuilder:Llvm.llbuilder ref)\n-      (ty:Ast.ty)\n-      (ptr:Llvm.llvalue)\n-      (f:Llvm.llvalue -> Ast.ty -> unit)\n-      : unit =\n-    iter_ty_parts_full llbuilder ty ptr ptr\n-      (fun _ src_ptr slot -> f src_ptr slot)\n-\n-  and drop_ty\n-      (llbuilder:Llvm.llbuilder ref)\n-      (lltask:Llvm.llvalue)\n-      (ptr:Llvm.llvalue)\n-      (ty:Ast.ty)\n-      : unit =\n-    iter_ty_parts llbuilder ty ptr (drop_ty llbuilder lltask)\n-\n-  and drop_slot\n-      (llbuilder:Llvm.llbuilder ref)\n-      (lltask:Llvm.llvalue)\n-      (slot_ptr:Llvm.llvalue)\n-      (slot:Ast.slot)\n-      : unit =\n-\n-    let llfn = Llvm.block_parent (Llvm.insertion_block (!llbuilder)) in\n-    let llty = trans_slot None slot in\n-    let ty = Semant.slot_ty slot in\n-\n-    let new_block klass debug_loc =\n-      let llblock = Llvm.append_block llctx (anon_llid klass) llfn in\n-      let llbuilder =\n-        llbuilder_at_end_with_debug_loc llctx llblock debug_loc in\n-        (llblock, llbuilder)\n-    in\n-\n-    let if_ptr_in_slot_not_null\n-        (inner:Llvm.llvalue -> Llvm.llbuilder -> Llvm.llbuilder)\n-        (llbuilder:Llvm.llbuilder)\n-        : Llvm.llbuilder =\n-      let ptr = Llvm.build_load slot_ptr (anon_llid \"tmp\") llbuilder in\n-      let null = Llvm.const_pointer_null llty in\n-      let test =\n-        Llvm.build_icmp Llvm.Icmp.Ne null ptr (anon_llid \"nullp\") llbuilder\n-      in\n-      let debug_loc = Llvm.current_debug_location llbuilder in\n-      let (llthen, llthen_builder) = new_block \"then\" debug_loc in\n-      let (llnext, llnext_builder) = new_block \"next\" debug_loc in\n-        ignore (Llvm.build_cond_br test llthen llnext llbuilder);\n-        let llthen_builder = inner ptr llthen_builder in\n-          ignore (Llvm.build_br llnext llthen_builder);\n-          llnext_builder\n-    in\n-\n-    let decr_refcnt_and_if_zero\n-        (rc_elt:int)\n-        (inner:Llvm.llvalue -> Llvm.llbuilder -> Llvm.llbuilder)\n-        (ptr:Llvm.llvalue)\n-        (llbuilder:Llvm.llbuilder)\n-        : Llvm.llbuilder  =\n-      let rc_ptr = get_element_ptr llbuilder ptr rc_elt in\n-      let rc = Llvm.build_load rc_ptr (anon_llid \"rc\") llbuilder in\n-      let rc = Llvm.build_sub rc (imm 1L) (anon_llid \"tmp\") llbuilder in\n-      let _ = Llvm.build_store rc rc_ptr llbuilder in\n-        log sem_cx \"rc type: %s\" (llval_str rc);\n-      let test =\n-        Llvm.build_icmp Llvm.Icmp.Eq\n-          rc (imm 0L) (anon_llid \"zerop\") llbuilder\n-      in\n-      let debug_loc = Llvm.current_debug_location llbuilder in\n-      let (llthen, llthen_builder) = new_block \"then\" debug_loc in\n-      let (llnext, llnext_builder) = new_block \"next\" debug_loc in\n-        ignore (Llvm.build_cond_br test llthen llnext llbuilder);\n-        let llthen_builder = inner ptr llthen_builder in\n-          ignore (Llvm.build_br llnext llthen_builder);\n-          llnext_builder\n-    in\n-\n-    let free_and_null_out_slot\n-        (ptr:Llvm.llvalue)\n-        (llbuilder:Llvm.llbuilder)\n-        : Llvm.llbuilder =\n-      free_ty llbuilder lltask ty ptr;\n-      let null = Llvm.const_pointer_null llty in\n-        ignore (Llvm.build_store null slot_ptr llbuilder);\n-        llbuilder\n-    in\n-\n-      begin\n-          match slot_mem_ctrl sem_cx slot with\n-              MEM_rc_struct\n-            | MEM_gc ->\n-                llbuilder :=\n-                  if_ptr_in_slot_not_null\n-                    (decr_refcnt_and_if_zero\n-                       Abi.box_rc_field_refcnt\n-                       free_and_null_out_slot)\n-                    (!llbuilder)\n-\n-            | MEM_rc_opaque ->\n-                llbuilder :=\n-                  if_ptr_in_slot_not_null\n-                    (decr_refcnt_and_if_zero\n-                       Abi.box_rc_field_refcnt\n-                       free_and_null_out_slot)\n-                    (!llbuilder)\n-\n-            | MEM_interior when Semant.type_is_structured sem_cx ty ->\n-                (* FIXME: to handle recursive types, need to call drop\n-                   glue here, not inline. *)\n-                drop_ty llbuilder lltask slot_ptr ty\n-\n-            | _ -> ()\n-        end\n-  in\n-\n-  (* Dereferences the box referred to by ptr, whose type is ty.  Looks\n-     straight through all mutable and constrained-type boxes, and loads\n-     pointers per dctrl.  Returns the dereferenced value and its type. *)\n-  let rec deref_ty\n-      (llbuilder:Llvm.llbuilder) (dctrl:deref_ctrl)\n-      (ptr:Llvm.llvalue) (ty:Ast.ty)\n-      : (Llvm.llvalue * Ast.ty) =\n-    match (ty, dctrl) with\n-\n-      | (Ast.TY_mutable ty, _)\n-      | (Ast.TY_constrained (ty, _), _) ->\n-          deref_ty llbuilder dctrl ptr ty\n-\n-      | (Ast.TY_box ty', DEREF_one_box)\n-      | (Ast.TY_box ty', DEREF_all_boxes) ->\n-          let content =\n-            Llvm.build_load\n-              (get_element_ptr llbuilder ptr (Abi.box_rc_field_body))\n-              (anon_llid \"deref\") llbuilder\n-          in\n-          let inner_dctrl =\n-            if dctrl = DEREF_one_box\n-            then DEREF_none\n-            else DEREF_all_boxes\n-          in\n-            (* Possibly deref recursively. *)\n-            deref_ty llbuilder inner_dctrl content ty'\n-\n-      | _ -> (ptr, ty)\n-  in\n-\n-  let (llitems:(node_id, Llvm.llvalue) Hashtbl.t) = Hashtbl.create 0 in\n-    (* Maps a fn's or block's id to an LLVM metadata node (subprogram or\n-       lexical block) representing it. *)\n-  let (dbg_llscopes:(node_id, Llvm.llvalue) Hashtbl.t) = Hashtbl.create 0 in\n-  let rec declare_mod_item\n-      (name:Ast.ident)\n-      mod_item\n-      : unit =\n-    let { node = { Ast.decl_item = (item:Ast.mod_item');\n-                   Ast.decl_params = _ }; id = id } =\n-      mod_item in\n-    let full_name = Semant.item_str sem_cx id in\n-    let (filename, line_num) =\n-      match Session.get_span sess id with\n-          None -> (\"\", 0)\n-        | Some span ->\n-            let (file, line, _) = span.lo in\n-              (file, line)\n-    in\n-      match item with\n-          Ast.MOD_ITEM_fn _ ->\n-            let llty = trans_ty (ty_of_item id) in\n-            let llfn = Llvm.declare_function (\"_rust_\" ^ name) llty llmod in\n-            let meta = (di_subprogram crate_compile_unit name full_name\n-                          (di_file filename) line_num llfn)\n-            in\n-              Llvm.set_function_call_conv Llvm.CallConv.c llfn;\n-              Hashtbl.add llitems id llfn;\n-              Hashtbl.add dbg_llscopes id meta\n-\n-        | Ast.MOD_ITEM_type _ ->\n-            ()  (* Types get translated with their terms. *)\n-\n-        | Ast.MOD_ITEM_mod (_, items) ->\n-            Hashtbl.iter declare_mod_item items\n-\n-        | _ ->\n-            Common.unimpl (Some id)\n-              \"LLVM module declaration for: %a\"\n-              Ast.sprintf_mod_item (name, mod_item)\n-  in\n-\n-  let trans_fn (fn:Ast.fn)\n-      (fn_id:node_id)\n-      : unit =\n-    let header_slots = fn.Ast.fn_input_slots in\n-    let body = fn.Ast.fn_body in\n-    let llfn = Hashtbl.find llitems fn_id in\n-    let lloutptr = Llvm.param llfn 0 in\n-    let lltask = Llvm.param llfn 1 in\n-    let llsubprogram = Hashtbl.find dbg_llscopes fn_id in\n-\n-    (* LLVM requires that functions be grouped into basic blocks terminated by\n-     * terminator instructions, while our AST is less strict. So we have to do\n-     * a little trickery here to wrangle the statement sequence into LLVM's\n-     * format. *)\n-\n-    let new_block id_opt klass debug_loc =\n-      let llblock = Llvm.append_block llctx (node_llid id_opt klass) llfn in\n-      let llbuilder =\n-        llbuilder_at_end_with_debug_loc llctx llblock debug_loc in\n-        (llblock, llbuilder)\n-    in\n-\n-    (* Build up the slot-to-llvalue mapping, allocating space along the\n-     * way. *)\n-    let slot_to_llvalue = Hashtbl.create 0 in\n-    let (_, llinitbuilder) =\n-      new_block None \"init\" (di_location_from_id llsubprogram fn_id) in\n-\n-    (* Allocate space for arguments (needed because arguments are lvalues in\n-     * Rust), and store them in the slot-to-llvalue mapping. *)\n-    let n_implicit_args = 2 in\n-    let build_arg idx llargval =\n-      if idx >= n_implicit_args\n-      then\n-        let ({ id = id; node = _ }, ident) = header_slots.(idx - 2) in\n-        Llvm.set_value_name ident llargval;\n-        let llarg =\n-          let llty = Llvm.type_of llargval in\n-          Llvm.build_alloca llty (ident ^ \"_ptr\") llinitbuilder\n-        in\n-        ignore (Llvm.build_store llargval llarg llinitbuilder);\n-        Hashtbl.add slot_to_llvalue id llarg\n-    in\n-    Array.iteri build_arg (Llvm.params llfn);\n-\n-    (* Allocate space for all the blocks' slots.\n-     * and zero the box pointers. *)\n-    let init_block (block_id:node_id) : unit =\n-      let init_slot\n-          (key:Ast.slot_key)\n-          (slot_id:node_id)\n-          (slot:Ast.slot)\n-          : unit =\n-        let name = Ast.sprintf_slot_key () key in\n-        let llty = trans_slot (Some slot_id) slot in\n-        let llptr = Llvm.build_alloca llty name llinitbuilder in\n-          begin\n-            match slot_mem_ctrl sem_cx slot with\n-                MEM_rc_struct\n-              | MEM_rc_opaque\n-              | MEM_gc ->\n-                  ignore (Llvm.build_store\n-                            (Llvm.const_pointer_null llty)\n-                            llptr llinitbuilder);\n-              | _ -> ()\n-          end;\n-          Hashtbl.add slot_to_llvalue slot_id llptr\n-      in\n-        iter_block_slots sem_cx block_id init_slot\n-    in\n-\n-    let exit_block\n-        (llbuilder:Llvm.llbuilder)\n-        (block_id:node_id)\n-        : Llvm.llbuilder =\n-      let r = ref llbuilder in\n-        iter_block_slots sem_cx block_id\n-          begin\n-            fun _ slot_id slot ->\n-              if (not (Semant.slot_is_obj_state sem_cx slot_id))\n-              then\n-                let ptr = Hashtbl.find slot_to_llvalue slot_id in\n-                  drop_slot r lltask ptr slot\n-          end;\n-        !r\n-    in\n-\n-    List.iter init_block (Hashtbl.find sem_cx.Semant.ctxt_frame_blocks fn_id);\n-\n-    let static_str (s:string) : Llvm.llvalue =\n-      Llvm.define_global (anon_llid \"str\") (Llvm.const_stringz llctx s) llmod\n-    in\n-\n-\n-    (* Translates a list of AST statements to a sequence of LLVM instructions.\n-     * The supplied \"terminate\" function appends the appropriate terminator\n-     * instruction to the instruction stream. It may or may not be called,\n-     * depending on whether the AST contains a terminating instruction\n-     * explicitly. *)\n-    let rec trans_stmts\n-        (block_id:node_id)\n-        (llbuilder:Llvm.llbuilder)\n-        (stmts:Ast.stmt list)\n-        (terminate:(Llvm.llbuilder -> node_id -> unit))\n-        : unit =\n-      let set_debug_loc (id:node_id) =\n-        (* Sets the llbuilder's current location (which it attaches to all\n-           instructions) to the location of the start of the 'id' node. *)\n-        set_debug_location llbuilder llsubprogram id\n-      in\n-\n-      let trans_literal\n-          (lit:Ast.lit)\n-          : Llvm.llvalue =\n-        match lit with\n-            Ast.LIT_nil -> llnil\n-          | Ast.LIT_bool value ->\n-            Llvm.const_int (Llvm.i1_type llctx) (if value then 1 else 0)\n-          | Ast.LIT_mach_int (mty, value) ->\n-            let llty = trans_mach_ty mty in\n-            Llvm.const_of_int64 llty value (mach_is_signed mty)\n-          | Ast.LIT_int value ->\n-            Llvm.const_of_int64 (Llvm.i32_type llctx) value true\n-          | Ast.LIT_uint value ->\n-            Llvm.const_of_int64 (Llvm.i32_type llctx) value false\n-          | Ast.LIT_char ch ->\n-            Llvm.const_int (Llvm.i32_type llctx) ch\n-      in\n-\n-      (* Translates an lval by reference into the appropriate pointer\n-       * value. *)\n-      let rec trans_lval (lval:Ast.lval) : (Llvm.llvalue * Ast.ty) =\n-        iflog (fun _ -> log sem_cx \"trans_lval: %a\" Ast.sprintf_lval lval);\n-        match lval with\n-            Ast.LVAL_base { id = base_id; node = _ } ->\n-              set_debug_loc base_id;\n-              let defn_id = lval_base_defn_id sem_cx lval in\n-              begin\n-                match get_defn sem_cx defn_id with\n-                    Semant.DEFN_slot slot ->\n-                      (Hashtbl.find slot_to_llvalue defn_id, slot_ty slot)\n-                  | Semant.DEFN_item _ ->\n-                      (Hashtbl.find llitems defn_id, lval_ty sem_cx lval)\n-                  | _ ->\n-                      Common.unimpl (Some defn_id)\n-                        \"LLVM base-defn translation of: %a\"\n-                        Ast.sprintf_lval lval\n-              end\n-          | Ast.LVAL_ext (base, component) ->\n-              let (llbase, base_ty) = trans_lval base in\n-              let base_ty = strip_mutable_or_constrained_ty base_ty in\n-                (*\n-                 * All lval components aside from explicit-deref just\n-                 * auto-deref through all boxes to find their indexable\n-                 * referent.\n-                 *)\n-              let (llbase, base_ty) =\n-                if component = Ast.COMP_deref\n-                then (llbase, base_ty)\n-                else deref_ty llbuilder DEREF_all_boxes llbase base_ty\n-              in\n-                match (base_ty, component) with\n-                    (Ast.TY_rec entries,\n-                     Ast.COMP_named (Ast.COMP_ident id)) ->\n-                      let i = arr_idx (Array.map fst entries) id in\n-                        (get_element_ptr llbuilder llbase i, snd entries.(i))\n-\n-                  | (Ast.TY_tup entries,\n-                     Ast.COMP_named (Ast.COMP_idx i)) ->\n-                      (get_element_ptr llbuilder llbase i, entries.(i))\n-\n-                  | (Ast.TY_box _, Ast.COMP_deref) ->\n-                      deref_ty llbuilder DEREF_one_box llbase base_ty\n-\n-                  | _ -> (Common.unimpl (Some (Semant.lval_base_id lval))\n-                            \"LLVM lval translation of: %a\"\n-                            Ast.sprintf_lval lval)\n-      in\n-\n-      let trans_callee (fn:Ast.lval) : (Llvm.llvalue * Ast.ty) =\n-        let fty = Hashtbl.find sem_cx.ctxt_all_lval_types (lval_base_id fn) in\n-          if lval_base_is_item sem_cx fn then\n-            let fn_item = lval_item sem_cx fn in\n-            let llfn = Hashtbl.find llitems (fn_item.id) in\n-              (llfn, fty)\n-          else\n-            (* indirect call to computed slot *)\n-            trans_lval fn\n-      in\n-\n-      let trans_atom (atom:Ast.atom) : Llvm.llvalue =\n-        iflog (fun _ -> log sem_cx \"trans_atom: %a\" Ast.sprintf_atom atom);\n-        match atom with\n-            Ast.ATOM_literal { node = lit; id = _ } -> trans_literal lit\n-          | Ast.ATOM_lval lval ->\n-              Llvm.build_load (fst (trans_lval lval)) (anon_llid \"tmp\")\n-                llbuilder\n-          | Ast.ATOM_pexp _ ->\n-              bug () \"Lltrans.trans_atom on ATOM_pexp\"\n-      in\n-\n-      let build_binop (op:Ast.binop) (lllhs:Llvm.llvalue) (llrhs:Llvm.llvalue)\n-          : Llvm.llvalue =\n-        let llid = anon_llid \"expr\" in\n-        match op with\n-            Ast.BINOP_eq ->\n-              (* TODO: equality works on more than just integers *)\n-              Llvm.build_icmp Llvm.Icmp.Eq lllhs llrhs llid llbuilder\n-\n-            (* TODO: signed/unsigned distinction, floating point *)\n-          | Ast.BINOP_add -> Llvm.build_add lllhs llrhs llid llbuilder\n-          | Ast.BINOP_sub -> Llvm.build_sub lllhs llrhs llid llbuilder\n-          | Ast.BINOP_mul -> Llvm.build_mul lllhs llrhs llid llbuilder\n-          | Ast.BINOP_div -> Llvm.build_sdiv lllhs llrhs llid llbuilder\n-          | Ast.BINOP_mod -> Llvm.build_srem lllhs llrhs llid llbuilder\n-\n-          | _ ->\n-              Common.unimpl None\n-                \"LLVM binop trranslation of: %a\"\n-                Ast.sprintf_binop op\n-      in\n-\n-      let trans_binary_expr\n-          ((op:Ast.binop), (lhs:Ast.atom), (rhs:Ast.atom))\n-          : Llvm.llvalue =\n-        (* Evaluate the operands in the proper order. *)\n-        let (lllhs, llrhs) =\n-          match op with\n-              Ast.BINOP_or | Ast.BINOP_and | Ast.BINOP_eq | Ast.BINOP_ne\n-                  | Ast.BINOP_lt | Ast.BINOP_le | Ast.BINOP_ge | Ast.BINOP_gt\n-                  | Ast.BINOP_lsl | Ast.BINOP_lsr | Ast.BINOP_asr\n-                  | Ast.BINOP_add | Ast.BINOP_sub | Ast.BINOP_mul\n-                  | Ast.BINOP_div | Ast.BINOP_mod | Ast.BINOP_xor ->\n-                (trans_atom lhs, trans_atom rhs)\n-            | Ast.BINOP_send ->\n-                let llrhs = trans_atom rhs in\n-                let lllhs = trans_atom lhs in\n-                (lllhs, llrhs)\n-        in\n-          build_binop op lllhs llrhs\n-      in\n-\n-      let trans_unary_expr e =\n-        Common.unimpl None\n-          \"LLVM unary-expression translation of: %a\"\n-          Ast.sprintf_expr (Ast.EXPR_unary e)\n-      in\n-\n-      let trans_expr (expr:Ast.expr) : Llvm.llvalue =\n-        iflog (fun _ -> log sem_cx \"trans_expr: %a\" Ast.sprintf_expr expr);\n-        match expr with\n-            Ast.EXPR_binary binexp -> trans_binary_expr binexp\n-          | Ast.EXPR_unary unexp -> trans_unary_expr unexp\n-          | Ast.EXPR_atom atom -> trans_atom atom\n-      in\n-\n-      let trans_log_str (atom:Ast.atom) : unit =\n-        upcall llbuilder lltask \"upcall_log_str\" None [| trans_atom atom |]\n-      in\n-\n-      let trans_log_int (atom:Ast.atom) : unit =\n-        upcall llbuilder lltask \"upcall_log_int\" None [| trans_atom atom |]\n-      in\n-\n-      let trans_fail\n-          (llbuilder:Llvm.llbuilder)\n-          (lltask:Llvm.llvalue)\n-          (reason:string)\n-          (stmt_id:node_id)\n-          : unit =\n-        let (file, line, _) =\n-          match Session.get_span sem_cx.Semant.ctxt_sess stmt_id with\n-              None -> (\"<none>\", 0, 0)\n-            | Some sp -> sp.lo\n-        in\n-        upcall llbuilder lltask \"upcall_fail\" None [|\n-          static_str reason;\n-          static_str file;\n-          Llvm.const_int (Llvm.i32_type llctx) line\n-        |];\n-        ignore (Llvm.build_unreachable llbuilder)\n-      in\n-\n-      (* FIXME: this may be irrelevant; possibly LLVM will wind up\n-       * using GOT and such wherever it needs to to achieve PIC\n-       * data.\n-       *)\n-      (*\n-        let crate_rel (v:Llvm.llvalue) : Llvm.llvalue =\n-        let v_int = Llvm.const_pointercast v word_ty in\n-        let c_int = Llvm.const_pointercast crate_ptr word_ty in\n-        Llvm.const_sub v_int c_int\n-        in\n-      *)\n-\n-      match stmts with\n-          [] -> terminate llbuilder block_id\n-        | head::tail ->\n-\n-            iflog (fun _ ->\n-                     log sem_cx \"trans_stmt: %a\" Ast.sprintf_stmt head);\n-\n-            let trans_tail_with_builder llbuilder' : unit =\n-              trans_stmts block_id llbuilder' tail terminate\n-            in\n-            let trans_tail () = trans_tail_with_builder llbuilder in\n-\n-            set_debug_loc head.id;\n-\n-            match head.node with\n-                Ast.STMT_new_tup (dest, elems) ->\n-                  let zero = const_i32 0 in\n-                  let (lldest, _) = trans_lval dest in\n-                  let trans_tup_elem idx (_, atom) =\n-                    let indices = [| zero; const_i32 idx |] in\n-                    let gep_id = anon_llid \"init_tup_gep\" in\n-                    let ptr =\n-                      Llvm.build_gep lldest indices gep_id llbuilder\n-                    in\n-                    ignore (Llvm.build_store (trans_atom atom) ptr llbuilder)\n-                  in\n-                  Array.iteri trans_tup_elem elems;\n-                  trans_tail ()\n-\n-              | Ast.STMT_copy (dest, src) ->\n-                  let llsrc = trans_expr src in\n-                  let (lldest, _) = trans_lval dest in\n-                  ignore (Llvm.build_store llsrc lldest llbuilder);\n-                  trans_tail ()\n-\n-              | Ast.STMT_copy_binop (dest, op, src) ->\n-                  let (lldest, _) = trans_lval dest in\n-                  let llsrc = trans_atom src in\n-                    (* FIXME: Handle vecs and strs. *)\n-                  let lldest_deref =\n-                    Llvm.build_load lldest (anon_llid \"dest_init\") llbuilder\n-                  in\n-                  let llres = build_binop op lldest_deref llsrc in\n-                  ignore (Llvm.build_store llres lldest llbuilder);\n-                  trans_tail ()\n-\n-              | Ast.STMT_call (dest, fn, args) ->\n-                  let llargs = Array.map trans_atom args in\n-                  let (lldest, _) = trans_lval dest in\n-                  let (llfn, _) = trans_callee fn in\n-                  let llallargs = Array.append [| lldest; lltask |] llargs in\n-                  let llrv = build_call llfn llallargs \"\" llbuilder in\n-                    Llvm.set_instruction_call_conv Llvm.CallConv.c llrv;\n-                    trans_tail ()\n-\n-              | Ast.STMT_if sif ->\n-                  let llexpr = trans_expr sif.Ast.if_test in\n-                  let (llnext, llnextbuilder) =\n-                    new_block None \"next\"\n-                      (Llvm.current_debug_location llbuilder) in\n-                  let branch_to_next llbuilder' _ =\n-                    ignore (Llvm.build_br llnext llbuilder')\n-                  in\n-                  let llthen = trans_block sif.Ast.if_then branch_to_next in\n-                  let llelse =\n-                    match sif.Ast.if_else with\n-                        None -> llnext\n-                      | Some if_else -> trans_block if_else branch_to_next\n-                  in\n-                  ignore (Llvm.build_cond_br llexpr llthen llelse llbuilder);\n-                  trans_tail_with_builder llnextbuilder\n-\n-              | Ast.STMT_ret atom_opt ->\n-                  begin\n-                    match atom_opt with\n-                        None -> ()\n-                      | Some atom ->\n-                          ignore (Llvm.build_store (trans_atom atom)\n-                                    lloutptr llbuilder)\n-                  end;\n-                  let llbuilder = exit_block llbuilder block_id in\n-                    ignore (Llvm.build_ret_void llbuilder)\n-\n-              | Ast.STMT_fail ->\n-                  trans_fail llbuilder lltask \"explicit failure\" head.id\n-\n-              | Ast.STMT_log a ->\n-                  begin\n-                    let aty = Semant.atom_type sem_cx a in\n-                      match Semant.simplified_ty aty with\n-                          (* NB: If you extend this, be sure to update the\n-                           * typechecking code in type.ml as well. *)\n-                          Ast.TY_str -> trans_log_str a\n-                        | Ast.TY_int | Ast.TY_uint | Ast.TY_bool | Ast.TY_char\n-                        | Ast.TY_mach (TY_u8) | Ast.TY_mach (TY_u16)\n-                        | Ast.TY_mach (TY_u32) | Ast.TY_mach (TY_i8)\n-                        | Ast.TY_mach (TY_i16) | Ast.TY_mach (TY_i32) ->\n-                            trans_log_int a\n-                        | _ -> Common.unimpl (Some head.id)\n-                            \"logging type\"\n-                  end;\n-                  trans_tail ()\n-\n-              | Ast.STMT_check_expr expr ->\n-                  let llexpr = trans_expr expr in\n-                  let debug_loc = Llvm.current_debug_location llbuilder in\n-                  let (llfail, llfailbuilder) =\n-                    new_block None \"fail\" debug_loc in\n-                  let reason = Fmt.fmt_to_str Ast.fmt_expr expr in\n-                  trans_fail llfailbuilder lltask reason head.id;\n-                  let (llok, llokbuilder) =\n-                    new_block None \"ok\" debug_loc in\n-                  ignore (Llvm.build_cond_br llexpr llok llfail llbuilder);\n-                  trans_tail_with_builder llokbuilder\n-\n-              | Ast.STMT_new_str (dst, str) ->\n-                  let (d, _) = trans_lval dst in\n-                  let s = static_str str in\n-                  let len =\n-                    Llvm.const_int word_ty ((String.length str) + 1)\n-                  in\n-                    upcall llbuilder lltask \"upcall_new_str\"\n-                      (Some d) [| s; len |];\n-                    trans_tail ()\n-\n-              | Ast.STMT_decl _ ->\n-                  trans_tail ()\n-\n-              | _ ->\n-                  Common.unimpl (Some head.id)\n-                    \"LLVM statement translation of: %a\"\n-                    Ast.sprintf_stmt head\n-\n-    (* \n-     * Translates an AST block to one or more LLVM basic blocks and returns\n-     * the first basic block. The supplied callback is expected to add a\n-     * terminator instruction.\n-     *)\n-\n-    and trans_block\n-        ({ node = (stmts:Ast.stmt array); id = id }:Ast.block)\n-        (terminate:Llvm.llbuilder -> node_id -> unit)\n-        : Llvm.llbasicblock =\n-      let (llblock, llbuilder) =\n-        new_block (Some id) \"bb\" (di_location_from_id llsubprogram id) in\n-        trans_stmts id llbuilder (Array.to_list stmts) terminate;\n-        llblock\n-    in\n-\n-    (* \"Falling off the end\" of a function needs to turn into an explicit\n-     * return instruction. *)\n-    let default_terminate llbuilder block_id =\n-      let llbuilder = exit_block llbuilder block_id in\n-        ignore (Llvm.build_ret_void llbuilder)\n-    in\n-\n-    (* Build up the first body block, and link it to the end of the\n-     * initialization block. *)\n-    let llbodyblock = (trans_block body default_terminate) in\n-      ignore (Llvm.build_br llbodyblock llinitbuilder)\n-  in\n-\n-  let rec trans_mod_item\n-      (name:Ast.ident)\n-      mod_item\n-      : unit =\n-    let { node = { Ast.decl_item = (item:Ast.mod_item');\n-                   Ast.decl_params = _ }; id = id } =\n-      mod_item in\n-    match item with\n-        Ast.MOD_ITEM_type _ ->\n-          ()  (* Types get translated with their terms. *)\n-      | Ast.MOD_ITEM_mod (_, items) ->\n-          Hashtbl.iter trans_mod_item items\n-      | Ast.MOD_ITEM_fn fn -> trans_fn fn id\n-      | _ -> Common.unimpl (Some id)\n-          \"LLVM module declaration for: %a\"\n-            Ast.sprintf_mod_item (name, mod_item)\n-\n-  in\n-\n-  let exit_task_glue =\n-    (* The exit-task glue does not get called.\n-     * \n-     * Rather, control arrives at it by *returning* to the first\n-     * instruction of it, when control falls off the end of the task's\n-     * root function.\n-     * \n-     * There is a \"fake\" frame set up by the runtime, underneath us,\n-     * that we find ourselves in. This frame has the shape of a frame\n-     * entered with 2 standard arguments (outptr + taskptr), then a\n-     * retpc and N callee-saves sitting on the stack; all this is under\n-     * ebp. Then there are 2 *outgoing* args at sp[0] and sp[1].\n-     * \n-     * All these are fake except the taskptr, which is the one bit we\n-     * want. So we construct an equally fake cdecl llvm signature here\n-     * to crudely *get* the taskptr that's sitting 2 words up from sp,\n-     * and pass it to upcall_exit.\n-     * \n-     * The latter never returns.\n-     *)\n-    let llty = fn_ty void_ty [| task_ptr_ty |] in\n-    let llfn = Llvm.declare_function \"rust_exit_task_glue\" llty llmod in\n-    let lltask = Llvm.param llfn 0 in\n-    let llblock = Llvm.append_block llctx \"body\" llfn in\n-    let llbuilder = Llvm.builder_at_end llctx llblock in\n-      trans_upcall llbuilder lltask \"upcall_exit\" None [||];\n-      ignore (Llvm.build_ret_void llbuilder);\n-      llfn\n-  in\n-\n-    try\n-      let crate' = crate.node in\n-      let items = snd (crate'.Ast.crate_items) in\n-        Hashtbl.iter declare_mod_item items;\n-        Hashtbl.iter trans_mod_item items;\n-        Llfinal.finalize_module\n-          sess llctx llmod abi asm_glue exit_task_glue crate_ptr;\n-        llmod\n-    with e -> Llvm.dispose_module llmod; raise e\n-;;\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)\n-"}]}