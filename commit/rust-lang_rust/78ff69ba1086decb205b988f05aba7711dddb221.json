{"sha": "78ff69ba1086decb205b988f05aba7711dddb221", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4ZmY2OWJhMTA4NmRlY2IyMDViOTg4ZjA1YWJhNzcxMWRkZGIyMjE=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-05-24T16:22:04Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-09-18T19:23:00Z"}, "message": "Implement a destination propagation pass", "tree": {"sha": "c59923b830955d667d1ce60f5421a1d9a0577d09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c59923b830955d667d1ce60f5421a1d9a0577d09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78ff69ba1086decb205b988f05aba7711dddb221", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78ff69ba1086decb205b988f05aba7711dddb221", "html_url": "https://github.com/rust-lang/rust/commit/78ff69ba1086decb205b988f05aba7711dddb221", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78ff69ba1086decb205b988f05aba7711dddb221/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "html_url": "https://github.com/rust-lang/rust/commit/9f8ac718f44e280edb1a7b3266f2c26106ec11a0"}], "stats": {"total": 743, "additions": 742, "deletions": 1}, "files": [{"sha": "1769feaf7a5140c2abf61f6592a0796224303116", "filename": "compiler/rustc_mir/src/dataflow/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78ff69ba1086decb205b988f05aba7711dddb221/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff69ba1086decb205b988f05aba7711dddb221/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fmod.rs?ref=78ff69ba1086decb205b988f05aba7711dddb221", "patch": "@@ -204,7 +204,7 @@ impl<'a, 'tcx> HasMoveData<'tcx> for DefinitelyInitializedPlaces<'a, 'tcx> {\n \n /// `EverInitializedPlaces` tracks all places that might have ever been\n /// initialized upon reaching a particular point in the control flow\n-/// for a function, without an intervening `Storage Dead`.\n+/// for a function, without an intervening `StorageDead`.\n ///\n /// This dataflow is used to determine if an immutable local variable may\n /// be assigned to."}, {"sha": "251037792c917db60d79899ac67b7d88d1a4ae33", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/78ff69ba1086decb205b988f05aba7711dddb221/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff69ba1086decb205b988f05aba7711dddb221/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=78ff69ba1086decb205b988f05aba7711dddb221", "patch": "@@ -6,6 +6,7 @@ Rust MIR: a lowered representation of Rust.\n \n #![feature(nll)]\n #![feature(in_band_lifetimes)]\n+#![feature(bindings_after_at)]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]"}, {"sha": "19054f36171d916a9be20abb842a57b66ca499b5", "filename": "compiler/rustc_mir/src/transform/dest_prop.rs", "status": "added", "additions": 732, "deletions": 0, "changes": 732, "blob_url": "https://github.com/rust-lang/rust/blob/78ff69ba1086decb205b988f05aba7711dddb221/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff69ba1086decb205b988f05aba7711dddb221/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs?ref=78ff69ba1086decb205b988f05aba7711dddb221", "patch": "@@ -0,0 +1,732 @@\n+//! Propagates assignment destinations backwards in the CFG to eliminate redundant assignments.\n+//!\n+//! # Motivation\n+//!\n+//! MIR building can insert a lot of redundant copies, and Rust code in general often tends to move\n+//! values around a lot. The result is a lot of assignments of the form `dest = {move} src;` in MIR.\n+//! MIR building for constants in particular tends to create additional locals that are only used\n+//! inside a single block to shuffle a value around unnecessarily.\n+//!\n+//! LLVM by itself is not good enough at eliminating these redundant copies (eg. see\n+//! https://github.com/rust-lang/rust/issues/32966), so this leaves some performance on the table\n+//! that we can regain by implementing an optimization for removing these assign statements in rustc\n+//! itself. When this optimization runs fast enough, it can also speed up the constant evaluation\n+//! and code generation phases of rustc due to the reduced number of statements and locals.\n+//!\n+//! # The Optimization\n+//!\n+//! Conceptually, this optimization is \"destination propagation\". It is similar to the Named Return\n+//! Value Optimization, or NRVO, known from the C++ world, except that it isn't limited to return\n+//! values or the return place `_0`. On a very high level, independent of the actual implementation\n+//! details, it does the following:\n+//!\n+//! 1) Identify `dest = src;` statements that can be soundly eliminated.\n+//! 2) Replace all mentions of `src` with `dest` (\"unifying\" them and propagating the destination\n+//!    backwards).\n+//! 3) Delete the `dest = src;` statement (by making it a `nop`).\n+//!\n+//! Step 1) is by far the hardest, so it is explained in more detail below.\n+//!\n+//! ## Soundness\n+//!\n+//! Given an `Assign` statement `dest = src;`, where `dest` is a `Place` and `src` is an `Rvalue`,\n+//! there are a few requirements that must hold for the optimization to be sound:\n+//!\n+//! * `dest` must not contain any *indirection* through a pointer. It must access part of the base\n+//!   local. Otherwise it might point to arbitrary memory that is hard to track.\n+//!\n+//!   It must also not contain any indexing projections, since those take an arbitrary `Local` as\n+//!   the index, and that local might only be initialized shortly before `dest` is used.\n+//!\n+//!   Subtle case: If `dest` is a, or projects through a union, then we have to make sure that there\n+//!   remains an assignment to it, since that sets the \"active field\" of the union. But if `src` is\n+//!   a ZST, it might not be initialized, so there might not be any use of it before the assignment,\n+//!   and performing the optimization would simply delete the assignment, leaving `dest`\n+//!   uninitialized.\n+//!\n+//! * `src` must be a bare `Local` without any indirections or field projections (FIXME: Why?).\n+//!   It can be copied or moved by the assignment.\n+//!\n+//! * The `dest` and `src` locals must never be [*live*][liveness] at the same time. If they are, it\n+//!   means that they both hold a (potentially different) value that is needed by a future use of\n+//!   the locals. Unifying them would overwrite one of the values.\n+//!\n+//!   Note that computing liveness of locals that have had their address taken is more difficult:\n+//!   Short of doing full escape analysis on the address/pointer/reference, the pass would need to\n+//!   assume that any operation that can potentially involve opaque user code (such as function\n+//!   calls, destructors, and inline assembly) may access any local that had its address taken\n+//!   before that point.\n+//!\n+//! Here, the first two conditions are simple structural requirements on the `Assign` statements\n+//! that can be trivially checked. The liveness requirement however is more difficult and costly to\n+//! check.\n+//!\n+//! ## Previous Work\n+//!\n+//! A [previous attempt] at implementing an optimization like this turned out to be a significant\n+//! regression in compiler performance. Fixing the regressions introduced a lot of undesirable\n+//! complexity to the implementation.\n+//!\n+//! A [subsequent approach] tried to avoid the costly computation by limiting itself to acyclic\n+//! CFGs, but still turned out to be far too costly to run due to suboptimal performance within\n+//! individual basic blocks, requiring a walk across the entire block for every assignment found\n+//! within the block. For the `tuple-stress` benchmark, which has 458745 statements in a single\n+//! block, this proved to be far too costly.\n+//!\n+//! Since the first attempt at this, the compiler has improved dramatically, and new analysis\n+//! frameworks have been added that should make this approach viable without requiring a limited\n+//! approach that only works for some classes of CFGs:\n+//! - rustc now has a powerful dataflow analysis framework that can handle forwards and backwards\n+//!   analyses efficiently.\n+//! - Layout optimizations for generators have been added to improve code generation for\n+//!   async/await, which are very similar in spirit to what this optimization does. Both walk the\n+//!   MIR and record conflicting uses of locals in a `BitMatrix`.\n+//!\n+//! Also, rustc now has a simple NRVO pass (see `nrvo.rs`), which handles a subset of the cases that\n+//! this destination propagation pass handles, proving that similar optimizations can be performed\n+//! on MIR.\n+//!\n+//! ## Pre/Post Optimization\n+//!\n+//! It is recommended to run `SimplifyCfg` and then `SimplifyLocals` some time after this pass, as\n+//! it replaces the eliminated assign statements with `nop`s and leaves unused locals behind.\n+//!\n+//! [liveness]: https://en.wikipedia.org/wiki/Live_variable_analysis\n+//! [previous attempt]: https://github.com/rust-lang/rust/pull/47954\n+//! [subsequent approach]: https://github.com/rust-lang/rust/pull/71003\n+\n+use crate::dataflow::{self, Analysis};\n+use crate::{\n+    transform::{MirPass, MirSource},\n+    util::{dump_mir, PassWhere},\n+};\n+use dataflow::{\n+    impls::{MaybeInitializedLocals, MaybeLiveLocals},\n+    ResultsCursor,\n+};\n+use rustc_data_structures::unify::{InPlaceUnificationTable, UnifyKey};\n+use rustc_index::{\n+    bit_set::{BitMatrix, BitSet},\n+    vec::IndexVec,\n+};\n+use rustc_middle::mir::tcx::PlaceTy;\n+use rustc_middle::mir::visit::{MutVisitor, PlaceContext, Visitor};\n+use rustc_middle::mir::{\n+    traversal, Body, Local, LocalKind, Location, Operand, Place, PlaceElem, Rvalue, Statement,\n+    StatementKind, Terminator, TerminatorKind,\n+};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+\n+pub struct DestinationPropagation;\n+\n+impl<'tcx> MirPass<'tcx> for DestinationPropagation {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        // Only run at mir-opt-level=2 or higher for now (we don't fix up debuginfo and remove\n+        // storage statements at the moment).\n+        if tcx.sess.opts.debugging_opts.mir_opt_level <= 1 {\n+            return;\n+        }\n+\n+        let mut conflicts = Conflicts::build(tcx, body, source);\n+        let mut replacements = Replacements::new(body.local_decls.len());\n+        for candidate @ CandidateAssignment { dest, src, loc } in find_candidates(tcx, body) {\n+            // Merge locals that don't conflict.\n+            if conflicts.contains(dest.local, src) {\n+                debug!(\"at assignment {:?}, conflict {:?} vs. {:?}\", loc, dest.local, src);\n+                continue;\n+            }\n+\n+            if !tcx.consider_optimizing(|| {\n+                format!(\"DestinationPropagation {:?} {:?}\", source.def_id(), candidate)\n+            }) {\n+                break;\n+            }\n+\n+            if replacements.push(candidate).is_ok() {\n+                conflicts.unify(candidate.src, candidate.dest.local);\n+            }\n+        }\n+\n+        replacements.flatten(tcx);\n+\n+        debug!(\"replacements {:?}\", replacements.map);\n+\n+        Replacer { tcx, replacements, place_elem_cache: Vec::new() }.visit_body(body);\n+\n+        // FIXME fix debug info\n+    }\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Copy, Clone)]\n+struct UnifyLocal(Local);\n+\n+impl From<Local> for UnifyLocal {\n+    fn from(l: Local) -> Self {\n+        Self(l)\n+    }\n+}\n+\n+impl UnifyKey for UnifyLocal {\n+    type Value = ();\n+    fn index(&self) -> u32 {\n+        self.0.as_u32()\n+    }\n+    fn from_index(u: u32) -> Self {\n+        Self(Local::from_u32(u))\n+    }\n+    fn tag() -> &'static str {\n+        \"UnifyLocal\"\n+    }\n+}\n+\n+struct Replacements<'tcx> {\n+    /// Maps locals to their replacement.\n+    map: IndexVec<Local, Option<Place<'tcx>>>,\n+\n+    /// Whose locals' live ranges to kill.\n+    kill: BitSet<Local>,\n+\n+    /// Tracks locals that have already been merged together to prevent cycles.\n+    unified_locals: InPlaceUnificationTable<UnifyLocal>,\n+}\n+\n+impl Replacements<'tcx> {\n+    fn new(locals: usize) -> Self {\n+        Self {\n+            map: IndexVec::from_elem_n(None, locals),\n+            kill: BitSet::new_empty(locals),\n+            unified_locals: {\n+                let mut table = InPlaceUnificationTable::new();\n+                for local in 0..locals {\n+                    assert_eq!(table.new_key(()), UnifyLocal(Local::from_usize(local)));\n+                }\n+                table\n+            },\n+        }\n+    }\n+\n+    fn push(&mut self, candidate: CandidateAssignment<'tcx>) -> Result<(), ()> {\n+        if self.unified_locals.unioned(candidate.src, candidate.dest.local) {\n+            // Candidate conflicts with previous replacement (ie. could possibly form a cycle and\n+            // hang).\n+\n+            let replacement = self.map[candidate.src].as_mut().unwrap();\n+\n+            // If the current replacement is for the same `dest` local, there are 2 or more\n+            // equivalent `src = dest;` assignments. This is fine, the replacer will `nop` out all\n+            // of them.\n+            if replacement.local == candidate.dest.local {\n+                assert_eq!(replacement.projection, candidate.dest.projection);\n+            }\n+\n+            // We still return `Err` in any case, as `src` and `dest` do not need to be unified\n+            // *again*.\n+            return Err(());\n+        }\n+\n+        let entry = &mut self.map[candidate.src];\n+        if entry.is_some() {\n+            // We're already replacing `src` with something else, so this candidate is out.\n+            return Err(());\n+        }\n+\n+        self.unified_locals.union(candidate.src, candidate.dest.local);\n+\n+        *entry = Some(candidate.dest);\n+        self.kill.insert(candidate.src);\n+        self.kill.insert(candidate.dest.local);\n+\n+        Ok(())\n+    }\n+\n+    /// Applies the stored replacements to all replacements, until no replacements would result in\n+    /// locals that need further replacements when applied.\n+    fn flatten(&mut self, tcx: TyCtxt<'tcx>) {\n+        // Note: This assumes that there are no cycles in the replacements, which is enforced via\n+        // `self.unified_locals`. Otherwise this can cause an infinite loop.\n+\n+        for local in self.map.indices() {\n+            if let Some(replacement) = self.map[local] {\n+                // Substitute the base local of `replacement` until fixpoint.\n+                let mut base = replacement.local;\n+                let mut reversed_projection_slices = Vec::with_capacity(1);\n+                while let Some(replacement_for_replacement) = self.map[base] {\n+                    base = replacement_for_replacement.local;\n+                    reversed_projection_slices.push(replacement_for_replacement.projection);\n+                }\n+\n+                let projection: Vec<_> = reversed_projection_slices\n+                    .iter()\n+                    .rev()\n+                    .flat_map(|projs| projs.iter())\n+                    .chain(replacement.projection.iter())\n+                    .collect();\n+                let projection = tcx.intern_place_elems(&projection);\n+\n+                // Replace with the final `Place`.\n+                self.map[local] = Some(Place { local: base, projection });\n+            }\n+        }\n+    }\n+\n+    fn for_src(&self, src: Local) -> Option<&Place<'tcx>> {\n+        self.map[src].as_ref()\n+    }\n+}\n+\n+struct Replacer<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    replacements: Replacements<'tcx>,\n+    place_elem_cache: Vec<PlaceElem<'tcx>>,\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for Replacer<'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn visit_local(&mut self, local: &mut Local, context: PlaceContext, location: Location) {\n+        if context.is_use() && self.replacements.for_src(*local).is_some() {\n+            bug!(\n+                \"use of local {:?} should have been replaced by visit_place; context={:?}, loc={:?}\",\n+                local,\n+                context,\n+                location,\n+            );\n+        }\n+    }\n+\n+    fn process_projection_elem(\n+        &mut self,\n+        elem: PlaceElem<'tcx>,\n+        _: Location,\n+    ) -> Option<PlaceElem<'tcx>> {\n+        match elem {\n+            PlaceElem::Index(local) => {\n+                if let Some(replacement) = self.replacements.for_src(local) {\n+                    bug!(\n+                        \"cannot replace {:?} with {:?} in index projection {:?}\",\n+                        local,\n+                        replacement,\n+                        elem,\n+                    );\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n+        if let Some(replacement) = self.replacements.for_src(place.local) {\n+            // Rebase `place`s projections onto `replacement`'s.\n+            self.place_elem_cache.clear();\n+            self.place_elem_cache.extend(replacement.projection.iter().chain(place.projection));\n+            let projection = self.tcx.intern_place_elems(&self.place_elem_cache);\n+            let new_place = Place { local: replacement.local, projection };\n+\n+            debug!(\"Replacer: {:?} -> {:?}\", place, new_place);\n+            *place = new_place;\n+        }\n+\n+        self.super_place(place, context, location);\n+    }\n+\n+    fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n+        self.super_statement(statement, location);\n+\n+        match &statement.kind {\n+            // FIXME: Don't delete storage statements, merge the live ranges instead\n+            StatementKind::StorageDead(local) | StatementKind::StorageLive(local)\n+                if self.replacements.kill.contains(*local) =>\n+            {\n+                statement.make_nop()\n+            }\n+\n+            StatementKind::Assign(box (dest, rvalue)) => {\n+                match rvalue {\n+                    Rvalue::Use(Operand::Copy(place) | Operand::Move(place)) => {\n+                        // These might've been turned into self-assignments by the replacement\n+                        // (this includes the original statement we wanted to eliminate).\n+                        if dest == place {\n+                            debug!(\"{:?} turned into self-assignment, deleting\", location);\n+                            statement.make_nop();\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+    }\n+}\n+\n+struct Conflicts {\n+    /// The conflict matrix. It is always symmetric and the adjacency matrix of the corresponding\n+    /// conflict graph.\n+    matrix: BitMatrix<Local, Local>,\n+\n+    /// Preallocated `BitSet` used by `unify`.\n+    unify_cache: BitSet<Local>,\n+}\n+\n+impl Conflicts {\n+    fn build<'tcx>(tcx: TyCtxt<'tcx>, body: &'_ Body<'tcx>, source: MirSource<'tcx>) -> Self {\n+        // We don't have to look out for locals that have their address taken, since `find_candidates`\n+        // already takes care of that.\n+\n+        let mut conflicts = BitMatrix::from_row_n(\n+            &BitSet::new_empty(body.local_decls.len()),\n+            body.local_decls.len(),\n+        );\n+\n+        let mut record_conflicts =\n+            |init: &ResultsCursor<'_, '_, MaybeInitializedLocals>,\n+             live: &ResultsCursor<'_, '_, MaybeLiveLocals>| {\n+                let mut requires_storage = init.get().clone();\n+                requires_storage.intersect(live.get());\n+\n+                for local in requires_storage.iter() {\n+                    conflicts.union_row_with(&requires_storage, local);\n+                }\n+            };\n+\n+        let def_id = source.def_id();\n+        let mut init = MaybeInitializedLocals\n+            .into_engine(tcx, body, def_id)\n+            .iterate_to_fixpoint()\n+            .into_results_cursor(body);\n+        let mut live = MaybeLiveLocals\n+            .into_engine(tcx, body, def_id)\n+            .iterate_to_fixpoint()\n+            .into_results_cursor(body);\n+\n+        dump_mir(\n+            tcx,\n+            None,\n+            \"DestinationPropagation-dataflow\",\n+            &\"\",\n+            source,\n+            body,\n+            |pass_where, w| {\n+                match pass_where {\n+                    PassWhere::BeforeLocation(loc) => {\n+                        init.seek_before_primary_effect(loc);\n+                        live.seek_after_primary_effect(loc);\n+\n+                        writeln!(w, \"        // init: {:?}\", init.get())?;\n+                        writeln!(w, \"        // live: {:?}\", live.get())?;\n+                    }\n+                    PassWhere::AfterTerminator(bb) => {\n+                        let loc = body.terminator_loc(bb);\n+                        init.seek_after_primary_effect(loc);\n+                        live.seek_before_primary_effect(loc);\n+\n+                        writeln!(w, \"        // init: {:?}\", init.get())?;\n+                        writeln!(w, \"        // live: {:?}\", live.get())?;\n+                    }\n+\n+                    PassWhere::BeforeBlock(bb) => {\n+                        init.seek_to_block_start(bb);\n+                        live.seek_to_block_start(bb);\n+\n+                        writeln!(w, \"    // init: {:?}\", init.get())?;\n+                        writeln!(w, \"    // live: {:?}\", live.get())?;\n+                    }\n+\n+                    PassWhere::BeforeCFG | PassWhere::AfterCFG | PassWhere::AfterLocation(_) => {}\n+                }\n+\n+                Ok(())\n+            },\n+        );\n+\n+        // Visit only reachable basic blocks. The exact order is not important.\n+        for (block, data) in traversal::preorder(body) {\n+            // Observe the dataflow state *before* all possible locations (statement or terminator) in\n+            // each basic block...\n+            for statement_index in 0..=data.statements.len() {\n+                let loc = Location { block, statement_index };\n+                trace!(\"record conflicts at {:?}\", loc);\n+                init.seek_before_primary_effect(loc);\n+                live.seek_after_primary_effect(loc);\n+                // FIXME: liveness is backwards, so this is slow\n+\n+                record_conflicts(&init, &live);\n+            }\n+\n+            // ...and then observe the state *after* the terminator effect is applied. As long as\n+            // neither `init` nor `borrowed` has a \"before\" effect, we will observe all possible\n+            // dataflow states here or in the loop above.\n+            trace!(\"record conflicts at end of {:?}\", block);\n+            init.seek_to_block_end(block);\n+            live.seek_to_block_end(block);\n+            record_conflicts(&init, &live);\n+        }\n+\n+        Self { matrix: conflicts, unify_cache: BitSet::new_empty(body.local_decls.len()) }\n+    }\n+\n+    fn contains(&self, a: Local, b: Local) -> bool {\n+        self.matrix.contains(a, b)\n+    }\n+\n+    /// Merges the conflicts of `a` and `b`, so that each one inherits all conflicts of the other.\n+    ///\n+    /// This is called when the pass makes the decision to unify `a` and `b` (or parts of `a` and\n+    /// `b`) and is needed to ensure that future unification decisions take potentially newly\n+    /// introduced conflicts into account.\n+    ///\n+    /// For an example, assume we have locals `_0`, `_1`, `_2`, and `_3`. There are these conflicts:\n+    ///\n+    /// * `_0` <-> `_1`\n+    /// * `_1` <-> `_2`\n+    /// * `_3` <-> `_0`\n+    ///\n+    /// We then decide to merge `_2` with `_3` since they don't conflict. Then we decide to merge\n+    /// `_2` with `_0`, which also doesn't have a conflict in the above list. However `_2` is now\n+    /// `_3`, which does conflict with `_0`.\n+    fn unify(&mut self, a: Local, b: Local) {\n+        // FIXME: This might be somewhat slow. Conflict graphs are undirected, maybe we can use\n+        // something with union-find to speed this up?\n+\n+        // Make all locals that conflict with `a` also conflict with `b`, and vice versa.\n+        self.unify_cache.clear();\n+        for conflicts_with_a in self.matrix.iter(a) {\n+            self.unify_cache.insert(conflicts_with_a);\n+        }\n+        for conflicts_with_b in self.matrix.iter(b) {\n+            self.unify_cache.insert(conflicts_with_b);\n+        }\n+        for conflicts_with_a_or_b in self.unify_cache.iter() {\n+            // Set both `a` and `b` for this local's row.\n+            self.matrix.insert(conflicts_with_a_or_b, a);\n+            self.matrix.insert(conflicts_with_a_or_b, b);\n+        }\n+\n+        // Write the locals `a` conflicts with to `b`'s row.\n+        self.matrix.union_rows(a, b);\n+        // Write the locals `b` conflicts with to `a`'s row.\n+        self.matrix.union_rows(b, a);\n+    }\n+}\n+\n+/// A `dest = {move} src;` statement at `loc`.\n+///\n+/// We want to consider merging `dest` and `src` due to this assignment.\n+#[derive(Debug, Copy, Clone)]\n+struct CandidateAssignment<'tcx> {\n+    /// Does not contain indirection or indexing (so the only local it contains is the place base).\n+    dest: Place<'tcx>,\n+    src: Local,\n+    loc: Location,\n+}\n+\n+/// Scans the MIR for assignments between locals that we might want to consider merging.\n+///\n+/// This will filter out assignments that do not match the right form (as described in the top-level\n+/// comment) and also throw out assignments that involve a local that has its address taken or is\n+/// otherwise ineligible (eg. locals used as array indices are ignored because we cannot propagate\n+/// arbitrary places into array indices).\n+fn find_candidates<'a, 'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &'a Body<'tcx>,\n+) -> Vec<CandidateAssignment<'tcx>> {\n+    struct FindAssignments<'a, 'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        body: &'a Body<'tcx>,\n+        candidates: Vec<CandidateAssignment<'tcx>>,\n+        ever_borrowed_locals: BitSet<Local>,\n+        locals_used_as_array_index: BitSet<Local>,\n+    }\n+\n+    impl<'a, 'tcx> Visitor<'tcx> for FindAssignments<'a, 'tcx> {\n+        fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n+            if let StatementKind::Assign(box (\n+                dest,\n+                Rvalue::Use(Operand::Copy(src) | Operand::Move(src)),\n+            )) = &statement.kind\n+            {\n+                // `dest` must not have pointer indirection.\n+                if dest.is_indirect() {\n+                    return;\n+                }\n+\n+                // `src` must be a plain local.\n+                if !src.projection.is_empty() {\n+                    return;\n+                }\n+\n+                // Since we want to replace `src` with `dest`, `src` must not be required.\n+                if is_local_required(src.local, self.body) {\n+                    return;\n+                }\n+\n+                // Can't optimize if both locals ever have their address taken (can introduce\n+                // aliasing).\n+                // FIXME: This can be smarter and take `StorageDead` into account (which\n+                // invalidates borrows).\n+                if self.ever_borrowed_locals.contains(dest.local)\n+                    && self.ever_borrowed_locals.contains(src.local)\n+                {\n+                    return;\n+                }\n+\n+                assert_ne!(dest.local, src.local, \"self-assignments are UB\");\n+\n+                // We can't replace locals occurring in `PlaceElem::Index` for now.\n+                if self.locals_used_as_array_index.contains(src.local) {\n+                    return;\n+                }\n+\n+                // Handle the \"subtle case\" described above by rejecting any `dest` that is or\n+                // projects through a union.\n+                let is_union = |ty: Ty<'_>| {\n+                    if let ty::Adt(def, _) = ty.kind() {\n+                        if def.is_union() {\n+                            return true;\n+                        }\n+                    }\n+\n+                    false\n+                };\n+                let mut place_ty = PlaceTy::from_ty(self.body.local_decls[dest.local].ty);\n+                if is_union(place_ty.ty) {\n+                    return;\n+                }\n+                for elem in dest.projection {\n+                    if let PlaceElem::Index(_) = elem {\n+                        // `dest` contains an indexing projection.\n+                        return;\n+                    }\n+\n+                    place_ty = place_ty.projection_ty(self.tcx, elem);\n+                    if is_union(place_ty.ty) {\n+                        return;\n+                    }\n+                }\n+\n+                self.candidates.push(CandidateAssignment {\n+                    dest: *dest,\n+                    src: src.local,\n+                    loc: location,\n+                });\n+            }\n+        }\n+    }\n+\n+    let mut visitor = FindAssignments {\n+        tcx,\n+        body,\n+        candidates: Vec::new(),\n+        ever_borrowed_locals: ever_borrowed_locals(body),\n+        locals_used_as_array_index: locals_used_as_array_index(body),\n+    };\n+    visitor.visit_body(body);\n+    visitor.candidates\n+}\n+\n+/// Some locals are part of the function's interface and can not be removed.\n+///\n+/// Note that these locals *can* still be merged with non-required locals by removing that other\n+/// local.\n+fn is_local_required(local: Local, body: &Body<'_>) -> bool {\n+    match body.local_kind(local) {\n+        LocalKind::Arg | LocalKind::ReturnPointer => true,\n+        LocalKind::Var | LocalKind::Temp => false,\n+    }\n+}\n+\n+/// Walks MIR to find all locals that have their address taken anywhere.\n+fn ever_borrowed_locals(body: &Body<'_>) -> BitSet<Local> {\n+    struct BorrowCollector {\n+        locals: BitSet<Local>,\n+    }\n+\n+    impl<'tcx> Visitor<'tcx> for BorrowCollector {\n+        fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+            self.super_rvalue(rvalue, location);\n+\n+            match rvalue {\n+                Rvalue::AddressOf(_, borrowed_place) | Rvalue::Ref(_, _, borrowed_place) => {\n+                    if !borrowed_place.is_indirect() {\n+                        self.locals.insert(borrowed_place.local);\n+                    }\n+                }\n+\n+                Rvalue::Cast(..)\n+                | Rvalue::Use(..)\n+                | Rvalue::Repeat(..)\n+                | Rvalue::Len(..)\n+                | Rvalue::BinaryOp(..)\n+                | Rvalue::CheckedBinaryOp(..)\n+                | Rvalue::NullaryOp(..)\n+                | Rvalue::UnaryOp(..)\n+                | Rvalue::Discriminant(..)\n+                | Rvalue::Aggregate(..)\n+                | Rvalue::ThreadLocalRef(..) => {}\n+            }\n+        }\n+\n+        fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+            self.super_terminator(terminator, location);\n+\n+            match terminator.kind {\n+                TerminatorKind::Drop { place: dropped_place, .. }\n+                | TerminatorKind::DropAndReplace { place: dropped_place, .. } => {\n+                    self.locals.insert(dropped_place.local);\n+                }\n+\n+                TerminatorKind::Abort\n+                | TerminatorKind::Assert { .. }\n+                | TerminatorKind::Call { .. }\n+                | TerminatorKind::FalseEdge { .. }\n+                | TerminatorKind::FalseUnwind { .. }\n+                | TerminatorKind::GeneratorDrop\n+                | TerminatorKind::Goto { .. }\n+                | TerminatorKind::Resume\n+                | TerminatorKind::Return\n+                | TerminatorKind::SwitchInt { .. }\n+                | TerminatorKind::Unreachable\n+                | TerminatorKind::Yield { .. }\n+                | TerminatorKind::InlineAsm { .. } => {}\n+            }\n+        }\n+    }\n+\n+    let mut visitor = BorrowCollector { locals: BitSet::new_empty(body.local_decls.len()) };\n+    visitor.visit_body(body);\n+    visitor.locals\n+}\n+\n+/// `PlaceElem::Index` only stores a `Local`, so we can't replace that with a full `Place`.\n+///\n+/// Collect locals used as indices so we don't generate candidates that are impossible to apply\n+/// later.\n+fn locals_used_as_array_index(body: &Body<'_>) -> BitSet<Local> {\n+    struct IndexCollector {\n+        locals: BitSet<Local>,\n+    }\n+\n+    impl<'tcx> Visitor<'tcx> for IndexCollector {\n+        fn visit_projection_elem(\n+            &mut self,\n+            local: Local,\n+            proj_base: &[PlaceElem<'tcx>],\n+            elem: PlaceElem<'tcx>,\n+            context: PlaceContext,\n+            location: Location,\n+        ) {\n+            if let PlaceElem::Index(i) = elem {\n+                self.locals.insert(i);\n+            }\n+            self.super_projection_elem(local, proj_base, elem, context, location);\n+        }\n+    }\n+\n+    let mut visitor = IndexCollector { locals: BitSet::new_empty(body.local_decls.len()) };\n+    visitor.visit_body(body);\n+    visitor.locals\n+}"}, {"sha": "fc9854ba499f839ab51a7b509e956977eb80e262", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78ff69ba1086decb205b988f05aba7711dddb221/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff69ba1086decb205b988f05aba7711dddb221/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=78ff69ba1086decb205b988f05aba7711dddb221", "patch": "@@ -24,6 +24,7 @@ pub mod cleanup_post_borrowck;\n pub mod const_prop;\n pub mod copy_prop;\n pub mod deaggregator;\n+pub mod dest_prop;\n pub mod dump_mir;\n pub mod elaborate_drops;\n pub mod generator;\n@@ -467,6 +468,7 @@ fn run_optimization_passes<'tcx>(\n         &simplify_comparison_integral::SimplifyComparisonIntegral,\n         &simplify_try::SimplifyArmIdentity,\n         &simplify_try::SimplifyBranchSame,\n+        &dest_prop::DestinationPropagation,\n         &copy_prop::CopyPropagation,\n         &simplify_branches::SimplifyBranches::new(\"after-copy-prop\"),\n         &remove_noop_landing_pads::RemoveNoopLandingPads,"}, {"sha": "1ffb5a87c4762f2b00a77e483e7e51dc139950bd", "filename": "compiler/rustc_mir/src/transform/nrvo.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78ff69ba1086decb205b988f05aba7711dddb221/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fnrvo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78ff69ba1086decb205b988f05aba7711dddb221/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fnrvo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fnrvo.rs?ref=78ff69ba1086decb205b988f05aba7711dddb221", "patch": "@@ -36,6 +36,12 @@ impl<'tcx> MirPass<'tcx> for RenameReturnPlace {\n             return;\n         }\n \n+        if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n+            // The `DestinationPropagation` pass runs at level 2, so this pass is redundant (and\n+            // fails some asserts).\n+            return;\n+        }\n+\n         let returned_local = match local_eligible_for_nrvo(body) {\n             Some(l) => l,\n             None => {"}]}