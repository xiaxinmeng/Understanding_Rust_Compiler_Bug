{"sha": "6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlMmE3YmZmN2ZhZjA0MGIxZWNlZDBlZTM1NDdiMjhmNjk2MmNlZGM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-27T12:48:34Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-27T13:54:33Z"}, "message": "Fix damage done by the pretty-printer", "tree": {"sha": "bd05a425b4ad236d7e861ffdf0931bf71ad3bba9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd05a425b4ad236d7e861ffdf0931bf71ad3bba9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "html_url": "https://github.com/rust-lang/rust/commit/6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df7f21db093b0f206048b18e977161f91b7c28f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/df7f21db093b0f206048b18e977161f91b7c28f1", "html_url": "https://github.com/rust-lang/rust/commit/df7f21db093b0f206048b18e977161f91b7c28f1"}], "stats": {"total": 1091, "additions": 678, "deletions": 413}, "files": [{"sha": "7a933aa20f8a575104505715237a96d086e9c0d9", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -340,10 +340,8 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n         ret alt metas.name {\n               some(v) { v }\n               none. {\n-                let \n-                    // FIXME: Remove this vec->ivec conversion.\n-\n-                    name =\n+                // FIXME: Remove this vec->ivec conversion.\n+                let name =\n                     {\n                         let os_vec =\n                             str::split(fs::basename(output), '.' as u8);"}, {"sha": "3dacbd3b9d0b46e9351c72bf675ce9a8b29102e6", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -65,9 +65,8 @@ fn build_configuration(sess: session::session, argv0: str, input: str) ->\n     // some default and generated configuration items\n     let default_cfg = default_configuration(sess, argv0, input);\n     let user_cfg = sess.get_opts().cfg;\n-    let \n-        // If the user wants a test runner, then add the test cfg\n-        gen_cfg =\n+    // If the user wants a test runner, then add the test cfg\n+    let gen_cfg =\n         {\n             if sess.get_opts().test && !attr::contains_name(user_cfg, \"test\")\n                {"}, {"sha": "e1e580f191eca22c484ba51101ba286b3a7d109a", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -101,9 +101,7 @@ fn in_cfg(cfg: &ast::crate_cfg, attrs: &ast::attribute[]) -> bool {\n     // Pull the inner meta_items from the #[cfg(meta_item, ...)]  attributes,\n     // so we can match against them. This is the list of configurations for\n     // which the item is valid\n-    let \n-\n-        item_cfg_metas =\n+    let item_cfg_metas =\n         {\n             fn extract_metas(inner_items: &(@ast::meta_item)[],\n                              cfg_item: &@ast::meta_item) ->"}, {"sha": "76e234cae9a862e678f10fd5902d922b4d9221ad", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1395,11 +1395,10 @@ obj builder(B: BuilderRef, terminated: @mutable bool) {\n \n     fn is_terminated() -> bool {\n         ret *terminated;\n-    }drop \n-\n-          {\n+    }\n+    drop {\n          llvm::LLVMDisposeBuilder(B);\n-     }\n+    }\n }\n \n /* Memory-managed object interface to type handles. */"}, {"sha": "b0fa97f7ea9ee600b29cd1c59cfa53d84c9a92db", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -122,22 +122,20 @@ fn find_library_crate(sess: &session::session, ident: &ast::ident,\n \n     attr::require_unique_names(sess, metas);\n \n-    let \n-        // FIXME: Probably want a warning here since the user\n-        // is using the wrong type of meta item\n-        crate_name =\n-        {\n-            let name_items = attr::find_meta_items_by_name(metas, \"name\");\n-            alt ivec::last(name_items) {\n-              some(i) {\n-                alt attr::get_meta_item_value_str(i) {\n-                  some(n) { n }\n-                  _ { ident }\n-                }\n-              }\n-              none. { ident }\n+    // FIXME: Probably want a warning here since the user\n+    // is using the wrong type of meta item\n+    let crate_name = {\n+        let name_items = attr::find_meta_items_by_name(metas, \"name\");\n+        alt ivec::last(name_items) {\n+          some(i) {\n+            alt attr::get_meta_item_value_str(i) {\n+              some(n) { n }\n+              _ { ident }\n             }\n-        };\n+          }\n+          none. { ident }\n+        }\n+    };\n \n     let nn = default_native_lib_naming(sess, sess.get_opts().static);\n     let x ="}, {"sha": "ab9c07981b9146642c35d9d6b3825c9c18b279dc", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -164,9 +164,8 @@ fn lookup_def(cnum: ast::crate_num, data: @u8[], did_: &ast::def_id) ->\n     let item = lookup_item(did_.node, data);\n     let kind_ch = item_kind(item);\n     let did = {crate: cnum, node: did_.node};\n-    let \n-        // We treat references to tags as references to types.\n-        def =\n+    // We treat references to tags as references to types.\n+    let def =\n         alt kind_ch as char {\n           'c' { ast::def_const(did) }\n           'f' { ast::def_fn(did, ast::impure_fn) }"}, {"sha": "ee56a3958bc8e734b4c315632e6622ffc7817f71", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -39,10 +39,9 @@ tag local_info { arg(ast::mode); objfield(ast::mutability); }\n type ctx = {tcx: ty::ctxt, local_map: std::map::hashmap[node_id, local_info]};\n \n fn check_crate(tcx: ty::ctxt, crate: &@ast::crate) {\n-    let \n-        // Stores information about object fields and function\n-        // arguments that's otherwise not easily available.\n-        cx =\n+    // Stores information about object fields and function\n+    // arguments that's otherwise not easily available.\n+    let cx =\n         @{tcx: tcx, local_map: std::map::new_int_hash()};\n     let v =\n         @{visit_fn: bind visit_fn(cx, _, _, _, _, _, _, _),"}, {"sha": "c49d0ff28346797288e3faa3d865105be2a65621", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -73,12 +73,12 @@ fn collect_freevars(def_map: &resolve::def_map, sess: &session::session,\n \n     let e: env =\n         @{mutable refs: ~[], decls: decls, def_map: def_map, sess: sess};\n-    walker(visit::mk_simple_visitor(@{visit_local: bind walk_local(e, _),\n-                                      visit_pat: bind walk_pat(e, _),\n-                                      visit_expr: bind walk_expr(e, _),\n-                                      visit_fn: bind walk_fn(e, _, _, _, _, _)\n-                                         with\n-                                             *visit::default_simple_visitor()}));\n+    walker(visit::mk_simple_visitor\n+           (@{visit_local: bind walk_local(e, _),\n+              visit_pat: bind walk_pat(e, _),\n+              visit_expr: bind walk_expr(e, _),\n+              visit_fn: bind walk_fn(e, _, _, _, _, _)\n+              with *visit::default_simple_visitor()}));\n \n     // Calculate (refs - decls). This is the set of captured upvars.\n     // We build a vec of the node ids of the uses and a set of the"}, {"sha": "c690889dd36efdd86cf6319f5ed959d700bbfcee", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 40, "deletions": 47, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -830,10 +830,9 @@ fn trans_malloc_boxed(cx: &@block_ctxt, t: ty::t) -> result {\n     // size of; box_ptr is the type that's converted to a TypeRef and used as\n     // the pointer cast target in trans_raw_malloc.\n \n-    let \n-        // The mk_int here is the space being\n-        // reserved for the refcount.\n-        boxed_body =\n+    // The mk_int here is the space being\n+    // reserved for the refcount.\n+    let boxed_body =\n         ty::mk_imm_tup(bcx_tcx(cx), ~[ty::mk_int(bcx_tcx(cx)), t]);\n     let box_ptr = ty::mk_imm_box(bcx_tcx(cx), t);\n     let sz = size_of(cx, boxed_body);\n@@ -1243,21 +1242,20 @@ fn incr_refcnt_of_boxed(cx: &@block_ctxt, box_ptr: ValueRef) -> result {\n fn make_free_glue(cx: &@block_ctxt, v0: ValueRef, t: &ty::t) {\n     // NB: v is an *alias* of type t here, not a direct value.\n \n-    let \n-        // FIXME: switch gc/non-gc on layer of the type.\n-        // FIXME: switch gc/non-gc on layer of the type.\n-        // TODO: call upcall_kill\n+    // FIXME: switch gc/non-gc on layer of the type.\n+    // FIXME: switch gc/non-gc on layer of the type.\n+    // TODO: call upcall_kill\n \n \n-        // Call through the obj's own fields-drop glue first.\n+    // Call through the obj's own fields-drop glue first.\n \n-        // Then free the body.\n-        // FIXME: switch gc/non-gc on layer of the type.\n-        // Call through the closure's own fields-drop glue first.\n+    // Then free the body.\n+    // FIXME: switch gc/non-gc on layer of the type.\n+    // Call through the closure's own fields-drop glue first.\n \n-        // Then free the body.\n-        // FIXME: switch gc/non-gc on layer of the type.\n-        rs =\n+    // Then free the body.\n+    // FIXME: switch gc/non-gc on layer of the type.\n+    let rs =\n         alt ty::struct(bcx_tcx(cx), t) {\n           ty::ty_str. { let v = cx.build.Load(v0); trans_non_gc_free(cx, v) }\n           ty::ty_vec(_) {\n@@ -1361,9 +1359,7 @@ fn maybe_free_ivec_heap_part(cx: &@block_ctxt, v0: ValueRef, unit_ty: ty::t)\n fn make_drop_glue(cx: &@block_ctxt, v0: ValueRef, t: &ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let ccx = bcx_ccx(cx);\n-    let \n-\n-        rs =\n+    let rs =\n         alt ty::struct(ccx.tcx, t) {\n           ty::ty_str. { decr_refcnt_maybe_free(cx, v0, v0, t) }\n           ty::ty_vec(_) { decr_refcnt_maybe_free(cx, v0, v0, t) }\n@@ -1453,7 +1449,9 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: &ast::def_id,\n     // value here, but the dtor expects a type that still has opaque pointers\n     // for type variables.\n     let val_llty =\n-        lib::llvm::fn_ty_param_tys(llvm::LLVMGetElementType(llvm::LLVMTypeOf(dtor_addr))).(std::ivec::len(args));\n+        lib::llvm::fn_ty_param_tys(llvm::LLVMGetElementType\n+                                   (llvm::LLVMTypeOf(dtor_addr)))\n+                                    .(std::ivec::len(args));\n     let val_cast = cx.build.BitCast(val.val, val_llty);\n     cx.build.FastCall(dtor_addr, args + ~[val_cast]);\n \n@@ -3345,9 +3343,8 @@ mod ivec {\n             maybe_on_heap_cx.build.PointerCast(vptr,\n                                                T_ptr(T_ivec_heap(llunitty)));\n         let heap_ptr_ptr =\n-            maybe_on_heap_cx.build.InBoundsGEP(stub_ptr,\n-                                               ~[C_int(0),\n-                                                 C_uint(abi::ivec_heap_stub_elt_ptr)]);\n+            maybe_on_heap_cx.build.InBoundsGEP\n+            (stub_ptr, ~[C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)]);\n         let heap_ptr = maybe_on_heap_cx.build.Load(heap_ptr_ptr);\n         let heap_ptr_is_nonnull =\n             maybe_on_heap_cx.build.ICmp(lib::llvm::LLVMIntNE, heap_ptr,\n@@ -3358,9 +3355,8 @@ mod ivec {\n \n         // Ok, the vector is on the heap. Copy the heap part.\n         let alen_ptr =\n-            on_heap_cx.build.InBoundsGEP(stub_ptr,\n-                                         ~[C_int(0),\n-                                           C_uint(abi::ivec_heap_stub_elt_alen)]);\n+            on_heap_cx.build.InBoundsGEP\n+            (stub_ptr, ~[C_int(0), C_uint(abi::ivec_heap_stub_elt_alen)]);\n         let alen = on_heap_cx.build.Load(alen_ptr);\n \n         let heap_part_sz =\n@@ -3598,17 +3594,15 @@ fn trans_if(cx: &@block_ctxt, cond: &@ast::expr, thn: &ast::blk,\n     let then_cx = new_scope_block_ctxt(cx, \"then\");\n     let then_res = trans_block(then_cx, thn, output);\n     let else_cx = new_scope_block_ctxt(cx, \"else\");\n-    let \n-        // Synthesize a block here to act as the else block\n-        // containing an if expression. Needed in order for the\n-        // else scope to behave like a normal block scope. A tad\n-        // ugly.\n-        // Calling trans_block directly instead of trans_expr\n-        // because trans_expr will create another scope block\n-        // context for the block, but we've already got the\n-        // 'else' context\n-\n-        else_res =\n+    // Synthesize a block here to act as the else block\n+    // containing an if expression. Needed in order for the\n+    // else scope to behave like a normal block scope. A tad\n+    // ugly.\n+    // Calling trans_block directly instead of trans_expr\n+    // because trans_expr will create another scope block\n+    // context for the block, but we've already got the\n+    // 'else' context\n+    let else_res =\n         alt els {\n           some(elexpr) {\n             alt elexpr.node {\n@@ -4908,7 +4902,7 @@ fn trans_call(cx: &@block_ctxt, f: &@ast::expr,\n     let llretslot = args_res.retslot;\n     /*\n     log \"calling: \" + val_str(bcx_ccx(cx).tn, faddr);\n-    \n+\n     for (ValueRef arg in llargs) {\n         log \"arg: \" + val_str(bcx_ccx(cx).tn, arg);\n     }\n@@ -5334,9 +5328,9 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n       }\n       _ {\n         // The expression is an lvalue. Fall through.\n-        assert (ty::is_lval(e)); // make sure it really is and that we\n-                                 // didn't forget to add a case for a new expr!\n-\n+        assert (ty::is_lval(e));\n+        // make sure it really is and that we\n+        // didn't forget to add a case for a new expr!\n       }\n     }\n     // lval cases fall through to trans_lval and then\n@@ -6352,8 +6346,8 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, args: &ast::arg[],\n             alt bcx.fcx.llargs.find(aarg.id) {\n               some(x) { argval = x; }\n               _ {\n-                bcx_ccx(bcx).sess.span_fatal(aarg.ty.span,\n-                                             \"unbound arg ID in copy_args_to_allocas\");\n+                bcx_ccx(bcx).sess.span_fatal\n+                    (aarg.ty.span, \"unbound arg ID in copy_args_to_allocas\");\n               }\n             }\n             bcx.build.Store(argval, a);\n@@ -6374,8 +6368,8 @@ fn add_cleanups_for_args(bcx: &@block_ctxt, args: &ast::arg[],\n             alt bcx.fcx.llargs.find(aarg.id) {\n               some(x) { argval = x; }\n               _ {\n-                bcx_ccx(bcx).sess.span_fatal(aarg.ty.span,\n-                                             \"unbound arg ID in copy_args_to_allocas\");\n+                bcx_ccx(bcx).sess.span_fatal\n+                    (aarg.ty.span, \"unbound arg ID in copy_args_to_allocas\");\n               }\n             }\n             add_clean(bcx, argval, arg_tys.(arg_n).ty);\n@@ -7227,9 +7221,8 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n     let bcx = new_top_block_ctxt(fcx);\n     let lltop = bcx.llbb;\n \n-    let \n-        // Cast the tag to a type we can GEP into.\n-        llblobptr =\n+    // Cast the tag to a type we can GEP into.\n+    let llblobptr =\n         if is_degen {\n             fcx.llretptr\n         } else {"}, {"sha": "ead0bcaf0b63f1809d1dc1d848bba1ccaee8b323", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -294,9 +294,8 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: ValueRef[],\n             if ivec::len(ty::tag_variants(ccx.tcx, vdef.tg)) == 1u {\n                 kind = single;\n             } else {\n-                let tagptr =\n-                    bcx.build.PointerCast(val,\n-                                          trans_common::T_opaque_tag_ptr(ccx.tn));\n+                let tagptr = bcx.build.PointerCast\n+                    (val, trans_common::T_opaque_tag_ptr(ccx.tn));\n                 let discrimptr = bcx.build.GEP(tagptr, ~[C_int(0), C_int(0)]);\n                 test_val = bcx.build.Load(discrimptr);\n                 kind = switch;"}, {"sha": "d125427776a0c90e6b32891bd53f7faa555e9fd9", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -159,9 +159,7 @@ fn relax_precond_block(fcx: &fn_ctxt, i: node_id, b: &blk) {\n     fn quit(keepgoing: @mutable bool, i: &@item) { *keepgoing = false; }\n     fn kg(keepgoing: @mutable bool) -> bool { ret *keepgoing; }\n \n-    let \n-\n-        v =\n+    let v =\n         {visit_block_pre: bind relax_precond_block_non_recursive(fcx, i, _),\n          visit_expr_pre: bind relax_precond_expr(fcx, i, _),\n          visit_stmt_pre: bind relax_precond_stmt(fcx, i, _),"}, {"sha": "d9910d8217dc3f96c066a2c17a04df692962f1d7", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -641,7 +641,7 @@ fn find_pre_post_block(fcx: &fn_ctxt, b: blk) {\n      This will mean that:\n      x = 0;\n      break;\n-    \n+\n      won't have a postcondition that says x is initialized, but that's ok.\n      */\n "}, {"sha": "674e5c9b9cbad42b4d678a1462ac10ba519b20a6", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1987,8 +1987,9 @@ mod unify {\n \n             let result_mode;\n             if expected_input.mode != actual_input.mode {\n-                ret fn_common_res_err(ures_err(terr_mode_mismatch(expected_input.mode,\n-                                                                  actual_input.mode)));\n+                ret fn_common_res_err\n+                    (ures_err(terr_mode_mismatch(expected_input.mode,\n+                                                 actual_input.mode)));\n             } else { result_mode = expected_input.mode; }\n             let result = unify_step(cx, expected_input.ty, actual_input.ty);\n             alt result {\n@@ -2817,10 +2818,10 @@ fn ast_constr_to_constr[T](tcx: ty::ctxt, c: &@ast::constr_general[T]) ->\n                     {path: c.node.path, args: c.node.args, id: pred_id});\n       }\n       _ {\n-        tcx.sess.span_fatal(c.span,\n-                            \"Predicate \" + path_to_str(c.node.path) +\n-                                \" is unbound or bound to a non-function or an \\\n-                        impure function\");\n+        tcx.sess.span_fatal\n+            (c.span, \"Predicate \" + path_to_str(c.node.path) +\n+             \" is unbound or bound to a non-function or an \\\n+              impure function\");\n       }\n     }\n }"}, {"sha": "d567b9d45bc19bfec35123281c51d26e2695bab7", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 37, "deletions": 42, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -164,14 +164,14 @@ fn instantiate_path(fcx: &@fn_ctxt, pth: &ast::path,\n     if ty_substs_len > 0u {\n         let param_var_len = ivec::len(ty_param_vars);\n         if param_var_len == 0u {\n-            fcx.ccx.tcx.sess.span_fatal(sp,\n-                                        \"this item does not take type parameters\");\n+            fcx.ccx.tcx.sess.span_fatal\n+                (sp, \"this item does not take type parameters\");\n         } else if (ty_substs_len > param_var_len) {\n-            fcx.ccx.tcx.sess.span_fatal(sp,\n-                                        \"too many type parameter provided for this item\");\n+            fcx.ccx.tcx.sess.span_fatal\n+                (sp, \"too many type parameter provided for this item\");\n         } else if (ty_substs_len < param_var_len) {\n-            fcx.ccx.tcx.sess.span_fatal(sp,\n-                                        \"not enough type parameters provided for this item\");\n+            fcx.ccx.tcx.sess.span_fatal\n+                (sp, \"not enough type parameters provided for this item\");\n         }\n         let ty_substs: ty::t[] = ~[];\n         let i = 0u;\n@@ -868,11 +868,10 @@ mod collect {\n         let abi = @mutable none[ast::native_abi];\n         let cx = @{tcx: tcx};\n         let visit =\n-            visit::mk_simple_visitor(@{visit_item: bind convert(cx, abi, _),\n-                                       visit_native_item:\n-                                           bind convert_native(cx, abi, _)\n-                                          with\n-                                              *visit::default_simple_visitor()});\n+            visit::mk_simple_visitor\n+            (@{visit_item: bind convert(cx, abi, _),\n+               visit_native_item: bind convert_native(cx, abi, _)\n+               with *visit::default_simple_visitor()});\n         visit::visit_crate(*crate, (), visit);\n     }\n }\n@@ -1426,14 +1425,13 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast::pat_id_map, pat: &@ast::pat,\n                 // TODO (issue #448): Wrap a #fmt string over multiple\n                 // lines...\n \n-                fcx.ccx.tcx.sess.span_fatal(pat.span,\n-                                            #fmt(\"this pattern has %u field%s, \\\n-                                                but the corresponding \\\n-                                                variant has no fields\",\n-                                                 subpats_len,\n-                                                 if subpats_len == 1u {\n-                                                     \"\"\n-                                                 } else { \"s\" }));\n+                fcx.ccx.tcx.sess.span_fatal\n+                    (pat.span, #fmt(\"this pattern has %u field%s, \\\n+                                     but the corresponding \\\n+                                     variant has no fields\",\n+                                    subpats_len,\n+                                    if subpats_len == 1u { \"\" }\n+                                    else { \"s\" }));\n             }\n             write::ty_fixup(fcx, pat.id, path_tpot);\n           }\n@@ -1464,11 +1462,10 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast::pat_id_map, pat: &@ast::pat,\n         let f_count = ivec::len(fields);\n         let ex_f_count = ivec::len(ex_fields);\n         if ex_f_count < f_count || !etc && ex_f_count > f_count {\n-            fcx.ccx.tcx.sess.span_fatal(pat.span,\n-                                        #fmt(\"mismatched types: expected a record \\\n-                                     with %u fields, found one with %u \\\n-                                     fields\",\n-                                             ex_f_count, f_count));\n+            fcx.ccx.tcx.sess.span_fatal\n+                (pat.span, #fmt(\"mismatched types: expected a record \\\n+                                 with %u fields, found one with %u \\\n+                                 fields\", ex_f_count, f_count));\n         }\n         fn matches(name: &str, f: &ty::field) -> bool {\n             ret str::eq(name, f.ident);\n@@ -1521,8 +1518,8 @@ fn require_pure_call(ccx: @crate_ctxt, caller_purity: &ast::purity,\n         alt ccx.tcx.def_map.find(callee.id) {\n           some(ast::def_fn(_, ast::pure_fn.)) { ret; }\n           _ {\n-            ccx.tcx.sess.span_fatal(sp,\n-                                    \"Pure function calls function not known to be pure\");\n+            ccx.tcx.sess.span_fatal\n+                (sp, \"Pure function calls function not known to be pure\");\n           }\n         }\n       }\n@@ -1614,10 +1611,10 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n                        arg_tys.(i).mode == mo_val {\n                     // For why the check is necessary, see the\n                     // none case in trans_bind_thunk\n-                    fcx.ccx.tcx.sess.span_fatal(sp,\n-                                                call_kind_str(call_kind) +\n-                                                    \" arguments with types containing parameters \\\n-                             must be passed by alias\");\n+                    fcx.ccx.tcx.sess.span_fatal\n+                        (sp, call_kind_str(call_kind) +\n+                         \" arguments with types containing parameters \\\n+                          must be passed by alias\");\n                 }\n               }\n             }\n@@ -1785,10 +1782,10 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n                 let variants = ty::tag_variants(fcx.ccx.tcx, id);\n                 if ivec::len(variants) != 1u ||\n                        ivec::len(variants.(0).args) != 1u {\n-                    fcx.ccx.tcx.sess.span_fatal(expr.span,\n-                                                \"can only dereference tags \" +\n-                                                    \"with a single variant which has a \"\n-                                                    + \"single argument\");\n+                    fcx.ccx.tcx.sess.span_fatal\n+                        (expr.span, \"can only dereference tags \" +\n+                         \"with a single variant which has a \"\n+                         + \"single argument\");\n                 }\n                 oper_t =\n                     ty::substitute_type_params(fcx.ccx.tcx, tps,\n@@ -1983,10 +1980,9 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n           ty::ty_ivec(vec_elt_ty) { elt_ty = vec_elt_ty.ty; }\n           ty::ty_istr. { elt_ty = ty::mk_mach(fcx.ccx.tcx, ast::ty_u8); }\n           _ {\n-            fcx.ccx.tcx.sess.span_fatal(expr.span,\n-                                        \"mismatched types: expected vector or string but \"\n-                                            + \"found \" +\n-                                            ty_to_str(fcx.ccx.tcx, ety));\n+            fcx.ccx.tcx.sess.span_fatal\n+                (expr.span, \"mismatched types: expected vector or string but \"\n+                 + \"found \" + ty_to_str(fcx.ccx.tcx, ety));\n           }\n         }\n         check_for_or_for_each(fcx, decl, elt_ty, body, id);\n@@ -2440,10 +2436,9 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) {\n                       _ {\n                         // The user is trying to extend a\n                         // non-object.\n-                        fcx.ccx.tcx.sess.span_fatal(e.span,\n-                                                    syntax::print::pprust::expr_to_str(e)\n-                                                        +\n-                                                        \" does not have object type\");\n+                        fcx.ccx.tcx.sess.span_fatal\n+                            (e.span, syntax::print::pprust::expr_to_str(e) +\n+                             \" does not have object type\");\n                       }\n                     }\n                   }"}, {"sha": "8fb396392d71ba940bb623e700cbcb432cf33578", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -329,9 +329,9 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: vec[piece],\n     let expected_nargs = n + 1u; // n conversions + the fmt string\n \n     if expected_nargs < nargs {\n-        cx.span_fatal(sp,\n-                      #fmt(\"too many arguments to #fmt. found %u, expected %u\",\n-                           nargs, expected_nargs));\n+        cx.span_fatal\n+            (sp, #fmt(\"too many arguments to #fmt. found %u, expected %u\",\n+                      nargs, expected_nargs));\n     }\n     ret tmp_expr;\n }"}, {"sha": "d52c234205cab127ec0b5bce2cbc979f04f7bc14", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -317,10 +317,9 @@ fn noop_fold_expr(e: &expr_, fld: ast_fold) -> expr_ {\n \n         ret {fields:\n                  alt ao.fields {\n-                   option::none[anon_obj_field[]]. { ao.fields }\n-                   option::some[anon_obj_field[]](v) {\n-                     option::some[anon_obj_field[]](ivec::map(fold_anon_obj_field,\n-                                                              v))\n+                   option::none. { ao.fields }\n+                   option::some(v) {\n+                     option::some(ivec::map(fold_anon_obj_field, v))\n                    }\n                  },\n              methods: ivec::map(fld.fold_method, ao.methods),"}, {"sha": "0b402e2e054834252c6748f1026f3e199104ca37", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1812,15 +1812,14 @@ fn parse_dtor(p: &parser) -> @ast::method {\n     let b: ast::blk = parse_block(p);\n     let inputs: ast::arg[] = ~[];\n     let output: @ast::ty = @spanned(lo, lo, ast::ty_nil);\n-    let \n-\n-        // I guess dtors can't have constraints?\n-        d: ast::fn_decl =\n-        {inputs: inputs,\n-         output: output,\n-         purity: ast::impure_fn,\n-         cf: ast::return,\n-         constraints: ~[]};\n+    // I guess dtors can't have constraints?\n+    let d: ast::fn_decl = {\n+        inputs: inputs,\n+        output: output,\n+        purity: ast::impure_fn,\n+        cf: ast::return,\n+        constraints: ~[]\n+    };\n     let f: ast::_fn = {decl: d, proto: ast::proto_fn, body: b};\n     let m: ast::method_ = {ident: \"drop\", meth: f, id: p.get_id()};\n     ret @spanned(lo, f.body.span.hi, m);\n@@ -1877,9 +1876,8 @@ fn parse_item_res(p: &parser, lyr: ast::layer, attrs: &ast::attribute[]) ->\n \n fn parse_mod_items(p: &parser, term: token::token,\n                    first_item_attrs: &ast::attribute[]) -> ast::_mod {\n-    let \n-        // Shouldn't be any view items since we've already parsed an item attr\n-        view_items =\n+    // Shouldn't be any view items since we've already parsed an item attr\n+    let view_items =\n         if ivec::len(first_item_attrs) == 0u { parse_view(p) } else { ~[] };\n     let items: (@ast::item)[] = ~[];\n     let initial_attrs = first_item_attrs;\n@@ -1960,11 +1958,10 @@ fn parse_native_item(p: &parser, attrs: &ast::attribute[]) ->\n }\n \n fn parse_native_mod_items(p: &parser, native_name: &str, abi: ast::native_abi,\n-                          first_item_attrs: &ast::attribute[]) ->\n-   ast::native_mod {\n-    let \n-        // Shouldn't be any view items since we've already parsed an item attr\n-        view_items =\n+                          first_item_attrs: &ast::attribute[])\n+    -> ast::native_mod {\n+    // Shouldn't be any view items since we've already parsed an item attr\n+    let view_items =\n         if ivec::len(first_item_attrs) == 0u {\n             parse_native_view(p)\n         } else { ~[] };"}, {"sha": "f9db8eda6939f8d8b68ce87c75541f015c80da81", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -215,11 +215,9 @@ mod ct {\n        {ty: ty, next: uint} {\n         if i >= lim { error(\"missing type in conversion\"); }\n         let tstr = str::substr(s, i, 1u);\n-        let \n-\n-            // TODO: Do we really want two signed types here?\n-            // How important is it to be printf compatible?\n-            t =\n+        // TODO: Do we really want two signed types here?\n+        // How important is it to be printf compatible?\n+        let t =\n             if str::eq(tstr, \"b\") {\n                 ty_bool\n             } else if (str::eq(tstr, \"s\")) {\n@@ -305,13 +303,11 @@ mod rt {\n         ret pad(cv, str::from_char(c), pad_nozero);\n     }\n     fn conv_str(cv: &conv, s: str) -> str {\n-        let \n-\n-            // For strings, precision is the maximum characters\n-            // displayed\n+        // For strings, precision is the maximum characters\n+        // displayed\n \n-            // FIXME: substr works on bytes, not chars!\n-            unpadded =\n+        // FIXME: substr works on bytes, not chars!\n+        let unpadded =\n             alt cv.precision {\n               count_implied. { s }\n               count_is(max) {"}, {"sha": "c710d220a6bb0036833100e0165640b4498ce69a", "filename": "src/lib/ivec.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Flib%2Fivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Flib%2Fivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fivec.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -90,10 +90,12 @@ pred is_not_empty[T](v: &T[mutable? ]) -> bool { ret !is_empty(v); }\n // Accessors\n \n /// Returns the first element of a vector\n-fn head[T](v: &T[mutable? ]) -> T { ret v.(0); }\n+fn head[T](v: &T[mutable?]) : is_not_empty(v) -> T { ret v.(0); }\n \n /// Returns all but the first element of a vector\n-fn tail[T](v: &T[mutable? ]) -> T[mutable? ] { ret slice(v, 1u, len(v)); }\n+fn tail[T](v: &T[mutable? ]) : is_not_empty(v)  -> T[mutable?] {\n+    ret slice(v, 1u, len(v));\n+}\n \n /// Returns the last element of `v`.\n fn last[T](v: &T[mutable? ]) -> option::t[T] {"}, {"sha": "0adf356116586543d83bae58132f4b1aea6006f7", "filename": "src/lib/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -396,7 +396,7 @@ fn slice(s: str, begin: uint, end: uint) -> str {\n     ret rustrt::str_slice(s, begin, end);\n }\n \n-fn safe_slice(s: str, begin: uint, end: uint) -> str {\n+fn safe_slice(s: str, begin: uint, end: uint): le(begin, end) -> str {\n     assert (end <=\n                 str::byte_len(s)); // would need some magic to\n                                    // make this a precondition\n@@ -505,7 +505,7 @@ fn to_upper(s: str) -> str {\n }\n \n // FIXME: This is super-inefficient\n-fn replace(s: str, from: str, to: str) -> str {\n+fn replace(s: str, from: str, to: str) : is_not_empty(from) -> str {\n     // FIXME (694): Shouldn't have to check this\n     check (is_not_empty(from));\n     if byte_len(s) == 0u {"}, {"sha": "03606debc1d85fcaca8ddc66a83dabb4a181437f", "filename": "src/lib/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -58,7 +58,7 @@ type test_opts = {filter: option::t[str], run_ignored: bool};\n type opt_res = either::t[test_opts, str];\n \n // Parses command line arguments into test options\n-fn parse_opts(args: &str[]) -> opt_res {\n+fn parse_opts(args: &str[]) : ivec::is_not_empty(args) -> opt_res {\n \n     // FIXME (#649): Shouldn't have to check here\n     check (ivec::is_not_empty(args));"}, {"sha": "08ef4995ad4ec19aa8212547833dbd5d37e936fa", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -6,16 +6,13 @@ native \"llvm\" mod llvm {\n }\n \n fn main() {\n-\n-    let \n-        //\n-        // Leave these commented out to\n-        // finish in a reasonable time\n-        // during 'make check' under valgrind\n-        // 5000000\n-        // 50000000\n-        inputs: vec[int] =\n-        [50000, 500000];\n+    //\n+    // Leave these commented out to\n+    // finish in a reasonable time\n+    // during 'make check' under valgrind\n+    // 5000000\n+    // 50000000\n+    let inputs: vec[int] = [50000, 500000];\n \n     let bodies: vec[Body::props] = NBodySystem::MakeNBodySystem();\n \n@@ -35,9 +32,8 @@ fn main() {\n mod NBodySystem {\n \n     fn MakeNBodySystem() -> vec[Body::props] {\n-        let \n-            // these each return a Body::props\n-            bodies: vec[Body::props] =\n+        // these each return a Body::props\n+        let bodies: vec[Body::props] =\n             [Body::sun(), Body::jupiter(), Body::saturn(), Body::uranus(),\n              Body::neptune()];\n "}, {"sha": "85714affba6e630767cda54c0d244b71df27f8f2", "filename": "src/test/compile-fail/attr-bad-meta.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fattr-bad-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fattr-bad-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-bad-meta.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,6 @@\n-./src/test/compile-fail/attr-bad-meta.rs:5:6:5:7: \u001b[1;31merror:\u001b[0m expecting ], found *\n-./src/test/compile-fail/attr-bad-meta.rs:5 #[attr*]\n-                                                 ^\n-rt: ---\n-rt: f00e:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: f00e:main:                        domain main @0xa6bf04c root task failed\n+// xfail-stage0\n+// error-pattern:expecting ]\n+\n+// asterisk is bogus\n+#[attr*]\n+mod m { }\n\\ No newline at end of file"}, {"sha": "29dd83b8af0defab833afcee737538dc22a8bb73", "filename": "src/test/compile-fail/attr-before-stmt.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fattr-before-stmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fattr-before-stmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-before-stmt.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,10 @@\n-./src/test/compile-fail/attr-before-stmt.rs:6:2:6:6: \u001b[1;31merror:\u001b[0m expected item\n-./src/test/compile-fail/attr-before-stmt.rs:6   auto x = 10;\n-                                                ^~~~\n-rt: ---\n-rt: 0bb1:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: 0bb1:main:                        domain main @0x8ef904c root task failed\n+// xfail-stage0\n+// error-pattern:expected item\n+\n+fn f() {\n+  #[foo = \"bar\"]\n+  let x = 10;\n+}\n+\n+fn main() {\n+}"}, {"sha": "56e2ab7f54f877e5efd53dcf39465ec592f6e43d", "filename": "src/test/compile-fail/attr-before-view-item.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fattr-before-view-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fattr-before-view-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-before-view-item.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,8 @@\n-./src/test/compile-fail/attr-before-view-item.rs:5:0:5:3: \u001b[1;31merror:\u001b[0m expected item but found use\n-./src/test/compile-fail/attr-before-view-item.rs:5 use std;\n-                                                   ^~~\n-rt: ---\n-rt: 0bb1:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: 0bb1:main:                        domain main @0xa78604c root task failed\n+// xfail-stage0\n+// error-pattern:expected item\n+\n+#[foo = \"bar\"]\n+use std;\n+\n+fn main() {\n+}"}, {"sha": "ad4071a07aa65bfc6127ceb2210bff1e4c9c326e", "filename": "src/test/compile-fail/attr-before-view-item2.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fattr-before-view-item2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fattr-before-view-item2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-before-view-item2.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,10 @@\n-./src/test/compile-fail/attr-before-view-item2.rs:6:2:6:5: \u001b[1;31merror:\u001b[0m expected item but found use\n-./src/test/compile-fail/attr-before-view-item2.rs:6   use std;\n-                                                      ^~~\n-rt: ---\n-rt: 0bb1:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: 0bb1:main:                        domain main @0xa1fd04c root task failed\n+// xfail-stage0\n+// error-pattern:expected item\n+\n+mod m {\n+  #[foo = \"bar\"]\n+  use std;\n+}\n+\n+fn main() {\n+}"}, {"sha": "c31b3250d768c8d05486d9796a12400e298125d6", "filename": "src/test/compile-fail/attr-dangling-in-fn.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fattr-dangling-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fattr-dangling-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-dangling-in-fn.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,9 @@\n-./src/test/compile-fail/attr-dangling-in-fn.rs:6:0:6:1: \u001b[1;31merror:\u001b[0m expected item\n-./src/test/compile-fail/attr-dangling-in-fn.rs:6 }\n-                                                 ^\n-rt: ---\n-rt: f00e:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: f00e:main:                        domain main @0x9fb104c root task failed\n+// xfail-stage0\n+// error-pattern:expected item\n+\n+fn f() {\n+  #[foo = \"bar\"]\n+}\n+\n+fn main() {\n+}"}, {"sha": "bd072402d257da634381b7820b2f99792a14259a", "filename": "src/test/compile-fail/attr-dangling-in-mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fattr-dangling-in-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fattr-dangling-in-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-dangling-in-mod.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,7 @@\n-./src/test/compile-fail/attr-dangling-in-mod.rs:7:14:7:14: \u001b[1;31merror:\u001b[0m expected item but found <eof>\n-./src/test/compile-fail/attr-dangling-in-mod.rs:7 #[foo = \"bar\"]\n-                                                                ^\n-rt: ---\n-rt: 0bb1:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: 0bb1:main:                        domain main @0xa2d504c root task failed\n+// xfail-stage0\n+// error-pattern:expected item\n+\n+fn main() {\n+}\n+\n+#[foo = \"bar\"]"}, {"sha": "0762953569e2fa46956b95449af467676ae94b81", "filename": "src/test/compile-fail/bad-alt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fbad-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fbad-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-alt.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,6 @@\n-./src/test/compile-fail/bad-alt.rs:5:7:5:8: \u001b[1;31merror:\u001b[0m expecting {, found ;\n-./src/test/compile-fail/bad-alt.rs:5   alt x;\n-                                            ^\n-rt: ---\n-rt: 0bb1:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: 0bb1:main:                        domain main @0x9e0f04c root task failed\n+// error-pattern: expecting\n+\n+fn main() {\n+  let int x = 5;\n+  alt x;\n+}"}, {"sha": "a53b8284d59e242726ffd748db757bcfa86779e4", "filename": "src/test/compile-fail/bad-name.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fbad-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fbad-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-name.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,5 @@\n-./src/test/compile-fail/bad-name.rs:4:7:4:8: \u001b[1;31merror:\u001b[0m expecting ident\n-./src/test/compile-fail/bad-name.rs:4   let x.y[int].z foo;\n-                                             ^\n-rt: ---\n-rt: f00e:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: f00e:main:                        domain main @0x8d6004c root task failed\n+// error-pattern: expecting\n+\n+fn main() {\n+  let x.y[int].z foo;\n+}"}, {"sha": "cebe5b3b189606a4459ef28871e0d14c742844f7", "filename": "src/test/compile-fail/constrained-type-missing-check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fconstrained-type-missing-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fconstrained-type-missing-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconstrained-type-missing-check.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -11,7 +11,7 @@ type bubu = {x: int, y: int};\n \n pred less_than(x: int, y: int) -> bool { ret x < y; }\n \n-type ordered_range = {low: int, high: int} :  : less_than(low, high);\n+type ordered_range = {low: int, high: int} : less_than(low, high);\n \n fn main() {\n     // Should fail to compile, b/c we're not doing the check"}, {"sha": "7d8774dbb1f41e63d409bae93e7f44634cdd928e", "filename": "src/test/compile-fail/do-while-pred-constraints.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fdo-while-pred-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fdo-while-pred-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdo-while-pred-constraints.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,16 +1,25 @@\n // xfail-stage0\n // error-pattern: Unsatisfied precondition constraint (for example, even(y\n \n-fn print_even(y: int) { log y; }\n+fn print_even(y: int) : even(y) {\n+  log y;\n+}\n \n-pred even(y: int) -> bool { true }\n+pred even(y: int) -> bool {\n+  true\n+}\n \n fn main() {\n-\n-    let y: int = 42;\n-    check (even(y));\n-    do  {\n-        print_even(y);\n-        do  { do  { do  { y += 1; } while true } while true } while true\n-    } while true\n-}\n\\ No newline at end of file\n+  let y: int = 42;\n+  check even(y);\n+  do {\n+    print_even(y);\n+    do {\n+      do {\n+    do {\n+      y += 1;\n+    } while (true);\n+      } while (true);\n+    } while (true);\n+  } while (true);\n+}"}, {"sha": "446fb836717c676627d582a9df42807d45002f8a", "filename": "src/test/compile-fail/ext-after-attrib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,8 @@\n-./src/test/compile-fail/ext-after-attrib.rs:7:1:7:4: \u001b[1;31merror:\u001b[0m expecting [, found fmt\n-./src/test/compile-fail/ext-after-attrib.rs:7 #fmt(\"baz\")\n-                                               ^~~\n-rt: ---\n-rt: f00e:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: f00e:main:                        domain main @0xa47a04c root task failed\n+// xfail-stage0\n+// error-pattern:expecting [, found fmt\n+\n+// Don't know how to deal with a syntax extension appearing after an\n+// item attribute. Probably could use a better error message.\n+#[foo = \"bar\"]\n+#fmt(\"baz\")\n+fn main() { }\n\\ No newline at end of file"}, {"sha": "82395c710a8f38f1d00e1895f0e61e458c512831", "filename": "src/test/compile-fail/ext-noname.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fext-noname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fext-noname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-noname.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,5 @@\n-./src/test/compile-fail/ext-noname.rs:4:3:4:4: \u001b[1;31merror:\u001b[0m expected a syntax expander name\n-./src/test/compile-fail/ext-noname.rs:4   #();\n-                                           ^\n-rt: ---\n-rt: 0bb1:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: 0bb1:main:                        domain main @0x91a204c root task failed\n+// error-pattern:expected a syntax expander name\n+\n+fn main() {\n+  #();\n+}\n\\ No newline at end of file"}, {"sha": "5b0be3c987132690a7ddf3a3de7703ac85ef8d6e", "filename": "src/test/compile-fail/extenv-no-args.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,3 +1,5 @@\n // error-pattern:malformed #env call\n \n-fn main() { #env; }\n\\ No newline at end of file\n+fn main() {\n+    #env();\n+}"}, {"sha": "8bc3f23f2f037f0778863825b94edde013e6f216", "filename": "src/test/compile-fail/extfmt-no-args.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,3 +1,5 @@\n // error-pattern:format string\n \n-fn main() { #fmt; }\n\\ No newline at end of file\n+fn main() {\n+    #fmt();\n+}\n\\ No newline at end of file"}, {"sha": "768cc1e1bf4c66effe9ea91b81a5d67e8ed2daa7", "filename": "src/test/compile-fail/fail-simple.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Ffail-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Ffail-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-simple.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,6 @@\n-./src/test/compile-fail/fail-simple.rs:5:9:5:10: \u001b[1;31merror:\u001b[0m unexpected token: ;\n-./src/test/compile-fail/fail-simple.rs:5   fail @ ;\n-                                                  ^\n-rt: ---\n-rt: f00e:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: f00e:main:                        domain main @0x994f04c root task failed\n+// -*- rust -*-\n+\n+// error-pattern:unexpected token\n+fn main() {\n+  fail @ ;\n+}"}, {"sha": "df8f1147fde546e58f4fe96c6d719bf5b847984f", "filename": "src/test/compile-fail/if-check-precond-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fif-check-precond-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fif-check-precond-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-check-precond-fail.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -6,7 +6,7 @@ pred even(x: uint) -> bool {\n     } else if (x == 2u) { ret true; } else { ret even(x - 2u); }\n }\n \n-fn print_even(x: uint) { log x; }\n+fn print_even(x: uint) : even(x) { log x; }\n \n fn foo(x: uint) { if check even(x) { fail; } else { print_even(x); } }\n "}, {"sha": "8a5d253618322ceec96b4f88aacffe350293d62b", "filename": "src/test/compile-fail/macro-2.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,11 +1,7 @@\n // xfail-stage0\n //error-pattern:is an expr, expected an identifier\n fn main() {\n-    #macro([#mylambda(x, body),\n-            {\n-                fn f(x: int) -> int { ret body }\n-                f\n-            }]);\n+  #macro([#mylambda(x, body), {fn f(x: int) -> int {ret body}; f}]);\n \n-    assert (#mylambda(y * 1, y * 2)(8) == 16);\n+  assert(#mylambda(y*1, y*2)(8) == 16);\n }\n\\ No newline at end of file"}, {"sha": "5beb996ebbf4658cc8138c6b31d9fda3d6105348", "filename": "src/test/compile-fail/macro.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fmacro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fmacro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -2,8 +2,7 @@\n //error-pattern:no clauses match\n \n fn main() {\n-    #macro([#trivial, 1 * 2 * 4 * 2 * 1]);\n+  #macro([#trivial(), 1*2*4*2*1]);\n \n-    assert (#trivial(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16) ==\n-                16);\n-}\n\\ No newline at end of file\n+  assert(#trivial(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16) == 16);\n+}"}, {"sha": "a345425fc9822ebf1ef03ed6321a29feed49753f", "filename": "src/test/compile-fail/multiline-comment-line-tracking.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fmultiline-comment-line-tracking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fmultiline-comment-line-tracking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmultiline-comment-line-tracking.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,10 @@\n-./src/test/compile-fail/multiline-comment-line-tracking.rs:9:2:9:3: \u001b[1;31merror:\u001b[0m unexpected token: %\n-./src/test/compile-fail/multiline-comment-line-tracking.rs:9   %; // parse error on line 9, but is reported on line 6 instead.\n-                                                               ^\n-rt: ---\n-rt: f00e:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: f00e:main:                        domain main @0x969e04c root task failed\n+// -*- rust -*-\n+// error-pattern:9:2\n+\n+/* 1\n+ * 2\n+ * 3\n+ */\n+fn main() {\n+  %; // parse error on line 9, but is reported on line 6 instead.\n+}"}, {"sha": "5ec15e9c65308aa56692cd928698509407de6b8d", "filename": "src/test/compile-fail/not-a-pred-3.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-3.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -8,5 +8,6 @@ obj f() {\n \n fn main() {\n     let z = f();\n-    check (z.g(42)); // should fail to typecheck, as z.g isn't an explicit name\n+    // should fail to typecheck, as z.g isn't an explicit name\n+    check (z.g(42));\n }\n\\ No newline at end of file"}, {"sha": "5e29596a712fcae457cb4d615f85a9a6632de4e1", "filename": "src/test/compile-fail/not-a-pred.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -2,7 +2,7 @@\n // xfail-stage0\n // error-pattern: Non-predicate in constraint: lt\n \n-fn f(a: int, b: int) { }\n+fn f(a: int, b: int) : lt(a,b) { }\n \n obj lt(a: int, b: int) { }\n "}, {"sha": "e73cd18dac7c554a2518ca6f069a662072ce31c7", "filename": "src/test/compile-fail/not-pred-args.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fnot-pred-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fnot-pred-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-pred-args.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -5,6 +5,7 @@\n pred f(q: int) -> bool { ret true; }\n \n fn main() {\n-    // should fail to typecheck, as pred args must be slot variables or literals\n+    // should fail to typecheck, as pred args must be slot variables\n+    // or literals\n     check (f(42 * 17));\n }\n\\ No newline at end of file"}, {"sha": "167572f00167548356cc001600d573ea07eba54a", "filename": "src/test/compile-fail/pred-assign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fpred-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fpred-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpred-assign.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -3,7 +3,7 @@\n \n // error-pattern: Unsatisfied precondition constraint (for example, lt(a, b)\n \n-fn f(a: int, b: int) { }\n+fn f(a: int, b: int) : lt(a,b) { }\n \n pred lt(a: int, b: int) -> bool { ret a < b; }\n "}, {"sha": "a3b583bd6dd93c4b0c8c7f55e2ee560afb5da608", "filename": "src/test/compile-fail/pred-on-wrong-slots.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fpred-on-wrong-slots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fpred-on-wrong-slots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpred-on-wrong-slots.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -3,7 +3,7 @@\n \n // error-pattern: lt(a, c)\n \n-fn f(a: int, b: int) { }\n+fn f(a: int, b: int) : lt(a,b) { }\n \n pred lt(a: int, b: int) -> bool { ret a < b; }\n "}, {"sha": "110db69fee28937a8b48a3ec27517996a86acbe6", "filename": "src/test/compile-fail/pred-swap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fpred-swap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fpred-swap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpred-swap.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -3,7 +3,7 @@\n \n // error-pattern: Unsatisfied precondition constraint (for example, lt(a, b)\n \n-fn f(a: int, b: int) { }\n+fn f(a: int, b: int) : lt(a,b) { }\n \n pred lt(a: int, b: int) -> bool { ret a < b; }\n "}, {"sha": "af69d2ac1a4c8c3ae9e3e8b34d66763301a01d08", "filename": "src/test/compile-fail/self-missing-method.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fself-missing-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fself-missing-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself-missing-method.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,12 @@\n-./src/test/compile-fail/self-missing-method.rs:6:14:6:15: \u001b[1;31merror:\u001b[0m expecting ., found (\n-./src/test/compile-fail/self-missing-method.rs:6           self();\n-                                                               ^\n-rt: ---\n-rt: 0bb1:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: 0bb1:main:                        domain main @0x8f5904c root task failed\n+// error-pattern:expecting ., found (\n+fn main() {\n+\n+  obj foo() {\n+      fn m() {\n+          self();\n+      }\n+  }\n+\n+  let a = foo;\n+  a.m();\n+}"}, {"sha": "65a8863fbad94d1f1a65e982f4d910a52d31b516", "filename": "src/test/compile-fail/slot-as-pred.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fslot-as-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fslot-as-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslot-as-pred.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -2,7 +2,7 @@\n // xfail-stage0\n // error-pattern: unresolved name: lt\n \n-fn f(a: int, b: int) { }\n+fn f(a: int, b: int) : lt(a,b) { }\n \n fn main() {\n     let lt: int;"}, {"sha": "559065a00f4c331ad6fad3449aae70bbe89d992e", "filename": "src/test/compile-fail/tail-non-call.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Ftail-non-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Ftail-non-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftail-non-call.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,10 @@\n-./src/test/compile-fail/tail-non-call.rs:5:6:5:7: \u001b[1;31merror:\u001b[0m Non-call expression in tail call\n-./src/test/compile-fail/tail-non-call.rs:5   be x;\n-                                                 ^\n-rt: ---\n-rt: f00e:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: f00e:main:                        domain main @0x9d9404c root task failed\n+// error-pattern: Non-call expression in tail call\n+\n+fn f() -> int {\n+  let x = 1;\n+  be x;\n+}\n+\n+fn main() {\n+  let y = f();\n+}"}, {"sha": "c9d3e0c9b6a4fe85de51db487e5c417445872c44", "filename": "src/test/compile-fail/unbalanced-comment.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Funbalanced-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Funbalanced-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funbalanced-comment.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,11 @@\n-./src/test/compile-fail/unbalanced-comment.rs:11:1:11:1: \u001b[1;31merror:\u001b[0m unterminated block comment\n-./src/test/compile-fail/unbalanced-comment.rs:11 }\n-                                                  ^\n-rt: ---\n-rt: f00e:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/lexer.rs:153\n-rt: f00e:main:                        domain main @0x96ef04c root task failed\n+// -*- rust -*-\n+\n+// error-pattern: unterminated block comment\n+\n+/*\n+ * This is an un-balanced /* multi-line comment.\n+ */\n+\n+fn main() {\n+  log \"hello, world.\";\n+}"}, {"sha": "0cfda830ee900784cb6c1973b51b36fde887028d", "filename": "src/test/compile-fail/while-loop-pred-constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fwhile-loop-pred-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fcompile-fail%2Fwhile-loop-pred-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhile-loop-pred-constraints.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,7 +1,7 @@\n // xfail-stage0\n // error-pattern: Unsatisfied precondition constraint (for example, even(y\n \n-fn print_even(y: int) { log y; }\n+fn print_even(y: int) : even(y) { log y; }\n \n pred even(y: int) -> bool { true }\n "}, {"sha": "2271e9dcc653195a5fca5cdc54be966281c4e7b1", "filename": "src/test/run-fail/fn-constraint-claim.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-fail%2Ffn-constraint-claim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-fail%2Ffn-constraint-claim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffn-constraint-claim.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -5,6 +5,11 @@ use std;\n import std::str::*;\n import std::uint::*;\n \n-fn nop(a: uint, b: uint) { fail \"quux\"; }\n+fn nop(a: uint, b: uint) : le(a, b) { fail \"quux\"; }\n \n-fn main() { let a: uint = 5u; let b: uint = 4u; claim (le(a, b)); nop(a, b); }\n\\ No newline at end of file\n+fn main() {\n+    let a: uint = 5u;\n+    let b: uint = 4u;\n+    claim (le(a, b));\n+    nop(a, b);\n+}"}, {"sha": "c1e6b73aefc5090e4bac2ff3261b02afbed5cf94", "filename": "src/test/run-fail/task-comm-14.rs", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-fail%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-fail%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftask-comm-14.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,33 @@\n-./src/test/run-fail/task-comm-14.rs:5:0:5:2: \u001b[1;31merror:\u001b[0m expected item but found io\n-./src/test/run-fail/task-comm-14.rs:5 io fn main() {\n-                                      ^~\n-rt: ---\n-rt: 0bb1:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: 0bb1:main:                        domain main @0x919b04c root task failed\n+// xfail-stage0\n+// xfail-stage1\n+// xfail-stage2\n+// xfail-stage3\n+io fn main() {\n+    let port[int] po = port();\n+\n+    // Spawn 10 tasks each sending us back one int.\n+    let int i = 10;\n+    while (i > 0) {\n+        log i;\n+        spawn \"child\" child(i, chan(po));\n+        i = i - 1;\n+    }\n+\n+    // Spawned tasks are likely killed before they get a chance to send\n+    // anything back, so we deadlock here.\n+\n+    i = 10;\n+    let int value = 0;\n+    while (i > 0) {\n+        log i;\n+        po |> value;\n+        i = i - 1;\n+    }\n+\n+    log \"main thread exiting\";\n+}\n+\n+io fn child(int x, chan[int] ch) {\n+    log x;\n+    ch <| x;\n+}"}, {"sha": "bee450e9893cd9b3836002055385030778f14ffb", "filename": "src/test/run-pass/alt-type-simple.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Falt-type-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Falt-type-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-type-simple.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,15 @@\n-./src/test/run-pass/alt-type-simple.rs:6:6:6:10: \u001b[1;31merror:\u001b[0m found type in expression position\n-./src/test/run-pass/alt-type-simple.rs:6   alt type (f) {\n-                                               ^~~~\n-rt: ---\n-rt: f00e:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: f00e:main:                        domain main @0x9b0204c root task failed\n+// xfail-stage0\n+// xfail-stage1\n+// xfail-stage2\n+// xfail-stage3\n+fn altsimple(any x) {\n+  alt type (f) {\n+    case (int i) { print(\"int\"); }\n+    case (str s) { print(\"str\"); }\n+  }\n+}\n+\n+fn main() {\n+  altsimple(5);\n+  altsimple(\"asdfasdfsDF\");\n+}"}, {"sha": "19860158ce4a0b0bf75606726e0f8abda7d3561e", "filename": "src/test/run-pass/anon-obj-overriding.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fanon-obj-overriding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fanon-obj-overriding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-obj-overriding.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -10,9 +10,7 @@ fn main() {\n     let my_a = a();\n \n     // An anonymous object that overloads the 'foo' method.\n-    let \n-\n-        my_b =\n+    let my_b =\n         obj () {\n             fn foo() -> int { ret 3; }\n             with"}, {"sha": "2164ef25a0ae23d2de9741c4b7eb3768c95c9e3d", "filename": "src/test/run-pass/block-expr-precedence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fblock-expr-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fblock-expr-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-expr-precedence.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -43,7 +43,7 @@\n \n fn main() {\n \n-  auto num = 12;\n+  let num = 12;\n \n   assert if (true) { 12 } else { 12 } - num == 0;\n   assert 12 - if (true) { 12 } else { 12 } == 0;"}, {"sha": "01ffc0963ee439f93eb9369fb7e64a988d981300", "filename": "src/test/run-pass/clone-with-exterior.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,14 @@\n-./src/test/run-pass/clone-with-exterior.rs:12:28:12:29: \u001b[1;31merror:\u001b[0m expecting (, found f\n-./src/test/run-pass/clone-with-exterior.rs:12   let task p = spawn thread f(z);\n-                                                                          ^\n-rt: ---\n-rt: f00e:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: f00e:main:                        domain main @0x8f2504c root task failed\n+// xfail-stage0\n+// xfail-stage1\n+// xfail-stage2\n+// xfail-stage3\n+fn f(@rec(int a, int b) x) {\n+  assert (x.a == 10);\n+  assert (x.b == 12);\n+}\n+\n+fn main() {\n+  let @rec(int a, int b) z = rec(a=10, b=12);\n+  let task p = spawn thread f(z);\n+  join p;\n+}\n\\ No newline at end of file"}, {"sha": "6f3c6a51dfe277614ef7aa4dd15afd014c57b6a5", "filename": "src/test/run-pass/constrained-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fconstrained-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fconstrained-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstrained-type.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -7,6 +7,6 @@ type bubu = {x: int, y: int};\n \n pred less_than(x: int, y: int) -> bool { ret x < y; }\n \n-type ordered_range = {low: int, high: int} :  : less_than(low, high);\n+type ordered_range = {low: int, high: int} : less_than(*.low, *.high);\n \n fn main() { }\n\\ No newline at end of file"}, {"sha": "ae504a7916fad1485ca40b5babb34e2762e74e62", "filename": "src/test/run-pass/destructor-ordering.rs", "status": "modified", "additions": 123, "deletions": 6, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fdestructor-ordering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fdestructor-ordering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdestructor-ordering.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,123 @@\n-./src/test/run-pass/destructor-ordering.rs:25:0:25:2: \u001b[1;31merror:\u001b[0m expected item but found io\n-./src/test/run-pass/destructor-ordering.rs:25 io fn check_order(port[order_info] expected_p) {\n-                                              ^~\n-rt: ---\n-rt: 17b9:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: 17b9:main:                        domain main @0x96d304c root task failed\n+// xfail-stage0\n+// xfail-stage1\n+// xfail-stage2\n+// xfail-stage3\n+// This test checks that destructors run in the right order.  Because\n+// stateful objects can't have destructors, we have the destructors\n+// record their expected order into a channel when they execute (so\n+// the object becomes 'io' rather than 'state').  Then each test case\n+// asserts that the channel produces values in ascending order.\n+//\n+// FIXME: Write an int->str function and concatenate the whole failure\n+// message into a single log statement (or, even better, a print).\n+//\n+// FIXME: check_order should take only 1 line in a test, not 2+a block\n+// block. Since destructor-having objects can't refer to mutable state\n+// (like the port), we'd need a with-like construct to do the same for\n+// stateful objects within a scope.\n+//\n+// FIXME #21: Each test should execute in its own task, so it can fail\n+// independently, writing its error message to a channel that the\n+// parent task aggregates.\n+\n+type order_info = rec(int order, str msg);\n+\n+io fn check_order(port[order_info] expected_p) {\n+  chan(expected_p) <| rec(order=-1, msg=\"\");\n+  let mutable int actual = 0;\n+  // FIXME #121: Workaround for while(true) bug.\n+  auto expected; expected_p |> expected;\n+  auto done = -1;  // FIXME: Workaround for typechecking bug.\n+  while(expected.order != done) {\n+    if (expected.order != actual) {\n+      log expected.order;\n+      log \" != \";\n+      log actual;\n+      log expected.msg;\n+      fail;\n+    }\n+    actual += 1;\n+    expected_p |> expected;\n+  }\n+}\n+\n+\n+obj dorder(chan[order_info] expected, int order, str message) {\n+  drop {\n+    expected <| rec(order=order, msg=message);\n+  }\n+}\n+\n+io fn test_simple() {\n+  let port[order_info] tracker_p = port();\n+  auto tracker = chan(tracker_p);\n+  dorder(tracker, 1, \"Reverse decl order\");\n+  dorder(tracker, 0, \"Reverse decl order\");\n+  check_order(tracker_p);\n+}\n+\n+io fn test_block() {\n+  let port[order_info] tracker_p = port();\n+  auto tracker = chan(tracker_p);\n+  {\n+    dorder(tracker, 2, \"Before block\");\n+    {\n+      dorder(tracker, 0, \"Inside block\");\n+    }\n+    dorder(tracker, 1, \"After block\");\n+  }\n+  check_order(tracker_p);\n+}\n+\n+io fn test_decl_v_init() {\n+  let port[order_info] tracker_p = port();\n+  auto tracker = chan(tracker_p);\n+  {\n+    auto var1;\n+    auto var2;\n+    var2 = dorder(tracker, 0, \"decl, not init\");\n+    var1 = dorder(tracker, 1, \"decl, not init\");\n+  }\n+  check_order(tracker_p);\n+}\n+\n+io fn test_overwritten_obj() {\n+  let port[order_info] tracker_p = port();\n+  auto tracker = chan(tracker_p);\n+  {\n+    auto var1 = dorder(tracker, 0, \"overwritten object destroyed first\");\n+    auto var2 = dorder(tracker, 2, \"destroyed at end of scope\");\n+    var1 = dorder(tracker, 3, \"overwriter deleted in rev decl order\");\n+    {\n+      dorder(tracker, 1, \"overwritten object destroyed before end of scope\");\n+    }\n+  }\n+  check_order(tracker_p);\n+}\n+\n+// Used to embed dorder objects into an expression.  Note that the\n+// parameters don't get destroyed.\n+fn combine_dorders(dorder d1, dorder d2) -> int {\n+  ret 1;\n+}\n+io fn test_expression_destroyed_right_to_left() {\n+  let port[order_info] tracker_p = port();\n+  auto tracker = chan(tracker_p);\n+  {\n+    combine_dorders(dorder(tracker, 4, \"\"), dorder(tracker, 3, \"\"))\n+      / combine_dorders(dorder(tracker, 2, \"\"), dorder(tracker, 1, \"\"));\n+    {\n+      dorder(tracker, 0,\n+             \"expression objects live to end of block, not statement\");\n+    }\n+  }\n+  check_order(tracker_p);\n+}\n+\n+io fn main() {\n+  test_simple();\n+  test_block();\n+  test_decl_v_init();\n+  test_overwritten_obj();\n+  test_expression_destroyed_right_to_left();\n+}"}, {"sha": "bb7fdd308178a4e73595e96564fb47f0dc110e64", "filename": "src/test/run-pass/if-check-precond.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fif-check-precond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fif-check-precond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fif-check-precond.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -5,7 +5,7 @@ pred even(x: uint) -> bool {\n     } else if (x == 2u) { ret true; } else { ret even(x - 2u); }\n }\n \n-fn print_even(x: uint) { log x; }\n+fn print_even(x: uint) : even(x) { log x; }\n \n fn foo(x: uint) { if check even(x) { print_even(x); } else { fail; } }\n "}, {"sha": "0137bf912af8505fd9f147fbaf38fb2780e1bdfa", "filename": "src/test/run-pass/if-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fif-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fif-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fif-ret.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,4 +1,4 @@\n // xfail-stage0\n-fn foo() { if ret { } }\n+fn foo() { if (ret) { } }\n \n fn main() { foo(); }\n\\ No newline at end of file"}, {"sha": "43a1701f39e292ca41014dc4341bf0554f825643", "filename": "src/test/run-pass/item-attributes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fitem-attributes.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -83,7 +83,7 @@ mod test_stmt_single_attr_outer {\n         #[attr = \"val\"]\n         mod mod1 {\n         }\n-        \n+\n         #[attr = \"val\"]\n         native \"rust\" mod rustrt {\n         }\n@@ -115,7 +115,7 @@ mod test_stmt_multi_attr_outer {\n         #[attr2 = \"val\"]\n         mod mod1 {\n         }\n-        \n+\n         #[attr1 = \"val\"]\n         #[attr2 = \"val\"]\n         native \"rust\" mod rustrt {"}, {"sha": "0cd21a830eb2e877dada3183e3d7b7c62aefb9b8", "filename": "src/test/run-pass/macro-2.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fmacro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fmacro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-2.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,11 +1,7 @@\n // xfail-stage0\n \n fn main() {\n-    #macro([#mylambda(x, body),\n-            {\n-                fn f(x: int) -> int { ret body }\n-                f\n-            }]);\n+  #macro([#mylambda(x,body), {fn f(x: int) -> int { ret body }; f}]);\n \n-    assert (#mylambda(y, y * 2)(8) == 16);\n+  assert(#mylambda(y,y*2)(8) == 16);\n }\n\\ No newline at end of file"}, {"sha": "c14d89430830013d0b425f34ffaebc09af109a64", "filename": "src/test/run-pass/macro-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fmacro-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fmacro-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-3.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,7 +1,7 @@\n // xfail-stage0\n \n fn main() {\n-    #macro([#trivial, 1 * 2 * 4 * 2 * 1]);\n+  #macro([#trivial(), 1*2*4*2*1]);\n \n-    assert (#trivial == 16);\n-}\n\\ No newline at end of file\n+  assert(#trivial() == 16);\n+}"}, {"sha": "f82e37deea22a109eadd35fa431c3d70b201b8f5", "filename": "src/test/run-pass/macro.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fmacro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fmacro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,3 +1,6 @@\n // xfail-stage0\n \n-fn main() { #macro([#m1(a), a * 4]); assert (#m1(2) == 8); }\n\\ No newline at end of file\n+fn main() {\n+  #macro([#m1(a), a*4]);\n+  assert (#m1(2) == 8);\n+}"}, {"sha": "6affa165aeab61ff118c963ebfdbe1d55b6b56de", "filename": "src/test/run-pass/many.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fmany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fmany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmany.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,25 @@\n-./src/test/run-pass/many.rs:21:12:21:14: \u001b[1;31merror:\u001b[0m expecting ;, found |>\n-./src/test/run-pass/many.rs:21   let int p |> y;\n-                                           ^~\n-rt: ---\n-rt: f00e:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: f00e:main:                        domain main @0x8da604c root task failed\n+// xfail-stage0\n+// xfail-stage1\n+// xfail-stage2\n+// xfail-stage3\n+// -*- rust -*-\n+\n+fn sub(chan[int] parent, int id) {\n+  if (id == 0) {\n+    parent <| 0;\n+  } else {\n+    let port[int] p = port();\n+    auto child = spawn sub(chan(p), id-1);\n+    let int y; p |> y;\n+    parent <| y + 1;\n+  }\n+}\n+\n+fn main() {\n+  let port[int] p = port();\n+  auto child = spawn sub(chan(p), 500);\n+  let int p |> y;\n+  log \"transmission complete\";\n+  log y;\n+  assert (y == 500);\n+}"}, {"sha": "cf8153c0fe47cfadff63f4b6feb3c0efacd75a22", "filename": "src/test/run-pass/nil-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fnil-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fnil-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnil-pattern.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,2 +1,2 @@\n // xfail-stage0\n-fn main() { let x = (); alt x { () { } } }\n\\ No newline at end of file\n+fn main() { let x = (); alt x { (()) { } } }\n\\ No newline at end of file"}, {"sha": "24711da7c0b79921a86d9e4dbde1319853198c81", "filename": "src/test/run-pass/spawn-module-qualified.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-module-qualified.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,13 @@\n-./src/test/run-pass/spawn-module-qualified.rs:7:7:7:8: \u001b[1;31merror:\u001b[0m expected ';' or '}' after expression but found x\n-./src/test/run-pass/spawn-module-qualified.rs:7   join x;\n-                                                       ^\n-rt: ---\n-rt: 0bb1:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: 0bb1:main:                        domain main @0xa98404c root task failed\n+// xfail-stage0\n+// xfail-stage1\n+// xfail-stage2\n+// xfail-stage3\n+fn main() {\n+  auto x = spawn m::child(10);\n+  join x;\n+}\n+mod m {\n+  fn child(int i) {\n+    log i;\n+  }\n+}"}, {"sha": "59ef847cced077031a1f847e21bc8bd3c4d87ed3", "filename": "src/test/run-pass/syntax-extension-shell.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fsyntax-extension-shell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fsyntax-extension-shell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-shell.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,8 @@\n-./src/test/run-pass/syntax-extension-shell.rs:6:18:6:19: \u001b[1;31merror:\u001b[0m expecting (, found {\n-./src/test/run-pass/syntax-extension-shell.rs:6   auto s = #shell { uname -a };\n-                                                                  ^\n-rt: ---\n-rt: f00e:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: f00e:main:                        domain main @0x910c04c root task failed\n+// xfail-stage0\n+// xfail-stage1\n+// xfail-stage2\n+// xfail-stage3\n+fn main() {\n+  auto s = #shell { uname -a };\n+  log s;\n+}"}, {"sha": "bad47e2aed92bacbf5cf7f5b2a03a72da5f14e64", "filename": "src/test/run-pass/task-killjoin.rs", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Ftask-killjoin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Ftask-killjoin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,41 @@\n-./src/test/run-pass/task-killjoin.rs:22:36:22:46: \u001b[1;31merror:\u001b[0m expecting (, found supervised\n-./src/test/run-pass/task-killjoin.rs:22     let task t = spawn \"supervised\" supervised();\n-                                                                            ^~~~~~~~~~\n-rt: ---\n-rt: f00e:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: f00e:main:                        domain main @0xa7b604c root task failed\n+// xfail-stage0\n+// xfail-stage1\n+// xfail-stage2\n+// xfail-stage3\n+\n+// Create a task that is supervised by another task,\n+// join the supervised task from the supervising task,\n+// then fail the supervised task. The supervised task\n+// will kill the supervising task, waking it up. The\n+// supervising task no longer needs to be wakened when\n+// the supervised task exits.\n+\n+fn supervised() {\n+    // Yield to make sure the supervisor joins before we\n+    // fail. This is currently not needed because the supervisor\n+    // runs first, but I can imagine that changing.\n+    yield;\n+    fail;\n+}\n+\n+fn supervisor() {\n+    let task t = spawn \"supervised\" supervised();\n+    join t;\n+}\n+\n+fn main() {\n+    // Start the test in another domain so that\n+    // the process doesn't return a failure status as a result\n+    // of the main task being killed.\n+    let task dom2 = spawn thread \"supervisor\" supervisor();\n+    join dom2;\n+}\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "885b0e87e472f090a111d670ec1fb6333876fc0a", "filename": "src/test/run-pass/threads.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthreads.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,20 @@\n-./src/test/run-pass/threads.rs:11:17:11:24: \u001b[1;31merror:\u001b[0m expecting (, found \"child\"\n-./src/test/run-pass/threads.rs:11     spawn thread \"child\" child(i);\n-                                                   ^~~~~~~\n-rt: ---\n-rt: f00e:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: f00e:main:                        domain main @0x999804c root task failed\n+// xfail-stage0\n+// xfail-stage1\n+// xfail-stage2\n+// xfail-stage3\n+\n+// -*- rust -*-\n+\n+fn main() {\n+  let int i = 10;\n+  while (i > 0) {\n+    spawn thread \"child\" child(i);\n+    i = i - 1;\n+  }\n+  log \"main thread exiting\";\n+}\n+\n+fn child(int x) {\n+  log x;\n+}\n+"}, {"sha": "f2eda37e0d00a3243e1924c710c1537723b30968", "filename": "src/test/run-pass/typestate-transitive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Ftypestate-transitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Ftypestate-transitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypestate-transitive.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,7 +1,7 @@\n pred p(i: int) -> bool { true }\n \n-fn f(i: int) -> int { i }\n+fn f(i: int) : p(i) -> int { i }\n \n-fn g(i: int) -> int { f(i) }\n+fn g(i: int) : p(i) -> int { f(i) }\n \n fn main() { }\n\\ No newline at end of file"}, {"sha": "02d184e25cad4ea78fe80756917fcb42fbabe129", "filename": "src/test/run-pass/user.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fuser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fuser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuser.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,18 @@\n-./src/test/run-pass/user.rs:9:16:9:17: \u001b[1;31merror:\u001b[0m unexpected token: _\n-./src/test/run-pass/user.rs:9          uuid = _, ver = _);\n-                                              ^\n-rt: ---\n-rt: f00e:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: f00e:main:                        domain main @0x907604c root task failed\n+// xfail-stage0\n+// xfail-stage1\n+// xfail-stage2\n+// xfail-stage3\n+// -*- rust -*-\n+\n+use std (name = \"std\",\n+         url = \"http://rust-lang.org/src/std\",\n+         uuid = _, ver = _);\n+\n+fn main() {\n+  auto s = std::str.alloc(10 as uint);\n+  s += \"hello \";\n+  log s;\n+  s += \"there\";\n+  log s;\n+  auto z = std::vec.alloc[int](10 as uint);\n+}"}, {"sha": "9434eed3847eb45e870655b63df5caf81f264511", "filename": "src/test/run-pass/vec-slice.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fvec-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Frun-pass%2Fvec-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-slice.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -1,6 +1,10 @@\n-./src/test/run-pass/vec-slice.rs:7:16:7:17: \u001b[1;31merror:\u001b[0m expecting ), found ,\n-./src/test/run-pass/vec-slice.rs:7   auto v2 = v.(1,2);\n-                                                   ^\n-rt: ---\n-rt: f00e:main:main:                   upcall fail 'explicit failure', src/comp/syntax/parse/parser.rs:112\n-rt: f00e:main:                        domain main @0xa73404c root task failed\n+// xfail-stage0\n+// xfail-stage1\n+// xfail-stage2\n+// xfail-stage3\n+fn main() {\n+  let vec[int] v = [1,2,3,4,5];\n+  auto v2 = v.(1,2);\n+  assert (v2.(0) == 2);\n+  assert (v2.(1) == 3);\n+}\n\\ No newline at end of file"}, {"sha": "2b4da0cdf6bb628c021773b82c9361f09afb51bc", "filename": "src/test/stdtest/deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fstdtest%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fstdtest%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fdeque.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -178,7 +178,7 @@ fn test() {\n                               two(17, 42));\n     /*\n      * FIXME: Segfault.  Also appears to be caused only after upcall_grow_task\n-    \n+\n     log \"*** test parameterized: taggypar[int]\";\n     let eqfn[taggypar[int]] eq4 = taggypareq[int];\n     test_parameterized[taggypar[int]](eq4,\n@@ -187,7 +187,7 @@ fn test() {\n                                       threepar[int](1, 2, 3),\n                                       twopar[int](17, 42));\n     log \"*** end test parameterized: taggypar[int]\";\n-    \n+\n      */\n \n     log \"*** test parameterized: reccy\";"}, {"sha": "0031f338f1f6b677cf1b388881aabdfa95ad5e25", "filename": "src/test/stdtest/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fstdtest%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2a7bff7faf040b1eced0ee3547b28f6962cedc/src%2Ftest%2Fstdtest%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fmap.rs?ref=6e2a7bff7faf040b1eced0ee3547b28f6962cedc", "patch": "@@ -197,15 +197,15 @@ fn test_removal() {\n         /**\n          * FIXME (issue #150): we want to check the removed value as in the\n          * following:\n-        \n+\n         let util.option[uint] v = hm.remove(i);\n         alt (v) {\n           case (util.some[uint](u)) {\n             assert (u == (i * i));\n           }\n           case (util.none[uint]()) { fail; }\n         }\n-        \n+\n          * but we util.option is a tag type so util.some and util.none are\n          * off limits until we parse the dwarf for tag types.\n          */"}]}