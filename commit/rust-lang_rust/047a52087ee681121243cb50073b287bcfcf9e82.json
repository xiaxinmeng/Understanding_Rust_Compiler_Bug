{"sha": "047a52087ee681121243cb50073b287bcfcf9e82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0N2E1MjA4N2VlNjgxMTIxMjQzY2I1MDA3M2IyODdiY2ZjZjllODI=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-03-12T03:25:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-12T03:25:12Z"}, "message": "Merge pull request #2528 from topecongiro/rfc/trait-impl-where\n\nImplement RFC style for trait", "tree": {"sha": "e19b478ba265068fd70958b0ad9b833c4ee1a45e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e19b478ba265068fd70958b0ad9b833c4ee1a45e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/047a52087ee681121243cb50073b287bcfcf9e82", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJapfMYCRBK7hj4Ov3rIwAAdHIIAB+Lr+uDuSMPrHh0zrpUzTNY\nTl0UvKYWtbRnogx9GjAxBqZkuwsKENfYwM1YMjV8f0q7td3jT+G9f7pPDuKYanid\nK6+LYCAbSrfbqbnONOWdqjppTVVnHeIMYRd2A2R5XCrm2RNOC9hCrtwzZn8QG9FB\nqWDk+dCLWikSKVjaxPTVfY1zI/Aa/mvOlqx9pZXLCMn1sVJ+gsMszb2PxHE1Kaqj\nZGkGCqJCIc3HSW4fncWA7si5rEn240BAi8doe87e3vKFBPLjZEmN1gx7+ISYe6tZ\nVd8KULz3SWwYgZgpU5KdaQT38w18U0DKX3Q2oO8psMGFfEAdA6CVw1+4Z97fYR4=\n=yAJH\n-----END PGP SIGNATURE-----\n", "payload": "tree e19b478ba265068fd70958b0ad9b833c4ee1a45e\nparent f5ebcd922e2ef64ea6df17fa86e921304c88ca3c\nparent 182b46e0ed29621f4cd29f39b8dd82f5a9b63e3f\nauthor Nick Cameron <nrc@ncameron.org> 1520825112 +1300\ncommitter GitHub <noreply@github.com> 1520825112 +1300\n\nMerge pull request #2528 from topecongiro/rfc/trait-impl-where\n\nImplement RFC style for trait"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/047a52087ee681121243cb50073b287bcfcf9e82", "html_url": "https://github.com/rust-lang/rust/commit/047a52087ee681121243cb50073b287bcfcf9e82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/047a52087ee681121243cb50073b287bcfcf9e82/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5ebcd922e2ef64ea6df17fa86e921304c88ca3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5ebcd922e2ef64ea6df17fa86e921304c88ca3c", "html_url": "https://github.com/rust-lang/rust/commit/f5ebcd922e2ef64ea6df17fa86e921304c88ca3c"}, {"sha": "182b46e0ed29621f4cd29f39b8dd82f5a9b63e3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/182b46e0ed29621f4cd29f39b8dd82f5a9b63e3f", "html_url": "https://github.com/rust-lang/rust/commit/182b46e0ed29621f4cd29f39b8dd82f5a9b63e3f"}], "stats": {"total": 398, "additions": 225, "deletions": 173}, "files": [{"sha": "0e6b8f1bc1e39b04c5e09f8dec7c5304fee7b3ce", "filename": "src/expr.rs", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/047a52087ee681121243cb50073b287bcfcf9e82/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/047a52087ee681121243cb50073b287bcfcf9e82/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=047a52087ee681121243cb50073b287bcfcf9e82", "patch": "@@ -1698,7 +1698,8 @@ fn rewrite_match_body(\n     );\n     match (orig_body, next_line_body) {\n         (Some(ref orig_str), Some(ref next_line_str))\n-            if forbid_same_line || prefer_next_line(orig_str, next_line_str) =>\n+            if forbid_same_line\n+                || prefer_next_line(orig_str, next_line_str, RhsTactics::Default) =>\n         {\n             combine_next_line_body(next_line_str)\n         }\n@@ -2514,13 +2515,32 @@ fn rewrite_assignment(\n     rewrite_assign_rhs(context, lhs_str, rhs, shape)\n }\n \n+/// Controls where to put the rhs.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum RhsTactics {\n+    /// Use heuristics.\n+    Default,\n+    /// Put the rhs on the next line if it uses multiple line.\n+    ForceNextLine,\n+}\n+\n // The left hand side must contain everything up to, and including, the\n // assignment operator.\n pub fn rewrite_assign_rhs<S: Into<String>, R: Rewrite>(\n     context: &RewriteContext,\n     lhs: S,\n     ex: &R,\n     shape: Shape,\n+) -> Option<String> {\n+    rewrite_assign_rhs_with(context, lhs, ex, shape, RhsTactics::Default)\n+}\n+\n+pub fn rewrite_assign_rhs_with<S: Into<String>, R: Rewrite>(\n+    context: &RewriteContext,\n+    lhs: S,\n+    ex: &R,\n+    shape: Shape,\n+    rhs_tactics: RhsTactics,\n ) -> Option<String> {\n     let lhs = lhs.into();\n     let last_line_width = last_line_width(&lhs)\n@@ -2536,15 +2556,22 @@ pub fn rewrite_assign_rhs<S: Into<String>, R: Rewrite>(\n         offset: shape.offset + last_line_width + 1,\n         ..shape\n     });\n-    let rhs = choose_rhs(context, ex, orig_shape, ex.rewrite(context, orig_shape))?;\n+    let rhs = choose_rhs(\n+        context,\n+        ex,\n+        orig_shape,\n+        ex.rewrite(context, orig_shape),\n+        rhs_tactics,\n+    )?;\n     Some(lhs + &rhs)\n }\n \n-pub fn choose_rhs<R: Rewrite>(\n+fn choose_rhs<R: Rewrite>(\n     context: &RewriteContext,\n     expr: &R,\n     shape: Shape,\n     orig_rhs: Option<String>,\n+    rhs_tactics: RhsTactics,\n ) -> Option<String> {\n     match orig_rhs {\n         Some(ref new_str) if !new_str.contains('\\n') && new_str.len() <= shape.width => {\n@@ -2566,7 +2593,9 @@ pub fn choose_rhs<R: Rewrite>(\n                 {\n                     Some(format!(\" {}\", orig_rhs))\n                 }\n-                (Some(ref orig_rhs), Some(ref new_rhs)) if prefer_next_line(orig_rhs, new_rhs) => {\n+                (Some(ref orig_rhs), Some(ref new_rhs))\n+                    if prefer_next_line(orig_rhs, new_rhs, rhs_tactics) =>\n+                {\n                     Some(format!(\"{}{}\", new_indent_str, new_rhs))\n                 }\n                 (None, Some(ref new_rhs)) => Some(format!(\"{}{}\", new_indent_str, new_rhs)),\n@@ -2577,8 +2606,9 @@ pub fn choose_rhs<R: Rewrite>(\n     }\n }\n \n-fn prefer_next_line(orig_rhs: &str, next_line_rhs: &str) -> bool {\n-    !next_line_rhs.contains('\\n') || count_newlines(orig_rhs) > count_newlines(next_line_rhs) + 1\n+fn prefer_next_line(orig_rhs: &str, next_line_rhs: &str, rhs_tactics: RhsTactics) -> bool {\n+    rhs_tactics == RhsTactics::ForceNextLine || !next_line_rhs.contains('\\n')\n+        || count_newlines(orig_rhs) > count_newlines(next_line_rhs) + 1\n }\n \n fn rewrite_expr_addrof("}, {"sha": "b639697194b7a5f68ca04e669602d2bb1cffcb90", "filename": "src/items.rs", "status": "modified", "additions": 54, "deletions": 75, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/047a52087ee681121243cb50073b287bcfcf9e82/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/047a52087ee681121243cb50073b287bcfcf9e82/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=047a52087ee681121243cb50073b287bcfcf9e82", "patch": "@@ -23,13 +23,14 @@ use codemap::{LineRangeUtils, SpanUtils};\n use comment::{combine_strs_with_missing_comments, contains_comment, recover_comment_removed,\n               recover_missing_comment_in_span, rewrite_missing_comment, FindUncommented};\n use config::{BraceStyle, Config, Density, IndentStyle};\n-use expr::{format_expr, is_empty_block, is_simple_block_stmt, rewrite_assign_rhs, ExprType};\n+use expr::{format_expr, is_empty_block, is_simple_block_stmt, rewrite_assign_rhs,\n+           rewrite_assign_rhs_with, ExprType, RhsTactics};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator};\n use rewrite::{Rewrite, RewriteContext};\n use overflow;\n use shape::{Indent, Shape};\n use spanned::Spanned;\n-use types::join_bounds;\n+use types::TraitTyParamBounds;\n use utils::{colon_spaces, contains_skip, first_line_width, format_abi, format_constness,\n             format_defaultness, format_mutability, format_unsafety, format_visibility,\n             is_attributes_extendable, last_line_contains_single_line_comment,\n@@ -919,60 +920,55 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n                 return None;\n             }\n         }\n-        let trait_bound_str = rewrite_trait_bounds(\n-            context,\n-            type_param_bounds,\n-            Shape::indented(offset, context.config),\n-        )?;\n-        // If the trait, generics, and trait bound cannot fit on the same line,\n-        // put the trait bounds on an indented new line\n-        if offset.width() + last_line_width(&result) + trait_bound_str.len()\n-            > context.config.comment_width()\n-        {\n-            let trait_indent = offset.block_only().block_indent(context.config);\n-            result.push_str(&trait_indent.to_string_with_newline(context.config));\n+        if !type_param_bounds.is_empty() {\n+            result = rewrite_assign_rhs_with(\n+                context,\n+                result + \":\",\n+                &TraitTyParamBounds::new(type_param_bounds),\n+                shape,\n+                RhsTactics::ForceNextLine,\n+            )?;\n         }\n-        result.push_str(&trait_bound_str);\n \n-        let where_density =\n-            if context.config.indent_style() == IndentStyle::Block && result.is_empty() {\n+        // Rewrite where clause.\n+        if !generics.where_clause.predicates.is_empty() {\n+            let where_density = if context.config.indent_style() == IndentStyle::Block {\n                 Density::Compressed\n             } else {\n                 Density::Tall\n             };\n \n-        let where_budget = context.budget(last_line_width(&result));\n-        let pos_before_where = if type_param_bounds.is_empty() {\n-            generics.where_clause.span.lo()\n+            let where_budget = context.budget(last_line_width(&result));\n+            let pos_before_where = if type_param_bounds.is_empty() {\n+                generics.where_clause.span.lo()\n+            } else {\n+                type_param_bounds[type_param_bounds.len() - 1].span().hi()\n+            };\n+            let option = WhereClauseOption::snuggled(&generics_str);\n+            let where_clause_str = rewrite_where_clause(\n+                context,\n+                &generics.where_clause,\n+                context.config.brace_style(),\n+                Shape::legacy(where_budget, offset.block_only()),\n+                where_density,\n+                \"{\",\n+                None,\n+                pos_before_where,\n+                option,\n+                false,\n+            )?;\n+            // If the where clause cannot fit on the same line,\n+            // put the where clause on a new line\n+            if !where_clause_str.contains('\\n')\n+                && last_line_width(&result) + where_clause_str.len() + offset.width()\n+                    > context.config.comment_width()\n+            {\n+                let width = offset.block_indent + context.config.tab_spaces() - 1;\n+                let where_indent = Indent::new(0, width);\n+                result.push_str(&where_indent.to_string_with_newline(context.config));\n+            }\n+            result.push_str(&where_clause_str);\n         } else {\n-            type_param_bounds[type_param_bounds.len() - 1].span().hi()\n-        };\n-        let option = WhereClauseOption::snuggled(&generics_str);\n-        let where_clause_str = rewrite_where_clause(\n-            context,\n-            &generics.where_clause,\n-            context.config.brace_style(),\n-            Shape::legacy(where_budget, offset.block_only()),\n-            where_density,\n-            \"{\",\n-            None,\n-            pos_before_where,\n-            option,\n-            false,\n-        )?;\n-        // If the where clause cannot fit on the same line,\n-        // put the where clause on a new line\n-        if !where_clause_str.contains('\\n')\n-            && last_line_width(&result) + where_clause_str.len() + offset.width()\n-                > context.config.comment_width()\n-        {\n-            let width = offset.block_indent + context.config.tab_spaces() - 1;\n-            let where_indent = Indent::new(0, width);\n-            result.push_str(&where_indent.to_string_with_newline(context.config));\n-        }\n-        result.push_str(&where_clause_str);\n-\n-        if generics.where_clause.predicates.is_empty() {\n             let item_snippet = context.snippet(item.span);\n             if let Some(lo) = item_snippet.chars().position(|c| c == '/') {\n                 // 1 = `{`\n@@ -995,16 +991,18 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         }\n \n         match context.config.brace_style() {\n-            _ if last_line_contains_single_line_comment(&result) => {\n+            _ if last_line_contains_single_line_comment(&result)\n+                || last_line_width(&result) + 2 > context.budget(offset.width()) =>\n+            {\n                 result.push_str(&offset.to_string_with_newline(context.config));\n             }\n             BraceStyle::AlwaysNextLine => {\n                 result.push_str(&offset.to_string_with_newline(context.config));\n             }\n             BraceStyle::PreferSameLine => result.push(' '),\n             BraceStyle::SameLineWhere => {\n-                if !where_clause_str.is_empty()\n-                    && (!trait_items.is_empty() || result.contains('\\n'))\n+                if result.contains('\\n')\n+                    || (!generics.where_clause.predicates.is_empty() && !trait_items.is_empty())\n                 {\n                     result.push_str(&offset.to_string_with_newline(context.config));\n                 } else {\n@@ -1585,16 +1583,12 @@ pub fn rewrite_associated_type(\n     let prefix = format!(\"type {}\", ident);\n \n     let type_bounds_str = if let Some(bounds) = ty_param_bounds_opt {\n-        // 2 = \": \".len()\n-        let shape = Shape::indented(indent, context.config).offset_left(prefix.len() + 2)?;\n-        let bound_str = bounds\n-            .iter()\n-            .map(|ty_bound| ty_bound.rewrite(context, shape))\n-            .collect::<Option<Vec<_>>>()?;\n-        if !bounds.is_empty() {\n-            format!(\": {}\", join_bounds(context, shape, &bound_str))\n-        } else {\n+        if bounds.is_empty() {\n             String::new()\n+        } else {\n+            // 2 = \": \".len()\n+            let shape = Shape::indented(indent, context.config).offset_left(prefix.len() + 2)?;\n+            bounds.rewrite(context, shape).map(|s| format!(\": {}\", s))?\n         }\n     } else {\n         String::new()\n@@ -2329,21 +2323,6 @@ pub fn generics_shape_from_config(config: &Config, shape: Shape, offset: usize)\n     }\n }\n \n-fn rewrite_trait_bounds(\n-    context: &RewriteContext,\n-    bounds: &[ast::TyParamBound],\n-    shape: Shape,\n-) -> Option<String> {\n-    if bounds.is_empty() {\n-        return Some(String::new());\n-    }\n-    let bound_str = bounds\n-        .iter()\n-        .map(|ty_bound| ty_bound.rewrite(context, shape))\n-        .collect::<Option<Vec<_>>>()?;\n-    Some(format!(\": {}\", join_bounds(context, shape, &bound_str)))\n-}\n-\n fn rewrite_where_clause_rfc_style(\n     context: &RewriteContext,\n     where_clause: &ast::WhereClause,"}, {"sha": "676095ff4ce4c75968ba6c4f942624df1d27dd31", "filename": "src/types.rs", "status": "modified", "additions": 63, "deletions": 69, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/047a52087ee681121243cb50073b287bcfcf9e82/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/047a52087ee681121243cb50073b287bcfcf9e82/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=047a52087ee681121243cb50073b287bcfcf9e82", "patch": "@@ -18,7 +18,8 @@ use syntax::symbol::keywords;\n \n use codemap::SpanUtils;\n use config::{IndentStyle, TypeDensity};\n-use expr::{rewrite_pair, rewrite_tuple, rewrite_unary_prefix, PairParts, ToExpr};\n+use expr::{rewrite_assign_rhs, rewrite_pair, rewrite_tuple, rewrite_unary_prefix, PairParts,\n+           ToExpr};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, Separator};\n use macros::{rewrite_macro, MacroPosition};\n use overflow;\n@@ -431,64 +432,35 @@ impl Rewrite for ast::WherePredicate {\n                 ..\n             }) => {\n                 let type_str = bounded_ty.rewrite(context, shape)?;\n-\n-                let colon = type_bound_colon(context);\n-\n-                if let Some(lifetime_str) =\n+                let colon = type_bound_colon(context).trim_right();\n+                let lhs = if let Some(lifetime_str) =\n                     rewrite_lifetime_param(context, shape, bound_generic_params)\n                 {\n-                    // 6 = \"for<> \".len()\n-                    let used_width = lifetime_str.len() + type_str.len() + colon.len() + 6;\n-                    let ty_shape = shape.offset_left(used_width)?;\n-                    let bounds = bounds\n-                        .iter()\n-                        .map(|ty_bound| ty_bound.rewrite(context, ty_shape))\n-                        .collect::<Option<Vec<_>>>()?;\n-                    let bounds_str = join_bounds(context, ty_shape, &bounds);\n-\n                     if context.config.spaces_within_parens_and_brackets()\n                         && !lifetime_str.is_empty()\n                     {\n-                        format!(\n-                            \"for< {} > {}{}{}\",\n-                            lifetime_str, type_str, colon, bounds_str\n-                        )\n+                        format!(\"for< {} > {}{}\", lifetime_str, type_str, colon)\n                     } else {\n-                        format!(\"for<{}> {}{}{}\", lifetime_str, type_str, colon, bounds_str)\n+                        format!(\"for<{}> {}{}\", lifetime_str, type_str, colon)\n                     }\n                 } else {\n-                    let used_width = type_str.len() + colon.len();\n-                    let ty_shape = match context.config.indent_style() {\n-                        IndentStyle::Visual => shape.block_left(used_width)?,\n-                        IndentStyle::Block => shape,\n-                    };\n-                    let bounds = bounds\n-                        .iter()\n-                        .map(|ty_bound| ty_bound.rewrite(context, ty_shape))\n-                        .collect::<Option<Vec<_>>>()?;\n-                    let overhead = type_str.len() + colon.len();\n-                    let bounds_str = join_bounds(context, ty_shape.sub_width(overhead)?, &bounds);\n-\n-                    format!(\"{}{}{}\", type_str, colon, bounds_str)\n-                }\n+                    format!(\"{}{}\", type_str, colon)\n+                };\n+\n+                rewrite_assign_rhs(context, lhs, bounds, shape)?\n             }\n             ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate {\n                 ref lifetime,\n                 ref bounds,\n                 ..\n-            }) => rewrite_bounded_lifetime(lifetime, bounds.iter(), context, shape)?,\n+            }) => rewrite_bounded_lifetime(lifetime, bounds, context, shape)?,\n             ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n                 ref lhs_ty,\n                 ref rhs_ty,\n                 ..\n             }) => {\n-                let lhs_ty_str = lhs_ty.rewrite(context, shape)?;\n-                // 3 = \" = \".len()\n-                let used_width = 3 + lhs_ty_str.len();\n-                let budget = shape.width.checked_sub(used_width)?;\n-                let rhs_ty_str =\n-                    rhs_ty.rewrite(context, Shape::legacy(budget, shape.indent + used_width))?;\n-                format!(\"{} = {}\", lhs_ty_str, rhs_ty_str)\n+                let lhs_ty_str = lhs_ty.rewrite(context, shape).map(|lhs| lhs + \" =\")?;\n+                rewrite_assign_rhs(context, lhs_ty_str, &**rhs_ty, shape)?\n             }\n         };\n \n@@ -498,35 +470,28 @@ impl Rewrite for ast::WherePredicate {\n \n impl Rewrite for ast::LifetimeDef {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        rewrite_bounded_lifetime(&self.lifetime, self.bounds.iter(), context, shape)\n+        rewrite_bounded_lifetime(&self.lifetime, &self.bounds, context, shape)\n     }\n }\n \n-fn rewrite_bounded_lifetime<'b, I>(\n+fn rewrite_bounded_lifetime(\n     lt: &ast::Lifetime,\n-    bounds: I,\n+    bounds: &[ast::Lifetime],\n     context: &RewriteContext,\n     shape: Shape,\n-) -> Option<String>\n-where\n-    I: ExactSizeIterator<Item = &'b ast::Lifetime>,\n-{\n+) -> Option<String> {\n     let result = lt.rewrite(context, shape)?;\n \n     if bounds.len() == 0 {\n         Some(result)\n     } else {\n-        let appendix = bounds\n-            .into_iter()\n-            .map(|b| b.rewrite(context, shape))\n-            .collect::<Option<Vec<_>>>()?;\n         let colon = type_bound_colon(context);\n         let overhead = last_line_width(&result) + colon.len();\n         let result = format!(\n             \"{}{}{}\",\n             result,\n             colon,\n-            join_bounds(context, shape.sub_width(overhead)?, &appendix)\n+            join_bounds(context, shape.sub_width(overhead)?, bounds, true)?\n         );\n         Some(result)\n     }\n@@ -552,12 +517,21 @@ impl Rewrite for ast::Lifetime {\n     }\n }\n \n+/// A simple wrapper over type param bounds in trait.\n+#[derive(new)]\n+pub struct TraitTyParamBounds<'a> {\n+    inner: &'a ast::TyParamBounds,\n+}\n+\n+impl<'a> Rewrite for TraitTyParamBounds<'a> {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        join_bounds(context, shape, self.inner, false)\n+    }\n+}\n+\n impl Rewrite for ast::TyParamBounds {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        let strs = self.iter()\n-            .map(|b| b.rewrite(context, shape))\n-            .collect::<Option<Vec<_>>>()?;\n-        Some(join_bounds(context, shape, &strs))\n+        join_bounds(context, shape, self, true)\n     }\n }\n \n@@ -572,11 +546,7 @@ impl Rewrite for ast::TyParam {\n         result.push_str(&self.ident.to_string());\n         if !self.bounds.is_empty() {\n             result.push_str(type_bound_colon(context));\n-            let strs = self.bounds\n-                .iter()\n-                .map(|ty_bound| ty_bound.rewrite(context, shape))\n-                .collect::<Option<Vec<_>>>()?;\n-            result.push_str(&join_bounds(context, shape, &strs));\n+            result.push_str(&self.bounds.rewrite(context, shape)?)\n         }\n         if let Some(ref def) = self.default {\n             let eq_str = match context.config.type_punctuation_density() {\n@@ -794,20 +764,44 @@ fn rewrite_bare_fn(\n     Some(result)\n }\n \n-pub fn join_bounds(context: &RewriteContext, shape: Shape, type_strs: &[String]) -> String {\n+fn join_bounds<T>(\n+    context: &RewriteContext,\n+    shape: Shape,\n+    items: &[T],\n+    need_indent: bool,\n+) -> Option<String>\n+where\n+    T: Rewrite,\n+{\n     // Try to join types in a single line\n     let joiner = match context.config.type_punctuation_density() {\n         TypeDensity::Compressed => \"+\",\n         TypeDensity::Wide => \" + \",\n     };\n+    let type_strs = items\n+        .iter()\n+        .map(|item| item.rewrite(context, shape))\n+        .collect::<Option<Vec<_>>>()?;\n     let result = type_strs.join(joiner);\n-    if result.contains('\\n') || result.len() > shape.width {\n-        let joiner_indent = shape.indent.block_indent(context.config);\n-        let joiner = format!(\"{}+ \", joiner_indent.to_string_with_newline(context.config));\n-        type_strs.join(&joiner)\n-    } else {\n-        result\n+    if items.len() == 1 || (!result.contains('\\n') && result.len() <= shape.width) {\n+        return Some(result);\n     }\n+\n+    // We need to use multiple lines.\n+    let (type_strs, offset) = if need_indent {\n+        // Rewrite with additional indentation.\n+        let nested_shape = shape.block_indent(context.config.tab_spaces());\n+        let type_strs = items\n+            .iter()\n+            .map(|item| item.rewrite(context, nested_shape))\n+            .collect::<Option<Vec<_>>>()?;\n+        (type_strs, nested_shape.indent)\n+    } else {\n+        (type_strs, shape.indent)\n+    };\n+\n+    let joiner = format!(\"{}+ \", offset.to_string_with_newline(context.config));\n+    Some(type_strs.join(&joiner))\n }\n \n pub fn can_be_overflowed_type(context: &RewriteContext, ty: &ast::Ty, len: usize) -> bool {"}, {"sha": "94a927580f6a9500c766dee07fbcf37cd6b69a28", "filename": "tests/source/issue-2506.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/047a52087ee681121243cb50073b287bcfcf9e82/tests%2Fsource%2Fissue-2506.rs", "raw_url": "https://github.com/rust-lang/rust/raw/047a52087ee681121243cb50073b287bcfcf9e82/tests%2Fsource%2Fissue-2506.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-2506.rs?ref=047a52087ee681121243cb50073b287bcfcf9e82", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     fn f1(a: Box<dyn MyTrait>) {}\n \n     // checks if line wrap works correctly\n-    trait Very_______________________Long__________________Name____________________Trait {\n+    trait Very_______________________Long__________________Name_______________________________Trait {\n         fn method(&self) -> u64;\n     }\n "}, {"sha": "d915fccf1a0f1cb370d8950533cdd548b2b7c4ed", "filename": "tests/source/where-clause-rfc.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/047a52087ee681121243cb50073b287bcfcf9e82/tests%2Fsource%2Fwhere-clause-rfc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/047a52087ee681121243cb50073b287bcfcf9e82/tests%2Fsource%2Fwhere-clause-rfc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fwhere-clause-rfc.rs?ref=047a52087ee681121243cb50073b287bcfcf9e82", "patch": "@@ -56,3 +56,20 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // ...\n     }\n }\n+\n+// #2497\n+fn handle_update<'a, Tab, Conn, R, C>(executor: &Executor<PooledConnection<ConnectionManager<Conn>>>, change_set: &'a C) -> ExecutionResult\n+where &'a C: Identifiable + AsChangeset<Target = Tab> + HasTable<Table = Tab>,\n+      <&'a C as AsChangeset>::Changeset: QueryFragment<Conn::Backend>,\n+      Tab: Table + HasTable<Table = Tab>,\n+      Tab::PrimaryKey: EqAll<<&'a C as Identifiable>::Id>,\n+      Tab::FromClause: QueryFragment<Conn::Backend>,\n+      Tab: FindDsl<<&'a C as Identifiable>::Id>,\n+      Find<Tab, <&'a C as Identifiable>::Id>: IntoUpdateTarget<Table = Tab>,\n+      <Find<Tab, <&'a C as Identifiable>::Id> as IntoUpdateTarget>::WhereClause: QueryFragment<Conn::Backend>,\n+      Tab::Query: FilterDsl<<Tab::PrimaryKey as EqAll<<&'a C as Identifiable>::Id>>::Output>,\n+      Filter<Tab::Query, <Tab::PrimaryKey as EqAll<<&'a C as Identifiable>::Id>>::Output>: LimitDsl,\n+      Limit<Filter<Tab::Query, <Tab::PrimaryKey as EqAll<<&'a C as Identifiable>::Id>>::Output>>: QueryDsl + BoxedDsl< 'a, Conn::Backend, Output = BoxedSelectStatement<'a, R::SqlType, Tab, Conn::Backend>>,\n+      R: LoadingHandler<Conn, Table = Tab, SqlType = Tab::SqlType> + GraphQLType<TypeInfo = (), Context = ()>, {\n+    unimplemented!()\n+}"}, {"sha": "2175b5d7bd9d315a018dc4f30387e6262a5d332b", "filename": "tests/target/impls.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/047a52087ee681121243cb50073b287bcfcf9e82/tests%2Ftarget%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/047a52087ee681121243cb50073b287bcfcf9e82/tests%2Ftarget%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimpls.rs?ref=047a52087ee681121243cb50073b287bcfcf9e82", "patch": "@@ -174,23 +174,24 @@ impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n }\n \n // #1168\n-pub trait Number\n-    : Copy\n+pub trait Number:\n+    Copy\n     + Eq\n     + Not<Output = Self>\n     + Shl<u8, Output = Self>\n     + Shr<u8, Output = Self>\n     + BitAnd<Self, Output = Self>\n     + BitOr<Self, Output = Self>\n     + BitAndAssign\n-    + BitOrAssign {\n+    + BitOrAssign\n+{\n     // test\n     fn zero() -> Self;\n }\n \n // #1642\n-pub trait SomeTrait\n-    : Clone\n+pub trait SomeTrait:\n+    Clone\n     + Eq\n     + PartialEq\n     + Ord\n@@ -201,7 +202,8 @@ pub trait SomeTrait\n     + Display\n     + Write\n     + Read\n-    + FromStr {\n+    + FromStr\n+{\n     // comment\n }\n "}, {"sha": "1e1971db85f6a8b6cf7d76c5a13c07d8f5e39328", "filename": "tests/target/issue-2506.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/047a52087ee681121243cb50073b287bcfcf9e82/tests%2Ftarget%2Fissue-2506.rs", "raw_url": "https://github.com/rust-lang/rust/raw/047a52087ee681121243cb50073b287bcfcf9e82/tests%2Ftarget%2Fissue-2506.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-2506.rs?ref=047a52087ee681121243cb50073b287bcfcf9e82", "patch": "@@ -7,8 +7,8 @@ fn main() {\n     fn f1(a: Box<dyn MyTrait>) {}\n \n     // checks if line wrap works correctly\n-    trait Very_______________________Long__________________Name____________________Trait\n-         {\n+    trait Very_______________________Long__________________Name_______________________________Trait\n+    {\n         fn method(&self) -> u64;\n     }\n "}, {"sha": "d1ee43f4e3f16158cf797a68ed104a718b532daa", "filename": "tests/target/trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/047a52087ee681121243cb50073b287bcfcf9e82/tests%2Ftarget%2Ftrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/047a52087ee681121243cb50073b287bcfcf9e82/tests%2Ftarget%2Ftrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ftrait.rs?ref=047a52087ee681121243cb50073b287bcfcf9e82", "patch": "@@ -65,8 +65,7 @@ where\n {\n }\n \n-trait FooBar<T>\n-    : Tttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt\n+trait FooBar<T>: Tttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt\n where\n     J: Bar,\n {\n@@ -106,7 +105,8 @@ trait MyTrait<\n     BBBBBBBBBBBBBBBBBBBB,\n     CCCCCCCCCCCCCCCCCCCC,\n     DDDDDDDDDDDDDDDDDDDD,\n-> {\n+>\n+{\n     fn foo() {}\n }\n "}, {"sha": "a41d82c8e4179da431c8606a7dcb878e87c3ed1f", "filename": "tests/target/where-clause-rfc.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/047a52087ee681121243cb50073b287bcfcf9e82/tests%2Ftarget%2Fwhere-clause-rfc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/047a52087ee681121243cb50073b287bcfcf9e82/tests%2Ftarget%2Fwhere-clause-rfc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fwhere-clause-rfc.rs?ref=047a52087ee681121243cb50073b287bcfcf9e82", "patch": "@@ -126,3 +126,33 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // ...\n     }\n }\n+\n+// #2497\n+fn handle_update<'a, Tab, Conn, R, C>(\n+    executor: &Executor<PooledConnection<ConnectionManager<Conn>>>,\n+    change_set: &'a C,\n+) -> ExecutionResult\n+where\n+    &'a C: Identifiable + AsChangeset<Target = Tab> + HasTable<Table = Tab>,\n+    <&'a C as AsChangeset>::Changeset: QueryFragment<Conn::Backend>,\n+    Tab: Table + HasTable<Table = Tab>,\n+    Tab::PrimaryKey: EqAll<<&'a C as Identifiable>::Id>,\n+    Tab::FromClause: QueryFragment<Conn::Backend>,\n+    Tab: FindDsl<<&'a C as Identifiable>::Id>,\n+    Find<Tab, <&'a C as Identifiable>::Id>: IntoUpdateTarget<Table = Tab>,\n+    <Find<Tab, <&'a C as Identifiable>::Id> as IntoUpdateTarget>::WhereClause:\n+        QueryFragment<Conn::Backend>,\n+    Tab::Query: FilterDsl<<Tab::PrimaryKey as EqAll<<&'a C as Identifiable>::Id>>::Output>,\n+    Filter<Tab::Query, <Tab::PrimaryKey as EqAll<<&'a C as Identifiable>::Id>>::Output>: LimitDsl,\n+    Limit<Filter<Tab::Query, <Tab::PrimaryKey as EqAll<<&'a C as Identifiable>::Id>>::Output>>:\n+        QueryDsl\n+            + BoxedDsl<\n+                'a,\n+                Conn::Backend,\n+                Output = BoxedSelectStatement<'a, R::SqlType, Tab, Conn::Backend>,\n+            >,\n+    R: LoadingHandler<Conn, Table = Tab, SqlType = Tab::SqlType>\n+        + GraphQLType<TypeInfo = (), Context = ()>,\n+{\n+    unimplemented!()\n+}"}, {"sha": "eb2f8d5e6e81ec47badcc0a62f16e5b4dbf51c54", "filename": "tests/target/where-clause.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/047a52087ee681121243cb50073b287bcfcf9e82/tests%2Ftarget%2Fwhere-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/047a52087ee681121243cb50073b287bcfcf9e82/tests%2Ftarget%2Fwhere-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fwhere-clause.rs?ref=047a52087ee681121243cb50073b287bcfcf9e82", "patch": "@@ -81,17 +81,17 @@ struct AlwaysOnNextLine<LongLongTypename, LongTypename, A, B, C, D, E, F>\n \n pub trait SomeTrait<T>\n     where T: Something\n-                 + Sync\n-                 + Send\n-                 + Display\n-                 + Debug\n-                 + Copy\n-                 + Hash\n-                 + Debug\n-                 + Display\n-                 + Write\n-                 + Read\n-                 + FromStr\n+              + Sync\n+              + Send\n+              + Display\n+              + Debug\n+              + Copy\n+              + Hash\n+              + Debug\n+              + Display\n+              + Write\n+              + Read\n+              + FromStr\n {\n }\n "}]}