{"sha": "927a5e393ccb68fc7166f7737459dad42d5e50ca", "node_id": "C_kwDOAAsO6NoAKDkyN2E1ZTM5M2NjYjY4ZmM3MTY2Zjc3Mzc0NTlkYWQ0MmQ1ZTUwY2E", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-12-03T21:34:46Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-12-03T22:05:41Z"}, "message": "Remove a Clean impl for a tuple (3)", "tree": {"sha": "5ccc22c1fb58568e017adb73154abaa52190b5f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ccc22c1fb58568e017adb73154abaa52190b5f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/927a5e393ccb68fc7166f7737459dad42d5e50ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/927a5e393ccb68fc7166f7737459dad42d5e50ca", "html_url": "https://github.com/rust-lang/rust/commit/927a5e393ccb68fc7166f7737459dad42d5e50ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/927a5e393ccb68fc7166f7737459dad42d5e50ca/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63d434a36334c10851e72172484c32abf98533c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/63d434a36334c10851e72172484c32abf98533c2", "html_url": "https://github.com/rust-lang/rust/commit/63d434a36334c10851e72172484c32abf98533c2"}], "stats": {"total": 337, "additions": 172, "deletions": 165}, "files": [{"sha": "7b66ff7d4113674a20e8e3da3cef6d2aad27c799", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/927a5e393ccb68fc7166f7737459dad42d5e50ca/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927a5e393ccb68fc7166f7737459dad42d5e50ca/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=927a5e393ccb68fc7166f7737459dad42d5e50ca", "patch": "@@ -100,9 +100,12 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 // Instead, we generate `impl !Send for Foo<T>`, which better\n                 // expresses the fact that `Foo<T>` never implements `Send`,\n                 // regardless of the choice of `T`.\n-                let params = (tcx.generics_of(item_def_id), ty::GenericPredicates::default())\n-                    .clean(self.cx)\n-                    .params;\n+                let raw_generics = clean_ty_generics(\n+                    self.cx,\n+                    tcx.generics_of(item_def_id),\n+                    ty::GenericPredicates::default(),\n+                );\n+                let params = raw_generics.params;\n \n                 Generics { params, where_predicates: Vec::new() }\n             }\n@@ -451,10 +454,12 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             })\n             .map(|p| p.fold_with(&mut replacer));\n \n-        let mut generic_params =\n-            (tcx.generics_of(item_def_id), tcx.explicit_predicates_of(item_def_id))\n-                .clean(self.cx)\n-                .params;\n+        let raw_generics = clean_ty_generics(\n+            self.cx,\n+            tcx.generics_of(item_def_id),\n+            tcx.explicit_predicates_of(item_def_id),\n+        );\n+        let mut generic_params = raw_generics.params;\n \n         debug!(\"param_env_to_generics({:?}): generic_params={:?}\", item_def_id, generic_params);\n "}, {"sha": "80e3bb5c6624f99f611f09646545cddc9e7703c1", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/927a5e393ccb68fc7166f7737459dad42d5e50ca/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927a5e393ccb68fc7166f7737459dad42d5e50ca/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=927a5e393ccb68fc7166f7737459dad42d5e50ca", "patch": "@@ -107,11 +107,11 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                     def_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n                     kind: box ImplItem(Impl {\n                         unsafety: hir::Unsafety::Normal,\n-                        generics: (\n+                        generics: clean_ty_generics(\n+                            self.cx,\n                             self.cx.tcx.generics_of(impl_def_id),\n                             self.cx.tcx.explicit_predicates_of(impl_def_id),\n-                        )\n-                            .clean(self.cx),\n+                        ),\n                         // FIXME(eddyb) compute both `trait_` and `for_` from\n                         // the post-inference `trait_ref`, as it's more accurate.\n                         trait_: Some(trait_ref.clean(self.cx)),"}, {"sha": "7e5089d0d3741a3c17d81a2c3ea830f8d28f00a6", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/927a5e393ccb68fc7166f7737459dad42d5e50ca/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927a5e393ccb68fc7166f7737459dad42d5e50ca/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=927a5e393ccb68fc7166f7737459dad42d5e50ca", "patch": "@@ -15,13 +15,12 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n use crate::clean::{\n-    self, utils, Attributes, AttributesExt, ImplKind, ItemId, NestedAttributesExt, Type,\n+    self, clean_ty_generics, utils, Attributes, AttributesExt, Clean, ImplKind, ItemId,\n+    NestedAttributesExt, Type, Visibility,\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n \n-use super::{Clean, Visibility};\n-\n type Attrs<'hir> = rustc_middle::ty::Attributes<'hir>;\n \n /// Attempt to inline a definition into this AST.\n@@ -208,7 +207,7 @@ crate fn build_external_trait(cx: &mut DocContext<'_>, did: DefId) -> clean::Tra\n         .collect();\n \n     let predicates = cx.tcx.predicates_of(did);\n-    let generics = (cx.tcx.generics_of(did), predicates).clean(cx);\n+    let generics = clean_ty_generics(cx, cx.tcx.generics_of(did), predicates);\n     let generics = filter_non_trait_generics(did, generics);\n     let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n     let is_auto = cx.tcx.trait_is_auto(did);\n@@ -230,7 +229,9 @@ fn build_external_function(cx: &mut DocContext<'_>, did: DefId) -> clean::Functi\n     let predicates = cx.tcx.predicates_of(did);\n     let (generics, decl) = clean::enter_impl_trait(cx, |cx| {\n         // NOTE: generics need to be cleaned before the decl!\n-        ((cx.tcx.generics_of(did), predicates).clean(cx), (did, sig).clean(cx))\n+        let generics = clean_ty_generics(cx, cx.tcx.generics_of(did), predicates);\n+        let decl = (did, sig).clean(cx);\n+        (generics, decl)\n     });\n     clean::Function {\n         decl,\n@@ -243,7 +244,7 @@ fn build_enum(cx: &mut DocContext<'_>, did: DefId) -> clean::Enum {\n     let predicates = cx.tcx.explicit_predicates_of(did);\n \n     clean::Enum {\n-        generics: (cx.tcx.generics_of(did), predicates).clean(cx),\n+        generics: clean_ty_generics(cx, cx.tcx.generics_of(did), predicates),\n         variants_stripped: false,\n         variants: cx.tcx.adt_def(did).variants.iter().map(|v| v.clean(cx)).collect(),\n     }\n@@ -255,7 +256,7 @@ fn build_struct(cx: &mut DocContext<'_>, did: DefId) -> clean::Struct {\n \n     clean::Struct {\n         struct_type: variant.ctor_kind,\n-        generics: (cx.tcx.generics_of(did), predicates).clean(cx),\n+        generics: clean_ty_generics(cx, cx.tcx.generics_of(did), predicates),\n         fields: variant.fields.iter().map(|x| x.clean(cx)).collect(),\n         fields_stripped: false,\n     }\n@@ -265,7 +266,7 @@ fn build_union(cx: &mut DocContext<'_>, did: DefId) -> clean::Union {\n     let predicates = cx.tcx.explicit_predicates_of(did);\n     let variant = cx.tcx.adt_def(did).non_enum_variant();\n \n-    let generics = (cx.tcx.generics_of(did), predicates).clean(cx);\n+    let generics = clean_ty_generics(cx, cx.tcx.generics_of(did), predicates);\n     let fields = variant.fields.iter().map(|x| x.clean(cx)).collect();\n     clean::Union { generics, fields, fields_stripped: false }\n }\n@@ -276,7 +277,7 @@ fn build_type_alias(cx: &mut DocContext<'_>, did: DefId) -> clean::Typedef {\n \n     clean::Typedef {\n         type_,\n-        generics: (cx.tcx.generics_of(did), predicates).clean(cx),\n+        generics: clean_ty_generics(cx, cx.tcx.generics_of(did), predicates),\n         item_type: None,\n     }\n }\n@@ -440,7 +441,9 @@ crate fn build_impl(\n                     }\n                 })\n                 .collect::<Vec<_>>(),\n-            clean::enter_impl_trait(cx, |cx| (tcx.generics_of(did), predicates).clean(cx)),\n+            clean::enter_impl_trait(cx, |cx| {\n+                clean_ty_generics(cx, tcx.generics_of(did), predicates)\n+            }),\n         ),\n     };\n     let polarity = tcx.impl_polarity(did);"}, {"sha": "110ee839f7cd4c156c097f6d08cd7a4c341f007c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 144, "deletions": 145, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/927a5e393ccb68fc7166f7737459dad42d5e50ca/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/927a5e393ccb68fc7166f7737459dad42d5e50ca/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=927a5e393ccb68fc7166f7737459dad42d5e50ca", "patch": "@@ -522,170 +522,167 @@ impl Clean<Generics> for hir::Generics<'_> {\n     }\n }\n \n-impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx>) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Generics {\n-        use self::WherePredicate as WP;\n-        use std::collections::BTreeMap;\n-\n-        let (gens, preds) = *self;\n-\n-        // Don't populate `cx.impl_trait_bounds` before `clean`ning `where` clauses,\n-        // since `Clean for ty::Predicate` would consume them.\n-        let mut impl_trait = BTreeMap::<ImplTraitParam, Vec<GenericBound>>::default();\n-\n-        // Bounds in the type_params and lifetimes fields are repeated in the\n-        // predicates field (see rustc_typeck::collect::ty_generics), so remove\n-        // them.\n-        let stripped_params = gens\n-            .params\n-            .iter()\n-            .filter_map(|param| match param.kind {\n-                ty::GenericParamDefKind::Lifetime => Some(param.clean(cx)),\n-                ty::GenericParamDefKind::Type { synthetic, .. } => {\n-                    if param.name == kw::SelfUpper {\n-                        assert_eq!(param.index, 0);\n-                        return None;\n-                    }\n-                    if synthetic {\n-                        impl_trait.insert(param.index.into(), vec![]);\n-                        return None;\n-                    }\n-                    Some(param.clean(cx))\n+fn clean_ty_generics(\n+    cx: &mut DocContext<'_>,\n+    gens: &ty::Generics,\n+    preds: ty::GenericPredicates<'tcx>,\n+) -> Generics {\n+    use self::WherePredicate as WP;\n+    use std::collections::BTreeMap;\n+\n+    // Don't populate `cx.impl_trait_bounds` before `clean`ning `where` clauses,\n+    // since `Clean for ty::Predicate` would consume them.\n+    let mut impl_trait = BTreeMap::<ImplTraitParam, Vec<GenericBound>>::default();\n+\n+    // Bounds in the type_params and lifetimes fields are repeated in the\n+    // predicates field (see rustc_typeck::collect::ty_generics), so remove\n+    // them.\n+    let stripped_params = gens\n+        .params\n+        .iter()\n+        .filter_map(|param| match param.kind {\n+            ty::GenericParamDefKind::Lifetime => Some(param.clean(cx)),\n+            ty::GenericParamDefKind::Type { synthetic, .. } => {\n+                if param.name == kw::SelfUpper {\n+                    assert_eq!(param.index, 0);\n+                    return None;\n                 }\n-                ty::GenericParamDefKind::Const { .. } => Some(param.clean(cx)),\n-            })\n-            .collect::<Vec<GenericParamDef>>();\n+                if synthetic {\n+                    impl_trait.insert(param.index.into(), vec![]);\n+                    return None;\n+                }\n+                Some(param.clean(cx))\n+            }\n+            ty::GenericParamDefKind::Const { .. } => Some(param.clean(cx)),\n+        })\n+        .collect::<Vec<GenericParamDef>>();\n \n-        // param index -> [(DefId of trait, associated type name, type)]\n-        let mut impl_trait_proj = FxHashMap::<u32, Vec<(DefId, Symbol, Ty<'tcx>)>>::default();\n+    // param index -> [(DefId of trait, associated type name, type)]\n+    let mut impl_trait_proj = FxHashMap::<u32, Vec<(DefId, Symbol, Ty<'tcx>)>>::default();\n \n-        let where_predicates = preds\n-            .predicates\n-            .iter()\n-            .flat_map(|(p, _)| {\n-                let mut projection = None;\n-                let param_idx = (|| {\n-                    let bound_p = p.kind();\n-                    match bound_p.skip_binder() {\n-                        ty::PredicateKind::Trait(pred) => {\n-                            if let ty::Param(param) = pred.self_ty().kind() {\n-                                return Some(param.index);\n-                            }\n-                        }\n-                        ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n-                            if let ty::Param(param) = ty.kind() {\n-                                return Some(param.index);\n-                            }\n+    let where_predicates = preds\n+        .predicates\n+        .iter()\n+        .flat_map(|(p, _)| {\n+            let mut projection = None;\n+            let param_idx = (|| {\n+                let bound_p = p.kind();\n+                match bound_p.skip_binder() {\n+                    ty::PredicateKind::Trait(pred) => {\n+                        if let ty::Param(param) = pred.self_ty().kind() {\n+                            return Some(param.index);\n                         }\n-                        ty::PredicateKind::Projection(p) => {\n-                            if let ty::Param(param) = p.projection_ty.self_ty().kind() {\n-                                projection = Some(bound_p.rebind(p));\n-                                return Some(param.index);\n-                            }\n+                    }\n+                    ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n+                        if let ty::Param(param) = ty.kind() {\n+                            return Some(param.index);\n                         }\n-                        _ => (),\n                     }\n-\n-                    None\n-                })();\n-\n-                if let Some(param_idx) = param_idx {\n-                    if let Some(b) = impl_trait.get_mut(&param_idx.into()) {\n-                        let p = p.clean(cx)?;\n-\n-                        b.extend(\n-                            p.get_bounds()\n-                                .into_iter()\n-                                .flatten()\n-                                .cloned()\n-                                .filter(|b| !b.is_sized_bound(cx)),\n-                        );\n-\n-                        let proj = projection\n-                            .map(|p| (p.skip_binder().projection_ty.clean(cx), p.skip_binder().ty));\n-                        if let Some(((_, trait_did, name), rhs)) =\n-                            proj.as_ref().and_then(|(lhs, rhs)| Some((lhs.projection()?, rhs)))\n-                        {\n-                            impl_trait_proj\n-                                .entry(param_idx)\n-                                .or_default()\n-                                .push((trait_did, name, rhs));\n+                    ty::PredicateKind::Projection(p) => {\n+                        if let ty::Param(param) = p.projection_ty.self_ty().kind() {\n+                            projection = Some(bound_p.rebind(p));\n+                            return Some(param.index);\n                         }\n-\n-                        return None;\n                     }\n+                    _ => (),\n                 }\n \n-                Some(p)\n-            })\n-            .collect::<Vec<_>>();\n-\n-        for (param, mut bounds) in impl_trait {\n-            // Move trait bounds to the front.\n-            bounds.sort_by_key(|b| !matches!(b, GenericBound::TraitBound(..)));\n-\n-            if let crate::core::ImplTraitParam::ParamIndex(idx) = param {\n-                if let Some(proj) = impl_trait_proj.remove(&idx) {\n-                    for (trait_did, name, rhs) in proj {\n-                        let rhs = rhs.clean(cx);\n-                        simplify::merge_bounds(cx, &mut bounds, trait_did, name, &rhs);\n+                None\n+            })();\n+\n+            if let Some(param_idx) = param_idx {\n+                if let Some(b) = impl_trait.get_mut(&param_idx.into()) {\n+                    let p = p.clean(cx)?;\n+\n+                    b.extend(\n+                        p.get_bounds()\n+                            .into_iter()\n+                            .flatten()\n+                            .cloned()\n+                            .filter(|b| !b.is_sized_bound(cx)),\n+                    );\n+\n+                    let proj = projection\n+                        .map(|p| (p.skip_binder().projection_ty.clean(cx), p.skip_binder().ty));\n+                    if let Some(((_, trait_did, name), rhs)) =\n+                        proj.as_ref().and_then(|(lhs, rhs)| Some((lhs.projection()?, rhs)))\n+                    {\n+                        impl_trait_proj.entry(param_idx).or_default().push((trait_did, name, rhs));\n                     }\n+\n+                    return None;\n                 }\n-            } else {\n-                unreachable!();\n             }\n \n-            cx.impl_trait_bounds.insert(param, bounds);\n-        }\n+            Some(p)\n+        })\n+        .collect::<Vec<_>>();\n \n-        // Now that `cx.impl_trait_bounds` is populated, we can process\n-        // remaining predicates which could contain `impl Trait`.\n-        let mut where_predicates =\n-            where_predicates.into_iter().flat_map(|p| p.clean(cx)).collect::<Vec<_>>();\n-\n-        // Type parameters have a Sized bound by default unless removed with\n-        // ?Sized. Scan through the predicates and mark any type parameter with\n-        // a Sized bound, removing the bounds as we find them.\n-        //\n-        // Note that associated types also have a sized bound by default, but we\n-        // don't actually know the set of associated types right here so that's\n-        // handled in cleaning associated types\n-        let mut sized_params = FxHashSet::default();\n-        where_predicates.retain(|pred| match *pred {\n-            WP::BoundPredicate { ty: Generic(ref g), ref bounds, .. } => {\n-                if bounds.iter().any(|b| b.is_sized_bound(cx)) {\n-                    sized_params.insert(*g);\n-                    false\n-                } else {\n-                    true\n+    for (param, mut bounds) in impl_trait {\n+        // Move trait bounds to the front.\n+        bounds.sort_by_key(|b| !matches!(b, GenericBound::TraitBound(..)));\n+\n+        if let crate::core::ImplTraitParam::ParamIndex(idx) = param {\n+            if let Some(proj) = impl_trait_proj.remove(&idx) {\n+                for (trait_did, name, rhs) in proj {\n+                    let rhs = rhs.clean(cx);\n+                    simplify::merge_bounds(cx, &mut bounds, trait_did, name, &rhs);\n                 }\n             }\n-            _ => true,\n-        });\n+        } else {\n+            unreachable!();\n+        }\n \n-        // Run through the type parameters again and insert a ?Sized\n-        // unbound for any we didn't find to be Sized.\n-        for tp in &stripped_params {\n-            if matches!(tp.kind, types::GenericParamDefKind::Type { .. })\n-                && !sized_params.contains(&tp.name)\n-            {\n-                where_predicates.push(WP::BoundPredicate {\n-                    ty: Type::Generic(tp.name),\n-                    bounds: vec![GenericBound::maybe_sized(cx)],\n-                    bound_params: Vec::new(),\n-                })\n+        cx.impl_trait_bounds.insert(param, bounds);\n+    }\n+\n+    // Now that `cx.impl_trait_bounds` is populated, we can process\n+    // remaining predicates which could contain `impl Trait`.\n+    let mut where_predicates =\n+        where_predicates.into_iter().flat_map(|p| p.clean(cx)).collect::<Vec<_>>();\n+\n+    // Type parameters have a Sized bound by default unless removed with\n+    // ?Sized. Scan through the predicates and mark any type parameter with\n+    // a Sized bound, removing the bounds as we find them.\n+    //\n+    // Note that associated types also have a sized bound by default, but we\n+    // don't actually know the set of associated types right here so that's\n+    // handled in cleaning associated types\n+    let mut sized_params = FxHashSet::default();\n+    where_predicates.retain(|pred| match *pred {\n+        WP::BoundPredicate { ty: Generic(ref g), ref bounds, .. } => {\n+            if bounds.iter().any(|b| b.is_sized_bound(cx)) {\n+                sized_params.insert(*g);\n+                false\n+            } else {\n+                true\n             }\n         }\n+        _ => true,\n+    });\n \n-        // It would be nice to collect all of the bounds on a type and recombine\n-        // them if possible, to avoid e.g., `where T: Foo, T: Bar, T: Sized, T: 'a`\n-        // and instead see `where T: Foo + Bar + Sized + 'a`\n-\n-        Generics {\n-            params: stripped_params,\n-            where_predicates: simplify::where_clauses(cx, where_predicates),\n+    // Run through the type parameters again and insert a ?Sized\n+    // unbound for any we didn't find to be Sized.\n+    for tp in &stripped_params {\n+        if matches!(tp.kind, types::GenericParamDefKind::Type { .. })\n+            && !sized_params.contains(&tp.name)\n+        {\n+            where_predicates.push(WP::BoundPredicate {\n+                ty: Type::Generic(tp.name),\n+                bounds: vec![GenericBound::maybe_sized(cx)],\n+                bound_params: Vec::new(),\n+            })\n         }\n     }\n+\n+    // It would be nice to collect all of the bounds on a type and recombine\n+    // them if possible, to avoid e.g., `where T: Foo, T: Bar, T: Sized, T: 'a`\n+    // and instead see `where T: Foo + Bar + Sized + 'a`\n+\n+    Generics {\n+        params: stripped_params,\n+        where_predicates: simplify::where_clauses(cx, where_predicates),\n+    }\n }\n \n fn clean_fn_or_proc_macro(\n@@ -1007,9 +1004,11 @@ impl Clean<Item> for ty::AssocItem {\n                 AssocConstItem(ty.clean(cx), default)\n             }\n             ty::AssocKind::Fn => {\n-                let generics =\n-                    (tcx.generics_of(self.def_id), tcx.explicit_predicates_of(self.def_id))\n-                        .clean(cx);\n+                let generics = clean_ty_generics(\n+                    cx,\n+                    tcx.generics_of(self.def_id),\n+                    tcx.explicit_predicates_of(self.def_id),\n+                );\n                 let sig = tcx.fn_sig(self.def_id);\n                 let mut decl = (self.def_id, sig).clean(cx);\n \n@@ -1080,7 +1079,7 @@ impl Clean<Item> for ty::AssocItem {\n                 if let ty::TraitContainer(_) = self.container {\n                     let bounds = tcx.explicit_item_bounds(self.def_id);\n                     let predicates = ty::GenericPredicates { parent: None, predicates: bounds };\n-                    let generics = (tcx.generics_of(self.def_id), predicates).clean(cx);\n+                    let generics = clean_ty_generics(cx, tcx.generics_of(self.def_id), predicates);\n                     let mut bounds = generics\n                         .where_predicates\n                         .iter()"}]}