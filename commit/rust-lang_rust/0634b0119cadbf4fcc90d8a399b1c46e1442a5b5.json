{"sha": "0634b0119cadbf4fcc90d8a399b1c46e1442a5b5", "node_id": "C_kwDOAAsO6NoAKDA2MzRiMDExOWNhZGJmNGZjYzkwZDhhMzk5YjFjNDZlMTQ0MmE1YjU", "commit": {"author": {"name": "Nikita Tomashevich", "email": "quant3234@gmail.com", "date": "2022-09-16T23:54:59Z"}, "committer": {"name": "Nikita Tomashevich", "email": "quant3234@gmail.com", "date": "2022-12-28T11:53:47Z"}, "message": "Partial work on static_impl_trait.rs", "tree": {"sha": "7d021a9e4d41482785a73a9c90081a1630e576ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d021a9e4d41482785a73a9c90081a1630e576ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0634b0119cadbf4fcc90d8a399b1c46e1442a5b5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEAWou4Gq79HasRseDspeR1Nh440UFAmOsLksACgkQspeR1Nh4\n40UkKw/+NOec/KIRap0nYG2IqzPoipI7xuw+bVzSpZtaMxXYL36v8H7sIGS8whdD\n37AExy02A9ONEYMZUmzeTYHw+tj0eODS0i/dG6Dp7ZYRqGSQIYRHH2IE6PG/ISUb\n9L1MSjxjJ8hd+daXR6RzLTRaMVRD38cR7BnT3Ot9+3v7wnWAeeZ0nsZt2yJZVST4\nDKzgSO1iBfZzZXAIYnX4PC7CKg+rKHjxfDxh/q4zSh5IDIfLp1rBkytrwSjpO2I+\nbSWUuUz7zP6aDmJbQIXYnTMYNHYfLcAlWnXNYxTd5eJ7LJBIiV3yS9rDm0FIDGUq\ntjbyKZjN3q03Z5A2e2q/GNeFx3DRdkwkhoOOWUpaUX78p4JgXXmTICvdSTYIRqrR\nSJevlOVQDNq2omQNrreo4ciGa0VGCG3JM9Evc9pNJAI49lb9u8L/Dep7HQarPf0F\ncdZFvc9UUaUOCI9vGLkCuUtGy2YWtGbOkWKhWCd5ARgh2tgRg2uny2uWIpxKMcKr\ntcuTBAyjcZOnu5PqiXiqAGxd8DZKzClPb1Lt4wRWoZBSBdrVtYJqpRmgkbmc/pLK\nnaS5wrVTdeJvvWatRt6864yO4EGqC+kzi/l24fco7YSKVzClrJzA2ux/EBxokAGn\n3kuaxeaY5QkY9OnyOBVlAUqev3L8JLySjnmw1g6Z4oBHgJAKkX0=\n=Mhh9\n-----END PGP SIGNATURE-----", "payload": "tree 7d021a9e4d41482785a73a9c90081a1630e576ee\nparent 3935a81d473167387123f8d48087f5ee446f92c4\nauthor Nikita Tomashevich <quant3234@gmail.com> 1663372499 +0300\ncommitter Nikita Tomashevich <quant3234@gmail.com> 1672228427 +0300\n\nPartial work on static_impl_trait.rs\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0634b0119cadbf4fcc90d8a399b1c46e1442a5b5", "html_url": "https://github.com/rust-lang/rust/commit/0634b0119cadbf4fcc90d8a399b1c46e1442a5b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0634b0119cadbf4fcc90d8a399b1c46e1442a5b5/comments", "author": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "committer": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3935a81d473167387123f8d48087f5ee446f92c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3935a81d473167387123f8d48087f5ee446f92c4", "html_url": "https://github.com/rust-lang/rust/commit/3935a81d473167387123f8d48087f5ee446f92c4"}], "stats": {"total": 332, "additions": 221, "deletions": 111}, "files": [{"sha": "7a10f4b7bc54910f5eed8d358ae8e88930a7a54d", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0634b0119cadbf4fcc90d8a399b1c46e1442a5b5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0634b0119cadbf4fcc90d8a399b1c46e1442a5b5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=0634b0119cadbf4fcc90d8a399b1c46e1442a5b5", "patch": "@@ -221,3 +221,55 @@ infer_trait_impl_diff = `impl` item signature doesn't match `trait` item signatu\n infer_tid_rel_help = verify the lifetime relationships in the `trait` and `impl` between the `self` argument, the other inputs and its output\n infer_tid_consider_borriwing = consider borrowing this type parameter in the trait\n infer_tid_param_help = the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n+\n+infer_dtcs_has_lifetime_req_label = this has an implicit `'static` lifetime requirement\n+infer_dtcs_introduces_requirement = calling this method introduces the `impl`'s 'static` requirement\n+infer_dtcs_has_req_note = the used `impl` has a `'static` requirement\n+infer_dtcs_suggestion = consider relaxing the implicit `'static` requirement\n+\n+infer_but_calling_introduces = {$has_param_name ->\n+    [true] `{$param_name}`\n+    *[false] `fn` parameter\n+} has {$lifetime_kind ->\n+    [named] lifetime `{lifetime}`\n+    *[anon] an anonymous lifetime `'_`\n+} but calling `{assoc_item}` introduces an implicit `'static` lifetime requirement\n+    .label1 = {$has_lifetime ->\n+        [named] lifetime `{lifetime}`\n+        *[anon] an anonymous lifetime `'_`\n+    }\n+    .label2 = ...is used and required to live as long as `'static` here because of an implicit lifetime bound on the {$has_impl_path ->\n+        [named] `impl` of `{$impl_path}`\n+        *[anon] inherent `impl`\n+    }\n+\n+infer_but_needs_to_satisfy = {$has_param_name ->\n+    [true] `{$param_name}`\n+    *[false] `fn` parameter\n+} has {$has_lifetime ->\n+    [named] lifetime `{lifetime}`\n+    *[anon] an anonymous lifetime `'_`\n+} but it needs to satisfy a `'static` lifetime requirement\n+    .influencer = this data with {$has_lifetime ->\n+        [named] lifetime `{lifetime}`\n+        *[anon] an anonymous lifetime `'_`\n+    }...\n+    .require = {$spans_empty ->\n+        *[true] ...is used and required to live as long as `'static` here\n+        [false] ...and is required to live as long as `'static` here\n+    }\n+    .used_here = ...is used here...\n+    .introduced_by_bound = 'static` lifetime requirement introduced by this bound\n+\n+infer_more_targeted = {$has_param_name ->\n+    [true] `{$param_name}`\n+    *[false] `fn` parameter\n+} has {$has_lifetime ->\n+    [named] lifetime `{lifetime}`\n+    *[anon] an anonymous lifetime `'_`\n+} but calling `{$ident}` introduces an implicit `'static` lifetime requirement\n+\n+infer_ril_introduced_here = `'static` requirement introduced here\n+infer_ril_introduced_by = requirement introduced by this return type\n+infer_ril_because_of = because of this returned expression\n+infer_ril_static_introduced_by = \"`'static` lifetime requirement introduced by the return type"}, {"sha": "dc79c725951b3d9f2c64284ec6aba447d0f6cad3", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/0634b0119cadbf4fcc90d8a399b1c46e1442a5b5/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0634b0119cadbf4fcc90d8a399b1c46e1442a5b5/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=0634b0119cadbf4fcc90d8a399b1c46e1442a5b5", "patch": "@@ -8,6 +8,7 @@ use rustc_hir::{FnRetTy, Ty};\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_middle::ty::{Region, TyCtxt};\n use rustc_span::symbol::kw;\n+use rustc_span::Symbol;\n use rustc_span::{symbol::Ident, BytePos, Span};\n \n use crate::infer::error_reporting::{\n@@ -619,3 +620,99 @@ pub struct TraitImplDiff {\n     pub expected: String,\n     pub found: String,\n }\n+\n+pub struct DynTraitConstraintSuggestion {\n+    pub span: Span,\n+    pub ident: Ident,\n+}\n+\n+impl AddSubdiagnostic for DynTraitConstraintSuggestion {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        let mut multi_span: MultiSpan = vec![self.span].into();\n+        multi_span.push_span_label(self.span, fluent::infer::dtcs_has_lifetime_req_label);\n+        multi_span.push_span_label(self.ident.span, fluent::infer::dtcs_introduces_requirement);\n+        diag.span_note(multi_span, fluent::infer::dtcs_has_req_note);\n+        diag.span_suggestion_verbose(\n+            self.span.shrink_to_hi(),\n+            fluent::infer::dtcs_suggestion,\n+            \" + '_\",\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::but_calling_introduces, code = \"E0772\")]\n+pub struct ButCallingIntroduces {\n+    #[label(infer::label1)]\n+    pub param_ty_span: Span,\n+    #[primary_span]\n+    #[label(infer::label2)]\n+    pub cause_span: Span,\n+\n+    pub has_param_name: bool,\n+    pub param_name: String,\n+    pub has_lifetime: bool,\n+    pub lifetime: String,\n+    pub assoc_item: Symbol,\n+    pub has_impl_path: bool,\n+    pub impl_path: String,\n+}\n+\n+pub struct ReqIntroducedLocations {\n+    pub span: MultiSpan,\n+    pub spans: Vec<Span>,\n+    pub fn_decl_span: Span,\n+    pub cause_span: Span,\n+    pub add_label: bool,\n+}\n+\n+impl AddSubdiagnostic for ReqIntroducedLocations {\n+    fn add_to_diagnostic(mut self, diag: &mut rustc_errors::Diagnostic) {\n+        for sp in self.spans {\n+            self.span.push_span_label(sp, fluent::infer::ril_introduced_here);\n+        }\n+\n+        if self.add_label {\n+            self.span.push_span_label(self.fn_decl_span, fluent::infer::ril_introduced_by);\n+        }\n+        self.span.push_span_label(self.cause_span, fluent::infer::ril_because_of);\n+        diag.span_note(self.span, fluent::infer::ril_static_introduced_by);\n+    }\n+}\n+\n+pub struct MoreTargeted {\n+    pub ident: Symbol,\n+}\n+\n+impl AddSubdiagnostic for MoreTargeted {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        diag.code(rustc_errors::error_code!(E0772));\n+        diag.set_primary_message(fluent::infer::more_targeted);\n+        diag.set_arg(\"ident\", self.ident);\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::but_needs_to_satisfy, code = \"E0759\")]\n+pub struct ButNeedsToSatisfy {\n+    #[primary_span]\n+    pub sp: Span,\n+    #[label(infer::influencer)]\n+    pub influencer_point: Span,\n+    #[label(infer::used_here)]\n+    pub spans: Vec<Span>,\n+    #[label(infer::require)]\n+    pub require_span_as_label: Option<Span>,\n+    #[note(infer::require)]\n+    pub require_span_as_note: Option<Span>,\n+    #[note(infer::introduced_by_bound)]\n+    pub bound: Option<Span>,\n+\n+    #[subdiagnostic]\n+    pub req_introduces_loc: Option<ReqIntroducedLocations>,\n+\n+    pub spans_empty: bool,\n+    pub has_lifetime: bool,\n+    pub lifetime: String,\n+}"}, {"sha": "b76f7e7689ff9ef3dc1a7a6994bddaa00124f913", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 72, "deletions": 111, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/0634b0119cadbf4fcc90d8a399b1c46e1442a5b5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0634b0119cadbf4fcc90d8a399b1c46e1442a5b5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=0634b0119cadbf4fcc90d8a399b1c46e1442a5b5", "patch": "@@ -1,11 +1,15 @@\n //! Error Reporting for static impl Traits.\n \n+use crate::errors::{\n+    ButCallingIntroduces, ButNeedsToSatisfy, DynTraitConstraintSuggestion, MoreTargeted,\n+    ReqIntroducedLocations,\n+};\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCauseCode, UnifyReceiverContext};\n-use rustc_data_structures::fx::FxIndexSet;\n-use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorGuaranteed, MultiSpan};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::{AddSubdiagnostic, Applicability, Diagnostic, ErrorGuaranteed, MultiSpan};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_ty, Visitor};\n use rustc_hir::{self as hir, GenericBound, Item, ItemKind, Lifetime, LifetimeName, Node, TyKind};\n@@ -49,46 +53,33 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                     }\n \n                     let param = self.find_param_with_region(*sup_r, *sub_r)?;\n-                    let lifetime = if sup_r.has_name() {\n-                        format!(\"lifetime `{}`\", sup_r)\n-                    } else {\n-                        \"an anonymous lifetime `'_`\".to_string()\n+                    let simple_ident = param.param.pat.simple_ident();\n+\n+                    let (has_impl_path, impl_path) = match ctxt.assoc_item.container {\n+                        AssocItemContainer::TraitContainer => {\n+                            let id = ctxt.assoc_item.container_id(tcx);\n+                            (true, tcx.def_path_str(id))\n+                        }\n+                        AssocItemContainer::ImplContainer => (false, String::new()),\n                     };\n-                    let mut err = struct_span_err!(\n-                        tcx.sess,\n-                        cause.span,\n-                        E0772,\n-                        \"{} has {} but calling `{}` introduces an implicit `'static` lifetime \\\n-                         requirement\",\n-                        param\n-                            .param\n-                            .pat\n-                            .simple_ident()\n-                            .map(|s| format!(\"`{}`\", s))\n-                            .unwrap_or_else(|| \"`fn` parameter\".to_string()),\n-                        lifetime,\n-                        ctxt.assoc_item.name,\n-                    );\n-                    err.span_label(param.param_ty_span, &format!(\"this data with {}...\", lifetime));\n-                    err.span_label(\n-                        cause.span,\n-                        &format!(\n-                            \"...is used and required to live as long as `'static` here \\\n-                             because of an implicit lifetime bound on the {}\",\n-                            match ctxt.assoc_item.container {\n-                                AssocItemContainer::TraitContainer => {\n-                                    let id = ctxt.assoc_item.container_id(tcx);\n-                                    format!(\"`impl` of `{}`\", tcx.def_path_str(id))\n-                                }\n-                                AssocItemContainer::ImplContainer => \"inherent `impl`\".to_string(),\n-                            },\n-                        ),\n-                    );\n+\n+                    let diag = ButCallingIntroduces {\n+                        param_ty_span: param.param_ty_span,\n+                        cause_span: cause.span,\n+                        has_param_name: simple_ident.is_some(),\n+                        param_name: simple_ident.map(|x| x.to_string()).unwrap_or_default(),\n+                        has_lifetime: sup_r.has_name(),\n+                        lifetime: sup_r.to_string(),\n+                        assoc_item: ctxt.assoc_item.name,\n+                        has_impl_path,\n+                        impl_path,\n+                    };\n+                    let mut err = self.tcx().sess.create_err(diag);\n                     if self.find_impl_on_dyn_trait(&mut err, param.param_ty, &ctxt) {\n                         let reported = err.emit();\n                         return Some(reported);\n                     } else {\n-                        err.cancel();\n+                        err.cancel()\n                     }\n                 }\n                 return None;\n@@ -104,25 +95,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let sp = var_origin.span();\n         let return_sp = sub_origin.span();\n         let param = self.find_param_with_region(*sup_r, *sub_r)?;\n-        let (lifetime_name, lifetime) = if sup_r.has_name() {\n-            (sup_r.to_string(), format!(\"lifetime `{}`\", sup_r))\n-        } else {\n-            (\"'_\".to_owned(), \"an anonymous lifetime `'_`\".to_string())\n-        };\n-        let param_name = param\n-            .param\n-            .pat\n-            .simple_ident()\n-            .map(|s| format!(\"`{}`\", s))\n-            .unwrap_or_else(|| \"`fn` parameter\".to_string());\n-        let mut err = struct_span_err!(\n-            tcx.sess,\n-            sp,\n-            E0759,\n-            \"{} has {} but it needs to satisfy a `'static` lifetime requirement\",\n-            param_name,\n-            lifetime,\n-        );\n+        let lifetime_name = if sup_r.has_name() { sup_r.to_string() } else { \"'_\".to_owned() };\n \n         let (mention_influencer, influencer_point) =\n             if sup_origin.span().overlaps(param.param_ty_span) {\n@@ -141,7 +114,6 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             } else {\n                 (!sup_origin.span().overlaps(return_sp), param.param_ty_span)\n             };\n-        err.span_label(influencer_point, &format!(\"this data with {}...\", lifetime));\n \n         debug!(\"try_report_static_impl_trait: param_info={:?}\", param);\n \n@@ -155,65 +127,70 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         spans.dedup_by_key(|span| (span.lo(), span.hi()));\n \n         // We try to make the output have fewer overlapping spans if possible.\n-        let require_msg = if spans.is_empty() {\n-            \"...is used and required to live as long as `'static` here\"\n-        } else {\n-            \"...and is required to live as long as `'static` here\"\n-        };\n         let require_span =\n             if sup_origin.span().overlaps(return_sp) { sup_origin.span() } else { return_sp };\n \n-        for span in &spans {\n-            err.span_label(*span, \"...is used here...\");\n-        }\n-\n-        if spans.iter().any(|sp| sp.overlaps(return_sp) || *sp > return_sp) {\n-            // If any of the \"captured here\" labels appears on the same line or after\n-            // `require_span`, we put it on a note to ensure the text flows by appearing\n-            // always at the end.\n-            err.span_note(require_span, require_msg);\n+        let spans_empty = spans.is_empty();\n+        let require_as_note = spans.iter().any(|sp| sp.overlaps(return_sp) || *sp > return_sp);\n+        let bound = if let SubregionOrigin::RelateParamBound(_, _, Some(bound)) = sub_origin {\n+            Some(*bound)\n         } else {\n-            // We don't need a note, it's already at the end, it can be shown as a `span_label`.\n-            err.span_label(require_span, require_msg);\n-        }\n+            None\n+        };\n+\n+        let mut subdiag = None;\n \n-        if let SubregionOrigin::RelateParamBound(_, _, Some(bound)) = sub_origin {\n-            err.span_note(*bound, \"`'static` lifetime requirement introduced by this bound\");\n-        }\n         if let SubregionOrigin::Subtype(box TypeTrace { cause, .. }) = sub_origin {\n             if let ObligationCauseCode::ReturnValue(hir_id)\n             | ObligationCauseCode::BlockTailExpression(hir_id) = cause.code()\n             {\n                 let parent_id = tcx.hir().get_parent_item(*hir_id);\n                 if let Some(fn_decl) = tcx.hir().fn_decl_by_hir_id(parent_id.into()) {\n                     let mut span: MultiSpan = fn_decl.output.span().into();\n+                    let mut spans = Vec::new();\n                     let mut add_label = true;\n                     if let hir::FnRetTy::Return(ty) = fn_decl.output {\n                         let mut v = StaticLifetimeVisitor(vec![], tcx.hir());\n                         v.visit_ty(ty);\n                         if !v.0.is_empty() {\n                             span = v.0.clone().into();\n-                            for sp in v.0 {\n-                                span.push_span_label(sp, \"`'static` requirement introduced here\");\n-                            }\n+                            spans = v.0;\n                             add_label = false;\n                         }\n                     }\n-                    if add_label {\n-                        span.push_span_label(\n-                            fn_decl.output.span(),\n-                            \"requirement introduced by this return type\",\n-                        );\n-                    }\n-                    span.push_span_label(cause.span, \"because of this returned expression\");\n-                    err.span_note(\n+                    let fn_decl_span = fn_decl.output.span();\n+\n+                    subdiag = Some(ReqIntroducedLocations {\n                         span,\n-                        \"`'static` lifetime requirement introduced by the return type\",\n-                    );\n+                        spans,\n+                        fn_decl_span,\n+                        cause_span: cause.span,\n+                        add_label,\n+                    });\n                 }\n             }\n         }\n \n+        let diag = ButNeedsToSatisfy {\n+            sp,\n+            influencer_point,\n+            spans: spans.clone(),\n+            // If any of the \"captured here\" labels appears on the same line or after\n+            // `require_span`, we put it on a note to ensure the text flows by appearing\n+            // always at the end.\n+            require_span_as_note: require_as_note.then_some(require_span),\n+            // We don't need a note, it's already at the end, it can be shown as a `span_label`.\n+            require_span_as_label: (!require_as_note).then_some(require_span),\n+            req_introduces_loc: subdiag,\n+\n+            has_lifetime: sup_r.has_name(),\n+            lifetime: sup_r.to_string(),\n+            spans_empty,\n+            bound,\n+        };\n+\n+        let mut err = self.tcx().sess.create_err(diag);\n+\n         let fn_returns = tcx.return_type_impl_or_dyn_traits(anon_reg_sup.def_id);\n \n         let mut override_error_code = None;\n@@ -247,12 +224,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         }\n         if let (Some(ident), true) = (override_error_code, fn_returns.is_empty()) {\n             // Provide a more targeted error code and description.\n-            err.code(rustc_errors::error_code!(E0772));\n-            err.set_primary_message(&format!(\n-                \"{} has {} but calling `{}` introduces an implicit `'static` lifetime \\\n-                requirement\",\n-                param_name, lifetime, ident,\n-            ));\n+            let retarget_subdiag = MoreTargeted { ident };\n+            retarget_subdiag.add_to_diagnostic(&mut err);\n         }\n \n         let arg = match param.param.pat.simple_ident() {\n@@ -513,21 +486,9 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             let mut traits = vec![];\n             let mut hir_v = HirTraitObjectVisitor(&mut traits, *found_did);\n             hir_v.visit_ty(&self_ty);\n-            for span in &traits {\n-                let mut multi_span: MultiSpan = vec![*span].into();\n-                multi_span\n-                    .push_span_label(*span, \"this has an implicit `'static` lifetime requirement\");\n-                multi_span.push_span_label(\n-                    ident.span,\n-                    \"calling this method introduces the `impl`'s 'static` requirement\",\n-                );\n-                err.span_note(multi_span, \"the used `impl` has a `'static` requirement\");\n-                err.span_suggestion_verbose(\n-                    span.shrink_to_hi(),\n-                    \"consider relaxing the implicit `'static` requirement\",\n-                    \" + '_\",\n-                    Applicability::MaybeIncorrect,\n-                );\n+            for &span in &traits {\n+                let subdiag = DynTraitConstraintSuggestion { span, ident };\n+                subdiag.add_to_diagnostic(err);\n                 suggested = true;\n             }\n         }"}]}