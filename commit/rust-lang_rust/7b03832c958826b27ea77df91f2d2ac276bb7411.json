{"sha": "7b03832c958826b27ea77df91f2d2ac276bb7411", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMDM4MzJjOTU4ODI2YjI3ZWE3N2RmOTFmMmQyYWMyNzZiYjc0MTE=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-06T06:14:27Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-06T17:42:41Z"}, "message": "Updating tests to use pipes.", "tree": {"sha": "37832e91fead2552b564a56b7da753b80103bd29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37832e91fead2552b564a56b7da753b80103bd29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b03832c958826b27ea77df91f2d2ac276bb7411", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b03832c958826b27ea77df91f2d2ac276bb7411", "html_url": "https://github.com/rust-lang/rust/commit/7b03832c958826b27ea77df91f2d2ac276bb7411", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b03832c958826b27ea77df91f2d2ac276bb7411/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa4134611dfc54e117f196644d30948a75b7b9eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa4134611dfc54e117f196644d30948a75b7b9eb", "html_url": "https://github.com/rust-lang/rust/commit/fa4134611dfc54e117f196644d30948a75b7b9eb"}], "stats": {"total": 558, "additions": 71, "deletions": 487}, "files": [{"sha": "bf3c30a573b865763dd81dcc0908026609d611a4", "filename": "src/libcore/future.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7b03832c958826b27ea77df91f2d2ac276bb7411/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b03832c958826b27ea77df91f2d2ac276bb7411/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=7b03832c958826b27ea77df91f2d2ac276bb7411", "patch": "@@ -138,6 +138,15 @@ fn with<A,B>(future: future<A>, blk: fn(A) -> B) -> B {\n }\n \n // The pipe protocol, generated by pipec\n+/*\n+proto! future_pipe {\n+    waiting:recv<T:send> {\n+        completed(T) -> terminated\n+    }\n+\n+    terminated { }\n+}\n+*/\n mod future_pipe {\n     fn init<T: send>() -> (client::waiting<T>, server::waiting<T>) {\n         { let (s, c) = pipes::entangle(); (c, s) }"}, {"sha": "abf19825fdd27736fc1158f95f61694dad7a69e4", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7b03832c958826b27ea77df91f2d2ac276bb7411/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b03832c958826b27ea77df91f2d2ac276bb7411/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=7b03832c958826b27ea77df91f2d2ac276bb7411", "patch": "@@ -10,11 +10,10 @@ impl proto_parser for parser {\n     fn parse_proto(id: ident) -> protocol {\n         let proto = protocol(id);\n \n-        self.expect(token::LBRACE);\n-\n-        while self.token != token::RBRACE {\n-            self.parse_state(proto);\n-        }\n+        self.parse_unspanned_seq(token::LBRACE,\n+                                 token::RBRACE,\n+                                 {sep: none, trailing_sep_allowed: false},\n+                                 |self| self.parse_state(proto));\n \n         ret proto;\n     }\n@@ -35,29 +34,44 @@ impl proto_parser for parser {\n           _ { fail }\n         };\n \n-        let state = proto.add_state(id, dir);\n-        // TODO: add typarams too.\n+        let typarms = if self.token == token::LT {\n+            self.parse_ty_params()\n+        }\n+        else { ~[] };\n+\n+        let state = proto.add_state_poly(id, dir, typarms);\n \n-        self.expect(token::LBRACE);\n+        // parse the messages\n+        self.parse_unspanned_seq(\n+            token::LBRACE, token::RBRACE,\n+            {sep: some(token::COMMA), trailing_sep_allowed: true},\n+            |self| {\n+                let mname = self.parse_ident();\n \n-        while self.token != token::RBRACE {\n-            let mname = self.parse_ident();\n+                let args = if self.token == token::LPAREN {\n+                    self.parse_unspanned_seq(token::LPAREN,\n+                                             token::RPAREN,\n+                                             {sep: some(token::COMMA),\n+                                              trailing_sep_allowed: true},\n+                                             |p| p.parse_ty(false))\n+                }\n+                else { ~[] };\n \n-            // TODO: parse data\n+                self.expect(token::RARROW);\n \n-            self.expect(token::RARROW);\n+                let next = self.parse_ident();\n \n-            let next = self.parse_ident();\n-            // TODO: parse next types\n+                let ntys = if self.token == token::LT {\n+                    self.parse_unspanned_seq(token::LT,\n+                                             token::GT,\n+                                             {sep: some(token::COMMA),\n+                                              trailing_sep_allowed: true},\n+                                             |p| p.parse_ty(false))\n+                }\n+                else { ~[] };\n \n-            state.add_message(mname, ~[], next, ~[]);\n+                state.add_message(mname, args, next, ntys);\n \n-            alt copy self.token {\n-              token::COMMA { self.bump() }\n-              token::RBRACE { }\n-              _ { fail }\n-            }\n-        }\n-        self.bump();\n+            });\n     }\n }"}, {"sha": "2eb630d642746bf74fbf0e2fba10d2c2382a46ae", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "renamed", "additions": 7, "deletions": 32, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7b03832c958826b27ea77df91f2d2ac276bb7411/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b03832c958826b27ea77df91f2d2ac276bb7411/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=7b03832c958826b27ea77df91f2d2ac276bb7411", "patch": "@@ -4,7 +4,7 @@\n // that things will look really good once we get that lock out of the\n // message path.\n \n-// This version uses semi-automatically compiled channel contracts.\n+// This version uses automatically compiled channel contracts.\n \n // xfail-pretty\n \n@@ -13,40 +13,15 @@ import future::future;\n use std;\n import std::time;\n \n-import ring::server::recv;\n-\n-// This module was generated by the pipe compiler.\n-mod ring {\n-    fn init() -> (client::num, server::num) { pipes::entangle() }\n-    enum num { num(uint, server::num), }\n-    mod client {\n-        fn num(-pipe: num, x_0: uint) -> num {\n-            let (c, s) = pipes::entangle();\n-            let message = ring::num(x_0, s);\n-            pipes::send(pipe, message);\n-            c\n-        }\n-        type num = pipes::send_packet<ring::num>;\n-    }\n-    mod server {\n-        impl recv for num {\n-            fn recv() -> extern fn(-num) -> ring::num {\n-                fn recv(-pipe: num) -> ring::num {\n-                    option::unwrap(pipes::recv(pipe))\n-                }\n-                recv\n-            }\n-        }\n-        type num = pipes::recv_packet<ring::num>;\n+import pipes::recv;\n+\n+proto! ring {\n+    num:send {\n+        num(uint) -> num\n     }\n }\n \n fn macros() {\n-    #macro[\n-        [#recv[chan],\n-         chan.recv()(chan)]\n-    ];\n-\n     #macro[\n         [#move[x],\n          unsafe { let y <- *ptr::addr_of(x); y }]\n@@ -68,7 +43,7 @@ fn thread_ring(i: uint,\n         num_port2 <-> num_port;\n         num_chan = some(ring::client::num(option::unwrap(num_chan2), i * j));\n         let port = option::unwrap(num_port2);\n-        alt (#recv(port)) {\n+        alt (option::unwrap(recv(port))) {\n           ring::num(_n, p) {\n             //log(error, _n);\n             num_port = some(#move(p));", "previous_filename": "src/test/bench/msgsend-ring-contracts.rs"}, {"sha": "7efedfe6418ca35cd1ddeacae585f432944ffbef", "filename": "src/test/run-pass/pipe-manual-1.rs", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/fa4134611dfc54e117f196644d30948a75b7b9eb/src%2Ftest%2Frun-pass%2Fpipe-manual-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4134611dfc54e117f196644d30948a75b7b9eb/src%2Ftest%2Frun-pass%2Fpipe-manual-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-manual-1.rs?ref=fa4134611dfc54e117f196644d30948a75b7b9eb", "patch": "@@ -1,110 +0,0 @@\n-/*\n-\n-The first test case using pipes. The idea is to break this into\n-several stages for prototyping. Here's the plan:\n-\n-1. Write an already-compiled protocol using existing ports and chans.\n-\n-2. Take the already-compiled version and add the low-level\n-synchronization code instead.\n-\n-3. Write a syntax extension to compile the protocols.\n-\n-At some point, we'll need to add support for select.\n-\n-*/\n-\n-mod pingpong {\n-    import newcomm::*;\n-\n-    type pingpong = ~mut option<(chan<()>, port<()>)>;\n-\n-    fn init() -> (client::ping, server::ping) {\n-        let cp = port();\n-        let sp = port();\n-        let cc = chan(sp);\n-        let sc = chan(cp);\n-\n-        let client = client::ping(~mut some((cc, cp)));\n-        let server = server::ping(~mut some((sc, sp)));\n-\n-        (client, server)\n-    }\n-\n-    mod client {\n-        enum ping = pingpong;\n-        enum pong = pingpong;\n-\n-        fn do_ping(-c: ping) -> pong {\n-            let mut op = none;\n-            op <-> **c;\n-            let (c, s) <- option::unwrap(op);\n-            c.send(());\n-            let p <- (c, s);\n-            pong(~mut some(p))\n-        }\n-\n-        fn do_pong(-c: pong) -> (ping, ()) {\n-            let mut op = none;\n-            op <-> **c;\n-            let (c, s) <- option::unwrap(op);\n-            let d = s.recv();\n-            let p <- (c, s);\n-            (ping(~mut some(p)), d)\n-        }\n-    }\n-\n-    mod server {\n-        enum ping = pingpong;\n-        enum pong = pingpong;\n-\n-        fn do_ping(-c: ping) -> (pong, ()) {\n-            let mut op = none;\n-            op <-> **c;\n-            let (c, s) <- option::unwrap(op);\n-            let d = s.recv();\n-            let p <- (c, s);\n-            (pong(~mut some(p)), d)\n-        }\n-\n-        fn do_pong(-c: pong) -> ping {\n-            let mut op = none;\n-            op <-> **c;\n-            let (c, s) <- option::unwrap(op);\n-            c.send(());\n-            let p <- (c, s);\n-            ping(~mut some(p))\n-        }\n-    }\n-}\n-\n-fn client(-chan: pingpong::client::ping) {\n-    let chan = pingpong::client::do_ping(chan);\n-    log(error, \"Sent ping\");\n-    let (_chan, _data) = pingpong::client::do_pong(chan);\n-    log(error, \"Received pong\");\n-}\n-\n-fn server(-chan: pingpong::server::ping) {\n-    let (chan, _data) = pingpong::server::do_ping(chan);\n-    log(error, \"Received ping\");\n-    let _chan = pingpong::server::do_pong(chan);\n-    log(error, \"Sent pong\");\n-}\n-\n-fn main() {\n-    let (client_, server_) = pingpong::init();\n-    let client_ = ~mut some(client_);\n-    let server_ = ~mut some(server_);\n-\n-    do task::spawn |move client_| {\n-        let mut client__ = none;\n-        *client_ <-> client__;\n-        client(option::unwrap(client__));\n-    };\n-    do task::spawn |move server_| {\n-        let mut server_\u02ca = none;\n-        *server_ <-> server_\u02ca;\n-        server(option::unwrap(server_\u02ca));\n-    };\n-}"}, {"sha": "0803bbfe531705b39a6e752ca99771224ffea5f6", "filename": "src/test/run-pass/pipe-manual-2.rs", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/fa4134611dfc54e117f196644d30948a75b7b9eb/src%2Ftest%2Frun-pass%2Fpipe-manual-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4134611dfc54e117f196644d30948a75b7b9eb/src%2Ftest%2Frun-pass%2Fpipe-manual-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-manual-2.rs?ref=fa4134611dfc54e117f196644d30948a75b7b9eb", "patch": "@@ -1,93 +0,0 @@\n-/*\n-The first test case using pipes. The idea is to break this into\n-several stages for prototyping. Here's the plan:\n-\n-1. Write an already-compiled protocol using existing ports and chans.\n-\n-2. Take the already-compiled version and add the low-level\n-synchronization code instead. (That's what this file attempts to do)\n-\n-3. Write a syntax extension to compile the protocols.\n-\n-At some point, we'll need to add support for select.\n-\n-*/\n-\n-mod pingpong {\n-    enum ping = *pipes::packet<pong>;\n-    enum pong = *pipes::packet<ping>;\n-\n-    fn init() -> (client::ping, server::ping) {\n-        pipes::entangle()\n-    }\n-\n-    mod client {\n-        type ping = pipes::send_packet<pingpong::ping>;\n-        type pong = pipes::recv_packet<pingpong::pong>;\n-\n-        fn do_ping(-c: ping) -> pong {\n-            let p = pipes::packet();\n-\n-            pipes::send(c, pingpong::ping(p));\n-            pipes::recv_packet(p)\n-        }\n-\n-        fn do_pong(-c: pong) -> (ping, ()) {\n-            let packet = pipes::recv(c);\n-            if packet == none {\n-                fail \"sender closed the connection\"\n-            }\n-            (pipes::send_packet(*option::unwrap(packet)), ())\n-        }\n-    }\n-\n-    mod server {\n-        type ping = pipes::recv_packet<pingpong::ping>;\n-        type pong = pipes::send_packet<pingpong::pong>;\n-\n-        fn do_ping(-c: ping) -> (pong, ()) {\n-            let packet = pipes::recv(c);\n-            if packet == none {\n-                fail \"sender closed the connection\"\n-            }\n-            (pipes::send_packet(*option::unwrap(packet)), ())\n-        }\n-\n-        fn do_pong(-c: pong) -> ping {\n-            let p = pipes::packet();\n-            pipes::send(c, pingpong::pong(p));\n-            pipes::recv_packet(p)\n-        }\n-    }\n-}\n-\n-fn client(-chan: pingpong::client::ping) {\n-    let chan = pingpong::client::do_ping(chan);\n-    log(error, \"Sent ping\");\n-    let (chan, _data) = pingpong::client::do_pong(chan);\n-    log(error, \"Received pong\");\n-}\n-\n-fn server(-chan: pingpong::server::ping) {\n-    let (chan, _data) = pingpong::server::do_ping(chan);\n-    log(error, \"Received ping\");\n-    let chan = pingpong::server::do_pong(chan);\n-    log(error, \"Sent pong\");\n-}\n-\n-fn main() {\n-    let (client_, server_) = pingpong::init();\n-    let client_ = ~mut some(client_);\n-    let server_ = ~mut some(server_);\n-\n-    do task::spawn |move client_| {\n-        let mut client__ = none;\n-        *client_ <-> client__;\n-        client(option::unwrap(client__));\n-    };\n-    do task::spawn |move server_| {\n-        let mut server_\u02ca = none;\n-        *server_ <-> server_\u02ca;\n-        server(option::unwrap(server_\u02ca));\n-    };\n-}"}, {"sha": "9f05038aadc6cfb9c11c7e1012ef19c5e4293cbd", "filename": "src/test/run-pass/pipe-manual-3.rs", "status": "removed", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/fa4134611dfc54e117f196644d30948a75b7b9eb/src%2Ftest%2Frun-pass%2Fpipe-manual-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4134611dfc54e117f196644d30948a75b7b9eb/src%2Ftest%2Frun-pass%2Fpipe-manual-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-manual-3.rs?ref=fa4134611dfc54e117f196644d30948a75b7b9eb", "patch": "@@ -1,129 +0,0 @@\n-/*\n-The first test case using pipes. The idea is to break this into\n-several stages for prototyping. Here's the plan:\n-\n-1. Write an already-compiled protocol using existing ports and chans.\n-\n-2. Take the already-compiled version and add the low-level\n-synchronization code instead.\n-\n-3. Write a syntax extension to compile the protocols.\n-\n-At some point, we'll need to add support for select.\n-\n-This file does horrible things to pretend we have self-move.\n-\n-*/\n-\n-mod pingpong {\n-    enum ping { ping, }\n-    enum ping_message = *pipes::packet<pong_message>;\n-    enum pong { pong, }\n-    enum pong_message = *pipes::packet<ping_message>;\n-\n-    fn init() -> (client::ping, server::ping) {\n-        pipes::entangle()\n-    }\n-\n-    mod client {\n-        type ping = pipes::send_packet<pingpong::ping_message>;\n-        type pong = pipes::recv_packet<pingpong::pong_message>;\n-    }\n-\n-    impl abominable for client::ping {\n-        fn send() -> fn@(-client::ping, ping) -> client::pong {\n-            |pipe, data| {\n-                let p = pipes::packet();\n-                pipes::send(pipe, pingpong::ping_message(p));\n-                pipes::recv_packet(p)\n-            }\n-        }\n-    }\n-\n-    impl abominable for client::pong {\n-        fn recv() -> fn@(-client::pong) -> (client::ping, pong) {\n-            |pipe| {\n-                let packet = pipes::recv(pipe);\n-                if packet == none {\n-                    fail \"sender closed the connection\"\n-                }\n-                let p : pong_message = option::unwrap(packet);\n-                (pipes::send_packet(*p), pong)\n-            }\n-        }\n-    }\n-\n-    mod server {\n-        type ping = pipes::recv_packet<pingpong::ping_message>;\n-        type pong = pipes::send_packet<pingpong::pong_message>;\n-    }\n-\n-    impl abominable for server::ping {\n-        fn recv() -> fn@(-server::ping) -> (server::pong, ping) {\n-            |pipe| {\n-                let packet = pipes::recv(pipe);\n-                if packet == none {\n-                    fail \"sender closed the connection\"\n-                }\n-                let p : ping_message = option::unwrap(packet);\n-                (pipes::send_packet(*p), ping)\n-            }\n-        }\n-    }\n-\n-    impl abominable for server::pong {\n-        fn send() -> fn@(-server::pong, pong) -> server::ping {\n-            |pipe, data| {\n-                let p = pipes::packet();\n-                pipes::send(pipe, pingpong::pong_message(p));\n-                pipes::recv_packet(p)\n-            }\n-        }\n-    }\n-}\n-\n-mod test {\n-    import pingpong::{ping, pong, abominable};\n-\n-    fn macros() {\n-        #macro[\n-            [#send[chan, data],\n-             chan.send()(chan, data)]\n-        ];\n-        #macro[\n-            [#recv[chan],\n-             chan.recv()(chan)]\n-        ];\n-    }\n-\n-    fn client(-chan: pingpong::client::ping) {\n-        let chan = #send(chan, ping);\n-        log(error, \"Sent ping\");\n-        let (chan, _data) = #recv(chan);\n-        log(error, \"Received pong\");\n-    }\n-    \n-    fn server(-chan: pingpong::server::ping) {\n-        let (chan, _data) = #recv(chan);\n-        log(error, \"Received ping\");\n-        let chan = #send(chan, pong);\n-        log(error, \"Sent pong\");\n-    }\n-}\n-\n-fn main() {\n-    let (client_, server_) = pingpong::init();\n-    let client_ = ~mut some(client_);\n-    let server_ = ~mut some(server_);\n-\n-    do task::spawn |move client_| {\n-        let mut client__ = none;\n-        *client_ <-> client__;\n-        test::client(option::unwrap(client__));\n-    };\n-    do task::spawn |move server_| {\n-        let mut server_\u02ca = none;\n-        *server_ <-> server_\u02ca;\n-        test::server(option::unwrap(server_\u02ca));\n-    };\n-}"}, {"sha": "af01e568ffd4024261ac3e6ea957f299219a3c61", "filename": "src/test/run-pass/pipe-select.rs", "status": "modified", "additions": 10, "deletions": 60, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7b03832c958826b27ea77df91f2d2ac276bb7411/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b03832c958826b27ea77df91f2d2ac276bb7411/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-select.rs?ref=7b03832c958826b27ea77df91f2d2ac276bb7411", "patch": "@@ -1,72 +1,22 @@\n+// xfail-pretty\n+\n use std;\n import std::timer::sleep;\n import std::uv;\n \n import pipes::{recv, select};\n \n-// Compiled by pipec\n-mod oneshot {\n-    fn init() -> (client::waiting, server::waiting) { pipes::entangle() }\n-    enum waiting { signal(server::signaled), }\n-    enum signaled { }\n-    mod client {\n-        fn signal(-pipe: waiting) -> signaled {\n-            let (c, s) = pipes::entangle();\n-            let message = oneshot::signal(s);\n-            pipes::send(pipe, message);\n-            c\n-        }\n-        type waiting = pipes::send_packet<oneshot::waiting>;\n-        type signaled = pipes::send_packet<oneshot::signaled>;\n-    }\n-    mod server {\n-        impl recv for waiting {\n-            fn recv() -> extern fn(-waiting) -> oneshot::waiting {\n-                fn recv(-pipe: waiting) -> oneshot::waiting {\n-                    option::unwrap(pipes::recv(pipe))\n-                }\n-                recv\n-            }\n-        }\n-        type waiting = pipes::recv_packet<oneshot::waiting>;\n-        impl recv for signaled {\n-            fn recv() -> extern fn(-signaled) -> oneshot::signaled {\n-                fn recv(-pipe: signaled) -> oneshot::signaled {\n-                    option::unwrap(pipes::recv(pipe))\n-                }\n-                recv\n-            }\n-        }\n-        type signaled = pipes::recv_packet<oneshot::signaled>;\n+proto! oneshot {\n+    waiting:send {\n+        signal -> signaled\n     }\n+\n+    signaled:send { }\n }\n \n-mod stream {\n-    fn init<T: send>() -> (client::stream<T>, server::stream<T>) {\n-        pipes::entangle()\n-    }\n-    enum stream<T: send> { send(T, server::stream<T>), }\n-    mod client {\n-        fn send<T: send>(+pipe: stream<T>, +x_0: T) -> stream<T> {\n-            {\n-                let (c, s) = pipes::entangle();\n-                let message = stream::send(x_0, s);\n-                pipes::send(pipe, message);\n-                c\n-            }\n-        }\n-        type stream<T: send> = pipes::send_packet<stream::stream<T>>;\n-    }\n-    mod server {\n-        impl recv<T: send> for stream<T> {\n-            fn recv() -> extern fn(+stream<T>) -> stream::stream<T> {\n-                fn recv<T: send>(+pipe: stream<T>) -> stream::stream<T> {\n-                    option::unwrap(pipes::recv(pipe))\n-                }\n-                recv\n-            }\n-        }\n-        type stream<T: send> = pipes::recv_packet<stream::stream<T>>;\n+proto! stream {\n+    stream:send<T:send> {\n+        send(T) -> stream<T>\n     }\n }\n "}, {"sha": "c4b44ff0be72912dc28b586e182f535f649eb21e", "filename": "src/test/run-pass/pipe-sleep.rs", "status": "modified", "additions": 9, "deletions": 41, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7b03832c958826b27ea77df91f2d2ac276bb7411/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b03832c958826b27ea77df91f2d2ac276bb7411/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs?ref=7b03832c958826b27ea77df91f2d2ac276bb7411", "patch": "@@ -1,54 +1,22 @@\n+// xfail-pretty\n+\n use std;\n import std::timer::sleep;\n import std::uv;\n+import pipes::recv;\n \n-// Compiled by pipec\n-mod oneshot {\n-    fn init() -> (client::waiting, server::waiting) { pipes::entangle() }\n-    enum waiting { signal(server::signaled), }\n-    enum signaled { }\n-    mod client {\n-        fn signal(-pipe: waiting) -> signaled {\n-            let (c, s) = pipes::entangle();\n-            let message = oneshot::signal(s);\n-            pipes::send(pipe, message);\n-            c\n-        }\n-        type waiting = pipes::send_packet<oneshot::waiting>;\n-        type signaled = pipes::send_packet<oneshot::signaled>;\n-    }\n-    mod server {\n-        impl recv for waiting {\n-            fn recv() -> extern fn(-waiting) -> oneshot::waiting {\n-                fn recv(-pipe: waiting) -> oneshot::waiting {\n-                    option::unwrap(pipes::recv(pipe))\n-                }\n-                recv\n-            }\n-        }\n-        type waiting = pipes::recv_packet<oneshot::waiting>;\n-        impl recv for signaled {\n-            fn recv() -> extern fn(-signaled) -> oneshot::signaled {\n-                fn recv(-pipe: signaled) -> oneshot::signaled {\n-                    option::unwrap(pipes::recv(pipe))\n-                }\n-                recv\n-            }\n-        }\n-        type signaled = pipes::recv_packet<oneshot::signaled>;\n+proto! oneshot {\n+    waiting:send {\n+        signal -> signaled\n     }\n+\n+    signaled:send { }\n }\n \n fn main() {\n     import oneshot::client::*;\n-    import oneshot::server::recv;\n-\n-    #macro[\n-        [#recv[chan],\n-         chan.recv()(chan)]\n-    ];\n \n-    let c = pipes::spawn_service(oneshot::init, |p| { #recv(p); });\n+    let c = pipes::spawn_service(oneshot::init, |p| { recv(p); });\n \n     let iotask = uv::global_loop::get();\n     sleep(iotask, 5000);"}]}