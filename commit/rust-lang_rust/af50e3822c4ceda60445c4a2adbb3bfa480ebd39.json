{"sha": "af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmNTBlMzgyMmM0Y2VkYTYwNDQ1YzRhMmFkYmIzYmZhNDgwZWJkMzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-22T14:26:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-22T14:26:15Z"}, "message": "Auto merge of #54457 - pietroalbini:rollup, r=pietroalbini\n\nRollup of 16 pull requests\n\nSuccessful merges:\n\n - #53652 (define copy_within on slices)\n - #54261 (Make `dyn` a keyword in the 2018 edition)\n - #54280 (remove (more) CAS API from Atomic* types where not natively supported)\n - #54323 (rustbuild: drop color handling)\n - #54350 (Support specifying edition in doc test)\n - #54370 (Improve handling of type bounds in `bit_set.rs`.)\n - #54371 (add -Zui-testing to rustdoc)\n - #54374 (Make 'proc_macro::MultiSpan' public.)\n - #54402 (Use no_default_libraries for all NetBSD flavors)\n - #54409 (Detect `for _ in in bar {}` typo)\n - #54412 (add applicability to span_suggestion call)\n - #54413 (Add UI test for deref recursion limit printing twice)\n - #54415 (parser: Tweak function parameter parsing to avoid rollback on succesfull path)\n - #54420 (Compress `Liveness` data some more.)\n - #54422 (Simplify slice's first(_mut) and last(_mut) with get)\n - #54446 (Unify christianpoveda's emails)\n\nFailed merges:\n\n - #54058 (Introduce the partition_dedup/by/by_key methods for slices)\n\nr? @ghost", "tree": {"sha": "34fd72c893b38708f648f92b4222ebc7ea625b9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34fd72c893b38708f648f92b4222ebc7ea625b9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "html_url": "https://github.com/rust-lang/rust/commit/af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7b5ba8661aa844a06c37f22d7af0afb1807d347", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7b5ba8661aa844a06c37f22d7af0afb1807d347", "html_url": "https://github.com/rust-lang/rust/commit/e7b5ba8661aa844a06c37f22d7af0afb1807d347"}, {"sha": "48ec53ccaebe555832114612b6c3f8df183c0a91", "url": "https://api.github.com/repos/rust-lang/rust/commits/48ec53ccaebe555832114612b6c3f8df183c0a91", "html_url": "https://github.com/rust-lang/rust/commit/48ec53ccaebe555832114612b6c3f8df183c0a91"}], "stats": {"total": 1359, "additions": 912, "deletions": 447}, "files": [{"sha": "f63b299ffd57e8b8f6aa5238628184fc57832f39", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -52,6 +52,7 @@ Chris C Cerami <chrisccerami@users.noreply.github.com> Chris C Cerami <chrisccer\n Chris Pressey <cpressey@gmail.com>\n Chris Thorn <chris@thorn.co> Chris Thorn <thorn@thoughtbot.com>\n Chris Vittal <christopher.vittal@gmail.com> Christopher Vittal <christopher.vittal@gmail.com>\n+Christian Poveda <christianpoveda@protonmail.com> <z1mvader@protonmail.com> <cn.poveda.ruiz@gmail.com>\n Clark Gaebel <cg.wowus.cg@gmail.com> <cgaebel@mozilla.com>\n Clinton Ryan <clint.ryan3@gmail.com>\n Corey Richardson <corey@octayn.net> Elaine \"See More\" Nemo <corey@octayn.net>"}, {"sha": "b89976eca26c4b69dbfb13a27fbf919e91a5b257", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -291,15 +291,6 @@ fn main() {\n         cmd.arg(\"-Z\").arg(\"verify-llvm-ir\");\n     }\n \n-    let color = match env::var(\"RUSTC_COLOR\") {\n-        Ok(s) => usize::from_str(&s).expect(\"RUSTC_COLOR should be an integer\"),\n-        Err(_) => 0,\n-    };\n-\n-    if color != 0 {\n-        cmd.arg(\"--color=always\");\n-    }\n-\n     if env::var_os(\"RUSTC_DENY_WARNINGS\").is_some() && env::var_os(\"RUSTC_EXTERNAL_TOOL\").is_none()\n     {\n         cmd.arg(\"-Dwarnings\");"}, {"sha": "608f2c982c2a52485abfd8751054f189a759cf5f", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -29,7 +29,7 @@ use build_helper::{output, mtime, up_to_date};\n use filetime::FileTime;\n use serde_json;\n \n-use util::{exe, libdir, is_dylib, CiEnv};\n+use util::{exe, libdir, is_dylib};\n use {Compiler, Mode, GitRepo};\n use native;\n \n@@ -1034,29 +1034,6 @@ pub fn add_to_sysroot(builder: &Builder, sysroot_dst: &Path, stamp: &Path) {\n     }\n }\n \n-// Avoiding a dependency on winapi to keep compile times down\n-#[cfg(unix)]\n-fn stderr_isatty() -> bool {\n-    use libc;\n-    unsafe { libc::isatty(libc::STDERR_FILENO) != 0 }\n-}\n-#[cfg(windows)]\n-fn stderr_isatty() -> bool {\n-    type DWORD = u32;\n-    type BOOL = i32;\n-    type HANDLE = *mut u8;\n-    const STD_ERROR_HANDLE: DWORD = -12i32 as DWORD;\n-    extern \"system\" {\n-        fn GetStdHandle(which: DWORD) -> HANDLE;\n-        fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: *mut DWORD) -> BOOL;\n-    }\n-    unsafe {\n-        let handle = GetStdHandle(STD_ERROR_HANDLE);\n-        let mut out = 0;\n-        GetConsoleMode(handle, &mut out) != 0\n-    }\n-}\n-\n pub fn run_cargo(builder: &Builder,\n                  cargo: &mut Command,\n                  tail_args: Vec<String>,\n@@ -1218,15 +1195,6 @@ pub fn stream_cargo(\n     cargo.arg(\"--message-format\").arg(\"json\")\n          .stdout(Stdio::piped());\n \n-    if stderr_isatty() && builder.ci_env == CiEnv::None &&\n-        // if the terminal is reported as dumb, then we don't want to enable color for rustc\n-        env::var_os(\"TERM\").map(|t| t != *\"dumb\").unwrap_or(true) {\n-        // since we pass message-format=json to cargo, we need to tell the rustc\n-        // wrapper to give us colored output if necessary. This is because we\n-        // only want Cargo's JSON output, not rustcs.\n-        cargo.env(\"RUSTC_COLOR\", \"1\");\n-    }\n-\n     for arg in tail_args {\n         cargo.arg(arg);\n     }"}, {"sha": "dd8dcb7ff9bd23e886b3071c60b69af31cf3e17f", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -323,6 +323,22 @@ compiles, then the test will fail. However please note that code failing\n with the current Rust release may work in a future release, as new features\n are added.\n \n+```text\n+/// Only runs on the 2018 edition.\n+///\n+/// ```edition2018\n+/// let result: Result<i32, ParseIntError> = try {\n+///     \"1\".parse::<i32>()?\n+///         + \"2\".parse::<i32>()?\n+///         + \"3\".parse::<i32>()?\n+/// };\n+/// ```\n+```\n+\n+`edition2018` tells `rustdoc` that the code sample should be compiled the 2018\n+edition of Rust. Similarly, you can specify `edition2015` to compile the code\n+with the 2015 edition.\n+\n ## Syntax reference\n \n The *exact* syntax for code blocks, including the edge cases, can be found"}, {"sha": "e342c260a739bf405827de5d2b6b3c9f5ce82f19", "filename": "src/doc/unstable-book/src/language-features/try-blocks.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftry-blocks.md", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftry-blocks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftry-blocks.md?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -9,9 +9,7 @@ The tracking issue for this feature is: [#31436]\n The `try_blocks` feature adds support for `try` blocks. A `try`\n block creates a new scope one can use the `?` operator in.\n \n-```rust,ignore\n-// This code needs the 2018 edition\n-\n+```rust,edition2018\n #![feature(try_blocks)]\n \n use std::num::ParseIntError;"}, {"sha": "aed9020d9d14a09b8124310dd23716310e4efc7c", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 63, "deletions": 6, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -119,7 +119,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn first(&self) -> Option<&T> {\n-        if self.is_empty() { None } else { Some(&self[0]) }\n+        self.get(0)\n     }\n \n     /// Returns a mutable pointer to the first element of the slice, or `None` if it is empty.\n@@ -137,7 +137,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn first_mut(&mut self) -> Option<&mut T> {\n-        if self.is_empty() { None } else { Some(&mut self[0]) }\n+        self.get_mut(0)\n     }\n \n     /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n@@ -239,7 +239,8 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn last(&self) -> Option<&T> {\n-        if self.is_empty() { None } else { Some(&self[self.len() - 1]) }\n+        let last_idx = self.len().checked_sub(1)?;\n+        self.get(last_idx)\n     }\n \n     /// Returns a mutable pointer to the last item in the slice.\n@@ -257,9 +258,8 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn last_mut(&mut self) -> Option<&mut T> {\n-        let len = self.len();\n-        if len == 0 { return None; }\n-        Some(&mut self[len - 1])\n+        let last_idx = self.len().checked_sub(1)?;\n+        self.get_mut(last_idx)\n     }\n \n     /// Returns a reference to an element or subslice depending on the type of\n@@ -1618,6 +1618,63 @@ impl<T> [T] {\n         }\n     }\n \n+    /// Copies elements from one part of the slice to another part of itself,\n+    /// using a memmove.\n+    ///\n+    /// `src` is the range within `self` to copy from. `dest` is the starting\n+    /// index of the range within `self` to copy to, which will have the same\n+    /// length as `src`. The two ranges may overlap. The ends of the two ranges\n+    /// must be less than or equal to `self.len()`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if either range exceeds the end of the slice,\n+    /// or if the end of `src` is before the start.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Copying four bytes within a slice:\n+    ///\n+    /// ```\n+    /// # #![feature(copy_within)]\n+    /// let mut bytes = *b\"Hello, World!\";\n+    ///\n+    /// bytes.copy_within(1..5, 8);\n+    ///\n+    /// assert_eq!(&bytes, b\"Hello, Wello!\");\n+    /// ```\n+    #[unstable(feature = \"copy_within\", issue = \"54236\")]\n+    pub fn copy_within<R: ops::RangeBounds<usize>>(&mut self, src: R, dest: usize)\n+    where\n+        T: Copy,\n+    {\n+        let src_start = match src.start_bound() {\n+            ops::Bound::Included(&n) => n,\n+            ops::Bound::Excluded(&n) => n\n+                .checked_add(1)\n+                .unwrap_or_else(|| slice_index_overflow_fail()),\n+            ops::Bound::Unbounded => 0,\n+        };\n+        let src_end = match src.end_bound() {\n+            ops::Bound::Included(&n) => n\n+                .checked_add(1)\n+                .unwrap_or_else(|| slice_index_overflow_fail()),\n+            ops::Bound::Excluded(&n) => n,\n+            ops::Bound::Unbounded => self.len(),\n+        };\n+        assert!(src_start <= src_end, \"src end is before src start\");\n+        assert!(src_end <= self.len(), \"src is out of bounds\");\n+        let count = src_end - src_start;\n+        assert!(dest <= self.len() - count, \"dest is out of bounds\");\n+        unsafe {\n+            ptr::copy(\n+                self.get_unchecked(src_start),\n+                self.get_unchecked_mut(dest),\n+                count,\n+            );\n+        }\n+    }\n+\n     /// Swaps all elements in `self` with those in `other`.\n     ///\n     /// The length of `other` must be the same as `self`."}, {"sha": "69c524925fc546e9d82f9f1a9aab80cba7e504bc", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -558,6 +558,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n+    #[cfg(target_has_atomic = \"cas\")]\n     pub fn compare_exchange_weak(&self,\n                                  current: bool,\n                                  new: bool,\n@@ -1041,6 +1042,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n+    #[cfg(target_has_atomic = \"cas\")]\n     pub fn compare_exchange_weak(&self,\n                                  current: *mut T,\n                                  new: *mut T,\n@@ -1434,6 +1436,7 @@ loop {\n ```\"),\n                 #[inline]\n                 #[$stable_cxchg]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn compare_exchange_weak(&self,\n                                              current: $int_type,\n                                              new: $int_type,\n@@ -1471,6 +1474,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_add(self.v.get(), val, order) }\n                 }\n@@ -1502,6 +1506,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_sub(self.v.get(), val, order) }\n                 }\n@@ -1536,6 +1541,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n ```\"),\n                 #[inline]\n                 #[$stable]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_and(self.v.get(), val, order) }\n                 }\n@@ -1571,6 +1577,7 @@ assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n ```\"),\n                 #[inline]\n                 #[$stable_nand]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_nand(self.v.get(), val, order) }\n                 }\n@@ -1605,6 +1612,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n ```\"),\n                 #[inline]\n                 #[$stable]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_or(self.v.get(), val, order) }\n                 }\n@@ -1639,6 +1647,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n ```\"),\n                 #[inline]\n                 #[$stable]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_xor(self.v.get(), val, order) }\n                 }\n@@ -1688,6 +1697,7 @@ assert_eq!(x.load(Ordering::SeqCst), 9);\n                 #[unstable(feature = \"no_more_cas\",\n                        reason = \"no more CAS loops in user code\",\n                        issue = \"48655\")]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_update<F>(&self,\n                                        mut f: F,\n                                        fetch_order: Ordering,\n@@ -1748,6 +1758,7 @@ assert!(max_foo == 42);\n                 #[unstable(feature = \"atomic_min_max\",\n                        reason = \"easier and faster min/max than writing manual CAS loop\",\n                        issue = \"48655\")]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { $max_fn(self.v.get(), val, order) }\n                 }\n@@ -1799,6 +1810,7 @@ assert_eq!(min_foo, 12);\n                 #[unstable(feature = \"atomic_min_max\",\n                        reason = \"easier and faster min/max than writing manual CAS loop\",\n                        issue = \"48655\")]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { $min_fn(self.v.get(), val, order) }\n                 }\n@@ -1987,6 +1999,7 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_add).\n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xadd_acq(dst, val),\n@@ -1999,6 +2012,7 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_sub).\n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xsub_acq(dst, val),\n@@ -2035,6 +2049,7 @@ unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n }\n \n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n                                           old: T,\n                                           new: T,\n@@ -2059,6 +2074,7 @@ unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n }\n \n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_and_acq(dst, val),\n@@ -2070,6 +2086,7 @@ unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_nand_acq(dst, val),\n@@ -2081,6 +2098,7 @@ unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_or_acq(dst, val),\n@@ -2092,6 +2110,7 @@ unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xor_acq(dst, val),\n@@ -2104,6 +2123,7 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (signed comparison)\n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_max_acq(dst, val),\n@@ -2116,6 +2136,7 @@ unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (signed comparison)\n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_min_acq(dst, val),\n@@ -2128,6 +2149,7 @@ unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (signed comparison)\n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_umax_acq(dst, val),\n@@ -2140,6 +2162,7 @@ unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (signed comparison)\n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_umin<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_umin_acq(dst, val),"}, {"sha": "8fc32f40b9920275a3f364edd5b0e44d556fe257", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -39,6 +39,7 @@\n #![feature(inner_deref)]\n #![feature(slice_internals)]\n #![feature(option_replace)]\n+#![feature(copy_within)]\n \n extern crate core;\n extern crate test;"}, {"sha": "d46a35ab82cfcae93dbaed7f6f3ceba5853adba7", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -1000,3 +1000,49 @@ fn test_align_to_empty_mid() {\n         assert_eq!(mid.as_ptr() as usize % mem::align_of::<Chunk>(), 0);\n     }\n }\n+\n+#[test]\n+fn test_copy_within() {\n+    // Start to end, with a RangeTo.\n+    let mut bytes = *b\"Hello, World!\";\n+    bytes.copy_within(..3, 10);\n+    assert_eq!(&bytes, b\"Hello, WorHel\");\n+\n+    // End to start, with a RangeFrom.\n+    let mut bytes = *b\"Hello, World!\";\n+    bytes.copy_within(10.., 0);\n+    assert_eq!(&bytes, b\"ld!lo, World!\");\n+\n+    // Overlapping, with a RangeInclusive.\n+    let mut bytes = *b\"Hello, World!\";\n+    bytes.copy_within(0..=11, 1);\n+    assert_eq!(&bytes, b\"HHello, World\");\n+\n+    // Whole slice, with a RangeFull.\n+    let mut bytes = *b\"Hello, World!\";\n+    bytes.copy_within(.., 0);\n+    assert_eq!(&bytes, b\"Hello, World!\");\n+}\n+\n+#[test]\n+#[should_panic(expected = \"src is out of bounds\")]\n+fn test_copy_within_panics_src_too_long() {\n+    let mut bytes = *b\"Hello, World!\";\n+    // The length is only 13, so 14 is out of bounds.\n+    bytes.copy_within(10..14, 0);\n+}\n+\n+#[test]\n+#[should_panic(expected = \"dest is out of bounds\")]\n+fn test_copy_within_panics_dest_too_long() {\n+    let mut bytes = *b\"Hello, World!\";\n+    // The length is only 13, so a slice of length 4 starting at index 10 is out of bounds.\n+    bytes.copy_within(0..4, 10);\n+}\n+#[test]\n+#[should_panic(expected = \"src end is before src start\")]\n+fn test_copy_within_panics_src_inverted() {\n+    let mut bytes = *b\"Hello, World!\";\n+    // 2 is greater than 1, so this range is invalid.\n+    bytes.copy_within(2..1, 0);\n+}"}, {"sha": "d885f9b406f59117642ac3915b2f969a420766a0", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -48,7 +48,7 @@ pub mod rustc;\n mod diagnostic;\n \n #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n-pub use diagnostic::{Diagnostic, Level};\n+pub use diagnostic::{Diagnostic, Level, MultiSpan};\n \n use std::{ascii, fmt, iter};\n use std::path::PathBuf;"}, {"sha": "0d70a64123bf364903fa7e328d4133d3872881aa", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 149, "deletions": 58, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -64,10 +64,10 @@\n //! methods.  It effectively does a reverse walk of the AST; whenever we\n //! reach a loop node, we iterate until a fixed point is reached.\n //!\n-//! ## The `users_*` fields\n+//! ## The `RWU` struct\n //!\n //! At each live node `N`, we track three pieces of information for each\n-//! variable `V` (these are in the `users_*` fields):\n+//! variable `V` (these are encapsulated in the `RWU` struct):\n //!\n //! - `reader`: the `LiveNode` ID of some node which will read the value\n //!    that `V` holds on entry to `N`.  Formally: a node `M` such\n@@ -536,6 +536,112 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n // Actually we compute just a bit more than just liveness, but we use\n // the same basic propagation framework in all cases.\n \n+#[derive(Clone, Copy)]\n+struct RWU {\n+    reader: LiveNode,\n+    writer: LiveNode,\n+    used: bool\n+}\n+\n+/// Conceptually, this is like a `Vec<RWU>`. But the number of `RWU`s can get\n+/// very large, so it uses a more compact representation that takes advantage\n+/// of the fact that when the number of `RWU`s is large, most of them have an\n+/// invalid reader and an invalid writer.\n+struct RWUTable {\n+    /// Each entry in `packed_rwus` is either INV_INV_FALSE, INV_INV_TRUE, or\n+    /// an index into `unpacked_rwus`. In the common cases, this compacts the\n+    /// 65 bits of data into 32; in the uncommon cases, it expands the 65 bits\n+    /// in 96.\n+    ///\n+    /// More compact representations are possible -- e.g. use only 2 bits per\n+    /// packed `RWU` and make the secondary table a HashMap that maps from\n+    /// indices to `RWU`s -- but this one strikes a good balance between size\n+    /// and speed.\n+    packed_rwus: Vec<u32>,\n+    unpacked_rwus: Vec<RWU>,\n+}\n+\n+// A constant representing `RWU { reader: invalid_node(); writer: invalid_node(); used: false }`.\n+const INV_INV_FALSE: u32 = u32::MAX;\n+\n+// A constant representing `RWU { reader: invalid_node(); writer: invalid_node(); used: true }`.\n+const INV_INV_TRUE: u32 = u32::MAX - 1;\n+\n+impl RWUTable {\n+    fn new(num_rwus: usize) -> RWUTable {\n+        Self {\n+            packed_rwus: vec![INV_INV_FALSE; num_rwus],\n+            unpacked_rwus: vec![],\n+        }\n+    }\n+\n+    fn get(&self, idx: usize) -> RWU {\n+        let packed_rwu = self.packed_rwus[idx];\n+        match packed_rwu {\n+            INV_INV_FALSE => RWU { reader: invalid_node(), writer: invalid_node(), used: false },\n+            INV_INV_TRUE => RWU { reader: invalid_node(), writer: invalid_node(), used: true },\n+            _ => self.unpacked_rwus[packed_rwu as usize],\n+        }\n+    }\n+\n+    fn get_reader(&self, idx: usize) -> LiveNode {\n+        let packed_rwu = self.packed_rwus[idx];\n+        match packed_rwu {\n+            INV_INV_FALSE | INV_INV_TRUE => invalid_node(),\n+            _ => self.unpacked_rwus[packed_rwu as usize].reader,\n+        }\n+    }\n+\n+    fn get_writer(&self, idx: usize) -> LiveNode {\n+        let packed_rwu = self.packed_rwus[idx];\n+        match packed_rwu {\n+            INV_INV_FALSE | INV_INV_TRUE => invalid_node(),\n+            _ => self.unpacked_rwus[packed_rwu as usize].writer,\n+        }\n+    }\n+\n+    fn get_used(&self, idx: usize) -> bool {\n+        let packed_rwu = self.packed_rwus[idx];\n+        match packed_rwu {\n+            INV_INV_FALSE => false,\n+            INV_INV_TRUE => true,\n+            _ => self.unpacked_rwus[packed_rwu as usize].used,\n+        }\n+    }\n+\n+    #[inline]\n+    fn copy_packed(&mut self, dst_idx: usize, src_idx: usize) {\n+        self.packed_rwus[dst_idx] = self.packed_rwus[src_idx];\n+    }\n+\n+    fn assign_unpacked(&mut self, idx: usize, rwu: RWU) {\n+        if rwu.reader == invalid_node() && rwu.writer == invalid_node() {\n+            // When we overwrite an indexing entry in `self.packed_rwus` with\n+            // `INV_INV_{TRUE,FALSE}` we don't remove the corresponding entry\n+            // from `self.unpacked_rwus`; it's not worth the effort, and we\n+            // can't have entries shifting around anyway.\n+            self.packed_rwus[idx] = if rwu.used {\n+                INV_INV_TRUE\n+            } else {\n+                INV_INV_FALSE\n+            }\n+        } else {\n+            // Add a new RWU to `unpacked_rwus` and make `packed_rwus[idx]`\n+            // point to it.\n+            self.packed_rwus[idx] = self.unpacked_rwus.len() as u32;\n+            self.unpacked_rwus.push(rwu);\n+        }\n+    }\n+\n+    fn assign_inv_inv(&mut self, idx: usize) {\n+        self.packed_rwus[idx] = if self.get_used(idx) {\n+            INV_INV_TRUE\n+        } else {\n+            INV_INV_FALSE\n+        };\n+    }\n+}\n+\n #[derive(Copy, Clone)]\n struct Specials {\n     exit_ln: LiveNode,\n@@ -552,14 +658,7 @@ struct Liveness<'a, 'tcx: 'a> {\n     tables: &'a ty::TypeckTables<'tcx>,\n     s: Specials,\n     successors: Vec<LiveNode>,\n-\n-    // We used to have a single `users: Vec<Users>` field here, where `Users`\n-    // had `reader`, `writer` and `used` fields. But the number of users can\n-    // get very large, and it's more compact to store the data in three\n-    // separate `Vec`s so that no space is wasted for padding.\n-    users_reader: Vec<LiveNode>,\n-    users_writer: Vec<LiveNode>,\n-    users_used: Vec<bool>,\n+    rwu_table: RWUTable,\n \n     // mappings from loop node ID to LiveNode\n     // (\"break\" label should map to loop node ID,\n@@ -584,16 +683,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         let num_live_nodes = ir.num_live_nodes;\n         let num_vars = ir.num_vars;\n-        let num_users = num_live_nodes * num_vars;\n \n         Liveness {\n             ir,\n             tables,\n             s: specials,\n             successors: vec![invalid_node(); num_live_nodes],\n-            users_reader: vec![invalid_node(); num_users],\n-            users_writer: vec![invalid_node(); num_users],\n-            users_used: vec![false; num_users],\n+            rwu_table: RWUTable::new(num_live_nodes * num_vars),\n             break_ln: NodeMap(),\n             cont_ln: NodeMap(),\n         }\n@@ -657,16 +753,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         ln.get() * self.ir.num_vars + var.get()\n     }\n \n-    fn live_on_entry(&self, ln: LiveNode, var: Variable)\n-                      -> Option<LiveNodeKind> {\n+    fn live_on_entry(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n-        let reader = self.users_reader[self.idx(ln, var)];\n-        if reader.is_valid() {Some(self.ir.lnk(reader))} else {None}\n+        let reader = self.rwu_table.get_reader(self.idx(ln, var));\n+        if reader.is_valid() { Some(self.ir.lnk(reader)) } else { None }\n     }\n \n-    /*\n-    Is this variable live on entry to any of its successor nodes?\n-    */\n+    // Is this variable live on entry to any of its successor nodes?\n     fn live_on_exit(&self, ln: LiveNode, var: Variable)\n                     -> Option<LiveNodeKind> {\n         let successor = self.successors[ln.get()];\n@@ -675,14 +768,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n         assert!(ln.is_valid());\n-        self.users_used[self.idx(ln, var)]\n+        self.rwu_table.get_used(self.idx(ln, var))\n     }\n \n     fn assigned_on_entry(&self, ln: LiveNode, var: Variable)\n                          -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n-        let writer = self.users_writer[self.idx(ln, var)];\n-        if writer.is_valid() {Some(self.ir.lnk(writer))} else {None}\n+        let writer = self.rwu_table.get_writer(self.idx(ln, var));\n+        if writer.is_valid() { Some(self.ir.lnk(writer)) } else { None }\n     }\n \n     fn assigned_on_exit(&self, ln: LiveNode, var: Variable)\n@@ -725,9 +818,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         {\n             let wr = &mut wr as &mut dyn Write;\n             write!(wr, \"[ln({:?}) of kind {:?} reads\", ln.get(), self.ir.lnk(ln));\n-            self.write_vars(wr, ln, |idx| self.users_reader[idx]);\n+            self.write_vars(wr, ln, |idx| self.rwu_table.get_reader(idx));\n             write!(wr, \"  writes\");\n-            self.write_vars(wr, ln, |idx| self.users_writer[idx]);\n+            self.write_vars(wr, ln, |idx| self.rwu_table.get_writer(idx));\n             write!(wr, \"  precedes {:?}]\", self.successors[ln.get()]);\n         }\n         String::from_utf8(wr).unwrap()\n@@ -736,26 +829,17 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn init_empty(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n         self.successors[ln.get()] = succ_ln;\n \n-        // It is not necessary to initialize the\n-        // values to empty because this is the value\n-        // they have when they are created, and the sets\n-        // only grow during iterations.\n-        //\n-        // self.indices(ln) { |idx|\n-        //     self.users_reader[idx] = invalid_node();\n-        //     self.users_writer[idx] = invalid_node();\n-        //     self.users_used[idx] = false;\n-        // }\n+        // It is not necessary to initialize the RWUs here because they are all\n+        // set to INV_INV_FALSE when they are created, and the sets only grow\n+        // during iterations.\n     }\n \n     fn init_from_succ(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n         // more efficient version of init_empty() / merge_from_succ()\n         self.successors[ln.get()] = succ_ln;\n \n         self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n-            this.users_reader[idx] = this.users_reader[succ_idx];\n-            this.users_writer[idx] = this.users_writer[succ_idx];\n-            this.users_used[idx] = this.users_used[succ_idx];\n+            this.rwu_table.copy_packed(idx, succ_idx);\n         });\n         debug!(\"init_from_succ(ln={}, succ={})\",\n                self.ln_str(ln), self.ln_str(succ_ln));\n@@ -770,35 +854,39 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         let mut changed = false;\n         self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n-            changed |= copy_if_invalid(this.users_reader[succ_idx], &mut this.users_reader[idx]);\n-            changed |= copy_if_invalid(this.users_writer[succ_idx], &mut this.users_writer[idx]);\n-            if this.users_used[succ_idx] && !this.users_used[idx] {\n-                this.users_used[idx] = true;\n+            let mut rwu = this.rwu_table.get(idx);\n+            let succ_rwu = this.rwu_table.get(succ_idx);\n+            if succ_rwu.reader.is_valid() && !rwu.reader.is_valid() {\n+                rwu.reader = succ_rwu.reader;\n+                changed = true\n+            }\n+\n+            if succ_rwu.writer.is_valid() && !rwu.writer.is_valid() {\n+                rwu.writer = succ_rwu.writer;\n+                changed = true\n+            }\n+\n+            if succ_rwu.used && !rwu.used {\n+                rwu.used = true;\n                 changed = true;\n             }\n+\n+            if changed {\n+                this.rwu_table.assign_unpacked(idx, rwu);\n+            }\n         });\n \n         debug!(\"merge_from_succ(ln={:?}, succ={}, first_merge={}, changed={})\",\n                ln, self.ln_str(succ_ln), first_merge, changed);\n         return changed;\n-\n-        fn copy_if_invalid(src: LiveNode, dst: &mut LiveNode) -> bool {\n-            if src.is_valid() && !dst.is_valid() {\n-                *dst = src;\n-                true\n-            } else {\n-                false\n-            }\n-        }\n     }\n \n     // Indicates that a local variable was *defined*; we know that no\n     // uses of the variable can precede the definition (resolve checks\n     // this) so we just clear out all the data.\n     fn define(&mut self, writer: LiveNode, var: Variable) {\n         let idx = self.idx(writer, var);\n-        self.users_reader[idx] = invalid_node();\n-        self.users_writer[idx] = invalid_node();\n+        self.rwu_table.assign_inv_inv(idx);\n \n         debug!(\"{:?} defines {:?} (idx={}): {}\", writer, var,\n                idx, self.ln_str(writer));\n@@ -810,21 +898,24 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                ln, acc, var, self.ln_str(ln));\n \n         let idx = self.idx(ln, var);\n+        let mut rwu = self.rwu_table.get(idx);\n \n         if (acc & ACC_WRITE) != 0 {\n-            self.users_reader[idx] = invalid_node();\n-            self.users_writer[idx] = ln;\n+            rwu.reader = invalid_node();\n+            rwu.writer = ln;\n         }\n \n         // Important: if we both read/write, must do read second\n         // or else the write will override.\n         if (acc & ACC_READ) != 0 {\n-            self.users_reader[idx] = ln;\n+            rwu.reader = ln;\n         }\n \n         if (acc & ACC_USE) != 0 {\n-            self.users_used[idx] = true;\n+            rwu.used = true;\n         }\n+\n+        self.rwu_table.assign_unpacked(idx, rwu);\n     }\n \n     // _______________________________________________________________________"}, {"sha": "9ffddf353acd4bae16c27f78e2136ea0484d0c00", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -44,7 +44,7 @@ use ty::relate::TypeRelation;\n use middle::lang_items;\n use mir::interpret::{GlobalId};\n \n-use rustc_data_structures::bit_set::BitSet;\n+use rustc_data_structures::bit_set::GrowableBitSet;\n use rustc_data_structures::sync::Lock;\n use std::iter;\n use std::cmp;\n@@ -3054,7 +3054,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 } else {\n                     return Err(Unimplemented);\n                 };\n-                let mut ty_params = BitSet::new_empty(substs_a.types().count());\n+                let mut ty_params = GrowableBitSet::new_empty();\n                 let mut found = false;\n                 for ty in field.walk() {\n                     if let ty::Param(p) = ty.sty {"}, {"sha": "1fba57fa541f0140c8b96e9980ca9d025536ed73", "filename": "src/librustc_data_structures/bit_set.rs", "status": "modified", "additions": 190, "deletions": 196, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustc_data_structures%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustc_data_structures%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use indexed_vec::{Idx, IndexVec};\n-use rustc_serialize;\n use smallvec::SmallVec;\n use std::fmt;\n use std::iter;\n@@ -26,68 +25,68 @@ pub const WORD_BITS: usize = WORD_BYTES * 8;\n ///\n /// `T` is an index type, typically a newtyped `usize` wrapper, but it can also\n /// just be `usize`.\n-#[derive(Clone, Eq, PartialEq)]\n+///\n+/// All operations that involve an element will panic if the element is equal\n+/// to or greater than the domain size. All operations that involve two bitsets\n+/// will panic if the bitsets have differing domain sizes.\n+#[derive(Clone, Eq, PartialEq, RustcDecodable, RustcEncodable)]\n pub struct BitSet<T: Idx> {\n+    domain_size: usize,\n     words: Vec<Word>,\n     marker: PhantomData<T>,\n }\n \n impl<T: Idx> BitSet<T> {\n+    /// Create a new, empty bitset with a given `domain_size`.\n     #[inline]\n     pub fn new_empty(domain_size: usize) -> BitSet<T> {\n         let num_words = num_words(domain_size);\n         BitSet {\n+            domain_size,\n             words: vec![0; num_words],\n             marker: PhantomData,\n         }\n     }\n \n+    /// Create a new, filled bitset with a given `domain_size`.\n     #[inline]\n     pub fn new_filled(domain_size: usize) -> BitSet<T> {\n         let num_words = num_words(domain_size);\n         let mut result = BitSet {\n+            domain_size,\n             words: vec![!0; num_words],\n             marker: PhantomData,\n         };\n-        result.clear_above(domain_size);\n+        result.clear_excess_bits();\n         result\n     }\n \n+    /// Get the domain size.\n+    pub fn domain_size(&self) -> usize {\n+        self.domain_size\n+    }\n+\n+    /// Clear all elements.\n     #[inline]\n     pub fn clear(&mut self) {\n         for word in &mut self.words {\n             *word = 0;\n         }\n     }\n \n-    /// Sets all elements up to and including `size`.\n-    pub fn set_up_to(&mut self, elem: usize) {\n-        for word in &mut self.words {\n-            *word = !0;\n+    /// Clear excess bits in the final word.\n+    fn clear_excess_bits(&mut self) {\n+        let num_bits_in_final_word = self.domain_size % WORD_BITS;\n+        if num_bits_in_final_word > 0 {\n+            let mask = (1 << num_bits_in_final_word) - 1;\n+            let final_word_idx = self.words.len() - 1;\n+            self.words[final_word_idx] &= mask;\n         }\n-        self.clear_above(elem);\n     }\n \n-    /// Clear all elements above `elem`.\n-    fn clear_above(&mut self, elem: usize) {\n-        let first_clear_block = elem / WORD_BITS;\n-\n-        if first_clear_block < self.words.len() {\n-            // Within `first_clear_block`, the `elem % WORD_BITS` LSBs should\n-            // remain.\n-            let mask = (1 << (elem % WORD_BITS)) - 1;\n-            self.words[first_clear_block] &= mask;\n-\n-            // All the blocks above `first_clear_block` are fully cleared.\n-            for word in &mut self.words[first_clear_block + 1..] {\n-                *word = 0;\n-            }\n-        }\n-    }\n-\n-    /// Efficiently overwrite `self` with `other`. Panics if `self` and `other`\n-    /// don't have the same length.\n+    /// Efficiently overwrite `self` with `other`.\n     pub fn overwrite(&mut self, other: &BitSet<T>) {\n+        assert!(self.domain_size == other.domain_size);\n         self.words.clone_from_slice(&other.words);\n     }\n \n@@ -99,16 +98,15 @@ impl<T: Idx> BitSet<T> {\n     /// True if `self` contains `elem`.\n     #[inline]\n     pub fn contains(&self, elem: T) -> bool {\n+        assert!(elem.index() < self.domain_size);\n         let (word_index, mask) = word_index_and_mask(elem);\n         (self.words[word_index] & mask) != 0\n     }\n \n-    /// True if `self` is a (non-strict) superset of `other`.\n-    ///\n-    /// The two sets must have the same domain_size.\n+    /// Is `self` is a (non-strict) superset of `other`?\n     #[inline]\n     pub fn superset(&self, other: &BitSet<T>) -> bool {\n-        assert_eq!(self.words.len(), other.words.len());\n+        assert_eq!(self.domain_size, other.domain_size);\n         self.words.iter().zip(&other.words).all(|(a, b)| (a & b) == *b)\n     }\n \n@@ -121,6 +119,7 @@ impl<T: Idx> BitSet<T> {\n     /// Insert `elem`. Returns true if the set has changed.\n     #[inline]\n     pub fn insert(&mut self, elem: T) -> bool {\n+        assert!(elem.index() < self.domain_size);\n         let (word_index, mask) = word_index_and_mask(elem);\n         let word_ref = &mut self.words[word_index];\n         let word = *word_ref;\n@@ -134,11 +133,13 @@ impl<T: Idx> BitSet<T> {\n         for word in &mut self.words {\n             *word = !0;\n         }\n+        self.clear_excess_bits();\n     }\n \n     /// Returns true if the set has changed.\n     #[inline]\n     pub fn remove(&mut self, elem: T) -> bool {\n+        assert!(elem.index() < self.domain_size);\n         let (word_index, mask) = word_index_and_mask(elem);\n         let word_ref = &mut self.words[word_index];\n         let word = *word_ref;\n@@ -162,6 +163,7 @@ impl<T: Idx> BitSet<T> {\n     /// Set `self = self & other` and return true if `self` changed.\n     /// (i.e., if any bits were removed).\n     pub fn intersect(&mut self, other: &BitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size);\n         bitwise(&mut self.words, &other.words, |a, b| { a & b })\n     }\n \n@@ -182,43 +184,8 @@ impl<T: Idx> BitSet<T> {\n \n     /// Duplicates the set as a hybrid set.\n     pub fn to_hybrid(&self) -> HybridBitSet<T> {\n-        // This domain_size may be slightly larger than the one specified\n-        // upon creation, due to rounding up to a whole word. That's ok.\n-        let domain_size = self.words.len() * WORD_BITS;\n-\n         // Note: we currently don't bother trying to make a Sparse set.\n-        HybridBitSet::Dense(self.to_owned(), domain_size)\n-    }\n-\n-    pub fn to_string(&self, bits: usize) -> String {\n-        let mut result = String::new();\n-        let mut sep = '[';\n-\n-        // Note: this is a little endian printout of bytes.\n-\n-        // i tracks how many bits we have printed so far.\n-        let mut i = 0;\n-        for word in &self.words {\n-            let mut word = *word;\n-            for _ in 0..WORD_BYTES { // for each byte in `word`:\n-                let remain = bits - i;\n-                // If less than a byte remains, then mask just that many bits.\n-                let mask = if remain <= 8 { (1 << remain) - 1 } else { 0xFF };\n-                assert!(mask <= 0xFF);\n-                let byte = word & mask;\n-\n-                result.push_str(&format!(\"{}{:02x}\", sep, byte));\n-\n-                if remain <= 8 { break; }\n-                word >>= 8;\n-                i += 8;\n-                sep = '-';\n-            }\n-            sep = '|';\n-        }\n-        result.push(']');\n-\n-        result\n+        HybridBitSet::Dense(self.to_owned())\n     }\n }\n \n@@ -238,12 +205,14 @@ pub trait SubtractFromBitSet<T: Idx> {\n \n impl<T: Idx> UnionIntoBitSet<T> for BitSet<T> {\n     fn union_into(&self, other: &mut BitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size);\n         bitwise(&mut other.words, &self.words, |a, b| { a | b })\n     }\n }\n \n impl<T: Idx> SubtractFromBitSet<T> for BitSet<T> {\n     fn subtract_from(&self, other: &mut BitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size);\n         bitwise(&mut other.words, &self.words, |a, b| { a & !b })\n     }\n }\n@@ -256,19 +225,36 @@ impl<T: Idx> fmt::Debug for BitSet<T> {\n     }\n }\n \n-impl<T: Idx> rustc_serialize::Encodable for BitSet<T> {\n-    fn encode<E: rustc_serialize::Encoder>(&self, encoder: &mut E) -> Result<(), E::Error> {\n-        self.words.encode(encoder)\n-    }\n-}\n+impl<T: Idx> ToString for BitSet<T> {\n+    fn to_string(&self) -> String {\n+        let mut result = String::new();\n+        let mut sep = '[';\n \n-impl<T: Idx> rustc_serialize::Decodable for BitSet<T> {\n-    fn decode<D: rustc_serialize::Decoder>(d: &mut D) -> Result<BitSet<T>, D::Error> {\n-        let words: Vec<Word> = rustc_serialize::Decodable::decode(d)?;\n-        Ok(BitSet {\n-            words,\n-            marker: PhantomData,\n-        })\n+        // Note: this is a little endian printout of bytes.\n+\n+        // i tracks how many bits we have printed so far.\n+        let mut i = 0;\n+        for word in &self.words {\n+            let mut word = *word;\n+            for _ in 0..WORD_BYTES { // for each byte in `word`:\n+                let remain = self.domain_size - i;\n+                // If less than a byte remains, then mask just that many bits.\n+                let mask = if remain <= 8 { (1 << remain) - 1 } else { 0xFF };\n+                assert!(mask <= 0xFF);\n+                let byte = word & mask;\n+\n+                result.push_str(&format!(\"{}{:02x}\", sep, byte));\n+\n+                if remain <= 8 { break; }\n+                word >>= 8;\n+                i += 8;\n+                sep = '-';\n+            }\n+            sep = '|';\n+        }\n+        result.push(']');\n+\n+        result\n     }\n }\n \n@@ -326,67 +312,78 @@ const SPARSE_MAX: usize = 8;\n ///\n /// This type is used by `HybridBitSet`; do not use directly.\n #[derive(Clone, Debug)]\n-pub struct SparseBitSet<T: Idx>(SmallVec<[T; SPARSE_MAX]>);\n+pub struct SparseBitSet<T: Idx> {\n+    domain_size: usize,\n+    elems: SmallVec<[T; SPARSE_MAX]>,\n+}\n \n impl<T: Idx> SparseBitSet<T> {\n-    fn new_empty() -> Self {\n-        SparseBitSet(SmallVec::new())\n+    fn new_empty(domain_size: usize) -> Self {\n+        SparseBitSet {\n+            domain_size,\n+            elems: SmallVec::new()\n+        }\n     }\n \n     fn len(&self) -> usize {\n-        self.0.len()\n+        self.elems.len()\n     }\n \n     fn is_empty(&self) -> bool {\n-        self.0.len() == 0\n+        self.elems.len() == 0\n     }\n \n     fn contains(&self, elem: T) -> bool {\n-        self.0.contains(&elem)\n+        assert!(elem.index() < self.domain_size);\n+        self.elems.contains(&elem)\n     }\n \n     fn insert(&mut self, elem: T) -> bool {\n-        assert!(self.len() < SPARSE_MAX);\n-        if let Some(i) = self.0.iter().position(|&e| e >= elem) {\n-            if self.0[i] == elem {\n+        assert!(elem.index() < self.domain_size);\n+        let changed = if let Some(i) = self.elems.iter().position(|&e| e >= elem) {\n+            if self.elems[i] == elem {\n                 // `elem` is already in the set.\n                 false\n             } else {\n                 // `elem` is smaller than one or more existing elements.\n-                self.0.insert(i, elem);\n+                self.elems.insert(i, elem);\n                 true\n             }\n         } else {\n             // `elem` is larger than all existing elements.\n-            self.0.push(elem);\n+            self.elems.push(elem);\n             true\n-        }\n+        };\n+        assert!(self.len() <= SPARSE_MAX);\n+        changed\n     }\n \n     fn remove(&mut self, elem: T) -> bool {\n-        if let Some(i) = self.0.iter().position(|&e| e == elem) {\n-            self.0.remove(i);\n+        assert!(elem.index() < self.domain_size);\n+        if let Some(i) = self.elems.iter().position(|&e| e == elem) {\n+            self.elems.remove(i);\n             true\n         } else {\n             false\n         }\n     }\n \n-    fn to_dense(&self, domain_size: usize) -> BitSet<T> {\n-        let mut dense = BitSet::new_empty(domain_size);\n-        for elem in self.0.iter() {\n+    fn to_dense(&self) -> BitSet<T> {\n+        let mut dense = BitSet::new_empty(self.domain_size);\n+        for elem in self.elems.iter() {\n             dense.insert(*elem);\n         }\n         dense\n     }\n \n     fn iter(&self) -> slice::Iter<T> {\n-        self.0.iter()\n+        self.elems.iter()\n     }\n }\n \n impl<T: Idx> UnionIntoBitSet<T> for SparseBitSet<T> {\n     fn union_into(&self, other: &mut BitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size);\n         let mut changed = false;\n         for elem in self.iter() {\n             changed |= other.insert(*elem);\n@@ -397,6 +394,7 @@ impl<T: Idx> UnionIntoBitSet<T> for SparseBitSet<T> {\n \n impl<T: Idx> SubtractFromBitSet<T> for SparseBitSet<T> {\n     fn subtract_from(&self, other: &mut BitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size);\n         let mut changed = false;\n         for elem in self.iter() {\n             changed |= other.remove(*elem);\n@@ -414,10 +412,14 @@ impl<T: Idx> SubtractFromBitSet<T> for SparseBitSet<T> {\n ///\n /// `T` is an index type, typically a newtyped `usize` wrapper, but it can also\n /// just be `usize`.\n+///\n+/// All operations that involve an element will panic if the element is equal\n+/// to or greater than the domain size. All operations that involve two bitsets\n+/// will panic if the bitsets have differing domain sizes.\n #[derive(Clone, Debug)]\n pub enum HybridBitSet<T: Idx> {\n-    Sparse(SparseBitSet<T>, usize),\n-    Dense(BitSet<T>, usize),\n+    Sparse(SparseBitSet<T>),\n+    Dense(BitSet<T>),\n }\n \n impl<T: Idx> HybridBitSet<T> {\n@@ -427,17 +429,17 @@ impl<T: Idx> HybridBitSet<T> {\n     fn dummy() -> Self {\n         // The cheapest HybridBitSet to construct, which is only used to get\n         // around the borrow checker.\n-        HybridBitSet::Sparse(SparseBitSet::new_empty(), 0)\n+        HybridBitSet::Sparse(SparseBitSet::new_empty(0))\n     }\n \n     pub fn new_empty(domain_size: usize) -> Self {\n-        HybridBitSet::Sparse(SparseBitSet::new_empty(), domain_size)\n+        HybridBitSet::Sparse(SparseBitSet::new_empty(domain_size))\n     }\n \n-    pub fn domain_size(&self) -> usize {\n-        match *self {\n-            HybridBitSet::Sparse(_, size) => size,\n-            HybridBitSet::Dense(_, size) => size,\n+    fn domain_size(&self) -> usize {\n+        match self {\n+            HybridBitSet::Sparse(sparse) => sparse.domain_size,\n+            HybridBitSet::Dense(dense) => dense.domain_size,\n         }\n     }\n \n@@ -448,83 +450,88 @@ impl<T: Idx> HybridBitSet<T> {\n \n     pub fn contains(&self, elem: T) -> bool {\n         match self {\n-            HybridBitSet::Sparse(sparse, _) => sparse.contains(elem),\n-            HybridBitSet::Dense(dense, _) => dense.contains(elem),\n+            HybridBitSet::Sparse(sparse) => sparse.contains(elem),\n+            HybridBitSet::Dense(dense) => dense.contains(elem),\n         }\n     }\n \n     pub fn superset(&self, other: &HybridBitSet<T>) -> bool {\n         match (self, other) {\n-            (HybridBitSet::Dense(self_dense, _), HybridBitSet::Dense(other_dense, _)) => {\n+            (HybridBitSet::Dense(self_dense), HybridBitSet::Dense(other_dense)) => {\n                 self_dense.superset(other_dense)\n             }\n-            _ => other.iter().all(|elem| self.contains(elem)),\n+            _ => {\n+                assert!(self.domain_size() == other.domain_size());\n+                other.iter().all(|elem| self.contains(elem))\n+            }\n         }\n     }\n \n     pub fn is_empty(&self) -> bool {\n         match self {\n-            HybridBitSet::Sparse(sparse, _) => sparse.is_empty(),\n-            HybridBitSet::Dense(dense, _) => dense.is_empty(),\n+            HybridBitSet::Sparse(sparse) => sparse.is_empty(),\n+            HybridBitSet::Dense(dense) => dense.is_empty(),\n         }\n     }\n \n     pub fn insert(&mut self, elem: T) -> bool {\n+        // No need to check `elem` against `self.domain_size` here because all\n+        // the match cases check it, one way or another.\n         match self {\n-            HybridBitSet::Sparse(sparse, _) if sparse.len() < SPARSE_MAX => {\n+            HybridBitSet::Sparse(sparse) if sparse.len() < SPARSE_MAX => {\n                 // The set is sparse and has space for `elem`.\n                 sparse.insert(elem)\n             }\n-            HybridBitSet::Sparse(sparse, _) if sparse.contains(elem) => {\n+            HybridBitSet::Sparse(sparse) if sparse.contains(elem) => {\n                 // The set is sparse and does not have space for `elem`, but\n                 // that doesn't matter because `elem` is already present.\n                 false\n             }\n-            HybridBitSet::Sparse(_, _) => {\n+            HybridBitSet::Sparse(_) => {\n                 // The set is sparse and full. Convert to a dense set.\n                 match mem::replace(self, HybridBitSet::dummy()) {\n-                    HybridBitSet::Sparse(sparse, domain_size) => {\n-                        let mut dense = sparse.to_dense(domain_size);\n+                    HybridBitSet::Sparse(sparse) => {\n+                        let mut dense = sparse.to_dense();\n                         let changed = dense.insert(elem);\n                         assert!(changed);\n-                        *self = HybridBitSet::Dense(dense, domain_size);\n+                        *self = HybridBitSet::Dense(dense);\n                         changed\n                     }\n                     _ => unreachable!()\n                 }\n             }\n \n-            HybridBitSet::Dense(dense, _) => dense.insert(elem),\n+            HybridBitSet::Dense(dense) => dense.insert(elem),\n         }\n     }\n \n     pub fn insert_all(&mut self) {\n         let domain_size = self.domain_size();\n         match self {\n-            HybridBitSet::Sparse(_, _) => {\n-                let dense = BitSet::new_filled(domain_size);\n-                *self = HybridBitSet::Dense(dense, domain_size);\n+            HybridBitSet::Sparse(_) => {\n+                *self = HybridBitSet::Dense(BitSet::new_filled(domain_size));\n             }\n-            HybridBitSet::Dense(dense, _) => dense.insert_all(),\n+            HybridBitSet::Dense(dense) => dense.insert_all(),\n         }\n     }\n \n     pub fn remove(&mut self, elem: T) -> bool {\n         // Note: we currently don't bother going from Dense back to Sparse.\n         match self {\n-            HybridBitSet::Sparse(sparse, _) => sparse.remove(elem),\n-            HybridBitSet::Dense(dense, _) => dense.remove(elem),\n+            HybridBitSet::Sparse(sparse) => sparse.remove(elem),\n+            HybridBitSet::Dense(dense) => dense.remove(elem),\n         }\n     }\n \n     pub fn union(&mut self, other: &HybridBitSet<T>) -> bool {\n         match self {\n-            HybridBitSet::Sparse(_, _) => {\n+            HybridBitSet::Sparse(_) => {\n                 match other {\n-                    HybridBitSet::Sparse(other_sparse, _) => {\n+                    HybridBitSet::Sparse(other_sparse) => {\n                         // Both sets are sparse. Add the elements in\n                         // `other_sparse` to `self_hybrid` one at a time. This\n                         // may or may not cause `self_hybrid` to be densified.\n+                        assert_eq!(self.domain_size(), other.domain_size());\n                         let mut self_hybrid = mem::replace(self, HybridBitSet::dummy());\n                         let mut changed = false;\n                         for elem in other_sparse.iter() {\n@@ -533,14 +540,14 @@ impl<T: Idx> HybridBitSet<T> {\n                         *self = self_hybrid;\n                         changed\n                     }\n-                    HybridBitSet::Dense(other_dense, _) => {\n+                    HybridBitSet::Dense(other_dense) => {\n                         // `self` is sparse and `other` is dense. Densify\n                         // `self` and then do the bitwise union.\n                         match mem::replace(self, HybridBitSet::dummy()) {\n-                            HybridBitSet::Sparse(self_sparse, self_domain_size) => {\n-                                let mut new_dense = self_sparse.to_dense(self_domain_size);\n+                            HybridBitSet::Sparse(self_sparse) => {\n+                                let mut new_dense = self_sparse.to_dense();\n                                 let changed = new_dense.union(other_dense);\n-                                *self = HybridBitSet::Dense(new_dense, self_domain_size);\n+                                *self = HybridBitSet::Dense(new_dense);\n                                 changed\n                             }\n                             _ => unreachable!()\n@@ -549,40 +556,40 @@ impl<T: Idx> HybridBitSet<T> {\n                 }\n             }\n \n-            HybridBitSet::Dense(self_dense, _) => self_dense.union(other),\n+            HybridBitSet::Dense(self_dense) => self_dense.union(other),\n         }\n     }\n \n     /// Converts to a dense set, consuming itself in the process.\n     pub fn to_dense(self) -> BitSet<T> {\n         match self {\n-            HybridBitSet::Sparse(sparse, domain_size) => sparse.to_dense(domain_size),\n-            HybridBitSet::Dense(dense, _) => dense,\n+            HybridBitSet::Sparse(sparse) => sparse.to_dense(),\n+            HybridBitSet::Dense(dense) => dense,\n         }\n     }\n \n     pub fn iter(&self) -> HybridIter<T> {\n         match self {\n-            HybridBitSet::Sparse(sparse, _) => HybridIter::Sparse(sparse.iter()),\n-            HybridBitSet::Dense(dense, _) => HybridIter::Dense(dense.iter()),\n+            HybridBitSet::Sparse(sparse) => HybridIter::Sparse(sparse.iter()),\n+            HybridBitSet::Dense(dense) => HybridIter::Dense(dense.iter()),\n         }\n     }\n }\n \n impl<T: Idx> UnionIntoBitSet<T> for HybridBitSet<T> {\n     fn union_into(&self, other: &mut BitSet<T>) -> bool {\n         match self {\n-            HybridBitSet::Sparse(sparse, _) => sparse.union_into(other),\n-            HybridBitSet::Dense(dense, _) => dense.union_into(other),\n+            HybridBitSet::Sparse(sparse) => sparse.union_into(other),\n+            HybridBitSet::Dense(dense) => dense.union_into(other),\n         }\n     }\n }\n \n impl<T: Idx> SubtractFromBitSet<T> for HybridBitSet<T> {\n     fn subtract_from(&self, other: &mut BitSet<T>) -> bool {\n         match self {\n-            HybridBitSet::Sparse(sparse, _) => sparse.subtract_from(other),\n-            HybridBitSet::Dense(dense, _) => dense.subtract_from(other),\n+            HybridBitSet::Sparse(sparse) => sparse.subtract_from(other),\n+            HybridBitSet::Dense(dense) => dense.subtract_from(other),\n         }\n     }\n }\n@@ -607,16 +614,24 @@ impl<'a, T: Idx> Iterator for HybridIter<'a, T> {\n ///\n /// `T` is an index type, typically a newtyped `usize` wrapper, but it can also\n /// just be `usize`.\n+///\n+/// All operations that involve an element will panic if the element is equal\n+/// to or greater than the domain size.\n #[derive(Clone, Debug, PartialEq)]\n pub struct GrowableBitSet<T: Idx> {\n     bit_set: BitSet<T>,\n }\n \n impl<T: Idx> GrowableBitSet<T> {\n-    pub fn grow(&mut self, domain_size: T) {\n-        let num_words = num_words(domain_size);\n-        if self.bit_set.words.len() <= num_words {\n-            self.bit_set.words.resize(num_words + 1, 0)\n+    /// Ensure that the set can hold at least `min_domain_size` elements.\n+    pub fn ensure(&mut self, min_domain_size: usize) {\n+        if self.bit_set.domain_size < min_domain_size {\n+            self.bit_set.domain_size = min_domain_size;\n+        }\n+\n+        let min_num_words = num_words(min_domain_size);\n+        if self.bit_set.words.len() < min_num_words {\n+            self.bit_set.words.resize(min_num_words, 0)\n         }\n     }\n \n@@ -631,7 +646,7 @@ impl<T: Idx> GrowableBitSet<T> {\n     /// Returns true if the set has changed.\n     #[inline]\n     pub fn insert(&mut self, elem: T) -> bool {\n-        self.grow(elem);\n+        self.ensure(elem.index() + 1);\n         self.bit_set.insert(elem)\n     }\n \n@@ -651,39 +666,43 @@ impl<T: Idx> GrowableBitSet<T> {\n /// `R` and `C` are index types used to identify rows and columns respectively;\n /// typically newtyped `usize` wrappers, but they can also just be `usize`.\n ///\n+/// All operations that involve a row and/or column index will panic if the\n+/// index exceeds the relevant bound.\n #[derive(Clone, Debug)]\n pub struct BitMatrix<R: Idx, C: Idx> {\n-    columns: usize,\n+    num_rows: usize,\n+    num_columns: usize,\n     words: Vec<Word>,\n     marker: PhantomData<(R, C)>,\n }\n \n impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     /// Create a new `rows x columns` matrix, initially empty.\n-    pub fn new(rows: usize, columns: usize) -> BitMatrix<R, C> {\n+    pub fn new(num_rows: usize, num_columns: usize) -> BitMatrix<R, C> {\n         // For every element, we need one bit for every other\n         // element. Round up to an even number of words.\n-        let words_per_row = num_words(columns);\n+        let words_per_row = num_words(num_columns);\n         BitMatrix {\n-            columns,\n-            words: vec![0; rows * words_per_row],\n+            num_rows,\n+            num_columns,\n+            words: vec![0; num_rows * words_per_row],\n             marker: PhantomData,\n         }\n     }\n \n     /// The range of bits for a given row.\n     fn range(&self, row: R) -> (usize, usize) {\n-        let row = row.index();\n-        let words_per_row = num_words(self.columns);\n-        let start = row * words_per_row;\n+        let words_per_row = num_words(self.num_columns);\n+        let start = row.index() * words_per_row;\n         (start, start + words_per_row)\n     }\n \n     /// Sets the cell at `(row, column)` to true. Put another way, insert\n     /// `column` to the bitset for `row`.\n     ///\n     /// Returns true if this changed the matrix, and false otherwise.\n-    pub fn insert(&mut self, row: R, column: R) -> bool {\n+    pub fn insert(&mut self, row: R, column: C) -> bool {\n+        assert!(row.index() < self.num_rows && column.index() < self.num_columns);\n         let (start, _) = self.range(row);\n         let (word_index, mask) = word_index_and_mask(column);\n         let words = &mut self.words[..];\n@@ -697,7 +716,8 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     /// the matrix cell at `(row, column)` true?  Put yet another way,\n     /// if the matrix represents (transitive) reachability, can\n     /// `row` reach `column`?\n-    pub fn contains(&self, row: R, column: R) -> bool {\n+    pub fn contains(&self, row: R, column: C) -> bool {\n+        assert!(row.index() < self.num_rows && column.index() < self.num_columns);\n         let (start, _) = self.range(row);\n         let (word_index, mask) = word_index_and_mask(column);\n         (self.words[start + word_index] & mask) != 0\n@@ -707,11 +727,12 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     /// is an O(n) operation where `n` is the number of elements\n     /// (somewhat independent from the actual size of the\n     /// intersection, in particular).\n-    pub fn intersect_rows(&self, a: R, b: R) -> Vec<C> {\n-        let (a_start, a_end) = self.range(a);\n-        let (b_start, b_end) = self.range(b);\n-        let mut result = Vec::with_capacity(self.columns);\n-        for (base, (i, j)) in (a_start..a_end).zip(b_start..b_end).enumerate() {\n+    pub fn intersect_rows(&self, row1: R, row2: R) -> Vec<C> {\n+        assert!(row1.index() < self.num_rows && row2.index() < self.num_rows);\n+        let (row1_start, row1_end) = self.range(row1);\n+        let (row2_start, row2_end) = self.range(row2);\n+        let mut result = Vec::with_capacity(self.num_columns);\n+        for (base, (i, j)) in (row1_start..row1_end).zip(row2_start..row2_end).enumerate() {\n             let mut v = self.words[i] & self.words[j];\n             for bit in 0..WORD_BITS {\n                 if v == 0 {\n@@ -734,6 +755,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     /// `write` can reach everything that `read` can (and\n     /// potentially more).\n     pub fn union_rows(&mut self, read: R, write: R) -> bool {\n+        assert!(read.index() < self.num_rows && write.index() < self.num_rows);\n         let (read_start, read_end) = self.range(read);\n         let (write_start, write_end) = self.range(write);\n         let words = &mut self.words[..];\n@@ -750,6 +772,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     /// Iterates through all the columns set to true in a given row of\n     /// the matrix.\n     pub fn iter<'a>(&'a self, row: R) -> BitIter<'a, C> {\n+        assert!(row.index() < self.num_rows);\n         let (start, end) = self.range(row);\n         BitIter {\n             cur: None,\n@@ -865,47 +888,18 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n }\n \n #[inline]\n-fn num_words<T: Idx>(elements: T) -> usize {\n-    (elements.index() + WORD_BITS - 1) / WORD_BITS\n+fn num_words<T: Idx>(domain_size: T) -> usize {\n+    (domain_size.index() + WORD_BITS - 1) / WORD_BITS\n }\n \n #[inline]\n-fn word_index_and_mask<T: Idx>(index: T) -> (usize, Word) {\n-    let index = index.index();\n-    let word_index = index / WORD_BITS;\n-    let mask = 1 << (index % WORD_BITS);\n+fn word_index_and_mask<T: Idx>(elem: T) -> (usize, Word) {\n+    let elem = elem.index();\n+    let word_index = elem / WORD_BITS;\n+    let mask = 1 << (elem % WORD_BITS);\n     (word_index, mask)\n }\n \n-#[test]\n-fn test_clear_above() {\n-    use std::cmp;\n-\n-    for i in 0..256 {\n-        let mut idx_buf: BitSet<usize> = BitSet::new_filled(128);\n-        idx_buf.clear_above(i);\n-\n-        let elems: Vec<usize> = idx_buf.iter().collect();\n-        let expected: Vec<usize> = (0..cmp::min(i, 128)).collect();\n-        assert_eq!(elems, expected);\n-    }\n-}\n-\n-#[test]\n-fn test_set_up_to() {\n-    for i in 0..128 {\n-        for mut idx_buf in\n-            vec![BitSet::new_empty(128), BitSet::new_filled(128)].into_iter()\n-        {\n-            idx_buf.set_up_to(i);\n-\n-            let elems: Vec<usize> = idx_buf.iter().collect();\n-            let expected: Vec<usize> = (0..i).collect();\n-            assert_eq!(elems, expected);\n-        }\n-    }\n-}\n-\n #[test]\n fn test_new_filled() {\n     for i in 0..128 {\n@@ -936,7 +930,7 @@ fn bitset_iter_works() {\n \n #[test]\n fn bitset_iter_works_2() {\n-    let mut bitset: BitSet<usize> = BitSet::new_empty(319);\n+    let mut bitset: BitSet<usize> = BitSet::new_empty(320);\n     bitset.insert(0);\n     bitset.insert(127);\n     bitset.insert(191);\n@@ -1037,7 +1031,7 @@ fn grow() {\n         assert!(set.insert(index));\n         assert!(!set.insert(index));\n     }\n-    set.grow(128);\n+    set.ensure(128);\n \n     // Check if the bits set before growing are still set\n     for index in 0..65 {"}, {"sha": "74e7c6c21edd9c6acd002b03b7275436b3ccb63e", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -1937,8 +1937,7 @@ impl EarlyLintPass for KeywordIdents {\n         let next_edition = match cx.sess.edition() {\n             Edition::Edition2015 => {\n                 match &ident.as_str()[..] {\n-                    \"async\" |\n-                    \"try\" => Edition::Edition2018,\n+                    \"async\" | \"try\" | \"dyn\" => Edition::Edition2018,\n                     _ => return,\n                 }\n             }"}, {"sha": "67e4394c9aaa0329bdc24376b726f11ff87a94b4", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -22,6 +22,7 @@ use std::collections::VecDeque;\n use std::fmt;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n+use syntax::errors::Applicability;\n \n mod region_name;\n mod var_name;\n@@ -540,14 +541,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                             RegionName::Named(name) => format!(\"{}\", name),\n                             RegionName::Synthesized(_) => \"'_\".to_string(),\n                         };\n-                        diag.span_suggestion(\n+                        diag.span_suggestion_with_applicability(\n                             span,\n                             &format!(\n                                 \"to allow this impl Trait to capture borrowed data with lifetime \\\n                                  `{}`, add `{}` as a constraint\",\n                                 fr_name, suggestable_fr_name,\n                             ),\n                             format!(\"{} + {}\", snippet, suggestable_fr_name),\n+                            Applicability::MachineApplicable,\n                         );\n                     }\n                 }"}, {"sha": "1fbeb66be304fd56cf742839ff17393f82e34eff", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -216,13 +216,12 @@ where MWF: MirWithFlowState<'tcx>,\n         let i = n.index();\n \n         let flow = self.mbcx.flow_state();\n-        let bits_per_block = flow.sets.bits_per_block();\n \n         write!(w, \"<tr>\")?;\n \n         // Entry\n         let set = flow.sets.on_entry_set_for(i);\n-        write!(w, \"<td>{:?}</td>\", dot::escape_html(&set.to_string(bits_per_block)))?;\n+        write!(w, \"<td>{:?}</td>\", dot::escape_html(&set.to_string()))?;\n \n         // Terminator\n         write!(w, \"<td>\")?;"}, {"sha": "efdf9c3302374afb370534ea9e6e174eba8851ba", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -354,7 +354,8 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeUninitializedPlaces<'a, 'gcx, 'tcx>\n     // sets on_entry bits for Arg places\n     fn start_block_effect(&self, entry_set: &mut BitSet<MovePathIndex>) {\n         // set all bits to 1 (uninit) before gathering counterevidence\n-        entry_set.set_up_to(self.bits_per_block());\n+        assert!(self.bits_per_block() == entry_set.domain_size());\n+        entry_set.insert_all();\n \n         drop_flag_effects_for_function_entry(\n             self.tcx, self.mir, self.mdpe,"}, {"sha": "ea01d17ac134124744e5b2293de308a3b22f4eaa", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -256,7 +256,7 @@ impl<'tcx> InliningMap<'tcx> {\n         let new_items_count_total = new_items_count + self.targets.len();\n \n         self.targets.reserve(new_items_count);\n-        self.inlines.grow(new_items_count_total);\n+        self.inlines.ensure(new_items_count_total);\n \n         for (i, (target, inline)) in new_targets.enumerate() {\n             self.targets.push(target);"}, {"sha": "8cb5a33cdb5f89d572353d65ec35319b74843d93", "filename": "src/librustc_target/spec/netbsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustc_target%2Fspec%2Fnetbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustc_target%2Fspec%2Fnetbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fnetbsd_base.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -29,6 +29,7 @@ pub fn opts() -> TargetOptions {\n         executables: true,\n         target_family: Some(\"unix\".to_string()),\n         linker_is_gnu: true,\n+        no_default_libraries: false,\n         has_rpath: true,\n         pre_link_args: args,\n         position_independent_executables: true,"}, {"sha": "684bf5a6c1026e2e950e679decfc18a22f883cda", "filename": "src/librustc_target/spec/x86_64_rumprun_netbsd.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustc_target%2Fspec%2Fx86_64_rumprun_netbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustc_target%2Fspec%2Fx86_64_rumprun_netbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_rumprun_netbsd.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -21,7 +21,6 @@ pub fn target() -> TargetResult {\n     base.has_rpath = false;\n     base.position_independent_executables = false;\n     base.disable_redzone = true;\n-    base.no_default_libraries = false;\n     base.exe_allocation_crate = None;\n     base.stack_probes = true;\n "}, {"sha": "b85604d860be4ca48b7e98f5faf1beb50a909d2e", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -272,6 +272,7 @@ impl DocAccessLevels for AccessLevels<DefId> {\n pub fn new_handler(error_format: ErrorOutputType,\n                    source_map: Option<Lrc<source_map::SourceMap>>,\n                    treat_err_as_bug: bool,\n+                   ui_testing: bool,\n ) -> errors::Handler {\n     // rustdoc doesn't override (or allow to override) anything from this that is relevant here, so\n     // stick to the defaults\n@@ -283,7 +284,7 @@ pub fn new_handler(error_format: ErrorOutputType,\n                 source_map.map(|cm| cm as _),\n                 false,\n                 sessopts.debugging_opts.teach,\n-            ).ui_testing(sessopts.debugging_opts.ui_testing)\n+            ).ui_testing(ui_testing)\n         ),\n         ErrorOutputType::Json(pretty) => {\n             let source_map = source_map.unwrap_or_else(\n@@ -293,7 +294,7 @@ pub fn new_handler(error_format: ErrorOutputType,\n                     None,\n                     source_map,\n                     pretty,\n-                ).ui_testing(sessopts.debugging_opts.ui_testing)\n+                ).ui_testing(ui_testing)\n             )\n         },\n         ErrorOutputType::Short(color_config) => Box::new(\n@@ -335,6 +336,7 @@ pub fn run_core(search_paths: SearchPaths,\n                 mut manual_passes: Vec<String>,\n                 mut default_passes: passes::DefaultPassOption,\n                 treat_err_as_bug: bool,\n+                ui_testing: bool,\n ) -> (clean::Crate, RenderInfo, Vec<String>) {\n     // Parse, resolve, and typecheck the given crate.\n \n@@ -389,6 +391,8 @@ pub fn run_core(search_paths: SearchPaths,\n         actually_rustdoc: true,\n         debugging_opts: config::DebuggingOptions {\n             force_unstable_if_unmarked,\n+            treat_err_as_bug,\n+            ui_testing,\n             ..config::basic_debugging_options()\n         },\n         error_format,\n@@ -400,7 +404,8 @@ pub fn run_core(search_paths: SearchPaths,\n         let source_map = Lrc::new(source_map::SourceMap::new(sessopts.file_path_mapping()));\n         let diagnostic_handler = new_handler(error_format,\n                                              Some(source_map.clone()),\n-                                             treat_err_as_bug);\n+                                             treat_err_as_bug,\n+                                             ui_testing);\n \n         let mut sess = session::build_session_(\n             sessopts, cpath, diagnostic_handler, source_map,"}, {"sha": "d14275aeb6bf5e52c50ecbecb0b7e81086cb37bd", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 76, "deletions": 31, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -37,6 +37,7 @@ use std::fmt::{self, Write};\n use std::borrow::Cow;\n use std::ops::Range;\n use std::str;\n+use syntax::edition::Edition;\n \n use html::toc::TocBuilder;\n use html::highlight;\n@@ -170,13 +171,15 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n         let event = self.inner.next();\n         let compile_fail;\n         let ignore;\n+        let edition;\n         if let Some(Event::Start(Tag::CodeBlock(lang))) = event {\n             let parse_result = LangString::parse(&lang, self.check_error_codes);\n             if !parse_result.rust {\n                 return Some(Event::Start(Tag::CodeBlock(lang)));\n             }\n             compile_fail = parse_result.compile_fail;\n             ignore = parse_result.ignore;\n+            edition = parse_result.edition;\n         } else {\n             return event;\n         }\n@@ -212,6 +215,17 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n                 } else {\n                     \"\"\n                 };\n+\n+                let edition_string = if let Some(e @ Edition::Edition2018) = edition {\n+                    format!(\"&amp;edition={}{}\", e,\n+                            if channel == \"&amp;version=nightly\" { \"\" }\n+                            else { \"&amp;version=nightly\" })\n+                } else if let Some(e) = edition {\n+                    format!(\"&amp;edition={}\", e)\n+                } else {\n+                    \"\".to_owned()\n+                };\n+\n                 // These characters don't need to be escaped in a URI.\n                 // FIXME: use a library function for percent encoding.\n                 fn dont_escape(c: u8) -> bool {\n@@ -231,26 +245,44 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n                     }\n                 }\n                 Some(format!(\n-                    r#\"<a class=\"test-arrow\" target=\"_blank\" href=\"{}?code={}{}\">Run</a>\"#,\n-                    url, test_escaped, channel\n+                    r#\"<a class=\"test-arrow\" target=\"_blank\" href=\"{}?code={}{}{}\">Run</a>\"#,\n+                    url, test_escaped, channel, edition_string\n                 ))\n             });\n+\n             let tooltip = if ignore {\n-                Some((\"This example is not tested\", \"ignore\"))\n+                Some((\"This example is not tested\".to_owned(), \"ignore\"))\n             } else if compile_fail {\n-                Some((\"This example deliberately fails to compile\", \"compile_fail\"))\n+                Some((\"This example deliberately fails to compile\".to_owned(), \"compile_fail\"))\n+            } else if let Some(e) = edition {\n+                Some((format!(\"This code runs with edition {}\", e), \"edition\"))\n             } else {\n                 None\n             };\n-            s.push_str(&highlight::render_with_highlighting(\n-                        &text,\n-                        Some(&format!(\"rust-example-rendered{}\",\n-                                      if ignore { \" ignore\" }\n-                                      else if compile_fail { \" compile_fail\" }\n-                                      else { \"\" })),\n-                        playground_button.as_ref().map(String::as_str),\n-                        tooltip));\n-            Some(Event::Html(s.into()))\n+\n+            if let Some((s1, s2)) = tooltip {\n+                s.push_str(&highlight::render_with_highlighting(\n+                    &text,\n+                    Some(&format!(\"rust-example-rendered{}\",\n+                                  if ignore { \" ignore\" }\n+                                  else if compile_fail { \" compile_fail\" }\n+                                  else if edition.is_some() { \" edition \" }\n+                                  else { \"\" })),\n+                    playground_button.as_ref().map(String::as_str),\n+                    Some((s1.as_str(), s2))));\n+                Some(Event::Html(s.into()))\n+            } else {\n+                s.push_str(&highlight::render_with_highlighting(\n+                    &text,\n+                    Some(&format!(\"rust-example-rendered{}\",\n+                                  if ignore { \" ignore\" }\n+                                  else if compile_fail { \" compile_fail\" }\n+                                  else if edition.is_some() { \" edition \" }\n+                                  else { \"\" })),\n+                    playground_button.as_ref().map(String::as_str),\n+                    None));\n+                Some(Event::Html(s.into()))\n+            }\n         })\n     }\n }\n@@ -577,6 +609,7 @@ pub struct LangString {\n     pub compile_fail: bool,\n     pub error_codes: Vec<String>,\n     pub allow_fail: bool,\n+    pub edition: Option<Edition>\n }\n \n impl LangString {\n@@ -591,6 +624,7 @@ impl LangString {\n             compile_fail: false,\n             error_codes: Vec::new(),\n             allow_fail: false,\n+            edition: None,\n         }\n     }\n \n@@ -625,6 +659,11 @@ impl LangString {\n                     seen_rust_tags = !seen_other_tags || seen_rust_tags;\n                     data.no_run = true;\n                 }\n+                x if allow_error_code_check && x.starts_with(\"edition\") => {\n+                    // allow_error_code_check is true if we're on nightly, which\n+                    // is needed for edition support\n+                    data.edition = x[7..].parse::<Edition>().ok();\n+                }\n                 x if allow_error_code_check && x.starts_with(\"E\") && x.len() == 5 => {\n                     if x[1..].parse::<u32>().is_ok() {\n                         data.error_codes.push(x.to_owned());\n@@ -925,12 +964,14 @@ mod tests {\n     use super::{ErrorCodes, LangString, Markdown, MarkdownHtml, IdMap};\n     use super::plain_summary_line;\n     use std::cell::RefCell;\n+    use syntax::edition::Edition;\n \n     #[test]\n     fn test_lang_string_parse() {\n         fn t(s: &str,\n             should_panic: bool, no_run: bool, ignore: bool, rust: bool, test_harness: bool,\n-            compile_fail: bool, allow_fail: bool, error_codes: Vec<String>) {\n+            compile_fail: bool, allow_fail: bool, error_codes: Vec<String>,\n+             edition: Option<Edition>) {\n             assert_eq!(LangString::parse(s, ErrorCodes::Yes), LangString {\n                 should_panic,\n                 no_run,\n@@ -941,30 +982,34 @@ mod tests {\n                 error_codes,\n                 original: s.to_owned(),\n                 allow_fail,\n+                edition,\n             })\n         }\n \n         fn v() -> Vec<String> {\n             Vec::new()\n         }\n \n-        // marker                | should_panic| no_run| ignore| rust | test_harness| compile_fail\n-        //                       | allow_fail | error_codes\n-        t(\"\",                      false,        false,  false,  true,  false, false, false, v());\n-        t(\"rust\",                  false,        false,  false,  true,  false, false, false, v());\n-        t(\"sh\",                    false,        false,  false,  false, false, false, false, v());\n-        t(\"ignore\",                false,        false,  true,   true,  false, false, false, v());\n-        t(\"should_panic\",          true,         false,  false,  true,  false, false, false, v());\n-        t(\"no_run\",                false,        true,   false,  true,  false, false, false, v());\n-        t(\"test_harness\",          false,        false,  false,  true,  true,  false, false, v());\n-        t(\"compile_fail\",          false,        true,   false,  true,  false, true,  false, v());\n-        t(\"allow_fail\",            false,        false,  false,  true,  false, false, true,  v());\n-        t(\"{.no_run .example}\",    false,        true,   false,  true,  false, false, false, v());\n-        t(\"{.sh .should_panic}\",   true,         false,  false,  false, false, false, false, v());\n-        t(\"{.example .rust}\",      false,        false,  false,  true,  false, false, false, v());\n-        t(\"{.test_harness .rust}\", false,        false,  false,  true,  true,  false, false, v());\n-        t(\"text, no_run\",          false,        true,   false,  false, false, false, false, v());\n-        t(\"text,no_run\",           false,        true,   false,  false, false, false, false, v());\n+        // ignore-tidy-linelength\n+        // marker                | should_panic | no_run | ignore | rust | test_harness\n+        //                       | compile_fail | allow_fail | error_codes | edition\n+        t(\"\",                      false,         false,   false,   true,  false, false, false, v(), None);\n+        t(\"rust\",                  false,         false,   false,   true,  false, false, false, v(), None);\n+        t(\"sh\",                    false,         false,   false,   false, false, false, false, v(), None);\n+        t(\"ignore\",                false,         false,   true,    true,  false, false, false, v(), None);\n+        t(\"should_panic\",          true,          false,   false,   true,  false, false, false, v(), None);\n+        t(\"no_run\",                false,         true,    false,   true,  false, false, false, v(), None);\n+        t(\"test_harness\",          false,         false,   false,   true,  true,  false, false, v(), None);\n+        t(\"compile_fail\",          false,         true,    false,   true,  false, true,  false, v(), None);\n+        t(\"allow_fail\",            false,         false,   false,   true,  false, false, true,  v(), None);\n+        t(\"{.no_run .example}\",    false,         true,    false,   true,  false, false, false, v(), None);\n+        t(\"{.sh .should_panic}\",   true,          false,   false,   false, false, false, false, v(), None);\n+        t(\"{.example .rust}\",      false,         false,   false,   true,  false, false, false, v(), None);\n+        t(\"{.test_harness .rust}\", false,         false,   false,   true,  true,  false, false, v(), None);\n+        t(\"text, no_run\",          false,         true,    false,   false, false, false, false, v(), None);\n+        t(\"text,no_run\",           false,         true,    false,   false, false, false, false, v(), None);\n+        t(\"edition2015\",           false,         false,   false,   true,  false, false, false, v(), Some(Edition::Edition2015));\n+        t(\"edition2018\",           false,         false,   false,   true,  false, false, false, v(), Some(Edition::Edition2018));\n     }\n \n     #[test]"}, {"sha": "2456a5ad14acc61e15c81d5b4cd961d9122bef72", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -409,8 +409,11 @@ fn main_args(args: &[String]) -> isize {\n     let treat_err_as_bug = matches.opt_strs(\"Z\").iter().any(|x| {\n         *x == \"treat-err-as-bug\"\n     });\n+    let ui_testing = matches.opt_strs(\"Z\").iter().any(|x| {\n+        *x == \"ui-testing\"\n+    });\n \n-    let diag = core::new_handler(error_format, None, treat_err_as_bug);\n+    let diag = core::new_handler(error_format, None, treat_err_as_bug, ui_testing);\n \n     // check for deprecated options\n     check_deprecated_options(&matches, &diag);\n@@ -565,7 +568,7 @@ fn main_args(args: &[String]) -> isize {\n     let res = acquire_input(PathBuf::from(input), externs, edition, cg, &matches, error_format,\n                             move |out| {\n         let Output { krate, passes, renderinfo } = out;\n-        let diag = core::new_handler(error_format, None, treat_err_as_bug);\n+        let diag = core::new_handler(error_format, None, treat_err_as_bug, ui_testing);\n         info!(\"going to format\");\n         match output_format.as_ref().map(|s| &**s) {\n             Some(\"html\") | None => {\n@@ -702,6 +705,9 @@ where R: 'static + Send,\n     let treat_err_as_bug = matches.opt_strs(\"Z\").iter().any(|x| {\n         *x == \"treat-err-as-bug\"\n     });\n+    let ui_testing = matches.opt_strs(\"Z\").iter().any(|x| {\n+        *x == \"ui-testing\"\n+    });\n \n     let (lint_opts, describe_lints, lint_cap) = get_cmd_lint_options(matches, error_format);\n \n@@ -715,7 +721,7 @@ where R: 'static + Send,\n                            display_warnings, crate_name.clone(),\n                            force_unstable_if_unmarked, edition, cg, error_format,\n                            lint_opts, lint_cap, describe_lints, manual_passes, default_passes,\n-                           treat_err_as_bug);\n+                           treat_err_as_bug, ui_testing);\n \n         info!(\"finished with rustc\");\n "}, {"sha": "dbebc3ab393977a0e226e20dabeb03607e0d757a", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -545,7 +545,7 @@ impl Collector {\n         let opts = self.opts.clone();\n         let maybe_sysroot = self.maybe_sysroot.clone();\n         let linker = self.linker.clone();\n-        let edition = self.edition;\n+        let edition = config.edition.unwrap_or(self.edition);\n         debug!(\"Creating test {}: {}\", name, test);\n         self.tests.push(testing::TestDescAndFn {\n             desc: testing::TestDesc {"}, {"sha": "6f1652cdee06f79906fbb0138553150865659dc9", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -16,6 +16,7 @@ Core encoding and decoding interfaces.\n \n use std::borrow::Cow;\n use std::intrinsics;\n+use std::marker::PhantomData;\n use std::path;\n use std::rc::Rc;\n use std::cell::{Cell, RefCell};\n@@ -547,6 +548,19 @@ impl Decodable for () {\n     }\n }\n \n+impl<T> Encodable for PhantomData<T> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_unit()\n+    }\n+}\n+\n+impl<T> Decodable for PhantomData<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<PhantomData<T>, D::Error> {\n+        d.read_nil()?;\n+        Ok(PhantomData)\n+    }\n+}\n+\n impl<'a, T: ?Sized + Encodable> Encodable for &'a T {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)"}, {"sha": "7a13beb78526cf8b0119755bcb2195bdf66077b9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 54, "deletions": 47, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -1578,8 +1578,9 @@ impl<'a> Parser<'a> {\n             impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n             TyKind::ImplTrait(ast::DUMMY_NODE_ID, bounds)\n         } else if self.check_keyword(keywords::Dyn) &&\n-                  self.look_ahead(1, |t| t.can_begin_bound() &&\n-                                         !can_continue_type_after_non_fn_ident(t)) {\n+                  (self.span.edition() == Edition::Edition2018 ||\n+                   self.look_ahead(1, |t| t.can_begin_bound() &&\n+                                         !can_continue_type_after_non_fn_ident(t))) {\n             self.bump(); // `dyn`\n             // Always parse bounds greedily for better error recovery.\n             let bounds = self.parse_generic_bounds()?;\n@@ -1780,27 +1781,32 @@ impl<'a> Parser<'a> {\n             (pat, self.parse_ty()?)\n         } else {\n             debug!(\"parse_arg_general ident_to_pat\");\n+            let parser_snapshot_before_ty = self.clone();\n+            let mut ty = self.parse_ty();\n+            if ty.is_ok() && self.token == token::Colon {\n+                // This wasn't actually a type, but a pattern looking like a type,\n+                // so we are going to rollback and re-parse for recovery.\n+                ty = self.unexpected();\n+            }\n+            match ty {\n+                Ok(ty) => {\n+                    let ident = Ident::new(keywords::Invalid.name(), self.prev_span);\n+                    let pat = P(Pat {\n+                        id: ast::DUMMY_NODE_ID,\n+                        node: PatKind::Ident(\n+                            BindingMode::ByValue(Mutability::Immutable), ident, None),\n+                        span: ty.span,\n+                    });\n+                    (pat, ty)\n+                }\n+                Err(mut err) => {\n+                    // Recover from attempting to parse the argument as a type without pattern.\n+                    err.cancel();\n+                    mem::replace(self, parser_snapshot_before_ty);\n+                    let pat = self.parse_pat()?;\n+                    self.expect(&token::Colon)?;\n+                    let ty = self.parse_ty()?;\n \n-            let parser_snapshot_before_pat = self.clone();\n-\n-            // Once we can use edition 2018 in the compiler,\n-            // replace this with real try blocks.\n-            macro_rules! try_block {\n-                ($($inside:tt)*) => (\n-                    (||{ ::std::ops::Try::from_ok({ $($inside)* }) })()\n-                )\n-            }\n-\n-            // We're going to try parsing the argument as a pattern (even though it's not\n-            // allowed). This way we can provide better errors to the user.\n-            let pat_arg: PResult<'a, _> = try_block! {\n-                let pat = self.parse_pat()?;\n-                self.expect(&token::Colon)?;\n-                (pat, self.parse_ty()?)\n-            };\n-\n-            match pat_arg {\n-                Ok((pat, ty)) => {\n                     let mut err = self.diagnostic().struct_span_err_with_code(\n                         pat.span,\n                         \"patterns aren't allowed in methods without bodies\",\n@@ -1813,6 +1819,7 @@ impl<'a> Parser<'a> {\n                         Applicability::MachineApplicable,\n                     );\n                     err.emit();\n+\n                     // Pretend the pattern is `_`, to avoid duplicate errors from AST validation.\n                     let pat = P(Pat {\n                         node: PatKind::Wild,\n@@ -1821,22 +1828,6 @@ impl<'a> Parser<'a> {\n                     });\n                     (pat, ty)\n                 }\n-                Err(mut err) => {\n-                    err.cancel();\n-                    // Recover from attempting to parse the argument as a pattern. This means\n-                    // the type is alone, with no name, e.g. `fn foo(u32)`.\n-                    mem::replace(self, parser_snapshot_before_pat);\n-                    debug!(\"parse_arg_general ident_to_pat\");\n-                    let ident = Ident::new(keywords::Invalid.name(), self.prev_span);\n-                    let ty = self.parse_ty()?;\n-                    let pat = P(Pat {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: PatKind::Ident(\n-                            BindingMode::ByValue(Mutability::Immutable), ident, None),\n-                        span: ty.span,\n-                    });\n-                    (pat, ty)\n-                }\n             }\n         };\n \n@@ -2702,8 +2693,8 @@ impl<'a> Parser<'a> {\n                   token::Literal(token::Float(n), _suf) => {\n                     self.bump();\n                     let fstr = n.as_str();\n-                    let mut err = self.diagnostic().struct_span_err(self.prev_span,\n-                        &format!(\"unexpected token: `{}`\", n));\n+                    let mut err = self.diagnostic()\n+                        .struct_span_err(self.prev_span, &format!(\"unexpected token: `{}`\", n));\n                     err.span_label(self.prev_span, \"unexpected token\");\n                     if fstr.chars().all(|x| \"0123456789.\".contains(x)) {\n                         let float = match fstr.parse::<f64>().ok() {\n@@ -2863,8 +2854,8 @@ impl<'a> Parser<'a> {\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n                 let span_of_tilde = lo;\n-                let mut err = self.diagnostic().struct_span_err(span_of_tilde,\n-                        \"`~` cannot be used as a unary operator\");\n+                let mut err = self.diagnostic()\n+                    .struct_span_err(span_of_tilde, \"`~` cannot be used as a unary operator\");\n                 err.span_suggestion_short_with_applicability(\n                     span_of_tilde,\n                     \"use `!` to perform bitwise negation\",\n@@ -3422,6 +3413,24 @@ impl<'a> Parser<'a> {\n             );\n             err.emit();\n         }\n+        let in_span = self.prev_span;\n+        if self.eat_keyword(keywords::In) {\n+            // a common typo: `for _ in in bar {}`\n+            let mut err = self.sess.span_diagnostic.struct_span_err(\n+                self.prev_span,\n+                \"expected iterable, found keyword `in`\",\n+            );\n+            err.span_suggestion_short_with_applicability(\n+                in_span.until(self.prev_span),\n+                \"remove the duplicated `in`\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            );\n+            err.note(\"if you meant to use emplacement syntax, it is obsolete (for now, anyway)\");\n+            err.note(\"for more information on the status of emplacement syntax, see <\\\n+                      https://github.com/rust-lang/rust/issues/27779#issuecomment-378416911>\");\n+            err.emit();\n+        }\n         let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n         let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n@@ -4765,12 +4774,9 @@ impl<'a> Parser<'a> {\n         if !self.eat(&token::OpenDelim(token::Brace)) {\n             let sp = self.span;\n             let tok = self.this_token_to_string();\n-            let mut do_not_suggest_help = false;\n             let mut e = self.span_fatal(sp, &format!(\"expected `{{`, found `{}`\", tok));\n-            if self.token.is_keyword(keywords::In) || self.token == token::Colon {\n-                do_not_suggest_help = true;\n-                e.span_label(sp, \"expected `{`\");\n-            }\n+            let do_not_suggest_help =\n+                self.token.is_keyword(keywords::In) || self.token == token::Colon;\n \n             if self.token.is_ident_named(\"and\") {\n                 e.span_suggestion_short_with_applicability(\n@@ -4801,6 +4807,7 @@ impl<'a> Parser<'a> {\n                         || do_not_suggest_help {\n                         // if the next token is an open brace (e.g., `if a b {`), the place-\n                         // inside-a-block suggestion would be more likely wrong than right\n+                        e.span_label(sp, \"expected `{`\");\n                         return Err(e);\n                     }\n                     let mut stmt_span = stmt.span;"}, {"sha": "01bc7f6ad302be195c1ef2369a219f3573fab4ea", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -136,6 +136,7 @@ fn ident_can_begin_type(ident: ast::Ident, is_raw: bool) -> bool {\n         keywords::Unsafe.name(),\n         keywords::Extern.name(),\n         keywords::Typeof.name(),\n+        keywords::Dyn.name(),\n     ].contains(&ident.name)\n }\n "}, {"sha": "5819cd7f480a039ded2eef959be9cac7845bfada", "filename": "src/libsyntax_pos/edition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibsyntax_pos%2Fedition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibsyntax_pos%2Fedition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fedition.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -12,7 +12,7 @@ use std::fmt;\n use std::str::FromStr;\n \n /// The edition of the compiler (RFC 2052)\n-#[derive(Clone, Copy, Hash, PartialEq, PartialOrd, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Hash, PartialEq, PartialOrd, Debug, RustcEncodable, RustcDecodable, Eq)]\n #[non_exhaustive]\n pub enum Edition {\n     // editions must be kept in order, oldest to newest"}, {"sha": "d412412fc655e8782e8bae6943e3bbe7bb8f3ba7", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -414,26 +414,25 @@ declare_keywords! {\n     (50, Yield,              \"yield\")\n \n     // Edition-specific keywords reserved for future use.\n-    (51, Async,              \"async\") // >= 2018 Edition Only\n-    (52, Try,                \"try\") // >= 2018 Edition Only\n+    (51, Async,              \"async\") // >= 2018 Edition only\n+    (52, Dyn,                \"dyn\") // >= 2018 Edition only\n+    (53, Try,                \"try\") // >= 2018 Edition only\n \n     // Special lifetime names\n-    (53, UnderscoreLifetime, \"'_\")\n-    (54, StaticLifetime,     \"'static\")\n+    (54, UnderscoreLifetime, \"'_\")\n+    (55, StaticLifetime,     \"'static\")\n \n     // Weak keywords, have special meaning only in specific contexts.\n-    (55, Auto,               \"auto\")\n-    (56, Catch,              \"catch\")\n-    (57, Default,            \"default\")\n-    (58, Dyn,                \"dyn\")\n+    (56, Auto,               \"auto\")\n+    (57, Catch,              \"catch\")\n+    (58, Default,            \"default\")\n     (59, Union,              \"union\")\n     (60, Existential,        \"existential\")\n }\n \n impl Symbol {\n     fn is_unused_keyword_2018(self) -> bool {\n-        self >= keywords::Async.name() &&\n-        self <= keywords::Try.name()\n+        self >= keywords::Async.name() && self <= keywords::Try.name()\n     }\n }\n "}, {"sha": "b82cbc1ab36fdb6893a7e32661fa4b4aff8360a5", "filename": "src/test/rustdoc-ui/deny-intra-link-resolution-failure.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -1,13 +1,13 @@\n error: `[v2]` cannot be resolved, ignoring it...\n   --> $DIR/deny-intra-link-resolution-failure.rs:13:6\n    |\n-13 | /// [v2] //~ ERROR\n+LL | /// [v2] //~ ERROR\n    |      ^^ cannot be resolved, ignoring\n    |\n note: lint level defined here\n   --> $DIR/deny-intra-link-resolution-failure.rs:11:9\n    |\n-11 | #![deny(intra_doc_link_resolution_failure)]\n+LL | #![deny(intra_doc_link_resolution_failure)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: to escape `[` and `]` characters, just add '/' before them like `/[` or `/]`\n "}, {"sha": "5bd62d60b48f3966c2d154fd5bd3600deb0839c4", "filename": "src/test/rustdoc-ui/deprecated-attrs.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Frustdoc-ui%2Fdeprecated-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Frustdoc-ui%2Fdeprecated-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdeprecated-attrs.stderr?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -1,9 +1,9 @@\n warning: the `#![doc(no_default_passes)]` attribute is considered deprecated\n-  |\n-  = warning: please see https://github.com/rust-lang/rust/issues/44136\n-  = help: you may want to use `#![doc(document_private_items)]`\n+   |\n+   = warning: please see https://github.com/rust-lang/rust/issues/44136\n+   = help: you may want to use `#![doc(document_private_items)]`\n \n warning: the `#![doc(passes = \"...\")]` attribute is considered deprecated\n-  |\n-  = warning: please see https://github.com/rust-lang/rust/issues/44136\n+   |\n+   = warning: please see https://github.com/rust-lang/rust/issues/44136\n "}, {"sha": "498d02a7d1caf00b7ca71f591cf9a597436c39e8", "filename": "src/test/rustdoc-ui/intra-doc-alias-ice.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.stderr?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -1,13 +1,13 @@\n error: `[TypeAlias::hoge]` cannot be resolved, ignoring it...\n   --> $DIR/intra-doc-alias-ice.rs:15:30\n    |\n-15 | /// [broken cross-reference](TypeAlias::hoge) //~ ERROR\n+LL | /// [broken cross-reference](TypeAlias::hoge) //~ ERROR\n    |                              ^^^^^^^^^^^^^^^ cannot be resolved, ignoring\n    |\n note: lint level defined here\n   --> $DIR/intra-doc-alias-ice.rs:11:9\n    |\n-11 | #![deny(intra_doc_link_resolution_failure)]\n+LL | #![deny(intra_doc_link_resolution_failure)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: to escape `[` and `]` characters, just add '/' before them like `/[` or `/]`\n "}, {"sha": "c05f99fadc9e4bce2ab0255978b46cb1a2d3d487", "filename": "src/test/rustdoc-ui/intra-links-warning.stderr", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -1,7 +1,7 @@\n warning: `[Foo::baz]` cannot be resolved, ignoring it...\n   --> $DIR/intra-links-warning.rs:13:23\n    |\n-13 |        //! Test with [Foo::baz], [Bar::foo], ...\n+LL |        //! Test with [Foo::baz], [Bar::foo], ...\n    |                       ^^^^^^^^ cannot be resolved, ignoring\n    |\n    = note: #[warn(intra_doc_link_resolution_failure)] on by default\n@@ -10,67 +10,67 @@ warning: `[Foo::baz]` cannot be resolved, ignoring it...\n warning: `[Bar::foo]` cannot be resolved, ignoring it...\n   --> $DIR/intra-links-warning.rs:13:35\n    |\n-13 |        //! Test with [Foo::baz], [Bar::foo], ...\n+LL |        //! Test with [Foo::baz], [Bar::foo], ...\n    |                                   ^^^^^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '/' before them like `/[` or `/]`\n \n warning: `[Uniooon::X]` cannot be resolved, ignoring it...\n   --> $DIR/intra-links-warning.rs:14:13\n    |\n-14 |      //! , [Uniooon::X] and [Qux::Z].\n+LL |      //! , [Uniooon::X] and [Qux::Z].\n    |             ^^^^^^^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '/' before them like `/[` or `/]`\n \n warning: `[Qux::Z]` cannot be resolved, ignoring it...\n   --> $DIR/intra-links-warning.rs:14:30\n    |\n-14 |      //! , [Uniooon::X] and [Qux::Z].\n+LL |      //! , [Uniooon::X] and [Qux::Z].\n    |                              ^^^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '/' before them like `/[` or `/]`\n \n warning: `[Uniooon::X]` cannot be resolved, ignoring it...\n   --> $DIR/intra-links-warning.rs:16:14\n    |\n-16 |       //! , [Uniooon::X] and [Qux::Z].\n+LL |       //! , [Uniooon::X] and [Qux::Z].\n    |              ^^^^^^^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '/' before them like `/[` or `/]`\n \n warning: `[Qux::Z]` cannot be resolved, ignoring it...\n   --> $DIR/intra-links-warning.rs:16:31\n    |\n-16 |       //! , [Uniooon::X] and [Qux::Z].\n+LL |       //! , [Uniooon::X] and [Qux::Z].\n    |                               ^^^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '/' before them like `/[` or `/]`\n \n warning: `[Qux:Y]` cannot be resolved, ignoring it...\n   --> $DIR/intra-links-warning.rs:18:13\n    |\n-18 |        /// [Qux:Y]\n+LL |        /// [Qux:Y]\n    |             ^^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '/' before them like `/[` or `/]`\n \n warning: `[BarA]` cannot be resolved, ignoring it...\n   --> $DIR/intra-links-warning.rs:24:10\n    |\n-24 | /// bar [BarA] bar\n+LL | /// bar [BarA] bar\n    |          ^^^^ cannot be resolved, ignoring\n    |\n    = help: to escape `[` and `]` characters, just add '/' before them like `/[` or `/]`\n \n warning: `[BarB]` cannot be resolved, ignoring it...\n   --> $DIR/intra-links-warning.rs:28:1\n    |\n-28 | / /**\n-29 | |  * Foo\n-30 | |  * bar [BarB] bar\n-31 | |  * baz\n-32 | |  */\n+LL | / /**\n+LL | |  * Foo\n+LL | |  * bar [BarB] bar\n+LL | |  * baz\n+LL | |  */\n    | |___^\n    |\n    = note: the link appears in this line:\n@@ -82,13 +82,13 @@ warning: `[BarB]` cannot be resolved, ignoring it...\n warning: `[BarC]` cannot be resolved, ignoring it...\n   --> $DIR/intra-links-warning.rs:35:1\n    |\n-35 | / /** Foo\n-36 | |\n-37 | | bar [BarC] bar\n-38 | | baz\n+LL | / /** Foo\n+LL | |\n+LL | | bar [BarC] bar\n+LL | | baz\n ...  |\n-44 | |\n-45 | | */\n+LL | |\n+LL | | */\n    | |__^\n    |\n    = note: the link appears in this line:\n@@ -100,7 +100,7 @@ warning: `[BarC]` cannot be resolved, ignoring it...\n warning: `[BarD]` cannot be resolved, ignoring it...\n   --> $DIR/intra-links-warning.rs:48:1\n    |\n-48 | #[doc = \"Foo/nbar [BarD] bar/nbaz\"]\n+LL | #[doc = \"Foo/nbar [BarD] bar/nbaz\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: the link appears in this line:\n@@ -112,10 +112,10 @@ warning: `[BarD]` cannot be resolved, ignoring it...\n warning: `[BarF]` cannot be resolved, ignoring it...\n   --> $DIR/intra-links-warning.rs:53:9\n    |\n-53 |         #[doc = $f]\n+LL |         #[doc = $f]\n    |         ^^^^^^^^^^^\n ...\n-57 | f!(\"Foo/nbar [BarF] bar/nbaz\");\n+LL | f!(\"Foo/nbar [BarF] bar/nbaz\");\n    | ------------------------------- in this macro invocation\n    |\n    = note: the link appears in this line:"}, {"sha": "322d461f854e9475fe033ad10269e3db6a8f2053", "filename": "src/test/rustdoc/edition-doctest.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Frustdoc%2Fedition-doctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Frustdoc%2Fedition-doctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fedition-doctest.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:--test\n+\n+/// ```rust,edition2018\n+/// #![feature(try_blocks)]\n+///\n+/// use std::num::ParseIntError;\n+///\n+/// let result: Result<i32, ParseIntError> = try {\n+///     \"1\".parse::<i32>()?\n+///         + \"2\".parse::<i32>()?\n+///         + \"3\".parse::<i32>()?\n+/// };\n+/// assert_eq!(result, Ok(6));\n+///\n+/// let result: Result<i32, ParseIntError> = try {\n+///     \"1\".parse::<i32>()?\n+///         + \"foo\".parse::<i32>()?\n+///         + \"3\".parse::<i32>()?\n+/// };\n+/// assert!(result.is_err());\n+/// ```\n+\n+\n+/// ```rust,edition2015,compile_fail,E0574\n+/// #![feature(try_blocks)]\n+///\n+/// use std::num::ParseIntError;\n+///\n+/// let result: Result<i32, ParseIntError> = try {\n+///     \"1\".parse::<i32>()?\n+///         + \"2\".parse::<i32>()?\n+///         + \"3\".parse::<i32>()?\n+/// };\n+/// assert_eq!(result, Ok(6));\n+///\n+/// let result: Result<i32, ParseIntError> = try {\n+///     \"1\".parse::<i32>()?\n+///         + \"foo\".parse::<i32>()?\n+///         + \"3\".parse::<i32>()?\n+/// };\n+/// assert!(result.is_err());\n+/// ```\n+\n+pub fn foo() {}"}, {"sha": "aa54425efa342dd43c839164f0bce56e46e7e03d", "filename": "src/test/ui/did_you_mean/issue-54109-and_instead_of_ampersands.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-54109-and_instead_of_ampersands.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-54109-and_instead_of_ampersands.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-54109-and_instead_of_ampersands.stderr?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -2,16 +2,20 @@ error: expected `{`, found `and`\n   --> $DIR/issue-54109-and_instead_of_ampersands.rs:14:10\n    |\n LL |     if a and b {\n-   |     --   ^^^ help: use `&&` instead of `and` for the boolean operator\n-   |     |\n+   |     --   ^^^\n+   |     |    |\n+   |     |    expected `{`\n+   |     |    help: use `&&` instead of `and` for the boolean operator\n    |     this `if` statement has a condition, but no block\n \n error: expected `{`, found `or`\n   --> $DIR/issue-54109-and_instead_of_ampersands.rs:23:10\n    |\n LL |     if a or b {\n-   |     --   ^^ help: use `||` instead of `or` for the boolean operator\n-   |     |\n+   |     --   ^^\n+   |     |    |\n+   |     |    expected `{`\n+   |     |    help: use `||` instead of `or` for the boolean operator\n    |     this `if` statement has a condition, but no block\n \n error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `and`"}, {"sha": "7f9b141e02e3ca84164101e30733c92c9a40bd29", "filename": "src/test/ui/issues/issue-38940.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Fui%2Fissues%2Fissue-38940.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Fui%2Fissues%2Fissue-38940.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38940.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -0,0 +1,46 @@\n+// issue-38940: error printed twice for deref recursion limit exceeded\n+// Test that the recursion limit can be changed. In this case, we have\n+// deeply nested types that will fail the `Send` check by overflow\n+// when the recursion limit is set very low.\n+#![allow(dead_code)]\n+#![recursion_limit=\"10\"]\n+macro_rules! link {\n+    ($outer:ident, $inner:ident) => {\n+        struct $outer($inner);\n+        impl $outer {\n+            fn new() -> $outer {\n+                $outer($inner::new())\n+            }\n+        }\n+        impl std::ops::Deref for $outer {\n+            type Target = $inner;\n+            fn deref(&self) -> &$inner {\n+                &self.0\n+            }\n+        }\n+    }\n+}\n+struct Bottom;\n+impl Bottom {\n+    fn new() -> Bottom {\n+        Bottom\n+    }\n+}\n+link!(Top, A);\n+link!(A, B);\n+link!(B, C);\n+link!(C, D);\n+link!(D, E);\n+link!(E, F);\n+link!(F, G);\n+link!(G, H);\n+link!(H, I);\n+link!(I, J);\n+link!(J, K);\n+link!(K, Bottom);\n+fn main() {\n+    let t = Top::new();\n+    let x: &Bottom = &t;\n+    //~^ ERROR mismatched types\n+    //~| ERROR reached the recursion limit while auto-dereferencing I\n+}"}, {"sha": "2d3cfda9a5f7272c787357c34a6d21d1bb41a52c", "filename": "src/test/ui/issues/issue-38940.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Fui%2Fissues%2Fissue-38940.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Fui%2Fissues%2Fissue-38940.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38940.stderr?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -0,0 +1,21 @@\n+error[E0055]: reached the recursion limit while auto-dereferencing I\n+  --> $DIR/issue-38940.rs:43:22\n+   |\n+LL |     let x: &Bottom = &t;\n+   |                      ^^ deref recursion limit reached\n+   |\n+   = help: consider adding a `#![recursion_limit=\"20\"]` attribute to your crate\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-38940.rs:43:22\n+   |\n+LL |     let x: &Bottom = &t;\n+   |                      ^^ expected struct `Bottom`, found struct `Top`\n+   |\n+   = note: expected type `&Bottom`\n+              found type `&Top`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0055, E0308.\n+For more information about an error, try `rustc --explain E0055`."}, {"sha": "9bc9aaff298db1c81542ef4e4a587356149cfa8c", "filename": "src/test/ui/parser/if-in-in.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Fui%2Fparser%2Fif-in-in.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Fui%2Fparser%2Fif-in-in.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fif-in-in.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    for i in in 1..2 {\n+        println!(\"{}\", i);\n+    }\n+}"}, {"sha": "9926fcc0858e546b13e349f0dbe19cf262ae2f11", "filename": "src/test/ui/parser/if-in-in.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Fui%2Fparser%2Fif-in-in.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Fui%2Fparser%2Fif-in-in.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fif-in-in.stderr?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -0,0 +1,13 @@\n+error: expected iterable, found keyword `in`\n+  --> $DIR/if-in-in.rs:2:14\n+   |\n+LL |     for i in in 1..2 {\n+   |           ---^^\n+   |           |\n+   |           help: remove the duplicated `in`\n+   |\n+   = note: if you meant to use emplacement syntax, it is obsolete (for now, anyway)\n+   = note: for more information on the status of emplacement syntax, see <https://github.com/rust-lang/rust/issues/27779#issuecomment-378416911>\n+\n+error: aborting due to previous error\n+"}, {"sha": "e9cda1af939321d435923db4d948ca52fe6fb0af", "filename": "src/test/ui/rust-2018/dyn-keyword.fixed", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Fui%2Frust-2018%2Fdyn-keyword.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Fui%2Frust-2018%2Fdyn-keyword.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fdyn-keyword.fixed?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -0,0 +1,10 @@\n+// edition:2015\n+// run-rustfix\n+\n+#![allow(unused_variables)]\n+#![deny(keyword_idents)]\n+\n+fn main() {\n+    let r#dyn = (); //~ ERROR dyn\n+    //~^ WARN hard error in the 2018 edition\n+}"}, {"sha": "bdd3a90cab9ec40ad43b93c367f876556d76c9d0", "filename": "src/test/ui/rust-2018/dyn-keyword.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Fui%2Frust-2018%2Fdyn-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Fui%2Frust-2018%2Fdyn-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fdyn-keyword.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -0,0 +1,10 @@\n+// edition:2015\n+// run-rustfix\n+\n+#![allow(unused_variables)]\n+#![deny(keyword_idents)]\n+\n+fn main() {\n+    let dyn = (); //~ ERROR dyn\n+    //~^ WARN hard error in the 2018 edition\n+}"}, {"sha": "5a3e00ab1d96a7c906d97bdca53ce76fb56c9238", "filename": "src/test/ui/rust-2018/dyn-keyword.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Fui%2Frust-2018%2Fdyn-keyword.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Fui%2Frust-2018%2Fdyn-keyword.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fdyn-keyword.stderr?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -0,0 +1,16 @@\n+error: `dyn` is a keyword in the 2018 edition\n+  --> $DIR/dyn-keyword.rs:8:9\n+   |\n+LL |     let dyn = (); //~ ERROR dyn\n+   |         ^^^ help: you can use a raw identifier to stay compatible: `r#dyn`\n+   |\n+note: lint level defined here\n+  --> $DIR/dyn-keyword.rs:5:9\n+   |\n+LL | #![deny(keyword_idents)]\n+   |         ^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: aborting due to previous error\n+"}, {"sha": "9548df5959bd4d23b8c430fde12b58bc2de0cf9f", "filename": "src/test/ui/rust-2018/dyn-trait-compatibility.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Fui%2Frust-2018%2Fdyn-trait-compatibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Fui%2Frust-2018%2Fdyn-trait-compatibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fdyn-trait-compatibility.rs?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -0,0 +1,8 @@\n+// edition:2018\n+\n+type A0 = dyn;\n+type A1 = dyn::dyn; //~ERROR expected identifier, found reserved keyword\n+type A2 = dyn<dyn, dyn>; //~ERROR expected identifier, found `<`\n+type A3 = dyn<<dyn as dyn>::dyn>;\n+\n+fn main() {}"}, {"sha": "ea0483394b5ea1e76589e3c69a32df7367659db2", "filename": "src/test/ui/rust-2018/dyn-trait-compatibility.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Fui%2Frust-2018%2Fdyn-trait-compatibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af50e3822c4ceda60445c4a2adbb3bfa480ebd39/src%2Ftest%2Fui%2Frust-2018%2Fdyn-trait-compatibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fdyn-trait-compatibility.stderr?ref=af50e3822c4ceda60445c4a2adbb3bfa480ebd39", "patch": "@@ -0,0 +1,14 @@\n+error: expected identifier, found reserved keyword `dyn`\n+  --> $DIR/dyn-trait-compatibility.rs:4:16\n+   |\n+LL | type A1 = dyn::dyn; //~ERROR expected identifier, found reserved keyword\n+   |                ^^^ expected identifier, found reserved keyword\n+\n+error: expected identifier, found `<`\n+  --> $DIR/dyn-trait-compatibility.rs:5:14\n+   |\n+LL | type A2 = dyn<dyn, dyn>; //~ERROR expected identifier, found `<`\n+   |              ^ expected identifier\n+\n+error: aborting due to 2 previous errors\n+"}]}