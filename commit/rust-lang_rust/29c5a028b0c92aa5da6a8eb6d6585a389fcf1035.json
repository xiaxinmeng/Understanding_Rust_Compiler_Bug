{"sha": "29c5a028b0c92aa5da6a8eb6d6585a389fcf1035", "node_id": "C_kwDOAAsO6NoAKDI5YzVhMDI4YjBjOTJhYTVkYTZhOGViNmQ2NTg1YTM4OWZjZjEwMzU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-19T16:33:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-19T16:33:45Z"}, "message": "Auto merge of #99309 - RalfJung:no-large-copies, r=oli-obk\n\ninterpret: make some large types not Copy\n\nAlso remove some unused trait impls (mostly HashStable).\n\nThis didn't find any unnecessary copies that I managed to avoid, but it might still be better to require explicit clone for these types? Not sure.\n\nr? `@oli-obk`", "tree": {"sha": "5024665390c7f1c62f831487f5dd96ac461ee9d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5024665390c7f1c62f831487f5dd96ac461ee9d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035", "html_url": "https://github.com/rust-lang/rust/commit/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a289cfcfb32593c63d75f113547f63ffe2dde285", "url": "https://api.github.com/repos/rust-lang/rust/commits/a289cfcfb32593c63d75f113547f63ffe2dde285", "html_url": "https://github.com/rust-lang/rust/commit/a289cfcfb32593c63d75f113547f63ffe2dde285"}, {"sha": "213a25d975e06fcba28c2e6aab829ef9f16617cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/213a25d975e06fcba28c2e6aab829ef9f16617cf", "html_url": "https://github.com/rust-lang/rust/commit/213a25d975e06fcba28c2e6aab829ef9f16617cf"}], "stats": {"total": 136, "additions": 54, "deletions": 82}, "files": [{"sha": "6feb5219ab1f9cb06e0d348ba33fd36f9fa24c61", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 6, "deletions": 38, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=29c5a028b0c92aa5da6a8eb6d6585a389fcf1035", "patch": "@@ -2,10 +2,8 @@ use std::cell::Cell;\n use std::fmt;\n use std::mem;\n \n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::{self as hir, def_id::DefId, definitions::DefPathData};\n use rustc_index::vec::IndexVec;\n-use rustc_macros::HashStable;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{InterpError, InvalidProgramInfo};\n use rustc_middle::ty::layout::{\n@@ -16,7 +14,6 @@ use rustc_middle::ty::{\n     self, query::TyCtxtAt, subst::SubstsRef, ParamEnv, Ty, TyCtxt, TypeFoldable,\n };\n use rustc_mir_dataflow::storage::always_storage_live_locals;\n-use rustc_query_system::ich::StableHashingContext;\n use rustc_session::Limit;\n use rustc_span::{Pos, Span};\n use rustc_target::abi::{call::FnAbi, Align, HasDataLayout, Size, TargetDataLayout};\n@@ -142,7 +139,7 @@ pub struct FrameInfo<'tcx> {\n }\n \n /// Unwind information.\n-#[derive(Clone, Copy, Eq, PartialEq, Debug, HashStable)]\n+#[derive(Clone, Copy, Eq, PartialEq, Debug)]\n pub enum StackPopUnwind {\n     /// The cleanup block.\n     Cleanup(mir::BasicBlock),\n@@ -152,7 +149,7 @@ pub enum StackPopUnwind {\n     NotAllowed,\n }\n \n-#[derive(Clone, Copy, Eq, PartialEq, Debug, HashStable)] // Miri debug-prints these\n+#[derive(Clone, Copy, Eq, PartialEq, Debug)] // Miri debug-prints these\n pub enum StackPopCleanup {\n     /// Jump to the next block in the caller, or cause UB if None (that's a function\n     /// that may never return). Also store layout of return place so\n@@ -168,16 +165,15 @@ pub enum StackPopCleanup {\n }\n \n /// State of a local variable including a memoized layout\n-#[derive(Clone, Debug, PartialEq, Eq, HashStable)]\n+#[derive(Clone, Debug)]\n pub struct LocalState<'tcx, Tag: Provenance = AllocId> {\n     pub value: LocalValue<Tag>,\n     /// Don't modify if `Some`, this is only used to prevent computing the layout twice\n-    #[stable_hasher(ignore)]\n     pub layout: Cell<Option<TyAndLayout<'tcx>>>,\n }\n \n /// Current value of a local variable\n-#[derive(Copy, Clone, PartialEq, Eq, HashStable, Debug)] // Miri debug-prints these\n+#[derive(Copy, Clone, Debug)] // Miri debug-prints these\n pub enum LocalValue<Tag: Provenance = AllocId> {\n     /// This local is not currently alive, and cannot be used at all.\n     Dead,\n@@ -678,7 +674,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             body,\n             loc: Err(body.span), // Span used for errors caused during preamble.\n             return_to_block,\n-            return_place: *return_place,\n+            return_place: return_place.clone(),\n             // empty local array, we fill it in below, after we are inside the stack frame and\n             // all methods actually know about the frame\n             locals: IndexVec::new(),\n@@ -799,7 +795,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             let op = self\n                 .local_to_op(self.frame(), mir::RETURN_PLACE, None)\n                 .expect(\"return place should always be live\");\n-            let dest = self.frame().return_place;\n+            let dest = self.frame().return_place.clone();\n             let err = self.copy_op(&op, &dest, /*allow_transmute*/ true);\n             trace!(\"return value: {:?}\", self.dump_place(*dest));\n             // We delay actually short-circuiting on this error until *after* the stack frame is\n@@ -1021,31 +1017,3 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> std::fmt::Debug\n         }\n     }\n }\n-\n-impl<'ctx, 'mir, 'tcx, Tag: Provenance, Extra> HashStable<StableHashingContext<'ctx>>\n-    for Frame<'mir, 'tcx, Tag, Extra>\n-where\n-    Extra: HashStable<StableHashingContext<'ctx>>,\n-    Tag: HashStable<StableHashingContext<'ctx>>,\n-{\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'ctx>, hasher: &mut StableHasher) {\n-        // Exhaustive match on fields to make sure we forget no field.\n-        let Frame {\n-            body,\n-            instance,\n-            return_to_block,\n-            return_place,\n-            locals,\n-            loc,\n-            extra,\n-            tracing_span: _,\n-        } = self;\n-        body.hash_stable(hcx, hasher);\n-        instance.hash_stable(hcx, hasher);\n-        return_to_block.hash_stable(hcx, hasher);\n-        return_place.hash_stable(hcx, hasher);\n-        locals.hash_stable(hcx, hasher);\n-        loc.hash_stable(hcx, hasher);\n-        extra.hash_stable(hcx, hasher);\n-    }\n-}"}, {"sha": "c6030604aed374c15712230435d313bda8a1cc41", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=29c5a028b0c92aa5da6a8eb6d6585a389fcf1035", "patch": "@@ -455,8 +455,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 for i in 0..dest_len {\n                     let place = self.mplace_index(&dest, i)?;\n-                    let value =\n-                        if i == index { *elem } else { self.mplace_index(&input, i)?.into() };\n+                    let value = if i == index {\n+                        elem.clone()\n+                    } else {\n+                        self.mplace_index(&input, i)?.into()\n+                    };\n                     self.copy_op(&value, &place.into(), /*allow_transmute*/ false)?;\n                 }\n             }"}, {"sha": "de6eb1c03361bfd0c4fcd9c160e21d7d144cf3df", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=29c5a028b0c92aa5da6a8eb6d6585a389fcf1035", "patch": "@@ -4,7 +4,6 @@\n use std::fmt::Write;\n \n use rustc_hir::def::Namespace;\n-use rustc_macros::HashStable;\n use rustc_middle::ty::layout::{LayoutOf, PrimitiveExt, TyAndLayout};\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Printer};\n use rustc_middle::ty::{ConstInt, DelaySpanBugEmitted, Ty};\n@@ -25,7 +24,7 @@ use super::{\n /// operations and wide pointers. This idea was taken from rustc's codegen.\n /// In particular, thanks to `ScalarPair`, arithmetic operations and casts can be entirely\n /// defined on `Immediate`, and do not have to work with a `Place`.\n-#[derive(Copy, Clone, PartialEq, Eq, HashStable, Hash, Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub enum Immediate<Tag: Provenance = AllocId> {\n     /// A single scalar value (must have *initialized* `Scalar` ABI).\n     /// FIXME: we also currently often use this for ZST.\n@@ -112,7 +111,7 @@ impl<'tcx, Tag: Provenance> Immediate<Tag> {\n \n // ScalarPair needs a type to interpret, so we often have an immediate and a type together\n // as input for binary and cast operations.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Clone, Debug)]\n pub struct ImmTy<'tcx, Tag: Provenance = AllocId> {\n     imm: Immediate<Tag>,\n     pub layout: TyAndLayout<'tcx>,\n@@ -182,13 +181,16 @@ impl<'tcx, Tag: Provenance> std::ops::Deref for ImmTy<'tcx, Tag> {\n /// An `Operand` is the result of computing a `mir::Operand`. It can be immediate,\n /// or still in memory. The latter is an optimization, to delay reading that chunk of\n /// memory and to avoid having to store arbitrary-sized data here.\n-#[derive(Copy, Clone, PartialEq, Eq, HashStable, Hash, Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub enum Operand<Tag: Provenance = AllocId> {\n     Immediate(Immediate<Tag>),\n     Indirect(MemPlace<Tag>),\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+rustc_data_structures::static_assert_size!(Operand, 64);\n+\n+#[derive(Clone, Debug)]\n pub struct OpTy<'tcx, Tag: Provenance = AllocId> {\n     op: Operand<Tag>, // Keep this private; it helps enforce invariants.\n     pub layout: TyAndLayout<'tcx>,"}, {"sha": "bc71bfe4327d4ae16adcfa3def7c441fce73e866", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=29c5a028b0c92aa5da6a8eb6d6585a389fcf1035", "patch": "@@ -5,7 +5,6 @@\n use std::hash::Hash;\n \n use rustc_ast::Mutability;\n-use rustc_macros::HashStable;\n use rustc_middle::mir;\n use rustc_middle::ty;\n use rustc_middle::ty::layout::{LayoutOf, PrimitiveExt, TyAndLayout};\n@@ -17,7 +16,7 @@ use super::{\n     Pointer, Provenance, Scalar, ScalarMaybeUninit,\n };\n \n-#[derive(Copy, Clone, Hash, PartialEq, Eq, HashStable, Debug)]\n+#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]\n /// Information required for the sound usage of a `MemPlace`.\n pub enum MemPlaceMeta<Tag: Provenance = AllocId> {\n     /// The unsized payload (e.g. length for slices or vtable pointer for trait objects).\n@@ -47,7 +46,7 @@ impl<Tag: Provenance> MemPlaceMeta<Tag> {\n     }\n }\n \n-#[derive(Copy, Clone, Hash, PartialEq, Eq, HashStable, Debug)]\n+#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]\n pub struct MemPlace<Tag: Provenance = AllocId> {\n     /// The pointer can be a pure integer, with the `None` tag.\n     pub ptr: Pointer<Option<Tag>>,\n@@ -60,7 +59,22 @@ pub struct MemPlace<Tag: Provenance = AllocId> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(MemPlace, 40);\n \n-#[derive(Copy, Clone, Hash, PartialEq, Eq, HashStable, Debug)]\n+/// A MemPlace with its layout. Constructing it is only possible in this module.\n+#[derive(Copy, Clone, Hash, Eq, PartialEq, Debug)]\n+pub struct MPlaceTy<'tcx, Tag: Provenance = AllocId> {\n+    mplace: MemPlace<Tag>,\n+    pub layout: TyAndLayout<'tcx>,\n+    /// rustc does not have a proper way to represent the type of a field of a `repr(packed)` struct:\n+    /// it needs to have a different alignment than the field type would usually have.\n+    /// So we represent this here with a separate field that \"overwrites\" `layout.align`.\n+    /// This means `layout.align` should never be used for a `MPlaceTy`!\n+    pub align: Align,\n+}\n+\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+rustc_data_structures::static_assert_size!(MPlaceTy<'_>, 64);\n+\n+#[derive(Copy, Clone, Debug)]\n pub enum Place<Tag: Provenance = AllocId> {\n     /// A place referring to a value allocated in the `Memory` system.\n     Ptr(MemPlace<Tag>),\n@@ -73,7 +87,7 @@ pub enum Place<Tag: Provenance = AllocId> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Place, 48);\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Clone, Debug)]\n pub struct PlaceTy<'tcx, Tag: Provenance = AllocId> {\n     place: Place<Tag>, // Keep this private; it helps enforce invariants.\n     pub layout: TyAndLayout<'tcx>,\n@@ -95,21 +109,6 @@ impl<'tcx, Tag: Provenance> std::ops::Deref for PlaceTy<'tcx, Tag> {\n     }\n }\n \n-/// A MemPlace with its layout. Constructing it is only possible in this module.\n-#[derive(Copy, Clone, Hash, Eq, PartialEq, Debug)]\n-pub struct MPlaceTy<'tcx, Tag: Provenance = AllocId> {\n-    mplace: MemPlace<Tag>,\n-    pub layout: TyAndLayout<'tcx>,\n-    /// rustc does not have a proper way to represent the type of a field of a `repr(packed)` struct:\n-    /// it needs to have a different alignment than the field type would usually have.\n-    /// So we represent this here with a separate field that \"overwrites\" `layout.align`.\n-    /// This means `layout.align` should never be used for a `MPlaceTy`!\n-    pub align: Align,\n-}\n-\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(MPlaceTy<'_>, 64);\n-\n impl<'tcx, Tag: Provenance> std::ops::Deref for MPlaceTy<'tcx, Tag> {\n     type Target = MemPlace<Tag>;\n     #[inline(always)]"}, {"sha": "4e69d71dc00ec6c1370c9426e867540074c65bc0", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=29c5a028b0c92aa5da6a8eb6d6585a389fcf1035", "patch": "@@ -157,7 +157,7 @@ where\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         // Downcast just changes the layout\n-        let mut base = *base;\n+        let mut base = base.clone();\n         base.layout = base.layout.for_variant(self, variant);\n         Ok(base)\n     }\n@@ -168,7 +168,7 @@ where\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         // Downcast just changes the layout\n-        let mut base = *base;\n+        let mut base = base.clone();\n         base.layout = base.layout.for_variant(self, variant);\n         Ok(base)\n     }\n@@ -350,7 +350,7 @@ where\n         use rustc_middle::mir::ProjectionElem::*;\n         Ok(match proj_elem {\n             OpaqueCast(ty) => {\n-                let mut place = *base;\n+                let mut place = base.clone();\n                 place.layout = self.layout_of(ty)?;\n                 place\n             }\n@@ -379,7 +379,7 @@ where\n         use rustc_middle::mir::ProjectionElem::*;\n         Ok(match proj_elem {\n             OpaqueCast(ty) => {\n-                let mut op = *base;\n+                let mut op = base.clone();\n                 op.layout = self.layout_of(ty)?;\n                 op\n             }"}, {"sha": "d0c9b5319ddc1092c2138c6639744e23b3ef11ff", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=29c5a028b0c92aa5da6a8eb6d6585a389fcf1035", "patch": "@@ -444,7 +444,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             trace!(\"eval_fn_call: Will pass last argument by untupling\");\n                             Cow::from(\n                                 args.iter()\n-                                    .map(|&a| Ok(a))\n+                                    .map(|a| Ok(a.clone()))\n                                     .chain(\n                                         (0..untuple_arg.layout.fields.count())\n                                             .map(|i| self.operand_field(untuple_arg, i)),\n@@ -525,7 +525,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // We have to implement all \"object safe receivers\". So we have to go search for a\n                 // pointer or `dyn Trait` type, but it could be wrapped in newtypes. So recursively\n                 // unwrap those newtypes until we are there.\n-                let mut receiver = args[0];\n+                let mut receiver = args[0].clone();\n                 let receiver_place = loop {\n                     match receiver.layout.ty.kind() {\n                         ty::Ref(..) | ty::RawPtr(..) => break self.deref_operand(&receiver)?,"}, {"sha": "5956b7e4cb91d9f9d1b96a7bad5bb19937094920", "filename": "compiler/rustc_const_eval/src/interpret/visitor.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs?ref=29c5a028b0c92aa5da6a8eb6d6585a389fcf1035", "patch": "@@ -13,7 +13,7 @@ use super::{InterpCx, MPlaceTy, Machine, OpTy, PlaceTy};\n /// A thing that we can project into, and that has a layout.\n /// This wouldn't have to depend on `Machine` but with the current type inference,\n /// that's just more convenient to work with (avoids repeating all the `Machine` bounds).\n-pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n+pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Sized {\n     /// Gets this value's layout.\n     fn layout(&self) -> TyAndLayout<'tcx>;\n \n@@ -54,7 +54,7 @@ pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n /// A thing that we can project into given *mutable* access to `ecx`, and that has a layout.\n /// This wouldn't have to depend on `Machine` but with the current type inference,\n /// that's just more convenient to work with (avoids repeating all the `Machine` bounds).\n-pub trait ValueMut<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n+pub trait ValueMut<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Sized {\n     /// Gets this value's layout.\n     fn layout(&self) -> TyAndLayout<'tcx>;\n \n@@ -106,12 +106,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tc\n         &self,\n         _ecx: &InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        Ok(*self)\n+        Ok(self.clone())\n     }\n \n     #[inline(always)]\n     fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self {\n-        *op\n+        op.clone()\n     }\n \n     #[inline(always)]\n@@ -146,20 +146,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n         &self,\n         _ecx: &InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        Ok(*self)\n+        Ok(self.clone())\n     }\n \n     #[inline(always)]\n     fn to_op_for_proj(\n         &self,\n         _ecx: &mut InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        Ok(*self)\n+        Ok(self.clone())\n     }\n \n     #[inline(always)]\n     fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self {\n-        *op\n+        op.clone()\n     }\n \n     #[inline(always)]"}, {"sha": "2fd026b1bcaf68f7fc93201f92f0fe0baefac28e", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=29c5a028b0c92aa5da6a8eb6d6585a389fcf1035", "patch": "@@ -516,7 +516,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let l = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?));\n         // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n         if op == BinOp::Shr || op == BinOp::Shl {\n-            let r = r?;\n+            let r = r.clone()?;\n             // We need the type of the LHS. We cannot use `place_layout` as that is the type\n             // of the result, which for checked binops is not the same!\n             let left_ty = left.ty(self.local_decls, self.tcx);"}, {"sha": "9c843f11c1ed13e5ddd04940733954ee99438055", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29c5a028b0c92aa5da6a8eb6d6585a389fcf1035/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=29c5a028b0c92aa5da6a8eb6d6585a389fcf1035", "patch": "@@ -584,7 +584,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         });\n         // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n         if op == BinOp::Shr || op == BinOp::Shl {\n-            let r = r?;\n+            let r = r.clone()?;\n             // We need the type of the LHS. We cannot use `place_layout` as that is the type\n             // of the result, which for checked binops is not the same!\n             let left_ty = left.ty(self.local_decls, self.tcx);\n@@ -616,10 +616,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             }\n         }\n \n-        if let (Some(l), Some(r)) = (&l, &r) {\n+        if let (Some(l), Some(r)) = (l, r) {\n             // The remaining operators are handled through `overflowing_binary_op`.\n             if self.use_ecx(source_info, |this| {\n-                let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n+                let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, &l, &r)?;\n                 Ok(overflow)\n             })? {\n                 self.report_assert_as_lint("}]}