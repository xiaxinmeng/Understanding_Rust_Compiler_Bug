{"sha": "6af4fd385ec23145bc3ba08f700c61361ae961c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZjRmZDM4NWVjMjMxNDViYzNiYTA4ZjcwMGM2MTM2MWFlOTYxYzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-02T06:30:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-02T06:30:52Z"}, "message": "Auto merge of #69469 - matthewjasper:type-flags, r=cramertj\n\nClean up TypeFlags\n\n* Add a new method `has_infer_types_or_consts` that's used instead of `has_infer_types` most of the time, since there's generally no reason to only consider types.\n*  Remove `has_closure_types`/`HAS_TY_CLOSURE`, because closures are no longer implicitly linked to the `InferCtxt`.\n* Reorder flags to group similar ones together\n* Make some flags more granular\n* Compute `HAS_FREE_LOCAL_NAMES` from the other flags\n* Add some more doc comments", "tree": {"sha": "c93624c6be620fad9bdadc9a5fcbf26e59e1eb7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c93624c6be620fad9bdadc9a5fcbf26e59e1eb7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6af4fd385ec23145bc3ba08f700c61361ae961c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6af4fd385ec23145bc3ba08f700c61361ae961c0", "html_url": "https://github.com/rust-lang/rust/commit/6af4fd385ec23145bc3ba08f700c61361ae961c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6af4fd385ec23145bc3ba08f700c61361ae961c0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e86c9e6ef8be7ddec0360f20aae7d86c69c59a83", "url": "https://api.github.com/repos/rust-lang/rust/commits/e86c9e6ef8be7ddec0360f20aae7d86c69c59a83", "html_url": "https://github.com/rust-lang/rust/commit/e86c9e6ef8be7ddec0360f20aae7d86c69c59a83"}, {"sha": "1617ec4ad2b12b34b22e2d78bb96a27448fce04c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1617ec4ad2b12b34b22e2d78bb96a27448fce04c", "html_url": "https://github.com/rust-lang/rust/commit/1617ec4ad2b12b34b22e2d78bb96a27448fce04c"}], "stats": {"total": 284, "additions": 136, "deletions": 148}, "files": [{"sha": "5243e1fbf579b70cff52847ceadd1a135b41191a", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=6af4fd385ec23145bc3ba08f700c61361ae961c0", "patch": "@@ -80,13 +80,10 @@ impl FlagComputation {\n             &ty::Error => self.add_flags(TypeFlags::HAS_TY_ERR),\n \n             &ty::Param(_) => {\n-                self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES);\n-                self.add_flags(TypeFlags::HAS_PARAMS);\n+                self.add_flags(TypeFlags::HAS_TY_PARAM);\n             }\n \n             &ty::Generator(_, ref substs, _) => {\n-                self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n-                self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES);\n                 self.add_substs(substs);\n             }\n \n@@ -97,8 +94,6 @@ impl FlagComputation {\n             }\n \n             &ty::Closure(_, ref substs) => {\n-                self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n-                self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES);\n                 self.add_substs(substs);\n             }\n \n@@ -107,12 +102,10 @@ impl FlagComputation {\n             }\n \n             &ty::Placeholder(..) => {\n-                self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES);\n                 self.add_flags(TypeFlags::HAS_TY_PLACEHOLDER);\n             }\n \n             &ty::Infer(infer) => {\n-                self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES); // it might, right?\n                 self.add_flags(TypeFlags::HAS_TY_INFER);\n                 match infer {\n                     ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_) => {}\n@@ -128,17 +121,17 @@ impl FlagComputation {\n             }\n \n             &ty::Projection(ref data) => {\n-                self.add_flags(TypeFlags::HAS_PROJECTION);\n+                self.add_flags(TypeFlags::HAS_TY_PROJECTION);\n                 self.add_projection_ty(data);\n             }\n \n             &ty::UnnormalizedProjection(ref data) => {\n-                self.add_flags(TypeFlags::HAS_PROJECTION);\n+                self.add_flags(TypeFlags::HAS_TY_PROJECTION);\n                 self.add_projection_ty(data);\n             }\n \n             &ty::Opaque(_, substs) => {\n-                self.add_flags(TypeFlags::HAS_PROJECTION | TypeFlags::HAS_TY_OPAQUE);\n+                self.add_flags(TypeFlags::HAS_TY_OPAQUE);\n                 self.add_substs(substs);\n             }\n \n@@ -221,22 +214,20 @@ impl FlagComputation {\n         match c.val {\n             ty::ConstKind::Unevaluated(_, substs, _) => {\n                 self.add_substs(substs);\n-                self.add_flags(TypeFlags::HAS_PROJECTION);\n+                self.add_flags(TypeFlags::HAS_CT_PROJECTION);\n             }\n             ty::ConstKind::Infer(infer) => {\n-                self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES | TypeFlags::HAS_CT_INFER);\n+                self.add_flags(TypeFlags::HAS_CT_INFER);\n                 match infer {\n                     InferConst::Fresh(_) => {}\n                     InferConst::Var(_) => self.add_flags(TypeFlags::KEEP_IN_LOCAL_TCX),\n                 }\n             }\n             ty::ConstKind::Bound(debruijn, _) => self.add_binder(debruijn),\n             ty::ConstKind::Param(_) => {\n-                self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES);\n-                self.add_flags(TypeFlags::HAS_PARAMS);\n+                self.add_flags(TypeFlags::HAS_CT_PARAM);\n             }\n             ty::ConstKind::Placeholder(_) => {\n-                self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES);\n                 self.add_flags(TypeFlags::HAS_CT_PLACEHOLDER);\n             }\n             ty::ConstKind::Value(_) => {}"}, {"sha": "4adca6c7d97723fc9da8bd663744ee4ff4a38b36", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=6af4fd385ec23145bc3ba08f700c61361ae961c0", "patch": "@@ -85,21 +85,22 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n         self.has_type_flags(TypeFlags::HAS_TY_ERR)\n     }\n     fn has_param_types(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_PARAMS)\n+        self.has_type_flags(TypeFlags::HAS_TY_PARAM | TypeFlags::HAS_CT_PARAM)\n     }\n     fn has_infer_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_INFER)\n     }\n+    fn has_infer_types_or_consts(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_TY_INFER | TypeFlags::HAS_CT_INFER)\n+    }\n     fn has_infer_consts(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_CT_INFER)\n     }\n     fn has_local_value(&self) -> bool {\n         self.has_type_flags(TypeFlags::KEEP_IN_LOCAL_TCX)\n     }\n     fn needs_infer(&self) -> bool {\n-        self.has_type_flags(\n-            TypeFlags::HAS_TY_INFER | TypeFlags::HAS_RE_INFER | TypeFlags::HAS_CT_INFER,\n-        )\n+        self.has_type_flags(TypeFlags::NEEDS_INFER)\n     }\n     fn has_placeholders(&self) -> bool {\n         self.has_type_flags(\n@@ -114,9 +115,6 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn has_re_placeholders(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_RE_PLACEHOLDER)\n     }\n-    fn has_closure_types(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_TY_CLOSURE)\n-    }\n     /// \"Free\" regions in this context means that it has any region\n     /// that is not (a) erased or (b) late-bound.\n     fn has_free_regions(&self) -> bool {"}, {"sha": "28553954b2243d4bb08f66b1cd64d0ddb2862402", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=6af4fd385ec23145bc3ba08f700c61361ae961c0", "patch": "@@ -502,7 +502,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         let univariant = |fields: &[TyLayout<'_>], repr: &ReprOptions, kind| {\n             Ok(tcx.intern_layout(self.univariant_uninterned(ty, fields, repr, kind)?))\n         };\n-        debug_assert!(!ty.has_infer_types());\n+        debug_assert!(!ty.has_infer_types_or_consts());\n \n         Ok(match ty.kind {\n             // Basic scalars.\n@@ -1752,7 +1752,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Result<SizeSkeleton<'tcx>, LayoutError<'tcx>> {\n-        debug_assert!(!ty.has_infer_types());\n+        debug_assert!(!ty.has_infer_types_or_consts());\n \n         // First try computing a static layout.\n         let err = match tcx.layout_of(param_env.and(ty)) {"}, {"sha": "b25fd3c61fd5d24f93dd1556a6d3a1e7889b8fc8", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 89, "deletions": 61, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6af4fd385ec23145bc3ba08f700c61361ae961c0", "patch": "@@ -515,79 +515,107 @@ pub struct CReaderCacheKey {\n     pub pos: usize,\n }\n \n-// Flags that we track on types. These flags are propagated upwards\n-// through the type during type construction, so that we can quickly\n-// check whether the type has various kinds of types in it without\n-// recursing over the type itself.\n bitflags! {\n+    /// Flags that we track on types. These flags are propagated upwards\n+    /// through the type during type construction, so that we can quickly check\n+    /// whether the type has various kinds of types in it without recursing\n+    /// over the type itself.\n     pub struct TypeFlags: u32 {\n-        const HAS_PARAMS         = 1 << 0;\n-        const HAS_TY_INFER       = 1 << 1;\n-        const HAS_RE_INFER       = 1 << 2;\n-        const HAS_RE_PLACEHOLDER = 1 << 3;\n-\n-        /// Does this have any `ReEarlyBound` regions? Used to\n-        /// determine whether substitition is required, since those\n-        /// represent regions that are bound in a `ty::Generics` and\n-        /// hence may be substituted.\n-        const HAS_RE_EARLY_BOUND = 1 << 4;\n-\n-        /// Does this have any region that \"appears free\" in the type?\n-        /// Basically anything but `ReLateBound` and `ReErased`.\n-        const HAS_FREE_REGIONS   = 1 << 5;\n-\n-        /// Is an error type reachable?\n-        const HAS_TY_ERR         = 1 << 6;\n-        const HAS_PROJECTION     = 1 << 7;\n-\n-        // FIXME: Rename this to the actual property since it's used for generators too\n-        const HAS_TY_CLOSURE     = 1 << 8;\n+        // Does this have parameters? Used to determine whether substitution is\n+        // required.\n+        /// Does this have [Param]?\n+        const HAS_TY_PARAM              = 1 << 0;\n+        /// Does this have [ReEarlyBound]?\n+        const HAS_RE_PARAM              = 1 << 1;\n+        /// Does this have [ConstKind::Param]?\n+        const HAS_CT_PARAM              = 1 << 2;\n+\n+        const NEEDS_SUBST               = TypeFlags::HAS_TY_PARAM.bits\n+                                        | TypeFlags::HAS_RE_PARAM.bits\n+                                        | TypeFlags::HAS_CT_PARAM.bits;\n+\n+        /// Does this have [Infer]?\n+        const HAS_TY_INFER              = 1 << 3;\n+        /// Does this have [ReVar]?\n+        const HAS_RE_INFER              = 1 << 4;\n+        /// Does this have [ConstKind::Infer]?\n+        const HAS_CT_INFER              = 1 << 5;\n+\n+        /// Does this have inference variables? Used to determine whether\n+        /// inference is required.\n+        const NEEDS_INFER               = TypeFlags::HAS_TY_INFER.bits\n+                                        | TypeFlags::HAS_RE_INFER.bits\n+                                        | TypeFlags::HAS_CT_INFER.bits;\n+\n+        /// Does this have [Placeholder]?\n+        const HAS_TY_PLACEHOLDER        = 1 << 6;\n+        /// Does this have [RePlaceholder]?\n+        const HAS_RE_PLACEHOLDER        = 1 << 7;\n+        /// Does this have [ConstKind::Placeholder]?\n+        const HAS_CT_PLACEHOLDER        = 1 << 8;\n \n         /// `true` if there are \"names\" of types and regions and so forth\n         /// that are local to a particular fn\n-        const HAS_FREE_LOCAL_NAMES = 1 << 9;\n+        const HAS_FREE_LOCAL_NAMES      = TypeFlags::HAS_TY_PARAM.bits\n+                                        | TypeFlags::HAS_RE_PARAM.bits\n+                                        | TypeFlags::HAS_CT_PARAM.bits\n+                                        | TypeFlags::HAS_TY_INFER.bits\n+                                        | TypeFlags::HAS_RE_INFER.bits\n+                                        | TypeFlags::HAS_CT_INFER.bits\n+                                        | TypeFlags::HAS_TY_PLACEHOLDER.bits\n+                                        | TypeFlags::HAS_RE_PLACEHOLDER.bits\n+                                        | TypeFlags::HAS_CT_PLACEHOLDER.bits;\n+\n+        /// Does this have [Projection] or [UnnormalizedProjection]?\n+        const HAS_TY_PROJECTION         = 1 << 9;\n+        /// Does this have [Opaque]?\n+        const HAS_TY_OPAQUE             = 1 << 10;\n+        /// Does this have [ConstKind::Unevaluated]?\n+        const HAS_CT_PROJECTION         = 1 << 11;\n+\n+        /// Could this type be normalized further?\n+        const HAS_PROJECTION            = TypeFlags::HAS_TY_PROJECTION.bits\n+                                        | TypeFlags::HAS_TY_OPAQUE.bits\n+                                        | TypeFlags::HAS_CT_PROJECTION.bits;\n \n         /// Present if the type belongs in a local type context.\n-        /// Only set for Infer other than Fresh.\n-        const KEEP_IN_LOCAL_TCX  = 1 << 10;\n-\n-        /// Does this have any `ReLateBound` regions? Used to check\n-        /// if a global bound is safe to evaluate.\n-        const HAS_RE_LATE_BOUND  = 1 << 11;\n+        /// Set for placeholders and inference variables that are not \"Fresh\".\n+        const KEEP_IN_LOCAL_TCX         = 1 << 12;\n \n-        /// Does this have any `ReErased` regions?\n-        const HAS_RE_ERASED  = 1 << 12;\n+        /// Is an error type reachable?\n+        const HAS_TY_ERR                = 1 << 13;\n \n-        const HAS_TY_PLACEHOLDER = 1 << 13;\n+        /// Does this have any region that \"appears free\" in the type?\n+        /// Basically anything but [ReLateBound] and [ReErased].\n+        const HAS_FREE_REGIONS          = 1 << 14;\n \n-        const HAS_CT_INFER       = 1 << 14;\n-        const HAS_CT_PLACEHOLDER = 1 << 15;\n-        /// Does this have any [Opaque] types.\n-        const HAS_TY_OPAQUE      = 1 << 16;\n+        /// Does this have any [ReLateBound] regions? Used to check\n+        /// if a global bound is safe to evaluate.\n+        const HAS_RE_LATE_BOUND         = 1 << 15;\n \n-        const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n-                                   TypeFlags::HAS_RE_EARLY_BOUND.bits;\n+        /// Does this have any [ReErased] regions?\n+        const HAS_RE_ERASED             = 1 << 16;\n \n         /// Flags representing the nominal content of a type,\n         /// computed by FlagsComputation. If you add a new nominal\n         /// flag, it should be added here too.\n-        const NOMINAL_FLAGS     = TypeFlags::HAS_PARAMS.bits |\n-                                  TypeFlags::HAS_TY_INFER.bits |\n-                                  TypeFlags::HAS_RE_INFER.bits |\n-                                  TypeFlags::HAS_RE_PLACEHOLDER.bits |\n-                                  TypeFlags::HAS_RE_EARLY_BOUND.bits |\n-                                  TypeFlags::HAS_FREE_REGIONS.bits |\n-                                  TypeFlags::HAS_TY_ERR.bits |\n-                                  TypeFlags::HAS_PROJECTION.bits |\n-                                  TypeFlags::HAS_TY_CLOSURE.bits |\n-                                  TypeFlags::HAS_FREE_LOCAL_NAMES.bits |\n-                                  TypeFlags::KEEP_IN_LOCAL_TCX.bits |\n-                                  TypeFlags::HAS_RE_LATE_BOUND.bits |\n-                                  TypeFlags::HAS_RE_ERASED.bits |\n-                                  TypeFlags::HAS_TY_PLACEHOLDER.bits |\n-                                  TypeFlags::HAS_CT_INFER.bits |\n-                                  TypeFlags::HAS_CT_PLACEHOLDER.bits |\n-                                  TypeFlags::HAS_TY_OPAQUE.bits;\n+        const NOMINAL_FLAGS             = TypeFlags::HAS_TY_PARAM.bits\n+                                        | TypeFlags::HAS_RE_PARAM.bits\n+                                        | TypeFlags::HAS_CT_PARAM.bits\n+                                        | TypeFlags::HAS_TY_INFER.bits\n+                                        | TypeFlags::HAS_RE_INFER.bits\n+                                        | TypeFlags::HAS_CT_INFER.bits\n+                                        | TypeFlags::HAS_TY_PLACEHOLDER.bits\n+                                        | TypeFlags::HAS_RE_PLACEHOLDER.bits\n+                                        | TypeFlags::HAS_CT_PLACEHOLDER.bits\n+                                        | TypeFlags::HAS_TY_PROJECTION.bits\n+                                        | TypeFlags::HAS_TY_OPAQUE.bits\n+                                        | TypeFlags::HAS_CT_PROJECTION.bits\n+                                        | TypeFlags::KEEP_IN_LOCAL_TCX.bits\n+                                        | TypeFlags::HAS_TY_ERR.bits\n+                                        | TypeFlags::HAS_FREE_REGIONS.bits\n+                                        | TypeFlags::HAS_RE_LATE_BOUND.bits\n+                                        | TypeFlags::HAS_RE_ERASED.bits;\n     }\n }\n \n@@ -1816,10 +1844,10 @@ impl<'tcx> ParamEnv<'tcx> {\n             Reveal::UserFacing => ParamEnvAnd { param_env: self, value },\n \n             Reveal::All => {\n-                if value.has_placeholders() || value.needs_infer() || value.has_param_types() {\n-                    ParamEnvAnd { param_env: self, value }\n-                } else {\n+                if value.is_global() {\n                     ParamEnvAnd { param_env: self.without_caller_bounds(), value }\n+                } else {\n+                    ParamEnvAnd { param_env: self, value }\n                 }\n             }\n         }"}, {"sha": "9f60c9cdbcc54c40430b6046f1c6a981098fc1eb", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=6af4fd385ec23145bc3ba08f700c61361ae961c0", "patch": "@@ -1768,7 +1768,7 @@ impl RegionKind {\n             }\n             ty::ReEarlyBound(..) => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n-                flags = flags | TypeFlags::HAS_RE_EARLY_BOUND;\n+                flags = flags | TypeFlags::HAS_RE_PARAM;\n             }\n             ty::ReEmpty(_) | ty::ReStatic | ty::ReFree { .. } | ty::ReScope { .. } => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n@@ -1781,11 +1781,6 @@ impl RegionKind {\n             }\n         }\n \n-        match *self {\n-            ty::ReStatic | ty::ReEmpty(_) | ty::ReErased | ty::ReLateBound(..) => (),\n-            _ => flags = flags | TypeFlags::HAS_FREE_LOCAL_NAMES,\n-        }\n-\n         debug!(\"type_flags({:?}) = {:?}\", self, flags);\n \n         flags"}, {"sha": "a454feea36b70d6dad0bcbe877ed841e92207ec5", "filename": "src/librustc_infer/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs?ref=6af4fd385ec23145bc3ba08f700c61361ae961c0", "patch": "@@ -143,10 +143,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !(t.needs_infer()\n-            || t.has_erasable_regions()\n-            || (t.has_closure_types() && self.infcx.in_progress_tables.is_some()))\n-        {\n+        if !t.needs_infer() && !t.has_erasable_regions() {\n             return t;\n         }\n "}, {"sha": "6adddf2500cdc12739e61dca6381c8bacb2f21c1", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=6af4fd385ec23145bc3ba08f700c61361ae961c0", "patch": "@@ -1482,12 +1482,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) -> bool {\n         let ty = self.resolve_vars_if_possible(&ty);\n \n-        // Even if the type may have no inference variables, during\n-        // type-checking closure types are in local tables only.\n-        if self.in_progress_tables.is_none() || !ty.has_closure_types() {\n-            if !(param_env, ty).has_local_value() {\n-                return ty.is_copy_modulo_regions(self.tcx, param_env, span);\n-            }\n+        if !(param_env, ty).has_local_value() {\n+            return ty.is_copy_modulo_regions(self.tcx, param_env, span);\n         }\n \n         let copy_def_id = self.tcx.require_lang_item(lang_items::CopyTraitLangItem, None);"}, {"sha": "50bea300c50644ffe74ccba3c860c35f13ab561b", "filename": "src/librustc_infer/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs?ref=6af4fd385ec23145bc3ba08f700c61361ae961c0", "patch": "@@ -340,7 +340,7 @@ where\n             // In NLL, we don't have type inference variables\n             // floating around, so we can do this rather imprecise\n             // variant of the occurs-check.\n-            assert!(!generalized_ty.has_infer_types());\n+            assert!(!generalized_ty.has_infer_types_or_consts());\n         }\n \n         self.infcx.inner.borrow_mut().type_variables.instantiate(vid, generalized_ty);"}, {"sha": "e2207d08ee61bc09cef34ebbf82a882cc9153457", "filename": "src/librustc_infer/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_infer%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_infer%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fresolve.rs?ref=6af4fd385ec23145bc3ba08f700c61361ae961c0", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticVarResolver<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !t.has_infer_types() && !t.has_infer_consts() {\n+        if !t.has_infer_types_or_consts() {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n@@ -37,7 +37,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticVarResolver<'a, 'tcx> {\n     }\n \n     fn fold_const(&mut self, ct: &'tcx Const<'tcx>) -> &'tcx Const<'tcx> {\n-        if !ct.has_infer_consts() {\n+        if !ct.has_infer_types_or_consts() {\n             ct // micro-optimize -- if there is nothing in this const that this fold affects...\n         } else {\n             let ct = self.infcx.shallow_resolve(ct);"}, {"sha": "7a84a5f5c727bddc730b5a6ed33c98baae8d090c", "filename": "src/librustc_infer/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=6af4fd385ec23145bc3ba08f700c61361ae961c0", "patch": "@@ -647,7 +647,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         }\n \n                         // Try to report a help message\n-                        if !trait_ref.has_infer_types()\n+                        if !trait_ref.has_infer_types_or_consts()\n                             && self.predicate_can_apply(obligation.param_env, trait_ref)\n                         {\n                             // If a where-clause may be useful, remind the"}, {"sha": "ed6cfa51cdf1860b480b8b2e318b5c7e05cefefc", "filename": "src/librustc_infer/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=6af4fd385ec23145bc3ba08f700c61361ae961c0", "patch": "@@ -471,7 +471,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 return;\n             }\n             let trait_ref = self.resolve_vars_if_possible(trait_ref);\n-            if trait_ref.has_infer_types() {\n+            if trait_ref.has_infer_types_or_consts() {\n                 // Do not ICE while trying to find if a reborrow would succeed on a trait with\n                 // unresolved bindings.\n                 return;"}, {"sha": "ac9ff484a027466a84f5a0a2e41269d9766b2bac", "filename": "src/librustc_infer/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_infer%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_infer%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Ffulfill.rs?ref=6af4fd385ec23145bc3ba08f700c61361ae961c0", "patch": "@@ -299,7 +299,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n \n         let obligation = &mut pending_obligation.obligation;\n \n-        if obligation.predicate.has_infer_types() {\n+        if obligation.predicate.has_infer_types_or_consts() {\n             obligation.predicate =\n                 self.selcx.infcx().resolve_vars_if_possible(&obligation.predicate);\n         }\n@@ -346,16 +346,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                         // This is a bit subtle: for the most part, the\n                         // only reason we can fail to make progress on\n                         // trait selection is because we don't have enough\n-                        // information about the types in the trait. One\n-                        // exception is that we sometimes haven't decided\n-                        // what kind of closure a closure is. *But*, in\n-                        // that case, it turns out, the type of the\n-                        // closure will also change, because the closure\n-                        // also includes references to its upvars as part\n-                        // of its type, and those types are resolved at\n-                        // the same time.\n-                        //\n-                        // FIXME(#32286) logic seems false if no upvars\n+                        // information about the types in the trait.\n                         pending_obligation.stalled_on =\n                             trait_ref_type_vars(self.selcx, data.to_poly_trait_ref());\n "}, {"sha": "2815a77882a7f7932062aabe302575ebb07612b2", "filename": "src/librustc_infer/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmod.rs?ref=6af4fd385ec23145bc3ba08f700c61361ae961c0", "patch": "@@ -213,7 +213,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'tcx>(\n         result\n     );\n \n-    if result && (ty.has_infer_types() || ty.has_closure_types()) {\n+    if result && ty.has_infer_types_or_consts() {\n         // Because of inference \"guessing\", selection can sometimes claim\n         // to succeed while the success requires a guess. To ensure\n         // this function's result remains infallible, we must confirm"}, {"sha": "34889c6984bb042f3405ff6c23b23128217c6db6", "filename": "src/librustc_infer/traits/project.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fproject.rs?ref=6af4fd385ec23145bc3ba08f700c61361ae961c0", "patch": "@@ -490,22 +490,14 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n     match cache_result {\n         Ok(()) => {}\n         Err(ProjectionCacheEntry::Ambiguous) => {\n-            // If we found ambiguity the last time, that generally\n-            // means we will continue to do so until some type in the\n-            // key changes (and we know it hasn't, because we just\n-            // fully resolved it). One exception though is closure\n-            // types, which can transition from having a fixed kind to\n-            // no kind with no visible change in the key.\n-            //\n-            // FIXME(#32286) refactor this so that closure type\n-            // changes\n+            // If we found ambiguity the last time, that means we will continue\n+            // to do so until some type in the key changes (and we know it\n+            // hasn't, because we just fully resolved it).\n             debug!(\n                 \"opt_normalize_projection_type: \\\n                  found cache entry: ambiguous\"\n             );\n-            if !projection_ty.has_closure_types() {\n-                return None;\n-            }\n+            return None;\n         }\n         Err(ProjectionCacheEntry::InProgress) => {\n             // If while normalized A::B, we are asked to normalize"}, {"sha": "1b6b8735651b5f3c6d94ebbe7e22f3e7d3fcfae3", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=6af4fd385ec23145bc3ba08f700c61361ae961c0", "patch": "@@ -84,7 +84,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // to avoids duplicate errors that otherwise show up.\n         fulfill_cx.register_predicate_obligations(\n             infcx,\n-            obligations.iter().filter(|o| o.predicate.has_infer_types()).cloned(),\n+            obligations.iter().filter(|o| o.predicate.has_infer_types_or_consts()).cloned(),\n         );\n \n         // From the full set of obligations, just filter down to the"}, {"sha": "b7353c6af267a8f3fe44b5d68c3ebc4a6b94057c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6af4fd385ec23145bc3ba08f700c61361ae961c0", "patch": "@@ -2900,14 +2900,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"resolve_vars_with_obligations(ty={:?})\", ty);\n \n         // No Infer()? Nothing needs doing.\n-        if !ty.has_infer_types() && !ty.has_infer_consts() {\n+        if !ty.has_infer_types_or_consts() {\n             debug!(\"resolve_vars_with_obligations: ty={:?}\", ty);\n             return ty;\n         }\n \n         // If `ty` is a type variable, see whether we already know what it is.\n         ty = self.resolve_vars_if_possible(&ty);\n-        if !ty.has_infer_types() && !ty.has_infer_consts() {\n+        if !ty.has_infer_types_or_consts() {\n             debug!(\"resolve_vars_with_obligations: ty={:?}\", ty);\n             return ty;\n         }"}, {"sha": "b39a160b5298785940b5658298f7e4e3c48583a9", "filename": "src/test/ui/const-generics/array-impls/into-iter-no-impls-length-33.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6af4fd385ec23145bc3ba08f700c61361ae961c0/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.stderr?ref=6af4fd385ec23145bc3ba08f700c61361ae961c0", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: arrays only have std trait implementations for lengths 0..=32\n-  --> $DIR/into-iter-no-impls-length-33.rs:12:5\n+  --> $DIR/into-iter-no-impls-length-33.rs:12:19\n    |\n LL |     IntoIter::new([0i32; 33])\n-   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |                   ^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n    |\n    = note: required by `std::array::IntoIter::<T, N>::new`\n \n@@ -19,10 +19,10 @@ LL |     IntoIter::new([0i32; 33])\n    = note: the return type of a function must have a statically known size\n \n error[E0277]: arrays only have std trait implementations for lengths 0..=32\n-  --> $DIR/into-iter-no-impls-length-33.rs:18:5\n+  --> $DIR/into-iter-no-impls-length-33.rs:18:19\n    |\n LL |     IntoIter::new([0i32; 33])\n-   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |                   ^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n    |\n    = note: required by `std::array::IntoIter::<T, N>::new`\n \n@@ -39,10 +39,10 @@ LL |     IntoIter::new([0i32; 33])\n    = note: the return type of a function must have a statically known size\n \n error[E0277]: arrays only have std trait implementations for lengths 0..=32\n-  --> $DIR/into-iter-no-impls-length-33.rs:24:5\n+  --> $DIR/into-iter-no-impls-length-33.rs:24:19\n    |\n LL |     IntoIter::new([0i32; 33])\n-   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |                   ^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n    |\n    = note: required by `std::array::IntoIter::<T, N>::new`\n \n@@ -59,10 +59,10 @@ LL |     IntoIter::new([0i32; 33])\n    = note: the return type of a function must have a statically known size\n \n error[E0277]: arrays only have std trait implementations for lengths 0..=32\n-  --> $DIR/into-iter-no-impls-length-33.rs:30:5\n+  --> $DIR/into-iter-no-impls-length-33.rs:30:19\n    |\n LL |     IntoIter::new([0i32; 33])\n-   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |                   ^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n    |\n    = note: required by `std::array::IntoIter::<T, N>::new`\n \n@@ -79,10 +79,10 @@ LL |     IntoIter::new([0i32; 33])\n    = note: the return type of a function must have a statically known size\n \n error[E0277]: arrays only have std trait implementations for lengths 0..=32\n-  --> $DIR/into-iter-no-impls-length-33.rs:36:5\n+  --> $DIR/into-iter-no-impls-length-33.rs:36:19\n    |\n LL |     IntoIter::new([0i32; 33])\n-   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |                   ^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n    |\n    = note: required by `std::array::IntoIter::<T, N>::new`\n \n@@ -99,10 +99,10 @@ LL |     IntoIter::new([0i32; 33])\n    = note: the return type of a function must have a statically known size\n \n error[E0277]: arrays only have std trait implementations for lengths 0..=32\n-  --> $DIR/into-iter-no-impls-length-33.rs:42:5\n+  --> $DIR/into-iter-no-impls-length-33.rs:42:19\n    |\n LL |     IntoIter::new([0i32; 33])\n-   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |                   ^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n    |\n    = note: required by `std::array::IntoIter::<T, N>::new`\n \n@@ -119,10 +119,10 @@ LL |     IntoIter::new([0i32; 33])\n    = note: the return type of a function must have a statically known size\n \n error[E0277]: arrays only have std trait implementations for lengths 0..=32\n-  --> $DIR/into-iter-no-impls-length-33.rs:48:5\n+  --> $DIR/into-iter-no-impls-length-33.rs:48:19\n    |\n LL |     IntoIter::new([0i32; 33])\n-   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |                   ^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n    |\n    = note: required by `std::array::IntoIter::<T, N>::new`\n "}]}