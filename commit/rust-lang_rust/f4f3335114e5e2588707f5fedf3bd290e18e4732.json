{"sha": "f4f3335114e5e2588707f5fedf3bd290e18e4732", "node_id": "C_kwDOAAsO6NoAKGY0ZjMzMzUxMTRlNWUyNTg4NzA3ZjVmZWRmM2JkMjkwZTE4ZTQ3MzI", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-01-23T06:22:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-23T06:22:05Z"}, "message": "Rollup merge of #107108 - sulami:issue-83968-doc-alias-typo-suggestions, r=compiler-errors\n\nConsider doc(alias) when providing typo suggestions\n\nThis means that\n\n```rust\nimpl Foo {\n    #[doc(alias = \"quux\")]\n    fn bar(&self) {}\n}\n\nfn main() {\n    (Foo {}).quux();\n}\n```\n\nwill suggest `bar`. This currently uses the \"there is a method with a similar name\" help text, because the point where we choose and emit a suggestion is different from where we gather the suggestions. Changes have mainly been made to the latter.\n\nThe selection code will now fall back to aliased candidates, but generally only if there is no candidate that matches based on the existing Levenshtein methodology.\n\nFixes #83968.", "tree": {"sha": "e494a53e4473a8f52357322d01ad532e7c17367f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e494a53e4473a8f52357322d01ad532e7c17367f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4f3335114e5e2588707f5fedf3bd290e18e4732", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjzieNCRBK7hj4Ov3rIwAARu0IAAMS7qp2q/ngLxbeXkXRDrWi\nhIKrbpILW8VB5EdpWQ1m69Ak1P8dwSLrRoaBRZxFPypCgXzjyJzIdxwBroyQQeUa\nn7HJxbxYXUxwtjk7qHyfsNCq0p/NE+x8Cdye77SULtbTrdy3yyH+7O5nIC9B5F+p\n4ZsTkywgmcbW9Gb/EOr7ThshSBnOpDB6fdiG4xlxy3fLzyuFTULlh3LnvJEMuHgG\nL1HmUHtc9X6SsTEzKgTAwIDOah9x6O73yMeCs2QfGbXVxEmJ467GlkUW0uO6VJ70\nQCOHwPEkNUkfDT7QUOpKofnOom9CEbpnG848b5dEyO5pme1kKJuK6GAtb/dl5y8=\n=Lsfy\n-----END PGP SIGNATURE-----\n", "payload": "tree e494a53e4473a8f52357322d01ad532e7c17367f\nparent 28081a6aa6a13199e6ee3c09ab544139eb23a3fa\nparent f908f0be5a088a0e1748c7853a8acf75be6d1c18\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1674454925 +0530\ncommitter GitHub <noreply@github.com> 1674454925 +0530\n\nRollup merge of #107108 - sulami:issue-83968-doc-alias-typo-suggestions, r=compiler-errors\n\nConsider doc(alias) when providing typo suggestions\n\nThis means that\n\n```rust\nimpl Foo {\n    #[doc(alias = \"quux\")]\n    fn bar(&self) {}\n}\n\nfn main() {\n    (Foo {}).quux();\n}\n```\n\nwill suggest `bar`. This currently uses the \"there is a method with a similar name\" help text, because the point where we choose and emit a suggestion is different from where we gather the suggestions. Changes have mainly been made to the latter.\n\nThe selection code will now fall back to aliased candidates, but generally only if there is no candidate that matches based on the existing Levenshtein methodology.\n\nFixes #83968.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4f3335114e5e2588707f5fedf3bd290e18e4732", "html_url": "https://github.com/rust-lang/rust/commit/f4f3335114e5e2588707f5fedf3bd290e18e4732", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4f3335114e5e2588707f5fedf3bd290e18e4732/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28081a6aa6a13199e6ee3c09ab544139eb23a3fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/28081a6aa6a13199e6ee3c09ab544139eb23a3fa", "html_url": "https://github.com/rust-lang/rust/commit/28081a6aa6a13199e6ee3c09ab544139eb23a3fa"}, {"sha": "f908f0be5a088a0e1748c7853a8acf75be6d1c18", "url": "https://api.github.com/repos/rust-lang/rust/commits/f908f0be5a088a0e1748c7853a8acf75be6d1c18", "html_url": "https://github.com/rust-lang/rust/commit/f908f0be5a088a0e1748c7853a8acf75be6d1c18"}], "stats": {"total": 90, "additions": 77, "deletions": 13}, "files": [{"sha": "47396204b14e7c50314d32a35ef9ecbd8bc7bb01", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4f3335114e5e2588707f5fedf3bd290e18e4732/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f3335114e5e2588707f5fedf3bd290e18e4732/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=f4f3335114e5e2588707f5fedf3bd290e18e4732", "patch": "@@ -76,7 +76,7 @@ pub struct NoMatchData<'tcx> {\n     pub unsatisfied_predicates:\n         Vec<(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>, Option<ObligationCause<'tcx>>)>,\n     pub out_of_scope_traits: Vec<DefId>,\n-    pub lev_candidate: Option<ty::AssocItem>,\n+    pub similar_candidate: Option<ty::AssocItem>,\n     pub mode: probe::Mode,\n }\n "}, {"sha": "9c06a22315bcba12189377e2770e9884588d5e5f", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f4f3335114e5e2588707f5fedf3bd290e18e4732/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f3335114e5e2588707f5fedf3bd290e18e4732/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=f4f3335114e5e2588707f5fedf3bd290e18e4732", "patch": "@@ -461,7 +461,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     static_candidates: Vec::new(),\n                     unsatisfied_predicates: Vec::new(),\n                     out_of_scope_traits: Vec::new(),\n-                    lev_candidate: None,\n+                    similar_candidate: None,\n                     mode,\n                 }));\n             }\n@@ -1076,13 +1076,13 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         if let Some((kind, def_id)) = private_candidate {\n             return Err(MethodError::PrivateMatch(kind, def_id, out_of_scope_traits));\n         }\n-        let lev_candidate = self.probe_for_lev_candidate()?;\n+        let similar_candidate = self.probe_for_similar_candidate()?;\n \n         Err(MethodError::NoMatch(NoMatchData {\n             static_candidates,\n             unsatisfied_predicates,\n             out_of_scope_traits,\n-            lev_candidate,\n+            similar_candidate,\n             mode: self.mode,\n         }))\n     }\n@@ -1787,7 +1787,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     /// Similarly to `probe_for_return_type`, this method attempts to find the best matching\n     /// candidate method where the method name may have been misspelled. Similarly to other\n     /// Levenshtein based suggestions, we provide at most one such suggestion.\n-    fn probe_for_lev_candidate(&mut self) -> Result<Option<ty::AssocItem>, MethodError<'tcx>> {\n+    fn probe_for_similar_candidate(&mut self) -> Result<Option<ty::AssocItem>, MethodError<'tcx>> {\n         debug!(\"probing for method names similar to {:?}\", self.method_name);\n \n         let steps = self.steps.clone();\n@@ -1831,6 +1831,12 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         None,\n                     )\n                 }\n+                .or_else(|| {\n+                    applicable_close_candidates\n+                        .iter()\n+                        .find(|cand| self.matches_by_doc_alias(cand.def_id))\n+                        .map(|cand| cand.name)\n+                })\n                 .unwrap();\n                 Ok(applicable_close_candidates.into_iter().find(|method| method.name == best_name))\n             }\n@@ -1981,6 +1987,38 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         }\n     }\n \n+    /// Determine if the associated item withe the given DefId matches\n+    /// the desired name via a doc alias.\n+    fn matches_by_doc_alias(&self, def_id: DefId) -> bool {\n+        let Some(name) = self.method_name else { return false; };\n+        let Some(local_def_id) = def_id.as_local() else { return false; };\n+        let hir_id = self.fcx.tcx.hir().local_def_id_to_hir_id(local_def_id);\n+        let attrs = self.fcx.tcx.hir().attrs(hir_id);\n+        for attr in attrs {\n+            let sym::doc = attr.name_or_empty() else { continue; };\n+            let Some(values) = attr.meta_item_list() else { continue; };\n+            for v in values {\n+                if v.name_or_empty() != sym::alias {\n+                    continue;\n+                }\n+                if let Some(nested) = v.meta_item_list() {\n+                    // #[doc(alias(\"foo\", \"bar\"))]\n+                    for n in nested {\n+                        if let Some(lit) = n.lit() && name.as_str() == lit.symbol.as_str() {\n+                            return true;\n+                        }\n+                    }\n+                } else if let Some(meta) = v.meta_item()\n+                    && let Some(lit) = meta.name_value_literal()\n+                    && name.as_str() == lit.symbol.as_str() {\n+                        // #[doc(alias = \"foo\")]\n+                        return true;\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n     /// Finds the method with the appropriate name (or return type, as the case may be). If\n     /// `allow_similar_names` is set, find methods with close-matching names.\n     // The length of the returned iterator is nearly always 0 or 1 and this\n@@ -1996,6 +2034,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         if !self.is_relevant_kind_for_mode(x.kind) {\n                             return false;\n                         }\n+                        if self.matches_by_doc_alias(x.def_id) {\n+                            return true;\n+                        }\n                         match lev_distance_with_substrings(name.as_str(), x.name.as_str(), max_dist)\n                         {\n                             Some(d) => d > 0,"}, {"sha": "8c54e9bdb5fb3a3ae7670f01c5d8e3b66c346b98", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f4f3335114e5e2588707f5fedf3bd290e18e4732/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f3335114e5e2588707f5fedf3bd290e18e4732/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=f4f3335114e5e2588707f5fedf3bd290e18e4732", "patch": "@@ -262,7 +262,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty_str = with_forced_trimmed_paths!(self.ty_to_string(rcvr_ty));\n         let is_method = mode == Mode::MethodCall;\n         let unsatisfied_predicates = &no_match_data.unsatisfied_predicates;\n-        let lev_candidate = no_match_data.lev_candidate;\n+        let similar_candidate = no_match_data.similar_candidate;\n         let item_kind = if is_method {\n             \"method\"\n         } else if rcvr_ty.is_enum() {\n@@ -937,7 +937,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // give a helping note that it has to be called as `(x.f)(...)`.\n         if let SelfSource::MethodCall(expr) = source {\n             if !self.suggest_calling_field_as_fn(span, rcvr_ty, expr, item_name, &mut err)\n-                && lev_candidate.is_none()\n+                && similar_candidate.is_none()\n                 && !custom_span_label\n             {\n                 label_span_not_found(&mut err);\n@@ -1015,20 +1015,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if fallback_span {\n                 err.span_label(span, msg);\n             }\n-        } else if let Some(lev_candidate) = lev_candidate {\n+        } else if let Some(similar_candidate) = similar_candidate {\n             // Don't emit a suggestion if we found an actual method\n             // that had unsatisfied trait bounds\n             if unsatisfied_predicates.is_empty() {\n-                let def_kind = lev_candidate.kind.as_def_kind();\n+                let def_kind = similar_candidate.kind.as_def_kind();\n                 // Methods are defined within the context of a struct and their first parameter is always self,\n                 // which represents the instance of the struct the method is being called on\n                 // Associated functions don\u2019t take self as a parameter and\n                 // they are not methods because they don\u2019t have an instance of the struct to work with.\n-                if def_kind == DefKind::AssocFn && lev_candidate.fn_has_self_parameter {\n+                if def_kind == DefKind::AssocFn && similar_candidate.fn_has_self_parameter {\n                     err.span_suggestion(\n                         span,\n                         \"there is a method with a similar name\",\n-                        lev_candidate.name,\n+                        similar_candidate.name,\n                         Applicability::MaybeIncorrect,\n                     );\n                 } else {\n@@ -1037,9 +1037,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         &format!(\n                             \"there is {} {} with a similar name\",\n                             def_kind.article(),\n-                            def_kind.descr(lev_candidate.def_id),\n+                            def_kind.descr(similar_candidate.def_id),\n                         ),\n-                        lev_candidate.name,\n+                        similar_candidate.name,\n                         Applicability::MaybeIncorrect,\n                     );\n                 }"}, {"sha": "9c6d10029239b8035c92ab6a48d5136f15fe4866", "filename": "tests/ui/methods/method-not-found-but-doc-alias.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f4f3335114e5e2588707f5fedf3bd290e18e4732/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f3335114e5e2588707f5fedf3bd290e18e4732/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.rs?ref=f4f3335114e5e2588707f5fedf3bd290e18e4732", "patch": "@@ -0,0 +1,11 @@\n+struct Foo;\n+\n+impl Foo {\n+    #[doc(alias = \"quux\")]\n+    fn bar(&self) {}\n+}\n+\n+fn main() {\n+    Foo.quux();\n+    //~^ ERROR  no method named `quux` found for struct `Foo` in the current scope\n+}"}, {"sha": "5102a452f0c28c7267fe2d72cb241ddd211673fc", "filename": "tests/ui/methods/method-not-found-but-doc-alias.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4f3335114e5e2588707f5fedf3bd290e18e4732/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4f3335114e5e2588707f5fedf3bd290e18e4732/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.stderr?ref=f4f3335114e5e2588707f5fedf3bd290e18e4732", "patch": "@@ -0,0 +1,12 @@\n+error[E0599]: no method named `quux` found for struct `Foo` in the current scope\n+  --> $DIR/method-not-found-but-doc-alias.rs:9:9\n+   |\n+LL | struct Foo;\n+   | ---------- method `quux` not found for this struct\n+...\n+LL |     Foo.quux();\n+   |         ^^^^ help: there is a method with a similar name: `bar`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}]}