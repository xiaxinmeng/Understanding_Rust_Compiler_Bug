{"sha": "90788159d7f1f0458352b8849cf9bb80ceed50a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwNzg4MTU5ZDdmMWYwNDU4MzUyYjg4NDljZjliYjgwY2VlZDUwYTE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-22T16:08:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-22T16:08:14Z"}, "message": "Rollup merge of #60773 - Aaron1011:fix/rustdoc-project-all, r=eddyb\n\nAlways try to project predicates when finding auto traits in rustdoc\n\nFixes #60726\n\nPrevious, AutoTraitFinder would only try to project predicates when the\npredicate type contained an inference variable. When finding auto\ntraits, we only project to try to unify inference variables - we don't\notherwise learn any new information about the required bounds.\n\nHowever, this lead to failing to properly generate a negative auto trait\nimpl (indicating that a type never implements a certain auto trait) in\nthe following unusual scenario:\n\nIn almost all cases, a type has an (implicit) negative impl of an auto\ntrait due some other type having an explicit *negative* impl of that\nauto trait. For example:\n\nstruct MyType<T> {\n    field: *const T\n}\n\nhas an implicit 'impl<T> !Send for MyType<T>', due to the explicit\nnegative impl (in libcore) 'impl<T: ?Sized> !Send for *const T'.\n\nHowever, as exposed by the 'abi_stable' crate, this isn't always the\ncase. This minimzed example shows how a type can never implement\n'Send', due to a projection error:\n\n```\npub struct True;\npub struct False;\n\npub trait MyTrait {\n    type Project;\n}\n\npub struct MyStruct<T> {\n    field: T\n}\n\nimpl MyTrait for u8 {\n    type Project = False;\n}\n\nunsafe impl<T> Send for MyStruct<T>\n    where T: MyTrait<Project=True> {}\n\npub struct Wrapper {\n    inner: MyStruct<u8>\n}\n```\n\nIn this example, `<u8 as MyTrait>::Project == True'\nmust hold for 'MyStruct<u8>: Send' to hold.\nHowever, '<u8 as MyTrait>::Project == False' holds instead\n\nTo properly account for this unusual case, we need to call\n'poly_project_and_unify' on *all* predicates, not just those with\ninference variables. This ensures that we catch the projection error\nthat occurs above, and don't incorrectly determine that 'Wrapper: Send'\nholds.", "tree": {"sha": "9b39fe0ad9b1c765b40caa904dad4ba5aeb4550a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b39fe0ad9b1c765b40caa904dad4ba5aeb4550a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90788159d7f1f0458352b8849cf9bb80ceed50a1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc5XPuCRBK7hj4Ov3rIwAAdHIIAGT1sHh9v2sGbZtrpU6r+iGI\niebm73F7ES00jiipd53Fe0mtegCCCAOCfBbs0TnZdUdxsyj+EFL2wuypNN/Xs1xi\nZl9NL+svK4vN60QwrQXF31ufd7WyI3yr4UKhNp7sFhSoPM/vPS+gOAB3cjaSqo+e\nrZupIR+1Nr8K4UtLP1/+UItcCtIdTpylS3zDIro1lAmOQHPj1sdYkzmrg9FUgjKd\nlxbxdWxye8agznPnu+wjLfBOAVqovRz3uItVHoB/NXXdchDrZkln0GoeYcqwtKaW\nnP1j35nEYeFghwEhE3mPzSVlqnHD/RIEnKBFUMXixY+qNpuUY+2gVIUoSLnefM4=\n=7p4d\n-----END PGP SIGNATURE-----\n", "payload": "tree 9b39fe0ad9b1c765b40caa904dad4ba5aeb4550a\nparent 7cd8d3d8d00bcadb32a4243f33b91c7b89af7a69\nparent 476ea9ef1c0ba7250e369a2ec7205506b09474b7\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1558541294 +0200\ncommitter GitHub <noreply@github.com> 1558541294 +0200\n\nRollup merge of #60773 - Aaron1011:fix/rustdoc-project-all, r=eddyb\n\nAlways try to project predicates when finding auto traits in rustdoc\n\nFixes #60726\n\nPrevious, AutoTraitFinder would only try to project predicates when the\npredicate type contained an inference variable. When finding auto\ntraits, we only project to try to unify inference variables - we don't\notherwise learn any new information about the required bounds.\n\nHowever, this lead to failing to properly generate a negative auto trait\nimpl (indicating that a type never implements a certain auto trait) in\nthe following unusual scenario:\n\nIn almost all cases, a type has an (implicit) negative impl of an auto\ntrait due some other type having an explicit *negative* impl of that\nauto trait. For example:\n\nstruct MyType<T> {\n    field: *const T\n}\n\nhas an implicit 'impl<T> !Send for MyType<T>', due to the explicit\nnegative impl (in libcore) 'impl<T: ?Sized> !Send for *const T'.\n\nHowever, as exposed by the 'abi_stable' crate, this isn't always the\ncase. This minimzed example shows how a type can never implement\n'Send', due to a projection error:\n\n```\npub struct True;\npub struct False;\n\npub trait MyTrait {\n    type Project;\n}\n\npub struct MyStruct<T> {\n    field: T\n}\n\nimpl MyTrait for u8 {\n    type Project = False;\n}\n\nunsafe impl<T> Send for MyStruct<T>\n    where T: MyTrait<Project=True> {}\n\npub struct Wrapper {\n    inner: MyStruct<u8>\n}\n```\n\nIn this example, `<u8 as MyTrait>::Project == True'\nmust hold for 'MyStruct<u8>: Send' to hold.\nHowever, '<u8 as MyTrait>::Project == False' holds instead\n\nTo properly account for this unusual case, we need to call\n'poly_project_and_unify' on *all* predicates, not just those with\ninference variables. This ensures that we catch the projection error\nthat occurs above, and don't incorrectly determine that 'Wrapper: Send'\nholds.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90788159d7f1f0458352b8849cf9bb80ceed50a1", "html_url": "https://github.com/rust-lang/rust/commit/90788159d7f1f0458352b8849cf9bb80ceed50a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90788159d7f1f0458352b8849cf9bb80ceed50a1/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cd8d3d8d00bcadb32a4243f33b91c7b89af7a69", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cd8d3d8d00bcadb32a4243f33b91c7b89af7a69", "html_url": "https://github.com/rust-lang/rust/commit/7cd8d3d8d00bcadb32a4243f33b91c7b89af7a69"}, {"sha": "476ea9ef1c0ba7250e369a2ec7205506b09474b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/476ea9ef1c0ba7250e369a2ec7205506b09474b7", "html_url": "https://github.com/rust-lang/rust/commit/476ea9ef1c0ba7250e369a2ec7205506b09474b7"}], "stats": {"total": 120, "additions": 103, "deletions": 17}, "files": [{"sha": "2fa896962daf9f6c5442241ee41188b62bdd0409", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 68, "deletions": 17, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/90788159d7f1f0458352b8849cf9bb80ceed50a1/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90788159d7f1f0458352b8849cf9bb80ceed50a1/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=90788159d7f1f0458352b8849cf9bb80ceed50a1", "patch": "@@ -700,22 +700,64 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                             }\n                     }\n \n-                    // We can only call poly_project_and_unify_type when our predicate's\n-                    // Ty contains an inference variable - otherwise, there won't be anything to\n-                    // unify\n-                    if p.ty().skip_binder().has_infer_types() {\n-                        debug!(\"Projecting and unifying projection predicate {:?}\",\n-                               predicate);\n-                        match poly_project_and_unify_type(select, &obligation.with(p)) {\n-                            Err(e) => {\n-                                debug!(\n-                                    \"evaluate_nested_obligations: Unable to unify predicate \\\n-                                     '{:?}' '{:?}', bailing out\",\n-                                    ty, e\n-                                );\n-                                return false;\n-                            }\n-                            Ok(Some(v)) => {\n+                    // There are three possible cases when we project a predicate:\n+                    //\n+                    // 1. We encounter an error. This means that it's impossible for\n+                    // our current type to implement the auto trait - there's bound\n+                    // that we could add to our ParamEnv that would 'fix' this kind\n+                    // of error, as it's not caused by an unimplemented type.\n+                    //\n+                    // 2. We succesfully project the predicate (Ok(Some(_))), generating\n+                    //  some subobligations. We then process these subobligations\n+                    //  like any other generated sub-obligations.\n+                    //\n+                    // 3. We receieve an 'ambiguous' result (Ok(None))\n+                    // If we were actually trying to compile a crate,\n+                    // we would need to re-process this obligation later.\n+                    // However, all we care about is finding out what bounds\n+                    // are needed for our type to implement a particular auto trait.\n+                    // We've already added this obligation to our computed ParamEnv\n+                    // above (if it was necessary). Therefore, we don't need\n+                    // to do any further processing of the obligation.\n+                    //\n+                    // Note that we *must* try to project *all* projection predicates\n+                    // we encounter, even ones without inference variable.\n+                    // This ensures that we detect any projection errors,\n+                    // which indicate that our type can *never* implement the given\n+                    // auto trait. In that case, we will generate an explicit negative\n+                    // impl (e.g. 'impl !Send for MyType'). However, we don't\n+                    // try to process any of the generated subobligations -\n+                    // they contain no new information, since we already know\n+                    // that our type implements the projected-through trait,\n+                    // and can lead to weird region issues.\n+                    //\n+                    // Normally, we'll generate a negative impl as a result of encountering\n+                    // a type with an explicit negative impl of an auto trait\n+                    // (for example, raw pointers have !Send and !Sync impls)\n+                    // However, through some **interesting** manipulations of the type\n+                    // system, it's actually possible to write a type that never\n+                    // implements an auto trait due to a projection error, not a normal\n+                    // negative impl error. To properly handle this case, we need\n+                    // to ensure that we catch any potential projection errors,\n+                    // and turn them into an explicit negative impl for our type.\n+                    debug!(\"Projecting and unifying projection predicate {:?}\",\n+                           predicate);\n+\n+                    match poly_project_and_unify_type(select, &obligation.with(p)) {\n+                        Err(e) => {\n+                            debug!(\n+                                \"evaluate_nested_obligations: Unable to unify predicate \\\n+                                 '{:?}' '{:?}', bailing out\",\n+                                ty, e\n+                            );\n+                            return false;\n+                        }\n+                        Ok(Some(v)) => {\n+                            // We only care about sub-obligations\n+                            // when we started out trying to unify\n+                            // some inference variables. See the comment above\n+                            // for more infomration\n+                            if p.ty().skip_binder().has_infer_types() {\n                                 if !self.evaluate_nested_obligations(\n                                     ty,\n                                     v.clone().iter().cloned(),\n@@ -728,7 +770,16 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                     return false;\n                                 }\n                             }\n-                            Ok(None) => {\n+                        }\n+                        Ok(None) => {\n+                            // It's ok not to make progress when hvave no inference variables -\n+                            // in that case, we were only performing unifcation to check if an\n+                            // error occured (which would indicate that it's impossible for our\n+                            // type to implement the auto trait).\n+                            // However, we should always make progress (either by generating\n+                            // subobligations or getting an error) when we started off with\n+                            // inference variables\n+                            if p.ty().skip_binder().has_infer_types() {\n                                 panic!(\"Unexpected result when selecting {:?} {:?}\", ty, obligation)\n                             }\n                         }"}, {"sha": "6acc86277385de125041e9e09f4f45c7dbadadd4", "filename": "src/test/rustdoc/issue-60726.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/90788159d7f1f0458352b8849cf9bb80ceed50a1/src%2Ftest%2Frustdoc%2Fissue-60726.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90788159d7f1f0458352b8849cf9bb80ceed50a1/src%2Ftest%2Frustdoc%2Fissue-60726.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-60726.rs?ref=90788159d7f1f0458352b8849cf9bb80ceed50a1", "patch": "@@ -0,0 +1,35 @@\n+use std::marker::PhantomData;\n+\n+pub struct True;\n+pub struct False;\n+\n+pub trait InterfaceType{\n+    type Send;\n+}\n+\n+\n+pub struct FooInterface<T>(PhantomData<fn()->T>);\n+\n+impl<T> InterfaceType for FooInterface<T> {\n+    type Send=False;\n+}\n+\n+\n+pub struct DynTrait<I>{\n+    _interface:PhantomData<fn()->I>,\n+    _unsync_unsend:PhantomData<::std::rc::Rc<()>>,\n+}\n+\n+unsafe impl<I> Send for DynTrait<I>\n+where\n+    I:InterfaceType<Send=True>\n+{}\n+\n+// @has issue_60726/struct.IntoIter.html\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<T> !Send for \\\n+// IntoIter<T>\"\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<T> !Sync for \\\n+// IntoIter<T>\"\n+pub struct IntoIter<T>{\n+    hello:DynTrait<FooInterface<T>>,\n+}"}]}