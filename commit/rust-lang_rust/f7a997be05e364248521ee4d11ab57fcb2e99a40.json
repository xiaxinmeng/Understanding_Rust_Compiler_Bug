{"sha": "f7a997be05e364248521ee4d11ab57fcb2e99a40", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3YTk5N2JlMDVlMzY0MjQ4NTIxZWU0ZDExYWI1N2ZjYjJlOTlhNDA=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-06T16:13:04Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-08T12:28:24Z"}, "message": "rustc: fix fallout from the addition of a 'tcx lifetime on trans::Block.", "tree": {"sha": "8894b56715c16ec48e720575e8892fd81e396392", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8894b56715c16ec48e720575e8892fd81e396392"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7a997be05e364248521ee4d11ab57fcb2e99a40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7a997be05e364248521ee4d11ab57fcb2e99a40", "html_url": "https://github.com/rust-lang/rust/commit/f7a997be05e364248521ee4d11ab57fcb2e99a40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7a997be05e364248521ee4d11ab57fcb2e99a40/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28be695b2c727b380d075986cbe52e699761b56e", "url": "https://api.github.com/repos/rust-lang/rust/commits/28be695b2c727b380d075986cbe52e699761b56e", "html_url": "https://github.com/rust-lang/rust/commit/28be695b2c727b380d075986cbe52e699761b56e"}], "stats": {"total": 2230, "additions": 1095, "deletions": 1135}, "files": [{"sha": "dd0668b8fa0e77aefdd8aa8f4fda189913c41356", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 144, "deletions": 153, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=f7a997be05e364248521ee4d11ab57fcb2e99a40", "patch": "@@ -225,14 +225,14 @@ use syntax::ast::Ident;\n use syntax::codemap::Span;\n use syntax::fold::Folder;\n \n-struct ConstantExpr<'a>(&'a ty::ctxt, Gc<ast::Expr>);\n+struct ConstantExpr<'a, 'tcx: 'a>(&'a ty::ctxt<'tcx>, Gc<ast::Expr>);\n \n-impl<'a> Eq for ConstantExpr<'a> {\n+impl<'a, 'tcx> Eq for ConstantExpr<'a, 'tcx> {\n     fn assert_receiver_is_total_eq(&self) {}\n }\n \n-impl<'a> PartialEq for ConstantExpr<'a> {\n-    fn eq(&self, other: &ConstantExpr<'a>) -> bool {\n+impl<'a, 'tcx> PartialEq for ConstantExpr<'a, 'tcx> {\n+    fn eq(&self, other: &ConstantExpr<'a, 'tcx>) -> bool {\n         let &ConstantExpr(tcx, expr) = self;\n         let &ConstantExpr(_, other_expr) = other;\n         match const_eval::compare_lit_exprs(tcx, &*expr, &*other_expr) {\n@@ -244,16 +244,16 @@ impl<'a> PartialEq for ConstantExpr<'a> {\n \n // An option identifying a branch (either a literal, an enum variant or a range)\n #[deriving(Eq, PartialEq)]\n-enum Opt<'a> {\n-    ConstantValue(ConstantExpr<'a>),\n-    ConstantRange(ConstantExpr<'a>, ConstantExpr<'a>),\n+enum Opt<'blk, 'tcx: 'blk> {\n+    ConstantValue(ConstantExpr<'blk, 'tcx>),\n+    ConstantRange(ConstantExpr<'blk, 'tcx>, ConstantExpr<'blk, 'tcx>),\n     Variant(ty::Disr, Rc<adt::Repr>, ast::DefId),\n     SliceLengthEqual(uint),\n     SliceLengthGreaterOrEqual(/* prefix length */ uint, /* suffix length */ uint),\n }\n \n-impl<'a> Opt<'a> {\n-    fn trans(&self, mut bcx: &'a Block<'a>) -> OptResult<'a> {\n+impl<'blk, 'tcx> Opt<'blk, 'tcx> {\n+    fn trans(&self, mut bcx: Block<'blk, 'tcx>) -> OptResult<'blk, 'tcx> {\n         let _icx = push_ctxt(\"match::trans_opt\");\n         let ccx = bcx.ccx();\n         match *self {\n@@ -293,10 +293,10 @@ pub enum BranchKind {\n     CompareSliceLength\n }\n \n-pub enum OptResult<'a> {\n-    SingleResult(Result<'a>),\n-    RangeResult(Result<'a>, Result<'a>),\n-    LowerBound(Result<'a>)\n+pub enum OptResult<'blk, 'tcx: 'blk> {\n+    SingleResult(Result<'blk, 'tcx>),\n+    RangeResult(Result<'blk, 'tcx>, Result<'blk, 'tcx>),\n+    LowerBound(Result<'blk, 'tcx>)\n }\n \n #[deriving(Clone)]\n@@ -325,8 +325,8 @@ pub struct BindingInfo {\n \n type BindingsMap = HashMap<Ident, BindingInfo>;\n \n-struct ArmData<'a, 'b> {\n-    bodycx: &'b Block<'b>,\n+struct ArmData<'a, 'blk, 'tcx: 'blk> {\n+    bodycx: Block<'blk, 'tcx>,\n     arm: &'a ast::Arm,\n     bindings_map: BindingsMap\n }\n@@ -337,13 +337,13 @@ struct ArmData<'a, 'b> {\n  * As we proceed `bound_ptrs` are filled with pointers to values to be bound,\n  * these pointers are stored in llmatch variables just before executing `data` arm.\n  */\n-struct Match<'a, 'b:'a> {\n+struct Match<'a, 'blk: 'a, 'tcx: 'blk> {\n     pats: Vec<Gc<ast::Pat>>,\n-    data: &'a ArmData<'a, 'b>,\n+    data: &'a ArmData<'a, 'blk, 'tcx>,\n     bound_ptrs: Vec<(Ident, ValueRef)>\n }\n \n-impl<'a, 'b> Repr for Match<'a, 'b> {\n+impl<'a, 'blk, 'tcx> Repr for Match<'a, 'blk, 'tcx> {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         if tcx.sess.verbose() {\n             // for many programs, this just take too long to serialize\n@@ -364,12 +364,11 @@ fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     return false;\n }\n \n-fn expand_nested_bindings<'a, 'b>(\n-                          bcx: &'b Block<'b>,\n-                          m: &'a [Match<'a, 'b>],\n-                          col: uint,\n-                          val: ValueRef)\n-                          -> Vec<Match<'a, 'b>> {\n+fn expand_nested_bindings<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                          m: &'a [Match<'a, 'blk, 'tcx>],\n+                                          col: uint,\n+                                          val: ValueRef)\n+                                          -> Vec<Match<'a, 'blk, 'tcx>> {\n     debug!(\"expand_nested_bindings(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -402,14 +401,13 @@ fn expand_nested_bindings<'a, 'b>(\n \n type EnterPatterns<'a> = |&[Gc<ast::Pat>]|: 'a -> Option<Vec<Gc<ast::Pat>>>;\n \n-fn enter_match<'a, 'b>(\n-               bcx: &'b Block<'b>,\n-               dm: &DefMap,\n-               m: &'a [Match<'a, 'b>],\n-               col: uint,\n-               val: ValueRef,\n-               e: EnterPatterns)\n-               -> Vec<Match<'a, 'b>> {\n+fn enter_match<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               dm: &DefMap,\n+                               m: &'a [Match<'a, 'blk, 'tcx>],\n+                               col: uint,\n+                               val: ValueRef,\n+                               e: EnterPatterns)\n+                               -> Vec<Match<'a, 'blk, 'tcx>> {\n     debug!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -450,13 +448,12 @@ fn enter_match<'a, 'b>(\n     }).collect()\n }\n \n-fn enter_default<'a, 'b>(\n-                 bcx: &'b Block<'b>,\n-                 dm: &DefMap,\n-                 m: &'a [Match<'a, 'b>],\n-                 col: uint,\n-                 val: ValueRef)\n-                 -> Vec<Match<'a, 'b>> {\n+fn enter_default<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 dm: &DefMap,\n+                                 m: &'a [Match<'a, 'blk, 'tcx>],\n+                                 col: uint,\n+                                 val: ValueRef)\n+                                 -> Vec<Match<'a, 'blk, 'tcx>> {\n     debug!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -502,16 +499,16 @@ fn enter_default<'a, 'b>(\n /// takes the complete row of patterns rather than just the first one.\n /// Also, most of the enter_() family functions have been unified with\n /// the check_match specialization step.\n-fn enter_opt<'a, 'b>(\n-             bcx: &'b Block<'b>,\n+fn enter_opt<'a, 'blk, 'tcx>(\n+             bcx: Block<'blk, 'tcx>,\n              _: ast::NodeId,\n              dm: &DefMap,\n-             m: &'a [Match<'a, 'b>],\n+             m: &'a [Match<'a, 'blk, 'tcx>],\n              opt: &Opt,\n              col: uint,\n              variant_size: uint,\n              val: ValueRef)\n-             -> Vec<Match<'a, 'b>> {\n+             -> Vec<Match<'a, 'blk, 'tcx>> {\n     debug!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -545,10 +542,12 @@ fn enter_opt<'a, 'b>(\n // Returns the options in one column of matches. An option is something that\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n-fn get_branches<'a>(bcx: &'a Block, m: &[Match], col: uint) -> Vec<Opt<'a>> {\n+fn get_branches<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                            m: &[Match], col: uint)\n+                            -> Vec<Opt<'blk, 'tcx>> {\n     let ccx = bcx.ccx();\n \n-    fn add_to_set<'a>(set: &mut Vec<Opt<'a>>, opt: Opt<'a>) {\n+    fn add_to_set<'blk, 'tcx>(set: &mut Vec<Opt<'blk, 'tcx>>, opt: Opt<'blk, 'tcx>) {\n         if !set.contains(&opt) {\n             set.push(opt);\n         }\n@@ -593,17 +592,16 @@ fn get_branches<'a>(bcx: &'a Block, m: &[Match], col: uint) -> Vec<Opt<'a>> {\n     found\n }\n \n-struct ExtractedBlock<'a> {\n-    vals: Vec<ValueRef> ,\n-    bcx: &'a Block<'a>,\n+struct ExtractedBlock<'blk, 'tcx: 'blk> {\n+    vals: Vec<ValueRef>,\n+    bcx: Block<'blk, 'tcx>,\n }\n \n-fn extract_variant_args<'a>(\n-                        bcx: &'a Block<'a>,\n-                        repr: &adt::Repr,\n-                        disr_val: ty::Disr,\n-                        val: ValueRef)\n-                        -> ExtractedBlock<'a> {\n+fn extract_variant_args<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    repr: &adt::Repr,\n+                                    disr_val: ty::Disr,\n+                                    val: ValueRef)\n+                                    -> ExtractedBlock<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::extract_variant_args\");\n     let args = Vec::from_fn(adt::num_args(repr, disr_val), |i| {\n         adt::trans_field_ptr(bcx, repr, val, disr_val, i)\n@@ -621,12 +619,11 @@ fn match_datum(val: ValueRef, left_ty: ty::t) -> Datum<Lvalue> {\n     Datum::new(val, left_ty, Lvalue)\n }\n \n-fn bind_subslice_pat<'a>(\n-                    bcx: &'a Block<'a>,\n-                    pat_id: ast::NodeId,\n-                    val: ValueRef,\n-                    offset_left: uint,\n-                    offset_right: uint) -> ValueRef {\n+fn bind_subslice_pat(bcx: Block,\n+                     pat_id: ast::NodeId,\n+                     val: ValueRef,\n+                     offset_left: uint,\n+                     offset_right: uint) -> ValueRef {\n     let _icx = push_ctxt(\"match::bind_subslice_pat\");\n     let vec_ty = node_id_type(bcx, pat_id);\n     let vt = tvec::vec_types(bcx, ty::sequence_element_type(bcx.tcx(), ty::type_content(vec_ty)));\n@@ -647,13 +644,12 @@ fn bind_subslice_pat<'a>(\n     scratch.val\n }\n \n-fn extract_vec_elems<'a>(\n-                     bcx: &'a Block<'a>,\n-                     left_ty: ty::t,\n-                     before: uint,\n-                     after: uint,\n-                     val: ValueRef)\n-                     -> ExtractedBlock<'a> {\n+fn extract_vec_elems<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 left_ty: ty::t,\n+                                 before: uint,\n+                                 after: uint,\n+                                 val: ValueRef)\n+                                 -> ExtractedBlock<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::extract_vec_elems\");\n     let vec_datum = match_datum(val, left_ty);\n     let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n@@ -714,13 +710,13 @@ fn any_irrefutable_adt_pat(tcx: &ty::ctxt, m: &[Match], col: uint) -> bool {\n }\n \n /// What to do when the pattern match fails.\n-enum FailureHandler<'a> {\n+enum FailureHandler {\n     Infallible,\n     JumpToBasicBlock(BasicBlockRef),\n     Unreachable\n }\n \n-impl<'a> FailureHandler<'a> {\n+impl FailureHandler {\n     fn is_fallible(&self) -> bool {\n         match *self {\n             Infallible => false,\n@@ -732,7 +728,7 @@ impl<'a> FailureHandler<'a> {\n         !self.is_fallible()\n     }\n \n-    fn handle_fail(&self, bcx: &Block) {\n+    fn handle_fail(&self, bcx: Block) {\n         match *self {\n             Infallible =>\n                 fail!(\"attempted to fail in an infallible failure handler!\"),\n@@ -774,17 +770,16 @@ fn pick_col(m: &[Match]) -> uint {\n }\n \n // Compiles a comparison between two things.\n-fn compare_values<'a>(\n-                  cx: &'a Block<'a>,\n-                  lhs: ValueRef,\n-                  rhs: ValueRef,\n-                  rhs_t: ty::t)\n-                  -> Result<'a> {\n-    fn compare_str<'a>(cx: &'a Block<'a>,\n-                       lhs: ValueRef,\n-                       rhs: ValueRef,\n-                       rhs_t: ty::t)\n-                       -> Result<'a> {\n+fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                              lhs: ValueRef,\n+                              rhs: ValueRef,\n+                              rhs_t: ty::t)\n+                              -> Result<'blk, 'tcx> {\n+    fn compare_str<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                               lhs: ValueRef,\n+                               rhs: ValueRef,\n+                               rhs_t: ty::t)\n+                               -> Result<'blk, 'tcx> {\n         let did = langcall(cx,\n                            None,\n                            format!(\"comparison of `{}`\",\n@@ -819,9 +814,10 @@ fn compare_values<'a>(\n     }\n }\n \n-fn insert_lllocals<'a>(mut bcx: &'a Block<'a>, bindings_map: &BindingsMap,\n-                       cs: Option<cleanup::ScopeId>)\n-                       -> &'a Block<'a> {\n+fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                               bindings_map: &BindingsMap,\n+                               cs: Option<cleanup::ScopeId>)\n+                               -> Block<'blk, 'tcx> {\n     /*!\n      * For each binding in `data.bindings_map`, adds an appropriate entry into\n      * the `fcx.lllocals` map\n@@ -874,15 +870,14 @@ fn insert_lllocals<'a>(mut bcx: &'a Block<'a>, bindings_map: &BindingsMap,\n     bcx\n }\n \n-fn compile_guard<'a, 'b>(\n-                 bcx: &'b Block<'b>,\n-                 guard_expr: &ast::Expr,\n-                 data: &ArmData,\n-                 m: &'a [Match<'a, 'b>],\n-                 vals: &[ValueRef],\n-                 chk: &FailureHandler,\n-                 has_genuine_default: bool)\n-                 -> &'b Block<'b> {\n+fn compile_guard<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 guard_expr: &ast::Expr,\n+                                 data: &ArmData,\n+                                 m: &'a [Match<'a, 'blk, 'tcx>],\n+                                 vals: &[ValueRef],\n+                                 chk: &FailureHandler,\n+                                 has_genuine_default: bool)\n+                                 -> Block<'blk, 'tcx> {\n     debug!(\"compile_guard(bcx={}, guard_expr={}, m={}, vals={})\",\n            bcx.to_str(),\n            bcx.expr_to_string(guard_expr),\n@@ -923,12 +918,11 @@ fn compile_guard<'a, 'b>(\n     })\n }\n \n-fn compile_submatch<'a, 'b>(\n-                    bcx: &'b Block<'b>,\n-                    m: &'a [Match<'a, 'b>],\n-                    vals: &[ValueRef],\n-                    chk: &FailureHandler,\n-                    has_genuine_default: bool) {\n+fn compile_submatch<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    m: &'a [Match<'a, 'blk, 'tcx>],\n+                                    vals: &[ValueRef],\n+                                    chk: &FailureHandler,\n+                                    has_genuine_default: bool) {\n     debug!(\"compile_submatch(bcx={}, m={}, vals={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -984,14 +978,13 @@ fn compile_submatch<'a, 'b>(\n     }\n }\n \n-fn compile_submatch_continue<'a, 'b>(\n-                             mut bcx: &'b Block<'b>,\n-                             m: &'a [Match<'a, 'b>],\n-                             vals: &[ValueRef],\n-                             chk: &FailureHandler,\n-                             col: uint,\n-                             val: ValueRef,\n-                             has_genuine_default: bool) {\n+fn compile_submatch_continue<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                             m: &'a [Match<'a, 'blk, 'tcx>],\n+                                             vals: &[ValueRef],\n+                                             chk: &FailureHandler,\n+                                             col: uint,\n+                                             val: ValueRef,\n+                                             has_genuine_default: bool) {\n     let fcx = bcx.fcx;\n     let tcx = bcx.tcx();\n     let dm = &tcx.def_map;\n@@ -1218,19 +1211,18 @@ fn compile_submatch_continue<'a, 'b>(\n     }\n }\n \n-pub fn trans_match<'a>(\n-                   bcx: &'a Block<'a>,\n-                   match_expr: &ast::Expr,\n-                   discr_expr: &ast::Expr,\n-                   arms: &[ast::Arm],\n-                   dest: Dest)\n-                   -> &'a Block<'a> {\n+pub fn trans_match<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               match_expr: &ast::Expr,\n+                               discr_expr: &ast::Expr,\n+                               arms: &[ast::Arm],\n+                               dest: Dest)\n+                               -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::trans_match\");\n     trans_match_inner(bcx, match_expr.id, discr_expr, arms, dest)\n }\n \n /// Checks whether the binding in `discr` is assigned to anywhere in the expression `body`\n-fn is_discr_reassigned(bcx: &Block, discr: &ast::Expr, body: &ast::Expr) -> bool {\n+fn is_discr_reassigned(bcx: Block, discr: &ast::Expr, body: &ast::Expr) -> bool {\n     match discr.node {\n         ast::ExprPath(..) => match bcx.def(discr.id) {\n             def::DefArg(vid, _) | def::DefBinding(vid, _) |\n@@ -1272,7 +1264,7 @@ impl euv::Delegate for ReassignmentChecker {\n     }\n }\n \n-fn create_bindings_map(bcx: &Block, pat: Gc<ast::Pat>,\n+fn create_bindings_map(bcx: Block, pat: Gc<ast::Pat>,\n                       discr: &ast::Expr, body: &ast::Expr) -> BindingsMap {\n     // Create the bindings map, which is a mapping from each binding name\n     // to an alloca() that will be the value for that local variable.\n@@ -1327,11 +1319,11 @@ fn create_bindings_map(bcx: &Block, pat: Gc<ast::Pat>,\n     return bindings_map;\n }\n \n-fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n-                         match_id: ast::NodeId,\n-                         discr_expr: &ast::Expr,\n-                         arms: &[ast::Arm],\n-                         dest: Dest) -> &'a Block<'a> {\n+fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n+                                 match_id: ast::NodeId,\n+                                 discr_expr: &ast::Expr,\n+                                 arms: &[ast::Arm],\n+                                 dest: Dest) -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::trans_match_inner\");\n     let fcx = scope_cx.fcx;\n     let mut bcx = scope_cx;\n@@ -1402,9 +1394,9 @@ enum IrrefutablePatternBindingMode {\n     BindArgument\n }\n \n-pub fn store_local<'a>(bcx: &'a Block<'a>,\n-                       local: &ast::Local)\n-                       -> &'a Block<'a> {\n+pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               local: &ast::Local)\n+                               -> Block<'blk, 'tcx> {\n     /*!\n      * Generates code for a local variable declaration like\n      * `let <pat>;` or `let <pat> = <opt_init_expr>`.\n@@ -1457,9 +1449,9 @@ pub fn store_local<'a>(bcx: &'a Block<'a>,\n         }\n     };\n \n-    fn create_dummy_locals<'a>(mut bcx: &'a Block<'a>,\n-                               pat: Gc<ast::Pat>)\n-                               -> &'a Block<'a> {\n+    fn create_dummy_locals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                       pat: Gc<ast::Pat>)\n+                                       -> Block<'blk, 'tcx> {\n         // create dummy memory for the variables if we have no\n         // value to store into them immediately\n         let tcx = bcx.tcx();\n@@ -1473,11 +1465,11 @@ pub fn store_local<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-pub fn store_arg<'a>(mut bcx: &'a Block<'a>,\n-                     pat: Gc<ast::Pat>,\n-                     arg: Datum<Rvalue>,\n-                     arg_scope: cleanup::ScopeId)\n-                     -> &'a Block<'a> {\n+pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                             pat: Gc<ast::Pat>,\n+                             arg: Datum<Rvalue>,\n+                             arg_scope: cleanup::ScopeId)\n+                             -> Block<'blk, 'tcx> {\n     /*!\n      * Generates code for argument patterns like `fn foo(<pat>: T)`.\n      * Creates entries in the `llargs` map for each of the bindings\n@@ -1527,12 +1519,11 @@ pub fn store_arg<'a>(mut bcx: &'a Block<'a>,\n \n /// Generates code for the pattern binding in a `for` loop like\n /// `for <pat> in <expr> { ... }`.\n-pub fn store_for_loop_binding<'a>(\n-                              bcx: &'a Block<'a>,\n-                              pat: Gc<ast::Pat>,\n-                              llvalue: ValueRef,\n-                              body_scope: cleanup::ScopeId)\n-                              -> &'a Block<'a> {\n+pub fn store_for_loop_binding<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                          pat: Gc<ast::Pat>,\n+                                          llvalue: ValueRef,\n+                                          body_scope: cleanup::ScopeId)\n+                                          -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::store_for_loop_binding\");\n \n     if simple_identifier(&*pat).is_some() {\n@@ -1550,14 +1541,15 @@ pub fn store_for_loop_binding<'a>(\n     bind_irrefutable_pat(bcx, pat, llvalue, BindLocal, body_scope)\n }\n \n-fn mk_binding_alloca<'a,A>(bcx: &'a Block<'a>,\n-                           p_id: ast::NodeId,\n-                           ident: &ast::Ident,\n-                           binding_mode: IrrefutablePatternBindingMode,\n-                           cleanup_scope: cleanup::ScopeId,\n-                           arg: A,\n-                           populate: |A, &'a Block<'a>, ValueRef, ty::t| -> &'a Block<'a>)\n-                         -> &'a Block<'a> {\n+fn mk_binding_alloca<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n+                                    p_id: ast::NodeId,\n+                                    ident: &ast::Ident,\n+                                    binding_mode: IrrefutablePatternBindingMode,\n+                                    cleanup_scope: cleanup::ScopeId,\n+                                    arg: A,\n+                                    populate: |A, Block<'blk, 'tcx>, ValueRef, ty::t|\n+                                              -> Block<'blk, 'tcx>)\n+                                    -> Block<'blk, 'tcx> {\n     let var_ty = node_id_type(bcx, p_id);\n \n     // Allocate memory on stack for the binding.\n@@ -1580,13 +1572,12 @@ fn mk_binding_alloca<'a,A>(bcx: &'a Block<'a>,\n     bcx\n }\n \n-fn bind_irrefutable_pat<'a>(\n-                        bcx: &'a Block<'a>,\n-                        pat: Gc<ast::Pat>,\n-                        val: ValueRef,\n-                        binding_mode: IrrefutablePatternBindingMode,\n-                        cleanup_scope: cleanup::ScopeId)\n-                        -> &'a Block<'a> {\n+fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    pat: Gc<ast::Pat>,\n+                                    val: ValueRef,\n+                                    binding_mode: IrrefutablePatternBindingMode,\n+                                    cleanup_scope: cleanup::ScopeId)\n+                                    -> Block<'blk, 'tcx> {\n     /*!\n      * A simple version of the pattern matching code that only handles\n      * irrefutable patterns. This is used in let/argument patterns,"}, {"sha": "e62e3563a0a2ca3c0f85c1eec3f6b325d1e4a3fc", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=f7a997be05e364248521ee4d11ab57fcb2e99a40", "patch": "@@ -143,7 +143,7 @@ pub struct Struct {\n  * these, for places in trans where the `ty::t` isn't directly\n  * available.\n  */\n-pub fn represent_node(bcx: &Block, node: ast::NodeId) -> Rc<Repr> {\n+pub fn represent_node(bcx: Block, node: ast::NodeId) -> Rc<Repr> {\n     represent_type(bcx.ccx(), node_id_type(bcx, node))\n }\n \n@@ -574,7 +574,7 @@ fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool, dst: bool) -> V\n  *\n  * This should ideally be less tightly tied to `_match`.\n  */\n-pub fn trans_switch(bcx: &Block, r: &Repr, scrutinee: ValueRef)\n+pub fn trans_switch(bcx: Block, r: &Repr, scrutinee: ValueRef)\n     -> (_match::BranchKind, Option<ValueRef>) {\n     match *r {\n         CEnum(..) | General(..) |\n@@ -590,7 +590,7 @@ pub fn trans_switch(bcx: &Block, r: &Repr, scrutinee: ValueRef)\n \n \n /// Obtain the actual discriminant of a value.\n-pub fn trans_get_discr(bcx: &Block, r: &Repr, scrutinee: ValueRef, cast_to: Option<Type>)\n+pub fn trans_get_discr(bcx: Block, r: &Repr, scrutinee: ValueRef, cast_to: Option<Type>)\n     -> ValueRef {\n     let signed;\n     let val;\n@@ -625,7 +625,7 @@ pub fn trans_get_discr(bcx: &Block, r: &Repr, scrutinee: ValueRef, cast_to: Opti\n     }\n }\n \n-fn struct_wrapped_nullable_bitdiscr(bcx: &Block, nndiscr: Disr, ptrfield: PointerField,\n+fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: Disr, ptrfield: PointerField,\n                                     scrutinee: ValueRef) -> ValueRef {\n     let llptrptr = match ptrfield {\n         ThinPointer(field) => GEPi(bcx, scrutinee, [0, field]),\n@@ -637,7 +637,7 @@ fn struct_wrapped_nullable_bitdiscr(bcx: &Block, nndiscr: Disr, ptrfield: Pointe\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: &Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n+fn load_discr(bcx: Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n     -> ValueRef {\n     let llty = ll_inttype(bcx.ccx(), ity);\n     assert_eq!(val_ty(ptr), llty.ptr_to());\n@@ -666,8 +666,8 @@ fn load_discr(bcx: &Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n  *\n  * This should ideally be less tightly tied to `_match`.\n  */\n-pub fn trans_case<'a>(bcx: &'a Block<'a>, r: &Repr, discr: Disr)\n-                  -> _match::OptResult<'a> {\n+pub fn trans_case<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr, discr: Disr)\n+                              -> _match::OptResult<'blk, 'tcx> {\n     match *r {\n         CEnum(ity, _, _) => {\n             _match::SingleResult(Result::new(bcx, C_integral(ll_inttype(bcx.ccx(), ity),\n@@ -692,7 +692,7 @@ pub fn trans_case<'a>(bcx: &'a Block<'a>, r: &Repr, discr: Disr)\n  * Set the discriminant for a new value of the given case of the given\n  * representation.\n  */\n-pub fn trans_set_discr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr) {\n+pub fn trans_set_discr(bcx: Block, r: &Repr, val: ValueRef, discr: Disr) {\n     match *r {\n         CEnum(ity, min, max) => {\n             assert_discr_in_range(ity, min, max, discr);\n@@ -770,7 +770,7 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n }\n \n /// Access a field, at a point when the value's case is known.\n-pub fn trans_field_ptr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr,\n+pub fn trans_field_ptr(bcx: Block, r: &Repr, val: ValueRef, discr: Disr,\n                        ix: uint) -> ValueRef {\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n@@ -809,7 +809,7 @@ pub fn trans_field_ptr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr,\n     }\n }\n \n-pub fn struct_field_ptr(bcx: &Block, st: &Struct, val: ValueRef,\n+pub fn struct_field_ptr(bcx: Block, st: &Struct, val: ValueRef,\n                         ix: uint, needs_cast: bool) -> ValueRef {\n     let val = if needs_cast {\n         let ccx = bcx.ccx();\n@@ -823,10 +823,10 @@ pub fn struct_field_ptr(bcx: &Block, st: &Struct, val: ValueRef,\n     GEPi(bcx, val, [0, ix])\n }\n \n-pub fn fold_variants<'r, 'b>(\n-    bcx: &'b Block<'b>, r: &Repr, value: ValueRef,\n-    f: |&'b Block<'b>, &Struct, ValueRef|: 'r -> &'b Block<'b>\n-) -> &'b Block<'b> {\n+pub fn fold_variants<'blk, 'tcx>(\n+        bcx: Block<'blk, 'tcx>, r: &Repr, value: ValueRef,\n+        f: |Block<'blk, 'tcx>, &Struct, ValueRef| -> Block<'blk, 'tcx>)\n+        -> Block<'blk, 'tcx> {\n     let fcx = bcx.fcx;\n     match *r {\n         Univariant(ref st, _) => {\n@@ -864,8 +864,8 @@ pub fn fold_variants<'r, 'b>(\n }\n \n /// Access the struct drop flag, if present.\n-pub fn trans_drop_flag_ptr<'b>(mut bcx: &'b Block<'b>, r: &Repr,\n-                               val: ValueRef) -> datum::DatumBlock<'b, datum::Expr> {\n+pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr, val: ValueRef)\n+                                       -> datum::DatumBlock<'blk, 'tcx, datum::Expr> {\n     let ptr_ty = ty::mk_imm_ptr(bcx.tcx(), ty::mk_bool());\n     match *r {\n         Univariant(ref st, true) => {"}, {"sha": "7fb692c270ee3dd1b51ef20ea012a79d13448ce5", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=f7a997be05e364248521ee4d11ab57fcb2e99a40", "patch": "@@ -27,8 +27,8 @@ use std::string::String;\n use syntax::ast;\n \n // Take an inline assembly expression and splat it out via LLVM\n-pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n-                        -> &'a Block<'a> {\n+pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n+                                    -> Block<'blk, 'tcx> {\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n     let mut constraints = Vec::new();"}, {"sha": "dc2aa16eb728494a612c869615a18043e3fc099b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 122, "deletions": 134, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f7a997be05e364248521ee4d11ab57fcb2e99a40", "patch": "@@ -344,15 +344,15 @@ pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n // Returns a pointer to the body for the box. The box may be an opaque\n // box. The result will be casted to the type of body_t, if it is statically\n // known.\n-pub fn at_box_body(bcx: &Block, body_t: ty::t, boxptr: ValueRef) -> ValueRef {\n+pub fn at_box_body(bcx: Block, body_t: ty::t, boxptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"at_box_body\");\n     let ccx = bcx.ccx();\n     let ty = Type::at_box(ccx, type_of(ccx, body_t));\n     let boxptr = PointerCast(bcx, boxptr, ty.ptr_to());\n     GEPi(bcx, boxptr, [0u, abi::box_field_body])\n }\n \n-fn require_alloc_fn(bcx: &Block, info_ty: ty::t, it: LangItem) -> ast::DefId {\n+fn require_alloc_fn(bcx: Block, info_ty: ty::t, it: LangItem) -> ast::DefId {\n     match bcx.tcx().lang_items.require(it) {\n         Ok(id) => id,\n         Err(s) => {\n@@ -366,12 +366,12 @@ fn require_alloc_fn(bcx: &Block, info_ty: ty::t, it: LangItem) -> ast::DefId {\n // The following malloc_raw_dyn* functions allocate a box to contain\n // a given type, but with a potentially dynamic size.\n \n-pub fn malloc_raw_dyn<'a>(bcx: &'a Block<'a>,\n-                          llty_ptr: Type,\n-                          info_ty: ty::t,\n-                          size: ValueRef,\n-                          align: ValueRef)\n-                          -> Result<'a> {\n+pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                  llty_ptr: Type,\n+                                  info_ty: ty::t,\n+                                  size: ValueRef,\n+                                  align: ValueRef)\n+                                  -> Result<'blk, 'tcx> {\n     let _icx = push_ctxt(\"malloc_raw_exchange\");\n \n     // Allocate space:\n@@ -383,9 +383,9 @@ pub fn malloc_raw_dyn<'a>(bcx: &'a Block<'a>,\n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n \n-pub fn malloc_raw_dyn_proc<'a>(\n-                      bcx: &'a Block<'a>,\n-                      t: ty::t, alloc_fn: LangItem) -> Result<'a> {\n+pub fn malloc_raw_dyn_proc<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                       t: ty::t, alloc_fn: LangItem)\n+                                       -> Result<'blk, 'tcx> {\n     let _icx = push_ctxt(\"malloc_raw_dyn_proc\");\n     let ccx = bcx.ccx();\n \n@@ -414,12 +414,11 @@ pub fn malloc_raw_dyn_proc<'a>(\n }\n \n \n-pub fn malloc_raw_dyn_managed<'a>(\n-                      bcx: &'a Block<'a>,\n-                      t: ty::t,\n-                      alloc_fn: LangItem,\n-                      size: ValueRef)\n-                      -> Result<'a> {\n+pub fn malloc_raw_dyn_managed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                          t: ty::t,\n+                                          alloc_fn: LangItem,\n+                                          size: ValueRef)\n+                                          -> Result<'blk, 'tcx> {\n     let _icx = push_ctxt(\"malloc_raw_dyn_managed\");\n     let ccx = bcx.ccx();\n \n@@ -585,13 +584,12 @@ pub fn maybe_name_value(cx: &CrateContext, v: ValueRef, s: &str) {\n // Used only for creating scalar comparison glue.\n pub enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n \n-pub fn compare_scalar_types<'a>(\n-                            cx: &'a Block<'a>,\n-                            lhs: ValueRef,\n-                            rhs: ValueRef,\n-                            t: ty::t,\n-                            op: ast::BinOp)\n-                            -> Result<'a> {\n+pub fn compare_scalar_types<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                        lhs: ValueRef,\n+                                        rhs: ValueRef,\n+                                        t: ty::t,\n+                                        op: ast::BinOp)\n+                                        -> Result<'blk, 'tcx> {\n     let f = |a| Result::new(cx, compare_scalar_values(cx, lhs, rhs, a, op));\n \n     match ty::get(t).sty {\n@@ -607,15 +605,14 @@ pub fn compare_scalar_types<'a>(\n \n \n // A helper function to do the actual comparison of scalar values.\n-pub fn compare_scalar_values<'a>(\n-                             cx: &'a Block<'a>,\n-                             lhs: ValueRef,\n-                             rhs: ValueRef,\n-                             nt: scalar_type,\n-                             op: ast::BinOp)\n-                             -> ValueRef {\n+pub fn compare_scalar_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                         lhs: ValueRef,\n+                                         rhs: ValueRef,\n+                                         nt: scalar_type,\n+                                         op: ast::BinOp)\n+                                         -> ValueRef {\n     let _icx = push_ctxt(\"compare_scalar_values\");\n-    fn die(cx: &Block) -> ! {\n+    fn die(cx: Block) -> ! {\n         cx.sess().bug(\"compare_scalar_values: must be a comparison operator\");\n     }\n     match nt {\n@@ -669,7 +666,7 @@ pub fn compare_scalar_values<'a>(\n }\n \n pub fn compare_simd_types(\n-                    cx: &Block,\n+                    cx: Block,\n                     lhs: ValueRef,\n                     rhs: ValueRef,\n                     t: ty::t,\n@@ -706,28 +703,24 @@ pub fn compare_simd_types(\n     }\n }\n \n-pub type val_and_ty_fn<'r,'b> =\n-    |&'b Block<'b>, ValueRef, ty::t|: 'r -> &'b Block<'b>;\n+pub type val_and_ty_fn<'a, 'blk, 'tcx> =\n+    |Block<'blk, 'tcx>, ValueRef, ty::t|: 'a -> Block<'blk, 'tcx>;\n \n // Iterates through the elements of a structural type.\n-pub fn iter_structural_ty<'r,\n-                          'b>(\n-                          cx: &'b Block<'b>,\n-                          av: ValueRef,\n-                          t: ty::t,\n-                          f: val_and_ty_fn<'r,'b>)\n-                          -> &'b Block<'b> {\n+pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                          av: ValueRef,\n+                                          t: ty::t,\n+                                          f: val_and_ty_fn<'a, 'blk, 'tcx>)\n+                                          -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"iter_structural_ty\");\n \n-    fn iter_variant<'r,\n-                    'b>(\n-                    cx: &'b Block<'b>,\n-                    repr: &adt::Repr,\n-                    av: ValueRef,\n-                    variant: &ty::VariantInfo,\n-                    substs: &subst::Substs,\n-                    f: val_and_ty_fn<'r,'b>)\n-                    -> &'b Block<'b> {\n+    fn iter_variant<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                    repr: &adt::Repr,\n+                                    av: ValueRef,\n+                                    variant: &ty::VariantInfo,\n+                                    substs: &subst::Substs,\n+                                    f: val_and_ty_fn<'a, 'blk, 'tcx>)\n+                                    -> Block<'blk, 'tcx> {\n         let _icx = push_ctxt(\"iter_variant\");\n         let tcx = cx.tcx();\n         let mut cx = cx;\n@@ -847,8 +840,7 @@ pub fn iter_structural_ty<'r,\n     return cx;\n }\n \n-pub fn cast_shift_expr_rhs<'a>(\n-                           cx: &'a Block<'a>,\n+pub fn cast_shift_expr_rhs(cx: Block,\n                            op: ast::BinOp,\n                            lhs: ValueRef,\n                            rhs: ValueRef)\n@@ -895,14 +887,14 @@ pub fn cast_shift_rhs(op: ast::BinOp,\n     }\n }\n \n-pub fn fail_if_zero_or_overflows<'a>(\n-                    cx: &'a Block<'a>,\n-                    span: Span,\n-                    divrem: ast::BinOp,\n-                    lhs: ValueRef,\n-                    rhs: ValueRef,\n-                    rhs_t: ty::t)\n-                    -> &'a Block<'a> {\n+pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n+                                cx: Block<'blk, 'tcx>,\n+                                span: Span,\n+                                divrem: ast::BinOp,\n+                                lhs: ValueRef,\n+                                rhs: ValueRef,\n+                                rhs_t: ty::t)\n+                                -> Block<'blk, 'tcx> {\n     let (zero_text, overflow_text) = if divrem == ast::BiDiv {\n         (\"attempted to divide by zero\",\n          \"attempted to divide with overflow\")\n@@ -999,16 +991,15 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n     }\n }\n \n-pub fn invoke<'a>(\n-              bcx: &'a Block<'a>,\n-              llfn: ValueRef,\n-              llargs: Vec<ValueRef> ,\n-              fn_ty: ty::t,\n-              call_info: Option<NodeInfo>,\n-              // FIXME(15064) is_lang_item is a horrible hack, please remove it\n-              // at the soonest opportunity.\n-              is_lang_item: bool)\n-              -> (ValueRef, &'a Block<'a>) {\n+pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                          llfn: ValueRef,\n+                          llargs: Vec<ValueRef> ,\n+                          fn_ty: ty::t,\n+                          call_info: Option<NodeInfo>,\n+                          // FIXME(15064) is_lang_item is a horrible hack, please remove it\n+                          // at the soonest opportunity.\n+                          is_lang_item: bool)\n+                          -> (ValueRef, Block<'blk, 'tcx>) {\n     let _icx = push_ctxt(\"invoke_\");\n     if bcx.unreachable.get() {\n         return (C_null(Type::i8(bcx.ccx())), bcx);\n@@ -1067,7 +1058,7 @@ pub fn invoke<'a>(\n     }\n }\n \n-pub fn need_invoke(bcx: &Block) -> bool {\n+pub fn need_invoke(bcx: Block) -> bool {\n     if bcx.sess().no_landing_pads() {\n         return false;\n     }\n@@ -1080,13 +1071,13 @@ pub fn need_invoke(bcx: &Block) -> bool {\n     bcx.fcx.needs_invoke()\n }\n \n-pub fn load_if_immediate(cx: &Block, v: ValueRef, t: ty::t) -> ValueRef {\n+pub fn load_if_immediate(cx: Block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = push_ctxt(\"load_if_immediate\");\n     if type_is_immediate(cx.ccx(), t) { return load_ty(cx, v, t); }\n     return v;\n }\n \n-pub fn load_ty(cx: &Block, ptr: ValueRef, t: ty::t) -> ValueRef {\n+pub fn load_ty(cx: Block, ptr: ValueRef, t: ty::t) -> ValueRef {\n     /*!\n      * Helper for loading values from memory. Does the necessary conversion if\n      * the in-memory type differs from the type used for SSA values. Also\n@@ -1106,7 +1097,7 @@ pub fn load_ty(cx: &Block, ptr: ValueRef, t: ty::t) -> ValueRef {\n     }\n }\n \n-pub fn store_ty(cx: &Block, v: ValueRef, dst: ValueRef, t: ty::t) {\n+pub fn store_ty(cx: Block, v: ValueRef, dst: ValueRef, t: ty::t) {\n     /*!\n      * Helper for storing values in memory. Does the necessary conversion if\n      * the in-memory type differs from the type used for SSA values.\n@@ -1118,33 +1109,31 @@ pub fn store_ty(cx: &Block, v: ValueRef, dst: ValueRef, t: ty::t) {\n     };\n }\n \n-pub fn ignore_lhs(_bcx: &Block, local: &ast::Local) -> bool {\n+pub fn ignore_lhs(_bcx: Block, local: &ast::Local) -> bool {\n     match local.pat.node {\n         ast::PatWild(ast::PatWildSingle) => true, _ => false\n     }\n }\n \n-pub fn init_local<'a>(bcx: &'a Block<'a>, local: &ast::Local)\n-                  -> &'a Block<'a> {\n+pub fn init_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, local: &ast::Local)\n+                              -> Block<'blk, 'tcx> {\n     debug!(\"init_local(bcx={}, local.id={:?})\", bcx.to_str(), local.id);\n     let _indenter = indenter();\n     let _icx = push_ctxt(\"init_local\");\n     _match::store_local(bcx, local)\n }\n \n-pub fn raw_block<'a>(\n-                 fcx: &'a FunctionContext<'a>,\n-                 is_lpad: bool,\n-                 llbb: BasicBlockRef)\n-                 -> &'a Block<'a> {\n-    common::Block::new(llbb, is_lpad, None, fcx)\n+pub fn raw_block<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n+                             is_lpad: bool,\n+                             llbb: BasicBlockRef)\n+                             -> Block<'blk, 'tcx> {\n+    common::BlockS::new(llbb, is_lpad, None, fcx)\n }\n \n-pub fn with_cond<'a>(\n-                 bcx: &'a Block<'a>,\n-                 val: ValueRef,\n-                 f: |&'a Block<'a>| -> &'a Block<'a>)\n-                 -> &'a Block<'a> {\n+pub fn with_cond<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             val: ValueRef,\n+                             f: |Block<'blk, 'tcx>| -> Block<'blk, 'tcx>)\n+                             -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"with_cond\");\n     let fcx = bcx.fcx;\n     let next_cx = fcx.new_temp_block(\"next\");\n@@ -1157,7 +1146,7 @@ pub fn with_cond<'a>(\n     next_cx\n }\n \n-pub fn call_lifetime_start(cx: &Block, ptr: ValueRef) {\n+pub fn call_lifetime_start(cx: Block, ptr: ValueRef) {\n     if cx.sess().opts.optimize == config::No {\n         return;\n     }\n@@ -1171,7 +1160,7 @@ pub fn call_lifetime_start(cx: &Block, ptr: ValueRef) {\n     Call(cx, lifetime_start, [llsize, ptr], None);\n }\n \n-pub fn call_lifetime_end(cx: &Block, ptr: ValueRef) {\n+pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n     if cx.sess().opts.optimize == config::No {\n         return;\n     }\n@@ -1185,7 +1174,7 @@ pub fn call_lifetime_end(cx: &Block, ptr: ValueRef) {\n     Call(cx, lifetime_end, [llsize, ptr], None);\n }\n \n-pub fn call_memcpy(cx: &Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n+pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n     let key = match ccx.sess().targ_cfg.arch {\n@@ -1201,7 +1190,7 @@ pub fn call_memcpy(cx: &Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef,\n     Call(cx, memcpy, [dst_ptr, src_ptr, size, align, volatile], None);\n }\n \n-pub fn memcpy_ty(bcx: &Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n+pub fn memcpy_ty(bcx: Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n     let _icx = push_ctxt(\"memcpy_ty\");\n     let ccx = bcx.ccx();\n     if ty::type_is_structural(t) {\n@@ -1214,7 +1203,7 @@ pub fn memcpy_ty(bcx: &Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n     }\n }\n \n-pub fn zero_mem(cx: &Block, llptr: ValueRef, t: ty::t) {\n+pub fn zero_mem(cx: Block, llptr: ValueRef, t: ty::t) {\n     if cx.unreachable.get() { return; }\n     let _icx = push_ctxt(\"zero_mem\");\n     let bcx = cx;\n@@ -1246,7 +1235,7 @@ fn memzero(b: &Builder, llptr: ValueRef, ty: ty::t) {\n     b.call(llintrinsicfn, [llptr, llzeroval, size, align, volatile], None);\n }\n \n-pub fn alloc_ty(bcx: &Block, t: ty::t, name: &str) -> ValueRef {\n+pub fn alloc_ty(bcx: Block, t: ty::t, name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let ty = type_of::type_of(ccx, t);\n@@ -1255,13 +1244,13 @@ pub fn alloc_ty(bcx: &Block, t: ty::t, name: &str) -> ValueRef {\n     return val;\n }\n \n-pub fn alloca(cx: &Block, ty: Type, name: &str) -> ValueRef {\n+pub fn alloca(cx: Block, ty: Type, name: &str) -> ValueRef {\n     let p = alloca_no_lifetime(cx, ty, name);\n     call_lifetime_start(cx, p);\n     p\n }\n \n-pub fn alloca_no_lifetime(cx: &Block, ty: Type, name: &str) -> ValueRef {\n+pub fn alloca_no_lifetime(cx: Block, ty: Type, name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"alloca\");\n     if cx.unreachable.get() {\n         unsafe {\n@@ -1272,7 +1261,7 @@ pub fn alloca_no_lifetime(cx: &Block, ty: Type, name: &str) -> ValueRef {\n     Alloca(cx, ty, name)\n }\n \n-pub fn alloca_zeroed(cx: &Block, ty: ty::t, name: &str) -> ValueRef {\n+pub fn alloca_zeroed(cx: Block, ty: ty::t, name: &str) -> ValueRef {\n     let llty = type_of::type_of(cx.ccx(), ty);\n     if cx.unreachable.get() {\n         unsafe {\n@@ -1286,7 +1275,7 @@ pub fn alloca_zeroed(cx: &Block, ty: ty::t, name: &str) -> ValueRef {\n     p\n }\n \n-pub fn arrayalloca(cx: &Block, ty: Type, v: ValueRef) -> ValueRef {\n+pub fn arrayalloca(cx: Block, ty: Type, v: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"arrayalloca\");\n     if cx.unreachable.get() {\n         unsafe {\n@@ -1441,15 +1430,15 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n //\n // Be warned! You must call `init_function` before doing anything with the\n // returned function context.\n-pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext,\n-                       llfndecl: ValueRef,\n-                       id: ast::NodeId,\n-                       has_env: bool,\n-                       output_type: ty::t,\n-                       param_substs: &'a param_substs,\n-                       sp: Option<Span>,\n-                       block_arena: &'a TypedArena<Block<'a>>)\n-                       -> FunctionContext<'a> {\n+pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n+                             llfndecl: ValueRef,\n+                             id: ast::NodeId,\n+                             has_env: bool,\n+                             output_type: ty::t,\n+                             param_substs: &'a param_substs,\n+                             sp: Option<Span>,\n+                             block_arena: &'a TypedArena<common::BlockS<'a, 'tcx>>)\n+                             -> FunctionContext<'a, 'tcx> {\n     param_substs.validate();\n \n     debug!(\"new_fn_ctxt(path={}, id={}, param_substs={})\",\n@@ -1495,9 +1484,9 @@ pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext,\n \n /// Performs setup on a newly created function, creating the entry scope block\n /// and allocating space for the return pointer.\n-pub fn init_function<'a>(fcx: &'a FunctionContext<'a>,\n-                         skip_retptr: bool,\n-                         output_type: ty::t) -> &'a Block<'a> {\n+pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n+                               skip_retptr: bool,\n+                               output_type: ty::t) -> Block<'a, 'tcx> {\n     let entry_bcx = fcx.new_temp_block(\"entry-block\");\n \n     // Use a dummy instruction as the insertion point for all allocas.\n@@ -1565,9 +1554,8 @@ pub fn create_datums_for_fn_args(fcx: &FunctionContext,\n /// datums.\n ///\n /// FIXME(pcwalton): Reduce the amount of code bloat this is responsible for.\n-fn create_datums_for_fn_args_under_call_abi<\n-        'a>(\n-        mut bcx: &'a Block<'a>,\n+fn create_datums_for_fn_args_under_call_abi(\n+        mut bcx: Block,\n         arg_scope: cleanup::CustomScopeIndex,\n         arg_tys: &[ty::t])\n         -> Vec<RvalueDatum> {\n@@ -1633,12 +1621,12 @@ fn create_datums_for_fn_args_under_call_abi<\n     result\n }\n \n-fn copy_args_to_allocas<'a>(fcx: &FunctionContext<'a>,\n-                            arg_scope: cleanup::CustomScopeIndex,\n-                            bcx: &'a Block<'a>,\n-                            args: &[ast::Arg],\n-                            arg_datums: Vec<RvalueDatum> )\n-                            -> &'a Block<'a> {\n+fn copy_args_to_allocas<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n+                                    arg_scope: cleanup::CustomScopeIndex,\n+                                    bcx: Block<'blk, 'tcx>,\n+                                    args: &[ast::Arg],\n+                                    arg_datums: Vec<RvalueDatum> )\n+                                    -> Block<'blk, 'tcx> {\n     debug!(\"copy_args_to_allocas\");\n \n     let _icx = push_ctxt(\"copy_args_to_allocas\");\n@@ -1665,13 +1653,13 @@ fn copy_args_to_allocas<'a>(fcx: &FunctionContext<'a>,\n     bcx\n }\n \n-fn copy_unboxed_closure_args_to_allocas<'a>(\n-                                        mut bcx: &'a Block<'a>,\n+fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n+                                        mut bcx: Block<'blk, 'tcx>,\n                                         arg_scope: cleanup::CustomScopeIndex,\n                                         args: &[ast::Arg],\n                                         arg_datums: Vec<RvalueDatum>,\n                                         monomorphized_arg_types: &[ty::t])\n-                                        -> &'a Block<'a> {\n+                                        -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"copy_unboxed_closure_args_to_allocas\");\n     let arg_scope_id = cleanup::CustomScope(arg_scope);\n \n@@ -1721,9 +1709,9 @@ fn copy_unboxed_closure_args_to_allocas<'a>(\n \n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n-pub fn finish_fn<'a>(fcx: &'a FunctionContext<'a>,\n-                     last_bcx: &'a Block<'a>,\n-                     retty: ty::t) {\n+pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n+                             last_bcx: Block<'blk, 'tcx>,\n+                             retty: ty::t) {\n     let _icx = push_ctxt(\"finish_fn\");\n \n     // This shouldn't need to recompute the return type,\n@@ -1745,7 +1733,7 @@ pub fn finish_fn<'a>(fcx: &'a FunctionContext<'a>,\n }\n \n // Builds the return block for a function.\n-pub fn build_return_block(fcx: &FunctionContext, ret_cx: &Block, retty: ty::t) {\n+pub fn build_return_block(fcx: &FunctionContext, ret_cx: Block, retty: ty::t) {\n     if fcx.llretslotptr.get().is_none() ||\n        (!fcx.needs_ret_allocas && fcx.caller_expects_out_pointer) {\n         return RetVoid(ret_cx);\n@@ -1814,8 +1802,8 @@ pub fn trans_closure(ccx: &CrateContext,\n                      abi: Abi,\n                      has_env: bool,\n                      is_unboxed_closure: IsUnboxedClosureFlag,\n-                     maybe_load_env: <'a>|&'a Block<'a>, ScopeId|\n-                                         -> &'a Block<'a>) {\n+                     maybe_load_env: <'blk, 'tcx> |Block<'blk, 'tcx>, ScopeId|\n+                                                  -> Block<'blk, 'tcx>) {\n     ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n     let _icx = push_ctxt(\"trans_closure\");\n@@ -1981,11 +1969,11 @@ pub fn trans_enum_variant(ccx: &CrateContext,\n         llfndecl);\n }\n \n-pub fn trans_named_tuple_constructor<'a>(mut bcx: &'a Block<'a>,\n-                                         ctor_ty: ty::t,\n-                                         disr: ty::Disr,\n-                                         args: callee::CallArgs,\n-                                         dest: expr::Dest) -> Result<'a> {\n+pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                                 ctor_ty: ty::t,\n+                                                 disr: ty::Disr,\n+                                                 args: callee::CallArgs,\n+                                                 dest: expr::Dest) -> Result<'blk, 'tcx> {\n \n     let ccx = bcx.fcx.ccx;\n     let tcx = ccx.tcx();"}, {"sha": "e30f9af02c6a6ce334577aff000ab4b09d9b1e88", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 108, "deletions": 108, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=f7a997be05e364248521ee4d11ab57fcb2e99a40", "patch": "@@ -23,18 +23,18 @@ use middle::trans::type_::Type;\n \n use libc::{c_uint, c_ulonglong, c_char};\n \n-pub fn terminate(cx: &Block, _: &str) {\n+pub fn terminate(cx: Block, _: &str) {\n     debug!(\"terminate({})\", cx.to_str());\n     cx.terminated.set(true);\n }\n \n-pub fn check_not_terminated(cx: &Block) {\n+pub fn check_not_terminated(cx: Block) {\n     if cx.terminated.get() {\n         fail!(\"already terminated!\");\n     }\n }\n \n-pub fn B<'b, 'tcx>(cx: &'b Block<'b, 'tcx>) -> Builder<'b, 'tcx> {\n+pub fn B<'blk, 'tcx>(cx: Block<'blk, 'tcx>) -> Builder<'blk, 'tcx> {\n     let b = cx.fcx.ccx.builder();\n     b.position_at_end(cx.llbb);\n     b\n@@ -48,35 +48,35 @@ pub fn B<'b, 'tcx>(cx: &'b Block<'b, 'tcx>) -> Builder<'b, 'tcx> {\n // for (fail/break/return statements, call to diverging functions, etc), and\n // further instructions to the block should simply be ignored.\n \n-pub fn RetVoid(cx: &Block) {\n+pub fn RetVoid(cx: Block) {\n     if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"RetVoid\");\n     B(cx).ret_void();\n }\n \n-pub fn Ret(cx: &Block, v: ValueRef) {\n+pub fn Ret(cx: Block, v: ValueRef) {\n     if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"Ret\");\n     B(cx).ret(v);\n }\n \n-pub fn AggregateRet(cx: &Block, ret_vals: &[ValueRef]) {\n+pub fn AggregateRet(cx: Block, ret_vals: &[ValueRef]) {\n     if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"AggregateRet\");\n     B(cx).aggregate_ret(ret_vals);\n }\n \n-pub fn Br(cx: &Block, dest: BasicBlockRef) {\n+pub fn Br(cx: Block, dest: BasicBlockRef) {\n     if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"Br\");\n     B(cx).br(dest);\n }\n \n-pub fn CondBr(cx: &Block,\n+pub fn CondBr(cx: Block,\n               if_: ValueRef,\n               then: BasicBlockRef,\n               else_: BasicBlockRef) {\n@@ -86,7 +86,7 @@ pub fn CondBr(cx: &Block,\n     B(cx).cond_br(if_, then, else_);\n }\n \n-pub fn Switch(cx: &Block, v: ValueRef, else_: BasicBlockRef, num_cases: uint)\n+pub fn Switch(cx: Block, v: ValueRef, else_: BasicBlockRef, num_cases: uint)\n     -> ValueRef {\n     if cx.unreachable.get() { return _Undef(v); }\n     check_not_terminated(cx);\n@@ -101,14 +101,14 @@ pub fn AddCase(s: ValueRef, on_val: ValueRef, dest: BasicBlockRef) {\n     }\n }\n \n-pub fn IndirectBr(cx: &Block, addr: ValueRef, num_dests: uint) {\n+pub fn IndirectBr(cx: Block, addr: ValueRef, num_dests: uint) {\n     if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"IndirectBr\");\n     B(cx).indirect_br(addr, num_dests);\n }\n \n-pub fn Invoke(cx: &Block,\n+pub fn Invoke(cx: Block,\n               fn_: ValueRef,\n               args: &[ValueRef],\n               then: BasicBlockRef,\n@@ -126,7 +126,7 @@ pub fn Invoke(cx: &Block,\n     B(cx).invoke(fn_, args, then, catch, attributes)\n }\n \n-pub fn Unreachable(cx: &Block) {\n+pub fn Unreachable(cx: Block) {\n     if cx.unreachable.get() {\n         return\n     }\n@@ -143,163 +143,163 @@ pub fn _Undef(val: ValueRef) -> ValueRef {\n }\n \n /* Arithmetic */\n-pub fn Add(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn Add(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).add(lhs, rhs)\n }\n \n-pub fn NSWAdd(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn NSWAdd(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).nswadd(lhs, rhs)\n }\n \n-pub fn NUWAdd(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn NUWAdd(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).nuwadd(lhs, rhs)\n }\n \n-pub fn FAdd(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn FAdd(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).fadd(lhs, rhs)\n }\n \n-pub fn Sub(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn Sub(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).sub(lhs, rhs)\n }\n \n-pub fn NSWSub(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn NSWSub(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).nswsub(lhs, rhs)\n }\n \n-pub fn NUWSub(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn NUWSub(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).nuwsub(lhs, rhs)\n }\n \n-pub fn FSub(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn FSub(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).fsub(lhs, rhs)\n }\n \n-pub fn Mul(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn Mul(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).mul(lhs, rhs)\n }\n \n-pub fn NSWMul(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn NSWMul(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).nswmul(lhs, rhs)\n }\n \n-pub fn NUWMul(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn NUWMul(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).nuwmul(lhs, rhs)\n }\n \n-pub fn FMul(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn FMul(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).fmul(lhs, rhs)\n }\n \n-pub fn UDiv(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn UDiv(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).udiv(lhs, rhs)\n }\n \n-pub fn SDiv(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn SDiv(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).sdiv(lhs, rhs)\n }\n \n-pub fn ExactSDiv(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn ExactSDiv(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).exactsdiv(lhs, rhs)\n }\n \n-pub fn FDiv(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn FDiv(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).fdiv(lhs, rhs)\n }\n \n-pub fn URem(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn URem(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).urem(lhs, rhs)\n }\n \n-pub fn SRem(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn SRem(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).srem(lhs, rhs)\n }\n \n-pub fn FRem(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn FRem(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).frem(lhs, rhs)\n }\n \n-pub fn Shl(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn Shl(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).shl(lhs, rhs)\n }\n \n-pub fn LShr(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn LShr(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).lshr(lhs, rhs)\n }\n \n-pub fn AShr(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn AShr(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).ashr(lhs, rhs)\n }\n \n-pub fn And(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn And(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).and(lhs, rhs)\n }\n \n-pub fn Or(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn Or(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).or(lhs, rhs)\n }\n \n-pub fn Xor(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn Xor(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).xor(lhs, rhs)\n }\n \n-pub fn BinOp(cx: &Block, op: Opcode, lhs: ValueRef, rhs: ValueRef)\n+pub fn BinOp(cx: Block, op: Opcode, lhs: ValueRef, rhs: ValueRef)\n           -> ValueRef {\n     if cx.unreachable.get() { return _Undef(lhs); }\n     B(cx).binop(op, lhs, rhs)\n }\n \n-pub fn Neg(cx: &Block, v: ValueRef) -> ValueRef {\n+pub fn Neg(cx: Block, v: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(v); }\n     B(cx).neg(v)\n }\n \n-pub fn NSWNeg(cx: &Block, v: ValueRef) -> ValueRef {\n+pub fn NSWNeg(cx: Block, v: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(v); }\n     B(cx).nswneg(v)\n }\n \n-pub fn NUWNeg(cx: &Block, v: ValueRef) -> ValueRef {\n+pub fn NUWNeg(cx: Block, v: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(v); }\n     B(cx).nuwneg(v)\n }\n-pub fn FNeg(cx: &Block, v: ValueRef) -> ValueRef {\n+pub fn FNeg(cx: Block, v: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(v); }\n     B(cx).fneg(v)\n }\n \n-pub fn Not(cx: &Block, v: ValueRef) -> ValueRef {\n+pub fn Not(cx: Block, v: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(v); }\n     B(cx).not(v)\n }\n \n /* Memory */\n-pub fn Malloc(cx: &Block, ty: Type) -> ValueRef {\n+pub fn Malloc(cx: Block, ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n@@ -308,7 +308,7 @@ pub fn Malloc(cx: &Block, ty: Type) -> ValueRef {\n     }\n }\n \n-pub fn ArrayMalloc(cx: &Block, ty: Type, val: ValueRef) -> ValueRef {\n+pub fn ArrayMalloc(cx: Block, ty: Type, val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n@@ -317,7 +317,7 @@ pub fn ArrayMalloc(cx: &Block, ty: Type, val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn Alloca(cx: &Block, ty: Type, name: &str) -> ValueRef {\n+pub fn Alloca(cx: Block, ty: Type, name: &str) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.ptr_to().to_ref()); }\n         AllocaFcx(cx.fcx, ty, name)\n@@ -330,7 +330,7 @@ pub fn AllocaFcx(fcx: &FunctionContext, ty: Type, name: &str) -> ValueRef {\n     b.alloca(ty, name)\n }\n \n-pub fn ArrayAlloca(cx: &Block, ty: Type, val: ValueRef) -> ValueRef {\n+pub fn ArrayAlloca(cx: Block, ty: Type, val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.ptr_to().to_ref()); }\n         let b = cx.fcx.ccx.builder();\n@@ -339,12 +339,12 @@ pub fn ArrayAlloca(cx: &Block, ty: Type, val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn Free(cx: &Block, pointer_val: ValueRef) {\n+pub fn Free(cx: Block, pointer_val: ValueRef) {\n     if cx.unreachable.get() { return; }\n     B(cx).free(pointer_val)\n }\n \n-pub fn Load(cx: &Block, pointer_val: ValueRef) -> ValueRef {\n+pub fn Load(cx: Block, pointer_val: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable.get() {\n@@ -360,7 +360,7 @@ pub fn Load(cx: &Block, pointer_val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn VolatileLoad(cx: &Block, pointer_val: ValueRef) -> ValueRef {\n+pub fn VolatileLoad(cx: Block, pointer_val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n@@ -369,7 +369,7 @@ pub fn VolatileLoad(cx: &Block, pointer_val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn AtomicLoad(cx: &Block, pointer_val: ValueRef, order: AtomicOrdering) -> ValueRef {\n+pub fn AtomicLoad(cx: Block, pointer_val: ValueRef, order: AtomicOrdering) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable.get() {\n@@ -380,7 +380,7 @@ pub fn AtomicLoad(cx: &Block, pointer_val: ValueRef, order: AtomicOrdering) -> V\n }\n \n \n-pub fn LoadRangeAssert(cx: &Block, pointer_val: ValueRef, lo: c_ulonglong,\n+pub fn LoadRangeAssert(cx: Block, pointer_val: ValueRef, lo: c_ulonglong,\n                        hi: c_ulonglong, signed: llvm::Bool) -> ValueRef {\n     if cx.unreachable.get() {\n         let ccx = cx.fcx.ccx;\n@@ -398,22 +398,22 @@ pub fn LoadRangeAssert(cx: &Block, pointer_val: ValueRef, lo: c_ulonglong,\n     }\n }\n \n-pub fn Store(cx: &Block, val: ValueRef, ptr: ValueRef) {\n+pub fn Store(cx: Block, val: ValueRef, ptr: ValueRef) {\n     if cx.unreachable.get() { return; }\n     B(cx).store(val, ptr)\n }\n \n-pub fn VolatileStore(cx: &Block, val: ValueRef, ptr: ValueRef) {\n+pub fn VolatileStore(cx: Block, val: ValueRef, ptr: ValueRef) {\n     if cx.unreachable.get() { return; }\n     B(cx).volatile_store(val, ptr)\n }\n \n-pub fn AtomicStore(cx: &Block, val: ValueRef, ptr: ValueRef, order: AtomicOrdering) {\n+pub fn AtomicStore(cx: Block, val: ValueRef, ptr: ValueRef, order: AtomicOrdering) {\n     if cx.unreachable.get() { return; }\n     B(cx).atomic_store(val, ptr, order)\n }\n \n-pub fn GEP(cx: &Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n+pub fn GEP(cx: Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n@@ -425,7 +425,7 @@ pub fn GEP(cx: &Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n // Simple wrapper around GEP that takes an array of ints and wraps them\n // in C_i32()\n #[inline]\n-pub fn GEPi(cx: &Block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n+pub fn GEPi(cx: Block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n@@ -434,7 +434,7 @@ pub fn GEPi(cx: &Block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     }\n }\n \n-pub fn InBoundsGEP(cx: &Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n+pub fn InBoundsGEP(cx: Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n@@ -443,7 +443,7 @@ pub fn InBoundsGEP(cx: &Block, pointer: ValueRef, indices: &[ValueRef]) -> Value\n     }\n }\n \n-pub fn StructGEP(cx: &Block, pointer: ValueRef, idx: uint) -> ValueRef {\n+pub fn StructGEP(cx: Block, pointer: ValueRef, idx: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n@@ -452,7 +452,7 @@ pub fn StructGEP(cx: &Block, pointer: ValueRef, idx: uint) -> ValueRef {\n     }\n }\n \n-pub fn GlobalString(cx: &Block, _str: *const c_char) -> ValueRef {\n+pub fn GlobalString(cx: Block, _str: *const c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n@@ -461,7 +461,7 @@ pub fn GlobalString(cx: &Block, _str: *const c_char) -> ValueRef {\n     }\n }\n \n-pub fn GlobalStringPtr(cx: &Block, _str: *const c_char) -> ValueRef {\n+pub fn GlobalStringPtr(cx: Block, _str: *const c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n@@ -471,112 +471,112 @@ pub fn GlobalStringPtr(cx: &Block, _str: *const c_char) -> ValueRef {\n }\n \n /* Casts */\n-pub fn Trunc(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn Trunc(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).trunc(val, dest_ty)\n     }\n }\n \n-pub fn ZExt(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn ZExt(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).zext(val, dest_ty)\n     }\n }\n \n-pub fn SExt(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn SExt(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).sext(val, dest_ty)\n     }\n }\n \n-pub fn FPToUI(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn FPToUI(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).fptoui(val, dest_ty)\n     }\n }\n \n-pub fn FPToSI(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn FPToSI(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).fptosi(val, dest_ty)\n     }\n }\n \n-pub fn UIToFP(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn UIToFP(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).uitofp(val, dest_ty)\n     }\n }\n \n-pub fn SIToFP(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn SIToFP(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).sitofp(val, dest_ty)\n     }\n }\n \n-pub fn FPTrunc(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn FPTrunc(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).fptrunc(val, dest_ty)\n     }\n }\n \n-pub fn FPExt(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn FPExt(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).fpext(val, dest_ty)\n     }\n }\n \n-pub fn PtrToInt(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn PtrToInt(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).ptrtoint(val, dest_ty)\n     }\n }\n \n-pub fn IntToPtr(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn IntToPtr(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).inttoptr(val, dest_ty)\n     }\n }\n \n-pub fn BitCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn BitCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).bitcast(val, dest_ty)\n     }\n }\n \n-pub fn ZExtOrBitCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn ZExtOrBitCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).zext_or_bitcast(val, dest_ty)\n     }\n }\n \n-pub fn SExtOrBitCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn SExtOrBitCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).sext_or_bitcast(val, dest_ty)\n     }\n }\n \n-pub fn TruncOrBitCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn TruncOrBitCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).trunc_or_bitcast(val, dest_ty)\n     }\n }\n \n-pub fn Cast(cx: &Block, op: Opcode, val: ValueRef, dest_ty: Type,\n+pub fn Cast(cx: Block, op: Opcode, val: ValueRef, dest_ty: Type,\n             _: *const u8)\n      -> ValueRef {\n     unsafe {\n@@ -585,21 +585,21 @@ pub fn Cast(cx: &Block, op: Opcode, val: ValueRef, dest_ty: Type,\n     }\n }\n \n-pub fn PointerCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn PointerCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).pointercast(val, dest_ty)\n     }\n }\n \n-pub fn IntCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn IntCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).intcast(val, dest_ty)\n     }\n }\n \n-pub fn FPCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n+pub fn FPCast(cx: Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n         B(cx).fpcast(val, dest_ty)\n@@ -608,7 +608,7 @@ pub fn FPCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n \n \n /* Comparisons */\n-pub fn ICmp(cx: &Block, op: IntPredicate, lhs: ValueRef, rhs: ValueRef)\n+pub fn ICmp(cx: Block, op: IntPredicate, lhs: ValueRef, rhs: ValueRef)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n@@ -618,7 +618,7 @@ pub fn ICmp(cx: &Block, op: IntPredicate, lhs: ValueRef, rhs: ValueRef)\n     }\n }\n \n-pub fn FCmp(cx: &Block, op: RealPredicate, lhs: ValueRef, rhs: ValueRef)\n+pub fn FCmp(cx: Block, op: RealPredicate, lhs: ValueRef, rhs: ValueRef)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n@@ -629,14 +629,14 @@ pub fn FCmp(cx: &Block, op: RealPredicate, lhs: ValueRef, rhs: ValueRef)\n }\n \n /* Miscellaneous instructions */\n-pub fn EmptyPhi(cx: &Block, ty: Type) -> ValueRef {\n+pub fn EmptyPhi(cx: Block, ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.to_ref()); }\n         B(cx).empty_phi(ty)\n     }\n }\n \n-pub fn Phi(cx: &Block, ty: Type, vals: &[ValueRef],\n+pub fn Phi(cx: Block, ty: Type, vals: &[ValueRef],\n            bbs: &[BasicBlockRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.to_ref()); }\n@@ -651,7 +651,7 @@ pub fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n     }\n }\n \n-pub fn _UndefReturn(cx: &Block, fn_: ValueRef) -> ValueRef {\n+pub fn _UndefReturn(cx: Block, fn_: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         let ty = val_ty(fn_);\n@@ -665,51 +665,51 @@ pub fn _UndefReturn(cx: &Block, fn_: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn add_span_comment(cx: &Block, sp: Span, text: &str) {\n+pub fn add_span_comment(cx: Block, sp: Span, text: &str) {\n     B(cx).add_span_comment(sp, text)\n }\n \n-pub fn add_comment(cx: &Block, text: &str) {\n+pub fn add_comment(cx: Block, text: &str) {\n     B(cx).add_comment(text)\n }\n \n-pub fn InlineAsmCall(cx: &Block, asm: *const c_char, cons: *const c_char,\n+pub fn InlineAsmCall(cx: Block, asm: *const c_char, cons: *const c_char,\n                      inputs: &[ValueRef], output: Type,\n                      volatile: bool, alignstack: bool,\n                      dia: AsmDialect) -> ValueRef {\n     B(cx).inline_asm_call(asm, cons, inputs, output, volatile, alignstack, dia)\n }\n \n-pub fn Call(cx: &Block, fn_: ValueRef, args: &[ValueRef],\n+pub fn Call(cx: Block, fn_: ValueRef, args: &[ValueRef],\n             attributes: Option<AttrBuilder>) -> ValueRef {\n     if cx.unreachable.get() { return _UndefReturn(cx, fn_); }\n     B(cx).call(fn_, args, attributes)\n }\n \n-pub fn CallWithConv(cx: &Block, fn_: ValueRef, args: &[ValueRef], conv: CallConv,\n+pub fn CallWithConv(cx: Block, fn_: ValueRef, args: &[ValueRef], conv: CallConv,\n                     attributes: Option<AttrBuilder>) -> ValueRef {\n     if cx.unreachable.get() { return _UndefReturn(cx, fn_); }\n     B(cx).call_with_conv(fn_, args, conv, attributes)\n }\n \n-pub fn AtomicFence(cx: &Block, order: AtomicOrdering) {\n+pub fn AtomicFence(cx: Block, order: AtomicOrdering) {\n     if cx.unreachable.get() { return; }\n     B(cx).atomic_fence(order)\n }\n \n-pub fn Select(cx: &Block, if_: ValueRef, then: ValueRef, else_: ValueRef) -> ValueRef {\n+pub fn Select(cx: Block, if_: ValueRef, then: ValueRef, else_: ValueRef) -> ValueRef {\n     if cx.unreachable.get() { return _Undef(then); }\n     B(cx).select(if_, then, else_)\n }\n \n-pub fn VAArg(cx: &Block, list: ValueRef, ty: Type) -> ValueRef {\n+pub fn VAArg(cx: Block, list: ValueRef, ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.to_ref()); }\n         B(cx).va_arg(list, ty)\n     }\n }\n \n-pub fn ExtractElement(cx: &Block, vec_val: ValueRef, index: ValueRef) -> ValueRef {\n+pub fn ExtractElement(cx: Block, vec_val: ValueRef, index: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n@@ -718,7 +718,7 @@ pub fn ExtractElement(cx: &Block, vec_val: ValueRef, index: ValueRef) -> ValueRe\n     }\n }\n \n-pub fn InsertElement(cx: &Block, vec_val: ValueRef, elt_val: ValueRef,\n+pub fn InsertElement(cx: Block, vec_val: ValueRef, elt_val: ValueRef,\n                      index: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n@@ -728,7 +728,7 @@ pub fn InsertElement(cx: &Block, vec_val: ValueRef, elt_val: ValueRef,\n     }\n }\n \n-pub fn ShuffleVector(cx: &Block, v1: ValueRef, v2: ValueRef,\n+pub fn ShuffleVector(cx: Block, v1: ValueRef, v2: ValueRef,\n                      mask: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n@@ -738,7 +738,7 @@ pub fn ShuffleVector(cx: &Block, v1: ValueRef, v2: ValueRef,\n     }\n }\n \n-pub fn VectorSplat(cx: &Block, num_elts: uint, elt_val: ValueRef) -> ValueRef {\n+pub fn VectorSplat(cx: Block, num_elts: uint, elt_val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n@@ -747,7 +747,7 @@ pub fn VectorSplat(cx: &Block, num_elts: uint, elt_val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn ExtractValue(cx: &Block, agg_val: ValueRef, index: uint) -> ValueRef {\n+pub fn ExtractValue(cx: Block, agg_val: ValueRef, index: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n@@ -756,7 +756,7 @@ pub fn ExtractValue(cx: &Block, agg_val: ValueRef, index: uint) -> ValueRef {\n     }\n }\n \n-pub fn InsertValue(cx: &Block, agg_val: ValueRef, elt_val: ValueRef, index: uint) -> ValueRef {\n+pub fn InsertValue(cx: Block, agg_val: ValueRef, elt_val: ValueRef, index: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n@@ -765,7 +765,7 @@ pub fn InsertValue(cx: &Block, agg_val: ValueRef, elt_val: ValueRef, index: uint\n     }\n }\n \n-pub fn IsNull(cx: &Block, val: ValueRef) -> ValueRef {\n+pub fn IsNull(cx: Block, val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i1(cx.ccx()).to_ref());\n@@ -774,7 +774,7 @@ pub fn IsNull(cx: &Block, val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn IsNotNull(cx: &Block, val: ValueRef) -> ValueRef {\n+pub fn IsNotNull(cx: Block, val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i1(cx.ccx()).to_ref());\n@@ -783,44 +783,44 @@ pub fn IsNotNull(cx: &Block, val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn PtrDiff(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn PtrDiff(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(ccx.int_type().to_ref()); }\n         B(cx).ptrdiff(lhs, rhs)\n     }\n }\n \n-pub fn Trap(cx: &Block) {\n+pub fn Trap(cx: Block) {\n     if cx.unreachable.get() { return; }\n     B(cx).trap();\n }\n \n-pub fn LandingPad(cx: &Block, ty: Type, pers_fn: ValueRef,\n+pub fn LandingPad(cx: Block, ty: Type, pers_fn: ValueRef,\n                   num_clauses: uint) -> ValueRef {\n     check_not_terminated(cx);\n     assert!(!cx.unreachable.get());\n     B(cx).landing_pad(ty, pers_fn, num_clauses)\n }\n \n-pub fn SetCleanup(cx: &Block, landing_pad: ValueRef) {\n+pub fn SetCleanup(cx: Block, landing_pad: ValueRef) {\n     B(cx).set_cleanup(landing_pad)\n }\n \n-pub fn Resume(cx: &Block, exn: ValueRef) -> ValueRef {\n+pub fn Resume(cx: Block, exn: ValueRef) -> ValueRef {\n     check_not_terminated(cx);\n     terminate(cx, \"Resume\");\n     B(cx).resume(exn)\n }\n \n // Atomic Operations\n-pub fn AtomicCmpXchg(cx: &Block, dst: ValueRef,\n+pub fn AtomicCmpXchg(cx: Block, dst: ValueRef,\n                      cmp: ValueRef, src: ValueRef,\n                      order: AtomicOrdering,\n                      failure_order: AtomicOrdering) -> ValueRef {\n     B(cx).atomic_cmpxchg(dst, cmp, src, order, failure_order)\n }\n-pub fn AtomicRMW(cx: &Block, op: AtomicBinOp,\n+pub fn AtomicRMW(cx: Block, op: AtomicBinOp,\n                  dst: ValueRef, src: ValueRef,\n                  order: AtomicOrdering) -> ValueRef {\n     B(cx).atomic_rmw(op, dst, src, order)"}, {"sha": "5d66ec0a4b936df092a2e9f100fa5e9d664e7c1e", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 66, "deletions": 69, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=f7a997be05e364248521ee4d11ab57fcb2e99a40", "patch": "@@ -80,12 +80,13 @@ pub enum CalleeData {\n     TraitItem(MethodData)\n }\n \n-pub struct Callee<'a> {\n-    pub bcx: &'a Block<'a>,\n+pub struct Callee<'blk, 'tcx: 'blk> {\n+    pub bcx: Block<'blk, 'tcx>,\n     pub data: CalleeData,\n }\n \n-fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n+fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n+                     -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_callee\");\n     debug!(\"callee::trans(expr={})\", expr.repr(bcx.tcx()));\n \n@@ -100,7 +101,8 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n     // any other expressions are closures:\n     return datum_callee(bcx, expr);\n \n-    fn datum_callee<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n+    fn datum_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n+                                -> Callee<'blk, 'tcx> {\n         let DatumBlock {bcx: mut bcx, datum} = expr::trans(bcx, expr);\n         match ty::get(datum.ty).sty {\n             ty::ty_bare_fn(..) => {\n@@ -128,15 +130,16 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n         }\n     }\n \n-    fn fn_callee<'a>(bcx: &'a Block<'a>, llfn: ValueRef) -> Callee<'a> {\n+    fn fn_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, llfn: ValueRef)\n+                             -> Callee<'blk, 'tcx> {\n         return Callee {\n             bcx: bcx,\n             data: Fn(llfn),\n         };\n     }\n \n-    fn trans_def<'a>(bcx: &'a Block<'a>, def: def::Def, ref_expr: &ast::Expr)\n-                 -> Callee<'a> {\n+    fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, def: def::Def, ref_expr: &ast::Expr)\n+                             -> Callee<'blk, 'tcx> {\n         debug!(\"trans_def(def={}, ref_expr={})\", def.repr(bcx.tcx()), ref_expr.repr(bcx.tcx()));\n         let expr_ty = node_id_type(bcx, ref_expr.id);\n         match def {\n@@ -214,7 +217,7 @@ fn trans<'a>(bcx: &'a Block<'a>, expr: &ast::Expr) -> Callee<'a> {\n     }\n }\n \n-pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId, node: ExprOrMethodCall) -> ValueRef {\n+pub fn trans_fn_ref(bcx: Block, def_id: ast::DefId, node: ExprOrMethodCall) -> ValueRef {\n     /*!\n      * Translates a reference (with id `ref_id`) to the fn/method\n      * with id `def_id` into a function pointer.  This may require\n@@ -237,12 +240,12 @@ pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId, node: ExprOrMethodCall) ->\n     trans_fn_ref_with_vtables(bcx, def_id, node, substs, vtables)\n }\n \n-fn trans_fn_ref_with_vtables_to_callee<'a>(bcx: &'a Block<'a>,\n-                                           def_id: ast::DefId,\n-                                           ref_id: ast::NodeId,\n-                                           substs: subst::Substs,\n-                                           vtables: typeck::vtable_res)\n-                                           -> Callee<'a> {\n+fn trans_fn_ref_with_vtables_to_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                                   def_id: ast::DefId,\n+                                                   ref_id: ast::NodeId,\n+                                                   substs: subst::Substs,\n+                                                   vtables: typeck::vtable_res)\n+                                                   -> Callee<'blk, 'tcx> {\n     Callee {\n         bcx: bcx,\n         data: Fn(trans_fn_ref_with_vtables(bcx,\n@@ -253,7 +256,7 @@ fn trans_fn_ref_with_vtables_to_callee<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-fn resolve_default_method_vtables(bcx: &Block,\n+fn resolve_default_method_vtables(bcx: Block,\n                                   impl_id: ast::DefId,\n                                   substs: &subst::Substs,\n                                   impl_vtables: typeck::vtable_res)\n@@ -281,7 +284,7 @@ fn resolve_default_method_vtables(bcx: &Block,\n \n /// Translates the adapter that deconstructs a `Box<Trait>` object into\n /// `Trait` so that a by-value self method can be called.\n-pub fn trans_unboxing_shim(bcx: &Block,\n+pub fn trans_unboxing_shim(bcx: Block,\n                            llshimmedfn: ValueRef,\n                            fty: &ty::BareFnTy,\n                            method_id: ast::DefId,\n@@ -406,7 +409,7 @@ pub fn trans_unboxing_shim(bcx: &Block,\n }\n \n pub fn trans_fn_ref_with_vtables(\n-    bcx: &Block,                 //\n+    bcx: Block,                  //\n     def_id: ast::DefId,          // def id of fn\n     node: ExprOrMethodCall,      // node id of use of fn; may be zero if N/A\n     substs: subst::Substs,       // values for fn's ty params\n@@ -625,13 +628,12 @@ pub fn trans_fn_ref_with_vtables(\n // ______________________________________________________________________\n // Translating calls\n \n-pub fn trans_call<'a>(\n-                  in_cx: &'a Block<'a>,\n-                  call_ex: &ast::Expr,\n-                  f: &ast::Expr,\n-                  args: CallArgs,\n-                  dest: expr::Dest)\n-                  -> &'a Block<'a> {\n+pub fn trans_call<'blk, 'tcx>(in_cx: Block<'blk, 'tcx>,\n+                              call_ex: &ast::Expr,\n+                              f: &ast::Expr,\n+                              args: CallArgs,\n+                              dest: expr::Dest)\n+                              -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_call\");\n     trans_call_inner(in_cx,\n                      Some(common::expr_info(call_ex)),\n@@ -641,13 +643,12 @@ pub fn trans_call<'a>(\n                      Some(dest)).bcx\n }\n \n-pub fn trans_method_call<'a>(\n-                         bcx: &'a Block<'a>,\n-                         call_ex: &ast::Expr,\n-                         rcvr: &ast::Expr,\n-                         args: CallArgs,\n-                         dest: expr::Dest)\n-                         -> &'a Block<'a> {\n+pub fn trans_method_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                     call_ex: &ast::Expr,\n+                                     rcvr: &ast::Expr,\n+                                     args: CallArgs,\n+                                     dest: expr::Dest)\n+                                     -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_ex={})\", call_ex.repr(bcx.tcx()));\n     let method_call = MethodCall::expr(call_ex.id);\n@@ -663,12 +664,11 @@ pub fn trans_method_call<'a>(\n         Some(dest)).bcx\n }\n \n-pub fn trans_lang_call<'a>(\n-                       bcx: &'a Block<'a>,\n-                       did: ast::DefId,\n-                       args: &[ValueRef],\n-                       dest: Option<expr::Dest>)\n-                       -> Result<'a> {\n+pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   did: ast::DefId,\n+                                   args: &[ValueRef],\n+                                   dest: Option<expr::Dest>)\n+                                   -> Result<'blk, 'tcx> {\n     let fty = if did.krate == ast::LOCAL_CRATE {\n         ty::node_id_to_type(bcx.tcx(), did.node)\n     } else {\n@@ -688,16 +688,15 @@ pub fn trans_lang_call<'a>(\n                              dest)\n }\n \n-pub fn trans_call_inner<'a>(\n-                        bcx: &'a Block<'a>,\n-                        call_info: Option<NodeInfo>,\n-                        callee_ty: ty::t,\n-                        get_callee: |bcx: &'a Block<'a>,\n-                                     arg_cleanup_scope: cleanup::ScopeId|\n-                                     -> Callee<'a>,\n-                        args: CallArgs,\n-                        dest: Option<expr::Dest>)\n-                        -> Result<'a> {\n+pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    call_info: Option<NodeInfo>,\n+                                    callee_ty: ty::t,\n+                                    get_callee: |bcx: Block<'blk, 'tcx>,\n+                                                arg_cleanup_scope: cleanup::ScopeId|\n+                                                -> Callee<'blk, 'tcx>,\n+                                    args: CallArgs,\n+                                    dest: Option<expr::Dest>)\n+                                    -> Result<'blk, 'tcx> {\n     /*!\n      * This behemoth of a function translates function calls.\n      * Unfortunately, in order to generate more efficient LLVM\n@@ -920,14 +919,14 @@ pub enum CallArgs<'a> {\n     ArgOverloadedCall(&'a [Gc<ast::Expr>]),\n }\n \n-fn trans_args_under_call_abi<'a>(\n-                             mut bcx: &'a Block<'a>,\n+fn trans_args_under_call_abi<'blk, 'tcx>(\n+                             mut bcx: Block<'blk, 'tcx>,\n                              arg_exprs: &[Gc<ast::Expr>],\n                              fn_ty: ty::t,\n                              llargs: &mut Vec<ValueRef>,\n                              arg_cleanup_scope: cleanup::ScopeId,\n                              ignore_self: bool)\n-                             -> &'a Block<'a> {\n+                             -> Block<'blk, 'tcx> {\n     // Translate the `self` argument first.\n     let arg_tys = ty::ty_fn_args(fn_ty);\n     if !ignore_self {\n@@ -981,14 +980,14 @@ fn trans_args_under_call_abi<'a>(\n     bcx\n }\n \n-fn trans_overloaded_call_args<'a>(\n-                              mut bcx: &'a Block<'a>,\n+fn trans_overloaded_call_args<'blk, 'tcx>(\n+                              mut bcx: Block<'blk, 'tcx>,\n                               arg_exprs: &[Gc<ast::Expr>],\n                               fn_ty: ty::t,\n                               llargs: &mut Vec<ValueRef>,\n                               arg_cleanup_scope: cleanup::ScopeId,\n                               ignore_self: bool)\n-                              -> &'a Block<'a> {\n+                              -> Block<'blk, 'tcx> {\n     // Translate the `self` argument first.\n     let arg_tys = ty::ty_fn_args(fn_ty);\n     if !ignore_self {\n@@ -1028,15 +1027,14 @@ fn trans_overloaded_call_args<'a>(\n     bcx\n }\n \n-pub fn trans_args<'a>(\n-                  cx: &'a Block<'a>,\n-                  args: CallArgs,\n-                  fn_ty: ty::t,\n-                  llargs: &mut Vec<ValueRef> ,\n-                  arg_cleanup_scope: cleanup::ScopeId,\n-                  ignore_self: bool,\n-                  abi: synabi::Abi)\n-                  -> &'a Block<'a> {\n+pub fn trans_args<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                              args: CallArgs,\n+                              fn_ty: ty::t,\n+                              llargs: &mut Vec<ValueRef> ,\n+                              arg_cleanup_scope: cleanup::ScopeId,\n+                              ignore_self: bool,\n+                              abi: synabi::Abi)\n+                              -> Block<'blk, 'tcx> {\n     debug!(\"trans_args(abi={})\", abi);\n \n     let _icx = push_ctxt(\"trans_args\");\n@@ -1124,13 +1122,12 @@ pub enum AutorefArg {\n     DoAutorefArg(ast::NodeId)\n }\n \n-pub fn trans_arg_datum<'a>(\n-                      bcx: &'a Block<'a>,\n-                      formal_arg_ty: ty::t,\n-                      arg_datum: Datum<Expr>,\n-                      arg_cleanup_scope: cleanup::ScopeId,\n-                      autoref_arg: AutorefArg)\n-                      -> Result<'a> {\n+pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   formal_arg_ty: ty::t,\n+                                   arg_datum: Datum<Expr>,\n+                                   arg_cleanup_scope: cleanup::ScopeId,\n+                                   autoref_arg: AutorefArg)\n+                                   -> Result<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_arg_datum\");\n     let mut bcx = bcx;\n     let ccx = bcx.ccx();"}, {"sha": "4d54308031e92cc0dc46697a36be721108cf8207", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=f7a997be05e364248521ee4d11ab57fcb2e99a40", "patch": "@@ -25,13 +25,13 @@ use middle::ty;\n use syntax::ast;\n use util::ppaux::Repr;\n \n-pub struct CleanupScope<'a> {\n+pub struct CleanupScope<'blk, 'tcx: 'blk> {\n     // The id of this cleanup scope. If the id is None,\n     // this is a *temporary scope* that is pushed during trans to\n     // cleanup miscellaneous garbage that trans may generate whose\n     // lifetime is a subset of some expression.  See module doc for\n     // more details.\n-    kind: CleanupScopeKind<'a>,\n+    kind: CleanupScopeKind<'blk, 'tcx>,\n \n     // Cleanups to run upon scope exit.\n     cleanups: Vec<CleanupObj>,\n@@ -48,10 +48,10 @@ pub static EXIT_BREAK: uint = 0;\n pub static EXIT_LOOP: uint = 1;\n pub static EXIT_MAX: uint = 2;\n \n-pub enum CleanupScopeKind<'a> {\n+pub enum CleanupScopeKind<'blk, 'tcx: 'blk> {\n     CustomScopeKind,\n     AstScopeKind(ast::NodeId),\n-    LoopScopeKind(ast::NodeId, [&'a Block<'a>, ..EXIT_MAX])\n+    LoopScopeKind(ast::NodeId, [Block<'blk, 'tcx>, ..EXIT_MAX])\n }\n \n #[deriving(PartialEq)]\n@@ -69,7 +69,7 @@ pub struct CachedEarlyExit {\n pub trait Cleanup {\n     fn must_unwind(&self) -> bool;\n     fn clean_on_unwind(&self) -> bool;\n-    fn trans<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a>;\n+    fn trans<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>) -> Block<'blk, 'tcx>;\n }\n \n pub type CleanupObj = Box<Cleanup+'static>;\n@@ -79,7 +79,7 @@ pub enum ScopeId {\n     CustomScope(CustomScopeIndex)\n }\n \n-impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n+impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     fn push_ast_cleanup_scope(&self, id: ast::NodeId) {\n         /*!\n          * Invoked when we start to trans the code contained\n@@ -109,7 +109,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n \n     fn push_loop_cleanup_scope(&self,\n                                id: ast::NodeId,\n-                               exits: [&'a Block<'a>, ..EXIT_MAX]) {\n+                               exits: [Block<'blk, 'tcx>, ..EXIT_MAX]) {\n         debug!(\"push_loop_cleanup_scope({})\",\n                self.ccx.tcx().map.node_to_string(id));\n         assert_eq!(Some(id), self.top_ast_scope());\n@@ -125,9 +125,9 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n     }\n \n     fn pop_and_trans_ast_cleanup_scope(&self,\n-                                       bcx: &'a Block<'a>,\n+                                       bcx: Block<'blk, 'tcx>,\n                                        cleanup_scope: ast::NodeId)\n-                                       -> &'a Block<'a> {\n+                                       -> Block<'blk, 'tcx> {\n         /*!\n          * Removes the cleanup scope for id `cleanup_scope`, which\n          * must be at the top of the cleanup stack, and generates the\n@@ -175,9 +175,9 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n     }\n \n     fn pop_and_trans_custom_cleanup_scope(&self,\n-                                        bcx: &'a Block<'a>,\n+                                        bcx: Block<'blk, 'tcx>,\n                                         custom_scope: CustomScopeIndex)\n-                                        -> &'a Block<'a> {\n+                                        -> Block<'blk, 'tcx> {\n         /*!\n          * Removes the top cleanup scope from the stack, which must be\n          * a temporary scope, and generates the code to do its\n@@ -207,7 +207,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n         self.ccx.sess().bug(\"no loop scope found\");\n     }\n \n-    fn normal_exit_block(&'a self,\n+    fn normal_exit_block(&'blk self,\n                          cleanup_scope: ast::NodeId,\n                          exit: uint) -> BasicBlockRef {\n         /*!\n@@ -219,7 +219,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n         self.trans_cleanups_to_exit_scope(LoopExit(cleanup_scope, exit))\n     }\n \n-    fn return_exit_block(&'a self) -> BasicBlockRef {\n+    fn return_exit_block(&'blk self) -> BasicBlockRef {\n         /*!\n          * Returns a block to branch to which will perform all pending\n          * cleanups and then return from this function\n@@ -426,7 +426,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n         self.scopes.borrow().iter().rev().any(|s| s.needs_invoke())\n     }\n \n-    fn get_landing_pad(&'a self) -> BasicBlockRef {\n+    fn get_landing_pad(&'blk self) -> BasicBlockRef {\n         /*!\n          * Returns a basic block to branch to in the event of a failure.\n          * This block will run the failure cleanups and eventually\n@@ -464,7 +464,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n     }\n }\n \n-impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n+impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     fn top_ast_scope(&self) -> Option<ast::NodeId> {\n         /*!\n          * Returns the id of the current top-most AST scope, if any.\n@@ -496,8 +496,8 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n     }\n \n     fn trans_scope_cleanups(&self, // cannot borrow self, will recurse\n-                            bcx: &'a Block<'a>,\n-                            scope: &CleanupScope) -> &'a Block<'a> {\n+                            bcx: Block<'blk, 'tcx>,\n+                            scope: &CleanupScope) -> Block<'blk, 'tcx> {\n         /*! Generates the cleanups for `scope` into `bcx` */\n \n         let mut bcx = bcx;\n@@ -513,23 +513,23 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n         self.scopes.borrow().len()\n     }\n \n-    fn push_scope(&self, scope: CleanupScope<'a>) {\n+    fn push_scope(&self, scope: CleanupScope<'blk, 'tcx>) {\n         self.scopes.borrow_mut().push(scope)\n     }\n \n-    fn pop_scope(&self) -> CleanupScope<'a> {\n+    fn pop_scope(&self) -> CleanupScope<'blk, 'tcx> {\n         debug!(\"popping cleanup scope {}, {} scopes remaining\",\n                self.top_scope(|s| s.block_name(\"\")),\n                self.scopes_len() - 1);\n \n         self.scopes.borrow_mut().pop().unwrap()\n     }\n \n-    fn top_scope<R>(&self, f: |&CleanupScope<'a>| -> R) -> R {\n+    fn top_scope<R>(&self, f: |&CleanupScope<'blk, 'tcx>| -> R) -> R {\n         f(self.scopes.borrow().last().unwrap())\n     }\n \n-    fn trans_cleanups_to_exit_scope(&'a self,\n+    fn trans_cleanups_to_exit_scope(&'blk self,\n                                     label: EarlyExitLabel)\n                                     -> BasicBlockRef {\n         /*!\n@@ -691,7 +691,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n         prev_llbb\n     }\n \n-    fn get_or_create_landing_pad(&'a self) -> BasicBlockRef {\n+    fn get_or_create_landing_pad(&'blk self) -> BasicBlockRef {\n         /*!\n          * Creates a landing pad for the top scope, if one does not\n          * exist.  The landing pad will perform all cleanups necessary\n@@ -784,8 +784,8 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n     }\n }\n \n-impl<'a> CleanupScope<'a> {\n-    fn new(kind: CleanupScopeKind<'a>) -> CleanupScope<'a> {\n+impl<'blk, 'tcx> CleanupScope<'blk, 'tcx> {\n+    fn new(kind: CleanupScopeKind<'blk, 'tcx>) -> CleanupScope<'blk, 'tcx> {\n         CleanupScope {\n             kind: kind,\n             cleanups: vec!(),\n@@ -836,7 +836,7 @@ impl<'a> CleanupScope<'a> {\n     }\n }\n \n-impl<'a> CleanupScopeKind<'a> {\n+impl<'blk, 'tcx> CleanupScopeKind<'blk, 'tcx> {\n     fn is_temp(&self) -> bool {\n         match *self {\n             CustomScopeKind => true,\n@@ -902,7 +902,7 @@ impl Cleanup for DropValue {\n         self.must_unwind\n     }\n \n-    fn trans<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a> {\n+    fn trans<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>) -> Block<'blk, 'tcx> {\n         let bcx = if self.is_immediate {\n             glue::drop_ty_immediate(bcx, self.val, self.ty)\n         } else {\n@@ -935,7 +935,7 @@ impl Cleanup for FreeValue {\n         true\n     }\n \n-    fn trans<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a> {\n+    fn trans<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>) -> Block<'blk, 'tcx> {\n         match self.heap {\n             HeapManaged => {\n                 glue::trans_free(bcx, self.ptr)\n@@ -963,7 +963,7 @@ impl Cleanup for FreeSlice {\n         true\n     }\n \n-    fn trans<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a> {\n+    fn trans<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>) -> Block<'blk, 'tcx> {\n         match self.heap {\n             HeapManaged => {\n                 glue::trans_free(bcx, self.ptr)\n@@ -988,7 +988,7 @@ impl Cleanup for LifetimeEnd {\n         true\n     }\n \n-    fn trans<'a>(&self, bcx: &'a Block<'a>) -> &'a Block<'a> {\n+    fn trans<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>) -> Block<'blk, 'tcx> {\n         base::call_lifetime_end(bcx, self.ptr);\n         bcx\n     }\n@@ -1026,29 +1026,29 @@ fn cleanup_is_suitable_for(c: &Cleanup,\n ///////////////////////////////////////////////////////////////////////////\n // These traits just exist to put the methods into this file.\n \n-pub trait CleanupMethods<'a> {\n+pub trait CleanupMethods<'blk, 'tcx> {\n     fn push_ast_cleanup_scope(&self, id: ast::NodeId);\n     fn push_loop_cleanup_scope(&self,\n                                    id: ast::NodeId,\n-                                   exits: [&'a Block<'a>, ..EXIT_MAX]);\n+                                   exits: [Block<'blk, 'tcx>, ..EXIT_MAX]);\n     fn push_custom_cleanup_scope(&self) -> CustomScopeIndex;\n     fn pop_and_trans_ast_cleanup_scope(&self,\n-                                              bcx: &'a Block<'a>,\n+                                              bcx: Block<'blk, 'tcx>,\n                                               cleanup_scope: ast::NodeId)\n-                                              -> &'a Block<'a>;\n+                                              -> Block<'blk, 'tcx>;\n     fn pop_loop_cleanup_scope(&self,\n                               cleanup_scope: ast::NodeId);\n     fn pop_custom_cleanup_scope(&self,\n                                 custom_scope: CustomScopeIndex);\n     fn pop_and_trans_custom_cleanup_scope(&self,\n-                                          bcx: &'a Block<'a>,\n+                                          bcx: Block<'blk, 'tcx>,\n                                           custom_scope: CustomScopeIndex)\n-                                          -> &'a Block<'a>;\n+                                          -> Block<'blk, 'tcx>;\n     fn top_loop_scope(&self) -> ast::NodeId;\n-    fn normal_exit_block(&'a self,\n+    fn normal_exit_block(&'blk self,\n                          cleanup_scope: ast::NodeId,\n                          exit: uint) -> BasicBlockRef;\n-    fn return_exit_block(&'a self) -> BasicBlockRef;\n+    fn return_exit_block(&'blk self) -> BasicBlockRef;\n     fn schedule_lifetime_end(&self,\n                          cleanup_scope: ScopeId,\n                          val: ValueRef);\n@@ -1085,23 +1085,23 @@ pub trait CleanupMethods<'a> {\n                                     custom_scope: CustomScopeIndex,\n                                     cleanup: CleanupObj);\n     fn needs_invoke(&self) -> bool;\n-    fn get_landing_pad(&'a self) -> BasicBlockRef;\n+    fn get_landing_pad(&'blk self) -> BasicBlockRef;\n }\n \n-trait CleanupHelperMethods<'a> {\n+trait CleanupHelperMethods<'blk, 'tcx> {\n     fn top_ast_scope(&self) -> Option<ast::NodeId>;\n     fn top_nonempty_cleanup_scope(&self) -> Option<uint>;\n     fn is_valid_to_pop_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool;\n     fn is_valid_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool;\n     fn trans_scope_cleanups(&self,\n-                            bcx: &'a Block<'a>,\n-                            scope: &CleanupScope<'a>) -> &'a Block<'a>;\n-    fn trans_cleanups_to_exit_scope(&'a self,\n+                            bcx: Block<'blk, 'tcx>,\n+                            scope: &CleanupScope<'blk, 'tcx>) -> Block<'blk, 'tcx>;\n+    fn trans_cleanups_to_exit_scope(&'blk self,\n                                     label: EarlyExitLabel)\n                                     -> BasicBlockRef;\n-    fn get_or_create_landing_pad(&'a self) -> BasicBlockRef;\n+    fn get_or_create_landing_pad(&'blk self) -> BasicBlockRef;\n     fn scopes_len(&self) -> uint;\n-    fn push_scope(&self, scope: CleanupScope<'a>);\n-    fn pop_scope(&self) -> CleanupScope<'a>;\n-    fn top_scope<R>(&self, f: |&CleanupScope<'a>| -> R) -> R;\n+    fn push_scope(&self, scope: CleanupScope<'blk, 'tcx>);\n+    fn pop_scope(&self) -> CleanupScope<'blk, 'tcx>;\n+    fn top_scope<R>(&self, f: |&CleanupScope<'blk, 'tcx>| -> R) -> R;\n }"}, {"sha": "7bbdf332fe11f20b843062c003d394bb14b8b9d7", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=f7a997be05e364248521ee4d11ab57fcb2e99a40", "patch": "@@ -135,10 +135,10 @@ fn tuplify_box_ty(tcx: &ty::ctxt, t: ty::t) -> ty::t {\n     ty::mk_tup(tcx, vec!(ty::mk_uint(), ty::mk_nil_ptr(tcx), ptr, ptr, t))\n }\n \n-fn allocate_cbox<'a>(bcx: &'a Block<'a>,\n-                     store: ty::TraitStore,\n-                     cdata_ty: ty::t)\n-                     -> Result<'a> {\n+fn allocate_cbox<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             store: ty::TraitStore,\n+                             cdata_ty: ty::t)\n+                             -> Result<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::allocate_cbox\");\n     let tcx = bcx.tcx();\n \n@@ -155,21 +155,20 @@ fn allocate_cbox<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-pub struct ClosureResult<'a> {\n+pub struct ClosureResult<'blk, 'tcx: 'blk> {\n     llbox: ValueRef,    // llvalue of ptr to closure\n     cdata_ty: ty::t,    // type of the closure data\n-    bcx: &'a Block<'a>  // final bcx\n+    bcx: Block<'blk, 'tcx>  // final bcx\n }\n \n // Given a block context and a list of tydescs and values to bind\n // construct a closure out of them. If copying is true, it is a\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n-pub fn store_environment<'a>(\n-                         bcx: &'a Block<'a>,\n-                         bound_values: Vec<EnvValue> ,\n-                         store: ty::TraitStore)\n-                         -> ClosureResult<'a> {\n+pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                     bound_values: Vec<EnvValue> ,\n+                                     store: ty::TraitStore)\n+                                     -> ClosureResult<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx();\n@@ -224,12 +223,11 @@ pub fn store_environment<'a>(\n \n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for store_environment.\n-fn build_closure<'a>(bcx0: &'a Block<'a>,\n-                     freevar_mode: freevars::CaptureMode,\n-                     freevars: &Vec<freevars::freevar_entry>,\n-                     store: ty::TraitStore)\n-                     -> ClosureResult<'a>\n-{\n+fn build_closure<'blk, 'tcx>(bcx0: Block<'blk, 'tcx>,\n+                             freevar_mode: freevars::CaptureMode,\n+                             freevars: &Vec<freevars::freevar_entry>,\n+                             store: ty::TraitStore)\n+                             -> ClosureResult<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::build_closure\");\n \n     // If we need to, package up the iterator body to call\n@@ -248,11 +246,11 @@ fn build_closure<'a>(bcx0: &'a Block<'a>,\n // Given an enclosing block context, a new function context, a closure type,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n-fn load_environment<'a>(bcx: &'a Block<'a>,\n-                        cdata_ty: ty::t,\n-                        freevars: &Vec<freevars::freevar_entry>,\n-                        store: ty::TraitStore)\n-                        -> &'a Block<'a> {\n+fn load_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                cdata_ty: ty::t,\n+                                freevars: &Vec<freevars::freevar_entry>,\n+                                store: ty::TraitStore)\n+                                -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::load_environment\");\n \n     // Don't bother to create the block if there's nothing to load\n@@ -301,12 +299,12 @@ fn load_environment<'a>(bcx: &'a Block<'a>,\n     bcx\n }\n \n-fn load_unboxed_closure_environment<'a>(\n-                                    bcx: &'a Block<'a>,\n+fn load_unboxed_closure_environment<'blk, 'tcx>(\n+                                    bcx: Block<'blk, 'tcx>,\n                                     arg_scope_id: ScopeId,\n                                     freevars: &Vec<freevars::freevar_entry>,\n                                     closure_id: ast::DefId)\n-                                    -> &'a Block<'a> {\n+                                    -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::load_environment\");\n \n     if freevars.len() == 0 {\n@@ -343,20 +341,19 @@ fn load_unboxed_closure_environment<'a>(\n     bcx\n }\n \n-fn fill_fn_pair(bcx: &Block, pair: ValueRef, llfn: ValueRef, llenvptr: ValueRef) {\n+fn fill_fn_pair(bcx: Block, pair: ValueRef, llfn: ValueRef, llenvptr: ValueRef) {\n     Store(bcx, llfn, GEPi(bcx, pair, [0u, abi::fn_field_code]));\n     let llenvptr = PointerCast(bcx, llenvptr, Type::i8p(bcx.ccx()));\n     Store(bcx, llenvptr, GEPi(bcx, pair, [0u, abi::fn_field_box]));\n }\n \n-pub fn trans_expr_fn<'a>(\n-                     bcx: &'a Block<'a>,\n-                     store: ty::TraitStore,\n-                     decl: &ast::FnDecl,\n-                     body: &ast::Block,\n-                     id: ast::NodeId,\n-                     dest: expr::Dest)\n-                     -> &'a Block<'a> {\n+pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 store: ty::TraitStore,\n+                                 decl: &ast::FnDecl,\n+                                 body: &ast::Block,\n+                                 id: ast::NodeId,\n+                                 dest: expr::Dest)\n+                                 -> Block<'blk, 'tcx> {\n     /*!\n      *\n      * Translates the body of a closure expression.\n@@ -458,13 +455,13 @@ pub fn get_or_create_declaration_if_unboxed_closure(ccx: &CrateContext,\n     Some(llfn)\n }\n \n-pub fn trans_unboxed_closure<'a>(\n-                             mut bcx: &'a Block<'a>,\n+pub fn trans_unboxed_closure<'blk, 'tcx>(\n+                             mut bcx: Block<'blk, 'tcx>,\n                              decl: &ast::FnDecl,\n                              body: &ast::Block,\n                              id: ast::NodeId,\n                              dest: expr::Dest)\n-                             -> &'a Block<'a> {\n+                             -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::trans_unboxed_closure\");\n \n     debug!(\"trans_unboxed_closure()\");\n@@ -620,11 +617,11 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n     llfn\n }\n \n-pub fn make_closure_from_bare_fn<'a>(bcx: &'a Block<'a>,\n-                                     closure_ty: ty::t,\n-                                     def: def::Def,\n-                                     fn_ptr: ValueRef)\n-                                     -> DatumBlock<'a, Expr>  {\n+pub fn make_closure_from_bare_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                             closure_ty: ty::t,\n+                                             def: def::Def,\n+                                             fn_ptr: ValueRef)\n+                                             -> DatumBlock<'blk, 'tcx, Expr>  {\n     let scratch = rvalue_scratch_datum(bcx, closure_ty, \"__adjust\");\n     let wrapper = get_wrapper_for_bare_fn(bcx.ccx(), closure_ty, def, fn_ptr, true);\n     fill_fn_pair(bcx, scratch.val, wrapper, C_null(Type::i8p(bcx.ccx())));"}, {"sha": "4ac9ae64d5a08e7eb17c09fda5dcefab536eff14", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=f7a997be05e364248521ee4d11ab57fcb2e99a40", "patch": "@@ -294,7 +294,7 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     pub span: Option<Span>,\n \n     // The arena that blocks are allocated from.\n-    pub block_arena: &'a TypedArena<Block<'a>>,\n+    pub block_arena: &'a TypedArena<BlockS<'a, 'tcx>>,\n \n     // This function's enclosing crate context.\n     pub ccx: &'a CrateContext<'a, 'tcx>,\n@@ -303,7 +303,7 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     pub debug_context: debuginfo::FunctionDebugContext,\n \n     // Cleanup scopes.\n-    pub scopes: RefCell<Vec<cleanup::CleanupScope<'a>> >,\n+    pub scopes: RefCell<Vec<cleanup::CleanupScope<'a, 'tcx>>>,\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n@@ -350,7 +350,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         self.llreturn.get().unwrap()\n     }\n \n-    pub fn get_ret_slot(&self, bcx: &Block, ty: ty::t, name: &str) -> ValueRef {\n+    pub fn get_ret_slot(&self, bcx: Block, ty: ty::t, name: &str) -> ValueRef {\n         if self.needs_ret_allocas {\n             base::alloca_no_lifetime(bcx, type_of::type_of(bcx.ccx(), ty), name)\n         } else {\n@@ -362,34 +362,34 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n                      is_lpad: bool,\n                      name: &str,\n                      opt_node_id: Option<ast::NodeId>)\n-                     -> &'a Block<'a> {\n+                     -> Block<'a, 'tcx> {\n         unsafe {\n             let llbb = name.with_c_str(|buf| {\n                     llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n                                                         self.llfn,\n                                                         buf)\n                 });\n-            Block::new(llbb, is_lpad, opt_node_id, self)\n+            BlockS::new(llbb, is_lpad, opt_node_id, self)\n         }\n     }\n \n     pub fn new_id_block(&'a self,\n                         name: &str,\n                         node_id: ast::NodeId)\n-                        -> &'a Block<'a> {\n+                        -> Block<'a, 'tcx> {\n         self.new_block(false, name, Some(node_id))\n     }\n \n     pub fn new_temp_block(&'a self,\n                           name: &str)\n-                          -> &'a Block<'a> {\n+                          -> Block<'a, 'tcx> {\n         self.new_block(false, name, None)\n     }\n \n     pub fn join_blocks(&'a self,\n                        id: ast::NodeId,\n-                       in_cxs: &[&'a Block<'a>])\n-                       -> &'a Block<'a> {\n+                       in_cxs: &[Block<'a, 'tcx>])\n+                       -> Block<'a, 'tcx> {\n         let out = self.new_id_block(\"join\", id);\n         let mut reachable = false;\n         for bcx in in_cxs.iter() {\n@@ -410,7 +410,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n // code.  Each basic block we generate is attached to a function, typically\n // with many basic blocks per function.  All the basic blocks attached to a\n // function are organized as a directed graph.\n-pub struct Block<'a, 'tcx> {\n+pub struct BlockS<'blk, 'tcx: 'blk> {\n     // The BasicBlockRef returned from a call to\n     // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n     // block to the function pointed to by llfn.  We insert\n@@ -429,16 +429,18 @@ pub struct Block<'a, 'tcx> {\n \n     // The function context for the function to which this block is\n     // attached.\n-    pub fcx: &'a FunctionContext<'a, 'tcx>,\n+    pub fcx: &'blk FunctionContext<'blk, 'tcx>,\n }\n \n-impl<'a, 'tcx> Block<'a, 'tcx> {\n+pub type Block<'blk, 'tcx> = &'blk BlockS<'blk, 'tcx>;\n+\n+impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     pub fn new(llbb: BasicBlockRef,\n                is_lpad: bool,\n                opt_node_id: Option<ast::NodeId>,\n-               fcx: &'a FunctionContext<'a, 'tcx>)\n-               -> &'a Block<'a, 'tcx> {\n-        fcx.block_arena.alloc(Block {\n+               fcx: &'blk FunctionContext<'blk, 'tcx>)\n+               -> Block<'blk, 'tcx> {\n+        fcx.block_arena.alloc(BlockS {\n             llbb: llbb,\n             terminated: Cell::new(false),\n             unreachable: Cell::new(false),\n@@ -448,11 +450,13 @@ impl<'a, 'tcx> Block<'a, 'tcx> {\n         })\n     }\n \n-    pub fn ccx(&self) -> &'a CrateContext<'a, 'tcx> { self.fcx.ccx }\n-    pub fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+    pub fn ccx(&self) -> &'blk CrateContext<'blk, 'tcx> {\n+        self.fcx.ccx\n+    }\n+    pub fn tcx(&self) -> &'blk ty::ctxt<'tcx> {\n         self.fcx.ccx.tcx()\n     }\n-    pub fn sess(&self) -> &'a Session { self.fcx.ccx.sess() }\n+    pub fn sess(&self) -> &'blk Session { self.fcx.ccx.sess() }\n \n     pub fn ident(&self, ident: Ident) -> String {\n         token::get_ident(ident).get().to_string()\n@@ -489,12 +493,11 @@ impl<'a, 'tcx> Block<'a, 'tcx> {\n     }\n \n     pub fn to_str(&self) -> String {\n-        let blk: *const Block = self;\n-        format!(\"[block {}]\", blk)\n+        format!(\"[block {:p}]\", self)\n     }\n }\n \n-impl<'blk, 'tcx> mc::Typer<'tcx> for Block<'blk, 'tcx> {\n+impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.tcx()\n     }\n@@ -535,12 +538,12 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for Block<'blk, 'tcx> {\n }\n \n pub struct Result<'blk, 'tcx: 'blk> {\n-    pub bcx: &'blk Block<'blk, 'tcx>,\n+    pub bcx: Block<'blk, 'tcx>,\n     pub val: ValueRef\n }\n \n impl<'b, 'tcx> Result<'b, 'tcx> {\n-    pub fn new(bcx: &'b Block<'b, 'tcx>, val: ValueRef) -> Result<'b, 'tcx> {\n+    pub fn new(bcx: Block<'b, 'tcx>, val: ValueRef) -> Result<'b, 'tcx> {\n         Result {\n             bcx: bcx,\n             val: val,\n@@ -745,21 +748,21 @@ pub fn is_null(val: ValueRef) -> bool {\n     }\n }\n \n-pub fn monomorphize_type(bcx: Block, t: ty::t) -> ty::t {\n+pub fn monomorphize_type(bcx: &BlockS, t: ty::t) -> ty::t {\n     t.subst(bcx.tcx(), &bcx.fcx.param_substs.substs)\n }\n \n-pub fn node_id_type(bcx: Block, id: ast::NodeId) -> ty::t {\n+pub fn node_id_type(bcx: &BlockS, id: ast::NodeId) -> ty::t {\n     let tcx = bcx.tcx();\n     let t = ty::node_id_to_type(tcx, id);\n     monomorphize_type(bcx, t)\n }\n \n-pub fn expr_ty(bcx: &Block, ex: &ast::Expr) -> ty::t {\n+pub fn expr_ty(bcx: Block, ex: &ast::Expr) -> ty::t {\n     node_id_type(bcx, ex.id)\n }\n \n-pub fn expr_ty_adjusted(bcx: &Block, ex: &ast::Expr) -> ty::t {\n+pub fn expr_ty_adjusted(bcx: Block, ex: &ast::Expr) -> ty::t {\n     monomorphize_type(bcx, ty::expr_ty_adjusted(bcx.tcx(), ex))\n }\n \n@@ -773,7 +776,7 @@ pub enum ExprOrMethodCall {\n     MethodCall(typeck::MethodCall)\n }\n \n-pub fn node_id_substs(bcx: &Block,\n+pub fn node_id_substs(bcx: Block,\n                       node: ExprOrMethodCall)\n                       -> subst::Substs {\n     let tcx = bcx.tcx();\n@@ -798,7 +801,7 @@ pub fn node_id_substs(bcx: &Block,\n     substs.substp(tcx, bcx.fcx.param_substs)\n }\n \n-pub fn node_vtables(bcx: &Block, id: typeck::MethodCall)\n+pub fn node_vtables(bcx: Block, id: typeck::MethodCall)\n                  -> typeck::vtable_res {\n     bcx.tcx().vtable_map.borrow().find(&id).map(|vts| {\n         resolve_vtables_in_fn_ctxt(bcx.fcx, vts)\n@@ -876,7 +879,7 @@ pub fn find_vtable(tcx: &ty::ctxt,\n     param_bounds.get(n_bound).clone()\n }\n \n-pub fn langcall(bcx: &Block,\n+pub fn langcall(bcx: Block,\n                 span: Option<Span>,\n                 msg: &str,\n                 li: LangItem)"}, {"sha": "dd9e41a61bf8748fa0adc29b3f8d6a00976e84cf", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 56, "deletions": 58, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=f7a997be05e364248521ee4d11ab57fcb2e99a40", "patch": "@@ -41,9 +41,9 @@ use syntax::visit::Visitor;\n \n use std::gc::Gc;\n \n-pub fn trans_stmt<'a>(cx: &'a Block<'a>,\n-                      s: &ast::Stmt)\n-                      -> &'a Block<'a> {\n+pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                              s: &ast::Stmt)\n+                              -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_stmt\");\n     let fcx = cx.fcx;\n     debug!(\"trans_stmt({})\", s.repr(cx.tcx()));\n@@ -83,7 +83,8 @@ pub fn trans_stmt<'a>(cx: &'a Block<'a>,\n     return bcx;\n }\n \n-pub fn trans_stmt_semi<'a>(cx: &'a Block<'a>, e: &ast::Expr) -> &'a Block<'a> {\n+pub fn trans_stmt_semi<'blk, 'tcx>(cx: Block<'blk, 'tcx>, e: &ast::Expr)\n+                                   -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_stmt_semi\");\n     let ty = expr_ty(cx, e);\n     if ty::type_needs_drop(cx.tcx(), ty) {\n@@ -93,10 +94,10 @@ pub fn trans_stmt_semi<'a>(cx: &'a Block<'a>, e: &ast::Expr) -> &'a Block<'a> {\n     }\n }\n \n-pub fn trans_block<'a>(bcx: &'a Block<'a>,\n-                       b: &ast::Block,\n-                       mut dest: expr::Dest)\n-                       -> &'a Block<'a> {\n+pub fn trans_block<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               b: &ast::Block,\n+                               mut dest: expr::Dest)\n+                               -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_block\");\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n@@ -128,13 +129,13 @@ pub fn trans_block<'a>(bcx: &'a Block<'a>,\n     return bcx;\n }\n \n-pub fn trans_if<'a>(bcx: &'a Block<'a>,\n-                    if_id: ast::NodeId,\n-                    cond: &ast::Expr,\n-                    thn: ast::P<ast::Block>,\n-                    els: Option<Gc<ast::Expr>>,\n-                    dest: expr::Dest)\n-                    -> &'a Block<'a> {\n+pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                            if_id: ast::NodeId,\n+                            cond: &ast::Expr,\n+                            thn: ast::P<ast::Block>,\n+                            els: Option<Gc<ast::Expr>>,\n+                            dest: expr::Dest)\n+                            -> Block<'blk, 'tcx> {\n     debug!(\"trans_if(bcx={}, if_id={}, cond={}, thn={:?}, dest={})\",\n            bcx.to_str(), if_id, bcx.expr_to_string(cond), thn.id,\n            dest.to_string(bcx.ccx()));\n@@ -204,11 +205,11 @@ pub fn trans_if<'a>(bcx: &'a Block<'a>,\n     next_bcx\n }\n \n-pub fn trans_while<'a>(bcx: &'a Block<'a>,\n-                       loop_id: ast::NodeId,\n-                       cond: &ast::Expr,\n-                       body: &ast::Block)\n-                       -> &'a Block<'a> {\n+pub fn trans_while<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               loop_id: ast::NodeId,\n+                               cond: &ast::Expr,\n+                               body: &ast::Block)\n+                               -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_while\");\n     let fcx = bcx.fcx;\n \n@@ -248,13 +249,12 @@ pub fn trans_while<'a>(bcx: &'a Block<'a>,\n }\n \n /// Translates a `for` loop.\n-pub fn trans_for<'a>(\n-                 mut bcx: &'a Block<'a>,\n-                 loop_info: NodeInfo,\n-                 pat: Gc<ast::Pat>,\n-                 head: &ast::Expr,\n-                 body: &ast::Block)\n-                 -> &'a Block<'a> {\n+pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                             loop_info: NodeInfo,\n+                             pat: Gc<ast::Pat>,\n+                             head: &ast::Expr,\n+                             body: &ast::Block)\n+                             -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_for\");\n \n     //            bcx\n@@ -369,10 +369,10 @@ pub fn trans_for<'a>(\n     next_bcx_in\n }\n \n-pub fn trans_loop<'a>(bcx:&'a Block<'a>,\n-                      loop_id: ast::NodeId,\n-                      body: &ast::Block)\n-                      -> &'a Block<'a> {\n+pub fn trans_loop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              loop_id: ast::NodeId,\n+                              body: &ast::Block)\n+                              -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_loop\");\n     let fcx = bcx.fcx;\n \n@@ -405,11 +405,11 @@ pub fn trans_loop<'a>(bcx:&'a Block<'a>,\n     return next_bcx_in;\n }\n \n-pub fn trans_break_cont<'a>(bcx: &'a Block<'a>,\n-                            expr_id: ast::NodeId,\n-                            opt_label: Option<Ident>,\n-                            exit: uint)\n-                            -> &'a Block<'a> {\n+pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    expr_id: ast::NodeId,\n+                                    opt_label: Option<Ident>,\n+                                    exit: uint)\n+                                    -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_break_cont\");\n     let fcx = bcx.fcx;\n \n@@ -438,23 +438,23 @@ pub fn trans_break_cont<'a>(bcx: &'a Block<'a>,\n     return bcx;\n }\n \n-pub fn trans_break<'a>(bcx: &'a Block<'a>,\n-                       expr_id: ast::NodeId,\n-                       label_opt: Option<Ident>)\n-                       -> &'a Block<'a> {\n+pub fn trans_break<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               expr_id: ast::NodeId,\n+                               label_opt: Option<Ident>)\n+                               -> Block<'blk, 'tcx> {\n     return trans_break_cont(bcx, expr_id, label_opt, cleanup::EXIT_BREAK);\n }\n \n-pub fn trans_cont<'a>(bcx: &'a Block<'a>,\n-                      expr_id: ast::NodeId,\n-                      label_opt: Option<Ident>)\n-                      -> &'a Block<'a> {\n+pub fn trans_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              expr_id: ast::NodeId,\n+                              label_opt: Option<Ident>)\n+                              -> Block<'blk, 'tcx> {\n     return trans_break_cont(bcx, expr_id, label_opt, cleanup::EXIT_LOOP);\n }\n \n-pub fn trans_ret<'a>(bcx: &'a Block<'a>,\n-                     e: Option<Gc<ast::Expr>>)\n-                     -> &'a Block<'a> {\n+pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             e: Option<Gc<ast::Expr>>)\n+                             -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_ret\");\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n@@ -483,11 +483,10 @@ pub fn trans_ret<'a>(bcx: &'a Block<'a>,\n     return bcx;\n }\n \n-pub fn trans_fail<'a>(\n-                  bcx: &'a Block<'a>,\n-                  sp: Span,\n-                  fail_str: InternedString)\n-                  -> &'a Block<'a> {\n+pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              sp: Span,\n+                              fail_str: InternedString)\n+                              -> Block<'blk, 'tcx> {\n     let ccx = bcx.ccx();\n     let _icx = push_ctxt(\"trans_fail_value\");\n \n@@ -508,12 +507,11 @@ pub fn trans_fail<'a>(\n     return bcx;\n }\n \n-pub fn trans_fail_bounds_check<'a>(\n-                               bcx: &'a Block<'a>,\n-                               sp: Span,\n-                               index: ValueRef,\n-                               len: ValueRef)\n-                               -> &'a Block<'a> {\n+pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                           sp: Span,\n+                                           index: ValueRef,\n+                                           len: ValueRef)\n+                                           -> Block<'blk, 'tcx> {\n     let ccx = bcx.ccx();\n     let _icx = push_ctxt(\"trans_fail_bounds_check\");\n "}, {"sha": "84d9f2cb740a36fd7017ba6f6019d98b33f4fab6", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 95, "deletions": 96, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=f7a997be05e364248521ee4d11ab57fcb2e99a40", "patch": "@@ -47,8 +47,8 @@ pub struct Datum<K> {\n     pub kind: K,\n }\n \n-pub struct DatumBlock<'a, K> {\n-    pub bcx: &'a Block<'a>,\n+pub struct DatumBlock<'blk, 'tcx: 'blk, K> {\n+    pub bcx: Block<'blk, 'tcx>,\n     pub datum: Datum<K>,\n }\n \n@@ -94,23 +94,23 @@ pub fn immediate_rvalue(val: ValueRef, ty: ty::t) -> Datum<Rvalue> {\n     return Datum::new(val, ty, Rvalue::new(ByValue));\n }\n \n-pub fn immediate_rvalue_bcx<'a>(bcx: &'a Block<'a>,\n-                                val: ValueRef,\n-                                ty: ty::t)\n-                                -> DatumBlock<'a, Rvalue> {\n+pub fn immediate_rvalue_bcx<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                        val: ValueRef,\n+                                        ty: ty::t)\n+                                        -> DatumBlock<'blk, 'tcx, Rvalue> {\n     return DatumBlock::new(bcx, immediate_rvalue(val, ty))\n }\n \n \n-pub fn lvalue_scratch_datum<'a, A>(bcx: &'a Block<'a>,\n-                                   ty: ty::t,\n-                                   name: &str,\n-                                   zero: bool,\n-                                   scope: cleanup::ScopeId,\n-                                   arg: A,\n-                                   populate: |A, &'a Block<'a>, ValueRef|\n-                                             -> &'a Block<'a>)\n-                                   -> DatumBlock<'a, Lvalue> {\n+pub fn lvalue_scratch_datum<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n+                                           ty: ty::t,\n+                                           name: &str,\n+                                           zero: bool,\n+                                           scope: cleanup::ScopeId,\n+                                           arg: A,\n+                                           populate: |A, Block<'blk, 'tcx>, ValueRef|\n+                                                      -> Block<'blk, 'tcx>)\n+                                          -> DatumBlock<'blk, 'tcx, Lvalue> {\n     /*!\n      * Allocates temporary space on the stack using alloca() and\n      * returns a by-ref Datum pointing to it. The memory will be\n@@ -135,7 +135,7 @@ pub fn lvalue_scratch_datum<'a, A>(bcx: &'a Block<'a>,\n     DatumBlock::new(bcx, Datum::new(scratch, ty, Lvalue))\n }\n \n-pub fn rvalue_scratch_datum(bcx: &Block,\n+pub fn rvalue_scratch_datum(bcx: Block,\n                             ty: ty::t,\n                             name: &str)\n                             -> Datum<Rvalue> {\n@@ -188,11 +188,11 @@ pub trait KindOps {\n      * Take appropriate action after the value in `datum` has been\n      * stored to a new location.\n      */\n-    fn post_store<'a>(&self,\n-                      bcx: &'a Block<'a>,\n-                      val: ValueRef,\n-                      ty: ty::t)\n-                      -> &'a Block<'a>;\n+    fn post_store<'blk, 'tcx>(&self,\n+                              bcx: Block<'blk, 'tcx>,\n+                              val: ValueRef,\n+                              ty: ty::t)\n+                              -> Block<'blk, 'tcx>;\n \n     /**\n      * True if this mode is a reference mode, meaning that the datum's\n@@ -208,11 +208,11 @@ pub trait KindOps {\n }\n \n impl KindOps for Rvalue {\n-    fn post_store<'a>(&self,\n-                      bcx: &'a Block<'a>,\n-                      _val: ValueRef,\n-                      _ty: ty::t)\n-                      -> &'a Block<'a> {\n+    fn post_store<'blk, 'tcx>(&self,\n+                              bcx: Block<'blk, 'tcx>,\n+                              _val: ValueRef,\n+                              _ty: ty::t)\n+                              -> Block<'blk, 'tcx> {\n         // No cleanup is scheduled for an rvalue, so we don't have\n         // to do anything after a move to cancel or duplicate it.\n         bcx\n@@ -228,11 +228,11 @@ impl KindOps for Rvalue {\n }\n \n impl KindOps for Lvalue {\n-    fn post_store<'a>(&self,\n-                      bcx: &'a Block<'a>,\n-                      val: ValueRef,\n-                      ty: ty::t)\n-                      -> &'a Block<'a> {\n+    fn post_store<'blk, 'tcx>(&self,\n+                              bcx: Block<'blk, 'tcx>,\n+                              val: ValueRef,\n+                              ty: ty::t)\n+                              -> Block<'blk, 'tcx> {\n         /*!\n          * If an lvalue is moved, we must zero out the memory in which\n          * it resides so as to cancel cleanup. If an @T lvalue is\n@@ -263,11 +263,11 @@ impl KindOps for Lvalue {\n }\n \n impl KindOps for Expr {\n-    fn post_store<'a>(&self,\n-                      bcx: &'a Block<'a>,\n-                      val: ValueRef,\n-                      ty: ty::t)\n-                      -> &'a Block<'a> {\n+    fn post_store<'blk, 'tcx>(&self,\n+                              bcx: Block<'blk, 'tcx>,\n+                              val: ValueRef,\n+                              ty: ty::t)\n+                              -> Block<'blk, 'tcx> {\n         match *self {\n             LvalueExpr => Lvalue.post_store(bcx, val, ty),\n             RvalueExpr(ref r) => r.post_store(bcx, val, ty),\n@@ -302,11 +302,11 @@ impl Datum<Rvalue> {\n         self.val\n     }\n \n-    pub fn to_lvalue_datum_in_scope<'a>(self,\n-                                        bcx: &'a Block<'a>,\n-                                        name: &str,\n-                                        scope: cleanup::ScopeId)\n-                                        -> DatumBlock<'a, Lvalue> {\n+    pub fn to_lvalue_datum_in_scope<'blk, 'tcx>(self,\n+                                                bcx: Block<'blk, 'tcx>,\n+                                                name: &str,\n+                                                scope: cleanup::ScopeId)\n+                                                -> DatumBlock<'blk, 'tcx, Lvalue> {\n         /*!\n          * Returns an lvalue datum (that is, a by ref datum with\n          * cleanup scheduled). If `self` is not already an lvalue,\n@@ -328,7 +328,8 @@ impl Datum<Rvalue> {\n         }\n     }\n \n-    pub fn to_ref_datum<'a>(self, bcx: &'a Block<'a>) -> DatumBlock<'a, Rvalue> {\n+    pub fn to_ref_datum<'blk, 'tcx>(self, bcx: Block<'blk, 'tcx>)\n+                                    -> DatumBlock<'blk, 'tcx, Rvalue> {\n         let mut bcx = bcx;\n         match self.kind.mode {\n             ByRef => DatumBlock::new(bcx, self),\n@@ -340,9 +341,9 @@ impl Datum<Rvalue> {\n         }\n     }\n \n-    pub fn to_appropriate_datum<'a>(self,\n-                                    bcx: &'a Block<'a>)\n-                                    -> DatumBlock<'a, Rvalue> {\n+    pub fn to_appropriate_datum<'blk, 'tcx>(self,\n+                                            bcx: Block<'blk, 'tcx>)\n+                                            -> DatumBlock<'blk, 'tcx, Rvalue> {\n         match self.appropriate_rvalue_mode(bcx.ccx()) {\n             ByRef => {\n                 self.to_ref_datum(bcx)\n@@ -381,7 +382,7 @@ impl Datum<Expr> {\n     }\n \n     #[allow(dead_code)] // potentially useful\n-    pub fn assert_lvalue(self, bcx: &Block) -> Datum<Lvalue> {\n+    pub fn assert_lvalue(self, bcx: Block) -> Datum<Lvalue> {\n         /*!\n          * Asserts that this datum *is* an lvalue and returns it.\n          */\n@@ -391,7 +392,7 @@ impl Datum<Expr> {\n             |_| bcx.sess().bug(\"assert_lvalue given rvalue\"))\n     }\n \n-    pub fn assert_rvalue(self, bcx: &Block) -> Datum<Rvalue> {\n+    pub fn assert_rvalue(self, bcx: Block) -> Datum<Rvalue> {\n         /*!\n          * Asserts that this datum *is* an lvalue and returns it.\n          */\n@@ -401,11 +402,11 @@ impl Datum<Expr> {\n             |r| r)\n     }\n \n-    pub fn store_to_dest<'a>(self,\n-                             bcx: &'a Block<'a>,\n-                             dest: expr::Dest,\n-                             expr_id: ast::NodeId)\n-                             -> &'a Block<'a> {\n+    pub fn store_to_dest<'blk, 'tcx>(self,\n+                                     bcx: Block<'blk, 'tcx>,\n+                                     dest: expr::Dest,\n+                                     expr_id: ast::NodeId)\n+                                     -> Block<'blk, 'tcx> {\n         match dest {\n             expr::Ignore => {\n                 self.add_clean_if_rvalue(bcx, expr_id);\n@@ -417,9 +418,9 @@ impl Datum<Expr> {\n         }\n     }\n \n-    pub fn add_clean_if_rvalue<'a>(self,\n-                                   bcx: &'a Block<'a>,\n-                                   expr_id: ast::NodeId) {\n+    pub fn add_clean_if_rvalue<'blk, 'tcx>(self,\n+                                           bcx: Block<'blk, 'tcx>,\n+                                           expr_id: ast::NodeId) {\n         /*!\n          * Arranges cleanup for `self` if it is an rvalue. Use when\n          * you are done working with a value that may need drop.\n@@ -433,11 +434,11 @@ impl Datum<Expr> {\n             })\n     }\n \n-    pub fn clean<'a>(self,\n-                     bcx: &'a Block<'a>,\n-                     name: &'static str,\n-                     expr_id: ast::NodeId)\n-                     -> &'a Block<'a> {\n+    pub fn clean<'blk, 'tcx>(self,\n+                             bcx: Block<'blk, 'tcx>,\n+                             name: &'static str,\n+                             expr_id: ast::NodeId)\n+                             -> Block<'blk, 'tcx> {\n         /*!\n          * Ensures that `self` will get cleaned up, if it is not an lvalue\n          * already.\n@@ -446,11 +447,11 @@ impl Datum<Expr> {\n         self.to_lvalue_datum(bcx, name, expr_id).bcx\n     }\n \n-    pub fn to_lvalue_datum<'a>(self,\n-                               bcx: &'a Block<'a>,\n-                               name: &str,\n-                               expr_id: ast::NodeId)\n-                               -> DatumBlock<'a, Lvalue> {\n+    pub fn to_lvalue_datum<'blk, 'tcx>(self,\n+                                       bcx: Block<'blk, 'tcx>,\n+                                       name: &str,\n+                                       expr_id: ast::NodeId)\n+                                       -> DatumBlock<'blk, 'tcx, Lvalue> {\n         debug!(\"to_lvalue_datum self: {}\", self.to_string(bcx.ccx()));\n \n         assert!(ty::lltype_is_sized(bcx.tcx(), self.ty),\n@@ -463,10 +464,10 @@ impl Datum<Expr> {\n             })\n     }\n \n-    pub fn to_rvalue_datum<'a>(self,\n-                               bcx: &'a Block<'a>,\n-                               name: &'static str)\n-                               -> DatumBlock<'a, Rvalue> {\n+    pub fn to_rvalue_datum<'blk, 'tcx>(self,\n+                                       bcx: Block<'blk, 'tcx>,\n+                                       name: &'static str)\n+                                       -> DatumBlock<'blk, 'tcx, Rvalue> {\n         /*!\n          * Ensures that we have an rvalue datum (that is, a datum with\n          * no cleanup scheduled).\n@@ -514,11 +515,9 @@ impl Datum<Lvalue> {\n     // datum may also be unsized _without the size information_. It is the\n     // callers responsibility to package the result in some way to make a valid\n     // datum in that case (e.g., by making a fat pointer or opened pair).\n-    pub fn get_element<'a>(&self,\n-                           bcx: &'a Block<'a>,\n-                           ty: ty::t,\n-                           gep: |ValueRef| -> ValueRef)\n-                           -> Datum<Lvalue> {\n+    pub fn get_element(&self, bcx: Block, ty: ty::t,\n+                       gep: |ValueRef| -> ValueRef)\n+                       -> Datum<Lvalue> {\n         let val = match ty::get(self.ty).sty {\n             _ if ty::type_is_sized(bcx.tcx(), self.ty) => gep(self.val),\n             ty::ty_open(_) => {\n@@ -536,7 +535,7 @@ impl Datum<Lvalue> {\n         }\n     }\n \n-    pub fn get_vec_base_and_len<'a>(&self, bcx: &'a Block<'a>) -> (ValueRef, ValueRef) {\n+    pub fn get_vec_base_and_len(&self, bcx: Block) -> (ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair.\n \n         tvec::get_base_and_len(bcx, self.val, self.ty)\n@@ -556,10 +555,10 @@ impl<K:KindOps> Datum<K> {\n         Datum { val: val, ty: ty, kind: kind.to_expr_kind() }\n     }\n \n-    pub fn store_to<'a>(self,\n-                        bcx: &'a Block<'a>,\n-                        dst: ValueRef)\n-                        -> &'a Block<'a> {\n+    pub fn store_to<'blk, 'tcx>(self,\n+                                bcx: Block<'blk, 'tcx>,\n+                                dst: ValueRef)\n+                                -> Block<'blk, 'tcx> {\n         /*!\n          * Moves or copies this value into a new home, as appropriate\n          * depending on the type of the datum. This method consumes\n@@ -573,10 +572,10 @@ impl<K:KindOps> Datum<K> {\n         self.kind.post_store(bcx, self.val, self.ty)\n     }\n \n-    fn shallow_copy<'a>(&self,\n-                        bcx: &'a Block<'a>,\n-                        dst: ValueRef)\n-                        -> &'a Block<'a> {\n+    fn shallow_copy<'blk, 'tcx>(&self,\n+                                bcx: Block<'blk, 'tcx>,\n+                                dst: ValueRef)\n+                                -> Block<'blk, 'tcx> {\n         /*!\n          * Helper function that performs a shallow copy of this value\n          * into `dst`, which should be a pointer to a memory location\n@@ -606,10 +605,10 @@ impl<K:KindOps> Datum<K> {\n         return bcx;\n     }\n \n-    pub fn shallow_copy_and_take<'a>(&self,\n-                                     bcx: &'a Block<'a>,\n-                                     dst: ValueRef)\n-                                     -> &'a Block<'a> {\n+    pub fn shallow_copy_and_take<'blk, 'tcx>(&self,\n+                                             bcx: Block<'blk, 'tcx>,\n+                                             dst: ValueRef)\n+                                             -> Block<'blk, 'tcx> {\n         /*!\n          * Copies the value into a new location and runs any necessary\n          * take glue on the new location. This function always\n@@ -638,7 +637,7 @@ impl<K:KindOps> Datum<K> {\n         appropriate_rvalue_mode(ccx, self.ty)\n     }\n \n-    pub fn to_llscalarish<'a>(self, bcx: &'a Block<'a>) -> ValueRef {\n+    pub fn to_llscalarish(self, bcx: Block) -> ValueRef {\n         /*!\n          * Converts `self` into a by-value `ValueRef`. Consumes this\n          * datum (i.e., absolves you of responsibility to cleanup the\n@@ -657,33 +656,33 @@ impl<K:KindOps> Datum<K> {\n         }\n     }\n \n-    pub fn to_llbool<'a>(self, bcx: &'a Block<'a>) -> ValueRef {\n+    pub fn to_llbool(self, bcx: Block) -> ValueRef {\n         assert!(ty::type_is_bool(self.ty) || ty::type_is_bot(self.ty))\n         self.to_llscalarish(bcx)\n     }\n }\n \n-impl <'a, K> DatumBlock<'a, K> {\n-    pub fn new(bcx: &'a Block<'a>, datum: Datum<K>) -> DatumBlock<'a, K> {\n+impl<'blk, 'tcx, K> DatumBlock<'blk, 'tcx, K> {\n+    pub fn new(bcx: Block<'blk, 'tcx>, datum: Datum<K>) -> DatumBlock<'blk, 'tcx, K> {\n         DatumBlock { bcx: bcx, datum: datum }\n     }\n }\n \n-impl<'a, K:KindOps> DatumBlock<'a, K> {\n-    pub fn to_expr_datumblock(self) -> DatumBlock<'a, Expr> {\n+impl<'blk, 'tcx, K:KindOps> DatumBlock<'blk, 'tcx, K> {\n+    pub fn to_expr_datumblock(self) -> DatumBlock<'blk, 'tcx, Expr> {\n         DatumBlock::new(self.bcx, self.datum.to_expr_datum())\n     }\n }\n \n-impl<'a> DatumBlock<'a, Expr> {\n+impl<'blk, 'tcx> DatumBlock<'blk, 'tcx, Expr> {\n     pub fn store_to_dest(self,\n                          dest: expr::Dest,\n-                         expr_id: ast::NodeId) -> &'a Block<'a> {\n+                         expr_id: ast::NodeId) -> Block<'blk, 'tcx> {\n         let DatumBlock { bcx, datum } = self;\n         datum.store_to_dest(bcx, dest, expr_id)\n     }\n \n-    pub fn to_llbool(self) -> Result<'a> {\n+    pub fn to_llbool(self) -> Result<'blk, 'tcx> {\n         let DatumBlock { datum, bcx } = self;\n         Result::new(bcx, datum.to_llbool(bcx))\n     }"}, {"sha": "b640f9ef5af11dfb5cb6640666de6bd6824e1fc7", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=f7a997be05e364248521ee4d11ab57fcb2e99a40", "patch": "@@ -832,7 +832,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n /// Creates debug information for the given local variable.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n+pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n@@ -867,7 +867,7 @@ pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n /// Creates debug information for a variable captured in a closure.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_captured_var_metadata(bcx: &Block,\n+pub fn create_captured_var_metadata(bcx: Block,\n                                     node_id: ast::NodeId,\n                                     env_data_type: ty::t,\n                                     env_pointer: ValueRef,\n@@ -954,7 +954,7 @@ pub fn create_captured_var_metadata(bcx: &Block,\n /// match-statement arm.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_match_binding_metadata(bcx: &Block,\n+pub fn create_match_binding_metadata(bcx: Block,\n                                      variable_ident: ast::Ident,\n                                      binding: BindingInfo) {\n     if fn_should_be_ignored(bcx.fcx) {\n@@ -994,7 +994,7 @@ pub fn create_match_binding_metadata(bcx: &Block,\n /// Creates debug information for the given function argument.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n+pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n@@ -1518,7 +1518,7 @@ fn compile_unit_metadata(cx: &CrateContext) {\n     }\n }\n \n-fn declare_local(bcx: &Block,\n+fn declare_local(bcx: Block,\n                  variable_ident: ast::Ident,\n                  variable_type: ty::t,\n                  scope_metadata: DIScope,"}, {"sha": "0421aef45ef9c4617d866f1e1f99c1889ebd62c7", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 208, "deletions": 213, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=f7a997be05e364248521ee4d11ab57fcb2e99a40", "patch": "@@ -100,10 +100,10 @@ impl Dest {\n     }\n }\n \n-pub fn trans_into<'a>(bcx: &'a Block<'a>,\n-                      expr: &ast::Expr,\n-                      dest: Dest)\n-                      -> &'a Block<'a> {\n+pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              expr: &ast::Expr,\n+                              dest: Dest)\n+                              -> Block<'blk, 'tcx> {\n     /*!\n      * This function is equivalent to `trans(bcx, expr).store_to_dest(dest)`\n      * but it may generate better optimized LLVM code.\n@@ -139,9 +139,9 @@ pub fn trans_into<'a>(bcx: &'a Block<'a>,\n     bcx.fcx.pop_and_trans_ast_cleanup_scope(bcx, expr.id)\n }\n \n-pub fn trans<'a>(bcx: &'a Block<'a>,\n-                 expr: &ast::Expr)\n-                 -> DatumBlock<'a, Expr> {\n+pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                         expr: &ast::Expr)\n+                         -> DatumBlock<'blk, 'tcx, Expr> {\n     /*!\n      * Translates an expression, returning a datum (and new block)\n      * encapsulating the result. When possible, it is preferred to\n@@ -161,18 +161,18 @@ pub fn trans<'a>(bcx: &'a Block<'a>,\n     return DatumBlock::new(bcx, datum);\n }\n \n-pub fn get_len(bcx: &Block, fat_ptr: ValueRef) -> ValueRef {\n+pub fn get_len(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n     GEPi(bcx, fat_ptr, [0u, abi::slice_elt_len])\n }\n \n-pub fn get_dataptr(bcx: &Block, fat_ptr: ValueRef) -> ValueRef {\n+pub fn get_dataptr(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n     GEPi(bcx, fat_ptr, [0u, abi::slice_elt_base])\n }\n \n-fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n-                         expr: &ast::Expr,\n-                         datum: Datum<Expr>)\n-                         -> DatumBlock<'a, Expr> {\n+fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 expr: &ast::Expr,\n+                                 datum: Datum<Expr>)\n+                                 -> DatumBlock<'blk, 'tcx, Expr> {\n     /*!\n      * Helper for trans that apply adjustments from `expr` to `datum`,\n      * which should be the unadjusted translation of `expr`.\n@@ -245,11 +245,11 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n     debug!(\"after adjustments, datum={}\", datum.to_string(bcx.ccx()));\n     return DatumBlock::new(bcx, datum);\n \n-    fn apply_autoref<'a>(autoref: &ty::AutoRef,\n-                         bcx: &'a Block<'a>,\n-                         expr: &ast::Expr,\n-                         datum: Datum<Expr>)\n-                         -> DatumBlock<'a, Expr> {\n+    fn apply_autoref<'blk, 'tcx>(autoref: &ty::AutoRef,\n+                                 bcx: Block<'blk, 'tcx>,\n+                                 expr: &ast::Expr,\n+                                 datum: Datum<Expr>)\n+                                 -> DatumBlock<'blk, 'tcx, Expr> {\n         let mut bcx = bcx;\n         let mut datum = datum;\n \n@@ -281,10 +281,10 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         DatumBlock::new(bcx, datum)\n     }\n \n-    fn ref_ptr<'a>(bcx: &'a Block<'a>,\n-                   expr: &ast::Expr,\n-                   datum: Datum<Expr>)\n-                   -> DatumBlock<'a, Expr> {\n+    fn ref_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                           expr: &ast::Expr,\n+                           datum: Datum<Expr>)\n+                           -> DatumBlock<'blk, 'tcx, Expr> {\n         if !ty::type_is_sized(bcx.tcx(), datum.ty) {\n             debug!(\"Taking address of unsized type {}\",\n                    bcx.ty_to_string(datum.ty));\n@@ -303,11 +303,11 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n     // into a type to be destructed. If we want to end up with a Box pointer,\n     // then mk_ty should make a Box pointer (T -> Box<T>), if we want a\n     // borrowed reference then it should be T -> &T.\n-    fn unsized_info<'a>(bcx: &'a Block<'a>,\n-                        kind: &ty::UnsizeKind,\n-                        id: ast::NodeId,\n-                        unsized_ty: ty::t,\n-                        mk_ty: |ty::t| -> ty::t) -> ValueRef {\n+    fn unsized_info<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                kind: &ty::UnsizeKind,\n+                                id: ast::NodeId,\n+                                unsized_ty: ty::t,\n+                                mk_ty: |ty::t| -> ty::t) -> ValueRef {\n         match kind {\n             &ty::UnsizeLength(len) => C_uint(bcx.ccx(), len),\n             &ty::UnsizeStruct(box ref k, tp_index) => match ty::get(unsized_ty).sty {\n@@ -327,11 +327,11 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         }\n     }\n \n-    fn unsize_expr<'a>(bcx: &'a Block<'a>,\n-                       expr: &ast::Expr,\n-                       datum: Datum<Expr>,\n-                       k: &ty::UnsizeKind)\n-                       -> DatumBlock<'a, Expr> {\n+    fn unsize_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               expr: &ast::Expr,\n+                               datum: Datum<Expr>,\n+                               k: &ty::UnsizeKind)\n+                               -> DatumBlock<'blk, 'tcx, Expr> {\n         let tcx = bcx.tcx();\n         let datum_ty = datum.ty;\n         let unsized_ty = ty::unsize_ty(tcx, datum_ty, k, expr.span);\n@@ -361,24 +361,24 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         into_fat_ptr(bcx, expr, datum, dest_ty, base, info)\n     }\n \n-    fn ref_fat_ptr<'a>(bcx: &'a Block<'a>,\n-                       expr: &ast::Expr,\n-                       datum: Datum<Expr>)\n-                       -> DatumBlock<'a, Expr> {\n+    fn ref_fat_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               expr: &ast::Expr,\n+                               datum: Datum<Expr>)\n+                               -> DatumBlock<'blk, 'tcx, Expr> {\n         let tcx = bcx.tcx();\n         let dest_ty = ty::close_type(tcx, datum.ty);\n         let base = |bcx, val| Load(bcx, get_dataptr(bcx, val));\n         let len = |bcx, val| Load(bcx, get_len(bcx, val));\n         into_fat_ptr(bcx, expr, datum, dest_ty, base, len)\n     }\n \n-    fn into_fat_ptr<'a>(bcx: &'a Block<'a>,\n-                        expr: &ast::Expr,\n-                        datum: Datum<Expr>,\n-                        dest_ty: ty::t,\n-                        base: |&'a Block<'a>, ValueRef| -> ValueRef,\n-                        info: |&'a Block<'a>, ValueRef| -> ValueRef)\n-                        -> DatumBlock<'a, Expr> {\n+    fn into_fat_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                expr: &ast::Expr,\n+                                datum: Datum<Expr>,\n+                                dest_ty: ty::t,\n+                                base: |Block<'blk, 'tcx>, ValueRef| -> ValueRef,\n+                                info: |Block<'blk, 'tcx>, ValueRef| -> ValueRef)\n+                                -> DatumBlock<'blk, 'tcx, Expr> {\n         let mut bcx = bcx;\n \n         // Arrange cleanup\n@@ -394,11 +394,11 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         DatumBlock::new(bcx, scratch.to_expr_datum())\n     }\n \n-    fn unsize_unique_vec<'a>(bcx: &'a Block<'a>,\n-                             expr: &ast::Expr,\n-                             datum: Datum<Expr>,\n-                             len: uint)\n-                             -> DatumBlock<'a, Expr> {\n+    fn unsize_unique_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                     expr: &ast::Expr,\n+                                     datum: Datum<Expr>,\n+                                     len: uint)\n+                                     -> DatumBlock<'blk, 'tcx, Expr> {\n         let mut bcx = bcx;\n         let tcx = bcx.tcx();\n \n@@ -440,11 +440,11 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         DatumBlock::new(bcx, scratch.to_expr_datum())\n     }\n \n-    fn unsize_unique_expr<'a>(bcx: &'a Block<'a>,\n-                              expr: &ast::Expr,\n-                              datum: Datum<Expr>,\n-                              k: &ty::UnsizeKind)\n-                              -> DatumBlock<'a, Expr> {\n+    fn unsize_unique_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                      expr: &ast::Expr,\n+                                      datum: Datum<Expr>,\n+                                      k: &ty::UnsizeKind)\n+                                      -> DatumBlock<'blk, 'tcx, Expr> {\n         let mut bcx = bcx;\n         let tcx = bcx.tcx();\n \n@@ -475,10 +475,10 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         DatumBlock::new(bcx, scratch.to_expr_datum())\n     }\n \n-    fn add_env<'a>(bcx: &'a Block<'a>,\n-                   expr: &ast::Expr,\n-                   datum: Datum<Expr>)\n-                   -> DatumBlock<'a, Expr> {\n+    fn add_env<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                           expr: &ast::Expr,\n+                           datum: Datum<Expr>)\n+                           -> DatumBlock<'blk, 'tcx, Expr> {\n         // This is not the most efficient thing possible; since closures\n         // are two words it'd be better if this were compiled in\n         // 'dest' mode, but I can't find a nice way to structure the\n@@ -492,10 +492,10 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-pub fn trans_to_lvalue<'a>(bcx: &'a Block<'a>,\n-                           expr: &ast::Expr,\n-                           name: &str)\n-                           -> DatumBlock<'a, Lvalue> {\n+pub fn trans_to_lvalue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   expr: &ast::Expr,\n+                                   name: &str)\n+                                   -> DatumBlock<'blk, 'tcx, Lvalue> {\n     /*!\n      * Translates an expression in \"lvalue\" mode -- meaning that it\n      * returns a reference to the memory that the expr represents.\n@@ -512,9 +512,9 @@ pub fn trans_to_lvalue<'a>(bcx: &'a Block<'a>,\n     return datum.to_lvalue_datum(bcx, name, expr.id);\n }\n \n-fn trans_unadjusted<'a>(bcx: &'a Block<'a>,\n-                        expr: &ast::Expr)\n-                        -> DatumBlock<'a, Expr> {\n+fn trans_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                expr: &ast::Expr)\n+                                -> DatumBlock<'blk, 'tcx, Expr> {\n     /*!\n      * A version of `trans` that ignores adjustments. You almost\n      * certainly do not want to call this directly.\n@@ -568,16 +568,17 @@ fn trans_unadjusted<'a>(bcx: &'a Block<'a>,\n         }\n     };\n \n-    fn nil<'a>(bcx: &'a Block<'a>, ty: ty::t) -> DatumBlock<'a, Expr> {\n+    fn nil<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ty: ty::t)\n+                       -> DatumBlock<'blk, 'tcx, Expr> {\n         let llval = C_undef(type_of::type_of(bcx.ccx(), ty));\n         let datum = immediate_rvalue(llval, ty);\n         DatumBlock::new(bcx, datum.to_expr_datum())\n     }\n }\n \n-fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n-                              expr: &ast::Expr)\n-                              -> DatumBlock<'a, Expr> {\n+fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                      expr: &ast::Expr)\n+                                      -> DatumBlock<'blk, 'tcx, Expr> {\n     let mut bcx = bcx;\n     let fcx = bcx.fcx;\n     let _icx = push_ctxt(\"trans_datum_unadjusted\");\n@@ -665,10 +666,10 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-fn trans_rec_field<'a>(bcx: &'a Block<'a>,\n-                       base: &ast::Expr,\n-                       field: ast::Ident)\n-                       -> DatumBlock<'a, Expr> {\n+fn trans_rec_field<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               base: &ast::Expr,\n+                               field: ast::Ident)\n+                               -> DatumBlock<'blk, 'tcx, Expr> {\n     //! Translates `base.field`.\n \n     let mut bcx = bcx;\n@@ -698,12 +699,12 @@ fn trans_rec_field<'a>(bcx: &'a Block<'a>,\n     })\n }\n \n-fn trans_index<'a>(bcx: &'a Block<'a>,\n-                   index_expr: &ast::Expr,\n-                   base: &ast::Expr,\n-                   idx: &ast::Expr,\n-                   method_call: MethodCall)\n-                   -> DatumBlock<'a, Expr> {\n+fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                           index_expr: &ast::Expr,\n+                           base: &ast::Expr,\n+                           idx: &ast::Expr,\n+                           method_call: MethodCall)\n+                           -> DatumBlock<'blk, 'tcx, Expr> {\n     //! Translates `base[idx]`.\n \n     let _icx = push_ctxt(\"trans_index\");\n@@ -803,11 +804,10 @@ fn trans_index<'a>(bcx: &'a Block<'a>,\n     DatumBlock::new(bcx, elt_datum)\n }\n \n-fn trans_def<'a>(bcx: &'a Block<'a>,\n-                 ref_expr: &ast::Expr,\n-                 def: def::Def)\n-                 -> DatumBlock<'a, Expr>\n-{\n+fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                         ref_expr: &ast::Expr,\n+                         def: def::Def)\n+                         -> DatumBlock<'blk, 'tcx, Expr> {\n     //! Translates a reference to a path.\n \n     let _icx = push_ctxt(\"trans_def_lvalue\");\n@@ -830,8 +830,8 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n             //     an external global, and return a pointer to that.\n             let const_ty = expr_ty(bcx, ref_expr);\n \n-            fn get_val<'a>(bcx: &'a Block<'a>, did: ast::DefId, const_ty: ty::t)\n-                       -> ValueRef {\n+            fn get_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, did: ast::DefId, const_ty: ty::t)\n+                                   -> ValueRef {\n                 // For external constants, we don't inline.\n                 if did.krate == ast::LOCAL_CRATE {\n                     // Case 1 or 2.  (The inlining in case 2 produces a new\n@@ -880,9 +880,9 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-fn trans_rvalue_stmt_unadjusted<'a>(bcx: &'a Block<'a>,\n-                                    expr: &ast::Expr)\n-                                    -> &'a Block<'a> {\n+fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                            expr: &ast::Expr)\n+                                            -> Block<'blk, 'tcx> {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_rvalue_stmt\");\n \n@@ -961,10 +961,10 @@ fn trans_rvalue_stmt_unadjusted<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n-                                   expr: &ast::Expr,\n-                                   dest: Dest)\n-                                   -> &'a Block<'a> {\n+fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                           expr: &ast::Expr,\n+                                           dest: Dest)\n+                                           -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_rvalue_dps_unadjusted\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx();\n@@ -1091,12 +1091,11 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-fn trans_def_dps_unadjusted<'a>(\n-                            bcx: &'a Block<'a>,\n-                            ref_expr: &ast::Expr,\n-                            def: def::Def,\n-                            dest: Dest)\n-                            -> &'a Block<'a> {\n+fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                        ref_expr: &ast::Expr,\n+                                        def: def::Def,\n+                                        dest: Dest)\n+                                        -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_def_dps_unadjusted\");\n \n     let lldest = match dest {\n@@ -1140,9 +1139,10 @@ fn trans_def_dps_unadjusted<'a>(\n     }\n }\n \n-fn trans_def_fn_unadjusted<'a>(bcx: &'a Block<'a>,\n-                               ref_expr: &ast::Expr,\n-                               def: def::Def) -> DatumBlock<'a, Expr> {\n+fn trans_def_fn_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                       ref_expr: &ast::Expr,\n+                                       def: def::Def)\n+                                       -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n \n     let llfn = match def {\n@@ -1167,9 +1167,9 @@ fn trans_def_fn_unadjusted<'a>(bcx: &'a Block<'a>,\n     DatumBlock::new(bcx, Datum::new(llfn, fn_ty, RvalueExpr(Rvalue::new(ByValue))))\n }\n \n-pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n-                           def: def::Def)\n-                           -> Datum<Lvalue> {\n+pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   def: def::Def)\n+                                   -> Datum<Lvalue> {\n     /*!\n      * Translates a reference to a local variable or argument.\n      * This always results in an lvalue datum.\n@@ -1203,10 +1203,10 @@ pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n         }\n     };\n \n-    fn take_local<'a>(bcx: &'a Block<'a>,\n-                      table: &NodeMap<Datum<Lvalue>>,\n-                      nid: ast::NodeId)\n-                      -> Datum<Lvalue> {\n+    fn take_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              table: &NodeMap<Datum<Lvalue>>,\n+                              nid: ast::NodeId)\n+                              -> Datum<Lvalue> {\n         let datum = match table.find(&nid) {\n             Some(&v) => v,\n             None => {\n@@ -1275,12 +1275,12 @@ pub fn with_field_tys<R>(tcx: &ty::ctxt,\n     }\n }\n \n-fn trans_struct<'a>(bcx: &'a Block<'a>,\n-                    fields: &[ast::Field],\n-                    base: Option<Gc<ast::Expr>>,\n-                    expr_span: codemap::Span,\n-                    id: ast::NodeId,\n-                    dest: Dest) -> &'a Block<'a> {\n+fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                            fields: &[ast::Field],\n+                            base: Option<Gc<ast::Expr>>,\n+                            expr_span: codemap::Span,\n+                            id: ast::NodeId,\n+                            dest: Dest) -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_rec\");\n \n     let ty = node_id_type(bcx, id);\n@@ -1350,12 +1350,12 @@ pub struct StructBaseInfo {\n  * - `optbase` contains information on the base struct (if any) from\n  * which remaining fields are copied; see comments on `StructBaseInfo`.\n  */\n-pub fn trans_adt<'a>(mut bcx: &'a Block<'a>,\n-                     ty: ty::t,\n-                     discr: ty::Disr,\n-                     fields: &[(uint, Gc<ast::Expr>)],\n-                     optbase: Option<StructBaseInfo>,\n-                     dest: Dest) -> &'a Block<'a> {\n+pub fn trans_adt<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                             ty: ty::t,\n+                             discr: ty::Disr,\n+                             fields: &[(uint, Gc<ast::Expr>)],\n+                             optbase: Option<StructBaseInfo>,\n+                             dest: Dest) -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_adt\");\n     let fcx = bcx.fcx;\n     let repr = adt::represent_type(bcx.ccx(), ty);\n@@ -1419,22 +1419,22 @@ pub fn trans_adt<'a>(mut bcx: &'a Block<'a>,\n }\n \n \n-fn trans_immediate_lit<'a>(bcx: &'a Block<'a>,\n-                           expr: &ast::Expr,\n-                           lit: ast::Lit)\n-                           -> DatumBlock<'a, Expr> {\n+fn trans_immediate_lit<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   expr: &ast::Expr,\n+                                   lit: ast::Lit)\n+                                   -> DatumBlock<'blk, 'tcx, Expr> {\n     // must not be a string constant, that is a RvalueDpsExpr\n     let _icx = push_ctxt(\"trans_immediate_lit\");\n     let ty = expr_ty(bcx, expr);\n     let v = consts::const_lit(bcx.ccx(), expr, lit);\n     immediate_rvalue_bcx(bcx, v, ty).to_expr_datumblock()\n }\n \n-fn trans_unary<'a>(bcx: &'a Block<'a>,\n-                   expr: &ast::Expr,\n-                   op: ast::UnOp,\n-                   sub_expr: &ast::Expr)\n-                   -> DatumBlock<'a, Expr> {\n+fn trans_unary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                           expr: &ast::Expr,\n+                           op: ast::UnOp,\n+                           sub_expr: &ast::Expr)\n+                           -> DatumBlock<'blk, 'tcx, Expr> {\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_unary_datum\");\n@@ -1481,11 +1481,11 @@ fn trans_unary<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-fn trans_uniq_expr<'a>(bcx: &'a Block<'a>,\n-                       box_ty: ty::t,\n-                       contents: &ast::Expr,\n-                       contents_ty: ty::t)\n-                        -> DatumBlock<'a, Expr> {\n+fn trans_uniq_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               box_ty: ty::t,\n+                               contents: &ast::Expr,\n+                               contents_ty: ty::t)\n+                               -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_uniq_expr\");\n     let fcx = bcx.fcx;\n     assert!(ty::type_is_sized(bcx.tcx(), contents_ty));\n@@ -1510,11 +1510,11 @@ fn trans_uniq_expr<'a>(bcx: &'a Block<'a>,\n     immediate_rvalue_bcx(bcx, val, box_ty).to_expr_datumblock()\n }\n \n-fn trans_managed_expr<'a>(bcx: &'a Block<'a>,\n-                          box_ty: ty::t,\n-                          contents: &ast::Expr,\n-                          contents_ty: ty::t)\n-                          -> DatumBlock<'a, Expr> {\n+fn trans_managed_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                  box_ty: ty::t,\n+                                  contents: &ast::Expr,\n+                                  contents_ty: ty::t)\n+                                  -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_managed_expr\");\n     let fcx = bcx.fcx;\n     let ty = type_of::type_of(bcx.ccx(), contents_ty);\n@@ -1530,10 +1530,10 @@ fn trans_managed_expr<'a>(bcx: &'a Block<'a>,\n     immediate_rvalue_bcx(bcx, bx, box_ty).to_expr_datumblock()\n }\n \n-fn trans_addr_of<'a>(bcx: &'a Block<'a>,\n-                     expr: &ast::Expr,\n-                     subexpr: &ast::Expr)\n-                     -> DatumBlock<'a, Expr> {\n+fn trans_addr_of<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             expr: &ast::Expr,\n+                             subexpr: &ast::Expr)\n+                             -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_addr_of\");\n     let mut bcx = bcx;\n     let sub_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, subexpr, \"addr_of\"));\n@@ -1563,16 +1563,15 @@ fn trans_addr_of<'a>(bcx: &'a Block<'a>,\n \n // Important to get types for both lhs and rhs, because one might be _|_\n // and the other not.\n-fn trans_eager_binop<'a>(\n-                     bcx: &'a Block<'a>,\n-                     binop_expr: &ast::Expr,\n-                     binop_ty: ty::t,\n-                     op: ast::BinOp,\n-                     lhs_t: ty::t,\n-                     lhs: ValueRef,\n-                     rhs_t: ty::t,\n-                     rhs: ValueRef)\n-                     -> DatumBlock<'a, Expr> {\n+fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 binop_expr: &ast::Expr,\n+                                 binop_ty: ty::t,\n+                                 op: ast::BinOp,\n+                                 lhs_t: ty::t,\n+                                 lhs: ValueRef,\n+                                 rhs_t: ty::t,\n+                                 rhs: ValueRef)\n+                                 -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_eager_binop\");\n \n     let tcx = bcx.tcx();\n@@ -1663,13 +1662,12 @@ enum lazy_binop_ty {\n     lazy_or,\n }\n \n-fn trans_lazy_binop<'a>(\n-                    bcx: &'a Block<'a>,\n-                    binop_expr: &ast::Expr,\n-                    op: lazy_binop_ty,\n-                    a: &ast::Expr,\n-                    b: &ast::Expr)\n-                    -> DatumBlock<'a, Expr> {\n+fn trans_lazy_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                binop_expr: &ast::Expr,\n+                                op: lazy_binop_ty,\n+                                a: &ast::Expr,\n+                                b: &ast::Expr)\n+                                -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_lazy_binop\");\n     let binop_ty = expr_ty(bcx, binop_expr);\n     let fcx = bcx.fcx;\n@@ -1703,12 +1701,12 @@ fn trans_lazy_binop<'a>(\n     return immediate_rvalue_bcx(join, phi, binop_ty).to_expr_datumblock();\n }\n \n-fn trans_binary<'a>(bcx: &'a Block<'a>,\n-                    expr: &ast::Expr,\n-                    op: ast::BinOp,\n-                    lhs: &ast::Expr,\n-                    rhs: &ast::Expr)\n-                    -> DatumBlock<'a, Expr> {\n+fn trans_binary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                            expr: &ast::Expr,\n+                            op: ast::BinOp,\n+                            lhs: &ast::Expr,\n+                            rhs: &ast::Expr)\n+                            -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_binary\");\n     let ccx = bcx.ccx();\n \n@@ -1745,14 +1743,13 @@ fn trans_binary<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-fn trans_overloaded_op<'a, 'b>(\n-                       bcx: &'a Block<'a>,\n-                       expr: &ast::Expr,\n-                       method_call: MethodCall,\n-                       lhs: Datum<Expr>,\n-                       rhs: Option<(Datum<Expr>, ast::NodeId)>,\n-                       dest: Option<Dest>)\n-                       -> Result<'a> {\n+fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   expr: &ast::Expr,\n+                                   method_call: MethodCall,\n+                                   lhs: Datum<Expr>,\n+                                   rhs: Option<(Datum<Expr>, ast::NodeId)>,\n+                                   dest: Option<Dest>)\n+                                   -> Result<'blk, 'tcx> {\n     let method_ty = bcx.tcx().method_map.borrow().get(&method_call).ty;\n     callee::trans_call_inner(bcx,\n                              Some(expr_info(expr)),\n@@ -1767,13 +1764,12 @@ fn trans_overloaded_op<'a, 'b>(\n                              dest)\n }\n \n-fn trans_overloaded_call<'a>(\n-                         mut bcx: &'a Block<'a>,\n-                         expr: &ast::Expr,\n-                         callee: Gc<ast::Expr>,\n-                         args: &[Gc<ast::Expr>],\n-                         dest: Option<Dest>)\n-                         -> &'a Block<'a> {\n+fn trans_overloaded_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                     expr: &ast::Expr,\n+                                     callee: Gc<ast::Expr>,\n+                                     args: &[Gc<ast::Expr>],\n+                                     dest: Option<Dest>)\n+                                     -> Block<'blk, 'tcx> {\n     let method_call = MethodCall::expr(expr.id);\n     let method_type = bcx.tcx()\n                          .method_map\n@@ -1800,7 +1796,7 @@ fn trans_overloaded_call<'a>(\n     bcx\n }\n \n-fn int_cast(bcx: &Block,\n+fn int_cast(bcx: Block,\n             lldsttype: Type,\n             llsrctype: Type,\n             llsrc: ValueRef,\n@@ -1822,7 +1818,7 @@ fn int_cast(bcx: &Block,\n     }\n }\n \n-fn float_cast(bcx: &Block,\n+fn float_cast(bcx: Block,\n               lldsttype: Type,\n               llsrctype: Type,\n               llsrc: ValueRef)\n@@ -1879,10 +1875,10 @@ fn cast_is_noop(t_in: ty::t, t_out: ty::t) -> bool {\n     }\n }\n \n-fn trans_imm_cast<'a>(bcx: &'a Block<'a>,\n-                      expr: &ast::Expr,\n-                      id: ast::NodeId)\n-                      -> DatumBlock<'a, Expr> {\n+fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              expr: &ast::Expr,\n+                              id: ast::NodeId)\n+                              -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_cast\");\n     let mut bcx = bcx;\n     let ccx = bcx.ccx();\n@@ -1971,13 +1967,12 @@ fn trans_imm_cast<'a>(bcx: &'a Block<'a>,\n     return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n }\n \n-fn trans_assign_op<'a>(\n-                   bcx: &'a Block<'a>,\n-                   expr: &ast::Expr,\n-                   op: ast::BinOp,\n-                   dst: &ast::Expr,\n-                   src: Gc<ast::Expr>)\n-                   -> &'a Block<'a> {\n+fn trans_assign_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               expr: &ast::Expr,\n+                               op: ast::BinOp,\n+                               dst: &ast::Expr,\n+                               src: Gc<ast::Expr>)\n+                               -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_assign_op\");\n     let mut bcx = bcx;\n \n@@ -2004,10 +1999,10 @@ fn trans_assign_op<'a>(\n     return result_datum.store_to(bcx, dst_datum.val);\n }\n \n-fn auto_ref<'a>(bcx: &'a Block<'a>,\n-                datum: Datum<Expr>,\n-                expr: &ast::Expr)\n-                -> DatumBlock<'a, Expr> {\n+fn auto_ref<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                        datum: Datum<Expr>,\n+                        expr: &ast::Expr)\n+                        -> DatumBlock<'blk, 'tcx, Expr> {\n     let mut bcx = bcx;\n \n     // Ensure cleanup of `datum` if not already scheduled and obtain\n@@ -2028,11 +2023,11 @@ fn auto_ref<'a>(bcx: &'a Block<'a>,\n     DatumBlock::new(bcx, Datum::new(llref, ptr_ty, RvalueExpr(Rvalue::new(ByValue))))\n }\n \n-fn deref_multiple<'a>(bcx: &'a Block<'a>,\n-                      expr: &ast::Expr,\n-                      datum: Datum<Expr>,\n-                      times: uint)\n-                      -> DatumBlock<'a, Expr> {\n+fn deref_multiple<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              expr: &ast::Expr,\n+                              datum: Datum<Expr>,\n+                              times: uint)\n+                              -> DatumBlock<'blk, 'tcx, Expr> {\n     let mut bcx = bcx;\n     let mut datum = datum;\n     for i in range(0, times) {\n@@ -2042,11 +2037,11 @@ fn deref_multiple<'a>(bcx: &'a Block<'a>,\n     DatumBlock { bcx: bcx, datum: datum }\n }\n \n-fn deref_once<'a>(bcx: &'a Block<'a>,\n-                  expr: &ast::Expr,\n-                  datum: Datum<Expr>,\n-                  method_call: MethodCall)\n-                  -> DatumBlock<'a, Expr> {\n+fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                          expr: &ast::Expr,\n+                          datum: Datum<Expr>,\n+                          method_call: MethodCall)\n+                          -> DatumBlock<'blk, 'tcx, Expr> {\n     let ccx = bcx.ccx();\n \n     debug!(\"deref_once(expr={}, datum={}, method_call={})\",\n@@ -2146,11 +2141,11 @@ fn deref_once<'a>(bcx: &'a Block<'a>,\n \n     return r;\n \n-    fn deref_owned_pointer<'a>(bcx: &'a Block<'a>,\n-                               expr: &ast::Expr,\n-                               datum: Datum<Expr>,\n-                               content_ty: ty::t)\n-                               -> DatumBlock<'a, Expr> {\n+    fn deref_owned_pointer<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                       expr: &ast::Expr,\n+                                       datum: Datum<Expr>,\n+                                       content_ty: ty::t)\n+                                       -> DatumBlock<'blk, 'tcx, Expr> {\n         /*!\n          * We microoptimize derefs of owned pointers a bit here.\n          * Basically, the idea is to make the deref of an rvalue"}, {"sha": "2cb8c86094496ad253a818d6e1711fb86b27c317", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=f7a997be05e364248521ee4d11ab57fcb2e99a40", "patch": "@@ -247,14 +247,13 @@ pub fn register_foreign_item_fn(ccx: &CrateContext, abi: Abi, fty: ty::t,\n     llfn\n }\n \n-pub fn trans_native_call<'a>(\n-                         bcx: &'a Block<'a>,\n-                         callee_ty: ty::t,\n-                         llfn: ValueRef,\n-                         llretptr: ValueRef,\n-                         llargs_rust: &[ValueRef],\n-                         passed_arg_tys: Vec<ty::t> )\n-                         -> &'a Block<'a> {\n+pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                     callee_ty: ty::t,\n+                                     llfn: ValueRef,\n+                                     llretptr: ValueRef,\n+                                     llargs_rust: &[ValueRef],\n+                                     passed_arg_tys: Vec<ty::t> )\n+                                     -> Block<'blk, 'tcx> {\n     /*!\n      * Prepares a call to a native function. This requires adapting\n      * from the Rust argument passing rules to the native rules."}, {"sha": "259f85098afee14ff9feec007d8f8b569c5c3b51", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 42, "deletions": 39, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=f7a997be05e364248521ee4d11ab57fcb2e99a40", "patch": "@@ -45,16 +45,18 @@ use libc::c_uint;\n use syntax::ast;\n use syntax::parse::token;\n \n-pub fn trans_free<'a>(cx: &'a Block<'a>, v: ValueRef) -> &'a Block<'a> {\n+pub fn trans_free<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef)\n+                              -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_free\");\n     callee::trans_lang_call(cx,\n         langcall(cx, None, \"\", FreeFnLangItem),\n         [PointerCast(cx, v, Type::i8p(cx.ccx()))],\n         Some(expr::Ignore)).bcx\n }\n \n-pub fn trans_exchange_free_dyn<'a>(cx: &'a Block<'a>, v: ValueRef, size: ValueRef,\n-                               align: ValueRef) -> &'a Block<'a> {\n+pub fn trans_exchange_free_dyn<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef,\n+                                           size: ValueRef, align: ValueRef)\n+                                           -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_exchange_free\");\n     let ccx = cx.ccx();\n     callee::trans_lang_call(cx,\n@@ -63,14 +65,14 @@ pub fn trans_exchange_free_dyn<'a>(cx: &'a Block<'a>, v: ValueRef, size: ValueRe\n         Some(expr::Ignore)).bcx\n }\n \n-pub fn trans_exchange_free<'a>(cx: &'a Block<'a>, v: ValueRef, size: u64,\n-                               align: u64) -> &'a Block<'a> {\n+pub fn trans_exchange_free<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef,\n+                                       size: u64, align: u64) -> Block<'blk, 'tcx> {\n     trans_exchange_free_dyn(cx, v, C_uint(cx.ccx(), size as uint),\n                             C_uint(cx.ccx(), align as uint))\n }\n \n-pub fn trans_exchange_free_ty<'a>(bcx: &'a Block<'a>, ptr: ValueRef,\n-                                  content_ty: ty::t) -> &'a Block<'a> {\n+pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ptr: ValueRef,\n+                                          content_ty: ty::t) -> Block<'blk, 'tcx> {\n     assert!(ty::type_is_sized(bcx.ccx().tcx(), content_ty));\n     let sizing_type = sizing_type_of(bcx.ccx(), content_ty);\n     let content_size = llsize_of_alloc(bcx.ccx(), sizing_type);\n@@ -84,8 +86,8 @@ pub fn trans_exchange_free_ty<'a>(bcx: &'a Block<'a>, ptr: ValueRef,\n     }\n }\n \n-pub fn take_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n-               -> &'a Block<'a> {\n+pub fn take_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v: ValueRef, t: ty::t)\n+                           -> Block<'blk, 'tcx> {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"take_ty\");\n     match ty::get(t).sty {\n@@ -123,8 +125,8 @@ pub fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n     }\n }\n \n-pub fn drop_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n-               -> &'a Block<'a> {\n+pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v: ValueRef, t: ty::t)\n+                           -> Block<'blk, 'tcx> {\n     // NB: v is an *alias* of type t here, not a direct value.\n     debug!(\"drop_ty(t={})\", t.repr(bcx.tcx()));\n     let _icx = push_ctxt(\"drop_ty\");\n@@ -142,8 +144,8 @@ pub fn drop_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n     bcx\n }\n \n-pub fn drop_ty_immediate<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n-                         -> &'a Block<'a> {\n+pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v: ValueRef, t: ty::t)\n+                                     -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n     let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n     Store(bcx, v, vp);\n@@ -232,7 +234,7 @@ pub fn lazily_emit_visit_glue(ccx: &CrateContext, ti: &tydesc_info) -> ValueRef\n }\n \n // See [Note-arg-mode]\n-pub fn call_visit_glue(bcx: &Block, v: ValueRef, tydesc: ValueRef) {\n+pub fn call_visit_glue(bcx: Block, v: ValueRef, tydesc: ValueRef) {\n     let _icx = push_ctxt(\"call_visit_glue\");\n \n     // Select the glue function to call from the tydesc\n@@ -242,8 +244,8 @@ pub fn call_visit_glue(bcx: &Block, v: ValueRef, tydesc: ValueRef) {\n     Call(bcx, llfn, [llrawptr], None);\n }\n \n-fn make_visit_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n-                   -> &'a Block<'a> {\n+fn make_visit_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v: ValueRef, t: ty::t)\n+                               -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"make_visit_glue\");\n     let mut bcx = bcx;\n     let (visitor_trait, object_ty) = match ty::visitor_object_ty(bcx.tcx(),\n@@ -259,13 +261,13 @@ fn make_visit_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n     bcx\n }\n \n-fn trans_struct_drop_flag<'a>(mut bcx: &'a Block<'a>,\n-                              t: ty::t,\n-                              v0: ValueRef,\n-                              dtor_did: ast::DefId,\n-                              class_did: ast::DefId,\n-                              substs: &subst::Substs)\n-                              -> &'a Block<'a> {\n+fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                      t: ty::t,\n+                                      v0: ValueRef,\n+                                      dtor_did: ast::DefId,\n+                                      class_did: ast::DefId,\n+                                      substs: &subst::Substs)\n+                                      -> Block<'blk, 'tcx> {\n     let repr = adt::represent_type(bcx.ccx(), t);\n     let struct_data = if ty::type_is_sized(bcx.tcx(), t) {\n         v0\n@@ -279,13 +281,13 @@ fn trans_struct_drop_flag<'a>(mut bcx: &'a Block<'a>,\n     })\n }\n \n-fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n-                         t: ty::t,\n-                         v0: ValueRef,\n-                         dtor_did: ast::DefId,\n-                         class_did: ast::DefId,\n-                         substs: &subst::Substs)\n-                         -> &'a Block<'a> {\n+fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 t: ty::t,\n+                                 v0: ValueRef,\n+                                 dtor_did: ast::DefId,\n+                                 class_did: ast::DefId,\n+                                 substs: &subst::Substs)\n+                                 -> Block<'blk, 'tcx> {\n     let repr = adt::represent_type(bcx.ccx(), t);\n \n     // Find and call the actual destructor\n@@ -371,7 +373,7 @@ fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n     })\n }\n \n-fn size_and_align_of_dst<'a>(bcx: &'a Block<'a>, t :ty::t, info: ValueRef) -> (ValueRef, ValueRef) {\n+fn size_and_align_of_dst(bcx: Block, t :ty::t, info: ValueRef) -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {}\",\n            bcx.ty_to_string(t), bcx.val_to_string(info));\n     if ty::type_is_sized(bcx.tcx(), t) {\n@@ -426,7 +428,8 @@ fn size_and_align_of_dst<'a>(bcx: &'a Block<'a>, t :ty::t, info: ValueRef) -> (V\n     }\n }\n \n-fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'a> {\n+fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: ty::t)\n+                              -> Block<'blk, 'tcx> {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n     match ty::get(t).sty {\n@@ -549,9 +552,9 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n     }\n }\n \n-fn decr_refcnt_maybe_free<'a>(bcx: &'a Block<'a>,\n-                              box_ptr_ptr: ValueRef,\n-                              t: ty::t) -> &'a Block<'a> {\n+fn decr_refcnt_maybe_free<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                      box_ptr_ptr: ValueRef,\n+                                      t: ty::t) -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"decr_refcnt_maybe_free\");\n     let fcx = bcx.fcx;\n     let ccx = bcx.ccx();\n@@ -578,8 +581,8 @@ fn decr_refcnt_maybe_free<'a>(bcx: &'a Block<'a>,\n     next_bcx\n }\n \n-fn incr_refcnt_of_boxed<'a>(bcx: &'a Block<'a>,\n-                            box_ptr_ptr: ValueRef) -> &'a Block<'a> {\n+fn incr_refcnt_of_boxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    box_ptr_ptr: ValueRef) -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"incr_refcnt_of_boxed\");\n     let ccx = bcx.ccx();\n     let box_ptr = Load(bcx, box_ptr_ptr);\n@@ -645,8 +648,8 @@ fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n fn make_generic_glue(ccx: &CrateContext,\n                      t: ty::t,\n                      llfn: ValueRef,\n-                     helper: <'a> |&'a Block<'a>, ValueRef, ty::t|\n-                                  -> &'a Block<'a>,\n+                     helper: <'blk, 'tcx> |Block<'blk, 'tcx>, ValueRef, ty::t|\n+                                           -> Block<'blk, 'tcx>,\n                      name: &str)\n                      -> ValueRef {\n     let _icx = push_ctxt(\"make_generic_glue\");"}, {"sha": "36184b2eed37e3156a10f7ce5f677ad2e4340bbf", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=f7a997be05e364248521ee4d11ab57fcb2e99a40", "patch": "@@ -134,10 +134,11 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n     ccx.sess().abort_if_errors();\n }\n \n-pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n-                                callee_ty: ty::t, cleanup_scope: cleanup::CustomScopeIndex,\n-                                args: callee::CallArgs, dest: expr::Dest,\n-                                substs: subst::Substs, call_info: NodeInfo) -> Result<'a> {\n+pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::NodeId,\n+                                        callee_ty: ty::t, cleanup_scope: cleanup::CustomScopeIndex,\n+                                        args: callee::CallArgs, dest: expr::Dest,\n+                                        substs: subst::Substs, call_info: NodeInfo)\n+                                        -> Result<'blk, 'tcx> {\n \n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n@@ -548,7 +549,7 @@ pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n     Result::new(bcx, llresult)\n }\n \n-fn copy_intrinsic(bcx: &Block, allow_overlap: bool, volatile: bool,\n+fn copy_intrinsic(bcx: Block, allow_overlap: bool, volatile: bool,\n                   tp_ty: ty::t, dst: ValueRef, src: ValueRef, count: ValueRef) -> ValueRef {\n     let ccx = bcx.ccx();\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n@@ -577,7 +578,7 @@ fn copy_intrinsic(bcx: &Block, allow_overlap: bool, volatile: bool,\n                      C_bool(ccx, volatile)], None)\n }\n \n-fn memset_intrinsic(bcx: &Block, volatile: bool, tp_ty: ty::t,\n+fn memset_intrinsic(bcx: Block, volatile: bool, tp_ty: ty::t,\n                     dst: ValueRef, val: ValueRef, count: ValueRef) -> ValueRef {\n     let ccx = bcx.ccx();\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n@@ -596,13 +597,13 @@ fn memset_intrinsic(bcx: &Block, volatile: bool, tp_ty: ty::t,\n                      C_bool(ccx, volatile)], None)\n }\n \n-fn count_zeros_intrinsic(bcx: &Block, name: &'static str, val: ValueRef) -> ValueRef {\n+fn count_zeros_intrinsic(bcx: Block, name: &'static str, val: ValueRef) -> ValueRef {\n     let y = C_bool(bcx.ccx(), false);\n     let llfn = bcx.ccx().get_intrinsic(&name);\n     Call(bcx, llfn, [val, y], None)\n }\n \n-fn with_overflow_intrinsic(bcx: &Block, name: &'static str, t: ty::t,\n+fn with_overflow_intrinsic(bcx: Block, name: &'static str, t: ty::t,\n                            a: ValueRef, b: ValueRef) -> ValueRef {\n     let llfn = bcx.ccx().get_intrinsic(&name);\n "}, {"sha": "fb1a764f0fce51eefb7051e7eeeac44cf3791017", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=f7a997be05e364248521ee4d11ab57fcb2e99a40", "patch": "@@ -102,12 +102,11 @@ pub fn trans_impl(ccx: &CrateContext,\n     }\n }\n \n-pub fn trans_method_callee<'a>(\n-                           bcx: &'a Block<'a>,\n-                           method_call: MethodCall,\n-                           self_expr: Option<&ast::Expr>,\n-                           arg_cleanup_scope: cleanup::ScopeId)\n-                           -> Callee<'a> {\n+pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                       method_call: MethodCall,\n+                                       self_expr: Option<&ast::Expr>,\n+                                       arg_cleanup_scope: cleanup::ScopeId)\n+                                       -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_method_callee\");\n \n     let (origin, method_ty) = match bcx.tcx().method_map\n@@ -166,7 +165,7 @@ pub fn trans_method_callee<'a>(\n     }\n }\n \n-pub fn trans_static_method_callee(bcx: &Block,\n+pub fn trans_static_method_callee(bcx: Block,\n                                   method_id: ast::DefId,\n                                   trait_id: ast::DefId,\n                                   expr_id: ast::NodeId)\n@@ -262,13 +261,12 @@ fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n     meth_did.def_id()\n }\n \n-fn trans_monomorphized_callee<'a>(\n-                              bcx: &'a Block<'a>,\n-                              method_call: MethodCall,\n-                              trait_id: ast::DefId,\n-                              n_method: uint,\n-                              vtbl: typeck::vtable_origin)\n-                              -> Callee<'a> {\n+fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                          method_call: MethodCall,\n+                                          trait_id: ast::DefId,\n+                                          n_method: uint,\n+                                          vtbl: typeck::vtable_origin)\n+                                          -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_monomorphized_callee\");\n     match vtbl {\n       typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n@@ -324,7 +322,7 @@ fn trans_monomorphized_callee<'a>(\n     }\n }\n \n-fn combine_impl_and_methods_tps(bcx: &Block,\n+fn combine_impl_and_methods_tps(bcx: Block,\n                                 node: ExprOrMethodCall,\n                                 rcvr_substs: subst::Substs,\n                                 rcvr_origins: typeck::vtable_res)\n@@ -378,12 +376,12 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n     (ty_substs, vtables)\n }\n \n-fn trans_trait_callee<'a>(bcx: &'a Block<'a>,\n-                          method_ty: ty::t,\n-                          n_method: uint,\n-                          self_expr: &ast::Expr,\n-                          arg_cleanup_scope: cleanup::ScopeId)\n-                          -> Callee<'a> {\n+fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                  method_ty: ty::t,\n+                                  n_method: uint,\n+                                  self_expr: &ast::Expr,\n+                                  arg_cleanup_scope: cleanup::ScopeId)\n+                                  -> Callee<'blk, 'tcx> {\n     /*!\n      * Create a method callee where the method is coming from a trait\n      * object (e.g., Box<Trait> type).  In this case, we must pull the fn\n@@ -422,11 +420,11 @@ fn trans_trait_callee<'a>(bcx: &'a Block<'a>,\n     trans_trait_callee_from_llval(bcx, method_ty, n_method, llval)\n }\n \n-pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n-                                         callee_ty: ty::t,\n-                                         n_method: uint,\n-                                         llpair: ValueRef)\n-                                         -> Callee<'a> {\n+pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                                 callee_ty: ty::t,\n+                                                 n_method: uint,\n+                                                 llpair: ValueRef)\n+                                                 -> Callee<'blk, 'tcx> {\n     /*!\n      * Same as `trans_trait_callee()` above, except that it is given\n      * a by-ref pointer to the object pair.\n@@ -476,7 +474,7 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n /// Creates the self type and (fake) callee substitutions for an unboxed\n /// closure with the given def ID. The static region and type parameters are\n /// lies, but we're in trans so it doesn't matter.\n-fn get_callee_substitutions_for_unboxed_closure(bcx: &Block,\n+fn get_callee_substitutions_for_unboxed_closure(bcx: Block,\n                                                 def_id: ast::DefId)\n                                                 -> subst::Substs {\n     let self_ty = ty::mk_unboxed_closure(bcx.tcx(), def_id, ty::ReStatic);\n@@ -495,7 +493,7 @@ fn get_callee_substitutions_for_unboxed_closure(bcx: &Block,\n \n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n /// This is used only for objects.\n-fn get_vtable(bcx: &Block,\n+fn get_vtable(bcx: Block,\n               self_ty: ty::t,\n               origins: typeck::vtable_param_res)\n               -> ValueRef\n@@ -630,7 +628,7 @@ pub fn make_vtable<I: Iterator<ValueRef>>(ccx: &CrateContext,\n     }\n }\n \n-fn emit_vtable_methods(bcx: &Block,\n+fn emit_vtable_methods(bcx: Block,\n                        impl_id: ast::DefId,\n                        substs: subst::Substs,\n                        vtables: typeck::vtable_res)\n@@ -686,9 +684,9 @@ fn emit_vtable_methods(bcx: &Block,\n     }).collect()\n }\n \n-pub fn vtable_ptr<'a>(bcx: &'a Block<'a>,\n-                      id: ast::NodeId,\n-                      self_ty: ty::t) -> ValueRef {\n+pub fn vtable_ptr(bcx: Block,\n+                  id: ast::NodeId,\n+                  self_ty: ty::t) -> ValueRef {\n     let ccx = bcx.ccx();\n     let origins = {\n         let vtable_map = ccx.tcx().vtable_map.borrow();\n@@ -706,11 +704,11 @@ pub fn vtable_ptr<'a>(bcx: &'a Block<'a>,\n     get_vtable(bcx, self_ty, origins)\n }\n \n-pub fn trans_trait_cast<'a>(bcx: &'a Block<'a>,\n-                            datum: Datum<Expr>,\n-                            id: ast::NodeId,\n-                            dest: expr::Dest)\n-                            -> &'a Block<'a> {\n+pub fn trans_trait_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    datum: Datum<Expr>,\n+                                    id: ast::NodeId,\n+                                    dest: expr::Dest)\n+                                    -> Block<'blk, 'tcx> {\n     /*!\n      * Generates the code to convert from a pointer (`Box<T>`, `&T`, etc)\n      * into an object (`Box<Trait>`, `&Trait`, etc). This means creating a"}, {"sha": "214726edd778d0c14a40c1bee9050d22f78f5101", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=f7a997be05e364248521ee4d11ab57fcb2e99a40", "patch": "@@ -33,15 +33,15 @@ use syntax::ast_map;\n use syntax::parse::token::{InternedString, special_idents};\n use syntax::parse::token;\n \n-pub struct Reflector<'a, 'b> {\n+pub struct Reflector<'a, 'blk, 'tcx: 'blk> {\n     visitor_val: ValueRef,\n     visitor_items: &'a [ty::ImplOrTraitItem],\n-    final_bcx: &'b Block<'b>,\n+    final_bcx: Block<'blk, 'tcx>,\n     tydesc_ty: Type,\n-    bcx: &'b Block<'b>\n+    bcx: Block<'blk, 'tcx>\n }\n \n-impl<'a, 'b> Reflector<'a, 'b> {\n+impl<'a, 'blk, 'tcx> Reflector<'a, 'blk, 'tcx> {\n     pub fn c_uint(&mut self, u: uint) -> ValueRef {\n         C_uint(self.bcx.ccx(), u)\n     }\n@@ -419,12 +419,11 @@ impl<'a, 'b> Reflector<'a, 'b> {\n }\n \n // Emit a sequence of calls to visit_ty::visit_foo\n-pub fn emit_calls_to_trait_visit_ty<'a>(\n-                                    bcx: &'a Block<'a>,\n-                                    t: ty::t,\n-                                    visitor_val: ValueRef,\n-                                    visitor_trait_id: DefId)\n-                                    -> &'a Block<'a> {\n+pub fn emit_calls_to_trait_visit_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                                t: ty::t,\n+                                                visitor_val: ValueRef,\n+                                                visitor_trait_id: DefId)\n+                                                -> Block<'blk, 'tcx> {\n     let fcx = bcx.fcx;\n     let final = fcx.new_temp_block(\"final\");\n     let tydesc_ty = ty::get_tydesc_ty(bcx.tcx()).unwrap();"}, {"sha": "00b9977c7523ce46a47c750bfd5234a4bf47e4c6", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 52, "deletions": 60, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=f7a997be05e364248521ee4d11ab57fcb2e99a40", "patch": "@@ -35,29 +35,28 @@ use util::ppaux::ty_to_string;\n use syntax::ast;\n use syntax::parse::token::InternedString;\n \n-fn get_len(bcx: &Block, vptr: ValueRef) -> ValueRef {\n+fn get_len(bcx: Block, vptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::get_lenl\");\n     Load(bcx, expr::get_len(bcx, vptr))\n }\n \n-fn get_dataptr(bcx: &Block, vptr: ValueRef) -> ValueRef {\n+fn get_dataptr(bcx: Block, vptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::get_dataptr\");\n     Load(bcx, expr::get_dataptr(bcx, vptr))\n }\n \n-pub fn pointer_add_byte(bcx: &Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n+pub fn pointer_add_byte(bcx: Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::pointer_add_byte\");\n     let old_ty = val_ty(ptr);\n     let bptr = PointerCast(bcx, ptr, Type::i8p(bcx.ccx()));\n     return PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n-pub fn make_drop_glue_unboxed<'a>(\n-                              bcx: &'a Block<'a>,\n-                              vptr: ValueRef,\n-                              unit_ty: ty::t,\n-                              should_deallocate: bool)\n-                              -> &'a Block<'a> {\n+pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                          vptr: ValueRef,\n+                                          unit_ty: ty::t,\n+                                          should_deallocate: bool)\n+                                          -> Block<'blk, 'tcx> {\n     let not_null = IsNotNull(bcx, vptr);\n     with_cond(bcx, not_null, |bcx| {\n         let ccx = bcx.ccx();\n@@ -105,11 +104,10 @@ impl VecTypes {\n     }\n }\n \n-pub fn trans_fixed_vstore<'a>(\n-                          bcx: &'a Block<'a>,\n-                          expr: &ast::Expr,\n-                          dest: expr::Dest)\n-                          -> &'a Block<'a> {\n+pub fn trans_fixed_vstore<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                      expr: &ast::Expr,\n+                                      dest: expr::Dest)\n+                                      -> Block<'blk, 'tcx> {\n     //!\n     //\n     // [...] allocates a fixed-size array and moves it around \"by value\".\n@@ -133,10 +131,10 @@ pub fn trans_fixed_vstore<'a>(\n     };\n }\n \n-pub fn trans_slice_vec<'a>(bcx: &'a Block<'a>,\n-                           slice_expr: &ast::Expr,\n-                           content_expr: &ast::Expr)\n-                           -> DatumBlock<'a, Expr> {\n+pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   slice_expr: &ast::Expr,\n+                                   content_expr: &ast::Expr)\n+                                   -> DatumBlock<'blk, 'tcx, Expr> {\n     /*!\n      * &[...] allocates memory on the stack and writes the values into it,\n      * returning the vector (the caller must make the reference).  \"...\" is\n@@ -207,12 +205,11 @@ pub fn trans_slice_vec<'a>(bcx: &'a Block<'a>,\n     immediate_rvalue_bcx(bcx, llfixed, vec_ty).to_expr_datumblock()\n }\n \n-pub fn trans_lit_str<'a>(\n-                     bcx: &'a Block<'a>,\n-                     lit_expr: &ast::Expr,\n-                     str_lit: InternedString,\n-                     dest: Dest)\n-                     -> &'a Block<'a> {\n+pub fn trans_lit_str<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 lit_expr: &ast::Expr,\n+                                 str_lit: InternedString,\n+                                 dest: Dest)\n+                                 -> Block<'blk, 'tcx> {\n     /*!\n      * Literal strings translate to slices into static memory.  This is\n      * different from trans_slice_vstore() above because it doesn't need to copy\n@@ -239,10 +236,10 @@ pub fn trans_lit_str<'a>(\n     }\n }\n \n-pub fn trans_uniq_vec<'a>(bcx: &'a Block<'a>,\n-                          uniq_expr: &ast::Expr,\n-                          content_expr: &ast::Expr)\n-                          -> DatumBlock<'a, Expr> {\n+pub fn trans_uniq_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                  uniq_expr: &ast::Expr,\n+                                  content_expr: &ast::Expr)\n+                                  -> DatumBlock<'blk, 'tcx, Expr> {\n     /*!\n      * Box<[...]> and \"...\".to_string() allocate boxes in the exchange heap and write\n      * the array elements into them.\n@@ -327,13 +324,12 @@ pub fn trans_uniq_vec<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-pub fn write_content<'a>(\n-                     bcx: &'a Block<'a>,\n-                     vt: &VecTypes,\n-                     vstore_expr: &ast::Expr,\n-                     content_expr: &ast::Expr,\n-                     dest: Dest)\n-                     -> &'a Block<'a> {\n+pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 vt: &VecTypes,\n+                                 vstore_expr: &ast::Expr,\n+                                 content_expr: &ast::Expr,\n+                                 dest: Dest)\n+                                 -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"tvec::write_content\");\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n@@ -429,12 +425,12 @@ pub fn write_content<'a>(\n     }\n }\n \n-pub fn vec_types_from_expr(bcx: &Block, vec_expr: &ast::Expr) -> VecTypes {\n+pub fn vec_types_from_expr(bcx: Block, vec_expr: &ast::Expr) -> VecTypes {\n     let vec_ty = node_id_type(bcx, vec_expr.id);\n     vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty))\n }\n \n-pub fn vec_types(bcx: &Block, unit_ty: ty::t) -> VecTypes {\n+pub fn vec_types(bcx: Block, unit_ty: ty::t) -> VecTypes {\n     let ccx = bcx.ccx();\n     let llunit_ty = type_of::type_of(ccx, unit_ty);\n     let llunit_size = nonzero_llsize_of(ccx, llunit_ty);\n@@ -448,7 +444,7 @@ pub fn vec_types(bcx: &Block, unit_ty: ty::t) -> VecTypes {\n     }\n }\n \n-pub fn elements_required(bcx: &Block, content_expr: &ast::Expr) -> uint {\n+pub fn elements_required(bcx: Block, content_expr: &ast::Expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n     match content_expr.node {\n@@ -470,7 +466,7 @@ pub fn elements_required(bcx: &Block, content_expr: &ast::Expr) -> uint {\n     }\n }\n \n-pub fn get_fixed_base_and_len(bcx: &Block,\n+pub fn get_fixed_base_and_len(bcx: Block,\n                               llval: ValueRef,\n                               vec_length: uint)\n                               -> (ValueRef, ValueRef) {\n@@ -486,15 +482,15 @@ pub fn get_fixed_base_and_len(bcx: &Block,\n     (base, len)\n }\n \n-fn get_slice_base_and_len(bcx: &Block,\n+fn get_slice_base_and_len(bcx: Block,\n                           llval: ValueRef)\n                           -> (ValueRef, ValueRef) {\n     let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n     let len = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n     (base, len)\n }\n \n-pub fn get_base_and_len(bcx: &Block,\n+pub fn get_base_and_len(bcx: Block,\n                         llval: ValueRef,\n                         vec_ty: ty::t)\n                         -> (ValueRef, ValueRef) {\n@@ -528,17 +524,15 @@ pub fn get_base_and_len(bcx: &Block,\n     }\n }\n \n-pub type iter_vec_block<'r,'b> =\n-    |&'b Block<'b>, ValueRef, ty::t|: 'r -> &'b Block<'b>;\n-\n-pub fn iter_vec_loop<'r,\n-                     'b>(\n-                     bcx: &'b Block<'b>,\n-                     data_ptr: ValueRef,\n-                     vt: &VecTypes,\n-                     count: ValueRef,\n-                     f: iter_vec_block<'r,'b>)\n-                     -> &'b Block<'b> {\n+pub type iter_vec_block<'a, 'blk, 'tcx> =\n+    |Block<'blk, 'tcx>, ValueRef, ty::t|: 'a -> Block<'blk, 'tcx>;\n+\n+pub fn iter_vec_loop<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                     data_ptr: ValueRef,\n+                                     vt: &VecTypes,\n+                                     count: ValueRef,\n+                                     f: iter_vec_block<'a, 'blk, 'tcx>)\n+                                     -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"tvec::iter_vec_loop\");\n     let fcx = bcx.fcx;\n \n@@ -589,14 +583,12 @@ pub fn iter_vec_loop<'r,\n     next_bcx\n }\n \n-pub fn iter_vec_raw<'r,\n-                    'b>(\n-                    bcx: &'b Block<'b>,\n-                    data_ptr: ValueRef,\n-                    unit_ty: ty::t,\n-                    len: ValueRef,\n-                    f: iter_vec_block<'r,'b>)\n-                    -> &'b Block<'b> {\n+pub fn iter_vec_raw<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    data_ptr: ValueRef,\n+                                    unit_ty: ty::t,\n+                                    len: ValueRef,\n+                                    f: iter_vec_block<'a, 'blk, 'tcx>)\n+                                    -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"tvec::iter_vec_raw\");\n     let fcx = bcx.fcx;\n "}, {"sha": "dfa4ae6b285c87786236cdef19f0156077611093", "filename": "src/librustc/middle/trans/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a997be05e364248521ee4d11ab57fcb2e99a40/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs?ref=f7a997be05e364248521ee4d11ab57fcb2e99a40", "patch": "@@ -55,7 +55,7 @@ impl Value {\n     /// This only performs a search for a trivially dominating store. The store\n     /// must be the only user of this value, and there must not be any conditional\n     /// branches between the store and the given block.\n-    pub fn get_dominating_store(self, bcx: &Block) -> Option<Value> {\n+    pub fn get_dominating_store(self, bcx: Block) -> Option<Value> {\n         match self.get_single_user().and_then(|user| user.as_store_inst()) {\n             Some(store) => {\n                 store.get_parent().and_then(|store_bb| {"}]}