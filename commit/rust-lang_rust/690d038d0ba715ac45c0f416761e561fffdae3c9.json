{"sha": "690d038d0ba715ac45c0f416761e561fffdae3c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5MGQwMzhkMGJhNzE1YWM0NWMwZjQxNjc2MWU1NjFmZmZkYWUzYzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-15T19:26:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-15T19:26:41Z"}, "message": "auto merge of #4959 : thestinger/rust/map, r=graydon", "tree": {"sha": "d083855b07ace1245ef10ff50088ddd42d1c872d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d083855b07ace1245ef10ff50088ddd42d1c872d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/690d038d0ba715ac45c0f416761e561fffdae3c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/690d038d0ba715ac45c0f416761e561fffdae3c9", "html_url": "https://github.com/rust-lang/rust/commit/690d038d0ba715ac45c0f416761e561fffdae3c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/690d038d0ba715ac45c0f416761e561fffdae3c9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a1fcadc907341b1993b109c72384ab16b512d06", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a1fcadc907341b1993b109c72384ab16b512d06", "html_url": "https://github.com/rust-lang/rust/commit/0a1fcadc907341b1993b109c72384ab16b512d06"}, {"sha": "1561661db86a5fed995eef620eb314b7f859502e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1561661db86a5fed995eef620eb314b7f859502e", "html_url": "https://github.com/rust-lang/rust/commit/1561661db86a5fed995eef620eb314b7f859502e"}], "stats": {"total": 35, "additions": 27, "deletions": 8}, "files": [{"sha": "9cc7c2b760c5590b4f3c37afb8c67f90cd73c21d", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/690d038d0ba715ac45c0f416761e561fffdae3c9/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/690d038d0ba715ac45c0f416761e561fffdae3c9/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=690d038d0ba715ac45c0f416761e561fffdae3c9", "patch": "@@ -51,6 +51,7 @@ pub mod linear {\n         FoundEntry(uint), FoundHole(uint), TableFull\n     }\n \n+    #[inline(always)]\n     pure fn resize_at(capacity: uint) -> uint {\n         ((capacity as float) * 3. / 4.) as uint\n     }\n@@ -76,10 +77,8 @@ pub mod linear {\n     priv impl<K: Hash IterBytes Eq, V> LinearMap<K, V> {\n         #[inline(always)]\n         pure fn to_bucket(&self, h: uint) -> uint {\n-            // FIXME(#3041) borrow a more sophisticated technique here from\n-            // Gecko, for example borrowing from Knuth, as Eich so\n-            // colorfully argues for here:\n-            // https://bugzilla.mozilla.org/show_bug.cgi?id=743107#c22\n+            // A good hash function with entropy spread over all of the\n+            // bits is assumed. SipHash is more than good enough.\n             h % self.buckets.len()\n         }\n \n@@ -128,12 +127,19 @@ pub mod linear {\n             TableFull\n         }\n \n-        /// Expands the capacity of the array and re-inserts each\n-        /// of the existing buckets.\n+        /// Expand the capacity of the array to the next power of two\n+        /// and re-insert each of the existing buckets.\n+        #[inline(always)]\n         fn expand(&mut self) {\n+            let new_capacity = self.buckets.len() * 2;\n+            self.resize(new_capacity);\n+        }\n+\n+        /// Expands the capacity of the array and re-insert each of the\n+        /// existing buckets.\n+        fn resize(&mut self, new_capacity: uint) {\n             let old_capacity = self.buckets.len();\n-            let new_capacity = old_capacity * 2;\n-            self.resize_at = ((new_capacity as float) * 3.0 / 4.0) as uint;\n+            self.resize_at = resize_at(new_capacity);\n \n             let mut old_buckets = vec::from_fn(new_capacity, |_| None);\n             self.buckets <-> old_buckets;\n@@ -333,6 +339,14 @@ pub mod linear {\n             linear_map_with_capacity(INITIAL_CAPACITY)\n         }\n \n+        /// Reserve space for at least `n` elements in the hash table.\n+        fn reserve_at_least(&mut self, n: uint) {\n+            if n > self.buckets.len() {\n+                let buckets = n * 4 / 3 + 1;\n+                self.resize(uint::next_power_of_two(buckets));\n+            }\n+        }\n+\n         fn pop(&mut self, k: &K) -> Option<V> {\n             let hash = k.hash_keyed(self.k0, self.k1) as uint;\n             self.pop_internal(hash, k)\n@@ -564,6 +578,11 @@ pub mod linear {\n     pub impl <T: Hash IterBytes Eq> LinearSet<T> {\n         /// Create an empty LinearSet\n         static fn new() -> LinearSet<T> { LinearSet{map: LinearMap::new()} }\n+\n+        /// Reserve space for at least `n` elements in the hash table.\n+        fn reserve_at_least(&mut self, n: uint) {\n+            self.map.reserve_at_least(n)\n+        }\n     }\n }\n "}]}