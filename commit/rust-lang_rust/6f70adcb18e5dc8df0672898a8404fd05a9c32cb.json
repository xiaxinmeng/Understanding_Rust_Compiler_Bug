{"sha": "6f70adcb18e5dc8df0672898a8404fd05a9c32cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmNzBhZGNiMThlNWRjOGRmMDY3Mjg5OGE4NDA0ZmQwNWE5YzMyY2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-10T10:02:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-10T10:02:28Z"}, "message": "Auto merge of #63352 - jgalenson:reproducible-lto, r=alexcrichton\n\nSort the fat LTO modules to produce deterministic output.\n\nSome projects that use LTO for their release builds are not reproducible.  We can fix this by sorting the fat LTO modules before using them.\n\nIt might also be useful to do this for thin LTO, but I couldn't get that to work to test it so I didn't do it.", "tree": {"sha": "dffec21a1128fc5b2bc8427dcf643a575f36b16b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dffec21a1128fc5b2bc8427dcf643a575f36b16b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f70adcb18e5dc8df0672898a8404fd05a9c32cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f70adcb18e5dc8df0672898a8404fd05a9c32cb", "html_url": "https://github.com/rust-lang/rust/commit/6f70adcb18e5dc8df0672898a8404fd05a9c32cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f70adcb18e5dc8df0672898a8404fd05a9c32cb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d19a359444295bab01de7ff44a9d72302e573bc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d19a359444295bab01de7ff44a9d72302e573bc9", "html_url": "https://github.com/rust-lang/rust/commit/d19a359444295bab01de7ff44a9d72302e573bc9"}, {"sha": "b6767b3096f47b9dc4613cd7ae45c5e89bfd1146", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6767b3096f47b9dc4613cd7ae45c5e89bfd1146", "html_url": "https://github.com/rust-lang/rust/commit/b6767b3096f47b9dc4613cd7ae45c5e89bfd1146"}], "stats": {"total": 211, "additions": 209, "deletions": 2}, "files": [{"sha": "5ed08943fe6fdb194e430a637d37076e0081f650", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f70adcb18e5dc8df0672898a8404fd05a9c32cb/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f70adcb18e5dc8df0672898a8404fd05a9c32cb/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=6f70adcb18e5dc8df0672898a8404fd05a9c32cb", "patch": "@@ -265,7 +265,7 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         // and we want to move everything to the same LLVM context. Currently the\n         // way we know of to do that is to serialize them to a string and them parse\n         // them later. Not great but hey, that's why it's \"fat\" LTO, right?\n-        serialized_modules.extend(modules.into_iter().map(|module| {\n+        let mut new_modules = modules.into_iter().map(|module| {\n             match module {\n                 FatLTOInput::InMemory(module) => {\n                     let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n@@ -277,7 +277,10 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                     (SerializedModule::Local(buffer), llmod_id)\n                 }\n             }\n-        }));\n+        }).collect::<Vec<_>>();\n+        // Sort the modules to ensure we produce deterministic results.\n+        new_modules.sort_by(|module1, module2| module1.1.partial_cmp(&module2.1).unwrap());\n+        serialized_modules.extend(new_modules);\n         serialized_modules.extend(cached_modules.into_iter().map(|(buffer, wp)| {\n             (buffer, CString::new(wp.cgu_name).unwrap())\n         }));"}, {"sha": "b96954fea0d1e3ee0fa0423d8dcafc1af2cdb2ad", "filename": "src/test/run-make-fulldeps/reproducible-build-2/Makefile", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f70adcb18e5dc8df0672898a8404fd05a9c32cb/src%2Ftest%2Frun-make-fulldeps%2Freproducible-build-2%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/6f70adcb18e5dc8df0672898a8404fd05a9c32cb/src%2Ftest%2Frun-make-fulldeps%2Freproducible-build-2%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Freproducible-build-2%2FMakefile?ref=6f70adcb18e5dc8df0672898a8404fd05a9c32cb", "patch": "@@ -0,0 +1,16 @@\n+-include ../tools.mk\n+\n+# ignore-musl\n+# ignore-windows\n+# Objects are reproducible but their path is not.\n+\n+all:  \\\n+\tfat_lto\n+\n+fat_lto:\n+\trm -rf $(TMPDIR) && mkdir $(TMPDIR)\n+\t$(RUSTC) reproducible-build-aux.rs\n+\t$(RUSTC) reproducible-build.rs -C lto=fat\n+\tcp $(TMPDIR)/reproducible-build $(TMPDIR)/reproducible-build-a\n+\t$(RUSTC) reproducible-build.rs -C lto=fat\n+\tcmp \"$(TMPDIR)/reproducible-build-a\" \"$(TMPDIR)/reproducible-build\" || exit 1"}, {"sha": "998d1f328596c8a16cc5d6e4677542d4d06e4f41", "filename": "src/test/run-make-fulldeps/reproducible-build-2/linker.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6f70adcb18e5dc8df0672898a8404fd05a9c32cb/src%2Ftest%2Frun-make-fulldeps%2Freproducible-build-2%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f70adcb18e5dc8df0672898a8404fd05a9c32cb/src%2Ftest%2Frun-make-fulldeps%2Freproducible-build-2%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Freproducible-build-2%2Flinker.rs?ref=6f70adcb18e5dc8df0672898a8404fd05a9c32cb", "patch": "@@ -0,0 +1,44 @@\n+use std::env;\n+use std::path::Path;\n+use std::fs::File;\n+use std::io::{Read, Write};\n+\n+fn main() {\n+    let mut dst = env::current_exe().unwrap();\n+    dst.pop();\n+    dst.push(\"linker-arguments1\");\n+    if dst.exists() {\n+        dst.pop();\n+        dst.push(\"linker-arguments2\");\n+        assert!(!dst.exists());\n+    }\n+\n+    let mut out = String::new();\n+    for arg in env::args().skip(1) {\n+        let path = Path::new(&arg);\n+        if !path.is_file() {\n+            out.push_str(&arg);\n+            out.push_str(\"\\n\");\n+            continue\n+        }\n+\n+        let mut contents = Vec::new();\n+        File::open(path).unwrap().read_to_end(&mut contents).unwrap();\n+\n+        out.push_str(&format!(\"{}: {}\\n\", arg, hash(&contents)));\n+    }\n+\n+    File::create(dst).unwrap().write_all(out.as_bytes()).unwrap();\n+}\n+\n+// fnv hash for now\n+fn hash(contents: &[u8]) -> u64 {\n+    let mut hash = 0xcbf29ce484222325;\n+\n+    for byte in contents {\n+        hash = hash ^ (*byte as u64);\n+        hash = hash.wrapping_mul(0x100000001b3);\n+    }\n+\n+    hash\n+}"}, {"sha": "8105b3d2bda3df7d16e54f5cbac35bc61a6c74e0", "filename": "src/test/run-make-fulldeps/reproducible-build-2/reproducible-build-aux.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6f70adcb18e5dc8df0672898a8404fd05a9c32cb/src%2Ftest%2Frun-make-fulldeps%2Freproducible-build-2%2Freproducible-build-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f70adcb18e5dc8df0672898a8404fd05a9c32cb/src%2Ftest%2Frun-make-fulldeps%2Freproducible-build-2%2Freproducible-build-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Freproducible-build-2%2Freproducible-build-aux.rs?ref=6f70adcb18e5dc8df0672898a8404fd05a9c32cb", "patch": "@@ -0,0 +1,28 @@\n+#![crate_type=\"lib\"]\n+\n+pub static STATIC: i32 = 1234;\n+\n+pub struct Struct<T1, T2> {\n+    _t1: std::marker::PhantomData<T1>,\n+    _t2: std::marker::PhantomData<T2>,\n+}\n+\n+pub fn regular_fn(_: i32) {}\n+\n+pub fn generic_fn<T1, T2>() {}\n+\n+impl<T1, T2> Drop for Struct<T1, T2> {\n+    fn drop(&mut self) {}\n+}\n+\n+pub enum Enum {\n+    Variant1,\n+    Variant2(u32),\n+    Variant3 { x: u32 }\n+}\n+\n+pub struct TupleStruct(pub i8, pub i16, pub i32, pub i64);\n+\n+pub trait Trait<T1, T2> {\n+    fn foo(&self);\n+}"}, {"sha": "a6c04774c869a26dc110e270393ffbb0475ec34f", "filename": "src/test/run-make-fulldeps/reproducible-build-2/reproducible-build.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/6f70adcb18e5dc8df0672898a8404fd05a9c32cb/src%2Ftest%2Frun-make-fulldeps%2Freproducible-build-2%2Freproducible-build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f70adcb18e5dc8df0672898a8404fd05a9c32cb/src%2Ftest%2Frun-make-fulldeps%2Freproducible-build-2%2Freproducible-build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Freproducible-build-2%2Freproducible-build.rs?ref=6f70adcb18e5dc8df0672898a8404fd05a9c32cb", "patch": "@@ -0,0 +1,116 @@\n+// This test case makes sure that two identical invocations of the compiler\n+// (i.e., same code base, same compile-flags, same compiler-versions, etc.)\n+// produce the same output. In the past, symbol names of monomorphized functions\n+// were not deterministic (which we want to avoid).\n+//\n+// The test tries to exercise as many different paths into symbol name\n+// generation as possible:\n+//\n+// - regular functions\n+// - generic functions\n+// - methods\n+// - statics\n+// - closures\n+// - enum variant constructors\n+// - tuple struct constructors\n+// - drop glue\n+// - FnOnce adapters\n+// - Trait object shims\n+// - Fn Pointer shims\n+\n+#![allow(dead_code, warnings)]\n+\n+extern crate reproducible_build_aux;\n+\n+static STATIC: i32 = 1234;\n+\n+pub struct Struct<T1, T2> {\n+    x: T1,\n+    y: T2,\n+}\n+\n+fn regular_fn(_: i32) {}\n+\n+fn generic_fn<T1, T2>() {}\n+\n+impl<T1, T2> Drop for Struct<T1, T2> {\n+    fn drop(&mut self) {}\n+}\n+\n+pub enum Enum {\n+    Variant1,\n+    Variant2(u32),\n+    Variant3 { x: u32 }\n+}\n+\n+struct TupleStruct(i8, i16, i32, i64);\n+\n+impl TupleStruct {\n+    pub fn bar(&self) {}\n+}\n+\n+trait Trait<T1, T2> {\n+    fn foo(&self);\n+}\n+\n+impl Trait<i32, u64> for u64 {\n+    fn foo(&self) {}\n+}\n+\n+impl reproducible_build_aux::Trait<char, String> for TupleStruct {\n+    fn foo(&self) {}\n+}\n+\n+fn main() {\n+    regular_fn(STATIC);\n+    generic_fn::<u32, char>();\n+    generic_fn::<char, Struct<u32, u64>>();\n+    generic_fn::<Struct<u64, u32>, reproducible_build_aux::Struct<u32, u64>>();\n+\n+    let dropped = Struct {\n+        x: \"\",\n+        y: 'a',\n+    };\n+\n+    let _ = Enum::Variant1;\n+    let _ = Enum::Variant2(0);\n+    let _ = Enum::Variant3 { x: 0 };\n+    let _ = TupleStruct(1, 2, 3, 4);\n+\n+    let closure  = |x| {\n+        x + 1i32\n+    };\n+\n+    fn inner<F: Fn(i32) -> i32>(f: F) -> i32 {\n+        f(STATIC)\n+    }\n+\n+    println!(\"{}\", inner(closure));\n+\n+    let object_shim: &Trait<i32, u64> = &0u64;\n+    object_shim.foo();\n+\n+    fn with_fn_once_adapter<F: FnOnce(i32)>(f: F) {\n+        f(0);\n+    }\n+\n+    with_fn_once_adapter(|_:i32| { });\n+\n+    reproducible_build_aux::regular_fn(STATIC);\n+    reproducible_build_aux::generic_fn::<u32, char>();\n+    reproducible_build_aux::generic_fn::<char, Struct<u32, u64>>();\n+    reproducible_build_aux::generic_fn::<Struct<u64, u32>,\n+                                         reproducible_build_aux::Struct<u32, u64>>();\n+\n+    let _ = reproducible_build_aux::Enum::Variant1;\n+    let _ = reproducible_build_aux::Enum::Variant2(0);\n+    let _ = reproducible_build_aux::Enum::Variant3 { x: 0 };\n+    let _ = reproducible_build_aux::TupleStruct(1, 2, 3, 4);\n+\n+    let object_shim: &reproducible_build_aux::Trait<char, String> = &TupleStruct(0, 1, 2, 3);\n+    object_shim.foo();\n+\n+    let pointer_shim: &Fn(i32) = &regular_fn;\n+\n+    TupleStruct(1, 2, 3, 4).bar();\n+}"}]}