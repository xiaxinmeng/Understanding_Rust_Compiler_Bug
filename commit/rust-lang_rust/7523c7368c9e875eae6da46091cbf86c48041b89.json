{"sha": "7523c7368c9e875eae6da46091cbf86c48041b89", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1MjNjNzM2OGM5ZTg3NWVhZTZkYTQ2MDkxY2JmODZjNDgwNDFiODk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-10-24T18:20:47Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-10-31T16:41:38Z"}, "message": "introduce liveness constraints into NLL code\n\nAnd do a bunch of gratuitious refactoring that I did not bother to\nseparate into nice commits.", "tree": {"sha": "3755349b7aac2016446c00ff71dd56f3936f757c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3755349b7aac2016446c00ff71dd56f3936f757c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7523c7368c9e875eae6da46091cbf86c48041b89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7523c7368c9e875eae6da46091cbf86c48041b89", "html_url": "https://github.com/rust-lang/rust/commit/7523c7368c9e875eae6da46091cbf86c48041b89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7523c7368c9e875eae6da46091cbf86c48041b89/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8535a4a32c2b11b0ecadd00d857604fed81e869e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8535a4a32c2b11b0ecadd00d857604fed81e869e", "html_url": "https://github.com/rust-lang/rust/commit/8535a4a32c2b11b0ecadd00d857604fed81e869e"}], "stats": {"total": 606, "additions": 395, "deletions": 211}, "files": [{"sha": "c5ffb0033999556819070439d453e09c287d7ac7", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7523c7368c9e875eae6da46091cbf86c48041b89/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7523c7368c9e875eae6da46091cbf86c48041b89/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=7523c7368c9e875eae6da46091cbf86c48041b89", "patch": "@@ -53,11 +53,19 @@ pub struct IdxSet<T: Idx> {\n }\n \n impl<T: Idx> fmt::Debug for IdxSetBuf<T> {\n-    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result { self.bits.fmt(w) }\n+    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n+        w.debug_list()\n+         .entries(self.iter())\n+         .finish()\n+    }\n }\n \n impl<T: Idx> fmt::Debug for IdxSet<T> {\n-    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result { self.bits.fmt(w) }\n+    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n+        w.debug_list()\n+         .entries(self.iter())\n+         .finish()\n+    }\n }\n \n impl<T: Idx> IdxSetBuf<T> {"}, {"sha": "16753cee7e0e24c8c7b7737b84420b94013f22b5", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7523c7368c9e875eae6da46091cbf86c48041b89/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7523c7368c9e875eae6da46091cbf86c48041b89/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=7523c7368c9e875eae6da46091cbf86c48041b89", "patch": "@@ -18,6 +18,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(conservative_impl_trait)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(i128_type)]"}, {"sha": "1c0c3b6fc33f356d5c3493f1fb457a6b01263b82", "filename": "src/librustc_mir/transform/nll/constraint_generation.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7523c7368c9e875eae6da46091cbf86c48041b89/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7523c7368c9e875eae6da46091cbf86c48041b89/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs?ref=7523c7368c9e875eae6da46091cbf86c48041b89", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::mir::Mir;\n+use rustc::infer::InferCtxt;\n+use util::liveness::LivenessResult;\n+\n+use super::ToRegionIndex;\n+use super::region_infer::RegionInferenceContext;\n+\n+pub fn generate_constraints<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                            regioncx: &mut RegionInferenceContext,\n+                                            mir: &Mir<'tcx>,\n+                                            liveness: &LivenessResult)\n+{\n+    ConstraintGeneration { infcx, regioncx, mir, liveness }.add_constraints();\n+}\n+\n+struct ConstraintGeneration<'constrain, 'gcx: 'tcx, 'tcx: 'constrain> {\n+    infcx: &'constrain InferCtxt<'constrain, 'gcx, 'tcx>,\n+    regioncx: &'constrain mut RegionInferenceContext,\n+    mir: &'constrain Mir<'tcx>,\n+    liveness: &'constrain LivenessResult,\n+}\n+\n+impl<'constrain, 'gcx, 'tcx> ConstraintGeneration<'constrain, 'gcx, 'tcx> {\n+    fn add_constraints(&mut self) {\n+        // To start, add the liveness constraints.\n+        self.add_liveness_constraints();\n+    }\n+\n+    /// Liveness constraints:\n+    ///\n+    /// > If a variable V is live at point P, then all regions R in the type of V\n+    /// > must include the point P.\n+    fn add_liveness_constraints(&mut self) {\n+        let tcx = self.infcx.tcx;\n+\n+        debug!(\"add_liveness_constraints()\");\n+        for bb in self.mir.basic_blocks().indices() {\n+            debug!(\"add_liveness_constraints: bb={:?}\", bb);\n+\n+            self.liveness.simulate_block(self.mir, bb, |location, live_locals| {\n+                debug!(\"add_liveness_constraints: location={:?} live_locals={:?}\",\n+                       location, live_locals);\n+\n+                for live_local in live_locals.iter() {\n+                    let live_local_ty = self.mir.local_decls[live_local].ty;\n+                    tcx.for_each_free_region(&live_local_ty, |live_region| {\n+                        let vid = live_region.to_region_index();\n+                        self.regioncx.add_live_point(vid, location);\n+                    })\n+                }\n+            });\n+        }\n+    }\n+}"}, {"sha": "273972f693799c93674e302d36490fb042240e0c", "filename": "src/librustc_mir/transform/nll/mod.rs", "status": "modified", "additions": 104, "deletions": 183, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/7523c7368c9e875eae6da46091cbf86c48041b89/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7523c7368c9e875eae6da46091cbf86c48041b89/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs?ref=7523c7368c9e875eae6da46091cbf86c48041b89", "patch": "@@ -8,215 +8,115 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use self::infer::InferenceContext;\n-use rustc::ty::TypeFoldable;\n-use rustc::ty::subst::{Kind, Substs};\n-use rustc::ty::{Ty, TyCtxt, ClosureSubsts, RegionVid, RegionKind};\n-use rustc::mir::{Mir, Location, Rvalue, BasicBlock, Statement, StatementKind};\n-use rustc::mir::visit::{MutVisitor, Lookup};\n+use rustc::ty::{self, RegionKind, TyCtxt};\n+use rustc::mir::{Location, Mir};\n use rustc::mir::transform::{MirPass, MirSource};\n-use rustc::infer::{self as rustc_infer, InferCtxt};\n-use rustc::util::nodemap::{FxHashMap, FxHashSet};\n-use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n-use syntax_pos::DUMMY_SP;\n-use std::collections::HashMap;\n+use rustc::infer::InferCtxt;\n+use rustc::util::nodemap::FxHashMap;\n+use rustc_data_structures::indexed_vec::Idx;\n+use std::collections::BTreeSet;\n use std::fmt;\n-use util::liveness;\n+use util::liveness::{self, LivenessResult};\n \n use util as mir_util;\n use self::mir_util::PassWhere;\n \n-mod infer;\n+mod constraint_generation;\n \n-#[allow(dead_code)]\n-struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    lookup_map: HashMap<RegionVid, Lookup>,\n-    regions: IndexVec<RegionIndex, Region>,\n-    #[allow(dead_code)]\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-}\n+mod region_infer;\n+use self::region_infer::RegionInferenceContext;\n \n-impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n-        NLLVisitor {\n-            infcx,\n-            lookup_map: HashMap::new(),\n-            regions: IndexVec::new(),\n-        }\n-    }\n+mod renumber;\n \n-    pub fn into_results(self) -> (HashMap<RegionVid, Lookup>, IndexVec<RegionIndex, Region>) {\n-        (self.lookup_map, self.regions)\n-    }\n-\n-    fn renumber_regions<T>(&mut self, value: &T) -> T where T: TypeFoldable<'tcx> {\n-        self.infcx.tcx.fold_regions(value, &mut false, |_region, _depth| {\n-            self.regions.push(Region::default());\n-            self.infcx.next_region_var(rustc_infer::MiscVariable(DUMMY_SP))\n-        })\n-    }\n+// MIR Pass for non-lexical lifetimes\n+pub struct NLL;\n \n-    fn store_region(&mut self, region: &RegionKind, lookup: Lookup) {\n-        if let RegionKind::ReVar(rid) = *region {\n-            self.lookup_map.entry(rid).or_insert(lookup);\n+impl MirPass for NLL {\n+    fn run_pass<'a, 'tcx>(\n+        &self,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        source: MirSource,\n+        input_mir: &mut Mir<'tcx>,\n+    ) {\n+        if !tcx.sess.opts.debugging_opts.nll {\n+            return;\n         }\n-    }\n \n-    fn store_ty_regions(&mut self, ty: &Ty<'tcx>, lookup: Lookup) {\n-        for region in ty.regions() {\n-            self.store_region(region, lookup);\n-        }\n-    }\n+        tcx.infer_ctxt().enter(|ref infcx| {\n+            // Clone mir so we can mutate it without disturbing the rest of the compiler\n+            let mir = &mut input_mir.clone();\n \n-    fn store_kind_regions(&mut self, kind: &'tcx Kind, lookup: Lookup) {\n-        if let Some(ty) = kind.as_type() {\n-            self.store_ty_regions(&ty, lookup);\n-        } else if let Some(region) = kind.as_region() {\n-            self.store_region(region, lookup);\n-        }\n-    }\n-}\n+            // Replace all regions with fresh inference variables.\n+            let num_region_variables = renumber::renumber_mir(infcx, mir);\n \n-impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n-    fn visit_ty(&mut self, ty: &mut Ty<'tcx>, lookup: Lookup) {\n-        let old_ty = *ty;\n-        *ty = self.renumber_regions(&old_ty);\n-        self.store_ty_regions(ty, lookup);\n-    }\n+            // Compute what is live where.\n+            let liveness = &liveness::liveness_of_locals(mir);\n \n-    fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, location: Location) {\n-        *substs = self.renumber_regions(&{*substs});\n-        let lookup = Lookup::Loc(location);\n-        for kind in *substs {\n-            self.store_kind_regions(kind, lookup);\n-        }\n-    }\n+            // Create the region inference context, generate the constraints,\n+            // and then solve them.\n+            let regioncx = &mut RegionInferenceContext::new(num_region_variables);\n+            constraint_generation::generate_constraints(infcx, regioncx, mir, liveness);\n+            regioncx.solve(infcx, mir);\n \n-    fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n-        match *rvalue {\n-            Rvalue::Ref(ref mut r, _, _) => {\n-                let old_r = *r;\n-                *r = self.renumber_regions(&old_r);\n-                let lookup = Lookup::Loc(location);\n-                self.store_region(r, lookup);\n-            }\n-            Rvalue::Use(..) |\n-            Rvalue::Repeat(..) |\n-            Rvalue::Len(..) |\n-            Rvalue::Cast(..) |\n-            Rvalue::BinaryOp(..) |\n-            Rvalue::CheckedBinaryOp(..) |\n-            Rvalue::UnaryOp(..) |\n-            Rvalue::Discriminant(..) |\n-            Rvalue::NullaryOp(..) |\n-            Rvalue::Aggregate(..) => {\n-                // These variants don't contain regions.\n-            }\n-        }\n-        self.super_rvalue(rvalue, location);\n+            // Dump MIR results into a file, if that is enabled.\n+            dump_mir_results(infcx, liveness, source, regioncx, mir);\n+        })\n     }\n+}\n \n-    fn visit_closure_substs(&mut self,\n-                            substs: &mut ClosureSubsts<'tcx>,\n-                            location: Location) {\n-        *substs = self.renumber_regions(substs);\n-        let lookup = Lookup::Loc(location);\n-        for kind in substs.substs {\n-            self.store_kind_regions(kind, lookup);\n-        }\n+fn dump_mir_results<'a, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    liveness: &LivenessResult,\n+    source: MirSource,\n+    regioncx: &RegionInferenceContext,\n+    mir: &Mir<'tcx>,\n+) {\n+    if !mir_util::dump_enabled(infcx.tcx, \"nll\", source) {\n+        return;\n     }\n \n-    fn visit_statement(&mut self,\n-                       block: BasicBlock,\n-                       statement: &mut Statement<'tcx>,\n-                       location: Location) {\n-        if let StatementKind::EndRegion(_) = statement.kind {\n-            statement.kind = StatementKind::Nop;\n-        }\n-        self.super_statement(block, statement, location);\n-    }\n-}\n+    let liveness_per_location: FxHashMap<_, _> = mir.basic_blocks()\n+        .indices()\n+        .flat_map(|bb| {\n+            let mut results = vec![];\n+            liveness.simulate_block(&mir, bb, |location, local_set| {\n+                results.push((location, local_set.clone()));\n+            });\n+            results\n+        })\n+        .collect();\n+\n+    mir_util::dump_mir(infcx.tcx, None, \"nll\", &0, source, mir, |pass_where, out| {\n+        match pass_where {\n+            // Before the CFG, dump out the values for each region variable.\n+            PassWhere::BeforeCFG => for region in regioncx.regions() {\n+                writeln!(out, \"| {:?}: {:?}\", region, regioncx.region_value(region))?;\n+            },\n+\n+            // Before each basic block, dump out the values\n+            // that are live on entry to the basic block.\n+            PassWhere::BeforeBlock(bb) => {\n+                let local_set = &liveness.ins[bb];\n+                writeln!(out, \"    | Variables live on entry to the block {:?}:\", bb)?;\n+                for local in local_set.iter() {\n+                    writeln!(out, \"    | - {:?}\", local)?;\n+                }\n+            }\n \n-// MIR Pass for non-lexical lifetimes\n-pub struct NLL;\n+            PassWhere::InCFG(location) => {\n+                let local_set = &liveness_per_location[&location];\n+                writeln!(out, \"        | Live variables here: {:?}\", local_set)?;\n+            }\n \n-impl MirPass for NLL {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          source: MirSource,\n-                          input_mir: &mut Mir<'tcx>) {\n-        if !tcx.sess.opts.debugging_opts.nll {\n-            return;\n+            PassWhere::AfterCFG => {}\n         }\n-\n-        tcx.infer_ctxt().enter(|infcx| {\n-            // Clone mir so we can mutate it without disturbing the rest of the compiler\n-            let mir = &mut input_mir.clone();\n-\n-            let mut visitor = NLLVisitor::new(&infcx);\n-            visitor.visit_mir(mir);\n-\n-            let liveness = liveness::liveness_of_locals(mir);\n-\n-            let liveness_per_location: FxHashMap<_, _> =\n-                mir\n-                .basic_blocks()\n-                .indices()\n-                .flat_map(|bb| {\n-                    let mut results = vec![];\n-                    liveness.simulate_block(&mir, bb, |location, local_set| {\n-                        results.push((location, local_set.clone()));\n-                    });\n-                    results\n-                })\n-                .collect();\n-\n-            mir_util::dump_mir(infcx.tcx, None, \"nll\", &0, source, mir, |pass_where, out| {\n-                match pass_where {\n-                    // Before the CFG, dump out the values for each region variable.\n-                    PassWhere::BeforeCFG => {\n-                        for (index, value) in visitor.regions.iter_enumerated() {\n-                            writeln!(out, \"| R{:03}: {:?}\", index.0, value)?;\n-                        }\n-                    }\n-\n-                    // Before each basic block, dump out the values\n-                    // that are live on entry to the basic block.\n-                    PassWhere::BeforeBlock(bb) => {\n-                        let local_set = &liveness.ins[bb];\n-                        writeln!(out, \"    | Variables live on entry to the block {:?}:\", bb)?;\n-                        for local in local_set.iter() {\n-                            writeln!(out, \"    | - {:?}\", local)?;\n-                        }\n-                    }\n-\n-                    PassWhere::InCFG(location) => {\n-                        let local_set = &liveness_per_location[&location];\n-                        let mut string = String::new();\n-                        for local in local_set.iter() {\n-                            string.push_str(&format!(\", {:?}\", local));\n-                        }\n-                        if !string.is_empty() {\n-                            writeln!(out, \"        | Live variables here: [{}]\", &string[2..])?;\n-                        } else {\n-                            writeln!(out, \"        | Live variables here: []\")?;\n-                        }\n-                    }\n-\n-                    PassWhere::AfterCFG => { }\n-                }\n-                Ok(())\n-            });\n-            let (_lookup_map, regions) = visitor.into_results();\n-            let mut inference_context = InferenceContext::new(regions);\n-            inference_context.solve(&infcx, mir);\n-        })\n-    }\n+        Ok(())\n+    });\n }\n \n #[derive(Clone, Default, PartialEq, Eq)]\n pub struct Region {\n-    points: FxHashSet<Location>,\n+    points: BTreeSet<Location>,\n }\n \n impl fmt::Debug for Region {\n@@ -235,4 +135,25 @@ impl Region {\n     }\n }\n \n-newtype_index!(RegionIndex);\n+newtype_index!(RegionIndex {\n+    DEBUG_NAME = \"R\",\n+});\n+\n+/// Right now, we piggy back on the `ReVar` to store our NLL inference\n+/// regions. These are indexed with `RegionIndex`. This method will\n+/// assert that the region is a `ReVar` and convert the internal index\n+/// into a `RegionIndex`. This is reasonable because in our MIR we\n+/// replace all free regions with inference variables.\n+trait ToRegionIndex {\n+    fn to_region_index(&self) -> RegionIndex;\n+}\n+\n+impl ToRegionIndex for RegionKind {\n+    fn to_region_index(&self) -> RegionIndex {\n+        if let &ty::ReVar(vid) = self {\n+            RegionIndex::new(vid.index as usize)\n+        } else {\n+            bug!(\"region is not an ReVar: {:?}\", self)\n+        }\n+    }\n+}"}, {"sha": "75abd4d3ff53a1b0c59f83e1741e36a69335da5c", "filename": "src/librustc_mir/transform/nll/region_infer.rs", "status": "renamed", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7523c7368c9e875eae6da46091cbf86c48041b89/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7523c7368c9e875eae6da46091cbf86c48041b89/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs?ref=7523c7368c9e875eae6da46091cbf86c48041b89", "patch": "@@ -15,7 +15,7 @@ use rustc::mir::{Location, Mir};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::fx::FxHashSet;\n \n-pub struct InferenceContext {\n+pub struct RegionInferenceContext {\n     definitions: IndexVec<RegionIndex, VarDefinition>,\n     constraints: IndexVec<ConstraintIndex, Constraint>,\n     errors: IndexVec<InferenceErrorIndex, InferenceError>,\n@@ -28,22 +28,13 @@ pub struct InferenceError {\n \n newtype_index!(InferenceErrorIndex);\n \n+#[derive(Default)]\n struct VarDefinition {\n     name: (), // FIXME(nashenas88) RegionName\n     value: Region,\n     capped: bool,\n }\n \n-impl VarDefinition {\n-    pub fn new(value: Region) -> Self {\n-        Self {\n-            name: (),\n-            value,\n-            capped: false,\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub struct Constraint {\n     sub: RegionIndex,\n@@ -53,10 +44,12 @@ pub struct Constraint {\n \n newtype_index!(ConstraintIndex);\n \n-impl InferenceContext {\n-    pub fn new(values: IndexVec<RegionIndex, Region>) -> Self {\n+impl RegionInferenceContext {\n+    pub fn new(num_region_variables: usize) -> Self {\n         Self {\n-            definitions: values.into_iter().map(VarDefinition::new).collect(),\n+            definitions: (0..num_region_variables)\n+                .map(|_| VarDefinition::default())\n+                .collect(),\n             constraints: IndexVec::new(),\n             errors: IndexVec::new(),\n         }\n@@ -87,8 +80,14 @@ impl InferenceContext {\n         self.constraints.push(Constraint { sup, sub, point });\n     }\n \n-    #[allow(dead_code)]\n-    pub fn region(&self, v: RegionIndex) -> &Region {\n+    /// Returns an iterator over all the region indices.\n+    pub fn regions(&self) -> impl Iterator<Item = RegionIndex> {\n+        self.definitions.indices()\n+    }\n+\n+    /// Returns the current value for the region `v`. This is only\n+    /// really meaningful after `solve` has executed.\n+    pub fn region_value(&self, v: RegionIndex) -> &Region {\n         &self.definitions[v].value\n     }\n \n@@ -144,8 +143,7 @@ impl InferenceContext {\n }\n \n struct Dfs<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> {\n-    #[allow(dead_code)]\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    #[allow(dead_code)] infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n }\n \n@@ -183,17 +181,22 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> Dfs<'a, 'gcx, 'tcx> {\n \n             let block_data = &self.mir[p.block];\n             let successor_points = if p.statement_index < block_data.statements.len() {\n-                vec![Location {\n-                    statement_index: p.statement_index + 1,\n-                    ..p\n-                }]\n+                vec![\n+                    Location {\n+                        statement_index: p.statement_index + 1,\n+                        ..p\n+                    },\n+                ]\n             } else {\n-                block_data.terminator()\n+                block_data\n+                    .terminator()\n                     .successors()\n                     .iter()\n-                    .map(|&basic_block| Location {\n-                        statement_index: 0,\n-                        block: basic_block,\n+                    .map(|&basic_block| {\n+                        Location {\n+                            statement_index: 0,\n+                            block: basic_block,\n+                        }\n                     })\n                     .collect::<Vec<_>>()\n             };", "previous_filename": "src/librustc_mir/transform/nll/infer.rs"}, {"sha": "589179c2066854ef05e451a6967acb333eec0454", "filename": "src/librustc_mir/transform/nll/renumber.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/7523c7368c9e875eae6da46091cbf86c48041b89/src%2Flibrustc_mir%2Ftransform%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7523c7368c9e875eae6da46091cbf86c48041b89/src%2Flibrustc_mir%2Ftransform%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Frenumber.rs?ref=7523c7368c9e875eae6da46091cbf86c48041b89", "patch": "@@ -0,0 +1,132 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty::TypeFoldable;\n+use rustc::ty::subst::{Kind, Substs};\n+use rustc::ty::{Ty, ClosureSubsts, RegionVid, RegionKind};\n+use rustc::mir::{Mir, Location, Rvalue, BasicBlock, Statement, StatementKind};\n+use rustc::mir::visit::{MutVisitor, Lookup};\n+use rustc::infer::{self as rustc_infer, InferCtxt};\n+use syntax_pos::DUMMY_SP;\n+use std::collections::HashMap;\n+\n+/// Replaces all free regions appearing in the MIR with fresh\n+/// inference variables, returning the number of variables created.\n+pub fn renumber_mir<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                    mir: &mut Mir<'tcx>)\n+                                    -> usize\n+{\n+    let mut visitor = NLLVisitor::new(infcx);\n+    visitor.visit_mir(mir);\n+    visitor.num_region_variables\n+}\n+\n+struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+    lookup_map: HashMap<RegionVid, Lookup>,\n+    num_region_variables: usize,\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+        NLLVisitor {\n+            infcx,\n+            lookup_map: HashMap::new(),\n+            num_region_variables: 0\n+        }\n+    }\n+\n+    fn renumber_regions<T>(&mut self, value: &T) -> T where T: TypeFoldable<'tcx> {\n+        self.infcx.tcx.fold_regions(value, &mut false, |_region, _depth| {\n+            self.num_region_variables += 1;\n+            self.infcx.next_region_var(rustc_infer::MiscVariable(DUMMY_SP))\n+        })\n+    }\n+\n+    fn store_region(&mut self, region: &RegionKind, lookup: Lookup) {\n+        if let RegionKind::ReVar(rid) = *region {\n+            self.lookup_map.entry(rid).or_insert(lookup);\n+        }\n+    }\n+\n+    fn store_ty_regions(&mut self, ty: &Ty<'tcx>, lookup: Lookup) {\n+        for region in ty.regions() {\n+            self.store_region(region, lookup);\n+        }\n+    }\n+\n+    fn store_kind_regions(&mut self, kind: &'tcx Kind, lookup: Lookup) {\n+        if let Some(ty) = kind.as_type() {\n+            self.store_ty_regions(&ty, lookup);\n+        } else if let Some(region) = kind.as_region() {\n+            self.store_region(region, lookup);\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n+    fn visit_ty(&mut self, ty: &mut Ty<'tcx>, lookup: Lookup) {\n+        let old_ty = *ty;\n+        *ty = self.renumber_regions(&old_ty);\n+        self.store_ty_regions(ty, lookup);\n+    }\n+\n+    fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, location: Location) {\n+        *substs = self.renumber_regions(&{*substs});\n+        let lookup = Lookup::Loc(location);\n+        for kind in *substs {\n+            self.store_kind_regions(kind, lookup);\n+        }\n+    }\n+\n+    fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n+        match *rvalue {\n+            Rvalue::Ref(ref mut r, _, _) => {\n+                let old_r = *r;\n+                *r = self.renumber_regions(&old_r);\n+                let lookup = Lookup::Loc(location);\n+                self.store_region(r, lookup);\n+            }\n+            Rvalue::Use(..) |\n+            Rvalue::Repeat(..) |\n+            Rvalue::Len(..) |\n+            Rvalue::Cast(..) |\n+            Rvalue::BinaryOp(..) |\n+            Rvalue::CheckedBinaryOp(..) |\n+            Rvalue::UnaryOp(..) |\n+            Rvalue::Discriminant(..) |\n+            Rvalue::NullaryOp(..) |\n+            Rvalue::Aggregate(..) => {\n+                // These variants don't contain regions.\n+            }\n+        }\n+        self.super_rvalue(rvalue, location);\n+    }\n+\n+    fn visit_closure_substs(&mut self,\n+                            substs: &mut ClosureSubsts<'tcx>,\n+                            location: Location) {\n+        *substs = self.renumber_regions(substs);\n+        let lookup = Lookup::Loc(location);\n+        for kind in substs.substs {\n+            self.store_kind_regions(kind, lookup);\n+        }\n+    }\n+\n+    fn visit_statement(&mut self,\n+                       block: BasicBlock,\n+                       statement: &mut Statement<'tcx>,\n+                       location: Location) {\n+        if let StatementKind::EndRegion(_) = statement.kind {\n+            statement.kind = StatementKind::Nop;\n+        }\n+        self.super_statement(block, statement, location);\n+    }\n+}"}, {"sha": "d1ef08cf00d7d67da9563d566df4db2951ddcfa6", "filename": "src/test/mir-opt/nll/region-liveness-basic.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7523c7368c9e875eae6da46091cbf86c48041b89/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7523c7368c9e875eae6da46091cbf86c48041b89/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs?ref=7523c7368c9e875eae6da46091cbf86c48041b89", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for liveness constraints: the region (`R1`) that appears\n+// in the type of `p` includes the points after `&v[0]` up to (but not\n+// including) the call to `use_x`. The `else` branch is not included.\n+\n+// compile-flags:-Znll -Zverbose\n+//                     ^^^^^^^^^ force compiler to dump more region information\n+\n+#![allow(warnings)]\n+\n+fn use_x(_: usize) -> bool { true }\n+\n+fn main() {\n+    let mut v = [1, 2, 3];\n+    let p = &v[0];\n+    if true {\n+        use_x(*p);\n+    } else {\n+        use_x(22);\n+    }\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node12.nll.0.mir\n+// | R1: {bb1[1], bb2[0], bb2[1]}\n+// ...\n+//             let _2: &'_#1r usize;\n+// END rustc.node12.nll.0.mir\n+// START rustc.node12.nll.0.mir\n+//    bb1: {\n+//        | Live variables here: [_1, _3]\n+//        _2 = &'_#0r _1[_3];\n+//        | Live variables here: [_2]\n+//        switchInt(const true) -> [0u8: bb3, otherwise: bb2];\n+//    }\n+// END rustc.node12.nll.0.mir\n+// START rustc.node12.nll.0.mir\n+//    bb2: {\n+//        | Live variables here: [_2]\n+//        StorageLive(_7);\n+//        | Live variables here: [_2]\n+//        _7 = (*_2);\n+//        | Live variables here: [_7]\n+//        _6 = const use_x(_7) -> bb4;\n+//    }\n+// END rustc.node12.nll.0.mir"}]}