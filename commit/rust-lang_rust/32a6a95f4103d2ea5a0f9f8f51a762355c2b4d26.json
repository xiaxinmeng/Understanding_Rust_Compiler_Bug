{"sha": "32a6a95f4103d2ea5a0f9f8f51a762355c2b4d26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyYTZhOTVmNDEwM2QyZWE1YTBmOWY4ZjUxYTc2MjM1NWMyYjRkMjY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2018-12-16T13:08:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-12-16T13:08:30Z"}, "message": "Rollup merge of #56793 - QuietMisdreavus:better-doctests, r=GuillaumeGomez\n\nrustdoc: look for comments when scraping attributes/crates from doctests\n\nFixes https://github.com/rust-lang/rust/issues/56727\n\nWhen scraping out crate-level attributes and `extern crate` statements, we wouldn't look for comments, so any presence of comments would shunt it and everything after it into \"everything else\". This could cause parsing issues when looking for `fn main` and `extern crate my_crate` later on, which would in turn cause rustdoc to incorrectly wrap a test with `fn main` when it already had one declared.\n\nI took the opportunity to clean up the logic a little bit, but it would still benefit from a libsyntax-based loop like the `fn main` detection.", "tree": {"sha": "30c60616242c5f77d86d0acfc4d98803be8b03c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30c60616242c5f77d86d0acfc4d98803be8b03c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32a6a95f4103d2ea5a0f9f8f51a762355c2b4d26", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcFk5PCRBK7hj4Ov3rIwAAdHIIAFU/yzfsMX3r3tk+UMcNwJjQ\nDBnMul9XXVG6qPWwwwLF3nnbdV4nzzLyXcCdcuSMzz2zt2iZMipMzv6Tt9eu0PsK\nlYrh9acFbXdJhHlDUW7TZ7DVxo+gVj5WeCLRHLwjBADZ4JVG6LGSVzQtYfMYR1fb\nx53QWMVhTJ5wEbG0qnS3gWe4t8HfFEle7hakIBO7R+LnN4ugqRXyJt/jX8GOAgRb\nRQsSWP7JTqMGsCvFxI82toviNdyTM/3nRRi6V3hdugw4+quVNZGU2ELo7P065RvV\n3FR/ljKxuZ5SPt0ZAstc/qb/7C9BJbsIu2RTR1o8rNavh6QYiuhUwOKG7GAOWiI=\n=SFk6\n-----END PGP SIGNATURE-----\n", "payload": "tree 30c60616242c5f77d86d0acfc4d98803be8b03c6\nparent d91032a9efab1f552ce5a50d0f213d185b06129d\nparent 8faaef66c921c7c65fa73727ae5bd5d4e4fe7a76\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1544965710 +0100\ncommitter GitHub <noreply@github.com> 1544965710 +0100\n\nRollup merge of #56793 - QuietMisdreavus:better-doctests, r=GuillaumeGomez\n\nrustdoc: look for comments when scraping attributes/crates from doctests\n\nFixes https://github.com/rust-lang/rust/issues/56727\n\nWhen scraping out crate-level attributes and `extern crate` statements, we wouldn't look for comments, so any presence of comments would shunt it and everything after it into \"everything else\". This could cause parsing issues when looking for `fn main` and `extern crate my_crate` later on, which would in turn cause rustdoc to incorrectly wrap a test with `fn main` when it already had one declared.\n\nI took the opportunity to clean up the logic a little bit, but it would still benefit from a libsyntax-based loop like the `fn main` detection.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32a6a95f4103d2ea5a0f9f8f51a762355c2b4d26", "html_url": "https://github.com/rust-lang/rust/commit/32a6a95f4103d2ea5a0f9f8f51a762355c2b4d26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32a6a95f4103d2ea5a0f9f8f51a762355c2b4d26/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d91032a9efab1f552ce5a50d0f213d185b06129d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d91032a9efab1f552ce5a50d0f213d185b06129d", "html_url": "https://github.com/rust-lang/rust/commit/d91032a9efab1f552ce5a50d0f213d185b06129d"}, {"sha": "8faaef66c921c7c65fa73727ae5bd5d4e4fe7a76", "url": "https://api.github.com/repos/rust-lang/rust/commits/8faaef66c921c7c65fa73727ae5bd5d4e4fe7a76", "html_url": "https://github.com/rust-lang/rust/commit/8faaef66c921c7c65fa73727ae5bd5d4e4fe7a76"}], "stats": {"total": 104, "additions": 88, "deletions": 16}, "files": [{"sha": "84ce9f6d2574d1bc54926aa1c99ff32fb004b94f", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 58, "deletions": 16, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/32a6a95f4103d2ea5a0f9f8f51a762355c2b4d26/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32a6a95f4103d2ea5a0f9f8f51a762355c2b4d26/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=32a6a95f4103d2ea5a0f9f8f51a762355c2b4d26", "patch": "@@ -395,6 +395,7 @@ pub fn make_test(s: &str,\n     // Now push any outer attributes from the example, assuming they\n     // are intended to be crate attributes.\n     prog.push_str(&crate_attrs);\n+    prog.push_str(&crates);\n \n     // Uses libsyntax to parse the doctest and find if there's a main fn and the extern\n     // crate already is included.\n@@ -488,37 +489,78 @@ pub fn make_test(s: &str,\n         prog.push_str(\"\\n}\");\n     }\n \n+    debug!(\"final doctest:\\n{}\", prog);\n+\n     (prog, line_offset)\n }\n \n // FIXME(aburka): use a real parser to deal with multiline attributes\n fn partition_source(s: &str) -> (String, String, String) {\n-    let mut after_header = false;\n+    #[derive(Copy, Clone, PartialEq)]\n+    enum PartitionState {\n+        Attrs,\n+        Crates,\n+        Other,\n+    }\n+    let mut state = PartitionState::Attrs;\n     let mut before = String::new();\n     let mut crates = String::new();\n     let mut after = String::new();\n \n     for line in s.lines() {\n         let trimline = line.trim();\n-        let header = trimline.chars().all(|c| c.is_whitespace()) ||\n-            trimline.starts_with(\"#![\") ||\n-            trimline.starts_with(\"#[macro_use] extern crate\") ||\n-            trimline.starts_with(\"extern crate\");\n-        if !header || after_header {\n-            after_header = true;\n-            after.push_str(line);\n-            after.push_str(\"\\n\");\n-        } else {\n-            if trimline.starts_with(\"#[macro_use] extern crate\")\n-                || trimline.starts_with(\"extern crate\") {\n+\n+        // FIXME(misdreavus): if a doc comment is placed on an extern crate statement, it will be\n+        // shunted into \"everything else\"\n+        match state {\n+            PartitionState::Attrs => {\n+                state = if trimline.starts_with(\"#![\") ||\n+                    trimline.chars().all(|c| c.is_whitespace()) ||\n+                    (trimline.starts_with(\"//\") && !trimline.starts_with(\"///\"))\n+                {\n+                    PartitionState::Attrs\n+                } else if trimline.starts_with(\"extern crate\") ||\n+                    trimline.starts_with(\"#[macro_use] extern crate\")\n+                {\n+                    PartitionState::Crates\n+                } else {\n+                    PartitionState::Other\n+                };\n+            }\n+            PartitionState::Crates => {\n+                state = if trimline.starts_with(\"extern crate\") ||\n+                    trimline.starts_with(\"#[macro_use] extern crate\") ||\n+                    trimline.chars().all(|c| c.is_whitespace()) ||\n+                    (trimline.starts_with(\"//\") && !trimline.starts_with(\"///\"))\n+                {\n+                    PartitionState::Crates\n+                } else {\n+                    PartitionState::Other\n+                };\n+            }\n+            PartitionState::Other => {}\n+        }\n+\n+        match state {\n+            PartitionState::Attrs => {\n+                before.push_str(line);\n+                before.push_str(\"\\n\");\n+            }\n+            PartitionState::Crates => {\n                 crates.push_str(line);\n                 crates.push_str(\"\\n\");\n             }\n-            before.push_str(line);\n-            before.push_str(\"\\n\");\n+            PartitionState::Other => {\n+                after.push_str(line);\n+                after.push_str(\"\\n\");\n+            }\n         }\n     }\n \n+    debug!(\"before:\\n{}\", before);\n+    debug!(\"crates:\\n{}\", crates);\n+    debug!(\"after:\\n{}\", after);\n+\n     (before, after, crates)\n }\n \n@@ -1035,8 +1077,8 @@ fn main() {\n assert_eq!(2+2, 4);\";\n         let expected =\n \"#![allow(unused)]\n-fn main() {\n //Ceci n'est pas une `fn main`\n+fn main() {\n assert_eq!(2+2, 4);\n }\".to_string();\n         let output = make_test(input, None, false, &opts);\n@@ -1083,8 +1125,8 @@ assert_eq!(2+2, 4);\";\n \n         let expected =\n \"#![allow(unused)]\n-fn main() {\n // fn main\n+fn main() {\n assert_eq!(2+2, 4);\n }\".to_string();\n "}, {"sha": "3468bb7bda4730d833b7326d8f4aa0d570ca28a4", "filename": "src/test/rustdoc/comment-in-doctest.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/32a6a95f4103d2ea5a0f9f8f51a762355c2b4d26/src%2Ftest%2Frustdoc%2Fcomment-in-doctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32a6a95f4103d2ea5a0f9f8f51a762355c2b4d26/src%2Ftest%2Frustdoc%2Fcomment-in-doctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcomment-in-doctest.rs?ref=32a6a95f4103d2ea5a0f9f8f51a762355c2b4d26", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:--test\n+\n+// comments, both doc comments and regular ones, used to trick rustdoc's doctest parser into\n+// thinking that everything after it was part of the regular program. combined with the libsyntax\n+// parser loop failing to detect the manual main function, it would wrap everything in `fn main`,\n+// which would cause the doctest to fail as the \"extern crate\" declaration was no longer valid.\n+// oddly enough, it would pass in 2018 if a crate was in the extern prelude. see\n+// https://github.com/rust-lang/rust/issues/56727\n+\n+//! ```\n+//! // crate: proc-macro-test\n+//! //! this is a test\n+//!\n+//! // used to pull in proc-macro specific items\n+//! extern crate proc_macro;\n+//!\n+//! use proc_macro::TokenStream;\n+//!\n+//! # fn main() {}\n+//! ```"}]}