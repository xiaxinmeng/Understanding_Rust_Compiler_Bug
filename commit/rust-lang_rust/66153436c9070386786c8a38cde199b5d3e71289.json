{"sha": "66153436c9070386786c8a38cde199b5d3e71289", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MTUzNDM2YzkwNzAzODY3ODZjOGEzOGNkZTE5OWI1ZDNlNzEyODk=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-16T14:27:34Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-16T16:21:05Z"}, "message": "Saner approach to lvalues and callable values in trans\n\nLValues no longer carry information about generics and objs, instead\nthere's an extended form of lvalue, lval_maybe_callee, only used by\ncall and bind, which holds this info.\n\nThis makes it possible to take the value of a method and get a working\nclosure, and will (with some more work) allow us to call statically\nknown functions without loading from their pair.\n\nCloses #435\nCloses #758", "tree": {"sha": "e7657594a91d7a49dc8b7836f511d6a471684630", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7657594a91d7a49dc8b7836f511d6a471684630"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66153436c9070386786c8a38cde199b5d3e71289", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66153436c9070386786c8a38cde199b5d3e71289", "html_url": "https://github.com/rust-lang/rust/commit/66153436c9070386786c8a38cde199b5d3e71289", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66153436c9070386786c8a38cde199b5d3e71289/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "639d88a6936491cfc3b879bb54989e458b4c93c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/639d88a6936491cfc3b879bb54989e458b4c93c4", "html_url": "https://github.com/rust-lang/rust/commit/639d88a6936491cfc3b879bb54989e458b4c93c4"}], "stats": {"total": 417, "additions": 220, "deletions": 197}, "files": [{"sha": "3f253b4920c8629ff835716e2d39a91c90f514be", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 216, "deletions": 193, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/66153436c9070386786c8a38cde199b5d3e71289/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66153436c9070386786c8a38cde199b5d3e71289/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=66153436c9070386786c8a38cde199b5d3e71289", "patch": "@@ -2048,7 +2048,7 @@ fn copy_val_no_check(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n // doesn't need to be dropped.\n fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n             src: lval_result, t: ty::t) -> @block_ctxt {\n-    let src_val = src.res.val;\n+    let src_val = src.val;\n     let tcx = bcx_tcx(cx);\n     if ty::type_is_scalar(tcx, t) || ty::type_is_native(tcx, t) {\n         if src.is_mem { src_val = Load(cx, src_val); }\n@@ -2060,7 +2060,7 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n         if src.is_mem { src_val = Load(cx, src_val); }\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t); }\n         Store(cx, src_val, dst);\n-        if src.is_mem { ret zero_alloca(cx, src.res.val, t).bcx; }\n+        if src.is_mem { ret zero_alloca(cx, src.val, t).bcx; }\n \n         // If we're here, it must be a temporary.\n         ret revoke_clean(cx, src_val, t);\n@@ -2082,7 +2082,7 @@ fn move_val_if_temp(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n \n     // Lvals in memory are not temporaries. Copy them.\n     if src.is_mem {\n-        ret copy_val(cx, action, dst, load_if_immediate(cx, src.res.val, t),\n+        ret copy_val(cx, action, dst, load_if_immediate(cx, src.val, t),\n                      t);\n     }\n     ret move_val(cx, action, dst, src, t);\n@@ -2164,8 +2164,8 @@ fn trans_unary(cx: @block_ctxt, op: ast::unop, e: @ast::expr,\n       }\n       ast::box(_) {\n         let lv = trans_lval(cx, e);\n-        let box_ty = node_id_type(bcx_ccx(lv.res.bcx), id);\n-        let sub = trans_malloc_boxed(lv.res.bcx, e_ty);\n+        let box_ty = node_id_type(bcx_ccx(lv.bcx), id);\n+        let sub = trans_malloc_boxed(lv.bcx, e_ty);\n         let body = sub.body;\n         add_clean_temp(cx, sub.box, box_ty);\n \n@@ -2561,7 +2561,7 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n         bcx = bound.bcx;\n         if copying {\n             bcx = move_val_if_temp(bcx, INIT, bound.val, lv, bound_tys[i]);\n-        } else { Store(bcx, lv.res.val, bound.val); }\n+        } else { Store(bcx, lv.val, bound.val); }\n         i += 1u;\n     }\n \n@@ -2765,8 +2765,8 @@ fn trans_for_each(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n       ast::expr_call(f, args) {\n         let pair =\n             create_real_fn_pair(cx, iter_body_llty, lliterbody, llenv.ptr);\n-        r = trans_call(cx, f, some(pair), args, seq.id).res;\n-        ret rslt(r.bcx, C_nil());\n+        let r = trans_call(cx, f, some(pair), args, seq.id);\n+        ret rslt(r.res.bcx, C_nil());\n       }\n     }\n }\n@@ -2812,24 +2812,26 @@ type generic_info =\n      static_tis: [option::t<@tydesc_info>],\n      tydescs: [ValueRef]};\n \n-type lval_result =\n-    {res: result,\n-     is_mem: bool,\n-     generic: option::t<generic_info>,\n-     llobj: option::t<ValueRef>};\n+type lval_result = {bcx: @block_ctxt,\n+                    val: ValueRef,\n+                    is_mem: bool};\n+tag callee_env { some_env(ValueRef); null_env; is_closure; }\n+type lval_maybe_callee = {bcx: @block_ctxt,\n+                          val: ValueRef,\n+                          is_mem: bool,\n+                          env: callee_env,\n+                          generic: option::t<generic_info>};\n \n-fn lval_mem(cx: @block_ctxt, val: ValueRef) -> lval_result {\n-    ret {res: rslt(cx, val),\n-         is_mem: true,\n-         generic: none::<generic_info>,\n-         llobj: none::<ValueRef>};\n+fn lval_mem(bcx: @block_ctxt, val: ValueRef) -> lval_result {\n+    ret {bcx: bcx, val: val, is_mem: true};\n+}\n+fn lval_val(bcx: @block_ctxt, val: ValueRef) -> lval_result {\n+    ret {bcx: bcx, val: val, is_mem: false};\n }\n \n-fn lval_val(cx: @block_ctxt, val: ValueRef) -> lval_result {\n-    ret {res: rslt(cx, val),\n-         is_mem: false,\n-         generic: none::<generic_info>,\n-         llobj: none::<ValueRef>};\n+fn lval_no_env(bcx: @block_ctxt, val: ValueRef, is_mem: bool)\n+    -> lval_maybe_callee {\n+    ret {bcx: bcx, val: val, is_mem: is_mem, env: is_closure, generic: none};\n }\n \n fn trans_external_path(cx: @block_ctxt, did: ast::def_id,\n@@ -2840,35 +2842,31 @@ fn trans_external_path(cx: @block_ctxt, did: ast::def_id,\n                          type_of_ty_param_kinds_and_ty(lcx, cx.sp, tpt));\n }\n \n-fn lval_generic_fn(cx: @block_ctxt, tpt: ty::ty_param_kinds_and_ty,\n-                   fn_id: ast::def_id, id: ast::node_id) -> lval_result {\n-    let lv;\n-    if fn_id.crate == ast::local_crate {\n+fn lval_static_fn(bcx: @block_ctxt, tpt: ty::ty_param_kinds_and_ty,\n+                  fn_id: ast::def_id, id: ast::node_id) -> lval_maybe_callee {\n+    let val = if fn_id.crate == ast::local_crate {\n         // Internal reference.\n-        assert (bcx_ccx(cx).fn_pairs.contains_key(fn_id.node));\n-        lv = lval_val(cx, bcx_ccx(cx).fn_pairs.get(fn_id.node));\n+        assert (bcx_ccx(bcx).fn_pairs.contains_key(fn_id.node));\n+        bcx_ccx(bcx).fn_pairs.get(fn_id.node)\n     } else {\n         // External reference.\n-        lv = lval_val(cx, trans_external_path(cx, fn_id, tpt));\n-    }\n-    let tys = ty::node_id_to_type_params(bcx_tcx(cx), id);\n+        trans_external_path(bcx, fn_id, tpt)\n+    };\n+    let tys = ty::node_id_to_type_params(bcx_tcx(bcx), id);\n+    let gen = none;\n     if std::vec::len::<ty::t>(tys) != 0u {\n-        let bcx = lv.res.bcx;\n-        let tydescs: [ValueRef] = [];\n-        let tis: [option::t<@tydesc_info>] = [];\n-        for t: ty::t in tys {\n+        let tydescs = [], tis = [];\n+        for t in tys {\n             // TODO: Doesn't always escape.\n-\n-            let ti = none::<@tydesc_info>;\n+            let ti = none;\n             let td = get_tydesc(bcx, t, true, tps_normal, ti).result;\n             tis += [ti];\n             bcx = td.bcx;\n             tydescs += [td.val];\n         }\n-        let gen = {item_type: tpt.ty, static_tis: tis, tydescs: tydescs};\n-        lv = {res: rslt(bcx, lv.res.val), generic: some(gen) with lv};\n+        gen = some({item_type: tpt.ty, static_tis: tis, tydescs: tydescs});\n     }\n-    ret lv;\n+    ret {bcx: bcx, val: val, is_mem: true, env: is_closure, generic: gen};\n }\n \n fn lookup_discriminant(lcx: @local_ctxt, vid: ast::def_id) -> ValueRef {\n@@ -2921,21 +2919,25 @@ fn trans_local_var(cx: @block_ctxt, def: ast::def) -> lval_result {\n     }\n }\n \n-fn trans_var(cx: @block_ctxt, sp: span, def: ast::def, id: ast::node_id) ->\n-   lval_result {\n+fn trans_path(cx: @block_ctxt, p: ast::path, id: ast::node_id)\n+    -> lval_maybe_callee {\n+    ret trans_var(cx, p.span, bcx_tcx(cx).def_map.get(id), id);\n+}\n+\n+fn trans_var(cx: @block_ctxt, sp: span, def: ast::def, id: ast::node_id)\n+    -> lval_maybe_callee {\n     let ccx = bcx_ccx(cx);\n     alt def {\n       ast::def_fn(did, _) | ast::def_native_fn(did) {\n         let tyt = ty::lookup_item_type(ccx.tcx, did);\n-        ret lval_generic_fn(cx, tyt, did, id);\n+        ret lval_static_fn(cx, tyt, did, id);\n       }\n       ast::def_variant(tid, vid) {\n         let v_tyt = ty::lookup_item_type(ccx.tcx, vid);\n         alt ty::struct(ccx.tcx, v_tyt.ty) {\n           ty::ty_fn(_, _, _, _, _) {\n             // N-ary variant.\n-\n-            ret lval_generic_fn(cx, v_tyt, vid, id);\n+            ret lval_static_fn(cx, v_tyt, vid, id);\n           }\n           _ {\n             // Nullary variant.\n@@ -2951,43 +2953,44 @@ fn trans_var(cx: @block_ctxt, sp: span, def: ast::def, id: ast::node_id) ->\n                 let lldiscrimptr = GEP(bcx, lltagptr, [C_int(0), C_int(0)]);\n                 Store(bcx, lldiscrim, lldiscrimptr);\n             }\n-            ret lval_val(bcx, lltagptr);\n+            ret lval_no_env(bcx, lltagptr, false);\n           }\n         }\n       }\n       ast::def_const(did) {\n         if did.crate == ast::local_crate {\n             assert (ccx.consts.contains_key(did.node));\n-            ret lval_mem(cx, ccx.consts.get(did.node));\n+            ret lval_no_env(cx, ccx.consts.get(did.node), true);\n         } else {\n             let tp = ty::node_id_to_monotype(ccx.tcx, id);\n             let k: [ast::kind] = [];\n-            ret lval_val(cx,\n-                         load_if_immediate(cx,\n-                                           trans_external_path(cx, did,\n-                                                               {kinds: k,\n-                                                                ty: tp}),\n-                                           tp));\n+            let val = trans_external_path(cx, did, {kinds: k, ty: tp});\n+            ret lval_no_env(cx, load_if_immediate(cx, val, tp), false);\n         }\n       }\n-      _ { ret trans_local_var(cx, def); }\n+      _ {\n+        let loc = trans_local_var(cx, def);\n+        ret lval_no_env(loc.bcx, loc.val, loc.is_mem);\n+      }\n     }\n }\n \n-fn trans_path(cx: @block_ctxt, p: ast::path, id: ast::node_id) ->\n-   lval_result {\n-    ret trans_var(cx, p.span, bcx_tcx(cx).def_map.get(id), id);\n+fn trans_field(cx: @block_ctxt, sp: span, base: @ast::expr,\n+               field: ast::ident) -> lval_maybe_callee {\n+    let {bcx, val} = trans_expr(cx, base);\n+    ret trans_field_inner(bcx, sp, val, ty::expr_ty(bcx_tcx(cx), base),\n+                          field);\n }\n \n-fn trans_field(cx: @block_ctxt, sp: span, v: ValueRef, t0: ty::t,\n-               field: ast::ident) -> lval_result {\n+fn trans_field_inner(cx: @block_ctxt, sp: span, v: ValueRef, t0: ty::t,\n+                     field: ast::ident) -> lval_maybe_callee {\n     let r = autoderef(cx, v, t0);\n     let t = r.ty;\n     alt ty::struct(bcx_tcx(cx), t) {\n       ty::ty_rec(fields) {\n         let ix: uint = ty::field_idx(bcx_ccx(cx).sess, sp, field, fields);\n         let v = GEP_tup_like(r.bcx, t, r.val, [0, ix as int]);\n-        ret lval_mem(v.bcx, v.val);\n+        ret lval_no_env(v.bcx, v.val, true);\n       }\n       ty::ty_obj(methods) {\n         let ix: uint = ty::method_idx(bcx_ccx(cx).sess, sp, field, methods);\n@@ -3005,9 +3008,9 @@ fn trans_field(cx: @block_ctxt, sp: span, v: ValueRef, t0: ty::t,\n             type_of_fn(bcx_ccx(cx), sp, ty::ty_fn_proto(tcx, fn_ty),\n                        true, ret_ref, ty::ty_fn_args(tcx, fn_ty),\n                        ty::ty_fn_ret(tcx, fn_ty), 0u);\n-        v = PointerCast(r.bcx, v, T_ptr(T_ptr(ll_fn_ty)));\n-        let lvo = lval_mem(r.bcx, v);\n-        ret {llobj: some::<ValueRef>(r.val) with lvo};\n+        v = Load(r.bcx, PointerCast(r.bcx, v, T_ptr(T_ptr(ll_fn_ty))));\n+        ret {bcx: r.bcx, val: v, is_mem: true,\n+             env: some_env(r.val), generic: none};\n       }\n       _ { bcx_ccx(cx).sess.unimpl(\"field variant in trans_field\"); }\n     }\n@@ -3062,16 +3065,38 @@ fn trans_index(cx: @block_ctxt, sp: span, base: @ast::expr, idx: @ast::expr,\n     ret lval_mem(next_cx, elt);\n }\n \n+fn trans_callee(cx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n+    alt e.node {\n+      ast::expr_path(p) { ret trans_path(cx, p, e.id); }\n+      ast::expr_field(base, ident) {\n+        ret trans_field(cx, e.span, base, ident);\n+      }\n+      ast::expr_self_method(ident) {\n+        alt cx.fcx.llself {\n+          some(pair) {\n+            ret trans_field_inner(cx, e.span, pair.v, pair.t, ident);\n+          }\n+        }\n+      }\n+      _ {\n+        let lv = trans_lval(cx, e);\n+        ret lval_no_env(lv.bcx, lv.val, lv.is_mem);\n+      }\n+    }\n+}\n+\n // The additional bool returned indicates whether it's mem (that is\n // represented as an alloca or heap, hence needs a 'load' to be used as an\n // immediate).\n-fn trans_lval_gen(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n+fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n     alt e.node {\n-      ast::expr_path(p) { ret trans_path(cx, p, e.id); }\n+      ast::expr_path(p) {\n+        let v = trans_path(cx, p, e.id);\n+        ret lval_maybe_callee_to_lval(v, ty::expr_ty(bcx_tcx(cx), e));\n+      }\n       ast::expr_field(base, ident) {\n-        let r = trans_expr(cx, base);\n-        let t = ty::expr_ty(bcx_tcx(cx), base);\n-        ret trans_field(r.bcx, e.span, r.val, t, ident);\n+        let f = trans_field(cx, e.span, base, ident);\n+        ret lval_maybe_callee_to_lval(f, ty::expr_ty(bcx_tcx(cx), e));\n       }\n       ast::expr_index(base, idx) {\n         ret trans_index(cx, e.span, base, idx, e.id);\n@@ -3103,39 +3128,45 @@ fn trans_lval_gen(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n             };\n         ret lval_mem(sub.bcx, val);\n       }\n-      ast::expr_self_method(ident) {\n-        alt copy cx.fcx.llself {\n-          some(pair) {\n-            ret trans_field(cx, e.span, pair.v, pair.t, ident);\n-          }\n-        }\n-      }\n       ast::expr_call(f, args) {\n         let {res: {bcx, val}, by_ref} =\n             trans_call(cx, f, none, args, e.id);\n         if by_ref { ret lval_mem(bcx, val); }\n         else { ret lval_val(bcx, val); }\n       }\n       _ {\n-        ret {res: trans_expr(cx, e),\n-             is_mem: false,\n-             generic: none,\n-             llobj: none};\n+        let res = trans_expr(cx, e);\n+        ret lval_val(res.bcx, res.val);\n       }\n     }\n }\n \n-fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n-    let lv = trans_lval_gen(cx, e);\n-    alt lv.generic {\n+fn maybe_add_env(bcx: @block_ctxt, c: lval_maybe_callee)\n+    -> (bool, ValueRef) {\n+    if c.env == is_closure {\n+        (c.is_mem, c.val)\n+    } else {\n+        let env = alt c.env {\n+          null_env. { C_null(T_opaque_closure_ptr(*bcx_ccx(bcx))) }\n+          some_env(e) { e }\n+        };\n+        let llfnty = llvm::LLVMGetElementType(val_ty(c.val));\n+        (false, create_real_fn_pair(bcx, llfnty, c.val, env))\n+    }\n+}\n+\n+fn lval_maybe_callee_to_lval(c: lval_maybe_callee, ty: ty::t) -> lval_result {\n+    alt c.generic {\n       some(gi) {\n-        let t = ty::expr_ty(bcx_tcx(cx), e);\n-        let n_args = std::vec::len(ty::ty_fn_args(bcx_tcx(cx), t));\n+        let n_args = std::vec::len(ty::ty_fn_args(bcx_tcx(c.bcx), ty));\n         let args = std::vec::init_elt(none::<@ast::expr>, n_args);\n-        let bound = trans_bind_1(lv.res.bcx, e, lv, args, e.id);\n-        ret lval_val(bound.bcx, bound.val);\n+        let {bcx, val} = trans_bind_1(c.bcx, ty, c, args, ty);\n+        ret lval_val(bcx, val);\n+      }\n+      none. {\n+        let (is_mem, val) = maybe_add_env(c.bcx, c);\n+        ret {bcx: c.bcx, val: val, is_mem: is_mem};\n       }\n-      none. { ret lv; }\n     }\n }\n \n@@ -3287,24 +3318,26 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n     // creating.  (In our running example, target is the function f.)  Pick\n     // out the pointer to the target function from the environment. The\n     // target function lives in the first binding spot.\n-    let (lltarget, starting_idx) =\n-        alt target_fn {\n-          some(lltarget) { (lltarget, 0) }\n-          none. {\n-            let lltarget =\n-                GEP_tup_like(bcx, closure_ty, llclosure,\n-                             [0, abi::box_rc_field_body,\n-                              abi::closure_elt_bindings, 0]);\n-            bcx = lltarget.bcx;;\n-            (lltarget.val, 1)\n-          }\n-        };\n+    let (lltargetfn, lltargetenv, starting_idx) = alt target_fn {\n+      some(fptr) {\n+        (fptr, C_null(T_opaque_closure_ptr(*bcx_ccx(bcx))), 0)\n+      }\n+      none. {\n+        let {bcx: cx, val: pair} =\n+            GEP_tup_like(bcx, closure_ty, llclosure,\n+                         [0, abi::box_rc_field_body,\n+                          abi::closure_elt_bindings, 0]);\n+        let lltargetenv =\n+            Load(cx, GEP(cx, pair, [C_int(0), C_int(abi::fn_field_box)]));\n+        let lltargetfn = Load\n+            (cx, GEP(cx, pair, [C_int(0), C_int(abi::fn_field_code)]));\n+        bcx = cx;\n+        (lltargetfn, lltargetenv, 1)\n+      }\n+    };\n \n     // And then, pick out the target function's own environment.  That's what\n     // we'll use as the environment the thunk gets.\n-    let lltargetclosure =\n-        GEP(bcx, lltarget, [C_int(0), C_int(abi::fn_field_box)]);\n-    lltargetclosure = Load(bcx, lltargetclosure);\n \n     // Get f's return type, which will also be the return type of the entire\n     // bind expression.\n@@ -3324,7 +3357,7 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n     }\n \n     // Set up the three implicit arguments to the thunk.\n-    let llargs: [ValueRef] = [llretptr, fcx.lltaskptr, lltargetclosure];\n+    let llargs: [ValueRef] = [llretptr, fcx.lltaskptr, lltargetenv];\n \n     // Copy in the type parameters.\n     let i: uint = 0u;\n@@ -3349,10 +3382,6 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n         let out_arg = outgoing_args[outgoing_arg_index];\n         let llout_arg_ty = llout_arg_tys[outgoing_arg_index];\n         alt arg {\n-\n-\n-\n-\n           // Arg provided at binding time; thunk copies it from\n           // closure.\n           some(e) {\n@@ -3371,8 +3400,6 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n             b += 1;\n           }\n \n-\n-\n           // Arg will be provided when the thunk is invoked.\n           none. {\n             let arg: ValueRef = llvm::LLVMGetParam(llthunk, a);\n@@ -3386,18 +3413,13 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n         outgoing_arg_index += 1u;\n     }\n \n-    let lltargetfn =\n-        GEP(bcx, lltarget, [C_int(0), C_int(abi::fn_field_code)]);\n-\n     // Cast the outgoing function to the appropriate type.\n     // This is necessary because the type of the function that we have\n     // in the closure does not know how many type descriptors the function\n     // needs to take.\n     let lltargetty =\n         type_of_fn_from_ty(bcx_ccx(bcx), sp, outgoing_fty, ty_param_count);\n-    lltargetfn = PointerCast(bcx, lltargetfn, T_ptr(T_ptr(lltargetty)));\n-    lltargetfn = Load(bcx, lltargetfn);\n-\n+    lltargetfn = PointerCast(bcx, lltargetfn, T_ptr(lltargetty));\n     FastCall(bcx, lltargetfn, llargs);\n     build_return(bcx);\n     finish_fn(fcx, lltop);\n@@ -3406,19 +3428,20 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n \n fn trans_bind(cx: @block_ctxt, f: @ast::expr, args: [option::t<@ast::expr>],\n               id: ast::node_id) -> result {\n-    let f_res = trans_lval_gen(cx, f);\n-    ret trans_bind_1(cx, f, f_res, args, id);\n+    let f_res = trans_callee(cx, f);\n+    ret trans_bind_1(cx, ty::expr_ty(bcx_tcx(cx), f), f_res, args,\n+                     ty::node_id_to_type(bcx_tcx(cx), id));\n }\n \n-fn trans_bind_1(cx: @block_ctxt, f: @ast::expr, f_res: lval_result,\n-                args: [option::t<@ast::expr>], id: ast::node_id) -> result {\n+fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n+                f_res: lval_maybe_callee,\n+                args: [option::t<@ast::expr>], pair_ty: ty::t) -> result {\n     let bound: [@ast::expr] = [];\n     for argopt: option::t<@ast::expr> in args {\n         alt argopt { none. { } some(e) { bound += [e]; } }\n     }\n \n     // Figure out which tydescs we need to pass, if any.\n-    let outgoing_fty: ty::t = ty::expr_ty(bcx_tcx(cx), f);\n     let outgoing_fty_real; // the type with typarams still in it\n     let lltydescs: [ValueRef];\n     alt f_res.generic {\n@@ -3432,33 +3455,40 @@ fn trans_bind_1(cx: @block_ctxt, f: @ast::expr, f_res: lval_result,\n \n     let ty_param_count = std::vec::len(lltydescs);\n     if std::vec::len(bound) == 0u && ty_param_count == 0u {\n-        // Trivial 'binding': just return the static pair-ptr.\n-        ret f_res.res;\n-    }\n-    let bcx = f_res.res.bcx;\n+        // Trivial 'binding': just return the closure\n+        let lv = lval_maybe_callee_to_lval(f_res, pair_ty);\n+        ret rslt(lv.bcx, lv.val);\n+    }\n+    let bcx = f_res.bcx;\n+    let (is_mem, closure) = alt f_res.env {\n+      null_env. { (true, none) }\n+      _ { let (mem, cl) = maybe_add_env(cx, f_res); (mem, some(cl)) }\n+    };\n \n     // FIXME: should follow from a precondition on trans_bind_1\n     let ccx = bcx_ccx(cx);\n     check (type_has_static_size(ccx, outgoing_fty));\n \n     // Arrange for the bound function to live in the first binding spot\n     // if the function is not statically known.\n-    let (bound_tys, bound_vals, target_res) =\n-        if f_res.is_mem {\n-            // Cast the function we are binding to be the type that the\n-            // closure will expect it to have. The type the closure knows\n-            // about has the type parameters substituted with the real types.\n-            let sp = cx.sp;\n-            let llclosurety = T_ptr(type_of(ccx, sp, outgoing_fty));\n-            let src_loc = PointerCast(bcx, f_res.res.val, llclosurety);\n-            let bound_f = {res: {bcx: bcx, val: src_loc} with f_res};\n-            ([outgoing_fty], [bound_f], none)\n-        } else { ([], [], some(f_res.res.val)) };\n+    let (bound_tys, bound_vals, target_res) = alt closure {\n+      some(cl) {\n+        // Cast the function we are binding to be the type that the\n+        // closure will expect it to have. The type the closure knows\n+        // about has the type parameters substituted with the real types.\n+        let sp = cx.sp;\n+        let llclosurety = T_ptr(type_of(ccx, sp, outgoing_fty));\n+        let src_loc = PointerCast(bcx, cl, llclosurety);\n+        let bound_f = {bcx: bcx, val: src_loc, is_mem: is_mem};\n+        ([outgoing_fty], [bound_f], none)\n+      }\n+      none. { ([], [], some(f_res.val)) }\n+    };\n \n     // Translate the bound expressions.\n     for e: @ast::expr in bound {\n         let lv = trans_lval(bcx, e);\n-        bcx = lv.res.bcx;\n+        bcx = lv.bcx;\n         bound_vals += [lv];\n         bound_tys += [ty::expr_ty(bcx_tcx(cx), e)];\n     }\n@@ -3469,8 +3499,6 @@ fn trans_bind_1(cx: @block_ctxt, f: @ast::expr, f_res: lval_result,\n     bcx = closure.bcx;\n \n     // Make thunk\n-    // The type of the entire bind expression.\n-    let pair_ty = node_id_type(bcx_ccx(cx), id);\n     let llthunk =\n         trans_bind_thunk(cx.fcx.lcx, cx.sp, pair_ty, outgoing_fty_real, args,\n                          closure.ptrty, ty_param_count, target_res);\n@@ -3490,8 +3518,8 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty0: TypeRef,\n     let e_ty = ty::expr_ty(ccx.tcx, e);\n     let is_bot = ty::type_is_bot(ccx.tcx, e_ty);\n     let lv = trans_lval(cx, e);\n-    let bcx = lv.res.bcx;\n-    let val = lv.res.val;\n+    let bcx = lv.bcx;\n+    let val = lv.val;\n     if is_bot {\n         // For values of type _|_, we generate an\n         // \"undef\" value, as such a value should never\n@@ -3530,8 +3558,8 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty0: TypeRef,\n         if lv.is_mem {\n             // Use actual ty, not declared ty -- anything else doesn't make\n             // sense if declared ty is a ty param\n-            to_zero += [{v: lv.res.val, t: e_ty}];\n-        } else { to_revoke += [{v: lv.res.val, t: e_ty}]; }\n+            to_zero += [{v: lv.val, t: e_ty}];\n+        } else { to_revoke += [{v: lv.val, t: e_ty}]; }\n     }\n     ret rslt(bcx, val);\n }\n@@ -3670,27 +3698,23 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     let by_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(bcx_tcx(in_cx),\n                                                           fn_expr_ty));\n     let cx = new_scope_block_ctxt(in_cx, \"call\");\n-    let f_res = trans_lval_gen(cx, f);\n-    let bcx = f_res.res.bcx;\n-\n-    let faddr = f_res.res.val;\n-    let llenv = C_null(T_opaque_closure_ptr(*bcx_ccx(cx)));\n-    alt f_res.llobj {\n-      some(ob) {\n-        // It's a vtbl entry.\n-        faddr = Load(bcx, faddr);\n-        llenv = ob;\n-      }\n-      none. {\n-        // It's a closure. We have to autoderef.\n+    let f_res = trans_callee(cx, f);\n+    let bcx = f_res.bcx;\n+\n+    let faddr = f_res.val;\n+    let llenv = alt f_res.env {\n+      null_env. { C_null(T_opaque_closure_ptr(*bcx_ccx(cx))) }\n+      some_env(e) { e }\n+      is_closure. {\n+        // It's a closure. Have to fetch the elements\n         if f_res.is_mem { faddr = load_if_immediate(bcx, faddr, fn_expr_ty); }\n         let pair = faddr;\n         faddr = GEP(bcx, pair, [C_int(0), C_int(abi::fn_field_code)]);\n         faddr = Load(bcx, faddr);\n         let llclosure = GEP(bcx, pair, [C_int(0), C_int(abi::fn_field_box)]);\n-        llenv = Load(bcx, llclosure);\n+        Load(bcx, llclosure)\n       }\n-    }\n+    };\n \n     let ret_ty = ty::node_id_to_type(bcx_tcx(cx), id);\n     let args_res =\n@@ -3854,7 +3878,7 @@ fn trans_tup(cx: @block_ctxt, elts: [@ast::expr], id: ast::node_id) ->\n     for e in elts {\n         let e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n         let src = trans_lval(bcx, e);\n-        bcx = src.res.bcx;\n+        bcx = src.bcx;\n         let dst_res = GEP_tup_like(bcx, t, tup_val, [0, i]);\n         bcx = move_val_if_temp(dst_res.bcx, INIT, dst_res.val, src, e_ty);\n         i += 1;\n@@ -3892,7 +3916,7 @@ fn trans_rec(cx: @block_ctxt, fields: [ast::field],\n                 expr_provided = true;\n                 let lv = trans_lval(bcx, f.node.expr);\n                 bcx =\n-                    move_val_if_temp(lv.res.bcx, INIT, dst_res.val, lv, e_ty);\n+                    move_val_if_temp(lv.bcx, INIT, dst_res.val, lv, e_ty);\n                 break;\n             }\n         }\n@@ -3972,13 +3996,13 @@ fn trans_expr_out(cx: @block_ctxt, e: @ast::expr, output: out_method) ->\n       ast::expr_copy(a) {\n         let e_ty = ty::expr_ty(bcx_tcx(cx), a);\n         let lv = trans_lval(cx, a);\n-        let bcx = lv.res.bcx;\n-        if !lv.is_mem { ret lv.res; }\n+        let bcx = lv.bcx;\n+        if !lv.is_mem { ret {bcx: lv.bcx, val: lv.val}; }\n         let r = if type_is_immediate(bcx_ccx(cx), e_ty) {\n-            rslt(bcx, Load(bcx, lv.res.val))\n+            rslt(bcx, Load(bcx, lv.val))\n         } else {\n             let {bcx, val: dest} = alloc_ty(bcx, e_ty);\n-            bcx = copy_val(bcx, INIT, dest, lv.res.val, e_ty);\n+            bcx = copy_val(bcx, INIT, dest, lv.val, e_ty);\n             rslt(bcx, dest)\n         };\n         add_clean_temp(bcx, r.val, e_ty);\n@@ -3987,43 +4011,43 @@ fn trans_expr_out(cx: @block_ctxt, e: @ast::expr, output: out_method) ->\n       ast::expr_move(dst, src) {\n         let lhs_res = trans_lval(cx, dst);\n         assert (lhs_res.is_mem);\n-        // FIXME Fill in lhs_res.res.bcx.sp\n+        // FIXME Fill in lhs_res.bcx.sp\n \n-        let rhs_res = trans_lval(lhs_res.res.bcx, src);\n+        let rhs_res = trans_lval(lhs_res.bcx, src);\n         let t = ty::expr_ty(bcx_tcx(cx), src);\n         // FIXME: calculate copy init-ness in typestate.\n \n         let bcx =\n-            move_val(rhs_res.res.bcx, DROP_EXISTING, lhs_res.res.val, rhs_res,\n+            move_val(rhs_res.bcx, DROP_EXISTING, lhs_res.val, rhs_res,\n                      t);\n         ret rslt(bcx, C_nil());\n       }\n       ast::expr_assign(dst, src) {\n         let lhs_res = trans_lval(cx, dst);\n         assert (lhs_res.is_mem);\n-        // FIXME Fill in lhs_res.res.bcx.sp\n-        let rhs = trans_lval(lhs_res.res.bcx, src);\n+        // FIXME Fill in lhs_res.bcx.sp\n+        let rhs = trans_lval(lhs_res.bcx, src);\n         let t = ty::expr_ty(bcx_tcx(cx), src);\n         // FIXME: calculate copy init-ness in typestate.\n         let bcx =\n-            move_val_if_temp(rhs.res.bcx, DROP_EXISTING, lhs_res.res.val, rhs,\n+            move_val_if_temp(rhs.bcx, DROP_EXISTING, lhs_res.val, rhs,\n                              t);\n         ret rslt(bcx, C_nil());\n       }\n       ast::expr_swap(dst, src) {\n         let lhs_res = trans_lval(cx, dst);\n         assert (lhs_res.is_mem);\n-        // FIXME Fill in lhs_res.res.bcx.sp\n+        // FIXME Fill in lhs_res.bcx.sp\n \n-        let rhs_res = trans_lval(lhs_res.res.bcx, src);\n+        let rhs_res = trans_lval(lhs_res.bcx, src);\n         let t = ty::expr_ty(bcx_tcx(cx), src);\n-        let {bcx: bcx, val: tmp_alloc} = alloc_ty(rhs_res.res.bcx, t);\n+        let {bcx: bcx, val: tmp_alloc} = alloc_ty(rhs_res.bcx, t);\n         // Swap through a temporary.\n \n         bcx = move_val(bcx, INIT, tmp_alloc, lhs_res, t);\n-        bcx = move_val(bcx, INIT, lhs_res.res.val, rhs_res, t);\n+        bcx = move_val(bcx, INIT, lhs_res.val, rhs_res, t);\n         bcx =\n-            move_val(bcx, INIT, rhs_res.res.val, lval_mem(bcx, tmp_alloc), t);\n+            move_val(bcx, INIT, rhs_res.val, lval_mem(bcx, tmp_alloc), t);\n         ret rslt(bcx, C_nil());\n       }\n       ast::expr_assign_op(op, dst, src) {\n@@ -4038,8 +4062,8 @@ fn trans_expr_out(cx: @block_ctxt, e: @ast::expr, output: out_method) ->\n             alt src.node {\n               ast::expr_vec(args, _) {\n                 let bcx =\n-                    tvec::trans_append_literal(lhs_res.res.bcx,\n-                                               lhs_res.res.val, t, args);\n+                    tvec::trans_append_literal(lhs_res.bcx,\n+                                               lhs_res.val, t, args);\n                 ret rslt(bcx, C_nil());\n               }\n               _ { }\n@@ -4048,24 +4072,24 @@ fn trans_expr_out(cx: @block_ctxt, e: @ast::expr, output: out_method) ->\n           _ { }\n         }\n \n-        // FIXME Fill in lhs_res.res.bcx.sp\n-        let rhs_res = trans_expr(lhs_res.res.bcx, src);\n+        // FIXME Fill in lhs_res.bcx.sp\n+        let rhs_res = trans_expr(lhs_res.bcx, src);\n         if ty::type_is_sequence(tcx, t) {\n             alt op {\n               ast::add. {\n-                ret tvec::trans_append(rhs_res.bcx, t, lhs_res.res.val,\n+                ret tvec::trans_append(rhs_res.bcx, t, lhs_res.val,\n                                        rhs_res.val);\n               }\n               _ { }\n             }\n         }\n-        let lhs_val = load_if_immediate(rhs_res.bcx, lhs_res.res.val, t);\n+        let lhs_val = load_if_immediate(rhs_res.bcx, lhs_res.val, t);\n         let v =\n             trans_eager_binop(rhs_res.bcx, op, lhs_val, t, rhs_res.val, t);\n         // FIXME: calculate copy init-ness in typestate.\n         // This is always a temporary, so can always be safely moved\n         let bcx =\n-            move_val(v.bcx, DROP_EXISTING, lhs_res.res.val,\n+            move_val(v.bcx, DROP_EXISTING, lhs_res.val,\n                      lval_val(v.bcx, v.val), t);\n         ret rslt(bcx, C_nil());\n       }\n@@ -4120,9 +4144,9 @@ fn trans_expr_out(cx: @block_ctxt, e: @ast::expr, output: out_method) ->\n       ast::expr_path(_) | ast::expr_unary(ast::deref., _) {\n         let t = ty::expr_ty(bcx_tcx(cx), e);\n         let sub = trans_lval(cx, e);\n-        let v = sub.res.val;\n-        if sub.is_mem { v = load_if_immediate(sub.res.bcx, v, t); }\n-        ret rslt(sub.res.bcx, v);\n+        let v = sub.val;\n+        if sub.is_mem { v = load_if_immediate(sub.bcx, v, t); }\n+        ret rslt(sub.bcx, v);\n       }\n       ast::expr_unary(op, x) {\n         ret trans_unary(cx, op, x, e.id);\n@@ -4412,10 +4436,10 @@ fn trans_ret(cx: @block_ctxt, e: option::t<@ast::expr>) -> result {\n       some(x) {\n         let t = ty::expr_ty(bcx_tcx(cx), x);\n         let lv = trans_lval(cx, x);\n-        bcx = lv.res.bcx;\n+        bcx = lv.bcx;\n         if ast_util::ret_by_ref(cx.fcx.ret_style) {\n             assert lv.is_mem;\n-            Store(bcx, lv.res.val, cx.fcx.llretptr);\n+            Store(bcx, lv.val, cx.fcx.llretptr);\n         } else {\n             let is_local = alt x.node {\n               ast::expr_path(p) {\n@@ -4484,11 +4508,11 @@ fn init_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n             // the value.\n             ty = node_id_type(bcx_ccx(bcx), init.expr.id);\n             let sub = trans_lval(bcx, init.expr);\n-            bcx = move_val_if_temp(sub.res.bcx, INIT, llptr, sub, ty);\n+            bcx = move_val_if_temp(sub.bcx, INIT, llptr, sub, ty);\n           }\n           ast::init_move. {\n             let sub = trans_lval(bcx, init.expr);\n-            bcx = move_val(sub.res.bcx, INIT, llptr, sub, ty);\n+            bcx = move_val(sub.bcx, INIT, llptr, sub, ty);\n           }\n         }\n       }\n@@ -4538,9 +4562,8 @@ fn init_ref_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     let init_expr = option::get(local.node.init).expr;\n     let val = trans_lval(bcx, init_expr);\n     assert val.is_mem;\n-    ret trans_alt::bind_irrefutable_pat(val.res.bcx, local.node.pat,\n-                                        val.res.val,\n-                                        bcx.fcx.lllocals, false);\n+    ret trans_alt::bind_irrefutable_pat(val.bcx, local.node.pat,\n+                                        val.val, bcx.fcx.lllocals, false);\n }\n \n fn zero_alloca(cx: @block_ctxt, llptr: ValueRef, t: ty::t) -> result {\n@@ -4806,7 +4829,7 @@ fn trans_block(cx: @block_ctxt, b: ast::blk, output: out_method) -> result {\n             if is_terminated(bcx) || ty::type_is_bot(ccx.tcx, r_ty) { ret r; }\n         } else {\n             let lv = trans_lval(bcx, e);\n-            r = lv.res;\n+            r = {bcx: lv.bcx, val: lv.val};\n             bcx = r.bcx;\n             if is_terminated(bcx) || ty::type_is_bot(ccx.tcx, r_ty) { ret r; }\n             alt output {"}, {"sha": "5c04aafeedaa69b6146035678c9ed75146806bc0", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66153436c9070386786c8a38cde199b5d3e71289/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66153436c9070386786c8a38cde199b5d3e71289/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=66153436c9070386786c8a38cde199b5d3e71289", "patch": "@@ -117,7 +117,7 @@ fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id) ->\n     let i = 0u;\n     for e in args {\n         let lv = trans_lval(bcx, e);\n-        bcx = lv.res.bcx;\n+        bcx = lv.bcx;\n         let lleltptr =\n             if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n                 InBoundsGEP(bcx, dataptr, [Mul(bcx, C_uint(i), llunitsz)])"}, {"sha": "e832b558ca05f25a372132d40648133e7c4829e4", "filename": "src/test/run-pass/standalone-method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66153436c9070386786c8a38cde199b5d3e71289/src%2Ftest%2Frun-pass%2Fstandalone-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66153436c9070386786c8a38cde199b5d3e71289/src%2Ftest%2Frun-pass%2Fstandalone-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstandalone-method.rs?ref=66153436c9070386786c8a38cde199b5d3e71289", "patch": "@@ -1,6 +1,6 @@\n // Test case for issue #435.\n-obj foo() {\n-    fn add5(n: int) -> int { ret n + 5; }\n+obj foo(x: int) {\n+    fn add5(n: int) -> int { ret n + x; }\n }\n \n fn add5(n: int) -> int { ret n + 5; }\n@@ -10,7 +10,7 @@ fn main() {\n     assert (add5(7) == 12);\n     assert (fiveplusseven() == 12);\n \n-    let my_foo = foo();\n+    let my_foo = foo(5);\n     let fiveplusseven_too = bind my_foo.add5(7);\n     assert (my_foo.add5(7) == 12);\n     assert (fiveplusseven_too() == 12);"}]}