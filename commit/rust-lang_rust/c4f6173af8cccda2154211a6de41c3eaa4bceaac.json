{"sha": "c4f6173af8cccda2154211a6de41c3eaa4bceaac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0ZjYxNzNhZjhjY2NkYTIxNTQyMTFhNmRlNDFjM2VhYTRiY2VhYWM=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-16T23:45:52Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:03:27Z"}, "message": "Replace init with get_entry_block.", "tree": {"sha": "d49cf6b16373139e7a6b055c1ca503dcc0f1009f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d49cf6b16373139e7a6b055c1ca503dcc0f1009f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4f6173af8cccda2154211a6de41c3eaa4bceaac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4f6173af8cccda2154211a6de41c3eaa4bceaac", "html_url": "https://github.com/rust-lang/rust/commit/c4f6173af8cccda2154211a6de41c3eaa4bceaac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4f6173af8cccda2154211a6de41c3eaa4bceaac/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbbdb73eb07fb9a29e20f4fb16b8f1c059e9763f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbbdb73eb07fb9a29e20f4fb16b8f1c059e9763f", "html_url": "https://github.com/rust-lang/rust/commit/cbbdb73eb07fb9a29e20f4fb16b8f1c059e9763f"}], "stats": {"total": 95, "additions": 44, "deletions": 51}, "files": [{"sha": "30c1074b89c1ecc7b06f017d797e09da526a7a11", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c4f6173af8cccda2154211a6de41c3eaa4bceaac/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f6173af8cccda2154211a6de41c3eaa4bceaac/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=c4f6173af8cccda2154211a6de41c3eaa4bceaac", "patch": "@@ -657,11 +657,11 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n \n     // Builds the return block for a function.\n     pub fn build_return_block(&self, ret_cx: &BlockAndBuilder<'blk, 'tcx>) {\n-        if self.llretslotptr.get().is_none() || self.fn_ty.ret.is_indirect() {\n+        if self.llretslotptr.is_none() || self.fn_ty.ret.is_indirect() {\n             return ret_cx.ret_void();\n         }\n \n-        let retslot = self.llretslotptr.get().unwrap();\n+        let retslot = self.llretslotptr.unwrap();\n         let retptr = Value(retslot);\n         let llty = self.fn_ty.ret.original_ty;\n         match (retptr.get_dominating_store(ret_cx), self.fn_ty.ret.cast) {\n@@ -751,7 +751,7 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n \n     let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n \n-    let fcx = FunctionContext::new(ccx, lldecl, fn_ty, Some((instance, &sig, abi)));\n+    let fcx = FunctionContext::new(ccx, lldecl, fn_ty, Some((instance, &sig, abi)), true);\n \n     if fcx.mir.is_none() {\n         bug!(\"attempted translation of `{}` w/o MIR\", instance);\n@@ -774,11 +774,11 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&ctor_ty.fn_sig());\n     let fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n \n-    let fcx = FunctionContext::new(ccx, llfndecl, fn_ty, None);\n-    let bcx = fcx.init(false);\n+    let fcx = FunctionContext::new(ccx, llfndecl, fn_ty, None, false);\n+    let bcx = fcx.get_entry_block();\n \n     if !fcx.fn_ty.ret.is_ignore() {\n-        let dest = fcx.llretslotptr.get().unwrap();\n+        let dest = fcx.llretslotptr.unwrap();\n         let dest_val = adt::MaybeSizedValue::sized(dest); // Can return unsized value\n         let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n         let mut arg_idx = 0;"}, {"sha": "8c880210f62f0f9d47384f0922304de35c52d4fe", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c4f6173af8cccda2154211a6de41c3eaa4bceaac/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f6173af8cccda2154211a6de41c3eaa4bceaac/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=c4f6173af8cccda2154211a6de41c3eaa4bceaac", "patch": "@@ -347,8 +347,8 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let lloncefn = declare::define_internal_fn(ccx, &function_name, llonce_fn_ty);\n     attributes::set_frame_pointer_elimination(ccx, lloncefn);\n \n-    let fcx = FunctionContext::new(ccx, lloncefn, fn_ty, None);\n-    let mut bcx = fcx.init(false);\n+    let fcx = FunctionContext::new(ccx, lloncefn, fn_ty, None, false);\n+    let mut bcx = fcx.get_entry_block();\n \n     // the first argument (`self`) will be the (by value) closure env.\n \n@@ -378,8 +378,6 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n         llargs[self_idx] = llenv;\n     }\n \n-    let dest = fcx.llretslotptr.get();\n-\n     let callee = Callee {\n         data: Fn(llreffn),\n         ty: llref_fn_ty\n@@ -392,7 +390,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let fn_ty = callee.direct_fn_type(bcx.ccx(), &[]);\n \n     let first_llarg = if fn_ty.ret.is_indirect() {\n-        dest\n+        fcx.llretslotptr\n     } else {\n         None\n     };\n@@ -411,7 +409,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     fn_ty.apply_attrs_callsite(llret);\n \n     if !fn_ty.ret.is_indirect() {\n-        if let Some(llretslot) = dest {\n+        if let Some(llretslot) = fcx.llretslotptr {\n             fn_ty.ret.store(&bcx, llret, llretslot);\n         }\n     }\n@@ -521,8 +519,8 @@ fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llfn = declare::define_internal_fn(ccx, &function_name, tuple_fn_ty);\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n     //\n-    let fcx = FunctionContext::new(ccx, llfn, fn_ty, None);\n-    let bcx = fcx.init(false);\n+    let fcx = FunctionContext::new(ccx, llfn, fn_ty, None, false);\n+    let bcx = fcx.get_entry_block();\n \n     let llargs = get_params(fcx.llfn);\n \n@@ -536,13 +534,11 @@ fn trans_fn_pointer_shim<'a, 'tcx>(\n         }\n     });\n \n-    let dest = fcx.llretslotptr.get();\n-\n     let callee = Callee {\n         data: Fn(llfnpointer),\n         ty: bare_fn_ty\n     };\n-    let bcx = callee.call(bcx, &llargs[(self_idx + 1)..], dest, None).0;\n+    let bcx = callee.call(bcx, &llargs[(self_idx + 1)..], fcx.llretslotptr, None).0;\n     fcx.finish(&bcx);\n \n     ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty_maybe_ref, llfn);"}, {"sha": "610c4cfd1087993fe15f3aea7ca0524f2d97480f", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c4f6173af8cccda2154211a6de41c3eaa4bceaac/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f6173af8cccda2154211a6de41c3eaa4bceaac/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=c4f6173af8cccda2154211a6de41c3eaa4bceaac", "patch": "@@ -276,7 +276,7 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // immediate, this points to an alloca in the function. Otherwise, it's a\n     // pointer to the hidden first parameter of the function. After function\n     // construction, this should always be Some.\n-    pub llretslotptr: Cell<Option<ValueRef>>,\n+    pub llretslotptr: Option<ValueRef>,\n \n     // These pub elements: \"hoisted basic blocks\" containing\n     // administrative activities that have to happen in only one place in\n@@ -311,13 +311,14 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     /// Create a function context for the given function.\n-    /// Beware that you must call `fcx.init` before doing anything with the returned function\n-    /// context.\n-    pub fn new(ccx: &'a CrateContext<'a, 'tcx>,\n-               llfndecl: ValueRef,\n-               fn_ty: FnType,\n-               definition: Option<(Instance<'tcx>, &ty::FnSig<'tcx>, Abi)>)\n-               -> FunctionContext<'a, 'tcx> {\n+    /// Call FunctionContext::get_entry_block for the first entry block.\n+    pub fn new(\n+        ccx: &'a CrateContext<'a, 'tcx>,\n+        llfndecl: ValueRef,\n+        fn_ty: FnType,\n+        definition: Option<(Instance<'tcx>, &ty::FnSig<'tcx>, Abi)>,\n+        skip_retptr: bool,\n+    ) -> FunctionContext<'a, 'tcx> {\n         let (param_substs, def_id) = match definition {\n             Some((instance, ..)) => {\n                 validate_substs(instance.substs);\n@@ -350,7 +351,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         let mut fcx = FunctionContext {\n             mir: mir,\n             llfn: llfndecl,\n-            llretslotptr: Cell::new(None),\n+            llretslotptr: None,\n             param_env: ccx.tcx().empty_parameter_environment(),\n             alloca_insert_pt: None,\n             landingpad_alloca: Cell::new(None),\n@@ -372,31 +373,28 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         // This is later removed in the drop of FunctionContext.\n         fcx.alloca_insert_pt = Some(val);\n \n-        fcx\n-    }\n-\n-    /// Performs setup on a newly created function, creating the entry\n-    /// scope block and allocating space for the return pointer.\n-    pub fn init(&'a self, skip_retptr: bool) -> BlockAndBuilder<'a, 'tcx> {\n-        if !self.fn_ty.ret.is_ignore() && !skip_retptr {\n-            // We normally allocate the llretslotptr, unless we\n-            // have been instructed to skip it for immediate return\n-            // values, or there is nothing to return at all.\n-\n+        // We normally allocate the llretslotptr, unless we\n+        // have been instructed to skip it for immediate return\n+        // values, or there is nothing to return at all.\n+        if !fcx.fn_ty.ret.is_ignore() && !skip_retptr {\n             // But if there are no nested returns, we skip the indirection\n             // and have a single retslot\n-            let slot = if self.fn_ty.ret.is_indirect() {\n-                get_param(self.llfn, 0)\n+            let slot = if fcx.fn_ty.ret.is_indirect() {\n+                get_param(fcx.llfn, 0)\n             } else {\n                 // We create an alloca to hold a pointer of type `ret.original_ty`\n                 // which will hold the pointer to the right alloca which has the\n                 // final ret value\n-                self.alloca(self.fn_ty.ret.memory_ty(self.ccx), \"sret_slot\")\n+                fcx.alloca(fcx.fn_ty.ret.memory_ty(ccx), \"sret_slot\")\n             };\n \n-            self.llretslotptr.set(Some(slot));\n+            fcx.llretslotptr = Some(slot);\n         }\n \n+        fcx\n+    }\n+\n+    pub fn get_entry_block(&'a self) -> BlockAndBuilder<'a, 'tcx> {\n         BlockAndBuilder::new(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn)\n         }, self)"}, {"sha": "1f58327555e25f93c6139d8b8d2f59db77a26ee0", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c4f6173af8cccda2154211a6de41c3eaa4bceaac/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f6173af8cccda2154211a6de41c3eaa4bceaac/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=c4f6173af8cccda2154211a6de41c3eaa4bceaac", "patch": "@@ -202,9 +202,8 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     assert_eq!(g.ty(), get_drop_glue_type(tcx, g.ty()));\n     let (llfn, fn_ty) = ccx.drop_glues().borrow().get(&g).unwrap().clone();\n \n-    let fcx = FunctionContext::new(ccx, llfn, fn_ty, None);\n-\n-    let bcx = fcx.init(false);\n+    let fcx = FunctionContext::new(ccx, llfn, fn_ty, None, false);\n+    let bcx = fcx.get_entry_block();\n \n     ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1);\n     // All glue functions take values passed *by alias*; this is a"}, {"sha": "ec6b908c26485f08e0a8c27500c8de209abfb949", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4f6173af8cccda2154211a6de41c3eaa4bceaac/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f6173af8cccda2154211a6de41c3eaa4bceaac/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=c4f6173af8cccda2154211a6de41c3eaa4bceaac", "patch": "@@ -965,8 +965,8 @@ fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         sig: ty::Binder(sig)\n     }));\n     let llfn = declare::define_internal_fn(ccx, name, rust_fn_ty);\n-    let fcx = FunctionContext::new(ccx, llfn, fn_ty, None);\n-    trans(fcx.init(true));\n+    let fcx = FunctionContext::new(ccx, llfn, fn_ty, None, true);\n+    trans(fcx.get_entry_block());\n     llfn\n }\n "}, {"sha": "99330c1253765a2270344fa99be0d0097f6485e1", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c4f6173af8cccda2154211a6de41c3eaa4bceaac/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f6173af8cccda2154211a6de41c3eaa4bceaac/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=c4f6173af8cccda2154211a6de41c3eaa4bceaac", "patch": "@@ -81,12 +81,12 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     let llfn = declare::define_internal_fn(ccx, &function_name, callee.ty);\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n \n-    let fcx = FunctionContext::new(ccx, llfn, fn_ty, None);\n-    let mut bcx = fcx.init(false);\n+    let fcx = FunctionContext::new(ccx, llfn, fn_ty, None, false);\n+    let mut bcx = fcx.get_entry_block();\n \n-    let dest = fcx.llretslotptr.get();\n     let llargs = get_params(fcx.llfn);\n-    bcx = callee.call(bcx, &llargs[fcx.fn_ty.ret.is_indirect() as usize..], dest, None).0;\n+    bcx = callee.call(bcx, &llargs[fcx.fn_ty.ret.is_indirect() as usize..], fcx.llretslotptr,\n+        None).0;\n \n     fcx.finish(&bcx);\n "}, {"sha": "f02a8f725f78dcc46352b2d4d16aeed1db8ee9c4", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4f6173af8cccda2154211a6de41c3eaa4bceaac/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f6173af8cccda2154211a6de41c3eaa4bceaac/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=c4f6173af8cccda2154211a6de41c3eaa4bceaac", "patch": "@@ -180,7 +180,7 @@ impl<'tcx> LocalRef<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n \n pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n-    let bcx = fcx.init(true);\n+    let bcx = fcx.get_entry_block();\n     let mir = fcx.mir();\n \n     // Analyze the temps to determine which must be lvalues"}]}