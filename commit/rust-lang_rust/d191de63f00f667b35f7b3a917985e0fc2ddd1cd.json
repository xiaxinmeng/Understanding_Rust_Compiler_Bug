{"sha": "d191de63f00f667b35f7b3a917985e0fc2ddd1cd", "node_id": "C_kwDOAAsO6NoAKGQxOTFkZTYzZjAwZjY2N2IzNWY3YjNhOTE3OTg1ZTBmYzJkZGQxY2Q", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-02-20T10:38:48Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-02-20T10:38:48Z"}, "message": "Prepare for adding a `TyCtxt` to `Resolver`", "tree": {"sha": "f3e71b565b0e15a7b380b88a05456af4c52faf27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3e71b565b0e15a7b380b88a05456af4c52faf27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d191de63f00f667b35f7b3a917985e0fc2ddd1cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d191de63f00f667b35f7b3a917985e0fc2ddd1cd", "html_url": "https://github.com/rust-lang/rust/commit/d191de63f00f667b35f7b3a917985e0fc2ddd1cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d191de63f00f667b35f7b3a917985e0fc2ddd1cd/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e253a7fb2e2e050021fed32da6fa2ec7bcea0fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e253a7fb2e2e050021fed32da6fa2ec7bcea0fb", "html_url": "https://github.com/rust-lang/rust/commit/7e253a7fb2e2e050021fed32da6fa2ec7bcea0fb"}], "stats": {"total": 441, "additions": 247, "deletions": 194}, "files": [{"sha": "78a0d0a2a5aee6ad5101e483b9e2963c16754a44", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 38, "deletions": 27, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d191de63f00f667b35f7b3a917985e0fc2ddd1cd/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d191de63f00f667b35f7b3a917985e0fc2ddd1cd/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=d191de63f00f667b35f7b3a917985e0fc2ddd1cd", "patch": "@@ -133,8 +133,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some(self.new_module(\n                         parent,\n                         ModuleKind::Def(def_kind, def_id, name),\n-                        self.cstore().module_expansion_untracked(def_id, &self.session),\n-                        self.cstore().get_span_untracked(def_id, &self.session),\n+                        self.cstore().module_expansion_untracked(def_id, &self.tcx.sess),\n+                        self.cstore().get_span_untracked(def_id, &self.tcx.sess),\n                         // FIXME: Account for `#[no_implicit_prelude]` attributes.\n                         parent.map_or(false, |module| module.no_implicit_prelude),\n                     ))\n@@ -179,7 +179,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             return macro_data.clone();\n         }\n \n-        let (ext, macro_rules) = match self.cstore().load_macro_untracked(def_id, &self.session) {\n+        let (ext, macro_rules) = match self.cstore().load_macro_untracked(def_id, &self.tcx.sess) {\n             LoadedMacro::MacroDef(item, edition) => (\n                 Lrc::new(self.compile_macro(&item, edition).0),\n                 matches!(item.kind, ItemKind::MacroDef(def) if def.macro_rules),\n@@ -205,7 +205,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     pub(crate) fn build_reduced_graph_external(&mut self, module: Module<'a>) {\n         for child in\n-            Vec::from_iter(self.cstore().module_children_untracked(module.def_id(), self.session))\n+            Vec::from_iter(self.cstore().module_children_untracked(module.def_id(), self.tcx.sess))\n         {\n             let parent_scope = ParentScope::module(module, self);\n             BuildReducedGraphVisitor { r: self, parent_scope }\n@@ -346,7 +346,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n \n     fn insert_field_names_extern(&mut self, def_id: DefId) {\n         let field_names =\n-            self.r.cstore().struct_field_names_untracked(def_id, self.r.session).collect();\n+            self.r.cstore().struct_field_names_untracked(def_id, self.r.tcx.sess).collect();\n         self.r.field_names.insert(def_id, field_names);\n     }\n \n@@ -539,14 +539,15 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                         }\n \n                         self.r\n-                            .session\n+                            .tcx\n+                            .sess\n                             .struct_span_err(item.span, \"`$crate` may not be imported\")\n                             .emit();\n                     }\n                 }\n \n                 if ident.name == kw::Crate {\n-                    self.r.session.span_err(\n+                    self.r.tcx.sess.span_err(\n                         ident.span,\n                         \"crate root imports need to be explicitly named: \\\n                          `use crate as name;`\",\n@@ -575,7 +576,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             }\n             ast::UseTreeKind::Glob => {\n                 let kind = ImportKind::Glob {\n-                    is_prelude: self.r.session.contains_name(&item.attrs, sym::prelude_import),\n+                    is_prelude: self.r.tcx.sess.contains_name(&item.attrs, sym::prelude_import),\n                     max_vis: Cell::new(None),\n                     id,\n                 };\n@@ -690,7 +691,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                     expansion.to_expn_id(),\n                     item.span,\n                     parent.no_implicit_prelude\n-                        || self.r.session.contains_name(&item.attrs, sym::no_implicit_prelude),\n+                        || self.r.tcx.sess.contains_name(&item.attrs, sym::no_implicit_prelude),\n                 );\n                 self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n \n@@ -755,7 +756,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                     // If the structure is marked as non_exhaustive then lower the visibility\n                     // to within the crate.\n                     let mut ctor_vis = if vis.is_public()\n-                        && self.r.session.contains_name(&item.attrs, sym::non_exhaustive)\n+                        && self.r.tcx.sess.contains_name(&item.attrs, sym::non_exhaustive)\n                     {\n                         ty::Visibility::Restricted(CRATE_DEF_ID)\n                     } else {\n@@ -837,7 +838,8 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n \n         let (used, module, binding) = if orig_name.is_none() && ident.name == kw::SelfLower {\n             self.r\n-                .session\n+                .tcx\n+                .sess\n                 .struct_span_err(item.span, \"`extern crate self;` requires renaming\")\n                 .span_suggestion(\n                     item.span,\n@@ -887,7 +889,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                 {\n                     let msg = \"macro-expanded `extern crate` items cannot \\\n                                        shadow names passed with `--extern`\";\n-                    self.r.session.span_err(item.span, msg);\n+                    self.r.tcx.sess.span_err(item.span, msg);\n                 }\n             }\n             let entry = self.r.extern_prelude.entry(ident.normalize_to_macros_2_0()).or_insert(\n@@ -1014,7 +1016,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             }\n             Res::Def(DefKind::Union, def_id) => self.insert_field_names_extern(def_id),\n             Res::Def(DefKind::AssocFn, def_id) => {\n-                if cstore.fn_has_self_parameter_untracked(def_id, self.r.session) {\n+                if cstore.fn_has_self_parameter_untracked(def_id, self.r.tcx.sess) {\n                     self.r.has_self.insert(def_id);\n                 }\n             }\n@@ -1033,7 +1035,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             let msg = format!(\"`{}` is already in scope\", name);\n             let note =\n                 \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";\n-            self.r.session.struct_span_err(span, &msg).note(note).emit();\n+            self.r.tcx.sess.struct_span_err(span, &msg).note(note).emit();\n         }\n     }\n \n@@ -1045,7 +1047,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             if attr.has_name(sym::macro_use) {\n                 if self.parent_scope.module.parent.is_some() {\n                     struct_span_err!(\n-                        self.r.session,\n+                        self.r.tcx.sess,\n                         item.span,\n                         E0468,\n                         \"an `extern crate` loading macros must be at the crate root\"\n@@ -1055,7 +1057,8 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                 if let ItemKind::ExternCrate(Some(orig_name)) = item.kind {\n                     if orig_name == kw::SelfLower {\n                         self.r\n-                            .session\n+                            .tcx\n+                            .sess\n                             .struct_span_err(\n                                 attr.span,\n                                 \"`#[macro_use]` is not supported on `extern crate self`\",\n@@ -1064,7 +1067,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                     }\n                 }\n                 let ill_formed = |span| {\n-                    struct_span_err!(self.r.session, span, E0466, \"bad macro import\").emit();\n+                    struct_span_err!(self.r.tcx.sess, span, E0466, \"bad macro import\").emit();\n                 };\n                 match attr.meta() {\n                     Some(meta) => match meta.kind {\n@@ -1135,8 +1138,13 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                         allow_shadowing,\n                     );\n                 } else {\n-                    struct_span_err!(self.r.session, ident.span, E0469, \"imported macro not found\")\n-                        .emit();\n+                    struct_span_err!(\n+                        self.r.tcx.sess,\n+                        ident.span,\n+                        E0469,\n+                        \"imported macro not found\"\n+                    )\n+                    .emit();\n                 }\n             }\n         }\n@@ -1148,7 +1156,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         for attr in attrs {\n             if attr.has_name(sym::macro_escape) {\n                 let msg = \"`#[macro_escape]` is a deprecated synonym for `#[macro_use]`\";\n-                let mut err = self.r.session.struct_span_warn(attr.span, msg);\n+                let mut err = self.r.tcx.sess.struct_span_warn(attr.span, msg);\n                 if let ast::AttrStyle::Inner = attr.style {\n                     err.help(\"try an outer attribute: `#[macro_use]`\").emit();\n                 } else {\n@@ -1159,7 +1167,10 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             }\n \n             if !attr.is_word() {\n-                self.r.session.span_err(attr.span, \"arguments to `macro_use` are not allowed here\");\n+                self.r\n+                    .tcx\n+                    .sess\n+                    .span_err(attr.span, \"arguments to `macro_use` are not allowed here\");\n             }\n             return true;\n         }\n@@ -1183,11 +1194,11 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n     }\n \n     fn proc_macro_stub(&self, item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n-        if self.r.session.contains_name(&item.attrs, sym::proc_macro) {\n+        if self.r.tcx.sess.contains_name(&item.attrs, sym::proc_macro) {\n             return Some((MacroKind::Bang, item.ident, item.span));\n-        } else if self.r.session.contains_name(&item.attrs, sym::proc_macro_attribute) {\n+        } else if self.r.tcx.sess.contains_name(&item.attrs, sym::proc_macro_attribute) {\n             return Some((MacroKind::Attr, item.ident, item.span));\n-        } else if let Some(attr) = self.r.session.find_by_name(&item.attrs, sym::proc_macro_derive)\n+        } else if let Some(attr) = self.r.tcx.sess.find_by_name(&item.attrs, sym::proc_macro_derive)\n         {\n             if let Some(nested_meta) = attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n                 if let Some(ident) = nested_meta.ident() {\n@@ -1222,7 +1233,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         let def_id = self.r.local_def_id(item.id);\n         let (ext, ident, span, macro_rules, rule_spans) = match &item.kind {\n             ItemKind::MacroDef(def) => {\n-                let (ext, rule_spans) = self.r.compile_macro(item, self.r.session.edition());\n+                let (ext, rule_spans) = self.r.compile_macro(item, self.r.tcx.sess.edition());\n                 let ext = Lrc::new(ext);\n                 (ext, item.ident, item.span, def.macro_rules, rule_spans)\n             }\n@@ -1243,7 +1254,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         if macro_rules {\n             let ident = ident.normalize_to_macros_2_0();\n             self.r.macro_names.insert(ident);\n-            let is_macro_export = self.r.session.contains_name(&item.attrs, sym::macro_export);\n+            let is_macro_export = self.r.tcx.sess.contains_name(&item.attrs, sym::macro_export);\n             let vis = if is_macro_export {\n                 ty::Visibility::Public\n             } else {\n@@ -1507,7 +1518,7 @@ impl<'a, 'b, 'tcx> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n \n         // If the variant is marked as non_exhaustive then lower the visibility to within the crate.\n         let ctor_vis = if vis.is_public()\n-            && self.r.session.contains_name(&variant.attrs, sym::non_exhaustive)\n+            && self.r.tcx.sess.contains_name(&variant.attrs, sym::non_exhaustive)\n         {\n             ty::Visibility::Restricted(CRATE_DEF_ID)\n         } else {"}, {"sha": "0114e116386b028be4cb2d9e779bc7de051fedfc", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d191de63f00f667b35f7b3a917985e0fc2ddd1cd/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d191de63f00f667b35f7b3a917985e0fc2ddd1cd/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=d191de63f00f667b35f7b3a917985e0fc2ddd1cd", "patch": "@@ -290,7 +290,7 @@ impl Resolver<'_, '_> {\n             let ms = MultiSpan::from_spans(spans.clone());\n             let mut span_snippets = spans\n                 .iter()\n-                .filter_map(|s| match visitor.r.session.source_map().span_to_snippet(*s) {\n+                .filter_map(|s| match visitor.r.tcx.sess.source_map().span_to_snippet(*s) {\n                     Ok(s) => Some(format!(\"`{}`\", s)),\n                     _ => None,\n                 })\n@@ -317,7 +317,7 @@ impl Resolver<'_, '_> {\n             // If we are in the `--test` mode, suppress a help that adds the `#[cfg(test)]`\n             // attribute; however, if not, suggest adding the attribute. There is no way to\n             // retrieve attributes here because we do not have a `TyCtxt` yet.\n-            let test_module_span = if visitor.r.session.opts.test {\n+            let test_module_span = if visitor.r.tcx.sess.opts.test {\n                 None\n             } else {\n                 let parent_module = visitor.r.get_nearest_non_block_module("}, {"sha": "d8b9569a19694246a523968b60129850306eb343", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 77, "deletions": 66, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/d191de63f00f667b35f7b3a917985e0fc2ddd1cd/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d191de63f00f667b35f7b3a917985e0fc2ddd1cd/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=d191de63f00f667b35f7b3a917985e0fc2ddd1cd", "patch": "@@ -154,7 +154,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             if !candidates.is_empty() {\n                 show_candidates(\n-                    &self.session,\n+                    &self.tcx.sess,\n                     &self.untracked.source_span,\n                     &mut err,\n                     span,\n@@ -206,7 +206,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         };\n \n         let (name, span) =\n-            (ident.name, self.session.source_map().guess_head_span(new_binding.span));\n+            (ident.name, self.tcx.sess.source_map().guess_head_span(new_binding.span));\n \n         if let Some(s) = self.name_already_seen.get(&name) {\n             if s == &span {\n@@ -226,15 +226,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let msg = format!(\"the name `{}` is defined multiple times\", name);\n \n         let mut err = match (old_binding.is_extern_crate(), new_binding.is_extern_crate()) {\n-            (true, true) => struct_span_err!(self.session, span, E0259, \"{}\", msg),\n+            (true, true) => struct_span_err!(self.tcx.sess, span, E0259, \"{}\", msg),\n             (true, _) | (_, true) => match new_binding.is_import() && old_binding.is_import() {\n-                true => struct_span_err!(self.session, span, E0254, \"{}\", msg),\n-                false => struct_span_err!(self.session, span, E0260, \"{}\", msg),\n+                true => struct_span_err!(self.tcx.sess, span, E0254, \"{}\", msg),\n+                false => struct_span_err!(self.tcx.sess, span, E0260, \"{}\", msg),\n             },\n             _ => match (old_binding.is_import_user_facing(), new_binding.is_import_user_facing()) {\n-                (false, false) => struct_span_err!(self.session, span, E0428, \"{}\", msg),\n-                (true, true) => struct_span_err!(self.session, span, E0252, \"{}\", msg),\n-                _ => struct_span_err!(self.session, span, E0255, \"{}\", msg),\n+                (false, false) => struct_span_err!(self.tcx.sess, span, E0428, \"{}\", msg),\n+                (true, true) => struct_span_err!(self.tcx.sess, span, E0252, \"{}\", msg),\n+                _ => struct_span_err!(self.tcx.sess, span, E0255, \"{}\", msg),\n             },\n         };\n \n@@ -248,7 +248,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         err.span_label(span, format!(\"`{}` re{} here\", name, new_participle));\n         if !old_binding.span.is_dummy() && old_binding.span != span {\n             err.span_label(\n-                self.session.source_map().guess_head_span(old_binding.span),\n+                self.tcx.sess.source_map().guess_head_span(old_binding.span),\n                 format!(\"previous {} of the {} `{}` here\", old_noun, old_kind, name),\n             );\n         }\n@@ -352,7 +352,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 if let Some(pos) =\n                     source.span.hi().0.checked_sub(binding_span.lo().0).map(|pos| pos as usize)\n                 {\n-                    if let Ok(snippet) = self.session.source_map().span_to_snippet(binding_span) {\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(binding_span) {\n                         if pos <= snippet.len() {\n                             suggestion = Some(format!(\n                                 \"{} as {}{}\",\n@@ -426,12 +426,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         //   `a` and `import.use_span` is `issue_52891::{d, e, a};`.\n \n         let (found_closing_brace, span) =\n-            find_span_of_binding_until_next_binding(self.session, binding_span, import.use_span);\n+            find_span_of_binding_until_next_binding(self.tcx.sess, binding_span, import.use_span);\n \n         // If there was a closing brace then identify the span to remove any trailing commas from\n         // previous imports.\n         if found_closing_brace {\n-            if let Some(span) = extend_span_to_previous_binding(self.session, span) {\n+            if let Some(span) = extend_span_to_previous_binding(self.tcx.sess, span) {\n                 err.tool_only_span_suggestion(span, message, \"\", Applicability::MaybeIncorrect);\n             } else {\n                 // Remove the entire line if we cannot extend the span back, this indicates an\n@@ -462,7 +462,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         let first_name = match path.get(0) {\n             // In the 2018 edition this lint is a hard error, so nothing to do\n-            Some(seg) if seg.ident.span.is_rust_2015() && self.session.is_rust_2015() => {\n+            Some(seg) if seg.ident.span.is_rust_2015() && self.tcx.sess.is_rust_2015() => {\n                 seg.ident.name\n             }\n             _ => return,\n@@ -541,14 +541,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match resolution_error {\n             ResolutionError::GenericParamsFromOuterFunction(outer_res, has_generic_params) => {\n                 let mut err = struct_span_err!(\n-                    self.session,\n+                    self.tcx.sess,\n                     span,\n                     E0401,\n                     \"can't use generic parameters from outer function\",\n                 );\n                 err.span_label(span, \"use of generic parameter from outer function\");\n \n-                let sm = self.session.source_map();\n+                let sm = self.tcx.sess.source_map();\n                 let def_id = match outer_res {\n                     Res::SelfTyParam { .. } => {\n                         err.span_label(span, \"can't use `Self` here\");\n@@ -605,10 +605,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 err\n             }\n             ResolutionError::NameAlreadyUsedInParameterList(name, first_use_span) => self\n-                .session\n+                .tcx\n+                .sess\n                 .create_err(errs::NameAlreadyUsedInParameterList { span, first_use_span, name }),\n             ResolutionError::MethodNotMemberOfTrait(method, trait_, candidate) => {\n-                self.session.create_err(errs::MethodNotMemberOfTrait {\n+                self.tcx.sess.create_err(errs::MethodNotMemberOfTrait {\n                     span,\n                     method,\n                     trait_,\n@@ -619,7 +620,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 })\n             }\n             ResolutionError::TypeNotMemberOfTrait(type_, trait_, candidate) => {\n-                self.session.create_err(errs::TypeNotMemberOfTrait {\n+                self.tcx.sess.create_err(errs::TypeNotMemberOfTrait {\n                     span,\n                     type_,\n                     trait_,\n@@ -630,7 +631,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 })\n             }\n             ResolutionError::ConstNotMemberOfTrait(const_, trait_, candidate) => {\n-                self.session.create_err(errs::ConstNotMemberOfTrait {\n+                self.tcx.sess.create_err(errs::ConstNotMemberOfTrait {\n                     span,\n                     const_,\n                     trait_,\n@@ -648,7 +649,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 let msp = MultiSpan::from_spans(target_sp.clone());\n                 let mut err = struct_span_err!(\n-                    self.session,\n+                    self.tcx.sess,\n                     msp,\n                     E0408,\n                     \"variable `{}` is not bound in all patterns\",\n@@ -686,7 +687,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         err.span_help(span, &help_msg);\n                     }\n                     show_candidates(\n-                        &self.session,\n+                        &self.tcx.sess,\n                         &self.untracked.source_span,\n                         &mut err,\n                         Some(span),\n@@ -701,17 +702,19 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 err\n             }\n             ResolutionError::VariableBoundWithDifferentMode(variable_name, first_binding_span) => {\n-                self.session.create_err(errs::VariableBoundWithDifferentMode {\n+                self.tcx.sess.create_err(errs::VariableBoundWithDifferentMode {\n                     span,\n                     first_binding_span,\n                     variable_name,\n                 })\n             }\n             ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => self\n-                .session\n+                .tcx\n+                .sess\n                 .create_err(errs::IdentifierBoundMoreThanOnceInParameterList { span, identifier }),\n             ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(identifier) => self\n-                .session\n+                .tcx\n+                .sess\n                 .create_err(errs::IdentifierBoundMoreThanOnceInSamePattern { span, identifier }),\n             ResolutionError::UndeclaredLabel { name, suggestion } => {\n                 let ((sub_reachable, sub_reachable_suggestion), sub_unreachable) = match suggestion\n@@ -737,7 +740,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // No similarly-named labels exist.\n                     None => ((None, None), None),\n                 };\n-                self.session.create_err(errs::UndeclaredLabel {\n+                self.tcx.sess.create_err(errs::UndeclaredLabel {\n                     span,\n                     name,\n                     sub_reachable,\n@@ -762,21 +765,22 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     };\n                     (Some(suggestion), Some(mpart_suggestion))\n                 };\n-                self.session.create_err(errs::SelfImportsOnlyAllowedWithin {\n+                self.tcx.sess.create_err(errs::SelfImportsOnlyAllowedWithin {\n                     span,\n                     suggestion,\n                     mpart_suggestion,\n                 })\n             }\n             ResolutionError::SelfImportCanOnlyAppearOnceInTheList => {\n-                self.session.create_err(errs::SelfImportCanOnlyAppearOnceInTheList { span })\n-            }\n-            ResolutionError::SelfImportOnlyInImportListWithNonEmptyPrefix => {\n-                self.session.create_err(errs::SelfImportOnlyInImportListWithNonEmptyPrefix { span })\n+                self.tcx.sess.create_err(errs::SelfImportCanOnlyAppearOnceInTheList { span })\n             }\n+            ResolutionError::SelfImportOnlyInImportListWithNonEmptyPrefix => self\n+                .tcx\n+                .sess\n+                .create_err(errs::SelfImportOnlyInImportListWithNonEmptyPrefix { span }),\n             ResolutionError::FailedToResolve { label, suggestion } => {\n                 let mut err =\n-                    struct_span_err!(self.session, span, E0433, \"failed to resolve: {}\", &label);\n+                    struct_span_err!(self.tcx.sess, span, E0433, \"failed to resolve: {}\", &label);\n                 err.span_label(span, label);\n \n                 if let Some((suggestions, msg, applicability)) = suggestion {\n@@ -790,7 +794,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 err\n             }\n             ResolutionError::CannotCaptureDynamicEnvironmentInFnItem => {\n-                self.session.create_err(errs::CannotCaptureDynamicEnvironmentInFnItem { span })\n+                self.tcx.sess.create_err(errs::CannotCaptureDynamicEnvironmentInFnItem { span })\n             }\n             ResolutionError::AttemptToUseNonConstantValueInConstant(ident, suggestion, current) => {\n                 // let foo =...\n@@ -802,12 +806,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 // the further the two are apart, the higher the chance of the suggestion being wrong\n \n                 let sp = self\n-                    .session\n+                    .tcx\n+                    .sess\n                     .source_map()\n                     .span_extend_to_prev_str(ident.span, current, true, false);\n \n                 let ((with, with_label), without) = match sp {\n-                    Some(sp) if !self.session.source_map().is_multiline(sp) => {\n+                    Some(sp) if !self.tcx.sess.source_map().is_multiline(sp) => {\n                         let sp = sp.with_lo(BytePos(sp.lo().0 - (current.len() as u32)));\n                         (\n                         (Some(errs::AttemptToUseNonConstantValueInConstantWithSuggestion {\n@@ -828,7 +833,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     ),\n                 };\n \n-                self.session.create_err(errs::AttemptToUseNonConstantValueInConstant {\n+                self.tcx.sess.create_err(errs::AttemptToUseNonConstantValueInConstant {\n                     span,\n                     with,\n                     with_label,\n@@ -842,7 +847,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 article,\n                 shadowed_binding,\n                 shadowed_binding_span,\n-            } => self.session.create_err(errs::BindingShadowsSomethingUnacceptable {\n+            } => self.tcx.sess.create_err(errs::BindingShadowsSomethingUnacceptable {\n                 span,\n                 shadowing_binding,\n                 shadowed_binding,\n@@ -859,13 +864,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 name,\n             }),\n             ResolutionError::ForwardDeclaredGenericParam => {\n-                self.session.create_err(errs::ForwardDeclaredGenericParam { span })\n+                self.tcx.sess.create_err(errs::ForwardDeclaredGenericParam { span })\n             }\n             ResolutionError::ParamInTyOfConstParam(name) => {\n-                self.session.create_err(errs::ParamInTyOfConstParam { span, name })\n+                self.tcx.sess.create_err(errs::ParamInTyOfConstParam { span, name })\n             }\n             ResolutionError::ParamInNonTrivialAnonConst { name, is_type } => {\n-                self.session.create_err(errs::ParamInNonTrivialAnonConst {\n+                self.tcx.sess.create_err(errs::ParamInNonTrivialAnonConst {\n                     span,\n                     name,\n                     sub_is_type: if is_type {\n@@ -874,13 +879,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         errs::ParamInNonTrivialAnonConstIsType::NotAType { name }\n                     },\n                     help: self\n-                        .session\n+                        .tcx\n+                        .sess\n                         .is_nightly_build()\n                         .then_some(errs::ParamInNonTrivialAnonConstHelp),\n                 })\n             }\n             ResolutionError::SelfInGenericParamDefault => {\n-                self.session.create_err(errs::SelfInGenericParamDefault { span })\n+                self.tcx.sess.create_err(errs::SelfInGenericParamDefault { span })\n             }\n             ResolutionError::UnreachableLabel { name, definition_span, suggestion } => {\n                 let ((sub_suggestion_label, sub_suggestion), sub_unreachable_label) =\n@@ -908,7 +914,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // No similarly-named labels exist.\n                         None => ((None, None), None),\n                     };\n-                self.session.create_err(errs::UnreachableLabel {\n+                self.tcx.sess.create_err(errs::UnreachableLabel {\n                     span,\n                     name,\n                     definition_span,\n@@ -924,7 +930,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 trait_item_span,\n                 trait_path,\n             } => {\n-                let mut err = self.session.struct_span_err_with_code(\n+                let mut err = self.tcx.sess.struct_span_err_with_code(\n                     span,\n                     &format!(\n                         \"item `{}` is an associated {}, which doesn't match its trait `{}`\",\n@@ -937,9 +943,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 err\n             }\n             ResolutionError::TraitImplDuplicate { name, trait_item_span, old_span } => self\n-                .session\n+                .tcx\n+                .sess\n                 .create_err(errs::TraitImplDuplicate { span, name, trait_item_span, old_span }),\n-            ResolutionError::InvalidAsmSym => self.session.create_err(errs::InvalidAsmSym { span }),\n+            ResolutionError::InvalidAsmSym => {\n+                self.tcx.sess.create_err(errs::InvalidAsmSym { span })\n+            }\n         }\n     }\n \n@@ -949,7 +958,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     ) -> ErrorGuaranteed {\n         match vis_resolution_error {\n             VisResolutionError::Relative2018(span, path) => {\n-                self.session.create_err(errs::Relative2018 {\n+                self.tcx.sess.create_err(errs::Relative2018 {\n                     span,\n                     path_span: path.span,\n                     // intentionally converting to String, as the text would also be used as\n@@ -958,18 +967,20 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 })\n             }\n             VisResolutionError::AncestorOnly(span) => {\n-                self.session.create_err(errs::AncestorOnly(span))\n+                self.tcx.sess.create_err(errs::AncestorOnly(span))\n             }\n             VisResolutionError::FailedToResolve(span, label, suggestion) => {\n                 self.into_struct_error(span, ResolutionError::FailedToResolve { label, suggestion })\n             }\n             VisResolutionError::ExpectedFound(span, path_str, res) => {\n-                self.session.create_err(errs::ExpectedFound { span, res, path_str })\n+                self.tcx.sess.create_err(errs::ExpectedFound { span, res, path_str })\n             }\n             VisResolutionError::Indeterminate(span) => {\n-                self.session.create_err(errs::Indeterminate(span))\n+                self.tcx.sess.create_err(errs::Indeterminate(span))\n+            }\n+            VisResolutionError::ModuleOnly(span) => {\n+                self.tcx.sess.create_err(errs::ModuleOnly(span))\n             }\n-            VisResolutionError::ModuleOnly(span) => self.session.create_err(errs::ModuleOnly(span)),\n         }\n         .emit()\n     }\n@@ -1206,7 +1217,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // a note about editions\n                             let note = if let Some(did) = did {\n                                 let requires_note = !did.is_local()\n-                                    && this.cstore().item_attrs_untracked(did, this.session).any(\n+                                    && this.cstore().item_attrs_untracked(did, this.tcx.sess).any(\n                                         |attr| {\n                                             if attr.has_name(sym::rustc_diagnostic_item) {\n                                                 [sym::TryInto, sym::TryFrom, sym::FromIterator]\n@@ -1341,7 +1352,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let import_suggestions =\n             self.lookup_import_candidates(ident, Namespace::MacroNS, parent_scope, is_expected);\n         show_candidates(\n-            &self.session,\n+            &self.tcx.sess,\n             &self.untracked.source_span,\n             err,\n             None,\n@@ -1366,7 +1377,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             && let ModuleKind::Def(DefKind::Enum, def_id, _) = parent_scope.module.kind\n             && let Some(span) = self.opt_span(def_id)\n         {\n-            let source_map = self.session.source_map();\n+            let source_map = self.tcx.sess.source_map();\n             let head_span = source_map.guess_head_span(span);\n             if let Ok(head) = source_map.span_to_snippet(head_span) {\n                 err.span_suggestion(head_span, \"consider adding a derive\", format!(\"#[derive(Default)]\\n{head}\"), Applicability::MaybeIncorrect);\n@@ -1443,7 +1454,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         };\n         let def_span = suggestion.res.opt_def_id().and_then(|def_id| match def_id.krate {\n             LOCAL_CRATE => self.opt_span(def_id),\n-            _ => Some(self.cstore().get_span_untracked(def_id, self.session)),\n+            _ => Some(self.cstore().get_span_untracked(def_id, self.tcx.sess)),\n         });\n         if let Some(def_span) = def_span {\n             if span.overlaps(def_span) {\n@@ -1473,7 +1484,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             };\n \n             err.span_label(\n-                self.session.source_map().guess_head_span(def_span),\n+                self.tcx.sess.source_map().guess_head_span(def_span),\n                 &format!(\n                     \"{}{} `{}` defined here\",\n                     prefix,\n@@ -1498,15 +1509,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn binding_description(&self, b: &NameBinding<'_>, ident: Ident, from_prelude: bool) -> String {\n         let res = b.res();\n-        if b.span.is_dummy() || !self.session.source_map().is_span_accessible(b.span) {\n+        if b.span.is_dummy() || !self.tcx.sess.source_map().is_span_accessible(b.span) {\n             // These already contain the \"built-in\" prefix or look bad with it.\n             let add_built_in =\n                 !matches!(b.res(), Res::NonMacroAttr(..) | Res::PrimTy(..) | Res::ToolMod);\n             let (built_in, from) = if from_prelude {\n                 (\"\", \" from prelude\")\n             } else if b.is_extern_crate()\n                 && !b.is_import()\n-                && self.session.opts.externs.get(ident.as_str()).is_some()\n+                && self.tcx.sess.opts.externs.get(ident.as_str()).is_some()\n             {\n                 (\"\", \" passed with `--extern`\")\n             } else if add_built_in {\n@@ -1532,7 +1543,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             (b1, b2, misc1, misc2, false)\n         };\n \n-        let mut err = struct_span_err!(self.session, ident.span, E0659, \"`{ident}` is ambiguous\");\n+        let mut err = struct_span_err!(self.tcx.sess, ident.span, E0659, \"`{ident}` is ambiguous\");\n         err.span_label(ident.span, \"ambiguous name\");\n         err.note(&format!(\"ambiguous because of {}\", kind.descr()));\n \n@@ -1604,7 +1615,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Print the primary message.\n         let descr = get_descr(binding);\n         let mut err =\n-            struct_span_err!(self.session, ident.span, E0603, \"{} `{}` is private\", descr, ident);\n+            struct_span_err!(self.tcx.sess, ident.span, E0603, \"{} `{}` is private\", descr, ident);\n         err.span_label(ident.span, &format!(\"private {}\", descr));\n         if let Some(span) = ctor_fields_span {\n             err.span_label(span, \"a constructor is private if any of the fields is private\");\n@@ -1650,7 +1661,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 which = if first { \"\" } else { \" which\" },\n                 dots = if next_binding.is_some() { \"...\" } else { \"\" },\n             );\n-            let def_span = self.session.source_map().guess_head_span(binding.span);\n+            let def_span = self.tcx.sess.source_map().guess_head_span(binding.span);\n             let mut note_span = MultiSpan::from_span(def_span);\n             if !first && binding.vis.is_public() {\n                 note_span.push_span_label(def_span, \"consider importing it directly\");\n@@ -1719,7 +1730,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         Applicability::MaybeIncorrect,\n                     )),\n                 )\n-            } else if self.session.is_rust_2015() {\n+            } else if self.tcx.sess.is_rust_2015() {\n                 (\n                     format!(\"maybe a missing crate `{ident}`?\"),\n                     Some((\n@@ -1738,7 +1749,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             let parent = match parent {\n                 // ::foo is mounted at the crate root for 2015, and is the extern\n                 // prelude for 2018+\n-                kw::PathRoot if self.session.edition() > Edition::Edition2015 => {\n+                kw::PathRoot if self.tcx.sess.edition() > Edition::Edition2015 => {\n                     \"the list of imported crates\".to_owned()\n                 }\n                 kw::PathRoot | kw::Crate => \"the crate root\".to_owned(),\n@@ -2079,7 +2090,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                 //   ie. `use a::b::{c, d, e};`\n                 //                      ^^^\n                 let (found_closing_brace, binding_span) = find_span_of_binding_until_next_binding(\n-                    self.r.session,\n+                    self.r.tcx.sess,\n                     import.span,\n                     import.use_span,\n                 );\n@@ -2098,7 +2109,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     //   ie. `use a::b::{c, d};`\n                     //                    ^^^\n                     if let Some(previous_span) =\n-                        extend_span_to_previous_binding(self.r.session, binding_span)\n+                        extend_span_to_previous_binding(self.r.tcx.sess, binding_span)\n                     {\n                         debug!(\"check_for_module_export_macro: previous_span={:?}\", previous_span);\n                         removal_span = removal_span.with_lo(previous_span.lo());\n@@ -2116,7 +2127,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                 //   or  `use a::{b, c, d}};`\n                 //               ^^^^^^^^^^^\n                 let (has_nested, after_crate_name) = find_span_immediately_after_crate_name(\n-                    self.r.session,\n+                    self.r.tcx.sess,\n                     module_name,\n                     import.use_span,\n                 );\n@@ -2125,7 +2136,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     has_nested, after_crate_name\n                 );\n \n-                let source_map = self.r.session.source_map();\n+                let source_map = self.r.tcx.sess.source_map();\n \n                 // Make sure this is actually crate-relative.\n                 let is_definitely_crate = import"}, {"sha": "ba7f04239c35fd822e998c719e8122f372a3d100", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d191de63f00f667b35f7b3a917985e0fc2ddd1cd/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d191de63f00f667b35f7b3a917985e0fc2ddd1cd/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=d191de63f00f667b35f7b3a917985e0fc2ddd1cd", "patch": "@@ -1179,7 +1179,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         }\n \n                         ConstantItemRibKind(trivial, _) => {\n-                            let features = self.session.features_untracked();\n+                            let features = self.tcx.sess.features_untracked();\n                             // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n                             if !(trivial == ConstantHasGenerics::Yes\n                                 || features.generic_const_exprs)\n@@ -1208,7 +1208,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                 is_type: true,\n                                             },\n                                         );\n-                                        self.session.delay_span_bug(span, CG_BUG_STR);\n+                                        self.tcx.sess.delay_span_bug(span, CG_BUG_STR);\n                                     }\n \n                                     return Res::Err;\n@@ -1255,7 +1255,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         | ForwardGenericParamBanRibKind => continue,\n \n                         ConstantItemRibKind(trivial, _) => {\n-                            let features = self.session.features_untracked();\n+                            let features = self.tcx.sess.features_untracked();\n                             // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n                             if !(trivial == ConstantHasGenerics::Yes\n                                 || features.generic_const_exprs)\n@@ -1268,7 +1268,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                             is_type: false,\n                                         },\n                                     );\n-                                    self.session.delay_span_bug(span, CG_BUG_STR);\n+                                    self.tcx.sess.delay_span_bug(span, CG_BUG_STR);\n                                 }\n \n                                 return Res::Err;\n@@ -1397,7 +1397,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         module = Some(ModuleOrUniformRoot::ExternPrelude);\n                         continue;\n                     }\n-                    if name == kw::PathRoot && ident.span.is_rust_2015() && self.session.rust_2018()\n+                    if name == kw::PathRoot\n+                        && ident.span.is_rust_2015()\n+                        && self.tcx.sess.rust_2018()\n                     {\n                         // `::a::b` from 2015 macro on 2018 global edition\n                         module = Some(ModuleOrUniformRoot::CrateRootAndExternPrelude);\n@@ -1494,7 +1496,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         record_segment_res(self, res);\n                     } else if res == Res::ToolMod && i + 1 != path.len() {\n                         if binding.is_import() {\n-                            self.session\n+                            self.tcx\n+                                .sess\n                                 .struct_span_err(\n                                     ident.span,\n                                     \"cannot use a tool module through an import\","}, {"sha": "0862e56a4c4fe2a241a5411599a97728dad58ac2", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d191de63f00f667b35f7b3a917985e0fc2ddd1cd/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d191de63f00f667b35f7b3a917985e0fc2ddd1cd/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=d191de63f00f667b35f7b3a917985e0fc2ddd1cd", "patch": "@@ -526,7 +526,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             .collect::<Vec<_>>();\n         let msg = format!(\"unresolved import{} {}\", pluralize!(paths.len()), paths.join(\", \"),);\n \n-        let mut diag = struct_span_err!(self.r.session, span, E0432, \"{}\", &msg);\n+        let mut diag = struct_span_err!(self.r.tcx.sess, span, E0432, \"{}\", &msg);\n \n         if let Some((_, UnresolvedImportError { note: Some(note), .. })) = errors.iter().last() {\n             diag.note(note);\n@@ -548,7 +548,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             if let Some(candidates) = &err.candidates {\n                 match &import.kind {\n                     ImportKind::Single { nested: false, source, target, .. } => import_candidates(\n-                        self.r.session,\n+                        self.r.tcx.sess,\n                         &self.r.untracked.source_span,\n                         &mut diag,\n                         Some(err.span),\n@@ -561,7 +561,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     ),\n                     ImportKind::Single { nested: true, source, target, .. } => {\n                         import_candidates(\n-                            self.r.session,\n+                            self.r.tcx.sess,\n                             &self.r.untracked.source_span,\n                             &mut diag,\n                             None,\n@@ -658,7 +658,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     source_binding @ (Ok(..) | Err(Determined)) => {\n                         if source_binding.is_ok() {\n                             let msg = format!(\"`{}` is not directly importable\", target);\n-                            struct_span_err!(this.session, import.span, E0253, \"{}\", &msg)\n+                            struct_span_err!(this.tcx.sess, import.span, E0253, \"{}\", &msg)\n                                 .span_label(import.span, \"cannot be imported directly\")\n                                 .emit();\n                         }\n@@ -706,7 +706,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                 } else if self.r.privacy_errors.is_empty() {\n                     let msg = \"cannot determine resolution for the import\";\n                     let msg_note = \"import resolution is stuck, try simplifying other imports\";\n-                    self.r.session.struct_span_err(import.span, msg).note(msg_note).emit();\n+                    self.r.tcx.sess.struct_span_err(import.span, msg).note(msg_note).emit();\n                 }\n \n                 module\n@@ -859,7 +859,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                             let msg = \"cannot determine resolution for the import\";\n                             let msg_note =\n                                 \"import resolution is stuck, try simplifying other imports\";\n-                            this.session.struct_span_err(import.span, msg).note(msg_note).emit();\n+                            this.tcx.sess.struct_span_err(import.span, msg).note(msg_note).emit();\n                         }\n                     }\n                     Err(..) => {\n@@ -1035,13 +1035,13 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                         format!(\"re-export of private `{}`\", ident)\n                     };\n \n-                    struct_span_err!(self.r.session, import.span, E0365, \"{}\", error_msg)\n+                    struct_span_err!(self.r.tcx.sess, import.span, E0365, \"{}\", error_msg)\n                         .span_label(import.span, label_msg)\n                         .note(&format!(\"consider declaring type or module `{}` with `pub`\", ident))\n                         .emit();\n                 } else {\n                     let mut err =\n-                        struct_span_err!(self.r.session, import.span, E0364, \"{error_msg}\");\n+                        struct_span_err!(self.r.tcx.sess, import.span, E0364, \"{error_msg}\");\n                     match binding.kind {\n                         NameBindingKind::Res(Res::Def(DefKind::Macro(_), def_id))\n                             // exclude decl_macro\n@@ -1164,12 +1164,12 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n         let ImportKind::Glob { id, is_prelude, .. } = import.kind else { unreachable!() };\n \n         let ModuleOrUniformRoot::Module(module) = import.imported_module.get().unwrap() else {\n-            self.r.session.span_err(import.span, \"cannot glob-import all possible crates\");\n+            self.r.tcx.sess.span_err(import.span, \"cannot glob-import all possible crates\");\n             return;\n         };\n \n         if module.is_trait() {\n-            self.r.session.span_err(import.span, \"items in traits are not importable\");\n+            self.r.tcx.sess.span_err(import.span, \"items in traits are not importable\");\n             return;\n         } else if ptr::eq(module, import.parent_scope.module) {\n             return;"}, {"sha": "d3df3a5d4614bc515fa8e00b9f89cb8b68a63404", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d191de63f00f667b35f7b3a917985e0fc2ddd1cd/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d191de63f00f667b35f7b3a917985e0fc2ddd1cd/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=d191de63f00f667b35f7b3a917985e0fc2ddd1cd", "patch": "@@ -682,7 +682,7 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n                 // Elided lifetime in reference: we resolve as if there was some lifetime `'_` with\n                 // NodeId `ty.id`.\n                 // This span will be used in case of elision failure.\n-                let span = self.r.session.source_map().start_point(ty.span);\n+                let span = self.r.tcx.sess.source_map().start_point(ty.span);\n                 self.resolve_elided_lifetime(ty.id, span);\n                 visit::walk_ty(self, ty);\n             }\n@@ -1571,7 +1571,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                         (\"`'_` cannot be used here\", \"`'_` is a reserved lifetime name\")\n                     };\n                     let mut diag = rustc_errors::struct_span_err!(\n-                        self.r.session,\n+                        self.r.tcx.sess,\n                         lifetime.ident.span,\n                         E0637,\n                         \"{}\",\n@@ -1748,7 +1748,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                     //     impl Foo for std::cell::Ref<u32> // note lack of '_\n                     //     async fn foo(_: std::cell::Ref<u32>) { ... }\n                     LifetimeRibKind::AnonymousCreateParameter { report_in_path: true, .. } => {\n-                        let sess = self.r.session;\n+                        let sess = self.r.tcx.sess;\n                         let mut err = rustc_errors::struct_span_err!(\n                             sess,\n                             path_span,\n@@ -2194,7 +2194,8 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                 let what = if ns == TypeNS { \"type parameters\" } else { \"local variables\" };\n                 if this.should_report_errs() {\n                     this.r\n-                        .session\n+                        .tcx\n+                        .sess\n                         .span_err(ident.span, &format!(\"imports cannot refer to {}\", what));\n                 }\n             };\n@@ -2438,7 +2439,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             if let GenericParamKind::Lifetime = param.kind\n                 && let Some(&original) = seen_lifetimes.get(&ident)\n             {\n-                diagnostics::signal_lifetime_shadowing(self.r.session, original, param.ident);\n+                diagnostics::signal_lifetime_shadowing(self.r.tcx.sess, original, param.ident);\n                 // Record lifetime res, so lowering knows there is something fishy.\n                 self.record_lifetime_param(param.id, LifetimeRes::Error);\n                 continue;\n@@ -2462,7 +2463,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n \n             if param.ident.name == kw::UnderscoreLifetime {\n                 rustc_errors::struct_span_err!(\n-                    self.r.session,\n+                    self.r.tcx.sess,\n                     param.ident.span,\n                     E0637,\n                     \"`'_` cannot be used here\"\n@@ -2476,7 +2477,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n \n             if param.ident.name == kw::StaticLifetime {\n                 rustc_errors::struct_span_err!(\n-                    self.r.session,\n+                    self.r.tcx.sess,\n                     param.ident.span,\n                     E0262,\n                     \"invalid lifetime parameter name: `{}`\",\n@@ -2506,7 +2507,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             let res = match kind {\n                 ItemRibKind(..) | AssocItemRibKind => Res::Def(def_kind, def_id.to_def_id()),\n                 NormalRibKind => {\n-                    if self.r.session.features_untracked().non_lifetime_binders {\n+                    if self.r.tcx.sess.features_untracked().non_lifetime_binders {\n                         Res::Def(def_kind, def_id.to_def_id())\n                     } else {\n                         Res::Err\n@@ -3384,7 +3385,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             Res::SelfCtor(_) => {\n                 // We resolve `Self` in pattern position as an ident sometimes during recovery,\n                 // so delay a bug instead of ICEing.\n-                self.r.session.delay_span_bug(\n+                self.r.tcx.sess.delay_span_bug(\n                     ident.span,\n                     \"unexpected `SelfCtor` in pattern, expected identifier\"\n                 );\n@@ -3664,7 +3665,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n     #[inline]\n     /// If we're actually rustdoc then avoid giving a name resolution error for `cfg()` items.\n     fn should_report_errs(&self) -> bool {\n-        !(self.r.session.opts.actually_rustdoc && self.in_func_body)\n+        !(self.r.tcx.sess.opts.actually_rustdoc && self.in_func_body)\n     }\n \n     // Resolve in alternative namespaces if resolution in the primary namespace fails.\n@@ -3829,7 +3830,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             }\n \n             if let Ok((_, orig_span)) = self.resolve_label(label.ident) {\n-                diagnostics::signal_label_shadowing(self.r.session, orig_span, label.ident)\n+                diagnostics::signal_label_shadowing(self.r.tcx.sess, orig_span, label.ident)\n             }\n \n             self.with_label_rib(NormalRibKind, |this| {\n@@ -4211,8 +4212,8 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                 if let Some(res) = res\n                     && let Some(def_id) = res.opt_def_id()\n                     && !def_id.is_local()\n-                    && self.r.session.crate_types().contains(&CrateType::ProcMacro)\n-                    && matches!(self.r.session.opts.resolve_doc_links, ResolveDocLinks::ExportedMetadata) {\n+                    && self.r.tcx.sess.crate_types().contains(&CrateType::ProcMacro)\n+                    && matches!(self.r.tcx.sess.opts.resolve_doc_links, ResolveDocLinks::ExportedMetadata) {\n                     // Encoding foreign def ids in proc macro crate metadata will ICE.\n                     return None;\n                 }\n@@ -4224,10 +4225,10 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n     }\n \n     fn resolve_doc_links(&mut self, attrs: &[Attribute], maybe_exported: MaybeExported<'_>) {\n-        match self.r.session.opts.resolve_doc_links {\n+        match self.r.tcx.sess.opts.resolve_doc_links {\n             ResolveDocLinks::None => return,\n             ResolveDocLinks::ExportedMetadata\n-                if !self.r.session.crate_types().iter().copied().any(CrateType::has_metadata)\n+                if !self.r.tcx.sess.crate_types().iter().copied().any(CrateType::has_metadata)\n                     || !maybe_exported.eval(self.r) =>\n             {\n                 return;\n@@ -4281,9 +4282,9 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                         .into_iter()\n                         .filter_map(|tr| {\n                             if !tr.def_id.is_local()\n-                                && self.r.session.crate_types().contains(&CrateType::ProcMacro)\n+                                && self.r.tcx.sess.crate_types().contains(&CrateType::ProcMacro)\n                                 && matches!(\n-                                    self.r.session.opts.resolve_doc_links,\n+                                    self.r.tcx.sess.opts.resolve_doc_links,\n                                     ResolveDocLinks::ExportedMetadata\n                                 )\n                             {"}, {"sha": "0dce8976bc258a4d795fd464df01b6342bd8c061", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d191de63f00f667b35f7b3a917985e0fc2ddd1cd/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d191de63f00f667b35f7b3a917985e0fc2ddd1cd/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=d191de63f00f667b35f7b3a917985e0fc2ddd1cd", "patch": "@@ -170,7 +170,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n     fn def_span(&self, def_id: DefId) -> Option<Span> {\n         match def_id.krate {\n             LOCAL_CRATE => self.r.opt_span(def_id),\n-            _ => Some(self.r.cstore().get_span_untracked(def_id, self.r.session)),\n+            _ => Some(self.r.cstore().get_span_untracked(def_id, self.r.tcx.sess)),\n         }\n     }\n \n@@ -200,7 +200,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                     Res::Def(DefKind::Fn, _) => {\n                         // Verify whether this is a fn call or an Fn used as a type.\n                         self.r\n-                            .session\n+                            .tcx\n+                            .sess\n                             .source_map()\n                             .span_to_snippet(span)\n                             .map(|snippet| snippet.ends_with(')'))\n@@ -255,7 +256,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 };\n                 (String::new(), \"this scope\".to_string(), suggestion)\n             } else if path.len() == 2 && path[0].ident.name == kw::PathRoot {\n-                if self.r.session.edition() > Edition::Edition2015 {\n+                if self.r.tcx.sess.edition() > Edition::Edition2015 {\n                     // In edition 2018 onwards, the `::foo` syntax may only pull from the extern prelude\n                     // which overrides all other expectations of item type\n                     expected = \"crate\";\n@@ -323,7 +324,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         let base_error = self.make_base_error(path, span, source, res);\n         let code = source.error_code(res.is_some());\n         let mut err =\n-            self.r.session.struct_span_err_with_code(base_error.span, &base_error.msg, code);\n+            self.r.tcx.sess.struct_span_err_with_code(base_error.span, &base_error.msg, code);\n \n         self.suggest_swapping_misplaced_self_ty_and_trait(&mut err, source, res, base_error.span);\n \n@@ -432,7 +433,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                     } else {\n                         (\n                             self.r\n-                                .session\n+                                .tcx\n+                                .sess\n                                 .source_map()\n                                 .span_through_char(*fn_span, '(')\n                                 .shrink_to_hi(),\n@@ -505,7 +507,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 {\n                     if self\n                         .r\n-                        .session\n+                        .tcx\n+                        .sess\n                         .parse_sess\n                         .type_ascription_path_suggestions\n                         .borrow()\n@@ -596,7 +599,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             if let Some((call_span, args_span)) = self.call_has_self_arg(source) {\n                 let mut args_snippet = String::new();\n                 if let Some(args_span) = args_span {\n-                    if let Ok(snippet) = self.r.session.source_map().span_to_snippet(args_span) {\n+                    if let Ok(snippet) = self.r.tcx.sess.source_map().span_to_snippet(args_span) {\n                         args_snippet = snippet;\n                     }\n                 }\n@@ -732,7 +735,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n         let typo_sugg = self.lookup_typo_candidate(path, source.namespace(), is_expected);\n         let is_in_same_file = &|sp1, sp2| {\n-            let source_map = self.r.session.source_map();\n+            let source_map = self.r.tcx.sess.source_map();\n             let file1 = source_map.span_to_filename(sp1);\n             let file2 = source_map.span_to_filename(sp2);\n             file1 == file2\n@@ -895,7 +898,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                                 .map_or(*span, |ident| span.with_lo(ident.span.hi()));\n                             (\n                                 self.r\n-                                    .session\n+                                    .tcx\n+                                    .sess\n                                     .source_map()\n                                     .span_through_char(span, '(')\n                                     .shrink_to_hi(),\n@@ -949,9 +953,9 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             && let PathSource::Trait(_) = source\n             && let Some(Res::Def(DefKind::Struct | DefKind::Enum | DefKind::Union, _)) = res\n             && let Ok(self_ty_str) =\n-                self.r.session.source_map().span_to_snippet(self_ty.span)\n+                self.r.tcx.sess.source_map().span_to_snippet(self_ty.span)\n             && let Ok(trait_ref_str) =\n-                self.r.session.source_map().span_to_snippet(trait_ref.path.span)\n+                self.r.tcx.sess.source_map().span_to_snippet(trait_ref.path.span)\n         {\n                 err.multipart_suggestion(\n                     \"`impl` items mention the trait being implemented first and the type it is being implemented for second\",\n@@ -1095,7 +1099,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                             format!(\n                                 \"{}: {}<{} = {}>\",\n                                 self.r\n-                                    .session\n+                                    .tcx\n+                                    .sess\n                                     .source_map()\n                                     .span_to_snippet(ty.span) // Account for `<&'a T as Foo>::Bar`.\n                                     .unwrap_or_else(|_| constrain_ident.to_string()),\n@@ -1164,7 +1169,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         // parser issue where a struct literal is being used on an expression\n         // where a brace being opened means a block is being started. Look\n         // ahead for the next text to see if `span` is followed by a `{`.\n-        let sm = self.r.session.source_map();\n+        let sm = self.r.tcx.sess.source_map();\n         let sp = sm.span_look_ahead(span, None, Some(50));\n         let followed_by_brace = matches!(sm.span_to_snippet(sp), Ok(ref snippet) if snippet == \"{\");\n         // In case this could be a struct literal that needs to be surrounded\n@@ -1212,7 +1217,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 true\n             } else if kind == DefKind::Struct\n             && let Some(lhs_source_span) = lhs_span.find_ancestor_inside(expr.span)\n-            && let Ok(snippet) = self.r.session.source_map().span_to_snippet(lhs_source_span)\n+            && let Ok(snippet) = self.r.tcx.sess.source_map().span_to_snippet(lhs_source_span)\n             {\n                 // The LHS is a type that originates from a macro call.\n                 // We have to add angle brackets around it.\n@@ -1352,11 +1357,11 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             }\n             (Res::Def(DefKind::TyAlias, def_id), PathSource::Trait(_)) => {\n                 err.span_label(span, \"type aliases cannot be used as traits\");\n-                if self.r.session.is_nightly_build() {\n+                if self.r.tcx.sess.is_nightly_build() {\n                     let msg = \"you might have meant to use `#![feature(trait_alias)]` instead of a \\\n                                `type` alias\";\n                     if let Some(span) = self.def_span(def_id) {\n-                        if let Ok(snip) = self.r.session.source_map().span_to_snippet(span) {\n+                        if let Ok(snip) = self.r.tcx.sess.source_map().span_to_snippet(span) {\n                             // The span contains a type alias so we should be able to\n                             // replace `type` with `trait`.\n                             let snip = snip.replacen(\"type\", \"trait\", 1);\n@@ -1387,7 +1392,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                     .last()\n                     .map(|sp| {\n                         self.r\n-                            .session\n+                            .tcx\n+                            .sess\n                             .parse_sess\n                             .type_ascription_path_suggestions\n                             .borrow()\n@@ -1774,12 +1780,12 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n \n     /// Only used in a specific case of type ascription suggestions\n     fn get_colon_suggestion_span(&self, start: Span) -> Span {\n-        let sm = self.r.session.source_map();\n+        let sm = self.r.tcx.sess.source_map();\n         start.to(sm.next_point(start))\n     }\n \n     fn type_ascription_suggestion(&self, err: &mut Diagnostic, base_span: Span) -> bool {\n-        let sm = self.r.session.source_map();\n+        let sm = self.r.tcx.sess.source_map();\n         let base_snippet = sm.span_to_snippet(base_span);\n         if let Some(&sp) = self.diagnostic_metadata.current_type_ascription.last() {\n             if let Ok(snippet) = sm.span_to_snippet(sp) {\n@@ -1809,7 +1815,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                             show_label = false;\n                             if !self\n                                 .r\n-                                .session\n+                                .tcx\n+                                .sess\n                                 .parse_sess\n                                 .type_ascription_path_suggestions\n                                 .borrow_mut()\n@@ -2272,7 +2279,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         debug_assert_ne!(lifetime_ref.ident.name, kw::UnderscoreLifetime);\n         let mut err = if let Some(outer) = outer_lifetime_ref {\n             let mut err = struct_span_err!(\n-                self.r.session,\n+                self.r.tcx.sess,\n                 lifetime_ref.ident.span,\n                 E0401,\n                 \"can't use generic parameters from outer item\",\n@@ -2282,7 +2289,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             err\n         } else {\n             let mut err = struct_span_err!(\n-                self.r.session,\n+                self.r.tcx.sess,\n                 lifetime_ref.ident.span,\n                 E0261,\n                 \"use of undeclared lifetime name `{}`\",\n@@ -2340,8 +2347,13 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                         );\n                         (span, sugg)\n                     } else {\n-                        let span =\n-                            self.r.session.source_map().span_through_char(span, '<').shrink_to_hi();\n+                        let span = self\n+                            .r\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_through_char(span, '<')\n+                            .shrink_to_hi();\n                         let sugg = format!(\"{}, \", name.unwrap_or(\"'a\"));\n                         (span, sugg)\n                     };\n@@ -2375,7 +2387,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n \n     pub(crate) fn emit_non_static_lt_in_const_generic_error(&self, lifetime_ref: &ast::Lifetime) {\n         struct_span_err!(\n-            self.r.session,\n+            self.r.tcx.sess,\n             lifetime_ref.ident.span,\n             E0771,\n             \"use of non-static lifetime `{}` in const generic\",\n@@ -2395,10 +2407,10 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         &self,\n         lifetime_ref: &ast::Lifetime,\n     ) {\n-        let feature_active = self.r.session.features_untracked().generic_const_exprs;\n+        let feature_active = self.r.tcx.sess.features_untracked().generic_const_exprs;\n         if !feature_active {\n             feature_err(\n-                &self.r.session.parse_sess,\n+                &self.r.tcx.sess.parse_sess,\n                 sym::generic_const_exprs,\n                 lifetime_ref.ident.span,\n                 \"a non-static lifetime is not allowed in a `const`\",\n@@ -2416,7 +2428,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         let spans: Vec<_> = lifetime_refs.iter().map(|lt| lt.span).collect();\n \n         let mut err = struct_span_err!(\n-            self.r.session,\n+            self.r.tcx.sess,\n             spans,\n             E0106,\n             \"missing lifetime specifier{}\","}, {"sha": "74eda51fa8c4b9c4255083857b26473d92dfa291", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d191de63f00f667b35f7b3a917985e0fc2ddd1cd/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d191de63f00f667b35f7b3a917985e0fc2ddd1cd/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=d191de63f00f667b35f7b3a917985e0fc2ddd1cd", "patch": "@@ -861,11 +861,15 @@ struct MacroData {\n     macro_rules: bool,\n }\n \n+struct TyCtxt<'tcx> {\n+    sess: &'tcx Session,\n+}\n+\n /// The main resolver class.\n ///\n /// This is the visitor that walks the whole crate.\n pub struct Resolver<'a, 'tcx> {\n-    session: &'tcx Session,\n+    tcx: TyCtxt<'tcx>,\n \n     /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n     expn_that_defined: FxHashMap<LocalDefId, ExpnId>,\n@@ -1195,7 +1199,7 @@ impl<'tcx> Resolver<'_, 'tcx> {\n         if let Some(def_id) = def_id.as_local() {\n             self.item_generics_num_lifetimes[&def_id]\n         } else {\n-            self.cstore().item_generics_num_lifetimes(def_id, self.session)\n+            self.cstore().item_generics_num_lifetimes(def_id, self.tcx.sess)\n         }\n     }\n }\n@@ -1208,6 +1212,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         metadata_loader: Box<MetadataLoaderDyn>,\n         arenas: &'a ResolverArenas<'a>,\n     ) -> Resolver<'a, 'tcx> {\n+        let tcx = TyCtxt { sess: session };\n+\n         let root_def_id = CRATE_DEF_ID.to_def_id();\n         let mut module_map = FxHashMap::default();\n         let graph_root = arenas.new_module(\n@@ -1264,7 +1270,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let features = session.features_untracked();\n \n         let mut resolver = Resolver {\n-            session,\n+            tcx,\n \n             expn_that_defined: Default::default(),\n \n@@ -1473,12 +1479,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n-        StableHashingContext::new(self.session, &self.untracked)\n+        StableHashingContext::new(self.tcx.sess, &self.untracked)\n     }\n \n     fn crate_loader(&mut self) -> CrateLoader<'_> {\n         CrateLoader::new(\n-            &self.session,\n+            &self.tcx.sess,\n             &*self.metadata_loader,\n             self.local_crate_name,\n             &mut *self.untracked.cstore.untracked_as_any().downcast_mut().unwrap(),\n@@ -1521,17 +1527,19 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n-        self.session.time(\"resolve_crate\", || {\n-            self.session.time(\"finalize_imports\", || ImportResolver { r: self }.finalize_imports());\n-            self.session.time(\"compute_effective_visibilities\", || {\n+        self.tcx.sess.time(\"resolve_crate\", || {\n+            self.tcx\n+                .sess\n+                .time(\"finalize_imports\", || ImportResolver { r: self }.finalize_imports());\n+            self.tcx.sess.time(\"compute_effective_visibilities\", || {\n                 EffectiveVisibilitiesVisitor::compute_effective_visibilities(self, krate)\n             });\n-            self.session.time(\"finalize_macro_resolutions\", || self.finalize_macro_resolutions());\n-            self.session.time(\"late_resolve_crate\", || self.late_resolve_crate(krate));\n-            self.session.time(\"resolve_main\", || self.resolve_main());\n-            self.session.time(\"resolve_check_unused\", || self.check_unused(krate));\n-            self.session.time(\"resolve_report_errors\", || self.report_errors(krate));\n-            self.session.time(\"resolve_postprocess\", || self.crate_loader().postprocess(krate));\n+            self.tcx.sess.time(\"finalize_macro_resolutions\", || self.finalize_macro_resolutions());\n+            self.tcx.sess.time(\"late_resolve_crate\", || self.late_resolve_crate(krate));\n+            self.tcx.sess.time(\"resolve_main\", || self.resolve_main());\n+            self.tcx.sess.time(\"resolve_check_unused\", || self.check_unused(krate));\n+            self.tcx.sess.time(\"resolve_report_errors\", || self.report_errors(krate));\n+            self.tcx.sess.time(\"resolve_postprocess\", || self.crate_loader().postprocess(krate));\n         });\n     }\n \n@@ -1961,7 +1969,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 let attr = self\n                     .cstore()\n-                    .item_attrs_untracked(def_id, self.session)\n+                    .item_attrs_untracked(def_id, self.tcx.sess)\n                     .find(|a| a.has_name(sym::rustc_legacy_const_generics))?;\n                 let mut ret = Vec::new();\n                 for meta in attr.meta_item_list()? {"}, {"sha": "403df94897a4d5e81658a2acd5858c12116d0910", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d191de63f00f667b35f7b3a917985e0fc2ddd1cd/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d191de63f00f667b35f7b3a917985e0fc2ddd1cd/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=d191de63f00f667b35f7b3a917985e0fc2ddd1cd", "patch": "@@ -195,7 +195,8 @@ impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n \n     fn register_builtin_macro(&mut self, name: Symbol, ext: SyntaxExtensionKind) {\n         if self.builtin_macros.insert(name, BuiltinMacroState::NotYetSeen(ext)).is_some() {\n-            self.session\n+            self.tcx\n+                .sess\n                 .diagnostic()\n                 .bug(&format!(\"built-in macro `{}` was already registered\", name));\n         }\n@@ -216,7 +217,7 @@ impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n             ExpnData::allow_unstable(\n                 ExpnKind::AstPass(pass),\n                 call_site,\n-                self.session.edition(),\n+                self.tcx.sess.edition(),\n                 features.into(),\n                 None,\n                 parent_module,\n@@ -430,7 +431,7 @@ impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n                 PathResult::NonModule(..) |\n                 // HACK(Urgau): This shouldn't be necessary\n                 PathResult::Failed { is_error_from_last_segment: false, .. } => {\n-                    self.session\n+                    self.tcx.sess\n                         .struct_span_err(span, \"not sure whether the path is accessible or not\")\n                         .note(\"the type may have associated items, but we are currently not checking them\")\n                         .emit();\n@@ -455,7 +456,7 @@ impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n     }\n \n     fn get_proc_macro_quoted_span(&self, krate: CrateNum, id: usize) -> Span {\n-        self.cstore().get_proc_macro_quoted_span_untracked(krate, id, self.session)\n+        self.cstore().get_proc_macro_quoted_span_untracked(krate, id, self.tcx.sess)\n     }\n \n     fn declare_proc_macro(&mut self, id: NodeId) {\n@@ -493,10 +494,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Report errors for the resolved macro.\n         for segment in &path.segments {\n             if let Some(args) = &segment.args {\n-                self.session.span_err(args.span(), \"generic arguments in macro path\");\n+                self.tcx.sess.span_err(args.span(), \"generic arguments in macro path\");\n             }\n             if kind == MacroKind::Attr && segment.ident.as_str().starts_with(\"rustc\") {\n-                self.session.span_err(\n+                self.tcx.sess.span_err(\n                     segment.ident.span,\n                     \"attributes starting with `rustc` are reserved for use by the `rustc` compiler\",\n                 );\n@@ -508,7 +509,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 if let Some(def_id) = def_id.as_local() {\n                     self.unused_macros.remove(&def_id);\n                     if self.proc_macro_stubs.contains(&def_id) {\n-                        self.session.span_err(\n+                        self.tcx.sess.span_err(\n                             path.span,\n                             \"can't use a procedural macro from the same crate that defines it\",\n                         );\n@@ -540,7 +541,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if let Some((article, expected)) = unexpected_res {\n             let path_str = pprust::path_to_string(path);\n             let msg = format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str);\n-            self.session\n+            self.tcx\n+                .sess\n                 .struct_span_err(path.span, &msg)\n                 .span_label(path.span, format!(\"not {} {}\", article, expected))\n                 .emit();\n@@ -550,18 +552,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // We are trying to avoid reporting this error if other related errors were reported.\n         if res != Res::Err\n             && inner_attr\n-            && !self.session.features_untracked().custom_inner_attributes\n+            && !self.tcx.sess.features_untracked().custom_inner_attributes\n         {\n             let msg = match res {\n                 Res::Def(..) => \"inner macro attributes are unstable\",\n                 Res::NonMacroAttr(..) => \"custom inner attributes are unstable\",\n                 _ => unreachable!(),\n             };\n             if soft_custom_inner_attributes_gate {\n-                self.session.parse_sess.buffer_lint(SOFT_UNSTABLE, path.span, node_id, msg);\n+                self.tcx.sess.parse_sess.buffer_lint(SOFT_UNSTABLE, path.span, node_id, msg);\n             } else {\n-                feature_err(&self.session.parse_sess, sym::custom_inner_attributes, path.span, msg)\n-                    .emit();\n+                feature_err(\n+                    &self.tcx.sess.parse_sess,\n+                    sym::custom_inner_attributes,\n+                    path.span,\n+                    msg,\n+                )\n+                .emit();\n             }\n         }\n \n@@ -655,7 +662,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // Make sure compilation does not succeed if preferred macro resolution\n                     // has changed after the macro had been expanded. In theory all such\n                     // situations should be reported as errors, so this is a bug.\n-                    this.session.delay_span_bug(span, \"inconsistent resolution for a macro\");\n+                    this.tcx.sess.delay_span_bug(span, \"inconsistent resolution for a macro\");\n                 }\n             } else {\n                 // It's possible that the macro was unresolved (indeterminate) and silently\n@@ -672,7 +679,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         Segment::names_to_string(path)\n                     );\n                     let msg_note = \"import resolution is stuck, try simplifying macro imports\";\n-                    this.session.struct_span_err(span, &msg).note(msg_note).emit();\n+                    this.tcx.sess.struct_span_err(span, &msg).note(msg_note).emit();\n                 }\n             }\n         };\n@@ -699,7 +706,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // try to suggest if it's not a macro, maybe a function\n                         if let PathResult::NonModule(partial_res) = self.maybe_resolve_path(&path, Some(ValueNS), &parent_scope)\n                             && partial_res.unresolved_segments() == 0 {\n-                            let sm = self.session.source_map();\n+                            let sm = self.tcx.sess.source_map();\n                             let exclamation_span = sm.next_point(span);\n                             suggestion = Some((\n                                 vec![(exclamation_span, \"\".to_string())],\n@@ -762,7 +769,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 Err(..) => {\n                     let expected = kind.descr_expected();\n                     let msg = format!(\"cannot find {} `{}` in this scope\", expected, ident);\n-                    let mut err = self.session.struct_span_err(ident.span, &msg);\n+                    let mut err = self.tcx.sess.struct_span_err(ident.span, &msg);\n                     self.unresolved_macro_suggestions(&mut err, kind, &parent_scope, ident);\n                     err.emit();\n                 }\n@@ -804,7 +811,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let soft_handler =\n                         |lint, span, msg: &_| lint_buffer.buffer_lint(lint, node_id, span, msg);\n                     stability::report_unstable(\n-                        self.session,\n+                        self.tcx.sess,\n                         feature,\n                         reason.to_opt_reason(),\n                         issue,\n@@ -840,7 +847,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             if kind != NonMacroAttrKind::Tool && binding.map_or(true, |b| b.is_import()) {\n                 let msg =\n                     format!(\"cannot use {} {} through an import\", kind.article(), kind.descr());\n-                let mut err = self.session.struct_span_err(span, &msg);\n+                let mut err = self.tcx.sess.struct_span_err(span, &msg);\n                 if let Some(binding) = binding {\n                     err.span_note(binding.span, &format!(\"the {} imported here\", kind.descr()));\n                 }\n@@ -855,7 +862,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if ident.name == sym::cfg || ident.name == sym::cfg_attr {\n             let macro_kind = self.get_macro(res).map(|macro_data| macro_data.ext.macro_kind());\n             if macro_kind.is_some() && sub_namespace_match(macro_kind, Some(MacroKind::Attr)) {\n-                self.session.span_err(\n+                self.tcx.sess.span_err(\n                     ident.span,\n                     &format!(\"name `{}` is reserved in attribute namespace\", ident),\n                 );\n@@ -872,8 +879,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         edition: Edition,\n     ) -> (SyntaxExtension, Vec<(usize, Span)>) {\n         let (mut result, mut rule_spans) = compile_declarative_macro(\n-            &self.session,\n-            self.session.features_untracked(),\n+            &self.tcx.sess,\n+            self.tcx.sess.features_untracked(),\n             item,\n             edition,\n         );\n@@ -895,7 +902,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                     BuiltinMacroState::AlreadySeen(span) => {\n                         struct_span_err!(\n-                            self.session,\n+                            self.tcx.sess,\n                             item.span,\n                             E0773,\n                             \"attempted to define built-in macro more than once\"\n@@ -906,7 +913,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             } else {\n                 let msg = format!(\"cannot find a built-in macro with name `{}`\", item.ident);\n-                self.session.span_err(item.span, &msg);\n+                self.tcx.sess.span_err(item.span, &msg);\n             }\n         }\n "}]}