{"sha": "e25e15ce99eb44c5c4184c595c26037636355a56", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyNWUxNWNlOTllYjQ0YzVjNDE4NGM1OTVjMjYwMzc2MzYzNTVhNTY=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-03-07T22:11:12Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-03-24T20:48:36Z"}, "message": "Store tcx and cache when they are used multiple times instead of calling functions every time", "tree": {"sha": "f4176a2ef0daf4f07f355c8b17f0f7f875987913", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4176a2ef0daf4f07f355c8b17f0f7f875987913"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e25e15ce99eb44c5c4184c595c26037636355a56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e25e15ce99eb44c5c4184c595c26037636355a56", "html_url": "https://github.com/rust-lang/rust/commit/e25e15ce99eb44c5c4184c595c26037636355a56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e25e15ce99eb44c5c4184c595c26037636355a56/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0cde85523f60b8de774bda91d171c9277464d489", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cde85523f60b8de774bda91d171c9277464d489", "html_url": "https://github.com/rust-lang/rust/commit/0cde85523f60b8de774bda91d171c9277464d489"}], "stats": {"total": 124, "additions": 66, "deletions": 58}, "files": [{"sha": "07bd26a4c5ebe679f56e5c8403ee7250b7998587", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 66, "deletions": 58, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/e25e15ce99eb44c5c4184c595c26037636355a56/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25e15ce99eb44c5c4184c595c26037636355a56/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=e25e15ce99eb44c5c4184c595c26037636355a56", "patch": "@@ -855,10 +855,12 @@ fn render_impls(\n     traits: &[&&Impl],\n     containing_item: &clean::Item,\n ) {\n+    let cache = cx.cache();\n+    let tcx = cx.tcx();\n     let mut impls = traits\n         .iter()\n         .map(|i| {\n-            let did = i.trait_did_full(cx.cache()).unwrap();\n+            let did = i.trait_did_full(cache).unwrap();\n             let assoc_link = AssocItemLink::GotoSource(did, &i.inner_impl().provided_trait_methods);\n             let mut buffer = if w.is_for_html() { Buffer::html() } else { Buffer::new() };\n             render_impl(\n@@ -868,8 +870,8 @@ fn render_impls(\n                 containing_item,\n                 assoc_link,\n                 RenderMode::Normal,\n-                containing_item.stable_since(cx.tcx()).as_deref(),\n-                containing_item.const_stable_since(cx.tcx()).as_deref(),\n+                containing_item.stable_since(tcx).as_deref(),\n+                containing_item.const_stable_since(tcx).as_deref(),\n                 true,\n                 None,\n                 false,\n@@ -911,14 +913,16 @@ fn assoc_const(\n     extra: &str,\n     cx: &Context<'_>,\n ) {\n+    let cache = cx.cache();\n+    let tcx = cx.tcx();\n     write!(\n         w,\n         \"{}{}const <a href=\\\"{}\\\" class=\\\"constant\\\"><b>{}</b></a>: {}\",\n         extra,\n-        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n-        naive_assoc_href(it, link, cx.cache()),\n+        it.visibility.print_with_space(tcx, it.def_id, cache),\n+        naive_assoc_href(it, link, cache),\n         it.name.as_ref().unwrap(),\n-        ty.print(cx.cache(), cx.tcx())\n+        ty.print(cache, tcx)\n     );\n }\n \n@@ -993,6 +997,8 @@ fn render_assoc_item(\n         parent: ItemType,\n         cx: &Context<'_>,\n     ) {\n+        let cache = cx.cache();\n+        let tcx = cx.tcx();\n         let name = meth.name.as_ref().unwrap();\n         let anchor = format!(\"#{}.{}\", meth.type_(), name);\n         let href = match link {\n@@ -1007,18 +1013,17 @@ fn render_assoc_item(\n                     ItemType::TyMethod\n                 };\n \n-                href(did, cx.cache()).map(|p| format!(\"{}#{}.{}\", p.0, ty, name)).unwrap_or(anchor)\n+                href(did, cache).map(|p| format!(\"{}#{}.{}\", p.0, ty, name)).unwrap_or(anchor)\n             }\n         };\n-        let tcx = cx.tcx();\n-        let vis = meth.visibility.print_with_space(tcx, meth.def_id, cx.cache()).to_string();\n+        let vis = meth.visibility.print_with_space(tcx, meth.def_id, cache).to_string();\n         let constness = header.constness.print_with_space();\n         let asyncness = header.asyncness.print_with_space();\n         let unsafety = header.unsafety.print_with_space();\n         let defaultness = print_default_space(meth.is_default());\n         let abi = print_abi_with_space(header.abi).to_string();\n         // NOTE: `{:#}` does not print HTML formatting, `{}` does. So `g.print` can't be reused between the length calculation and `write!`.\n-        let generics_len = format!(\"{:#}\", g.print(cx.cache(), tcx)).len();\n+        let generics_len = format!(\"{:#}\", g.print(cache, tcx)).len();\n         let mut header_len = \"fn \".len()\n             + vis.len()\n             + constness.len()\n@@ -1050,10 +1055,10 @@ fn render_assoc_item(\n             abi,\n             href = href,\n             name = name,\n-            generics = g.print(cx.cache(), cx.tcx()),\n-            decl = d.full_print(cx.cache(), cx.tcx(), header_len, indent, header.asyncness),\n-            spotlight = spotlight_decl(&d, cx.cache(), cx.tcx()),\n-            where_clause = print_where_clause(g, cx.cache(), cx.tcx(), indent, end_newline),\n+            generics = g.print(cache, tcx),\n+            decl = d.full_print(cache, tcx, header_len, indent, header.asyncness),\n+            spotlight = spotlight_decl(&d, cache, tcx),\n+            where_clause = print_where_clause(g, cache, tcx, indent, end_newline),\n         )\n     }\n     match *item.kind {\n@@ -1156,6 +1161,8 @@ fn render_assoc_items(\n         Some(v) => v,\n         None => return,\n     };\n+    let tcx = cx.tcx();\n+    let cache = cx.cache();\n     let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| i.inner_impl().trait_.is_none());\n     if !non_trait.is_empty() {\n         let render_mode = match what {\n@@ -1170,21 +1177,19 @@ fn render_assoc_items(\n             AssocItemRender::DerefFor { trait_, type_, deref_mut_ } => {\n                 let id = cx.derive_id(small_url_encode(format!(\n                     \"deref-methods-{:#}\",\n-                    type_.print(cx.cache(), cx.tcx())\n+                    type_.print(cache, tcx)\n                 )));\n-                debug!(\"Adding {} to deref id map\", type_.print(cx.cache(), cx.tcx()));\n-                cx.deref_id_map\n-                    .borrow_mut()\n-                    .insert(type_.def_id_full(cx.cache()).unwrap(), id.clone());\n+                debug!(\"Adding {} to deref id map\", type_.print(cache, tcx));\n+                cx.deref_id_map.borrow_mut().insert(type_.def_id_full(cache).unwrap(), id.clone());\n                 write!(\n                     w,\n                     \"<h2 id=\\\"{id}\\\" class=\\\"small-section-header\\\">\\\n                          Methods from {trait_}&lt;Target = {type_}&gt;\\\n                          <a href=\\\"#{id}\\\" class=\\\"anchor\\\"></a>\\\n                      </h2>\",\n                     id = id,\n-                    trait_ = trait_.print(cx.cache(), cx.tcx()),\n-                    type_ = type_.print(cx.cache(), cx.tcx()),\n+                    trait_ = trait_.print(cache, tcx),\n+                    type_ = type_.print(cache, tcx),\n                 );\n                 RenderMode::ForDeref { mut_: deref_mut_ }\n             }\n@@ -1197,8 +1202,8 @@ fn render_assoc_items(\n                 containing_item,\n                 AssocItemLink::Anchor(None),\n                 render_mode,\n-                containing_item.stable_since(cx.tcx()).as_deref(),\n-                containing_item.const_stable_since(cx.tcx()).as_deref(),\n+                containing_item.stable_since(tcx).as_deref(),\n+                containing_item.const_stable_since(tcx).as_deref(),\n                 true,\n                 None,\n                 false,\n@@ -1210,11 +1215,11 @@ fn render_assoc_items(\n     if !traits.is_empty() {\n         let deref_impl = traits\n             .iter()\n-            .find(|t| t.inner_impl().trait_.def_id_full(cx.cache()) == cx.cache.deref_trait_did);\n+            .find(|t| t.inner_impl().trait_.def_id_full(cache) == cx.cache.deref_trait_did);\n         if let Some(impl_) = deref_impl {\n-            let has_deref_mut = traits.iter().any(|t| {\n-                t.inner_impl().trait_.def_id_full(cx.cache()) == cx.cache.deref_mut_trait_did\n-            });\n+            let has_deref_mut = traits\n+                .iter()\n+                .any(|t| t.inner_impl().trait_.def_id_full(cache) == cx.cache.deref_mut_trait_did);\n             render_deref_methods(w, cx, impl_, containing_item, has_deref_mut);\n         }\n \n@@ -1415,18 +1420,17 @@ fn render_impl(\n     aliases: &[String],\n ) {\n     let traits = &cx.cache.traits;\n-    let trait_ = i.trait_did_full(cx.cache()).map(|did| &traits[&did]);\n+    let tcx = cx.tcx();\n+    let cache = cx.cache();\n+    let trait_ = i.trait_did_full(cache).map(|did| &traits[&did]);\n \n     if render_mode == RenderMode::Normal {\n         let id = cx.derive_id(match i.inner_impl().trait_ {\n             Some(ref t) => {\n                 if is_on_foreign_type {\n-                    get_id_for_impl_on_foreign_type(&i.inner_impl().for_, t, cx.cache(), cx.tcx())\n+                    get_id_for_impl_on_foreign_type(&i.inner_impl().for_, t, cache, tcx)\n                 } else {\n-                    format!(\n-                        \"impl-{}\",\n-                        small_url_encode(format!(\"{:#}\", t.print(cx.cache(), cx.tcx())))\n-                    )\n+                    format!(\"impl-{}\", small_url_encode(format!(\"{:#}\", t.print(cache, tcx))))\n                 }\n             }\n             None => \"impl\".to_string(),\n@@ -1438,7 +1442,7 @@ fn render_impl(\n         };\n         if let Some(use_absolute) = use_absolute {\n             write!(w, \"<h3 id=\\\"{}\\\" class=\\\"impl\\\"{}><code class=\\\"in-band\\\">\", id, aliases);\n-            write!(w, \"{}\", i.inner_impl().print(cx.cache(), use_absolute, cx.tcx()));\n+            write!(w, \"{}\", i.inner_impl().print(cache, use_absolute, tcx));\n             if show_def_docs {\n                 for it in &i.inner_impl().items {\n                     if let clean::TypedefItem(ref tydef, _) = *it.kind {\n@@ -1450,8 +1454,8 @@ fn render_impl(\n                             Some(&tydef.type_),\n                             AssocItemLink::Anchor(None),\n                             \"\",\n-                            cx.cache(),\n-                            cx.tcx(),\n+                            cache,\n+                            tcx,\n                         );\n                         w.write_str(\";</span>\");\n                     }\n@@ -1464,14 +1468,14 @@ fn render_impl(\n                 \"<h3 id=\\\"{}\\\" class=\\\"impl\\\"{}><code class=\\\"in-band\\\">{}</code>\",\n                 id,\n                 aliases,\n-                i.inner_impl().print(cx.cache(), false, cx.tcx())\n+                i.inner_impl().print(cache, false, tcx)\n             );\n         }\n         write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n         render_stability_since_raw(\n             w,\n-            i.impl_item.stable_since(cx.tcx()).as_deref(),\n-            i.impl_item.const_stable_since(cx.tcx()).as_deref(),\n+            i.impl_item.stable_since(tcx).as_deref(),\n+            i.impl_item.const_stable_since(tcx).as_deref(),\n             outer_version,\n             outer_const_version,\n         );\n@@ -1517,6 +1521,7 @@ fn render_impl(\n     ) {\n         let item_type = item.type_();\n         let name = item.name.as_ref().unwrap();\n+        let tcx = cx.tcx();\n \n         let render_method_item = match render_mode {\n             RenderMode::Normal => true,\n@@ -1544,8 +1549,8 @@ fn render_impl(\n                     w.write_str(\"</code>\");\n                     render_stability_since_raw(\n                         w,\n-                        item.stable_since(cx.tcx()).as_deref(),\n-                        item.const_stable_since(cx.tcx()).as_deref(),\n+                        item.stable_since(tcx).as_deref(),\n+                        item.const_stable_since(tcx).as_deref(),\n                         outer_version,\n                         outer_const_version,\n                     );\n@@ -1564,7 +1569,7 @@ fn render_impl(\n                     link.anchor(&id),\n                     \"\",\n                     cx.cache(),\n-                    cx.tcx(),\n+                    tcx,\n                 );\n                 w.write_str(\"</code></h4>\");\n             }\n@@ -1575,8 +1580,8 @@ fn render_impl(\n                 w.write_str(\"</code>\");\n                 render_stability_since_raw(\n                     w,\n-                    item.stable_since(cx.tcx()).as_deref(),\n-                    item.const_stable_since(cx.tcx()).as_deref(),\n+                    item.stable_since(tcx).as_deref(),\n+                    item.const_stable_since(tcx).as_deref(),\n                     outer_version,\n                     outer_const_version,\n                 );\n@@ -1594,7 +1599,7 @@ fn render_impl(\n                     link.anchor(&id),\n                     \"\",\n                     cx.cache(),\n-                    cx.tcx(),\n+                    tcx,\n                 );\n                 w.write_str(\"</code></h4>\");\n             }\n@@ -1898,6 +1903,8 @@ fn small_url_encode(s: String) -> String {\n fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n     if let Some(v) = cx.cache.impls.get(&it.def_id) {\n         let mut used_links = FxHashSet::default();\n+        let tcx = cx.tcx();\n+        let cache = cx.cache();\n \n         {\n             let used_links_bor = &mut used_links;\n@@ -1927,7 +1934,7 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n             if let Some(impl_) = v\n                 .iter()\n                 .filter(|i| i.inner_impl().trait_.is_some())\n-                .find(|i| i.inner_impl().trait_.def_id_full(cx.cache()) == cx.cache.deref_trait_did)\n+                .find(|i| i.inner_impl().trait_.def_id_full(cache) == cx.cache.deref_trait_did)\n             {\n                 sidebar_deref_methods(cx, out, impl_, v);\n             }\n@@ -1938,10 +1945,9 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n                     .iter()\n                     .filter_map(|it| {\n                         if let Some(ref i) = it.inner_impl().trait_ {\n-                            let i_display = format!(\"{:#}\", i.print(cx.cache(), cx.tcx()));\n+                            let i_display = format!(\"{:#}\", i.print(cache, tcx));\n                             let out = Escape(&i_display);\n-                            let encoded =\n-                                small_url_encode(format!(\"{:#}\", i.print(cx.cache(), cx.tcx())));\n+                            let encoded = small_url_encode(format!(\"{:#}\", i.print(cache, tcx)));\n                             let generated = format!(\n                                 \"<a href=\\\"#impl-{}\\\">{}{}</a>\",\n                                 encoded,\n@@ -2018,8 +2024,8 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &V\n         })\n     {\n         debug!(\"found target, real_target: {:?} {:?}\", target, real_target);\n-        if let Some(did) = target.def_id_full(cx.cache()) {\n-            if let Some(type_did) = impl_.inner_impl().for_.def_id_full(cx.cache()) {\n+        if let Some(did) = target.def_id_full(c) {\n+            if let Some(type_did) = impl_.inner_impl().for_.def_id_full(c) {\n                 // `impl Deref<Target = S> for S`\n                 if did == type_did {\n                     // Avoid infinite cycles\n@@ -2030,9 +2036,9 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &V\n         let deref_mut = v\n             .iter()\n             .filter(|i| i.inner_impl().trait_.is_some())\n-            .any(|i| i.inner_impl().trait_.def_id_full(cx.cache()) == c.deref_mut_trait_did);\n+            .any(|i| i.inner_impl().trait_.def_id_full(c) == c.deref_mut_trait_did);\n         let inner_impl = target\n-            .def_id_full(cx.cache())\n+            .def_id_full(c)\n             .or_else(|| {\n                 target.primitive_type().and_then(|prim| c.primitive_locations.get(&prim).cloned())\n             })\n@@ -2048,7 +2054,7 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &V\n             if !ret.is_empty() {\n                 let deref_id_map = cx.deref_id_map.borrow();\n                 let id = deref_id_map\n-                    .get(&real_target.def_id_full(cx.cache()).unwrap())\n+                    .get(&real_target.def_id_full(c).unwrap())\n                     .expect(\"Deref section without derived id\");\n                 write!(\n                     out,\n@@ -2071,12 +2077,12 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &V\n         }\n \n         // Recurse into any further impls that might exist for `target`\n-        if let Some(target_did) = target.def_id_full(cx.cache()) {\n+        if let Some(target_did) = target.def_id_full(c) {\n             if let Some(target_impls) = c.impls.get(&target_did) {\n                 if let Some(target_deref_impl) = target_impls\n                     .iter()\n                     .filter(|i| i.inner_impl().trait_.is_some())\n-                    .find(|i| i.inner_impl().trait_.def_id_full(cx.cache()) == c.deref_trait_did)\n+                    .find(|i| i.inner_impl().trait_.def_id_full(c) == c.deref_trait_did)\n                 {\n                     sidebar_deref_methods(cx, out, target_deref_impl, target_impls);\n                 }\n@@ -2214,15 +2220,17 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n     );\n \n     if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n+        let cache = cx.cache();\n+        let tcx = cx.tcx();\n         let mut res = implementors\n             .iter()\n             .filter(|i| {\n                 i.inner_impl()\n                     .for_\n-                    .def_id_full(cx.cache())\n+                    .def_id_full(cache)\n                     .map_or(false, |d| !cx.cache.paths.contains_key(&d))\n             })\n-            .filter_map(|i| extract_for_impl_name(&i.impl_item, cx.cache(), cx.tcx()))\n+            .filter_map(|i| extract_for_impl_name(&i.impl_item, cache, tcx))\n             .collect::<Vec<_>>();\n \n         if !res.is_empty() {"}]}