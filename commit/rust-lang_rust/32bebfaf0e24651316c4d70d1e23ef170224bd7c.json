{"sha": "32bebfaf0e24651316c4d70d1e23ef170224bd7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyYmViZmFmMGUyNDY1MTMxNmM0ZDcwZDFlMjNlZjE3MDIyNGJkN2M=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-02T14:37:48Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-02T14:37:48Z"}, "message": "cleanup", "tree": {"sha": "db9afdd2881a2585b34c885723a406905903d6cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db9afdd2881a2585b34c885723a406905903d6cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32bebfaf0e24651316c4d70d1e23ef170224bd7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32bebfaf0e24651316c4d70d1e23ef170224bd7c", "html_url": "https://github.com/rust-lang/rust/commit/32bebfaf0e24651316c4d70d1e23ef170224bd7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32bebfaf0e24651316c4d70d1e23ef170224bd7c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f39f72db57a78b7f92f99377be0e05ec3db6dc98", "url": "https://api.github.com/repos/rust-lang/rust/commits/f39f72db57a78b7f92f99377be0e05ec3db6dc98", "html_url": "https://github.com/rust-lang/rust/commit/f39f72db57a78b7f92f99377be0e05ec3db6dc98"}], "stats": {"total": 176, "additions": 86, "deletions": 90}, "files": [{"sha": "2bcbb418427676d7b3aae09160337428a5c0a4c8", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 72, "deletions": 74, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/32bebfaf0e24651316c4d70d1e23ef170224bd7c/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32bebfaf0e24651316c4d70d1e23ef170224bd7c/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=32bebfaf0e24651316c4d70d1e23ef170224bd7c", "patch": "@@ -49,98 +49,96 @@ pub(crate) fn root(p: &mut Parser) {\n     m.complete(p, SOURCE_FILE);\n }\n \n-pub(crate) fn macro_items(p: &mut Parser) {\n-    let m = p.start();\n-    items::mod_contents(p, false);\n-    m.complete(p, MACRO_ITEMS);\n-}\n+/// Various pieces of syntax that can be parsed by macros by example\n+pub(crate) mod fragments {\n+    use super::*;\n \n-pub(crate) fn macro_stmts(p: &mut Parser) {\n-    let m = p.start();\n-\n-    while !p.at(EOF) {\n-        if p.current() == T![;] {\n-            p.bump();\n-            continue;\n-        }\n+    pub(crate) use super::{\n+        expressions::block, paths::type_path as path, patterns::pattern, types::type_,\n+    };\n \n-        expressions::stmt(p, expressions::StmtWithSemi::Optional);\n+    pub(crate) fn expr(p: &mut Parser) {\n+        let _ = expressions::expr(p);\n     }\n \n-    m.complete(p, MACRO_STMTS);\n-}\n-\n-pub(crate) fn path(p: &mut Parser) {\n-    paths::type_path(p);\n-}\n+    pub(crate) fn stmt(p: &mut Parser, with_semi: bool) {\n+        let with_semi =\n+            if with_semi { expressions::StmtWithSemi::Yes } else { expressions::StmtWithSemi::No };\n \n-pub(crate) fn expr(p: &mut Parser) {\n-    expressions::expr(p);\n-}\n+        expressions::stmt(p, with_semi)\n+    }\n \n-pub(crate) fn type_(p: &mut Parser) {\n-    types::type_(p)\n-}\n+    pub(crate) fn opt_visibility(p: &mut Parser) {\n+        let _ = super::opt_visibility(p);\n+    }\n \n-pub(crate) fn pattern(p: &mut Parser) {\n-    patterns::pattern(p)\n-}\n+    // Parse a meta item , which excluded [], e.g : #[ MetaItem ]\n+    pub(crate) fn meta_item(p: &mut Parser) {\n+        fn is_delimiter(p: &mut Parser) -> bool {\n+            match p.current() {\n+                T!['{'] | T!['('] | T!['['] => true,\n+                _ => false,\n+            }\n+        }\n \n-pub(crate) fn stmt(p: &mut Parser, with_semi: bool) {\n-    let with_semi =\n-        if with_semi { expressions::StmtWithSemi::Yes } else { expressions::StmtWithSemi::No };\n+        if is_delimiter(p) {\n+            items::token_tree(p);\n+            return;\n+        }\n \n-    expressions::stmt(p, with_semi)\n-}\n+        let m = p.start();\n+        while !p.at(EOF) {\n+            if is_delimiter(p) {\n+                items::token_tree(p);\n+                break;\n+            } else {\n+                // https://doc.rust-lang.org/reference/attributes.html\n+                // https://doc.rust-lang.org/reference/paths.html#simple-paths\n+                // The start of an meta must be a simple path\n+                match p.current() {\n+                    IDENT | T![::] | T![super] | T![self] | T![crate] => p.bump(),\n+                    T![=] => {\n+                        p.bump();\n+                        match p.current() {\n+                            c if c.is_literal() => p.bump(),\n+                            T![true] | T![false] => p.bump(),\n+                            _ => {}\n+                        }\n+                        break;\n+                    }\n+                    _ => break,\n+                }\n+            }\n+        }\n \n-pub(crate) fn block(p: &mut Parser) {\n-    expressions::block(p);\n-}\n+        m.complete(p, TOKEN_TREE);\n+    }\n \n-// Parse a meta item , which excluded [], e.g : #[ MetaItem ]\n-pub(crate) fn meta_item(p: &mut Parser) {\n-    fn is_delimiter(p: &mut Parser) -> bool {\n-        match p.current() {\n-            T!['{'] | T!['('] | T!['['] => true,\n-            _ => false,\n-        }\n+    pub(crate) fn item(p: &mut Parser) {\n+        items::item_or_macro(p, true, items::ItemFlavor::Mod)\n     }\n \n-    if is_delimiter(p) {\n-        items::token_tree(p);\n-        return;\n+    pub(crate) fn macro_items(p: &mut Parser) {\n+        let m = p.start();\n+        items::mod_contents(p, false);\n+        m.complete(p, MACRO_ITEMS);\n     }\n \n-    let m = p.start();\n-    while !p.at(EOF) {\n-        if is_delimiter(p) {\n-            items::token_tree(p);\n-            break;\n-        } else {\n-            // https://doc.rust-lang.org/reference/attributes.html\n-            // https://doc.rust-lang.org/reference/paths.html#simple-paths\n-            // The start of an meta must be a simple path\n-            match p.current() {\n-                IDENT | T![::] | T![super] | T![self] | T![crate] => p.bump(),\n-                T![=] => {\n-                    p.bump();\n-                    match p.current() {\n-                        c if c.is_literal() => p.bump(),\n-                        T![true] | T![false] => p.bump(),\n-                        _ => {}\n-                    }\n-                    break;\n-                }\n-                _ => break,\n+    pub(crate) fn macro_stmts(p: &mut Parser) {\n+        let m = p.start();\n+\n+        while !p.at(EOF) {\n+            if p.current() == T![;] {\n+                p.bump();\n+                continue;\n             }\n+\n+            expressions::stmt(p, expressions::StmtWithSemi::Optional);\n         }\n-    }\n \n-    m.complete(p, TOKEN_TREE);\n-}\n+        m.complete(p, MACRO_STMTS);\n+    }\n \n-pub(crate) fn item(p: &mut Parser) {\n-    items::item_or_macro(p, true, items::ItemFlavor::Mod)\n }\n \n pub(crate) fn reparser(\n@@ -180,7 +178,7 @@ impl BlockLike {\n     }\n }\n \n-pub(crate) fn opt_visibility(p: &mut Parser) -> bool {\n+fn opt_visibility(p: &mut Parser) -> bool {\n     match p.current() {\n         T![pub] => {\n             let m = p.start();"}, {"sha": "28c35a67d5f7842dd186d9bfaaa99870b93d3f76", "filename": "crates/ra_parser/src/grammar/paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32bebfaf0e24651316c4d70d1e23ef170224bd7c/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32bebfaf0e24651316c4d70d1e23ef170224bd7c/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs?ref=32bebfaf0e24651316c4d70d1e23ef170224bd7c", "patch": "@@ -18,7 +18,7 @@ pub(super) fn use_path(p: &mut Parser) {\n     path(p, Mode::Use)\n }\n \n-pub(super) fn type_path(p: &mut Parser) {\n+pub(crate) fn type_path(p: &mut Parser) {\n     path(p, Mode::Type)\n }\n "}, {"sha": "32cde7de671bcde18a60398da75238cff17d9010", "filename": "crates/ra_parser/src/grammar/patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32bebfaf0e24651316c4d70d1e23ef170224bd7c/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32bebfaf0e24651316c4d70d1e23ef170224bd7c/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=32bebfaf0e24651316c4d70d1e23ef170224bd7c", "patch": "@@ -4,7 +4,7 @@ pub(super) const PATTERN_FIRST: TokenSet = expressions::LITERAL_FIRST\n     .union(paths::PATH_FIRST)\n     .union(token_set![BOX_KW, REF_KW, MUT_KW, L_PAREN, L_BRACK, AMP, UNDERSCORE, MINUS]);\n \n-pub(super) fn pattern(p: &mut Parser) {\n+pub(crate) fn pattern(p: &mut Parser) {\n     pattern_r(p, PAT_RECOVERY_SET);\n }\n "}, {"sha": "9e321b2a699d09684e7fa00223d0e466453d9856", "filename": "crates/ra_parser/src/grammar/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32bebfaf0e24651316c4d70d1e23ef170224bd7c/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32bebfaf0e24651316c4d70d1e23ef170224bd7c/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs?ref=32bebfaf0e24651316c4d70d1e23ef170224bd7c", "patch": "@@ -7,7 +7,7 @@ pub(super) const TYPE_FIRST: TokenSet = paths::PATH_FIRST.union(token_set![\n \n const TYPE_RECOVERY_SET: TokenSet = token_set![R_PAREN, COMMA];\n \n-pub(super) fn type_(p: &mut Parser) {\n+pub(crate) fn type_(p: &mut Parser) {\n     type_with_bounds_cond(p, true);\n }\n "}, {"sha": "e494fc4804b3db6435b5f18ea724e7e9182c52b9", "filename": "crates/ra_parser/src/lib.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/32bebfaf0e24651316c4d70d1e23ef170224bd7c/crates%2Fra_parser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32bebfaf0e24651316c4d70d1e23ef170224bd7c/crates%2Fra_parser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Flib.rs?ref=32bebfaf0e24651316c4d70d1e23ef170224bd7c", "patch": "@@ -85,22 +85,22 @@ pub fn parse(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n \n /// Parse given tokens into the given sink as a path\n pub fn parse_path(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, grammar::path);\n+    parse_from_tokens(token_source, tree_sink, grammar::fragments::path);\n }\n \n /// Parse given tokens into the given sink as a expression\n pub fn parse_expr(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, grammar::expr);\n+    parse_from_tokens(token_source, tree_sink, grammar::fragments::expr);\n }\n \n /// Parse given tokens into the given sink as a ty\n pub fn parse_ty(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, grammar::type_);\n+    parse_from_tokens(token_source, tree_sink, grammar::fragments::type_);\n }\n \n /// Parse given tokens into the given sink as a pattern\n pub fn parse_pat(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, grammar::pattern);\n+    parse_from_tokens(token_source, tree_sink, grammar::fragments::pattern);\n }\n \n /// Parse given tokens into the given sink as a statement\n@@ -109,36 +109,34 @@ pub fn parse_stmt(\n     tree_sink: &mut dyn TreeSink,\n     with_semi: bool,\n ) {\n-    parse_from_tokens(token_source, tree_sink, |p| grammar::stmt(p, with_semi));\n+    parse_from_tokens(token_source, tree_sink, |p| grammar::fragments::stmt(p, with_semi));\n }\n \n /// Parse given tokens into the given sink as a block\n pub fn parse_block(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, grammar::block);\n+    parse_from_tokens(token_source, tree_sink, grammar::fragments::block);\n }\n \n pub fn parse_meta(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, grammar::meta_item);\n+    parse_from_tokens(token_source, tree_sink, grammar::fragments::meta_item);\n }\n \n /// Parse given tokens into the given sink as an item\n pub fn parse_item(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, grammar::item);\n+    parse_from_tokens(token_source, tree_sink, grammar::fragments::item);\n }\n \n /// Parse given tokens into the given sink as an visibility qualifier\n pub fn parse_vis(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, |p| {\n-        grammar::opt_visibility(p);\n-    });\n+    parse_from_tokens(token_source, tree_sink, grammar::fragments::opt_visibility);\n }\n \n pub fn parse_macro_items(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, grammar::macro_items);\n+    parse_from_tokens(token_source, tree_sink, grammar::fragments::macro_items);\n }\n \n pub fn parse_macro_stmts(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n-    parse_from_tokens(token_source, tree_sink, grammar::macro_stmts);\n+    parse_from_tokens(token_source, tree_sink, grammar::fragments::macro_stmts);\n }\n \n /// A parsing function for a specific braced-block."}]}