{"sha": "8742fd9c8592a846d487e8a1cdab8235859c4bc8", "node_id": "C_kwDOAAsO6NoAKDg3NDJmZDljODU5MmE4NDZkNDg3ZThhMWNkYWI4MjM1ODU5YzRiYzg", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-08T00:29:30Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-21T05:49:36Z"}, "message": "Label closure captures/generator locals that make opaque types recursive", "tree": {"sha": "346fb83442fd7ab577448cfc4fc6f58e2b66bd19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/346fb83442fd7ab577448cfc4fc6f58e2b66bd19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8742fd9c8592a846d487e8a1cdab8235859c4bc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8742fd9c8592a846d487e8a1cdab8235859c4bc8", "html_url": "https://github.com/rust-lang/rust/commit/8742fd9c8592a846d487e8a1cdab8235859c4bc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8742fd9c8592a846d487e8a1cdab8235859c4bc8/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0726909f6d219951ba15ac2f65656eff96bb1867", "url": "https://api.github.com/repos/rust-lang/rust/commits/0726909f6d219951ba15ac2f65656eff96bb1867", "html_url": "https://github.com/rust-lang/rust/commit/0726909f6d219951ba15ac2f65656eff96bb1867"}], "stats": {"total": 105, "additions": 99, "deletions": 6}, "files": [{"sha": "abc1c2d7b8d1754ade0e1b977b8032a7c331c787", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 53, "deletions": 6, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8742fd9c8592a846d487e8a1cdab8235859c4bc8/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8742fd9c8592a846d487e8a1cdab8235859c4bc8/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=8742fd9c8592a846d487e8a1cdab8235859c4bc8", "patch": "@@ -1391,11 +1391,15 @@ fn async_opaque_type_cycle_error(tcx: TyCtxt<'_>, span: Span) -> ErrorGuaranteed\n ///\n /// If all the return expressions evaluate to `!`, then we explain that the error will go away\n /// after changing it. This can happen when a user uses `panic!()` or similar as a placeholder.\n-fn opaque_type_cycle_error(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) -> ErrorGuaranteed {\n+fn opaque_type_cycle_error(\n+    tcx: TyCtxt<'_>,\n+    opaque_def_id: LocalDefId,\n+    span: Span,\n+) -> ErrorGuaranteed {\n     let mut err = struct_span_err!(tcx.sess, span, E0720, \"cannot resolve opaque type\");\n \n     let mut label = false;\n-    if let Some((def_id, visitor)) = get_owner_return_paths(tcx, def_id) {\n+    if let Some((def_id, visitor)) = get_owner_return_paths(tcx, opaque_def_id) {\n         let typeck_results = tcx.typeck(def_id);\n         if visitor\n             .returns\n@@ -1431,28 +1435,71 @@ fn opaque_type_cycle_error(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) -> E\n                 .filter_map(|e| typeck_results.node_type_opt(e.hir_id).map(|t| (e.span, t)))\n                 .filter(|(_, ty)| !matches!(ty.kind(), ty::Never))\n             {\n-                struct OpaqueTypeCollector(Vec<DefId>);\n+                #[derive(Default)]\n+                struct OpaqueTypeCollector {\n+                    opaques: Vec<DefId>,\n+                    closures: Vec<DefId>,\n+                }\n                 impl<'tcx> ty::visit::TypeVisitor<'tcx> for OpaqueTypeCollector {\n                     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n                         match *t.kind() {\n                             ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, .. }) => {\n-                                self.0.push(def);\n+                                self.opaques.push(def);\n                                 ControlFlow::Continue(())\n                             }\n+                            ty::Closure(def_id, ..) | ty::Generator(def_id, ..) => {\n+                                self.closures.push(def_id);\n+                                t.super_visit_with(self)\n+                            }\n                             _ => t.super_visit_with(self),\n                         }\n                     }\n                 }\n-                let mut visitor = OpaqueTypeCollector(vec![]);\n+\n+                let mut visitor = OpaqueTypeCollector::default();\n                 ty.visit_with(&mut visitor);\n-                for def_id in visitor.0 {\n+                for def_id in visitor.opaques {\n                     let ty_span = tcx.def_span(def_id);\n                     if !seen.contains(&ty_span) {\n                         err.span_label(ty_span, &format!(\"returning this opaque type `{ty}`\"));\n                         seen.insert(ty_span);\n                     }\n                     err.span_label(sp, &format!(\"returning here with type `{ty}`\"));\n                 }\n+\n+                for closure_def_id in visitor.closures {\n+                    let Some(closure_local_did) = closure_def_id.as_local() else { continue; };\n+                    let typeck_results = tcx.typeck(closure_local_did);\n+\n+                    let mut label_match = |ty: Ty<'_>, span| {\n+                        for arg in ty.walk() {\n+                            if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+                                && let ty::Alias(ty::Opaque, ty::AliasTy { def_id: captured_def_id, .. }) = *ty.kind()\n+                                && captured_def_id == opaque_def_id.to_def_id()\n+                            {\n+                                err.span_label(\n+                                    span,\n+                                    format!(\n+                                        \"{} captures itself here\",\n+                                        tcx.def_kind(closure_def_id).descr(closure_def_id)\n+                                    ),\n+                                );\n+                            }\n+                        }\n+                    };\n+\n+                    // Label any closure upvars that capture the opaque\n+                    for capture in typeck_results.closure_min_captures_flattened(closure_local_did)\n+                    {\n+                        label_match(capture.place.ty(), capture.get_path_span(tcx));\n+                    }\n+                    // Label any generator locals that capture the opaque\n+                    for interior_ty in\n+                        typeck_results.generator_interior_types.as_ref().skip_binder()\n+                    {\n+                        label_match(interior_ty.ty, interior_ty.span);\n+                    }\n+                }\n             }\n         }\n     }"}, {"sha": "e876f0fb43f65086be101f0aff1f1e98d67c012c", "filename": "tests/ui/impl-trait/recursive-generator.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8742fd9c8592a846d487e8a1cdab8235859c4bc8/tests%2Fui%2Fimpl-trait%2Frecursive-generator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8742fd9c8592a846d487e8a1cdab8235859c4bc8/tests%2Fui%2Fimpl-trait%2Frecursive-generator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Frecursive-generator.rs?ref=8742fd9c8592a846d487e8a1cdab8235859c4bc8", "patch": "@@ -0,0 +1,23 @@\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::{Generator, GeneratorState};\n+\n+fn foo() -> impl Generator<Yield = (), Return = ()> {\n+    //~^ ERROR cannot resolve opaque type\n+    //~| NOTE recursive opaque type\n+    //~| NOTE in this expansion of desugaring of\n+    || {\n+    //~^ NOTE returning here\n+        let mut gen = Box::pin(foo());\n+        //~^ NOTE generator captures itself here\n+        let mut r = gen.as_mut().resume(());\n+        while let GeneratorState::Yielded(v) = r {\n+            yield v;\n+            r = gen.as_mut().resume(());\n+        }\n+    }\n+}\n+\n+fn main() {\n+    foo();\n+}"}, {"sha": "e23fd4b4a85e51526cd82ac0ddb64238d126e429", "filename": "tests/ui/impl-trait/recursive-generator.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8742fd9c8592a846d487e8a1cdab8235859c4bc8/tests%2Fui%2Fimpl-trait%2Frecursive-generator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8742fd9c8592a846d487e8a1cdab8235859c4bc8/tests%2Fui%2Fimpl-trait%2Frecursive-generator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Frecursive-generator.stderr?ref=8742fd9c8592a846d487e8a1cdab8235859c4bc8", "patch": "@@ -0,0 +1,19 @@\n+error[E0720]: cannot resolve opaque type\n+  --> $DIR/recursive-generator.rs:5:13\n+   |\n+LL |   fn foo() -> impl Generator<Yield = (), Return = ()> {\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ recursive opaque type\n+...\n+LL | /     || {\n+LL | |\n+LL | |         let mut gen = Box::pin(foo());\n+   | |             ------- generator captures itself here\n+LL | |\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____- returning here with type `[generator@$DIR/recursive-generator.rs:9:5: 9:7]`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0720`."}, {"sha": "ebb231ae14f0d77b564567461740e41a377d97dd", "filename": "tests/ui/impl-trait/recursive-impl-trait-type-indirect.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8742fd9c8592a846d487e8a1cdab8235859c4bc8/tests%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8742fd9c8592a846d487e8a1cdab8235859c4bc8/tests%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr?ref=8742fd9c8592a846d487e8a1cdab8235859c4bc8", "patch": "@@ -53,6 +53,7 @@ LL |   fn closure_capture() -> impl Sized {\n ...\n LL | /     move || {\n LL | |         x;\n+   | |         - closure captures itself here\n LL | |     }\n    | |_____- returning here with type `[closure@$DIR/recursive-impl-trait-type-indirect.rs:35:5: 35:12]`\n \n@@ -64,6 +65,7 @@ LL |   fn closure_ref_capture() -> impl Sized {\n ...\n LL | /     move || {\n LL | |         &x;\n+   | |          - closure captures itself here\n LL | |     }\n    | |_____- returning here with type `[closure@$DIR/recursive-impl-trait-type-indirect.rs:43:5: 43:12]`\n \n@@ -94,6 +96,7 @@ LL |   fn generator_capture() -> impl Sized {\n LL | /     move || {\n LL | |         yield;\n LL | |         x;\n+   | |         - generator captures itself here\n LL | |     }\n    | |_____- returning here with type `[generator@$DIR/recursive-impl-trait-type-indirect.rs:61:5: 61:12]`\n \n@@ -114,6 +117,7 @@ LL |   fn generator_hold() -> impl Sized {\n LL |\n LL | /     move || {\n LL | |         let x = generator_hold();\n+   | |             - generator captures itself here\n LL | |         yield;\n LL | |         x;\n LL | |     }"}]}