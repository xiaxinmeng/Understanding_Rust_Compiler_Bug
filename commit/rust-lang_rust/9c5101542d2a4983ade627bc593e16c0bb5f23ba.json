{"sha": "9c5101542d2a4983ade627bc593e16c0bb5f23ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNTEwMTU0MmQyYTQ5ODNhZGU2MjdiYzU5M2UxNmMwYmI1ZjIzYmE=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-11-22T01:47:40Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-12-20T14:10:02Z"}, "message": "Conventions and cleanup for Bitv and BitvSet\n\nPart of #18424\n\nThis commit changes the semantics of `reserve` and `capacity` for Bitv and BitvSet to match conventions. It also introduces the notion of `reserve_index` and `reserve_index_exact` for collections with maximum-index-based capacity semantics.\n\nDeprecates free function constructors in favour of functions on Bitv itself.\n\nChanges `Bitv::pop` to return an Option rather than panicking.\n\nDeprecates and renames several methods in favour of conventions.\n\nMarks several blessed methods as unstable.\n\nThis commit also substantially refactors Bitv and BitvSet's implementations. The new implementation is simpler, cleaner, better documented, and more robust against overflows. It also reduces coupling between Bitv and BitvSet. Tests have been seperated into seperate submodules.\n\nFixes #16958\n\n[breaking-change]", "tree": {"sha": "b4d01fad71809dbcba2f15e22866dafc67cdb0ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4d01fad71809dbcba2f15e22866dafc67cdb0ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c5101542d2a4983ade627bc593e16c0bb5f23ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c5101542d2a4983ade627bc593e16c0bb5f23ba", "html_url": "https://github.com/rust-lang/rust/commit/9c5101542d2a4983ade627bc593e16c0bb5f23ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c5101542d2a4983ade627bc593e16c0bb5f23ba/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f51ad2420776925c12be67a7bf38ac28343fd1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f51ad2420776925c12be67a7bf38ac28343fd1f", "html_url": "https://github.com/rust-lang/rust/commit/8f51ad2420776925c12be67a7bf38ac28343fd1f"}], "stats": {"total": 1625, "additions": 897, "deletions": 728}, "files": [{"sha": "41a5ccb7a0645e4da98e9245f4f0dea00cf60ad0", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 894, "deletions": 725, "changes": 1619, "blob_url": "https://github.com/rust-lang/rust/blob/9c5101542d2a4983ade627bc593e16c0bb5f23ba/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5101542d2a4983ade627bc593e16c0bb5f23ba/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=9c5101542d2a4983ade627bc593e16c0bb5f23ba", "patch": "@@ -11,6 +11,16 @@\n // FIXME(Gankro): Bitv and BitvSet are very tightly coupled. Ideally (for maintenance),\n // they should be in separate files/modules, with BitvSet only using Bitv's public API.\n \n+// First rule of Bitv club: almost everything can actually overflow because we're working with\n+// bits and not bytes.\n+//\n+// Second rule of Bitv club: the last \"block\" of bits may be partially used. We must ensure that\n+// those unused bits are zeroed out, as other methods will assume this is the case. It may be\n+// the case that this isn't a great design, but having \"undefined\" bits is headache-inducing.\n+//\n+// Third rule of Bitv club: BitvSet is fairly tightly coupled to Bitv's implementation details.\n+// Make sure any changes to Bitv are properly addressed in BitvSet.\n+\n //! Collections implemented with bit vectors.\n //!\n //! # Examples\n@@ -31,7 +41,7 @@\n //! let primes = {\n //!     // Assume all numbers are prime to begin, and then we\n //!     // cross off non-primes progressively\n-//!     let mut bv = Bitv::with_capacity(max_prime, true);\n+//!     let mut bv = Bitv::from_elem(max_prime, true);\n //!\n //!     // Neither 0 nor 1 are prime\n //!     bv.set(0, false);\n@@ -68,18 +78,19 @@ use core::prelude::*;\n use core::cmp;\n use core::default::Default;\n use core::fmt;\n-use core::iter::{Chain, Enumerate, Repeat, Skip, Take, repeat};\n+use core::iter::{Cloned, Chain, Enumerate, Repeat, Skip, Take};\n use core::iter;\n use core::num::Int;\n-use core::slice;\n-use core::u32;\n+use core::slice::{Items, MutItems};\n+use core::{u32, uint};\n use std::hash;\n \n use vec::Vec;\n \n-// FIXME(conventions): look, we just need to refactor this whole thing. Inside and out.\n+type Blocks<'a> = Cloned<Items<'a, u32>>\n+type MutBlocks<'a> MutItems<'a, u32>;\n+type MatchWords<'a> = Chain<Enumerate<Blocks<'a>>, Skip<Take<Enumerate<Repeat<u32>>>>>;\n \n-type MatchWords<'a> = Chain<MaskWords<'a>, Skip<Take<Enumerate<Repeat<u32>>>>>;\n // Take two BitV's, and return iterators of their words, where the shorter one\n // has been padded with 0's\n fn match_words <'a,'b>(a: &'a Bitv, b: &'b Bitv) -> (MatchWords<'a>, MatchWords<'b>) {\n@@ -88,11 +99,11 @@ fn match_words <'a,'b>(a: &'a Bitv, b: &'b Bitv) -> (MatchWords<'a>, MatchWords<\n \n     // have to uselessly pretend to pad the longer one for type matching\n     if a_len < b_len {\n-        (a.mask_words(0).chain(repeat(0u32).enumerate().take(b_len).skip(a_len)),\n-         b.mask_words(0).chain(repeat(0u32).enumerate().take(0).skip(0)))\n+        (a.blocks().enumerate().chain(iter::repeat(0u32).enumerate().take(b_len).skip(a_len)),\n+         b.blocks().enumerate().chain(iter::repeat(0u32).enumerate().take(0).skip(0)))\n     } else {\n-        (a.mask_words(0).chain(repeat(0u32).enumerate().take(0).skip(0)),\n-         b.mask_words(0).chain(repeat(0u32).enumerate().take(a_len).skip(b_len)))\n+        (a.blocks().enumerate().chain(iter::repeat(0u32).enumerate().take(0).skip(0)),\n+         b.blocks().enumerate().chain(iter::repeat(0u32).enumerate().take(a_len).skip(b_len)))\n     }\n }\n \n@@ -106,7 +117,7 @@ static FALSE: bool = false;\n /// ```rust\n /// use collections::Bitv;\n ///\n-/// let mut bv = Bitv::with_capacity(10, false);\n+/// let mut bv = Bitv::from_elem(10, false);\n ///\n /// // insert all primes less than 10\n /// bv.set(2, true);\n@@ -133,46 +144,39 @@ pub struct Bitv {\n     nbits: uint\n }\n \n+// FIXME(Gankro): NopeNopeNopeNopeNope (wait for IndexGet to be a thing)\n impl Index<uint,bool> for Bitv {\n     #[inline]\n     fn index<'a>(&'a self, i: &uint) -> &'a bool {\n-        if self.get(*i) {\n+        if self.get(*i).expect(\"index out of bounds\") {\n             &TRUE\n         } else {\n             &FALSE\n         }\n     }\n }\n \n-struct MaskWords<'a> {\n-    iter: slice::Items<'a, u32>,\n-    next_word: Option<&'a u32>,\n-    last_word_mask: u32,\n-    offset: uint\n-}\n-\n-impl<'a> Iterator<(uint, u32)> for MaskWords<'a> {\n-    /// Returns (offset, word)\n-    #[inline]\n-    fn next(&mut self) -> Option<(uint, u32)> {\n-        let ret = self.next_word;\n-        match ret {\n-            Some(&w) => {\n-                self.next_word = self.iter.next();\n-                self.offset += 1;\n-                // The last word may need to be masked\n-                if self.next_word.is_none() {\n-                    Some((self.offset - 1, w & self.last_word_mask))\n-                } else {\n-                    Some((self.offset - 1, w))\n-                }\n-            },\n-            None => None\n-        }\n+/// Computes how many blocks are needed to store that many bits\n+fn blocks_for_bits(bits: uint) -> uint {\n+    // If we want 17 bits, dividing by 32 will produce 0. So we add 1 to make sure we\n+    // reserve enough. But if we want exactly a multiple of 32, this will actually allocate\n+    // one too many. So we need to check if that's the case. We can do that by computing if\n+    // bitwise AND by `32 - 1` is 0. But LLVM should be able to optimize the semantically\n+    // superior modulo operator on a power of two to this.\n+    //\n+    // Note that we can technically avoid this branch with the expression\n+    // `(nbits + u32::BITS - 1) / 32::BITS`, but if nbits is almost uint::MAX this will overflow.\n+    if bits % u32::BITS == 0 {\n+        bits / u32::BITS\n+    } else {\n+        bits / u32::BITS + 1\n     }\n+\n }\n \n impl Bitv {\n+    /// Applies the given operation to the blocks of self and other, and sets self to\n+    /// be the result.\n     #[inline]\n     fn process<F>(&mut self, other: &Bitv, mut op: F) -> bool where F: FnMut(u32, u32) -> u32 {\n         let len = other.storage.len();\n@@ -182,8 +186,7 @@ impl Bitv {\n         // `op` is a bitwise operation, since any bits that should've\n         // been masked were fine to change anyway. `b` is masked to\n         // make sure its unmasked bits do not cause damage.\n-        for (a, (_, b)) in self.storage.iter_mut()\n-                           .zip(other.mask_words(0)) {\n+        for (a, b) in self.blocks_mut().zip(other.blocks()) {\n             let w = op(*a, b);\n             if *a != w {\n                 changed = true;\n@@ -193,22 +196,27 @@ impl Bitv {\n         changed\n     }\n \n-    #[inline]\n-    fn mask_words<'a>(&'a self, mut start: uint) -> MaskWords<'a> {\n-        if start > self.storage.len() {\n-            start = self.storage.len();\n-        }\n-        let mut iter = self.storage[start..].iter();\n-        MaskWords {\n-          next_word: iter.next(),\n-          iter: iter,\n-          last_word_mask: {\n-              let rem = self.nbits % u32::BITS;\n-              if rem > 0 {\n-                  (1 << rem) - 1\n-              } else { !0 }\n-          },\n-          offset: start\n+    /// Iterator over mutable refs to  the underlying blocks of data.\n+    fn blocks_mut(&mut self) -> MutBlocks {\n+        let blocks = blocks_for_bits(self.len());\n+        self.storage[..blocks].iter_mut()\n+    }\n+\n+    /// Iterator over the underlying blocks of data\n+    fn blocks(&self) -> Blocks {\n+        let blocks = blocks_for_bits(self.len());\n+        self.storage[..blocks].iter().cloned()\n+    }\n+\n+    /// An operation might screw up the unused bits in the last block of the Bitv.\n+    /// It's assumed to be all 0's. This fixes it up.\n+    fn fix_last_block(&mut self) {\n+        let len = self.len();\n+        let extra_bits = len % u32::BITS;\n+        if extra_bits > 0 {\n+            let mask = (1 << extra_bits) - 1;\n+            let storage_len = self.storage.len();\n+            self.storage[storage_len - 1] &= mask;\n         }\n     }\n \n@@ -226,61 +234,111 @@ impl Bitv {\n     }\n \n     /// Creates a `Bitv` that holds `nbits` elements, setting each element\n-    /// to `init`.\n+    /// to `bit`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = Bitv::with_capacity(10u, false);\n+    /// let mut bv = Bitv::from_elem(10u, false);\n     /// assert_eq!(bv.len(), 10u);\n     /// for x in bv.iter() {\n     ///     assert_eq!(x, false);\n     /// }\n     /// ```\n-    pub fn with_capacity(nbits: uint, init: bool) -> Bitv {\n+    pub fn from_elem(nbits: uint, bit: bool) -> Bitv {\n+        let nblocks = blocks_for_bits(nbits);\n         let mut bitv = Bitv {\n-            storage: Vec::from_elem((nbits + u32::BITS - 1) / u32::BITS,\n-                                    if init { !0u32 } else { 0u32 }),\n+            storage: Vec::from_elem(nblocks, if bit { !0u32 } else { 0u32 }),\n             nbits: nbits\n         };\n \n-        // Zero out any unused bits in the highest word if necessary\n-        let used_bits = bitv.nbits % u32::BITS;\n-        if init && used_bits != 0 {\n-            let largest_used_word = (bitv.nbits + u32::BITS - 1) / u32::BITS - 1;\n-            bitv.storage[largest_used_word] &= (1 << used_bits) - 1;\n+        bitv.fix_last_block();\n+        bitv\n+    }\n+\n+    /// Constructs a new, empty `Bitv` with the specified capacity.\n+    ///\n+    /// The bitvector will be able to hold at least `capacity` bits without\n+    /// reallocating. If `capacity` is 0, it will not allocate.\n+    ///\n+    /// It is important to note that this function does not specify the\n+    /// *length* of the returned bitvector, but only the *capacity*.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn with_capacity(nbits: uint) -> Bitv {\n+        Bitv {\n+            storage: Vec::with_capacity(blocks_for_bits(nbits)),\n+            nbits: 0,\n         }\n+    }\n \n-        bitv\n+    /// Transforms a byte-vector into a `Bitv`. Each byte becomes eight bits,\n+    /// with the most significant bits of each byte coming first. Each\n+    /// bit becomes `true` if equal to 1 or `false` if equal to 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let bv = Bitv::from_bytes(&[0b10100000, 0b00010010]);\n+    /// assert!(bv.eq_vec(&[true, false, true, false,\n+    ///                     false, false, false, false,\n+    ///                     false, false, false, true,\n+    ///                     false, false, true, false]));\n+    /// ```\n+    pub fn from_bytes(bytes: &[u8]) -> Bitv {\n+        Bitv::from_fn(bytes.len() * 8, |i| {\n+            let b = bytes[i / 8] as u32;\n+            let offset = i % 8;\n+            b >> (7 - offset) & 1 == 1\n+        })\n     }\n \n-    /// Retrieves the value at index `i`.\n+    /// Creates a `Bitv` of the specified length where the value at each\n+    /// index is `f(index)`.\n     ///\n-    /// # Panics\n+    /// # Examples\n     ///\n-    /// Panics if `i` is out of bounds.\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let bv = Bitv::from_fn(5, |i| { i % 2 == 0 });\n+    /// assert!(bv.eq_vec(&[true, false, true, false, true]));\n+    /// ```\n+    pub fn from_fn<F>(len: uint, mut f: F) -> Bitv where F: FnMut(uint) -> bool {\n+        let mut bitv = Bitv::from_elem(len, false);\n+        for i in range(0u, len) {\n+            bitv.set(i, f(i));\n+        }\n+        bitv\n+    }\n+\n+    /// Retrieves the value at index `i`, or `None` if the index is out of bounds.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n-    /// let bv = bitv::from_bytes(&[0b01100000]);\n-    /// assert_eq!(bv.get(0), false);\n-    /// assert_eq!(bv.get(1), true);\n+    /// let bv = Bitv::from_bytes(&[0b01100000]);\n+    /// assert_eq!(bv.get(0), Some(false));\n+    /// assert_eq!(bv.get(1), Some(true));\n+    /// assert_eq!(bv.get(100), None);\n     ///\n     /// // Can also use array indexing\n     /// assert_eq!(bv[1], true);\n     /// ```\n     #[inline]\n-    pub fn get(&self, i: uint) -> bool {\n+    #[unstable = \"panic semantics are likely to change in the future\"]\n+    pub fn get(&self, i: uint) -> Option<bool> {\n         assert!(i < self.nbits);\n         let w = i / u32::BITS;\n         let b = i % u32::BITS;\n-        let x = self.storage[w] & (1 << b);\n-        x != 0\n+        self.storage.get(w).map(|block|\n+            (block & (1 << b)) != 0\n+        )\n     }\n \n     /// Sets the value of a bit at an index `i`.\n@@ -294,11 +352,12 @@ impl Bitv {\n     /// ```\n     /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = Bitv::with_capacity(5, false);\n+    /// let mut bv = Bitv::from_elem(5, false);\n     /// bv.set(3, true);\n     /// assert_eq!(bv[3], true);\n     /// ```\n     #[inline]\n+    #[unstable = \"panic semantics are likely to change in the future\"]\n     pub fn set(&mut self, i: uint, x: bool) {\n         assert!(i < self.nbits);\n         let w = i / u32::BITS;\n@@ -314,37 +373,39 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n     /// let before = 0b01100000;\n     /// let after  = 0b11111111;\n     ///\n-    /// let mut bv = bitv::from_bytes(&[before]);\n+    /// let mut bv = Bitv::from_bytes(&[before]);\n     /// bv.set_all();\n-    /// assert_eq!(bv, bitv::from_bytes(&[after]));\n+    /// assert_eq!(bv, Bitv::from_bytes(&[after]));\n     /// ```\n     #[inline]\n     pub fn set_all(&mut self) {\n         for w in self.storage.iter_mut() { *w = !0u32; }\n+        self.fix_last_block();\n     }\n \n     /// Flips all bits.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n     /// let before = 0b01100000;\n     /// let after  = 0b10011111;\n     ///\n-    /// let mut bv = bitv::from_bytes(&[before]);\n+    /// let mut bv = Bitv::from_bytes(&[before]);\n     /// bv.negate();\n-    /// assert_eq!(bv, bitv::from_bytes(&[after]));\n+    /// assert_eq!(bv, Bitv::from_bytes(&[after]));\n     /// ```\n     #[inline]\n     pub fn negate(&mut self) {\n         for w in self.storage.iter_mut() { *w = !*w; }\n+        self.fix_last_block();\n     }\n \n     /// Calculates the union of two bitvectors. This acts like the bitwise `or`\n@@ -360,17 +421,17 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n     /// let a   = 0b01100100;\n     /// let b   = 0b01011010;\n     /// let res = 0b01111110;\n     ///\n-    /// let mut a = bitv::from_bytes(&[a]);\n-    /// let b = bitv::from_bytes(&[b]);\n+    /// let mut a = Bitv::from_bytes(&[a]);\n+    /// let b = Bitv::from_bytes(&[b]);\n     ///\n     /// assert!(a.union(&b));\n-    /// assert_eq!(a, bitv::from_bytes(&[res]));\n+    /// assert_eq!(a, Bitv::from_bytes(&[res]));\n     /// ```\n     #[inline]\n     pub fn union(&mut self, other: &Bitv) -> bool {\n@@ -390,17 +451,17 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n     /// let a   = 0b01100100;\n     /// let b   = 0b01011010;\n     /// let res = 0b01000000;\n     ///\n-    /// let mut a = bitv::from_bytes(&[a]);\n-    /// let b = bitv::from_bytes(&[b]);\n+    /// let mut a = Bitv::from_bytes(&[a]);\n+    /// let b = Bitv::from_bytes(&[b]);\n     ///\n     /// assert!(a.intersect(&b));\n-    /// assert_eq!(a, bitv::from_bytes(&[res]));\n+    /// assert_eq!(a, Bitv::from_bytes(&[res]));\n     /// ```\n     #[inline]\n     pub fn intersect(&mut self, other: &Bitv) -> bool {\n@@ -420,24 +481,24 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n     /// let a   = 0b01100100;\n     /// let b   = 0b01011010;\n     /// let a_b = 0b00100100; // a - b\n     /// let b_a = 0b00011010; // b - a\n     ///\n-    /// let mut bva = bitv::from_bytes(&[a]);\n-    /// let bvb = bitv::from_bytes(&[b]);\n+    /// let mut bva = Bitv::from_bytes(&[a]);\n+    /// let bvb = Bitv::from_bytes(&[b]);\n     ///\n     /// assert!(bva.difference(&bvb));\n-    /// assert_eq!(bva, bitv::from_bytes(&[a_b]));\n+    /// assert_eq!(bva, Bitv::from_bytes(&[a_b]));\n     ///\n-    /// let bva = bitv::from_bytes(&[a]);\n-    /// let mut bvb = bitv::from_bytes(&[b]);\n+    /// let bva = Bitv::from_bytes(&[a]);\n+    /// let mut bvb = Bitv::from_bytes(&[b]);\n     ///\n     /// assert!(bvb.difference(&bva));\n-    /// assert_eq!(bvb, bitv::from_bytes(&[b_a]));\n+    /// assert_eq!(bvb, Bitv::from_bytes(&[b_a]));\n     /// ```\n     #[inline]\n     pub fn difference(&mut self, other: &Bitv) -> bool {\n@@ -451,33 +512,35 @@ impl Bitv {\n     /// ```\n     /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = Bitv::with_capacity(5, true);\n+    /// let mut bv = Bitv::from_elem(5, true);\n     /// assert_eq!(bv.all(), true);\n     ///\n     /// bv.set(1, false);\n     /// assert_eq!(bv.all(), false);\n     /// ```\n-    #[inline]\n     pub fn all(&self) -> bool {\n         let mut last_word = !0u32;\n-        // Check that every word but the last is all-ones...\n-        self.mask_words(0).all(|(_, elem)|\n-            { let tmp = last_word; last_word = elem; tmp == !0u32 }) &&\n-        // ...and that the last word is ones as far as it needs to be\n-        (last_word == ((1 << self.nbits % u32::BITS) - 1) || last_word == !0u32)\n+        // Check that every block but the last is all-ones...\n+        self.blocks().all(|elem| {\n+            let tmp = last_word;\n+            last_word = elem;\n+            tmp == !0u32\n+        // and then check the last one has enough ones\n+        }) && (last_word == ((1 << self.nbits % u32::BITS) - 1) || last_word == !0u32)\n     }\n \n     /// Returns an iterator over the elements of the vector in order.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n-    /// let bv = bitv::from_bytes(&[0b01110100, 0b10010010]);\n+    /// let bv = Bitv::from_bytes(&[0b01110100, 0b10010010]);\n     /// assert_eq!(bv.iter().filter(|x| *x).count(), 7);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> Bits<'a> {\n         Bits {bitv: self, next_idx: 0, end_idx: self.nbits}\n     }\n@@ -489,14 +552,14 @@ impl Bitv {\n     /// ```\n     /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = Bitv::with_capacity(10, false);\n+    /// let mut bv = Bitv::from_elem(10, false);\n     /// assert_eq!(bv.none(), true);\n     ///\n     /// bv.set(3, true);\n     /// assert_eq!(bv.none(), false);\n     /// ```\n     pub fn none(&self) -> bool {\n-        self.mask_words(0).all(|(_, w)| w == 0)\n+        self.blocks().all(|w| w == 0)\n     }\n \n     /// Returns `true` if any bit is 1.\n@@ -506,7 +569,7 @@ impl Bitv {\n     /// ```\n     /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = Bitv::with_capacity(10, false);\n+    /// let mut bv = Bitv::from_elem(10, false);\n     /// assert_eq!(bv.any(), false);\n     ///\n     /// bv.set(3, true);\n@@ -527,12 +590,12 @@ impl Bitv {\n     /// ```\n     /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = Bitv::with_capacity(3, true);\n+    /// let mut bv = Bitv::from_elem(3, true);\n     /// bv.set(1, false);\n     ///\n     /// assert_eq!(bv.to_bytes(), vec!(0b10100000));\n     ///\n-    /// let mut bv = Bitv::with_capacity(9, false);\n+    /// let mut bv = Bitv::from_elem(9, false);\n     /// bv.set(2, true);\n     /// bv.set(8, true);\n     ///\n@@ -544,7 +607,7 @@ impl Bitv {\n             if offset >= bitv.nbits {\n                 0\n             } else {\n-                bitv.get(offset) as u8 << (7 - bit)\n+                bitv[offset] as u8 << (7 - bit)\n             }\n         }\n \n@@ -562,19 +625,10 @@ impl Bitv {\n         )\n     }\n \n-    /// Transforms `self` into a `Vec<bool>` by turning each bit into a `bool`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::bitv;\n-    ///\n-    /// let bv = bitv::from_bytes(&[0b10100000]);\n-    /// assert_eq!(bv.to_bools(), vec!(true, false, true, false,\n-    ///                                false, false, false, false));\n-    /// ```\n+    /// Deprecated: Use `iter().collect()`.\n+    #[deprecated = \"Use `iter().collect()`\"]\n     pub fn to_bools(&self) -> Vec<bool> {\n-        Vec::from_fn(self.nbits, |i| self.get(i))\n+        Vec::from_fn(self.nbits, |i| self[i])\n     }\n \n     /// Compares a `Bitv` to a slice of `bool`s.\n@@ -587,9 +641,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n-    /// let bv = bitv::from_bytes(&[0b10100000]);\n+    /// let bv = Bitv::from_bytes(&[0b10100000]);\n     ///\n     /// assert!(bv.eq_vec(&[true, false, true, false,\n     ///                     false, false, false, false]));\n@@ -598,7 +652,7 @@ impl Bitv {\n         assert_eq!(self.nbits, v.len());\n         let mut i = 0;\n         while i < self.nbits {\n-            if self.get(i) != v[i] { return false; }\n+            if self[i] != v[i] { return false; }\n             i = i + 1;\n         }\n         true\n@@ -612,42 +666,82 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = bitv::from_bytes(&[0b01001011]);\n+    /// let mut bv = Bitv::from_bytes(&[0b01001011]);\n     /// bv.truncate(2);\n     /// assert!(bv.eq_vec(&[false, true]));\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn truncate(&mut self, len: uint) {\n         if len < self.len() {\n             self.nbits = len;\n-            let word_len = (len + u32::BITS - 1) / u32::BITS;\n-            self.storage.truncate(word_len);\n-            if len % u32::BITS > 0 {\n-                let mask = (1 << len % u32::BITS) - 1;\n-                self.storage[word_len - 1] &= mask;\n+            self.storage.truncate(blocks_for_bits(len));\n+            self.fix_last_block();\n+        }\n+    }\n+\n+    /// Reserves capacity for at least `additional` more bits to be inserted in the given\n+    /// `Bitv`. The collection may reserve more space to avoid frequent reallocations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let mut bv = Bitv::from_elem(3, false);\n+    /// bv.reserve(10);\n+    /// assert_eq!(bv.len(), 3);\n+    /// assert!(bv.capacity() >= 13);\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve(&mut self, additional: uint) {\n+        let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n+        match self.storage.len().checked_mul(u32::BITS) {\n+            None => {} // Vec has more initialized capacity than we can ever use\n+            Some(initialized_cap) => {\n+                if desired_cap > initialized_cap {\n+                    self.storage.reserve(blocks_for_bits(desired_cap - initialized_cap));\n+                }\n             }\n         }\n     }\n \n-    /// Grows the vector to be able to store `size` bits without resizing.\n+    /// Reserves the minimum capacity for exactly `additional` more bits to be inserted in the\n+    /// given `Bitv`. Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it requests. Therefore\n+    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n+    /// insertions are expected.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = Bitv::with_capacity(3, false);\n+    /// let mut bv = Bitv::from_elem(3, false);\n     /// bv.reserve(10);\n     /// assert_eq!(bv.len(), 3);\n-    /// assert!(bv.capacity() >= 10);\n+    /// assert!(bv.capacity() >= 13);\n     /// ```\n-    pub fn reserve(&mut self, size: uint) {\n-        let old_size = self.storage.len();\n-        let new_size = (size + u32::BITS - 1) / u32::BITS;\n-        if old_size < new_size {\n-            self.storage.grow(new_size - old_size, 0);\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve_exact(&mut self, additional: uint) {\n+        let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n+        match self.storage.len().checked_mul(u32::BITS) {\n+            None => {} // Vec has more initialized capacity than we can ever use\n+            Some(initialized_cap) => {\n+                if desired_cap > initialized_cap {\n+                    self.storage.reserve_exact(blocks_for_bits(desired_cap - initialized_cap));\n+                }\n+            }\n         }\n     }\n \n@@ -664,83 +758,89 @@ impl Bitv {\n     /// assert!(bv.capacity() >= 10);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn capacity(&self) -> uint {\n-        self.storage.len() * u32::BITS\n+        self.storage.capacity().checked_mul(u32::BITS).unwrap_or(uint::MAX)\n     }\n \n     /// Grows the `Bitv` in-place, adding `n` copies of `value` to the `Bitv`.\n     ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new len overflows a `uint`.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = bitv::from_bytes(&[0b01001011]);\n+    /// let mut bv = Bitv::from_bytes(&[0b01001011]);\n     /// bv.grow(2, true);\n     /// assert_eq!(bv.len(), 10);\n     /// assert_eq!(bv.to_bytes(), vec!(0b01001011, 0b11000000));\n     /// ```\n     pub fn grow(&mut self, n: uint, value: bool) {\n-        let new_nbits = self.nbits + n;\n-        let new_nwords = (new_nbits + u32::BITS - 1) / u32::BITS;\n+        // Note: we just bulk set all the bits in the last word in this fn in multiple places\n+        // which is technically wrong if not all of these bits are to be used. However, at the end\n+        // of this fn we call `fix_last_block` at the end of this fn, which should fix this.\n+\n+        let new_nbits = self.nbits.checked_add(n).expect(\"capacity overflow\");\n+        let new_nblocks = blocks_for_bits(new_nbits);\n         let full_value = if value { !0 } else { 0 };\n+\n         // Correct the old tail word\n-        let old_last_word = (self.nbits + u32::BITS - 1) / u32::BITS - 1;\n+        let old_last_word = blocks_for_bits(self.nbits) - 1;\n         if self.nbits % u32::BITS > 0 {\n             let overhang = self.nbits % u32::BITS; // # of already-used bits\n-            let mask = !((1 << overhang) - 1);  // e.g. 5 unused bits => 111110....0\n+            let mask = !((1 << overhang) - 1);  // e.g. 5 unused bits => 111110..0\n             if value {\n                 self.storage[old_last_word] |= mask;\n             } else {\n                 self.storage[old_last_word] &= !mask;\n             }\n         }\n+\n         // Fill in words after the old tail word\n-        let stop_idx = cmp::min(self.storage.len(), new_nwords);\n+        let stop_idx = cmp::min(self.storage.len(), new_nblocks);\n         for idx in range(old_last_word + 1, stop_idx) {\n             self.storage[idx] = full_value;\n         }\n+\n         // Allocate new words, if needed\n-        if new_nwords > self.storage.len() {\n-            let to_add = new_nwords - self.storage.len();\n+        if new_nblocks > self.storage.len() {\n+            let to_add = new_nblocks - self.storage.len();\n             self.storage.grow(to_add, full_value);\n-\n-            // Zero out and unused bits in the new tail word\n-            if value {\n-                let tail_word = new_nwords - 1;\n-                let used_bits = new_nbits % u32::BITS;\n-                self.storage[tail_word] &= (1 << used_bits) - 1;\n-            }\n         }\n+\n         // Adjust internal bit count\n         self.nbits = new_nbits;\n+\n+        self.fix_last_block();\n     }\n \n-    /// Shortens by one element and returns the removed element.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Assert if empty.\n+    /// Removes the last bit from the Bitv, and returns it. Returns None if the Bitv is empty.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::bitv;\n+    /// use std::collections::Bitv;\n     ///\n-    /// let mut bv = bitv::from_bytes(&[0b01001001]);\n-    /// assert_eq!(bv.pop(), true);\n-    /// assert_eq!(bv.pop(), false);\n+    /// let mut bv = Bitv::from_bytes(&[0b01001001]);\n+    /// assert_eq!(bv.pop(), Some(true));\n+    /// assert_eq!(bv.pop(), Some(false));\n     /// assert_eq!(bv.len(), 6);\n-    /// assert_eq!(bv.to_bytes(), vec!(0b01001000));\n     /// ```\n-    pub fn pop(&mut self) -> bool {\n-        let ret = self.get(self.nbits - 1);\n-        // If we are unusing a whole word, make sure it is zeroed out\n-        if self.nbits % u32::BITS == 1 {\n-            self.storage[self.nbits / u32::BITS] = 0;\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn pop(&mut self) -> Option<bool> {\n+        if self.is_empty() {\n+            None\n+        } else {\n+            let ret = self[self.nbits - 1];\n+            // Second rule of Bitv Club\n+            self.set(self.nbits - 1, false);\n+            self.nbits -= 1;\n+            Some(ret)\n         }\n-        self.nbits -= 1;\n-        ret\n     }\n \n     /// Pushes a `bool` onto the end.\n@@ -755,10 +855,11 @@ impl Bitv {\n     /// bv.push(false);\n     /// assert!(bv.eq_vec(&[true, false]));\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push(&mut self, elem: bool) {\n         let insert_pos = self.nbits;\n-        self.nbits += 1;\n-        if self.storage.len() * u32::BITS < self.nbits {\n+        self.nbits = self.nbits.checked_add(1).expect(\"Capacity overflow\");\n+        if self.storage.len().checked_mul(u32::BITS).unwrap_or(uint::MAX) < self.nbits {\n             self.storage.push(0);\n         }\n         self.set(insert_pos, elem);\n@@ -782,46 +883,16 @@ impl Bitv {\n     }\n }\n \n-/// Transforms a byte-vector into a `Bitv`. Each byte becomes eight bits,\n-/// with the most significant bits of each byte coming first. Each\n-/// bit becomes `true` if equal to 1 or `false` if equal to 0.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::collections::bitv;\n-///\n-/// let bv = bitv::from_bytes(&[0b10100000, 0b00010010]);\n-/// assert!(bv.eq_vec(&[true, false, true, false,\n-///                     false, false, false, false,\n-///                     false, false, false, true,\n-///                     false, false, true, false]));\n-/// ```\n+/// Deprecated: Now a static method on Bitv.\n+#[deprecated = \"Now a static method on Bitv\"]\n pub fn from_bytes(bytes: &[u8]) -> Bitv {\n-    from_fn(bytes.len() * 8, |i| {\n-        let b = bytes[i / 8] as u32;\n-        let offset = i % 8;\n-        b >> (7 - offset) & 1 == 1\n-    })\n+    Bitv::from_bytes(bytes)\n }\n \n-/// Creates a `Bitv` of the specified length where the value at each\n-/// index is `f(index)`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::collections::bitv::from_fn;\n-///\n-/// let bv = from_fn(5, |i| { i % 2 == 0 });\n-/// assert!(bv.eq_vec(&[true, false, true, false, true]));\n-/// ```\n+/// Deprecated: Now a static method on Bitv.\n+#[deprecated = \"Now a static method on Bitv\"]\n pub fn from_fn<F>(len: uint, mut f: F) -> Bitv where F: FnMut(uint) -> bool {\n-    let mut bitv = Bitv::with_capacity(len, false);\n-    for i in range(0u, len) {\n-        bitv.set(i, f(i));\n-    }\n-    bitv\n+    Bitv::from_fn(len, f)\n }\n \n #[stable]\n@@ -843,8 +914,7 @@ impl Extend<bool> for Bitv {\n     #[inline]\n     fn extend<I: Iterator<bool>>(&mut self, mut iterator: I) {\n         let (min, _) = iterator.size_hint();\n-        let nbits = self.nbits;\n-        self.reserve(nbits + min);\n+        self.reserve(min);\n         for element in iterator {\n             self.push(element)\n         }\n@@ -890,7 +960,7 @@ impl fmt::Show for Bitv {\n impl<S: hash::Writer> hash::Hash<S> for Bitv {\n     fn hash(&self, state: &mut S) {\n         self.nbits.hash(state);\n-        for (_, elem) in self.mask_words(0) {\n+        for elem in self.blocks() {\n             elem.hash(state);\n         }\n     }\n@@ -902,7 +972,7 @@ impl cmp::PartialEq for Bitv {\n         if self.nbits != other.nbits {\n             return false;\n         }\n-        self.mask_words(0).zip(other.mask_words(0)).all(|((_, w1), (_, w2))| w1 == w2)\n+        self.blocks().zip(other.blocks()).all(|(w1, w2)| w1 == w2)\n     }\n }\n \n@@ -921,7 +991,7 @@ impl<'a> Iterator<bool> for Bits<'a> {\n         if self.next_idx != self.end_idx {\n             let idx = self.next_idx;\n             self.next_idx += 1;\n-            Some(self.bitv.get(idx))\n+            Some(self.bitv[idx])\n         } else {\n             None\n         }\n@@ -938,7 +1008,7 @@ impl<'a> DoubleEndedIterator<bool> for Bits<'a> {\n     fn next_back(&mut self) -> Option<bool> {\n         if self.next_idx != self.end_idx {\n             self.end_idx -= 1;\n-            Some(self.bitv.get(self.end_idx))\n+            Some(self.bitv[self.end_idx])\n         } else {\n             None\n         }\n@@ -958,7 +1028,7 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n         if index >= self.indexable() {\n             None\n         } else {\n-            Some(self.bitv.get(index))\n+            Some(self.bitv[index])\n         }\n     }\n }\n@@ -974,7 +1044,6 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n ///\n /// ```\n /// use std::collections::{BitvSet, Bitv};\n-/// use std::collections::bitv;\n ///\n /// // It's a regular set\n /// let mut s = BitvSet::new();\n@@ -989,7 +1058,7 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n /// }\n ///\n /// // Can initialize from a `Bitv`\n-/// let other = BitvSet::from_bitv(bitv::from_bytes(&[0b11010000]));\n+/// let other = BitvSet::from_bitv(Bitv::from_bytes(&[0b11010000]));\n ///\n /// s.union_with(&other);\n ///\n@@ -1000,10 +1069,12 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n ///\n /// // Can convert back to a `Bitv`\n /// let bv: Bitv = s.into_bitv();\n-/// assert!(bv.get(3));\n+/// assert!(bv[3]);\n /// ```\n #[deriving(Clone)]\n-pub struct BitvSet(Bitv);\n+pub struct BitvSet {\n+    bitv: Bitv,\n+}\n \n impl Default for BitvSet {\n     #[inline]\n@@ -1021,8 +1092,7 @@ impl FromIterator<bool> for BitvSet {\n impl Extend<bool> for BitvSet {\n     #[inline]\n     fn extend<I: Iterator<bool>>(&mut self, iterator: I) {\n-        let &BitvSet(ref mut self_bitv) = self;\n-        self_bitv.extend(iterator);\n+        self.bitv.extend(iterator);\n     }\n }\n \n@@ -1053,45 +1123,47 @@ impl cmp::PartialEq for BitvSet {\n impl cmp::Eq for BitvSet {}\n \n impl BitvSet {\n-    /// Creates a new bit vector set with initially no contents.\n+    /// Creates a new empty `BitvSet`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BitvSet;\n+    ///\n     /// let mut s = BitvSet::new();\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> BitvSet {\n-        BitvSet(Bitv::new())\n+        BitvSet { bitv: Bitv::new() }\n     }\n \n-    /// Creates a new bit vector set with initially no contents, able to\n+    /// Creates a new `BitvSet` with initially no contents, able to\n     /// hold `nbits` elements without resizing.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BitvSet;\n+    ///\n     /// let mut s = BitvSet::with_capacity(100);\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(nbits: uint) -> BitvSet {\n-        let bitv = Bitv::with_capacity(nbits, false);\n+        let bitv = Bitv::from_elem(nbits, false);\n         BitvSet::from_bitv(bitv)\n     }\n \n-    /// Creates a new bit vector set from the given bit vector.\n+    /// Creates a new `BitvSet` from the given bit vector.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{bitv, BitvSet};\n+    /// use std::collections::{Bitv, BitvSet};\n     ///\n-    /// let bv = bitv::from_bytes(&[0b01100000]);\n+    /// let bv = Bitv::from_bytes(&[0b01100000]);\n     /// let s = BitvSet::from_bitv(bv);\n     ///\n     /// // Print 1, 2 in arbitrary order\n@@ -1100,10 +1172,8 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n-    pub fn from_bitv(mut bitv: Bitv) -> BitvSet {\n-        // Mark every bit as valid\n-        bitv.nbits = bitv.capacity();\n-        BitvSet(bitv)\n+    pub fn from_bitv(bitv: Bitv) -> BitvSet {\n+        BitvSet { bitv: bitv }\n     }\n \n     /// Returns the capacity in bits for this bit vector. Inserting any\n@@ -1120,29 +1190,62 @@ impl BitvSet {\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn capacity(&self) -> uint {\n-        let &BitvSet(ref bitv) = self;\n-        bitv.capacity()\n+        self.bitv.capacity()\n+    }\n+\n+    /// Reserves capacity for an element to be inserted at `index` in the given\n+    /// `Bitv`. The collection may reserve more space to avoid frequent reallocations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    ///\n+    /// let mut s = BitvSet::new();\n+    /// s.reserve_index(10);\n+    /// assert!(s.capacity() >= 11);\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve_index(&mut self, index: uint) {\n+        let len = self.bitv.len();\n+        if index >= len {\n+            self.bitv.reserve(index - len + 1);\n+        }\n     }\n \n-    /// Grows the underlying vector to be able to store `size` bits.\n+    /// Reserves the minimum capacity for an element to be inserted at `index`\n+    /// in the given `BitvSet`. Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it requests. Therefore\n+    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve_index` if future\n+    /// insertions are expected.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::BitvSet;\n     ///\n     /// let mut s = BitvSet::new();\n-    /// s.reserve(10);\n-    /// assert!(s.capacity() >= 10);\n-    /// ```\n-    pub fn reserve(&mut self, size: uint) {\n-        let &BitvSet(ref mut bitv) = self;\n-        bitv.reserve(size);\n-        if bitv.nbits < size {\n-            bitv.nbits = bitv.capacity();\n+    /// s.reserve_index_exact(10);\n+    /// assert!(s.capacity() >= 11);\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve_index_exact(&mut self, index: uint) {\n+        let len = self.bitv.len();\n+        if index >= len {\n+            self.bitv.reserve_exact(index - len + 1);\n         }\n     }\n \n+\n     /// Consumes this set to return the underlying bit vector.\n     ///\n     /// # Examples\n@@ -1155,13 +1258,12 @@ impl BitvSet {\n     /// s.insert(3);\n     ///\n     /// let bv = s.into_bitv();\n-    /// assert!(bv.get(0));\n-    /// assert!(bv.get(3));\n+    /// assert!(bv[0]);\n+    /// assert!(bv[3]);\n     /// ```\n     #[inline]\n     pub fn into_bitv(self) -> Bitv {\n-        let BitvSet(bitv) = self;\n-        bitv\n+        self.bitv\n     }\n \n     /// Returns a reference to the underlying bit vector.\n@@ -1179,18 +1281,22 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     pub fn get_ref<'a>(&'a self) -> &'a Bitv {\n-        let &BitvSet(ref bitv) = self;\n-        bitv\n+        &self.bitv\n     }\n \n     #[inline]\n     fn other_op<F>(&mut self, other: &BitvSet, mut f: F) where F: FnMut(u32, u32) -> u32 {\n-        // Expand the vector if necessary\n-        self.reserve(other.capacity());\n-\n         // Unwrap Bitvs\n-        let &BitvSet(ref mut self_bitv) = self;\n-        let &BitvSet(ref other_bitv) = other;\n+        let self_bitv = &mut self.bitv;\n+        let other_bitv = &other.bitv;\n+\n+        let self_len = self_bitv.len();\n+        let other_len = other_bitv.len();\n+\n+        // Expand the vector if necessary\n+        if self_len < other_len {\n+            self_bitv.grow(other_len - self_len, false);\n+        }\n \n         // virtually pad other with 0's for equal lengths\n         let mut other_words = {\n@@ -1227,7 +1333,7 @@ impl BitvSet {\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn shrink_to_fit(&mut self) {\n-        let &BitvSet(ref mut bitv) = self;\n+        let bitv = &mut self.bitv;\n         // Obtain original length\n         let old_len = bitv.storage.len();\n         // Obtain coarse trailing zero length\n@@ -1243,10 +1349,9 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n-    /// use std::collections::bitv;\n+    /// use std::collections::{Bitv, BitvSet};\n     ///\n-    /// let s = BitvSet::from_bitv(bitv::from_bytes(&[0b01001010]));\n+    /// let s = BitvSet::from_bitv(Bitv::from_bytes(&[0b01001010]));\n     ///\n     /// // Print 1, 4, 6 in arbitrary order\n     /// for x in s.iter() {\n@@ -1265,11 +1370,10 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n-    /// use std::collections::bitv;\n+    /// use std::collections::{Bitv, BitvSet};\n     ///\n-    /// let a = BitvSet::from_bitv(bitv::from_bytes(&[0b01101000]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[0b10100000]));\n+    /// let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101000]));\n+    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 0, 1, 2, 4 in arbitrary order\n     /// for x in a.union(&b) {\n@@ -1296,11 +1400,10 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n-    /// use std::collections::bitv;\n+    /// use std::collections::{Bitv, BitvSet};\n     ///\n-    /// let a = BitvSet::from_bitv(bitv::from_bytes(&[0b01101000]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[0b10100000]));\n+    /// let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101000]));\n+    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 2\n     /// for x in a.intersection(&b) {\n@@ -1311,8 +1414,7 @@ impl BitvSet {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Take<TwoBitPositions<'a>> {\n         fn bitand(w1: u32, w2: u32) -> u32 { w1 & w2 }\n-\n-        let min = cmp::min(self.capacity(), other.capacity());\n+        let min = cmp::min(self.bitv.len(), other.bitv.len());\n         TwoBitPositions {\n             set: self,\n             other: other,\n@@ -1328,11 +1430,10 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n-    /// use std::collections::bitv;\n+    /// use std::collections::{BitvSet, Bitv};\n     ///\n-    /// let a = BitvSet::from_bitv(bitv::from_bytes(&[0b01101000]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[0b10100000]));\n+    /// let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101000]));\n+    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 1, 4 in arbitrary order\n     /// for x in a.difference(&b) {\n@@ -1367,11 +1468,10 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n-    /// use std::collections::bitv;\n+    /// use std::collections::{BitvSet, Bitv};\n     ///\n-    /// let a = BitvSet::from_bitv(bitv::from_bytes(&[0b01101000]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[0b10100000]));\n+    /// let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101000]));\n+    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 0, 1, 4 in arbitrary order\n     /// for x in a.symmetric_difference(&b) {\n@@ -1397,16 +1497,15 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n-    /// use std::collections::bitv;\n+    /// use std::collections::{BitvSet, Bitv};\n     ///\n     /// let a   = 0b01101000;\n     /// let b   = 0b10100000;\n     /// let res = 0b11101000;\n     ///\n-    /// let mut a = BitvSet::from_bitv(bitv::from_bytes(&[a]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[b]));\n-    /// let res = BitvSet::from_bitv(bitv::from_bytes(&[res]));\n+    /// let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n+    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n+    /// let res = BitvSet::from_bitv(Bitv::from_bytes(&[res]));\n     ///\n     /// a.union_with(&b);\n     /// assert_eq!(a, res);\n@@ -1421,16 +1520,15 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n-    /// use std::collections::bitv;\n+    /// use std::collections::{BitvSet, Bitv};\n     ///\n     /// let a   = 0b01101000;\n     /// let b   = 0b10100000;\n     /// let res = 0b00100000;\n     ///\n-    /// let mut a = BitvSet::from_bitv(bitv::from_bytes(&[a]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[b]));\n-    /// let res = BitvSet::from_bitv(bitv::from_bytes(&[res]));\n+    /// let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n+    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n+    /// let res = BitvSet::from_bitv(Bitv::from_bytes(&[res]));\n     ///\n     /// a.intersect_with(&b);\n     /// assert_eq!(a, res);\n@@ -1446,24 +1544,23 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n-    /// use std::collections::bitv;\n+    /// use std::collections::{BitvSet, Bitv};\n     ///\n     /// let a   = 0b01101000;\n     /// let b   = 0b10100000;\n     /// let a_b = 0b01001000; // a - b\n     /// let b_a = 0b10000000; // b - a\n     ///\n-    /// let mut bva = BitvSet::from_bitv(bitv::from_bytes(&[a]));\n-    /// let bvb = BitvSet::from_bitv(bitv::from_bytes(&[b]));\n-    /// let bva_b = BitvSet::from_bitv(bitv::from_bytes(&[a_b]));\n-    /// let bvb_a = BitvSet::from_bitv(bitv::from_bytes(&[b_a]));\n+    /// let mut bva = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n+    /// let bvb = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n+    /// let bva_b = BitvSet::from_bitv(Bitv::from_bytes(&[a_b]));\n+    /// let bvb_a = BitvSet::from_bitv(Bitv::from_bytes(&[b_a]));\n     ///\n     /// bva.difference_with(&bvb);\n     /// assert_eq!(bva, bva_b);\n     ///\n-    /// let bva = BitvSet::from_bitv(bitv::from_bytes(&[a]));\n-    /// let mut bvb = BitvSet::from_bitv(bitv::from_bytes(&[b]));\n+    /// let bva = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n+    /// let mut bvb = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n     ///\n     /// bvb.difference_with(&bva);\n     /// assert_eq!(bvb, bvb_a);\n@@ -1479,16 +1576,15 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n-    /// use std::collections::bitv;\n+    /// use std::collections::{BitvSet, Bitv};\n     ///\n     /// let a   = 0b01101000;\n     /// let b   = 0b10100000;\n     /// let res = 0b11001000;\n     ///\n-    /// let mut a = BitvSet::from_bitv(bitv::from_bytes(&[a]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[b]));\n-    /// let res = BitvSet::from_bitv(bitv::from_bytes(&[res]));\n+    /// let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n+    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n+    /// let res = BitvSet::from_bitv(Bitv::from_bytes(&[res]));\n     ///\n     /// a.symmetric_difference_with(&b);\n     /// assert_eq!(a, res);\n@@ -1502,32 +1598,29 @@ impl BitvSet {\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint  {\n-        let &BitvSet(ref bitv) = self;\n-        bitv.storage.iter().fold(0, |acc, &n| acc + n.count_ones())\n+        self.bitv.blocks().fold(0, |acc, n| acc + n.count_ones())\n     }\n \n     /// Returns whether there are no bits set in this set\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool {\n-        let &BitvSet(ref bitv) = self;\n-        bitv.storage.iter().all(|&n| n == 0)\n+        self.bitv.none()\n     }\n \n     /// Clears all bits in this set\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n-        let &BitvSet(ref mut bitv) = self;\n-        bitv.clear();\n+        self.bitv.clear();\n     }\n \n     /// Returns `true` if this set contains the specified integer.\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains(&self, value: &uint) -> bool {\n-        let &BitvSet(ref bitv) = self;\n-        *value < bitv.nbits && bitv.get(*value)\n+        let bitv = &self.bitv;\n+        *value < bitv.nbits && bitv[*value]\n     }\n \n     /// Returns `true` if the set has no elements in common with `other`.\n@@ -1542,14 +1635,14 @@ impl BitvSet {\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_subset(&self, other: &BitvSet) -> bool {\n-        let &BitvSet(ref self_bitv) = self;\n-        let &BitvSet(ref other_bitv) = other;\n+        let self_bitv = &self.bitv;\n+        let other_bitv = &other.bitv;\n+        let other_blocks = blocks_for_bits(other_bitv.len());\n \n         // Check that `self` intersect `other` is self\n-        self_bitv.mask_words(0).zip(other_bitv.mask_words(0))\n-                               .all(|((_, w1), (_, w2))| w1 & w2 == w1) &&\n-        // Check that `self` setminus `other` is empty\n-        self_bitv.mask_words(other_bitv.storage.len()).all(|(_, w)| w == 0)\n+        self_bitv.blocks().zip(other_bitv.blocks()).all(|(w1, w2)| w1 & w2 == w1) &&\n+        // Make sure if `self` has any more blocks than `other`, they're all 0\n+        self_bitv.blocks().skip(other_blocks).all(|w| w == 0)\n     }\n \n     /// Returns `true` if the set is a superset of another.\n@@ -1568,13 +1661,12 @@ impl BitvSet {\n         }\n \n         // Ensure we have enough space to hold the new element\n-        if value >= self.capacity() {\n-            let new_cap = cmp::max(value + 1, self.capacity() * 2);\n-            self.reserve(new_cap);\n+        let len = self.bitv.len();\n+        if value >= len {\n+            self.bitv.grow(value - len + 1, false)\n         }\n \n-        let &BitvSet(ref mut bitv) = self;\n-        bitv.set(value, true);\n+        self.bitv.set(value, true);\n         return true;\n     }\n \n@@ -1585,8 +1677,9 @@ impl BitvSet {\n         if !self.contains(value) {\n             return false;\n         }\n-        let &BitvSet(ref mut bitv) = self;\n-        bitv.set(*value, false);\n+\n+        self.bitv.set(*value, false);\n+\n         return true;\n     }\n }\n@@ -1631,7 +1724,7 @@ pub struct TwoBitPositions<'a> {\n \n impl<'a> Iterator<uint> for BitPositions<'a> {\n     fn next(&mut self) -> Option<uint> {\n-        while self.next_idx < self.set.capacity() {\n+        while self.next_idx < self.set.bitv.len() {\n             let idx = self.next_idx;\n             self.next_idx += 1;\n \n@@ -1645,18 +1738,18 @@ impl<'a> Iterator<uint> for BitPositions<'a> {\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        (0, Some(self.set.capacity() - self.next_idx))\n+        (0, Some(self.set.bitv.len() - self.next_idx))\n     }\n }\n \n impl<'a> Iterator<uint> for TwoBitPositions<'a> {\n     fn next(&mut self) -> Option<uint> {\n-        while self.next_idx < self.set.capacity() ||\n-              self.next_idx < self.other.capacity() {\n+        while self.next_idx < self.set.bitv.len() ||\n+              self.next_idx < self.other.bitv.len() {\n             let bit_idx = self.next_idx % u32::BITS;\n             if bit_idx == 0 {\n-                let &BitvSet(ref s_bitv) = self.set;\n-                let &BitvSet(ref o_bitv) = self.other;\n+                let s_bitv = &self.set.bitv;\n+                let o_bitv = &self.other.bitv;\n                 // Merging the two words is a bit of an awkward dance since\n                 // one Bitv might be longer than the other\n                 let word_idx = self.next_idx / u32::BITS;\n@@ -1679,11 +1772,15 @@ impl<'a> Iterator<uint> for TwoBitPositions<'a> {\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        let cap = cmp::max(self.set.capacity(), self.other.capacity());\n+        let cap = cmp::max(self.set.bitv.len(), self.other.bitv.len());\n         (0, Some(cap - self.next_idx))\n     }\n }\n \n+\n+\n+\n+\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n@@ -1696,14 +1793,12 @@ mod tests {\n     use super::{Bitv, BitvSet, from_fn, from_bytes};\n     use bitv;\n \n-    static BENCH_BITS : uint = 1 << 14;\n-\n     #[test]\n     fn test_to_str() {\n         let zerolen = Bitv::new();\n         assert_eq!(zerolen.to_string(), \"\");\n \n-        let eightbits = Bitv::with_capacity(8u, false);\n+        let eightbits = Bitv::from_elem(8u, false);\n         assert_eq!(eightbits.to_string(), \"00000000\")\n     }\n \n@@ -1716,15 +1811,15 @@ mod tests {\n \n     #[test]\n     fn test_1_element() {\n-        let mut act = Bitv::with_capacity(1u, false);\n+        let mut act = Bitv::from_elem(1u, false);\n         assert!(act.eq_vec(&[false]));\n-        act = Bitv::with_capacity(1u, true);\n+        act = Bitv::from_elem(1u, true);\n         assert!(act.eq_vec(&[true]));\n     }\n \n     #[test]\n     fn test_2_elements() {\n-        let mut b = bitv::Bitv::with_capacity(2, false);\n+        let mut b = Bitv::from_elem(2, false);\n         b.set(0, true);\n         b.set(1, false);\n         assert_eq!(b.to_string(), \"10\");\n@@ -1735,16 +1830,16 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::with_capacity(10u, false);\n+        act = Bitv::from_elem(10u, false);\n         assert!((act.eq_vec(\n                     &[false, false, false, false, false, false, false, false, false, false])));\n         // all 1\n \n-        act = Bitv::with_capacity(10u, true);\n+        act = Bitv::from_elem(10u, true);\n         assert!((act.eq_vec(&[true, true, true, true, true, true, true, true, true, true])));\n         // mixed\n \n-        act = Bitv::with_capacity(10u, false);\n+        act = Bitv::from_elem(10u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -1753,7 +1848,7 @@ mod tests {\n         assert!((act.eq_vec(&[true, true, true, true, true, false, false, false, false, false])));\n         // mixed\n \n-        act = Bitv::with_capacity(10u, false);\n+        act = Bitv::from_elem(10u, false);\n         act.set(5u, true);\n         act.set(6u, true);\n         act.set(7u, true);\n@@ -1762,7 +1857,7 @@ mod tests {\n         assert!((act.eq_vec(&[false, false, false, false, false, true, true, true, true, true])));\n         // mixed\n \n-        act = Bitv::with_capacity(10u, false);\n+        act = Bitv::from_elem(10u, false);\n         act.set(0u, true);\n         act.set(3u, true);\n         act.set(6u, true);\n@@ -1775,21 +1870,21 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::with_capacity(31u, false);\n+        act = Bitv::from_elem(31u, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false]));\n         // all 1\n \n-        act = Bitv::with_capacity(31u, true);\n+        act = Bitv::from_elem(31u, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true]));\n         // mixed\n \n-        act = Bitv::with_capacity(31u, false);\n+        act = Bitv::from_elem(31u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -1804,7 +1899,7 @@ mod tests {\n                   false, false, false, false, false, false, false]));\n         // mixed\n \n-        act = Bitv::with_capacity(31u, false);\n+        act = Bitv::from_elem(31u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -1819,7 +1914,7 @@ mod tests {\n                   false, false, false, false, false, false, false]));\n         // mixed\n \n-        act = Bitv::with_capacity(31u, false);\n+        act = Bitv::from_elem(31u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -1833,7 +1928,7 @@ mod tests {\n                   false, false, true, true, true, true, true, true, true]));\n         // mixed\n \n-        act = Bitv::with_capacity(31u, false);\n+        act = Bitv::from_elem(31u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n@@ -1848,21 +1943,21 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::with_capacity(32u, false);\n+        act = Bitv::from_elem(32u, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false]));\n         // all 1\n \n-        act = Bitv::with_capacity(32u, true);\n+        act = Bitv::from_elem(32u, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true]));\n         // mixed\n \n-        act = Bitv::with_capacity(32u, false);\n+        act = Bitv::from_elem(32u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -1877,7 +1972,7 @@ mod tests {\n                   false, false, false, false, false, false, false, false]));\n         // mixed\n \n-        act = Bitv::with_capacity(32u, false);\n+        act = Bitv::from_elem(32u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -1892,7 +1987,7 @@ mod tests {\n                   false, false, false, false, false, false, false, false]));\n         // mixed\n \n-        act = Bitv::with_capacity(32u, false);\n+        act = Bitv::from_elem(32u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -1907,7 +2002,7 @@ mod tests {\n                   false, false, true, true, true, true, true, true, true, true]));\n         // mixed\n \n-        act = Bitv::with_capacity(32u, false);\n+        act = Bitv::from_elem(32u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n@@ -1923,21 +2018,21 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::with_capacity(33u, false);\n+        act = Bitv::from_elem(33u, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false]));\n         // all 1\n \n-        act = Bitv::with_capacity(33u, true);\n+        act = Bitv::from_elem(33u, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true]));\n         // mixed\n \n-        act = Bitv::with_capacity(33u, false);\n+        act = Bitv::from_elem(33u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -1952,7 +2047,7 @@ mod tests {\n                   false, false, false, false, false, false, false, false, false]));\n         // mixed\n \n-        act = Bitv::with_capacity(33u, false);\n+        act = Bitv::from_elem(33u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -1967,7 +2062,7 @@ mod tests {\n                   false, false, false, false, false, false, false, false, false]));\n         // mixed\n \n-        act = Bitv::with_capacity(33u, false);\n+        act = Bitv::from_elem(33u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -1982,7 +2077,7 @@ mod tests {\n                   false, false, true, true, true, true, true, true, true, true, false]));\n         // mixed\n \n-        act = Bitv::with_capacity(33u, false);\n+        act = Bitv::from_elem(33u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n@@ -1996,37 +2091,37 @@ mod tests {\n \n     #[test]\n     fn test_equal_differing_sizes() {\n-        let v0 = Bitv::with_capacity(10u, false);\n-        let v1 = Bitv::with_capacity(11u, false);\n+        let v0 = Bitv::from_elem(10u, false);\n+        let v1 = Bitv::from_elem(11u, false);\n         assert!(v0 != v1);\n     }\n \n     #[test]\n     fn test_equal_greatly_differing_sizes() {\n-        let v0 = Bitv::with_capacity(10u, false);\n-        let v1 = Bitv::with_capacity(110u, false);\n+        let v0 = Bitv::from_elem(10u, false);\n+        let v1 = Bitv::from_elem(110u, false);\n         assert!(v0 != v1);\n     }\n \n     #[test]\n     fn test_equal_sneaky_small() {\n-        let mut a = bitv::Bitv::with_capacity(1, false);\n+        let mut a = Bitv::from_elem(1, false);\n         a.set(0, true);\n \n-        let mut b = bitv::Bitv::with_capacity(1, true);\n+        let mut b = Bitv::from_elem(1, true);\n         b.set(0, true);\n \n         assert_eq!(a, b);\n     }\n \n     #[test]\n     fn test_equal_sneaky_big() {\n-        let mut a = bitv::Bitv::with_capacity(100, false);\n+        let mut a = Bitv::from_elem(100, false);\n         for i in range(0u, 100) {\n             a.set(i, true);\n         }\n \n-        let mut b = bitv::Bitv::with_capacity(100, true);\n+        let mut b = Bitv::from_elem(100, true);\n         for i in range(0u, 100) {\n             b.set(i, true);\n         }\n@@ -2036,18 +2131,18 @@ mod tests {\n \n     #[test]\n     fn test_from_bytes() {\n-        let bitv = from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n+        let bitv = Bitv::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n         let str = concat!(\"10110110\", \"00000000\", \"11111111\");\n         assert_eq!(bitv.to_string(), str);\n     }\n \n     #[test]\n     fn test_to_bytes() {\n-        let mut bv = Bitv::with_capacity(3, true);\n+        let mut bv = Bitv::from_elem(3, true);\n         bv.set(1, false);\n         assert_eq!(bv.to_bytes(), vec!(0b10100000));\n \n-        let mut bv = Bitv::with_capacity(9, false);\n+        let mut bv = Bitv::from_elem(9, false);\n         bv.set(2, true);\n         bv.set(8, true);\n         assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n@@ -2060,21 +2155,10 @@ mod tests {\n         assert_eq!(bitv.to_string(), \"1011\");\n     }\n \n-    #[test]\n-    fn test_bitv_set_from_bools() {\n-        let bools = vec![true, false, true, true];\n-        let a: BitvSet = bools.iter().map(|n| *n).collect();\n-        let mut b = BitvSet::new();\n-        b.insert(0);\n-        b.insert(2);\n-        b.insert(3);\n-        assert_eq!(a, b);\n-    }\n-\n     #[test]\n     fn test_to_bools() {\n         let bools = vec!(false, false, true, false, false, true, true, false);\n-        assert_eq!(from_bytes(&[0b00100110]).iter().collect::<Vec<bool>>(), bools);\n+        assert_eq!(Bitv::from_bytes(&[0b00100110]).iter().collect::<Vec<bool>>(), bools);\n     }\n \n     #[test]\n@@ -2120,107 +2204,436 @@ mod tests {\n \n     #[test]\n     fn test_small_difference() {\n-        let mut b1 = Bitv::with_capacity(3, false);\n-        let mut b2 = Bitv::with_capacity(3, false);\n+        let mut b1 = Bitv::from_elem(3, false);\n+        let mut b2 = Bitv::from_elem(3, false);\n         b1.set(0, true);\n         b1.set(1, true);\n         b2.set(1, true);\n         b2.set(2, true);\n         assert!(b1.difference(&b2));\n-        assert!(b1.get(0));\n-        assert!(!b1.get(1));\n-        assert!(!b1.get(2));\n+        assert!(b1[0]);\n+        assert!(!b1[1]);\n+        assert!(!b1[2]);\n     }\n \n     #[test]\n     fn test_big_difference() {\n-        let mut b1 = Bitv::with_capacity(100, false);\n-        let mut b2 = Bitv::with_capacity(100, false);\n+        let mut b1 = Bitv::from_elem(100, false);\n+        let mut b2 = Bitv::from_elem(100, false);\n         b1.set(0, true);\n         b1.set(40, true);\n         b2.set(40, true);\n         b2.set(80, true);\n         assert!(b1.difference(&b2));\n-        assert!(b1.get(0));\n-        assert!(!b1.get(40));\n-        assert!(!b1.get(80));\n+        assert!(b1[0]);\n+        assert!(!b1[40]);\n+        assert!(!b1[80]);\n     }\n \n     #[test]\n     fn test_small_clear() {\n-        let mut b = Bitv::with_capacity(14, true);\n+        let mut b = Bitv::from_elem(14, true);\n         b.clear();\n         assert!(b.none());\n     }\n \n     #[test]\n     fn test_big_clear() {\n-        let mut b = Bitv::with_capacity(140, true);\n+        let mut b = Bitv::from_elem(140, true);\n         b.clear();\n         assert!(b.none());\n     }\n \n     #[test]\n-    fn test_bitv_masking() {\n-        let b = Bitv::with_capacity(140, true);\n-        let mut bs = BitvSet::from_bitv(b);\n-        assert!(bs.contains(&139));\n-        assert!(!bs.contains(&140));\n-        assert!(bs.insert(150));\n-        assert!(!bs.contains(&140));\n-        assert!(!bs.contains(&149));\n-        assert!(bs.contains(&150));\n-        assert!(!bs.contains(&151));\n+    fn test_bitv_lt() {\n+        let mut a = Bitv::from_elem(5u, false);\n+        let mut b = Bitv::from_elem(5u, false);\n+\n+        assert!(!(a < b) && !(b < a));\n+        b.set(2, true);\n+        assert!(a < b);\n+        a.set(3, true);\n+        assert!(a < b);\n+        a.set(2, true);\n+        assert!(!(a < b) && b < a);\n+        b.set(0, true);\n+        assert!(a < b);\n     }\n \n     #[test]\n-    fn test_bitv_set_basic() {\n-        // calculate nbits with u32::BITS granularity\n-        fn calc_nbits(bits: uint) -> uint {\n-            u32::BITS * ((bits + u32::BITS - 1) / u32::BITS)\n-        }\n+    fn test_ord() {\n+        let mut a = Bitv::from_elem(5u, false);\n+        let mut b = Bitv::from_elem(5u, false);\n \n-        let mut b = BitvSet::new();\n-        assert_eq!(b.capacity(), calc_nbits(0));\n-        assert!(b.insert(3));\n-        assert_eq!(b.capacity(), calc_nbits(3));\n-        assert!(!b.insert(3));\n-        assert!(b.contains(&3));\n-        assert!(b.insert(4));\n-        assert!(!b.insert(4));\n-        assert!(b.contains(&3));\n-        assert!(b.insert(400));\n-        assert_eq!(b.capacity(), calc_nbits(400));\n-        assert!(!b.insert(400));\n-        assert!(b.contains(&400));\n-        assert_eq!(b.len(), 3);\n+        assert!(a <= b && a >= b);\n+        a.set(1, true);\n+        assert!(a > b && a >= b);\n+        assert!(b < a && b <= a);\n+        b.set(1, true);\n+        b.set(2, true);\n+        assert!(b > a && b >= a);\n+        assert!(a < b && a <= b);\n     }\n \n-    #[test]\n-    fn test_bitv_set_intersection() {\n-        let mut a = BitvSet::new();\n-        let mut b = BitvSet::new();\n \n-        assert!(a.insert(11));\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(77));\n-        assert!(a.insert(103));\n-        assert!(a.insert(5));\n+    #[test]\n+    fn test_small_bitv_tests() {\n+        let v = Bitv::from_bytes(&[0]);\n+        assert!(!v.all());\n+        assert!(!v.any());\n+        assert!(v.none());\n \n-        assert!(b.insert(2));\n-        assert!(b.insert(11));\n-        assert!(b.insert(77));\n-        assert!(b.insert(5));\n-        assert!(b.insert(3));\n+        let v = Bitv::from_bytes(&[0b00010100]);\n+        assert!(!v.all());\n+        assert!(v.any());\n+        assert!(!v.none());\n \n-        let expected = [3, 5, 11, 77];\n-        let actual = a.intersection(&b).collect::<Vec<uint>>();\n-        assert_eq!(actual, expected);\n+        let v = Bitv::from_bytes(&[0xFF]);\n+        assert!(v.all());\n+        assert!(v.any());\n+        assert!(!v.none());\n     }\n \n     #[test]\n-    fn test_bitv_set_difference() {\n+    fn test_big_bitv_tests() {\n+        let v = Bitv::from_bytes(&[ // 88 bits\n+            0, 0, 0, 0,\n+            0, 0, 0, 0,\n+            0, 0, 0]);\n+        assert!(!v.all());\n+        assert!(!v.any());\n+        assert!(v.none());\n+\n+        let v = Bitv::from_bytes(&[ // 88 bits\n+            0, 0, 0b00010100, 0,\n+            0, 0, 0, 0b00110100,\n+            0, 0, 0]);\n+        assert!(!v.all());\n+        assert!(v.any());\n+        assert!(!v.none());\n+\n+        let v = Bitv::from_bytes(&[ // 88 bits\n+            0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF, 0xFF,\n+            0xFF, 0xFF, 0xFF]);\n+        assert!(v.all());\n+        assert!(v.any());\n+        assert!(!v.none());\n+    }\n+\n+    #[test]\n+    fn test_bitv_push_pop() {\n+        let mut s = Bitv::from_elem(5 * u32::BITS - 2, false);\n+        assert_eq!(s.len(), 5 * u32::BITS - 2);\n+        assert_eq!(s[5 * u32::BITS - 3], false);\n+        s.push(true);\n+        s.push(true);\n+        assert_eq!(s[5 * u32::BITS - 2], true);\n+        assert_eq!(s[5 * u32::BITS - 1], true);\n+        // Here the internal vector will need to be extended\n+        s.push(false);\n+        assert_eq!(s[5 * u32::BITS], false);\n+        s.push(false);\n+        assert_eq!(s[5 * u32::BITS + 1], false);\n+        assert_eq!(s.len(), 5 * u32::BITS + 2);\n+        // Pop it all off\n+        assert_eq!(s.pop(), Some(false));\n+        assert_eq!(s.pop(), Some(false));\n+        assert_eq!(s.pop(), Some(true));\n+        assert_eq!(s.pop(), Some(true));\n+        assert_eq!(s.len(), 5 * u32::BITS - 2);\n+    }\n+\n+    #[test]\n+    fn test_bitv_truncate() {\n+        let mut s = Bitv::from_elem(5 * u32::BITS, true);\n+\n+        assert_eq!(s, Bitv::from_elem(5 * u32::BITS, true));\n+        assert_eq!(s.len(), 5 * u32::BITS);\n+        s.truncate(4 * u32::BITS);\n+        assert_eq!(s, Bitv::from_elem(4 * u32::BITS, true));\n+        assert_eq!(s.len(), 4 * u32::BITS);\n+        // Truncating to a size > s.len() should be a noop\n+        s.truncate(5 * u32::BITS);\n+        assert_eq!(s, Bitv::from_elem(4 * u32::BITS, true));\n+        assert_eq!(s.len(), 4 * u32::BITS);\n+        s.truncate(3 * u32::BITS - 10);\n+        assert_eq!(s, Bitv::from_elem(3 * u32::BITS - 10, true));\n+        assert_eq!(s.len(), 3 * u32::BITS - 10);\n+        s.truncate(0);\n+        assert_eq!(s, Bitv::from_elem(0, true));\n+        assert_eq!(s.len(), 0);\n+    }\n+\n+    #[test]\n+    fn test_bitv_reserve() {\n+        let mut s = Bitv::from_elem(5 * u32::BITS, true);\n+        // Check capacity\n+        assert!(s.capacity() >= 5 * u32::BITS);\n+        s.reserve(2 * u32::BITS);\n+        assert!(s.capacity() >= 7 * u32::BITS);\n+        s.reserve(7 * u32::BITS);\n+        assert!(s.capacity() >= 12 * u32::BITS);\n+        s.reserve_exact(7 * u32::BITS);\n+        assert!(s.capacity() >= 12 * u32::BITS);\n+        s.reserve(7 * u32::BITS + 1);\n+        assert!(s.capacity() >= 12 * u32::BITS + 1);\n+        // Check that length hasn't changed\n+        assert_eq!(s.len(), 5 * u32::BITS);\n+        s.push(true);\n+        s.push(false);\n+        s.push(true);\n+        assert_eq!(s[5 * u32::BITS - 1], true);\n+        assert_eq!(s[5 * u32::BITS - 0], true);\n+        assert_eq!(s[5 * u32::BITS + 1], false);\n+        assert_eq!(s[5 * u32::BITS + 2], true);\n+    }\n+\n+    #[test]\n+    fn test_bitv_grow() {\n+        let mut bitv = Bitv::from_bytes(&[0b10110110, 0b00000000, 0b10101010]);\n+        bitv.grow(32, true);\n+        assert_eq!(bitv, Bitv::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n+                                     0xFF, 0xFF, 0xFF, 0xFF]));\n+        bitv.grow(64, false);\n+        assert_eq!(bitv, Bitv::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n+                                     0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0]));\n+        bitv.grow(16, true);\n+        assert_eq!(bitv, Bitv::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n+                                     0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF]));\n+    }\n+\n+    #[test]\n+    fn test_bitv_extend() {\n+        let mut bitv = Bitv::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n+        let ext = Bitv::from_bytes(&[0b01001001, 0b10010010, 0b10111101]);\n+        bitv.extend(ext.iter());\n+        assert_eq!(bitv, Bitv::from_bytes(&[0b10110110, 0b00000000, 0b11111111,\n+                                     0b01001001, 0b10010010, 0b10111101]));\n+    }\n+}\n+\n+\n+\n+\n+#[cfg(test)]\n+mod bitv_bench {\n+    use std::prelude::*;\n+    use std::rand;\n+    use std::rand::Rng;\n+    use std::u32;\n+    use test::{Bencher, black_box};\n+\n+    use super::Bitv;\n+\n+    static BENCH_BITS : uint = 1 << 14;\n+\n+    fn rng() -> rand::IsaacRng {\n+        let seed: &[_] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n+        rand::SeedableRng::from_seed(seed)\n+    }\n+\n+    #[bench]\n+    fn bench_uint_small(b: &mut Bencher) {\n+        let mut r = rng();\n+        let mut bitv = 0 as uint;\n+        b.iter(|| {\n+            for _ in range(0u, 100) {\n+                bitv |= 1 << ((r.next_u32() as uint) % u32::BITS);\n+            }\n+            black_box(&bitv)\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_bitv_set_big_fixed(b: &mut Bencher) {\n+        let mut r = rng();\n+        let mut bitv = Bitv::from_elem(BENCH_BITS, false);\n+        b.iter(|| {\n+            for _ in range(0u, 100) {\n+                bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n+            }\n+            black_box(&bitv)\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_bitv_set_big_variable(b: &mut Bencher) {\n+        let mut r = rng();\n+        let mut bitv = Bitv::from_elem(BENCH_BITS, false);\n+        b.iter(|| {\n+            for _ in range(0u, 100) {\n+                bitv.set((r.next_u32() as uint) % BENCH_BITS, r.gen());\n+            }\n+            black_box(&bitv);\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_bitv_set_small(b: &mut Bencher) {\n+        let mut r = rng();\n+        let mut bitv = Bitv::from_elem(u32::BITS, false);\n+        b.iter(|| {\n+            for _ in range(0u, 100) {\n+                bitv.set((r.next_u32() as uint) % u32::BITS, true);\n+            }\n+            black_box(&bitv);\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_bitv_big_union(b: &mut Bencher) {\n+        let mut b1 = Bitv::from_elem(BENCH_BITS, false);\n+        let b2 = Bitv::from_elem(BENCH_BITS, false);\n+        b.iter(|| {\n+            b1.union(&b2)\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_bitv_small_iter(b: &mut Bencher) {\n+        let bitv = Bitv::from_elem(u32::BITS, false);\n+        b.iter(|| {\n+            let mut sum = 0u;\n+            for _ in range(0u, 10) {\n+                for pres in bitv.iter() {\n+                    sum += pres as uint;\n+                }\n+            }\n+            sum\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_bitv_big_iter(b: &mut Bencher) {\n+        let bitv = Bitv::from_elem(BENCH_BITS, false);\n+        b.iter(|| {\n+            let mut sum = 0u;\n+            for pres in bitv.iter() {\n+                sum += pres as uint;\n+            }\n+            sum\n+        })\n+    }\n+}\n+\n+\n+\n+\n+\n+\n+\n+#[cfg(test)]\n+mod bitv_set_test {\n+    use std::prelude::*;\n+    use std::iter::range_step;\n+\n+    use super::{Bitv, BitvSet};\n+    use vec::Vec;\n+\n+    #[test]\n+    fn test_bitv_set_show() {\n+        let mut s = BitvSet::new();\n+        s.insert(1);\n+        s.insert(10);\n+        s.insert(50);\n+        s.insert(2);\n+        assert_eq!(\"{1, 2, 10, 50}\", s.to_string());\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_from_bools() {\n+        let bools = vec![true, false, true, true];\n+        let a: BitvSet = bools.iter().map(|n| *n).collect();\n+        let mut b = BitvSet::new();\n+        b.insert(0);\n+        b.insert(2);\n+        b.insert(3);\n+        assert_eq!(a, b);\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_iterator() {\n+        let bools = [true, false, true, true];\n+        let bitv: BitvSet = bools.iter().map(|n| *n).collect();\n+\n+        let idxs: Vec<uint> = bitv.iter().collect();\n+        assert_eq!(idxs, vec!(0, 2, 3));\n+\n+        let long: BitvSet = range(0u, 10000).map(|n| n % 2 == 0).collect();\n+        let real = range_step(0, 10000, 2).collect::<Vec<uint>>();\n+\n+        let idxs: Vec<uint> = long.iter().collect();\n+        assert_eq!(idxs, real);\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_frombitv_init() {\n+        let bools = [true, false];\n+        let lengths = [10, 64, 100];\n+        for &b in bools.iter() {\n+            for &l in lengths.iter() {\n+                let bitset = BitvSet::from_bitv(Bitv::from_elem(l, b));\n+                assert_eq!(bitset.contains(&1u), b)\n+                assert_eq!(bitset.contains(&(l-1u)), b)\n+                assert!(!bitset.contains(&l))\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_bitv_masking() {\n+        let b = Bitv::from_elem(140, true);\n+        let mut bs = BitvSet::from_bitv(b);\n+        assert!(bs.contains(&139));\n+        assert!(!bs.contains(&140));\n+        assert!(bs.insert(150));\n+        assert!(!bs.contains(&140));\n+        assert!(!bs.contains(&149));\n+        assert!(bs.contains(&150));\n+        assert!(!bs.contains(&151));\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_basic() {\n+        let mut b = BitvSet::new();\n+        assert!(b.insert(3));\n+        assert!(!b.insert(3));\n+        assert!(b.contains(&3));\n+        assert!(b.insert(4));\n+        assert!(!b.insert(4));\n+        assert!(b.contains(&3));\n+        assert!(b.insert(400));\n+        assert!(!b.insert(400));\n+        assert!(b.contains(&400));\n+        assert_eq!(b.len(), 3);\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_intersection() {\n+        let mut a = BitvSet::new();\n+        let mut b = BitvSet::new();\n+\n+        assert!(a.insert(11));\n+        assert!(a.insert(1));\n+        assert!(a.insert(3));\n+        assert!(a.insert(77));\n+        assert!(a.insert(103));\n+        assert!(a.insert(5));\n+\n+        assert!(b.insert(2));\n+        assert!(b.insert(11));\n+        assert!(b.insert(77));\n+        assert!(b.insert(5));\n+        assert!(b.insert(3));\n+\n+        let expected = [3, 5, 11, 77];\n+        let actual = a.intersection(&b).collect::<Vec<uint>>();\n+        assert_eq!(actual, expected);\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_difference() {\n         let mut a = BitvSet::new();\n         let mut b = BitvSet::new();\n \n@@ -2312,10 +2725,10 @@ mod tests {\n \n     #[test]\n     fn test_bitv_set_is_disjoint() {\n-        let a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n-        let b = BitvSet::from_bitv(from_bytes(&[0b01000000]));\n+        let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n+        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01000000]));\n         let c = BitvSet::new();\n-        let d = BitvSet::from_bitv(from_bytes(&[0b00110000]));\n+        let d = BitvSet::from_bitv(Bitv::from_bytes(&[0b00110000]));\n \n         assert!(!a.is_disjoint(&d));\n         assert!(!d.is_disjoint(&a));\n@@ -2335,13 +2748,13 @@ mod tests {\n         a.insert(0);\n         let mut b = BitvSet::new();\n         b.insert(5);\n-        let expected = BitvSet::from_bitv(from_bytes(&[0b10000100]));\n+        let expected = BitvSet::from_bitv(Bitv::from_bytes(&[0b10000100]));\n         a.union_with(&b);\n         assert_eq!(a, expected);\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::from_bitv(from_bytes(&[0b01100010]));\n+        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n+        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01100010]));\n         let c = a.clone();\n         a.union_with(&b);\n         b.union_with(&c);\n@@ -2352,16 +2765,16 @@ mod tests {\n     #[test]\n     fn test_bitv_set_intersect_with() {\n         // Explicitly 0'ed bits\n-        let mut a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::from_bitv(from_bytes(&[0b00000000]));\n+        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n+        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b00000000]));\n         let c = a.clone();\n         a.intersect_with(&b);\n         b.intersect_with(&c);\n         assert!(a.is_empty());\n         assert!(b.is_empty());\n \n         // Uninitialized bits should behave like 0's\n-        let mut a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n+        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n         let mut b = BitvSet::new();\n         let c = a.clone();\n         a.intersect_with(&b);\n@@ -2370,8 +2783,8 @@ mod tests {\n         assert!(b.is_empty());\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::from_bitv(from_bytes(&[0b01100010]));\n+        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n+        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01100010]));\n         let c = a.clone();\n         a.intersect_with(&b);\n         b.intersect_with(&c);\n@@ -2382,20 +2795,20 @@ mod tests {\n     #[test]\n     fn test_bitv_set_difference_with() {\n         // Explicitly 0'ed bits\n-        let mut a = BitvSet::from_bitv(from_bytes(&[0b00000000]));\n-        let b = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n+        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b00000000]));\n+        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n         a.difference_with(&b);\n         assert!(a.is_empty());\n \n         // Uninitialized bits should behave like 0's\n         let mut a = BitvSet::new();\n-        let b = BitvSet::from_bitv(from_bytes(&[0b11111111]));\n+        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b11111111]));\n         a.difference_with(&b);\n         assert!(a.is_empty());\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::from_bitv(from_bytes(&[0b01100010]));\n+        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n+        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01100010]));\n         let c = a.clone();\n         a.difference_with(&b);\n         b.difference_with(&c);\n@@ -2412,19 +2825,19 @@ mod tests {\n         let mut b = BitvSet::new();\n         b.insert(1);\n         b.insert(5);\n-        let expected = BitvSet::from_bitv(from_bytes(&[0b10000100]));\n+        let expected = BitvSet::from_bitv(Bitv::from_bytes(&[0b10000100]));\n         a.symmetric_difference_with(&b);\n         assert_eq!(a, expected);\n \n-        let mut a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n+        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n         let b = BitvSet::new();\n         let c = a.clone();\n         a.symmetric_difference_with(&b);\n         assert_eq!(a, c);\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(from_bytes(&[0b11100010]));\n-        let mut b = BitvSet::from_bitv(from_bytes(&[0b01101010]));\n+        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b11100010]));\n+        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101010]));\n         let c = a.clone();\n         a.symmetric_difference_with(&b);\n         b.symmetric_difference_with(&c);\n@@ -2434,8 +2847,8 @@ mod tests {\n \n     #[test]\n     fn test_bitv_set_eq() {\n-        let a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n-        let b = BitvSet::from_bitv(from_bytes(&[0b00000000]));\n+        let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n+        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b00000000]));\n         let c = BitvSet::new();\n \n         assert!(a == a);\n@@ -2448,8 +2861,8 @@ mod tests {\n \n     #[test]\n     fn test_bitv_set_cmp() {\n-        let a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n-        let b = BitvSet::from_bitv(from_bytes(&[0b00000000]));\n+        let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n+        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b00000000]));\n         let c = BitvSet::new();\n \n         assert_eq!(a.cmp(&b), Greater);\n@@ -2473,38 +2886,6 @@ mod tests {\n         assert!(a.insert(1000));\n         assert!(a.remove(&1000));\n         a.shrink_to_fit();\n-        assert_eq!(a.capacity(), u32::BITS);\n-    }\n-\n-    #[test]\n-    fn test_bitv_lt() {\n-        let mut a = Bitv::with_capacity(5u, false);\n-        let mut b = Bitv::with_capacity(5u, false);\n-\n-        assert!(!(a < b) && !(b < a));\n-        b.set(2, true);\n-        assert!(a < b);\n-        a.set(3, true);\n-        assert!(a < b);\n-        a.set(2, true);\n-        assert!(!(a < b) && b < a);\n-        b.set(0, true);\n-        assert!(a < b);\n-    }\n-\n-    #[test]\n-    fn test_ord() {\n-        let mut a = Bitv::with_capacity(5u, false);\n-        let mut b = Bitv::with_capacity(5u, false);\n-\n-        assert!(a <= b && a >= b);\n-        a.set(1, true);\n-        assert!(a > b && a >= b);\n-        assert!(b < a && b <= a);\n-        b.set(1, true);\n-        b.set(2, true);\n-        assert!(b > a && b >= a);\n-        assert!(a < b && a <= b);\n     }\n \n     #[test]\n@@ -2525,206 +2906,29 @@ mod tests {\n         assert!(a.remove(&1000));\n         assert!(b.contains(&1000));\n     }\n+}\n \n-    #[test]\n-    fn test_small_bitv_tests() {\n-        let v = from_bytes(&[0]);\n-        assert!(!v.all());\n-        assert!(!v.any());\n-        assert!(v.none());\n \n-        let v = from_bytes(&[0b00010100]);\n-        assert!(!v.all());\n-        assert!(v.any());\n-        assert!(!v.none());\n \n-        let v = from_bytes(&[0xFF]);\n-        assert!(v.all());\n-        assert!(v.any());\n-        assert!(!v.none());\n-    }\n \n-    #[test]\n-    fn test_big_bitv_tests() {\n-        let v = from_bytes(&[ // 88 bits\n-            0, 0, 0, 0,\n-            0, 0, 0, 0,\n-            0, 0, 0]);\n-        assert!(!v.all());\n-        assert!(!v.any());\n-        assert!(v.none());\n \n-        let v = from_bytes(&[ // 88 bits\n-            0, 0, 0b00010100, 0,\n-            0, 0, 0, 0b00110100,\n-            0, 0, 0]);\n-        assert!(!v.all());\n-        assert!(v.any());\n-        assert!(!v.none());\n-\n-        let v = from_bytes(&[ // 88 bits\n-            0xFF, 0xFF, 0xFF, 0xFF,\n-            0xFF, 0xFF, 0xFF, 0xFF,\n-            0xFF, 0xFF, 0xFF]);\n-        assert!(v.all());\n-        assert!(v.any());\n-        assert!(!v.none());\n-    }\n-\n-    #[test]\n-    fn test_bitv_push_pop() {\n-        let mut s = Bitv::with_capacity(5 * u32::BITS - 2, false);\n-        assert_eq!(s.len(), 5 * u32::BITS - 2);\n-        assert_eq!(s.get(5 * u32::BITS - 3), false);\n-        s.push(true);\n-        s.push(true);\n-        assert_eq!(s.get(5 * u32::BITS - 2), true);\n-        assert_eq!(s.get(5 * u32::BITS - 1), true);\n-        // Here the internal vector will need to be extended\n-        s.push(false);\n-        assert_eq!(s.get(5 * u32::BITS), false);\n-        s.push(false);\n-        assert_eq!(s.get(5 * u32::BITS + 1), false);\n-        assert_eq!(s.len(), 5 * u32::BITS + 2);\n-        // Pop it all off\n-        assert_eq!(s.pop(), false);\n-        assert_eq!(s.pop(), false);\n-        assert_eq!(s.pop(), true);\n-        assert_eq!(s.pop(), true);\n-        assert_eq!(s.len(), 5 * u32::BITS - 2);\n-    }\n-\n-    #[test]\n-    fn test_bitv_truncate() {\n-        let mut s = Bitv::with_capacity(5 * u32::BITS, true);\n-\n-        assert_eq!(s, Bitv::with_capacity(5 * u32::BITS, true));\n-        assert_eq!(s.len(), 5 * u32::BITS);\n-        s.truncate(4 * u32::BITS);\n-        assert_eq!(s, Bitv::with_capacity(4 * u32::BITS, true));\n-        assert_eq!(s.len(), 4 * u32::BITS);\n-        // Truncating to a size > s.len() should be a noop\n-        s.truncate(5 * u32::BITS);\n-        assert_eq!(s, Bitv::with_capacity(4 * u32::BITS, true));\n-        assert_eq!(s.len(), 4 * u32::BITS);\n-        s.truncate(3 * u32::BITS - 10);\n-        assert_eq!(s, Bitv::with_capacity(3 * u32::BITS - 10, true));\n-        assert_eq!(s.len(), 3 * u32::BITS - 10);\n-        s.truncate(0);\n-        assert_eq!(s, Bitv::with_capacity(0, true));\n-        assert_eq!(s.len(), 0);\n-    }\n-\n-    #[test]\n-    fn test_bitv_reserve() {\n-        let mut s = Bitv::with_capacity(5 * u32::BITS, true);\n-        // Check capacity\n-        assert_eq!(s.capacity(), 5 * u32::BITS);\n-        s.reserve(2 * u32::BITS);\n-        assert_eq!(s.capacity(), 5 * u32::BITS);\n-        s.reserve(7 * u32::BITS);\n-        assert_eq!(s.capacity(), 7 * u32::BITS);\n-        s.reserve(7 * u32::BITS);\n-        assert_eq!(s.capacity(), 7 * u32::BITS);\n-        s.reserve(7 * u32::BITS + 1);\n-        assert_eq!(s.capacity(), 8 * u32::BITS);\n-        // Check that length hasn't changed\n-        assert_eq!(s.len(), 5 * u32::BITS);\n-        s.push(true);\n-        s.push(false);\n-        s.push(true);\n-        assert_eq!(s.get(5 * u32::BITS - 1), true);\n-        assert_eq!(s.get(5 * u32::BITS - 0), true);\n-        assert_eq!(s.get(5 * u32::BITS + 1), false);\n-        assert_eq!(s.get(5 * u32::BITS + 2), true);\n-    }\n+#[cfg(test)]\n+mod bitv_set_bench {\n+    use std::prelude::*;\n+    use std::rand;\n+    use std::rand::Rng;\n+    use std::u32;\n+    use test::{Bencher, black_box};\n \n-    #[test]\n-    fn test_bitv_grow() {\n-        let mut bitv = from_bytes(&[0b10110110, 0b00000000, 0b10101010]);\n-        bitv.grow(32, true);\n-        assert_eq!(bitv, from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n-                                     0xFF, 0xFF, 0xFF, 0xFF]));\n-        bitv.grow(64, false);\n-        assert_eq!(bitv, from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n-                                     0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0]));\n-        bitv.grow(16, true);\n-        assert_eq!(bitv, from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n-                                     0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF]));\n-    }\n+    use super::{Bitv, BitvSet};\n \n-    #[test]\n-    fn test_bitv_extend() {\n-        let mut bitv = from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n-        let ext = from_bytes(&[0b01001001, 0b10010010, 0b10111101]);\n-        bitv.extend(ext.iter());\n-        assert_eq!(bitv, from_bytes(&[0b10110110, 0b00000000, 0b11111111,\n-                                     0b01001001, 0b10010010, 0b10111101]));\n-    }\n-\n-    #[test]\n-    fn test_bitv_set_show() {\n-        let mut s = BitvSet::new();\n-        s.insert(1);\n-        s.insert(10);\n-        s.insert(50);\n-        s.insert(2);\n-        assert_eq!(\"{1, 2, 10, 50}\", s.to_string());\n-    }\n+    static BENCH_BITS : uint = 1 << 14;\n \n     fn rng() -> rand::IsaacRng {\n         let seed: &[_] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n         rand::SeedableRng::from_seed(seed)\n     }\n \n-    #[bench]\n-    fn bench_uint_small(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bitv = 0 as uint;\n-        b.iter(|| {\n-            for _ in range(0u, 100) {\n-                bitv |= 1 << ((r.next_u32() as uint) % u32::BITS);\n-            }\n-            black_box(&bitv)\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_bitv_set_big_fixed(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bitv = Bitv::with_capacity(BENCH_BITS, false);\n-        b.iter(|| {\n-            for _ in range(0u, 100) {\n-                bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n-            }\n-            black_box(&bitv)\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_bitv_set_big_variable(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bitv = Bitv::with_capacity(BENCH_BITS, false);\n-        b.iter(|| {\n-            for _ in range(0u, 100) {\n-                bitv.set((r.next_u32() as uint) % BENCH_BITS, r.gen());\n-            }\n-            black_box(&bitv);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_bitv_set_small(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bitv = Bitv::with_capacity(u32::BITS, false);\n-        b.iter(|| {\n-            for _ in range(0u, 100) {\n-                bitv.set((r.next_u32() as uint) % u32::BITS, true);\n-            }\n-            black_box(&bitv);\n-        });\n-    }\n-\n     #[bench]\n     fn bench_bitvset_small(b: &mut Bencher) {\n         let mut r = rng();\n@@ -2749,44 +2953,9 @@ mod tests {\n         });\n     }\n \n-    #[bench]\n-    fn bench_bitv_big_union(b: &mut Bencher) {\n-        let mut b1 = Bitv::with_capacity(BENCH_BITS, false);\n-        let b2 = Bitv::with_capacity(BENCH_BITS, false);\n-        b.iter(|| {\n-            b1.union(&b2)\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_bitv_small_iter(b: &mut Bencher) {\n-        let bitv = Bitv::with_capacity(u32::BITS, false);\n-        b.iter(|| {\n-            let mut sum = 0u;\n-            for _ in range(0u, 10) {\n-                for pres in bitv.iter() {\n-                    sum += pres as uint;\n-                }\n-            }\n-            sum\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_bitv_big_iter(b: &mut Bencher) {\n-        let bitv = Bitv::with_capacity(BENCH_BITS, false);\n-        b.iter(|| {\n-            let mut sum = 0u;\n-            for pres in bitv.iter() {\n-                sum += pres as uint;\n-            }\n-            sum\n-        })\n-    }\n-\n     #[bench]\n     fn bench_bitvset_iter(b: &mut Bencher) {\n-        let bitv = BitvSet::from_bitv(from_fn(BENCH_BITS,\n+        let bitv = BitvSet::from_bitv(Bitv::from_fn(BENCH_BITS,\n                                               |idx| {idx % 3 == 0}));\n         b.iter(|| {\n             let mut sum = 0u;"}, {"sha": "c5f69f249db6bfe1707d9936c73362fcbd92fc65", "filename": "src/test/run-pass/bitv-perf-test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c5101542d2a4983ade627bc593e16c0bb5f23ba/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5101542d2a4983ade627bc593e16c0bb5f23ba/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs?ref=9c5101542d2a4983ade627bc593e16c0bb5f23ba", "patch": "@@ -13,8 +13,8 @@ extern crate collections;\n use std::collections::Bitv;\n \n fn bitv_test() {\n-    let mut v1 = box Bitv::with_capacity(31, false);\n-    let v2 = box Bitv::with_capacity(31, true);\n+    let mut v1 = box Bitv::from_elem(31, false);\n+    let v2 = box Bitv::from_elem(31, true);\n     v1.union(&*v2);\n }\n "}, {"sha": "bc4ceb38de33cdc9b1ff848a04e3a69709d839a8", "filename": "src/test/run-pass/issue-11736.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c5101542d2a4983ade627bc593e16c0bb5f23ba/src%2Ftest%2Frun-pass%2Fissue-11736.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5101542d2a4983ade627bc593e16c0bb5f23ba/src%2Ftest%2Frun-pass%2Fissue-11736.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11736.rs?ref=9c5101542d2a4983ade627bc593e16c0bb5f23ba", "patch": "@@ -16,7 +16,7 @@ use std::num::Float;\n fn main() {\n     // Generate sieve of Eratosthenes for n up to 1e6\n     let n = 1000000u;\n-    let mut sieve = Bitv::with_capacity(n+1, true);\n+    let mut sieve = Bitv::from_elem(n+1, true);\n     let limit: uint = (n as f32).sqrt() as uint;\n     for i in range(2, limit+1) {\n         if sieve[i] {"}]}