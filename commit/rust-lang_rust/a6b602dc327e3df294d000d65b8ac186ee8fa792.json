{"sha": "a6b602dc327e3df294d000d65b8ac186ee8fa792", "node_id": "C_kwDOAAsO6NoAKGE2YjYwMmRjMzI3ZTNkZjI5NGQwMDBkNjViOGFjMTg2ZWU4ZmE3OTI", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-07-22T18:42:51Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-07-22T18:59:16Z"}, "message": "Fix inline asm codegen for empty template", "tree": {"sha": "1ad8acfd74b6c0435f6a74cca4c379bf40f35f08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ad8acfd74b6c0435f6a74cca4c379bf40f35f08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6b602dc327e3df294d000d65b8ac186ee8fa792", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6b602dc327e3df294d000d65b8ac186ee8fa792", "html_url": "https://github.com/rust-lang/rust/commit/a6b602dc327e3df294d000d65b8ac186ee8fa792", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6b602dc327e3df294d000d65b8ac186ee8fa792/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd96988436c2ad6ca6654af073170df5e12e077a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd96988436c2ad6ca6654af073170df5e12e077a", "html_url": "https://github.com/rust-lang/rust/commit/cd96988436c2ad6ca6654af073170df5e12e077a"}], "stats": {"total": 170, "additions": 90, "deletions": 80}, "files": [{"sha": "241de5e36530c8bbddb1bce99b2f4f2fe39fa23b", "filename": "src/inline_asm.rs", "status": "modified", "additions": 90, "deletions": 80, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/a6b602dc327e3df294d000d65b8ac186ee8fa792/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6b602dc327e3df294d000d65b8ac186ee8fa792/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=a6b602dc327e3df294d000d65b8ac186ee8fa792", "patch": "@@ -18,86 +18,96 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n ) {\n     // FIXME add .eh_frame unwind info directives\n \n-    if template[0] == InlineAsmTemplatePiece::String(\"int $$0x29\".to_string()) {\n-        let true_ = fx.bcx.ins().iconst(types::I32, 1);\n-        fx.bcx.ins().trapnz(true_, TrapCode::User(1));\n-        return;\n-    } else if template[0] == InlineAsmTemplatePiece::String(\"movq %rbx, \".to_string())\n-        && matches!(\n-            template[1],\n-            InlineAsmTemplatePiece::Placeholder { operand_idx: 0, modifier: Some('r'), span: _ }\n-        )\n-        && template[2] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n-        && template[3] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n-        && template[4] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n-        && template[5] == InlineAsmTemplatePiece::String(\"xchgq %rbx, \".to_string())\n-        && matches!(\n-            template[6],\n-            InlineAsmTemplatePiece::Placeholder { operand_idx: 0, modifier: Some('r'), span: _ }\n-        )\n-    {\n-        assert_eq!(operands.len(), 4);\n-        let (leaf, eax_place) = match operands[1] {\n-            InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n-                assert_eq!(\n-                    reg,\n-                    InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax))\n-                );\n-                (\n-                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n-                    crate::base::codegen_place(fx, out_place.unwrap()),\n-                )\n-            }\n-            _ => unreachable!(),\n-        };\n-        let ebx_place = match operands[0] {\n-            InlineAsmOperand::Out { reg, late: true, place } => {\n-                assert_eq!(\n-                    reg,\n-                    InlineAsmRegOrRegClass::RegClass(InlineAsmRegClass::X86(\n-                        X86InlineAsmRegClass::reg\n-                    ))\n-                );\n-                crate::base::codegen_place(fx, place.unwrap())\n-            }\n-            _ => unreachable!(),\n-        };\n-        let (sub_leaf, ecx_place) = match operands[2] {\n-            InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n-                assert_eq!(\n-                    reg,\n-                    InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx))\n-                );\n-                (\n-                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n-                    crate::base::codegen_place(fx, out_place.unwrap()),\n-                )\n-            }\n-            _ => unreachable!(),\n-        };\n-        let edx_place = match operands[3] {\n-            InlineAsmOperand::Out { reg, late: true, place } => {\n-                assert_eq!(\n-                    reg,\n-                    InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx))\n-                );\n-                crate::base::codegen_place(fx, place.unwrap())\n-            }\n-            _ => unreachable!(),\n-        };\n-\n-        let (eax, ebx, ecx, edx) = crate::intrinsics::codegen_cpuid_call(fx, leaf, sub_leaf);\n-\n-        eax_place.write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fx.tcx.types.u32)));\n-        ebx_place.write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n-        ecx_place.write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n-        edx_place.write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n-        return;\n-    } else if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") {\n-        // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n-        crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n-    } else if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" {\n-        crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n+    if !template.is_empty() {\n+        if template[0] == InlineAsmTemplatePiece::String(\"int $$0x29\".to_string()) {\n+            let true_ = fx.bcx.ins().iconst(types::I32, 1);\n+            fx.bcx.ins().trapnz(true_, TrapCode::User(1));\n+            return;\n+        } else if template[0] == InlineAsmTemplatePiece::String(\"movq %rbx, \".to_string())\n+            && matches!(\n+                template[1],\n+                InlineAsmTemplatePiece::Placeholder {\n+                    operand_idx: 0,\n+                    modifier: Some('r'),\n+                    span: _\n+                }\n+            )\n+            && template[2] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[3] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n+            && template[4] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[5] == InlineAsmTemplatePiece::String(\"xchgq %rbx, \".to_string())\n+            && matches!(\n+                template[6],\n+                InlineAsmTemplatePiece::Placeholder {\n+                    operand_idx: 0,\n+                    modifier: Some('r'),\n+                    span: _\n+                }\n+            )\n+        {\n+            assert_eq!(operands.len(), 4);\n+            let (leaf, eax_place) = match operands[1] {\n+                InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n+                    assert_eq!(\n+                        reg,\n+                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax))\n+                    );\n+                    (\n+                        crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                        crate::base::codegen_place(fx, out_place.unwrap()),\n+                    )\n+                }\n+                _ => unreachable!(),\n+            };\n+            let ebx_place = match operands[0] {\n+                InlineAsmOperand::Out { reg, late: true, place } => {\n+                    assert_eq!(\n+                        reg,\n+                        InlineAsmRegOrRegClass::RegClass(InlineAsmRegClass::X86(\n+                            X86InlineAsmRegClass::reg\n+                        ))\n+                    );\n+                    crate::base::codegen_place(fx, place.unwrap())\n+                }\n+                _ => unreachable!(),\n+            };\n+            let (sub_leaf, ecx_place) = match operands[2] {\n+                InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n+                    assert_eq!(\n+                        reg,\n+                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx))\n+                    );\n+                    (\n+                        crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                        crate::base::codegen_place(fx, out_place.unwrap()),\n+                    )\n+                }\n+                _ => unreachable!(),\n+            };\n+            let edx_place = match operands[3] {\n+                InlineAsmOperand::Out { reg, late: true, place } => {\n+                    assert_eq!(\n+                        reg,\n+                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx))\n+                    );\n+                    crate::base::codegen_place(fx, place.unwrap())\n+                }\n+                _ => unreachable!(),\n+            };\n+\n+            let (eax, ebx, ecx, edx) = crate::intrinsics::codegen_cpuid_call(fx, leaf, sub_leaf);\n+\n+            eax_place.write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fx.tcx.types.u32)));\n+            ebx_place.write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n+            ecx_place.write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n+            edx_place.write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n+            return;\n+        } else if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") {\n+            // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n+            crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n+        } else if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" {\n+            crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n+        }\n     }\n \n     let mut inputs = Vec::new();"}]}