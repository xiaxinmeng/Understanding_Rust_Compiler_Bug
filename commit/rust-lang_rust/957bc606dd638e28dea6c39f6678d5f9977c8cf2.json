{"sha": "957bc606dd638e28dea6c39f6678d5f9977c8cf2", "node_id": "C_kwDOAAsO6NoAKDk1N2JjNjA2ZGQ2MzhlMjhkZWE2YzM5ZjY2NzhkNWY5OTc3YzhjZjI", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-01-16T21:09:23Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-01-25T19:14:09Z"}, "message": "rustdoc: Collect rustdoc-reachable items during early doc link resolution", "tree": {"sha": "556619e4d206702f54ecfb8336c490a9b260219e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/556619e4d206702f54ecfb8336c490a9b260219e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/957bc606dd638e28dea6c39f6678d5f9977c8cf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/957bc606dd638e28dea6c39f6678d5f9977c8cf2", "html_url": "https://github.com/rust-lang/rust/commit/957bc606dd638e28dea6c39f6678d5f9977c8cf2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/957bc606dd638e28dea6c39f6678d5f9977c8cf2/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "url": "https://api.github.com/repos/rust-lang/rust/commits/95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "html_url": "https://github.com/rust-lang/rust/commit/95b61d16d4bd2e46b0a110c1bda703f026f0a94f"}], "stats": {"total": 89, "additions": 83, "deletions": 6}, "files": [{"sha": "e5d0bb87edf66f4baffbff184a50c95aac40d3d5", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/957bc606dd638e28dea6c39f6678d5f9977c8cf2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957bc606dd638e28dea6c39f6678d5f9977c8cf2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=957bc606dd638e28dea6c39f6678d5f9977c8cf2", "patch": "@@ -632,6 +632,12 @@ impl CStore {\n             .get_attr_flags(def_id.index)\n             .contains(AttrFlags::MAY_HAVE_DOC_LINKS)\n     }\n+\n+    pub fn is_doc_hidden_untracked(&self, def_id: DefId) -> bool {\n+        self.get_crate_data(def_id.krate)\n+            .get_attr_flags(def_id.index)\n+            .contains(AttrFlags::IS_DOC_HIDDEN)\n+    }\n }\n \n impl CrateStore for CStore {"}, {"sha": "ca3a70c7236feb2a617527c19712bb65b81882c5", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/957bc606dd638e28dea6c39f6678d5f9977c8cf2/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957bc606dd638e28dea6c39f6678d5f9977c8cf2/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=957bc606dd638e28dea6c39f6678d5f9977c8cf2", "patch": "@@ -29,11 +29,6 @@ mod tests;\n pub(crate) fn krate(cx: &mut DocContext<'_>) -> Crate {\n     let module = crate::visit_ast::RustdocVisitor::new(cx).visit();\n \n-    for &cnum in cx.tcx.crates(()) {\n-        // Analyze doc-reachability for extern items\n-        crate::visit_lib::lib_embargo_visit_item(cx, cnum.as_def_id());\n-    }\n-\n     // Clean the crate, translating the entire librustc_ast AST to one that is\n     // understood by rustdoc.\n     let mut module = clean_doc_module(&module, cx);"}, {"sha": "0ce43f7db8e8b0d9d8fb5cd768141da3a27cd023", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/957bc606dd638e28dea6c39f6678d5f9977c8cf2/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957bc606dd638e28dea6c39f6678d5f9977c8cf2/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=957bc606dd638e28dea6c39f6678d5f9977c8cf2", "patch": "@@ -41,6 +41,7 @@ pub(crate) struct ResolverCaches {\n     pub(crate) traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n     pub(crate) all_trait_impls: Option<Vec<DefId>>,\n     pub(crate) all_macro_rules: FxHashMap<Symbol, Res<NodeId>>,\n+    pub(crate) extern_doc_reachable: DefIdSet,\n }\n \n pub(crate) struct DocContext<'tcx> {\n@@ -363,6 +364,10 @@ pub(crate) fn run_global_ctxt(\n         show_coverage,\n     };\n \n+    ctxt.cache\n+        .effective_visibilities\n+        .init(mem::take(&mut ctxt.resolver_caches.extern_doc_reachable));\n+\n     // Small hack to force the Sized trait to be present.\n     //\n     // Note that in case of `#![no_core]`, the trait is not available."}, {"sha": "150e53f63b9a512a3e0262c13f4e3dde002bce6b", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/957bc606dd638e28dea6c39f6678d5f9977c8cf2/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957bc606dd638e28dea6c39f6678d5f9977c8cf2/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=957bc606dd638e28dea6c39f6678d5f9977c8cf2", "patch": "@@ -2,6 +2,7 @@ use crate::clean::Attributes;\n use crate::core::ResolverCaches;\n use crate::passes::collect_intra_doc_links::preprocessed_markdown_links;\n use crate::passes::collect_intra_doc_links::{Disambiguator, PreprocessedMarkdownLink};\n+use crate::visit_lib::early_lib_embargo_visit_item;\n \n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::{self as ast, ItemKind};\n@@ -34,6 +35,8 @@ pub(crate) fn early_resolve_intra_doc_links(\n         traits_in_scope: Default::default(),\n         all_trait_impls: Default::default(),\n         all_macro_rules: Default::default(),\n+        extern_doc_reachable: Default::default(),\n+        local_doc_reachable: Default::default(),\n         document_private_items,\n     };\n \n@@ -61,6 +64,7 @@ pub(crate) fn early_resolve_intra_doc_links(\n         traits_in_scope: link_resolver.traits_in_scope,\n         all_trait_impls: Some(link_resolver.all_trait_impls),\n         all_macro_rules: link_resolver.all_macro_rules,\n+        extern_doc_reachable: link_resolver.extern_doc_reachable,\n     }\n }\n \n@@ -77,6 +81,15 @@ struct EarlyDocLinkResolver<'r, 'ra> {\n     traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n     all_trait_impls: Vec<DefId>,\n     all_macro_rules: FxHashMap<Symbol, Res<ast::NodeId>>,\n+    /// This set is used as a seed for `effective_visibilities`, which are then extended by some\n+    /// more items using `lib_embargo_visit_item` during doc inlining.\n+    extern_doc_reachable: DefIdSet,\n+    /// This is an easily identifiable superset of items added to `effective_visibilities`\n+    /// using `lib_embargo_visit_item` during doc inlining.\n+    /// The union of `(extern,local)_doc_reachable` is therefore a superset of\n+    /// `effective_visibilities` and can be used for pruning extern impls here\n+    /// in early doc link resolution.\n+    local_doc_reachable: DefIdSet,\n     document_private_items: bool,\n }\n \n@@ -114,6 +127,14 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n         let mut start_cnum = 0;\n         loop {\n             let crates = Vec::from_iter(self.resolver.cstore().crates_untracked());\n+            for cnum in &crates[start_cnum..] {\n+                early_lib_embargo_visit_item(\n+                    self.resolver,\n+                    &mut self.extern_doc_reachable,\n+                    cnum.as_def_id(),\n+                    true,\n+                );\n+            }\n             for &cnum in &crates[start_cnum..] {\n                 let all_trait_impls =\n                     Vec::from_iter(self.resolver.cstore().trait_impls_in_crate_untracked(cnum));\n@@ -298,6 +319,7 @@ impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n                     && module_id.is_local()\n             {\n                 if let Some(def_id) = child.res.opt_def_id() && !def_id.is_local() {\n+                    self.local_doc_reachable.insert(def_id);\n                     let scope_id = match child.res {\n                         Res::Def(\n                             DefKind::Variant"}, {"sha": "07d8b78d767dbb956994588c01ea194007ec06f0", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/957bc606dd638e28dea6c39f6678d5f9977c8cf2/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957bc606dd638e28dea6c39f6678d5f9977c8cf2/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=957bc606dd638e28dea6c39f6678d5f9977c8cf2", "patch": "@@ -1,7 +1,8 @@\n use crate::core::DocContext;\n-use rustc_hir::def::DefKind;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, DefIdSet};\n use rustc_middle::ty::TyCtxt;\n+use rustc_resolve::Resolver;\n \n // FIXME: this may not be exhaustive, but is sufficient for rustdocs current uses\n \n@@ -25,6 +26,10 @@ impl RustdocEffectiveVisibilities {\n     define_method!(is_directly_public);\n     define_method!(is_exported);\n     define_method!(is_reachable);\n+\n+    pub(crate) fn init(&mut self, extern_public: DefIdSet) {\n+        self.extern_public = extern_public;\n+    }\n }\n \n pub(crate) fn lib_embargo_visit_item(cx: &mut DocContext<'_>, def_id: DefId) {\n@@ -37,6 +42,17 @@ pub(crate) fn lib_embargo_visit_item(cx: &mut DocContext<'_>, def_id: DefId) {\n     .visit_item(def_id)\n }\n \n+pub(crate) fn early_lib_embargo_visit_item(\n+    resolver: &Resolver<'_>,\n+    extern_public: &mut DefIdSet,\n+    def_id: DefId,\n+    is_mod: bool,\n+) {\n+    assert!(!def_id.is_local());\n+    EarlyLibEmbargoVisitor { resolver, extern_public, visited_mods: Default::default() }\n+        .visit_item(def_id, is_mod)\n+}\n+\n /// Similar to `librustc_privacy::EmbargoVisitor`, but also takes\n /// specific rustdoc annotations into account (i.e., `doc(hidden)`)\n struct LibEmbargoVisitor<'a, 'tcx> {\n@@ -47,6 +63,14 @@ struct LibEmbargoVisitor<'a, 'tcx> {\n     visited_mods: DefIdSet,\n }\n \n+struct EarlyLibEmbargoVisitor<'r, 'ra> {\n+    resolver: &'r Resolver<'ra>,\n+    // Effective visibilities for reachable nodes\n+    extern_public: &'r mut DefIdSet,\n+    // Keeps track of already visited modules, in case a module re-exports its parent\n+    visited_mods: DefIdSet,\n+}\n+\n impl LibEmbargoVisitor<'_, '_> {\n     fn visit_mod(&mut self, def_id: DefId) {\n         if !self.visited_mods.insert(def_id) {\n@@ -71,3 +95,28 @@ impl LibEmbargoVisitor<'_, '_> {\n         }\n     }\n }\n+\n+impl EarlyLibEmbargoVisitor<'_, '_> {\n+    fn visit_mod(&mut self, def_id: DefId) {\n+        if !self.visited_mods.insert(def_id) {\n+            return;\n+        }\n+\n+        for item in self.resolver.cstore().module_children_untracked(def_id, self.resolver.sess()) {\n+            if let Some(def_id) = item.res.opt_def_id() {\n+                if item.vis.is_public() {\n+                    self.visit_item(def_id, matches!(item.res, Res::Def(DefKind::Mod, _)));\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_item(&mut self, def_id: DefId, is_mod: bool) {\n+        if !self.resolver.cstore().is_doc_hidden_untracked(def_id) {\n+            self.extern_public.insert(def_id);\n+            if is_mod {\n+                self.visit_mod(def_id);\n+            }\n+        }\n+    }\n+}"}]}