{"sha": "11251b9dab81048c94555c948914995bf8d0f3fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExMjUxYjlkYWI4MTA0OGM5NDU1NWM5NDg5MTQ5OTViZjhkMGYzZmQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-10T13:28:57Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-10T18:24:42Z"}, "message": "lowering: extract lower_expr_while_in_loop_scope", "tree": {"sha": "aed9fd89d6ab7f930ec7a0d1e38f8298b250b453", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aed9fd89d6ab7f930ec7a0d1e38f8298b250b453"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11251b9dab81048c94555c948914995bf8d0f3fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11251b9dab81048c94555c948914995bf8d0f3fd", "html_url": "https://github.com/rust-lang/rust/commit/11251b9dab81048c94555c948914995bf8d0f3fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11251b9dab81048c94555c948914995bf8d0f3fd/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8b3b2e0523ab6b5c9cd0591c5adb51e3b458d52", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8b3b2e0523ab6b5c9cd0591c5adb51e3b458d52", "html_url": "https://github.com/rust-lang/rust/commit/c8b3b2e0523ab6b5c9cd0591c5adb51e3b458d52"}], "stats": {"total": 159, "additions": 86, "deletions": 73}, "files": [{"sha": "794ac57f6a976fb5cb84e067b8539801ce86c008", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 86, "deletions": 73, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/11251b9dab81048c94555c948914995bf8d0f3fd/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11251b9dab81048c94555c948914995bf8d0f3fd/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=11251b9dab81048c94555c948914995bf8d0f3fd", "patch": "@@ -143,80 +143,8 @@ impl LoweringContext<'_> {\n \n                 hir::ExprKind::Match(P(scrutinee), vec![then_arm, else_arm].into(), desugar)\n             }\n-            // FIXME(#53667): handle lowering of && and parens.\n             ExprKind::While(ref cond, ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n-                // Note that the block AND the condition are evaluated in the loop scope.\n-                // This is done to allow `break` from inside the condition of the loop.\n-\n-                // `_ => break`:\n-                let else_arm = {\n-                    let else_pat = this.pat_wild(e.span);\n-                    let else_expr = this.expr_break(e.span, ThinVec::new());\n-                    this.arm(hir_vec![else_pat], else_expr)\n-                };\n-\n-                // Handle then + scrutinee:\n-                let then_blk = this.lower_block(body, false);\n-                let then_expr = this.expr_block(then_blk, ThinVec::new());\n-                let (then_pats, scrutinee, desugar, source) = match cond.node {\n-                    ExprKind::Let(ref pats, ref scrutinee) => {\n-                        // to:\n-                        //\n-                        //   [opt_ident]: loop {\n-                        //     match <sub_expr> {\n-                        //       <pat> => <body>,\n-                        //       _ => break\n-                        //     }\n-                        //   }\n-                        let scrutinee = this.with_loop_condition_scope(|t| t.lower_expr(scrutinee));\n-                        let pats = pats.iter().map(|pat| this.lower_pat(pat)).collect();\n-                        let desugar = hir::MatchSource::WhileLetDesugar;\n-                        (pats, scrutinee, desugar, hir::LoopSource::WhileLet)\n-                    }\n-                    _ => {\n-                        // We desugar: `'label: while $cond $body` into:\n-                        //\n-                        // ```\n-                        // 'label: loop {\n-                        //     match DropTemps($cond) {\n-                        //         true => $body,\n-                        //         _ => break,\n-                        //     }\n-                        // }\n-                        // ```\n-\n-                        // Lower condition:\n-                        let cond = this.with_loop_condition_scope(|this| this.lower_expr(cond));\n-                        let span_block = this.mark_span_with_reason(\n-                            DesugaringKind::CondTemporary, cond.span, None\n-                        );\n-                        // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n-                        // to preserve drop semantics since `while cond { ... }` does not\n-                        // let temporaries live outside of `cond`.\n-                        let cond = this.expr_drop_temps(span_block, P(cond), ThinVec::new());\n-\n-                        let desugar = hir::MatchSource::WhileDesugar;\n-                        // `true => <then>`:\n-                        let pats = hir_vec![this.pat_bool(e.span, true)];\n-                        (pats, cond, desugar, hir::LoopSource::While)\n-                    }\n-                };\n-                let then_arm = this.arm(then_pats, P(then_expr));\n-\n-                // `match <scrutinee> { ... }`\n-                let match_expr = this.expr_match(\n-                    scrutinee.span,\n-                    P(scrutinee),\n-                    hir_vec![then_arm, else_arm],\n-                    desugar,\n-                );\n-\n-                // `[opt_ident]: loop { ... }`\n-                hir::ExprKind::Loop(\n-                    P(this.block_expr(P(match_expr))),\n-                    this.lower_label(opt_label),\n-                    source\n-                )\n+                this.lower_expr_while_in_loop_scope(e.span, cond, body, opt_label)\n             }),\n             ExprKind::Loop(ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n                 hir::ExprKind::Loop(\n@@ -351,6 +279,91 @@ impl LoweringContext<'_> {\n         }\n     }\n \n+    fn lower_expr_while_in_loop_scope(\n+        &mut self,\n+        span: Span,\n+        cond: &Expr,\n+        body: &Block,\n+        opt_label: Option<Label>\n+    ) -> hir::ExprKind {\n+        // FIXME(#53667): handle lowering of && and parens.\n+\n+        // Note that the block AND the condition are evaluated in the loop scope.\n+        // This is done to allow `break` from inside the condition of the loop.\n+\n+        // `_ => break`:\n+        let else_arm = {\n+            let else_pat = self.pat_wild(span);\n+            let else_expr = self.expr_break(span, ThinVec::new());\n+            self.arm(hir_vec![else_pat], else_expr)\n+        };\n+\n+        // Handle then + scrutinee:\n+        let then_blk = self.lower_block(body, false);\n+        let then_expr = self.expr_block(then_blk, ThinVec::new());\n+        let (then_pats, scrutinee, desugar, source) = match cond.node {\n+            ExprKind::Let(ref pats, ref scrutinee) => {\n+                // to:\n+                //\n+                //   [opt_ident]: loop {\n+                //     match <sub_expr> {\n+                //       <pat> => <body>,\n+                //       _ => break\n+                //     }\n+                //   }\n+                let scrutinee = self.with_loop_condition_scope(|t| t.lower_expr(scrutinee));\n+                let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+                let desugar = hir::MatchSource::WhileLetDesugar;\n+                (pats, scrutinee, desugar, hir::LoopSource::WhileLet)\n+            }\n+            _ => {\n+                // We desugar: `'label: while $cond $body` into:\n+                //\n+                // ```\n+                // 'label: loop {\n+                //     match DropTemps($cond) {\n+                //         true => $body,\n+                //         _ => break,\n+                //     }\n+                // }\n+                // ```\n+\n+                // Lower condition:\n+                let cond = self.with_loop_condition_scope(|this| this.lower_expr(cond));\n+                let span_block = self.mark_span_with_reason(\n+                    DesugaringKind::CondTemporary,\n+                    cond.span,\n+                    None,\n+                );\n+                // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n+                // to preserve drop semantics since `while cond { ... }` does not\n+                // let temporaries live outside of `cond`.\n+                let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n+\n+                let desugar = hir::MatchSource::WhileDesugar;\n+                // `true => <then>`:\n+                let pats = hir_vec![self.pat_bool(span, true)];\n+                (pats, cond, desugar, hir::LoopSource::While)\n+            }\n+        };\n+        let then_arm = self.arm(then_pats, P(then_expr));\n+\n+        // `match <scrutinee> { ... }`\n+        let match_expr = self.expr_match(\n+            scrutinee.span,\n+            P(scrutinee),\n+            hir_vec![then_arm, else_arm],\n+            desugar,\n+        );\n+\n+        // `[opt_ident]: loop { ... }`\n+        hir::ExprKind::Loop(\n+            P(self.block_expr(P(match_expr))),\n+            self.lower_label(opt_label),\n+            source\n+        )\n+    }\n+\n     fn lower_expr_try_block(&mut self, body: &Block) -> hir::ExprKind {\n         self.with_catch_scope(body.id, |this| {\n             let unstable_span = this.mark_span_with_reason("}]}