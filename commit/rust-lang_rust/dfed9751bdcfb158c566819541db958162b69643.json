{"sha": "dfed9751bdcfb158c566819541db958162b69643", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmZWQ5NzUxYmRjZmIxNThjNTY2ODE5NTQxZGI5NTgxNjJiNjk2NDM=", "commit": {"author": {"name": "Josh Holmer", "email": "jholmer.in@gmail.com", "date": "2018-08-31T22:14:33Z"}, "committer": {"name": "Josh Holmer", "email": "jholmer.in@gmail.com", "date": "2018-09-04T03:29:44Z"}, "message": "Majority of PR changes", "tree": {"sha": "8540ca689bd00d10705f1fe960fe7ad03a8bd64c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8540ca689bd00d10705f1fe960fe7ad03a8bd64c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfed9751bdcfb158c566819541db958162b69643", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfed9751bdcfb158c566819541db958162b69643", "html_url": "https://github.com/rust-lang/rust/commit/dfed9751bdcfb158c566819541db958162b69643", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfed9751bdcfb158c566819541db958162b69643/comments", "author": {"login": "shssoichiro", "id": 5951392, "node_id": "MDQ6VXNlcjU5NTEzOTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5951392?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shssoichiro", "html_url": "https://github.com/shssoichiro", "followers_url": "https://api.github.com/users/shssoichiro/followers", "following_url": "https://api.github.com/users/shssoichiro/following{/other_user}", "gists_url": "https://api.github.com/users/shssoichiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/shssoichiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shssoichiro/subscriptions", "organizations_url": "https://api.github.com/users/shssoichiro/orgs", "repos_url": "https://api.github.com/users/shssoichiro/repos", "events_url": "https://api.github.com/users/shssoichiro/events{/privacy}", "received_events_url": "https://api.github.com/users/shssoichiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "shssoichiro", "id": 5951392, "node_id": "MDQ6VXNlcjU5NTEzOTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5951392?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shssoichiro", "html_url": "https://github.com/shssoichiro", "followers_url": "https://api.github.com/users/shssoichiro/followers", "following_url": "https://api.github.com/users/shssoichiro/following{/other_user}", "gists_url": "https://api.github.com/users/shssoichiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/shssoichiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shssoichiro/subscriptions", "organizations_url": "https://api.github.com/users/shssoichiro/orgs", "repos_url": "https://api.github.com/users/shssoichiro/repos", "events_url": "https://api.github.com/users/shssoichiro/events{/privacy}", "received_events_url": "https://api.github.com/users/shssoichiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbc93c0166e60fc6e56e6597524aeec7d17cbc58", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbc93c0166e60fc6e56e6597524aeec7d17cbc58", "html_url": "https://github.com/rust-lang/rust/commit/fbc93c0166e60fc6e56e6597524aeec7d17cbc58"}], "stats": {"total": 139, "additions": 76, "deletions": 63}, "files": [{"sha": "3b886875de736b6ca626caaf7cc1b7ec8d1648db", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/dfed9751bdcfb158c566819541db958162b69643/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfed9751bdcfb158c566819541db958162b69643/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=dfed9751bdcfb158c566819541db958162b69643", "patch": "@@ -18,6 +18,7 @@ use std::collections::{HashMap, HashSet};\n use std::iter::{once, Iterator};\n use syntax::ast;\n use syntax::source_map::Span;\n+use syntax_pos::BytePos;\n use crate::utils::{sugg, sext};\n use crate::utils::usage::mutated_variables;\n use crate::consts::{constant, Constant};\n@@ -2269,63 +2270,62 @@ impl<'a, 'tcx> Visitor<'tcx> for VarCollectorVisitor<'a, 'tcx> {\n fn check_needless_collect<'a, 'tcx>(expr: &'tcx Expr, cx: &LateContext<'a, 'tcx>) {\n     if let ExprKind::MethodCall(ref method, _, ref args) = expr.node {\n         if let ExprKind::MethodCall(ref chain_method, _, _) = args[0].node {\n-            if chain_method.ident.name == \"collect\" && match_trait_method(cx, &args[0], &paths::ITERATOR) {\n-                if method.ident.name == \"len\" {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        NEEDLESS_COLLECT,\n-                        expr.span,\n-                        \"you are collecting an iterator to check its length\",\n-                        \"consider replacing with\",\n-                        generate_needless_collect_len_sugg(&args[0], cx),\n-                    );\n-                }\n-                if method.ident.name == \"is_empty\" {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        NEEDLESS_COLLECT,\n-                        expr.span,\n-                        \"you are collecting an iterator to check if it is empty\",\n-                        \"consider replacing with\",\n-                        generate_needless_collect_is_empty_sugg(&args[0], cx),\n-                    );\n-                }\n-                if method.ident.name == \"contains\" {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        NEEDLESS_COLLECT,\n-                        expr.span,\n-                        \"you are collecting an iterator to check if contains an element\",\n-                        \"consider replacing with\",\n-                        generate_needless_collect_contains_sugg(&args[0], &args[1], cx),\n-                    );\n+            if chain_method.ident.name == \"collect\" &&\n+                match_trait_method(cx, &args[0], &paths::ITERATOR) &&\n+                chain_method.args.is_some() {\n+                let generic_args = chain_method.args.as_ref().unwrap();\n+                if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0) {\n+                    let ty = cx.tables.node_id_to_type(ty.hir_id);\n+                    if match_type(cx, ty, &paths::VEC) ||\n+                        match_type(cx, ty, &paths::VEC_DEQUE) ||\n+                        match_type(cx, ty, &paths::BTREEMAP) ||\n+                        match_type(cx, ty, &paths::HASHMAP) {\n+                        if method.ident.name == \"len\" {\n+                            span_lint_and_sugg(\n+                                cx,\n+                                NEEDLESS_COLLECT,\n+                                shorten_needless_collect_span(expr),\n+                                \"you are collecting an iterator to check its length\",\n+                                \"consider replacing with\",\n+                                \".count()\".to_string(),\n+                            );\n+                        }\n+                        if method.ident.name == \"is_empty\" {\n+                            span_lint_and_sugg(\n+                                cx,\n+                                NEEDLESS_COLLECT,\n+                                shorten_needless_collect_span(expr),\n+                                \"you are collecting an iterator to check if it is empty\",\n+                                \"consider replacing with\",\n+                                \".next().is_none()\".to_string(),\n+                            );\n+                        }\n+                        if method.ident.name == \"contains\" {\n+                            let contains_arg = snippet(cx, args[1].span, \"??\");\n+                            span_lint_and_sugg(\n+                                cx,\n+                                NEEDLESS_COLLECT,\n+                                shorten_needless_collect_span(expr),\n+                                \"you are collecting an iterator to check if contains an element\",\n+                                \"consider replacing with\",\n+                                format!(\n+                                    \".any(|&x| x == {})\",\n+                                    if contains_arg.starts_with('&') { &contains_arg[1..] } else { &contains_arg }\n+                                ),\n+                            );\n+                        }\n+                    }\n                 }\n             }\n         }\n     }\n }\n \n-fn generate_needless_collect_len_sugg<'a, 'tcx>(collect_expr: &'tcx Expr, cx: &LateContext<'a, 'tcx>) -> String {\n-    if let ExprKind::MethodCall(_, _, ref args) = collect_expr.node {\n-        let iter = snippet(cx, args[0].span, \"??\");\n-        return format!(\"{}.count()\", iter);\n-    }\n-    unreachable!();\n-}\n-\n-fn generate_needless_collect_is_empty_sugg<'a, 'tcx>(collect_expr: &'tcx Expr, cx: &LateContext<'a, 'tcx>) -> String {\n-    if let ExprKind::MethodCall(_, _, ref args) = collect_expr.node {\n-        let iter = snippet(cx, args[0].span, \"??\");\n-        return format!(\"{}.any(|_| true)\", iter);\n-    }\n-    unreachable!();\n-}\n-\n-fn generate_needless_collect_contains_sugg<'a, 'tcx>(collect_expr: &'tcx Expr, contains_arg: &'tcx Expr, cx: &LateContext<'a, 'tcx>) -> String {\n-    if let ExprKind::MethodCall(_, _, ref args) = collect_expr.node {\n-        let iter = snippet(cx, args[0].span, \"??\");\n-        let arg = snippet(cx, contains_arg.span, \"??\");\n-        return format!(\"{}.any(|&x| x == {})\", iter, if arg.starts_with('&') { &arg[1..] } else { &arg });\n+fn shorten_needless_collect_span(expr: &Expr) -> Span {\n+    if let ExprKind::MethodCall(_, _, ref args) = expr.node {\n+        if let ExprKind::MethodCall(_, ref span, _) = args[0].node {\n+            return expr.span.with_lo(span.lo() - BytePos(1));\n+        }\n     }\n-    unreachable!();\n+    unreachable!()\n }"}, {"sha": "1aff8ee95659b26b0835dd558b1b622b65284a88", "filename": "tests/ui/needless_collect.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dfed9751bdcfb158c566819541db958162b69643/tests%2Fui%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfed9751bdcfb158c566819541db958162b69643/tests%2Fui%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect.rs?ref=dfed9751bdcfb158c566819541db958162b69643", "patch": "@@ -1,3 +1,5 @@\n+use std::collections::{HashMap, HashSet, BTreeSet};\n+\n #[warn(clippy, needless_collect)]\n #[allow(unused_variables, iter_cloned_collect)]\n fn main() {\n@@ -7,4 +9,9 @@ fn main() {\n         // Empty\n     }\n     sample.iter().cloned().collect::<Vec<_>>().contains(&1);\n+    sample.iter().map(|x| (x, x)).collect::<HashMap<_, _>>().len();\n+    // Notice the `HashSet`--this should not be linted\n+    sample.iter().collect::<HashSet<_>>().len();\n+    // Neither should this\n+    sample.iter().collect::<BTreeSet<_>>().len();\n }"}, {"sha": "1eca733ea02fa28c3d8549f6b381bd5fc04f1b2b", "filename": "tests/ui/needless_collect.stderr", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dfed9751bdcfb158c566819541db958162b69643/tests%2Fui%2Fneedless_collect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dfed9751bdcfb158c566819541db958162b69643/tests%2Fui%2Fneedless_collect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect.stderr?ref=dfed9751bdcfb158c566819541db958162b69643", "patch": "@@ -1,22 +1,28 @@\n error: you are collecting an iterator to check its length\n- --> $DIR/needless_collect.rs:5:15\n+ --> $DIR/needless_collect.rs:7:28\n   |\n-5 |     let len = sample.iter().collect::<Vec<_>>().len();\n-  |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider replacing with: `sample.iter().count()`\n+7 |     let len = sample.iter().collect::<Vec<_>>().len();\n+  |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider replacing with: `.count()`\n   |\n   = note: `-D needless-collect` implied by `-D warnings`\n \n error: you are collecting an iterator to check if it is empty\n- --> $DIR/needless_collect.rs:6:8\n+ --> $DIR/needless_collect.rs:8:21\n   |\n-6 |     if sample.iter().collect::<Vec<_>>().is_empty() {\n-  |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider replacing with: `sample.iter().any(|_| true)`\n+8 |     if sample.iter().collect::<Vec<_>>().is_empty() {\n+  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider replacing with: `.next().is_none()`\n \n error: you are collecting an iterator to check if contains an element\n- --> $DIR/needless_collect.rs:9:5\n-  |\n-9 |     sample.iter().cloned().collect::<Vec<_>>().contains(&1);\n-  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider replacing with: `sample.iter().cloned().any(|&x| x == 1)`\n+  --> $DIR/needless_collect.rs:11:27\n+   |\n+11 |     sample.iter().cloned().collect::<Vec<_>>().contains(&1);\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider replacing with: `.any(|&x| x == 1)`\n+\n+error: you are collecting an iterator to check its length\n+  --> $DIR/needless_collect.rs:12:34\n+   |\n+12 |     sample.iter().map(|x| (x, x)).collect::<HashMap<_, _>>().len();\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider replacing with: `.count()`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n "}]}