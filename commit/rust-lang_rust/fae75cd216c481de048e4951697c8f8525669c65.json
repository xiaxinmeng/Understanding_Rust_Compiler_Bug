{"sha": "fae75cd216c481de048e4951697c8f8525669c65", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhZTc1Y2QyMTZjNDgxZGUwNDhlNDk1MTY5N2M4Zjg1MjU2NjljNjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-26T19:35:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-26T19:35:59Z"}, "message": "Auto merge of #65167 - hermitcore:rusty-hermit, r=alexcrichton\n\nRedesign the interface to the unikernel HermitCore\n\nWe are developing the unikernel HermitCore, where the kernel is written in Rust and is already part of the Rust Standard Library. The interface between the standard library and the kernel based on a small C library. With this pull request, we remove completely the dependency to C and use lld as linker. Currently, the kernel will be linked to the application as static library, which is published at https://github.com/hermitcore/libhermit-rs.\n\nWe don\u2019t longer support the C interface to the kernel. Consequently, we remove this part from the Rust Standard Library.", "tree": {"sha": "157e46f84638aa1fa3b0339ced417876e8ca209a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/157e46f84638aa1fa3b0339ced417876e8ca209a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fae75cd216c481de048e4951697c8f8525669c65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fae75cd216c481de048e4951697c8f8525669c65", "html_url": "https://github.com/rust-lang/rust/commit/fae75cd216c481de048e4951697c8f8525669c65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fae75cd216c481de048e4951697c8f8525669c65/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46e6c533d08a2c6d22083a2756a0b569e001c3c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/46e6c533d08a2c6d22083a2756a0b569e001c3c4", "html_url": "https://github.com/rust-lang/rust/commit/46e6c533d08a2c6d22083a2756a0b569e001c3c4"}, {"sha": "805a330ab4c7f33421acacbee0545f6991b2fc70", "url": "https://api.github.com/repos/rust-lang/rust/commits/805a330ab4c7f33421acacbee0545f6991b2fc70", "html_url": "https://github.com/rust-lang/rust/commit/805a330ab4c7f33421acacbee0545f6991b2fc70"}], "stats": {"total": 2772, "additions": 2322, "deletions": 450}, "files": [{"sha": "64f3a7ac619c2e37f55296d1c4789143cca51d20", "filename": "Cargo.lock", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -1328,6 +1328,17 @@ dependencies = [\n  \"unicode-segmentation\",\n ]\n \n+[[package]]\n+name = \"hermit-abi\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f22b8f315b98f415780ddbe9163c7dbbc5a07225b6d102ace1d8aeef85775140\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"libc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n [[package]]\n name = \"hex\"\n version = \"0.3.2\"\n@@ -4159,6 +4170,7 @@ dependencies = [\n  \"dlmalloc\",\n  \"fortanix-sgx-abi\",\n  \"hashbrown 0.6.2\",\n+ \"hermit-abi\",\n  \"libc\",\n  \"panic_abort\",\n  \"panic_unwind\","}, {"sha": "cbdb174c02d97cbcccf09ac9a5c50f1b42b69a47", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -160,7 +160,7 @@ mod job {\n     }\n }\n \n-#[cfg(any(target_os = \"haiku\", not(any(unix, windows))))]\n+#[cfg(any(target_os = \"haiku\", target_os = \"hermit\", not(any(unix, windows))))]\n mod job {\n     pub unsafe fn setup(_build: &mut crate::Build) {\n     }"}, {"sha": "5509f47bc8858ccdc5a668f71cf9f4f001ab32ff", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -54,7 +54,8 @@ pub unsafe extern fn __rust_start_panic(_payload: usize) -> u32 {\n         core::intrinsics::abort();\n     }\n \n-    #[cfg(all(target_vendor=\"fortanix\", target_env=\"sgx\"))]\n+    #[cfg(any(target_os = \"hermit\",\n+              all(target_vendor=\"fortanix\", target_env=\"sgx\")))]\n     unsafe fn abort() -> ! {\n         // call std::sys::abort_internal\n         extern \"C\" { pub fn __rust_abort() -> !; }"}, {"sha": "8bee6ff09e551ef56f5a65a57a7e27530d209c2a", "filename": "src/libpanic_unwind/hermit.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibpanic_unwind%2Fhermit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibpanic_unwind%2Fhermit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fhermit.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,21 @@\n+//! Unwinding for *hermit* target.\n+//!\n+//! Right now we don't support this, so this is just stubs.\n+\n+use alloc::boxed::Box;\n+use core::ptr;\n+use core::any::Any;\n+\n+pub fn payload() -> *mut u8 {\n+    ptr::null_mut()\n+}\n+\n+pub unsafe fn cleanup(_ptr: *mut u8) -> Box<dyn Any + Send> {\n+    extern \"C\" { pub fn __rust_abort() -> !; }\n+    __rust_abort();\n+}\n+\n+pub unsafe fn panic(_data: Box<dyn Any + Send>) -> u32 {\n+    extern \"C\" { pub fn __rust_abort() -> !; }\n+    __rust_abort();\n+}"}, {"sha": "2089a02083c59a4d1855950d6d0e531231a21614", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -43,6 +43,9 @@ cfg_if::cfg_if! {\n     } else if #[cfg(target_arch = \"wasm32\")] {\n         #[path = \"dummy.rs\"]\n         mod imp;\n+    } else if #[cfg(target_os = \"hermit\")] {\n+        #[path = \"hermit.rs\"]\n+        mod imp;\n     } else if #[cfg(all(target_env = \"msvc\", target_arch = \"aarch64\"))] {\n         #[path = \"dummy.rs\"]\n         mod imp;"}, {"sha": "f31de4dbd519418174790c755bc06ae12dfd4578", "filename": "src/librustc_target/spec/hermit_base.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibrustc_target%2Fspec%2Fhermit_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibrustc_target%2Fspec%2Fhermit_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fhermit_base.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -1,26 +1,26 @@\n-use crate::spec::{LinkArgs, LinkerFlavor, PanicStrategy, TargetOptions};\n+use crate::spec::{LldFlavor, LinkArgs, LinkerFlavor, PanicStrategy, TargetOptions};\n use std::default::Default;\n \n pub fn opts() -> TargetOptions {\n-    let mut args = LinkArgs::new();\n-    args.insert(LinkerFlavor::Gcc, vec![\n-        \"-Wl,-Bstatic\".to_string(),\n-        \"-Wl,--no-dynamic-linker\".to_string(),\n-        \"-Wl,--gc-sections\".to_string(),\n-        \"-Wl,--as-needed\".to_string(),\n+    let mut pre_link_args = LinkArgs::new();\n+    pre_link_args.insert(LinkerFlavor::Lld(LldFlavor::Ld), vec![\n+        \"--build-id\".to_string(),\n+        \"--hash-style=gnu\".to_string(),\n+        \"--Bstatic\".to_string(),\n     ]);\n \n     TargetOptions {\n+        linker: Some(\"rust-lld\".to_owned()),\n         executables: true,\n         has_elf_tls: true,\n         linker_is_gnu: true,\n-        no_default_libraries: false,\n+        pre_link_args,\n+        no_default_libraries: true,\n         panic_strategy: PanicStrategy::Abort,\n-        position_independent_executables: false,\n-        pre_link_args: args,\n+        position_independent_executables: true,\n         relocation_model: \"static\".to_string(),\n-        target_family: Some(\"unix\".to_string()),\n-        tls_model: \"local-exec\".to_string(),\n+        target_family: None,\n+        tls_model: \"initial-exec\".to_string(),\n         .. Default::default()\n     }\n }"}, {"sha": "b8be43be09766845cd8852eea8607216fc2efa39", "filename": "src/librustc_target/spec/x86_64_unknown_hermit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_hermit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_hermit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_hermit.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -1,11 +1,11 @@\n-use crate::spec::{LinkerFlavor, Target, TargetResult};\n+use crate::spec::{LldFlavor, LinkerFlavor, Target, TargetResult};\n \n pub fn target() -> TargetResult {\n     let mut base = super::hermit_base::opts();\n     base.cpu = \"x86-64\".to_string();\n-    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n-    base.linker = Some(\"x86_64-hermit-gcc\".to_string());\n     base.max_atomic_width = Some(64);\n+    base.features = \"+rdrnd,+rdseed\".to_string();\n+    base.stack_probes = true;\n \n     Ok(Target {\n         llvm_target: \"x86_64-unknown-hermit\".to_string(),\n@@ -17,7 +17,7 @@ pub fn target() -> TargetResult {\n         target_os: \"hermit\".to_string(),\n         target_env: String::new(),\n         target_vendor: \"unknown\".to_string(),\n-        linker_flavor: LinkerFlavor::Gcc,\n+        linker_flavor: LinkerFlavor::Lld(LldFlavor::Ld),\n         options: base,\n     })\n }"}, {"sha": "11f45c5f6d01c4ff1d849916daf91ec4100b1b9f", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -346,6 +346,7 @@ impl<'a> fmt::Display for Html<'a> {\n                         \"freebsd\" => \"FreeBSD\",\n                         \"fuchsia\" => \"Fuchsia\",\n                         \"haiku\" => \"Haiku\",\n+                        \"hermit\" => \"HermitCore\",\n                         \"ios\" => \"iOS\",\n                         \"l4re\" => \"L4Re\",\n                         \"linux\" => \"Linux\","}, {"sha": "c55911a33f5242cd7fa69a7b1d11bc39ff50a798", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -50,6 +50,9 @@ dlmalloc = { version = \"0.1\", features = ['rustc-dep-of-std'] }\n [target.x86_64-fortanix-unknown-sgx.dependencies]\n fortanix-sgx-abi = { version = \"0.3.2\", features = ['rustc-dep-of-std'] }\n \n+[target.'cfg(all(any(target_arch = \"x86_64\", target_arch = \"aarch64\"), target_os = \"hermit\"))'.dependencies]\n+hermit-abi = { version = \"0.1\", features = ['rustc-dep-of-std'] }\n+\n [target.wasm32-wasi.dependencies]\n wasi = { version = \"0.7.0\", features = ['rustc-dep-of-std', 'alloc'] }\n "}, {"sha": "1f839f165320f4a383cb7c1b5c512abdd8596a0d", "filename": "src/libstd/build.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -54,5 +54,7 @@ fn main() {\n         }\n         println!(\"cargo:rustc-link-lib=c\");\n         println!(\"cargo:rustc-link-lib=compiler_rt\");\n+    } else if target.contains(\"hermit\") {\n+        println!(\"cargo:rustc-link-lib=hermit\");\n     }\n }"}, {"sha": "eb28a839ba86582871bcecba8922aeb7b49f144d", "filename": "src/libstd/os/hermit/fs.rs", "status": "removed", "additions": 0, "deletions": 377, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/46e6c533d08a2c6d22083a2756a0b569e001c3c4/src%2Flibstd%2Fos%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46e6c533d08a2c6d22083a2756a0b569e001c3c4/src%2Flibstd%2Fos%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fhermit%2Ffs.rs?ref=46e6c533d08a2c6d22083a2756a0b569e001c3c4", "patch": "@@ -1,377 +0,0 @@\n-#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-\n-use crate::fs::Metadata;\n-use crate::sys_common::AsInner;\n-\n-#[allow(deprecated)]\n-use crate::os::hermit::raw;\n-\n-/// OS-specific extensions to [`fs::Metadata`].\n-///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n-#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-pub trait MetadataExt {\n-    /// Gain a reference to the underlying `stat` structure which contains\n-    /// the raw information returned by the OS.\n-    ///\n-    /// The contents of the returned [`stat`] are **not** consistent across\n-    /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n-    /// cross-Unix abstractions contained within the raw stat.\n-    ///\n-    /// [`stat`]: ../../../../std/os/linux/raw/struct.stat.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let stat = meta.as_raw_stat();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    #[rustc_deprecated(since = \"1.8.0\",\n-                       reason = \"deprecated in favor of the accessor \\\n-                                 methods of this trait\")]\n-    #[allow(deprecated)]\n-    fn as_raw_stat(&self) -> &raw::stat;\n-\n-    /// Returns the device ID on which this file resides.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_dev());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_dev(&self) -> u64;\n-    /// Returns the inode number.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_ino());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_ino(&self) -> u64;\n-    /// Returns the file type and mode.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_mode());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_mode(&self) -> u32;\n-    /// Returns the number of hard links to file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_nlink());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_nlink(&self) -> u64;\n-    /// Returns the user ID of the file owner.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_uid());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_uid(&self) -> u32;\n-    /// Returns the group ID of the file owner.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_gid());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_gid(&self) -> u32;\n-    /// Returns the device ID that this file represents. Only relevant for special file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_rdev());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_rdev(&self) -> u64;\n-    /// Returns the size of the file (if it is a regular file or a symbolic link) in bytes.\n-    ///\n-    /// The size of a symbolic link is the length of the pathname it contains,\n-    /// without a terminating null byte.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_size());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_size(&self) -> u64;\n-    /// Returns the last access time.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_atime());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_atime(&self) -> i64;\n-    /// Returns the last access time, nano seconds part.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_atime_nsec());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_atime_nsec(&self) -> i64;\n-    /// Returns the last modification time.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_mtime());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_mtime(&self) -> i64;\n-    /// Returns the last modification time, nano seconds part.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_mtime_nsec());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_mtime_nsec(&self) -> i64;\n-    /// Returns the last status change time.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_ctime());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_ctime(&self) -> i64;\n-    /// Returns the last status change time, nano seconds part.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_ctime_nsec());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_ctime_nsec(&self) -> i64;\n-    /// Returns the \"preferred\" blocksize for efficient filesystem I/O.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_blksize());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_blksize(&self) -> u64;\n-    /// Returns the number of blocks allocated to the file, 512-byte units.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::io;\n-    /// use std::os::linux::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     println!(\"{}\", meta.st_blocks());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_blocks(&self) -> u64;\n-}\n-\n-#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-impl MetadataExt for Metadata {\n-    #[allow(deprecated)]\n-    fn as_raw_stat(&self) -> &raw::stat {\n-        unsafe {\n-            &*(self.as_inner().as_inner() as *const libc::stat64\n-                                          as *const raw::stat)\n-        }\n-    }\n-    fn st_dev(&self) -> u64 {\n-        self.as_inner().as_inner().st_dev as u64\n-    }\n-    fn st_ino(&self) -> u64 {\n-        self.as_inner().as_inner().st_ino as u64\n-    }\n-    fn st_mode(&self) -> u32 {\n-        self.as_inner().as_inner().st_mode as u32\n-    }\n-    fn st_nlink(&self) -> u64 {\n-        self.as_inner().as_inner().st_nlink as u64\n-    }\n-    fn st_uid(&self) -> u32 {\n-        self.as_inner().as_inner().st_uid as u32\n-    }\n-    fn st_gid(&self) -> u32 {\n-        self.as_inner().as_inner().st_gid as u32\n-    }\n-    fn st_rdev(&self) -> u64 {\n-        self.as_inner().as_inner().st_rdev as u64\n-    }\n-    fn st_size(&self) -> u64 {\n-        self.as_inner().as_inner().st_size as u64\n-    }\n-    fn st_atime(&self) -> i64 {\n-        self.as_inner().as_inner().st_atime as i64\n-    }\n-    fn st_atime_nsec(&self) -> i64 {\n-        self.as_inner().as_inner().st_atime_nsec as i64\n-    }\n-    fn st_mtime(&self) -> i64 {\n-        self.as_inner().as_inner().st_mtime as i64\n-    }\n-    fn st_mtime_nsec(&self) -> i64 {\n-        self.as_inner().as_inner().st_mtime_nsec as i64\n-    }\n-    fn st_ctime(&self) -> i64 {\n-        self.as_inner().as_inner().st_ctime as i64\n-    }\n-    fn st_ctime_nsec(&self) -> i64 {\n-        self.as_inner().as_inner().st_ctime_nsec as i64\n-    }\n-    fn st_blksize(&self) -> u64 {\n-        self.as_inner().as_inner().st_blksize as u64\n-    }\n-    fn st_blocks(&self) -> u64 {\n-        self.as_inner().as_inner().st_blocks as u64\n-    }\n-}"}, {"sha": "4dee2a6d43397313e2c68b105bfd9007ba976fb1", "filename": "src/libstd/os/hermit/mod.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46e6c533d08a2c6d22083a2756a0b569e001c3c4/src%2Flibstd%2Fos%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46e6c533d08a2c6d22083a2756a0b569e001c3c4/src%2Flibstd%2Fos%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fhermit%2Fmod.rs?ref=46e6c533d08a2c6d22083a2756a0b569e001c3c4", "patch": "@@ -1,6 +0,0 @@\n-//! HermitCore-specific definitions\n-\n-#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-\n-pub mod raw;\n-pub mod fs;"}, {"sha": "0e232a808a09766a004ea36776a585dbdb8e69e8", "filename": "src/libstd/os/hermit/raw.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/46e6c533d08a2c6d22083a2756a0b569e001c3c4/src%2Flibstd%2Fos%2Fhermit%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46e6c533d08a2c6d22083a2756a0b569e001c3c4/src%2Flibstd%2Fos%2Fhermit%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fhermit%2Fraw.rs?ref=46e6c533d08a2c6d22083a2756a0b569e001c3c4", "patch": "@@ -1,17 +0,0 @@\n-//! HermitCore-specific raw type definitions\n-\n-#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-#![rustc_deprecated(since = \"1.8.0\",\n-                    reason = \"these type aliases are no longer supported by \\\n-                              the standard library, the `libc` crate on \\\n-                              crates.io should be used instead for the correct \\\n-                              definitions\")]\n-#![allow(deprecated)]\n-#![allow(missing_debug_implementations)]\n-\n-#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n-pub use libc::pthread_t;\n-\n-#[doc(inline)]\n-#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-pub use libc::{dev_t, mode_t, off_t, ino_t, nlink_t, blksize_t, blkcnt_t, stat, time_t};"}, {"sha": "d44c8ca544e807076f9dbd69b1c3fa1f44f5cbe3", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -49,7 +49,6 @@ cfg_if::cfg_if! {\n #[cfg(target_os = \"solaris\")]    pub mod solaris;\n #[cfg(target_os = \"emscripten\")] pub mod emscripten;\n #[cfg(target_os = \"fuchsia\")]    pub mod fuchsia;\n-#[cfg(target_os = \"hermit\")]     pub mod hermit;\n #[cfg(target_os = \"redox\")]      pub mod redox;\n #[cfg(target_os = \"wasi\")]       pub mod wasi;\n #[cfg(target_os = \"vxworks\")]    pub mod vxworks;"}, {"sha": "86cc44636328877ec626344dfb14b1024febcd25", "filename": "src/libstd/sys/hermit/alloc.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Falloc.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,35 @@\n+use crate::alloc::{GlobalAlloc, Layout, System};\n+use crate::ptr;\n+use crate::sys::hermit::abi;\n+\n+#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+unsafe impl GlobalAlloc for System {\n+    #[inline]\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        abi::malloc(layout.size(), layout.align())\n+    }\n+\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+        let addr = abi::malloc(layout.size(), layout.align());\n+\n+        if !addr.is_null() {\n+            ptr::write_bytes(\n+                addr,\n+                0x00,\n+                layout.size()\n+            );\n+        }\n+\n+        addr\n+    }\n+\n+    #[inline]\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+        abi::free(ptr, layout.size(), layout.align())\n+    }\n+\n+    #[inline]\n+    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+        abi::realloc(ptr, layout.size(), layout.align(), new_size)\n+    }\n+}"}, {"sha": "5b1f3add51fe06c9c172de361bfea597a8e928c0", "filename": "src/libstd/sys/hermit/args.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fargs.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,82 @@\n+use crate::ffi::OsString;\n+use crate::marker::PhantomData;\n+use crate::vec;\n+\n+/// One-time global initialization.\n+pub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv) }\n+\n+/// One-time global cleanup.\n+pub unsafe fn cleanup() { imp::cleanup() }\n+\n+/// Returns the command line arguments\n+pub fn args() -> Args {\n+    imp::args()\n+}\n+\n+pub struct Args {\n+    iter: vec::IntoIter<OsString>,\n+    _dont_send_or_sync_me: PhantomData<*mut ()>,\n+}\n+\n+impl Args {\n+    pub fn inner_debug(&self) -> &[OsString] {\n+        self.iter.as_slice()\n+    }\n+}\n+\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+impl ExactSizeIterator for Args {\n+    fn len(&self) -> usize { self.iter.len() }\n+}\n+\n+impl DoubleEndedIterator for Args {\n+    fn next_back(&mut self) -> Option<OsString> { self.iter.next_back() }\n+}\n+\n+mod imp {\n+    use crate::sys_common::os_str_bytes::*;\n+    use crate::ptr;\n+    use crate::ffi::{CStr, OsString};\n+    use crate::marker::PhantomData;\n+    use super::Args;\n+\n+    use crate::sys_common::mutex::Mutex;\n+\n+    static mut ARGC: isize = 0;\n+    static mut ARGV: *const *const u8 = ptr::null();\n+    static LOCK: Mutex = Mutex::new();\n+\n+    pub unsafe fn init(argc: isize, argv: *const *const u8) {\n+        let _guard = LOCK.lock();\n+        ARGC = argc;\n+        ARGV = argv;\n+    }\n+\n+    pub unsafe fn cleanup() {\n+        let _guard = LOCK.lock();\n+        ARGC = 0;\n+        ARGV = ptr::null();\n+    }\n+\n+    pub fn args() -> Args {\n+        Args {\n+            iter: clone().into_iter(),\n+            _dont_send_or_sync_me: PhantomData\n+        }\n+    }\n+\n+    fn clone() -> Vec<OsString> {\n+        unsafe {\n+            let _guard = LOCK.lock();\n+            (0..ARGC).map(|i| {\n+                let cstr = CStr::from_ptr(*ARGV.offset(i) as *const i8);\n+                OsStringExt::from_vec(cstr.to_bytes().to_vec())\n+            }).collect()\n+        }\n+    }\n+}"}, {"sha": "fa7783122c2e9baad872c6d928c3bb3372421ffb", "filename": "src/libstd/sys/hermit/cmath.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fcmath.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,29 @@\n+// These symbols are all defined in `compiler-builtins`\n+extern {\n+    pub fn acos(n: f64) -> f64;\n+    pub fn acosf(n: f32) -> f32;\n+    pub fn asin(n: f64) -> f64;\n+    pub fn asinf(n: f32) -> f32;\n+    pub fn atan(n: f64) -> f64;\n+    pub fn atan2(a: f64, b: f64) -> f64;\n+    pub fn atan2f(a: f32, b: f32) -> f32;\n+    pub fn atanf(n: f32) -> f32;\n+    pub fn cbrt(n: f64) -> f64;\n+    pub fn cbrtf(n: f32) -> f32;\n+    pub fn cosh(n: f64) -> f64;\n+    pub fn coshf(n: f32) -> f32;\n+    pub fn expm1(n: f64) -> f64;\n+    pub fn expm1f(n: f32) -> f32;\n+    pub fn fdim(a: f64, b: f64) -> f64;\n+    pub fn fdimf(a: f32, b: f32) -> f32;\n+    pub fn hypot(x: f64, y: f64) -> f64;\n+    pub fn hypotf(x: f32, y: f32) -> f32;\n+    pub fn log1p(n: f64) -> f64;\n+    pub fn log1pf(n: f32) -> f32;\n+    pub fn sinh(n: f64) -> f64;\n+    pub fn sinhf(n: f32) -> f32;\n+    pub fn tan(n: f64) -> f64;\n+    pub fn tanf(n: f32) -> f32;\n+    pub fn tanh(n: f64) -> f64;\n+    pub fn tanhf(n: f32) -> f32;\n+}"}, {"sha": "8e52b3da1b170e6cef9fa5293ce92c2c6b28ab23", "filename": "src/libstd/sys/hermit/condvar.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,62 @@\n+use crate::cmp;\n+use crate::sys::hermit::abi;\n+use crate::sys::mutex::Mutex;\n+use crate::time::Duration;\n+\n+pub struct Condvar {\n+    identifier: usize,\n+}\n+\n+impl Condvar {\n+    pub const fn new() -> Condvar {\n+        Condvar { identifier: 0 }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&mut self) {\n+        // nothing to do\n+    }\n+\n+    pub unsafe fn notify_one(&self) {\n+         let _ = abi::notify(self.id(), 1);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn notify_all(&self) {\n+         let _ = abi::notify(self.id(), -1 /* =all */);\n+    }\n+\n+    pub unsafe fn wait(&self, mutex: &Mutex) {\n+        // add current task to the wait queue\n+        let _ = abi::add_queue(self.id(), -1 /* no timeout */);\n+        mutex.unlock();\n+        let _ = abi::wait(self.id());\n+        mutex.lock();\n+    }\n+\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n+        let nanos = dur.as_nanos();\n+        let nanos = cmp::min(i64::max_value() as u128, nanos);\n+\n+        // add current task to the wait queue\n+        let _ = abi::add_queue(self.id(), nanos as i64);\n+\n+        mutex.unlock();\n+        // If the return value is !0 then a timeout happened, so we return\n+        // `false` as we weren't actually notified.\n+        let ret = abi::wait(self.id()) == 0;\n+        mutex.lock();\n+\n+        ret\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        let _ = abi::destroy_queue(self.id());\n+    }\n+\n+    #[inline]\n+    fn id(&self) -> usize {\n+        &self.identifier as *const usize as usize\n+    }\n+}"}, {"sha": "7a0fcb31ef2e87a66f2768aa263b8bf953ad28ca", "filename": "src/libstd/sys/hermit/env.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fenv.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,9 @@\n+pub mod os {\n+    pub const FAMILY: &str = \"\";\n+    pub const OS: &str = \"hermit\";\n+    pub const DLL_PREFIX: &str = \"\";\n+    pub const DLL_SUFFIX: &str = \"\";\n+    pub const DLL_EXTENSION: &str = \"\";\n+    pub const EXE_SUFFIX: &str = \"\";\n+    pub const EXE_EXTENSION: &str = \"\";\n+}"}, {"sha": "05464787a05d3c594f5bdd203715bff88b460d47", "filename": "src/libstd/sys/hermit/fast_thread_local.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Ffast_thread_local.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,4 @@\n+#![cfg(target_thread_local)]\n+#![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n+\n+pub use crate::sys_common::thread_local::register_dtor_fallback as register_dtor;"}, {"sha": "84c547366473a1994cc4d02ed26d95f675f6358b", "filename": "src/libstd/sys/hermit/fd.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Ffd.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,82 @@\n+#![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n+\n+use crate::io::{self, Read, ErrorKind};\n+use crate::mem;\n+use crate::sys::cvt;\n+use crate::sys::hermit::abi;\n+use crate::sys_common::AsInner;\n+\n+#[derive(Debug)]\n+pub struct FileDesc {\n+    fd: i32,\n+}\n+\n+impl FileDesc {\n+    pub fn new(fd: i32) -> FileDesc {\n+        FileDesc { fd }\n+    }\n+\n+    pub fn raw(&self) -> i32 { self.fd }\n+\n+    /// Extracts the actual file descriptor without closing it.\n+    pub fn into_raw(self) -> i32 {\n+        let fd = self.fd;\n+        mem::forget(self);\n+        fd\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        let result = unsafe { abi::read(self.fd, buf.as_mut_ptr(), buf.len()) };\n+        cvt(result as i32)\n+    }\n+\n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        let mut me = self;\n+        (&mut me).read_to_end(buf)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        let result = unsafe { abi::write(self.fd, buf.as_ptr(), buf.len()) };\n+        cvt(result as i32)\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<FileDesc> {\n+        self.duplicate_path(&[])\n+    }\n+    pub fn duplicate_path(&self, _path: &[u8]) -> io::Result<FileDesc> {\n+        Err(io::Error::new(ErrorKind::Other, \"duplicate isn't supported\"))\n+    }\n+\n+    pub fn nonblocking(&self) -> io::Result<bool> {\n+        Ok(false)\n+    }\n+\n+    pub fn set_cloexec(&self) -> io::Result<()> {\n+        Err(io::Error::new(ErrorKind::Other, \"cloexec isn't supported\"))\n+    }\n+\n+    pub fn set_nonblocking(&self, _nonblocking: bool) -> io::Result<()> {\n+        Err(io::Error::new(ErrorKind::Other, \"nonblocking isn't supported\"))\n+    }\n+}\n+\n+impl<'a> Read for &'a FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        (**self).read(buf)\n+    }\n+}\n+\n+impl AsInner<i32> for FileDesc {\n+    fn as_inner(&self) -> &i32 { &self.fd }\n+}\n+\n+impl Drop for FileDesc {\n+    fn drop(&mut self) {\n+        // Note that errors are ignored when closing a file descriptor. The\n+        // reason for this is that if an error occurs we don't actually know if\n+        // the file descriptor was closed or not, and if we retried (for\n+        // something like EINTR), we might close another valid file descriptor\n+        // (opened after we closed ours.\n+        let _ = unsafe { abi::close(self.fd) };\n+    }\n+}"}, {"sha": "f8e5844a1678d766e9b286e296e7f19fedc495ea", "filename": "src/libstd/sys/hermit/fs.rs", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Ffs.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,387 @@\n+use crate::ffi::{OsString, CString, CStr};\n+use crate::fmt;\n+use crate::io::{self, Error, ErrorKind};\n+use crate::hash::{Hash, Hasher};\n+use crate::io::{SeekFrom, IoSlice, IoSliceMut};\n+use crate::path::{Path, PathBuf};\n+use crate::sys::time::SystemTime;\n+use crate::sys::{unsupported, Void};\n+use crate::sys::hermit::abi;\n+use crate::sys::hermit::fd::FileDesc;\n+use crate::sys::cvt;\n+use crate::sys_common::os_str_bytes::OsStrExt;\n+\n+pub use crate::sys_common::fs::copy;\n+//pub use crate::sys_common::fs::remove_dir_all;\n+\n+fn cstr(path: &Path) -> io::Result<CString> {\n+    Ok(CString::new(path.as_os_str().as_bytes())?)\n+}\n+//const O_ACCMODE: i32 = 00000003;\n+const O_RDONLY: i32 = 00000000;\n+const O_WRONLY: i32 = 00000001;\n+const O_RDWR: i32 = 00000002;\n+const O_CREAT: i32 = 00000100;\n+const O_EXCL: i32 = 00000200;\n+const O_TRUNC: i32 = 00001000;\n+const O_APPEND: i32 = 00002000;\n+\n+#[derive(Debug)]\n+pub struct File(FileDesc);\n+\n+pub struct FileAttr(Void);\n+\n+pub struct ReadDir(Void);\n+\n+pub struct DirEntry(Void);\n+\n+#[derive(Clone, Debug)]\n+pub struct OpenOptions {\n+    // generic\n+    read: bool,\n+    write: bool,\n+    append: bool,\n+    truncate: bool,\n+    create: bool,\n+    create_new: bool,\n+    // system-specific\n+    mode: i32\n+}\n+\n+pub struct FilePermissions(Void);\n+\n+pub struct FileType(Void);\n+\n+#[derive(Debug)]\n+pub struct DirBuilder { }\n+\n+impl FileAttr {\n+    pub fn size(&self) -> u64 {\n+        match self.0 {}\n+    }\n+\n+    pub fn perm(&self) -> FilePermissions {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_type(&self) -> FileType {\n+        match self.0 {}\n+    }\n+\n+    pub fn modified(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+\n+    pub fn accessed(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+\n+    pub fn created(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FileAttr {\n+    fn clone(&self) -> FileAttr {\n+        match self.0 {}\n+    }\n+}\n+\n+impl FilePermissions {\n+    pub fn readonly(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_readonly(&mut self, _readonly: bool) {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FilePermissions {\n+    fn clone(&self) -> FilePermissions {\n+        match self.0 {}\n+    }\n+}\n+\n+impl PartialEq for FilePermissions {\n+    fn eq(&self, _other: &FilePermissions) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for FilePermissions {\n+}\n+\n+impl fmt::Debug for FilePermissions {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl FileType {\n+    pub fn is_dir(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn is_file(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn is_symlink(&self) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FileType {\n+    fn clone(&self) -> FileType {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Copy for FileType {}\n+\n+impl PartialEq for FileType {\n+    fn eq(&self, _other: &FileType) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for FileType {\n+}\n+\n+impl Hash for FileType {\n+    fn hash<H: Hasher>(&self, _h: &mut H) {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for FileType {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for ReadDir {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Iterator for ReadDir {\n+    type Item = io::Result<DirEntry>;\n+\n+    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl DirEntry {\n+    pub fn path(&self) -> PathBuf {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_name(&self) -> OsString {\n+        match self.0 {}\n+    }\n+\n+    pub fn metadata(&self) -> io::Result<FileAttr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_type(&self) -> io::Result<FileType> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl OpenOptions {\n+    pub fn new() -> OpenOptions {\n+        OpenOptions {\n+            // generic\n+            read: false,\n+            write: false,\n+            append: false,\n+            truncate: false,\n+            create: false,\n+            create_new: false,\n+            // system-specific\n+            mode: 0x777\n+        }\n+    }\n+\n+    pub fn read(&mut self, read: bool) { self.read = read; }\n+    pub fn write(&mut self, write: bool) { self.write = write; }\n+    pub fn append(&mut self, append: bool) { self.append = append; }\n+    pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }\n+    pub fn create(&mut self, create: bool) { self.create = create; }\n+    pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }\n+\n+    fn get_access_mode(&self) -> io::Result<i32> {\n+        match (self.read, self.write, self.append) {\n+            (true,  false, false) => Ok(O_RDONLY),\n+            (false, true,  false) => Ok(O_WRONLY),\n+            (true,  true,  false) => Ok(O_RDWR),\n+            (false, _,     true)  => Ok(O_WRONLY | O_APPEND),\n+            (true,  _,     true)  => Ok(O_RDWR | O_APPEND),\n+            (false, false, false) => {\n+                Err(io::Error::new(ErrorKind::InvalidInput, \"invalid access mode\"))\n+            },\n+        }\n+    }\n+\n+    fn get_creation_mode(&self) -> io::Result<i32> {\n+        match (self.write, self.append) {\n+            (true, false) => {}\n+            (false, false) =>\n+                if self.truncate || self.create || self.create_new {\n+                    return Err(io::Error::new(ErrorKind::InvalidInput, \"invalid creation mode\"));\n+                },\n+            (_, true) =>\n+                if self.truncate && !self.create_new {\n+                    return Err(io::Error::new(ErrorKind::InvalidInput, \"invalid creation mode\"));\n+                },\n+        }\n+\n+        Ok(match (self.create, self.truncate, self.create_new) {\n+                (false, false, false) => 0,\n+                (true,  false, false) => O_CREAT,\n+                (false, true,  false) => O_TRUNC,\n+                (true,  true,  false) => O_CREAT | O_TRUNC,\n+                (_,      _,    true)  => O_CREAT | O_EXCL,\n+           })\n+    }\n+}\n+\n+impl File {\n+    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n+        let path = cstr(path)?;\n+        File::open_c(&path, opts)\n+    }\n+\n+    pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n+        let mut flags = opts.get_access_mode()?;\n+        flags = flags | opts.get_creation_mode()?;\n+\n+        let mode;\n+        if flags & O_CREAT == O_CREAT {\n+            mode = opts.mode;\n+        } else {\n+            mode = 0;\n+        }\n+\n+        let fd = unsafe { cvt(abi::open(path.as_ptr(), flags, mode))? };\n+        Ok(File(FileDesc::new(fd as i32)))\n+    }\n+\n+    pub fn file_attr(&self) -> io::Result<FileAttr> {\n+        Err(Error::from_raw_os_error(22))\n+    }\n+\n+    pub fn fsync(&self) -> io::Result<()> {\n+        Err(Error::from_raw_os_error(22))\n+    }\n+\n+    pub fn datasync(&self) -> io::Result<()> {\n+        self.fsync()\n+    }\n+\n+    pub fn truncate(&self, _size: u64) -> io::Result<()> {\n+        Err(Error::from_raw_os_error(22))\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        crate::io::default_read_vectored(|buf| self.read(buf), bufs)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        crate::io::default_write_vectored(|buf| self.write(buf), bufs)\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n+\n+    pub fn seek(&self, _pos: SeekFrom) -> io::Result<u64> {\n+        Err(Error::from_raw_os_error(22))\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<File> {\n+        Err(Error::from_raw_os_error(22))\n+    }\n+\n+    pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n+        Err(Error::from_raw_os_error(22))\n+    }\n+\n+    pub fn diverge(&self) -> ! {\n+        loop {}\n+    }\n+}\n+\n+impl DirBuilder {\n+    pub fn new() -> DirBuilder {\n+        DirBuilder { }\n+    }\n+\n+    pub fn mkdir(&self, _p: &Path) -> io::Result<()> {\n+        unsupported()\n+    }\n+}\n+\n+pub fn readdir(_p: &Path) -> io::Result<ReadDir> {\n+    unsupported()\n+}\n+\n+pub fn unlink(path: &Path) -> io::Result<()> {\n+    let name = cstr(path)?;\n+    let _ = unsafe { cvt(abi::unlink(name.as_ptr()))? };\n+    Ok(())\n+}\n+\n+pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn set_perm(_p: &Path, perm: FilePermissions) -> io::Result<()> {\n+    match perm.0 {}\n+}\n+\n+pub fn rmdir(_p: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn remove_dir_all(_path: &Path) -> io::Result<()> {\n+    //unsupported()\n+    Ok(())\n+}\n+\n+pub fn readlink(_p: &Path) -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn symlink(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn stat(_p: &Path) -> io::Result<FileAttr> {\n+    unsupported()\n+}\n+\n+pub fn lstat(_p: &Path) -> io::Result<FileAttr> {\n+    unsupported()\n+}\n+\n+pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n+    unsupported()\n+}"}, {"sha": "976e122463d1b80ea9f60350ffb8dad875e9b741", "filename": "src/libstd/sys/hermit/io.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fio.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,46 @@\n+use crate::mem;\n+\n+pub struct IoSlice<'a>(&'a [u8]);\n+\n+impl<'a> IoSlice<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n+        IoSlice(buf)\n+    }\n+\n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        self.0 = &self.0[n..]\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        self.0\n+    }\n+}\n+\n+pub struct IoSliceMut<'a>(&'a mut [u8]);\n+\n+impl<'a> IoSliceMut<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n+        IoSliceMut(buf)\n+    }\n+\n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        let slice = mem::replace(&mut self.0, &mut []);\n+        let (_, remaining) = slice.split_at_mut(n);\n+        self.0 = remaining;\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        self.0\n+    }\n+\n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n+        self.0\n+    }\n+}"}, {"sha": "9967482197eb3642a1e1fef3d1cdc04b9c05711d", "filename": "src/libstd/sys/hermit/memchr.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fmemchr.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1 @@\n+pub use core::slice::memchr::{memchr, memrchr};"}, {"sha": "d4359631769da2c0f093e7019fadbae1b26d1dcf", "filename": "src/libstd/sys/hermit/mod.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fmod.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,147 @@\n+//! System bindings for HermitCore\n+//!\n+//! This module contains the facade (aka platform-specific) implementations of\n+//! OS level functionality for HermitCore.\n+//!\n+//! This is all super highly experimental and not actually intended for\n+//! wide/production use yet, it's still all in the experimental category. This\n+//! will likely change over time.\n+//!\n+//! Currently all functions here are basically stubs that immediately return\n+//! errors. The hope is that with a portability lint we can turn actually just\n+//! remove all this and just omit parts of the standard library if we're\n+//! compiling for wasm. That way it's a compile time error for something that's\n+//! guaranteed to be a runtime error!\n+\n+use crate::os::raw::c_char;\n+use crate::intrinsics;\n+\n+pub mod alloc;\n+pub mod args;\n+pub mod condvar;\n+pub mod stdio;\n+pub mod memchr;\n+pub mod io;\n+pub mod mutex;\n+pub mod rwlock;\n+pub mod os;\n+pub mod cmath;\n+pub mod thread;\n+pub mod env;\n+pub mod fs;\n+pub mod fd;\n+pub mod net;\n+pub mod path;\n+pub mod pipe;\n+pub mod process;\n+pub mod stack_overflow;\n+pub mod time;\n+pub mod thread_local;\n+pub mod fast_thread_local;\n+\n+pub use crate::sys_common::os_str_bytes as os_str;\n+use crate::io::ErrorKind;\n+\n+#[allow(unused_extern_crates)]\n+pub extern crate hermit_abi as abi;\n+\n+pub fn unsupported<T>() -> crate::io::Result<T> {\n+    Err(unsupported_err())\n+}\n+\n+pub fn unsupported_err() -> crate::io::Error {\n+    crate::io::Error::new(crate::io::ErrorKind::Other,\n+           \"operation not supported on HermitCore yet\")\n+}\n+\n+// This enum is used as the storage for a bunch of types which can't actually\n+// exist.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub enum Void {}\n+\n+pub unsafe fn strlen(start: *const c_char) -> usize {\n+    let mut str = start;\n+\n+    while *str != 0 {\n+        str = str.offset(1);\n+    }\n+\n+    (str as usize) - (start as usize)\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn floor(x: f64) -> f64 {\n+    unsafe {\n+        intrinsics::floorf64(x)\n+    }\n+}\n+\n+pub unsafe fn abort_internal() -> ! {\n+    abi::abort();\n+}\n+\n+// FIXME: just a workaround to test the system\n+pub fn hashmap_random_keys() -> (u64, u64) {\n+    (1, 2)\n+}\n+\n+// This function is needed by the panic runtime. The symbol is named in\n+// pre-link args for the target specification, so keep that in sync.\n+#[cfg(not(test))]\n+#[no_mangle]\n+// NB. used by both libunwind and libpanic_abort\n+pub unsafe extern \"C\" fn __rust_abort() {\n+    abort_internal();\n+}\n+\n+#[cfg(not(test))]\n+pub fn init() {\n+    unsafe {\n+        let _ = net::init();\n+    }\n+}\n+\n+#[cfg(not(test))]\n+#[no_mangle]\n+pub unsafe extern \"C\" fn runtime_entry(argc: i32, argv: *const *const c_char,\n+                                       env: *const *const c_char) -> ! {\n+    extern \"C\" {\n+        fn main(argc: isize, argv: *const *const c_char) -> i32;\n+    }\n+\n+    // initialize environment\n+    os::init_environment(env as *const *const i8);\n+\n+    let result = main(argc as isize, argv);\n+\n+    abi::exit(result);\n+}\n+\n+pub fn decode_error_kind(errno: i32) -> ErrorKind {\n+    match errno {\n+        x if x == 13 as i32 => ErrorKind::PermissionDenied,\n+        x if x == 98 as i32 => ErrorKind::AddrInUse,\n+        x if x == 99 as i32 => ErrorKind::AddrNotAvailable,\n+        x if x == 11 as i32 => ErrorKind::WouldBlock,\n+        x if x == 103 as i32 => ErrorKind::ConnectionAborted,\n+        x if x == 111 as i32 => ErrorKind::ConnectionRefused,\n+        x if x == 104 as i32 => ErrorKind::ConnectionReset,\n+        x if x == 17 as i32 => ErrorKind::AlreadyExists,\n+        x if x == 4 as i32 => ErrorKind::Interrupted,\n+        x if x == 22 as i32 => ErrorKind::InvalidInput,\n+        x if x == 2 as i32 => ErrorKind::NotFound,\n+        x if x == 107 as i32 => ErrorKind::NotConnected,\n+        x if x == 1 as i32 => ErrorKind::PermissionDenied,\n+        x if x == 32 as i32 => ErrorKind::BrokenPipe,\n+        x if x == 110 as i32 => ErrorKind::TimedOut,\n+        _ => ErrorKind::Other,\n+    }\n+}\n+\n+pub fn cvt(result: i32) -> crate::io::Result<usize> {\n+    if result < 0 {\n+        Err(crate::io::Error::from_raw_os_error(-result))\n+    } else {\n+        Ok(result as usize)\n+    }\n+}"}, {"sha": "9414bf8fbbbd4c7411a468e3777dace47d891524", "filename": "src/libstd/sys/hermit/mutex.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fmutex.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,77 @@\n+use crate::ptr;\n+use crate::ffi::c_void;\n+use crate::sys::hermit::abi;\n+\n+pub struct Mutex {\n+    inner: *const c_void\n+}\n+\n+unsafe impl Send for Mutex {}\n+unsafe impl Sync for Mutex {}\n+\n+impl Mutex {\n+    pub const fn new() -> Mutex {\n+        Mutex { inner: ptr::null() }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&mut self) {\n+        let _ = abi::sem_init(&mut self.inner as *mut *const c_void, 1);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn lock(&self) {\n+        let _ = abi::sem_timedwait(self.inner, 0);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn unlock(&self) {\n+        let _ = abi::sem_post(self.inner);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        let result = abi::sem_trywait(self.inner);\n+        result == 0\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        let _ = abi::sem_destroy(self.inner);\n+    }\n+}\n+\n+pub struct ReentrantMutex {\n+    inner: *const c_void\n+}\n+\n+impl ReentrantMutex {\n+    pub unsafe fn uninitialized() -> ReentrantMutex {\n+        ReentrantMutex { inner: ptr::null() }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&mut self) {\n+        let _ = abi::recmutex_init(&mut self.inner as *mut *const c_void);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn lock(&self) {\n+        let _ = abi::recmutex_lock(self.inner);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        true\n+    }\n+\n+    #[inline]\n+    pub unsafe fn unlock(&self) {\n+        let _ = abi::recmutex_unlock(self.inner);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        let _ = abi::recmutex_destroy(self.inner);\n+    }\n+}"}, {"sha": "5b7ff642271c5e8e0acee268d42848a49c04ee93", "filename": "src/libstd/sys/hermit/net.rs", "status": "added", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,364 @@\n+use crate::fmt;\n+use crate::convert::TryFrom;\n+use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n+use crate::str;\n+use crate::sys::{unsupported, Void};\n+use crate::time::Duration;\n+\n+//// Iinitializes HermitCore's network stack\n+pub unsafe fn init() -> io::Result<()> {\n+    Ok(())\n+}\n+\n+pub struct TcpStream(Void);\n+\n+impl TcpStream {\n+    pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n+        unsupported()\n+    }\n+\n+    pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {\n+        unsupported()\n+    }\n+\n+    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read_vectored(&self, _: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write_vectored(&self, _: &[IoSlice<'_>]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<TcpStream> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn nodelay(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for TcpStream {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct TcpListener(Void);\n+\n+impl TcpListener {\n+    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n+        unsupported()\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<TcpListener> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn only_v6(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for TcpListener {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct UdpSocket(Void);\n+\n+impl UdpSocket {\n+    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n+        unsupported()\n+    }\n+\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        match self.0 {}\n+    }\n+\n+    pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<UdpSocket> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn broadcast(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n+                         -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n+                         -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n+                          -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n+                          -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for UdpSocket {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct LookupHost(Void);\n+\n+impl LookupHost {\n+    pub fn port(&self) -> u16 {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Iterator for LookupHost {\n+    type Item = SocketAddr;\n+    fn next(&mut self) -> Option<SocketAddr> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl TryFrom<&str> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from(_v: &str) -> io::Result<LookupHost> {\n+        unsupported()\n+    }\n+}\n+\n+impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {\n+        unsupported()\n+    }\n+}\n+\n+#[allow(nonstandard_style)]\n+pub mod netc {\n+    pub const AF_INET: u8 = 0;\n+    pub const AF_INET6: u8 = 1;\n+    pub type sa_family_t = u8;\n+\n+    #[derive(Copy, Clone)]\n+    pub struct in_addr {\n+        pub s_addr: u32,\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    pub struct sockaddr_in {\n+        pub sin_family: sa_family_t,\n+        pub sin_port: u16,\n+        pub sin_addr: in_addr,\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    pub struct in6_addr {\n+        pub s6_addr: [u8; 16],\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    pub struct sockaddr_in6 {\n+        pub sin6_family: sa_family_t,\n+        pub sin6_port: u16,\n+        pub sin6_addr: in6_addr,\n+        pub sin6_flowinfo: u32,\n+        pub sin6_scope_id: u32,\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    pub struct sockaddr {\n+    }\n+\n+    pub type socklen_t = usize;\n+}"}, {"sha": "8a25cbcf07b9cc35cfb59bedf7223bd87d77aa45", "filename": "src/libstd/sys/hermit/os.rs", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fos.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,174 @@\n+use crate::error::Error as StdError;\n+use crate::ffi::{CStr, OsString, OsStr};\n+use crate::fmt;\n+use crate::io;\n+use crate::marker::PhantomData;\n+use crate::memchr;\n+use crate::path::{self, PathBuf};\n+use crate::ptr;\n+use crate::str;\n+use crate::sys::{unsupported, Void};\n+use crate::collections::HashMap;\n+use crate::vec;\n+use crate::sync::Mutex;\n+use crate::sys_common::os_str_bytes::*;\n+use crate::sys::hermit::abi;\n+\n+pub fn errno() -> i32 {\n+    0\n+}\n+\n+pub fn error_string(_errno: i32) -> String {\n+    \"operation successful\".to_string()\n+}\n+\n+pub fn getcwd() -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn chdir(_: &path::Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub struct SplitPaths<'a>(&'a Void);\n+\n+pub fn split_paths(_unparsed: &OsStr) -> SplitPaths<'_> {\n+    panic!(\"unsupported\")\n+}\n+\n+impl<'a> Iterator for SplitPaths<'a> {\n+    type Item = PathBuf;\n+    fn next(&mut self) -> Option<PathBuf> {\n+        match *self.0 {}\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct JoinPathsError;\n+\n+pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\n+    where I: Iterator<Item=T>, T: AsRef<OsStr>\n+{\n+    Err(JoinPathsError)\n+}\n+\n+impl fmt::Display for JoinPathsError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        \"not supported on hermit yet\".fmt(f)\n+    }\n+}\n+\n+impl StdError for JoinPathsError {\n+    fn description(&self) -> &str {\n+        \"not supported on hermit yet\"\n+    }\n+}\n+\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+static mut ENV: Option<Mutex<HashMap<OsString, OsString>>> = None;\n+\n+pub fn init_environment(env: *const *const i8) {\n+    unsafe {\n+        ENV = Some(Mutex::new(HashMap::new()));\n+\n+        let mut guard = ENV.as_ref().unwrap().lock().unwrap();\n+        let mut environ = env;\n+        while environ != ptr::null() && *environ != ptr::null() {\n+            if let Some((key,value)) = parse(CStr::from_ptr(*environ).to_bytes()) {\n+                guard.insert(key, value);\n+            }\n+            environ = environ.offset(1);\n+        }\n+    }\n+\n+    fn parse(input: &[u8]) -> Option<(OsString, OsString)> {\n+        // Strategy (copied from glibc): Variable name and value are separated\n+        // by an ASCII equals sign '='. Since a variable name must not be\n+        // empty, allow variable names starting with an equals sign. Skip all\n+        // malformed lines.\n+        if input.is_empty() {\n+            return None;\n+        }\n+        let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n+        pos.map(|p| (\n+            OsStringExt::from_vec(input[..p].to_vec()),\n+            OsStringExt::from_vec(input[p+1..].to_vec()),\n+        ))\n+    }\n+}\n+\n+pub struct Env {\n+    iter: vec::IntoIter<(OsString, OsString)>,\n+    _dont_send_or_sync_me: PhantomData<*mut ()>,\n+}\n+\n+impl Iterator for Env {\n+    type Item = (OsString, OsString);\n+    fn next(&mut self) -> Option<(OsString, OsString)> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+/// Returns a vector of (variable, value) byte-vector pairs for all the\n+/// environment variables of the current process.\n+pub fn env() -> Env {\n+   unsafe {\n+        let guard = ENV.as_ref().unwrap().lock().unwrap();\n+        let mut result = Vec::new();\n+\n+        for (key, value) in guard.iter() {\n+            result.push((key.clone(), value.clone()));\n+        }\n+\n+        return Env {\n+            iter: result.into_iter(),\n+            _dont_send_or_sync_me: PhantomData,\n+        }\n+    }\n+}\n+\n+pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n+    unsafe {\n+        match ENV.as_ref().unwrap().lock().unwrap().get_mut(k) {\n+            Some(value) => { Ok(Some(value.clone())) },\n+            None => { Ok(None) },\n+        }\n+    }\n+}\n+\n+pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n+    unsafe {\n+        let (k, v) = (k.to_owned(), v.to_owned());\n+        ENV.as_ref().unwrap().lock().unwrap().insert(k, v);\n+    }\n+    Ok(())\n+}\n+\n+pub fn unsetenv(k: &OsStr) -> io::Result<()> {\n+    unsafe {\n+        ENV.as_ref().unwrap().lock().unwrap().remove(k);\n+    }\n+    Ok(())\n+}\n+\n+pub fn temp_dir() -> PathBuf {\n+    panic!(\"no filesystem on hermit\")\n+}\n+\n+pub fn home_dir() -> Option<PathBuf> {\n+    None\n+}\n+\n+pub fn exit(code: i32) -> ! {\n+    unsafe {\n+        abi::exit(code);\n+    }\n+}\n+\n+pub fn getpid() -> u32 {\n+    unsafe {\n+        abi::getpid()\n+    }\n+}"}, {"sha": "7a1839561078575c74850ce343f81b0989767916", "filename": "src/libstd/sys/hermit/path.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fpath.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,19 @@\n+use crate::path::Prefix;\n+use crate::ffi::OsStr;\n+\n+#[inline]\n+pub fn is_sep_byte(b: u8) -> bool {\n+    b == b'/'\n+}\n+\n+#[inline]\n+pub fn is_verbatim_sep(b: u8) -> bool {\n+    b == b'/'\n+}\n+\n+pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n+    None\n+}\n+\n+pub const MAIN_SEP_STR: &str = \"/\";\n+pub const MAIN_SEP: char = '/';"}, {"sha": "9f07f054362feb550124adaaf5f3951dae58ed3c", "filename": "src/libstd/sys/hermit/pipe.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fpipe.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,33 @@\n+use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::sys::Void;\n+\n+pub struct AnonPipe(Void);\n+\n+impl AnonPipe {\n+    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn diverge(&self) -> ! {\n+        match self.0 {}\n+    }\n+}\n+\n+pub fn read2(p1: AnonPipe,\n+             _v1: &mut Vec<u8>,\n+             _p2: AnonPipe,\n+             _v2: &mut Vec<u8>) -> io::Result<()> {\n+    match p1.0 {}\n+}"}, {"sha": "edf933d10e07433f52f9ae280b89b1b7d16e5658", "filename": "src/libstd/sys/hermit/process.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fprocess.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,154 @@\n+use crate::ffi::OsStr;\n+use crate::fmt;\n+use crate::io;\n+use crate::sys::fs::File;\n+use crate::sys::pipe::AnonPipe;\n+use crate::sys::{unsupported, Void};\n+use crate::sys_common::process::CommandEnv;\n+\n+pub use crate::ffi::OsString as EnvKey;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct Command {\n+    env: CommandEnv,\n+}\n+\n+// passed back to std::process with the pipes connected to the child, if any\n+// were requested\n+pub struct StdioPipes {\n+    pub stdin: Option<AnonPipe>,\n+    pub stdout: Option<AnonPipe>,\n+    pub stderr: Option<AnonPipe>,\n+}\n+\n+pub enum Stdio {\n+    Inherit,\n+    Null,\n+    MakePipe,\n+}\n+\n+impl Command {\n+    pub fn new(_program: &OsStr) -> Command {\n+        Command {\n+            env: Default::default()\n+        }\n+    }\n+\n+    pub fn arg(&mut self, _arg: &OsStr) {\n+    }\n+\n+    pub fn env_mut(&mut self) -> &mut CommandEnv {\n+        &mut self.env\n+    }\n+\n+    pub fn cwd(&mut self, _dir: &OsStr) {\n+    }\n+\n+    pub fn stdin(&mut self, _stdin: Stdio) {\n+    }\n+\n+    pub fn stdout(&mut self, _stdout: Stdio) {\n+    }\n+\n+    pub fn stderr(&mut self, _stderr: Stdio) {\n+    }\n+\n+    pub fn spawn(&mut self, _default: Stdio, _needs_stdin: bool)\n+        -> io::Result<(Process, StdioPipes)> {\n+        unsupported()\n+    }\n+}\n+\n+impl From<AnonPipe> for Stdio {\n+    fn from(pipe: AnonPipe) -> Stdio {\n+        pipe.diverge()\n+    }\n+}\n+\n+impl From<File> for Stdio {\n+    fn from(file: File) -> Stdio {\n+        file.diverge()\n+    }\n+}\n+\n+impl fmt::Debug for Command {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        Ok(())\n+    }\n+}\n+\n+pub struct ExitStatus(Void);\n+\n+impl ExitStatus {\n+    pub fn success(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn code(&self) -> Option<i32> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for ExitStatus {\n+    fn clone(&self) -> ExitStatus {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Copy for ExitStatus {}\n+\n+impl PartialEq for ExitStatus {\n+    fn eq(&self, _other: &ExitStatus) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for ExitStatus {\n+}\n+\n+impl fmt::Debug for ExitStatus {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Display for ExitStatus {\n+    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitCode(bool);\n+\n+impl ExitCode {\n+    pub const SUCCESS: ExitCode = ExitCode(false);\n+    pub const FAILURE: ExitCode = ExitCode(true);\n+\n+    pub fn as_i32(&self) -> i32 {\n+        self.0 as i32\n+    }\n+}\n+\n+pub struct Process(Void);\n+\n+impl Process {\n+    pub fn id(&self) -> u32 {\n+        match self.0 {}\n+    }\n+\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        match self.0 {}\n+    }\n+\n+    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n+        match self.0 {}\n+    }\n+}"}, {"sha": "990e7551114bbfff2611f89d42063197112ffbf7", "filename": "src/libstd/sys/hermit/rwlock.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,51 @@\n+use super::mutex::Mutex;\n+\n+pub struct RWLock {\n+    mutex: Mutex\n+}\n+\n+unsafe impl Send for RWLock {}\n+unsafe impl Sync for RWLock {}\n+\n+impl RWLock {\n+    pub const fn new() -> RWLock {\n+        RWLock {\n+            mutex: Mutex::new()\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read(&self) {\n+        self.mutex.lock();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_read(&self) -> bool {\n+        self.mutex.try_lock()\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write(&self) {\n+        self.mutex.lock();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_write(&self) -> bool {\n+        self.mutex.try_lock()\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read_unlock(&self) {\n+        self.mutex.unlock();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write_unlock(&self) {\n+        self.mutex.unlock();\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        self.mutex.destroy();\n+    }\n+}"}, {"sha": "b339e433e77dec9c55eceea5ff9348baec3457d2", "filename": "src/libstd/sys/hermit/stack_overflow.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fstack_overflow.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,15 @@\n+pub struct Handler;\n+\n+impl Handler {\n+    pub unsafe fn new() -> Handler {\n+        Handler\n+    }\n+}\n+\n+#[inline]\n+pub unsafe fn init() {\n+}\n+\n+#[inline]\n+pub unsafe fn cleanup() {\n+}"}, {"sha": "9505f02fda83bd15581c33f3a259162e7b64377b", "filename": "src/libstd/sys/hermit/stdio.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fstdio.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,119 @@\n+use crate::io;\n+use crate::io::{IoSlice, IoSliceMut};\n+use crate::sys::hermit::abi;\n+\n+pub struct Stdin;\n+pub struct Stdout;\n+pub struct Stderr;\n+\n+impl Stdin {\n+    pub fn new() -> io::Result<Stdin> {\n+        Ok(Stdin)\n+    }\n+\n+    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n+        self.read_vectored(&mut [IoSliceMut::new(data)])\n+    }\n+\n+    pub fn read_vectored(&self, _data: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        //ManuallyDrop::new(unsafe { WasiFd::from_raw(libc::STDIN_FILENO as u32) })\n+        //    .read(data)\n+        Ok(0)\n+    }\n+\n+}\n+\n+impl Stdout {\n+    pub fn new() -> io::Result<Stdout> {\n+        Ok(Stdout)\n+    }\n+\n+    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+        let len;\n+\n+        unsafe {\n+            len = abi::write(1, data.as_ptr() as *const u8, data.len())\n+        }\n+\n+        if len < 0 {\n+            Err(io::Error::new(io::ErrorKind::Other, \"Stdout is not able to print\"))\n+        } else {\n+            Ok(len as usize)\n+        }\n+    }\n+\n+    pub fn write_vectored(&self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n+        let len;\n+\n+        unsafe {\n+            len = abi::write(1, data.as_ptr() as *const u8, data.len())\n+        }\n+\n+        if len < 0 {\n+            Err(io::Error::new(io::ErrorKind::Other, \"Stdout is not able to print\"))\n+        } else {\n+            Ok(len as usize)\n+        }\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl Stderr {\n+    pub fn new() -> io::Result<Stderr> {\n+        Ok(Stderr)\n+    }\n+\n+    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+        let len;\n+\n+        unsafe {\n+            len = abi::write(2, data.as_ptr() as *const u8, data.len())\n+        }\n+\n+        if len < 0 {\n+            Err(io::Error::new(io::ErrorKind::Other, \"Stderr is not able to print\"))\n+        } else {\n+            Ok(len as usize)\n+        }\n+    }\n+\n+    pub fn write_vectored(&self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n+        let len;\n+\n+        unsafe {\n+            len = abi::write(2, data.as_ptr() as *const u8, data.len())\n+        }\n+\n+        if len < 0 {\n+            Err(io::Error::new(io::ErrorKind::Other, \"Stderr is not able to print\"))\n+        } else {\n+            Ok(len as usize)\n+        }\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl io::Write for Stderr {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        (&*self).write(data)\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        (&*self).flush()\n+    }\n+}\n+\n+pub const STDIN_BUF_SIZE: usize = 0;\n+\n+pub fn is_ebadf(_err: &io::Error) -> bool {\n+    true\n+}\n+\n+pub fn panic_output() -> Option<impl io::Write> {\n+    Stderr::new().ok()\n+}"}, {"sha": "99a9c830c9e0a0fd3567d0006ca372d5a8f41e95", "filename": "src/libstd/sys/hermit/thread.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,116 @@\n+#![allow(dead_code)]\n+\n+use crate::ffi::CStr;\n+use crate::io;\n+use crate::sys::hermit::abi;\n+use crate::time::Duration;\n+use crate::mem;\n+use crate::fmt;\n+use core::u32;\n+\n+use crate::sys_common::thread::*;\n+\n+pub type Tid = abi::Tid;\n+\n+/// Priority of a task\n+#[derive(PartialEq, Eq, PartialOrd, Ord, Debug, Clone, Copy)]\n+pub struct Priority(u8);\n+\n+impl Priority {\n+    pub const fn into(self) -> u8 {\n+        self.0\n+    }\n+\n+    pub const fn from(x: u8) -> Self {\n+        Priority(x)\n+    }\n+}\n+\n+impl fmt::Display for Priority {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.0)\n+    }\n+}\n+\n+pub const NORMAL_PRIO: Priority = Priority::from(2);\n+\n+pub struct Thread {\n+    tid: Tid\n+}\n+\n+unsafe impl Send for Thread {}\n+unsafe impl Sync for Thread {}\n+\n+pub const DEFAULT_MIN_STACK_SIZE: usize = 262144;\n+\n+impl Thread {\n+    pub unsafe fn new_with_coreid(_stack: usize, p: Box<dyn FnOnce()>, core_id: isize)\n+        -> io::Result<Thread>\n+    {\n+        let p = box p;\n+        let mut tid: Tid = u32::MAX;\n+        let ret = abi::spawn(&mut tid as *mut Tid, thread_start,\n+                            &*p as *const _ as *const u8 as usize,\n+                            Priority::into(NORMAL_PRIO), core_id);\n+\n+        return if ret == 0 {\n+            mem::forget(p); // ownership passed to pthread_create\n+            Ok(Thread { tid: tid })\n+        } else {\n+            Err(io::Error::new(io::ErrorKind::Other, \"Unable to create thread!\"))\n+        };\n+\n+        extern fn thread_start(main: usize) {\n+            unsafe {\n+                start_thread(main as *mut u8);\n+            }\n+        }\n+    }\n+\n+    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>)\n+        -> io::Result<Thread>\n+    {\n+        Thread::new_with_coreid(stack, p, -1 /* = no specific core */)\n+    }\n+\n+    #[inline]\n+    pub fn yield_now() {\n+        unsafe {\n+            abi::yield_now();\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn set_name(_name: &CStr) {\n+        // nope\n+    }\n+\n+    #[inline]\n+    pub fn sleep(dur: Duration) {\n+        unsafe {\n+            abi::usleep(dur.as_micros() as u64);\n+        }\n+    }\n+\n+    pub fn join(self) {\n+        unsafe {\n+            let _ = abi::join(self.tid);\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn id(&self) -> Tid { self.tid }\n+\n+    #[inline]\n+    pub fn into_id(self) -> Tid {\n+        let id = self.tid;\n+        mem::forget(self);\n+        id\n+    }\n+}\n+\n+pub mod guard {\n+    pub type Guard = !;\n+    pub unsafe fn current() -> Option<Guard> { None }\n+    pub unsafe fn init() -> Option<Guard> { None }\n+}"}, {"sha": "4bc8c4d5883da0a8e41340be42e55e9c063166f6", "filename": "src/libstd/sys/hermit/thread_local.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fthread_local.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,61 @@\n+#![allow(dead_code)] // not used on all platforms\n+\n+use crate::collections::BTreeMap;\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicUsize, Ordering};\n+\n+pub type Key = usize;\n+\n+type Dtor = unsafe extern fn(*mut u8);\n+\n+static NEXT_KEY: AtomicUsize = AtomicUsize::new(0);\n+\n+static mut KEYS: *mut BTreeMap<Key, Option<Dtor>> = ptr::null_mut();\n+\n+#[thread_local]\n+static mut LOCALS: *mut BTreeMap<Key, *mut u8> = ptr::null_mut();\n+\n+unsafe fn keys() -> &'static mut BTreeMap<Key, Option<Dtor>> {\n+    if KEYS == ptr::null_mut() {\n+        KEYS = Box::into_raw(Box::new(BTreeMap::new()));\n+    }\n+    &mut *KEYS\n+}\n+\n+unsafe fn locals() -> &'static mut BTreeMap<Key, *mut u8> {\n+    if LOCALS == ptr::null_mut() {\n+        LOCALS = Box::into_raw(Box::new(BTreeMap::new()));\n+    }\n+    &mut *LOCALS\n+}\n+\n+#[inline]\n+pub unsafe fn create(dtor: Option<Dtor>) -> Key {\n+    let key = NEXT_KEY.fetch_add(1, Ordering::SeqCst);\n+    keys().insert(key, dtor);\n+    key\n+}\n+\n+#[inline]\n+pub unsafe fn get(key: Key) -> *mut u8 {\n+    if let Some(&entry) = locals().get(&key) {\n+        entry\n+    } else {\n+        ptr::null_mut()\n+    }\n+}\n+\n+#[inline]\n+pub unsafe fn set(key: Key, value: *mut u8) {\n+    locals().insert(key, value);\n+}\n+\n+#[inline]\n+pub unsafe fn destroy(key: Key) {\n+    keys().remove(&key);\n+}\n+\n+#[inline]\n+pub fn requires_synchronized_create() -> bool {\n+    false\n+}"}, {"sha": "8372189546d074a12e50babd03fd9ff9dacd45be", "filename": "src/libstd/sys/hermit/time.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fhermit%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Ftime.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -0,0 +1,176 @@\n+#![allow(dead_code)]\n+\n+use crate::time::Duration;\n+use crate::cmp::Ordering;\n+use crate::convert::TryInto;\n+use core::hash::{Hash, Hasher};\n+use crate::sys::hermit::abi;\n+use crate::sys::hermit::abi::{CLOCK_REALTIME, CLOCK_MONOTONIC, NSEC_PER_SEC};\n+use crate::sys::hermit::abi::timespec;\n+\n+#[derive(Copy, Clone, Debug)]\n+struct Timespec {\n+    t: timespec\n+}\n+\n+impl Timespec {\n+    const fn zero() -> Timespec {\n+        Timespec {\n+            t: timespec { tv_sec: 0, tv_nsec: 0 },\n+        }\n+    }\n+\n+    fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n+        if self >= other {\n+            Ok(if self.t.tv_nsec >= other.t.tv_nsec {\n+                Duration::new((self.t.tv_sec - other.t.tv_sec) as u64,\n+                              (self.t.tv_nsec - other.t.tv_nsec) as u32)\n+            } else {\n+                Duration::new((self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n+                              self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) -\n+                              other.t.tv_nsec as u32)\n+            })\n+        } else {\n+            match other.sub_timespec(self) {\n+                Ok(d) => Err(d),\n+                Err(d) => Ok(d),\n+            }\n+        }\n+    }\n+\n+    fn checked_add_duration(&self, other: &Duration) -> Option<Timespec> {\n+        let mut secs = other\n+            .as_secs()\n+            .try_into() // <- target type would be `libc::time_t`\n+            .ok()\n+            .and_then(|secs| self.t.tv_sec.checked_add(secs))?;\n+\n+        // Nano calculations can't overflow because nanos are <1B which fit\n+        // in a u32.\n+        let mut nsec = other.subsec_nanos() + self.t.tv_nsec as u32;\n+        if nsec >= NSEC_PER_SEC as u32 {\n+            nsec -= NSEC_PER_SEC as u32;\n+            secs = secs.checked_add(1)?;\n+        }\n+        Some(Timespec {\n+            t: timespec {\n+                tv_sec: secs,\n+                tv_nsec: nsec as _,\n+            },\n+        })\n+    }\n+\n+    fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {\n+        let mut secs = other\n+            .as_secs()\n+            .try_into() // <- target type would be `libc::time_t`\n+            .ok()\n+            .and_then(|secs| self.t.tv_sec.checked_sub(secs))?;\n+\n+        // Similar to above, nanos can't overflow.\n+        let mut nsec = self.t.tv_nsec as i32 - other.subsec_nanos() as i32;\n+        if nsec < 0 {\n+            nsec += NSEC_PER_SEC as i32;\n+            secs = secs.checked_sub(1)?;\n+        }\n+        Some(Timespec {\n+            t: timespec {\n+                tv_sec: secs,\n+                tv_nsec: nsec as _,\n+            },\n+        })\n+    }\n+}\n+\n+impl PartialEq for Timespec {\n+    fn eq(&self, other: &Timespec) -> bool {\n+        self.t.tv_sec == other.t.tv_sec && self.t.tv_nsec == other.t.tv_nsec\n+    }\n+}\n+\n+impl Eq for Timespec {}\n+\n+impl PartialOrd for Timespec {\n+    fn partial_cmp(&self, other: &Timespec) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for Timespec {\n+    fn cmp(&self, other: &Timespec) -> Ordering {\n+        let me = (self.t.tv_sec, self.t.tv_nsec);\n+        let other = (other.t.tv_sec, other.t.tv_nsec);\n+        me.cmp(&other)\n+    }\n+}\n+\n+impl Hash for Timespec {\n+    fn hash<H : Hasher>(&self, state: &mut H) {\n+        self.t.tv_sec.hash(state);\n+        self.t.tv_nsec.hash(state);\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub struct Instant {\n+    t: Timespec,\n+}\n+\n+impl Instant {\n+    pub fn now() -> Instant {\n+        let mut time: Timespec = Timespec::zero();\n+        let _ = unsafe { abi::clock_gettime(CLOCK_MONOTONIC, &mut time.t as *mut timespec) };\n+\n+        Instant { t: time }\n+    }\n+\n+    pub const fn zero() -> Instant {\n+        Instant { t: Timespec::zero() }\n+    }\n+\n+    pub fn actually_monotonic() -> bool {\n+        true\n+    }\n+\n+    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n+        self.t.sub_timespec(&other.t).ok()\n+    }\n+\n+    pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n+        Some(Instant { t: self.t.checked_add_duration(other)? })\n+    }\n+\n+    pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n+        Some(Instant { t: self.t.checked_sub_duration(other)? })\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+pub struct SystemTime {\n+    t: Timespec,\n+}\n+\n+pub const UNIX_EPOCH: SystemTime = SystemTime {\n+    t: Timespec::zero(),\n+};\n+\n+impl SystemTime {\n+    pub fn now() -> SystemTime {\n+        let mut time: Timespec = Timespec::zero();\n+        let _ = unsafe { abi::clock_gettime(CLOCK_REALTIME, &mut time.t as *mut timespec) };\n+\n+        SystemTime { t: time }\n+    }\n+\n+    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n+        self.t.sub_timespec(&other.t)\n+    }\n+\n+    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n+        Some(SystemTime { t: self.t.checked_add_duration(other)? })\n+    }\n+\n+    pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n+        Some(SystemTime { t: self.t.checked_sub_duration(other)? })\n+    }\n+}"}, {"sha": "16b0539cdb9f952f1411eb0e9c5717a0a9a99e79", "filename": "src/libstd/sys/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -35,6 +35,9 @@ cfg_if::cfg_if! {\n     } else if #[cfg(target_os = \"cloudabi\")] {\n         mod cloudabi;\n         pub use self::cloudabi::*;\n+    } else if #[cfg(target_os = \"hermit\")] {\n+        mod hermit;\n+        pub use self::hermit::*;\n     } else if #[cfg(target_os = \"wasi\")] {\n         mod wasi;\n         pub use self::wasi::*;\n@@ -60,6 +63,7 @@ cfg_if::cfg_if! {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         pub use self::ext as unix_ext;\n     } else if #[cfg(any(target_os = \"cloudabi\",\n+                        target_os = \"hermit\",\n                         target_arch = \"wasm32\",\n                         all(target_vendor = \"fortanix\", target_env = \"sgx\")))] {\n         // On CloudABI and wasm right now the module below doesn't compile"}, {"sha": "cf4900b48943e1d91a150a339ac7a388fc47c5db", "filename": "src/libstd/sys/unix/alloc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Funix%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Funix%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Falloc.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -53,7 +53,6 @@ unsafe impl GlobalAlloc for System {\n }\n \n #[cfg(any(target_os = \"android\",\n-          target_os = \"hermit\",\n           target_os = \"redox\",\n           target_os = \"solaris\"))]\n #[inline]\n@@ -79,7 +78,6 @@ unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n }\n \n #[cfg(not(any(target_os = \"android\",\n-              target_os = \"hermit\",\n               target_os = \"redox\",\n               target_os = \"solaris\")))]\n #[inline]"}, {"sha": "82ef35ea7b5d55dc46dcd0838207994e0b032fe2", "filename": "src/libstd/sys/unix/args.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fargs.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -56,7 +56,6 @@ impl DoubleEndedIterator for Args {\n           target_os = \"haiku\",\n           target_os = \"l4re\",\n           target_os = \"fuchsia\",\n-          target_os = \"hermit\",\n           target_os = \"redox\"))]\n mod imp {\n     use crate::os::unix::prelude::*;"}, {"sha": "6be844ded1936cf33ebc4183864689e3605fbef1", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -31,15 +31,13 @@ impl Condvar {\n               target_os = \"ios\",\n               target_os = \"l4re\",\n               target_os = \"android\",\n-              target_os = \"hermit\",\n               target_os = \"redox\"))]\n     pub unsafe fn init(&mut self) {}\n \n     #[cfg(not(any(target_os = \"macos\",\n                   target_os = \"ios\",\n                   target_os = \"l4re\",\n                   target_os = \"android\",\n-                  target_os = \"hermit\",\n                   target_os = \"redox\")))]\n     pub unsafe fn init(&mut self) {\n         use crate::mem::MaybeUninit;\n@@ -78,8 +76,7 @@ impl Condvar {\n     // from changes made to the system time.\n     #[cfg(not(any(target_os = \"macos\",\n                   target_os = \"ios\",\n-                  target_os = \"android\",\n-                  target_os = \"hermit\")))]\n+                  target_os = \"android\")))]\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n         use crate::mem;\n \n@@ -109,7 +106,7 @@ impl Condvar {\n     // This implementation is modeled after libcxx's condition_variable\n     // https://github.com/llvm-mirror/libcxx/blob/release_35/src/condition_variable.cpp#L46\n     // https://github.com/llvm-mirror/libcxx/blob/release_35/include/__mutex_base#L367\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\", target_os = \"hermit\"))]\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\"))]\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, mut dur: Duration) -> bool {\n         use crate::ptr;\n         use crate::time::Instant;"}, {"sha": "984bcfa45099ba6d4ec70dfede19b9eec4b278e2", "filename": "src/libstd/sys/unix/env.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Funix%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Funix%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fenv.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -152,17 +152,6 @@ pub mod os {\n     pub const EXE_EXTENSION: &str = \"\";\n }\n \n-#[cfg(target_os = \"hermit\")]\n-pub mod os {\n-    pub const FAMILY: &str = \"unix\";\n-    pub const OS: &str = \"hermit\";\n-    pub const DLL_PREFIX: &str = \"lib\";\n-    pub const DLL_SUFFIX: &str = \".so\";\n-    pub const DLL_EXTENSION: &str = \"so\";\n-    pub const EXE_SUFFIX: &str = \"\";\n-    pub const EXE_EXTENSION: &str = \"\";\n-}\n-\n #[cfg(target_os = \"redox\")]\n pub mod os {\n     pub const FAMILY: &str = \"unix\";"}, {"sha": "cbf751bec95be3078839d8c967c07b98ce20de3c", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -502,12 +502,12 @@ impl DirEntry {\n         lstat(&self.path())\n     }\n \n-    #[cfg(any(target_os = \"solaris\", target_os = \"haiku\", target_os = \"hermit\"))]\n+    #[cfg(any(target_os = \"solaris\", target_os = \"haiku\"))]\n     pub fn file_type(&self) -> io::Result<FileType> {\n         lstat(&self.path()).map(|m| m.file_type())\n     }\n \n-    #[cfg(not(any(target_os = \"solaris\", target_os = \"haiku\", target_os = \"hermit\")))]\n+    #[cfg(not(any(target_os = \"solaris\", target_os = \"haiku\")))]\n     pub fn file_type(&self) -> io::Result<FileType> {\n         match self.entry.d_type {\n             libc::DT_CHR => Ok(FileType { mode: libc::S_IFCHR }),\n@@ -530,7 +530,6 @@ impl DirEntry {\n               target_os = \"haiku\",\n               target_os = \"l4re\",\n               target_os = \"fuchsia\",\n-              target_os = \"hermit\",\n               target_os = \"redox\"))]\n     pub fn ino(&self) -> u64 {\n         self.entry.d_ino as u64\n@@ -561,8 +560,7 @@ impl DirEntry {\n               target_os = \"linux\",\n               target_os = \"emscripten\",\n               target_os = \"l4re\",\n-              target_os = \"haiku\",\n-              target_os = \"hermit\"))]\n+              target_os = \"haiku\"))]\n     fn name_bytes(&self) -> &[u8] {\n         unsafe {\n             CStr::from_ptr(self.entry.d_name.as_ptr()).to_bytes()"}, {"sha": "d0bed0f038e6c9b2a1c929f16f53b7abc183af0a", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -16,7 +16,6 @@ use crate::io::ErrorKind;\n #[cfg(all(not(rustdoc), target_os = \"emscripten\"))] pub use crate::os::emscripten as platform;\n #[cfg(all(not(rustdoc), target_os = \"fuchsia\"))]   pub use crate::os::fuchsia as platform;\n #[cfg(all(not(rustdoc), target_os = \"l4re\"))]      pub use crate::os::linux as platform;\n-#[cfg(all(not(rustdoc), target_os = \"hermit\"))]    pub use crate::os::hermit as platform;\n #[cfg(all(not(rustdoc), target_os = \"redox\"))]      pub use crate::os::redox as platform;\n \n pub use self::rand::hashmap_random_keys;"}, {"sha": "10cdb25999ca9d09c558fb2b94f5bc97eae11765", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -43,7 +43,6 @@ extern {\n     #[cfg_attr(any(target_os = \"netbsd\",\n                    target_os = \"openbsd\",\n                    target_os = \"android\",\n-                   target_os = \"hermit\",\n                    target_os = \"redox\",\n                    target_env = \"newlib\"),\n                link_name = \"__errno\")]\n@@ -394,7 +393,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     crate::fs::read_to_string(\"sys:exe\").map(PathBuf::from)\n }\n \n-#[cfg(any(target_os = \"fuchsia\", target_os = \"l4re\", target_os = \"hermit\"))]\n+#[cfg(any(target_os = \"fuchsia\", target_os = \"l4re\"))]\n pub fn current_exe() -> io::Result<PathBuf> {\n     use crate::io::ErrorKind;\n     Err(io::Error::new(ErrorKind::Other, \"Not yet implemented!\"))"}, {"sha": "72b0ac493da15cf1b544103161c9d5dcc257a45b", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -140,7 +140,6 @@ impl Thread {\n               target_os = \"haiku\",\n               target_os = \"l4re\",\n               target_os = \"emscripten\",\n-              target_os = \"hermit\",\n               target_os = \"redox\"))]\n     pub fn set_name(_name: &CStr) {\n         // Newlib, Illumos, Haiku, and Emscripten have no way to set a thread name."}, {"sha": "a9122defa55062758a1157e2a67cd020f7c9dea7", "filename": "src/libstd/sys/unix/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftime.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -371,9 +371,9 @@ mod inner {\n         }\n     }\n \n-    #[cfg(not(any(target_os = \"dragonfly\", target_os = \"hermit\")))]\n+    #[cfg(not(target_os = \"dragonfly\"))]\n     pub type clock_t = libc::c_int;\n-    #[cfg(any(target_os = \"dragonfly\", target_os = \"hermit\"))]\n+    #[cfg(target_os = \"dragonfly\")]\n     pub type clock_t = libc::c_ulong;\n \n     fn now(clock: clock_t) -> Timespec {"}, {"sha": "7a0bcd03d758f7748c5b7dbc0cc1d0e4c6243733", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -49,6 +49,7 @@ pub mod mutex;\n           unix,\n           target_os = \"redox\",\n           target_os = \"cloudabi\",\n+          target_os = \"hermit\",\n           target_arch = \"wasm32\",\n           all(target_vendor = \"fortanix\", target_env = \"sgx\")))]\n pub mod os_str_bytes;\n@@ -67,6 +68,7 @@ pub mod fs;\n cfg_if::cfg_if! {\n     if #[cfg(any(target_os = \"cloudabi\",\n                  target_os = \"l4re\",\n+                 target_os = \"hermit\",\n                  all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n                  all(target_vendor = \"fortanix\", target_env = \"sgx\")))] {\n         pub use crate::sys::net;"}, {"sha": "77bcfffd506c93a6913f1f0fea7390a435793814", "filename": "src/libunwind/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibunwind%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Flibunwind%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2FCargo.toml?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -17,7 +17,7 @@ doc = false\n \n [dependencies]\n core = { path = \"../libcore\" }\n-libc = { version = \"0.2.43\", features = ['rustc-dep-of-std'], default-features = false }\n+libc = { version = \"0.2.51\", features = ['rustc-dep-of-std'], default-features = false }\n compiler_builtins = \"0.1.0\"\n cfg-if = \"0.1.8\"\n "}, {"sha": "2a189a92f4b129825aafed07a8e0103aaf5b9253", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -52,6 +52,7 @@ static TARGETS: &[&str] = &[\n     \"aarch64-linux-android\",\n     \"aarch64-pc-windows-msvc\",\n     \"aarch64-unknown-cloudabi\",\n+    \"aarch64-unknown-hermit\",\n     \"aarch64-unknown-linux-gnu\",\n     \"aarch64-unknown-linux-musl\",\n     \"aarch64-unknown-redox\",\n@@ -136,6 +137,7 @@ static TARGETS: &[&str] = &[\n     \"x86_64-unknown-linux-musl\",\n     \"x86_64-unknown-netbsd\",\n     \"x86_64-unknown-redox\",\n+    \"x86_64-unknown-hermit\",\n ];\n \n static DOCS_TARGETS: &[&str] = &["}, {"sha": "e6ea1c75e289957b9a50af558e12358e4b4f6827", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fae75cd216c481de048e4951697c8f8525669c65/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fae75cd216c481de048e4951697c8f8525669c65/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=fae75cd216c481de048e4951697c8f8525669c65", "patch": "@@ -181,6 +181,7 @@ const WHITELIST: &[Crate<'_>] = &[\n     Crate(\"winapi-util\"),\n     Crate(\"winapi-x86_64-pc-windows-gnu\"),\n     Crate(\"wincolor\"),\n+    Crate(\"hermit-abi\"),\n ];\n \n // Some types for Serde to deserialize the output of `cargo metadata` to."}]}