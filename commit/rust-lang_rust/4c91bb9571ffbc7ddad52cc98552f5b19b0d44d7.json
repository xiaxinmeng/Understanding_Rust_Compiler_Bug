{"sha": "4c91bb9571ffbc7ddad52cc98552f5b19b0d44d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjOTFiYjk1NzFmZmJjN2RkYWQ1MmNjOTg1NTJmNWIxOWIwZDQ0ZDc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-06-11T17:40:24Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-07-02T16:15:20Z"}, "message": "introduce a `VecGraph` abstraction that cheaply stores graphs\n\nThis is perhaps better than the linked list approach I was using\nbefore. Lower memory overhead, Theta(N+E) storage. Does require a\nsort. =)", "tree": {"sha": "0776bef9d5fa38af8bd84c743a80e766003b4f03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0776bef9d5fa38af8bd84c743a80e766003b4f03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c91bb9571ffbc7ddad52cc98552f5b19b0d44d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c91bb9571ffbc7ddad52cc98552f5b19b0d44d7", "html_url": "https://github.com/rust-lang/rust/commit/4c91bb9571ffbc7ddad52cc98552f5b19b0d44d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c91bb9571ffbc7ddad52cc98552f5b19b0d44d7/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e85665e08059a3cd96600b7972f7dcd1f62b871", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e85665e08059a3cd96600b7972f7dcd1f62b871", "html_url": "https://github.com/rust-lang/rust/commit/4e85665e08059a3cd96600b7972f7dcd1f62b871"}], "stats": {"total": 200, "additions": 197, "deletions": 3}, "files": [{"sha": "45e7e5db38f0464c905f7e0a2765938cef37c65e", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c91bb9571ffbc7ddad52cc98552f5b19b0d44d7/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c91bb9571ffbc7ddad52cc98552f5b19b0d44d7/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=4c91bb9571ffbc7ddad52cc98552f5b19b0d44d7", "patch": "@@ -5,6 +5,7 @@ pub mod implementation;\n pub mod iterate;\n mod reference;\n pub mod scc;\n+pub mod vec_graph;\n \n #[cfg(test)]\n mod test;\n@@ -17,6 +18,10 @@ pub trait WithNumNodes: DirectedGraph {\n     fn num_nodes(&self) -> usize;\n }\n \n+pub trait WithNumEdges: DirectedGraph {\n+    fn num_edges(&self) -> usize;\n+}\n+\n pub trait WithSuccessors: DirectedGraph\n where\n     Self: for<'graph> GraphSuccessors<'graph, Item = <Self as DirectedGraph>::Node>,"}, {"sha": "78554cda77b44b2a8710e37667af151043b20d84", "filename": "src/librustc_data_structures/graph/scc/mod.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4c91bb9571ffbc7ddad52cc98552f5b19b0d44d7/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c91bb9571ffbc7ddad52cc98552f5b19b0d44d7/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs?ref=4c91bb9571ffbc7ddad52cc98552f5b19b0d44d7", "patch": "@@ -4,7 +4,8 @@\n //! O(n) time.\n \n use crate::fx::FxHashSet;\n-use crate::graph::{DirectedGraph, WithNumNodes, WithSuccessors, GraphSuccessors};\n+use crate::graph::{DirectedGraph, WithNumNodes, WithNumEdges, WithSuccessors, GraphSuccessors};\n+use crate::graph::vec_graph::VecGraph;\n use crate::indexed_vec::{Idx, IndexVec};\n use std::ops::Range;\n \n@@ -58,6 +59,18 @@ impl<N: Idx, S: Idx> Sccs<N, S> {\n     pub fn successors(&self, scc: S) -> &[S] {\n         self.scc_data.successors(scc)\n     }\n+\n+    /// Construct the reverse graph of the SCC graph.\n+    pub fn reverse(&self) -> VecGraph<S> {\n+        VecGraph::new(\n+            self.num_sccs(),\n+            self.all_sccs()\n+                .flat_map(|source| self.successors(source).iter().map(move |&target| {\n+                    (target, source)\n+                }))\n+                .collect(),\n+        )\n+    }\n }\n \n impl<N: Idx, S: Idx> DirectedGraph for Sccs<N, S> {\n@@ -70,6 +83,12 @@ impl<N: Idx, S: Idx> WithNumNodes for Sccs<N, S> {\n     }\n }\n \n+impl<N: Idx, S: Idx> WithNumEdges for Sccs<N, S> {\n+    fn num_edges(&self) -> usize {\n+        self.scc_data.all_successors.len()\n+    }\n+}\n+\n impl<N: Idx, S: Idx> GraphSuccessors<'graph> for Sccs<N, S> {\n     type Item = S;\n "}, {"sha": "6b3349e3e15494f71eec53765bc403b1f944ce72", "filename": "src/librustc_data_structures/graph/vec_graph/mod.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/4c91bb9571ffbc7ddad52cc98552f5b19b0d44d7/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c91bb9571ffbc7ddad52cc98552f5b19b0d44d7/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Fmod.rs?ref=4c91bb9571ffbc7ddad52cc98552f5b19b0d44d7", "patch": "@@ -0,0 +1,113 @@\n+use crate::indexed_vec::{Idx, IndexVec};\n+use crate::graph::{DirectedGraph, WithNumNodes, WithNumEdges, WithSuccessors, GraphSuccessors};\n+\n+mod test;\n+\n+pub struct VecGraph<N: Idx> {\n+    /// Maps from a given node to an index where the set of successors\n+    /// for that node starts. The index indexes into the `edges`\n+    /// vector. To find the range for a given node, we look up the\n+    /// start for that node and then the start for the next node\n+    /// (i.e., with an index 1 higher) and get the range between the\n+    /// two. This vector always has an extra entry so that this works\n+    /// even for the max element.\n+    node_starts: IndexVec<N, usize>,\n+\n+    edge_targets: Vec<N>,\n+}\n+\n+impl<N: Idx> VecGraph<N> {\n+    pub fn new(\n+        num_nodes: usize,\n+        mut edge_pairs: Vec<(N, N)>,\n+    ) -> Self {\n+        // Sort the edges by the source -- this is important.\n+        edge_pairs.sort();\n+\n+        let num_edges = edge_pairs.len();\n+\n+        // Store the *target* of each edge into `edge_targets`\n+        let edge_targets: Vec<N> = edge_pairs.iter().map(|&(_, target)| target).collect();\n+\n+        // Create the *edge starts* array. We are iterating over over\n+        // the (sorted) edge pairs. We maintain the invariant that the\n+        // length of the `node_starts` arary is enough to store the\n+        // current source node -- so when we see that the source node\n+        // for an edge is greater than the current length, we grow the\n+        // edge-starts array by just enough.\n+        let mut node_starts = IndexVec::with_capacity(num_edges);\n+        for (index, &(source, _)) in edge_pairs.iter().enumerate() {\n+            // If we have a list like `[(0, x), (2, y)]`:\n+            //\n+            // - Start out with `node_starts` of `[]`\n+            // - Iterate to `(0, x)` at index 0:\n+            //   - Push one entry because `node_starts.len()` (0) is <= the source (0)\n+            //   - Leaving us with `node_starts` of `[0]`\n+            // - Iterate to `(2, y)` at index 1:\n+            //   - Push one entry because `node_starts.len()` (1) is <= the source (2)\n+            //   - Push one entry because `node_starts.len()` (2) is <= the source (2)\n+            //   - Leaving us with `node_starts` of `[0, 1, 1]`\n+            // - Loop terminates\n+            while node_starts.len() <= source.index() {\n+                node_starts.push(index);\n+            }\n+        }\n+\n+        // Pad out the `node_starts` array so that it has `num_nodes +\n+        // 1` entries. Continuing our example above, if `num_nodes` is\n+        // be `3`, we would push one more index: `[0, 1, 1, 2]`.\n+        //\n+        // Interpretation of that vector:\n+        //\n+        // [0, 1, 1, 2]\n+        //        ---- range for N=2\n+        //     ---- range for N=1\n+        //  ---- range for N=0\n+        while node_starts.len() <= num_nodes {\n+            node_starts.push(edge_targets.len());\n+        }\n+\n+        assert_eq!(node_starts.len(), num_nodes + 1);\n+\n+        Self { node_starts, edge_targets }\n+    }\n+\n+    /// Gets the successors for `source` as a slice.\n+    pub fn successors(&self, source: N) -> &[N] {\n+        let start_index = self.node_starts[source];\n+        let end_index = self.node_starts[source.plus(1)];\n+        &self.edge_targets[start_index..end_index]\n+    }\n+}\n+\n+impl<N: Idx> DirectedGraph for VecGraph<N> {\n+    type Node = N;\n+}\n+\n+impl<N: Idx> WithNumNodes for VecGraph<N> {\n+    fn num_nodes(&self) -> usize {\n+        self.node_starts.len() - 1\n+    }\n+}\n+\n+impl<N: Idx> WithNumEdges for VecGraph<N> {\n+    fn num_edges(&self) -> usize {\n+        self.edge_targets.len()\n+    }\n+}\n+\n+impl<N: Idx> GraphSuccessors<'graph> for VecGraph<N> {\n+    type Item = N;\n+\n+    type Iter = std::iter::Cloned<std::slice::Iter<'graph, N>>;\n+}\n+\n+impl<N: Idx> WithSuccessors for VecGraph<N> {\n+    fn successors<'graph>(\n+        &'graph self,\n+        node: N\n+    ) -> <Self as GraphSuccessors<'graph>>::Iter {\n+        self.successors(node).iter().cloned()\n+    }\n+}\n+"}, {"sha": "4a168ee1d44fda617085ce68d4c6175cd2b1b4dc", "filename": "src/librustc_data_structures/graph/vec_graph/test.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4c91bb9571ffbc7ddad52cc98552f5b19b0d44d7/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c91bb9571ffbc7ddad52cc98552f5b19b0d44d7/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Ftest.rs?ref=4c91bb9571ffbc7ddad52cc98552f5b19b0d44d7", "patch": "@@ -0,0 +1,46 @@\n+#![cfg(test)]\n+\n+use super::*;\n+\n+fn create_graph() -> VecGraph<usize> {\n+    // Create a simple graph\n+    //\n+    //          5\n+    //          |\n+    //          V\n+    //    0 --> 1 --> 2\n+    //          |\n+    //          v\n+    //          3 --> 4\n+    //\n+    //    6\n+\n+    VecGraph::new(\n+        7,\n+        vec![\n+            (0, 1),\n+            (1, 2),\n+            (1, 3),\n+            (3, 4),\n+            (5, 1),\n+        ],\n+    )\n+}\n+\n+#[test]\n+fn num_nodes() {\n+    let graph = create_graph();\n+    assert_eq!(graph.num_nodes(), 7);\n+}\n+\n+#[test]\n+fn succesors() {\n+    let graph = create_graph();\n+    assert_eq!(graph.successors(0), &[1]);\n+    assert_eq!(graph.successors(1), &[2, 3]);\n+    assert_eq!(graph.successors(2), &[]);\n+    assert_eq!(graph.successors(3), &[4]);\n+    assert_eq!(graph.successors(4), &[]);\n+    assert_eq!(graph.successors(5), &[1]);\n+    assert_eq!(graph.successors(6), &[]);\n+}"}, {"sha": "b3a810a622d03dbdf7b2dd7479b1f21e83feeff2", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4c91bb9571ffbc7ddad52cc98552f5b19b0d44d7/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c91bb9571ffbc7ddad52cc98552f5b19b0d44d7/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=4c91bb9571ffbc7ddad52cc98552f5b19b0d44d7", "patch": "@@ -19,8 +19,11 @@ pub trait Idx: Copy + 'static + Ord + Debug + Hash {\n     fn index(self) -> usize;\n \n     fn increment_by(&mut self, amount: usize) {\n-        let v = self.index() + amount;\n-        *self = Self::new(v);\n+        *self = self.plus(amount);\n+    }\n+\n+    fn plus(self, amount: usize) -> Self {\n+        Self::new(self.index() + amount)\n     }\n }\n \n@@ -167,6 +170,14 @@ macro_rules! newtype_index {\n             }\n         }\n \n+        impl std::ops::Add<usize> for $type {\n+            type Output = Self;\n+\n+            fn add(self, other: usize) -> Self {\n+                Self::new(self.index() + other)\n+            }\n+        }\n+\n         impl Idx for $type {\n             #[inline]\n             fn new(value: usize) -> Self {"}]}