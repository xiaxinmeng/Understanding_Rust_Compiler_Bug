{"sha": "f37a6caffe0ec03b0b32da9d7045f22d35deb526", "node_id": "C_kwDOAAsO6NoAKGYzN2E2Y2FmZmUwZWMwM2IwYjMyZGE5ZDcwNDVmMjJkMzVkZWI1MjY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-11-20T21:33:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-20T21:33:50Z"}, "message": "Rollup merge of #91018 - est31:let_else, r=matthewjasper\n\nAdopt let_else in more places in rustc_mir_build\n\nHelps avoid rightward drift.\n\nfollowup of #89933", "tree": {"sha": "5e578b04251f07eb0b969e6f1607073a03115fc0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e578b04251f07eb0b969e6f1607073a03115fc0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f37a6caffe0ec03b0b32da9d7045f22d35deb526", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhmWm/CRBK7hj4Ov3rIwAA94oIACvt6FHdPow+pEWc3NbV7K3c\nc/5KYs5005QUkJe9mDh0hwY3mJBqt+nwFVnBJQkfa68jy4D9pMuKTvkd5nlIeuCG\nbzUZD95TJu48Q4y742sie8oiQwkNYCwTvrbzIcsVMzJeIWW2aBlszfF+c2j8JG3m\npwuwXHoAWjF9WDsihc0NvGrMaw/dkCM3oQv5Ioi3PBDt/3jnG6t1WYEDhqMJXfjl\nOGgdPxCaS2kmV91Y3MkGVMpddVOCDn56n5ozq+Ct7PffiUzIk26hLLo/V54F83aG\nxrAYgAbWa04lxIKrw7bMQkm0xFOY4I1rhI4cgdLYJKCQdHK0457Ia7niQIEynuE=\n=IEI7\n-----END PGP SIGNATURE-----\n", "payload": "tree 5e578b04251f07eb0b969e6f1607073a03115fc0\nparent 3d4f3ee71d8463b000684021120521d96d519b18\nparent 8dc8e72c4d68c95ef67e49370129f4b66c493add\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1637444030 +0100\ncommitter GitHub <noreply@github.com> 1637444030 +0100\n\nRollup merge of #91018 - est31:let_else, r=matthewjasper\n\nAdopt let_else in more places in rustc_mir_build\n\nHelps avoid rightward drift.\n\nfollowup of #89933\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f37a6caffe0ec03b0b32da9d7045f22d35deb526", "html_url": "https://github.com/rust-lang/rust/commit/f37a6caffe0ec03b0b32da9d7045f22d35deb526", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f37a6caffe0ec03b0b32da9d7045f22d35deb526/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d4f3ee71d8463b000684021120521d96d519b18", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d4f3ee71d8463b000684021120521d96d519b18", "html_url": "https://github.com/rust-lang/rust/commit/3d4f3ee71d8463b000684021120521d96d519b18"}, {"sha": "8dc8e72c4d68c95ef67e49370129f4b66c493add", "url": "https://api.github.com/repos/rust-lang/rust/commits/8dc8e72c4d68c95ef67e49370129f4b66c493add", "html_url": "https://github.com/rust-lang/rust/commit/8dc8e72c4d68c95ef67e49370129f4b66c493add"}], "stats": {"total": 135, "additions": 66, "deletions": 69}, "files": [{"sha": "e3a05e01ea8f089a0750aa4498fb04d439d50df2", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f37a6caffe0ec03b0b32da9d7045f22d35deb526/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37a6caffe0ec03b0b32da9d7045f22d35deb526/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=f37a6caffe0ec03b0b32da9d7045f22d35deb526", "patch": "@@ -1606,13 +1606,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // encounter a candidate where the test is not relevant; at\n         // that point, we stop sorting.\n         while let Some(candidate) = candidates.first_mut() {\n-            if let Some(idx) = self.sort_candidate(&match_place.clone(), &test, candidate) {\n-                let (candidate, rest) = candidates.split_first_mut().unwrap();\n-                target_candidates[idx].push(candidate);\n-                candidates = rest;\n-            } else {\n+            let Some(idx) = self.sort_candidate(&match_place.clone(), &test, candidate) else {\n                 break;\n-            }\n+            };\n+            let (candidate, rest) = candidates.split_first_mut().unwrap();\n+            target_candidates[idx].push(candidate);\n+            candidates = rest;\n         }\n         // at least the first candidate ought to be tested\n         assert!(total_candidate_count > candidates.len());"}, {"sha": "cb94e759972378899e45da2959035b5b0368ecc3", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 50, "deletions": 51, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f37a6caffe0ec03b0b32da9d7045f22d35deb526/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37a6caffe0ec03b0b32da9d7045f22d35deb526/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=f37a6caffe0ec03b0b32da9d7045f22d35deb526", "patch": "@@ -966,59 +966,58 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 DropKind::Value,\n             );\n \n-            if let Some(arg) = arg_opt {\n-                let pat = match tcx.hir().get(arg.pat.hir_id) {\n-                    Node::Pat(pat) | Node::Binding(pat) => pat,\n-                    node => bug!(\"pattern became {:?}\", node),\n-                };\n-                let pattern = pat_from_hir(tcx, self.param_env, self.typeck_results, pat);\n-                let original_source_scope = self.source_scope;\n-                let span = pattern.span;\n-                self.set_correct_source_scope_for_arg(arg.hir_id, original_source_scope, span);\n-                match *pattern.kind {\n-                    // Don't introduce extra copies for simple bindings\n-                    PatKind::Binding {\n-                        mutability,\n-                        var,\n-                        mode: BindingMode::ByValue,\n-                        subpattern: None,\n-                        ..\n-                    } => {\n-                        self.local_decls[local].mutability = mutability;\n-                        self.local_decls[local].source_info.scope = self.source_scope;\n-                        self.local_decls[local].local_info = if let Some(kind) = self_binding {\n-                            Some(Box::new(LocalInfo::User(ClearCrossCrate::Set(\n-                                BindingForm::ImplicitSelf(*kind),\n-                            ))))\n-                        } else {\n-                            let binding_mode = ty::BindingMode::BindByValue(mutability);\n-                            Some(Box::new(LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n-                                VarBindingForm {\n-                                    binding_mode,\n-                                    opt_ty_info,\n-                                    opt_match_place: Some((Some(place), span)),\n-                                    pat_span: span,\n-                                },\n-                            )))))\n-                        };\n-                        self.var_indices.insert(var, LocalsForNode::One(local));\n-                    }\n-                    _ => {\n-                        scope = self.declare_bindings(\n-                            scope,\n-                            expr.span,\n-                            &pattern,\n-                            matches::ArmHasGuard(false),\n-                            Some((Some(&place), span)),\n-                        );\n-                        let place_builder = PlaceBuilder::from(local);\n-                        unpack!(\n-                            block = self.place_into_pattern(block, pattern, place_builder, false)\n-                        );\n-                    }\n+            let Some(arg) = arg_opt else {\n+                continue;\n+            };\n+            let pat = match tcx.hir().get(arg.pat.hir_id) {\n+                Node::Pat(pat) | Node::Binding(pat) => pat,\n+                node => bug!(\"pattern became {:?}\", node),\n+            };\n+            let pattern = pat_from_hir(tcx, self.param_env, self.typeck_results, pat);\n+            let original_source_scope = self.source_scope;\n+            let span = pattern.span;\n+            self.set_correct_source_scope_for_arg(arg.hir_id, original_source_scope, span);\n+            match *pattern.kind {\n+                // Don't introduce extra copies for simple bindings\n+                PatKind::Binding {\n+                    mutability,\n+                    var,\n+                    mode: BindingMode::ByValue,\n+                    subpattern: None,\n+                    ..\n+                } => {\n+                    self.local_decls[local].mutability = mutability;\n+                    self.local_decls[local].source_info.scope = self.source_scope;\n+                    self.local_decls[local].local_info = if let Some(kind) = self_binding {\n+                        Some(Box::new(LocalInfo::User(ClearCrossCrate::Set(\n+                            BindingForm::ImplicitSelf(*kind),\n+                        ))))\n+                    } else {\n+                        let binding_mode = ty::BindingMode::BindByValue(mutability);\n+                        Some(Box::new(LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                            VarBindingForm {\n+                                binding_mode,\n+                                opt_ty_info,\n+                                opt_match_place: Some((Some(place), span)),\n+                                pat_span: span,\n+                            },\n+                        )))))\n+                    };\n+                    self.var_indices.insert(var, LocalsForNode::One(local));\n+                }\n+                _ => {\n+                    scope = self.declare_bindings(\n+                        scope,\n+                        expr.span,\n+                        &pattern,\n+                        matches::ArmHasGuard(false),\n+                        Some((Some(&place), span)),\n+                    );\n+                    let place_builder = PlaceBuilder::from(local);\n+                    unpack!(block = self.place_into_pattern(block, pattern, place_builder, false));\n                 }\n-                self.source_scope = original_source_scope;\n             }\n+            self.source_scope = original_source_scope;\n         }\n \n         // Enter the argument pattern bindings source scope, if it exists."}, {"sha": "7940bd1f33dc1bb35eacf2459708a02195c6d657", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f37a6caffe0ec03b0b32da9d7045f22d35deb526/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37a6caffe0ec03b0b32da9d7045f22d35deb526/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=f37a6caffe0ec03b0b32da9d7045f22d35deb526", "patch": "@@ -256,23 +256,22 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n             }\n             PatKind::Binding { mode: BindingMode::ByRef(borrow_kind), ty, .. } => {\n                 if self.inside_adt {\n-                    if let ty::Ref(_, ty, _) = ty.kind() {\n-                        match borrow_kind {\n-                            BorrowKind::Shallow | BorrowKind::Shared | BorrowKind::Unique => {\n-                                if !ty.is_freeze(self.tcx.at(pat.span), self.param_env) {\n-                                    self.requires_unsafe(pat.span, BorrowOfLayoutConstrainedField);\n-                                }\n-                            }\n-                            BorrowKind::Mut { .. } => {\n-                                self.requires_unsafe(pat.span, MutationOfLayoutConstrainedField);\n-                            }\n-                        }\n-                    } else {\n+                    let ty::Ref(_, ty, _) = ty.kind() else {\n                         span_bug!(\n                             pat.span,\n                             \"BindingMode::ByRef in pattern, but found non-reference type {}\",\n                             ty\n                         );\n+                    };\n+                    match borrow_kind {\n+                        BorrowKind::Shallow | BorrowKind::Shared | BorrowKind::Unique => {\n+                            if !ty.is_freeze(self.tcx.at(pat.span), self.param_env) {\n+                                self.requires_unsafe(pat.span, BorrowOfLayoutConstrainedField);\n+                            }\n+                        }\n+                        BorrowKind::Mut { .. } => {\n+                            self.requires_unsafe(pat.span, MutationOfLayoutConstrainedField);\n+                        }\n                     }\n                 }\n                 visit::walk_pat(self, pat);"}]}