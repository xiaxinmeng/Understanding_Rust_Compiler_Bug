{"sha": "fd30241281333d73d504355b2f4d0ecd94f27b0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkMzAyNDEyODEzMzNkNzNkNTA0MzU1YjJmNGQwZWNkOTRmMjdiMGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-30T13:57:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-30T13:57:21Z"}, "message": "Auto merge of #7573 - Jarcho:option_if_let_else, r=giraffate\n\nFix `option_if_let_else`\n\nfixes: #5822\nfixes: #6737\nfixes: #7567\n\nThe inference from #6137 still exists so I'm not sure if this should be moved from the nursery. Before doing that though I'd almost want to see this split into two lints. One suggesting `map_or` and the other suggesting `map_or_else`.\n\n`map_or_else` tends to have longer expressions for both branches so it doesn't end up much shorter than a match expression in practice. It also seems most people find it harder to read. `map_or` at least has the terseness benefit of being on one line most of the time, especially when the `None` branch is just a literal or path expression.\n\nchangelog: `break` and `continue` statments local to the would-be closure are allowed in `option_if_let_else`\nchangelog: don't lint in const contexts  in `option_if_let_else`\nchangelog: don't lint when yield expressions are used  in `option_if_let_else`\nchangelog: don't lint when the captures made by the would-be closure conflict with the other branch  in `option_if_let_else`\nchangelog: don't lint when a field of a local is used when the type could be pontentially moved from  in `option_if_let_else`\nchangelog: in some cases, don't lint when scrutinee expression conflicts with the captures of the would-be closure  in `option_if_let_else`", "tree": {"sha": "113b6bb488e5d6b07370791e101f5e43ba904c9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/113b6bb488e5d6b07370791e101f5e43ba904c9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd30241281333d73d504355b2f4d0ecd94f27b0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd30241281333d73d504355b2f4d0ecd94f27b0e", "html_url": "https://github.com/rust-lang/rust/commit/fd30241281333d73d504355b2f4d0ecd94f27b0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd30241281333d73d504355b2f4d0ecd94f27b0e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e1e9b0c6e36fb4f9b12c53a34ce3b834caa1323", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e1e9b0c6e36fb4f9b12c53a34ce3b834caa1323", "html_url": "https://github.com/rust-lang/rust/commit/5e1e9b0c6e36fb4f9b12c53a34ce3b834caa1323"}, {"sha": "3e5dcba2ee446ac712a4a57b042ca4b7f6a46ecc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e5dcba2ee446ac712a4a57b042ca4b7f6a46ecc", "html_url": "https://github.com/rust-lang/rust/commit/3e5dcba2ee446ac712a4a57b042ca4b7f6a46ecc"}], "stats": {"total": 260, "additions": 237, "deletions": 23}, "files": [{"sha": "0614c14462b7f77f069ef502d6af530cc5c09b7f", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/fd30241281333d73d504355b2f4d0ecd94f27b0e/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd30241281333d73d504355b2f4d0ecd94f27b0e/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=fd30241281333d73d504355b2f4d0ecd94f27b0e", "patch": "@@ -1,12 +1,16 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::usage::contains_return_break_continue_macro;\n-use clippy_utils::{eager_or_lazy, in_macro, is_else_clause, is_lang_ctor};\n+use clippy_utils::{\n+    can_move_expr_to_closure, eager_or_lazy, in_constant, in_macro, is_else_clause, is_lang_ctor, peel_hir_expr_while,\n+    CaptureKind,\n+};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionSome;\n-use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, PatKind, UnOp};\n+use rustc_hir::{\n+    def::Res, Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, PatKind, Path, QPath, UnOp,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -127,21 +131,30 @@ fn detect_option_if_let_else<'tcx>(\n ) -> Option<OptionIfLetElseOccurence> {\n     if_chain! {\n         if !in_macro(expr.span); // Don't lint macros, because it behaves weirdly\n-        if let ExprKind::Match(cond_expr, arms, MatchSource::IfLetDesugar{contains_else_clause: true}) = &expr.kind;\n+        if !in_constant(cx, expr.hir_id);\n+        if let ExprKind::Match(cond_expr, [some_arm, none_arm], MatchSource::IfLetDesugar{contains_else_clause: true})\n+            = &expr.kind;\n         if !is_else_clause(cx.tcx, expr);\n-        if arms.len() == 2;\n         if !is_result_ok(cx, cond_expr); // Don't lint on Result::ok because a different lint does it already\n-        if let PatKind::TupleStruct(struct_qpath, [inner_pat], _) = &arms[0].pat.kind;\n+        if let PatKind::TupleStruct(struct_qpath, [inner_pat], _) = &some_arm.pat.kind;\n         if is_lang_ctor(cx, struct_qpath, OptionSome);\n         if let PatKind::Binding(bind_annotation, _, id, _) = &inner_pat.kind;\n-        if !contains_return_break_continue_macro(arms[0].body);\n-        if !contains_return_break_continue_macro(arms[1].body);\n+        if let Some(some_captures) = can_move_expr_to_closure(cx, some_arm.body);\n+        if let Some(none_captures) = can_move_expr_to_closure(cx, none_arm.body);\n+        if some_captures\n+            .iter()\n+            .filter_map(|(id, &c)| none_captures.get(id).map(|&c2| (c, c2)))\n+            .all(|(x, y)| x.is_imm_ref() && y.is_imm_ref());\n \n         then {\n             let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n-            let some_body = extract_body_from_arm(&arms[0])?;\n-            let none_body = extract_body_from_arm(&arms[1])?;\n-            let method_sugg = if eager_or_lazy::is_eagerness_candidate(cx, none_body) { \"map_or\" } else { \"map_or_else\" };\n+            let some_body = extract_body_from_arm(some_arm)?;\n+            let none_body = extract_body_from_arm(none_arm)?;\n+            let method_sugg = if eager_or_lazy::is_eagerness_candidate(cx, none_body) {\n+                \"map_or\"\n+            } else {\n+                \"map_or_else\"\n+            };\n             let capture_name = id.name.to_ident_string();\n             let (as_ref, as_mut) = match &cond_expr.kind {\n                 ExprKind::AddrOf(_, Mutability::Not, _) => (true, false),\n@@ -153,6 +166,24 @@ fn detect_option_if_let_else<'tcx>(\n                 ExprKind::Unary(UnOp::Deref, expr) | ExprKind::AddrOf(_, _, expr) => expr,\n                 _ => cond_expr,\n             };\n+            // Check if captures the closure will need conflict with borrows made in the scrutinee.\n+            // TODO: check all the references made in the scrutinee expression. This will require interacting\n+            // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n+            if as_ref || as_mut {\n+                let e = peel_hir_expr_while(cond_expr, |e| match e.kind {\n+                    ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n+                    _ => None,\n+                });\n+                if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(local_id), .. })) = e.kind {\n+                    match some_captures.get(local_id)\n+                        .or_else(|| (method_sugg == \"map_or_else\").then(|| ()).and_then(|_| none_captures.get(local_id)))\n+                    {\n+                        Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return None,\n+                        Some(CaptureKind::Ref(Mutability::Not)) if as_mut => return None,\n+                        Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n+                    }\n+                }\n+            }\n             Some(OptionIfLetElseOccurence {\n                 option: format_option_in_sugg(cx, cond_expr, as_ref, as_mut),\n                 method_sugg: method_sugg.to_string(),"}, {"sha": "4d8d4709e04a38508074da44dfee0ca2f6fc901a", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd30241281333d73d504355b2f4d0ecd94f27b0e/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd30241281333d73d504355b2f4d0ecd94f27b0e/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=fd30241281333d73d504355b2f4d0ecd94f27b0e", "patch": "@@ -710,6 +710,11 @@ pub enum CaptureKind {\n     Value,\n     Ref(Mutability),\n }\n+impl CaptureKind {\n+    pub fn is_imm_ref(self) -> bool {\n+        self == Self::Ref(Mutability::Not)\n+    }\n+}\n impl std::ops::BitOr for CaptureKind {\n     type Output = Self;\n     fn bitor(self, rhs: Self) -> Self::Output {"}, {"sha": "d1815d0aec331692f66945f584d298fdb9e8d839", "filename": "tests/ui/option_if_let_else.fixed", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fd30241281333d73d504355b2f4d0ecd94f27b0e/tests%2Fui%2Foption_if_let_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fd30241281333d73d504355b2f4d0ecd94f27b0e/tests%2Fui%2Foption_if_let_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.fixed?ref=fd30241281333d73d504355b2f4d0ecd94f27b0e", "patch": "@@ -1,3 +1,4 @@\n+// edition:2018\n // run-rustfix\n #![warn(clippy::option_if_let_else)]\n #![allow(clippy::redundant_closure)]\n@@ -86,4 +87,65 @@ fn main() {\n     test_map_or_else(None);\n     let _ = negative_tests(None);\n     let _ = impure_else(None);\n+\n+    let _ = Some(0).map_or(0, |x| loop {\n+            if x == 0 {\n+                break x;\n+            }\n+        });\n+\n+    // #7576\n+    const fn _f(x: Option<u32>) -> u32 {\n+        // Don't lint, `map_or` isn't const\n+        if let Some(x) = x { x } else { 10 }\n+    }\n+\n+    // #5822\n+    let s = String::new();\n+    // Don't lint, `Some` branch consumes `s`, but else branch uses `s`\n+    let _ = if let Some(x) = Some(0) {\n+        let s = s;\n+        s.len() + x\n+    } else {\n+        s.len()\n+    };\n+\n+    let s = String::new();\n+    // Lint, both branches immutably borrow `s`.\n+    let _ = Some(0).map_or_else(|| s.len(), |x| s.len() + x);\n+\n+    let s = String::new();\n+    // Lint, `Some` branch consumes `s`, but else branch doesn't use `s`.\n+    let _ = Some(0).map_or(1, |x| {\n+        let s = s;\n+        s.len() + x\n+    });\n+\n+    let s = Some(String::new());\n+    // Don't lint, `Some` branch borrows `s`, but else branch consumes `s`\n+    let _ = if let Some(x) = &s {\n+        x.len()\n+    } else {\n+        let _s = s;\n+        10\n+    };\n+\n+    let mut s = Some(String::new());\n+    // Don't lint, `Some` branch mutably borrows `s`, but else branch also borrows  `s`\n+    let _ = if let Some(x) = &mut s {\n+        x.push_str(\"test\");\n+        x.len()\n+    } else {\n+        let _s = &s;\n+        10\n+    };\n+\n+    async fn _f1(x: u32) -> u32 {\n+        x\n+    }\n+\n+    async fn _f2() {\n+        // Don't lint. `await` can't be moved into a closure.\n+        let _ = if let Some(x) = Some(0) { _f1(x).await } else { 0 };\n+    }\n }"}, {"sha": "a15627338cb4aaeaa8460c83d03f5e30f5c86c2d", "filename": "tests/ui/option_if_let_else.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fd30241281333d73d504355b2f4d0ecd94f27b0e/tests%2Fui%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd30241281333d73d504355b2f4d0ecd94f27b0e/tests%2Fui%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.rs?ref=fd30241281333d73d504355b2f4d0ecd94f27b0e", "patch": "@@ -1,3 +1,4 @@\n+// edition:2018\n // run-rustfix\n #![warn(clippy::option_if_let_else)]\n #![allow(clippy::redundant_closure)]\n@@ -105,4 +106,71 @@ fn main() {\n     test_map_or_else(None);\n     let _ = negative_tests(None);\n     let _ = impure_else(None);\n+\n+    let _ = if let Some(x) = Some(0) {\n+        loop {\n+            if x == 0 {\n+                break x;\n+            }\n+        }\n+    } else {\n+        0\n+    };\n+\n+    // #7576\n+    const fn _f(x: Option<u32>) -> u32 {\n+        // Don't lint, `map_or` isn't const\n+        if let Some(x) = x { x } else { 10 }\n+    }\n+\n+    // #5822\n+    let s = String::new();\n+    // Don't lint, `Some` branch consumes `s`, but else branch uses `s`\n+    let _ = if let Some(x) = Some(0) {\n+        let s = s;\n+        s.len() + x\n+    } else {\n+        s.len()\n+    };\n+\n+    let s = String::new();\n+    // Lint, both branches immutably borrow `s`.\n+    let _ = if let Some(x) = Some(0) { s.len() + x } else { s.len() };\n+\n+    let s = String::new();\n+    // Lint, `Some` branch consumes `s`, but else branch doesn't use `s`.\n+    let _ = if let Some(x) = Some(0) {\n+        let s = s;\n+        s.len() + x\n+    } else {\n+        1\n+    };\n+\n+    let s = Some(String::new());\n+    // Don't lint, `Some` branch borrows `s`, but else branch consumes `s`\n+    let _ = if let Some(x) = &s {\n+        x.len()\n+    } else {\n+        let _s = s;\n+        10\n+    };\n+\n+    let mut s = Some(String::new());\n+    // Don't lint, `Some` branch mutably borrows `s`, but else branch also borrows  `s`\n+    let _ = if let Some(x) = &mut s {\n+        x.push_str(\"test\");\n+        x.len()\n+    } else {\n+        let _s = &s;\n+        10\n+    };\n+\n+    async fn _f1(x: u32) -> u32 {\n+        x\n+    }\n+\n+    async fn _f2() {\n+        // Don't lint. `await` can't be moved into a closure.\n+        let _ = if let Some(x) = Some(0) { _f1(x).await } else { 0 };\n+    }\n }"}, {"sha": "ed748ee8b39e4422c034f9a96982316dbb256745", "filename": "tests/ui/option_if_let_else.stderr", "status": "modified", "additions": 60, "deletions": 12, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/fd30241281333d73d504355b2f4d0ecd94f27b0e/tests%2Fui%2Foption_if_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd30241281333d73d504355b2f4d0ecd94f27b0e/tests%2Fui%2Foption_if_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.stderr?ref=fd30241281333d73d504355b2f4d0ecd94f27b0e", "patch": "@@ -1,5 +1,5 @@\n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:7:5\n+  --> $DIR/option_if_let_else.rs:8:5\n    |\n LL | /     if let Some(x) = string {\n LL | |         (true, x)\n@@ -11,19 +11,19 @@ LL | |     }\n    = note: `-D clippy::option-if-let-else` implied by `-D warnings`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:25:13\n+  --> $DIR/option_if_let_else.rs:26:13\n    |\n LL |     let _ = if let Some(s) = *string { s.len() } else { 0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `string.map_or(0, |s| s.len())`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:26:13\n+  --> $DIR/option_if_let_else.rs:27:13\n    |\n LL |     let _ = if let Some(s) = &num { s } else { &0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:27:13\n+  --> $DIR/option_if_let_else.rs:28:13\n    |\n LL |       let _ = if let Some(s) = &mut num {\n    |  _____________^\n@@ -43,13 +43,13 @@ LL ~     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:33:13\n+  --> $DIR/option_if_let_else.rs:34:13\n    |\n LL |     let _ = if let Some(ref s) = num { s } else { &0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:34:13\n+  --> $DIR/option_if_let_else.rs:35:13\n    |\n LL |       let _ = if let Some(mut s) = num {\n    |  _____________^\n@@ -69,7 +69,7 @@ LL ~     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:40:13\n+  --> $DIR/option_if_let_else.rs:41:13\n    |\n LL |       let _ = if let Some(ref mut s) = num {\n    |  _____________^\n@@ -89,7 +89,7 @@ LL ~     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:49:5\n+  --> $DIR/option_if_let_else.rs:50:5\n    |\n LL | /     if let Some(x) = arg {\n LL | |         let y = x * x;\n@@ -108,7 +108,7 @@ LL +     })\n    |\n \n error: use Option::map_or_else instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:62:13\n+  --> $DIR/option_if_let_else.rs:63:13\n    |\n LL |       let _ = if let Some(x) = arg {\n    |  _____________^\n@@ -120,7 +120,7 @@ LL | |     };\n    | |_____^ help: try: `arg.map_or_else(|| side_effect(), |x| x)`\n \n error: use Option::map_or_else instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:71:13\n+  --> $DIR/option_if_let_else.rs:72:13\n    |\n LL |       let _ = if let Some(x) = arg {\n    |  _____________^\n@@ -143,10 +143,58 @@ LL ~     }, |x| x * x * x * x);\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:100:13\n+  --> $DIR/option_if_let_else.rs:101:13\n    |\n LL |     let _ = if let Some(x) = optional { x + 2 } else { 5 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `optional.map_or(5, |x| x + 2)`\n \n-error: aborting due to 11 previous errors\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:110:13\n+   |\n+LL |       let _ = if let Some(x) = Some(0) {\n+   |  _____________^\n+LL | |         loop {\n+LL | |             if x == 0 {\n+LL | |                 break x;\n+...  |\n+LL | |         0\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL ~     let _ = Some(0).map_or(0, |x| loop {\n+LL +             if x == 0 {\n+LL +                 break x;\n+LL +             }\n+LL ~         });\n+   |\n+\n+error: use Option::map_or_else instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:138:13\n+   |\n+LL |     let _ = if let Some(x) = Some(0) { s.len() + x } else { s.len() };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Some(0).map_or_else(|| s.len(), |x| s.len() + x)`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:142:13\n+   |\n+LL |       let _ = if let Some(x) = Some(0) {\n+   |  _____________^\n+LL | |         let s = s;\n+LL | |         s.len() + x\n+LL | |     } else {\n+LL | |         1\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL ~     let _ = Some(0).map_or(1, |x| {\n+LL +         let s = s;\n+LL +         s.len() + x\n+LL ~     });\n+   |\n+\n+error: aborting due to 14 previous errors\n "}]}