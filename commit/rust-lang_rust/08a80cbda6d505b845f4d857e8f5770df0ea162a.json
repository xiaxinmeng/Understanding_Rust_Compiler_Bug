{"sha": "08a80cbda6d505b845f4d857e8f5770df0ea162a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4YTgwY2JkYTZkNTA1Yjg0NWY0ZDg1N2U4ZjU3NzBkZjBlYTE2MmE=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-03-08T00:01:23Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-03-28T17:38:55Z"}, "message": "Replace hoedown with pull in rustdoc", "tree": {"sha": "b40719b22e662668e7ef7796c2bcc53d3c31aa1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b40719b22e662668e7ef7796c2bcc53d3c31aa1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08a80cbda6d505b845f4d857e8f5770df0ea162a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08a80cbda6d505b845f4d857e8f5770df0ea162a", "html_url": "https://github.com/rust-lang/rust/commit/08a80cbda6d505b845f4d857e8f5770df0ea162a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08a80cbda6d505b845f4d857e8f5770df0ea162a/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccce2c6eb914a66571f60fa0afe8a46faa9fb3bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccce2c6eb914a66571f60fa0afe8a46faa9fb3bd", "html_url": "https://github.com/rust-lang/rust/commit/ccce2c6eb914a66571f60fa0afe8a46faa9fb3bd"}], "stats": {"total": 419, "additions": 312, "deletions": 107}, "files": [{"sha": "946818e7d2087addfb4fa174f780470a14522206", "filename": "src/Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08a80cbda6d505b845f4d857e8f5770df0ea162a/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/08a80cbda6d505b845f4d857e8f5770df0ea162a/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=08a80cbda6d505b845f4d857e8f5770df0ea162a", "patch": "@@ -772,6 +772,8 @@ dependencies = [\n  \"env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.0.0\",\n+ \"pulldown-cmark 0.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_eval 0.0.0\","}, {"sha": "2222077aae80bdeb24ff615a0f14a0fa57ed5d4f", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08a80cbda6d505b845f4d857e8f5770df0ea162a/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/08a80cbda6d505b845f4d857e8f5770df0ea162a/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=08a80cbda6d505b845f4d857e8f5770df0ea162a", "patch": "@@ -26,6 +26,7 @@ rustc_trans = { path = \"../librustc_trans\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n+pulldown-cmark = \"0.0.8\"\n \n [build-dependencies]\n build_helper = { path = \"../build_helper\" }"}, {"sha": "a745ccc822cda524f6e5b7b0aa0e68ffd20fb31f", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 308, "deletions": 107, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/08a80cbda6d505b845f4d857e8f5770df0ea162a/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a80cbda6d505b845f4d857e8f5770df0ea162a/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=08a80cbda6d505b845f4d857e8f5770df0ea162a", "patch": "@@ -30,9 +30,9 @@ use libc;\n use std::ascii::AsciiExt;\n use std::cell::RefCell;\n use std::default::Default;\n-use std::ffi::CString;\n+//use std::ffi::CString;\n use std::fmt::{self, Write};\n-use std::slice;\n+//use std::slice;\n use std::str;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::codemap::Span;\n@@ -43,6 +43,8 @@ use html::highlight;\n use html::escape::Escape;\n use test;\n \n+use pulldown_cmark::{self, Parser};\n+\n /// A unit struct which has the `fmt::Display` trait implemented. When\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n@@ -53,7 +55,7 @@ pub struct MarkdownWithToc<'a>(pub &'a str);\n /// A unit struct like `Markdown`, that renders the markdown escaping HTML tags.\n pub struct MarkdownHtml<'a>(pub &'a str);\n \n-const DEF_OUNIT: libc::size_t = 64;\n+/*const DEF_OUNIT: libc::size_t = 64;\n const HOEDOWN_EXT_NO_INTRA_EMPHASIS: libc::c_uint = 1 << 11;\n const HOEDOWN_EXT_TABLES: libc::c_uint = 1 << 0;\n const HOEDOWN_EXT_FENCED_CODE: libc::c_uint = 1 << 1;\n@@ -179,8 +181,8 @@ extern {\n     fn hoedown_document_free(md: *mut hoedown_document);\n \n     fn hoedown_buffer_new(unit: libc::size_t) -> *mut hoedown_buffer;\n-    fn hoedown_buffer_put(b: *mut hoedown_buffer, c: *const libc::c_char,\n-                          n: libc::size_t);\n+    /*fn hoedown_buffer_put(b: *mut hoedown_buffer, c: *const libc::c_char,\n+                          n: libc::size_t);*/\n     fn hoedown_buffer_puts(b: *mut hoedown_buffer, c: *const libc::c_char);\n     fn hoedown_buffer_free(b: *mut hoedown_buffer);\n \n@@ -191,7 +193,7 @@ impl hoedown_buffer {\n     fn as_bytes(&self) -> &[u8] {\n         unsafe { slice::from_raw_parts(self.data, self.size as usize) }\n     }\n-}\n+}*/\n \n /// Returns Some(code) if `s` is a line that should be stripped from\n /// documentation but used in example code. `code` is the portion of\n@@ -226,8 +228,8 @@ thread_local!(pub static PLAYGROUND: RefCell<Option<(Option<String>, String)>> =\n pub fn render(w: &mut fmt::Formatter,\n               s: &str,\n               print_toc: bool,\n-              html_flags: libc::c_uint) -> fmt::Result {\n-    extern fn block(ob: *mut hoedown_buffer, orig_text: *const hoedown_buffer,\n+              _html_flags: libc::c_uint) -> fmt::Result {\n+    /*extern fn block(ob: *mut hoedown_buffer, orig_text: *const hoedown_buffer,\n                     lang: *const hoedown_buffer, data: *const hoedown_renderer_data,\n                     line: libc::size_t) {\n         unsafe {\n@@ -422,76 +424,274 @@ pub fn render(w: &mut fmt::Formatter,\n         }\n         hoedown_buffer_free(ob);\n         ret\n+    }*/\n+\n+    fn block(parser: &mut Parser, lang: &str, buffer: &mut String) {\n+        let mut origtext = String::new();\n+        loop {\n+            let event = parser.next();\n+            if let Some(event) = event {\n+                match event {\n+                    pulldown_cmark::Event::End(\n+                        pulldown_cmark::Tag::CodeBlock(_)) => break,\n+                    pulldown_cmark::Event::Text(ref s) => {\n+                        origtext.push_str(s);\n+                    }\n+                    _ => {}\n+                }\n+            } else {\n+                break\n+            }\n+        }\n+        let origtext = origtext.trim_left();\n+        debug!(\"docblock: ==============\\n{:?}\\n=======\", origtext);\n+        let rendered = if lang.is_empty() || origtext.is_empty() {\n+            false\n+        } else {\n+            if !LangString::parse(lang).rust {\n+                /*(my_opaque.dfltblk)(ob, orig_text, lang,\n+                                    opaque as *const hoedown_renderer_data,\n+                                    line);*/\n+                // true\n+                false\n+            } else {\n+                false\n+            }\n+        };\n+\n+        let lines = origtext.lines().filter(|l| {\n+            stripped_filtered_line(*l).is_none()\n+        });\n+        let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n+        if rendered { return }\n+        PLAYGROUND.with(|play| {\n+            // insert newline to clearly separate it from the\n+            // previous block so we can shorten the html output\n+            let mut s = String::from(\"\\n\");\n+            let playground_button = play.borrow().as_ref().and_then(|&(ref krate, ref url)| {\n+                if url.is_empty() {\n+                    return None;\n+                }\n+                let test = origtext.lines().map(|l| {\n+                    stripped_filtered_line(l).unwrap_or(l)\n+                }).collect::<Vec<&str>>().join(\"\\n\");\n+                let krate = krate.as_ref().map(|s| &**s);\n+                let test = test::maketest(&test, krate, false,\n+                                          &Default::default());\n+                let channel = if test.contains(\"#![feature(\") {\n+                    \"&amp;version=nightly\"\n+                } else {\n+                    \"\"\n+                };\n+                // These characters don't need to be escaped in a URI.\n+                // FIXME: use a library function for percent encoding.\n+                fn dont_escape(c: u8) -> bool {\n+                    (b'a' <= c && c <= b'z') ||\n+                    (b'A' <= c && c <= b'Z') ||\n+                    (b'0' <= c && c <= b'9') ||\n+                    c == b'-' || c == b'_' || c == b'.' ||\n+                    c == b'~' || c == b'!' || c == b'\\'' ||\n+                    c == b'(' || c == b')' || c == b'*'\n+                }\n+                let mut test_escaped = String::new();\n+                for b in test.bytes() {\n+                    if dont_escape(b) {\n+                        test_escaped.push(char::from(b));\n+                    } else {\n+                        write!(test_escaped, \"%{:02X}\", b).unwrap();\n+                    }\n+                }\n+                Some(format!(\n+                    r#\"<a class=\"test-arrow\" target=\"_blank\" href=\"{}?code={}{}\">Run</a>\"#,\n+                    url, test_escaped, channel\n+                ))\n+            });\n+            s.push_str(&highlight::render_with_highlighting(\n+                           &text,\n+                           Some(\"rust-example-rendered\"),\n+                           None,\n+                           playground_button.as_ref().map(String::as_str)));\n+            buffer.push_str(&s);\n+        });\n     }\n-}\n \n-pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Span) {\n-    extern fn block(_ob: *mut hoedown_buffer,\n-                    text: *const hoedown_buffer,\n-                    lang: *const hoedown_buffer,\n-                    data: *const hoedown_renderer_data,\n-                    line: libc::size_t) {\n-        unsafe {\n-            if text.is_null() { return }\n-            let block_info = if lang.is_null() {\n-                LangString::all_false()\n+    fn header(parser: &mut Parser, level: i32, toc_builder: &mut Option<TocBuilder>,\n+              buffer: &mut String) {\n+        let mut ret = String::new();\n+        loop {\n+            let event = parser.next();\n+            if let Some(event) = event {\n+                match event {\n+                    pulldown_cmark::Event::End(\n+                        pulldown_cmark::Tag::Header(_)) => break,\n+                    pulldown_cmark::Event::Text(ref s) => {\n+                        ret.push_str(s);\n+                    }\n+                    _ => {}\n+                }\n             } else {\n-                let lang = (*lang).as_bytes();\n-                let s = str::from_utf8(lang).unwrap();\n-                LangString::parse(s)\n-            };\n-            if !block_info.rust { return }\n-            let text = (*text).as_bytes();\n-            let opaque = (*data).opaque as *mut hoedown_html_renderer_state;\n-            let tests = &mut *((*opaque).opaque as *mut ::test::Collector);\n-            let text = str::from_utf8(text).unwrap();\n-            let lines = text.lines().map(|l| {\n-                stripped_filtered_line(l).unwrap_or(l)\n-            });\n-            let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n-            let line = tests.get_line() + line;\n-            let filename = tests.get_filename();\n-            tests.add_test(text.to_owned(),\n-                           block_info.should_panic, block_info.no_run,\n-                           block_info.ignore, block_info.test_harness,\n-                           block_info.compile_fail, block_info.error_codes,\n-                           line, filename);\n+                break\n+            }\n         }\n+\n+        let id = ret.clone();\n+        // Discard '<em>', '<code>' tags and some escaped characters,\n+        // transform the contents of the header into a hyphenated string\n+        // without non-alphanumeric characters other than '-' and '_'.\n+        //\n+        // This is a terrible hack working around how hoedown gives us rendered\n+        // html for text rather than the raw text.\n+        let id = id.chars().filter_map(|c| {\n+            if c.is_alphanumeric() || c == '-' || c == '_' {\n+                if c.is_ascii() {\n+                    Some(c.to_ascii_lowercase())\n+                } else {\n+                    Some(c)\n+                }\n+            } else if c.is_whitespace() && c.is_ascii() {\n+                Some('-')\n+            } else {\n+                None\n+            }\n+        }).collect::<String>();\n+\n+        let id = derive_id(id);\n+\n+        let sec = toc_builder.as_mut().map_or(\"\".to_owned(), |builder| {\n+            format!(\"{} \", builder.push(level as u32, ret.clone(), id.clone()))\n+        });\n+\n+        // Render the HTML\n+        buffer.push_str(&format!(\"<h{lvl} id='{id}' class='section-header'>\\\n+                                  <a href='#{id}'>{sec}{}</a></h{lvl}>\",\n+                                 ret, lvl = level, id = id, sec = sec));\n     }\n \n-    extern fn header(_ob: *mut hoedown_buffer,\n-                     text: *const hoedown_buffer,\n-                     level: libc::c_int, data: *const hoedown_renderer_data,\n-                     _: libc::size_t) {\n-        unsafe {\n-            let opaque = (*data).opaque as *mut hoedown_html_renderer_state;\n-            let tests = &mut *((*opaque).opaque as *mut ::test::Collector);\n-            if text.is_null() {\n-                tests.register_header(\"\", level as u32);\n+    fn codespan(parser: &mut Parser, buffer: &mut String) {\n+        let mut content = String::new();\n+        loop {\n+            let event = parser.next();\n+            if let Some(event) = event {\n+                match event {\n+                    pulldown_cmark::Event::End(\n+                        pulldown_cmark::Tag::Code) => break,\n+                    pulldown_cmark::Event::Text(ref s) => {\n+                        content.push_str(s);\n+                    }\n+                    _ => {}\n+                }\n             } else {\n-                let text = (*text).as_bytes();\n-                let text = str::from_utf8(text).unwrap();\n-                tests.register_header(text, level as u32);\n+                break\n             }\n         }\n+        buffer.push_str(&format!(\"<code>{}</code>\", Escape(&collapse_whitespace(&content))));\n     }\n \n-    tests.set_position(position);\n-    unsafe {\n-        let ob = hoedown_buffer_new(DEF_OUNIT);\n-        let renderer = hoedown_html_renderer_new(0, 0);\n-        (*renderer).blockcode = Some(block);\n-        (*renderer).header = Some(header);\n-        (*((*renderer).opaque as *mut hoedown_html_renderer_state)).opaque\n-                = tests as *mut _ as *mut libc::c_void;\n+    let mut toc_builder = if print_toc {\n+        Some(TocBuilder::new())\n+    } else {\n+        None\n+    };\n+    let mut buffer = String::new();\n+    let mut parser = Parser::new(s);\n+    loop {\n+        let next_event = parser.next();\n+        if let Some(event) = next_event {\n+            match event {\n+                pulldown_cmark::Event::Start(pulldown_cmark::Tag::CodeBlock(s)) => {\n+                    block(&mut parser, &*s, &mut buffer);\n+                }\n+                pulldown_cmark::Event::Start(pulldown_cmark::Tag::Header(level)) => {\n+                    header(&mut parser, level, &mut toc_builder, &mut buffer);\n+                }\n+                pulldown_cmark::Event::Start(pulldown_cmark::Tag::Code) => {\n+                    codespan(&mut parser, &mut buffer);\n+                }\n+                _ => {}\n+            }\n+        } else {\n+            break\n+        }\n+    }\n+    let mut ret = toc_builder.map_or(Ok(()), |builder| {\n+        write!(w, \"<nav id=\\\"TOC\\\">{}</nav>\", builder.into_toc())\n+    });\n \n-        let document = hoedown_document_new(renderer, HOEDOWN_EXTENSIONS, 16);\n-        hoedown_document_render(document, ob, doc.as_ptr(),\n-                                doc.len() as libc::size_t);\n-        hoedown_document_free(document);\n+    if ret.is_ok() {\n+        ret = w.write_str(&buffer);\n+    }\n+    ret\n+}\n \n-        hoedown_html_renderer_free(renderer);\n-        hoedown_buffer_free(ob);\n+pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Span) {\n+    tests.set_position(position);\n+\n+    let mut parser = Parser::new(doc);\n+    let mut prev_offset = 0;\n+    let mut nb_lines = 0;\n+    let mut register_header = None;\n+    'main: loop {\n+        let next_event = parser.next();\n+        if let Some(event) = next_event {\n+            match event {\n+                pulldown_cmark::Event::Start(pulldown_cmark::Tag::CodeBlock(s)) => {\n+                    let block_info = if s.is_empty() {\n+                        LangString::all_false()\n+                    } else {\n+                        LangString::parse(&*s)\n+                    };\n+                    let mut test_s = String::new();\n+                    let mut offset = None;\n+                    loop {\n+                        let event = parser.next();\n+                        if let Some(event) = event {\n+                            match event {\n+                                pulldown_cmark::Event::End(\n+                                    pulldown_cmark::Tag::CodeBlock(_)) => break,\n+                                pulldown_cmark::Event::Text(ref s) => {\n+                                    test_s.push_str(s);\n+                                    if offset.is_none() {\n+                                        offset = Some(parser.get_offset());\n+                                    }\n+                                }\n+                                _ => {}\n+                            }\n+                        } else {\n+                            break 'main;\n+                        }\n+                    }\n+                    let offset = offset.unwrap_or(0);\n+                    let lines = test_s.lines().map(|l| {\n+                        stripped_filtered_line(l).unwrap_or(l)\n+                    });\n+                    let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n+                    nb_lines += doc[prev_offset..offset].lines().count();\n+                    let line = tests.get_line() + (nb_lines - 1);\n+                    let filename = tests.get_filename();\n+                    tests.add_test(text.to_owned(),\n+                                   block_info.should_panic, block_info.no_run,\n+                                   block_info.ignore, block_info.test_harness,\n+                                   block_info.compile_fail, block_info.error_codes,\n+                                   line, filename);\n+                    prev_offset = offset;\n+                }\n+                pulldown_cmark::Event::Start(pulldown_cmark::Tag::Header(level)) => {\n+                    register_header = Some(level as u32);\n+                }\n+                pulldown_cmark::Event::Text(ref s) if register_header.is_some() => {\n+                    let level = register_header.unwrap();\n+                    if s.is_empty() {\n+                        tests.register_header(\"\", level);\n+                    } else {\n+                        tests.register_header(s, level);\n+                    }\n+                    register_header = None;\n+                }\n+                _ => {}\n+            }\n+        } else {\n+            break\n+        }\n     }\n }\n \n@@ -589,57 +789,58 @@ impl<'a> fmt::Display for MarkdownHtml<'a> {\n         let MarkdownHtml(md) = *self;\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n-        render(fmt, md, false, HOEDOWN_HTML_ESCAPE)\n+        render(fmt, md, false, /*HOEDOWN_HTML_ESCAPE*/0)\n     }\n }\n \n pub fn plain_summary_line(md: &str) -> String {\n-    extern fn link(_ob: *mut hoedown_buffer,\n-                       _link: *const hoedown_buffer,\n-                       _title: *const hoedown_buffer,\n-                       content: *const hoedown_buffer,\n-                       data: *const hoedown_renderer_data,\n-                       _: libc::size_t) -> libc::c_int\n-    {\n-        unsafe {\n-            if !content.is_null() && (*content).size > 0 {\n-                let ob = (*data).opaque as *mut hoedown_buffer;\n-                hoedown_buffer_put(ob, (*content).data as *const libc::c_char,\n-                                   (*content).size);\n-            }\n-        }\n-        1\n+    struct ParserWrapper<'a> {\n+        inner: Parser<'a>,\n+        is_in: isize,\n+        is_first: bool,\n     }\n \n-    extern fn normal_text(_ob: *mut hoedown_buffer,\n-                          text: *const hoedown_buffer,\n-                          data: *const hoedown_renderer_data,\n-                          _: libc::size_t)\n-    {\n-        unsafe {\n-            let ob = (*data).opaque as *mut hoedown_buffer;\n-            hoedown_buffer_put(ob, (*text).data as *const libc::c_char,\n-                               (*text).size);\n+    impl<'a> Iterator for ParserWrapper<'a> {\n+        type Item = String;\n+\n+        fn next(&mut self) -> Option<String> {\n+            let next_event = self.inner.next();\n+            if next_event.is_none() {\n+                return None\n+            }\n+            let next_event = next_event.unwrap();\n+            let (ret, is_in) = match next_event {\n+                pulldown_cmark::Event::Start(pulldown_cmark::Tag::Paragraph) => (None, 1),\n+                pulldown_cmark::Event::Start(\n+                    pulldown_cmark::Tag::Link(_, ref t)) if !self.is_first => (Some(t.as_ref().to_owned()), 1),\n+                pulldown_cmark::Event::Text(ref s) if self.is_in > 0 => (Some(s.as_ref().to_owned()), 0),\n+                pulldown_cmark::Event::End(pulldown_cmark::Tag::Link(_, ref t)) => (Some(t.as_ref().to_owned()), -1),\n+                pulldown_cmark::Event::End(pulldown_cmark::Tag::Paragraph) => (None, -1),\n+                _ => (None, 0),\n+            };\n+            if is_in > 0 || (is_in < 0 && self.is_in > 0) {\n+                self.is_in += is_in;\n+            }\n+            if ret.is_some() {\n+                self.is_first = false;\n+                ret\n+            } else {\n+                Some(String::new())\n+            }\n         }\n     }\n-\n-    unsafe {\n-        let ob = hoedown_buffer_new(DEF_OUNIT);\n-        let mut plain_renderer: hoedown_renderer = ::std::mem::zeroed();\n-        let renderer: *mut hoedown_renderer = &mut plain_renderer;\n-        (*renderer).opaque = ob as *mut libc::c_void;\n-        (*renderer).link = Some(link);\n-        (*renderer).normal_text = Some(normal_text);\n-\n-        let document = hoedown_document_new(renderer, HOEDOWN_EXTENSIONS, 16);\n-        hoedown_document_render(document, ob, md.as_ptr(),\n-                                md.len() as libc::size_t);\n-        hoedown_document_free(document);\n-        let plain_slice = (*ob).as_bytes();\n-        let plain = str::from_utf8(plain_slice).unwrap_or(\"\").to_owned();\n-        hoedown_buffer_free(ob);\n-        plain\n+    let mut s = String::with_capacity(md.len() * 3 / 2);\n+    let mut p = ParserWrapper {\n+        inner: Parser::new(md),\n+        is_in: 0,\n+        is_first: true,\n+    };\n+    while let Some(t) = p.next() {\n+        if !t.is_empty() {\n+            s.push_str(&t);\n+        }\n     }\n+    s\n }\n \n #[cfg(test)]"}, {"sha": "efb51bdf471f48ad8f6517b6fe4215572d751e78", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08a80cbda6d505b845f4d857e8f5770df0ea162a/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a80cbda6d505b845f4d857e8f5770df0ea162a/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=08a80cbda6d505b845f4d857e8f5770df0ea162a", "patch": "@@ -48,6 +48,7 @@ extern crate test as testing;\n extern crate std_unicode;\n #[macro_use] extern crate log;\n extern crate rustc_errors as errors;\n+extern crate pulldown_cmark;\n \n extern crate serialize as rustc_serialize; // used by deriving\n "}]}