{"sha": "72bf201d61ac36f058cdea6a3487a27029fb65e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyYmYyMDFkNjFhYzM2ZjA1OGNkZWE2YTM0ODdhMjcwMjlmYjY1ZTY=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-09-21T11:32:57Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-10-09T11:22:42Z"}, "message": "std::rand: move the Isaac implementation to its own file.", "tree": {"sha": "0f0c3c5fa4b827128714ee3410f7924eef85070d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f0c3c5fa4b827128714ee3410f7924eef85070d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72bf201d61ac36f058cdea6a3487a27029fb65e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72bf201d61ac36f058cdea6a3487a27029fb65e6", "html_url": "https://github.com/rust-lang/rust/commit/72bf201d61ac36f058cdea6a3487a27029fb65e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72bf201d61ac36f058cdea6a3487a27029fb65e6/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a70df1d3cf12eae47536a96e26c1e7e0030b75a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a70df1d3cf12eae47536a96e26c1e7e0030b75a", "html_url": "https://github.com/rust-lang/rust/commit/3a70df1d3cf12eae47536a96e26c1e7e0030b75a"}], "stats": {"total": 391, "additions": 207, "deletions": 184}, "files": [{"sha": "d20b05db485c11d6a36b2ba819c51413990882ca", "filename": "src/libstd/rand/isaac.rs", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/72bf201d61ac36f058cdea6a3487a27029fb65e6/src%2Flibstd%2Frand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72bf201d61ac36f058cdea6a3487a27029fb65e6/src%2Flibstd%2Frand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fisaac.rs?ref=72bf201d61ac36f058cdea6a3487a27029fb65e6", "patch": "@@ -0,0 +1,198 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The ISAAC random number generator.\n+\n+use rand::{seed, Rng};\n+use iter::{Iterator, range, range_step};\n+use option::{None, Some};\n+\n+use cast;\n+use cmp;\n+use sys;\n+use vec;\n+\n+static RAND_SIZE_LEN: u32 = 8;\n+static RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n+\n+/// A random number generator that uses the [ISAAC\n+/// algorithm](http://en.wikipedia.org/wiki/ISAAC_%28cipher%29).\n+///\n+/// The ISAAC algorithm is suitable for cryptographic purposes.\n+pub struct IsaacRng {\n+    priv cnt: u32,\n+    priv rsl: [u32, .. RAND_SIZE],\n+    priv mem: [u32, .. RAND_SIZE],\n+    priv a: u32,\n+    priv b: u32,\n+    priv c: u32\n+}\n+\n+impl IsaacRng {\n+    /// Create an ISAAC random number generator with a random seed.\n+    pub fn new() -> IsaacRng {\n+        IsaacRng::new_seeded(seed(RAND_SIZE as uint * 4))\n+    }\n+\n+    /// Create an ISAAC random number generator with a seed. This can be any\n+    /// length, although the maximum number of bytes used is 1024 and any more\n+    /// will be silently ignored. A generator constructed with a given seed\n+    /// will generate the same sequence of values as all other generators\n+    /// constructed with the same seed.\n+    pub fn new_seeded(seed: &[u8]) -> IsaacRng {\n+        let mut rng = IsaacRng {\n+            cnt: 0,\n+            rsl: [0, .. RAND_SIZE],\n+            mem: [0, .. RAND_SIZE],\n+            a: 0, b: 0, c: 0\n+        };\n+\n+        let array_size = sys::size_of_val(&rng.rsl);\n+        let copy_length = cmp::min(array_size, seed.len());\n+\n+        // manually create a &mut [u8] slice of randrsl to copy into.\n+        let dest = unsafe { cast::transmute((&mut rng.rsl, array_size)) };\n+        vec::bytes::copy_memory(dest, seed, copy_length);\n+        rng.init(true);\n+        rng\n+    }\n+\n+    /// Create an ISAAC random number generator using the default\n+    /// fixed seed.\n+    pub fn new_unseeded() -> IsaacRng {\n+        let mut rng = IsaacRng {\n+            cnt: 0,\n+            rsl: [0, .. RAND_SIZE],\n+            mem: [0, .. RAND_SIZE],\n+            a: 0, b: 0, c: 0\n+        };\n+        rng.init(false);\n+        rng\n+    }\n+\n+    /// Initialises `self`. If `use_rsl` is true, then use the current value\n+    /// of `rsl` as a seed, otherwise construct one algorithmically (not\n+    /// randomly).\n+    fn init(&mut self, use_rsl: bool) {\n+        let mut a = 0x9e3779b9;\n+        let mut b = a;\n+        let mut c = a;\n+        let mut d = a;\n+        let mut e = a;\n+        let mut f = a;\n+        let mut g = a;\n+        let mut h = a;\n+\n+        macro_rules! mix(\n+            () => {{\n+                a^=b<<11; d+=a; b+=c;\n+                b^=c>>2;  e+=b; c+=d;\n+                c^=d<<8;  f+=c; d+=e;\n+                d^=e>>16; g+=d; e+=f;\n+                e^=f<<10; h+=e; f+=g;\n+                f^=g>>4;  a+=f; g+=h;\n+                g^=h<<8;  b+=g; h+=a;\n+                h^=a>>9;  c+=h; a+=b;\n+            }}\n+        );\n+\n+        do 4.times { mix!(); }\n+\n+        if use_rsl {\n+            macro_rules! memloop (\n+                ($arr:expr) => {{\n+                    for i in range_step(0u32, RAND_SIZE, 8) {\n+                        a+=$arr[i  ]; b+=$arr[i+1];\n+                        c+=$arr[i+2]; d+=$arr[i+3];\n+                        e+=$arr[i+4]; f+=$arr[i+5];\n+                        g+=$arr[i+6]; h+=$arr[i+7];\n+                        mix!();\n+                        self.mem[i  ]=a; self.mem[i+1]=b;\n+                        self.mem[i+2]=c; self.mem[i+3]=d;\n+                        self.mem[i+4]=e; self.mem[i+5]=f;\n+                        self.mem[i+6]=g; self.mem[i+7]=h;\n+                    }\n+                }}\n+            );\n+\n+            memloop!(self.rsl);\n+            memloop!(self.mem);\n+        } else {\n+            for i in range_step(0u32, RAND_SIZE, 8) {\n+                mix!();\n+                self.mem[i  ]=a; self.mem[i+1]=b;\n+                self.mem[i+2]=c; self.mem[i+3]=d;\n+                self.mem[i+4]=e; self.mem[i+5]=f;\n+                self.mem[i+6]=g; self.mem[i+7]=h;\n+            }\n+        }\n+\n+        self.isaac();\n+    }\n+\n+    /// Refills the output buffer (`self.rsl`)\n+    #[inline]\n+    fn isaac(&mut self) {\n+        self.c += 1;\n+        // abbreviations\n+        let mut a = self.a;\n+        let mut b = self.b + self.c;\n+\n+        static MIDPOINT: uint = RAND_SIZE as uint / 2;\n+\n+        macro_rules! ind (($x:expr) => {\n+            self.mem[($x >> 2) & (RAND_SIZE - 1)]\n+        });\n+        macro_rules! rngstep(\n+            ($j:expr, $shift:expr) => {{\n+                let base = $j;\n+                let mix = if $shift < 0 {\n+                    a >> -$shift as uint\n+                } else {\n+                    a << $shift as uint\n+                };\n+\n+                let x = self.mem[base  + mr_offset];\n+                a = (a ^ mix) + self.mem[base + m2_offset];\n+                let y = ind!(x) + a + b;\n+                self.mem[base + mr_offset] = y;\n+\n+                b = ind!(y >> RAND_SIZE_LEN) + x;\n+                self.rsl[base + mr_offset] = b;\n+            }}\n+        );\n+\n+        let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n+        for &(mr_offset, m2_offset) in r.iter() {\n+            for i in range_step(0u, MIDPOINT, 4) {\n+                rngstep!(i + 0, 13);\n+                rngstep!(i + 1, -6);\n+                rngstep!(i + 2, 2);\n+                rngstep!(i + 3, -16);\n+            }\n+        }\n+\n+        self.a = a;\n+        self.b = b;\n+        self.cnt = RAND_SIZE;\n+    }\n+}\n+\n+impl Rng for IsaacRng {\n+    #[inline]\n+    fn next(&mut self) -> u32 {\n+        if self.cnt == 0 {\n+            // make some more numbers\n+            self.isaac();\n+        }\n+        self.cnt -= 1;\n+        self.rsl[self.cnt]\n+    }\n+}"}, {"sha": "3348f5ee7f741cc7923bda77b3c8ec95d6a03eaf", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 9, "deletions": 184, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/72bf201d61ac36f058cdea6a3487a27029fb65e6/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72bf201d61ac36f058cdea6a3487a27029fb65e6/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=72bf201d61ac36f058cdea6a3487a27029fb65e6", "patch": "@@ -58,7 +58,10 @@ use uint;\n use vec;\n use libc::size_t;\n \n+pub use self::isaac::IsaacRng;\n+\n pub mod distributions;\n+pub mod isaac;\n \n /// A type that can be randomly generated using an Rng\n pub trait Rand {\n@@ -576,184 +579,6 @@ pub fn weak_rng() -> XorShiftRng {\n     XorShiftRng::new()\n }\n \n-static RAND_SIZE_LEN: u32 = 8;\n-static RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n-\n-/// A random number generator that uses the [ISAAC\n-/// algorithm](http://en.wikipedia.org/wiki/ISAAC_%28cipher%29).\n-///\n-/// The ISAAC algorithm is suitable for cryptographic purposes.\n-pub struct IsaacRng {\n-    priv cnt: u32,\n-    priv rsl: [u32, .. RAND_SIZE],\n-    priv mem: [u32, .. RAND_SIZE],\n-    priv a: u32,\n-    priv b: u32,\n-    priv c: u32\n-}\n-\n-impl IsaacRng {\n-    /// Create an ISAAC random number generator with a random seed.\n-    pub fn new() -> IsaacRng {\n-        IsaacRng::new_seeded(seed())\n-    }\n-\n-    /// Create an ISAAC random number generator with a seed. This can be any\n-    /// length, although the maximum number of bytes used is 1024 and any more\n-    /// will be silently ignored. A generator constructed with a given seed\n-    /// will generate the same sequence of values as all other generators\n-    /// constructed with the same seed.\n-    pub fn new_seeded(seed: &[u8]) -> IsaacRng {\n-        let mut rng = IsaacRng {\n-            cnt: 0,\n-            rsl: [0, .. RAND_SIZE],\n-            mem: [0, .. RAND_SIZE],\n-            a: 0, b: 0, c: 0\n-        };\n-\n-        let array_size = sys::size_of_val(&rng.rsl);\n-        let copy_length = cmp::min(array_size, seed.len());\n-\n-        // manually create a &mut [u8] slice of randrsl to copy into.\n-        let dest = unsafe { cast::transmute((&mut rng.rsl, array_size)) };\n-        vec::bytes::copy_memory(dest, seed, copy_length);\n-        rng.init(true);\n-        rng\n-    }\n-\n-    /// Create an ISAAC random number generator using the default\n-    /// fixed seed.\n-    pub fn new_unseeded() -> IsaacRng {\n-        let mut rng = IsaacRng {\n-            cnt: 0,\n-            rsl: [0, .. RAND_SIZE],\n-            mem: [0, .. RAND_SIZE],\n-            a: 0, b: 0, c: 0\n-        };\n-        rng.init(false);\n-        rng\n-    }\n-\n-    /// Initialises `self`. If `use_rsl` is true, then use the current value\n-    /// of `rsl` as a seed, otherwise construct one algorithmically (not\n-    /// randomly).\n-    fn init(&mut self, use_rsl: bool) {\n-        let mut a = 0x9e3779b9;\n-        let mut b = a;\n-        let mut c = a;\n-        let mut d = a;\n-        let mut e = a;\n-        let mut f = a;\n-        let mut g = a;\n-        let mut h = a;\n-\n-        macro_rules! mix(\n-            () => {{\n-                a^=b<<11; d+=a; b+=c;\n-                b^=c>>2;  e+=b; c+=d;\n-                c^=d<<8;  f+=c; d+=e;\n-                d^=e>>16; g+=d; e+=f;\n-                e^=f<<10; h+=e; f+=g;\n-                f^=g>>4;  a+=f; g+=h;\n-                g^=h<<8;  b+=g; h+=a;\n-                h^=a>>9;  c+=h; a+=b;\n-            }}\n-        );\n-\n-        do 4.times { mix!(); }\n-\n-        if use_rsl {\n-            macro_rules! memloop (\n-                ($arr:expr) => {{\n-                    for i in range_step(0u32, RAND_SIZE, 8) {\n-                        a+=$arr[i  ]; b+=$arr[i+1];\n-                        c+=$arr[i+2]; d+=$arr[i+3];\n-                        e+=$arr[i+4]; f+=$arr[i+5];\n-                        g+=$arr[i+6]; h+=$arr[i+7];\n-                        mix!();\n-                        self.mem[i  ]=a; self.mem[i+1]=b;\n-                        self.mem[i+2]=c; self.mem[i+3]=d;\n-                        self.mem[i+4]=e; self.mem[i+5]=f;\n-                        self.mem[i+6]=g; self.mem[i+7]=h;\n-                    }\n-                }}\n-            );\n-\n-            memloop!(self.rsl);\n-            memloop!(self.mem);\n-        } else {\n-            for i in range_step(0u32, RAND_SIZE, 8) {\n-                mix!();\n-                self.mem[i  ]=a; self.mem[i+1]=b;\n-                self.mem[i+2]=c; self.mem[i+3]=d;\n-                self.mem[i+4]=e; self.mem[i+5]=f;\n-                self.mem[i+6]=g; self.mem[i+7]=h;\n-            }\n-        }\n-\n-        self.isaac();\n-    }\n-\n-    /// Refills the output buffer (`self.rsl`)\n-    #[inline]\n-    fn isaac(&mut self) {\n-        self.c += 1;\n-        // abbreviations\n-        let mut a = self.a;\n-        let mut b = self.b + self.c;\n-\n-        static MIDPOINT: uint = RAND_SIZE as uint / 2;\n-\n-        macro_rules! ind (($x:expr) => {\n-            self.mem[($x >> 2) & (RAND_SIZE - 1)]\n-        });\n-        macro_rules! rngstep(\n-            ($j:expr, $shift:expr) => {{\n-                let base = $j;\n-                let mix = if $shift < 0 {\n-                    a >> -$shift as uint\n-                } else {\n-                    a << $shift as uint\n-                };\n-\n-                let x = self.mem[base  + mr_offset];\n-                a = (a ^ mix) + self.mem[base + m2_offset];\n-                let y = ind!(x) + a + b;\n-                self.mem[base + mr_offset] = y;\n-\n-                b = ind!(y >> RAND_SIZE_LEN) + x;\n-                self.rsl[base + mr_offset] = b;\n-            }}\n-        );\n-\n-        let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n-        for &(mr_offset, m2_offset) in r.iter() {\n-            for i in range_step(0u, MIDPOINT, 4) {\n-                rngstep!(i + 0, 13);\n-                rngstep!(i + 1, -6);\n-                rngstep!(i + 2, 2);\n-                rngstep!(i + 3, -16);\n-            }\n-        }\n-\n-        self.a = a;\n-        self.b = b;\n-        self.cnt = RAND_SIZE;\n-    }\n-}\n-\n-impl Rng for IsaacRng {\n-    #[inline]\n-    fn next(&mut self) -> u32 {\n-        if self.cnt == 0 {\n-            // make some more numbers\n-            self.isaac();\n-        }\n-        self.cnt -= 1;\n-        self.rsl[self.cnt]\n-    }\n-}\n-\n /// An [Xorshift random number\n /// generator](http://en.wikipedia.org/wiki/Xorshift).\n ///\n@@ -786,7 +611,8 @@ impl XorShiftRng {\n     pub fn new() -> XorShiftRng {\n         #[fixed_stack_segment]; #[inline(never)];\n \n-        // generate seeds the same way as seed(), except we have a spceific size\n+        // generate seeds the same way as seed(), except we have a\n+        // specific size, so we can just use a fixed buffer.\n         let mut s = [0u8, ..16];\n         loop {\n             do s.as_mut_buf |p, sz| {\n@@ -817,12 +643,11 @@ impl XorShiftRng {\n     }\n }\n \n-/// Create a new random seed.\n-pub fn seed() -> ~[u8] {\n+/// Create a new random seed of length `n`.\n+pub fn seed(n: uint) -> ~[u8] {\n     #[fixed_stack_segment]; #[inline(never)];\n \n     unsafe {\n-        let n = RAND_SIZE * 4;\n         let mut s = vec::from_elem(n as uint, 0_u8);\n         do s.as_mut_buf |p, sz| {\n             rustrt::rand_gen_seed(p, sz as size_t)\n@@ -844,7 +669,7 @@ pub fn task_rng() -> @mut IsaacRng {\n     let r = local_data::get(tls_rng_state, |k| k.map(|&k| *k));\n     match r {\n         None => {\n-            let rng = @@mut IsaacRng::new_seeded(seed());\n+            let rng = @@mut IsaacRng::new();\n             local_data::set(tls_rng_state, rng);\n             *rng\n         }\n@@ -877,7 +702,7 @@ mod test {\n \n     #[test]\n     fn test_rng_seeded() {\n-        let seed = seed();\n+        let seed = seed(400);\n         let mut ra = IsaacRng::new_seeded(seed);\n         let mut rb = IsaacRng::new_seeded(seed);\n         assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));"}]}