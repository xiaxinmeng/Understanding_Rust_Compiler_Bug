{"sha": "532446d3f8cc5bb1c01d4cdcced86ef1f3529897", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMjQ0NmQzZjhjYzViYjFjMDFkNGNkY2NlZDg2ZWYxZjM1Mjk4OTc=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-04-08T15:31:47Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-04-08T15:31:47Z"}, "message": "Rustup to 1.9.0-nightly (7979dd608 2016-04-07)", "tree": {"sha": "5bc4007e1bd350038a10adb2cb4e3371880d2a49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bc4007e1bd350038a10adb2cb4e3371880d2a49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/532446d3f8cc5bb1c01d4cdcced86ef1f3529897", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/532446d3f8cc5bb1c01d4cdcced86ef1f3529897", "html_url": "https://github.com/rust-lang/rust/commit/532446d3f8cc5bb1c01d4cdcced86ef1f3529897", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/532446d3f8cc5bb1c01d4cdcced86ef1f3529897/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76a831c60ff989446016ad0cfc519471661811f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/76a831c60ff989446016ad0cfc519471661811f1", "html_url": "https://github.com/rust-lang/rust/commit/76a831c60ff989446016ad0cfc519471661811f1"}], "stats": {"total": 65, "additions": 28, "deletions": 37}, "files": [{"sha": "4b8446e6201d6e038fcfa2847e8b06a5789cfa1b", "filename": "src/derive.rs", "status": "modified", "additions": 28, "deletions": 37, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/532446d3f8cc5bb1c01d4cdcced86ef1f3529897/src%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532446d3f8cc5bb1c01d4cdcced86ef1f3529897/src%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fderive.rs?ref=532446d3f8cc5bb1c01d4cdcced86ef1f3529897", "patch": "@@ -1,7 +1,6 @@\n use rustc::lint::*;\n use rustc::ty::subst::Subst;\n use rustc::ty::TypeVariants;\n-use rustc::ty::fast_reject::simplify_type;\n use rustc::ty;\n use rustc::hir::*;\n use syntax::ast::{Attribute, MetaItemKind};\n@@ -87,52 +86,44 @@ impl LateLintPass for Derive {\n }\n \n /// Implementation of the `DERIVE_HASH_XOR_EQ` lint.\n-fn check_hash_peq(cx: &LateContext, span: Span, trait_ref: &TraitRef, ty: ty::Ty, hash_is_automatically_derived: bool) {\n+fn check_hash_peq<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, trait_ref: &TraitRef, ty: ty::Ty<'tcx>, hash_is_automatically_derived: bool) {\n     if_let_chain! {[\n         match_path(&trait_ref.path, &HASH_PATH),\n         let Some(peq_trait_def_id) = cx.tcx.lang_items.eq_trait()\n     ], {\n         let peq_trait_def = cx.tcx.lookup_trait_def(peq_trait_def_id);\n \n-        cx.tcx.populate_implementations_for_trait_if_necessary(peq_trait_def.trait_ref.def_id);\n-        let peq_impls = peq_trait_def.borrow_impl_lists(cx.tcx).1;\n-\n         // Look for the PartialEq implementations for `ty`\n-        if_let_chain! {[\n-            let Some(simpl_ty) = simplify_type(cx.tcx, ty, false),\n-            let Some(impl_ids) = peq_impls.get(&simpl_ty)\n-        ], {\n-            for &impl_id in impl_ids {\n-                let peq_is_automatically_derived = cx.tcx.get_attrs(impl_id).iter().any(is_automatically_derived);\n+        peq_trait_def.for_each_relevant_impl(&cx.tcx, ty, |impl_id| {\n+            let peq_is_automatically_derived = cx.tcx.get_attrs(impl_id).iter().any(is_automatically_derived);\n \n-                if peq_is_automatically_derived == hash_is_automatically_derived {\n-                    return;\n-                }\n+            if peq_is_automatically_derived == hash_is_automatically_derived {\n+                return;\n+            }\n \n-                let trait_ref = cx.tcx.impl_trait_ref(impl_id).expect(\"must be a trait implementation\");\n-\n-                // Only care about `impl PartialEq<Foo> for Foo`\n-                if trait_ref.input_types()[0] == ty {\n-                    let mess = if peq_is_automatically_derived {\n-                        \"you are implementing `Hash` explicitly but have derived `PartialEq`\"\n-                    } else {\n-                        \"you are deriving `Hash` but have implemented `PartialEq` explicitly\"\n-                    };\n-\n-                    span_lint_and_then(\n-                        cx, DERIVE_HASH_XOR_EQ, span,\n-                        mess,\n-                        |db| {\n-                        if let Some(node_id) = cx.tcx.map.as_local_node_id(impl_id) {\n-                            db.span_note(\n-                                cx.tcx.map.span(node_id),\n-                                \"`PartialEq` implemented here\"\n-                            );\n-                        }\n-                    });\n-                }\n+            let trait_ref = cx.tcx.impl_trait_ref(impl_id).expect(\"must be a trait implementation\");\n+\n+            // Only care about `impl PartialEq<Foo> for Foo`\n+            if trait_ref.input_types()[0] == ty {\n+                let mess = if peq_is_automatically_derived {\n+                    \"you are implementing `Hash` explicitly but have derived `PartialEq`\"\n+                } else {\n+                    \"you are deriving `Hash` but have implemented `PartialEq` explicitly\"\n+                };\n+\n+                span_lint_and_then(\n+                    cx, DERIVE_HASH_XOR_EQ, span,\n+                    mess,\n+                    |db| {\n+                    if let Some(node_id) = cx.tcx.map.as_local_node_id(impl_id) {\n+                        db.span_note(\n+                            cx.tcx.map.span(node_id),\n+                            \"`PartialEq` implemented here\"\n+                        );\n+                    }\n+                });\n             }\n-        }}\n+        });\n     }}\n }\n "}]}