{"sha": "bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjNmVlY2QwYzJlZDc4NTRkNTJmYzgyM2JlMGIwOTNmM2JjNzZiYTg=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-03-17T01:56:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-17T01:56:52Z"}, "message": "Merge branch 'master' into frewsxcv-osstr", "tree": {"sha": "ba624a9e66a33fec8bcc8bc93734d03acbdd6688", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba624a9e66a33fec8bcc8bc93734d03acbdd6688"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "html_url": "https://github.com/rust-lang/rust/commit/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6adbbfc6ba8786ea91e1051ea14d64a91839f5b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6adbbfc6ba8786ea91e1051ea14d64a91839f5b5", "html_url": "https://github.com/rust-lang/rust/commit/6adbbfc6ba8786ea91e1051ea14d64a91839f5b5"}, {"sha": "0aeb9c12979e6da753701a798d04105b6b1a8c28", "url": "https://api.github.com/repos/rust-lang/rust/commits/0aeb9c12979e6da753701a798d04105b6b1a8c28", "html_url": "https://github.com/rust-lang/rust/commit/0aeb9c12979e6da753701a798d04105b6b1a8c28"}], "stats": {"total": 297, "additions": 244, "deletions": 53}, "files": [{"sha": "d6dded6dc5f7bccfbeb0d57a48f394d7b326f1f7", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/configure", "raw_url": "https://github.com/rust-lang/rust/raw/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "patch": "@@ -445,6 +445,7 @@ opt dist-host-only 0 \"only install bins for the host architecture\"\n opt inject-std-version 1 \"inject the current compiler version of libstd into programs\"\n opt llvm-version-check 1 \"check if the LLVM version is supported, build anyway\"\n opt codegen-tests 1 \"run the src/test/codegen tests\"\n+opt save-analysis 0 \"save API analysis data\"\n opt option-checking 1 \"complain about unrecognized options in this configure script\"\n opt ninja 0 \"build LLVM using the Ninja generator (for MSVC, requires building in the correct environment)\"\n opt locked-deps 0 \"force Cargo.lock to be up to date\""}, {"sha": "b1d1d79b9eaa3c58d4e8b4f5575f45c054a275aa", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "patch": "@@ -74,6 +74,7 @@ pub struct Config {\n     pub rustc_default_ar: Option<String>,\n     pub rust_optimize_tests: bool,\n     pub rust_debuginfo_tests: bool,\n+    pub rust_save_analysis: bool,\n     pub rust_dist_src: bool,\n \n     pub build: String,\n@@ -225,6 +226,7 @@ struct Rust {\n     optimize_tests: Option<bool>,\n     debuginfo_tests: Option<bool>,\n     codegen_tests: Option<bool>,\n+    save_analysis: Option<bool>,\n }\n \n /// TOML representation of how each build target is configured.\n@@ -350,6 +352,7 @@ impl Config {\n             set(&mut config.rust_optimize_tests, rust.optimize_tests);\n             set(&mut config.rust_debuginfo_tests, rust.debuginfo_tests);\n             set(&mut config.codegen_tests, rust.codegen_tests);\n+            set(&mut config.rust_save_analysis, rust.save_analysis);\n             set(&mut config.rust_rpath, rust.rpath);\n             set(&mut config.debug_jemalloc, rust.debug_jemalloc);\n             set(&mut config.use_jemalloc, rust.use_jemalloc);\n@@ -457,6 +460,7 @@ impl Config {\n                 (\"LOCAL_REBUILD\", self.local_rebuild),\n                 (\"NINJA\", self.ninja),\n                 (\"CODEGEN_TESTS\", self.codegen_tests),\n+                (\"SAVE_ANALYSIS\", self.rust_save_analysis),\n                 (\"LOCKED_DEPS\", self.locked_deps),\n                 (\"VENDOR\", self.vendor),\n                 (\"FULL_BOOTSTRAP\", self.full_bootstrap),"}, {"sha": "76fedae0f03ebb6189b0ab2695b0db1c7a948f16", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "patch": "@@ -234,6 +234,9 @@\n # saying that the FileCheck executable is missing, you may want to disable this.\n #codegen-tests = true\n \n+# Flag indicating whether the API analysis data should be saved.\n+#save-analysis = false\n+\n # =============================================================================\n # Options for specific targets\n #"}, {"sha": "289c1e1c3a99c5053883ee4eb42c900a7f511858", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "patch": "@@ -311,18 +311,14 @@ pub fn rust_src_location(build: &Build) -> PathBuf {\n \n /// Creates a tarball of save-analysis metadata, if available.\n pub fn analysis(build: &Build, compiler: &Compiler, target: &str) {\n+    if !build.config.rust_save_analysis {\n+        return\n+    }\n+\n     println!(\"Dist analysis\");\n \n-    if build.config.channel != \"nightly\" {\n-        println!(\"\\tskipping - not on nightly channel\");\n-        return;\n-    }\n     if compiler.host != build.config.build {\n-        println!(\"\\tskipping - not a build host\");\n-        return\n-    }\n-    if compiler.stage != 2 {\n-        println!(\"\\tskipping - not stage2\");\n+        println!(\"\\tskipping, not a build host\");\n         return\n     }\n "}, {"sha": "249f241a151bbd446dc3fc5c92661b954ceba9e2", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "patch": "@@ -49,6 +49,10 @@ pub fn install(build: &Build, stage: u32, host: &str) {\n         install_sh(&build, \"docs\", \"rust-docs\", stage, host, &prefix,\n                    &docdir, &libdir, &mandir, &empty_dir);\n     }\n+    if build.config.rust_save_analysis {\n+        install_sh(&build, \"analysis\", \"rust-analysis\", stage, host, &prefix,\n+                   &docdir, &libdir, &mandir, &empty_dir);\n+    }\n     install_sh(&build, \"std\", \"rust-std\", stage, host, &prefix,\n                &docdir, &libdir, &mandir, &empty_dir);\n     install_sh(&build, \"rustc\", \"rustc\", stage, host, &prefix,"}, {"sha": "2d2be531e628c5b075fb15a71479f8ba50c08d6b", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "patch": "@@ -524,7 +524,7 @@ impl Build {\n                  .env(format!(\"CFLAGS_{}\", target), self.cflags(target).join(\" \"));\n         }\n \n-        if self.config.channel == \"nightly\" && compiler.is_final_stage(self) {\n+        if self.config.rust_save_analysis && compiler.is_final_stage(self) {\n             cargo.env(\"RUSTC_SAVE_ANALYSIS\", \"api\".to_string());\n         }\n "}, {"sha": "d8b317a46c31e7f8653fbff7108a18ba5ec53529", "filename": "src/ci/run.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "patch": "@@ -43,6 +43,7 @@ fi\n if [ \"$DEPLOY$DEPLOY_ALT\" != \"\" ]; then\n   RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --release-channel=nightly\"\n   RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-llvm-static-stdcpp\"\n+  RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-save-analysis\"\n \n   if [ \"$NO_LLVM_ASSERTIONS\" = \"1\" ]; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --disable-llvm-assertions\""}, {"sha": "13c99a2d59bede98379d3a78ab7d4693951dc14b", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "patch": "@@ -1974,6 +1974,22 @@ impl<'a> From<&'a str> for String {\n     }\n }\n \n+// note: test pulls in libstd, which causes errors here\n+#[cfg(not(test))]\n+#[stable(feature = \"string_from_box\", since = \"1.17.0\")]\n+impl From<Box<str>> for String {\n+    fn from(s: Box<str>) -> String {\n+        s.into_string()\n+    }\n+}\n+\n+#[stable(feature = \"box_from_str\", since = \"1.17.0\")]\n+impl Into<Box<str>> for String {\n+    fn into(self) -> Box<str> {\n+        self.into_boxed_str()\n+    }\n+}\n+\n #[stable(feature = \"string_from_cow_str\", since = \"1.14.0\")]\n impl<'a> From<Cow<'a, str>> for String {\n     fn from(s: Cow<'a, str>) -> String {"}, {"sha": "e4a6af33409e164847a9e48698e531137e8a8901", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "patch": "@@ -1897,6 +1897,22 @@ impl<'a, T> From<Cow<'a, [T]>> for Vec<T> where [T]: ToOwned<Owned=Vec<T>> {\n     }\n }\n \n+// note: test pulls in libstd, which causes errors here\n+#[cfg(not(test))]\n+#[stable(feature = \"vec_from_box\", since = \"1.17.0\")]\n+impl<T> From<Box<[T]>> for Vec<T> {\n+    fn from(s: Box<[T]>) -> Vec<T> {\n+        s.into_vec()\n+    }\n+}\n+\n+#[stable(feature = \"box_from_vec\", since = \"1.17.0\")]\n+impl<T> Into<Box<[T]>> for Vec<T> {\n+    fn into(self) -> Box<[T]> {\n+        self.into_boxed_slice()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> From<&'a str> for Vec<u8> {\n     fn from(s: &'a str) -> Vec<u8> {"}, {"sha": "98d0b1c8e156594ab4a72570f7ac4cc033ebf56b", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "patch": "@@ -28,6 +28,7 @@\n #![feature(test)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n+#![feature(utf8_error_error_len)]\n \n extern crate collections;\n extern crate test;"}, {"sha": "c9b7104fec4f0072d2256f2b0de70153fd4648a9", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "patch": "@@ -540,6 +540,36 @@ fn from_utf8_mostly_ascii() {\n     }\n }\n \n+#[test]\n+fn from_utf8_error() {\n+    macro_rules! test {\n+        ($input: expr, $expected_valid_up_to: expr, $expected_error_len: expr) => {\n+            let error = from_utf8($input).unwrap_err();\n+            assert_eq!(error.valid_up_to(), $expected_valid_up_to);\n+            assert_eq!(error.error_len(), $expected_error_len);\n+        }\n+    }\n+    test!(b\"A\\xC3\\xA9 \\xFF \", 4, Some(1));\n+    test!(b\"A\\xC3\\xA9 \\x80 \", 4, Some(1));\n+    test!(b\"A\\xC3\\xA9 \\xC1 \", 4, Some(1));\n+    test!(b\"A\\xC3\\xA9 \\xC1\", 4, Some(1));\n+    test!(b\"A\\xC3\\xA9 \\xC2\", 4, None);\n+    test!(b\"A\\xC3\\xA9 \\xC2 \", 4, Some(1));\n+    test!(b\"A\\xC3\\xA9 \\xC2\\xC0\", 4, Some(1));\n+    test!(b\"A\\xC3\\xA9 \\xE0\", 4, None);\n+    test!(b\"A\\xC3\\xA9 \\xE0\\x9F\", 4, Some(1));\n+    test!(b\"A\\xC3\\xA9 \\xE0\\xA0\", 4, None);\n+    test!(b\"A\\xC3\\xA9 \\xE0\\xA0\\xC0\", 4, Some(2));\n+    test!(b\"A\\xC3\\xA9 \\xE0\\xA0 \", 4, Some(2));\n+    test!(b\"A\\xC3\\xA9 \\xED\\xA0\\x80 \", 4, Some(1));\n+    test!(b\"A\\xC3\\xA9 \\xF1\", 4, None);\n+    test!(b\"A\\xC3\\xA9 \\xF1\\x80\", 4, None);\n+    test!(b\"A\\xC3\\xA9 \\xF1\\x80\\x80\", 4, None);\n+    test!(b\"A\\xC3\\xA9 \\xF1 \", 4, Some(1));\n+    test!(b\"A\\xC3\\xA9 \\xF1\\x80 \", 4, Some(2));\n+    test!(b\"A\\xC3\\xA9 \\xF1\\x80\\x80 \", 4, Some(3));\n+}\n+\n #[test]\n fn test_as_bytes() {\n     // no null"}, {"sha": "2919adc1cbc631be284cde5884281d04113079fd", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 58, "deletions": 22, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "patch": "@@ -125,13 +125,14 @@ Section: Creating a string\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Utf8Error {\n     valid_up_to: usize,\n+    error_len: Option<u8>,\n }\n \n impl Utf8Error {\n     /// Returns the index in the given string up to which valid UTF-8 was\n     /// verified.\n     ///\n-    /// It is the maximum index such that `from_utf8(input[..index])`\n+    /// It is the maximum index such that `from_utf8(&input[..index])`\n     /// would return `Ok(_)`.\n     ///\n     /// # Examples\n@@ -152,6 +153,23 @@ impl Utf8Error {\n     /// ```\n     #[stable(feature = \"utf8_error\", since = \"1.5.0\")]\n     pub fn valid_up_to(&self) -> usize { self.valid_up_to }\n+\n+    /// Provide more information about the failure:\n+    ///\n+    /// * `None`: the end of the input was reached unexpectedly.\n+    ///   `self.valid_up_to()` is 1 to 3 bytes from the end of the input.\n+    ///   If a byte stream (such as a file or a network socket) is being decoded incrementally,\n+    ///   this could be a valid `char` whose UTF-8 byte sequence is spanning multiple chunks.\n+    ///\n+    /// * `Some(len)`: an unexpected byte was encountered.\n+    ///   The length provided is that of the invalid byte sequence\n+    ///   that starts at the index given by `valid_up_to()`.\n+    ///   Decoding should resume after that sequence\n+    ///   (after inserting a U+FFFD REPLACEMENT CHARACTER) in case of lossy decoding.\n+    #[unstable(feature = \"utf8_error_error_len\", reason =\"new\", issue = \"40494\")]\n+    pub fn error_len(&self) -> Option<usize> {\n+        self.error_len.map(|len| len as usize)\n+    }\n }\n \n /// Converts a slice of bytes to a string slice.\n@@ -300,7 +318,12 @@ pub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Utf8Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"invalid utf-8: invalid byte near index {}\", self.valid_up_to)\n+        if let Some(error_len) = self.error_len {\n+            write!(f, \"invalid utf-8 sequence of {} bytes from index {}\",\n+                   error_len, self.valid_up_to)\n+        } else {\n+            write!(f, \"incomplete utf-8 byte sequence from index {}\", self.valid_up_to)\n+        }\n     }\n }\n \n@@ -1241,25 +1264,27 @@ fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n \n     while index < len {\n         let old_offset = index;\n-        macro_rules! err { () => {{\n-            return Err(Utf8Error {\n-                valid_up_to: old_offset\n-            })\n-        }}}\n+        macro_rules! err {\n+            ($error_len: expr) => {\n+                return Err(Utf8Error {\n+                    valid_up_to: old_offset,\n+                    error_len: $error_len,\n+                })\n+            }\n+        }\n \n         macro_rules! next { () => {{\n             index += 1;\n             // we needed data, but there was none: error!\n             if index >= len {\n-                err!()\n+                err!(None)\n             }\n             v[index]\n         }}}\n \n         let first = v[index];\n         if first >= 128 {\n             let w = UTF8_CHAR_WIDTH[first as usize];\n-            let second = next!();\n             // 2-byte encoding is for codepoints  \\u{0080} to  \\u{07ff}\n             //        first  C2 80        last DF BF\n             // 3-byte encoding is for codepoints  \\u{0800} to  \\u{ffff}\n@@ -1279,25 +1304,36 @@ fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n             // UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /\n             //               %xF4 %x80-8F 2( UTF8-tail )\n             match w {\n-                2 => if second & !CONT_MASK != TAG_CONT_U8 {err!()},\n+                2 => if next!() & !CONT_MASK != TAG_CONT_U8 {\n+                    err!(Some(1))\n+                },\n                 3 => {\n-                    match (first, second, next!() & !CONT_MASK) {\n-                        (0xE0         , 0xA0 ... 0xBF, TAG_CONT_U8) |\n-                        (0xE1 ... 0xEC, 0x80 ... 0xBF, TAG_CONT_U8) |\n-                        (0xED         , 0x80 ... 0x9F, TAG_CONT_U8) |\n-                        (0xEE ... 0xEF, 0x80 ... 0xBF, TAG_CONT_U8) => {}\n-                        _ => err!()\n+                    match (first, next!()) {\n+                        (0xE0         , 0xA0 ... 0xBF) |\n+                        (0xE1 ... 0xEC, 0x80 ... 0xBF) |\n+                        (0xED         , 0x80 ... 0x9F) |\n+                        (0xEE ... 0xEF, 0x80 ... 0xBF) => {}\n+                        _ => err!(Some(1))\n+                    }\n+                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n+                        err!(Some(2))\n                     }\n                 }\n                 4 => {\n-                    match (first, second, next!() & !CONT_MASK, next!() & !CONT_MASK) {\n-                        (0xF0         , 0x90 ... 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n-                        (0xF1 ... 0xF3, 0x80 ... 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n-                        (0xF4         , 0x80 ... 0x8F, TAG_CONT_U8, TAG_CONT_U8) => {}\n-                        _ => err!()\n+                    match (first, next!()) {\n+                        (0xF0         , 0x90 ... 0xBF) |\n+                        (0xF1 ... 0xF3, 0x80 ... 0xBF) |\n+                        (0xF4         , 0x80 ... 0x8F) => {}\n+                        _ => err!(Some(1))\n+                    }\n+                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n+                        err!(Some(2))\n+                    }\n+                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n+                        err!(Some(3))\n                     }\n                 }\n-                _ => err!()\n+                _ => err!(Some(1))\n             }\n             index += 1;\n         } else {"}, {"sha": "2d14bb66bf4f976e6016832f1ff17050d008fe9c", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "patch": "@@ -325,7 +325,7 @@ impl CString {\n     }\n \n     /// Converts this `CString` into a boxed `CStr`.\n-    #[unstable(feature = \"into_boxed_c_str\", issue = \"0\")]\n+    #[unstable(feature = \"into_boxed_c_str\", issue = \"40380\")]\n     pub fn into_boxed_c_str(self) -> Box<CStr> {\n         unsafe { mem::transmute(self.into_inner()) }\n     }\n@@ -415,6 +415,20 @@ impl<'a> From<&'a CStr> for Box<CStr> {\n     }\n }\n \n+#[stable(feature = \"c_string_from_box\", since = \"1.17.0\")]\n+impl From<Box<CStr>> for CString {\n+    fn from(s: Box<CStr>) -> CString {\n+        s.into_c_string()\n+    }\n+}\n+\n+#[stable(feature = \"box_from_c_string\", since = \"1.17.0\")]\n+impl Into<Box<CStr>> for CString {\n+    fn into(self) -> Box<CStr> {\n+        self.into_boxed_c_str()\n+    }\n+}\n+\n #[stable(feature = \"default_box_extra\", since = \"1.17.0\")]\n impl Default for Box<CStr> {\n     fn default() -> Box<CStr> {\n@@ -728,6 +742,12 @@ impl CStr {\n     pub fn to_string_lossy(&self) -> Cow<str> {\n         String::from_utf8_lossy(self.to_bytes())\n     }\n+\n+    /// Converts a `Box<CStr>` into a `CString` without copying or allocating.\n+    #[unstable(feature = \"into_boxed_c_str\", issue = \"40380\")]\n+    pub fn into_c_string(self: Box<CStr>) -> CString {\n+        unsafe { mem::transmute(self) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -922,12 +942,11 @@ mod tests {\n     fn into_boxed() {\n         let orig: &[u8] = b\"Hello, world!\\0\";\n         let cstr = CStr::from_bytes_with_nul(orig).unwrap();\n-        let cstring = cstr.to_owned();\n-        let box1: Box<CStr> = Box::from(cstr);\n-        let box2 = cstring.into_boxed_c_str();\n-        assert_eq!(cstr, &*box1);\n-        assert_eq!(box1, box2);\n-        assert_eq!(&*box2, cstr);\n+        let boxed: Box<CStr> = Box::from(cstr);\n+        let cstring = cstr.to_owned().into_boxed_c_str().into_c_string();\n+        assert_eq!(cstr, &*boxed);\n+        assert_eq!(&*boxed, &*cstring);\n+        assert_eq!(&*cstring, cstr);\n     }\n \n     #[test]"}, {"sha": "bf3f41b13c18493b87c6bfe1280787d03fc7b255", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "patch": "@@ -260,7 +260,7 @@ impl OsString {\n     ///\n     /// let b: Box<OsStr> = s.into_boxed_os_str();\n     /// ```\n-    #[unstable(feature = \"into_boxed_os_str\", issue = \"0\")]\n+    #[unstable(feature = \"into_boxed_os_str\", issue = \"40380\")]\n     pub fn into_boxed_os_str(self) -> Box<OsStr> {\n         unsafe { mem::transmute(self.inner.into_box()) }\n     }\n@@ -506,6 +506,13 @@ impl OsStr {\n         self.inner.inner.len()\n     }\n \n+    /// Converts a `Box<OsStr>` into an `OsString` without copying or allocating.\n+    #[unstable(feature = \"into_boxed_os_str\", issue = \"40380\")]\n+    pub fn into_os_string(self: Box<OsStr>) -> OsString {\n+        let inner: Box<Slice> = unsafe { mem::transmute(self) };\n+        OsString { inner: Buf::from_box(inner) }\n+    }\n+\n     /// Gets the underlying byte representation.\n     ///\n     /// Note: it is *crucial* that this API is private, to avoid\n@@ -522,6 +529,20 @@ impl<'a> From<&'a OsStr> for Box<OsStr> {\n     }\n }\n \n+#[stable(feature = \"os_string_from_box\", since = \"1.17.0\")]\n+impl<'a> From<Box<OsStr>> for OsString {\n+    fn from(boxed: Box<OsStr>) -> OsString {\n+        boxed.into_os_string()\n+    }\n+}\n+\n+#[stable(feature = \"box_from_c_string\", since = \"1.17.0\")]\n+impl Into<Box<OsStr>> for OsString {\n+    fn into(self) -> Box<OsStr> {\n+        self.into_boxed_os_str()\n+    }\n+}\n+\n #[stable(feature = \"box_default_extra\", since = \"1.17.0\")]\n impl Default for Box<OsStr> {\n     fn default() -> Box<OsStr> {\n@@ -830,12 +851,11 @@ mod tests {\n     fn into_boxed() {\n         let orig = \"Hello, world!\";\n         let os_str = OsStr::new(orig);\n-        let os_string = os_str.to_owned();\n-        let box1: Box<OsStr> = Box::from(os_str);\n-        let box2 = os_string.into_boxed_os_str();\n-        assert_eq!(os_str, &*box1);\n-        assert_eq!(box1, box2);\n-        assert_eq!(&*box2, os_str);\n+        let boxed: Box<OsStr> = Box::from(os_str);\n+        let os_string = os_str.to_owned().into_boxed_os_str().into_os_string();\n+        assert_eq!(os_str, &*boxed);\n+        assert_eq!(&*boxed, &*os_string);\n+        assert_eq!(&*os_string, os_str);\n     }\n \n     #[test]"}, {"sha": "49b01bc0853732335af1274a22a92f45425f8157", "filename": "src/libstd/path.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "patch": "@@ -1196,7 +1196,7 @@ impl PathBuf {\n     }\n \n     /// Converts this `PathBuf` into a boxed `Path`.\n-    #[unstable(feature = \"into_boxed_path\", issue = \"0\")]\n+    #[unstable(feature = \"into_boxed_path\", issue = \"40380\")]\n     pub fn into_boxed_path(self) -> Box<Path> {\n         unsafe { mem::transmute(self.inner.into_boxed_os_str()) }\n     }\n@@ -1210,6 +1210,20 @@ impl<'a> From<&'a Path> for Box<Path> {\n     }\n }\n \n+#[stable(feature = \"path_buf_from_box\", since = \"1.17.0\")]\n+impl<'a> From<Box<Path>> for PathBuf {\n+    fn from(boxed: Box<Path>) -> PathBuf {\n+        boxed.into_path_buf()\n+    }\n+}\n+\n+#[stable(feature = \"box_from_path_buf\", since = \"1.17.0\")]\n+impl Into<Box<Path>> for PathBuf {\n+    fn into(self) -> Box<Path> {\n+        self.into_boxed_path()\n+    }\n+}\n+\n #[stable(feature = \"box_default_extra\", since = \"1.17.0\")]\n impl Default for Box<Path> {\n     fn default() -> Box<Path> {\n@@ -2089,6 +2103,13 @@ impl Path {\n     pub fn is_dir(&self) -> bool {\n         fs::metadata(self).map(|m| m.is_dir()).unwrap_or(false)\n     }\n+\n+    /// Converts a `Box<Path>` into a `PathBuf` without copying or allocating.\n+    #[unstable(feature = \"into_boxed_path\", issue = \"40380\")]\n+    pub fn into_path_buf(self: Box<Path>) -> PathBuf {\n+        let inner: Box<OsStr> = unsafe { mem::transmute(self) };\n+        PathBuf { inner: OsString::from(inner) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -3703,12 +3724,11 @@ mod tests {\n     fn into_boxed() {\n         let orig: &str = \"some/sort/of/path\";\n         let path = Path::new(orig);\n-        let path_buf = path.to_owned();\n-        let box1: Box<Path> = Box::from(path);\n-        let box2 = path_buf.into_boxed_path();\n-        assert_eq!(path, &*box1);\n-        assert_eq!(box1, box2);\n-        assert_eq!(&*box2, path);\n+        let boxed: Box<Path> = Box::from(path);\n+        let path_buf = path.to_owned().into_boxed_path().into_path_buf();\n+        assert_eq!(path, &*boxed);\n+        assert_eq!(&*boxed, &*path_buf);\n+        assert_eq!(&*path_buf, path);\n     }\n \n     #[test]"}, {"sha": "c2bba07f68ce0be0e346aa0763759cd97da51198", "filename": "src/libstd/sys/redox/os_str.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibstd%2Fsys%2Fredox%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibstd%2Fsys%2Fredox%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fos_str.rs?ref=bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "patch": "@@ -104,6 +104,12 @@ impl Buf {\n     pub fn into_box(self) -> Box<Slice> {\n         unsafe { mem::transmute(self.inner.into_boxed_slice()) }\n     }\n+\n+    #[inline]\n+    pub fn from_box(boxed: Box<Slice>) -> Buf {\n+        let inner: Box<[u8]> = unsafe { mem::transmute(boxed) };\n+        Buf { inner: inner.into_vec() }\n+    }\n }\n \n impl Slice {"}, {"sha": "f5b942d3343dc23e5ba221a9b498855e2c71448d", "filename": "src/libstd/sys/unix/os_str.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs?ref=bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "patch": "@@ -104,6 +104,12 @@ impl Buf {\n     pub fn into_box(self) -> Box<Slice> {\n         unsafe { mem::transmute(self.inner.into_boxed_slice()) }\n     }\n+\n+    #[inline]\n+    pub fn from_box(boxed: Box<Slice>) -> Buf {\n+        let inner: Box<[u8]> = unsafe { mem::transmute(boxed) };\n+        Buf { inner: inner.into_vec() }\n+    }\n }\n \n impl Slice {"}, {"sha": "f401e7b35c8d8d6c78c360733f8e6d99f724d8f1", "filename": "src/libstd/sys/windows/os_str.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs?ref=bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "patch": "@@ -97,6 +97,12 @@ impl Buf {\n     pub fn into_box(self) -> Box<Slice> {\n         unsafe { mem::transmute(self.inner.into_box()) }\n     }\n+\n+    #[inline]\n+    pub fn from_box(boxed: Box<Slice>) -> Buf {\n+        let inner: Box<Wtf8> = unsafe { mem::transmute(boxed) };\n+        Buf { inner: Wtf8Buf::from_box(inner) }\n+    }\n }\n \n impl Slice {"}, {"sha": "79aaf34ce2e0f5d68d18ea134f7cefa4275b20f2", "filename": "src/libstd/sys_common/wtf8.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fwtf8.rs?ref=bc6eecd0c2ed7854d52fc823be0b093f3bc76ba8", "patch": "@@ -351,6 +351,12 @@ impl Wtf8Buf {\n     pub fn into_box(self) -> Box<Wtf8> {\n         unsafe { mem::transmute(self.bytes.into_boxed_slice()) }\n     }\n+\n+    /// Converts a `Box<Wtf8>` into a `Wtf8Buf`.\n+    pub fn from_box(boxed: Box<Wtf8>) -> Wtf8Buf {\n+        let bytes: Box<[u8]> = unsafe { mem::transmute(boxed) };\n+        Wtf8Buf { bytes: bytes.into_vec() }\n+    }\n }\n \n /// Create a new WTF-8 string from an iterator of code points."}]}