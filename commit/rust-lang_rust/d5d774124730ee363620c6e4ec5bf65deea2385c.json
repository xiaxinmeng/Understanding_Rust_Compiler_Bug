{"sha": "d5d774124730ee363620c6e4ec5bf65deea2385c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1ZDc3NDEyNDczMGVlMzYzNjIwYzZlNGVjNWJmNjVkZWVhMjM4NWM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-07T05:23:16Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-07T05:24:15Z"}, "message": "Overhaul mods and crates section of tutorial", "tree": {"sha": "afe2f61bafa74986678ef4d697cca21b7a237268", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afe2f61bafa74986678ef4d697cca21b7a237268"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5d774124730ee363620c6e4ec5bf65deea2385c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5d774124730ee363620c6e4ec5bf65deea2385c", "html_url": "https://github.com/rust-lang/rust/commit/d5d774124730ee363620c6e4ec5bf65deea2385c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5d774124730ee363620c6e4ec5bf65deea2385c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5c95de212d7851c7f8788a328455ed381e38978", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5c95de212d7851c7f8788a328455ed381e38978", "html_url": "https://github.com/rust-lang/rust/commit/f5c95de212d7851c7f8788a328455ed381e38978"}], "stats": {"total": 317, "additions": 154, "deletions": 163}, "files": [{"sha": "727882d30994cf2b96425be5aace15f8dd6a302f", "filename": "doc/lib/codemirror-rust.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5d774124730ee363620c6e4ec5bf65deea2385c/doc%2Flib%2Fcodemirror-rust.js", "raw_url": "https://github.com/rust-lang/rust/raw/d5d774124730ee363620c6e4ec5bf65deea2385c/doc%2Flib%2Fcodemirror-rust.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Flib%2Fcodemirror-rust.js?ref=d5d774124730ee363620c6e4ec5bf65deea2385c", "patch": "@@ -9,7 +9,7 @@ CodeMirror.defineMode(\"rust\", function() {\n     \"as\": \"op\", \"true\": \"atom\", \"false\": \"atom\", \"assert\": \"op\", \"check\": \"op\",\n     \"claim\": \"op\", \"extern\": \"ignore\", \"unsafe\": \"ignore\", \"import\": \"else-style\",\n     \"export\": \"else-style\", \"copy\": \"op\", \"log\": \"op\",\n-    \"use\": \"op\", \"self\": \"atom\"\n+    \"use\": \"op\", \"self\": \"atom\", \"pub\": \"atom\", \"priv\": \"atom\"\n   };\n   var typeKeywords = function() {\n     var keywords = {\"fn\": \"fn\"};"}, {"sha": "f73ddd1b4c46537e054db32845ce3fb809b7023e", "filename": "doc/tutorial.md", "status": "modified", "additions": 153, "deletions": 162, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/d5d774124730ee363620c6e4ec5bf65deea2385c/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/d5d774124730ee363620c6e4ec5bf65deea2385c/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=d5d774124730ee363620c6e4ec5bf65deea2385c", "patch": "@@ -31,7 +31,7 @@ pleasant high-level features include:\n \n This is an introductory tutorial for the Rust programming language. It\n covers the fundamentals of the language, including the syntax, the\n-type system and memory model, and generics.  [Additional\n+type system and memory model, generics, and modules. [Additional\n tutorials](#what-next) cover specific language features in greater\n depth.\n \n@@ -2113,61 +2113,123 @@ This usage of traits is similar to Java interfaces.\n \n # Modules and crates\n \n-The Rust namespace is divided into modules. Each source file starts\n-with its own module.\n-\n-## Local modules\n-\n-The `mod` keyword can be used to open a new, local module. In the\n-example below, `chicken` lives in the module `farm`, so, unless you\n-explicitly import it, you must refer to it by its long name,\n-`farm::chicken`.\n+The Rust namespace is arranged in a hierarchy of modules. Each source\n+(.rs) file represents a single module and may in turn contain\n+additional modules.\n \n ~~~~\n mod farm {\n     pub fn chicken() -> ~str { ~\"cluck cluck\" }\n     pub fn cow() -> ~str { ~\"mooo\" }\n }\n+\n fn main() {\n     io::println(farm::chicken());\n }\n ~~~~\n \n-Modules can be nested to arbitrary depth.\n+The contents of modules can be imported into the current scope\n+with the `use` keyword, optionally giving it an alias. `use`\n+may appear at the beginning of crates, `mod`s, `fn`s, and other\n+blocks.\n+\n+~~~\n+# mod farm { pub fn chicken() { } }\n+# fn main() {\n+// Bring `chicken` into scope\n+use farm::chicken;\n+\n+fn chicken_farmer() {\n+    // The same, but name it `my_chicken`\n+    use my_chicken = farm::chicken;\n+    ...\n+}\n+# }\n+~~~\n+\n+These farm animal functions have a new keyword, `pub`, attached to\n+them.  This is a visibility modifier that allows item to be accessed\n+outside of the module in which they are declared, using `::`, as in\n+`farm::chicken`. Items, like `fn`, `struct`, etc. are private by\n+default.\n+\n+Visibility restrictions in Rust exist only at module boundaries. This\n+is quite different from most object-oriented languages that also enforce\n+restrictions on objects themselves. That's not to say that Rust doesn't\n+support encapsulation - both struct fields and methods can be private -\n+but it is at the module level, not the class level. Note that fields\n+and methods are _public_ by default.\n+\n+~~~\n+mod farm {\n+# pub fn make_me_a_farm() -> farm::Farm { farm::Farm { chickens: ~[], cows: ~[], farmer: Human(0) } }\n+    pub struct Farm {\n+        priv mut chickens: ~[Chicken],\n+        priv mut cows: ~[Cow],\n+        farmer: Human\n+    }\n+\n+    // Note - visibility modifiers on impls currently have no effect\n+    impl Farm {\n+        priv fn feed_chickens() { ... }\n+        priv fn feed_cows() { ... }\n+        fn add_chicken(c: Chicken) { ... }\n+    }\n+\n+    pub fn feed_animals(farm: &Farm) {\n+        farm.feed_chickens();\n+        farm.feed_cows();\n+    }\n+}\n+\n+fn main() {\n+     let f = make_me_a_farm();\n+     f.add_chicken(make_me_a_chicken());\n+     farm::feed_animals(&f);\n+     f.farmer.rest();\n+}\n+# type Chicken = int;\n+# type Cow = int;\n+# enum Human = int;\n+# fn make_me_a_farm() -> farm::Farm { farm::make_me_a_farm() }\n+# fn make_me_a_chicken() -> Chicken { 0 }\n+# impl Human { fn rest() { } }\n+~~~\n \n ## Crates\n \n-The unit of independent compilation in Rust is the crate. Libraries\n-tend to be packaged as crates, and your own programs may consist of\n-one or more crates.\n+The unit of independent compilation in Rust is the crate - rustc\n+compiles a single crate at a time, from which it produces either a\n+library or executable.\n \n When compiling a single `.rs` file, the file acts as the whole crate.\n You can compile it with the `--lib` compiler switch to create a shared\n library, or without, provided that your file contains a `fn main`\n somewhere, to create an executable.\n \n-It is also possible to include multiple files in a crate. For this\n-purpose, you create a `.rc` crate file, which references any number of\n-`.rs` code files. A crate file could look like this:\n+Larger crates typically span multiple files and are compiled from\n+a crate (.rc) file. Crate files contain their own syntax for loading\n+modules from .rs files and typically include metadata about the crate.\n \n-~~~~ {.ignore}\n+~~~~ { .xfail-test }\n #[link(name = \"farm\", vers = \"2.5\", author = \"mjh\")];\n #[crate_type = \"lib\"];\n+\n mod cow;\n mod chicken;\n mod horse;\n ~~~~\n \n Compiling this file will cause `rustc` to look for files named\n-`cow.rs`, `chicken.rs`, `horse.rs` in the same directory as the `.rc`\n-file, compile them all together, and, depending on the presence of the\n-`crate_type = \"lib\"` attribute, output a shared library or an executable.\n-(If the line `#[crate_type = \"lib\"];` was omitted, `rustc` would create an\n-executable.)\n+`cow.rs`, `chicken.rs`, and `horse.rs` in the same directory as the\n+`.rc` file, compile them all together, and, based on the presence of\n+the `crate_type = \"lib\"` attribute, output a shared library or an\n+executable.  (If the line `#[crate_type = \"lib\"];` was omitted,\n+`rustc` would create an executable.)\n \n-The `#[link(...)]` part provides meta information about the module,\n-which other crates can use to load the right module. More about that\n-later.\n+The `#[link(...)]` attribute provides meta information about the\n+module, which other crates can use to load the right module. More\n+about that later.\n \n To have a nested directory structure for your source files, you can\n nest mods in your `.rc` file:\n@@ -2184,56 +2246,65 @@ The compiler will now look for `poultry/chicken.rs` and\n and `poultry::turkey`. You can also provide a `poultry.rs` to add\n content to the `poultry` module itself.\n \n-The compiler then builds the crate as a platform-specific shared library or\n-executable which can be distributed.\n+When compiling .rc files, if rustc finds a .rs file with the same\n+name, then that .rs file provides the top-level content of the crate.\n \n-## Using other crates\n+~~~ {.xfail-test}\n+// foo.rc\n+#[link(name = \"foo\", vers=\"1.0\")];\n \n-Having compiled a crate that contains the `#[crate_type = \"lib\"]`\n-attribute, you can use it in another crate with a `use`\n-directive. We've already seen `extern mod std` in several of the\n-examples, which loads in the [standard library][std].\n+mod bar;\n+~~~\n \n-[std]: http://doc.rust-lang.org/doc/std/index/General.html\n+~~~ {.xfail-test}\n+// foo.rs\n+fn main() { bar::baz(); }\n+~~~\n \n-`use` directives can appear in a crate file, or at the top level of a\n-single-file `.rs` crate. They will cause the compiler to search its\n-library search path (which you can extend with `-L` switch) for a Rust\n-crate library with the right name.\n+> ***Note***: The way rustc looks for .rs files to pair with .rc\n+> files is a major source of confusion and will change. It's likely\n+> that the crate and source file grammars will merge.\n \n-It is possible to provide more specific information when using an\n-external crate.\n+> ***Note***: The way that directory modules are handled will also\n+> change. The code for directory modules currently lives in a .rs\n+> file with the same name as the directory, _next to_ the directory.\n+> A new scheme will make that file live _inside_ the directory.\n \n-~~~~ {.ignore}\n-extern mod myfarm (name = \"farm\", vers = \"2.7\");\n-~~~~\n+## Using other crates\n+\n+Having compiled a crate into a library you can use it in another crate\n+with an `extern mod` directive. `extern mod` can appear at the top of\n+a crate file or at the top of modules. It will cause the compiler to\n+look in the library search path (which you can extend with `-L`\n+switch) for a compiled Rust library with the right name, then add a\n+module with that crate's name into the local scope.\n \n-When a comma-separated list of name/value pairs is given after `use`,\n-these are matched against the attributes provided in the `link`\n+For example, `extern mod std` links the [standard library].\n+\n+[standard library]: std/index.html\n+\n+When a comma-separated list of name/value pairs is given after `extern\n+mod`, these are matched against the attributes provided in the `link`\n attribute of the crate file, and a crate is only used when the two\n match. A `name` value can be given to override the name used to search\n-for the crate. So the above would import the `farm` crate under the\n-local name `myfarm`.\n+for the crate.\n \n Our example crate declared this set of `link` attributes:\n \n-~~~~ {.ignore}\n+~~~~ {.xfail-test}\n #[link(name = \"farm\", vers = \"2.5\", author = \"mjh\")];\n ~~~~\n \n-The version does not match the one provided in the `use` directive, so\n-unless the compiler can find another crate with the right version\n-somewhere, it will complain that no matching crate was found.\n-\n-## The core library\n+Which can then be linked with any (or all) of the following:\n \n-A set of basic library routines, mostly related to built-in datatypes\n-and the task system, are always implicitly linked and included in any\n-Rust program.\n+~~~~ {.xfail-test}\n+extern mod farm;\n+extern mod my_farm (name = \"farm\", vers = \"2.5\");\n+extern mod my_auxiliary_farm (name = \"farm\", author = \"mjh\");\n+~~~~\n \n-This library is documented [here][core].\n-\n-[core]: core/index.html\n+If any of the requested metadata does not match then the crate\n+will not be compiled successfully.\n \n ## A minimal example\n \n@@ -2246,7 +2317,7 @@ these two files:\n fn explore() -> ~str { ~\"world\" }\n ~~~~\n \n-~~~~ {.ignore}\n+~~~~ {.xfail-test}\n // main.rs\n extern mod world;\n fn main() { io::println(~\"hello \" + world::explore()); }\n@@ -2261,113 +2332,33 @@ Now compile and run like this (adjust to your platform if necessary):\n \"hello world\"\n ~~~~\n \n-## Importing\n-\n-When using identifiers from other modules, it can get tiresome to\n-qualify them with the full module path every time (especially when\n-that path is several modules deep). Rust allows you to import\n-identifiers at the top of a file, module, or block.\n-\n-~~~~\n-extern mod std;\n-use io::println;\n-fn main() {\n-    println(~\"that was easy\");\n-}\n-~~~~\n-\n-\n-It is also possible to import just the name of a module (`use\n-std::list;`, then use `list::find`), to import all identifiers exported\n-by a given module (`use io::*`), or to import a specific set\n-of identifiers (`use math::{min, max, pi}`).\n-\n-Rust uses different namespaces for modules, types, and values.  You\n-can also rename an identifier when importing using the `=` operator:\n-\n-~~~~\n-use prnt = io::println;\n-~~~~\n-\n-## Exporting\n-\n-By default, a module exports everything that it defines. This can be\n-restricted with `export` directives at the top of the module or file.\n-\n-~~~~\n-mod enc {\n-    export encrypt, decrypt;\n-    const SUPER_SECRET_NUMBER: int = 10;\n-    fn encrypt(n: int) -> int { n + SUPER_SECRET_NUMBER }\n-    fn decrypt(n: int) -> int { n - SUPER_SECRET_NUMBER }\n-}\n-~~~~\n-\n-This defines a rock-solid encryption algorithm. Code outside of the\n-module can refer to the `enc::encrypt` and `enc::decrypt` identifiers\n-just fine, but it does not have access to `enc::super_secret_number`.\n-\n-## Resolution\n-\n-The resolution process in Rust simply goes up the chain of contexts,\n-looking for the name in each context. Nested functions and modules\n-create new contexts inside their parent function or module. A file\n-that's part of a bigger crate will have that crate's context as its\n-parent context.\n-\n-Identifiers can shadow each other. In this program, `x` is of type\n-`int`:\n+Notice that the library produced contains the version in the filename\n+as well as an inscrutable string of alphanumerics. These are both\n+part of Rust's library versioning scheme. The alphanumerics are\n+a hash representing the crate metadata.\n \n-~~~~\n-type MyType = ~str;\n-fn main() {\n-    type MyType = int;\n-    let x: MyType = 17;\n-}\n-~~~~\n-\n-An `use` directive will only import into the namespaces for which\n-identifiers are actually found. Consider this example:\n-\n-~~~~\n-mod foo {\n-   fn bar() {}\n-}\n-\n-fn main() {\n-    let bar = 10;\n-\n-    {\n-        use foo::bar;\n-        let quux = bar;\n-        assert quux == 10;\n-    }\n-}\n-~~~~\n+## The core library\n \n-When resolving the type name `bar` in the `quux` definition, the\n-resolver will first look at local block context for `baz`. This has an\n-import named `bar`, but that's function, not a value, So it continues\n-to the `baz` function context and finds a value named `bar` defined\n-there.\n+The Rust [core] library acts as the language runtime and contains\n+required memory management and task scheduling code as well as a\n+number of modules necessary for effective usage of the primitive\n+types. Methods on [vectors] and [strings], implementations of most\n+comparison and math operators, and pervasive types like [`Option`]\n+and [`Result`] live in core.\n \n-Normally, multiple definitions of the same identifier in a scope are\n-disallowed. Local variables defined with `let` are an exception to\n-this\u2014multiple `let` directives can redefine the same variable in a\n-single scope. When resolving the name of such a variable, the most\n-recent definition is used.\n+All Rust programs link to the core library and import its contents,\n+as if the following were written at the top of the crate.\n \n-~~~~\n-fn main() {\n-    let x = 10;\n-    let x = x + 10;\n-    assert x == 20;\n-}\n-~~~~\n+~~~ {.xfail-test}\n+extern mod core;\n+use core::*;\n+~~~\n \n-This makes it possible to rebind a variable without actually mutating\n-it, which is mostly useful for destructuring (which can rebind, but\n-not assign).\n+[core]: core/index.html\n+[vectors]: core/vec.html\n+[strings]: core/str.html\n+[`Option`]: core/option.html\n+[`Result`]: core/result.html\n \n # What next?\n "}]}