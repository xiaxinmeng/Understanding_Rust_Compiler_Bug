{"sha": "3227e35765bab6d02c581928e26ad1d34bacf394", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyMjdlMzU3NjViYWI2ZDAyYzU4MTkyOGUyNmFkMWQzNGJhY2YzOTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-02T13:31:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-02T13:31:02Z"}, "message": "Auto merge of #87248 - RalfJung:ctfe-partial-overwrite, r=oli-obk\n\nCTFE: throw unsupported error when partially overwriting a pointer\n\nCurrently, during CTFE, when a write to memory would overwrite parts of a pointer, we make the remaining parts of that pointer \"uninitialized\". This is probably not what users expect, so if this ever happens they will be quite confused about why some of the data just vanishes for seemingly no good reason.\nSo I propose we change this to abort CTFE when that happens, to at last avoid silently doing the wrong thing.\nCc https://github.com/rust-lang/rust/issues/87184\n\nOur CTFE test suite still seems to pass. However, we should probably crater this, and I want to do some tests with Miri as well.", "tree": {"sha": "52efcea7da782882ff41419a780e4981c0786671", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52efcea7da782882ff41419a780e4981c0786671"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3227e35765bab6d02c581928e26ad1d34bacf394", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3227e35765bab6d02c581928e26ad1d34bacf394", "html_url": "https://github.com/rust-lang/rust/commit/3227e35765bab6d02c581928e26ad1d34bacf394", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3227e35765bab6d02c581928e26ad1d34bacf394/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d08460e70cd77945ecfa6f4826c82ed4ba29fb76", "url": "https://api.github.com/repos/rust-lang/rust/commits/d08460e70cd77945ecfa6f4826c82ed4ba29fb76", "html_url": "https://github.com/rust-lang/rust/commit/d08460e70cd77945ecfa6f4826c82ed4ba29fb76"}, {"sha": "2a9b44d97d55779b3758a1f0558b22de3a6572ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a9b44d97d55779b3758a1f0558b22de3a6572ea", "html_url": "https://github.com/rust-lang/rust/commit/2a9b44d97d55779b3758a1f0558b22de3a6572ea"}], "stats": {"total": 131, "additions": 104, "deletions": 27}, "files": [{"sha": "a29b42b45df375f2a158c7d76756d1ebaa8b30a1", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3227e35765bab6d02c581928e26ad1d34bacf394/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3227e35765bab6d02c581928e26ad1d34bacf394/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=3227e35765bab6d02c581928e26ad1d34bacf394", "patch": "@@ -12,7 +12,7 @@ use rustc_span::DUMMY_SP;\n use rustc_target::abi::{Align, HasDataLayout, Size};\n \n use super::{\n-    read_target_uint, write_target_uint, AllocId, InterpError, InterpResult, Pointer,\n+    read_target_uint, write_target_uint, AllocId, InterpError, InterpResult, Pointer, Provenance,\n     ResourceExhaustionInfo, Scalar, ScalarMaybeUninit, UndefinedBehaviorInfo, UninitBytesAccess,\n     UnsupportedOpInfo,\n };\n@@ -53,18 +53,22 @@ pub struct Allocation<Tag = AllocId, Extra = ()> {\n pub enum AllocError {\n     /// Encountered a pointer where we needed raw bytes.\n     ReadPointerAsBytes,\n+    /// Partially overwriting a pointer.\n+    PartialPointerOverwrite(Size),\n     /// Using uninitialized data where it is not allowed.\n     InvalidUninitBytes(Option<UninitBytesAccess>),\n }\n pub type AllocResult<T = ()> = Result<T, AllocError>;\n \n impl AllocError {\n     pub fn to_interp_error<'tcx>(self, alloc_id: AllocId) -> InterpError<'tcx> {\n+        use AllocError::*;\n         match self {\n-            AllocError::ReadPointerAsBytes => {\n-                InterpError::Unsupported(UnsupportedOpInfo::ReadPointerAsBytes)\n-            }\n-            AllocError::InvalidUninitBytes(info) => InterpError::UndefinedBehavior(\n+            ReadPointerAsBytes => InterpError::Unsupported(UnsupportedOpInfo::ReadPointerAsBytes),\n+            PartialPointerOverwrite(offset) => InterpError::Unsupported(\n+                UnsupportedOpInfo::PartialPointerOverwrite(Pointer::new(alloc_id, offset)),\n+            ),\n+            InvalidUninitBytes(info) => InterpError::UndefinedBehavior(\n                 UndefinedBehaviorInfo::InvalidUninitBytes(info.map(|b| (alloc_id, b))),\n             ),\n         }\n@@ -218,7 +222,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n }\n \n /// Byte accessors.\n-impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n+impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n     /// The last argument controls whether we error out when there are uninitialized\n     /// or pointer bytes. You should never call this, call `get_bytes` or\n     /// `get_bytes_with_uninit_and_ptr` instead,\n@@ -275,30 +279,35 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     /// Most likely, you want to use the `PlaceTy` and `OperandTy`-based methods\n     /// on `InterpCx` instead.\n-    pub fn get_bytes_mut(&mut self, cx: &impl HasDataLayout, range: AllocRange) -> &mut [u8] {\n+    pub fn get_bytes_mut(\n+        &mut self,\n+        cx: &impl HasDataLayout,\n+        range: AllocRange,\n+    ) -> AllocResult<&mut [u8]> {\n         self.mark_init(range, true);\n-        self.clear_relocations(cx, range);\n+        self.clear_relocations(cx, range)?;\n \n-        &mut self.bytes[range.start.bytes_usize()..range.end().bytes_usize()]\n+        Ok(&mut self.bytes[range.start.bytes_usize()..range.end().bytes_usize()])\n     }\n \n     /// A raw pointer variant of `get_bytes_mut` that avoids invalidating existing aliases into this memory.\n-    pub fn get_bytes_mut_ptr(&mut self, cx: &impl HasDataLayout, range: AllocRange) -> *mut [u8] {\n+    pub fn get_bytes_mut_ptr(\n+        &mut self,\n+        cx: &impl HasDataLayout,\n+        range: AllocRange,\n+    ) -> AllocResult<*mut [u8]> {\n         self.mark_init(range, true);\n-        // This also clears relocations that just overlap with the written range. So writing to some\n-        // byte can de-initialize its neighbors! See\n-        // <https://github.com/rust-lang/rust/issues/87184> for details.\n-        self.clear_relocations(cx, range);\n+        self.clear_relocations(cx, range)?;\n \n         assert!(range.end().bytes_usize() <= self.bytes.len()); // need to do our own bounds-check\n         let begin_ptr = self.bytes.as_mut_ptr().wrapping_add(range.start.bytes_usize());\n         let len = range.end().bytes_usize() - range.start.bytes_usize();\n-        ptr::slice_from_raw_parts_mut(begin_ptr, len)\n+        Ok(ptr::slice_from_raw_parts_mut(begin_ptr, len))\n     }\n }\n \n /// Reading and writing.\n-impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n+impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n     /// Validates that `ptr.offset` and `ptr.offset + size` do not point to the middle of a\n     /// relocation. If `allow_uninit_and_ptr` is `false`, also enforces that the memory in the\n     /// given range contains neither relocations nor uninitialized bytes.\n@@ -395,7 +404,7 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n         };\n \n         let endian = cx.data_layout().endian;\n-        let dst = self.get_bytes_mut(cx, range);\n+        let dst = self.get_bytes_mut(cx, range)?;\n         write_target_uint(endian, dst, bytes).unwrap();\n \n         // See if we have to also write a relocation.\n@@ -433,13 +442,16 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// uninitialized. This is a somewhat odd \"spooky action at a distance\",\n     /// but it allows strictly more code to run than if we would just error\n     /// immediately in that case.\n-    fn clear_relocations(&mut self, cx: &impl HasDataLayout, range: AllocRange) {\n+    fn clear_relocations(&mut self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult\n+    where\n+        Tag: Provenance,\n+    {\n         // Find the start and end of the given range and its outermost relocations.\n         let (first, last) = {\n             // Find all relocations overlapping the given range.\n             let relocations = self.get_relocations(cx, range);\n             if relocations.is_empty() {\n-                return;\n+                return Ok(());\n             }\n \n             (\n@@ -450,17 +462,27 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n         let start = range.start;\n         let end = range.end();\n \n-        // Mark parts of the outermost relocations as uninitialized if they partially fall outside the\n-        // given range.\n+        // We need to handle clearing the relocations from parts of a pointer. See\n+        // <https://github.com/rust-lang/rust/issues/87184> for details.\n         if first < start {\n+            if Tag::ERR_ON_PARTIAL_PTR_OVERWRITE {\n+                return Err(AllocError::PartialPointerOverwrite(first));\n+            }\n             self.init_mask.set_range(first, start, false);\n         }\n         if last > end {\n+            if Tag::ERR_ON_PARTIAL_PTR_OVERWRITE {\n+                return Err(AllocError::PartialPointerOverwrite(\n+                    last - cx.data_layout().pointer_size,\n+                ));\n+            }\n             self.init_mask.set_range(end, last, false);\n         }\n \n         // Forget all the relocations.\n         self.relocations.0.remove_range(first..last);\n+\n+        Ok(())\n     }\n \n     /// Errors if there are relocations overlapping with the edges of the"}, {"sha": "4826c96000cc25ad2eb1cdf3850a422cd1bcf0e8", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3227e35765bab6d02c581928e26ad1d34bacf394/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3227e35765bab6d02c581928e26ad1d34bacf394/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=3227e35765bab6d02c581928e26ad1d34bacf394", "patch": "@@ -404,6 +404,9 @@ pub enum UnsupportedOpInfo {\n     Unsupported(String),\n     /// Encountered a pointer where we needed raw bytes.\n     ReadPointerAsBytes,\n+    /// Overwriting parts of a pointer; the resulting state cannot be represented in our\n+    /// `Allocation` data structure.\n+    PartialPointerOverwrite(Pointer<AllocId>),\n     //\n     // The variants below are only reachable from CTFE/const prop, miri will never emit them.\n     //\n@@ -418,9 +421,12 @@ impl fmt::Display for UnsupportedOpInfo {\n         use UnsupportedOpInfo::*;\n         match self {\n             Unsupported(ref msg) => write!(f, \"{}\", msg),\n-            ReadExternStatic(did) => write!(f, \"cannot read from extern static ({:?})\", did),\n-            ReadPointerAsBytes => write!(f, \"unable to turn pointer into raw bytes\",),\n+            ReadPointerAsBytes => write!(f, \"unable to turn pointer into raw bytes\"),\n+            PartialPointerOverwrite(ptr) => {\n+                write!(f, \"unable to overwrite parts of a pointer in memory at {:?}\", ptr)\n+            }\n             ThreadLocalStatic(did) => write!(f, \"cannot access thread local static ({:?})\", did),\n+            ReadExternStatic(did) => write!(f, \"cannot read from extern static ({:?})\", did),\n         }\n     }\n }"}, {"sha": "3eee45a9230d1ffbd68e3d17e55f7e136dc97fbc", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3227e35765bab6d02c581928e26ad1d34bacf394/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3227e35765bab6d02c581928e26ad1d34bacf394/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=3227e35765bab6d02c581928e26ad1d34bacf394", "patch": "@@ -108,6 +108,10 @@ pub trait Provenance: Copy + fmt::Debug {\n     /// If `false`, ptr-to-int casts are not supported. The offset *must* be relative in that case.\n     const OFFSET_IS_ADDR: bool;\n \n+    /// We also use this trait to control whether to abort execution when a pointer is being partially overwritten\n+    /// (this avoids a separate trait in `allocation.rs` just for this purpose).\n+    const ERR_ON_PARTIAL_PTR_OVERWRITE: bool;\n+\n     /// Determines how a pointer should be printed.\n     fn fmt(ptr: &Pointer<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result\n     where\n@@ -123,6 +127,9 @@ impl Provenance for AllocId {\n     // so ptr-to-int casts are not possible (since we do not know the global physical offset).\n     const OFFSET_IS_ADDR: bool = false;\n \n+    // For now, do not allow this, so that we keep our options open.\n+    const ERR_ON_PARTIAL_PTR_OVERWRITE: bool = true;\n+\n     fn fmt(ptr: &Pointer<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // Forward `alternate` flag to `alloc_id` printing.\n         if f.alternate() {"}, {"sha": "4d13274a1200d2d8cfad0c0a6df51e6dcce3f2a4", "filename": "compiler/rustc_mir/src/interpret/memory.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3227e35765bab6d02c581928e26ad1d34bacf394/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3227e35765bab6d02c581928e26ad1d34bacf394/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs?ref=3227e35765bab6d02c581928e26ad1d34bacf394", "patch": "@@ -907,7 +907,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n }\n \n /// Reading and writing.\n-impl<'tcx, 'a, Tag: Copy, Extra> AllocRefMut<'a, 'tcx, Tag, Extra> {\n+impl<'tcx, 'a, Tag: Provenance, Extra> AllocRefMut<'a, 'tcx, Tag, Extra> {\n     pub fn write_scalar(\n         &mut self,\n         range: AllocRange,\n@@ -928,7 +928,7 @@ impl<'tcx, 'a, Tag: Copy, Extra> AllocRefMut<'a, 'tcx, Tag, Extra> {\n     }\n }\n \n-impl<'tcx, 'a, Tag: Copy, Extra> AllocRef<'a, 'tcx, Tag, Extra> {\n+impl<'tcx, 'a, Tag: Provenance, Extra> AllocRef<'a, 'tcx, Tag, Extra> {\n     pub fn read_scalar(&self, range: AllocRange) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         Ok(self\n             .alloc\n@@ -998,7 +998,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         // Side-step AllocRef and directly access the underlying bytes more efficiently.\n         // (We are staying inside the bounds here so all is good.)\n-        let bytes = alloc_ref.alloc.get_bytes_mut(&alloc_ref.tcx, alloc_ref.range);\n+        let alloc_id = alloc_ref.alloc_id;\n+        let bytes = alloc_ref\n+            .alloc\n+            .get_bytes_mut(&alloc_ref.tcx, alloc_ref.range)\n+            .map_err(move |e| e.to_interp_error(alloc_id))?;\n         // `zip` would stop when the first iterator ends; we want to definitely\n         // cover all of `bytes`.\n         for dest in bytes {\n@@ -1072,7 +1076,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let (dest_alloc, extra) = self.get_raw_mut(dest_alloc_id)?;\n         let dest_range = alloc_range(dest_offset, size * num_copies);\n         M::memory_written(extra, &mut dest_alloc.extra, dest.provenance, dest_range)?;\n-        let dest_bytes = dest_alloc.get_bytes_mut_ptr(&tcx, dest_range).as_mut_ptr();\n+        let dest_bytes = dest_alloc\n+            .get_bytes_mut_ptr(&tcx, dest_range)\n+            .map_err(|e| e.to_interp_error(dest_alloc_id))?\n+            .as_mut_ptr();\n \n         if compressed.no_bytes_init() {\n             // Fast path: If all bytes are `uninit` then there is nothing to copy. The target range"}, {"sha": "5371f9f1749bbe27ab1c63abba78b9847a132262", "filename": "src/test/ui/consts/const-eval/partial_ptr_overwrite.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3227e35765bab6d02c581928e26ad1d34bacf394/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpartial_ptr_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3227e35765bab6d02c581928e26ad1d34bacf394/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpartial_ptr_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpartial_ptr_overwrite.rs?ref=3227e35765bab6d02c581928e26ad1d34bacf394", "patch": "@@ -0,0 +1,15 @@\n+// Test for the behavior described in <https://github.com/rust-lang/rust/issues/87184>.\n+#![feature(const_mut_refs, const_raw_ptr_deref)]\n+\n+const PARTIAL_OVERWRITE: () = {\n+    let mut p = &42;\n+    unsafe {\n+        let ptr: *mut _ = &mut p;\n+        *(ptr as *mut u8) = 123; //~ ERROR any use of this value\n+        //~| unable to overwrite parts of a pointer\n+        //~| WARN previously accepted\n+    }\n+    let x = *p;\n+};\n+\n+fn main() {}"}, {"sha": "a18c7e78d95af4ac593844c381cb68bbc91273f5", "filename": "src/test/ui/consts/const-eval/partial_ptr_overwrite.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3227e35765bab6d02c581928e26ad1d34bacf394/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpartial_ptr_overwrite.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3227e35765bab6d02c581928e26ad1d34bacf394/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpartial_ptr_overwrite.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpartial_ptr_overwrite.stderr?ref=3227e35765bab6d02c581928e26ad1d34bacf394", "patch": "@@ -0,0 +1,20 @@\n+error: any use of this value will cause an error\n+  --> $DIR/partial_ptr_overwrite.rs:8:9\n+   |\n+LL | / const PARTIAL_OVERWRITE: () = {\n+LL | |     let mut p = &42;\n+LL | |     unsafe {\n+LL | |         let ptr: *mut _ = &mut p;\n+LL | |         *(ptr as *mut u8) = 123;\n+   | |         ^^^^^^^^^^^^^^^^^^^^^^^ unable to overwrite parts of a pointer in memory at alloc4\n+...  |\n+LL | |     let x = *p;\n+LL | | };\n+   | |__-\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error: aborting due to previous error\n+"}]}