{"sha": "974e2837bb643a1213caeea4025f2f5681bd5f3e", "node_id": "C_kwDOAAsO6NoAKDk3NGUyODM3YmI2NDNhMTIxM2NhZWVhNDAyNWYyZjU2ODFiZDVmM2U", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-11-24T21:14:58Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-11-25T03:04:54Z"}, "message": "Introduce PredicateKind::Clause", "tree": {"sha": "ef25aad9b89c8cb4f8f618f153c04f3dd2aa8b87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef25aad9b89c8cb4f8f618f153c04f3dd2aa8b87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/974e2837bb643a1213caeea4025f2f5681bd5f3e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEF0ntrgrd9qf9uuThgTGiTgx5768FAmOAMNYACgkQgTGiTgx5\n76/Pug/+KqcKkB6La0M40e0ejq32dUhKJ40DpTnCGnpbofXg/Cin5E0APhvmKsSz\nSa29ws4H7jHe0Azj/grUPZDoZTrL/3DkpfnjQwCnrg7LSlnXfepHgnt6/uTzFt8K\nvjWX4UnHMoFq0VQlTOvEVIq7S25KQUUNgSUmtM8oOMZ5a4EsPyE5D6l0Y7hJWRGq\nzg0U1Vzf+pdjFEkmvli0K7Ldjw7RloaTSdXQDRLf+ue762sEWS17x0fMklAM9HoQ\nft21pIkeQz2z48Eg+gsEbCtOL/GqEh7af/gYRzVOj5lQmsNGfDytKR9VSq8BVDUs\npZkOjfJMTfC8gjtAti2GFfKNOsYj0gQJt53OuUdpq1Xkyl0A2s13HZnqFsahuNzR\nrVRFa5ot4CfrP4aXCWKce8zujtI4UamWonNRPNJZvCQrwQsvr4ux5Wgp5mMypSS7\nzXjZSpQSQAXTYTpygHGVLM5Udq8rA3Pmh4sA1pc02O0o21gQa/MWLV4AFL+t7bFC\n7KToxKmhLq0Hdol9ed7fYtiyfjmrhZkRi5pT7yshvOo4RprOH9PHs5UhAKaTU758\nAyg/tjpBPhX8mbRyNVUzrzwPZ2iZvTRcZ/PuJFhfCC1xytHlJ1rAczhFKFE21qCB\nYsu6l1PY96ZO3MYfB3Ebz6PgC9/eU+XaDIMSUeVC93a3QsV4BfU=\n=oeCa\n-----END PGP SIGNATURE-----", "payload": "tree ef25aad9b89c8cb4f8f618f153c04f3dd2aa8b87\nparent 42cc8e8f4e5fe3864a9aca4f342ee2aff2ba696a\nauthor Santiago Pastorino <spastorino@gmail.com> 1669324498 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1669345494 -0300\n\nIntroduce PredicateKind::Clause\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/974e2837bb643a1213caeea4025f2f5681bd5f3e", "html_url": "https://github.com/rust-lang/rust/commit/974e2837bb643a1213caeea4025f2f5681bd5f3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/974e2837bb643a1213caeea4025f2f5681bd5f3e/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42cc8e8f4e5fe3864a9aca4f342ee2aff2ba696a", "url": "https://api.github.com/repos/rust-lang/rust/commits/42cc8e8f4e5fe3864a9aca4f342ee2aff2ba696a", "html_url": "https://github.com/rust-lang/rust/commit/42cc8e8f4e5fe3864a9aca4f342ee2aff2ba696a"}], "stats": {"total": 975, "additions": 568, "deletions": 407}, "files": [{"sha": "a53940070f7eacf7f8962468ae406b1256686081", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -666,15 +666,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let tcx = self.infcx.tcx;\n \n         // Find out if the predicates show that the type is a Fn or FnMut\n-        let find_fn_kind_from_did =\n-            |predicates: ty::EarlyBinder<&[(ty::Predicate<'tcx>, Span)]>, substs| {\n-                predicates.0.iter().find_map(|(pred, _)| {\n+        let find_fn_kind_from_did = |predicates: ty::EarlyBinder<\n+            &[(ty::Predicate<'tcx>, Span)],\n+        >,\n+                                     substs| {\n+            predicates.0.iter().find_map(|(pred, _)| {\n                     let pred = if let Some(substs) = substs {\n                         predicates.rebind(*pred).subst(tcx, substs).kind().skip_binder()\n                     } else {\n                         pred.kind().skip_binder()\n                     };\n-                    if let ty::PredicateKind::Trait(pred) = pred && pred.self_ty() == ty {\n+                    if let ty::PredicateKind::Clause(ty::Clause::Trait(pred)) = pred && pred.self_ty() == ty {\n                     if Some(pred.def_id()) == tcx.lang_items().fn_trait() {\n                         return Some(hir::Mutability::Not);\n                     } else if Some(pred.def_id()) == tcx.lang_items().fn_mut_trait() {\n@@ -683,7 +685,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n                     None\n                 })\n-            };\n+        };\n \n         // If the type is opaque/param/closure, and it is Fn or FnMut, let's suggest (mutably)\n         // borrowing the type, since `&mut F: FnMut` iff `F: FnMut` and similarly for `Fn`.\n@@ -784,13 +786,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let predicates: Result<Vec<_>, _> = errors\n             .into_iter()\n             .map(|err| match err.obligation.predicate.kind().skip_binder() {\n-                PredicateKind::Trait(predicate) => match predicate.self_ty().kind() {\n-                    ty::Param(param_ty) => Ok((\n-                        generics.type_param(param_ty, tcx),\n-                        predicate.trait_ref.print_only_trait_path().to_string(),\n-                    )),\n-                    _ => Err(()),\n-                },\n+                PredicateKind::Clause(ty::Clause::Trait(predicate)) => {\n+                    match predicate.self_ty().kind() {\n+                        ty::Param(param_ty) => Ok((\n+                            generics.type_param(param_ty, tcx),\n+                            predicate.trait_ref.print_only_trait_path().to_string(),\n+                        )),\n+                        _ => Err(()),\n+                    }\n+                }\n                 _ => Err(()),\n             })\n             .collect();"}, {"sha": "0adaabd0dbf9be9694c092e1c2eafe003175a49d", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -959,8 +959,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             {\n                 predicates.iter().any(|pred| {\n                     match pred.kind().skip_binder() {\n-                        ty::PredicateKind::Trait(data) if data.self_ty() == ty => {}\n-                        ty::PredicateKind::Projection(data) if data.projection_ty.self_ty() == ty => {}\n+                        ty::PredicateKind::Clause(ty::Clause::Trait(data)) if data.self_ty() == ty => {}\n+                        ty::PredicateKind::Clause(ty::Clause::Projection(data)) if data.projection_ty.self_ty() == ty => {}\n                         _ => return false,\n                     }\n                     tcx.any_free_region_meets(pred, |r| {"}, {"sha": "1aad6738bba7a01b9081e14508b836bb324190d0", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -88,11 +88,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         category: ConstraintCategory<'tcx>,\n     ) {\n         self.prove_predicate(\n-            ty::Binder::dummy(ty::PredicateKind::Trait(ty::TraitPredicate {\n+            ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate {\n                 trait_ref,\n                 constness: ty::BoundConstness::NotConst,\n                 polarity: ty::ImplPolarity::Positive,\n-            })),\n+            }))),\n             locations,\n             category,\n         );"}, {"sha": "18e3cbbb86a0eace8d8cdd611012ed7b2b1d2041", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -2013,8 +2013,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         );\n \n                         let outlives_predicate =\n-                            tcx.mk_predicate(Binder::dummy(ty::PredicateKind::TypeOutlives(\n-                                ty::OutlivesPredicate(self_ty, *region),\n+                            tcx.mk_predicate(Binder::dummy(ty::PredicateKind::Clause(\n+                                ty::Clause::TypeOutlives(ty::OutlivesPredicate(self_ty, *region)),\n                             )));\n                         self.prove_predicate(\n                             outlives_predicate,"}, {"sha": "bc654c24b2f00fb05308c5d6eb163409a68b71e2", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -1378,7 +1378,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n                 let bound_predicate = obligation.predicate.kind();\n                 match bound_predicate.skip_binder() {\n-                    ty::PredicateKind::Trait(pred) => {\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => {\n                         let pred = bound_predicate.rebind(pred);\n                         associated_types.entry(span).or_default().extend(\n                             tcx.associated_items(pred.def_id())\n@@ -1387,7 +1387,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 .map(|item| item.def_id),\n                         );\n                     }\n-                    ty::PredicateKind::Projection(pred) => {\n+                    ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => {\n                         let pred = bound_predicate.rebind(pred);\n                         // A `Self` within the original bound will be substituted with a\n                         // `trait_object_dummy_self`, so check for that."}, {"sha": "d04d8ca2c32740d85bb6af99a9394d4b3f3785e1", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -183,19 +183,27 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n             let predicate = predicate.kind();\n             let p = p.kind();\n             match (predicate.skip_binder(), p.skip_binder()) {\n-                (ty::PredicateKind::Trait(a), ty::PredicateKind::Trait(b)) => {\n-                    relator.relate(predicate.rebind(a), p.rebind(b)).is_ok()\n-                }\n-                (ty::PredicateKind::Projection(a), ty::PredicateKind::Projection(b)) => {\n-                    relator.relate(predicate.rebind(a), p.rebind(b)).is_ok()\n-                }\n+                (\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(a)),\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(b)),\n+                ) => relator.relate(predicate.rebind(a), p.rebind(b)).is_ok(),\n+                (\n+                    ty::PredicateKind::Clause(ty::Clause::Projection(a)),\n+                    ty::PredicateKind::Clause(ty::Clause::Projection(b)),\n+                ) => relator.relate(predicate.rebind(a), p.rebind(b)).is_ok(),\n                 (\n                     ty::PredicateKind::ConstEvaluatable(a),\n                     ty::PredicateKind::ConstEvaluatable(b),\n                 ) => relator.relate(predicate.rebind(a), predicate.rebind(b)).is_ok(),\n                 (\n-                    ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_a, lt_a)),\n-                    ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_b, lt_b)),\n+                    ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                        ty_a,\n+                        lt_a,\n+                    ))),\n+                    ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                        ty_b,\n+                        lt_b,\n+                    ))),\n                 ) => {\n                     relator.relate(predicate.rebind(ty_a), p.rebind(ty_b)).is_ok()\n                         && relator.relate(predicate.rebind(lt_a), p.rebind(lt_b)).is_ok()"}, {"sha": "29255472a2516dd0917642ff3e83886320db7fd7", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -309,7 +309,7 @@ fn bounds_from_generic_predicates<'tcx>(\n         debug!(\"predicate {:?}\", predicate);\n         let bound_predicate = predicate.kind();\n         match bound_predicate.skip_binder() {\n-            ty::PredicateKind::Trait(trait_predicate) => {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(trait_predicate)) => {\n                 let entry = types.entry(trait_predicate.self_ty()).or_default();\n                 let def_id = trait_predicate.def_id();\n                 if Some(def_id) != tcx.lang_items().sized_trait() {\n@@ -318,7 +318,7 @@ fn bounds_from_generic_predicates<'tcx>(\n                     entry.push(trait_predicate.def_id());\n                 }\n             }\n-            ty::PredicateKind::Projection(projection_pred) => {\n+            ty::PredicateKind::Clause(ty::Clause::Projection(projection_pred)) => {\n                 projections.push(bound_predicate.rebind(projection_pred));\n             }\n             _ => {}"}, {"sha": "8171a2ab270cdc12f0dec26af7949fe2380c0cee", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -462,12 +462,16 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n         let mut unsatisfied_bounds: Vec<_> = required_bounds\n             .into_iter()\n             .filter(|clause| match clause.kind().skip_binder() {\n-                ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => {\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n+                    a,\n+                    b,\n+                ))) => {\n                     !region_known_to_outlive(tcx, gat_hir, param_env, &FxIndexSet::default(), a, b)\n                 }\n-                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(a, b)) => {\n-                    !ty_known_to_outlive(tcx, gat_hir, param_env, &FxIndexSet::default(), a, b)\n-                }\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                    a,\n+                    b,\n+                ))) => !ty_known_to_outlive(tcx, gat_hir, param_env, &FxIndexSet::default(), a, b),\n                 _ => bug!(\"Unexpected PredicateKind\"),\n             })\n             .map(|clause| clause.to_string())\n@@ -599,8 +603,9 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n                     }));\n                 // The predicate we expect to see. (In our example,\n                 // `Self: 'me`.)\n-                let clause =\n-                    ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_param, region_param));\n+                let clause = ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n+                    ty::OutlivesPredicate(ty_param, region_param),\n+                ));\n                 let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n                 bounds.insert(clause);\n             }\n@@ -636,9 +641,8 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n                         name: region_b_param.name,\n                     }));\n                 // The predicate we expect to see.\n-                let clause = ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n-                    region_a_param,\n-                    region_b_param,\n+                let clause = ty::PredicateKind::Clause(ty::Clause::RegionOutlives(\n+                    ty::OutlivesPredicate(region_a_param, region_b_param),\n                 ));\n                 let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n                 bounds.insert(clause);"}, {"sha": "d6a5736bbf4433bbfef64aaf10b4a7dfeff5b7ae", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -128,11 +128,11 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n                             .or_default()\n                             .push(error.obligation.cause.span);\n                     }\n-                    if let ty::PredicateKind::Trait(ty::TraitPredicate {\n+                    if let ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate {\n                         trait_ref,\n                         polarity: ty::ImplPolarity::Positive,\n                         ..\n-                    }) = error_predicate.kind().skip_binder()\n+                    })) = error_predicate.kind().skip_binder()\n                     {\n                         let ty = trait_ref.self_ty();\n                         if let ty::Param(_) = ty.kind() {"}, {"sha": "0542e2c8f50818fe047d605ec164543e37785062", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -35,9 +35,11 @@ fn associated_type_bounds<'tcx>(\n \n     let bounds_from_parent = trait_predicates.predicates.iter().copied().filter(|(pred, _)| {\n         match pred.kind().skip_binder() {\n-            ty::PredicateKind::Trait(tr) => tr.self_ty() == item_ty,\n-            ty::PredicateKind::Projection(proj) => proj.projection_ty.self_ty() == item_ty,\n-            ty::PredicateKind::TypeOutlives(outlives) => outlives.0 == item_ty,\n+            ty::PredicateKind::Clause(ty::Clause::Trait(tr)) => tr.self_ty() == item_ty,\n+            ty::PredicateKind::Clause(ty::Clause::Projection(proj)) => {\n+                proj.projection_ty.self_ty() == item_ty\n+            }\n+            ty::PredicateKind::Clause(ty::Clause::TypeOutlives(outlives)) => outlives.0 == item_ty,\n             _ => false,\n         }\n     });"}, {"sha": "da1c04f3f7bac7ba3c44618933970498b4dc6cf0", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -1558,7 +1558,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             let obligations = predicates.predicates.iter().filter_map(|&(pred, _)| {\n                 let bound_predicate = pred.kind();\n                 match bound_predicate.skip_binder() {\n-                    ty::PredicateKind::Trait(data) => {\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(data)) => {\n                         // The order here needs to match what we would get from `subst_supertrait`\n                         let pred_bound_vars = bound_predicate.bound_vars();\n                         let mut all_bound_vars = bound_vars.clone();"}, {"sha": "9417a2620d1d276d7a9e1eebe1b35a39caa0745d", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -233,8 +233,8 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                         }\n                         _ => bug!(),\n                     };\n-                    let pred = ty::Binder::dummy(ty::PredicateKind::RegionOutlives(\n-                        ty::OutlivesPredicate(r1, r2),\n+                    let pred = ty::Binder::dummy(ty::PredicateKind::Clause(\n+                        ty::Clause::RegionOutlives(ty::OutlivesPredicate(r1, r2)),\n                     ))\n                     .to_predicate(icx.tcx);\n \n@@ -299,17 +299,15 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                 name: duplicate.name.ident().name,\n             }));\n             predicates.push((\n-                ty::Binder::dummy(ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n-                    orig_region,\n-                    dup_region,\n+                ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::RegionOutlives(\n+                    ty::OutlivesPredicate(orig_region, dup_region),\n                 )))\n                 .to_predicate(icx.tcx),\n                 duplicate.span,\n             ));\n             predicates.push((\n-                ty::Binder::dummy(ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n-                    dup_region,\n-                    orig_region,\n+                ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::RegionOutlives(\n+                    ty::OutlivesPredicate(dup_region, orig_region),\n                 )))\n                 .to_predicate(icx.tcx),\n                 duplicate.span,\n@@ -426,11 +424,13 @@ pub(super) fn explicit_predicates_of<'tcx>(\n             .iter()\n             .copied()\n             .filter(|(pred, _)| match pred.kind().skip_binder() {\n-                ty::PredicateKind::Trait(tr) => !is_assoc_item_ty(tr.self_ty()),\n-                ty::PredicateKind::Projection(proj) => {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(tr)) => !is_assoc_item_ty(tr.self_ty()),\n+                ty::PredicateKind::Clause(ty::Clause::Projection(proj)) => {\n                     !is_assoc_item_ty(proj.projection_ty.self_ty())\n                 }\n-                ty::PredicateKind::TypeOutlives(outlives) => !is_assoc_item_ty(outlives.0),\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(outlives)) => {\n+                    !is_assoc_item_ty(outlives.0)\n+                }\n                 _ => true,\n             })\n             .collect();\n@@ -566,7 +566,9 @@ pub(super) fn super_predicates_that_define_assoc_type(\n             // which will, in turn, reach indirect supertraits.\n             for &(pred, span) in superbounds {\n                 debug!(\"superbound: {:?}\", pred);\n-                if let ty::PredicateKind::Trait(bound) = pred.kind().skip_binder() {\n+                if let ty::PredicateKind::Clause(ty::Clause::Trait(bound)) =\n+                    pred.kind().skip_binder()\n+                {\n                     tcx.at(span).super_predicates_of(bound.def_id());\n                 }\n             }\n@@ -666,7 +668,7 @@ pub(super) fn type_param_predicates(\n         )\n         .into_iter()\n         .filter(|(predicate, _)| match predicate.kind().skip_binder() {\n-            ty::PredicateKind::Trait(data) => data.self_ty().is_param(index),\n+            ty::PredicateKind::Clause(ty::Clause::Trait(data)) => data.self_ty().is_param(index),\n             _ => false,\n         }),\n     );"}, {"sha": "b4057df7896f30fa331f932e1c838bf91a35527d", "filename": "compiler/rustc_hir_analysis/src/constrained_generic_params.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -187,7 +187,8 @@ pub fn setup_constraining_predicates<'tcx>(\n         for j in i..predicates.len() {\n             // Note that we don't have to care about binders here,\n             // as the impl trait ref never contains any late-bound regions.\n-            if let ty::PredicateKind::Projection(projection) = predicates[j].0.kind().skip_binder()\n+            if let ty::PredicateKind::Clause(ty::Clause::Projection(projection)) =\n+                predicates[j].0.kind().skip_binder()\n             {\n                 // Special case: watch out for some kind of sneaky attempt\n                 // to project out an associated type defined by this very"}, {"sha": "fd8e8ed7ba605d4add40f3e6b81c30ffaad45f19", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -214,7 +214,9 @@ fn unconstrained_parent_impl_substs<'tcx>(\n     // the functions in `cgp` add the constrained parameters to a list of\n     // unconstrained parameters.\n     for (predicate, _) in impl_generic_predicates.predicates.iter() {\n-        if let ty::PredicateKind::Projection(proj) = predicate.kind().skip_binder() {\n+        if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) =\n+            predicate.kind().skip_binder()\n+        {\n             let projection_ty = proj.projection_ty;\n             let projected_ty = proj.term;\n \n@@ -429,7 +431,10 @@ fn trait_predicates_eq<'tcx>(\n     let pred1_kind = predicate1.kind().skip_binder();\n     let pred2_kind = predicate2.kind().skip_binder();\n     let (trait_pred1, trait_pred2) = match (pred1_kind, pred2_kind) {\n-        (ty::PredicateKind::Trait(pred1), ty::PredicateKind::Trait(pred2)) => (pred1, pred2),\n+        (\n+            ty::PredicateKind::Clause(ty::Clause::Trait(pred1)),\n+            ty::PredicateKind::Clause(ty::Clause::Trait(pred2)),\n+        ) => (pred1, pred2),\n         // Just use plain syntactic equivalence if either of the predicates aren't\n         // trait predicates or have bound vars.\n         _ => return predicate1 == predicate2,\n@@ -467,7 +472,11 @@ fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tc\n         _ if predicate.is_global() => (),\n         // We allow specializing on explicitly marked traits with no associated\n         // items.\n-        ty::PredicateKind::Trait(ty::TraitPredicate { trait_ref, constness: _, polarity: _ }) => {\n+        ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate {\n+            trait_ref,\n+            constness: _,\n+            polarity: _,\n+        })) => {\n             if !matches!(\n                 trait_predicate_kind(tcx, predicate),\n                 Some(TraitSpecializationKind::Marker)\n@@ -483,7 +492,10 @@ fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tc\n                     .emit();\n             }\n         }\n-        ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, term }) => {\n+        ty::PredicateKind::Clause(ty::Clause::Projection(ty::ProjectionPredicate {\n+            projection_ty,\n+            term,\n+        })) => {\n             tcx.sess\n                 .struct_span_err(\n                     span,\n@@ -504,12 +516,14 @@ fn trait_predicate_kind<'tcx>(\n     predicate: ty::Predicate<'tcx>,\n ) -> Option<TraitSpecializationKind> {\n     match predicate.kind().skip_binder() {\n-        ty::PredicateKind::Trait(ty::TraitPredicate { trait_ref, constness: _, polarity: _ }) => {\n-            Some(tcx.trait_def(trait_ref.def_id).specialization_kind)\n-        }\n-        ty::PredicateKind::RegionOutlives(_)\n-        | ty::PredicateKind::TypeOutlives(_)\n-        | ty::PredicateKind::Projection(_)\n+        ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate {\n+            trait_ref,\n+            constness: _,\n+            polarity: _,\n+        })) => Some(tcx.trait_def(trait_ref.def_id).specialization_kind),\n+        ty::PredicateKind::Clause(ty::Clause::RegionOutlives(_))\n+        | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(_))\n+        | ty::PredicateKind::Clause(ty::Clause::Projection(_))\n         | ty::PredicateKind::WellFormed(_)\n         | ty::PredicateKind::Subtype(_)\n         | ty::PredicateKind::Coerce(_)"}, {"sha": "663f1c49db7db192927a0c77e6b64d0ca7f8e629", "filename": "compiler/rustc_hir_analysis/src/outlives/explicit.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -30,28 +30,30 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n             // process predicates and convert to `RequiredPredicates` entry, see below\n             for &(predicate, span) in predicates.predicates {\n                 match predicate.kind().skip_binder() {\n-                    ty::PredicateKind::TypeOutlives(OutlivesPredicate(ty, reg)) => {\n-                        insert_outlives_predicate(\n-                            tcx,\n-                            ty.into(),\n-                            reg,\n-                            span,\n-                            &mut required_predicates,\n-                        )\n-                    }\n+                    ty::PredicateKind::Clause(ty::Clause::TypeOutlives(OutlivesPredicate(\n+                        ty,\n+                        reg,\n+                    ))) => insert_outlives_predicate(\n+                        tcx,\n+                        ty.into(),\n+                        reg,\n+                        span,\n+                        &mut required_predicates,\n+                    ),\n \n-                    ty::PredicateKind::RegionOutlives(OutlivesPredicate(reg1, reg2)) => {\n-                        insert_outlives_predicate(\n-                            tcx,\n-                            reg1.into(),\n-                            reg2,\n-                            span,\n-                            &mut required_predicates,\n-                        )\n-                    }\n+                    ty::PredicateKind::Clause(ty::Clause::RegionOutlives(OutlivesPredicate(\n+                        reg1,\n+                        reg2,\n+                    ))) => insert_outlives_predicate(\n+                        tcx,\n+                        reg1.into(),\n+                        reg2,\n+                        span,\n+                        &mut required_predicates,\n+                    ),\n \n-                    ty::PredicateKind::Trait(..)\n-                    | ty::PredicateKind::Projection(..)\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(..))\n+                    | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n                     | ty::PredicateKind::WellFormed(..)\n                     | ty::PredicateKind::ObjectSafe(..)\n                     | ty::PredicateKind::ClosureKind(..)"}, {"sha": "c8f37176836c5220dc64be4590896d4760ae6ce9", "filename": "compiler/rustc_hir_analysis/src/outlives/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -51,8 +51,10 @@ fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate\n                     let mut pred: Vec<String> = predicates\n                         .iter()\n                         .map(|(out_pred, _)| match out_pred.kind().skip_binder() {\n-                            ty::PredicateKind::RegionOutlives(p) => p.to_string(),\n-                            ty::PredicateKind::TypeOutlives(p) => p.to_string(),\n+                            ty::PredicateKind::Clause(ty::Clause::RegionOutlives(p)) => {\n+                                p.to_string()\n+                            }\n+                            ty::PredicateKind::Clause(ty::Clause::TypeOutlives(p)) => p.to_string(),\n                             err => bug!(\"unexpected predicate {:?}\", err),\n                         })\n                         .collect();\n@@ -101,15 +103,17 @@ fn inferred_outlives_crate(tcx: TyCtxt<'_>, (): ()) -> CratePredicatesMap<'_> {\n                 |(ty::OutlivesPredicate(kind1, region2), &span)| {\n                     match kind1.unpack() {\n                         GenericArgKind::Type(ty1) => Some((\n-                            ty::Binder::dummy(ty::PredicateKind::TypeOutlives(\n+                            ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n                                 ty::OutlivesPredicate(ty1, *region2),\n-                            ))\n+                            )))\n                             .to_predicate(tcx),\n                             span,\n                         )),\n                         GenericArgKind::Lifetime(region1) => Some((\n-                            ty::Binder::dummy(ty::PredicateKind::RegionOutlives(\n-                                ty::OutlivesPredicate(region1, *region2),\n+                            ty::Binder::dummy(ty::PredicateKind::Clause(\n+                                ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n+                                    region1, *region2,\n+                                )),\n                             ))\n                             .to_predicate(tcx),\n                             span,"}, {"sha": "9db05eedbde790e43c2e3c6fa081179424edc3f6", "filename": "compiler/rustc_hir_analysis/src/variance/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -123,25 +123,28 @@ fn variance_of_opaque(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[ty::Varianc\n         // which thus mentions `'a` and should thus accept hidden types that borrow 'a\n         // instead of requiring an additional `+ 'a`.\n         match pred.kind().skip_binder() {\n-            ty::PredicateKind::Trait(ty::TraitPredicate {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate {\n                 trait_ref: ty::TraitRef { def_id: _, substs },\n                 constness: _,\n                 polarity: _,\n-            }) => {\n+            })) => {\n                 for subst in &substs[1..] {\n                     subst.visit_with(&mut collector);\n                 }\n             }\n-            ty::PredicateKind::Projection(ty::ProjectionPredicate {\n+            ty::PredicateKind::Clause(ty::Clause::Projection(ty::ProjectionPredicate {\n                 projection_ty: ty::ProjectionTy { substs, item_def_id: _ },\n                 term,\n-            }) => {\n+            })) => {\n                 for subst in &substs[1..] {\n                     subst.visit_with(&mut collector);\n                 }\n                 term.visit_with(&mut collector);\n             }\n-            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_, region)) => {\n+            ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                _,\n+                region,\n+            ))) => {\n                 region.visit_with(&mut collector);\n             }\n             _ => {"}, {"sha": "e93e8b0badaa970cd7ac5e6f354853a1f36da849", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -539,17 +539,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .subst_iter_copied(self.tcx, substs)\n                     {\n                         let pred = pred.kind().rebind(match pred.kind().skip_binder() {\n-                            ty::PredicateKind::Trait(trait_pred) => {\n+                            ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => {\n                                 assert_eq!(trait_pred.trait_ref.self_ty(), opaque_ty);\n-                                ty::PredicateKind::Trait(trait_pred.with_self_type(self.tcx, ty))\n+                                ty::PredicateKind::Clause(ty::Clause::Trait(\n+                                    trait_pred.with_self_type(self.tcx, ty),\n+                                ))\n                             }\n-                            ty::PredicateKind::Projection(mut proj_pred) => {\n+                            ty::PredicateKind::Clause(ty::Clause::Projection(mut proj_pred)) => {\n                                 assert_eq!(proj_pred.projection_ty.self_ty(), opaque_ty);\n                                 proj_pred.projection_ty.substs = self.tcx.mk_substs_trait(\n                                     ty,\n                                     proj_pred.projection_ty.substs.iter().skip(1),\n                                 );\n-                                ty::PredicateKind::Projection(proj_pred)\n+                                ty::PredicateKind::Clause(ty::Clause::Projection(proj_pred))\n                             }\n                             _ => continue,\n                         });"}, {"sha": "e2fefd2724f7e98683dfad1d9331c358cdebd219", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Given a Projection predicate, we can potentially infer\n             // the complete signature.\n             if expected_sig.is_none()\n-                && let ty::PredicateKind::Projection(proj_predicate) = bound_predicate.skip_binder()\n+                && let ty::PredicateKind::Clause(ty::Clause::Projection(proj_predicate)) = bound_predicate.skip_binder()\n             {\n                 expected_sig = self.normalize_associated_types_in(\n                     obligation.cause.span,\n@@ -228,10 +228,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // like `F : Fn<A>`. Note that due to subtyping we could encounter\n             // many viable options, so pick the most restrictive.\n             let trait_def_id = match bound_predicate.skip_binder() {\n-                ty::PredicateKind::Projection(data) => {\n+                ty::PredicateKind::Clause(ty::Clause::Projection(data)) => {\n                     Some(data.projection_ty.trait_def_id(self.tcx))\n                 }\n-                ty::PredicateKind::Trait(data) => Some(data.def_id()),\n+                ty::PredicateKind::Clause(ty::Clause::Trait(data)) => Some(data.def_id()),\n                 _ => None,\n             };\n             if let Some(closure_kind) =\n@@ -658,7 +658,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // where R is the return type we are expecting. This type `T`\n             // will be our output.\n             let bound_predicate = predicate.kind();\n-            if let ty::PredicateKind::Projection(proj_predicate) = bound_predicate.skip_binder() {\n+            if let ty::PredicateKind::Clause(ty::Clause::Projection(proj_predicate)) =\n+                bound_predicate.skip_binder()\n+            {\n                 self.deduce_future_output_from_projection(\n                     span,\n                     bound_predicate.rebind(proj_predicate),"}, {"sha": "b6e37d9ec8e6929203eb55b8b54b074c3ab119a7", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -644,7 +644,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n             let bound_predicate = obligation.predicate.kind();\n             let trait_pred = match bound_predicate.skip_binder() {\n-                ty::PredicateKind::Trait(trait_pred) if traits.contains(&trait_pred.def_id()) => {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred))\n+                    if traits.contains(&trait_pred.def_id()) =>\n+                {\n                     if unsize_did == trait_pred.def_id() {\n                         let self_ty = trait_pred.self_ty();\n                         let unsize_ty = trait_pred.trait_ref.substs[1].expect_ty();\n@@ -778,8 +780,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     self.tcx,\n                     self.cause.clone(),\n                     self.param_env,\n-                    ty::Binder::dummy(ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n-                        a, b_region,\n+                    ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n+                        ty::OutlivesPredicate(a, b_region),\n                     ))),\n                 ),\n             ])"}, {"sha": "9299527ce179875818e5361d9712ad9baa7ba4ad", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -2824,7 +2824,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         for error in errors {\n             match error.obligation.predicate.kind().skip_binder() {\n-                ty::PredicateKind::Trait(predicate)\n+                ty::PredicateKind::Clause(ty::Clause::Trait(predicate))\n                     if self.tcx.is_diagnostic_item(sym::SliceIndex, predicate.trait_ref.def_id) => {\n                 }\n                 _ => continue,"}, {"sha": "994fe48c9fee0a21648f3fa28028e3c60f140a70", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -669,26 +669,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.fulfillment_cx.borrow().pending_obligations().into_iter().filter_map(\n             move |obligation| match &obligation.predicate.kind().skip_binder() {\n-                ty::PredicateKind::Projection(data)\n+                ty::PredicateKind::Clause(ty::Clause::Projection(data))\n                     if self.self_type_matches_expected_vid(\n                         data.projection_ty.self_ty(),\n                         ty_var_root,\n                     ) =>\n                 {\n                     Some(obligation)\n                 }\n-                ty::PredicateKind::Trait(data)\n+                ty::PredicateKind::Clause(ty::Clause::Trait(data))\n                     if self.self_type_matches_expected_vid(data.self_ty(), ty_var_root) =>\n                 {\n                     Some(obligation)\n                 }\n \n-                ty::PredicateKind::Trait(..)\n-                | ty::PredicateKind::Projection(..)\n+                ty::PredicateKind::Clause(ty::Clause::Trait(..))\n+                | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Coerce(..)\n-                | ty::PredicateKind::RegionOutlives(..)\n-                | ty::PredicateKind::TypeOutlives(..)\n+                | ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n+                | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n                 | ty::PredicateKind::WellFormed(..)\n                 | ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n@@ -712,7 +712,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let sized_did = self.tcx.lang_items().sized_trait();\n         self.obligations_for_self_ty(self_ty).any(|obligation| {\n             match obligation.predicate.kind().skip_binder() {\n-                ty::PredicateKind::Trait(data) => Some(data.def_id()) == sized_did,\n+                ty::PredicateKind::Clause(ty::Clause::Trait(data)) => {\n+                    Some(data.def_id()) == sized_did\n+                }\n                 _ => false,\n             }\n         })"}, {"sha": "ecf6f458ca3f7723c84ddd1411ea4c1f2a9c2989", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -1740,8 +1740,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let generics = self.tcx.generics_of(def_id);\n         let predicate_substs = match unsubstituted_pred.kind().skip_binder() {\n-            ty::PredicateKind::Trait(pred) => pred.trait_ref.substs,\n-            ty::PredicateKind::Projection(pred) => pred.projection_ty.substs,\n+            ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => pred.trait_ref.substs,\n+            ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => pred.projection_ty.substs,\n             _ => ty::List::empty(),\n         };\n \n@@ -2113,7 +2113,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         for (predicate, span) in\n                             std::iter::zip(instantiated.predicates, instantiated.spans)\n                         {\n-                            if let ty::PredicateKind::Trait(pred) = predicate.kind().skip_binder()\n+                            if let ty::PredicateKind::Clause(ty::Clause::Trait(pred)) = predicate.kind().skip_binder()\n                                 && pred.self_ty().peel_refs() == callee_ty\n                                 && ty::ClosureKind::from_def_id(self.tcx, pred.def_id()).is_some()\n                             {"}, {"sha": "ed5f7f31764fde1448af8301469880fef4da0f60", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -201,7 +201,9 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n             predicates: tcx.arena.alloc_from_iter(\n                 self.param_env.caller_bounds().iter().filter_map(|predicate| {\n                     match predicate.kind().skip_binder() {\n-                        ty::PredicateKind::Trait(data) if data.self_ty().is_param(index) => {\n+                        ty::PredicateKind::Clause(ty::Clause::Trait(data))\n+                            if data.self_ty().is_param(index) =>\n+                        {\n                             // HACK(eddyb) should get the original `Span`.\n                             let span = tcx.def_span(def_id);\n                             Some((predicate, span))"}, {"sha": "c0aff8f240f73790b998e4e7bf704de087c6dc3b", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -173,7 +173,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 ty::Opaque(def_id, substs) => {\n                     self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n-                        if let ty::PredicateKind::Projection(proj) = pred.kind().skip_binder()\n+                        if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n                         && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n                         // args tuple will always be substs[1]\n                         && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n@@ -208,7 +208,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ty::Param(param) => {\n                     let def_id = self.tcx.generics_of(self.body_id.owner).type_param(&param, self.tcx).def_id;\n                     self.tcx.predicates_of(self.body_id.owner).predicates.iter().find_map(|(pred, _)| {\n-                        if let ty::PredicateKind::Projection(proj) = pred.kind().skip_binder()\n+                        if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n                         && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n                         && proj.projection_ty.self_ty() == found\n                         // args tuple will always be substs[1]"}, {"sha": "30d2c63fd849ae589add9a944f6dd2481f26dd1f", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -566,7 +566,7 @@ fn check_must_not_suspend_ty<'tcx>(\n             let mut has_emitted = false;\n             for &(predicate, _) in fcx.tcx.explicit_item_bounds(def) {\n                 // We only look at the `DefId`, so it is safe to skip the binder here.\n-                if let ty::PredicateKind::Trait(ref poly_trait_predicate) =\n+                if let ty::PredicateKind::Clause(ty::Clause::Trait(ref poly_trait_predicate)) =\n                     predicate.kind().skip_binder()\n                 {\n                     let def_id = poly_trait_predicate.trait_ref.def_id;"}, {"sha": "e968ccc11e55afd0cc57c8e4bf5da3c7030a0647", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -531,7 +531,9 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         traits::elaborate_predicates(self.tcx, predicates.predicates.iter().copied())\n             // We don't care about regions here.\n             .filter_map(|obligation| match obligation.predicate.kind().skip_binder() {\n-                ty::PredicateKind::Trait(trait_pred) if trait_pred.def_id() == sized_def_id => {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred))\n+                    if trait_pred.def_id() == sized_def_id =>\n+                {\n                     let span = iter::zip(&predicates.predicates, &predicates.spans)\n                         .find_map(\n                             |(p, span)| {"}, {"sha": "002467fb73e918a65c9e88e8dd3d671e9ffd211a", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -785,7 +785,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         let bounds = self.param_env.caller_bounds().iter().filter_map(|predicate| {\n             let bound_predicate = predicate.kind();\n             match bound_predicate.skip_binder() {\n-                ty::PredicateKind::Trait(trait_predicate) => {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(trait_predicate)) => {\n                     match *trait_predicate.trait_ref.self_ty().kind() {\n                         ty::Param(p) if p == param_ty => {\n                             Some(bound_predicate.rebind(trait_predicate.trait_ref))\n@@ -795,12 +795,12 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 }\n                 ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Coerce(..)\n-                | ty::PredicateKind::Projection(..)\n-                | ty::PredicateKind::RegionOutlives(..)\n+                | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+                | ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n                 | ty::PredicateKind::WellFormed(..)\n                 | ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::ClosureKind(..)\n-                | ty::PredicateKind::TypeOutlives(..)\n+                | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n                 | ty::PredicateKind::Ambiguous"}, {"sha": "5ca74f713afe5e8f774757997974abda92b6c5b6", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -442,7 +442,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let mut unimplemented_traits = FxHashMap::default();\n                     let mut unimplemented_traits_only = true;\n                     for (predicate, _parent_pred, cause) in &unsatisfied_predicates {\n-                        if let (ty::PredicateKind::Trait(p), Some(cause)) =\n+                        if let (ty::PredicateKind::Clause(ty::Clause::Trait(p)), Some(cause)) =\n                             (predicate.kind().skip_binder(), cause.as_ref())\n                         {\n                             if p.trait_ref.self_ty() != rcvr_ty {\n@@ -469,7 +469,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // because of some non-Clone item being iterated over.\n                     for (predicate, _parent_pred, _cause) in &unsatisfied_predicates {\n                         match predicate.kind().skip_binder() {\n-                            ty::PredicateKind::Trait(p)\n+                            ty::PredicateKind::Clause(ty::Clause::Trait(p))\n                                 if unimplemented_traits.contains_key(&p.trait_ref.def_id) => {}\n                             _ => {\n                                 unimplemented_traits_only = false;\n@@ -481,7 +481,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let mut collect_type_param_suggestions =\n                         |self_ty: Ty<'tcx>, parent_pred: ty::Predicate<'tcx>, obligation: &str| {\n                             // We don't care about regions here, so it's fine to skip the binder here.\n-                            if let (ty::Param(_), ty::PredicateKind::Trait(p)) =\n+                            if let (ty::Param(_), ty::PredicateKind::Clause(ty::Clause::Trait(p))) =\n                                 (self_ty.kind(), parent_pred.kind().skip_binder())\n                             {\n                                 let hir = self.tcx.hir();\n@@ -544,7 +544,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let mut format_pred = |pred: ty::Predicate<'tcx>| {\n                         let bound_predicate = pred.kind();\n                         match bound_predicate.skip_binder() {\n-                            ty::PredicateKind::Projection(pred) => {\n+                            ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => {\n                                 let pred = bound_predicate.rebind(pred);\n                                 // `<Foo as Iterator>::Item = String`.\n                                 let projection_ty = pred.skip_binder().projection_ty;\n@@ -567,7 +567,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 bound_span_label(projection_ty.self_ty(), &obligation, &quiet);\n                                 Some((obligation, projection_ty.self_ty()))\n                             }\n-                            ty::PredicateKind::Trait(poly_trait_ref) => {\n+                            ty::PredicateKind::Clause(ty::Clause::Trait(poly_trait_ref)) => {\n                                 let p = poly_trait_ref.trait_ref;\n                                 let self_ty = p.self_ty();\n                                 let path = p.print_only_trait_path();\n@@ -637,7 +637,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 let sized_pred =\n                                     unsatisfied_predicates.iter().any(|(pred, _, _)| {\n                                         match pred.kind().skip_binder() {\n-                                            ty::PredicateKind::Trait(pred) => {\n+                                            ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => {\n                                                 Some(pred.def_id())\n                                                     == self.tcx.lang_items().sized_trait()\n                                                     && pred.polarity == ty::ImplPolarity::Positive\n@@ -1722,7 +1722,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         let all_local_types_needing_impls =\n             errors.iter().all(|e| match e.obligation.predicate.kind().skip_binder() {\n-                ty::PredicateKind::Trait(pred) => match pred.self_ty().kind() {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => match pred.self_ty().kind() {\n                     ty::Adt(def, _) => def.did().is_local(),\n                     _ => false,\n                 },\n@@ -1731,7 +1731,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut preds: Vec<_> = errors\n             .iter()\n             .filter_map(|e| match e.obligation.predicate.kind().skip_binder() {\n-                ty::PredicateKind::Trait(pred) => Some(pred),\n+                ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => Some(pred),\n                 _ => None,\n             })\n             .collect();\n@@ -1802,7 +1802,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut derives = Vec::<(String, Span, Symbol)>::new();\n         let mut traits = Vec::<Span>::new();\n         for (pred, _, _) in unsatisfied_predicates {\n-            let ty::PredicateKind::Trait(trait_pred) = pred.kind().skip_binder() else { continue };\n+            let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = pred.kind().skip_binder() else { continue };\n             let adt = match trait_pred.self_ty().ty_adt_def() {\n                 Some(adt) if adt.did().is_local() => adt,\n                 _ => continue,\n@@ -2212,8 +2212,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     match p.kind().skip_binder() {\n                         // Hide traits if they are present in predicates as they can be fixed without\n                         // having to implement them.\n-                        ty::PredicateKind::Trait(t) => t.def_id() == info.def_id,\n-                        ty::PredicateKind::Projection(p) => {\n+                        ty::PredicateKind::Clause(ty::Clause::Trait(t)) => {\n+                            t.def_id() == info.def_id\n+                        }\n+                        ty::PredicateKind::Clause(ty::Clause::Projection(p)) => {\n                             p.projection_ty.item_def_id == info.def_id\n                         }\n                         _ => false,"}, {"sha": "996b1c40e3fd6301438e538dff730135ad4b3348", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -569,10 +569,10 @@ impl<'tcx> InferCtxt<'tcx> {\n \n         let atom = match k1.unpack() {\n             GenericArgKind::Lifetime(r1) => {\n-                ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r1, r2))\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(r1, r2)))\n             }\n             GenericArgKind::Type(t1) => {\n-                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(t1, r2))\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(t1, r2)))\n             }\n             GenericArgKind::Const(..) => {\n                 // Consts cannot outlive one another, so we don't expect to\n@@ -720,8 +720,8 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         self.obligations.push(Obligation {\n             cause: self.cause.clone(),\n             param_env: self.param_env,\n-            predicate: ty::Binder::dummy(ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n-                sup, sub,\n+            predicate: ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::RegionOutlives(\n+                ty::OutlivesPredicate(sup, sub),\n             )))\n             .to_predicate(self.infcx.tcx),\n             recursion_depth: 0,"}, {"sha": "ecb23e2be7de35c9f22f84e287d094e1065a585e", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -351,7 +351,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                 let output = predicate\n                     .kind()\n                     .map_bound(|kind| match kind {\n-                        ty::PredicateKind::Projection(projection_predicate)\n+                        ty::PredicateKind::Clause(ty::Clause::Projection(projection_predicate))\n                             if projection_predicate.projection_ty.item_def_id == item_def_id =>\n                         {\n                             projection_predicate.term.ty()"}, {"sha": "26caf82ec6ae1ca4a1df5efa92709dce2edead6e", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -595,7 +595,9 @@ impl<'tcx> InferCtxt<'tcx> {\n                 ct_op: |ct| ct,\n             });\n \n-            if let ty::PredicateKind::Projection(projection) = predicate.kind().skip_binder() {\n+            if let ty::PredicateKind::Clause(ty::Clause::Projection(projection)) =\n+                predicate.kind().skip_binder()\n+            {\n                 if projection.term.references_error() {\n                     // No point on adding these obligations since there's a type error involved.\n                     return Ok(InferOk { value: (), obligations: vec![] });"}, {"sha": "4daa257672cfcd8c53e02e8ae6f933d60fdf9b52", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -19,20 +19,21 @@ pub fn explicit_outlives_bounds<'tcx>(\n         .map(ty::Predicate::kind)\n         .filter_map(ty::Binder::no_bound_vars)\n         .filter_map(move |kind| match kind {\n-            ty::PredicateKind::Projection(..)\n-            | ty::PredicateKind::Trait(..)\n+            ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+            | ty::PredicateKind::Clause(ty::Clause::Trait(..))\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::WellFormed(..)\n             | ty::PredicateKind::ObjectSafe(..)\n             | ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::TypeOutlives(..)\n+            | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n             | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n-            ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n-                Some(OutlivesBound::RegionSubRegion(r_b, r_a))\n-            }\n+            ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n+                r_a,\n+                r_b,\n+            ))) => Some(OutlivesBound::RegionSubRegion(r_b, r_a)),\n         })\n }"}, {"sha": "026713b6a28b8c539817d2362390f391f07533da", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -70,8 +70,8 @@ impl<'tcx> PredicateObligation<'tcx> {\n \n     pub fn without_const(mut self, tcx: TyCtxt<'tcx>) -> PredicateObligation<'tcx> {\n         self.param_env = self.param_env.without_const();\n-        if let ty::PredicateKind::Trait(trait_pred) = self.predicate.kind().skip_binder() && trait_pred.is_const_if_const() {\n-            self.predicate = tcx.mk_predicate(self.predicate.kind().map_bound(|_| ty::PredicateKind::Trait(trait_pred.without_const())));\n+        if let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = self.predicate.kind().skip_binder() && trait_pred.is_const_if_const() {\n+            self.predicate = tcx.mk_predicate(self.predicate.kind().map_bound(|_| ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred.without_const()))));\n         }\n         self\n     }"}, {"sha": "512e6079f43a02fa7ada619ec45164ccce254748", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -141,7 +141,7 @@ impl<'tcx> Elaborator<'tcx> {\n \n         let bound_predicate = obligation.predicate.kind();\n         match bound_predicate.skip_binder() {\n-            ty::PredicateKind::Trait(data) => {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(data)) => {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n@@ -184,7 +184,7 @@ impl<'tcx> Elaborator<'tcx> {\n                 // Currently, we do not \"elaborate\" predicates like `X -> Y`,\n                 // though conceivably we might.\n             }\n-            ty::PredicateKind::Projection(..) => {\n+            ty::PredicateKind::Clause(ty::Clause::Projection(..)) => {\n                 // Nothing to elaborate in a projection predicate.\n             }\n             ty::PredicateKind::ClosureKind(..) => {\n@@ -198,10 +198,13 @@ impl<'tcx> Elaborator<'tcx> {\n                 // Currently, we do not elaborate const-equate\n                 // predicates.\n             }\n-            ty::PredicateKind::RegionOutlives(..) => {\n+            ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..)) => {\n                 // Nothing to elaborate from `'a: 'b`.\n             }\n-            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_max, r_min)) => {\n+            ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                ty_max,\n+                r_min,\n+            ))) => {\n                 // We know that `T: 'a` for some type `T`. We can\n                 // often elaborate this. For example, if we know that\n                 // `[U]: 'a`, that implies that `U: 'a`. Similarly, if\n@@ -231,25 +234,25 @@ impl<'tcx> Elaborator<'tcx> {\n                                 if r.is_late_bound() {\n                                     None\n                                 } else {\n-                                    Some(ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n-                                        r, r_min,\n+                                    Some(ty::PredicateKind::Clause(ty::Clause::RegionOutlives(\n+                                        ty::OutlivesPredicate(r, r_min),\n                                     )))\n                                 }\n                             }\n \n                             Component::Param(p) => {\n                                 let ty = tcx.mk_ty_param(p.index, p.name);\n-                                Some(ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n-                                    ty, r_min,\n+                                Some(ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n+                                    ty::OutlivesPredicate(ty, r_min),\n                                 )))\n                             }\n \n                             Component::UnresolvedInferenceVariable(_) => None,\n \n                             Component::Opaque(def_id, substs) => {\n                                 let ty = tcx.mk_opaque(def_id, substs);\n-                                Some(ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n-                                    ty, r_min,\n+                                Some(ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n+                                    ty::OutlivesPredicate(ty, r_min),\n                                 )))\n                             }\n \n@@ -258,8 +261,8 @@ impl<'tcx> Elaborator<'tcx> {\n                                 // With this, we can deduce that `<Bar as Baz>::Assoc: 'a`.\n                                 let ty =\n                                     tcx.mk_projection(projection.item_def_id, projection.substs);\n-                                Some(ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n-                                    ty, r_min,\n+                                Some(ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n+                                    ty::OutlivesPredicate(ty, r_min),\n                                 )))\n                             }\n "}, {"sha": "4b5aa3badda9fa7136bd213c7baec61e8bd7dcb3", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -1638,19 +1638,20 @@ declare_lint_pass!(\n impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         use rustc_middle::ty::visit::TypeVisitable;\n+        use rustc_middle::ty::Clause;\n         use rustc_middle::ty::PredicateKind::*;\n \n         if cx.tcx.features().trivial_bounds {\n             let predicates = cx.tcx.predicates_of(item.owner_id);\n             for &(predicate, span) in predicates.predicates {\n                 let predicate_kind_name = match predicate.kind().skip_binder() {\n-                    Trait(..) => \"trait\",\n-                    TypeOutlives(..) |\n-                    RegionOutlives(..) => \"lifetime\",\n+                    Clause(Clause::Trait(..)) => \"trait\",\n+                    Clause(Clause::TypeOutlives(..)) |\n+                    Clause(Clause::RegionOutlives(..)) => \"lifetime\",\n \n                     // Ignore projections, as they can only be global\n                     // if the trait bound is global\n-                    Projection(..) |\n+                    Clause(Clause::Projection(..)) |\n                     // Ignore bounds that a user can't type\n                     WellFormed(..) |\n                     ObjectSafe(..) |\n@@ -2051,7 +2052,10 @@ impl ExplicitOutlivesRequirements {\n         inferred_outlives\n             .iter()\n             .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n-                ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => match *a {\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n+                    a,\n+                    b,\n+                ))) => match *a {\n                     ty::ReEarlyBound(ebr) if ebr.def_id == def_id => Some(b),\n                     _ => None,\n                 },\n@@ -2067,9 +2071,10 @@ impl ExplicitOutlivesRequirements {\n         inferred_outlives\n             .iter()\n             .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n-                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(a, b)) => {\n-                    a.is_param(index).then_some(b)\n-                }\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                    a,\n+                    b,\n+                ))) => a.is_param(index).then_some(b),\n                 _ => None,\n             })\n             .collect()"}, {"sha": "03d6f4fd92687f192ac40cbf540209b057bdfeae", "filename": "compiler/rustc_lint/src/opaque_hidden_inferred_bound.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n             // Liberate bound regions in the predicate since we\n             // don't actually care about lifetimes in this check.\n             let predicate = cx.tcx.liberate_late_bound_regions(def_id, pred.kind());\n-            let ty::PredicateKind::Projection(proj) = predicate else {\n+            let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = predicate else {\n                 continue;\n             };\n             // Only check types, since those are the only things that may\n@@ -116,12 +116,13 @@ impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n                     // If it's a trait bound and an opaque that doesn't satisfy it,\n                     // then we can emit a suggestion to add the bound.\n                     let add_bound = match (proj_term.kind(), assoc_pred.kind().skip_binder()) {\n-                        (ty::Opaque(def_id, _), ty::PredicateKind::Trait(trait_pred)) => {\n-                            Some(AddBound {\n-                                suggest_span: cx.tcx.def_span(*def_id).shrink_to_hi(),\n-                                trait_ref: trait_pred.print_modifiers_and_trait_path(),\n-                            })\n-                        }\n+                        (\n+                            ty::Opaque(def_id, _),\n+                            ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)),\n+                        ) => Some(AddBound {\n+                            suggest_span: cx.tcx.def_span(*def_id).shrink_to_hi(),\n+                            trait_ref: trait_pred.print_modifiers_and_trait_path(),\n+                        }),\n                         _ => None,\n                     };\n                     cx.emit_spanned_lint("}, {"sha": "1b21c2dac37887ab548d04826e62b5ec96e6ffde", "filename": "compiler/rustc_lint/src/traits.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -87,11 +87,12 @@ declare_lint_pass!(\n \n impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n+        use rustc_middle::ty::Clause;\n         use rustc_middle::ty::PredicateKind::*;\n \n         let predicates = cx.tcx.explicit_predicates_of(item.owner_id);\n         for &(predicate, span) in predicates.predicates {\n-            let Trait(trait_predicate) = predicate.kind().skip_binder() else {\n+            let Clause(Clause::Trait(trait_predicate)) = predicate.kind().skip_binder() else {\n                 continue\n             };\n             let def_id = trait_predicate.trait_ref.def_id;"}, {"sha": "43864ed45fae224c5ac60339e84e1eb4399c4557", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -258,8 +258,9 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     )\n                     .filter_map(|obligation| {\n                         // We only look at the `DefId`, so it is safe to skip the binder here.\n-                        if let ty::PredicateKind::Trait(ref poly_trait_predicate) =\n-                            obligation.predicate.kind().skip_binder()\n+                        if let ty::PredicateKind::Clause(ty::Clause::Trait(\n+                            ref poly_trait_predicate,\n+                        )) = obligation.predicate.kind().skip_binder()\n                         {\n                             let def_id = poly_trait_predicate.trait_ref.def_id;\n "}, {"sha": "bede0ec142e81ed76c6dd5d22c09cf5b60f64543", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -2296,7 +2296,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let future_trait = self.require_lang_item(LangItem::Future, None);\n \n         self.explicit_item_bounds(def_id).iter().any(|(predicate, _)| {\n-            let ty::PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder() else {\n+            let ty::PredicateKind::Clause(ty::Clause::Trait(trait_predicate)) = predicate.kind().skip_binder() else {\n                 return false;\n             };\n             trait_predicate.trait_ref.def_id == future_trait\n@@ -2319,7 +2319,9 @@ impl<'tcx> TyCtxt<'tcx> {\n             let generic_predicates = self.super_predicates_of(trait_did);\n \n             for (predicate, _) in generic_predicates.predicates {\n-                if let ty::PredicateKind::Trait(data) = predicate.kind().skip_binder() {\n+                if let ty::PredicateKind::Clause(ty::Clause::Trait(data)) =\n+                    predicate.kind().skip_binder()\n+                {\n                     if set.insert(data.def_id()) {\n                         stack.push(data.def_id());\n                     }"}, {"sha": "61f3a0685e72c16341b7a7e8bbb3ccffe90a964a", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -216,14 +216,17 @@ impl FlagComputation {\n \n     fn add_predicate_atom(&mut self, atom: ty::PredicateKind<'_>) {\n         match atom {\n-            ty::PredicateKind::Trait(trait_pred) => {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => {\n                 self.add_substs(trait_pred.trait_ref.substs);\n             }\n-            ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => {\n+            ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(a, b))) => {\n                 self.add_region(a);\n                 self.add_region(b);\n             }\n-            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, region)) => {\n+            ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                ty,\n+                region,\n+            ))) => {\n                 self.add_ty(ty);\n                 self.add_region(region);\n             }\n@@ -235,7 +238,10 @@ impl FlagComputation {\n                 self.add_ty(a);\n                 self.add_ty(b);\n             }\n-            ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, term }) => {\n+            ty::PredicateKind::Clause(ty::Clause::Projection(ty::ProjectionPredicate {\n+                projection_ty,\n+                term,\n+            })) => {\n                 self.add_projection_ty(projection_ty);\n                 match term.unpack() {\n                     ty::TermKind::Ty(ty) => self.add_ty(ty),"}, {"sha": "f20fa3c32adc941b3956cf82e9062b9085c637b0", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -574,13 +574,15 @@ impl<'tcx> Predicate<'tcx> {\n         let kind = self\n             .kind()\n             .map_bound(|kind| match kind {\n-                PredicateKind::Trait(TraitPredicate { trait_ref, constness, polarity }) => {\n-                    Some(PredicateKind::Trait(TraitPredicate {\n-                        trait_ref,\n-                        constness,\n-                        polarity: polarity.flip()?,\n-                    }))\n-                }\n+                PredicateKind::Clause(Clause::Trait(TraitPredicate {\n+                    trait_ref,\n+                    constness,\n+                    polarity,\n+                })) => Some(PredicateKind::Clause(Clause::Trait(TraitPredicate {\n+                    trait_ref,\n+                    constness,\n+                    polarity: polarity.flip()?,\n+                }))),\n \n                 _ => None,\n             })\n@@ -590,14 +592,14 @@ impl<'tcx> Predicate<'tcx> {\n     }\n \n     pub fn without_const(mut self, tcx: TyCtxt<'tcx>) -> Self {\n-        if let PredicateKind::Trait(TraitPredicate { trait_ref, constness, polarity }) = self.kind().skip_binder()\n+        if let PredicateKind::Clause(Clause::Trait(TraitPredicate { trait_ref, constness, polarity })) = self.kind().skip_binder()\n             && constness != BoundConstness::NotConst\n         {\n-            self = tcx.mk_predicate(self.kind().rebind(PredicateKind::Trait(TraitPredicate {\n+            self = tcx.mk_predicate(self.kind().rebind(PredicateKind::Clause(Clause::Trait(TraitPredicate {\n                 trait_ref,\n                 constness: BoundConstness::NotConst,\n                 polarity,\n-            })));\n+            }))));\n         }\n         self\n     }\n@@ -611,10 +613,10 @@ impl<'tcx> Predicate<'tcx> {\n     pub fn allow_normalization(self) -> bool {\n         match self.kind().skip_binder() {\n             PredicateKind::WellFormed(_) => false,\n-            PredicateKind::Trait(_)\n-            | PredicateKind::RegionOutlives(_)\n-            | PredicateKind::TypeOutlives(_)\n-            | PredicateKind::Projection(_)\n+            PredicateKind::Clause(Clause::Trait(_))\n+            | PredicateKind::Clause(Clause::RegionOutlives(_))\n+            | PredicateKind::Clause(Clause::TypeOutlives(_))\n+            | PredicateKind::Clause(Clause::Projection(_))\n             | PredicateKind::ObjectSafe(_)\n             | PredicateKind::ClosureKind(_, _, _)\n             | PredicateKind::Subtype(_)\n@@ -650,7 +652,9 @@ impl rustc_errors::IntoDiagnosticArg for Predicate<'_> {\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n-pub enum PredicateKind<'tcx> {\n+/// A clause is something that can appear in where bounds or be inferred\n+/// by implied bounds.\n+pub enum Clause<'tcx> {\n     /// Corresponds to `where Foo: Bar<A, B, C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n     /// would be the type parameters.\n@@ -665,6 +669,13 @@ pub enum PredicateKind<'tcx> {\n     /// `where <T as TraitRef>::Name == X`, approximately.\n     /// See the `ProjectionPredicate` struct for details.\n     Projection(ProjectionPredicate<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n+pub enum PredicateKind<'tcx> {\n+    /// Prove a clause\n+    Clause(Clause<'tcx>),\n \n     /// No syntax: `T` well-formed.\n     WellFormed(GenericArg<'tcx>),\n@@ -1174,41 +1185,41 @@ impl<'tcx> ToPredicate<'tcx, PolyTraitPredicate<'tcx>> for Binder<'tcx, TraitRef\n \n impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for PolyTraitPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        self.map_bound(PredicateKind::Trait).to_predicate(tcx)\n+        self.map_bound(|p| PredicateKind::Clause(Clause::Trait(p))).to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for PolyRegionOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        self.map_bound(PredicateKind::RegionOutlives).to_predicate(tcx)\n+        self.map_bound(|p| PredicateKind::Clause(Clause::RegionOutlives(p))).to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for PolyTypeOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        self.map_bound(PredicateKind::TypeOutlives).to_predicate(tcx)\n+        self.map_bound(|p| PredicateKind::Clause(Clause::TypeOutlives(p))).to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for PolyProjectionPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        self.map_bound(PredicateKind::Projection).to_predicate(tcx)\n+        self.map_bound(|p| PredicateKind::Clause(Clause::Projection(p))).to_predicate(tcx)\n     }\n }\n \n impl<'tcx> Predicate<'tcx> {\n     pub fn to_opt_poly_trait_pred(self) -> Option<PolyTraitPredicate<'tcx>> {\n         let predicate = self.kind();\n         match predicate.skip_binder() {\n-            PredicateKind::Trait(t) => Some(predicate.rebind(t)),\n-            PredicateKind::Projection(..)\n+            PredicateKind::Clause(Clause::Trait(t)) => Some(predicate.rebind(t)),\n+            PredicateKind::Clause(Clause::Projection(..))\n             | PredicateKind::Subtype(..)\n             | PredicateKind::Coerce(..)\n-            | PredicateKind::RegionOutlives(..)\n+            | PredicateKind::Clause(Clause::RegionOutlives(..))\n             | PredicateKind::WellFormed(..)\n             | PredicateKind::ObjectSafe(..)\n             | PredicateKind::ClosureKind(..)\n-            | PredicateKind::TypeOutlives(..)\n+            | PredicateKind::Clause(Clause::TypeOutlives(..))\n             | PredicateKind::ConstEvaluatable(..)\n             | PredicateKind::ConstEquate(..)\n             | PredicateKind::Ambiguous\n@@ -1219,15 +1230,15 @@ impl<'tcx> Predicate<'tcx> {\n     pub fn to_opt_poly_projection_pred(self) -> Option<PolyProjectionPredicate<'tcx>> {\n         let predicate = self.kind();\n         match predicate.skip_binder() {\n-            PredicateKind::Projection(t) => Some(predicate.rebind(t)),\n-            PredicateKind::Trait(..)\n+            PredicateKind::Clause(Clause::Projection(t)) => Some(predicate.rebind(t)),\n+            PredicateKind::Clause(Clause::Trait(..))\n             | PredicateKind::Subtype(..)\n             | PredicateKind::Coerce(..)\n-            | PredicateKind::RegionOutlives(..)\n+            | PredicateKind::Clause(Clause::RegionOutlives(..))\n             | PredicateKind::WellFormed(..)\n             | PredicateKind::ObjectSafe(..)\n             | PredicateKind::ClosureKind(..)\n-            | PredicateKind::TypeOutlives(..)\n+            | PredicateKind::Clause(Clause::TypeOutlives(..))\n             | PredicateKind::ConstEvaluatable(..)\n             | PredicateKind::ConstEquate(..)\n             | PredicateKind::Ambiguous\n@@ -1238,12 +1249,12 @@ impl<'tcx> Predicate<'tcx> {\n     pub fn to_opt_type_outlives(self) -> Option<PolyTypeOutlivesPredicate<'tcx>> {\n         let predicate = self.kind();\n         match predicate.skip_binder() {\n-            PredicateKind::TypeOutlives(data) => Some(predicate.rebind(data)),\n-            PredicateKind::Trait(..)\n-            | PredicateKind::Projection(..)\n+            PredicateKind::Clause(Clause::TypeOutlives(data)) => Some(predicate.rebind(data)),\n+            PredicateKind::Clause(Clause::Trait(..))\n+            | PredicateKind::Clause(Clause::Projection(..))\n             | PredicateKind::Subtype(..)\n             | PredicateKind::Coerce(..)\n-            | PredicateKind::RegionOutlives(..)\n+            | PredicateKind::Clause(Clause::RegionOutlives(..))\n             | PredicateKind::WellFormed(..)\n             | PredicateKind::ObjectSafe(..)\n             | PredicateKind::ClosureKind(..)"}, {"sha": "a90b63cc05b84558bf9d178fe4f2fe59177ef98b", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -814,7 +814,7 @@ pub trait PrettyPrinter<'tcx>:\n             let bound_predicate = predicate.kind();\n \n             match bound_predicate.skip_binder() {\n-                ty::PredicateKind::Trait(pred) => {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => {\n                     let trait_ref = bound_predicate.rebind(pred.trait_ref);\n \n                     // Don't print + Sized, but rather + ?Sized if absent.\n@@ -825,7 +825,7 @@ pub trait PrettyPrinter<'tcx>:\n \n                     self.insert_trait_and_projection(trait_ref, None, &mut traits, &mut fn_traits);\n                 }\n-                ty::PredicateKind::Projection(pred) => {\n+                ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => {\n                     let proj_ref = bound_predicate.rebind(pred);\n                     let trait_ref = proj_ref.required_poly_trait_ref(tcx);\n \n@@ -839,7 +839,7 @@ pub trait PrettyPrinter<'tcx>:\n                         &mut fn_traits,\n                     );\n                 }\n-                ty::PredicateKind::TypeOutlives(outlives) => {\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(outlives)) => {\n                     lifetimes.push(outlives.1);\n                 }\n                 _ => {}\n@@ -2689,14 +2689,14 @@ define_print_and_forward_display! {\n \n     ty::PredicateKind<'tcx> {\n         match *self {\n-            ty::PredicateKind::Trait(ref data) => {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(ref data)) => {\n                 p!(print(data))\n             }\n             ty::PredicateKind::Subtype(predicate) => p!(print(predicate)),\n             ty::PredicateKind::Coerce(predicate) => p!(print(predicate)),\n-            ty::PredicateKind::RegionOutlives(predicate) => p!(print(predicate)),\n-            ty::PredicateKind::TypeOutlives(predicate) => p!(print(predicate)),\n-            ty::PredicateKind::Projection(predicate) => p!(print(predicate)),\n+            ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => p!(print(predicate)),\n+            ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => p!(print(predicate)),\n+            ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => p!(print(predicate)),\n             ty::PredicateKind::WellFormed(arg) => p!(print(arg), \" well-formed\"),\n             ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                 p!(\"the trait `\", print_def_path(trait_def_id, &[]), \"` is object-safe\")"}, {"sha": "c8baac1ec20a7232bdacf20a2ba2056bd4c326b8", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -150,15 +150,23 @@ impl<'tcx> fmt::Debug for ty::Predicate<'tcx> {\n     }\n }\n \n+impl<'tcx> fmt::Debug for ty::Clause<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ty::Clause::Trait(ref a) => a.fmt(f),\n+            ty::Clause::RegionOutlives(ref pair) => pair.fmt(f),\n+            ty::Clause::TypeOutlives(ref pair) => pair.fmt(f),\n+            ty::Clause::Projection(ref pair) => pair.fmt(f),\n+        }\n+    }\n+}\n+\n impl<'tcx> fmt::Debug for ty::PredicateKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            ty::PredicateKind::Trait(ref a) => a.fmt(f),\n+            ty::PredicateKind::Clause(ref a) => a.fmt(f),\n             ty::PredicateKind::Subtype(ref pair) => pair.fmt(f),\n             ty::PredicateKind::Coerce(ref pair) => pair.fmt(f),\n-            ty::PredicateKind::RegionOutlives(ref pair) => pair.fmt(f),\n-            ty::PredicateKind::TypeOutlives(ref pair) => pair.fmt(f),\n-            ty::PredicateKind::Projection(ref pair) => pair.fmt(f),\n             ty::PredicateKind::WellFormed(data) => write!(f, \"WellFormed({:?})\", data),\n             ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                 write!(f, \"ObjectSafe({:?})\", trait_def_id)"}, {"sha": "b708d780b70050d648557d04f34bf82a1338d60b", "filename": "compiler/rustc_mir_transform/src/function_item_references.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -110,7 +110,7 @@ impl<'tcx> FunctionItemRefChecker<'_, 'tcx> {\n \n     /// If the given predicate is the trait `fmt::Pointer`, returns the bound parameter type.\n     fn is_pointer_trait(&self, bound: &PredicateKind<'tcx>) -> Option<Ty<'tcx>> {\n-        if let ty::PredicateKind::Trait(predicate) = bound {\n+        if let ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) = bound {\n             if self.tcx.is_diagnostic_item(sym::Pointer, predicate.def_id()) {\n                 Some(predicate.trait_ref.self_ty())\n             } else {"}, {"sha": "550ed9b6378445bf33017e82597ab3d8ce85103c", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -146,19 +146,23 @@ where\n \n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<V::BreakTy> {\n         match predicate.kind().skip_binder() {\n-            ty::PredicateKind::Trait(ty::TraitPredicate {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate {\n                 trait_ref,\n                 constness: _,\n                 polarity: _,\n-            }) => self.visit_trait(trait_ref),\n-            ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, term }) => {\n+            })) => self.visit_trait(trait_ref),\n+            ty::PredicateKind::Clause(ty::Clause::Projection(ty::ProjectionPredicate {\n+                projection_ty,\n+                term,\n+            })) => {\n                 term.visit_with(self)?;\n                 self.visit_projection_ty(projection_ty)\n             }\n-            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _region)) => {\n-                ty.visit_with(self)\n-            }\n-            ty::PredicateKind::RegionOutlives(..) => ControlFlow::CONTINUE,\n+            ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                ty,\n+                _region,\n+            ))) => ty.visit_with(self),\n+            ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..)) => ControlFlow::CONTINUE,\n             ty::PredicateKind::ConstEvaluatable(ct) => ct.visit_with(self),\n             ty::PredicateKind::WellFormed(arg) => arg.visit_with(self),\n             _ => bug!(\"unexpected predicate: {:?}\", predicate),"}, {"sha": "52552ff3f8674205d1d14b8341ffc0232d34d312", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -403,8 +403,10 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n     ) {\n         let mut should_add_new = true;\n         user_computed_preds.retain(|&old_pred| {\n-            if let (ty::PredicateKind::Trait(new_trait), ty::PredicateKind::Trait(old_trait)) =\n-                (new_pred.kind().skip_binder(), old_pred.kind().skip_binder())\n+            if let (\n+                ty::PredicateKind::Clause(ty::Clause::Trait(new_trait)),\n+                ty::PredicateKind::Clause(ty::Clause::Trait(old_trait)),\n+            ) = (new_pred.kind().skip_binder(), old_pred.kind().skip_binder())\n             {\n                 if new_trait.def_id() == old_trait.def_id() {\n                     let new_substs = new_trait.trait_ref.substs;\n@@ -624,14 +626,14 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n \n             let bound_predicate = predicate.kind();\n             match bound_predicate.skip_binder() {\n-                ty::PredicateKind::Trait(p) => {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(p)) => {\n                     // Add this to `predicates` so that we end up calling `select`\n                     // with it. If this predicate ends up being unimplemented,\n                     // then `evaluate_predicates` will handle adding it the `ParamEnv`\n                     // if possible.\n                     predicates.push_back(bound_predicate.rebind(p));\n                 }\n-                ty::PredicateKind::Projection(p) => {\n+                ty::PredicateKind::Clause(ty::Clause::Projection(p)) => {\n                     let p = bound_predicate.rebind(p);\n                     debug!(\n                         \"evaluate_nested_obligations: examining projection predicate {:?}\",\n@@ -764,11 +766,11 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                         }\n                     }\n                 }\n-                ty::PredicateKind::RegionOutlives(binder) => {\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(binder)) => {\n                     let binder = bound_predicate.rebind(binder);\n                     select.infcx().region_outlives_predicate(&dummy_cause, binder)\n                 }\n-                ty::PredicateKind::TypeOutlives(binder) => {\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(binder)) => {\n                     let binder = bound_predicate.rebind(binder);\n                     match (\n                         binder.no_bound_vars(),"}, {"sha": "e38b00a388d4d6baf00114ac6ae4b54beae47925", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -587,7 +587,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n                 let bound_predicate = obligation.predicate.kind();\n                 match bound_predicate.skip_binder() {\n-                    ty::PredicateKind::Trait(trait_predicate) => {\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(trait_predicate)) => {\n                         let trait_predicate = bound_predicate.rebind(trait_predicate);\n                         let mut trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n \n@@ -1051,9 +1051,9 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         span_bug!(span, \"coerce requirement gave wrong error: `{:?}`\", predicate)\n                     }\n \n-                    ty::PredicateKind::RegionOutlives(..)\n-                    | ty::PredicateKind::Projection(..)\n-                    | ty::PredicateKind::TypeOutlives(..) => {\n+                    ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n+                    | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+                    | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..)) => {\n                         let predicate = self.resolve_vars_if_possible(obligation.predicate);\n                         struct_span_err!(\n                             self.tcx.sess,\n@@ -1473,9 +1473,10 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         // FIXME: It should be possible to deal with `ForAll` in a cleaner way.\n         let bound_error = error.kind();\n         let (cond, error) = match (cond.kind().skip_binder(), bound_error.skip_binder()) {\n-            (ty::PredicateKind::Trait(..), ty::PredicateKind::Trait(error)) => {\n-                (cond, bound_error.rebind(error))\n-            }\n+            (\n+                ty::PredicateKind::Clause(ty::Clause::Trait(..)),\n+                ty::PredicateKind::Clause(ty::Clause::Trait(error)),\n+            ) => (cond, bound_error.rebind(error)),\n             _ => {\n                 // FIXME: make this work in other cases too.\n                 return false;\n@@ -1484,7 +1485,9 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n         for obligation in super::elaborate_predicates(self.tcx, std::iter::once(cond)) {\n             let bound_predicate = obligation.predicate.kind();\n-            if let ty::PredicateKind::Trait(implication) = bound_predicate.skip_binder() {\n+            if let ty::PredicateKind::Clause(ty::Clause::Trait(implication)) =\n+                bound_predicate.skip_binder()\n+            {\n                 let error = error.to_poly_trait_ref();\n                 let implication = bound_predicate.rebind(implication.trait_ref);\n                 // FIXME: I'm just not taking associated types at all here.\n@@ -1581,7 +1584,9 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             // this can fail if the problem was higher-ranked, in which\n             // cause I have no idea for a good error message.\n             let bound_predicate = predicate.kind();\n-            if let ty::PredicateKind::Projection(data) = bound_predicate.skip_binder() {\n+            if let ty::PredicateKind::Clause(ty::Clause::Projection(data)) =\n+                bound_predicate.skip_binder()\n+            {\n                 let mut selcx = SelectionContext::new(self);\n                 let data = self.replace_bound_vars_with_fresh_vars(\n                     obligation.cause.span,\n@@ -1629,7 +1634,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             let mut diag = struct_span_err!(self.tcx.sess, obligation.cause.span, E0271, \"{msg}\");\n \n             let secondary_span = match predicate.kind().skip_binder() {\n-                ty::PredicateKind::Projection(proj) => self\n+                ty::PredicateKind::Clause(ty::Clause::Projection(proj)) => self\n                     .tcx\n                     .opt_associated_item(proj.projection_ty.item_def_id)\n                     .and_then(|trait_assoc_item| {\n@@ -2047,7 +2052,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n         let bound_predicate = predicate.kind();\n         let mut err = match bound_predicate.skip_binder() {\n-            ty::PredicateKind::Trait(data) => {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(data)) => {\n                 let trait_ref = bound_predicate.rebind(data.trait_ref);\n                 debug!(?trait_ref);\n \n@@ -2324,7 +2329,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 assert!(a.is_ty_var() && b.is_ty_var());\n                 self.emit_inference_failure_err(body_id, span, a.into(), ErrorCode::E0282, true)\n             }\n-            ty::PredicateKind::Projection(data) => {\n+            ty::PredicateKind::Clause(ty::Clause::Projection(data)) => {\n                 if predicate.references_error() || self.tainted_by_errors().is_some() {\n                     return;\n                 }\n@@ -2570,7 +2575,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         err: &mut Diagnostic,\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n-        let ty::PredicateKind::Trait(pred) = obligation.predicate.kind().skip_binder() else { return; };\n+        let ty::PredicateKind::Clause(ty::Clause::Trait(pred)) = obligation.predicate.kind().skip_binder() else { return; };\n         let (ObligationCauseCode::BindingObligation(item_def_id, span)\n         | ObligationCauseCode::ExprBindingObligation(item_def_id, span, ..))\n             = *obligation.cause.code().peel_derives() else { return; };"}, {"sha": "0113df5bdc685b56902daa8c329ab5d835803e3b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -810,7 +810,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool {\n-        if let ty::PredicateKind::Trait(trait_pred) = obligation.predicate.kind().skip_binder()\n+        if let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = obligation.predicate.kind().skip_binder()\n             && Some(trait_pred.def_id()) == self.tcx.lang_items().sized_trait()\n         {\n             // Don't suggest calling to turn an unsized type into a sized type\n@@ -839,7 +839,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n             ty::Opaque(def_id, substs) => {\n                 self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n-                    if let ty::PredicateKind::Projection(proj) = pred.kind().skip_binder()\n+                    if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n                     && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n                     // args tuple will always be substs[1]\n                     && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n@@ -873,7 +873,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n             ty::Param(_) => {\n                 obligation.param_env.caller_bounds().iter().find_map(|pred| {\n-                    if let ty::PredicateKind::Projection(proj) = pred.kind().skip_binder()\n+                    if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n                     && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n                     && proj.projection_ty.self_ty() == found\n                     // args tuple will always be substs[1]\n@@ -1256,7 +1256,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     );\n                     // FIXME: account for associated `async fn`s.\n                     if let hir::Expr { span, kind: hir::ExprKind::Call(base, _), .. } = expr {\n-                        if let ty::PredicateKind::Trait(pred) =\n+                        if let ty::PredicateKind::Clause(ty::Clause::Trait(pred)) =\n                             obligation.predicate.kind().skip_binder()\n                         {\n                             err.span_label(\n@@ -1755,7 +1755,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         if let ObligationCauseCode::ExprBindingObligation(def_id, _, _, idx) = cause\n             && let predicates = self.tcx.predicates_of(def_id).instantiate_identity(self.tcx)\n             && let Some(pred) = predicates.predicates.get(*idx)\n-            && let ty::PredicateKind::Trait(trait_pred) = pred.kind().skip_binder()\n+            && let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = pred.kind().skip_binder()\n             && ty::ClosureKind::from_def_id(self.tcx, trait_pred.def_id()).is_some()\n         {\n             let expected_self =\n@@ -1769,7 +1769,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             let other_pred = std::iter::zip(&predicates.predicates, &predicates.spans)\n                 .enumerate()\n                 .find(|(other_idx, (pred, _))| match pred.kind().skip_binder() {\n-                    ty::PredicateKind::Trait(trait_pred)\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred))\n                         if ty::ClosureKind::from_def_id(self.tcx, trait_pred.def_id())\n                             .is_some()\n                             && other_idx != idx\n@@ -1896,7 +1896,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         // bound was introduced. At least one generator should be present for this diagnostic to be\n         // modified.\n         let (mut trait_ref, mut target_ty) = match obligation.predicate.kind().skip_binder() {\n-            ty::PredicateKind::Trait(p) => (Some(p), Some(p.self_ty())),\n+            ty::PredicateKind::Clause(ty::Clause::Trait(p)) => (Some(p), Some(p.self_ty())),\n             _ => (None, None),\n         };\n         let mut generator = None;"}, {"sha": "b0d0d1a7cba44d5c3038caca0724bb1419e51163", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -269,7 +269,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 // Evaluation will discard candidates using the leak check.\n                 // This means we need to pass it the bound version of our\n                 // predicate.\n-                ty::PredicateKind::Trait(trait_ref) => {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(trait_ref)) => {\n                     let trait_obligation = obligation.with(infcx.tcx, binder.rebind(trait_ref));\n \n                     self.process_trait_obligation(\n@@ -278,7 +278,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                         &mut pending_obligation.stalled_on,\n                     )\n                 }\n-                ty::PredicateKind::Projection(data) => {\n+                ty::PredicateKind::Clause(ty::Clause::Projection(data)) => {\n                     let project_obligation = obligation.with(infcx.tcx, binder.rebind(data));\n \n                     self.process_projection_obligation(\n@@ -287,8 +287,8 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                         &mut pending_obligation.stalled_on,\n                     )\n                 }\n-                ty::PredicateKind::RegionOutlives(_)\n-                | ty::PredicateKind::TypeOutlives(_)\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(_))\n+                | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(_))\n                 | ty::PredicateKind::WellFormed(_)\n                 | ty::PredicateKind::ObjectSafe(_)\n                 | ty::PredicateKind::ClosureKind(..)\n@@ -306,7 +306,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 }\n             },\n             Some(pred) => match pred {\n-                ty::PredicateKind::Trait(data) => {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(data)) => {\n                     let trait_obligation = obligation.with(infcx.tcx, Binder::dummy(data));\n \n                     self.process_trait_obligation(\n@@ -316,22 +316,25 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                     )\n                 }\n \n-                ty::PredicateKind::RegionOutlives(data) => {\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(data)) => {\n                     if infcx.considering_regions {\n                         infcx.region_outlives_predicate(&obligation.cause, Binder::dummy(data));\n                     }\n \n                     ProcessResult::Changed(vec![])\n                 }\n \n-                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(t_a, r_b)) => {\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                    t_a,\n+                    r_b,\n+                ))) => {\n                     if infcx.considering_regions {\n                         infcx.register_region_obligation_with_cause(t_a, r_b, &obligation.cause);\n                     }\n                     ProcessResult::Changed(vec![])\n                 }\n \n-                ty::PredicateKind::Projection(ref data) => {\n+                ty::PredicateKind::Clause(ty::Clause::Projection(ref data)) => {\n                     let project_obligation = obligation.with(infcx.tcx, Binder::dummy(*data));\n \n                     self.process_projection_obligation("}, {"sha": "3112756a0b14dbf5da5434ee535ece9f4324ca1c", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -317,7 +317,10 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // TypeOutlives predicates - these are normally used by regionck.\n     let outlives_predicates: Vec<_> = predicates\n         .drain_filter(|predicate| {\n-            matches!(predicate.kind().skip_binder(), ty::PredicateKind::TypeOutlives(..))\n+            matches!(\n+                predicate.kind().skip_binder(),\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n+            )\n         })\n         .collect();\n "}, {"sha": "9f531e03f06ad7e3245efff61f98e56fdc56c45f", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -288,11 +288,11 @@ fn predicate_references_self<'tcx>(\n     let self_ty = tcx.types.self_param;\n     let has_self_ty = |arg: &GenericArg<'tcx>| arg.walk().any(|arg| arg == self_ty.into());\n     match predicate.kind().skip_binder() {\n-        ty::PredicateKind::Trait(ref data) => {\n+        ty::PredicateKind::Clause(ty::Clause::Trait(ref data)) => {\n             // In the case of a trait predicate, we can skip the \"self\" type.\n             if data.trait_ref.substs[1..].iter().any(has_self_ty) { Some(sp) } else { None }\n         }\n-        ty::PredicateKind::Projection(ref data) => {\n+        ty::PredicateKind::Clause(ty::Clause::Projection(ref data)) => {\n             // And similarly for projections. This should be redundant with\n             // the previous check because any projection should have a\n             // matching `Trait` predicate with the same inputs, but we do\n@@ -312,8 +312,8 @@ fn predicate_references_self<'tcx>(\n         }\n         ty::PredicateKind::WellFormed(..)\n         | ty::PredicateKind::ObjectSafe(..)\n-        | ty::PredicateKind::TypeOutlives(..)\n-        | ty::PredicateKind::RegionOutlives(..)\n+        | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n+        | ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n         | ty::PredicateKind::ClosureKind(..)\n         | ty::PredicateKind::Subtype(..)\n         | ty::PredicateKind::Coerce(..)\n@@ -338,17 +338,17 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     let predicates = predicates.instantiate_identity(tcx).predicates;\n     elaborate_predicates(tcx, predicates.into_iter()).any(|obligation| {\n         match obligation.predicate.kind().skip_binder() {\n-            ty::PredicateKind::Trait(ref trait_pred) => {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(ref trait_pred)) => {\n                 trait_pred.def_id() == sized_def_id && trait_pred.self_ty().is_param(0)\n             }\n-            ty::PredicateKind::Projection(..)\n+            ty::PredicateKind::Clause(ty::Clause::Projection(..))\n             | ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::Coerce(..)\n-            | ty::PredicateKind::RegionOutlives(..)\n+            | ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n             | ty::PredicateKind::WellFormed(..)\n             | ty::PredicateKind::ObjectSafe(..)\n             | ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::TypeOutlives(..)\n+            | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n             | ty::PredicateKind::Ambiguous"}, {"sha": "c3605a4aab68981dc6b1b0b8b7cd0ec214ced273", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -1476,7 +1476,9 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     let infcx = selcx.infcx();\n     for predicate in env_predicates {\n         let bound_predicate = predicate.kind();\n-        if let ty::PredicateKind::Projection(data) = predicate.kind().skip_binder() {\n+        if let ty::PredicateKind::Clause(ty::Clause::Projection(data)) =\n+            predicate.kind().skip_binder()\n+        {\n             let data = bound_predicate.rebind(data);\n             if data.projection_def_id() != obligation.predicate.item_def_id {\n                 continue;"}, {"sha": "09b58894d3040df0e09649406a5633b1b150235b", "filename": "compiler/rustc_trait_selection/src/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -66,7 +66,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         let mut _orig_values = OriginalQueryValues::default();\n \n         let param_env = match obligation.predicate.kind().skip_binder() {\n-            ty::PredicateKind::Trait(pred) => {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => {\n                 // we ignore the value set to it.\n                 let mut _constness = pred.constness;\n                 obligation"}, {"sha": "68434c2b68d7b8b53c32934c63b4cdfab584ce25", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -15,7 +15,9 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n         // `&T`, accounts for about 60% percentage of the predicates\n         // we have to prove. No need to canonicalize and all that for\n         // such cases.\n-        if let ty::PredicateKind::Trait(trait_ref) = key.value.predicate.kind().skip_binder() {\n+        if let ty::PredicateKind::Clause(ty::Clause::Trait(trait_ref)) =\n+            key.value.predicate.kind().skip_binder()\n+        {\n             if let Some(sized_def_id) = tcx.lang_items().sized_trait() {\n                 if trait_ref.def_id() == sized_def_id {\n                     if trait_ref.self_ty().is_trivially_sized(tcx) {\n@@ -33,7 +35,7 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n         mut canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, ()>> {\n         match canonicalized.value.value.predicate.kind().skip_binder() {\n-            ty::PredicateKind::Trait(pred) => {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => {\n                 canonicalized.value.param_env.remap_constness_with(pred.constness);\n             }\n             _ => canonicalized.value.param_env = canonicalized.value.param_env.without_const(),"}, {"sha": "bfa318787e546869e2c0efe8ebcbb679579feaf0", "filename": "compiler/rustc_trait_selection/src/traits/relationships.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -12,7 +12,7 @@ pub(crate) fn update<'tcx, T>(\n     T: TraitEngine<'tcx>,\n {\n     // (*) binder skipped\n-    if let ty::PredicateKind::Trait(tpred) = obligation.predicate.kind().skip_binder()\n+    if let ty::PredicateKind::Clause(ty::Clause::Trait(tpred)) = obligation.predicate.kind().skip_binder()\n         && let Some(ty) = infcx.shallow_resolve(tpred.self_ty()).ty_vid().map(|t| infcx.root_var(t))\n         && infcx.tcx.lang_items().sized_trait().map_or(false, |st| st != tpred.trait_ref.def_id)\n     {\n@@ -26,7 +26,7 @@ pub(crate) fn update<'tcx, T>(\n                 .kind()\n                 .rebind(\n                     // (*) binder moved here\n-                    ty::PredicateKind::Trait(tpred.with_self_type(infcx.tcx, new_self_ty))\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(tpred.with_self_type(infcx.tcx, new_self_ty)))\n                 ),\n         );\n         // Don't report overflow errors. Otherwise equivalent to may_hold.\n@@ -35,7 +35,9 @@ pub(crate) fn update<'tcx, T>(\n         }\n     }\n \n-    if let ty::PredicateKind::Projection(predicate) = obligation.predicate.kind().skip_binder() {\n+    if let ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) =\n+        obligation.predicate.kind().skip_binder()\n+    {\n         // If the projection predicate (Foo::Bar == X) has X as a non-TyVid,\n         // we need to make it into one.\n         if let Some(vid) = predicate.term.ty().and_then(|ty| ty.ty_vid()) {"}, {"sha": "eedd8db61b03e5f66a445a6ea9989d12d4b25618", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -419,7 +419,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         ensure_sufficient_stack(|| {\n             let bound_predicate = obligation.predicate.kind();\n             match bound_predicate.skip_binder() {\n-                ty::PredicateKind::Trait(t) => {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(t)) => {\n                     let t = bound_predicate.rebind(t);\n                     debug_assert!(!t.has_escaping_bound_vars());\n                     let obligation = obligation.with(self.tcx(), t);\n@@ -546,7 +546,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n                 }\n \n-                ty::PredicateKind::TypeOutlives(pred) => {\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(pred)) => {\n                     // A global type with no late-bound regions can only\n                     // contain the \"'static\" lifetime (any other lifetime\n                     // would either be late-bound or local), so it is guaranteed\n@@ -558,7 +558,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n                 }\n \n-                ty::PredicateKind::RegionOutlives(..) => {\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..)) => {\n                     // We do not consider region relationships when evaluating trait matches.\n                     Ok(EvaluatedToOkModuloRegions)\n                 }\n@@ -571,7 +571,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n                 }\n \n-                ty::PredicateKind::Projection(data) => {\n+                ty::PredicateKind::Clause(ty::Clause::Projection(data)) => {\n                     let data = bound_predicate.rebind(data);\n                     let project_obligation = obligation.with(self.tcx(), data);\n                     match project::poly_project_and_unify_type(self, &project_obligation) {\n@@ -931,7 +931,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn coinductive_predicate(&self, predicate: ty::Predicate<'tcx>) -> bool {\n         let result = match predicate.kind().skip_binder() {\n-            ty::PredicateKind::Trait(ref data) => self.tcx().trait_is_coinductive(data.def_id()),\n+            ty::PredicateKind::Clause(ty::Clause::Trait(ref data)) => {\n+                self.tcx().trait_is_coinductive(data.def_id())\n+            }\n             ty::PredicateKind::WellFormed(_) => true,\n             _ => false,\n         };\n@@ -1377,7 +1379,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .enumerate()\n             .filter_map(|(idx, bound)| {\n                 let bound_predicate = bound.kind();\n-                if let ty::PredicateKind::Trait(pred) = bound_predicate.skip_binder() {\n+                if let ty::PredicateKind::Clause(ty::Clause::Trait(pred)) =\n+                    bound_predicate.skip_binder()\n+                {\n                     let bound = bound_predicate.rebind(pred.trait_ref);\n                     if self.infcx.probe(|_| {\n                         match self.match_normalize_trait_ref("}, {"sha": "7ab4bc3cb85586be825c7286878c050deeeb3571", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -476,7 +476,9 @@ pub(crate) fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Opti\n                     trait_pred\n                 });\n \n-                p = tcx.mk_predicate(new_trait_pred.map_bound(ty::PredicateKind::Trait))\n+                p = tcx.mk_predicate(\n+                    new_trait_pred.map_bound(|p| ty::PredicateKind::Clause(ty::Clause::Trait(p))),\n+                )\n             }\n         }\n         pretty_predicates.push(p.to_string());"}, {"sha": "fe68315ceb690db3964292216de215cea0b33f9d", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -121,14 +121,14 @@ pub fn predicate_obligations<'tcx>(\n \n     // It's ok to skip the binder here because wf code is prepared for it\n     match predicate.kind().skip_binder() {\n-        ty::PredicateKind::Trait(t) => {\n+        ty::PredicateKind::Clause(ty::Clause::Trait(t)) => {\n             wf.compute_trait_pred(&t, Elaborate::None);\n         }\n-        ty::PredicateKind::RegionOutlives(..) => {}\n-        ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n+        ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..)) => {}\n+        ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(ty, _reg))) => {\n             wf.compute(ty.into());\n         }\n-        ty::PredicateKind::Projection(t) => {\n+        ty::PredicateKind::Clause(ty::Clause::Projection(t)) => {\n             wf.compute_projection(t.projection_ty);\n             wf.compute(match t.term.unpack() {\n                 ty::TermKind::Ty(ty) => ty.into(),\n@@ -228,7 +228,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n \n     // It is fine to skip the binder as we don't care about regions here.\n     match pred.kind().skip_binder() {\n-        ty::PredicateKind::Projection(proj) => {\n+        ty::PredicateKind::Clause(ty::Clause::Projection(proj)) => {\n             // The obligation comes not from the current `impl` nor the `trait` being implemented,\n             // but rather from a \"second order\" obligation, where an associated type has a\n             // projection coming from another associated type. See\n@@ -245,7 +245,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n                 cause.span = impl_item_span;\n             }\n         }\n-        ty::PredicateKind::Trait(pred) => {\n+        ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => {\n             // An associated item obligation born out of the `trait` failed to be met. An example\n             // can be seen in `ui/associated-types/point-at-type-on-obligation-failure-2.rs`.\n             debug!(\"extended_cause_with_original_assoc_item_obligation trait proj {:?}\", pred);\n@@ -561,9 +561,9 @@ impl<'tcx> WfPredicates<'tcx> {\n                             cause,\n                             depth,\n                             param_env,\n-                            ty::Binder::dummy(ty::PredicateKind::TypeOutlives(\n+                            ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::TypeOutlives(\n                                 ty::OutlivesPredicate(rty, r),\n-                            )),\n+                            ))),\n                         ));\n                     }\n                 }\n@@ -866,19 +866,22 @@ pub(crate) fn required_region_bounds<'tcx>(\n         .filter_map(|obligation| {\n             debug!(?obligation);\n             match obligation.predicate.kind().skip_binder() {\n-                ty::PredicateKind::Projection(..)\n-                | ty::PredicateKind::Trait(..)\n+                ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+                | ty::PredicateKind::Clause(ty::Clause::Trait(..))\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Coerce(..)\n                 | ty::PredicateKind::WellFormed(..)\n                 | ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::ClosureKind(..)\n-                | ty::PredicateKind::RegionOutlives(..)\n+                | ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n                 | ty::PredicateKind::Ambiguous\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n-                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ref t, ref r)) => {\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                    ref t,\n+                    ref r,\n+                ))) => {\n                     // Search for a bound of the form `erased_self_ty\n                     // : 'a`, but be wary of something like `for<'a>\n                     // erased_self_ty : 'a` (we interpret a"}, {"sha": "c4ab86e9e9bab343d8b96b27cc0901ffbd52a607", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 50, "deletions": 38, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -89,24 +89,32 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                 ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                     chalk_ir::DomainGoal::FromEnv(chalk_ir::FromEnv::Ty(ty.lower_into(interner)))\n                 }\n-                ty::PredicateKind::Trait(predicate) => chalk_ir::DomainGoal::FromEnv(\n-                    chalk_ir::FromEnv::Trait(predicate.trait_ref.lower_into(interner)),\n-                ),\n-                ty::PredicateKind::RegionOutlives(predicate) => chalk_ir::DomainGoal::Holds(\n-                    chalk_ir::WhereClause::LifetimeOutlives(chalk_ir::LifetimeOutlives {\n-                        a: predicate.0.lower_into(interner),\n-                        b: predicate.1.lower_into(interner),\n-                    }),\n-                ),\n-                ty::PredicateKind::TypeOutlives(predicate) => chalk_ir::DomainGoal::Holds(\n-                    chalk_ir::WhereClause::TypeOutlives(chalk_ir::TypeOutlives {\n-                        ty: predicate.0.lower_into(interner),\n-                        lifetime: predicate.1.lower_into(interner),\n-                    }),\n-                ),\n-                ty::PredicateKind::Projection(predicate) => chalk_ir::DomainGoal::Holds(\n-                    chalk_ir::WhereClause::AliasEq(predicate.lower_into(interner)),\n-                ),\n+                ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => {\n+                    chalk_ir::DomainGoal::FromEnv(chalk_ir::FromEnv::Trait(\n+                        predicate.trait_ref.lower_into(interner),\n+                    ))\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => {\n+                    chalk_ir::DomainGoal::Holds(chalk_ir::WhereClause::LifetimeOutlives(\n+                        chalk_ir::LifetimeOutlives {\n+                            a: predicate.0.lower_into(interner),\n+                            b: predicate.1.lower_into(interner),\n+                        },\n+                    ))\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => {\n+                    chalk_ir::DomainGoal::Holds(chalk_ir::WhereClause::TypeOutlives(\n+                        chalk_ir::TypeOutlives {\n+                            ty: predicate.0.lower_into(interner),\n+                            lifetime: predicate.1.lower_into(interner),\n+                        },\n+                    ))\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => {\n+                    chalk_ir::DomainGoal::Holds(chalk_ir::WhereClause::AliasEq(\n+                        predicate.lower_into(interner),\n+                    ))\n+                }\n                 ty::PredicateKind::WellFormed(arg) => match arg.unpack() {\n                     ty::GenericArgKind::Type(ty) => chalk_ir::DomainGoal::WellFormed(\n                         chalk_ir::WellFormed::Ty(ty.lower_into(interner)),\n@@ -149,28 +157,28 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             collect_bound_vars(interner, interner.tcx, self.kind());\n \n         let value = match predicate {\n-            ty::PredicateKind::Trait(predicate) => {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => {\n                 chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n                     chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)),\n                 ))\n             }\n-            ty::PredicateKind::RegionOutlives(predicate) => {\n+            ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => {\n                 chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n                     chalk_ir::WhereClause::LifetimeOutlives(chalk_ir::LifetimeOutlives {\n                         a: predicate.0.lower_into(interner),\n                         b: predicate.1.lower_into(interner),\n                     }),\n                 ))\n             }\n-            ty::PredicateKind::TypeOutlives(predicate) => {\n+            ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => {\n                 chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n                     chalk_ir::WhereClause::TypeOutlives(chalk_ir::TypeOutlives {\n                         ty: predicate.0.lower_into(interner),\n                         lifetime: predicate.1.lower_into(interner),\n                     }),\n                 ))\n             }\n-            ty::PredicateKind::Projection(predicate) => {\n+            ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => {\n                 chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n                     chalk_ir::WhereClause::AliasEq(predicate.lower_into(interner)),\n                 ))\n@@ -605,22 +613,22 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n         let (predicate, binders, _named_regions) =\n             collect_bound_vars(interner, interner.tcx, self.kind());\n         let value = match predicate {\n-            ty::PredicateKind::Trait(predicate) => {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => {\n                 Some(chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)))\n             }\n-            ty::PredicateKind::RegionOutlives(predicate) => {\n+            ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => {\n                 Some(chalk_ir::WhereClause::LifetimeOutlives(chalk_ir::LifetimeOutlives {\n                     a: predicate.0.lower_into(interner),\n                     b: predicate.1.lower_into(interner),\n                 }))\n             }\n-            ty::PredicateKind::TypeOutlives(predicate) => {\n+            ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => {\n                 Some(chalk_ir::WhereClause::TypeOutlives(chalk_ir::TypeOutlives {\n                     ty: predicate.0.lower_into(interner),\n                     lifetime: predicate.1.lower_into(interner),\n                 }))\n             }\n-            ty::PredicateKind::Projection(predicate) => {\n+            ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => {\n                 Some(chalk_ir::WhereClause::AliasEq(predicate.lower_into(interner)))\n             }\n             ty::PredicateKind::WellFormed(_ty) => None,\n@@ -741,20 +749,24 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_solve::rust_ir::QuantifiedInlineBound<Ru\n         let (predicate, binders, _named_regions) =\n             collect_bound_vars(interner, interner.tcx, self.kind());\n         match predicate {\n-            ty::PredicateKind::Trait(predicate) => Some(chalk_ir::Binders::new(\n-                binders,\n-                chalk_solve::rust_ir::InlineBound::TraitBound(\n-                    predicate.trait_ref.lower_into(interner),\n-                ),\n-            )),\n-            ty::PredicateKind::Projection(predicate) => Some(chalk_ir::Binders::new(\n-                binders,\n-                chalk_solve::rust_ir::InlineBound::AliasEqBound(predicate.lower_into(interner)),\n-            )),\n-            ty::PredicateKind::TypeOutlives(_predicate) => None,\n+            ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => {\n+                Some(chalk_ir::Binders::new(\n+                    binders,\n+                    chalk_solve::rust_ir::InlineBound::TraitBound(\n+                        predicate.trait_ref.lower_into(interner),\n+                    ),\n+                ))\n+            }\n+            ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => {\n+                Some(chalk_ir::Binders::new(\n+                    binders,\n+                    chalk_solve::rust_ir::InlineBound::AliasEqBound(predicate.lower_into(interner)),\n+                ))\n+            }\n+            ty::PredicateKind::Clause(ty::Clause::TypeOutlives(_predicate)) => None,\n             ty::PredicateKind::WellFormed(_ty) => None,\n \n-            ty::PredicateKind::RegionOutlives(..)\n+            ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n             | ty::PredicateKind::ObjectSafe(..)\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::Subtype(..)"}, {"sha": "010233d7718c222372d87b976f7d29e0321c6d9d", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -86,10 +86,10 @@ fn compute_implied_outlives_bounds<'tcx>(\n             match obligation.predicate.kind().no_bound_vars() {\n                 None => None,\n                 Some(pred) => match pred {\n-                    ty::PredicateKind::Trait(..)\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(..))\n                     | ty::PredicateKind::Subtype(..)\n                     | ty::PredicateKind::Coerce(..)\n-                    | ty::PredicateKind::Projection(..)\n+                    | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n                     | ty::PredicateKind::ClosureKind(..)\n                     | ty::PredicateKind::ObjectSafe(..)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n@@ -101,13 +101,14 @@ fn compute_implied_outlives_bounds<'tcx>(\n                         None\n                     }\n \n-                    ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n-                        Some(ty::OutlivesPredicate(r_a.into(), r_b))\n-                    }\n+                    ty::PredicateKind::Clause(ty::Clause::RegionOutlives(\n+                        ty::OutlivesPredicate(r_a, r_b),\n+                    )) => Some(ty::OutlivesPredicate(r_a.into(), r_b)),\n \n-                    ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                        Some(ty::OutlivesPredicate(ty_a.into(), r_b))\n-                    }\n+                    ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                        ty_a,\n+                        r_b,\n+                    ))) => Some(ty::OutlivesPredicate(ty_a.into(), r_b)),\n                 },\n             }\n         }));"}, {"sha": "bd22d113b4092dc54ad1345b267b4c128f40b573", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -56,9 +56,10 @@ fn try_normalize_after_erasing_regions<'tcx, T: TypeFoldable<'tcx> + PartialEq +\n \n fn not_outlives_predicate<'tcx>(p: ty::Predicate<'tcx>) -> bool {\n     match p.kind().skip_binder() {\n-        ty::PredicateKind::RegionOutlives(..) | ty::PredicateKind::TypeOutlives(..) => false,\n-        ty::PredicateKind::Trait(..)\n-        | ty::PredicateKind::Projection(..)\n+        ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n+        | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..)) => false,\n+        ty::PredicateKind::Clause(ty::Clause::Trait(..))\n+        | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n         | ty::PredicateKind::WellFormed(..)\n         | ty::PredicateKind::ObjectSafe(..)\n         | ty::PredicateKind::ClosureKind(..)"}, {"sha": "953f4aa8a1b482137f4f24d4cd9447ed84b76c25", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -321,10 +321,10 @@ where\n         let bound_predicate = pred.kind();\n         let tcx = self.cx.tcx;\n         let regions = match bound_predicate.skip_binder() {\n-            ty::PredicateKind::Trait(poly_trait_pred) => {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(poly_trait_pred)) => {\n                 tcx.collect_referenced_late_bound_regions(&bound_predicate.rebind(poly_trait_pred))\n             }\n-            ty::PredicateKind::Projection(poly_proj_pred) => {\n+            ty::PredicateKind::Clause(ty::Clause::Projection(poly_proj_pred)) => {\n                 tcx.collect_referenced_late_bound_regions(&bound_predicate.rebind(poly_proj_pred))\n             }\n             _ => return FxHashSet::default(),\n@@ -451,7 +451,9 @@ where\n             .filter(|p| {\n                 !orig_bounds.contains(p)\n                     || match p.kind().skip_binder() {\n-                        ty::PredicateKind::Trait(pred) => pred.def_id() == sized_trait,\n+                        ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => {\n+                            pred.def_id() == sized_trait\n+                        }\n                         _ => false,\n                     }\n             })"}, {"sha": "b0927305eca9eaf09851029f0f8058a387559bfc", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -302,12 +302,16 @@ pub(crate) fn clean_predicate<'tcx>(\n ) -> Option<WherePredicate> {\n     let bound_predicate = predicate.kind();\n     match bound_predicate.skip_binder() {\n-        ty::PredicateKind::Trait(pred) => {\n+        ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => {\n             clean_poly_trait_predicate(bound_predicate.rebind(pred), cx)\n         }\n-        ty::PredicateKind::RegionOutlives(pred) => clean_region_outlives_predicate(pred),\n-        ty::PredicateKind::TypeOutlives(pred) => clean_type_outlives_predicate(pred, cx),\n-        ty::PredicateKind::Projection(pred) => {\n+        ty::PredicateKind::Clause(ty::Clause::RegionOutlives(pred)) => {\n+            clean_region_outlives_predicate(pred)\n+        }\n+        ty::PredicateKind::Clause(ty::Clause::TypeOutlives(pred)) => {\n+            clean_type_outlives_predicate(pred, cx)\n+        }\n+        ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => {\n             Some(clean_projection_predicate(bound_predicate.rebind(pred), cx))\n         }\n         ty::PredicateKind::ConstEvaluatable(..) => None,\n@@ -689,17 +693,20 @@ fn clean_ty_generics<'tcx>(\n             let param_idx = (|| {\n                 let bound_p = p.kind();\n                 match bound_p.skip_binder() {\n-                    ty::PredicateKind::Trait(pred) => {\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => {\n                         if let ty::Param(param) = pred.self_ty().kind() {\n                             return Some(param.index);\n                         }\n                     }\n-                    ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n+                    ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                        ty,\n+                        _reg,\n+                    ))) => {\n                         if let ty::Param(param) = ty.kind() {\n                             return Some(param.index);\n                         }\n                     }\n-                    ty::PredicateKind::Projection(p) => {\n+                    ty::PredicateKind::Clause(ty::Clause::Projection(p)) => {\n                         if let ty::Param(param) = p.projection_ty.self_ty().kind() {\n                             projection = Some(bound_p.rebind(p));\n                             return Some(param.index);\n@@ -1772,8 +1779,13 @@ fn clean_middle_opaque_bounds<'tcx>(\n         .filter_map(|bound| {\n             let bound_predicate = bound.kind();\n             let trait_ref = match bound_predicate.skip_binder() {\n-                ty::PredicateKind::Trait(tr) => bound_predicate.rebind(tr.trait_ref),\n-                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_ty, reg)) => {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(tr)) => {\n+                    bound_predicate.rebind(tr.trait_ref)\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                    _ty,\n+                    reg,\n+                ))) => {\n                     if let Some(r) = clean_middle_region(reg) {\n                         regions.push(GenericBound::Outlives(r));\n                     }\n@@ -1792,7 +1804,9 @@ fn clean_middle_opaque_bounds<'tcx>(\n             let bindings: ThinVec<_> = bounds\n                 .iter()\n                 .filter_map(|bound| {\n-                    if let ty::PredicateKind::Projection(proj) = bound.kind().skip_binder() {\n+                    if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) =\n+                        bound.kind().skip_binder()\n+                    {\n                         if proj.projection_ty.trait_ref(cx.tcx) == trait_ref.skip_binder() {\n                             Some(TypeBinding {\n                                 assoc: projection_to_path_segment(proj.projection_ty, cx),"}, {"sha": "e96a9bab72620970b87e9ab4f3d8acc0839ec664", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -132,7 +132,7 @@ fn trait_is_same_or_supertrait(cx: &DocContext<'_>, child: DefId, trait_: DefId)\n         .predicates\n         .iter()\n         .filter_map(|(pred, _)| {\n-            if let ty::PredicateKind::Trait(pred) = pred.kind().skip_binder() {\n+            if let ty::PredicateKind::Clause(ty::Clause::Trait(pred)) = pred.kind().skip_binder() {\n                 if pred.trait_ref.self_ty() == self_ty { Some(pred.def_id()) } else { None }\n             } else {\n                 None"}, {"sha": "47ea98956be24cc98b6c5e41d59a6b6a4badc646", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -25,7 +25,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::mir::{Rvalue, StatementKind};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::{\n-    self, Binder, BoundVariableKind, EarlyBinder, FnSig, GenericArgKind, List, ParamTy, PredicateKind,\n+    self, Binder, BoundVariableKind, Clause, EarlyBinder, FnSig, GenericArgKind, List, ParamTy, PredicateKind,\n     ProjectionPredicate, Ty, TyCtxt, TypeVisitable, TypeckResults,\n };\n use rustc_semver::RustcVersion;\n@@ -1097,7 +1097,7 @@ fn needless_borrow_impl_arg_position<'tcx>(\n     let projection_predicates = predicates\n         .iter()\n         .filter_map(|predicate| {\n-            if let PredicateKind::Projection(projection_predicate) = predicate.kind().skip_binder() {\n+            if let PredicateKind::Clause(Clause::Projection(projection_predicate)) = predicate.kind().skip_binder() {\n                 Some(projection_predicate)\n             } else {\n                 None\n@@ -1111,7 +1111,7 @@ fn needless_borrow_impl_arg_position<'tcx>(\n     if predicates\n         .iter()\n         .filter_map(|predicate| {\n-            if let PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder()\n+            if let PredicateKind::Clause(Clause::Trait(trait_predicate)) = predicate.kind().skip_binder()\n                 && trait_predicate.trait_ref.self_ty() == param_ty.to_ty(cx.tcx)\n             {\n                 Some(trait_predicate.trait_ref.def_id)\n@@ -1173,7 +1173,7 @@ fn needless_borrow_impl_arg_position<'tcx>(\n         }\n \n         predicates.iter().all(|predicate| {\n-            if let PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder()\n+            if let PredicateKind::Clause(Clause::Trait(trait_predicate)) = predicate.kind().skip_binder()\n                 && cx.tcx.is_diagnostic_item(sym::IntoIterator, trait_predicate.trait_ref.def_id)\n                 && let ty::Param(param_ty) = trait_predicate.self_ty().kind()\n                 && let GenericArgKind::Type(ty) = substs_with_referent_ty[param_ty.index as usize].unpack()"}, {"sha": "d870e0ceef471ae2505aa6aafcdf1f483a2c4c6c", "filename": "src/tools/clippy/clippy_lints/src/derive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -14,7 +14,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::traits::Reveal;\n use rustc_middle::ty::{\n-    self, Binder, BoundConstness, GenericParamDefKind, ImplPolarity, ParamEnv, PredicateKind, TraitPredicate, TraitRef,\n+    self, Binder, BoundConstness, Clause, GenericParamDefKind, ImplPolarity, ParamEnv, PredicateKind, TraitPredicate, TraitRef,\n     Ty, TyCtxt,\n };\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -499,7 +499,7 @@ fn param_env_for_derived_eq(tcx: TyCtxt<'_>, did: DefId, eq_trait_id: DefId) ->\n \n     let ty_predicates = tcx.predicates_of(did).predicates;\n     for (p, _) in ty_predicates {\n-        if let PredicateKind::Trait(p) = p.kind().skip_binder()\n+        if let PredicateKind::Clause(Clause::Trait(p)) = p.kind().skip_binder()\n             && p.trait_ref.def_id == eq_trait_id\n             && let ty::Param(self_ty) = p.trait_ref.self_ty().kind()\n             && p.constness == BoundConstness::NotConst\n@@ -512,14 +512,14 @@ fn param_env_for_derived_eq(tcx: TyCtxt<'_>, did: DefId, eq_trait_id: DefId) ->\n     ParamEnv::new(\n         tcx.mk_predicates(ty_predicates.iter().map(|&(p, _)| p).chain(\n             params.iter().filter(|&&(_, needs_eq)| needs_eq).map(|&(param, _)| {\n-                tcx.mk_predicate(Binder::dummy(PredicateKind::Trait(TraitPredicate {\n+                tcx.mk_predicate(Binder::dummy(PredicateKind::Clause(Clause::Trait(TraitPredicate {\n                     trait_ref: TraitRef::new(\n                         eq_trait_id,\n                         tcx.mk_substs(std::iter::once(tcx.mk_param_from_def(param))),\n                     ),\n                     constness: BoundConstness::NotConst,\n                     polarity: ImplPolarity::Positive,\n-                })))\n+                }))))\n             }),\n         )),\n         Reveal::UserFacing,"}, {"sha": "a9425a40f885ea192bf50e263c900b44d09d77b4", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -4,7 +4,7 @@ use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, FnDecl, HirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{EarlyBinder, Opaque, PredicateKind::Trait};\n+use rustc_middle::ty::{Clause, EarlyBinder, Opaque, PredicateKind};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n use rustc_trait_selection::traits::error_reporting::suggestions::TypeErrCtxtExt;\n@@ -91,7 +91,7 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n                                 infcx\n                                     .err_ctxt()\n                                     .maybe_note_obligation_cause_for_async_await(db, &obligation);\n-                                if let Trait(trait_pred) = obligation.predicate.kind().skip_binder() {\n+                                if let PredicateKind::Clause(Clause::Trait(trait_pred)) = obligation.predicate.kind().skip_binder() {\n                                     db.note(&format!(\n                                         \"`{}` doesn't implement `{}`\",\n                                         trait_pred.self_ty(),"}, {"sha": "7ff13b95626ba89b22d603caa7fbda300a0aaef1", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::mir::Mutability;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_middle::ty::EarlyBinder;\n-use rustc_middle::ty::{self, ParamTy, PredicateKind, ProjectionPredicate, TraitPredicate, Ty};\n+use rustc_middle::ty::{self, Clause, ParamTy, PredicateKind, ProjectionPredicate, TraitPredicate, Ty};\n use rustc_semver::RustcVersion;\n use rustc_span::{sym, Symbol};\n use rustc_trait_selection::traits::{\n@@ -341,12 +341,12 @@ fn get_input_traits_and_projections<'tcx>(\n     let mut projection_predicates = Vec::new();\n     for predicate in cx.tcx.param_env(callee_def_id).caller_bounds() {\n         match predicate.kind().skip_binder() {\n-            PredicateKind::Trait(trait_predicate) => {\n+            PredicateKind::Clause(Clause::Trait(trait_predicate)) => {\n                 if trait_predicate.trait_ref.self_ty() == input {\n                     trait_predicates.push(trait_predicate);\n                 }\n             }\n-            PredicateKind::Projection(projection_predicate) => {\n+            PredicateKind::Clause(Clause::Projection(projection_predicate)) => {\n                 if projection_predicate.projection_ty.self_ty() == input {\n                     projection_predicates.push(projection_predicate);\n                 }\n@@ -403,7 +403,7 @@ fn can_change_type<'a>(cx: &LateContext<'a>, mut expr: &'a Expr<'a>, mut ty: Ty<\n \n                         let mut trait_predicates = cx.tcx.param_env(callee_def_id)\n                             .caller_bounds().iter().filter(|predicate| {\n-                            if let PredicateKind::Trait(trait_predicate) =  predicate.kind().skip_binder()\n+                            if let PredicateKind::Clause(Clause::Trait(trait_predicate)) =  predicate.kind().skip_binder()\n                                 && trait_predicate.trait_ref.self_ty() == *param_ty {\n                                     true\n                                 } else {"}, {"sha": "75e12715458f4faf44f9605e6b22ce4470e36fb0", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -124,7 +124,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n             .filter_map(|obligation| {\n                 // Note that we do not want to deal with qualified predicates here.\n                 match obligation.predicate.kind().no_bound_vars() {\n-                    Some(ty::PredicateKind::Trait(pred)) if pred.def_id() != sized_trait => Some(pred),\n+                    Some(ty::PredicateKind::Clause(ty::Clause::Trait(pred))) if pred.def_id() != sized_trait => Some(pred),\n                     _ => None,\n                 }\n             })"}, {"sha": "d28e97b7943525b56224cc8a2a70b2126ebb3d63", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -19,7 +19,7 @@ use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::{Obligation, ObligationCause};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty::{self, Binder, ExistentialPredicate, List, PredicateKind, Ty};\n+use rustc_middle::ty::{self, Binder, Clause, ExistentialPredicate, List, PredicateKind, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::sym;\n@@ -699,7 +699,7 @@ fn matches_preds<'tcx>(\n             ObligationCause::dummy(),\n             cx.param_env,\n             cx.tcx.mk_predicate(Binder::dummy(\n-                PredicateKind::Projection(p.with_self_ty(cx.tcx, ty)),\n+                PredicateKind::Clause(Clause::Projection(p.with_self_ty(cx.tcx, ty))),\n             )),\n         )),\n         ExistentialPredicate::AutoTrait(p) => infcx"}, {"sha": "a138a4baa9b319eb5334709f8ff6089316cb6b9d", "filename": "src/tools/clippy/clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -4,7 +4,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::{Closure, Expr, ExprKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n-use rustc_middle::ty::{GenericPredicates, PredicateKind, ProjectionPredicate, TraitPredicate};\n+use rustc_middle::ty::{Clause, GenericPredicates, PredicateKind, ProjectionPredicate, TraitPredicate};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, BytePos, Span};\n \n@@ -45,7 +45,7 @@ fn get_trait_predicates_for_trait_id<'tcx>(\n     let mut preds = Vec::new();\n     for (pred, _) in generics.predicates {\n         if_chain! {\n-            if let PredicateKind::Trait(poly_trait_pred) = pred.kind().skip_binder();\n+            if let PredicateKind::Clause(Clause::Trait(poly_trait_pred)) = pred.kind().skip_binder();\n             let trait_pred = cx.tcx.erase_late_bound_regions(pred.kind().rebind(poly_trait_pred));\n             if let Some(trait_def_id) = trait_id;\n             if trait_def_id == trait_pred.trait_ref.def_id;\n@@ -63,7 +63,7 @@ fn get_projection_pred<'tcx>(\n     trait_pred: TraitPredicate<'tcx>,\n ) -> Option<ProjectionPredicate<'tcx>> {\n     generics.predicates.iter().find_map(|(proj_pred, _)| {\n-        if let ty::PredicateKind::Projection(pred) = proj_pred.kind().skip_binder() {\n+        if let ty::PredicateKind::Clause(Clause::Projection(pred)) = proj_pred.kind().skip_binder() {\n             let projection_pred = cx.tcx.erase_late_bound_regions(proj_pred.kind().rebind(pred));\n             if projection_pred.projection_ty.substs == trait_pred.trait_ref.substs {\n                 return Some(projection_pred);"}, {"sha": "f74f7dadfa90809aedb880e349a98515a98748c9", "filename": "src/tools/clippy/clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -73,7 +73,7 @@ fn fn_eagerness(cx: &LateContext<'_>, fn_id: DefId, name: Symbol, have_one_arg:\n             .flat_map(|v| v.fields.iter())\n             .any(|x| matches!(cx.tcx.type_of(x.did).peel_refs().kind(), ty::Param(_)))\n             && all_predicates_of(cx.tcx, fn_id).all(|(pred, _)| match pred.kind().skip_binder() {\n-                PredicateKind::Trait(pred) => cx.tcx.trait_def(pred.trait_ref.def_id).is_marker,\n+                PredicateKind::Clause(ty::Clause::Trait(pred)) => cx.tcx.trait_def(pred.trait_ref.def_id).is_marker,\n                 _ => true,\n             })\n             && subs.types().all(|x| matches!(x.peel_refs().kind(), ty::Param(_)))"}, {"sha": "b8c2dd5ab9ea16ee31ac7111304444bd16484774", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -25,13 +25,13 @@ pub fn is_min_const_fn<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, msrv: Option<\n         let predicates = tcx.predicates_of(current);\n         for (predicate, _) in predicates.predicates {\n             match predicate.kind().skip_binder() {\n-                ty::PredicateKind::RegionOutlives(_)\n-                | ty::PredicateKind::TypeOutlives(_)\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(_))\n+                | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(_))\n                 | ty::PredicateKind::WellFormed(_)\n-                | ty::PredicateKind::Projection(_)\n+                | ty::PredicateKind::Clause(ty::Clause::Projection(_))\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n-                | ty::PredicateKind::Trait(..)\n+                | ty::PredicateKind::Clause(ty::Clause::Trait(..))\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => continue,\n                 ty::PredicateKind::ObjectSafe(_) => panic!(\"object safe predicate on function: {predicate:#?}\"),\n                 ty::PredicateKind::ClosureKind(..) => panic!(\"closure kind predicate on function: {predicate:#?}\"),"}, {"sha": "f4459e3e6633abd3790038816d9ed5521596e4fa", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e2837bb643a1213caeea4025f2f5681bd5f3e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=974e2837bb643a1213caeea4025f2f5681bd5f3e", "patch": "@@ -81,7 +81,7 @@ pub fn contains_ty_adt_constructor_opaque<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'\n                     match predicate.kind().skip_binder() {\n                         // For `impl Trait<U>`, it will register a predicate of `T: Trait<U>`, so we go through\n                         // and check substituions to find `U`.\n-                        ty::PredicateKind::Trait(trait_predicate) => {\n+                        ty::PredicateKind::Clause(ty::Clause::Trait(trait_predicate)) => {\n                             if trait_predicate\n                                 .trait_ref\n                                 .substs\n@@ -94,7 +94,7 @@ pub fn contains_ty_adt_constructor_opaque<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'\n                         },\n                         // For `impl Trait<Assoc=U>`, it will register a predicate of `<T as Trait>::Assoc = U`,\n                         // so we check the term for `U`.\n-                        ty::PredicateKind::Projection(projection_predicate) => {\n+                        ty::PredicateKind::Clause(ty::Clause::Projection(projection_predicate)) => {\n                             if let ty::TermKind::Ty(ty) = projection_predicate.term.unpack() {\n                                 if contains_ty_adt_constructor_opaque(cx, ty, needle) {\n                                     return true;\n@@ -239,7 +239,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::Tuple(substs) => substs.iter().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Opaque(def_id, _) => {\n             for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n-                if let ty::PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder() {\n+                if let ty::PredicateKind::Clause(ty::Clause::Trait(trait_predicate)) = predicate.kind().skip_binder() {\n                     if cx.tcx.has_attr(trait_predicate.trait_ref.def_id, sym::must_use) {\n                         return true;\n                     }\n@@ -658,7 +658,7 @@ fn sig_from_bounds<'tcx>(\n \n     for pred in predicates {\n         match pred.kind().skip_binder() {\n-            PredicateKind::Trait(p)\n+            PredicateKind::Clause(ty::Clause::Trait(p))\n                 if (lang_items.fn_trait() == Some(p.def_id())\n                     || lang_items.fn_mut_trait() == Some(p.def_id())\n                     || lang_items.fn_once_trait() == Some(p.def_id()))\n@@ -671,7 +671,7 @@ fn sig_from_bounds<'tcx>(\n                 }\n                 inputs = Some(i);\n             },\n-            PredicateKind::Projection(p)\n+            PredicateKind::Clause(ty::Clause::Projection(p))\n                 if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output()\n                     && p.projection_ty.self_ty() == ty =>\n             {\n@@ -699,7 +699,7 @@ fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> O\n         .subst_iter_copied(cx.tcx, ty.substs)\n     {\n         match pred.kind().skip_binder() {\n-            PredicateKind::Trait(p)\n+            PredicateKind::Clause(ty::Clause::Trait(p))\n                 if (lang_items.fn_trait() == Some(p.def_id())\n                     || lang_items.fn_mut_trait() == Some(p.def_id())\n                     || lang_items.fn_once_trait() == Some(p.def_id())) =>\n@@ -712,7 +712,7 @@ fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> O\n                 }\n                 inputs = Some(i);\n             },\n-            PredicateKind::Projection(p) if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output() => {\n+            PredicateKind::Clause(ty::Clause::Projection(p)) if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output() => {\n                 if output.is_some() {\n                     // Multiple different fn trait impls. Is this even allowed?\n                     return None;\n@@ -887,7 +887,7 @@ pub fn ty_is_fn_once_param<'tcx>(tcx: TyCtxt<'_>, ty: Ty<'tcx>, predicates: &'tc\n     predicates\n         .iter()\n         .try_fold(false, |found, p| {\n-            if let PredicateKind::Trait(p) = p.kind().skip_binder()\n+            if let PredicateKind::Clause(ty::Clause::Trait(p)) = p.kind().skip_binder()\n             && let ty::Param(self_ty) = p.trait_ref.self_ty().kind()\n             && ty.index == self_ty.index\n         {"}]}