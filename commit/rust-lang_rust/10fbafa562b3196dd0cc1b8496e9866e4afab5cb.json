{"sha": "10fbafa562b3196dd0cc1b8496e9866e4afab5cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwZmJhZmE1NjJiMzE5NmRkMGNjMWI4NDk2ZTk4NjZlNGFmYWI1Y2I=", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-02-06T11:02:42Z"}, "committer": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-02-06T11:10:47Z"}, "message": "implement the download_and_extract() step for git sources", "tree": {"sha": "4a2d31c1c391470caa4d3b94da8633cc68789ffd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a2d31c1c391470caa4d3b94da8633cc68789ffd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10fbafa562b3196dd0cc1b8496e9866e4afab5cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10fbafa562b3196dd0cc1b8496e9866e4afab5cb", "html_url": "https://github.com/rust-lang/rust/commit/10fbafa562b3196dd0cc1b8496e9866e4afab5cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10fbafa562b3196dd0cc1b8496e9866e4afab5cb/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64982cc435fc4546cbdc9ce3935cdd63ac636e4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/64982cc435fc4546cbdc9ce3935cdd63ac636e4e", "html_url": "https://github.com/rust-lang/rust/commit/64982cc435fc4546cbdc9ce3935cdd63ac636e4e"}], "stats": {"total": 128, "additions": 88, "deletions": 40}, "files": [{"sha": "63f78db13f8d9748f9c0cad17758afcf1c20d58b", "filename": "clippy_dev/src/lintcheck.rs", "status": "modified", "additions": 88, "deletions": 40, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/10fbafa562b3196dd0cc1b8496e9866e4afab5cb/clippy_dev%2Fsrc%2Flintcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10fbafa562b3196dd0cc1b8496e9866e4afab5cb/clippy_dev%2Fsrc%2Flintcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flintcheck.rs?ref=10fbafa562b3196dd0cc1b8496e9866e4afab5cb", "patch": "@@ -16,6 +16,7 @@ use std::{fmt, fs::write, path::PathBuf};\n use clap::ArgMatches;\n use serde::{Deserialize, Serialize};\n use serde_json::Value;\n+//use git2::Repository;\n \n // use this to store the crates when interacting with the crates.toml file\n #[derive(Debug, Serialize, Deserialize)]\n@@ -35,12 +36,13 @@ struct TomlCrate {\n \n // represents an archive we download from crates.io\n #[derive(Debug, Serialize, Deserialize, Eq, Hash, PartialEq)]\n-struct CrateSource {\n-    name: String,\n-    version: String,\n+enum CrateSource {\n+    CratesIo { name: String, version: String },\n+    Git { name: String, url: String, commit: String },\n }\n \n // represents the extracted sourcecode of a crate\n+// we actually don't need to special-case git repos here because it does not matter for clippy, yay! (clippy only needs a simple path)\n #[derive(Debug)]\n struct Crate {\n     version: String,\n@@ -72,40 +74,70 @@ impl std::fmt::Display for ClippyWarning {\n \n impl CrateSource {\n     fn download_and_extract(&self) -> Crate {\n-        let extract_dir = PathBuf::from(\"target/lintcheck/crates\");\n-        let krate_download_dir = PathBuf::from(\"target/lintcheck/downloads\");\n-\n-        // url to download the crate from crates.io\n-        let url = format!(\n-            \"https://crates.io/api/v1/crates/{}/{}/download\",\n-            self.name, self.version\n-        );\n-        println!(\"Downloading and extracting {} {} from {}\", self.name, self.version, url);\n-        let _ = std::fs::create_dir(\"target/lintcheck/\");\n-        let _ = std::fs::create_dir(&krate_download_dir);\n-        let _ = std::fs::create_dir(&extract_dir);\n-\n-        let krate_file_path = krate_download_dir.join(format!(\"{}-{}.crate.tar.gz\", &self.name, &self.version));\n-        // don't download/extract if we already have done so\n-        if !krate_file_path.is_file() {\n-            // create a file path to download and write the crate data into\n-            let mut krate_dest = std::fs::File::create(&krate_file_path).unwrap();\n-            let mut krate_req = ureq::get(&url).call().unwrap().into_reader();\n-            // copy the crate into the file\n-            std::io::copy(&mut krate_req, &mut krate_dest).unwrap();\n-\n-            // unzip the tarball\n-            let ungz_tar = flate2::read::GzDecoder::new(std::fs::File::open(&krate_file_path).unwrap());\n-            // extract the tar archive\n-            let mut archive = tar::Archive::new(ungz_tar);\n-            archive.unpack(&extract_dir).expect(\"Failed to extract!\");\n-        }\n-        // crate is extracted, return a new Krate object which contains the path to the extracted\n-        // sources that clippy can check\n-        Crate {\n-            version: self.version.clone(),\n-            name: self.name.clone(),\n-            path: extract_dir.join(format!(\"{}-{}/\", self.name, self.version)),\n+        match self {\n+            CrateSource::CratesIo { name, version } => {\n+                let extract_dir = PathBuf::from(\"target/lintcheck/crates\");\n+                let krate_download_dir = PathBuf::from(\"target/lintcheck/downloads\");\n+\n+                // url to download the crate from crates.io\n+                let url = format!(\"https://crates.io/api/v1/crates/{}/{}/download\", name, version);\n+                println!(\"Downloading and extracting {} {} from {}\", name, version, url);\n+                let _ = std::fs::create_dir(\"target/lintcheck/\");\n+                let _ = std::fs::create_dir(&krate_download_dir);\n+                let _ = std::fs::create_dir(&extract_dir);\n+\n+                let krate_file_path = krate_download_dir.join(format!(\"{}-{}.crate.tar.gz\", name, version));\n+                // don't download/extract if we already have done so\n+                if !krate_file_path.is_file() {\n+                    // create a file path to download and write the crate data into\n+                    let mut krate_dest = std::fs::File::create(&krate_file_path).unwrap();\n+                    let mut krate_req = ureq::get(&url).call().unwrap().into_reader();\n+                    // copy the crate into the file\n+                    std::io::copy(&mut krate_req, &mut krate_dest).unwrap();\n+\n+                    // unzip the tarball\n+                    let ungz_tar = flate2::read::GzDecoder::new(std::fs::File::open(&krate_file_path).unwrap());\n+                    // extract the tar archive\n+                    let mut archive = tar::Archive::new(ungz_tar);\n+                    archive.unpack(&extract_dir).expect(\"Failed to extract!\");\n+                }\n+                // crate is extracted, return a new Krate object which contains the path to the extracted\n+                // sources that clippy can check\n+                Crate {\n+                    version: version.clone(),\n+                    name: name.clone(),\n+                    path: extract_dir.join(format!(\"{}-{}/\", name, version)),\n+                }\n+            },\n+            CrateSource::Git { name, url, commit } => {\n+                let repo_path = {\n+                    let mut repo_path = PathBuf::from(\"target/lintcheck/downloads\");\n+                    // add a -git suffix in case we have the same crate from crates.io and a git repo\n+                    repo_path.push(format!(\"{}-git\", name));\n+                    repo_path\n+                };\n+                // clone the repo if we have not done so\n+                if !repo_path.is_dir() {\n+                    Command::new(\"git\")\n+                        .arg(\"clone\")\n+                        .arg(url)\n+                        .arg(&repo_path)\n+                        .output()\n+                        .expect(\"Failed to clone git repo!\");\n+                }\n+                // check out the commit/branch/whatever\n+                Command::new(\"git\")\n+                    .arg(\"checkout\")\n+                    .arg(commit)\n+                    .output()\n+                    .expect(\"Failed to check out commit\");\n+\n+                Crate {\n+                    version: commit.clone(),\n+                    name: name.clone(),\n+                    path: repo_path,\n+                }\n+            },\n         }\n     }\n }\n@@ -175,14 +207,30 @@ fn read_crates() -> Vec<CrateSource> {\n     // multiple Cratesources)\n     let mut crate_sources = Vec::new();\n     tomlcrates.into_iter().for_each(|tk| {\n+        // if we have multiple versions, save each one\n         if let Some(ref versions) = tk.versions {\n             versions.iter().for_each(|ver| {\n-                crate_sources.push(CrateSource {\n+                crate_sources.push(CrateSource::CratesIo {\n                     name: tk.name.clone(),\n                     version: ver.to_string(),\n                 });\n             })\n         }\n+        // otherwise, we should have a git source\n+        if tk.git_url.is_some() && tk.git_hash.is_some() {\n+            crate_sources.push(CrateSource::Git {\n+                name: tk.name.clone(),\n+                url: tk.git_url.clone().unwrap(),\n+                commit: tk.git_hash.clone().unwrap(),\n+            });\n+        }\n+        // if we have a version as well as a git data OR only one git data, something is funky\n+        if tk.versions.is_some() && (tk.git_url.is_some() || tk.git_hash.is_some())\n+            || tk.git_hash.is_some() != tk.git_url.is_some()\n+        {\n+            dbg!(tk);\n+            unreachable!(\"Failed to translate TomlCrate into CrateSource!\");\n+        }\n     });\n     crate_sources\n }\n@@ -239,13 +287,13 @@ pub fn run(clap_config: &ArgMatches) {\n \n     let clippy_warnings: Vec<ClippyWarning> = if let Some(only_one_crate) = clap_config.value_of(\"only\") {\n         // if we don't have the specified crated in the .toml, throw an error\n-        if !crates.iter().any(|krate| krate.name == only_one_crate) {\n+        /*   if !crates.iter().any(|krate| krate.name == only_one_crate) {\n             eprintln!(\n                 \"ERROR: could not find crate '{}' in clippy_dev/lintcheck_crates.toml\",\n                 only_one_crate\n             );\n             std::process::exit(1);\n-        }\n+        } */ //@FIXME\n \n         // only check a single crate that was passed via cmdline\n         crates"}]}