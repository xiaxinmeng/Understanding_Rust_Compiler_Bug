{"sha": "1942a7a3fb3eb860f225f491c0aa2eb93a7c6e90", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5NDJhN2EzZmIzZWI4NjBmMjI1ZjQ5MWMwYWEyZWI5M2E3YzZlOTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-17T12:12:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-17T12:12:03Z"}, "message": "auto merge of #8053 : gavinb/rust/uuid_std, r=alexcrichton\n\nAddresses part of #7104\r\n\r\nThis module adds the ability to generate UUIDs (on all Rust-supported platforms).\r\n\r\nI reviewed the existing UUID support in libraries for a range of languages; Go, D, C#, Java and Boost++. The features were all very similar, and this patch essentially covers the union.  The implmentation is quite straightforward, and uses the underlying rng support which is assumed to be sufficiently strong for this purpose.\r\n\r\nThis patch is not complete, however I have put this up for review to gather feedback before finalising. It has tests for most features and documentation for most functions.\r\n\r\nOutstanding issues:\r\n\r\n* Only generates V4 (Random) UUIDs. Do we want to support the SHA-1 hash based flavour as well?\r\n* Is it worth having the field-based struct public as well as the byte array?\r\n* Formatting the string with '-' between groups not done yet.\r\n* Parsing full string not done as there appears to be no regexp support yet. I can write a simple manual parser for now?\r\n* D has a generator as well. This would be easy to add. However, given the simple interface for creating a new one, and the presence of the macro, is this useful?\r\n* Is it worth having a separate UUID trait and specific implementation? Or should it just have a struct+impl with the same name? Currently it feels weird to have the trait (which can't be named UUID so as to conflict) a separate thing.\r\n* Should the macro be visible at the top level scope?\r\n\r\nAs this is a first attempt, some code may not be idiomatic. Please comment below...\r\n\r\nThanks for all feedback!", "tree": {"sha": "339bde09e745b87c1f1284e3478ef50d04655d27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/339bde09e745b87c1f1284e3478ef50d04655d27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1942a7a3fb3eb860f225f491c0aa2eb93a7c6e90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1942a7a3fb3eb860f225f491c0aa2eb93a7c6e90", "html_url": "https://github.com/rust-lang/rust/commit/1942a7a3fb3eb860f225f491c0aa2eb93a7c6e90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1942a7a3fb3eb860f225f491c0aa2eb93a7c6e90/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ac17731eba236648e86b4e760d6c93addf19fa0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ac17731eba236648e86b4e760d6c93addf19fa0", "html_url": "https://github.com/rust-lang/rust/commit/8ac17731eba236648e86b4e760d6c93addf19fa0"}, {"sha": "328261aa54225eaf7e5a6792b154dd3e7a47404e", "url": "https://api.github.com/repos/rust-lang/rust/commits/328261aa54225eaf7e5a6792b154dd3e7a47404e", "html_url": "https://github.com/rust-lang/rust/commit/328261aa54225eaf7e5a6792b154dd3e7a47404e"}], "stats": {"total": 795, "additions": 795, "deletions": 0}, "files": [{"sha": "d88300581cd6c30bced9b27749eef05acbf8c33e", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1942a7a3fb3eb860f225f491c0aa2eb93a7c6e90/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1942a7a3fb3eb860f225f491c0aa2eb93a7c6e90/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=1942a7a3fb3eb860f225f491c0aa2eb93a7c6e90", "patch": "@@ -103,6 +103,8 @@ pub mod semver;\n pub mod fileinput;\n pub mod flate;\n pub mod hex;\n+pub mod uuid;\n+\n \n #[cfg(unicode)]\n mod unicode;"}, {"sha": "1a99de127a8d143ce3b815baf1621408b3ab9c0f", "filename": "src/libextra/uuid.rs", "status": "added", "additions": 793, "deletions": 0, "changes": 793, "blob_url": "https://github.com/rust-lang/rust/blob/1942a7a3fb3eb860f225f491c0aa2eb93a7c6e90/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1942a7a3fb3eb860f225f491c0aa2eb93a7c6e90/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=1942a7a3fb3eb860f225f491c0aa2eb93a7c6e90", "patch": "@@ -0,0 +1,793 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+Generate and parse UUIDs\n+\n+Provides support for Universally Unique Identifiers (UUIDs). A UUID is a\n+unique 128-bit number, stored as 16 octets.  UUIDs are used to  assign unique\n+identifiers to entities without requiring a central allocating authority.\n+\n+They are particularly useful in distributed systems, though can be used in\n+disparate areas, such as databases and network protocols.  Typically a UUID is\n+displayed in a readable string form as a sequence of hexadecimals digits,\n+separated into groups by hyphens.\n+\n+The uniqueness property is not strictly guaranteed, however for all practical\n+purposes, it can be assumed that an unintentional collision would be extremely\n+unlikely.\n+\n+# Examples\n+\n+To create a new random (V4) UUID and print it out in hexadecimal form:\n+\n+~~~ {.rust}\n+extern mod extra;\n+use extra::uuid::Uuid;\n+\n+fn main() {\n+    let uuid1 = Uuid::new_v4();\n+    println(uuid1.to_str());\n+}\n+~~~\n+\n+# Strings\n+\n+Examples of string representations:\n+\n+* simple: `936DA01F9ABD4d9d80C702AF85C822A8`\n+* hyphenated: `550e8400-e29b-41d4-a716-446655440000`\n+* urn: `urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4`\n+\n+# References\n+\n+* [Wikipedia: Universally Unique Identifier](\n+    http://en.wikipedia.org/wiki/Universally_unique_identifier)\n+* [RFC4122: A Universally Unique IDentifier (UUID) URN Namespace](\n+    http://tools.ietf.org/html/rfc4122)\n+\n+*/\n+\n+use std::str;\n+use std::vec;\n+use std::num::{FromStrRadix, Zero};\n+use std::char::Char;\n+use std::container::Container;\n+use std::to_str::ToStr;\n+use std::rand;\n+use std::rand::RngUtil;\n+use std::cmp::Eq;\n+use std::cast::{transmute,transmute_copy};\n+\n+/// A 128-bit (16 byte) buffer containing the ID\n+pub type UuidBytes = [u8, ..16];\n+\n+/// The version of the UUID, denoting the generating algorithm\n+#[deriving(Eq)]\n+pub enum UuidVersion {\n+    /// Version 1: MAC address\n+    Version1Mac    = 1,\n+    /// Version 2: DCE Security\n+    Version2Dce    = 2,\n+    /// Version 3: MD5 hash\n+    Version3Md5    = 3,\n+    /// Version 4: Random\n+    Version4Random = 4,\n+    /// Version 5: SHA-1 hash\n+    Version5Sha1   = 5,\n+}\n+\n+/// The reserved variants of UUIDs\n+#[deriving(Eq)]\n+pub enum UuidVariant {\n+    /// Reserved by the NCS for backward compatability\n+    VariantNCS,\n+    /// As described in the RFC4122 Specification (default)\n+    VariantRFC4122,\n+    /// Resreved by Microsoft for backward compatability\n+    VariantMicrosoft,\n+    /// Reserved for future expansion\n+    VariantFuture,\n+}\n+\n+/// A Universally Unique Identifier (UUID)\n+pub struct Uuid {\n+    /// The 128-bit number stored in 16 bytes\n+    bytes: UuidBytes\n+}\n+\n+/// A UUID stored as fields (identical to UUID, used only for conversions)\n+struct UuidFields {\n+    /// First field, 32-bit word\n+    data1: u32,\n+    /// Second field, 16-bit short\n+    data2: u16,\n+    /// Third field, 16-bit short\n+    data3: u16,\n+    /// Fourth field, 8 bytes\n+    data4: [u8, ..8]\n+}\n+\n+/// Error details for string parsing failures\n+pub enum ParseError {\n+    ErrorInvalidLength(uint),\n+    ErrorInvalidCharacter(char, uint),\n+    ErrorInvalidGroups(uint),\n+    ErrorInvalidGroupLength(uint, uint, uint),\n+}\n+\n+/// Converts a ParseError to a string\n+impl ToStr for ParseError {\n+    #[inline]\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            ErrorInvalidLength(found) =>\n+                fmt!(\"Invalid length; expecting 32, 36 or 45 chars, found %u\",\n+                    found),\n+            ErrorInvalidCharacter(found, pos) =>\n+                fmt!(\"Invalid character; found `%c` (0x%02x) at offset %u\",\n+                    found, found as uint, pos),\n+            ErrorInvalidGroups(found) =>\n+                fmt!(\"Malformed; wrong number of groups: expected 1 or 5, found %u\",\n+                    found),\n+            ErrorInvalidGroupLength(group, found, expecting) =>\n+                fmt!(\"Malformed; length of group %u was %u, expecting %u\",\n+                    group, found, expecting),\n+        }\n+    }\n+}\n+\n+// Length of each hyphenated group in hex digits\n+static UuidGroupLens: [uint, ..5] = [8u, 4u, 4u, 4u, 12u];\n+\n+/// UUID support\n+impl Uuid {\n+\n+    /// Returns a nil or empty UUID (containing all zeroes)\n+    pub fn new_nil() -> Uuid {\n+        let uuid = Uuid{ bytes: [0, .. 16] };\n+        uuid\n+    }\n+\n+    /// Create a new UUID of the specified version\n+    pub fn new(v: UuidVersion) -> Option<Uuid> {\n+        match v {\n+            Version4Random => Some(Uuid::new_v4()),\n+            _ => None\n+        }\n+    }\n+\n+    /// Creates a new random UUID\n+    ///\n+    /// Uses the `rand` module's default RNG task as the source\n+    /// of random numbers. Use the rand::Rand trait to supply\n+    /// a custom generator if required.\n+    pub fn new_v4() -> Uuid {\n+        let ub = rand::task_rng().gen_bytes(16);\n+        let mut uuid = Uuid{ bytes: [0, .. 16] };\n+        vec::bytes::copy_memory(uuid.bytes, ub, 16);\n+        uuid.set_variant(VariantRFC4122);\n+        uuid.set_version(Version4Random);\n+        uuid\n+    }\n+\n+    /// Creates a UUID using the supplied field values\n+    ///\n+    /// # Arguments\n+    /// * `d1` A 32-bit word\n+    /// * `d2` A 16-bit word\n+    /// * `d3` A 16-bit word\n+    /// * `d4` Array of 8 octets\n+    pub fn from_fields(d1: u32, d2: u16, d3: u16, d4: &[u8]) -> Uuid {\n+        use std::unstable::intrinsics::{to_be16, to_be32};\n+\n+        // First construct a temporary field-based struct\n+        let mut fields = UuidFields {\n+                data1: 0,\n+                data2: 0,\n+                data3: 0,\n+                data4: [0, ..8]\n+        };\n+\n+        fields.data1 = to_be32(d1 as i32) as u32;\n+        fields.data2 = to_be16(d2 as i16) as u16;\n+        fields.data3 = to_be16(d3 as i16) as u16;\n+        vec::bytes::copy_memory(fields.data4, d4, 8);\n+\n+        unsafe {\n+            transmute(fields)\n+        }\n+    }\n+\n+    /// Creates a UUID using the supplied bytes\n+    ///\n+    /// # Arguments\n+    /// * `b` An array or slice of 16 bytes\n+    pub fn from_bytes(b: &[u8]) -> Option<Uuid> {\n+        if b.len() != 16 {\n+            return None\n+        }\n+\n+        let mut uuid = Uuid{ bytes: [0, .. 16] };\n+        unsafe {\n+            vec::raw::copy_memory(uuid.bytes, b, 16);\n+        }\n+        Some(uuid)\n+    }\n+\n+    /// Specifies the variant of the UUID structure\n+    fn set_variant(&mut self, v: UuidVariant) {\n+        // Octet 8 contains the variant in the most significant 3 bits\n+        match v {\n+            VariantNCS =>        // b0xx...\n+                self.bytes[8] =  self.bytes[8] & 0x7f,\n+            VariantRFC4122 =>    // b10x...\n+                self.bytes[8] = (self.bytes[8] & 0x3f) | 0x80,\n+            VariantMicrosoft =>  // b110...\n+                self.bytes[8] = (self.bytes[8] & 0x1f) | 0xc0,\n+            VariantFuture =>     // b111...\n+                self.bytes[8] = (self.bytes[8] & 0x1f) | 0xe0,\n+        }\n+    }\n+\n+    /// Returns the variant of the UUID structure\n+    ///\n+    /// This determines the interpretation of the structure of the UUID.\n+    /// Currently only the RFC4122 variant is generated by this module.\n+    ///\n+    /// * [Variant Reference](http://tools.ietf.org/html/rfc4122#section-4.1.1)\n+    pub fn get_variant(&self) -> Option<UuidVariant> {\n+        if self.bytes[8] & 0x80 == 0x00 {\n+            Some(VariantNCS)\n+        } else if self.bytes[8] & 0xc0 == 0x80 {\n+            Some(VariantRFC4122)\n+        } else if self.bytes[8] & 0xe0 == 0xc0  {\n+            Some(VariantMicrosoft)\n+        } else if self.bytes[8] & 0xe0 == 0xe0 {\n+            Some(VariantFuture)\n+        } else  {\n+            None\n+        }\n+    }\n+\n+    /// Specifies the version number of the UUID\n+    fn set_version(&mut self, v: UuidVersion) {\n+        self.bytes[6] = (self.bytes[6] & 0xF) | ((v as u8) << 4);\n+    }\n+\n+    /// Returns the version number of the UUID\n+    ///\n+    /// This represents the algorithm used to generate the contents.\n+    ///\n+    /// Currently only the Random (V4) algorithm is supported by this\n+    /// module.  There are security and privacy implications for using\n+    /// older versions - see [Wikipedia: Universally Unique Identifier](\n+    /// http://en.wikipedia.org/wiki/Universally_unique_identifier) for\n+    /// details.\n+    ///\n+    /// * [Version Reference](http://tools.ietf.org/html/rfc4122#section-4.1.3)\n+    pub fn get_version_num(&self) -> uint {\n+        (self.bytes[6] >> 4) as uint\n+    }\n+\n+    /// Returns the version of the UUID\n+    ///\n+    /// This represents the algorithm used to generate the contents\n+    pub fn get_version(&self) -> Option<UuidVersion> {\n+        let v = (self.bytes[6] >> 4);\n+        match v {\n+            1 => Some(Version1Mac),\n+            2 => Some(Version2Dce),\n+            3 => Some(Version3Md5),\n+            4 => Some(Version4Random),\n+            5 => Some(Version5Sha1),\n+            _ => None\n+        }\n+    }\n+\n+    /// Return an array of 16 octets containing the UUID data\n+    pub fn to_bytes<'a>(&'a self) -> &'a [u8] {\n+        self.bytes.as_slice()\n+    }\n+\n+    /// Returns the UUID as a string of 16 hexadecimal digits\n+    ///\n+    /// Example: `936DA01F9ABD4d9d80C702AF85C822A8`\n+    pub fn to_simple_str(&self) -> ~str {\n+        let mut s: ~[u8] = vec::from_elem(32, 0u8);\n+        for i in range(0u, 16u) {\n+            let digit = fmt!(\"%02x\", self.bytes[i] as uint);\n+            s[i*2+0] = digit[0];\n+            s[i*2+1] = digit[1];\n+        }\n+        str::from_bytes(s)\n+    }\n+\n+    /// Returns a string of hexadecimal digits, separated into groups with a hypen\n+    ///\n+    /// Example: `550e8400-e29b-41d4-a716-446655440000`\n+    pub fn to_hyphenated_str(&self) -> ~str {\n+        use std::unstable::intrinsics::{to_be16, to_be32};\n+        // Convert to field-based struct as it matches groups in output.\n+        // Ensure fields are in network byte order, as per RFC.\n+        let mut uf: UuidFields;\n+        unsafe {\n+            uf = transmute_copy(&self.bytes);\n+        }\n+        uf.data1 = to_be32(uf.data1 as i32) as u32;\n+        uf.data2 = to_be16(uf.data2 as i16) as u16;\n+        uf.data3 = to_be16(uf.data3 as i16) as u16;\n+        let s = fmt!(\"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n+            uf.data1 as uint,\n+            uf.data2 as uint, uf.data3 as uint,\n+            uf.data4[0] as uint, uf.data4[1] as uint,\n+            uf.data4[2] as uint, uf.data4[3] as uint, uf.data4[4] as uint,\n+            uf.data4[5] as uint, uf.data4[6] as uint, uf.data4[7] as uint);\n+        s\n+    }\n+\n+    /// Returns the UUID formatted as a full URN string\n+    ///\n+    /// This is the same as the hyphenated format, but with the \"urn:uuid:\" prefix.\n+    ///\n+    /// Example: `urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4`\n+    pub fn to_urn_str(&self) -> ~str {\n+        \"urn:uuid:\" + self.to_hyphenated_str()\n+    }\n+\n+    /// Parses a UUID from a string of hexadecimal digits with optional hyphens\n+    ///\n+    /// Any of the formats generated by this module (simple, hyphenated, urn) are\n+    /// supported by this parsing function.\n+    pub fn parse_string(us: &str) -> Result<Uuid, ParseError> {\n+\n+        let mut us = us.clone();\n+        let orig_len = us.len();\n+\n+        // Ensure length is valid for any of the supported formats\n+        if orig_len != 32 && orig_len != 36 && orig_len != 45 {\n+            return Err(ErrorInvalidLength(orig_len));\n+        }\n+\n+        // Strip off URN prefix if present\n+        if us.starts_with(\"urn:uuid:\") {\n+            us = us.slice(9, orig_len);\n+        }\n+\n+        // Make sure all chars are either hex digits or hyphen\n+        for (i, c) in us.iter().enumerate() {\n+            match c {\n+                '0'..'9' | 'A'..'F' | 'a'..'f' | '-' => {},\n+                _ => return Err(ErrorInvalidCharacter(c, i)),\n+            }\n+        }\n+\n+        // Split string up by hyphens into groups\n+        let hex_groups: ~[&str] = us.split_str_iter(\"-\").collect();\n+\n+        // Get the length of each group\n+        let group_lens: ~[uint] = hex_groups.iter().map(|&v| v.len()).collect();\n+\n+        // Ensure the group lengths are valid\n+        match group_lens.len() {\n+            // Single group, no hyphens\n+            1 => {\n+                if group_lens[0] != 32 {\n+                    return Err(ErrorInvalidLength(group_lens[0]));\n+                }\n+            },\n+            // Five groups, hyphens in between each\n+            5 => {\n+                // Ensure each group length matches the expected\n+                for (i, (&gl, &expected)) in\n+                    group_lens.iter().zip(UuidGroupLens.iter()).enumerate() {\n+                    if gl != expected {\n+                        return Err(ErrorInvalidGroupLength(i, gl, expected))\n+                    }\n+                }\n+            },\n+            _ => {\n+                return Err(ErrorInvalidGroups(group_lens.len()));\n+            }\n+        }\n+\n+        // Normalise into one long hex string\n+        let vs = hex_groups.concat();\n+\n+        // At this point, we know we have a valid hex string, without hyphens\n+        assert!(vs.len() == 32);\n+        assert!(vs.iter().all(|c| c.is_digit_radix(16)));\n+\n+        // Allocate output UUID buffer\n+        let mut ub = [0u8, ..16];\n+\n+        // Extract each hex digit from the string\n+        for i in range(0u, 16u) {\n+            ub[i] = FromStrRadix::from_str_radix(vs.slice(i*2, (i+1)*2), 16).unwrap();\n+        }\n+\n+        Ok(Uuid::from_bytes(ub).unwrap())\n+    }\n+}\n+\n+impl Zero for Uuid {\n+    /// Returns the nil UUID, which is all zeroes\n+    fn zero() -> Uuid {\n+        Uuid::new_nil()\n+    }\n+\n+    /// Tests if the UUID is nil or all zeroes\n+    fn is_zero(&self) -> bool {\n+        return self.bytes.iter().all(|&b| b == 0);\n+    }\n+}\n+\n+impl Clone for Uuid {\n+    /// Returns a copy of the UUID\n+    fn clone(&self) -> Uuid {\n+        let mut clone = Uuid{ bytes: [0, .. 16] };\n+        vec::bytes::copy_memory(clone.bytes, self.bytes, 16);\n+        clone\n+    }\n+}\n+\n+impl FromStr for Uuid {\n+    /// Parse a hex string and interpret as a UUID\n+    ///\n+    /// Accepted formats are a sequence of 32 hexadecimal characters,\n+    /// with or without hypens (grouped as 8, 4, 4, 4, 12).\n+    fn from_str(us: &str) -> Option<Uuid> {\n+        let result = Uuid::parse_string(us);\n+        match result {\n+            Ok(u) => Some(u),\n+            Err(_) => None\n+        }\n+    }\n+}\n+\n+/// Convert the UUID to a hexadecimal-based string representation\n+impl ToStr for Uuid {\n+    fn to_str(&self) -> ~str {\n+        self.to_simple_str()\n+    }\n+}\n+\n+/// Test two UUIDs for equality\n+///\n+/// UUIDs are equal only when they are byte-for-byte identical\n+impl Eq for Uuid {\n+    fn eq(&self, other: &Uuid) -> bool {\n+        self.bytes == other.bytes\n+    }\n+}\n+\n+/// Test two UUIDs for equality\n+///\n+/// UUIDs are equal only when they are byte-for-byte identical\n+impl TotalEq for Uuid {\n+    fn equals(&self, other: &Uuid) -> bool {\n+        self.bytes == other.bytes\n+    }\n+}\n+\n+/// Generates a random instance of UUID (V4 conformant)\n+impl rand::Rand for Uuid {\n+    #[inline]\n+    fn rand<R: rand::Rng>(rng: &mut R) -> Uuid {\n+        let ub = rng.gen_bytes(16);\n+        let mut uuid = Uuid{ bytes: [0, .. 16] };\n+        vec::bytes::copy_memory(uuid.bytes, ub, 16);\n+        uuid.set_variant(VariantRFC4122);\n+        uuid.set_version(Version4Random);\n+        uuid\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use std::str;\n+    use std::rand;\n+    use std::num::Zero;\n+\n+    #[test]\n+    fn test_new_nil() {\n+        let nil = Uuid::new_nil();\n+        let nb = nil.to_bytes();\n+\n+        assert!(nb.iter().all(|&b| b == 0));\n+    }\n+\n+    #[test]\n+    fn test_zero() {\n+        let uz: Uuid = Zero::zero();\n+        let nz = Uuid::new_v4();\n+\n+        assert!(uz.is_zero());\n+        assert!(! nz.is_zero());\n+    }\n+\n+    #[test]\n+    fn test_new() {\n+        // Supported\n+        let uuid1 = Uuid::new(Version4Random).unwrap();\n+        let s = uuid1.to_simple_str();\n+\n+        assert!(s.len() == 32);\n+        assert!(uuid1.get_version().unwrap() == Version4Random);\n+\n+        // Test unsupported versions\n+        assert!(Uuid::new(Version1Mac) == None);\n+        assert!(Uuid::new(Version2Dce) == None);\n+        assert!(Uuid::new(Version3Md5) == None);\n+        assert!(Uuid::new(Version5Sha1) == None);\n+    }\n+\n+    #[test]\n+    fn test_new_v4() {\n+        let uuid1 = Uuid::new_v4();\n+\n+        assert!(uuid1.get_version().unwrap() == Version4Random);\n+        assert!(uuid1.get_variant().unwrap() == VariantRFC4122);\n+    }\n+\n+    #[test]\n+    fn test_get_version() {\n+        let uuid1 = Uuid::new_v4();\n+\n+        assert!(uuid1.get_version().unwrap() == Version4Random);\n+        assert!(uuid1.get_version_num() == 4);\n+    }\n+\n+    #[test]\n+    fn test_get_variant() {\n+        let uuid1 = Uuid::new_v4();\n+        let uuid2 = Uuid::parse_string(\"550e8400-e29b-41d4-a716-446655440000\").unwrap();\n+        let uuid3 = Uuid::parse_string(\"67e55044-10b1-426f-9247-bb680e5fe0c8\").unwrap();\n+        let uuid4 = Uuid::parse_string(\"936DA01F9ABD4d9dC0C702AF85C822A8\").unwrap();\n+        let uuid5 = Uuid::parse_string(\"F9168C5E-CEB2-4faa-D6BF-329BF39FA1E4\").unwrap();\n+        let uuid6 = Uuid::parse_string(\"f81d4fae-7dec-11d0-7765-00a0c91e6bf6\").unwrap();\n+\n+        assert!(uuid1.get_variant().unwrap() == VariantRFC4122);\n+        assert!(uuid2.get_variant().unwrap() == VariantRFC4122);\n+        assert!(uuid3.get_variant().unwrap() == VariantRFC4122);\n+        assert!(uuid4.get_variant().unwrap() == VariantMicrosoft);\n+        assert!(uuid5.get_variant().unwrap() == VariantMicrosoft);\n+        assert!(uuid6.get_variant().unwrap() == VariantNCS);\n+    }\n+\n+    #[test]\n+    fn test_parse_uuid_v4() {\n+\n+        // Invalid\n+        assert!(Uuid::parse_string(\"\").is_err());\n+        assert!(Uuid::parse_string(\"!\").is_err());\n+        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faa-B6BF-329BF39FA1E45\").is_err());\n+        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faa-BBF-329BF39FA1E4\").is_err());\n+        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faa-BGBF-329BF39FA1E4\").is_err());\n+        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faa-B6BFF329BF39FA1E4\").is_err());\n+        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faa\").is_err());\n+        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faaXB6BFF329BF39FA1E4\").is_err());\n+        assert!(Uuid::parse_string(\"F9168C5E-CEB-24fa-eB6BFF32-BF39FA1E4\").is_err());\n+        assert!(Uuid::parse_string(\"01020304-1112-2122-3132-41424344\").is_err());\n+        assert!(Uuid::parse_string(\"67e5504410b1426f9247bb680e5fe0c\").is_err());\n+        assert!(Uuid::parse_string(\"67e5504410b1426f9247bb680e5fe0c88\").is_err());\n+        assert!(Uuid::parse_string(\"67e5504410b1426f9247bb680e5fe0cg8\").is_err());\n+        assert!(Uuid::parse_string(\"67e5504410b1426%9247bb680e5fe0c8\").is_err());\n+\n+        // Valid\n+        assert!(Uuid::parse_string(\"00000000000000000000000000000000\").is_ok());\n+        assert!(Uuid::parse_string(\"67e55044-10b1-426f-9247-bb680e5fe0c8\").is_ok());\n+        assert!(Uuid::parse_string(\"67e55044-10b1-426f-9247-bb680e5fe0c8\").is_ok());\n+        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4\").is_ok());\n+        assert!(Uuid::parse_string(\"67e5504410b1426f9247bb680e5fe0c8\").is_ok());\n+        assert!(Uuid::parse_string(\"01020304-1112-2122-3132-414243444546\").is_ok());\n+        assert!(Uuid::parse_string(\"urn:uuid:67e55044-10b1-426f-9247-bb680e5fe0c8\").is_ok());\n+\n+        // Nil\n+        let nil = Uuid::new_nil();\n+        assert!(Uuid::parse_string(\"00000000000000000000000000000000\").unwrap()  == nil);\n+        assert!(Uuid::parse_string(\"00000000-0000-0000-0000-000000000000\").unwrap() == nil);\n+\n+        // Round-trip\n+        let uuid_orig = Uuid::new_v4();\n+        let orig_str = uuid_orig.to_str();\n+        let uuid_out = Uuid::parse_string(orig_str).unwrap();\n+        assert!(uuid_orig == uuid_out);\n+\n+        // Test error reporting\n+        let e = Uuid::parse_string(\"67e5504410b1426f9247bb680e5fe0c\").unwrap_err();\n+        assert!(match(e){ ErrorInvalidLength(n) => n==31, _ => false });\n+\n+        let e = Uuid::parse_string(\"67e550X410b1426f9247bb680e5fe0cd\").unwrap_err();\n+        assert!(match(e){ ErrorInvalidCharacter(c, n) => c=='X' && n==6, _ => false });\n+\n+        let e = Uuid::parse_string(\"67e550-4105b1426f9247bb680e5fe0c\").unwrap_err();\n+        assert!(match(e){ ErrorInvalidGroups(n) => n==2, _ => false });\n+\n+        let e = Uuid::parse_string(\"F9168C5E-CEB2-4faa-B6BF1-02BF39FA1E4\").unwrap_err();\n+        assert!(match(e){ ErrorInvalidGroupLength(g, n, e) => g==3 && n==5 && e==4, _ => false });\n+    }\n+\n+    #[test]\n+    fn test_to_simple_str() {\n+        let uuid1 = Uuid::new_v4();\n+        let s = uuid1.to_simple_str();\n+\n+        assert!(s.len() == 32);\n+        assert!(s.iter().all(|c| c.is_digit_radix(16)));\n+    }\n+\n+    #[test]\n+    fn test_to_str() {\n+        let uuid1 = Uuid::new_v4();\n+        let s = uuid1.to_str();\n+\n+        assert!(s.len() == 32);\n+        assert!(s.iter().all(|c| c.is_digit_radix(16)));\n+    }\n+\n+    #[test]\n+    fn test_to_hyphenated_str() {\n+        let uuid1 = Uuid::new_v4();\n+        let s = uuid1.to_hyphenated_str();\n+\n+        assert!(s.len() == 36);\n+        assert!(s.iter().all(|c| c.is_digit_radix(16) || c == '-'));\n+    }\n+\n+    #[test]\n+    fn test_to_urn_str() {\n+        let uuid1 = Uuid::new_v4();\n+        let ss = uuid1.to_urn_str();\n+        let s = ss.slice(9, ss.len());\n+\n+        assert!(ss.starts_with(\"urn:uuid:\"));\n+        assert!(s.len() == 36);\n+        assert!(s.iter().all(|c| c.is_digit_radix(16) || c == '-'));\n+    }\n+\n+    #[test]\n+    fn test_to_str_matching() {\n+        let uuid1 = Uuid::new_v4();\n+\n+        let hs = uuid1.to_hyphenated_str();\n+        let ss = uuid1.to_str();\n+\n+        let hsn = str::from_chars(hs.iter().filter(|&c| c != '-').collect::<~[char]>());\n+\n+        assert!(hsn == ss);\n+    }\n+\n+    #[test]\n+    fn test_string_roundtrip() {\n+        let uuid = Uuid::new_v4();\n+\n+        let hs = uuid.to_hyphenated_str();\n+        let uuid_hs = Uuid::parse_string(hs).unwrap();\n+        assert!(uuid_hs == uuid);\n+\n+        let ss = uuid.to_str();\n+        let uuid_ss = Uuid::parse_string(ss).unwrap();\n+        assert!(uuid_ss == uuid);\n+    }\n+\n+    #[test]\n+    fn test_compare() {\n+        let uuid1 = Uuid::new_v4();\n+        let uuid2 = Uuid::new_v4();\n+\n+        assert!(uuid1 == uuid1);\n+        assert!(uuid2 == uuid2);\n+        assert!(uuid1 != uuid2);\n+        assert!(uuid2 != uuid1);\n+    }\n+\n+    #[test]\n+    fn test_from_fields() {\n+        let d1: u32 = 0xa1a2a3a4;\n+        let d2: u16 = 0xb1b2;\n+        let d3: u16 = 0xc1c2;\n+        let d4: ~[u8] = ~[0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8];\n+\n+        let u = Uuid::from_fields(d1, d2, d3, d4);\n+\n+        let expected = ~\"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\";\n+        let result = u.to_simple_str();\n+        assert!(result == expected);\n+    }\n+\n+    #[test]\n+    fn test_from_bytes() {\n+        let b = ~[ 0xa1, 0xa2, 0xa3, 0xa4, 0xb1, 0xb2, 0xc1, 0xc2,\n+                   0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8 ];\n+\n+        let u = Uuid::from_bytes(b).unwrap();\n+        let expected = ~\"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\";\n+\n+        assert!(u.to_simple_str() == expected);\n+    }\n+\n+    #[test]\n+    fn test_to_bytes() {\n+        let u = Uuid::new_v4();\n+        let ub = u.to_bytes();\n+\n+        assert!(ub.len() == 16);\n+        assert!(! ub.iter().all(|&b| b == 0));\n+    }\n+\n+    #[test]\n+    fn test_bytes_roundtrip() {\n+        let b_in: [u8, ..16] = [ 0xa1, 0xa2, 0xa3, 0xa4, 0xb1, 0xb2, 0xc1, 0xc2,\n+                                 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8 ];\n+\n+        let u = Uuid::from_bytes(b_in.clone()).unwrap();\n+\n+        let b_out = u.to_bytes();\n+\n+        assert!(b_in == b_out);\n+    }\n+\n+    #[test]\n+    fn test_operator_eq() {\n+        let u1 = Uuid::new_v4();\n+        let u2 = u1.clone();\n+        let u3 = Uuid::new_v4();\n+\n+        assert!(u1 == u1);\n+        assert!(u1 == u2);\n+        assert!(u2 == u1);\n+\n+        assert!(u1 != u3);\n+        assert!(u3 != u1);\n+        assert!(u2 != u3);\n+        assert!(u3 != u2);\n+    }\n+\n+    #[test]\n+    fn test_rand_rand() {\n+        let mut rng = rand::rng();\n+        let u: ~Uuid = rand::Rand::rand(&mut rng);\n+        let ub = u.to_bytes();\n+\n+        assert!(ub.len() == 16);\n+        assert!(! ub.iter().all(|&b| b == 0));\n+    }\n+}\n+\n+#[cfg(test)]\n+mod bench {\n+    use super::*;\n+    use test::BenchHarness;\n+\n+    #[bench]\n+    pub fn create_uuids(bh: &mut BenchHarness) {\n+        do bh.iter {\n+            Uuid::new_v4();\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn uuid_to_str(bh: &mut BenchHarness) {\n+        let u = Uuid::new_v4();\n+        do bh.iter {\n+            u.to_str();\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn parse_str(bh: &mut BenchHarness) {\n+        let s = \"urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4\";\n+        do bh.iter {\n+            let u = Uuid::parse_string(s);\n+        }\n+    }\n+}"}]}