{"sha": "fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjMDYxMTRkZGZkMmJjZGJjNGYyOTA3NmMyMjZhN2ExZDY2ZWE4ZDY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-28T20:38:53Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-28T21:17:33Z"}, "message": "Merge remote-tracking branch 'brson/companion' into incoming\n\nConflicts:\n\tsrc/compiletest/compiletest.rs\n\tsrc/libcargo/cargo.rs\n\tsrc/libcore/core.rs\n\tsrc/librustc/rustc.rs\n\tsrc/librustdoc/rustdoc.rc", "tree": {"sha": "bd9de2c450f23b8ff0e09130ab59d784ace5b5e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd9de2c450f23b8ff0e09130ab59d784ace5b5e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "html_url": "https://github.com/rust-lang/rust/commit/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "669fbddc4435a9ab152332df06a7fcca789c8059", "url": "https://api.github.com/repos/rust-lang/rust/commits/669fbddc4435a9ab152332df06a7fcca789c8059", "html_url": "https://github.com/rust-lang/rust/commit/669fbddc4435a9ab152332df06a7fcca789c8059"}, {"sha": "8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "url": "https://api.github.com/repos/rust-lang/rust/commits/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "html_url": "https://github.com/rust-lang/rust/commit/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193"}], "stats": {"total": 12760, "additions": 4316, "deletions": 8444}, "files": [{"sha": "dcbe419ddb119000a2f8bb07ef8794e6b4ff3528", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -1,14 +1,5 @@\n enum mode { mode_compile_fail, mode_run_fail, mode_run_pass, mode_pretty, }\n \n-#[cfg(stage0)]\n-impl mode : cmp::Eq {\n-    pure fn eq(other: &mode) -> bool {\n-        (*other) as int == self as int\n-    }\n-    pure fn ne(other: &mode) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl mode : cmp::Eq {\n     pure fn eq(&self, other: &mode) -> bool {\n         (*other) as int == (*self) as int"}, {"sha": "a9ca15babded290872672b4d960158f3e0c1bd51", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -26,6 +26,198 @@ mod common;\n #[legacy_exports]\n mod errors;\n \n+use std::getopts;\n+use std::test;\n+\n+use core::result;\n+use result::{Ok, Err};\n+\n+use common::config;\n+use common::mode_run_pass;\n+use common::mode_run_fail;\n+use common::mode_compile_fail;\n+use common::mode_pretty;\n+use common::mode;\n+use util::logv;\n+\n+fn main() {\n+    let args = os::args();\n+    let config = parse_config(args);\n+    log_config(config);\n+    run_tests(config);\n+}\n+\n+fn parse_config(args: ~[~str]) -> config {\n+    let opts =\n+        ~[getopts::reqopt(~\"compile-lib-path\"),\n+          getopts::reqopt(~\"run-lib-path\"),\n+          getopts::reqopt(~\"rustc-path\"), getopts::reqopt(~\"src-base\"),\n+          getopts::reqopt(~\"build-base\"), getopts::reqopt(~\"aux-base\"),\n+          getopts::reqopt(~\"stage-id\"),\n+          getopts::reqopt(~\"mode\"), getopts::optflag(~\"ignored\"),\n+          getopts::optopt(~\"runtool\"), getopts::optopt(~\"rustcflags\"),\n+          getopts::optflag(~\"verbose\"),\n+          getopts::optopt(~\"logfile\"),\n+          getopts::optflag(~\"jit\")];\n+\n+    assert (vec::is_not_empty(args));\n+    let args_ = vec::tail(args);\n+    let matches =\n+        &match getopts::getopts(args_, opts) {\n+          Ok(m) => m,\n+          Err(f) => fail getopts::fail_str(f)\n+        };\n+\n+    fn opt_path(m: &getopts::Matches, nm: ~str) -> Path {\n+        Path(getopts::opt_str(m, nm))\n+    }\n+\n+    return {compile_lib_path: getopts::opt_str(matches, ~\"compile-lib-path\"),\n+         run_lib_path: getopts::opt_str(matches, ~\"run-lib-path\"),\n+         rustc_path: opt_path(matches, ~\"rustc-path\"),\n+         src_base: opt_path(matches, ~\"src-base\"),\n+         build_base: opt_path(matches, ~\"build-base\"),\n+         aux_base: opt_path(matches, ~\"aux-base\"),\n+         stage_id: getopts::opt_str(matches, ~\"stage-id\"),\n+         mode: str_mode(getopts::opt_str(matches, ~\"mode\")),\n+         run_ignored: getopts::opt_present(matches, ~\"ignored\"),\n+         filter:\n+             if vec::len(matches.free) > 0u {\n+                 option::Some(matches.free[0])\n+             } else { option::None },\n+         logfile: option::map(&getopts::opt_maybe_str(matches,\n+                                                     ~\"logfile\"),\n+                              |s| Path(*s)),\n+         runtool: getopts::opt_maybe_str(matches, ~\"runtool\"),\n+         rustcflags: getopts::opt_maybe_str(matches, ~\"rustcflags\"),\n+         jit: getopts::opt_present(matches, ~\"jit\"),\n+         verbose: getopts::opt_present(matches, ~\"verbose\")};\n+}\n+\n+fn log_config(config: config) {\n+    let c = config;\n+    logv(c, fmt!(\"configuration:\"));\n+    logv(c, fmt!(\"compile_lib_path: %s\", config.compile_lib_path));\n+    logv(c, fmt!(\"run_lib_path: %s\", config.run_lib_path));\n+    logv(c, fmt!(\"rustc_path: %s\", config.rustc_path.to_str()));\n+    logv(c, fmt!(\"src_base: %s\", config.src_base.to_str()));\n+    logv(c, fmt!(\"build_base: %s\", config.build_base.to_str()));\n+    logv(c, fmt!(\"stage_id: %s\", config.stage_id));\n+    logv(c, fmt!(\"mode: %s\", mode_str(config.mode)));\n+    logv(c, fmt!(\"run_ignored: %b\", config.run_ignored));\n+    logv(c, fmt!(\"filter: %s\", opt_str(config.filter)));\n+    logv(c, fmt!(\"runtool: %s\", opt_str(config.runtool)));\n+    logv(c, fmt!(\"rustcflags: %s\", opt_str(config.rustcflags)));\n+    logv(c, fmt!(\"jit: %b\", config.jit));\n+    logv(c, fmt!(\"verbose: %b\", config.verbose));\n+    logv(c, fmt!(\"\\n\"));\n+}\n+\n+fn opt_str(maybestr: Option<~str>) -> ~str {\n+    match maybestr { option::Some(s) => s, option::None => ~\"(none)\" }\n+}\n+\n+fn str_opt(maybestr: ~str) -> Option<~str> {\n+    if maybestr != ~\"(none)\" { option::Some(maybestr) } else { option::None }\n+}\n+\n+fn str_mode(s: ~str) -> mode {\n+    match s {\n+      ~\"compile-fail\" => mode_compile_fail,\n+      ~\"run-fail\" => mode_run_fail,\n+      ~\"run-pass\" => mode_run_pass,\n+      ~\"pretty\" => mode_pretty,\n+      _ => fail ~\"invalid mode\"\n+    }\n+}\n+\n+fn mode_str(mode: mode) -> ~str {\n+    match mode {\n+      mode_compile_fail => ~\"compile-fail\",\n+      mode_run_fail => ~\"run-fail\",\n+      mode_run_pass => ~\"run-pass\",\n+      mode_pretty => ~\"pretty\"\n+    }\n+}\n+\n+fn run_tests(config: config) {\n+    let opts = test_opts(config);\n+    let tests = make_tests(config);\n+    let res = test::run_tests_console(&opts, tests);\n+    if !res { fail ~\"Some tests failed\"; }\n+}\n+\n+fn test_opts(config: config) -> test::TestOpts {\n+    {filter:\n+         match config.filter {\n+           option::Some(s) => option::Some(s),\n+           option::None => option::None\n+         },\n+     run_ignored: config.run_ignored,\n+     logfile:\n+         match config.logfile {\n+           option::Some(s) => option::Some(s.to_str()),\n+           option::None => option::None\n+         }\n+    }\n+}\n+\n+fn make_tests(config: config) -> ~[test::TestDesc] {\n+    debug!(\"making tests from %s\",\n+           config.src_base.to_str());\n+    let mut tests = ~[];\n+    for os::list_dir_path(&config.src_base).each |file| {\n+        let file = copy *file;\n+        debug!(\"inspecting file %s\", file.to_str());\n+        if is_test(config, file) {\n+            tests.push(make_test(config, file))\n+        }\n+    }\n+    move tests\n+}\n+\n+fn is_test(config: config, testfile: &Path) -> bool {\n+    // Pretty-printer does not work with .rc files yet\n+    let valid_extensions =\n+        match config.mode {\n+          mode_pretty => ~[~\".rs\"],\n+          _ => ~[~\".rc\", ~\".rs\"]\n+        };\n+    let invalid_prefixes = ~[~\".\", ~\"#\", ~\"~\"];\n+    let name = testfile.filename().get();\n+\n+    let mut valid = false;\n+\n+    for valid_extensions.each |ext| {\n+        if str::ends_with(name, *ext) { valid = true; }\n+    }\n+\n+    for invalid_prefixes.each |pre| {\n+        if str::starts_with(name, *pre) { valid = false; }\n+    }\n+\n+    return valid;\n+}\n+\n+fn make_test(config: config, testfile: &Path) ->\n+   test::TestDesc {\n+    {\n+        name: make_test_name(config, testfile),\n+        testfn: make_test_closure(config, testfile),\n+        ignore: header::is_test_ignored(config, testfile),\n+        should_fail: false\n+    }\n+}\n+\n+fn make_test_name(config: config, testfile: &Path) -> ~str {\n+    fmt!(\"[%s] %s\", mode_str(config.mode), testfile.to_str())\n+}\n+\n+fn make_test_closure(config: config, testfile: &Path) -> test::TestFn {\n+    let testfile = testfile.to_str();\n+    fn~() { runtest::run(config, testfile) }\n+}\n+\n // Local Variables:\n // fill-column: 78;\n // indent-tabs-mode: nil"}, {"sha": "7ee297f3ffcf816e78c9e31713e1fe4953d39894", "filename": "src/compiletest/compiletest.rs", "status": "removed", "additions": 0, "deletions": 198, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,198 +0,0 @@\n-use std::getopts;\n-use std::test;\n-\n-use core::result;\n-use result::{Ok, Err};\n-\n-use common::config;\n-use common::mode_run_pass;\n-use common::mode_run_fail;\n-use common::mode_compile_fail;\n-use common::mode_pretty;\n-use common::mode;\n-use util::logv;\n-\n-fn main() {\n-    let args = os::args();\n-    let config = parse_config(args);\n-    log_config(config);\n-    run_tests(config);\n-}\n-\n-fn parse_config(args: ~[~str]) -> config {\n-    let opts =\n-        ~[getopts::reqopt(~\"compile-lib-path\"),\n-          getopts::reqopt(~\"run-lib-path\"),\n-          getopts::reqopt(~\"rustc-path\"), getopts::reqopt(~\"src-base\"),\n-          getopts::reqopt(~\"build-base\"), getopts::reqopt(~\"aux-base\"),\n-          getopts::reqopt(~\"stage-id\"),\n-          getopts::reqopt(~\"mode\"), getopts::optflag(~\"ignored\"),\n-          getopts::optopt(~\"runtool\"), getopts::optopt(~\"rustcflags\"),\n-          getopts::optflag(~\"verbose\"),\n-          getopts::optopt(~\"logfile\"),\n-          getopts::optflag(~\"jit\")];\n-\n-    assert (vec::is_not_empty(args));\n-    let args_ = vec::tail(args);\n-    let matches =\n-        &match getopts::getopts(args_, opts) {\n-          Ok(m) => m,\n-          Err(f) => fail getopts::fail_str(f)\n-        };\n-\n-    fn opt_path(m: &getopts::Matches, nm: ~str) -> Path {\n-        Path(getopts::opt_str(m, nm))\n-    }\n-\n-    return {compile_lib_path: getopts::opt_str(matches, ~\"compile-lib-path\"),\n-         run_lib_path: getopts::opt_str(matches, ~\"run-lib-path\"),\n-         rustc_path: opt_path(matches, ~\"rustc-path\"),\n-         src_base: opt_path(matches, ~\"src-base\"),\n-         build_base: opt_path(matches, ~\"build-base\"),\n-         aux_base: opt_path(matches, ~\"aux-base\"),\n-         stage_id: getopts::opt_str(matches, ~\"stage-id\"),\n-         mode: str_mode(getopts::opt_str(matches, ~\"mode\")),\n-         run_ignored: getopts::opt_present(matches, ~\"ignored\"),\n-         filter:\n-             if vec::len(matches.free) > 0u {\n-                 option::Some(matches.free[0])\n-             } else { option::None },\n-         logfile: option::map(&getopts::opt_maybe_str(matches,\n-                                                     ~\"logfile\"),\n-                              |s| Path(*s)),\n-         runtool: getopts::opt_maybe_str(matches, ~\"runtool\"),\n-         rustcflags: getopts::opt_maybe_str(matches, ~\"rustcflags\"),\n-         jit: getopts::opt_present(matches, ~\"jit\"),\n-         verbose: getopts::opt_present(matches, ~\"verbose\")};\n-}\n-\n-fn log_config(config: config) {\n-    let c = config;\n-    logv(c, fmt!(\"configuration:\"));\n-    logv(c, fmt!(\"compile_lib_path: %s\", config.compile_lib_path));\n-    logv(c, fmt!(\"run_lib_path: %s\", config.run_lib_path));\n-    logv(c, fmt!(\"rustc_path: %s\", config.rustc_path.to_str()));\n-    logv(c, fmt!(\"src_base: %s\", config.src_base.to_str()));\n-    logv(c, fmt!(\"build_base: %s\", config.build_base.to_str()));\n-    logv(c, fmt!(\"stage_id: %s\", config.stage_id));\n-    logv(c, fmt!(\"mode: %s\", mode_str(config.mode)));\n-    logv(c, fmt!(\"run_ignored: %b\", config.run_ignored));\n-    logv(c, fmt!(\"filter: %s\", opt_str(config.filter)));\n-    logv(c, fmt!(\"runtool: %s\", opt_str(config.runtool)));\n-    logv(c, fmt!(\"rustcflags: %s\", opt_str(config.rustcflags)));\n-    logv(c, fmt!(\"jit: %b\", config.jit));\n-    logv(c, fmt!(\"verbose: %b\", config.verbose));\n-    logv(c, fmt!(\"\\n\"));\n-}\n-\n-fn opt_str(maybestr: Option<~str>) -> ~str {\n-    match maybestr { option::Some(s) => s, option::None => ~\"(none)\" }\n-}\n-\n-fn str_opt(maybestr: ~str) -> Option<~str> {\n-    if maybestr != ~\"(none)\" { option::Some(maybestr) } else { option::None }\n-}\n-\n-fn str_mode(s: ~str) -> mode {\n-    match s {\n-      ~\"compile-fail\" => mode_compile_fail,\n-      ~\"run-fail\" => mode_run_fail,\n-      ~\"run-pass\" => mode_run_pass,\n-      ~\"pretty\" => mode_pretty,\n-      _ => fail ~\"invalid mode\"\n-    }\n-}\n-\n-fn mode_str(mode: mode) -> ~str {\n-    match mode {\n-      mode_compile_fail => ~\"compile-fail\",\n-      mode_run_fail => ~\"run-fail\",\n-      mode_run_pass => ~\"run-pass\",\n-      mode_pretty => ~\"pretty\"\n-    }\n-}\n-\n-fn run_tests(config: config) {\n-    let opts = test_opts(config);\n-    let tests = make_tests(config);\n-    let res = test::run_tests_console(&opts, tests);\n-    if !res { fail ~\"Some tests failed\"; }\n-}\n-\n-fn test_opts(config: config) -> test::TestOpts {\n-    {filter:\n-         match config.filter {\n-           option::Some(s) => option::Some(s),\n-           option::None => option::None\n-         },\n-     run_ignored: config.run_ignored,\n-     logfile:\n-         match config.logfile {\n-           option::Some(s) => option::Some(s.to_str()),\n-           option::None => option::None\n-         }\n-    }\n-}\n-\n-fn make_tests(config: config) -> ~[test::TestDesc] {\n-    debug!(\"making tests from %s\",\n-           config.src_base.to_str());\n-    let mut tests = ~[];\n-    for os::list_dir_path(&config.src_base).each |file| {\n-        let file = copy *file;\n-        debug!(\"inspecting file %s\", file.to_str());\n-        if is_test(config, file) {\n-            tests.push(make_test(config, file))\n-        }\n-    }\n-    move tests\n-}\n-\n-fn is_test(config: config, testfile: &Path) -> bool {\n-    // Pretty-printer does not work with .rc files yet\n-    let valid_extensions =\n-        match config.mode {\n-          mode_pretty => ~[~\".rs\"],\n-          _ => ~[~\".rc\", ~\".rs\"]\n-        };\n-    let invalid_prefixes = ~[~\".\", ~\"#\", ~\"~\"];\n-    let name = testfile.filename().get();\n-\n-    let mut valid = false;\n-\n-    for valid_extensions.each |ext| {\n-        if str::ends_with(name, *ext) { valid = true; }\n-    }\n-\n-    for invalid_prefixes.each |pre| {\n-        if str::starts_with(name, *pre) { valid = false; }\n-    }\n-\n-    return valid;\n-}\n-\n-fn make_test(config: config, testfile: &Path) ->\n-   test::TestDesc {\n-    {\n-        name: make_test_name(config, testfile),\n-        testfn: make_test_closure(config, testfile),\n-        ignore: header::is_test_ignored(config, testfile),\n-        should_fail: false\n-    }\n-}\n-\n-fn make_test_name(config: config, testfile: &Path) -> ~str {\n-    fmt!(\"[%s] %s\", mode_str(config.mode), testfile.to_str())\n-}\n-\n-fn make_test_closure(config: config, testfile: &Path) -> test::TestFn {\n-    let testfile = testfile.to_str();\n-    fn~() { runtest::run(config, testfile) }\n-}\n-\n-// Local Variables:\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "a559592e3c3443c3a8958fa75d0a24440124bf23", "filename": "src/libcargo/cargo.rc", "status": "modified", "additions": 1938, "deletions": 0, "changes": 1938, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -36,3 +36,1941 @@ use core::*;\n \n #[legacy_exports]\n mod pgp;\n+\n+use syntax::{ast, codemap, parse, visit, attr};\n+use syntax::diagnostic::span_handler;\n+use codemap::span;\n+use rustc::metadata::filesearch::{get_cargo_root, get_cargo_root_nearest,\n+                                     get_cargo_sysroot, libdir};\n+use syntax::diagnostic;\n+\n+use result::{Ok, Err};\n+use io::WriterUtil;\n+use send_map::linear::LinearMap;\n+use std::{map, json, tempfile, term, sort, getopts};\n+use map::HashMap;\n+use to_str::to_str;\n+use getopts::{optflag, optopt, opt_present};\n+use dvec::DVec;\n+\n+struct Package {\n+    name: ~str,\n+    uuid: ~str,\n+    url: ~str,\n+    method: ~str,\n+    description: ~str,\n+    reference: Option<~str>,\n+    tags: ~[~str],\n+    versions: ~[(~str, ~str)]\n+}\n+\n+impl Package : cmp::Ord {\n+    pure fn lt(&self, other: &Package) -> bool {\n+        if (*self).name.lt(&(*other).name) { return true; }\n+        if (*other).name.lt(&(*self).name) { return false; }\n+        if (*self).uuid.lt(&(*other).uuid) { return true; }\n+        if (*other).uuid.lt(&(*self).uuid) { return false; }\n+        if (*self).url.lt(&(*other).url) { return true; }\n+        if (*other).url.lt(&(*self).url) { return false; }\n+        if (*self).method.lt(&(*other).method) { return true; }\n+        if (*other).method.lt(&(*self).method) { return false; }\n+        if (*self).description.lt(&(*other).description) { return true; }\n+        if (*other).description.lt(&(*self).description) { return false; }\n+        if (*self).tags.lt(&(*other).tags) { return true; }\n+        if (*other).tags.lt(&(*self).tags) { return false; }\n+        if (*self).versions.lt(&(*other).versions) { return true; }\n+        return false;\n+    }\n+    pure fn le(&self, other: &Package) -> bool { !(*other).lt(&(*self)) }\n+    pure fn ge(&self, other: &Package) -> bool { !(*self).lt(other)     }\n+    pure fn gt(&self, other: &Package) -> bool { (*other).lt(&(*self))  }\n+}\n+\n+struct Source {\n+    name: ~str,\n+    mut url: ~str,\n+    mut method: ~str,\n+    mut key: Option<~str>,\n+    mut keyfp: Option<~str>,\n+    packages: DVec<Package>\n+}\n+\n+struct Cargo {\n+    pgp: bool,\n+    root: Path,\n+    installdir: Path,\n+    bindir: Path,\n+    libdir: Path,\n+    workdir: Path,\n+    sourcedir: Path,\n+    sources: map::HashMap<~str, @Source>,\n+    mut current_install: ~str,\n+    dep_cache: map::HashMap<~str, bool>,\n+    opts: Options\n+}\n+\n+struct Crate {\n+    name: ~str,\n+    vers: ~str,\n+    uuid: ~str,\n+    desc: Option<~str>,\n+    sigs: Option<~str>,\n+    crate_type: Option<~str>,\n+    deps: ~[~str]\n+}\n+\n+struct Options {\n+    test: bool,\n+    mode: Mode,\n+    free: ~[~str],\n+    help: bool,\n+}\n+\n+enum Mode { SystemMode, UserMode, LocalMode }\n+\n+impl Mode : cmp::Eq {\n+    pure fn eq(&self, other: &Mode) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(&self, other: &Mode) -> bool { !(*self).eq(other) }\n+}\n+\n+fn opts() -> ~[getopts::Opt] {\n+    ~[optflag(~\"g\"), optflag(~\"G\"), optflag(~\"test\"),\n+     optflag(~\"h\"), optflag(~\"help\")]\n+}\n+\n+fn info(msg: ~str) {\n+    let out = io::stdout();\n+\n+    if term::color_supported() {\n+        term::fg(out, term::color_green);\n+        out.write_str(~\"info: \");\n+        term::reset(out);\n+        out.write_line(msg);\n+    } else { out.write_line(~\"info: \" + msg); }\n+}\n+\n+fn warn(msg: ~str) {\n+    let out = io::stdout();\n+\n+    if term::color_supported() {\n+        term::fg(out, term::color_yellow);\n+        out.write_str(~\"warning: \");\n+        term::reset(out);\n+        out.write_line(msg);\n+    }else { out.write_line(~\"warning: \" + msg); }\n+}\n+\n+fn error(msg: ~str) {\n+    let out = io::stdout();\n+\n+    if term::color_supported() {\n+        term::fg(out, term::color_red);\n+        out.write_str(~\"error: \");\n+        term::reset(out);\n+        out.write_line(msg);\n+    }\n+    else { out.write_line(~\"error: \" + msg); }\n+}\n+\n+fn is_uuid(id: ~str) -> bool {\n+    let parts = str::split_str(id, ~\"-\");\n+    if vec::len(parts) == 5u {\n+        let mut correct = 0u;\n+        for vec::eachi(parts) |i, part| {\n+            fn is_hex_digit(+ch: char) -> bool {\n+                ('0' <= ch && ch <= '9') ||\n+                ('a' <= ch && ch <= 'f') ||\n+                ('A' <= ch && ch <= 'F')\n+            }\n+\n+            if !part.all(is_hex_digit) {\n+                return false;\n+            }\n+\n+            match i {\n+                0u => {\n+                    if part.len() == 8u {\n+                        correct += 1u;\n+                    }\n+                }\n+                1u | 2u | 3u => {\n+                    if part.len() == 4u {\n+                        correct += 1u;\n+                    }\n+                }\n+                4u => {\n+                    if part.len() == 12u {\n+                        correct += 1u;\n+                    }\n+                }\n+                _ => { }\n+            }\n+        }\n+        if correct >= 5u {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+#[test]\n+fn test_is_uuid() {\n+    assert is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaafAF09\");\n+    assert !is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaaa-aaaaaaaaaaaa\");\n+    assert !is_uuid(~\"\");\n+    assert !is_uuid(~\"aaaaaaaa-aaa -aaaa-aaaa-aaaaaaaaaaaa\");\n+    assert !is_uuid(~\"aaaaaaaa-aaa!-aaaa-aaaa-aaaaaaaaaaaa\");\n+    assert !is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa-a\");\n+    assert !is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa\u0e1b\");\n+}\n+\n+// FIXME (#2661): implement url/URL parsing so we don't have to resort\n+// to weak checks\n+\n+fn has_archive_extension(p: ~str) -> bool {\n+    str::ends_with(p, ~\".tar\") ||\n+    str::ends_with(p, ~\".tar.gz\") ||\n+    str::ends_with(p, ~\".tar.bz2\") ||\n+    str::ends_with(p, ~\".tar.Z\") ||\n+    str::ends_with(p, ~\".tar.lz\") ||\n+    str::ends_with(p, ~\".tar.xz\") ||\n+    str::ends_with(p, ~\".tgz\") ||\n+    str::ends_with(p, ~\".tbz\") ||\n+    str::ends_with(p, ~\".tbz2\") ||\n+    str::ends_with(p, ~\".tb2\") ||\n+    str::ends_with(p, ~\".taz\") ||\n+    str::ends_with(p, ~\".tlz\") ||\n+    str::ends_with(p, ~\".txz\")\n+}\n+\n+fn is_archive_path(u: ~str) -> bool {\n+    has_archive_extension(u) && os::path_exists(&Path(u))\n+}\n+\n+fn is_archive_url(u: ~str) -> bool {\n+    // FIXME (#2661): this requires the protocol bit - if we had proper\n+    // url parsing, we wouldn't need it\n+\n+    match str::find_str(u, ~\"://\") {\n+        option::Some(_) => has_archive_extension(u),\n+        _ => false\n+    }\n+}\n+\n+fn is_git_url(url: ~str) -> bool {\n+    if str::ends_with(url, ~\"/\") { str::ends_with(url, ~\".git/\") }\n+    else {\n+        str::starts_with(url, ~\"git://\") || str::ends_with(url, ~\".git\")\n+    }\n+}\n+\n+fn assume_source_method(url: ~str) -> ~str {\n+    if is_git_url(url) {\n+        return ~\"git\";\n+    }\n+    if str::starts_with(url, ~\"file://\") || os::path_exists(&Path(url)) {\n+        return ~\"file\";\n+    }\n+\n+    ~\"curl\"\n+}\n+\n+fn load_link(mis: ~[@ast::meta_item]) -> (Option<~str>,\n+                                         Option<~str>,\n+                                         Option<~str>) {\n+    let mut name = None;\n+    let mut vers = None;\n+    let mut uuid = None;\n+    for mis.each |a| {\n+        match a.node {\n+            ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) => {\n+                match v {\n+                    ~\"name\" => name = Some(*s),\n+                    ~\"vers\" => vers = Some(*s),\n+                    ~\"uuid\" => uuid = Some(*s),\n+                    _ => { }\n+                }\n+            }\n+            _ => fail ~\"load_link: meta items must be name-values\"\n+        }\n+    }\n+    (name, vers, uuid)\n+}\n+\n+fn load_crate(filename: &Path) -> Option<Crate> {\n+    let sess = parse::new_parse_sess(None);\n+    let c = parse::parse_crate_from_file(filename, ~[], sess);\n+\n+    let mut name = None;\n+    let mut vers = None;\n+    let mut uuid = None;\n+    let mut desc = None;\n+    let mut sigs = None;\n+    let mut crate_type = None;\n+\n+    for c.node.attrs.each |a| {\n+        match a.node.value.node {\n+            ast::meta_name_value(v, {node: ast::lit_str(_), span: _}) => {\n+                match v {\n+                    ~\"desc\" => desc = Some(v),\n+                    ~\"sigs\" => sigs = Some(v),\n+                    ~\"crate_type\" => crate_type = Some(v),\n+                    _ => { }\n+                }\n+            }\n+            ast::meta_list(v, mis) => {\n+                if v == ~\"link\" {\n+                    let (n, v, u) = load_link(mis);\n+                    name = n;\n+                    vers = v;\n+                    uuid = u;\n+                }\n+            }\n+            _ => {\n+                fail ~\"crate attributes may not contain \" +\n+                     ~\"meta_words\";\n+            }\n+        }\n+    }\n+\n+    type env = @{\n+        mut deps: ~[~str]\n+    };\n+\n+    fn goto_view_item(ps: syntax::parse::parse_sess, e: env,\n+                      i: @ast::view_item) {\n+        match i.node {\n+            ast::view_item_use(ident, metas, _) => {\n+                let name_items =\n+                    attr::find_meta_items_by_name(metas, ~\"name\");\n+                let m = if name_items.is_empty() {\n+                    metas + ~[attr::mk_name_value_item_str(\n+                        ~\"name\", *ps.interner.get(ident))]\n+                } else {\n+                    metas\n+                };\n+                let mut attr_name = ident;\n+                let mut attr_vers = ~\"\";\n+                let mut attr_from = ~\"\";\n+\n+              for m.each |item| {\n+                    match attr::get_meta_item_value_str(*item) {\n+                        Some(value) => {\n+                            let name = attr::get_meta_item_name(*item);\n+\n+                            match name {\n+                                ~\"vers\" => attr_vers = value,\n+                                ~\"from\" => attr_from = value,\n+                                _ => ()\n+                            }\n+                        }\n+                        None => ()\n+                    }\n+                }\n+\n+                let query = if !str::is_empty(attr_from) {\n+                    attr_from\n+                } else {\n+                    if !str::is_empty(attr_vers) {\n+                        ps.interner.get(attr_name) + ~\"@\" + attr_vers\n+                    } else { *ps.interner.get(attr_name) }\n+                };\n+\n+                match *ps.interner.get(attr_name) {\n+                    ~\"std\" | ~\"core\" => (),\n+                    _ => e.deps.push(query)\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+    fn goto_item(_e: env, _i: @ast::item) {\n+    }\n+\n+    let e = @{\n+        mut deps: ~[]\n+    };\n+    let v = visit::mk_simple_visitor(@{\n+        visit_view_item: |a| goto_view_item(sess, e, a),\n+        visit_item: |a| goto_item(e, a),\n+        .. *visit::default_simple_visitor()\n+    });\n+\n+    visit::visit_crate(*c, (), v);\n+\n+    let deps = copy e.deps;\n+\n+    match (name, vers, uuid) {\n+        (Some(name0), Some(vers0), Some(uuid0)) => {\n+            Some(Crate {\n+                name: name0,\n+                vers: vers0,\n+                uuid: uuid0,\n+                desc: desc,\n+                sigs: sigs,\n+                crate_type: crate_type,\n+                deps: deps })\n+        }\n+        _ => return None\n+    }\n+}\n+\n+fn print(s: ~str) {\n+    io::stdout().write_line(s);\n+}\n+\n+fn rest(s: ~str, start: uint) -> ~str {\n+    if (start >= str::len(s)) {\n+        ~\"\"\n+    } else {\n+        str::slice(s, start, str::len(s))\n+    }\n+}\n+\n+fn need_dir(s: &Path) {\n+    if os::path_is_dir(s) { return; }\n+    if !os::make_dir(s, 493_i32 /* oct: 755 */) {\n+        fail fmt!(\"can't make_dir %s\", s.to_str());\n+    }\n+}\n+\n+fn valid_pkg_name(s: &str) -> bool {\n+    fn is_valid_digit(+c: char) -> bool {\n+        ('0' <= c && c <= '9') ||\n+        ('a' <= c && c <= 'z') ||\n+        ('A' <= c && c <= 'Z') ||\n+        c == '-' ||\n+        c == '_'\n+    }\n+\n+    s.all(is_valid_digit)\n+}\n+\n+fn parse_source(name: ~str, j: &json::Json) -> @Source {\n+    if !valid_pkg_name(name) {\n+        fail fmt!(\"'%s' is an invalid source name\", name);\n+    }\n+\n+    match *j {\n+        json::Object(j) => {\n+            let mut url = match j.find(&~\"url\") {\n+                Some(json::String(u)) => u,\n+                _ => fail ~\"needed 'url' field in source\"\n+            };\n+            let method = match j.find(&~\"method\") {\n+                Some(json::String(u)) => u,\n+                _ => assume_source_method(url)\n+            };\n+            let key = match j.find(&~\"key\") {\n+                Some(json::String(u)) => Some(u),\n+                _ => None\n+            };\n+            let keyfp = match j.find(&~\"keyfp\") {\n+                Some(json::String(u)) => Some(u),\n+                _ => None\n+            };\n+            if method == ~\"file\" {\n+                url = os::make_absolute(&Path(url)).to_str();\n+            }\n+            return @Source {\n+                name: name,\n+                mut url: url,\n+                mut method: method,\n+                mut key: key,\n+                mut keyfp: keyfp,\n+                packages: DVec() };\n+        }\n+        _ => fail ~\"needed dict value in source\"\n+    };\n+}\n+\n+fn try_parse_sources(filename: &Path, sources: map::HashMap<~str, @Source>) {\n+    if !os::path_exists(filename)  { return; }\n+    let c = io::read_whole_file_str(filename);\n+    match json::from_str(c.get()) {\n+        Ok(json::Object(j)) => {\n+            for j.each |k, v| {\n+                sources.insert(copy *k, parse_source(*k, v));\n+                debug!(\"source: %s\", *k);\n+            }\n+        }\n+        Ok(_) => fail ~\"malformed sources.json\",\n+        Err(e) => fail fmt!(\"%s:%s\", filename.to_str(), e.to_str())\n+    }\n+}\n+\n+fn load_one_source_package(src: @Source, p: &json::Object) {\n+    let name = match p.find(&~\"name\") {\n+        Some(json::String(n)) => {\n+            if !valid_pkg_name(n) {\n+                warn(~\"malformed source json: \"\n+                     + src.name + ~\", '\" + n + ~\"'\"+\n+                     ~\" is an invalid name (alphanumeric, underscores and\" +\n+                     ~\" dashes only)\");\n+                return;\n+            }\n+            n\n+        }\n+        _ => {\n+            warn(~\"malformed source json: \" + src.name + ~\" (missing name)\");\n+            return;\n+        }\n+    };\n+\n+    let uuid = match p.find(&~\"uuid\") {\n+        Some(json::String(n)) => {\n+            if !is_uuid(n) {\n+                warn(~\"malformed source json: \"\n+                     + src.name + ~\", '\" + n + ~\"'\"+\n+                     ~\" is an invalid uuid\");\n+                return;\n+            }\n+            n\n+        }\n+        _ => {\n+            warn(~\"malformed source json: \" + src.name + ~\" (missing uuid)\");\n+            return;\n+        }\n+    };\n+\n+    let url = match p.find(&~\"url\") {\n+        Some(json::String(n)) => n,\n+        _ => {\n+            warn(~\"malformed source json: \" + src.name + ~\" (missing url)\");\n+            return;\n+        }\n+    };\n+\n+    let method = match p.find(&~\"method\") {\n+        Some(json::String(n)) => n,\n+        _ => {\n+            warn(~\"malformed source json: \"\n+                 + src.name + ~\" (missing method)\");\n+            return;\n+        }\n+    };\n+\n+    let reference = match p.find(&~\"ref\") {\n+        Some(json::String(n)) => Some(n),\n+        _ => None\n+    };\n+\n+    let mut tags = ~[];\n+    match p.find(&~\"tags\") {\n+        Some(json::List(js)) => {\n+          for js.each |j| {\n+                match *j {\n+                    json::String(ref j) => tags.grow(1u, j),\n+                    _ => ()\n+                }\n+            }\n+        }\n+        _ => ()\n+    }\n+\n+    let description = match p.find(&~\"description\") {\n+        Some(json::String(n)) => n,\n+        _ => {\n+            warn(~\"malformed source json: \" + src.name\n+                 + ~\" (missing description)\");\n+            return;\n+        }\n+    };\n+\n+    let newpkg = Package {\n+        name: name,\n+        uuid: uuid,\n+        url: url,\n+        method: method,\n+        description: description,\n+        reference: reference,\n+        tags: tags,\n+        versions: ~[]\n+    };\n+\n+    match src.packages.position(|pkg| pkg.uuid == uuid) {\n+        Some(idx) => {\n+            src.packages.set_elt(idx, newpkg);\n+            log(debug, ~\"  updated package: \" + src.name + ~\"/\" + name);\n+        }\n+        None => {\n+            src.packages.push(newpkg);\n+        }\n+    }\n+\n+    log(debug, ~\"  loaded package: \" + src.name + ~\"/\" + name);\n+}\n+\n+fn load_source_info(c: &Cargo, src: @Source) {\n+    let dir = c.sourcedir.push(src.name);\n+    let srcfile = dir.push(\"source.json\");\n+    if !os::path_exists(&srcfile) { return; }\n+    let srcstr = io::read_whole_file_str(&srcfile);\n+    match json::from_str(srcstr.get()) {\n+        Ok(ref json @ json::Object(_)) => {\n+            let o = parse_source(src.name, json);\n+\n+            src.key = o.key;\n+            src.keyfp = o.keyfp;\n+        }\n+        Ok(_) => {\n+            warn(~\"malformed source.json: \" + src.name +\n+                 ~\"(source info is not a dict)\");\n+        }\n+        Err(e) => {\n+            warn(fmt!(\"%s:%s\", src.name, e.to_str()));\n+        }\n+    };\n+}\n+fn load_source_packages(c: &Cargo, src: @Source) {\n+    log(debug, ~\"loading source: \" + src.name);\n+    let dir = c.sourcedir.push(src.name);\n+    let pkgfile = dir.push(\"packages.json\");\n+    if !os::path_exists(&pkgfile) { return; }\n+    let pkgstr = io::read_whole_file_str(&pkgfile);\n+    match json::from_str(pkgstr.get()) {\n+        Ok(json::List(js)) => {\n+          for js.each |j| {\n+                match *j {\n+                    json::Object(p) => {\n+                        load_one_source_package(src, p);\n+                    }\n+                    _ => {\n+                        warn(~\"malformed source json: \" + src.name +\n+                             ~\" (non-dict pkg)\");\n+                    }\n+                }\n+            }\n+        }\n+        Ok(_) => {\n+            warn(~\"malformed packages.json: \" + src.name +\n+                 ~\"(packages is not a list)\");\n+        }\n+        Err(e) => {\n+            warn(fmt!(\"%s:%s\", src.name, e.to_str()));\n+        }\n+    };\n+}\n+\n+fn build_cargo_options(argv: ~[~str]) -> Options {\n+    let matches = &match getopts::getopts(argv, opts()) {\n+        result::Ok(m) => m,\n+        result::Err(f) => {\n+            fail fmt!(\"%s\", getopts::fail_str(f));\n+        }\n+    };\n+\n+    let test = opt_present(matches, ~\"test\");\n+    let G    = opt_present(matches, ~\"G\");\n+    let g    = opt_present(matches, ~\"g\");\n+    let help = opt_present(matches, ~\"h\") || opt_present(matches, ~\"help\");\n+    let len  = vec::len(matches.free);\n+\n+    let is_install = len > 1u && matches.free[1] == ~\"install\";\n+    let is_uninstall = len > 1u && matches.free[1] == ~\"uninstall\";\n+\n+    if G && g { fail ~\"-G and -g both provided\"; }\n+\n+    if !is_install && !is_uninstall && (g || G) {\n+        fail ~\"-g and -G are only valid for `install` and `uninstall|rm`\";\n+    }\n+\n+    let mode =\n+        if (!is_install && !is_uninstall) || g { UserMode }\n+        else if G { SystemMode }\n+        else { LocalMode };\n+\n+    Options {test: test, mode: mode, free: matches.free, help: help}\n+}\n+\n+fn configure(opts: Options) -> Cargo {\n+    let home = match get_cargo_root() {\n+        Ok(home) => home,\n+        Err(_err) => get_cargo_sysroot().get()\n+    };\n+\n+    let get_cargo_dir = match opts.mode {\n+        SystemMode => get_cargo_sysroot,\n+        UserMode => get_cargo_root,\n+        LocalMode => get_cargo_root_nearest\n+    };\n+\n+    let p = get_cargo_dir().get();\n+\n+    let sources = HashMap();\n+    try_parse_sources(&home.push(\"sources.json\"), sources);\n+    try_parse_sources(&home.push(\"local-sources.json\"), sources);\n+\n+    let dep_cache = HashMap();\n+\n+    let mut c = Cargo {\n+        pgp: pgp::supported(),\n+        root: home,\n+        installdir: p,\n+        bindir: p.push(\"bin\"),\n+        libdir: p.push(\"lib\"),\n+        workdir: p.push(\"work\"),\n+        sourcedir: home.push(\"sources\"),\n+        sources: sources,\n+        mut current_install: ~\"\",\n+        dep_cache: dep_cache,\n+        opts: opts\n+    };\n+\n+    need_dir(&c.root);\n+    need_dir(&c.installdir);\n+    need_dir(&c.sourcedir);\n+    need_dir(&c.workdir);\n+    need_dir(&c.libdir);\n+    need_dir(&c.bindir);\n+\n+    for sources.each_key |k| {\n+        let mut s = sources.get(k);\n+        load_source_packages(&c, s);\n+        sources.insert(k, s);\n+    }\n+\n+    if c.pgp {\n+        pgp::init(&c.root);\n+    } else {\n+        warn(~\"command `gpg` was not found\");\n+        warn(~\"you have to install gpg from source \" +\n+             ~\" or package manager to get it to work correctly\");\n+    }\n+\n+    move c\n+}\n+\n+fn for_each_package(c: &Cargo, b: fn(s: @Source, p: &Package)) {\n+    for c.sources.each_value |v| {\n+        for v.packages.each |p| {\n+            b(v, p);\n+        }\n+    }\n+}\n+\n+// Runs all programs in directory <buildpath>\n+fn run_programs(buildpath: &Path) {\n+    let newv = os::list_dir_path(buildpath);\n+    for newv.each |ct| {\n+        run::run_program(ct.to_str(), ~[]);\n+    }\n+}\n+\n+// Runs rustc in <path + subdir> with the given flags\n+// and returns <patho + subdir>\n+fn run_in_buildpath(what: &str, path: &Path, subdir: &Path, cf: &Path,\n+                    extra_flags: ~[~str]) -> Option<Path> {\n+    let buildpath = path.push_rel(subdir);\n+    need_dir(&buildpath);\n+    debug!(\"%s: %s -> %s\", what, cf.to_str(), buildpath.to_str());\n+    let p = run::program_output(rustc_sysroot(),\n+                                ~[~\"--out-dir\",\n+                                  buildpath.to_str(),\n+                                  cf.to_str()] + extra_flags);\n+    if p.status != 0 {\n+        error(fmt!(\"rustc failed: %d\\n%s\\n%s\", p.status, p.err, p.out));\n+        return None;\n+    }\n+    Some(buildpath)\n+}\n+\n+fn test_one_crate(_c: &Cargo, path: &Path, cf: &Path) {\n+    let buildpath = match run_in_buildpath(~\"testing\", path,\n+                                           &Path(\"test\"),\n+                                           cf,\n+                                           ~[ ~\"--test\"]) {\n+      None => return,\n+    Some(bp) => bp\n+  };\n+  run_programs(&buildpath);\n+}\n+\n+fn install_one_crate(c: &Cargo, path: &Path, cf: &Path) {\n+    let buildpath = match run_in_buildpath(~\"installing\", path,\n+                                           &Path(\"build\"),\n+                                           cf, ~[]) {\n+      None => return,\n+      Some(bp) => bp\n+    };\n+    let newv = os::list_dir_path(&buildpath);\n+    let exec_suffix = os::exe_suffix();\n+    for newv.each |ct| {\n+        if (exec_suffix != ~\"\" && str::ends_with(ct.to_str(),\n+                                                 exec_suffix)) ||\n+            (exec_suffix == ~\"\" &&\n+             !str::starts_with(ct.filename().get(),\n+                               ~\"lib\")) {\n+            debug!(\"  bin: %s\", ct.to_str());\n+            install_to_dir(*ct, &c.bindir);\n+            if c.opts.mode == SystemMode {\n+                // FIXME (#2662): Put this file in PATH / symlink it so it can\n+                // be used as a generic executable\n+                // `cargo install -G rustray` and `rustray file.obj`\n+            }\n+        } else {\n+            debug!(\"  lib: %s\", ct.to_str());\n+            install_to_dir(*ct, &c.libdir);\n+        }\n+    }\n+}\n+\n+\n+fn rustc_sysroot() -> ~str {\n+    match os::self_exe_path() {\n+        Some(path) => {\n+            let rustc = path.push_many([~\"..\", ~\"bin\", ~\"rustc\"]);\n+            debug!(\"  rustc: %s\", rustc.to_str());\n+            rustc.to_str()\n+        }\n+        None => ~\"rustc\"\n+    }\n+}\n+\n+fn install_source(c: &Cargo, path: &Path) {\n+    debug!(\"source: %s\", path.to_str());\n+    os::change_dir(path);\n+\n+    let mut cratefiles = ~[];\n+    for os::walk_dir(&Path(\".\")) |p| {\n+        if p.filetype() == Some(~\".rc\") {\n+            cratefiles.push(*p);\n+        }\n+    }\n+\n+    if vec::is_empty(cratefiles) {\n+        fail ~\"this doesn't look like a rust package (no .rc files)\";\n+    }\n+\n+    for cratefiles.each |cf| {\n+        match load_crate(cf) {\n+            None => loop,\n+            Some(crate) => {\n+              for crate.deps.each |query| {\n+                    // FIXME (#1356): handle cyclic dependencies\n+                    // (n.b. #1356 says \"Cyclic dependency is an error\n+                    // condition\")\n+\n+                    let wd = get_temp_workdir(c);\n+                    install_query(c, &wd, *query);\n+                }\n+\n+                os::change_dir(path);\n+\n+                if c.opts.test {\n+                    test_one_crate(c, path, cf);\n+                }\n+                install_one_crate(c, path, cf);\n+            }\n+        }\n+    }\n+}\n+\n+fn install_git(c: &Cargo, wd: &Path, url: ~str, reference: Option<~str>) {\n+    run::program_output(~\"git\", ~[~\"clone\", url, wd.to_str()]);\n+    if reference.is_some() {\n+        let r = reference.get();\n+        os::change_dir(wd);\n+        run::run_program(~\"git\", ~[~\"checkout\", r]);\n+    }\n+\n+    install_source(c, wd);\n+}\n+\n+fn install_curl(c: &Cargo, wd: &Path, url: ~str) {\n+    let tarpath = wd.push(\"pkg.tar\");\n+    let p = run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\",\n+                                         tarpath.to_str(), url]);\n+    if p.status != 0 {\n+        fail fmt!(\"fetch of %s failed: %s\", url, p.err);\n+    }\n+    run::run_program(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n+                               ~\"-C\", wd.to_str(),\n+                               ~\"-f\", tarpath.to_str()]);\n+    install_source(c, wd);\n+}\n+\n+fn install_file(c: &Cargo, wd: &Path, path: &Path) {\n+    run::program_output(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n+                                  ~\"-C\", wd.to_str(),\n+                                  ~\"-f\", path.to_str()]);\n+    install_source(c, wd);\n+}\n+\n+fn install_package(c: &Cargo, src: ~str, wd: &Path, pkg: Package) {\n+    let url = copy pkg.url;\n+    let method = match pkg.method {\n+        ~\"git\" => ~\"git\",\n+        ~\"file\" => ~\"file\",\n+        _ => ~\"curl\"\n+    };\n+\n+    info(fmt!(\"installing %s/%s via %s...\", src, pkg.name, method));\n+\n+    match method {\n+        ~\"git\" => install_git(c, wd, url, copy pkg.reference),\n+        ~\"file\" => install_file(c, wd, &Path(url)),\n+        ~\"curl\" => install_curl(c, wd, url),\n+        _ => ()\n+    }\n+}\n+\n+fn cargo_suggestion(c: &Cargo, fallback: fn())\n+{\n+    if c.sources.size() == 0u {\n+        error(~\"no sources defined - you may wish to run \" +\n+              ~\"`cargo init`\");\n+        return;\n+    }\n+    fallback();\n+}\n+\n+fn install_uuid(c: &Cargo, wd: &Path, uuid: ~str) {\n+    let mut ps = ~[];\n+    for_each_package(c, |s, p| {\n+        if p.uuid == uuid {\n+            vec::push(&mut ps, (s.name, copy *p));\n+        }\n+    });\n+    if vec::len(ps) == 1u {\n+        let (sname, p) = copy ps[0];\n+        install_package(c, sname, wd, p);\n+        return;\n+    } else if vec::len(ps) == 0u {\n+        cargo_suggestion(c, || {\n+            error(~\"can't find package: \" + uuid);\n+        });\n+        return;\n+    }\n+    error(~\"found multiple packages:\");\n+    for ps.each |elt| {\n+        let (sname,p) = copy *elt;\n+        info(~\"  \" + sname + ~\"/\" + p.uuid + ~\" (\" + p.name + ~\")\");\n+    }\n+}\n+\n+fn install_named(c: &Cargo, wd: &Path, name: ~str) {\n+    let mut ps = ~[];\n+    for_each_package(c, |s, p| {\n+        if p.name == name {\n+            vec::push(&mut ps, (s.name, copy *p));\n+        }\n+    });\n+    if vec::len(ps) == 1u {\n+        let (sname, p) = copy ps[0];\n+        install_package(c, sname, wd, p);\n+        return;\n+    } else if vec::len(ps) == 0u {\n+        cargo_suggestion(c, || {\n+            error(~\"can't find package: \" + name);\n+        });\n+        return;\n+    }\n+    error(~\"found multiple packages:\");\n+    for ps.each |elt| {\n+        let (sname,p) = copy *elt;\n+        info(~\"  \" + sname + ~\"/\" + p.uuid + ~\" (\" + p.name + ~\")\");\n+    }\n+}\n+\n+fn install_uuid_specific(c: &Cargo, wd: &Path, src: ~str, uuid: ~str) {\n+    match c.sources.find(src) {\n+        Some(s) => {\n+            for s.packages.each |p| {\n+                if p.uuid == uuid {\n+                    install_package(c, src, wd, *p);\n+                    return;\n+                }\n+            }\n+        }\n+        _ => ()\n+    }\n+    error(~\"can't find package: \" + src + ~\"/\" + uuid);\n+}\n+\n+fn install_named_specific(c: &Cargo, wd: &Path, src: ~str, name: ~str) {\n+    match c.sources.find(src) {\n+        Some(s) => {\n+            for s.packages.each |p| {\n+                if p.name == name {\n+                    install_package(c, src, wd, *p);\n+                    return;\n+                }\n+            }\n+        }\n+        _ => ()\n+    }\n+    error(~\"can't find package: \" + src + ~\"/\" + name);\n+}\n+\n+fn cmd_uninstall(c: &Cargo) {\n+    if vec::len(c.opts.free) < 3u {\n+        cmd_usage();\n+        return;\n+    }\n+\n+    let lib = &c.libdir;\n+    let bin = &c.bindir;\n+    let target = c.opts.free[2u];\n+\n+    // FIXME (#2662): needs stronger pattern matching\n+    // FIXME (#2662): needs to uninstall from a specified location in a\n+    // cache instead of looking for it (binaries can be uninstalled by\n+    // name only)\n+\n+    fn try_uninstall(p: &Path) -> bool {\n+        if os::remove_file(p) {\n+            info(~\"uninstalled: '\" + p.to_str() + ~\"'\");\n+            true\n+        } else {\n+            error(~\"could not uninstall: '\" +\n+                  p.to_str() + ~\"'\");\n+            false\n+        }\n+    }\n+\n+    if is_uuid(target) {\n+        for os::list_dir(lib).each |file| {\n+            match str::find_str(*file, ~\"-\" + target + ~\"-\") {\n+              Some(_) => if !try_uninstall(&lib.push(*file)) { return },\n+              None => ()\n+            }\n+        }\n+        error(~\"can't find package with uuid: \" + target);\n+    } else {\n+        for os::list_dir(lib).each |file| {\n+            match str::find_str(*file, ~\"lib\" + target + ~\"-\") {\n+              Some(_) => if !try_uninstall(&lib.push(*file)) { return },\n+              None => ()\n+            }\n+        }\n+        for os::list_dir(bin).each |file| {\n+            match str::find_str(*file, target) {\n+              Some(_) => if !try_uninstall(&lib.push(*file)) { return },\n+              None => ()\n+            }\n+        }\n+\n+        error(~\"can't find package with name: \" + target);\n+    }\n+}\n+\n+fn install_query(c: &Cargo, wd: &Path, target: ~str) {\n+    match c.dep_cache.find(target) {\n+        Some(inst) => {\n+            if inst {\n+                return;\n+            }\n+        }\n+        None => ()\n+    }\n+\n+    c.dep_cache.insert(target, true);\n+\n+    if is_archive_path(target) {\n+        install_file(c, wd, &Path(target));\n+        return;\n+    } else if is_git_url(target) {\n+        let reference = if c.opts.free.len() >= 4u {\n+            Some(c.opts.free[3u])\n+        } else {\n+            None\n+        };\n+        install_git(c, wd, target, reference);\n+    } else if !valid_pkg_name(target) && has_archive_extension(target) {\n+        install_curl(c, wd, target);\n+        return;\n+    } else {\n+        let mut ps = copy target;\n+\n+        match str::find_char(ps, '/') {\n+            option::Some(idx) => {\n+                let source = str::slice(ps, 0u, idx);\n+                ps = str::slice(ps, idx + 1u, str::len(ps));\n+                if is_uuid(ps) {\n+                    install_uuid_specific(c, wd, source, ps);\n+                } else {\n+                    install_named_specific(c, wd, source, ps);\n+                }\n+            }\n+            option::None => {\n+                if is_uuid(ps) {\n+                    install_uuid(c, wd, ps);\n+                } else {\n+                    install_named(c, wd, ps);\n+                }\n+            }\n+        }\n+    }\n+\n+    // FIXME (#2662): This whole dep_cache and current_install thing is\n+    // a bit of a hack. It should be cleaned up in the future.\n+\n+    if target == c.current_install {\n+        for c.dep_cache.each |k, _v| {\n+            c.dep_cache.remove(k);\n+        }\n+\n+        c.current_install = ~\"\";\n+    }\n+}\n+\n+fn get_temp_workdir(c: &Cargo) -> Path {\n+    match tempfile::mkdtemp(&c.workdir, \"cargo\") {\n+      Some(wd) => wd,\n+      None => fail fmt!(\"needed temp dir: %s\",\n+                        c.workdir.to_str())\n+    }\n+}\n+\n+fn cmd_install(c: &Cargo) unsafe {\n+    let wd = get_temp_workdir(c);\n+\n+    if vec::len(c.opts.free) == 2u {\n+        let cwd = os::getcwd();\n+        let status = run::run_program(~\"cp\", ~[~\"-R\", cwd.to_str(),\n+                                               wd.to_str()]);\n+\n+        if status != 0 {\n+            fail fmt!(\"could not copy directory: %s\", cwd.to_str());\n+        }\n+\n+        install_source(c, &wd);\n+        return;\n+    }\n+\n+    sync(c);\n+\n+    let query = c.opts.free[2];\n+    c.current_install = query.to_str();\n+\n+    install_query(c, &wd, query);\n+}\n+\n+fn sync(c: &Cargo) {\n+    for c.sources.each_key |k| {\n+        let mut s = c.sources.get(k);\n+        sync_one(c, s);\n+        c.sources.insert(k, s);\n+    }\n+}\n+\n+fn sync_one_file(c: &Cargo, dir: &Path, src: @Source) -> bool {\n+    let name = src.name;\n+    let srcfile = dir.push(\"source.json.new\");\n+    let destsrcfile = dir.push(\"source.json\");\n+    let pkgfile = dir.push(\"packages.json.new\");\n+    let destpkgfile = dir.push(\"packages.json\");\n+    let keyfile = dir.push(\"key.gpg\");\n+    let srcsigfile = dir.push(\"source.json.sig\");\n+    let sigfile = dir.push(\"packages.json.sig\");\n+    let url = Path(src.url);\n+    let mut has_src_file = false;\n+\n+    if !os::copy_file(&url.push(\"packages.json\"), &pkgfile) {\n+        error(fmt!(\"fetch for source %s (url %s) failed\",\n+                   name, url.to_str()));\n+        return false;\n+    }\n+\n+    if os::copy_file(&url.push(\"source.json\"), &srcfile) {\n+        has_src_file = false;\n+    }\n+\n+    os::copy_file(&url.push(\"source.json.sig\"), &srcsigfile);\n+    os::copy_file(&url.push(\"packages.json.sig\"), &sigfile);\n+\n+    match copy src.key {\n+        Some(u) => {\n+            let p = run::program_output(~\"curl\",\n+                                        ~[~\"-f\", ~\"-s\",\n+                                          ~\"-o\", keyfile.to_str(), u]);\n+            if p.status != 0 {\n+                error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n+                return false;\n+            }\n+            pgp::add(&c.root, &keyfile);\n+        }\n+        _ => ()\n+    }\n+    match (src.key, src.keyfp) {\n+        (Some(_), Some(f)) => {\n+            let r = pgp::verify(&c.root, &pkgfile, &sigfile);\n+\n+            if !r {\n+                error(fmt!(\"signature verification failed for source %s with \\\n+                            key %s\", name, f));\n+                return false;\n+            }\n+\n+            if has_src_file {\n+                let e = pgp::verify(&c.root, &srcfile, &srcsigfile);\n+\n+                if !e {\n+                    error(fmt!(\"signature verification failed for source %s \\\n+                                with key %s\", name, f));\n+                    return false;\n+                }\n+            }\n+        }\n+        _ => ()\n+    }\n+\n+    copy_warn(&pkgfile, &destpkgfile);\n+\n+    if has_src_file {\n+        copy_warn(&srcfile, &destsrcfile);\n+    }\n+\n+    os::remove_file(&keyfile);\n+    os::remove_file(&srcfile);\n+    os::remove_file(&srcsigfile);\n+    os::remove_file(&pkgfile);\n+    os::remove_file(&sigfile);\n+\n+    info(fmt!(\"synced source: %s\", name));\n+\n+    return true;\n+}\n+\n+fn sync_one_git(c: &Cargo, dir: &Path, src: @Source) -> bool {\n+    let name = src.name;\n+    let srcfile = dir.push(\"source.json\");\n+    let pkgfile = dir.push(\"packages.json\");\n+    let keyfile = dir.push(\"key.gpg\");\n+    let srcsigfile = dir.push(\"source.json.sig\");\n+    let sigfile = dir.push(\"packages.json.sig\");\n+    let url = src.url;\n+\n+    fn rollback(name: ~str, dir: &Path, insecure: bool) {\n+        fn msg(name: ~str, insecure: bool) {\n+            error(fmt!(\"could not rollback source: %s\", name));\n+\n+            if insecure {\n+                warn(~\"a past security check failed on source \" +\n+                     name + ~\" and rolling back the source failed -\"\n+                     + ~\" this source may be compromised\");\n+            }\n+        }\n+\n+        if !os::change_dir(dir) {\n+            msg(name, insecure);\n+        }\n+        else {\n+            let p = run::program_output(~\"git\", ~[~\"reset\", ~\"--hard\",\n+                                                ~\"HEAD@{1}\"]);\n+\n+            if p.status != 0 {\n+                msg(name, insecure);\n+            }\n+        }\n+    }\n+\n+    if !os::path_exists(&dir.push(\".git\")) {\n+        let p = run::program_output(~\"git\", ~[~\"clone\", url, dir.to_str()]);\n+\n+        if p.status != 0 {\n+            error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n+            return false;\n+        }\n+    }\n+    else {\n+        if !os::change_dir(dir) {\n+            error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n+            return false;\n+        }\n+\n+        let p = run::program_output(~\"git\", ~[~\"pull\"]);\n+\n+        if p.status != 0 {\n+            error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n+            return false;\n+        }\n+    }\n+\n+    let has_src_file = os::path_exists(&srcfile);\n+\n+    match copy src.key {\n+        Some(u) => {\n+            let p = run::program_output(~\"curl\",\n+                                        ~[~\"-f\", ~\"-s\",\n+                                          ~\"-o\", keyfile.to_str(), u]);\n+            if p.status != 0 {\n+                error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n+                rollback(name, dir, false);\n+                return false;\n+            }\n+            pgp::add(&c.root, &keyfile);\n+        }\n+        _ => ()\n+    }\n+    match (src.key, src.keyfp) {\n+        (Some(_), Some(f)) => {\n+            let r = pgp::verify(&c.root, &pkgfile, &sigfile);\n+\n+            if !r {\n+                error(fmt!(\"signature verification failed for source %s with \\\n+                            key %s\", name, f));\n+                rollback(name, dir, false);\n+                return false;\n+            }\n+\n+            if has_src_file {\n+                let e = pgp::verify(&c.root, &srcfile, &srcsigfile);\n+\n+                if !e {\n+                    error(fmt!(\"signature verification failed for source %s \\\n+                                with key %s\", name, f));\n+                    rollback(name, dir, false);\n+                    return false;\n+                }\n+            }\n+        }\n+        _ => ()\n+    }\n+\n+    os::remove_file(&keyfile);\n+\n+    info(fmt!(\"synced source: %s\", name));\n+\n+    return true;\n+}\n+\n+fn sync_one_curl(c: &Cargo, dir: &Path, src: @Source) -> bool {\n+    let name = src.name;\n+    let srcfile = dir.push(\"source.json.new\");\n+    let destsrcfile = dir.push(\"source.json\");\n+    let pkgfile = dir.push(\"packages.json.new\");\n+    let destpkgfile = dir.push(\"packages.json\");\n+    let keyfile = dir.push(\"key.gpg\");\n+    let srcsigfile = dir.push(\"source.json.sig\");\n+    let sigfile = dir.push(\"packages.json.sig\");\n+    let mut url = src.url;\n+    let smart = !str::ends_with(src.url, ~\"packages.json\");\n+    let mut has_src_file = false;\n+\n+    if smart {\n+        url += ~\"/packages.json\";\n+    }\n+\n+    let p = run::program_output(~\"curl\",\n+                                ~[~\"-f\", ~\"-s\",\n+                                  ~\"-o\", pkgfile.to_str(), url]);\n+\n+    if p.status != 0 {\n+        error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n+        return false;\n+    }\n+    if smart {\n+        url = src.url + ~\"/source.json\";\n+        let p =\n+            run::program_output(~\"curl\",\n+                                ~[~\"-f\", ~\"-s\",\n+                                  ~\"-o\", srcfile.to_str(), url]);\n+\n+        if p.status == 0 {\n+            has_src_file = true;\n+        }\n+    }\n+\n+    match copy src.key {\n+       Some(u) => {\n+            let p = run::program_output(~\"curl\",\n+                                        ~[~\"-f\", ~\"-s\",\n+                                          ~\"-o\", keyfile.to_str(), u]);\n+            if p.status != 0 {\n+                error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n+                return false;\n+            }\n+            pgp::add(&c.root, &keyfile);\n+        }\n+        _ => ()\n+    }\n+    match (src.key, src.keyfp) {\n+        (Some(_), Some(f)) => {\n+            if smart {\n+                url = src.url + ~\"/packages.json.sig\";\n+            }\n+            else {\n+                url = src.url + ~\".sig\";\n+            }\n+\n+            let mut p = run::program_output(~\"curl\",\n+                                            ~[~\"-f\", ~\"-s\", ~\"-o\",\n+                                              sigfile.to_str(), url]);\n+            if p.status != 0 {\n+                error(fmt!(\"fetch for source %s (sig %s) failed\", name, url));\n+                return false;\n+            }\n+\n+            let r = pgp::verify(&c.root, &pkgfile, &sigfile);\n+\n+            if !r {\n+                error(fmt!(\"signature verification failed for source %s with \\\n+                            key %s\", name, f));\n+                return false;\n+            }\n+\n+            if smart && has_src_file {\n+                url = src.url + ~\"/source.json.sig\";\n+\n+                p = run::program_output(~\"curl\",\n+                                        ~[~\"-f\", ~\"-s\", ~\"-o\",\n+                                          srcsigfile.to_str(), url]);\n+                if p.status != 0 {\n+                    error(fmt!(\"fetch for source %s (sig %s) failed\",\n+                          name, url));\n+                    return false;\n+                }\n+\n+                let e = pgp::verify(&c.root, &srcfile, &srcsigfile);\n+\n+                if !e {\n+                    error(~\"signature verification failed for \" +\n+                          ~\"source \" + name + ~\" with key \" + f);\n+                    return false;\n+                }\n+            }\n+        }\n+        _ => ()\n+    }\n+\n+    copy_warn(&pkgfile, &destpkgfile);\n+\n+    if smart && has_src_file {\n+        copy_warn(&srcfile, &destsrcfile);\n+    }\n+\n+    os::remove_file(&keyfile);\n+    os::remove_file(&srcfile);\n+    os::remove_file(&srcsigfile);\n+    os::remove_file(&pkgfile);\n+    os::remove_file(&sigfile);\n+\n+    info(fmt!(\"synced source: %s\", name));\n+\n+    return true;\n+}\n+\n+fn sync_one(c: &Cargo, src: @Source) {\n+    let name = src.name;\n+    let dir = c.sourcedir.push(name);\n+\n+    info(fmt!(\"syncing source: %s...\", name));\n+\n+    need_dir(&dir);\n+\n+    let result = match src.method {\n+        ~\"git\" => sync_one_git(c, &dir, src),\n+        ~\"file\" => sync_one_file(c, &dir, src),\n+        _ => sync_one_curl(c, &dir, src)\n+    };\n+\n+    if result {\n+        load_source_info(c, src);\n+        load_source_packages(c, src);\n+    }\n+}\n+\n+fn cmd_init(c: &Cargo) {\n+    let srcurl = ~\"http://www.rust-lang.org/cargo/sources.json\";\n+    let sigurl = ~\"http://www.rust-lang.org/cargo/sources.json.sig\";\n+\n+    let srcfile = c.root.push(\"sources.json.new\");\n+    let sigfile = c.root.push(\"sources.json.sig\");\n+    let destsrcfile = c.root.push(\"sources.json\");\n+\n+    let p =\n+        run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\",\n+                                       ~\"-o\", srcfile.to_str(), srcurl]);\n+    if p.status != 0 {\n+        error(fmt!(\"fetch of sources.json failed: %s\", p.out));\n+        return;\n+    }\n+\n+    let p =\n+        run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\",\n+                                       ~\"-o\", sigfile.to_str(), sigurl]);\n+    if p.status != 0 {\n+        error(fmt!(\"fetch of sources.json.sig failed: %s\", p.out));\n+        return;\n+    }\n+\n+    let r = pgp::verify(&c.root, &srcfile, &sigfile);\n+    if !r {\n+        error(fmt!(\"signature verification failed for '%s'\",\n+                   srcfile.to_str()));\n+        return;\n+    }\n+\n+    copy_warn(&srcfile, &destsrcfile);\n+    os::remove_file(&srcfile);\n+    os::remove_file(&sigfile);\n+\n+    info(fmt!(\"initialized .cargo in %s\", c.root.to_str()));\n+}\n+\n+fn print_pkg(s: @Source, p: &Package) {\n+    let mut m = s.name + ~\"/\" + p.name + ~\" (\" + p.uuid + ~\")\";\n+    if vec::len(p.tags) > 0u {\n+        m = m + ~\" [\" + str::connect(p.tags, ~\", \") + ~\"]\";\n+    }\n+    info(m);\n+    if p.description != ~\"\" {\n+        print(~\"   >> \" + p.description + ~\"\\n\")\n+    }\n+}\n+\n+fn print_source(s: @Source) {\n+    info(s.name + ~\" (\" + s.url + ~\")\");\n+\n+    let pks = sort::merge_sort(s.packages.get(), sys::shape_lt);\n+    let l = vec::len(pks);\n+\n+    print(io::with_str_writer(|writer| {\n+        let mut list = ~\"   >> \";\n+\n+        for vec::eachi(pks) |i, pk| {\n+            if str::len(list) > 78u {\n+                writer.write_line(list);\n+                list = ~\"   >> \";\n+            }\n+            list += pk.name + (if l - 1u == i { ~\"\" } else { ~\", \" });\n+        }\n+\n+        writer.write_line(list);\n+    }));\n+}\n+\n+fn cmd_list(c: &Cargo) {\n+    sync(c);\n+\n+    if vec::len(c.opts.free) >= 3u {\n+        let v = vec::view(c.opts.free, 2u, vec::len(c.opts.free));\n+        for vec::each(v) |name| {\n+            if !valid_pkg_name(*name) {\n+                error(fmt!(\"'%s' is an invalid source name\", *name));\n+            } else {\n+                match c.sources.find(*name) {\n+                    Some(source) => {\n+                        print_source(source);\n+                    }\n+                    None => {\n+                        error(fmt!(\"no such source: %s\", *name));\n+                    }\n+                }\n+            }\n+        }\n+    } else {\n+        for c.sources.each_value |v| {\n+            print_source(v);\n+        }\n+    }\n+}\n+\n+fn cmd_search(c: &Cargo) {\n+    if vec::len(c.opts.free) < 3u {\n+        cmd_usage();\n+        return;\n+    }\n+\n+    sync(c);\n+\n+    let mut n = 0;\n+    let name = c.opts.free[2];\n+    let tags = vec::slice(c.opts.free, 3u, vec::len(c.opts.free));\n+    for_each_package(c, |s, p| {\n+        if (str::contains(p.name, name) || name == ~\"*\") &&\n+            vec::all(tags, |t| vec::contains(p.tags, t) ) {\n+            print_pkg(s, p);\n+            n += 1;\n+        }\n+    });\n+    info(fmt!(\"found %d packages\", n));\n+}\n+\n+fn install_to_dir(srcfile: &Path, destdir: &Path) {\n+    let newfile = destdir.push(srcfile.filename().get());\n+\n+    let status = run::run_program(~\"cp\", ~[~\"-r\", srcfile.to_str(),\n+                                           newfile.to_str()]);\n+    if status == 0 {\n+        info(fmt!(\"installed: '%s'\", newfile.to_str()));\n+    } else {\n+        error(fmt!(\"could not install: '%s'\", newfile.to_str()));\n+    }\n+}\n+\n+fn dump_cache(c: &Cargo) {\n+    need_dir(&c.root);\n+\n+    let out = c.root.push(\"cache.json\");\n+    let _root = json::Object(~LinearMap());\n+\n+    if os::path_exists(&out) {\n+        copy_warn(&out, &c.root.push(\"cache.json.old\"));\n+    }\n+}\n+fn dump_sources(c: &Cargo) {\n+    if c.sources.size() < 1u {\n+        return;\n+    }\n+\n+    need_dir(&c.root);\n+\n+    let out = c.root.push(\"sources.json\");\n+\n+    if os::path_exists(&out) {\n+        copy_warn(&out, &c.root.push(\"sources.json.old\"));\n+    }\n+\n+    match io::buffered_file_writer(&out) {\n+        result::Ok(writer) => {\n+            let mut hash = ~LinearMap();\n+\n+            for c.sources.each |k, v| {\n+                let mut chash = ~LinearMap();\n+\n+                chash.insert(~\"url\", json::String(v.url));\n+                chash.insert(~\"method\", json::String(v.method));\n+\n+                match copy v.key {\n+                    Some(key) => {\n+                        chash.insert(~\"key\", json::String(copy key));\n+                    }\n+                    _ => ()\n+                }\n+                match copy v.keyfp {\n+                    Some(keyfp) => {\n+                        chash.insert(~\"keyfp\", json::String(copy keyfp));\n+                    }\n+                    _ => ()\n+                }\n+\n+                hash.insert(copy k, json::Object(move chash));\n+            }\n+\n+            json::to_writer(writer, &json::Object(move hash))\n+        }\n+        result::Err(e) => {\n+            error(fmt!(\"could not dump sources: %s\", e));\n+        }\n+    }\n+}\n+\n+fn copy_warn(srcfile: &Path, destfile: &Path) {\n+    if !os::copy_file(srcfile, destfile) {\n+        warn(fmt!(\"copying %s to %s failed\",\n+                  srcfile.to_str(), destfile.to_str()));\n+    }\n+}\n+\n+fn cmd_sources(c: &Cargo) {\n+    if vec::len(c.opts.free) < 3u {\n+        for c.sources.each_value |v| {\n+            info(fmt!(\"%s (%s) via %s\",\n+                      v.name, v.url, v.method));\n+        }\n+        return;\n+    }\n+\n+    let action = c.opts.free[2u];\n+\n+    match action {\n+        ~\"clear\" => {\n+          for c.sources.each_key |k| {\n+                c.sources.remove(k);\n+            }\n+\n+            info(~\"cleared sources\");\n+        }\n+        ~\"add\" => {\n+            if vec::len(c.opts.free) < 5u {\n+                cmd_usage();\n+                return;\n+            }\n+\n+            let name = c.opts.free[3u];\n+            let url = c.opts.free[4u];\n+\n+            if !valid_pkg_name(name) {\n+                error(fmt!(\"'%s' is an invalid source name\", name));\n+                return;\n+            }\n+\n+            if c.sources.contains_key(name) {\n+                error(fmt!(\"source already exists: %s\", name));\n+            } else {\n+                c.sources.insert(name, @Source {\n+                    name: name,\n+                    mut url: url,\n+                    mut method: assume_source_method(url),\n+                    mut key: None,\n+                    mut keyfp: None,\n+                    packages: DVec()\n+                });\n+                info(fmt!(\"added source: %s\", name));\n+            }\n+        }\n+        ~\"remove\" => {\n+            if vec::len(c.opts.free) < 4u {\n+                cmd_usage();\n+                return;\n+            }\n+\n+            let name = c.opts.free[3u];\n+\n+            if !valid_pkg_name(name) {\n+                error(fmt!(\"'%s' is an invalid source name\", name));\n+                return;\n+            }\n+\n+            if c.sources.contains_key(name) {\n+                c.sources.remove(name);\n+                info(fmt!(\"removed source: %s\", name));\n+            } else {\n+                error(fmt!(\"no such source: %s\", name));\n+            }\n+        }\n+        ~\"set-url\" => {\n+            if vec::len(c.opts.free) < 5u {\n+                cmd_usage();\n+                return;\n+            }\n+\n+            let name = c.opts.free[3u];\n+            let url = c.opts.free[4u];\n+\n+            if !valid_pkg_name(name) {\n+                error(fmt!(\"'%s' is an invalid source name\", name));\n+                return;\n+            }\n+\n+            match c.sources.find(name) {\n+                Some(source) => {\n+                    let old = copy source.url;\n+                    let method = assume_source_method(url);\n+\n+                    source.url = url;\n+                    source.method = method;\n+\n+                    c.sources.insert(name, source);\n+\n+                    info(fmt!(\"changed source url: '%s' to '%s'\", old, url));\n+                }\n+                None => {\n+                    error(fmt!(\"no such source: %s\", name));\n+                }\n+            }\n+        }\n+        ~\"set-method\" => {\n+            if vec::len(c.opts.free) < 5u {\n+                cmd_usage();\n+                return;\n+            }\n+\n+            let name = c.opts.free[3u];\n+            let method = c.opts.free[4u];\n+\n+            if !valid_pkg_name(name) {\n+                error(fmt!(\"'%s' is an invalid source name\", name));\n+                return;\n+            }\n+\n+            match c.sources.find(name) {\n+                Some(source) => {\n+                    let old = copy source.method;\n+\n+                    source.method = match method {\n+                        ~\"git\" => ~\"git\",\n+                        ~\"file\" => ~\"file\",\n+                        _ => ~\"curl\"\n+                    };\n+\n+                    c.sources.insert(name, source);\n+\n+                    info(fmt!(\"changed source method: '%s' to '%s'\", old,\n+                         method));\n+                }\n+                None => {\n+                    error(fmt!(\"no such source: %s\", name));\n+                }\n+            }\n+        }\n+        ~\"rename\" => {\n+            if vec::len(c.opts.free) < 5u {\n+                cmd_usage();\n+                return;\n+            }\n+\n+            let name = c.opts.free[3u];\n+            let newn = c.opts.free[4u];\n+\n+            if !valid_pkg_name(name) {\n+                error(fmt!(\"'%s' is an invalid source name\", name));\n+                return;\n+            }\n+            if !valid_pkg_name(newn) {\n+                error(fmt!(\"'%s' is an invalid source name\", newn));\n+                return;\n+            }\n+\n+            match c.sources.find(name) {\n+                Some(source) => {\n+                    c.sources.remove(name);\n+                    c.sources.insert(newn, source);\n+                    info(fmt!(\"renamed source: %s to %s\", name, newn));\n+                }\n+                None => {\n+                    error(fmt!(\"no such source: %s\", name));\n+                }\n+            }\n+        }\n+        _ => cmd_usage()\n+    }\n+}\n+\n+fn cmd_usage() {\n+    print(~\"Usage: cargo <cmd> [options] [args..]\n+e.g. cargo install <name>\n+\n+Where <cmd> is one of:\n+    init, install, list, search, sources,\n+    uninstall, usage\n+\n+Options:\n+\n+    -h, --help                  Display this message\n+    <cmd> -h, <cmd> --help      Display help for <cmd>\n+\");\n+}\n+\n+fn cmd_usage_init() {\n+    print(~\"cargo init\n+\n+Re-initialize cargo in ~/.cargo. Clears all sources and then adds the\n+default sources from <www.rust-lang.org/sources.json>.\");\n+}\n+\n+fn cmd_usage_install() {\n+    print(~\"cargo install\n+cargo install [source/]<name>[@version]\n+cargo install [source/]<uuid>[@version]\n+cargo install <git url> [ref]\n+cargo install <tarball url>\n+cargo install <tarball file>\n+\n+Options:\n+    --test      Run crate tests before installing\n+    -g          Install to the user level (~/.cargo/bin/ instead of\n+                locally in ./.cargo/bin/ by default)\n+    -G          Install to the system level (/usr/local/lib/cargo/bin/)\n+\n+Install a crate. If no arguments are supplied, it installs from\n+the current working directory. If a source is provided, only install\n+from that source, otherwise it installs from any source.\");\n+}\n+\n+fn cmd_usage_uninstall() {\n+    print(~\"cargo uninstall [source/]<name>[@version]\n+cargo uninstall [source/]<uuid>[@version]\n+cargo uninstall <meta-name>[@version]\n+cargo uninstall <meta-uuid>[@version]\n+\n+Options:\n+    -g          Remove from the user level (~/.cargo/bin/ instead of\n+                locally in ./.cargo/bin/ by default)\n+    -G          Remove from the system level (/usr/local/lib/cargo/bin/)\n+\n+Remove a crate. If a source is provided, only remove\n+from that source, otherwise it removes from any source.\n+If a crate was installed directly (git, tarball, etc.), you can remove\n+it by metadata.\");\n+}\n+\n+fn cmd_usage_list() {\n+    print(~\"cargo list [sources..]\n+\n+If no arguments are provided, list all sources and their packages.\n+If source names are provided, list those sources and their packages.\n+\");\n+}\n+\n+fn cmd_usage_search() {\n+    print(~\"cargo search <query | '*'> [tags..]\n+\n+Search packages.\");\n+}\n+\n+fn cmd_usage_sources() {\n+    print(~\"cargo sources\n+cargo sources add <name> <url>\n+cargo sources remove <name>\n+cargo sources rename <name> <new>\n+cargo sources set-url <name> <url>\n+cargo sources set-method <name> <method>\n+\n+If no arguments are supplied, list all sources (but not their packages).\n+\n+Commands:\n+    add             Add a source. The source method will be guessed\n+                    from the URL.\n+    remove          Remove a source.\n+    rename          Rename a source.\n+    set-url         Change the URL for a source.\n+    set-method      Change the method for a source.\");\n+}\n+\n+fn main() {\n+    let argv = os::args();\n+    let o = build_cargo_options(argv);\n+\n+    if vec::len(o.free) < 2u {\n+        cmd_usage();\n+        return;\n+    }\n+    if o.help {\n+        match o.free[1] {\n+            ~\"init\" => cmd_usage_init(),\n+            ~\"install\" => cmd_usage_install(),\n+            ~\"uninstall\" => cmd_usage_uninstall(),\n+            ~\"list\" => cmd_usage_list(),\n+            ~\"search\" => cmd_usage_search(),\n+            ~\"sources\" => cmd_usage_sources(),\n+            _ => cmd_usage()\n+        }\n+        return;\n+    }\n+    if o.free[1] == ~\"usage\" {\n+        cmd_usage();\n+        return;\n+    }\n+\n+    let mut c = configure(o);\n+    let home = c.root;\n+    let first_time = os::path_exists(&home.push(\"sources.json\"));\n+\n+    if !first_time && o.free[1] != ~\"init\" {\n+        cmd_init(&c);\n+\n+        // FIXME (#2662): shouldn't need to reconfigure\n+        c = configure(o);\n+    }\n+\n+    let c = &move c;\n+\n+    match o.free[1] {\n+        ~\"init\" => cmd_init(c),\n+        ~\"install\" => cmd_install(c),\n+        ~\"uninstall\" => cmd_uninstall(c),\n+        ~\"list\" => cmd_list(c),\n+        ~\"search\" => cmd_search(c),\n+        ~\"sources\" => cmd_sources(c),\n+        _ => cmd_usage()\n+    }\n+\n+    dump_cache(c);\n+    dump_sources(c);\n+}"}, {"sha": "4ccabdae9e478635ab8ad54d33324e5c8b39f2c9", "filename": "src/libcargo/cargo.rs", "status": "removed", "additions": 0, "deletions": 1982, "changes": 1982, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,1982 +0,0 @@\n-// cargo.rs - Rust package manager\n-\n-#[legacy_exports];\n-\n-use syntax::{ast, codemap, parse, visit, attr};\n-use syntax::diagnostic::span_handler;\n-use codemap::span;\n-use rustc::metadata::filesearch::{get_cargo_root, get_cargo_root_nearest,\n-                                     get_cargo_sysroot, libdir};\n-use syntax::diagnostic;\n-\n-use result::{Ok, Err};\n-use io::WriterUtil;\n-use send_map::linear::LinearMap;\n-use std::{map, json, tempfile, term, sort, getopts};\n-use map::HashMap;\n-use to_str::to_str;\n-use getopts::{optflag, optopt, opt_present};\n-use dvec::DVec;\n-\n-struct Package {\n-    name: ~str,\n-    uuid: ~str,\n-    url: ~str,\n-    method: ~str,\n-    description: ~str,\n-    reference: Option<~str>,\n-    tags: ~[~str],\n-    versions: ~[(~str, ~str)]\n-}\n-\n-impl Package : cmp::Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: &Package) -> bool {\n-        if self.name.lt(&(*other).name) { return true; }\n-        if (*other).name.lt(&self.name) { return false; }\n-        if self.uuid.lt(&(*other).uuid) { return true; }\n-        if (*other).uuid.lt(&self.uuid) { return false; }\n-        if self.url.lt(&(*other).url) { return true; }\n-        if (*other).url.lt(&self.url) { return false; }\n-        if self.method.lt(&(*other).method) { return true; }\n-        if (*other).method.lt(&self.method) { return false; }\n-        if self.description.lt(&(*other).description) { return true; }\n-        if (*other).description.lt(&self.description) { return false; }\n-        if self.tags.lt(&(*other).tags) { return true; }\n-        if (*other).tags.lt(&self.tags) { return false; }\n-        if self.versions.lt(&(*other).versions) { return true; }\n-        return false;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn lt(&self, other: &Package) -> bool {\n-        if (*self).name.lt(&(*other).name) { return true; }\n-        if (*other).name.lt(&(*self).name) { return false; }\n-        if (*self).uuid.lt(&(*other).uuid) { return true; }\n-        if (*other).uuid.lt(&(*self).uuid) { return false; }\n-        if (*self).url.lt(&(*other).url) { return true; }\n-        if (*other).url.lt(&(*self).url) { return false; }\n-        if (*self).method.lt(&(*other).method) { return true; }\n-        if (*other).method.lt(&(*self).method) { return false; }\n-        if (*self).description.lt(&(*other).description) { return true; }\n-        if (*other).description.lt(&(*self).description) { return false; }\n-        if (*self).tags.lt(&(*other).tags) { return true; }\n-        if (*other).tags.lt(&(*self).tags) { return false; }\n-        if (*self).versions.lt(&(*other).versions) { return true; }\n-        return false;\n-    }\n-    #[cfg(stage0)]\n-    pure fn le(other: &Package) -> bool { !(*other).lt(&self) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn le(&self, other: &Package) -> bool { !(*other).lt(&(*self)) }\n-    #[cfg(stage0)]\n-    pure fn ge(other: &Package) -> bool { !self.lt(other)     }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn ge(&self, other: &Package) -> bool { !(*self).lt(other)     }\n-    #[cfg(stage0)]\n-    pure fn gt(other: &Package) -> bool { (*other).lt(&self)  }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn gt(&self, other: &Package) -> bool { (*other).lt(&(*self))  }\n-}\n-\n-struct Source {\n-    name: ~str,\n-    mut url: ~str,\n-    mut method: ~str,\n-    mut key: Option<~str>,\n-    mut keyfp: Option<~str>,\n-    packages: DVec<Package>\n-}\n-\n-struct Cargo {\n-    pgp: bool,\n-    root: Path,\n-    installdir: Path,\n-    bindir: Path,\n-    libdir: Path,\n-    workdir: Path,\n-    sourcedir: Path,\n-    sources: map::HashMap<~str, @Source>,\n-    mut current_install: ~str,\n-    dep_cache: map::HashMap<~str, bool>,\n-    opts: Options\n-}\n-\n-struct Crate {\n-    name: ~str,\n-    vers: ~str,\n-    uuid: ~str,\n-    desc: Option<~str>,\n-    sigs: Option<~str>,\n-    crate_type: Option<~str>,\n-    deps: ~[~str]\n-}\n-\n-struct Options {\n-    test: bool,\n-    mode: Mode,\n-    free: ~[~str],\n-    help: bool,\n-}\n-\n-enum Mode { SystemMode, UserMode, LocalMode }\n-\n-impl Mode : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Mode) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn eq(&self, other: &Mode) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Mode) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn ne(&self, other: &Mode) -> bool { !(*self).eq(other) }\n-}\n-\n-fn opts() -> ~[getopts::Opt] {\n-    ~[optflag(~\"g\"), optflag(~\"G\"), optflag(~\"test\"),\n-     optflag(~\"h\"), optflag(~\"help\")]\n-}\n-\n-fn info(msg: ~str) {\n-    let out = io::stdout();\n-\n-    if term::color_supported() {\n-        term::fg(out, term::color_green);\n-        out.write_str(~\"info: \");\n-        term::reset(out);\n-        out.write_line(msg);\n-    } else { out.write_line(~\"info: \" + msg); }\n-}\n-\n-fn warn(msg: ~str) {\n-    let out = io::stdout();\n-\n-    if term::color_supported() {\n-        term::fg(out, term::color_yellow);\n-        out.write_str(~\"warning: \");\n-        term::reset(out);\n-        out.write_line(msg);\n-    }else { out.write_line(~\"warning: \" + msg); }\n-}\n-\n-fn error(msg: ~str) {\n-    let out = io::stdout();\n-\n-    if term::color_supported() {\n-        term::fg(out, term::color_red);\n-        out.write_str(~\"error: \");\n-        term::reset(out);\n-        out.write_line(msg);\n-    }\n-    else { out.write_line(~\"error: \" + msg); }\n-}\n-\n-fn is_uuid(id: ~str) -> bool {\n-    let parts = str::split_str(id, ~\"-\");\n-    if vec::len(parts) == 5u {\n-        let mut correct = 0u;\n-        for vec::eachi(parts) |i, part| {\n-            fn is_hex_digit(+ch: char) -> bool {\n-                ('0' <= ch && ch <= '9') ||\n-                ('a' <= ch && ch <= 'f') ||\n-                ('A' <= ch && ch <= 'F')\n-            }\n-\n-            if !part.all(is_hex_digit) {\n-                return false;\n-            }\n-\n-            match i {\n-                0u => {\n-                    if part.len() == 8u {\n-                        correct += 1u;\n-                    }\n-                }\n-                1u | 2u | 3u => {\n-                    if part.len() == 4u {\n-                        correct += 1u;\n-                    }\n-                }\n-                4u => {\n-                    if part.len() == 12u {\n-                        correct += 1u;\n-                    }\n-                }\n-                _ => { }\n-            }\n-        }\n-        if correct >= 5u {\n-            return true;\n-        }\n-    }\n-    return false;\n-}\n-\n-#[test]\n-fn test_is_uuid() {\n-    assert is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaafAF09\");\n-    assert !is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaaa-aaaaaaaaaaaa\");\n-    assert !is_uuid(~\"\");\n-    assert !is_uuid(~\"aaaaaaaa-aaa -aaaa-aaaa-aaaaaaaaaaaa\");\n-    assert !is_uuid(~\"aaaaaaaa-aaa!-aaaa-aaaa-aaaaaaaaaaaa\");\n-    assert !is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa-a\");\n-    assert !is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa\u0e1b\");\n-}\n-\n-// FIXME (#2661): implement url/URL parsing so we don't have to resort\n-// to weak checks\n-\n-fn has_archive_extension(p: ~str) -> bool {\n-    str::ends_with(p, ~\".tar\") ||\n-    str::ends_with(p, ~\".tar.gz\") ||\n-    str::ends_with(p, ~\".tar.bz2\") ||\n-    str::ends_with(p, ~\".tar.Z\") ||\n-    str::ends_with(p, ~\".tar.lz\") ||\n-    str::ends_with(p, ~\".tar.xz\") ||\n-    str::ends_with(p, ~\".tgz\") ||\n-    str::ends_with(p, ~\".tbz\") ||\n-    str::ends_with(p, ~\".tbz2\") ||\n-    str::ends_with(p, ~\".tb2\") ||\n-    str::ends_with(p, ~\".taz\") ||\n-    str::ends_with(p, ~\".tlz\") ||\n-    str::ends_with(p, ~\".txz\")\n-}\n-\n-fn is_archive_path(u: ~str) -> bool {\n-    has_archive_extension(u) && os::path_exists(&Path(u))\n-}\n-\n-fn is_archive_url(u: ~str) -> bool {\n-    // FIXME (#2661): this requires the protocol bit - if we had proper\n-    // url parsing, we wouldn't need it\n-\n-    match str::find_str(u, ~\"://\") {\n-        option::Some(_) => has_archive_extension(u),\n-        _ => false\n-    }\n-}\n-\n-fn is_git_url(url: ~str) -> bool {\n-    if str::ends_with(url, ~\"/\") { str::ends_with(url, ~\".git/\") }\n-    else {\n-        str::starts_with(url, ~\"git://\") || str::ends_with(url, ~\".git\")\n-    }\n-}\n-\n-fn assume_source_method(url: ~str) -> ~str {\n-    if is_git_url(url) {\n-        return ~\"git\";\n-    }\n-    if str::starts_with(url, ~\"file://\") || os::path_exists(&Path(url)) {\n-        return ~\"file\";\n-    }\n-\n-    ~\"curl\"\n-}\n-\n-fn load_link(mis: ~[@ast::meta_item]) -> (Option<~str>,\n-                                         Option<~str>,\n-                                         Option<~str>) {\n-    let mut name = None;\n-    let mut vers = None;\n-    let mut uuid = None;\n-    for mis.each |a| {\n-        match a.node {\n-            ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) => {\n-                match v {\n-                    ~\"name\" => name = Some(*s),\n-                    ~\"vers\" => vers = Some(*s),\n-                    ~\"uuid\" => uuid = Some(*s),\n-                    _ => { }\n-                }\n-            }\n-            _ => fail ~\"load_link: meta items must be name-values\"\n-        }\n-    }\n-    (name, vers, uuid)\n-}\n-\n-fn load_crate(filename: &Path) -> Option<Crate> {\n-    let sess = parse::new_parse_sess(None);\n-    let c = parse::parse_crate_from_crate_file(filename, ~[], sess);\n-\n-    let mut name = None;\n-    let mut vers = None;\n-    let mut uuid = None;\n-    let mut desc = None;\n-    let mut sigs = None;\n-    let mut crate_type = None;\n-\n-    for c.node.attrs.each |a| {\n-        match a.node.value.node {\n-            ast::meta_name_value(v, {node: ast::lit_str(_), span: _}) => {\n-                match v {\n-                    ~\"desc\" => desc = Some(v),\n-                    ~\"sigs\" => sigs = Some(v),\n-                    ~\"crate_type\" => crate_type = Some(v),\n-                    _ => { }\n-                }\n-            }\n-            ast::meta_list(v, mis) => {\n-                if v == ~\"link\" {\n-                    let (n, v, u) = load_link(mis);\n-                    name = n;\n-                    vers = v;\n-                    uuid = u;\n-                }\n-            }\n-            _ => {\n-                fail ~\"crate attributes may not contain \" +\n-                     ~\"meta_words\";\n-            }\n-        }\n-    }\n-\n-    type env = @{\n-        mut deps: ~[~str]\n-    };\n-\n-    fn goto_view_item(ps: syntax::parse::parse_sess, e: env,\n-                      i: @ast::view_item) {\n-        match i.node {\n-            ast::view_item_use(ident, metas, _) => {\n-                let name_items =\n-                    attr::find_meta_items_by_name(metas, ~\"name\");\n-                let m = if name_items.is_empty() {\n-                    metas + ~[attr::mk_name_value_item_str(\n-                        ~\"name\", *ps.interner.get(ident))]\n-                } else {\n-                    metas\n-                };\n-                let mut attr_name = ident;\n-                let mut attr_vers = ~\"\";\n-                let mut attr_from = ~\"\";\n-\n-              for m.each |item| {\n-                    match attr::get_meta_item_value_str(*item) {\n-                        Some(value) => {\n-                            let name = attr::get_meta_item_name(*item);\n-\n-                            match name {\n-                                ~\"vers\" => attr_vers = value,\n-                                ~\"from\" => attr_from = value,\n-                                _ => ()\n-                            }\n-                        }\n-                        None => ()\n-                    }\n-                }\n-\n-                let query = if !str::is_empty(attr_from) {\n-                    attr_from\n-                } else {\n-                    if !str::is_empty(attr_vers) {\n-                        ps.interner.get(attr_name) + ~\"@\" + attr_vers\n-                    } else { *ps.interner.get(attr_name) }\n-                };\n-\n-                match *ps.interner.get(attr_name) {\n-                    ~\"std\" | ~\"core\" => (),\n-                    _ => e.deps.push(query)\n-                }\n-            }\n-            _ => ()\n-        }\n-    }\n-    fn goto_item(_e: env, _i: @ast::item) {\n-    }\n-\n-    let e = @{\n-        mut deps: ~[]\n-    };\n-    let v = visit::mk_simple_visitor(@{\n-        visit_view_item: |a| goto_view_item(sess, e, a),\n-        visit_item: |a| goto_item(e, a),\n-        .. *visit::default_simple_visitor()\n-    });\n-\n-    visit::visit_crate(*c, (), v);\n-\n-    let deps = copy e.deps;\n-\n-    match (name, vers, uuid) {\n-        (Some(name0), Some(vers0), Some(uuid0)) => {\n-            Some(Crate {\n-                name: name0,\n-                vers: vers0,\n-                uuid: uuid0,\n-                desc: desc,\n-                sigs: sigs,\n-                crate_type: crate_type,\n-                deps: deps })\n-        }\n-        _ => return None\n-    }\n-}\n-\n-fn print(s: ~str) {\n-    io::stdout().write_line(s);\n-}\n-\n-fn rest(s: ~str, start: uint) -> ~str {\n-    if (start >= str::len(s)) {\n-        ~\"\"\n-    } else {\n-        str::slice(s, start, str::len(s))\n-    }\n-}\n-\n-fn need_dir(s: &Path) {\n-    if os::path_is_dir(s) { return; }\n-    if !os::make_dir(s, 493_i32 /* oct: 755 */) {\n-        fail fmt!(\"can't make_dir %s\", s.to_str());\n-    }\n-}\n-\n-fn valid_pkg_name(s: &str) -> bool {\n-    fn is_valid_digit(+c: char) -> bool {\n-        ('0' <= c && c <= '9') ||\n-        ('a' <= c && c <= 'z') ||\n-        ('A' <= c && c <= 'Z') ||\n-        c == '-' ||\n-        c == '_'\n-    }\n-\n-    s.all(is_valid_digit)\n-}\n-\n-fn parse_source(name: ~str, j: &json::Json) -> @Source {\n-    if !valid_pkg_name(name) {\n-        fail fmt!(\"'%s' is an invalid source name\", name);\n-    }\n-\n-    match *j {\n-        json::Object(j) => {\n-            let mut url = match j.find(&~\"url\") {\n-                Some(json::String(u)) => u,\n-                _ => fail ~\"needed 'url' field in source\"\n-            };\n-            let method = match j.find(&~\"method\") {\n-                Some(json::String(u)) => u,\n-                _ => assume_source_method(url)\n-            };\n-            let key = match j.find(&~\"key\") {\n-                Some(json::String(u)) => Some(u),\n-                _ => None\n-            };\n-            let keyfp = match j.find(&~\"keyfp\") {\n-                Some(json::String(u)) => Some(u),\n-                _ => None\n-            };\n-            if method == ~\"file\" {\n-                url = os::make_absolute(&Path(url)).to_str();\n-            }\n-            return @Source {\n-                name: name,\n-                mut url: url,\n-                mut method: method,\n-                mut key: key,\n-                mut keyfp: keyfp,\n-                packages: DVec() };\n-        }\n-        _ => fail ~\"needed dict value in source\"\n-    };\n-}\n-\n-fn try_parse_sources(filename: &Path, sources: map::HashMap<~str, @Source>) {\n-    if !os::path_exists(filename)  { return; }\n-    let c = io::read_whole_file_str(filename);\n-    match json::from_str(c.get()) {\n-        Ok(json::Object(j)) => {\n-            for j.each |k, v| {\n-                sources.insert(copy *k, parse_source(*k, v));\n-                debug!(\"source: %s\", *k);\n-            }\n-        }\n-        Ok(_) => fail ~\"malformed sources.json\",\n-        Err(e) => fail fmt!(\"%s:%s\", filename.to_str(), e.to_str())\n-    }\n-}\n-\n-fn load_one_source_package(src: @Source, p: &json::Object) {\n-    let name = match p.find(&~\"name\") {\n-        Some(json::String(n)) => {\n-            if !valid_pkg_name(n) {\n-                warn(~\"malformed source json: \"\n-                     + src.name + ~\", '\" + n + ~\"'\"+\n-                     ~\" is an invalid name (alphanumeric, underscores and\" +\n-                     ~\" dashes only)\");\n-                return;\n-            }\n-            n\n-        }\n-        _ => {\n-            warn(~\"malformed source json: \" + src.name + ~\" (missing name)\");\n-            return;\n-        }\n-    };\n-\n-    let uuid = match p.find(&~\"uuid\") {\n-        Some(json::String(n)) => {\n-            if !is_uuid(n) {\n-                warn(~\"malformed source json: \"\n-                     + src.name + ~\", '\" + n + ~\"'\"+\n-                     ~\" is an invalid uuid\");\n-                return;\n-            }\n-            n\n-        }\n-        _ => {\n-            warn(~\"malformed source json: \" + src.name + ~\" (missing uuid)\");\n-            return;\n-        }\n-    };\n-\n-    let url = match p.find(&~\"url\") {\n-        Some(json::String(n)) => n,\n-        _ => {\n-            warn(~\"malformed source json: \" + src.name + ~\" (missing url)\");\n-            return;\n-        }\n-    };\n-\n-    let method = match p.find(&~\"method\") {\n-        Some(json::String(n)) => n,\n-        _ => {\n-            warn(~\"malformed source json: \"\n-                 + src.name + ~\" (missing method)\");\n-            return;\n-        }\n-    };\n-\n-    let reference = match p.find(&~\"ref\") {\n-        Some(json::String(n)) => Some(n),\n-        _ => None\n-    };\n-\n-    let mut tags = ~[];\n-    match p.find(&~\"tags\") {\n-        Some(json::List(js)) => {\n-          for js.each |j| {\n-                match *j {\n-                    json::String(ref j) => tags.grow(1u, j),\n-                    _ => ()\n-                }\n-            }\n-        }\n-        _ => ()\n-    }\n-\n-    let description = match p.find(&~\"description\") {\n-        Some(json::String(n)) => n,\n-        _ => {\n-            warn(~\"malformed source json: \" + src.name\n-                 + ~\" (missing description)\");\n-            return;\n-        }\n-    };\n-\n-    let newpkg = Package {\n-        name: name,\n-        uuid: uuid,\n-        url: url,\n-        method: method,\n-        description: description,\n-        reference: reference,\n-        tags: tags,\n-        versions: ~[]\n-    };\n-\n-    match src.packages.position(|pkg| pkg.uuid == uuid) {\n-        Some(idx) => {\n-            src.packages.set_elt(idx, newpkg);\n-            log(debug, ~\"  updated package: \" + src.name + ~\"/\" + name);\n-        }\n-        None => {\n-            src.packages.push(newpkg);\n-        }\n-    }\n-\n-    log(debug, ~\"  loaded package: \" + src.name + ~\"/\" + name);\n-}\n-\n-fn load_source_info(c: &Cargo, src: @Source) {\n-    let dir = c.sourcedir.push(src.name);\n-    let srcfile = dir.push(\"source.json\");\n-    if !os::path_exists(&srcfile) { return; }\n-    let srcstr = io::read_whole_file_str(&srcfile);\n-    match json::from_str(srcstr.get()) {\n-        Ok(ref json @ json::Object(_)) => {\n-            let o = parse_source(src.name, json);\n-\n-            src.key = o.key;\n-            src.keyfp = o.keyfp;\n-        }\n-        Ok(_) => {\n-            warn(~\"malformed source.json: \" + src.name +\n-                 ~\"(source info is not a dict)\");\n-        }\n-        Err(e) => {\n-            warn(fmt!(\"%s:%s\", src.name, e.to_str()));\n-        }\n-    };\n-}\n-fn load_source_packages(c: &Cargo, src: @Source) {\n-    log(debug, ~\"loading source: \" + src.name);\n-    let dir = c.sourcedir.push(src.name);\n-    let pkgfile = dir.push(\"packages.json\");\n-    if !os::path_exists(&pkgfile) { return; }\n-    let pkgstr = io::read_whole_file_str(&pkgfile);\n-    match json::from_str(pkgstr.get()) {\n-        Ok(json::List(js)) => {\n-          for js.each |j| {\n-                match *j {\n-                    json::Object(p) => {\n-                        load_one_source_package(src, p);\n-                    }\n-                    _ => {\n-                        warn(~\"malformed source json: \" + src.name +\n-                             ~\" (non-dict pkg)\");\n-                    }\n-                }\n-            }\n-        }\n-        Ok(_) => {\n-            warn(~\"malformed packages.json: \" + src.name +\n-                 ~\"(packages is not a list)\");\n-        }\n-        Err(e) => {\n-            warn(fmt!(\"%s:%s\", src.name, e.to_str()));\n-        }\n-    };\n-}\n-\n-fn build_cargo_options(argv: ~[~str]) -> Options {\n-    let matches = &match getopts::getopts(argv, opts()) {\n-        result::Ok(m) => m,\n-        result::Err(f) => {\n-            fail fmt!(\"%s\", getopts::fail_str(f));\n-        }\n-    };\n-\n-    let test = opt_present(matches, ~\"test\");\n-    let G    = opt_present(matches, ~\"G\");\n-    let g    = opt_present(matches, ~\"g\");\n-    let help = opt_present(matches, ~\"h\") || opt_present(matches, ~\"help\");\n-    let len  = vec::len(matches.free);\n-\n-    let is_install = len > 1u && matches.free[1] == ~\"install\";\n-    let is_uninstall = len > 1u && matches.free[1] == ~\"uninstall\";\n-\n-    if G && g { fail ~\"-G and -g both provided\"; }\n-\n-    if !is_install && !is_uninstall && (g || G) {\n-        fail ~\"-g and -G are only valid for `install` and `uninstall|rm`\";\n-    }\n-\n-    let mode =\n-        if (!is_install && !is_uninstall) || g { UserMode }\n-        else if G { SystemMode }\n-        else { LocalMode };\n-\n-    Options {test: test, mode: mode, free: matches.free, help: help}\n-}\n-\n-fn configure(opts: Options) -> Cargo {\n-    let home = match get_cargo_root() {\n-        Ok(home) => home,\n-        Err(_err) => get_cargo_sysroot().get()\n-    };\n-\n-    let get_cargo_dir = match opts.mode {\n-        SystemMode => get_cargo_sysroot,\n-        UserMode => get_cargo_root,\n-        LocalMode => get_cargo_root_nearest\n-    };\n-\n-    let p = get_cargo_dir().get();\n-\n-    let sources = HashMap();\n-    try_parse_sources(&home.push(\"sources.json\"), sources);\n-    try_parse_sources(&home.push(\"local-sources.json\"), sources);\n-\n-    let dep_cache = HashMap();\n-\n-    let mut c = Cargo {\n-        pgp: pgp::supported(),\n-        root: home,\n-        installdir: p,\n-        bindir: p.push(\"bin\"),\n-        libdir: p.push(\"lib\"),\n-        workdir: p.push(\"work\"),\n-        sourcedir: home.push(\"sources\"),\n-        sources: sources,\n-        mut current_install: ~\"\",\n-        dep_cache: dep_cache,\n-        opts: opts\n-    };\n-\n-    need_dir(&c.root);\n-    need_dir(&c.installdir);\n-    need_dir(&c.sourcedir);\n-    need_dir(&c.workdir);\n-    need_dir(&c.libdir);\n-    need_dir(&c.bindir);\n-\n-    for sources.each_key |k| {\n-        let mut s = sources.get(k);\n-        load_source_packages(&c, s);\n-        sources.insert(k, s);\n-    }\n-\n-    if c.pgp {\n-        pgp::init(&c.root);\n-    } else {\n-        warn(~\"command `gpg` was not found\");\n-        warn(~\"you have to install gpg from source \" +\n-             ~\" or package manager to get it to work correctly\");\n-    }\n-\n-    move c\n-}\n-\n-fn for_each_package(c: &Cargo, b: fn(s: @Source, p: &Package)) {\n-    for c.sources.each_value |v| {\n-        for v.packages.each |p| {\n-            b(v, p);\n-        }\n-    }\n-}\n-\n-// Runs all programs in directory <buildpath>\n-fn run_programs(buildpath: &Path) {\n-    let newv = os::list_dir_path(buildpath);\n-    for newv.each |ct| {\n-        run::run_program(ct.to_str(), ~[]);\n-    }\n-}\n-\n-// Runs rustc in <path + subdir> with the given flags\n-// and returns <patho + subdir>\n-fn run_in_buildpath(what: &str, path: &Path, subdir: &Path, cf: &Path,\n-                    extra_flags: ~[~str]) -> Option<Path> {\n-    let buildpath = path.push_rel(subdir);\n-    need_dir(&buildpath);\n-    debug!(\"%s: %s -> %s\", what, cf.to_str(), buildpath.to_str());\n-    let p = run::program_output(rustc_sysroot(),\n-                                ~[~\"--out-dir\",\n-                                  buildpath.to_str(),\n-                                  cf.to_str()] + extra_flags);\n-    if p.status != 0 {\n-        error(fmt!(\"rustc failed: %d\\n%s\\n%s\", p.status, p.err, p.out));\n-        return None;\n-    }\n-    Some(buildpath)\n-}\n-\n-fn test_one_crate(_c: &Cargo, path: &Path, cf: &Path) {\n-    let buildpath = match run_in_buildpath(~\"testing\", path,\n-                                           &Path(\"test\"),\n-                                           cf,\n-                                           ~[ ~\"--test\"]) {\n-      None => return,\n-    Some(bp) => bp\n-  };\n-  run_programs(&buildpath);\n-}\n-\n-fn install_one_crate(c: &Cargo, path: &Path, cf: &Path) {\n-    let buildpath = match run_in_buildpath(~\"installing\", path,\n-                                           &Path(\"build\"),\n-                                           cf, ~[]) {\n-      None => return,\n-      Some(bp) => bp\n-    };\n-    let newv = os::list_dir_path(&buildpath);\n-    let exec_suffix = os::exe_suffix();\n-    for newv.each |ct| {\n-        if (exec_suffix != ~\"\" && str::ends_with(ct.to_str(),\n-                                                 exec_suffix)) ||\n-            (exec_suffix == ~\"\" &&\n-             !str::starts_with(ct.filename().get(),\n-                               ~\"lib\")) {\n-            debug!(\"  bin: %s\", ct.to_str());\n-            install_to_dir(*ct, &c.bindir);\n-            if c.opts.mode == SystemMode {\n-                // FIXME (#2662): Put this file in PATH / symlink it so it can\n-                // be used as a generic executable\n-                // `cargo install -G rustray` and `rustray file.obj`\n-            }\n-        } else {\n-            debug!(\"  lib: %s\", ct.to_str());\n-            install_to_dir(*ct, &c.libdir);\n-        }\n-    }\n-}\n-\n-\n-fn rustc_sysroot() -> ~str {\n-    match os::self_exe_path() {\n-        Some(path) => {\n-            let rustc = path.push_many([~\"..\", ~\"bin\", ~\"rustc\"]);\n-            debug!(\"  rustc: %s\", rustc.to_str());\n-            rustc.to_str()\n-        }\n-        None => ~\"rustc\"\n-    }\n-}\n-\n-fn install_source(c: &Cargo, path: &Path) {\n-    debug!(\"source: %s\", path.to_str());\n-    os::change_dir(path);\n-\n-    let mut cratefiles = ~[];\n-    for os::walk_dir(&Path(\".\")) |p| {\n-        if p.filetype() == Some(~\".rc\") {\n-            cratefiles.push(*p);\n-        }\n-    }\n-\n-    if vec::is_empty(cratefiles) {\n-        fail ~\"this doesn't look like a rust package (no .rc files)\";\n-    }\n-\n-    for cratefiles.each |cf| {\n-        match load_crate(cf) {\n-            None => loop,\n-            Some(crate) => {\n-              for crate.deps.each |query| {\n-                    // FIXME (#1356): handle cyclic dependencies\n-                    // (n.b. #1356 says \"Cyclic dependency is an error\n-                    // condition\")\n-\n-                    let wd = get_temp_workdir(c);\n-                    install_query(c, &wd, *query);\n-                }\n-\n-                os::change_dir(path);\n-\n-                if c.opts.test {\n-                    test_one_crate(c, path, cf);\n-                }\n-                install_one_crate(c, path, cf);\n-            }\n-        }\n-    }\n-}\n-\n-fn install_git(c: &Cargo, wd: &Path, url: ~str, reference: Option<~str>) {\n-    run::program_output(~\"git\", ~[~\"clone\", url, wd.to_str()]);\n-    if reference.is_some() {\n-        let r = reference.get();\n-        os::change_dir(wd);\n-        run::run_program(~\"git\", ~[~\"checkout\", r]);\n-    }\n-\n-    install_source(c, wd);\n-}\n-\n-fn install_curl(c: &Cargo, wd: &Path, url: ~str) {\n-    let tarpath = wd.push(\"pkg.tar\");\n-    let p = run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\",\n-                                         tarpath.to_str(), url]);\n-    if p.status != 0 {\n-        fail fmt!(\"fetch of %s failed: %s\", url, p.err);\n-    }\n-    run::run_program(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n-                               ~\"-C\", wd.to_str(),\n-                               ~\"-f\", tarpath.to_str()]);\n-    install_source(c, wd);\n-}\n-\n-fn install_file(c: &Cargo, wd: &Path, path: &Path) {\n-    run::program_output(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n-                                  ~\"-C\", wd.to_str(),\n-                                  ~\"-f\", path.to_str()]);\n-    install_source(c, wd);\n-}\n-\n-fn install_package(c: &Cargo, src: ~str, wd: &Path, pkg: Package) {\n-    let url = copy pkg.url;\n-    let method = match pkg.method {\n-        ~\"git\" => ~\"git\",\n-        ~\"file\" => ~\"file\",\n-        _ => ~\"curl\"\n-    };\n-\n-    info(fmt!(\"installing %s/%s via %s...\", src, pkg.name, method));\n-\n-    match method {\n-        ~\"git\" => install_git(c, wd, url, copy pkg.reference),\n-        ~\"file\" => install_file(c, wd, &Path(url)),\n-        ~\"curl\" => install_curl(c, wd, url),\n-        _ => ()\n-    }\n-}\n-\n-fn cargo_suggestion(c: &Cargo, fallback: fn())\n-{\n-    if c.sources.size() == 0u {\n-        error(~\"no sources defined - you may wish to run \" +\n-              ~\"`cargo init`\");\n-        return;\n-    }\n-    fallback();\n-}\n-\n-fn install_uuid(c: &Cargo, wd: &Path, uuid: ~str) {\n-    let mut ps = ~[];\n-    for_each_package(c, |s, p| {\n-        if p.uuid == uuid {\n-            vec::push(&mut ps, (s.name, copy *p));\n-        }\n-    });\n-    if vec::len(ps) == 1u {\n-        let (sname, p) = copy ps[0];\n-        install_package(c, sname, wd, p);\n-        return;\n-    } else if vec::len(ps) == 0u {\n-        cargo_suggestion(c, || {\n-            error(~\"can't find package: \" + uuid);\n-        });\n-        return;\n-    }\n-    error(~\"found multiple packages:\");\n-    for ps.each |elt| {\n-        let (sname,p) = copy *elt;\n-        info(~\"  \" + sname + ~\"/\" + p.uuid + ~\" (\" + p.name + ~\")\");\n-    }\n-}\n-\n-fn install_named(c: &Cargo, wd: &Path, name: ~str) {\n-    let mut ps = ~[];\n-    for_each_package(c, |s, p| {\n-        if p.name == name {\n-            vec::push(&mut ps, (s.name, copy *p));\n-        }\n-    });\n-    if vec::len(ps) == 1u {\n-        let (sname, p) = copy ps[0];\n-        install_package(c, sname, wd, p);\n-        return;\n-    } else if vec::len(ps) == 0u {\n-        cargo_suggestion(c, || {\n-            error(~\"can't find package: \" + name);\n-        });\n-        return;\n-    }\n-    error(~\"found multiple packages:\");\n-    for ps.each |elt| {\n-        let (sname,p) = copy *elt;\n-        info(~\"  \" + sname + ~\"/\" + p.uuid + ~\" (\" + p.name + ~\")\");\n-    }\n-}\n-\n-fn install_uuid_specific(c: &Cargo, wd: &Path, src: ~str, uuid: ~str) {\n-    match c.sources.find(src) {\n-        Some(s) => {\n-            for s.packages.each |p| {\n-                if p.uuid == uuid {\n-                    install_package(c, src, wd, *p);\n-                    return;\n-                }\n-            }\n-        }\n-        _ => ()\n-    }\n-    error(~\"can't find package: \" + src + ~\"/\" + uuid);\n-}\n-\n-fn install_named_specific(c: &Cargo, wd: &Path, src: ~str, name: ~str) {\n-    match c.sources.find(src) {\n-        Some(s) => {\n-            for s.packages.each |p| {\n-                if p.name == name {\n-                    install_package(c, src, wd, *p);\n-                    return;\n-                }\n-            }\n-        }\n-        _ => ()\n-    }\n-    error(~\"can't find package: \" + src + ~\"/\" + name);\n-}\n-\n-fn cmd_uninstall(c: &Cargo) {\n-    if vec::len(c.opts.free) < 3u {\n-        cmd_usage();\n-        return;\n-    }\n-\n-    let lib = &c.libdir;\n-    let bin = &c.bindir;\n-    let target = c.opts.free[2u];\n-\n-    // FIXME (#2662): needs stronger pattern matching\n-    // FIXME (#2662): needs to uninstall from a specified location in a\n-    // cache instead of looking for it (binaries can be uninstalled by\n-    // name only)\n-\n-    fn try_uninstall(p: &Path) -> bool {\n-        if os::remove_file(p) {\n-            info(~\"uninstalled: '\" + p.to_str() + ~\"'\");\n-            true\n-        } else {\n-            error(~\"could not uninstall: '\" +\n-                  p.to_str() + ~\"'\");\n-            false\n-        }\n-    }\n-\n-    if is_uuid(target) {\n-        for os::list_dir(lib).each |file| {\n-            match str::find_str(*file, ~\"-\" + target + ~\"-\") {\n-              Some(_) => if !try_uninstall(&lib.push(*file)) { return },\n-              None => ()\n-            }\n-        }\n-        error(~\"can't find package with uuid: \" + target);\n-    } else {\n-        for os::list_dir(lib).each |file| {\n-            match str::find_str(*file, ~\"lib\" + target + ~\"-\") {\n-              Some(_) => if !try_uninstall(&lib.push(*file)) { return },\n-              None => ()\n-            }\n-        }\n-        for os::list_dir(bin).each |file| {\n-            match str::find_str(*file, target) {\n-              Some(_) => if !try_uninstall(&lib.push(*file)) { return },\n-              None => ()\n-            }\n-        }\n-\n-        error(~\"can't find package with name: \" + target);\n-    }\n-}\n-\n-fn install_query(c: &Cargo, wd: &Path, target: ~str) {\n-    match c.dep_cache.find(target) {\n-        Some(inst) => {\n-            if inst {\n-                return;\n-            }\n-        }\n-        None => ()\n-    }\n-\n-    c.dep_cache.insert(target, true);\n-\n-    if is_archive_path(target) {\n-        install_file(c, wd, &Path(target));\n-        return;\n-    } else if is_git_url(target) {\n-        let reference = if c.opts.free.len() >= 4u {\n-            Some(c.opts.free[3u])\n-        } else {\n-            None\n-        };\n-        install_git(c, wd, target, reference);\n-    } else if !valid_pkg_name(target) && has_archive_extension(target) {\n-        install_curl(c, wd, target);\n-        return;\n-    } else {\n-        let mut ps = copy target;\n-\n-        match str::find_char(ps, '/') {\n-            option::Some(idx) => {\n-                let source = str::slice(ps, 0u, idx);\n-                ps = str::slice(ps, idx + 1u, str::len(ps));\n-                if is_uuid(ps) {\n-                    install_uuid_specific(c, wd, source, ps);\n-                } else {\n-                    install_named_specific(c, wd, source, ps);\n-                }\n-            }\n-            option::None => {\n-                if is_uuid(ps) {\n-                    install_uuid(c, wd, ps);\n-                } else {\n-                    install_named(c, wd, ps);\n-                }\n-            }\n-        }\n-    }\n-\n-    // FIXME (#2662): This whole dep_cache and current_install thing is\n-    // a bit of a hack. It should be cleaned up in the future.\n-\n-    if target == c.current_install {\n-        for c.dep_cache.each |k, _v| {\n-            c.dep_cache.remove(k);\n-        }\n-\n-        c.current_install = ~\"\";\n-    }\n-}\n-\n-fn get_temp_workdir(c: &Cargo) -> Path {\n-    match tempfile::mkdtemp(&c.workdir, \"cargo\") {\n-      Some(wd) => wd,\n-      None => fail fmt!(\"needed temp dir: %s\",\n-                        c.workdir.to_str())\n-    }\n-}\n-\n-fn cmd_install(c: &Cargo) unsafe {\n-    let wd = get_temp_workdir(c);\n-\n-    if vec::len(c.opts.free) == 2u {\n-        let cwd = os::getcwd();\n-        let status = run::run_program(~\"cp\", ~[~\"-R\", cwd.to_str(),\n-                                               wd.to_str()]);\n-\n-        if status != 0 {\n-            fail fmt!(\"could not copy directory: %s\", cwd.to_str());\n-        }\n-\n-        install_source(c, &wd);\n-        return;\n-    }\n-\n-    sync(c);\n-\n-    let query = c.opts.free[2];\n-    c.current_install = query.to_str();\n-\n-    install_query(c, &wd, query);\n-}\n-\n-fn sync(c: &Cargo) {\n-    for c.sources.each_key |k| {\n-        let mut s = c.sources.get(k);\n-        sync_one(c, s);\n-        c.sources.insert(k, s);\n-    }\n-}\n-\n-fn sync_one_file(c: &Cargo, dir: &Path, src: @Source) -> bool {\n-    let name = src.name;\n-    let srcfile = dir.push(\"source.json.new\");\n-    let destsrcfile = dir.push(\"source.json\");\n-    let pkgfile = dir.push(\"packages.json.new\");\n-    let destpkgfile = dir.push(\"packages.json\");\n-    let keyfile = dir.push(\"key.gpg\");\n-    let srcsigfile = dir.push(\"source.json.sig\");\n-    let sigfile = dir.push(\"packages.json.sig\");\n-    let url = Path(src.url);\n-    let mut has_src_file = false;\n-\n-    if !os::copy_file(&url.push(\"packages.json\"), &pkgfile) {\n-        error(fmt!(\"fetch for source %s (url %s) failed\",\n-                   name, url.to_str()));\n-        return false;\n-    }\n-\n-    if os::copy_file(&url.push(\"source.json\"), &srcfile) {\n-        has_src_file = false;\n-    }\n-\n-    os::copy_file(&url.push(\"source.json.sig\"), &srcsigfile);\n-    os::copy_file(&url.push(\"packages.json.sig\"), &sigfile);\n-\n-    match copy src.key {\n-        Some(u) => {\n-            let p = run::program_output(~\"curl\",\n-                                        ~[~\"-f\", ~\"-s\",\n-                                          ~\"-o\", keyfile.to_str(), u]);\n-            if p.status != 0 {\n-                error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n-                return false;\n-            }\n-            pgp::add(&c.root, &keyfile);\n-        }\n-        _ => ()\n-    }\n-    match (src.key, src.keyfp) {\n-        (Some(_), Some(f)) => {\n-            let r = pgp::verify(&c.root, &pkgfile, &sigfile);\n-\n-            if !r {\n-                error(fmt!(\"signature verification failed for source %s with \\\n-                            key %s\", name, f));\n-                return false;\n-            }\n-\n-            if has_src_file {\n-                let e = pgp::verify(&c.root, &srcfile, &srcsigfile);\n-\n-                if !e {\n-                    error(fmt!(\"signature verification failed for source %s \\\n-                                with key %s\", name, f));\n-                    return false;\n-                }\n-            }\n-        }\n-        _ => ()\n-    }\n-\n-    copy_warn(&pkgfile, &destpkgfile);\n-\n-    if has_src_file {\n-        copy_warn(&srcfile, &destsrcfile);\n-    }\n-\n-    os::remove_file(&keyfile);\n-    os::remove_file(&srcfile);\n-    os::remove_file(&srcsigfile);\n-    os::remove_file(&pkgfile);\n-    os::remove_file(&sigfile);\n-\n-    info(fmt!(\"synced source: %s\", name));\n-\n-    return true;\n-}\n-\n-fn sync_one_git(c: &Cargo, dir: &Path, src: @Source) -> bool {\n-    let name = src.name;\n-    let srcfile = dir.push(\"source.json\");\n-    let pkgfile = dir.push(\"packages.json\");\n-    let keyfile = dir.push(\"key.gpg\");\n-    let srcsigfile = dir.push(\"source.json.sig\");\n-    let sigfile = dir.push(\"packages.json.sig\");\n-    let url = src.url;\n-\n-    fn rollback(name: ~str, dir: &Path, insecure: bool) {\n-        fn msg(name: ~str, insecure: bool) {\n-            error(fmt!(\"could not rollback source: %s\", name));\n-\n-            if insecure {\n-                warn(~\"a past security check failed on source \" +\n-                     name + ~\" and rolling back the source failed -\"\n-                     + ~\" this source may be compromised\");\n-            }\n-        }\n-\n-        if !os::change_dir(dir) {\n-            msg(name, insecure);\n-        }\n-        else {\n-            let p = run::program_output(~\"git\", ~[~\"reset\", ~\"--hard\",\n-                                                ~\"HEAD@{1}\"]);\n-\n-            if p.status != 0 {\n-                msg(name, insecure);\n-            }\n-        }\n-    }\n-\n-    if !os::path_exists(&dir.push(\".git\")) {\n-        let p = run::program_output(~\"git\", ~[~\"clone\", url, dir.to_str()]);\n-\n-        if p.status != 0 {\n-            error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n-            return false;\n-        }\n-    }\n-    else {\n-        if !os::change_dir(dir) {\n-            error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n-            return false;\n-        }\n-\n-        let p = run::program_output(~\"git\", ~[~\"pull\"]);\n-\n-        if p.status != 0 {\n-            error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n-            return false;\n-        }\n-    }\n-\n-    let has_src_file = os::path_exists(&srcfile);\n-\n-    match copy src.key {\n-        Some(u) => {\n-            let p = run::program_output(~\"curl\",\n-                                        ~[~\"-f\", ~\"-s\",\n-                                          ~\"-o\", keyfile.to_str(), u]);\n-            if p.status != 0 {\n-                error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n-                rollback(name, dir, false);\n-                return false;\n-            }\n-            pgp::add(&c.root, &keyfile);\n-        }\n-        _ => ()\n-    }\n-    match (src.key, src.keyfp) {\n-        (Some(_), Some(f)) => {\n-            let r = pgp::verify(&c.root, &pkgfile, &sigfile);\n-\n-            if !r {\n-                error(fmt!(\"signature verification failed for source %s with \\\n-                            key %s\", name, f));\n-                rollback(name, dir, false);\n-                return false;\n-            }\n-\n-            if has_src_file {\n-                let e = pgp::verify(&c.root, &srcfile, &srcsigfile);\n-\n-                if !e {\n-                    error(fmt!(\"signature verification failed for source %s \\\n-                                with key %s\", name, f));\n-                    rollback(name, dir, false);\n-                    return false;\n-                }\n-            }\n-        }\n-        _ => ()\n-    }\n-\n-    os::remove_file(&keyfile);\n-\n-    info(fmt!(\"synced source: %s\", name));\n-\n-    return true;\n-}\n-\n-fn sync_one_curl(c: &Cargo, dir: &Path, src: @Source) -> bool {\n-    let name = src.name;\n-    let srcfile = dir.push(\"source.json.new\");\n-    let destsrcfile = dir.push(\"source.json\");\n-    let pkgfile = dir.push(\"packages.json.new\");\n-    let destpkgfile = dir.push(\"packages.json\");\n-    let keyfile = dir.push(\"key.gpg\");\n-    let srcsigfile = dir.push(\"source.json.sig\");\n-    let sigfile = dir.push(\"packages.json.sig\");\n-    let mut url = src.url;\n-    let smart = !str::ends_with(src.url, ~\"packages.json\");\n-    let mut has_src_file = false;\n-\n-    if smart {\n-        url += ~\"/packages.json\";\n-    }\n-\n-    let p = run::program_output(~\"curl\",\n-                                ~[~\"-f\", ~\"-s\",\n-                                  ~\"-o\", pkgfile.to_str(), url]);\n-\n-    if p.status != 0 {\n-        error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n-        return false;\n-    }\n-    if smart {\n-        url = src.url + ~\"/source.json\";\n-        let p =\n-            run::program_output(~\"curl\",\n-                                ~[~\"-f\", ~\"-s\",\n-                                  ~\"-o\", srcfile.to_str(), url]);\n-\n-        if p.status == 0 {\n-            has_src_file = true;\n-        }\n-    }\n-\n-    match copy src.key {\n-       Some(u) => {\n-            let p = run::program_output(~\"curl\",\n-                                        ~[~\"-f\", ~\"-s\",\n-                                          ~\"-o\", keyfile.to_str(), u]);\n-            if p.status != 0 {\n-                error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n-                return false;\n-            }\n-            pgp::add(&c.root, &keyfile);\n-        }\n-        _ => ()\n-    }\n-    match (src.key, src.keyfp) {\n-        (Some(_), Some(f)) => {\n-            if smart {\n-                url = src.url + ~\"/packages.json.sig\";\n-            }\n-            else {\n-                url = src.url + ~\".sig\";\n-            }\n-\n-            let mut p = run::program_output(~\"curl\",\n-                                            ~[~\"-f\", ~\"-s\", ~\"-o\",\n-                                              sigfile.to_str(), url]);\n-            if p.status != 0 {\n-                error(fmt!(\"fetch for source %s (sig %s) failed\", name, url));\n-                return false;\n-            }\n-\n-            let r = pgp::verify(&c.root, &pkgfile, &sigfile);\n-\n-            if !r {\n-                error(fmt!(\"signature verification failed for source %s with \\\n-                            key %s\", name, f));\n-                return false;\n-            }\n-\n-            if smart && has_src_file {\n-                url = src.url + ~\"/source.json.sig\";\n-\n-                p = run::program_output(~\"curl\",\n-                                        ~[~\"-f\", ~\"-s\", ~\"-o\",\n-                                          srcsigfile.to_str(), url]);\n-                if p.status != 0 {\n-                    error(fmt!(\"fetch for source %s (sig %s) failed\",\n-                          name, url));\n-                    return false;\n-                }\n-\n-                let e = pgp::verify(&c.root, &srcfile, &srcsigfile);\n-\n-                if !e {\n-                    error(~\"signature verification failed for \" +\n-                          ~\"source \" + name + ~\" with key \" + f);\n-                    return false;\n-                }\n-            }\n-        }\n-        _ => ()\n-    }\n-\n-    copy_warn(&pkgfile, &destpkgfile);\n-\n-    if smart && has_src_file {\n-        copy_warn(&srcfile, &destsrcfile);\n-    }\n-\n-    os::remove_file(&keyfile);\n-    os::remove_file(&srcfile);\n-    os::remove_file(&srcsigfile);\n-    os::remove_file(&pkgfile);\n-    os::remove_file(&sigfile);\n-\n-    info(fmt!(\"synced source: %s\", name));\n-\n-    return true;\n-}\n-\n-fn sync_one(c: &Cargo, src: @Source) {\n-    let name = src.name;\n-    let dir = c.sourcedir.push(name);\n-\n-    info(fmt!(\"syncing source: %s...\", name));\n-\n-    need_dir(&dir);\n-\n-    let result = match src.method {\n-        ~\"git\" => sync_one_git(c, &dir, src),\n-        ~\"file\" => sync_one_file(c, &dir, src),\n-        _ => sync_one_curl(c, &dir, src)\n-    };\n-\n-    if result {\n-        load_source_info(c, src);\n-        load_source_packages(c, src);\n-    }\n-}\n-\n-fn cmd_init(c: &Cargo) {\n-    let srcurl = ~\"http://www.rust-lang.org/cargo/sources.json\";\n-    let sigurl = ~\"http://www.rust-lang.org/cargo/sources.json.sig\";\n-\n-    let srcfile = c.root.push(\"sources.json.new\");\n-    let sigfile = c.root.push(\"sources.json.sig\");\n-    let destsrcfile = c.root.push(\"sources.json\");\n-\n-    let p =\n-        run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\",\n-                                       ~\"-o\", srcfile.to_str(), srcurl]);\n-    if p.status != 0 {\n-        error(fmt!(\"fetch of sources.json failed: %s\", p.out));\n-        return;\n-    }\n-\n-    let p =\n-        run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\",\n-                                       ~\"-o\", sigfile.to_str(), sigurl]);\n-    if p.status != 0 {\n-        error(fmt!(\"fetch of sources.json.sig failed: %s\", p.out));\n-        return;\n-    }\n-\n-    let r = pgp::verify(&c.root, &srcfile, &sigfile);\n-    if !r {\n-        error(fmt!(\"signature verification failed for '%s'\",\n-                   srcfile.to_str()));\n-        return;\n-    }\n-\n-    copy_warn(&srcfile, &destsrcfile);\n-    os::remove_file(&srcfile);\n-    os::remove_file(&sigfile);\n-\n-    info(fmt!(\"initialized .cargo in %s\", c.root.to_str()));\n-}\n-\n-fn print_pkg(s: @Source, p: &Package) {\n-    let mut m = s.name + ~\"/\" + p.name + ~\" (\" + p.uuid + ~\")\";\n-    if vec::len(p.tags) > 0u {\n-        m = m + ~\" [\" + str::connect(p.tags, ~\", \") + ~\"]\";\n-    }\n-    info(m);\n-    if p.description != ~\"\" {\n-        print(~\"   >> \" + p.description + ~\"\\n\")\n-    }\n-}\n-\n-fn print_source(s: @Source) {\n-    info(s.name + ~\" (\" + s.url + ~\")\");\n-\n-    let pks = sort::merge_sort(s.packages.get(), sys::shape_lt);\n-    let l = vec::len(pks);\n-\n-    print(io::with_str_writer(|writer| {\n-        let mut list = ~\"   >> \";\n-\n-        for vec::eachi(pks) |i, pk| {\n-            if str::len(list) > 78u {\n-                writer.write_line(list);\n-                list = ~\"   >> \";\n-            }\n-            list += pk.name + (if l - 1u == i { ~\"\" } else { ~\", \" });\n-        }\n-\n-        writer.write_line(list);\n-    }));\n-}\n-\n-fn cmd_list(c: &Cargo) {\n-    sync(c);\n-\n-    if vec::len(c.opts.free) >= 3u {\n-        let v = vec::view(c.opts.free, 2u, vec::len(c.opts.free));\n-        for vec::each(v) |name| {\n-            if !valid_pkg_name(*name) {\n-                error(fmt!(\"'%s' is an invalid source name\", *name));\n-            } else {\n-                match c.sources.find(*name) {\n-                    Some(source) => {\n-                        print_source(source);\n-                    }\n-                    None => {\n-                        error(fmt!(\"no such source: %s\", *name));\n-                    }\n-                }\n-            }\n-        }\n-    } else {\n-        for c.sources.each_value |v| {\n-            print_source(v);\n-        }\n-    }\n-}\n-\n-fn cmd_search(c: &Cargo) {\n-    if vec::len(c.opts.free) < 3u {\n-        cmd_usage();\n-        return;\n-    }\n-\n-    sync(c);\n-\n-    let mut n = 0;\n-    let name = c.opts.free[2];\n-    let tags = vec::slice(c.opts.free, 3u, vec::len(c.opts.free));\n-    for_each_package(c, |s, p| {\n-        if (str::contains(p.name, name) || name == ~\"*\") &&\n-            vec::all(tags, |t| vec::contains(p.tags, t) ) {\n-            print_pkg(s, p);\n-            n += 1;\n-        }\n-    });\n-    info(fmt!(\"found %d packages\", n));\n-}\n-\n-fn install_to_dir(srcfile: &Path, destdir: &Path) {\n-    let newfile = destdir.push(srcfile.filename().get());\n-\n-    let status = run::run_program(~\"cp\", ~[~\"-r\", srcfile.to_str(),\n-                                           newfile.to_str()]);\n-    if status == 0 {\n-        info(fmt!(\"installed: '%s'\", newfile.to_str()));\n-    } else {\n-        error(fmt!(\"could not install: '%s'\", newfile.to_str()));\n-    }\n-}\n-\n-fn dump_cache(c: &Cargo) {\n-    need_dir(&c.root);\n-\n-    let out = c.root.push(\"cache.json\");\n-    let _root = json::Object(~LinearMap());\n-\n-    if os::path_exists(&out) {\n-        copy_warn(&out, &c.root.push(\"cache.json.old\"));\n-    }\n-}\n-fn dump_sources(c: &Cargo) {\n-    if c.sources.size() < 1u {\n-        return;\n-    }\n-\n-    need_dir(&c.root);\n-\n-    let out = c.root.push(\"sources.json\");\n-\n-    if os::path_exists(&out) {\n-        copy_warn(&out, &c.root.push(\"sources.json.old\"));\n-    }\n-\n-    match io::buffered_file_writer(&out) {\n-        result::Ok(writer) => {\n-            let mut hash = ~LinearMap();\n-\n-            for c.sources.each |k, v| {\n-                let mut chash = ~LinearMap();\n-\n-                chash.insert(~\"url\", json::String(v.url));\n-                chash.insert(~\"method\", json::String(v.method));\n-\n-                match copy v.key {\n-                    Some(key) => {\n-                        chash.insert(~\"key\", json::String(copy key));\n-                    }\n-                    _ => ()\n-                }\n-                match copy v.keyfp {\n-                    Some(keyfp) => {\n-                        chash.insert(~\"keyfp\", json::String(copy keyfp));\n-                    }\n-                    _ => ()\n-                }\n-\n-                hash.insert(copy k, json::Object(move chash));\n-            }\n-\n-            json::to_writer(writer, &json::Object(move hash))\n-        }\n-        result::Err(e) => {\n-            error(fmt!(\"could not dump sources: %s\", e));\n-        }\n-    }\n-}\n-\n-fn copy_warn(srcfile: &Path, destfile: &Path) {\n-    if !os::copy_file(srcfile, destfile) {\n-        warn(fmt!(\"copying %s to %s failed\",\n-                  srcfile.to_str(), destfile.to_str()));\n-    }\n-}\n-\n-fn cmd_sources(c: &Cargo) {\n-    if vec::len(c.opts.free) < 3u {\n-        for c.sources.each_value |v| {\n-            info(fmt!(\"%s (%s) via %s\",\n-                      v.name, v.url, v.method));\n-        }\n-        return;\n-    }\n-\n-    let action = c.opts.free[2u];\n-\n-    match action {\n-        ~\"clear\" => {\n-          for c.sources.each_key |k| {\n-                c.sources.remove(k);\n-            }\n-\n-            info(~\"cleared sources\");\n-        }\n-        ~\"add\" => {\n-            if vec::len(c.opts.free) < 5u {\n-                cmd_usage();\n-                return;\n-            }\n-\n-            let name = c.opts.free[3u];\n-            let url = c.opts.free[4u];\n-\n-            if !valid_pkg_name(name) {\n-                error(fmt!(\"'%s' is an invalid source name\", name));\n-                return;\n-            }\n-\n-            if c.sources.contains_key(name) {\n-                error(fmt!(\"source already exists: %s\", name));\n-            } else {\n-                c.sources.insert(name, @Source {\n-                    name: name,\n-                    mut url: url,\n-                    mut method: assume_source_method(url),\n-                    mut key: None,\n-                    mut keyfp: None,\n-                    packages: DVec()\n-                });\n-                info(fmt!(\"added source: %s\", name));\n-            }\n-        }\n-        ~\"remove\" => {\n-            if vec::len(c.opts.free) < 4u {\n-                cmd_usage();\n-                return;\n-            }\n-\n-            let name = c.opts.free[3u];\n-\n-            if !valid_pkg_name(name) {\n-                error(fmt!(\"'%s' is an invalid source name\", name));\n-                return;\n-            }\n-\n-            if c.sources.contains_key(name) {\n-                c.sources.remove(name);\n-                info(fmt!(\"removed source: %s\", name));\n-            } else {\n-                error(fmt!(\"no such source: %s\", name));\n-            }\n-        }\n-        ~\"set-url\" => {\n-            if vec::len(c.opts.free) < 5u {\n-                cmd_usage();\n-                return;\n-            }\n-\n-            let name = c.opts.free[3u];\n-            let url = c.opts.free[4u];\n-\n-            if !valid_pkg_name(name) {\n-                error(fmt!(\"'%s' is an invalid source name\", name));\n-                return;\n-            }\n-\n-            match c.sources.find(name) {\n-                Some(source) => {\n-                    let old = copy source.url;\n-                    let method = assume_source_method(url);\n-\n-                    source.url = url;\n-                    source.method = method;\n-\n-                    c.sources.insert(name, source);\n-\n-                    info(fmt!(\"changed source url: '%s' to '%s'\", old, url));\n-                }\n-                None => {\n-                    error(fmt!(\"no such source: %s\", name));\n-                }\n-            }\n-        }\n-        ~\"set-method\" => {\n-            if vec::len(c.opts.free) < 5u {\n-                cmd_usage();\n-                return;\n-            }\n-\n-            let name = c.opts.free[3u];\n-            let method = c.opts.free[4u];\n-\n-            if !valid_pkg_name(name) {\n-                error(fmt!(\"'%s' is an invalid source name\", name));\n-                return;\n-            }\n-\n-            match c.sources.find(name) {\n-                Some(source) => {\n-                    let old = copy source.method;\n-\n-                    source.method = match method {\n-                        ~\"git\" => ~\"git\",\n-                        ~\"file\" => ~\"file\",\n-                        _ => ~\"curl\"\n-                    };\n-\n-                    c.sources.insert(name, source);\n-\n-                    info(fmt!(\"changed source method: '%s' to '%s'\", old,\n-                         method));\n-                }\n-                None => {\n-                    error(fmt!(\"no such source: %s\", name));\n-                }\n-            }\n-        }\n-        ~\"rename\" => {\n-            if vec::len(c.opts.free) < 5u {\n-                cmd_usage();\n-                return;\n-            }\n-\n-            let name = c.opts.free[3u];\n-            let newn = c.opts.free[4u];\n-\n-            if !valid_pkg_name(name) {\n-                error(fmt!(\"'%s' is an invalid source name\", name));\n-                return;\n-            }\n-            if !valid_pkg_name(newn) {\n-                error(fmt!(\"'%s' is an invalid source name\", newn));\n-                return;\n-            }\n-\n-            match c.sources.find(name) {\n-                Some(source) => {\n-                    c.sources.remove(name);\n-                    c.sources.insert(newn, source);\n-                    info(fmt!(\"renamed source: %s to %s\", name, newn));\n-                }\n-                None => {\n-                    error(fmt!(\"no such source: %s\", name));\n-                }\n-            }\n-        }\n-        _ => cmd_usage()\n-    }\n-}\n-\n-fn cmd_usage() {\n-    print(~\"Usage: cargo <cmd> [options] [args..]\n-e.g. cargo install <name>\n-\n-Where <cmd> is one of:\n-    init, install, list, search, sources,\n-    uninstall, usage\n-\n-Options:\n-\n-    -h, --help                  Display this message\n-    <cmd> -h, <cmd> --help      Display help for <cmd>\n-\");\n-}\n-\n-fn cmd_usage_init() {\n-    print(~\"cargo init\n-\n-Re-initialize cargo in ~/.cargo. Clears all sources and then adds the\n-default sources from <www.rust-lang.org/sources.json>.\");\n-}\n-\n-fn cmd_usage_install() {\n-    print(~\"cargo install\n-cargo install [source/]<name>[@version]\n-cargo install [source/]<uuid>[@version]\n-cargo install <git url> [ref]\n-cargo install <tarball url>\n-cargo install <tarball file>\n-\n-Options:\n-    --test      Run crate tests before installing\n-    -g          Install to the user level (~/.cargo/bin/ instead of\n-                locally in ./.cargo/bin/ by default)\n-    -G          Install to the system level (/usr/local/lib/cargo/bin/)\n-\n-Install a crate. If no arguments are supplied, it installs from\n-the current working directory. If a source is provided, only install\n-from that source, otherwise it installs from any source.\");\n-}\n-\n-fn cmd_usage_uninstall() {\n-    print(~\"cargo uninstall [source/]<name>[@version]\n-cargo uninstall [source/]<uuid>[@version]\n-cargo uninstall <meta-name>[@version]\n-cargo uninstall <meta-uuid>[@version]\n-\n-Options:\n-    -g          Remove from the user level (~/.cargo/bin/ instead of\n-                locally in ./.cargo/bin/ by default)\n-    -G          Remove from the system level (/usr/local/lib/cargo/bin/)\n-\n-Remove a crate. If a source is provided, only remove\n-from that source, otherwise it removes from any source.\n-If a crate was installed directly (git, tarball, etc.), you can remove\n-it by metadata.\");\n-}\n-\n-fn cmd_usage_list() {\n-    print(~\"cargo list [sources..]\n-\n-If no arguments are provided, list all sources and their packages.\n-If source names are provided, list those sources and their packages.\n-\");\n-}\n-\n-fn cmd_usage_search() {\n-    print(~\"cargo search <query | '*'> [tags..]\n-\n-Search packages.\");\n-}\n-\n-fn cmd_usage_sources() {\n-    print(~\"cargo sources\n-cargo sources add <name> <url>\n-cargo sources remove <name>\n-cargo sources rename <name> <new>\n-cargo sources set-url <name> <url>\n-cargo sources set-method <name> <method>\n-\n-If no arguments are supplied, list all sources (but not their packages).\n-\n-Commands:\n-    add             Add a source. The source method will be guessed\n-                    from the URL.\n-    remove          Remove a source.\n-    rename          Rename a source.\n-    set-url         Change the URL for a source.\n-    set-method      Change the method for a source.\");\n-}\n-\n-fn main() {\n-    let argv = os::args();\n-    let o = build_cargo_options(argv);\n-\n-    if vec::len(o.free) < 2u {\n-        cmd_usage();\n-        return;\n-    }\n-    if o.help {\n-        match o.free[1] {\n-            ~\"init\" => cmd_usage_init(),\n-            ~\"install\" => cmd_usage_install(),\n-            ~\"uninstall\" => cmd_usage_uninstall(),\n-            ~\"list\" => cmd_usage_list(),\n-            ~\"search\" => cmd_usage_search(),\n-            ~\"sources\" => cmd_usage_sources(),\n-            _ => cmd_usage()\n-        }\n-        return;\n-    }\n-    if o.free[1] == ~\"usage\" {\n-        cmd_usage();\n-        return;\n-    }\n-\n-    let mut c = configure(o);\n-    let home = c.root;\n-    let first_time = os::path_exists(&home.push(\"sources.json\"));\n-\n-    if !first_time && o.free[1] != ~\"init\" {\n-        cmd_init(&c);\n-\n-        // FIXME (#2662): shouldn't need to reconfigure\n-        c = configure(o);\n-    }\n-\n-    let c = &move c;\n-\n-    match o.free[1] {\n-        ~\"init\" => cmd_init(c),\n-        ~\"install\" => cmd_install(c),\n-        ~\"uninstall\" => cmd_uninstall(c),\n-        ~\"list\" => cmd_list(c),\n-        ~\"search\" => cmd_search(c),\n-        ~\"sources\" => cmd_sources(c),\n-        _ => cmd_usage()\n-    }\n-\n-    dump_cache(c);\n-    dump_sources(c);\n-}"}, {"sha": "644cc90ccf68c605a7a03a085769c9ca3f3dfb94", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -66,15 +66,7 @@ pub fn all_values(blk: fn(v: bool)) {\n pub pure fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n \n impl bool : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &bool) -> bool { self == (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &bool) -> bool { (*self) == (*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &bool) -> bool { self != (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &bool) -> bool { (*self) != (*other) }\n }\n "}, {"sha": "4b4890f770fcbd6b059fd777b8029c67a612aa8d", "filename": "src/libcore/box.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbox.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -28,38 +28,14 @@ pub pure fn ptr_eq<T>(a: @T, b: @T) -> bool {\n }\n \n impl<T:Eq> @const T : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &@const T) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &@const T) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &@const T) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &@const T) -> bool { *(*self) != *(*other) }\n }\n \n impl<T:Ord> @const T : Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: &@const T) -> bool { *self < *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &@const T) -> bool { *(*self) < *(*other) }\n-    #[cfg(stage0)]\n-    pure fn le(other: &@const T) -> bool { *self <= *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &@const T) -> bool { *(*self) <= *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ge(other: &@const T) -> bool { *self >= *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &@const T) -> bool { *(*self) >= *(*other) }\n-    #[cfg(stage0)]\n-    pure fn gt(other: &@const T) -> bool { *self > *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &@const T) -> bool { *(*self) > *(*other) }\n }\n "}, {"sha": "f1c67785aa07f6d1b16b7ebb8e5dd89025c6bbe6", "filename": "src/libcore/char.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -181,15 +181,7 @@ pub pure fn cmp(a: char, b: char) -> int {\n }\n \n impl char : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &char) -> bool { self == (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &char) -> bool { (*self) == (*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &char) -> bool { self != (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &char) -> bool { (*self) != (*other) }\n }\n "}, {"sha": "97f439d936b2bd7a5df76ba9cba8a45095c7ca7f", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -30,17 +30,6 @@ mod nounittest {\n      * default implementations.\n      */\n     #[lang=\"ord\"]\n-    #[cfg(stage0)]\n-    pub trait Ord {\n-        pure fn lt(other: &self) -> bool;\n-        pure fn le(other: &self) -> bool;\n-        pure fn ge(other: &self) -> bool;\n-        pure fn gt(other: &self) -> bool;\n-    }\n-\n-    #[lang=\"ord\"]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pub trait Ord {\n         pure fn lt(&self, other: &self) -> bool;\n         pure fn le(&self, other: &self) -> bool;\n@@ -58,15 +47,6 @@ mod nounittest {\n      * a default implementation.\n      */\n     #[lang=\"eq\"]\n-    #[cfg(stage0)]\n-    pub trait Eq {\n-        pure fn eq(other: &self) -> bool;\n-        pure fn ne(other: &self) -> bool;\n-    }\n-\n-    #[lang=\"eq\"]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pub trait Eq {\n         pure fn eq(&self, other: &self) -> bool;\n         pure fn ne(&self, other: &self) -> bool;\n@@ -81,31 +61,13 @@ mod nounittest {\n mod unittest {\n     #[legacy_exports];\n \n-    #[cfg(stage0)]\n-    pub trait Ord {\n-        pure fn lt(other: &self) -> bool;\n-        pure fn le(other: &self) -> bool;\n-        pure fn ge(other: &self) -> bool;\n-        pure fn gt(other: &self) -> bool;\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pub trait Ord {\n         pure fn lt(&self, other: &self) -> bool;\n         pure fn le(&self, other: &self) -> bool;\n         pure fn ge(&self, other: &self) -> bool;\n         pure fn gt(&self, other: &self) -> bool;\n     }\n \n-    #[cfg(stage0)]\n-    pub trait Eq {\n-        pure fn eq(other: &self) -> bool;\n-        pure fn ne(other: &self) -> bool;\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pub trait Eq {\n         pure fn eq(&self, other: &self) -> bool;\n         pure fn ne(&self, other: &self) -> bool;"}, {"sha": "9e8dc94cd84c99c367ffc86288db90ce01bb29b3", "filename": "src/libcore/core.rc", "status": "modified", "additions": 127, "deletions": 77, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -45,80 +45,54 @@ Implicitly, all crates behave as if they included the following prologue:\n // Built-in-type support modules\n \n /// Operations and constants for `int`\n-#[path = \"int-template\"]\n-pub mod int {\n-    pub use inst::{ pow };\n-    #[path = \"int.rs\"]\n-    pub mod inst;\n-}\n+#[path = \"int-template.rs\"]\n+#[merge = \"int-template/intb.rs\"]\n+pub mod int;\n \n /// Operations and constants for `i8`\n-#[path = \"int-template\"]\n-pub mod i8 {\n-    #[path = \"i8.rs\"]\n-    pub mod inst;\n-}\n+#[path = \"int-template.rs\"]\n+#[merge = \"int-template/i8b.rs\"]\n+pub mod i8;\n \n /// Operations and constants for `i16`\n-#[path = \"int-template\"]\n-pub mod i16 {\n-    #[path = \"i16.rs\"]\n-    pub mod inst;\n-}\n+#[path = \"int-template.rs\"]\n+#[merge = \"int-template/i16b.rs\"]\n+pub mod i16;\n \n /// Operations and constants for `i32`\n-#[path = \"int-template\"]\n-pub mod i32 {\n-    #[path = \"i32.rs\"]\n-    pub mod inst;\n-}\n+#[path = \"int-template.rs\"]\n+#[merge = \"int-template/i32b.rs\"]\n+pub mod i32;\n \n /// Operations and constants for `i64`\n-#[path = \"int-template\"]\n-pub mod i64 {\n-    #[path = \"i64.rs\"]\n-    pub mod inst;\n-}\n+#[path = \"int-template.rs\"]\n+#[merge = \"int-template/i64b.rs\"]\n+pub mod i64;\n \n /// Operations and constants for `uint`\n-#[path = \"uint-template\"]\n-pub mod uint {\n-    pub use inst::{\n-        div_ceil, div_round, div_floor, iterate,\n-        next_power_of_two\n-    };\n-    #[path = \"uint.rs\"]\n-    pub mod inst;\n-}\n+#[path = \"uint-template.rs\"]\n+#[merge = \"uint-template/uintb.rs\"]\n+pub mod uint;\n \n /// Operations and constants for `u8`\n-#[path = \"uint-template\"]\n-pub mod u8 {\n-    pub use inst::is_ascii;\n-    #[path = \"u8.rs\"]\n-    pub mod inst;\n-}\n+#[path = \"uint-template.rs\"]\n+#[merge = \"uint-template/u8b.rs\"]\n+pub mod u8;\n \n /// Operations and constants for `u16`\n-#[path = \"uint-template\"]\n-pub mod u16 {\n-    #[path = \"u16.rs\"]\n-    pub mod inst;\n-}\n+#[path = \"uint-template.rs\"]\n+#[merge = \"uint-template/u16b.rs\"]\n+pub mod u16;\n \n /// Operations and constants for `u32`\n-#[path = \"uint-template\"]\n-pub mod u32 {\n-    #[path = \"u32.rs\"]\n-    pub mod inst;\n-}\n+#[path = \"uint-template.rs\"]\n+#[merge = \"uint-template/u32b.rs\"]\n+pub mod u32;\n \n /// Operations and constants for `u64`\n-#[path = \"uint-template\"]\n-pub mod u64 {\n-    #[path = \"u64.rs\"]\n-    pub mod inst;\n-}\n+#[path = \"uint-template.rs\"]\n+#[merge = \"uint-template/u64b.rs\"]\n+pub mod u64;\n \n \n pub mod box;\n@@ -146,11 +120,9 @@ pub mod either;\n pub mod iter;\n pub mod logging;\n pub mod option;\n-#[path=\"iter-trait\"]\n-pub mod option_iter {\n-    #[path = \"option.rs\"]\n-    pub mod inst;\n-}\n+#[path=\"iter-trait.rs\"]\n+#[merge = \"iter-trait/optionb.rs\"]\n+pub mod option_iter;\n pub mod result;\n pub mod to_str;\n pub mod to_bytes;\n@@ -161,27 +133,19 @@ pub mod clone;\n // Data structure modules\n \n pub mod dvec;\n-#[path=\"iter-trait\"]\n-pub mod dvec_iter {\n-    #[path = \"dvec.rs\"]\n-    pub mod inst;\n-}\n+#[path=\"iter-trait.rs\"]\n+#[merge = \"iter-trait/dvecb.rs\"]\n+pub mod dvec_iter;\n pub mod dlist;\n-#[path=\"iter-trait\"]\n-pub mod dlist_iter {\n-    #[path =\"dlist.rs\"]\n-    pub mod inst;\n-}\n+#[path=\"iter-trait.rs\"]\n+#[merge = \"iter-trait/dlistb.rs\"]\n+pub mod dlist_iter;\n pub mod send_map;\n \n // Concurrency\n pub mod comm;\n-pub mod task {\n-    pub mod local_data;\n-    mod local_data_priv;\n-    pub mod spawn;\n-    pub mod rt;\n-}\n+#[merge = \"task/mod.rs\"]\n+pub mod task;\n pub mod pipes;\n \n // Runtime and language-primitive support\n@@ -219,6 +183,92 @@ mod unicode;\n mod cmath;\n mod stackwalk;\n \n+// Top-level, visible-everywhere definitions.\n+\n+// Export various ubiquitous types, constructors, methods.\n+\n+pub use option::{Some, None};\n+pub use Option = option::Option;\n+pub use result::{Result, Ok, Err};\n+\n+pub use Path = path::Path;\n+pub use GenericPath = path::GenericPath;\n+pub use WindowsPath = path::WindowsPath;\n+pub use PosixPath = path::PosixPath;\n+\n+pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};\n+pub use str::{StrSlice, Trimmable};\n+pub use vec::{ConstVector, CopyableVector, ImmutableVector};\n+pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n+pub use vec::{MutableVector, MutableCopyableVector};\n+pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n+pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n+pub use num::Num;\n+pub use ptr::Ptr;\n+pub use to_str::ToStr;\n+\n+// The following exports are the core operators and kinds\n+// The compiler has special knowlege of these so we must not duplicate them\n+// when compiling for testing\n+#[cfg(notest)]\n+pub use ops::{Const, Copy, Send, Owned};\n+#[cfg(notest)]\n+pub use ops::{Drop};\n+#[cfg(notest)]\n+pub use ops::{Add, Sub, Mul, Div, Modulo, Neg, BitAnd, BitOr, BitXor};\n+#[cfg(notest)]\n+pub use ops::{Shl, Shr, Index};\n+\n+#[cfg(test)]\n+extern mod coreops(name = \"core\", vers = \"0.5\");\n+\n+#[cfg(test)]\n+pub use coreops::ops::{Const, Copy, Send, Owned};\n+#[cfg(test)]\n+pub use coreops::ops::{Drop};\n+#[cfg(test)]\n+pub use coreops::ops::{Add, Sub, Mul, Div, Modulo, Neg, BitAnd, BitOr};\n+#[cfg(test)]\n+pub use coreops::ops::{BitXor};\n+#[cfg(test)]\n+pub use coreops::ops::{Shl, Shr, Index};\n+\n+#[cfg(notest)]\n+pub use clone::Clone;\n+#[cfg(test)]\n+pub use coreops::clone::Clone;\n+\n+// Export the log levels as global constants. Higher levels mean\n+// more-verbosity. Error is the bottom level, default logging level is\n+// warn-and-below.\n+\n+/// The error log level\n+pub const error : u32 = 1_u32;\n+/// The warning log level\n+pub const warn : u32 = 2_u32;\n+/// The info log level\n+pub const info : u32 = 3_u32;\n+/// The debug log level\n+pub const debug : u32 = 4_u32;\n+\n+// A curious inner-module that's not exported that contains the binding\n+// 'core' so that macro-expanded references to core::error and such\n+// can be resolved within libcore.\n+#[doc(hidden)] // FIXME #3538\n+mod core {\n+    pub const error : u32 = 1_u32;\n+    pub const warn : u32 = 2_u32;\n+    pub const info : u32 = 3_u32;\n+    pub const debug : u32 = 4_u32;\n+}\n+\n+// Similar to above. Some magic to make core testable.\n+#[cfg(test)]\n+mod std {\n+    extern mod std(vers = \"0.5\");\n+    pub use std::test;\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "c9157a8d2542fc0c55f6badbc06cf0c656ed990b", "filename": "src/libcore/core.rs", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,85 +0,0 @@\n-// Top-level, visible-everywhere definitions.\n-\n-// Export various ubiquitous types, constructors, methods.\n-\n-pub use option::{Some, None};\n-pub use Option = option::Option;\n-pub use result::{Result, Ok, Err};\n-\n-pub use Path = path::Path;\n-pub use GenericPath = path::GenericPath;\n-pub use WindowsPath = path::WindowsPath;\n-pub use PosixPath = path::PosixPath;\n-\n-pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};\n-pub use str::{StrSlice, Trimmable};\n-pub use vec::{ConstVector, CopyableVector, ImmutableVector};\n-pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n-pub use vec::{MutableVector, MutableCopyableVector};\n-pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n-pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n-pub use num::Num;\n-pub use ptr::Ptr;\n-pub use to_str::ToStr;\n-\n-// The following exports are the core operators and kinds\n-// The compiler has special knowlege of these so we must not duplicate them\n-// when compiling for testing\n-#[cfg(notest)]\n-pub use ops::{Const, Copy, Send, Owned};\n-#[cfg(notest)]\n-pub use ops::{Drop};\n-#[cfg(notest)]\n-pub use ops::{Add, Sub, Mul, Div, Modulo, Neg, BitAnd, BitOr, BitXor};\n-#[cfg(notest)]\n-pub use ops::{Shl, Shr, Index};\n-\n-#[cfg(test)]\n-extern mod coreops(name = \"core\", vers = \"0.5\");\n-\n-#[cfg(test)]\n-pub use coreops::ops::{Const, Copy, Send, Owned};\n-#[cfg(test)]\n-pub use coreops::ops::{Drop};\n-#[cfg(test)]\n-pub use coreops::ops::{Add, Sub, Mul, Div, Modulo, Neg, BitAnd, BitOr};\n-#[cfg(test)]\n-pub use coreops::ops::{BitXor};\n-#[cfg(test)]\n-pub use coreops::ops::{Shl, Shr, Index};\n-\n-#[cfg(notest)]\n-pub use clone::Clone;\n-#[cfg(test)]\n-pub use coreops::clone::Clone;\n-\n-// Export the log levels as global constants. Higher levels mean\n-// more-verbosity. Error is the bottom level, default logging level is\n-// warn-and-below.\n-\n-/// The error log level\n-pub const error : u32 = 1_u32;\n-/// The warning log level\n-pub const warn : u32 = 2_u32;\n-/// The info log level\n-pub const info : u32 = 3_u32;\n-/// The debug log level\n-pub const debug : u32 = 4_u32;\n-\n-// A curious inner-module that's not exported that contains the binding\n-// 'core' so that macro-expanded references to core::error and such\n-// can be resolved within libcore.\n-#[doc(hidden)] // FIXME #3538\n-mod core {\n-    pub const error : u32 = 1_u32;\n-    pub const warn : u32 = 2_u32;\n-    pub const info : u32 = 3_u32;\n-    pub const debug : u32 = 4_u32;\n-}\n-\n-// Similar to above. Some magic to make core testable.\n-#[cfg(test)]\n-mod std {\n-    extern mod std(vers = \"0.5\");\n-    pub use std::test;\n-}"}, {"sha": "844f98acb2667e3fc4dfc297fa37dafaf3be8414", "filename": "src/libcore/either.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -132,25 +132,6 @@ pub pure fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n }\n \n impl<T:Eq,U:Eq> Either<T,U> : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Either<T,U>) -> bool {\n-        match self {\n-            Left(ref a) => {\n-                match (*other) {\n-                    Left(ref b) => (*a).eq(b),\n-                    Right(_) => false\n-                }\n-            }\n-            Right(ref a) => {\n-                match (*other) {\n-                    Left(_) => false,\n-                    Right(ref b) => (*a).eq(b)\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Either<T,U>) -> bool {\n         match (*self) {\n             Left(ref a) => {\n@@ -167,10 +148,6 @@ impl<T:Eq,U:Eq> Either<T,U> : Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Either<T,U>) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Either<T,U>) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "eb985a272dff235ee01eb6d3828068b9d83b9721", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -438,21 +438,6 @@ pub mod rt {\n     pub enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n \n     pub impl PadMode : Eq {\n-        #[cfg(stage0)]\n-        pure fn eq(other: &PadMode) -> bool {\n-            match (self, (*other)) {\n-                (PadSigned, PadSigned) => true,\n-                (PadUnsigned, PadUnsigned) => true,\n-                (PadNozero, PadNozero) => true,\n-                (PadFloat, PadFloat) => true,\n-                (PadSigned, _) => false,\n-                (PadUnsigned, _) => false,\n-                (PadNozero, _) => false,\n-                (PadFloat, _) => false\n-            }\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn eq(&self, other: &PadMode) -> bool {\n             match ((*self), (*other)) {\n                 (PadSigned, PadSigned) => true,\n@@ -465,10 +450,6 @@ pub mod rt {\n                 (PadFloat, _) => false\n             }\n         }\n-        #[cfg(stage0)]\n-        pure fn ne(other: &PadMode) -> bool { !self.eq(other) }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn ne(&self, other: &PadMode) -> bool { !(*self).eq(other) }\n     }\n "}, {"sha": "a5740c71323cf3b877980952e6d7addb8c311212", "filename": "src/libcore/float.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -400,38 +400,14 @@ pub pure fn cos(x: float) -> float { f64::cos(x as f64) as float }\n pub pure fn tan(x: float) -> float { f64::tan(x as f64) as float }\n \n impl float : Eq {\n-    #[cfg(stage0)]\n-    pub pure fn eq(other: &float) -> bool { self == (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &float) -> bool { (*self) == (*other) }\n-    #[cfg(stage0)]\n-    pub pure fn ne(other: &float) -> bool { self != (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &float) -> bool { (*self) != (*other) }\n }\n \n impl float : Ord {\n-    #[cfg(stage0)]\n-    pub pure fn lt(other: &float) -> bool { self < (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &float) -> bool { (*self) < (*other) }\n-    #[cfg(stage0)]\n-    pub pure fn le(other: &float) -> bool { self <= (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &float) -> bool { (*self) <= (*other) }\n-    #[cfg(stage0)]\n-    pub pure fn ge(other: &float) -> bool { self >= (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &float) -> bool { (*self) >= (*other) }\n-    #[cfg(stage0)]\n-    pub pure fn gt(other: &float) -> bool { self > (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &float) -> bool { (*self) > (*other) }\n }\n "}, {"sha": "e1383ba5ac218f44a031a27fce54b00eff921276", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -55,38 +55,14 @@ pub pure fn abs(i: T) -> T {\n }\n \n impl T : Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: &T) -> bool { return self < (*other); }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &T) -> bool { return (*self) < (*other); }\n-    #[cfg(stage0)]\n-    pure fn le(other: &T) -> bool { return self <= (*other); }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &T) -> bool { return (*self) <= (*other); }\n-    #[cfg(stage0)]\n-    pure fn ge(other: &T) -> bool { return self >= (*other); }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &T) -> bool { return (*self) >= (*other); }\n-    #[cfg(stage0)]\n-    pure fn gt(other: &T) -> bool { return self > (*other); }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &T) -> bool { return (*self) > (*other); }\n }\n \n impl T : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &T) -> bool { return self == (*other); }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &T) -> bool { return (*self) == (*other); }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &T) -> bool { return self != (*other); }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &T) -> bool { return (*self) != (*other); }\n }\n "}, {"sha": "b24eb86e4ae169f9bd47d205c9afb71d64a28387", "filename": "src/libcore/int-template/i16b.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fint-template%2Fi16b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fint-template%2Fi16b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fi16b.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,4 @@\n+mod inst {\n+    pub type T = i16;\n+    pub const bits: uint = u16::bits;\n+}\n\\ No newline at end of file"}, {"sha": "5bfb8a6d01cca54566c891a326bb6df316953dd4", "filename": "src/libcore/int-template/i32b.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fint-template%2Fi32b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fint-template%2Fi32b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fi32b.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,4 @@\n+mod inst {\n+    pub type T = i32;\n+    pub const bits: uint = u32::bits;\n+}"}, {"sha": "86552b2ccedc62719d5eb112dd69d22043f83c7f", "filename": "src/libcore/int-template/i64b.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fint-template%2Fi64b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fint-template%2Fi64b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fi64b.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,4 @@\n+mod inst {\n+    pub type T = i64;\n+    pub const bits: uint = u64::bits;\n+}\n\\ No newline at end of file"}, {"sha": "2cf7ed2983fba36ff558c8bcb35e16ca31725e53", "filename": "src/libcore/int-template/i8b.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fint-template%2Fi8b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fint-template%2Fi8b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fi8b.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,4 @@\n+mod inst {\n+    pub type T = i8;\n+    pub const bits: uint = u8::bits;\n+}\n\\ No newline at end of file"}, {"sha": "c1f2ca944dd636505d7ecacca07fe5e4ba99c38f", "filename": "src/libcore/int-template/intb.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fint-template%2Fintb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fint-template%2Fintb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fintb.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,45 @@\n+pub use inst::pow;\n+\n+mod inst {\n+    pub type T = int;\n+    pub const bits: uint = uint::bits;\n+\n+    /// Returns `base` raised to the power of `exponent`\n+    pub fn pow(base: int, exponent: uint) -> int {\n+        if exponent == 0u {\n+            //Not mathemtically true if ~[base == 0]\n+            return 1;\n+        }\n+        if base     == 0  { return 0; }\n+        let mut my_pow  = exponent;\n+        let mut acc     = 1;\n+        let mut multiplier = base;\n+        while(my_pow > 0u) {\n+            if my_pow % 2u == 1u {\n+                acc *= multiplier;\n+            }\n+            my_pow     /= 2u;\n+            multiplier *= multiplier;\n+        }\n+        return acc;\n+    }\n+\n+    #[test]\n+    fn test_pow() {\n+        assert (pow(0, 0u) == 1);\n+        assert (pow(0, 1u) == 0);\n+        assert (pow(0, 2u) == 0);\n+        assert (pow(-1, 0u) == 1);\n+        assert (pow(1, 0u) == 1);\n+        assert (pow(-3, 2u) == 9);\n+        assert (pow(-3, 3u) == -27);\n+        assert (pow(4, 9u) == 262144);\n+    }\n+\n+    #[test]\n+    fn test_overflows() {\n+        assert (max_value > 0);\n+        assert (min_value <= 0);\n+        assert (min_value + max_value + 1 == 0);\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "aa2eccfb343d83164174e889ccdf728a3ae9ad30", "filename": "src/libcore/io.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -516,25 +516,12 @@ pub enum FileFlag { Append, Create, Truncate, NoFlag, }\n pub enum WriterType { Screen, File }\n \n pub impl WriterType : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &WriterType) -> bool {\n-        match (self, (*other)) {\n-            (Screen, Screen) | (File, File) => true,\n-            (Screen, _) | (File, _) => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &WriterType) -> bool {\n         match ((*self), (*other)) {\n             (Screen, Screen) | (File, File) => true,\n             (Screen, _) | (File, _) => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &WriterType) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &WriterType) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "2d782b1262b9228fc80175012fd0aeed84e76deb", "filename": "src/libcore/iter-trait/dlistb.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fiter-trait%2Fdlistb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fiter-trait%2Fdlistb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlistb.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,38 @@\n+mod inst {\n+    #[allow(non_camel_case_types)]\n+    pub type IMPL_T<A> = dlist::DList<A>;\n+\n+    /**\n+    * Iterates through the current contents.\n+    *\n+    * Attempts to access this dlist during iteration are allowed (to\n+    * allow for e.g. breadth-first search with in-place enqueues), but\n+    * removing the current node is forbidden.\n+    */\n+    pub pure fn EACH<A>(self: &IMPL_T<A>, f: fn(v: &A) -> bool) {\n+        let mut link = self.peek_n();\n+        while option::is_some(&link) {\n+            let nobe = option::get(link);\n+            assert nobe.linked;\n+            if !f(&nobe.data) { break; }\n+            // Check (weakly) that the user didn't do a remove.\n+            if self.size == 0 {\n+                fail ~\"The dlist became empty during iteration??\"\n+            }\n+            if !nobe.linked ||\n+                (!((nobe.prev.is_some()\n+                    || box::ptr_eq(*self.hd.expect(~\"headless dlist?\"),\n+                                   *nobe))\n+                   && (nobe.next.is_some()\n+                    || box::ptr_eq(*self.tl.expect(~\"tailless dlist?\"),\n+                                   *nobe)))) {\n+                fail ~\"Removing a dlist node during iteration is forbidden!\"\n+            }\n+            link = nobe.next_link();\n+        }\n+    }\n+\n+    pub pure fn SIZE_HINT<A>(self: &IMPL_T<A>) -> Option<uint> {\n+        Some(self.len())\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "b30c1372a2e2b0de3116c2477ae9ab198cb5a36a", "filename": "src/libcore/iter-trait/dvecb.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fiter-trait%2Fdvecb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fiter-trait%2Fdvecb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdvecb.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,22 @@\n+mod inst {\n+    #[allow(non_camel_case_types)]\n+    pub type IMPL_T<A> = dvec::DVec<A>;\n+\n+    /**\n+    * Iterates through the current contents.\n+    *\n+    * Attempts to access this dvec during iteration will fail.\n+    */\n+    pub pure fn EACH<A>(self: &IMPL_T<A>, f: fn(v: &A) -> bool) {\n+        unsafe {\n+            do self.swap |v| {\n+                v.each(f);\n+                move v\n+            }\n+        }\n+    }\n+\n+    pub pure fn SIZE_HINT<A>(self: &IMPL_T<A>) -> Option<uint> {\n+        Some(self.len())\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "680893eb95b3ab0976cbd43a99267221fab635c2", "filename": "src/libcore/iter-trait/optionb.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fiter-trait%2Foptionb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fiter-trait%2Foptionb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Foptionb.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,18 @@\n+mod inst {\n+    #[allow(non_camel_case_types)]\n+    pub type IMPL_T<A> = Option<A>;\n+\n+    pub pure fn EACH<A>(self: &IMPL_T<A>, f: fn(v: &A) -> bool) {\n+        match *self {\n+            None => (),\n+            Some(ref a) => { f(a); }\n+        }\n+    }\n+\n+    pub pure fn SIZE_HINT<A>(self: &IMPL_T<A>) -> Option<uint> {\n+        match *self {\n+            None => Some(0),\n+            Some(_) => Some(1)\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "e5fcc7e83eb6045d6d8ad7992a5011768a987c90", "filename": "src/libcore/option.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -301,26 +301,6 @@ impl<T: Copy> Option<T> {\n }\n \n impl<T: Eq> Option<T> : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Option<T>) -> bool {\n-        match self {\n-            None => {\n-                match (*other) {\n-                    None => true,\n-                    Some(_) => false\n-                }\n-            }\n-            Some(ref self_contents) => {\n-                match (*other) {\n-                    None => false,\n-                    Some(ref other_contents) =>\n-                        (*self_contents).eq(other_contents)\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Option<T>) -> bool {\n         match (*self) {\n             None => {\n@@ -338,10 +318,6 @@ impl<T: Eq> Option<T> : Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Option<T>) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Option<T>) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "aaee987b4bd73d68990d5a509a3d852a6db2c392", "filename": "src/libcore/owned.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fowned.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -7,38 +7,14 @@\n use cmp::{Eq, Ord};\n \n impl<T:Eq> ~const T : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &~const T) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &~const T) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &~const T) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &~const T) -> bool { *(*self) != *(*other) }\n }\n \n impl<T:Ord> ~const T : Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: &~const T) -> bool { *self < *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &~const T) -> bool { *(*self) < *(*other) }\n-    #[cfg(stage0)]\n-    pure fn le(other: &~const T) -> bool { *self <= *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &~const T) -> bool { *(*self) <= *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ge(other: &~const T) -> bool { *self >= *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &~const T) -> bool { *(*self) >= *(*other) }\n-    #[cfg(stage0)]\n-    pure fn gt(other: &~const T) -> bool { *self > *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &~const T) -> bool { *(*self) > *(*other) }\n }\n "}, {"sha": "f0fefee9d06d2471d2dbd2e7637454845b4e4b8b", "filename": "src/libcore/path.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -344,44 +344,20 @@ impl PosixPath : ToStr {\n }\n \n impl PosixPath : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &PosixPath) -> bool {\n-        return self.is_absolute == (*other).is_absolute &&\n-            self.components == (*other).components;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &PosixPath) -> bool {\n         return (*self).is_absolute == (*other).is_absolute &&\n             (*self).components == (*other).components;\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &PosixPath) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &PosixPath) -> bool { !(*self).eq(other) }\n }\n \n impl WindowsPath : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &WindowsPath) -> bool {\n-        return self.host == (*other).host &&\n-            self.device == (*other).device &&\n-            self.is_absolute == (*other).is_absolute &&\n-            self.components == (*other).components;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &WindowsPath) -> bool {\n         return (*self).host == (*other).host &&\n             (*self).device == (*other).device &&\n             (*self).is_absolute == (*other).is_absolute &&\n             (*self).components == (*other).components;\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &WindowsPath) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &WindowsPath) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "9a6f05fe4051931c33e3d3a86b140c249c9e55ba", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -98,19 +98,9 @@ enum State {\n }\n \n impl State : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &State) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &State) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &State) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &State) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "d1566735a3f6cb251faf9d578644c342a3d5ba5a", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -208,75 +208,31 @@ impl<T> *mut T: Ptr<T> {\n \n // Equality for pointers\n impl<T> *const T : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &*const T) -> bool unsafe {\n-        let a: uint = cast::reinterpret_cast(&self);\n-        let b: uint = cast::reinterpret_cast(&(*other));\n-        return a == b;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&(*self));\n         let b: uint = cast::reinterpret_cast(&(*other));\n         return a == b;\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &*const T) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &*const T) -> bool { !(*self).eq(other) }\n }\n \n // Comparison for pointers\n impl<T> *const T : Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: &*const T) -> bool unsafe {\n-        let a: uint = cast::reinterpret_cast(&self);\n-        let b: uint = cast::reinterpret_cast(&(*other));\n-        return a < b;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&(*self));\n         let b: uint = cast::reinterpret_cast(&(*other));\n         return a < b;\n     }\n-    #[cfg(stage0)]\n-    pure fn le(other: &*const T) -> bool unsafe {\n-        let a: uint = cast::reinterpret_cast(&self);\n-        let b: uint = cast::reinterpret_cast(&(*other));\n-        return a <= b;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&(*self));\n         let b: uint = cast::reinterpret_cast(&(*other));\n         return a <= b;\n     }\n-    #[cfg(stage0)]\n-    pure fn ge(other: &*const T) -> bool unsafe {\n-        let a: uint = cast::reinterpret_cast(&self);\n-        let b: uint = cast::reinterpret_cast(&(*other));\n-        return a >= b;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&(*self));\n         let b: uint = cast::reinterpret_cast(&(*other));\n         return a >= b;\n     }\n-    #[cfg(stage0)]\n-    pure fn gt(other: &*const T) -> bool unsafe {\n-        let a: uint = cast::reinterpret_cast(&self);\n-        let b: uint = cast::reinterpret_cast(&(*other));\n-        return a > b;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&(*self));\n         let b: uint = cast::reinterpret_cast(&(*other));\n@@ -286,49 +242,25 @@ impl<T> *const T : Ord {\n \n // Equality for region pointers\n impl<T:Eq> &const T : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: & &self/const T) -> bool { return *self == *(*other); }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: & &self/const T) -> bool {\n         return *(*self) == *(*other);\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: & &self/const T) -> bool { return *self != *(*other); }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: & &self/const T) -> bool {\n         return *(*self) != *(*other);\n     }\n }\n \n // Comparison for region pointers\n impl<T:Ord> &const T : Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: & &self/const T) -> bool { *self < *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: & &self/const T) -> bool {\n         *(*self) < *(*other)\n     }\n-    #[cfg(stage0)]\n-    pure fn le(other: & &self/const T) -> bool { *self <= *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: & &self/const T) -> bool {\n         *(*self) <= *(*other)\n     }\n-    #[cfg(stage0)]\n-    pure fn ge(other: & &self/const T) -> bool { *self >= *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: & &self/const T) -> bool {\n         *(*self) >= *(*other)\n     }\n-    #[cfg(stage0)]\n-    pure fn gt(other: & &self/const T) -> bool { *self > *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: & &self/const T) -> bool {\n         *(*self) > *(*other)\n     }"}, {"sha": "3bec87e0af62821fcaaf4541a1bc6253ab7da938", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -516,19 +516,9 @@ enum EnumVisitState {\n }\n \n impl EnumVisitState : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &EnumVisitState) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &EnumVisitState) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &EnumVisitState) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &EnumVisitState) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "20d4bd81056ce64ddba56ad9148710adb41f25f7", "filename": "src/libcore/result.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -365,25 +365,6 @@ pub fn unwrap_err<T, U>(res: Result<T, U>) -> U {\n }\n \n impl<T:Eq,U:Eq> Result<T,U> : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Result<T,U>) -> bool {\n-        match self {\n-            Ok(ref e0a) => {\n-                match (*other) {\n-                    Ok(ref e0b) => *e0a == *e0b,\n-                    _ => false\n-                }\n-            }\n-            Err(ref e0a) => {\n-                match (*other) {\n-                    Err(ref e0b) => *e0a == *e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Result<T,U>) -> bool {\n         match (*self) {\n             Ok(ref e0a) => {\n@@ -400,10 +381,6 @@ impl<T:Eq,U:Eq> Result<T,U> : Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Result<T,U>) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Result<T,U>) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "410d18d66658a1e980a9d497abcae8c00d7043f4", "filename": "src/libcore/str.rs", "status": "modified", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -737,139 +737,61 @@ pure fn gt(a: &str, b: &str) -> bool {\n \n impl &str : Eq {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn eq(other: & &self/str) -> bool {\n-        eq_slice(self, (*other))\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: & &self/str) -> bool {\n         eq_slice((*self), (*other))\n     }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ne(other: & &self/str) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: & &self/str) -> bool { !(*self).eq(other) }\n }\n \n impl ~str : Eq {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn eq(other: &~str) -> bool {\n-        eq_slice(self, (*other))\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &~str) -> bool {\n         eq_slice((*self), (*other))\n     }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ne(other: &~str) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &~str) -> bool { !(*self).eq(other) }\n }\n \n impl @str : Eq {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn eq(other: &@str) -> bool {\n-        eq_slice(self, (*other))\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &@str) -> bool {\n         eq_slice((*self), (*other))\n     }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ne(other: &@str) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &@str) -> bool { !(*self).eq(other) }\n }\n \n impl ~str : Ord {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn lt(other: &~str) -> bool { lt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &~str) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn le(other: &~str) -> bool { le(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &~str) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ge(other: &~str) -> bool { ge(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &~str) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn gt(other: &~str) -> bool { gt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &~str) -> bool { gt((*self), (*other)) }\n }\n \n impl &str : Ord {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn lt(other: & &self/str) -> bool { lt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: & &self/str) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn le(other: & &self/str) -> bool { le(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: & &self/str) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ge(other: & &self/str) -> bool { ge(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: & &self/str) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn gt(other: & &self/str) -> bool { gt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: & &self/str) -> bool { gt((*self), (*other)) }\n }\n \n impl @str : Ord {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn lt(other: &@str) -> bool { lt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &@str) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn le(other: &@str) -> bool { le(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &@str) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ge(other: &@str) -> bool { ge(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &@str) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn gt(other: &@str) -> bool { gt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &@str) -> bool { gt((*self), (*other)) }\n }\n "}, {"sha": "a2b5c3229ad89330d83a255f9c36ba0cde8a8131", "filename": "src/libcore/task.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -43,15 +43,7 @@ pub enum Task {\n }\n \n impl Task : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Task) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Task) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Task) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Task) -> bool { !(*self).eq(other) }\n }\n \n@@ -72,25 +64,12 @@ pub enum TaskResult {\n }\n \n impl TaskResult : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &TaskResult) -> bool {\n-        match (self, (*other)) {\n-            (Success, Success) | (Failure, Failure) => true,\n-            (Success, _) | (Failure, _) => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &TaskResult) -> bool {\n         match ((*self), (*other)) {\n             (Success, Success) | (Failure, Failure) => true,\n             (Success, _) | (Failure, _) => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &TaskResult) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &TaskResult) -> bool { !(*self).eq(other) }\n }\n \n@@ -114,43 +93,6 @@ pub enum SchedMode {\n }\n \n impl SchedMode : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &SchedMode) -> bool {\n-        match self {\n-            SingleThreaded => {\n-                match (*other) {\n-                    SingleThreaded => true,\n-                    _ => false\n-                }\n-            }\n-            ThreadPerCore => {\n-                match (*other) {\n-                    ThreadPerCore => true,\n-                    _ => false\n-                }\n-            }\n-            ThreadPerTask => {\n-                match (*other) {\n-                    ThreadPerTask => true,\n-                    _ => false\n-                }\n-            }\n-            ManualThreads(e0a) => {\n-                match (*other) {\n-                    ManualThreads(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            PlatformThread => {\n-                match (*other) {\n-                    PlatformThread => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &SchedMode) -> bool {\n         match (*self) {\n             SingleThreaded => {\n@@ -185,12 +127,6 @@ impl SchedMode : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &SchedMode) -> bool {\n-        !self.eq(other)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &SchedMode) -> bool {\n         !(*self).eq(other)\n     }"}, {"sha": "b8537373e655003b5702e1793b46715f56c5702b", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -7,23 +7,11 @@ pub trait LocalData { }\n impl<T: Owned> @T: LocalData { }\n \n impl LocalData: Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &@LocalData) -> bool unsafe {\n-        let ptr_a: (uint, uint) = cast::reinterpret_cast(&self);\n-        let ptr_b: (uint, uint) = cast::reinterpret_cast(other);\n-        return ptr_a == ptr_b;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &@LocalData) -> bool unsafe {\n         let ptr_a: (uint, uint) = cast::reinterpret_cast(&(*self));\n         let ptr_b: (uint, uint) = cast::reinterpret_cast(other);\n         return ptr_a == ptr_b;\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &@LocalData) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &@LocalData) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "887983e8b6c8b2db982919c5b43ab82bbe9dbffa", "filename": "src/libcore/task/mod.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,8 @@\n+\n+mod local_data_priv;\n+\n+pub mod local_data;\n+\n+pub mod rt;\n+\n+pub mod spawn;"}, {"sha": "78a3e3c83550374cf28bdb3cbd7c16b61f14efc7", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -95,18 +95,6 @@ impl<A: Copy, B: Copy> (~[A], ~[B]): ExtendedTupleOps<A,B> {\n }\n \n impl<A: Eq, B: Eq> (A, B) : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &(A, B)) -> bool {\n-        match self {\n-            (ref self_a, ref self_b) => match other {\n-                &(ref other_a, ref other_b) => {\n-                    (*self_a).eq(other_a) && (*self_b).eq(other_b)\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &(A, B)) -> bool {\n         match (*self) {\n             (ref self_a, ref self_b) => match other {\n@@ -116,31 +104,10 @@ impl<A: Eq, B: Eq> (A, B) : Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &(A, B)) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &(A, B)) -> bool { !(*self).eq(other) }\n }\n \n impl<A: Ord, B: Ord> (A, B) : Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: &(A, B)) -> bool {\n-        match self {\n-            (ref self_a, ref self_b) => {\n-                match (*other) {\n-                    (ref other_a, ref other_b) => {\n-                        if (*self_a).lt(other_a) { return true; }\n-                        if (*other_a).lt(self_a) { return false; }\n-                        if (*self_b).lt(other_b) { return true; }\n-                        return false;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &(A, B)) -> bool {\n         match (*self) {\n             (ref self_a, ref self_b) => {\n@@ -155,37 +122,12 @@ impl<A: Ord, B: Ord> (A, B) : Ord {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn le(other: &(A, B)) -> bool { !(*other).lt(&self) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &(A, B)) -> bool { !(*other).lt(&(*self)) }\n-    #[cfg(stage0)]\n-    pure fn ge(other: &(A, B)) -> bool { !self.lt(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &(A, B)) -> bool { !(*self).lt(other) }\n-    #[cfg(stage0)]\n-    pure fn gt(other: &(A, B)) -> bool { (*other).lt(&self)  }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &(A, B)) -> bool { (*other).lt(&(*self))  }\n }\n \n impl<A: Eq, B: Eq, C: Eq> (A, B, C) : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &(A, B, C)) -> bool {\n-        match self {\n-            (ref self_a, ref self_b, ref self_c) => match other {\n-                &(ref other_a, ref other_b, ref other_c) => {\n-                    (*self_a).eq(other_a) && (*self_b).eq(other_b)\n-                        && (*self_c).eq(other_c)\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &(A, B, C)) -> bool {\n         match (*self) {\n             (ref self_a, ref self_b, ref self_c) => match other {\n@@ -196,33 +138,10 @@ impl<A: Eq, B: Eq, C: Eq> (A, B, C) : Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &(A, B, C)) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &(A, B, C)) -> bool { !(*self).eq(other) }\n }\n \n impl<A: Ord, B: Ord, C: Ord> (A, B, C) : Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: &(A, B, C)) -> bool {\n-        match self {\n-            (ref self_a, ref self_b, ref self_c) => {\n-                match (*other) {\n-                    (ref other_a, ref other_b, ref other_c) => {\n-                        if (*self_a).lt(other_a) { return true; }\n-                        if (*other_a).lt(self_a) { return false; }\n-                        if (*self_b).lt(other_b) { return true; }\n-                        if (*other_b).lt(self_b) { return false; }\n-                        if (*self_c).lt(other_c) { return true; }\n-                        return false;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &(A, B, C)) -> bool {\n         match (*self) {\n             (ref self_a, ref self_b, ref self_c) => {\n@@ -239,20 +158,8 @@ impl<A: Ord, B: Ord, C: Ord> (A, B, C) : Ord {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn le(other: &(A, B, C)) -> bool { !(*other).lt(&self) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &(A, B, C)) -> bool { !(*other).lt(&(*self)) }\n-    #[cfg(stage0)]\n-    pure fn ge(other: &(A, B, C)) -> bool { !self.lt(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &(A, B, C)) -> bool { !(*self).lt(other) }\n-    #[cfg(stage0)]\n-    pure fn gt(other: &(A, B, C)) -> bool { (*other).lt(&self)  }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &(A, B, C)) -> bool { (*other).lt(&(*self))  }\n }\n "}, {"sha": "e96a6766570d93d593656056ab6b20c0cef93830", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -49,38 +49,14 @@ pub pure fn compl(i: T) -> T {\n }\n \n impl T : Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: &T) -> bool { self < (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &T) -> bool { (*self) < (*other) }\n-    #[cfg(stage0)]\n-    pure fn le(other: &T) -> bool { self <= (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &T) -> bool { (*self) <= (*other) }\n-    #[cfg(stage0)]\n-    pure fn ge(other: &T) -> bool { self >= (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &T) -> bool { (*self) >= (*other) }\n-    #[cfg(stage0)]\n-    pure fn gt(other: &T) -> bool { self > (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &T) -> bool { (*self) > (*other) }\n }\n \n impl T : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &T) -> bool { return self == (*other); }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &T) -> bool { return (*self) == (*other); }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &T) -> bool { return self != (*other); }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &T) -> bool { return (*self) != (*other); }\n }\n "}, {"sha": "aafd46f845b0a513274c4620b117d8d8f27899f5", "filename": "src/libcore/uint-template/u16b.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fuint-template%2Fu16b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fuint-template%2Fu16b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fu16b.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,4 @@\n+mod inst {\n+    pub type T = u16;\n+    pub const bits: uint = 16;\n+}"}, {"sha": "8e784bdf22592c5122b99d338e7edffa6772fdf5", "filename": "src/libcore/uint-template/u32b.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fuint-template%2Fu32b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fuint-template%2Fu32b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fu32b.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,4 @@\n+mod inst {\n+    pub type T = u32;\n+    pub const bits: uint = 32;\n+}\n\\ No newline at end of file"}, {"sha": "43a8169f08b45e347e74d2babf3a9bf231b47669", "filename": "src/libcore/uint-template/u64b.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fuint-template%2Fu64b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fuint-template%2Fu64b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fu64b.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,4 @@\n+mod inst {\n+    pub type T = u64;\n+    pub const bits: uint = 64;\n+}\n\\ No newline at end of file"}, {"sha": "a3e750861e57347c18013dc2fe1162ac9191cf4a", "filename": "src/libcore/uint-template/u8b.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fuint-template%2Fu8b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fuint-template%2Fu8b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fu8b.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,11 @@\n+pub use inst::is_ascii;\n+\n+mod inst {\n+    pub type T = u8;\n+    pub const bits: uint = 8;\n+\n+    // Type-specific functions here. These must be reexported by the\n+    // parent module so that they appear in core::u8 and not core::u8::u8;\n+\n+    pub pure fn is_ascii(x: T) -> bool { return 0 as T == x & 128 as T; }\n+}"}, {"sha": "68054d47e1f988da7add538761a4420742e20a99", "filename": "src/libcore/uint-template/uintb.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fuint-template%2Fuintb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fuint-template%2Fuintb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fuintb.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,160 @@\n+pub use inst::{\n+    div_ceil, div_round, div_floor, iterate,\n+    next_power_of_two\n+};\n+\n+mod inst {\n+    pub type T = uint;\n+\n+    #[cfg(target_arch = \"x86\")]\n+    #[cfg(target_arch = \"arm\")]\n+    pub const bits: uint = 32;\n+\n+    #[cfg(target_arch = \"x86_64\")]\n+    pub const bits: uint = 64;\n+\n+    /**\n+    * Divide two numbers, return the result, rounded up.\n+    *\n+    * # Arguments\n+    *\n+    * * x - an integer\n+    * * y - an integer distinct from 0u\n+    *\n+    * # Return value\n+    *\n+    * The smallest integer `q` such that `x/y <= q`.\n+    */\n+    pub pure fn div_ceil(x: uint, y: uint) -> uint {\n+        let div = x / y;\n+        if x % y == 0u { div }\n+        else { div + 1u }\n+    }\n+\n+    /**\n+    * Divide two numbers, return the result, rounded to the closest integer.\n+    *\n+    * # Arguments\n+    *\n+    * * x - an integer\n+    * * y - an integer distinct from 0u\n+    *\n+    * # Return value\n+    *\n+    * The integer `q` closest to `x/y`.\n+    */\n+    pub pure fn div_round(x: uint, y: uint) -> uint {\n+        let div = x / y;\n+        if x % y * 2u  < y { div }\n+        else { div + 1u }\n+    }\n+\n+    /**\n+    * Divide two numbers, return the result, rounded down.\n+    *\n+    * Note: This is the same function as `div`.\n+    *\n+    * # Arguments\n+    *\n+    * * x - an integer\n+    * * y - an integer distinct from 0u\n+    *\n+    * # Return value\n+    *\n+    * The smallest integer `q` such that `x/y <= q`. This\n+    * is either `x/y` or `x/y + 1`.\n+    */\n+    pub pure fn div_floor(x: uint, y: uint) -> uint { return x / y; }\n+\n+    /**\n+    * Iterate over the range [`lo`..`hi`), or stop when requested\n+    *\n+    * # Arguments\n+    *\n+    * * lo - The integer at which to start the loop (included)\n+    * * hi - The integer at which to stop the loop (excluded)\n+    * * it - A block to execute with each consecutive integer of the range.\n+    *        Return `true` to continue, `false` to stop.\n+    *\n+    * # Return value\n+    *\n+    * `true` If execution proceeded correctly, `false` if it was interrupted,\n+    * that is if `it` returned `false` at any point.\n+    */\n+    pub pure fn iterate(lo: uint, hi: uint, it: fn(uint) -> bool) -> bool {\n+        let mut i = lo;\n+        while i < hi {\n+            if (!it(i)) { return false; }\n+            i += 1u;\n+        }\n+        return true;\n+    }\n+\n+    /// Returns the smallest power of 2 greater than or equal to `n`\n+    #[inline(always)]\n+    pub fn next_power_of_two(n: uint) -> uint {\n+        let halfbits: uint = sys::size_of::<uint>() * 4u;\n+        let mut tmp: uint = n - 1u;\n+        let mut shift: uint = 1u;\n+        while shift <= halfbits { tmp |= tmp >> shift; shift <<= 1u; }\n+        return tmp + 1u;\n+    }\n+\n+    #[test]\n+    fn test_next_power_of_two() {\n+        assert (uint::next_power_of_two(0u) == 0u);\n+        assert (uint::next_power_of_two(1u) == 1u);\n+        assert (uint::next_power_of_two(2u) == 2u);\n+        assert (uint::next_power_of_two(3u) == 4u);\n+        assert (uint::next_power_of_two(4u) == 4u);\n+        assert (uint::next_power_of_two(5u) == 8u);\n+        assert (uint::next_power_of_two(6u) == 8u);\n+        assert (uint::next_power_of_two(7u) == 8u);\n+        assert (uint::next_power_of_two(8u) == 8u);\n+        assert (uint::next_power_of_two(9u) == 16u);\n+        assert (uint::next_power_of_two(10u) == 16u);\n+        assert (uint::next_power_of_two(11u) == 16u);\n+        assert (uint::next_power_of_two(12u) == 16u);\n+        assert (uint::next_power_of_two(13u) == 16u);\n+        assert (uint::next_power_of_two(14u) == 16u);\n+        assert (uint::next_power_of_two(15u) == 16u);\n+        assert (uint::next_power_of_two(16u) == 16u);\n+        assert (uint::next_power_of_two(17u) == 32u);\n+        assert (uint::next_power_of_two(18u) == 32u);\n+        assert (uint::next_power_of_two(19u) == 32u);\n+        assert (uint::next_power_of_two(20u) == 32u);\n+        assert (uint::next_power_of_two(21u) == 32u);\n+        assert (uint::next_power_of_two(22u) == 32u);\n+        assert (uint::next_power_of_two(23u) == 32u);\n+        assert (uint::next_power_of_two(24u) == 32u);\n+        assert (uint::next_power_of_two(25u) == 32u);\n+        assert (uint::next_power_of_two(26u) == 32u);\n+        assert (uint::next_power_of_two(27u) == 32u);\n+        assert (uint::next_power_of_two(28u) == 32u);\n+        assert (uint::next_power_of_two(29u) == 32u);\n+        assert (uint::next_power_of_two(30u) == 32u);\n+        assert (uint::next_power_of_two(31u) == 32u);\n+        assert (uint::next_power_of_two(32u) == 32u);\n+        assert (uint::next_power_of_two(33u) == 64u);\n+        assert (uint::next_power_of_two(34u) == 64u);\n+        assert (uint::next_power_of_two(35u) == 64u);\n+        assert (uint::next_power_of_two(36u) == 64u);\n+        assert (uint::next_power_of_two(37u) == 64u);\n+        assert (uint::next_power_of_two(38u) == 64u);\n+        assert (uint::next_power_of_two(39u) == 64u);\n+    }\n+\n+    #[test]\n+    fn test_overflows() {\n+        assert (uint::max_value > 0u);\n+        assert (uint::min_value <= 0u);\n+        assert (uint::min_value + uint::max_value + 1u == 0u);\n+    }\n+\n+    #[test]\n+    fn test_div() {\n+        assert(uint::div_floor(3u, 4u) == 0u);\n+        assert(uint::div_ceil(3u, 4u)  == 1u);\n+        assert(uint::div_round(3u, 4u) == 1u);\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "6110b9eebff3c4736e50bf4840874a6a026457df", "filename": "src/libcore/unit.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funit.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -11,38 +11,14 @@ Functions for the unit type.\n use cmp::{Eq, Ord};\n \n impl () : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(_other: &()) -> bool { true }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, _other: &()) -> bool { true }\n-    #[cfg(stage0)]\n-    pure fn ne(_other: &()) -> bool { false }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, _other: &()) -> bool { false }\n }\n \n impl () : Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(_other: &()) -> bool { false }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, _other: &()) -> bool { false }\n-    #[cfg(stage0)]\n-    pure fn le(_other: &()) -> bool { true }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, _other: &()) -> bool { true }\n-    #[cfg(stage0)]\n-    pure fn ge(_other: &()) -> bool { true }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, _other: &()) -> bool { true }\n-    #[cfg(stage0)]\n-    pure fn gt(_other: &()) -> bool { false }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, _other: &()) -> bool { false }\n }\n "}, {"sha": "47864d0b5627420351289d70ca2f2c63269aa91a", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -1347,47 +1347,23 @@ pure fn eq<T: Eq>(a: &[T], b: &[T]) -> bool {\n \n impl<T: Eq> &[T] : Eq {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn eq(other: & &self/[T]) -> bool { eq(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: & &self/[T]) -> bool { eq((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ne(other: & &self/[T]) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: & &self/[T]) -> bool { !(*self).eq(other) }\n }\n \n \n impl<T: Eq> ~[T] : Eq {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn eq(other: &~[T]) -> bool { eq(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &~[T]) -> bool { eq((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ne(other: &~[T]) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &~[T]) -> bool { !(*self).eq(other) }\n }\n \n impl<T: Eq> @[T] : Eq {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn eq(other: &@[T]) -> bool { eq(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &@[T]) -> bool { eq((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ne(other: &@[T]) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &@[T]) -> bool { !(*self).eq(other) }\n }\n \n@@ -1414,82 +1390,34 @@ pure fn gt<T: Ord>(a: &[T], b: &[T]) -> bool { lt(b, a)  }\n \n impl<T: Ord> &[T] : Ord {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn lt(other: & &self/[T]) -> bool { lt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: & &self/[T]) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn le(other: & &self/[T]) -> bool { le(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: & &self/[T]) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ge(other: & &self/[T]) -> bool { ge(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: & &self/[T]) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn gt(other: & &self/[T]) -> bool { gt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: & &self/[T]) -> bool { gt((*self), (*other)) }\n }\n \n impl<T: Ord> ~[T] : Ord {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn lt(other: &~[T]) -> bool { lt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &~[T]) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn le(other: &~[T]) -> bool { le(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &~[T]) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ge(other: &~[T]) -> bool { ge(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &~[T]) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn gt(other: &~[T]) -> bool { gt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &~[T]) -> bool { gt((*self), (*other)) }\n }\n \n impl<T: Ord> @[T] : Ord {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn lt(other: &@[T]) -> bool { lt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &@[T]) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn le(other: &@[T]) -> bool { le(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &@[T]) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ge(other: &@[T]) -> bool { ge(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &@[T]) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn gt(other: &@[T]) -> bool { gt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &@[T]) -> bool { gt((*self), (*other)) }\n }\n "}, {"sha": "d8f4fd97c66ef94799e70a8776f968eb4d0ce102", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 619, "deletions": 0, "changes": 619, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -24,6 +24,625 @@ extern mod syntax(vers = \"0.5\");\n \n use core::*;\n \n+use io::WriterUtil;\n+\n+use syntax::{ast, ast_util, fold, visit, codemap};\n+use syntax::parse;\n+use syntax::print::pprust;\n+use syntax::diagnostic;\n+\n+enum test_mode { tm_converge, tm_run, }\n+type context = { mode: test_mode }; // + rng\n+\n+impl test_mode : cmp::Eq {\n+    pure fn eq(&self, other: &test_mode) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(&self, other: &test_mode) -> bool { !(*self).eq(other) }\n+}\n+\n+fn write_file(filename: &Path, content: ~str) {\n+    result::get(\n+        &io::file_writer(filename, ~[io::Create, io::Truncate]))\n+        .write_str(content);\n+}\n+\n+fn contains(haystack: ~str, needle: ~str) -> bool {\n+    str::contains(haystack, needle)\n+}\n+\n+fn find_rust_files(files: &mut ~[Path], path: &Path) {\n+    if path.filetype() == Some(~\".rs\") && !contains(path.to_str(), ~\"utf8\") {\n+        // ignoring \"utf8\" tests because something is broken\n+        files.push(*path);\n+    } else if os::path_is_dir(path)\n+        && !contains(path.to_str(), ~\"compile-fail\")\n+        && !contains(path.to_str(), ~\"build\") {\n+        for os::list_dir_path(path).each |p| {\n+            find_rust_files(files, *p);\n+        }\n+    }\n+}\n+\n+\n+fn common_exprs() -> ~[ast::expr] {\n+    fn dse(e: ast::expr_) -> ast::expr {\n+        { id: 0, callee_id: -1, node: e, span: ast_util::dummy_sp() }\n+    }\n+\n+    fn dsl(l: ast::lit_) -> ast::lit {\n+        { node: l, span: ast_util::dummy_sp() }\n+    }\n+\n+    ~[dse(ast::expr_break(option::None)),\n+     dse(ast::expr_again(option::None)),\n+     dse(ast::expr_fail(option::None)),\n+     dse(ast::expr_fail(option::Some(\n+         @dse(ast::expr_lit(@dsl(ast::lit_str(@~\"boo\"))))))),\n+     dse(ast::expr_ret(option::None)),\n+     dse(ast::expr_lit(@dsl(ast::lit_nil))),\n+     dse(ast::expr_lit(@dsl(ast::lit_bool(false)))),\n+     dse(ast::expr_lit(@dsl(ast::lit_bool(true)))),\n+     dse(ast::expr_unary(ast::box(ast::m_imm),\n+                         @dse(ast::expr_lit(@dsl(ast::lit_bool(true)))))),\n+     dse(ast::expr_unary(ast::uniq(ast::m_imm),\n+                         @dse(ast::expr_lit(@dsl(ast::lit_bool(true))))))\n+    ]\n+}\n+\n+pure fn safe_to_steal_expr(e: @ast::expr, tm: test_mode) -> bool {\n+    safe_to_use_expr(*e, tm)\n+}\n+\n+pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n+    match tm {\n+      tm_converge => {\n+        match e.node {\n+          // If the fuzzer moves a block-ending-in-semicolon into callee\n+          // position, the pretty-printer can't preserve this even by\n+          // parenthesizing!!  See email to marijn.\n+          ast::expr_if(*) | ast::expr_block(*)\n+          | ast::expr_match(*) | ast::expr_while(*)  => { false }\n+\n+          // https://github.com/mozilla/rust/issues/929\n+          ast::expr_cast(*) | ast::expr_assert(*) |\n+          ast::expr_binary(*) | ast::expr_assign(*) |\n+          ast::expr_assign_op(*) => { false }\n+\n+          ast::expr_fail(option::None) |\n+          ast::expr_ret(option::None) => { false }\n+\n+          // https://github.com/mozilla/rust/issues/953\n+          ast::expr_fail(option::Some(_)) => { false }\n+\n+          // https://github.com/mozilla/rust/issues/928\n+          //ast::expr_cast(_, _) { false }\n+\n+          // https://github.com/mozilla/rust/issues/1458\n+          ast::expr_call(_, _, _) => { false }\n+\n+          _ => { true }\n+        }\n+      }\n+      tm_run => { true }\n+    }\n+}\n+\n+fn safe_to_steal_ty(t: @ast::Ty, tm: test_mode) -> bool {\n+    // Restrictions happen to be the same.\n+    safe_to_replace_ty(t.node, tm)\n+}\n+\n+// Not type-parameterized: https://github.com/mozilla/rust/issues/898 (FIXED)\n+fn stash_expr_if(c: fn@(@ast::expr, test_mode)->bool,\n+                 es: @mut ~[ast::expr],\n+                 e: @ast::expr,\n+                 tm: test_mode) {\n+    if c(e, tm) {\n+        *es += ~[*e];\n+    } else {/* now my indices are wrong :( */ }\n+}\n+\n+fn stash_ty_if(c: fn@(@ast::Ty, test_mode)->bool,\n+               es: @mut ~[ast::Ty],\n+               e: @ast::Ty,\n+               tm: test_mode) {\n+    if c(e, tm) {\n+        es.push(*e);\n+    } else {/* now my indices are wrong :( */ }\n+}\n+\n+type stolen_stuff = {exprs: ~[ast::expr], tys: ~[ast::Ty]};\n+\n+fn steal(crate: ast::crate, tm: test_mode) -> stolen_stuff {\n+    let exprs = @mut ~[];\n+    let tys = @mut ~[];\n+    let v = visit::mk_simple_visitor(@{\n+        visit_expr: |a| stash_expr_if(safe_to_steal_expr, exprs, a, tm),\n+        visit_ty: |a| stash_ty_if(safe_to_steal_ty, tys, a, tm),\n+        .. *visit::default_simple_visitor()\n+    });\n+    visit::visit_crate(crate, (), v);\n+    {exprs: *exprs, tys: *tys}\n+}\n+\n+\n+fn safe_to_replace_expr(e: ast::expr_, _tm: test_mode) -> bool {\n+    match e {\n+      // https://github.com/mozilla/rust/issues/652\n+      ast::expr_if(*) => { false }\n+      ast::expr_block(_) => { false }\n+\n+      // expr_call is also missing a constraint\n+      ast::expr_fn_block(*) => { false }\n+\n+      _ => { true }\n+    }\n+}\n+\n+fn safe_to_replace_ty(t: ast::ty_, _tm: test_mode) -> bool {\n+    match t {\n+      ast::ty_infer => { false } // always implicit, always top level\n+      ast::ty_bot => { false }   // in source, can only appear\n+                              // as the out type of a function\n+      ast::ty_mac(_) => { false }\n+      _ => { true }\n+    }\n+}\n+\n+// Replace the |i|th expr (in fold order) of |crate| with |newexpr|.\n+fn replace_expr_in_crate(crate: ast::crate, i: uint,\n+                         newexpr: ast::expr, tm: test_mode) ->\n+   ast::crate {\n+    let j: @mut uint = @mut 0u;\n+    fn fold_expr_rep(j_: @mut uint, i_: uint, newexpr_: ast::expr_,\n+                     original: ast::expr_, fld: fold::ast_fold,\n+                     tm_: test_mode) ->\n+       ast::expr_ {\n+        *j_ += 1u;\n+        if i_ + 1u == *j_ && safe_to_replace_expr(original, tm_) {\n+            newexpr_\n+        } else {\n+            fold::noop_fold_expr(original, fld)\n+        }\n+    }\n+    let afp = @{\n+        fold_expr: fold::wrap(|a,b| {\n+            fold_expr_rep(j, i, newexpr.node, a, b, tm)\n+        }),\n+        .. *fold::default_ast_fold()\n+    };\n+    let af = fold::make_fold(afp);\n+    let crate2: @ast::crate = @af.fold_crate(crate);\n+    *crate2\n+}\n+\n+\n+// Replace the |i|th ty (in fold order) of |crate| with |newty|.\n+fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::Ty,\n+                       tm: test_mode) -> ast::crate {\n+    let j: @mut uint = @mut 0u;\n+    fn fold_ty_rep(j_: @mut uint, i_: uint, newty_: ast::ty_,\n+                   original: ast::ty_, fld: fold::ast_fold,\n+                   tm_: test_mode) ->\n+       ast::ty_ {\n+        *j_ += 1u;\n+        if i_ + 1u == *j_ && safe_to_replace_ty(original, tm_) {\n+            newty_\n+        } else { fold::noop_fold_ty(original, fld) }\n+    }\n+    let afp = @{\n+        fold_ty: fold::wrap(|a,b| fold_ty_rep(j, i, newty.node, a, b, tm) ),\n+        .. *fold::default_ast_fold()\n+    };\n+    let af = fold::make_fold(afp);\n+    let crate2: @ast::crate = @af.fold_crate(crate);\n+    *crate2\n+}\n+\n+fn under(n: uint, it: fn(uint)) {\n+    let mut i: uint = 0u;\n+    while i < n { it(i); i += 1u; }\n+}\n+\n+fn as_str(f: fn@(+x: io::Writer)) -> ~str {\n+    io::with_str_writer(f)\n+}\n+\n+fn check_variants_of_ast(crate: ast::crate, codemap: @codemap::CodeMap,\n+                         filename: &Path, cx: context) {\n+    let stolen = steal(crate, cx.mode);\n+    let extra_exprs = vec::filter(common_exprs(),\n+                                  |a| safe_to_use_expr(*a, cx.mode) );\n+    check_variants_T(crate, codemap, filename, ~\"expr\",\n+                     extra_exprs + stolen.exprs, pprust::expr_to_str,\n+                     replace_expr_in_crate, cx);\n+    check_variants_T(crate, codemap, filename, ~\"ty\", stolen.tys,\n+                     pprust::ty_to_str, replace_ty_in_crate, cx);\n+}\n+\n+fn check_variants_T<T: Copy>(\n+  crate: ast::crate,\n+  codemap: @codemap::CodeMap,\n+  filename: &Path,\n+  thing_label: ~str,\n+  things: ~[T],\n+  stringifier: fn@(@T, @syntax::parse::token::ident_interner) -> ~str,\n+  replacer: fn@(ast::crate, uint, T, test_mode) -> ast::crate,\n+  cx: context\n+  ) {\n+    error!(\"%s contains %u %s objects\", filename.to_str(),\n+           things.len(), thing_label);\n+\n+    // Assuming we're not generating any token_trees\n+    let intr = syntax::parse::token::mk_fake_ident_interner();\n+\n+    let L = things.len();\n+\n+    if L < 100 {\n+        do under(uint::min(L, 20)) |i| {\n+            log(error, ~\"Replacing... #\" + uint::str(i));\n+            let fname = str::from_slice(filename.to_str());\n+            do under(uint::min(L, 30)) |j| {\n+                log(error, ~\"With... \" + stringifier(@things[j], intr));\n+                let crate2 = @replacer(crate, i, things[j], cx.mode);\n+                // It would be best to test the *crate* for stability, but\n+                // testing the string for stability is easier and ok for now.\n+                let handler = diagnostic::mk_handler(None);\n+                let str3 = do io::with_str_reader(\"\") |rdr| {\n+                    @as_str(|a|pprust::print_crate(\n+                        codemap,\n+                        intr,\n+                        diagnostic::mk_span_handler(handler, codemap),\n+                        crate2,\n+                        fname,\n+                        rdr, a,\n+                        pprust::no_ann(),\n+                        false))\n+                };\n+                match cx.mode {\n+                  tm_converge => {\n+                    check_roundtrip_convergence(str3, 1u);\n+                  }\n+                  tm_run => {\n+                    let file_label = fmt!(\"rusttmp/%s_%s_%u_%u\",\n+                                          last_part(filename.to_str()),\n+                                          thing_label, i, j);\n+                    let safe_to_run = !(content_is_dangerous_to_run(*str3)\n+                                        || has_raw_pointers(*crate2));\n+                    check_whole_compiler(*str3, &Path(file_label),\n+                                         safe_to_run);\n+                  }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn last_part(filename: ~str) -> ~str {\n+  let ix = option::get(str::rfind_char(filename, '/'));\n+  str::slice(filename, ix + 1u, str::len(filename) - 3u)\n+}\n+\n+enum happiness {\n+    passed,\n+    cleanly_rejected(~str),\n+    known_bug(~str),\n+    failed(~str),\n+}\n+\n+// We'd find more bugs if we could take an AST here, but\n+// - that would find many \"false positives\" or unimportant bugs\n+// - that would be tricky, requiring use of tasks or serialization\n+//   or randomness.\n+// This seems to find plenty of bugs as it is :)\n+fn check_whole_compiler(code: ~str, suggested_filename_prefix: &Path,\n+                        allow_running: bool) {\n+    let filename = &suggested_filename_prefix.with_filetype(\"rs\");\n+    write_file(filename, code);\n+\n+    let compile_result = check_compiling(filename);\n+\n+    let run_result = match (compile_result, allow_running) {\n+      (passed, true) => { check_running(suggested_filename_prefix) }\n+      (h, _) => { h }\n+    };\n+\n+    match run_result {\n+      passed | cleanly_rejected(_) | known_bug(_) => {\n+        removeIfExists(suggested_filename_prefix);\n+        removeIfExists(&suggested_filename_prefix.with_filetype(\"rs\"));\n+        removeDirIfExists(&suggested_filename_prefix.with_filetype(\"dSYM\"));\n+      }\n+      failed(s) => {\n+        log(error, ~\"check_whole_compiler failure: \" + s);\n+        log(error, ~\"Saved as: \" + filename.to_str());\n+      }\n+    }\n+}\n+\n+fn removeIfExists(filename: &Path) {\n+    // So sketchy!\n+    assert !contains(filename.to_str(), ~\" \");\n+    run::program_output(~\"bash\", ~[~\"-c\", ~\"rm \" + filename.to_str()]);\n+}\n+\n+fn removeDirIfExists(filename: &Path) {\n+    // So sketchy!\n+    assert !contains(filename.to_str(), ~\" \");\n+    run::program_output(~\"bash\", ~[~\"-c\", ~\"rm -r \" + filename.to_str()]);\n+}\n+\n+fn check_running(exe_filename: &Path) -> happiness {\n+    let p = run::program_output(\n+        ~\"/Users/jruderman/scripts/timed_run_rust_program.py\",\n+        ~[exe_filename.to_str()]);\n+    let comb = p.out + ~\"\\n\" + p.err;\n+    if str::len(comb) > 1u {\n+        log(error, ~\"comb comb comb: \" + comb);\n+    }\n+\n+    if contains(comb, ~\"Assertion failed:\") {\n+        failed(~\"C++ assertion failure\")\n+    } else if contains(comb, ~\"leaked memory in rust main loop\") {\n+        // might also use exit code 134\n+        //failed(\"Leaked\")\n+        known_bug(~\"https://github.com/mozilla/rust/issues/910\")\n+    } else if contains(comb, ~\"src/rt/\") {\n+        failed(~\"Mentioned src/rt/\")\n+    } else if contains(comb, ~\"malloc\") {\n+        failed(~\"Mentioned malloc\")\n+    } else {\n+        match p.status {\n+            0         => { passed }\n+            100       => { cleanly_rejected(~\"running: explicit fail\") }\n+            101 | 247 => { cleanly_rejected(~\"running: timed out\") }\n+            245 | 246 | 138 | 252 => {\n+              known_bug(~\"https://github.com/mozilla/rust/issues/1466\")\n+            }\n+            136 | 248 => {\n+              known_bug(\n+                  ~\"SIGFPE - https://github.com/mozilla/rust/issues/944\")\n+            }\n+            rc => {\n+              failed(~\"Rust program ran but exited with status \" +\n+                     int::str(rc))\n+            }\n+        }\n+    }\n+}\n+\n+fn check_compiling(filename: &Path) -> happiness {\n+    let p = run::program_output(\n+        ~\"/Users/jruderman/code/rust/build/x86_64-apple-darwin/\\\n+         stage1/bin/rustc\",\n+        ~[filename.to_str()]);\n+\n+    //error!(\"Status: %d\", p.status);\n+    if p.status == 0 {\n+        passed\n+    } else if p.err != ~\"\" {\n+        if contains(p.err, ~\"error:\") {\n+            cleanly_rejected(~\"rejected with span_error\")\n+        } else {\n+            log(error, ~\"Stderr: \" + p.err);\n+            failed(~\"Unfamiliar error message\")\n+        }\n+    } else if contains(p.out, ~\"Assertion\") && contains(p.out, ~\"failed\") {\n+        log(error, ~\"Stdout: \" + p.out);\n+        failed(~\"Looks like an llvm assertion failure\")\n+    } else if contains(p.out, ~\"internal compiler error unimplemented\") {\n+        known_bug(~\"Something unimplemented\")\n+    } else if contains(p.out, ~\"internal compiler error\") {\n+        log(error, ~\"Stdout: \" + p.out);\n+        failed(~\"internal compiler error\")\n+\n+    } else {\n+        log(error, p.status);\n+        log(error, ~\"!Stdout: \" + p.out);\n+        failed(~\"What happened?\")\n+    }\n+}\n+\n+\n+fn parse_and_print(code: @~str) -> ~str {\n+    let filename = Path(\"tmp.rs\");\n+    let sess = parse::new_parse_sess(option::None);\n+    write_file(&filename, *code);\n+    let crate = parse::parse_crate_from_source_str(\n+        filename.to_str(), code, ~[], sess);\n+    do io::with_str_reader(*code) |rdr| {\n+        as_str(|a|\n+               pprust::print_crate(\n+                   sess.cm,\n+                   // Assuming there are no token_trees\n+                   syntax::parse::token::mk_fake_ident_interner(),\n+                   sess.span_diagnostic,\n+                   crate,\n+                   filename.to_str(),\n+                   rdr, a,\n+                   pprust::no_ann(),\n+                   false) )\n+    }\n+}\n+\n+fn has_raw_pointers(c: ast::crate) -> bool {\n+    let has_rp = @mut false;\n+    fn visit_ty(flag: @mut bool, t: @ast::Ty) {\n+        match t.node {\n+          ast::ty_ptr(_) => { *flag = true; }\n+          _ => { }\n+        }\n+    }\n+    let v =\n+        visit::mk_simple_visitor(@{visit_ty: |a| visit_ty(has_rp, a),\n+                                      .. *visit::default_simple_visitor()});\n+    visit::visit_crate(c, (), v);\n+    return *has_rp;\n+}\n+\n+fn content_is_dangerous_to_run(code: ~str) -> bool {\n+    let dangerous_patterns =\n+        ~[~\"xfail-test\",\n+         ~\"import\",  // espeically fs, run\n+         ~\"extern\",\n+         ~\"unsafe\",\n+         ~\"log\"];    // python --> rust pipe deadlock?\n+\n+    for dangerous_patterns.each |p| { if contains(code, *p) { return true; } }\n+    return false;\n+}\n+\n+fn content_is_dangerous_to_compile(code: ~str) -> bool {\n+    let dangerous_patterns =\n+        ~[~\"xfail-test\"];\n+\n+    for dangerous_patterns.each |p| { if contains(code, *p) { return true; } }\n+    return false;\n+}\n+\n+fn content_might_not_converge(code: ~str) -> bool {\n+    let confusing_patterns =\n+        ~[~\"xfail-test\",\n+         ~\"xfail-pretty\",\n+         ~\"self\",       // crazy rules enforced by parser not typechecker?\n+         ~\"spawn\",      // precedence issues?\n+         ~\"bind\",       // precedence issues?\n+         ~\" be \",       // don't want to replace its child with a non-call:\n+                       // \"Non-call expression in tail call\"\n+         ~\"\\n\\n\\n\\n\\n\"  // https://github.com/mozilla/rust/issues/850\n+        ];\n+\n+    for confusing_patterns.each |p| { if contains(code, *p) { return true; } }\n+    return false;\n+}\n+\n+fn file_might_not_converge(filename: &Path) -> bool {\n+    let confusing_files = ~[\n+      ~\"expr-alt.rs\", // pretty-printing \"(a = b) = c\"\n+                     // vs \"a = b = c\" and wrapping\n+      ~\"block-arg-in-ternary.rs\", // wrapping\n+      ~\"move-3-unique.rs\", // 0 becomes (0), but both seem reasonable. wtf?\n+      ~\"move-3.rs\"  // 0 becomes (0), but both seem reasonable. wtf?\n+    ];\n+\n+\n+    for confusing_files.each |f| {\n+        if contains(filename.to_str(), *f) {\n+            return true;\n+        }\n+    }\n+\n+    return false;\n+}\n+\n+fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n+\n+    let mut i = 0u;\n+    let mut newv = code;\n+    let mut oldv = code;\n+\n+    while i < maxIters {\n+        oldv = newv;\n+        if content_might_not_converge(*oldv) { return; }\n+        newv = @parse_and_print(oldv);\n+        if oldv == newv { break; }\n+        i += 1u;\n+    }\n+\n+    if oldv == newv {\n+        error!(\"Converged after %u iterations\", i);\n+    } else {\n+        error!(\"Did not converge after %u iterations!\", i);\n+        write_file(&Path(\"round-trip-a.rs\"), *oldv);\n+        write_file(&Path(\"round-trip-b.rs\"), *newv);\n+        run::run_program(~\"diff\",\n+                         ~[~\"-w\", ~\"-u\", ~\"round-trip-a.rs\",\n+                          ~\"round-trip-b.rs\"]);\n+        fail ~\"Mismatch\";\n+    }\n+}\n+\n+fn check_convergence(files: &[Path]) {\n+    error!(\"pp convergence tests: %u files\", vec::len(files));\n+    for files.each |file| {\n+        if !file_might_not_converge(file) {\n+            let s = @result::get(&io::read_whole_file_str(file));\n+            if !content_might_not_converge(*s) {\n+                error!(\"pp converge: %s\", file.to_str());\n+                // Change from 7u to 2u once\n+                // https://github.com/mozilla/rust/issues/850 is fixed\n+                check_roundtrip_convergence(s, 7u);\n+            }\n+        }\n+    }\n+}\n+\n+fn check_variants(files: &[Path], cx: context) {\n+    for files.each |file| {\n+        if cx.mode == tm_converge &&\n+            file_might_not_converge(file) {\n+            error!(\"Skipping convergence test based on\\\n+                    file_might_not_converge\");\n+            loop;\n+        }\n+\n+        let s = @result::get(&io::read_whole_file_str(file));\n+        if contains(*s, ~\"#\") {\n+            loop; // Macros are confusing\n+        }\n+        if cx.mode == tm_converge && content_might_not_converge(*s) {\n+            loop;\n+        }\n+        if cx.mode == tm_run && content_is_dangerous_to_compile(*s) {\n+            loop;\n+        }\n+\n+        let file_str = file.to_str();\n+\n+        log(error, ~\"check_variants: \" + file_str);\n+        let sess = parse::new_parse_sess(option::None);\n+        let crate =\n+            parse::parse_crate_from_source_str(\n+                file_str,\n+                s, ~[], sess);\n+        io::with_str_reader(*s, |rdr| {\n+            error!(\"%s\",\n+                   as_str(|a| pprust::print_crate(\n+                       sess.cm,\n+                       // Assuming no token_trees\n+                       syntax::parse::token::mk_fake_ident_interner(),\n+                       sess.span_diagnostic,\n+                       crate,\n+                       file_str,\n+                       rdr, a,\n+                       pprust::no_ann(),\n+                       false)))\n+        });\n+        check_variants_of_ast(*crate, sess.cm, file, cx);\n+    }\n+}\n+\n+fn main() {\n+    let args = os::args();\n+    if vec::len(args) != 2u {\n+        error!(\"usage: %s <testdir>\", args[0]);\n+        return;\n+    }\n+    let mut files = ~[];\n+    let root = Path(args[1]);\n+\n+    find_rust_files(&mut files, &root);\n+    error!(\"== check_convergence ==\");\n+    check_convergence(files);\n+    error!(\"== check_variants: converge ==\");\n+    check_variants(files, { mode: tm_converge });\n+    error!(\"== check_variants: run ==\");\n+    check_variants(files, { mode: tm_run });\n+\n+    error!(\"Fuzzer done\");\n+}\n+\n // Local Variables:\n // fill-column: 78;\n // indent-tabs-mode: nil"}, {"sha": "652837909b14acc2dce98e2e837f0c2a771c43ac", "filename": "src/libfuzzer/fuzzer.rs", "status": "removed", "additions": 0, "deletions": 638, "changes": 638, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibfuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibfuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,638 +0,0 @@\n-#[legacy_exports];\n-\n-use io::WriterUtil;\n-\n-use syntax::{ast, ast_util, fold, visit, codemap};\n-use syntax::parse;\n-use syntax::print::pprust;\n-use syntax::diagnostic;\n-\n-enum test_mode { tm_converge, tm_run, }\n-type context = { mode: test_mode }; // + rng\n-\n-#[cfg(stage0)]\n-impl test_mode : cmp::Eq {\n-    pure fn eq(other: &test_mode) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(other: &test_mode) -> bool { !self.eq(other) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-impl test_mode : cmp::Eq {\n-    pure fn eq(&self, other: &test_mode) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &test_mode) -> bool { !(*self).eq(other) }\n-}\n-\n-fn write_file(filename: &Path, content: ~str) {\n-    result::get(\n-        &io::file_writer(filename, ~[io::Create, io::Truncate]))\n-        .write_str(content);\n-}\n-\n-fn contains(haystack: ~str, needle: ~str) -> bool {\n-    str::contains(haystack, needle)\n-}\n-\n-fn find_rust_files(files: &mut ~[Path], path: &Path) {\n-    if path.filetype() == Some(~\".rs\") && !contains(path.to_str(), ~\"utf8\") {\n-        // ignoring \"utf8\" tests because something is broken\n-        files.push(*path);\n-    } else if os::path_is_dir(path)\n-        && !contains(path.to_str(), ~\"compile-fail\")\n-        && !contains(path.to_str(), ~\"build\") {\n-        for os::list_dir_path(path).each |p| {\n-            find_rust_files(files, *p);\n-        }\n-    }\n-}\n-\n-\n-fn common_exprs() -> ~[ast::expr] {\n-    fn dse(e: ast::expr_) -> ast::expr {\n-        { id: 0, callee_id: -1, node: e, span: ast_util::dummy_sp() }\n-    }\n-\n-    fn dsl(l: ast::lit_) -> ast::lit {\n-        { node: l, span: ast_util::dummy_sp() }\n-    }\n-\n-    ~[dse(ast::expr_break(option::None)),\n-     dse(ast::expr_again(option::None)),\n-     dse(ast::expr_fail(option::None)),\n-     dse(ast::expr_fail(option::Some(\n-         @dse(ast::expr_lit(@dsl(ast::lit_str(@~\"boo\"))))))),\n-     dse(ast::expr_ret(option::None)),\n-     dse(ast::expr_lit(@dsl(ast::lit_nil))),\n-     dse(ast::expr_lit(@dsl(ast::lit_bool(false)))),\n-     dse(ast::expr_lit(@dsl(ast::lit_bool(true)))),\n-     dse(ast::expr_unary(ast::box(ast::m_imm),\n-                         @dse(ast::expr_lit(@dsl(ast::lit_bool(true)))))),\n-     dse(ast::expr_unary(ast::uniq(ast::m_imm),\n-                         @dse(ast::expr_lit(@dsl(ast::lit_bool(true))))))\n-    ]\n-}\n-\n-pure fn safe_to_steal_expr(e: @ast::expr, tm: test_mode) -> bool {\n-    safe_to_use_expr(*e, tm)\n-}\n-\n-pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n-    match tm {\n-      tm_converge => {\n-        match e.node {\n-          // If the fuzzer moves a block-ending-in-semicolon into callee\n-          // position, the pretty-printer can't preserve this even by\n-          // parenthesizing!!  See email to marijn.\n-          ast::expr_if(*) | ast::expr_block(*)\n-          | ast::expr_match(*) | ast::expr_while(*)  => { false }\n-\n-          // https://github.com/mozilla/rust/issues/929\n-          ast::expr_cast(*) | ast::expr_assert(*) |\n-          ast::expr_binary(*) | ast::expr_assign(*) |\n-          ast::expr_assign_op(*) => { false }\n-\n-          ast::expr_fail(option::None) |\n-          ast::expr_ret(option::None) => { false }\n-\n-          // https://github.com/mozilla/rust/issues/953\n-          ast::expr_fail(option::Some(_)) => { false }\n-\n-          // https://github.com/mozilla/rust/issues/928\n-          //ast::expr_cast(_, _) { false }\n-\n-          // https://github.com/mozilla/rust/issues/1458\n-          ast::expr_call(_, _, _) => { false }\n-\n-          _ => { true }\n-        }\n-      }\n-      tm_run => { true }\n-    }\n-}\n-\n-fn safe_to_steal_ty(t: @ast::Ty, tm: test_mode) -> bool {\n-    // Restrictions happen to be the same.\n-    safe_to_replace_ty(t.node, tm)\n-}\n-\n-// Not type-parameterized: https://github.com/mozilla/rust/issues/898 (FIXED)\n-fn stash_expr_if(c: fn@(@ast::expr, test_mode)->bool,\n-                 es: @mut ~[ast::expr],\n-                 e: @ast::expr,\n-                 tm: test_mode) {\n-    if c(e, tm) {\n-        *es += ~[*e];\n-    } else {/* now my indices are wrong :( */ }\n-}\n-\n-fn stash_ty_if(c: fn@(@ast::Ty, test_mode)->bool,\n-               es: @mut ~[ast::Ty],\n-               e: @ast::Ty,\n-               tm: test_mode) {\n-    if c(e, tm) {\n-        es.push(*e);\n-    } else {/* now my indices are wrong :( */ }\n-}\n-\n-type stolen_stuff = {exprs: ~[ast::expr], tys: ~[ast::Ty]};\n-\n-fn steal(crate: ast::crate, tm: test_mode) -> stolen_stuff {\n-    let exprs = @mut ~[];\n-    let tys = @mut ~[];\n-    let v = visit::mk_simple_visitor(@{\n-        visit_expr: |a| stash_expr_if(safe_to_steal_expr, exprs, a, tm),\n-        visit_ty: |a| stash_ty_if(safe_to_steal_ty, tys, a, tm),\n-        .. *visit::default_simple_visitor()\n-    });\n-    visit::visit_crate(crate, (), v);\n-    {exprs: *exprs, tys: *tys}\n-}\n-\n-\n-fn safe_to_replace_expr(e: ast::expr_, _tm: test_mode) -> bool {\n-    match e {\n-      // https://github.com/mozilla/rust/issues/652\n-      ast::expr_if(*) => { false }\n-      ast::expr_block(_) => { false }\n-\n-      // expr_call is also missing a constraint\n-      ast::expr_fn_block(*) => { false }\n-\n-      _ => { true }\n-    }\n-}\n-\n-fn safe_to_replace_ty(t: ast::ty_, _tm: test_mode) -> bool {\n-    match t {\n-      ast::ty_infer => { false } // always implicit, always top level\n-      ast::ty_bot => { false }   // in source, can only appear\n-                              // as the out type of a function\n-      ast::ty_mac(_) => { false }\n-      _ => { true }\n-    }\n-}\n-\n-// Replace the |i|th expr (in fold order) of |crate| with |newexpr|.\n-fn replace_expr_in_crate(crate: ast::crate, i: uint,\n-                         newexpr: ast::expr, tm: test_mode) ->\n-   ast::crate {\n-    let j: @mut uint = @mut 0u;\n-    fn fold_expr_rep(j_: @mut uint, i_: uint, newexpr_: ast::expr_,\n-                     original: ast::expr_, fld: fold::ast_fold,\n-                     tm_: test_mode) ->\n-       ast::expr_ {\n-        *j_ += 1u;\n-        if i_ + 1u == *j_ && safe_to_replace_expr(original, tm_) {\n-            newexpr_\n-        } else {\n-            fold::noop_fold_expr(original, fld)\n-        }\n-    }\n-    let afp = @{\n-        fold_expr: fold::wrap(|a,b| {\n-            fold_expr_rep(j, i, newexpr.node, a, b, tm)\n-        }),\n-        .. *fold::default_ast_fold()\n-    };\n-    let af = fold::make_fold(afp);\n-    let crate2: @ast::crate = @af.fold_crate(crate);\n-    *crate2\n-}\n-\n-\n-// Replace the |i|th ty (in fold order) of |crate| with |newty|.\n-fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::Ty,\n-                       tm: test_mode) -> ast::crate {\n-    let j: @mut uint = @mut 0u;\n-    fn fold_ty_rep(j_: @mut uint, i_: uint, newty_: ast::ty_,\n-                   original: ast::ty_, fld: fold::ast_fold,\n-                   tm_: test_mode) ->\n-       ast::ty_ {\n-        *j_ += 1u;\n-        if i_ + 1u == *j_ && safe_to_replace_ty(original, tm_) {\n-            newty_\n-        } else { fold::noop_fold_ty(original, fld) }\n-    }\n-    let afp = @{\n-        fold_ty: fold::wrap(|a,b| fold_ty_rep(j, i, newty.node, a, b, tm) ),\n-        .. *fold::default_ast_fold()\n-    };\n-    let af = fold::make_fold(afp);\n-    let crate2: @ast::crate = @af.fold_crate(crate);\n-    *crate2\n-}\n-\n-fn under(n: uint, it: fn(uint)) {\n-    let mut i: uint = 0u;\n-    while i < n { it(i); i += 1u; }\n-}\n-\n-fn as_str(f: fn@(+x: io::Writer)) -> ~str {\n-    io::with_str_writer(f)\n-}\n-\n-fn check_variants_of_ast(crate: ast::crate, codemap: @codemap::CodeMap,\n-                         filename: &Path, cx: context) {\n-    let stolen = steal(crate, cx.mode);\n-    let extra_exprs = vec::filter(common_exprs(),\n-                                  |a| safe_to_use_expr(*a, cx.mode) );\n-    check_variants_T(crate, codemap, filename, ~\"expr\",\n-                     extra_exprs + stolen.exprs, pprust::expr_to_str,\n-                     replace_expr_in_crate, cx);\n-    check_variants_T(crate, codemap, filename, ~\"ty\", stolen.tys,\n-                     pprust::ty_to_str, replace_ty_in_crate, cx);\n-}\n-\n-fn check_variants_T<T: Copy>(\n-  crate: ast::crate,\n-  codemap: @codemap::CodeMap,\n-  filename: &Path,\n-  thing_label: ~str,\n-  things: ~[T],\n-  stringifier: fn@(@T, @syntax::parse::token::ident_interner) -> ~str,\n-  replacer: fn@(ast::crate, uint, T, test_mode) -> ast::crate,\n-  cx: context\n-  ) {\n-    error!(\"%s contains %u %s objects\", filename.to_str(),\n-           things.len(), thing_label);\n-\n-    // Assuming we're not generating any token_trees\n-    let intr = syntax::parse::token::mk_fake_ident_interner();\n-\n-    let L = things.len();\n-\n-    if L < 100 {\n-        do under(uint::min(L, 20)) |i| {\n-            log(error, ~\"Replacing... #\" + uint::str(i));\n-            let fname = str::from_slice(filename.to_str());\n-            do under(uint::min(L, 30)) |j| {\n-                log(error, ~\"With... \" + stringifier(@things[j], intr));\n-                let crate2 = @replacer(crate, i, things[j], cx.mode);\n-                // It would be best to test the *crate* for stability, but\n-                // testing the string for stability is easier and ok for now.\n-                let handler = diagnostic::mk_handler(None);\n-                let str3 = do io::with_str_reader(\"\") |rdr| {\n-                    @as_str(|a|pprust::print_crate(\n-                        codemap,\n-                        intr,\n-                        diagnostic::mk_span_handler(handler, codemap),\n-                        crate2,\n-                        fname,\n-                        rdr, a,\n-                        pprust::no_ann(),\n-                        false))\n-                };\n-                match cx.mode {\n-                  tm_converge => {\n-                    check_roundtrip_convergence(str3, 1u);\n-                  }\n-                  tm_run => {\n-                    let file_label = fmt!(\"rusttmp/%s_%s_%u_%u\",\n-                                          last_part(filename.to_str()),\n-                                          thing_label, i, j);\n-                    let safe_to_run = !(content_is_dangerous_to_run(*str3)\n-                                        || has_raw_pointers(*crate2));\n-                    check_whole_compiler(*str3, &Path(file_label),\n-                                         safe_to_run);\n-                  }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn last_part(filename: ~str) -> ~str {\n-  let ix = option::get(str::rfind_char(filename, '/'));\n-  str::slice(filename, ix + 1u, str::len(filename) - 3u)\n-}\n-\n-enum happiness {\n-    passed,\n-    cleanly_rejected(~str),\n-    known_bug(~str),\n-    failed(~str),\n-}\n-\n-// We'd find more bugs if we could take an AST here, but\n-// - that would find many \"false positives\" or unimportant bugs\n-// - that would be tricky, requiring use of tasks or serialization\n-//   or randomness.\n-// This seems to find plenty of bugs as it is :)\n-fn check_whole_compiler(code: ~str, suggested_filename_prefix: &Path,\n-                        allow_running: bool) {\n-    let filename = &suggested_filename_prefix.with_filetype(\"rs\");\n-    write_file(filename, code);\n-\n-    let compile_result = check_compiling(filename);\n-\n-    let run_result = match (compile_result, allow_running) {\n-      (passed, true) => { check_running(suggested_filename_prefix) }\n-      (h, _) => { h }\n-    };\n-\n-    match run_result {\n-      passed | cleanly_rejected(_) | known_bug(_) => {\n-        removeIfExists(suggested_filename_prefix);\n-        removeIfExists(&suggested_filename_prefix.with_filetype(\"rs\"));\n-        removeDirIfExists(&suggested_filename_prefix.with_filetype(\"dSYM\"));\n-      }\n-      failed(s) => {\n-        log(error, ~\"check_whole_compiler failure: \" + s);\n-        log(error, ~\"Saved as: \" + filename.to_str());\n-      }\n-    }\n-}\n-\n-fn removeIfExists(filename: &Path) {\n-    // So sketchy!\n-    assert !contains(filename.to_str(), ~\" \");\n-    run::program_output(~\"bash\", ~[~\"-c\", ~\"rm \" + filename.to_str()]);\n-}\n-\n-fn removeDirIfExists(filename: &Path) {\n-    // So sketchy!\n-    assert !contains(filename.to_str(), ~\" \");\n-    run::program_output(~\"bash\", ~[~\"-c\", ~\"rm -r \" + filename.to_str()]);\n-}\n-\n-fn check_running(exe_filename: &Path) -> happiness {\n-    let p = run::program_output(\n-        ~\"/Users/jruderman/scripts/timed_run_rust_program.py\",\n-        ~[exe_filename.to_str()]);\n-    let comb = p.out + ~\"\\n\" + p.err;\n-    if str::len(comb) > 1u {\n-        log(error, ~\"comb comb comb: \" + comb);\n-    }\n-\n-    if contains(comb, ~\"Assertion failed:\") {\n-        failed(~\"C++ assertion failure\")\n-    } else if contains(comb, ~\"leaked memory in rust main loop\") {\n-        // might also use exit code 134\n-        //failed(\"Leaked\")\n-        known_bug(~\"https://github.com/mozilla/rust/issues/910\")\n-    } else if contains(comb, ~\"src/rt/\") {\n-        failed(~\"Mentioned src/rt/\")\n-    } else if contains(comb, ~\"malloc\") {\n-        failed(~\"Mentioned malloc\")\n-    } else {\n-        match p.status {\n-            0         => { passed }\n-            100       => { cleanly_rejected(~\"running: explicit fail\") }\n-            101 | 247 => { cleanly_rejected(~\"running: timed out\") }\n-            245 | 246 | 138 | 252 => {\n-              known_bug(~\"https://github.com/mozilla/rust/issues/1466\")\n-            }\n-            136 | 248 => {\n-              known_bug(\n-                  ~\"SIGFPE - https://github.com/mozilla/rust/issues/944\")\n-            }\n-            rc => {\n-              failed(~\"Rust program ran but exited with status \" +\n-                     int::str(rc))\n-            }\n-        }\n-    }\n-}\n-\n-fn check_compiling(filename: &Path) -> happiness {\n-    let p = run::program_output(\n-        ~\"/Users/jruderman/code/rust/build/x86_64-apple-darwin/\\\n-         stage1/bin/rustc\",\n-        ~[filename.to_str()]);\n-\n-    //error!(\"Status: %d\", p.status);\n-    if p.status == 0 {\n-        passed\n-    } else if p.err != ~\"\" {\n-        if contains(p.err, ~\"error:\") {\n-            cleanly_rejected(~\"rejected with span_error\")\n-        } else {\n-            log(error, ~\"Stderr: \" + p.err);\n-            failed(~\"Unfamiliar error message\")\n-        }\n-    } else if contains(p.out, ~\"Assertion\") && contains(p.out, ~\"failed\") {\n-        log(error, ~\"Stdout: \" + p.out);\n-        failed(~\"Looks like an llvm assertion failure\")\n-    } else if contains(p.out, ~\"internal compiler error unimplemented\") {\n-        known_bug(~\"Something unimplemented\")\n-    } else if contains(p.out, ~\"internal compiler error\") {\n-        log(error, ~\"Stdout: \" + p.out);\n-        failed(~\"internal compiler error\")\n-\n-    } else {\n-        log(error, p.status);\n-        log(error, ~\"!Stdout: \" + p.out);\n-        failed(~\"What happened?\")\n-    }\n-}\n-\n-\n-fn parse_and_print(code: @~str) -> ~str {\n-    let filename = Path(\"tmp.rs\");\n-    let sess = parse::new_parse_sess(option::None);\n-    write_file(&filename, *code);\n-    let crate = parse::parse_crate_from_source_str(\n-        filename.to_str(), code, ~[], sess);\n-    do io::with_str_reader(*code) |rdr| {\n-        as_str(|a|\n-               pprust::print_crate(\n-                   sess.cm,\n-                   // Assuming there are no token_trees\n-                   syntax::parse::token::mk_fake_ident_interner(),\n-                   sess.span_diagnostic,\n-                   crate,\n-                   filename.to_str(),\n-                   rdr, a,\n-                   pprust::no_ann(),\n-                   false) )\n-    }\n-}\n-\n-fn has_raw_pointers(c: ast::crate) -> bool {\n-    let has_rp = @mut false;\n-    fn visit_ty(flag: @mut bool, t: @ast::Ty) {\n-        match t.node {\n-          ast::ty_ptr(_) => { *flag = true; }\n-          _ => { }\n-        }\n-    }\n-    let v =\n-        visit::mk_simple_visitor(@{visit_ty: |a| visit_ty(has_rp, a),\n-                                      .. *visit::default_simple_visitor()});\n-    visit::visit_crate(c, (), v);\n-    return *has_rp;\n-}\n-\n-fn content_is_dangerous_to_run(code: ~str) -> bool {\n-    let dangerous_patterns =\n-        ~[~\"xfail-test\",\n-         ~\"import\",  // espeically fs, run\n-         ~\"extern\",\n-         ~\"unsafe\",\n-         ~\"log\"];    // python --> rust pipe deadlock?\n-\n-    for dangerous_patterns.each |p| { if contains(code, *p) { return true; } }\n-    return false;\n-}\n-\n-fn content_is_dangerous_to_compile(code: ~str) -> bool {\n-    let dangerous_patterns =\n-        ~[~\"xfail-test\"];\n-\n-    for dangerous_patterns.each |p| { if contains(code, *p) { return true; } }\n-    return false;\n-}\n-\n-fn content_might_not_converge(code: ~str) -> bool {\n-    let confusing_patterns =\n-        ~[~\"xfail-test\",\n-         ~\"xfail-pretty\",\n-         ~\"self\",       // crazy rules enforced by parser not typechecker?\n-         ~\"spawn\",      // precedence issues?\n-         ~\"bind\",       // precedence issues?\n-         ~\" be \",       // don't want to replace its child with a non-call:\n-                       // \"Non-call expression in tail call\"\n-         ~\"\\n\\n\\n\\n\\n\"  // https://github.com/mozilla/rust/issues/850\n-        ];\n-\n-    for confusing_patterns.each |p| { if contains(code, *p) { return true; } }\n-    return false;\n-}\n-\n-fn file_might_not_converge(filename: &Path) -> bool {\n-    let confusing_files = ~[\n-      ~\"expr-alt.rs\", // pretty-printing \"(a = b) = c\"\n-                     // vs \"a = b = c\" and wrapping\n-      ~\"block-arg-in-ternary.rs\", // wrapping\n-      ~\"move-3-unique.rs\", // 0 becomes (0), but both seem reasonable. wtf?\n-      ~\"move-3.rs\"  // 0 becomes (0), but both seem reasonable. wtf?\n-    ];\n-\n-\n-    for confusing_files.each |f| {\n-        if contains(filename.to_str(), *f) {\n-            return true;\n-        }\n-    }\n-\n-    return false;\n-}\n-\n-fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n-\n-    let mut i = 0u;\n-    let mut newv = code;\n-    let mut oldv = code;\n-\n-    while i < maxIters {\n-        oldv = newv;\n-        if content_might_not_converge(*oldv) { return; }\n-        newv = @parse_and_print(oldv);\n-        if oldv == newv { break; }\n-        i += 1u;\n-    }\n-\n-    if oldv == newv {\n-        error!(\"Converged after %u iterations\", i);\n-    } else {\n-        error!(\"Did not converge after %u iterations!\", i);\n-        write_file(&Path(\"round-trip-a.rs\"), *oldv);\n-        write_file(&Path(\"round-trip-b.rs\"), *newv);\n-        run::run_program(~\"diff\",\n-                         ~[~\"-w\", ~\"-u\", ~\"round-trip-a.rs\",\n-                          ~\"round-trip-b.rs\"]);\n-        fail ~\"Mismatch\";\n-    }\n-}\n-\n-fn check_convergence(files: &[Path]) {\n-    error!(\"pp convergence tests: %u files\", vec::len(files));\n-    for files.each |file| {\n-        if !file_might_not_converge(file) {\n-            let s = @result::get(&io::read_whole_file_str(file));\n-            if !content_might_not_converge(*s) {\n-                error!(\"pp converge: %s\", file.to_str());\n-                // Change from 7u to 2u once\n-                // https://github.com/mozilla/rust/issues/850 is fixed\n-                check_roundtrip_convergence(s, 7u);\n-            }\n-        }\n-    }\n-}\n-\n-fn check_variants(files: &[Path], cx: context) {\n-    for files.each |file| {\n-        if cx.mode == tm_converge &&\n-            file_might_not_converge(file) {\n-            error!(\"Skipping convergence test based on\\\n-                    file_might_not_converge\");\n-            loop;\n-        }\n-\n-        let s = @result::get(&io::read_whole_file_str(file));\n-        if contains(*s, ~\"#\") {\n-            loop; // Macros are confusing\n-        }\n-        if cx.mode == tm_converge && content_might_not_converge(*s) {\n-            loop;\n-        }\n-        if cx.mode == tm_run && content_is_dangerous_to_compile(*s) {\n-            loop;\n-        }\n-\n-        let file_str = file.to_str();\n-\n-        log(error, ~\"check_variants: \" + file_str);\n-        let sess = parse::new_parse_sess(option::None);\n-        let crate =\n-            parse::parse_crate_from_source_str(\n-                file_str,\n-                s, ~[], sess);\n-        io::with_str_reader(*s, |rdr| {\n-            error!(\"%s\",\n-                   as_str(|a| pprust::print_crate(\n-                       sess.cm,\n-                       // Assuming no token_trees\n-                       syntax::parse::token::mk_fake_ident_interner(),\n-                       sess.span_diagnostic,\n-                       crate,\n-                       file_str,\n-                       rdr, a,\n-                       pprust::no_ann(),\n-                       false)))\n-        });\n-        check_variants_of_ast(*crate, sess.cm, file, cx);\n-    }\n-}\n-\n-fn main() {\n-    let args = os::args();\n-    if vec::len(args) != 2u {\n-        error!(\"usage: %s <testdir>\", args[0]);\n-        return;\n-    }\n-    let mut files = ~[];\n-    let root = Path(args[1]);\n-\n-    find_rust_files(&mut files, &root);\n-    error!(\"== check_convergence ==\");\n-    check_convergence(files);\n-    error!(\"== check_variants: converge ==\");\n-    check_variants(files, { mode: tm_converge });\n-    error!(\"== check_variants: run ==\");\n-    check_variants(files, { mode: tm_run });\n-\n-    error!(\"Fuzzer done\");\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "36cbdf8c6646d807c99888124e6d44fa48280fa9", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -27,19 +27,9 @@ enum output_type {\n }\n \n impl output_type : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &output_type) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &output_type) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &output_type) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &output_type) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "ba6b34ac5e67bfb15aa621d736e843c537ff3966", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -141,19 +141,9 @@ enum compile_upto {\n }\n \n impl compile_upto : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &compile_upto) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &compile_upto) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &compile_upto) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &compile_upto) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "7d9a55571d4914c139617d74943b12cd9e7fc67a", "filename": "src/librustc/driver/mod.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,5 @@\n+#[legacy_exports];\n+#[legacy_exports]\n+mod driver;\n+#[legacy_exports]\n+mod session;"}, {"sha": "7614bdbb25b39aadcd85644a980be78883ebebca", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -13,38 +13,18 @@ use middle::lint;\n enum os { os_win32, os_macos, os_linux, os_freebsd, }\n \n impl os : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &os) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &os) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &os) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &os) -> bool { !(*self).eq(other) }\n }\n \n enum arch { arch_x86, arch_x86_64, arch_arm, }\n \n impl arch : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &arch) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &arch) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &arch) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &arch) -> bool { !(*self).eq(other) }\n }\n \n@@ -111,19 +91,9 @@ enum OptLevel {\n }\n \n impl OptLevel : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &OptLevel) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &OptLevel) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &OptLevel) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &OptLevel) -> bool { !(*self).eq(other) }\n }\n \n@@ -357,7 +327,6 @@ mod test {\n         if with_bin { attrs += ~[make_crate_type_attr(~\"bin\")]; }\n         if with_lib { attrs += ~[make_crate_type_attr(~\"lib\")]; }\n         @ast_util::respan(ast_util::dummy_sp(), {\n-            directives: ~[],\n             module: {view_items: ~[], items: ~[]},\n             attrs: attrs,\n             config: ~[]"}, {"sha": "fa364700b74d3823d9ca36bafce3f0424c8bfce5", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -131,45 +131,6 @@ enum TypeKind {\n }\n \n impl TypeKind : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &TypeKind) -> bool {\n-        match (self, (*other)) {\n-            (Void, Void) => true,\n-            (Half, Half) => true,\n-            (Float, Float) => true,\n-            (Double, Double) => true,\n-            (X86_FP80, X86_FP80) => true,\n-            (FP128, FP128) => true,\n-            (PPC_FP128, PPC_FP128) => true,\n-            (Label, Label) => true,\n-            (Integer, Integer) => true,\n-            (Function, Function) => true,\n-            (Struct, Struct) => true,\n-            (Array, Array) => true,\n-            (Pointer, Pointer) => true,\n-            (Vector, Vector) => true,\n-            (Metadata, Metadata) => true,\n-            (X86_MMX, X86_MMX) => true,\n-            (Void, _) => false,\n-            (Half, _) => false,\n-            (Float, _) => false,\n-            (Double, _) => false,\n-            (X86_FP80, _) => false,\n-            (FP128, _) => false,\n-            (PPC_FP128, _) => false,\n-            (Label, _) => false,\n-            (Integer, _) => false,\n-            (Function, _) => false,\n-            (Struct, _) => false,\n-            (Array, _) => false,\n-            (Pointer, _) => false,\n-            (Vector, _) => false,\n-            (Metadata, _) => false,\n-            (X86_MMX, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &TypeKind) -> bool {\n         match ((*self), (*other)) {\n             (Void, Void) => true,\n@@ -206,10 +167,6 @@ impl TypeKind : cmp::Eq {\n             (X86_MMX, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &TypeKind) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &TypeKind) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "62235efb14d4d7e179199b7e24622a9a2dee2863", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -140,19 +140,9 @@ enum Family {\n }\n \n impl Family : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Family) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Family) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Family) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Family) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "a82ad39d412e1575c58f1e71d786a9c5c6824d6f", "filename": "src/librustc/metadata/mod.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmetadata%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmetadata%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmod.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,32 @@\n+#[legacy_exports];\n+export encoder;\n+export creader;\n+export cstore;\n+export csearch;\n+export common;\n+export decoder;\n+export tyencode;\n+export tydecode;\n+export loader;\n+export filesearch;\n+\n+#[legacy_exports]\n+mod common;\n+#[legacy_exports]\n+mod tyencode;\n+#[legacy_exports]\n+mod tydecode;\n+#[legacy_exports]\n+mod encoder;\n+#[legacy_exports]\n+mod decoder;\n+#[legacy_exports]\n+mod creader;\n+#[legacy_exports]\n+mod cstore;\n+#[legacy_exports]\n+mod csearch;\n+#[legacy_exports]\n+mod loader;\n+#[legacy_exports]\n+mod filesearch;"}, {"sha": "df573b121f8e3f0de172121fa9fd784d913af674", "filename": "src/librustc/middle/borrowck.rs", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -323,50 +323,6 @@ enum bckerr_code {\n }\n \n impl bckerr_code : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &bckerr_code) -> bool {\n-        match self {\n-            err_mut_uniq => {\n-                match (*other) {\n-                    err_mut_uniq => true,\n-                    _ => false\n-                }\n-            }\n-            err_mut_variant => {\n-                match (*other) {\n-                    err_mut_variant => true,\n-                    _ => false\n-                }\n-            }\n-            err_root_not_permitted => {\n-                match (*other) {\n-                    err_root_not_permitted => true,\n-                    _ => false\n-                }\n-            }\n-            err_mutbl(e0a) => {\n-                match (*other) {\n-                    err_mutbl(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            err_out_of_root_scope(e0a, e1a) => {\n-                match (*other) {\n-                    err_out_of_root_scope(e0b, e1b) =>\n-                        e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            err_out_of_scope(e0a, e1a) => {\n-                match (*other) {\n-                    err_out_of_scope(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &bckerr_code) -> bool {\n         match (*self) {\n             err_mut_uniq => {\n@@ -408,10 +364,6 @@ impl bckerr_code : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &bckerr_code) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &bckerr_code) -> bool { !(*self).eq(other) }\n }\n \n@@ -420,19 +372,9 @@ impl bckerr_code : cmp::Eq {\n type bckerr = {cmt: cmt, code: bckerr_code};\n \n impl bckerr : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &bckerr) -> bool {\n-        self.cmt == (*other).cmt && self.code == (*other).code\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &bckerr) -> bool {\n         (*self).cmt == (*other).cmt && (*self).code == (*other).code\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &bckerr) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &bckerr) -> bool { !(*self).eq(other) }\n }\n \n@@ -463,21 +405,9 @@ fn save_and_restore<T:Copy,U>(save_and_restore_t: &mut T, f: fn() -> U) -> U {\n /// Creates and returns a new root_map\n \n impl root_map_key : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &root_map_key) -> bool {\n-        self.id == (*other).id && self.derefs == (*other).derefs\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &root_map_key) -> bool {\n         (*self).id == (*other).id && (*self).derefs == (*other).derefs\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &root_map_key) -> bool {\n-        ! (self == (*other))\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &root_map_key) -> bool {\n         ! ((*self) == (*other))\n     }"}, {"sha": "a9deb51f1c71e760ea33026cf3cddc2bd4ee11cf", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -33,25 +33,6 @@ enum purity_cause {\n }\n \n impl purity_cause : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &purity_cause) -> bool {\n-        match self {\n-            pc_pure_fn => {\n-                match (*other) {\n-                    pc_pure_fn => true,\n-                    _ => false\n-                }\n-            }\n-            pc_cmt(e0a) => {\n-                match (*other) {\n-                    pc_cmt(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &purity_cause) -> bool {\n         match (*self) {\n             pc_pure_fn => {\n@@ -68,10 +49,6 @@ impl purity_cause : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &purity_cause) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &purity_cause) -> bool { !(*self).eq(other) }\n }\n \n@@ -97,19 +74,9 @@ enum assignment_type {\n }\n \n impl assignment_type : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &assignment_type) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &assignment_type) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &assignment_type) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &assignment_type) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "c44110084048bf880b71e4995f83f22ed5d1e873", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,9 @@\n+#[legacy_exports];\n+#[legacy_exports]\n+mod check_loans;\n+#[legacy_exports]\n+mod gather_loans;\n+#[legacy_exports]\n+mod loan;\n+#[legacy_exports]\n+mod preserve;"}, {"sha": "e7716ad984eb38dc61df721db0183ef5aba43c1f", "filename": "src/librustc/middle/check_alt.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -126,22 +126,6 @@ enum ctor {\n }\n \n impl ctor : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ctor) -> bool {\n-        match (self, (*other)) {\n-            (single, single) => true,\n-            (variant(did_self), variant(did_other)) => did_self == did_other,\n-            (val(cv_self), val(cv_other)) => cv_self == cv_other,\n-            (range(cv0_self, cv1_self), range(cv0_other, cv1_other)) => {\n-                cv0_self == cv0_other && cv1_self == cv1_other\n-            }\n-            (single, _) | (variant(_), _) | (val(_), _) | (range(*), _) => {\n-                false\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ctor) -> bool {\n         match ((*self), (*other)) {\n             (single, single) => true,\n@@ -155,10 +139,6 @@ impl ctor : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ctor) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ctor) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "ef1a5ff3caacfe276c149d123e68b963c768b561", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -207,20 +207,6 @@ enum const_val {\n }\n \n impl const_val : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &const_val) -> bool {\n-        match (self, (*other)) {\n-            (const_float(a), const_float(b)) => a == b,\n-            (const_int(a), const_int(b)) => a == b,\n-            (const_uint(a), const_uint(b)) => a == b,\n-            (const_str(a), const_str(b)) => a == b,\n-            (const_bool(a), const_bool(b)) => a == b,\n-            (const_float(_), _) | (const_int(_), _) | (const_uint(_), _) |\n-            (const_str(_), _) | (const_bool(_), _) => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &const_val) -> bool {\n         match ((*self), (*other)) {\n             (const_float(a), const_float(b)) => a == b,\n@@ -232,10 +218,6 @@ impl const_val : cmp::Eq {\n             (const_str(_), _) | (const_bool(_), _) => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &const_val) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &const_val) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "3691f62cc0da9d8b8c89135ce928fc47e298c8c9", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -68,19 +68,9 @@ enum lint {\n }\n \n impl lint : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &lint) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &lint) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &lint) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &lint) -> bool { !(*self).eq(other) }\n }\n \n@@ -98,19 +88,9 @@ enum level {\n }\n \n impl level : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &level) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &level) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &level) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &level) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "0f1b7489f4318befb758055ee4886e5152e7a3d0", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -119,28 +119,12 @@ enum Variable = uint;\n enum LiveNode = uint;\n \n impl Variable : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Variable) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Variable) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Variable) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Variable) -> bool { *(*self) != *(*other) }\n }\n \n impl LiveNode : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &LiveNode) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &LiveNode) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &LiveNode) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &LiveNode) -> bool { *(*self) != *(*other) }\n }\n \n@@ -152,37 +136,6 @@ enum LiveNodeKind {\n }\n \n impl LiveNodeKind : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &LiveNodeKind) -> bool {\n-        match self {\n-            FreeVarNode(e0a) => {\n-                match (*other) {\n-                    FreeVarNode(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ExprNode(e0a) => {\n-                match (*other) {\n-                    ExprNode(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            VarDefNode(e0a) => {\n-                match (*other) {\n-                    VarDefNode(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ExitNode => {\n-                match (*other) {\n-                    ExitNode => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &LiveNodeKind) -> bool {\n         match (*self) {\n             FreeVarNode(e0a) => {\n@@ -211,10 +164,6 @@ impl LiveNodeKind : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &LiveNodeKind) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &LiveNodeKind) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "fd5735e78defffa4aab5fb075a4f6349661e60fc", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 0, "deletions": 202, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -56,68 +56,6 @@ enum categorization {\n }\n \n impl categorization : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &categorization) -> bool {\n-        match self {\n-            cat_rvalue => {\n-                match (*other) {\n-                    cat_rvalue => true,\n-                    _ => false\n-                }\n-            }\n-            cat_special(e0a) => {\n-                match (*other) {\n-                    cat_special(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            cat_local(e0a) => {\n-                match (*other) {\n-                    cat_local(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            cat_binding(e0a) => {\n-                match (*other) {\n-                    cat_binding(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            cat_arg(e0a) => {\n-                match (*other) {\n-                    cat_arg(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            cat_stack_upvar(e0a) => {\n-                match (*other) {\n-                    cat_stack_upvar(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            cat_deref(e0a, e1a, e2a) => {\n-                match (*other) {\n-                    cat_deref(e0b, e1b, e2b) =>\n-                        e0a == e0b && e1a == e1b && e2a == e2b,\n-                    _ => false\n-                }\n-            }\n-            cat_comp(e0a, e1a) => {\n-                match (*other) {\n-                    cat_comp(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            cat_discr(e0a, e1a) => {\n-                match (*other) {\n-                    cat_discr(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &categorization) -> bool {\n         match (*self) {\n             cat_rvalue => {\n@@ -177,10 +115,6 @@ impl categorization : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &categorization) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &categorization) -> bool { !(*self).eq(other) }\n }\n \n@@ -193,37 +127,6 @@ enum ptr_kind {\n }\n \n impl ptr_kind : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ptr_kind) -> bool {\n-        match self {\n-            uniq_ptr => {\n-                match (*other) {\n-                    uniq_ptr => true,\n-                    _ => false\n-                }\n-            }\n-            gc_ptr => {\n-                match (*other) {\n-                    gc_ptr => true,\n-                    _ => false\n-                }\n-            }\n-            region_ptr(e0a) => {\n-                match (*other) {\n-                    region_ptr(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            unsafe_ptr => {\n-                match (*other) {\n-                    unsafe_ptr => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ptr_kind) -> bool {\n         match (*self) {\n             uniq_ptr => {\n@@ -252,10 +155,6 @@ impl ptr_kind : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ptr_kind) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ptr_kind) -> bool { !(*self).eq(other) }\n }\n \n@@ -273,43 +172,6 @@ enum comp_kind {\n }\n \n impl comp_kind : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &comp_kind) -> bool {\n-        match self {\n-            comp_tuple => {\n-                match (*other) {\n-                    comp_tuple => true,\n-                    _ => false\n-                }\n-            }\n-            comp_anon_field => {\n-                match (*other) {\n-                    comp_anon_field => true,\n-                    _ => false\n-                }\n-            }\n-            comp_variant(e0a) => {\n-                match (*other) {\n-                    comp_variant(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            comp_field(e0a, e1a) => {\n-                match (*other) {\n-                    comp_field(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            comp_index(e0a, e1a) => {\n-                match (*other) {\n-                    comp_index(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &comp_kind) -> bool {\n         match (*self) {\n             comp_tuple => {\n@@ -344,10 +206,6 @@ impl comp_kind : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &comp_kind) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &comp_kind) -> bool { !(*self).eq(other) }\n }\n \n@@ -360,19 +218,9 @@ enum special_kind {\n }\n \n impl special_kind : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &special_kind) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &special_kind) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &special_kind) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &special_kind) -> bool { !(*self).eq(other) }\n }\n \n@@ -389,17 +237,6 @@ type cmt_ = {id: ast::node_id,        // id of expr/pat producing this value\n type cmt = @cmt_;\n \n impl cmt_ : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &cmt_) -> bool {\n-        self.id == (*other).id &&\n-        self.span == (*other).span &&\n-        self.cat == (*other).cat &&\n-        self.lp == (*other).lp &&\n-        self.mutbl == (*other).mutbl &&\n-        self.ty == (*other).ty\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &cmt_) -> bool {\n         (*self).id == (*other).id &&\n         (*self).span == (*other).span &&\n@@ -408,10 +245,6 @@ impl cmt_ : cmp::Eq {\n         (*self).mutbl == (*other).mutbl &&\n         (*self).ty == (*other).ty\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &cmt_) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &cmt_) -> bool { !(*self).eq(other) }\n }\n \n@@ -426,37 +259,6 @@ enum loan_path {\n }\n \n impl loan_path : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &loan_path) -> bool {\n-        match self {\n-            lp_local(e0a) => {\n-                match (*other) {\n-                    lp_local(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            lp_arg(e0a) => {\n-                match (*other) {\n-                    lp_arg(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            lp_deref(e0a, e1a) => {\n-                match (*other) {\n-                    lp_deref(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            lp_comp(e0a, e1a) => {\n-                match (*other) {\n-                    lp_comp(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &loan_path) -> bool {\n         match (*self) {\n             lp_local(e0a) => {\n@@ -485,10 +287,6 @@ impl loan_path : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &loan_path) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &loan_path) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "dccb3965753a9b3bd2f573f05a32b2856572446c", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -148,6 +148,9 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n \n             visit::visit_mod(the_module, span, node_id, method_map, visitor);\n \n+            // FIXME #4054: n_added gets corrupted without this log statement\n+            debug!(\"%i\", n_added);\n+\n             for n_added.times {\n                 ignore(privileged_items.pop());\n             }"}, {"sha": "e7dec95f09a2846dcbe2ca45e2fc844e34583593", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -374,21 +374,10 @@ type region_dep = {ambient_variance: region_variance, id: ast::node_id};\n type dep_map = HashMap<ast::node_id, @DVec<region_dep>>;\n \n impl region_dep : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &region_dep) -> bool {\n-        self.ambient_variance == (*other).ambient_variance &&\n-        self.id == (*other).id\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &region_dep) -> bool {\n         (*self).ambient_variance == (*other).ambient_variance &&\n         (*self).id == (*other).id\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &region_dep) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &region_dep) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "581f65de25e7c197129cd6d15e7af38613e4a6a8", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -108,31 +108,6 @@ enum PatternBindingMode {\n }\n \n impl PatternBindingMode : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &PatternBindingMode) -> bool {\n-        match self {\n-            RefutableMode => {\n-                match *other {\n-                    RefutableMode => true,\n-                    _ => false\n-                }\n-            }\n-            LocalIrrefutableMode => {\n-                match *other {\n-                    LocalIrrefutableMode => true,\n-                    _ => false\n-                }\n-            }\n-            ArgumentIrrefutableMode(mode_a) => {\n-                match *other {\n-                    ArgumentIrrefutableMode(mode_b) => mode_a == mode_b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &PatternBindingMode) -> bool {\n         match (*self) {\n             RefutableMode => {\n@@ -155,10 +130,6 @@ impl PatternBindingMode : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &PatternBindingMode) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &PatternBindingMode) -> bool {\n         !(*self).eq(other)\n     }\n@@ -198,19 +169,9 @@ enum Mutability {\n }\n \n impl Mutability : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Mutability) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Mutability) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Mutability) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Mutability) -> bool { !(*self).eq(other) }\n }\n \n@@ -232,19 +193,9 @@ enum ImportDirectiveNS {\n }\n \n impl ImportDirectiveNS : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ImportDirectiveNS) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ImportDirectiveNS) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ImportDirectiveNS) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ImportDirectiveNS) -> bool {\n         !(*self).eq(other)\n     }\n@@ -343,19 +294,9 @@ enum XrayFlag {\n }\n \n impl XrayFlag : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &XrayFlag) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &XrayFlag) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &XrayFlag) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &XrayFlag) -> bool { !(*self).eq(other) }\n }\n \n@@ -365,19 +306,9 @@ enum AllowCapturingSelfFlag {\n }\n \n impl AllowCapturingSelfFlag : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &AllowCapturingSelfFlag) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &AllowCapturingSelfFlag) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &AllowCapturingSelfFlag) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &AllowCapturingSelfFlag) -> bool {\n         !(*self).eq(other)\n     }\n@@ -400,19 +331,9 @@ enum DuplicateCheckingMode {\n }\n \n impl DuplicateCheckingMode : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &DuplicateCheckingMode) -> bool {\n-        (self as uint) == (*other as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &DuplicateCheckingMode) -> bool {\n         ((*self) as uint) == (*other as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &DuplicateCheckingMode) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &DuplicateCheckingMode) -> bool {\n         !(*self).eq(other)\n     }\n@@ -619,19 +540,9 @@ enum Privacy {\n }\n \n impl Privacy : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Privacy) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Privacy) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Privacy) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Privacy) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "c8753dd0274fe944d30bf1171137c6645ef093f1", "filename": "src/librustc/middle/trans/alt.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -907,19 +907,9 @@ fn pick_col(m: &[@Match]) -> uint {\n enum branch_kind { no_branch, single, switch, compare, }\n \n impl branch_kind : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &branch_kind) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &branch_kind) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &branch_kind) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &branch_kind) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "21f1b2d8698f5e3a49be8c924cc3ece12600a221", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -296,25 +296,6 @@ enum cleanup {\n }\n \n impl cleantype : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &cleantype) -> bool {\n-        match self {\n-            normal_exit_only => {\n-                match (*other) {\n-                    normal_exit_only => true,\n-                    _ => false\n-                }\n-            }\n-            normal_exit_and_unwind => {\n-                match (*other) {\n-                    normal_exit_and_unwind => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &cleantype) -> bool {\n         match (*self) {\n             normal_exit_only => {\n@@ -331,10 +312,6 @@ impl cleantype : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &cleantype) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &cleantype) -> bool { !(*self).eq(other) }\n }\n \n@@ -1167,25 +1144,6 @@ type mono_id_ = {\n type mono_id = @mono_id_;\n \n impl mono_param_id : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &mono_param_id) -> bool {\n-        match (self, (*other)) {\n-            (mono_precise(ty_a, ids_a), mono_precise(ty_b, ids_b)) => {\n-                ty_a == ty_b && ids_a == ids_b\n-            }\n-            (mono_any, mono_any) => true,\n-            (mono_repr(size_a, align_a, is_float_a, mode_a),\n-             mono_repr(size_b, align_b, is_float_b, mode_b)) => {\n-                size_a == size_b && align_a == align_b &&\n-                    is_float_a == is_float_b && mode_a == mode_b\n-            }\n-            (mono_precise(*), _) => false,\n-            (mono_any, _) => false,\n-            (mono_repr(*), _) => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &mono_param_id) -> bool {\n         match ((*self), (*other)) {\n             (mono_precise(ty_a, ids_a), mono_precise(ty_b, ids_b)) => {\n@@ -1202,27 +1160,13 @@ impl mono_param_id : cmp::Eq {\n             (mono_repr(*), _) => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &mono_param_id) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &mono_param_id) -> bool { !(*self).eq(other) }\n }\n \n impl mono_id_ : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &mono_id_) -> bool {\n-        self.def == (*other).def && self.params == (*other).params\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &mono_id_) -> bool {\n         (*self).def == (*other).def && (*self).params == (*other).params\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &mono_id_) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &mono_id_) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "d1813289df478838dd359ea9575c65099c41d103", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -139,19 +139,9 @@ impl DatumMode {\n }\n \n impl DatumMode: cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &DatumMode) -> bool {\n-        self as uint == (*other as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &DatumMode) -> bool {\n         (*self) as uint == (*other as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &DatumMode) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &DatumMode) -> bool { !(*self).eq(other) }\n }\n \n@@ -817,17 +807,6 @@ impl DatumBlock {\n }\n \n impl CopyAction : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &CopyAction) -> bool {\n-        match (self, (*other)) {\n-            (INIT, INIT) => true,\n-            (DROP_EXISTING, DROP_EXISTING) => true,\n-            (INIT, _) => false,\n-            (DROP_EXISTING, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &CopyAction) -> bool {\n         match ((*self), (*other)) {\n             (INIT, INIT) => true,\n@@ -836,9 +815,5 @@ impl CopyAction : cmp::Eq {\n             (DROP_EXISTING, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &CopyAction) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &CopyAction) -> bool { !(*self).eq(other) }\n }"}, {"sha": "721e4fddb4c728a31b869aca4c7e06e44c68f3e0", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -148,17 +148,6 @@ impl Dest {\n }\n \n impl Dest : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Dest) -> bool {\n-        match (self, (*other)) {\n-            (SaveIn(e0a), SaveIn(e0b)) => e0a == e0b,\n-            (Ignore, Ignore) => true,\n-            (SaveIn(*), _) => false,\n-            (Ignore, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Dest) -> bool {\n         match ((*self), (*other)) {\n             (SaveIn(e0a), SaveIn(e0b)) => e0a == e0b,\n@@ -167,10 +156,6 @@ impl Dest : cmp::Eq {\n             (Ignore, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Dest) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Dest) -> bool { !(*self).eq(other) }\n }\n \n@@ -1445,23 +1430,6 @@ enum cast_kind {\n }\n \n impl cast_kind : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &cast_kind) -> bool {\n-        match (self, (*other)) {\n-            (cast_pointer, cast_pointer) => true,\n-            (cast_integral, cast_integral) => true,\n-            (cast_float, cast_float) => true,\n-            (cast_enum, cast_enum) => true,\n-            (cast_other, cast_other) => true,\n-            (cast_pointer, _) => false,\n-            (cast_integral, _) => false,\n-            (cast_float, _) => false,\n-            (cast_enum, _) => false,\n-            (cast_other, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &cast_kind) -> bool {\n         match ((*self), (*other)) {\n             (cast_pointer, cast_pointer) => true,\n@@ -1476,10 +1444,6 @@ impl cast_kind : cmp::Eq {\n             (cast_other, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &cast_kind) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &cast_kind) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "4fe7c307d5977d3b48093ade2a985704e3c42491", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -41,19 +41,9 @@ enum x86_64_reg_class {\n }\n \n impl x86_64_reg_class : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &x86_64_reg_class) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &x86_64_reg_class) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &x86_64_reg_class) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &x86_64_reg_class) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "520875f3b158f6f7f1aaa6fcefc8d69f38032f90", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 526, "changes": 527, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -245,25 +245,11 @@ type creader_cache_key = {cnum: int, pos: uint, len: uint};\n type creader_cache = HashMap<creader_cache_key, t>;\n \n impl creader_cache_key : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &creader_cache_key) -> bool {\n-        self.cnum == (*other).cnum &&\n-            self.pos == (*other).pos &&\n-            self.len == (*other).len\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &creader_cache_key) -> bool {\n         (*self).cnum == (*other).cnum &&\n             (*self).pos == (*other).pos &&\n             (*self).len == (*other).len\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &creader_cache_key) -> bool {\n-        !(self == (*other))\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &creader_cache_key) -> bool {\n         !((*self) == (*other))\n     }\n@@ -286,19 +272,9 @@ impl creader_cache_key : to_bytes::IterBytes {\n type intern_key = {sty: sty, o_def_id: Option<ast::def_id>};\n \n impl intern_key : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &intern_key) -> bool {\n-        self.sty == (*other).sty && self.o_def_id == (*other).o_def_id\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &intern_key) -> bool {\n         (*self).sty == (*other).sty && (*self).o_def_id == (*other).o_def_id\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &intern_key) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &intern_key) -> bool { !(*self).eq(other) }\n }\n \n@@ -328,19 +304,6 @@ type opt_region_variance = Option<region_variance>;\n enum region_variance { rv_covariant, rv_invariant, rv_contravariant }\n \n impl region_variance : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &region_variance) -> bool {\n-        match (self, (*other)) {\n-            (rv_covariant, rv_covariant) => true,\n-            (rv_invariant, rv_invariant) => true,\n-            (rv_contravariant, rv_contravariant) => true,\n-            (rv_covariant, _) => false,\n-            (rv_invariant, _) => false,\n-            (rv_contravariant, _) => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &region_variance) -> bool {\n         match ((*self), (*other)) {\n             (rv_covariant, rv_covariant) => true,\n@@ -351,10 +314,6 @@ impl region_variance : cmp::Eq {\n             (rv_contravariant, _) => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &region_variance) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &region_variance) -> bool { !(*self).eq(other) }\n }\n \n@@ -563,19 +522,9 @@ type FnTy = FnTyBase<FnMeta>;\n type param_ty = {idx: uint, def_id: def_id};\n \n impl param_ty : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &param_ty) -> bool {\n-        self.idx == (*other).idx && self.def_id == (*other).def_id\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &param_ty) -> bool {\n         (*self).idx == (*other).idx && (*self).def_id == (*other).def_id\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &param_ty) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &param_ty) -> bool { !(*self).eq(other) }\n }\n \n@@ -823,20 +772,6 @@ impl InferRegion : to_bytes::IterBytes {\n }\n \n impl InferRegion : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &InferRegion) -> bool {\n-        match (self, *other) {\n-            (ReVar(rva), ReVar(rvb)) => {\n-                rva == rvb\n-            }\n-            (ReSkolemized(rva, _), ReSkolemized(rvb, _)) => {\n-                rva == rvb\n-            }\n-            _ => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &InferRegion) -> bool {\n         match ((*self), *other) {\n             (ReVar(rva), ReVar(rvb)) => {\n@@ -848,12 +783,6 @@ impl InferRegion : cmp::Eq {\n             _ => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &InferRegion) -> bool {\n-        !(self == (*other))\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &InferRegion) -> bool {\n         !((*self) == (*other))\n     }\n@@ -4579,88 +4508,27 @@ pure fn determine_inherited_purity(parent_purity: ast::purity,\n }\n \n impl mt : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &mt) -> bool {\n-        self.ty == (*other).ty && self.mutbl == (*other).mutbl\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &mt) -> bool {\n         (*self).ty == (*other).ty && (*self).mutbl == (*other).mutbl\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &mt) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &mt) -> bool { !(*self).eq(other) }\n }\n \n impl arg : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &arg) -> bool {\n-        self.mode == (*other).mode && self.ty == (*other).ty\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &arg) -> bool {\n         (*self).mode == (*other).mode && (*self).ty == (*other).ty\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &arg) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &arg) -> bool { !(*self).eq(other) }\n }\n \n impl field : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &field) -> bool {\n-        self.ident == (*other).ident && self.mt == (*other).mt\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &field) -> bool {\n         (*self).ident == (*other).ident && (*self).mt == (*other).mt\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &field) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &field) -> bool { !(*self).eq(other) }\n }\n \n impl vstore : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &vstore) -> bool {\n-        match self {\n-            vstore_fixed(e0a) => {\n-                match (*other) {\n-                    vstore_fixed(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            vstore_uniq => {\n-                match (*other) {\n-                    vstore_uniq => true,\n-                    _ => false\n-                }\n-            }\n-            vstore_box => {\n-                match (*other) {\n-                    vstore_box => true,\n-                    _ => false\n-                }\n-            }\n-            vstore_slice(e0a) => {\n-                match (*other) {\n-                    vstore_slice(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &vstore) -> bool {\n         match (*self) {\n             vstore_fixed(e0a) => {\n@@ -4689,175 +4557,60 @@ impl vstore : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &vstore) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &vstore) -> bool { !(*self).eq(other) }\n }\n \n impl FnMeta : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &FnMeta) -> bool {\n-        self.purity == (*other).purity &&\n-        self.proto == (*other).proto &&\n-        self.bounds == (*other).bounds &&\n-        self.ret_style == (*other).ret_style\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &FnMeta) -> bool {\n         (*self).purity == (*other).purity &&\n         (*self).proto == (*other).proto &&\n         (*self).bounds == (*other).bounds &&\n         (*self).ret_style == (*other).ret_style\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &FnMeta) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &FnMeta) -> bool { !(*self).eq(other) }\n }\n \n impl FnSig : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &FnSig) -> bool {\n-        self.inputs == (*other).inputs &&\n-        self.output == (*other).output\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &FnSig) -> bool {\n         (*self).inputs == (*other).inputs &&\n         (*self).output == (*other).output\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &FnSig) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &FnSig) -> bool { !(*self).eq(other) }\n }\n \n impl<M: cmp::Eq> FnTyBase<M> : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &FnTyBase<M>) -> bool {\n-        self.meta == (*other).meta && self.sig == (*other).sig\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &FnTyBase<M>) -> bool {\n         (*self).meta == (*other).meta && (*self).sig == (*other).sig\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &FnTyBase<M>) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &FnTyBase<M>) -> bool { !(*self).eq(other) }\n }\n \n impl TyVid : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &TyVid) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &TyVid) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &TyVid) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &TyVid) -> bool { *(*self) != *(*other) }\n }\n \n impl IntVid : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &IntVid) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &IntVid) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &IntVid) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &IntVid) -> bool { *(*self) != *(*other) }\n }\n \n impl FloatVid : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &FloatVid) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &FloatVid) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &FloatVid) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &FloatVid) -> bool { *(*self) != *(*other) }\n }\n \n impl FnVid : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &FnVid) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &FnVid) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &FnVid) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &FnVid) -> bool { *(*self) != *(*other) }\n }\n \n impl RegionVid : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &RegionVid) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &RegionVid) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &RegionVid) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &RegionVid) -> bool { *(*self) != *(*other) }\n }\n \n impl Region : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Region) -> bool {\n-        match self {\n-            re_bound(e0a) => {\n-                match (*other) {\n-                    re_bound(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            re_free(e0a, e1a) => {\n-                match (*other) {\n-                    re_free(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            re_scope(e0a) => {\n-                match (*other) {\n-                    re_scope(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            re_static => {\n-                match (*other) {\n-                    re_static => true,\n-                    _ => false\n-                }\n-            }\n-            re_infer(e0a) => {\n-                match (*other) {\n-                    re_infer(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Region) -> bool {\n         match (*self) {\n             re_bound(e0a) => {\n@@ -4892,45 +4645,10 @@ impl Region : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Region) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Region) -> bool { !(*self).eq(other) }\n }\n \n impl bound_region : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &bound_region) -> bool {\n-        match self {\n-            br_self => {\n-                match (*other) {\n-                    br_self => true,\n-                    _ => false\n-                }\n-            }\n-            br_anon(e0a) => {\n-                match (*other) {\n-                    br_anon(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            br_named(e0a) => {\n-                match (*other) {\n-                    br_named(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            br_cap_avoid(e0a, e1a) => {\n-                match (*other) {\n-                    br_cap_avoid(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &bound_region) -> bool {\n         match (*self) {\n             br_self => {\n@@ -4959,216 +4677,26 @@ impl bound_region : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &bound_region) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &bound_region) -> bool { !(*self).eq(other) }\n }\n \n impl substs : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &substs) -> bool {\n-        self.self_r == (*other).self_r &&\n-        self.self_ty == (*other).self_ty &&\n-        self.tps == (*other).tps\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &substs) -> bool {\n         (*self).self_r == (*other).self_r &&\n         (*self).self_ty == (*other).self_ty &&\n         (*self).tps == (*other).tps\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &substs) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &substs) -> bool { !(*self).eq(other) }\n }\n \n impl InferTy : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &InferTy) -> bool {\n-        self.to_hash() == (*other).to_hash()\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &InferTy) -> bool {\n         (*self).to_hash() == (*other).to_hash()\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &InferTy) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &InferTy) -> bool { !(*self).eq(other) }\n }\n \n impl sty : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &sty) -> bool {\n-        match self {\n-            ty_nil => {\n-                match (*other) {\n-                    ty_nil => true,\n-                    _ => false\n-                }\n-            }\n-            ty_bot => {\n-                match (*other) {\n-                    ty_bot => true,\n-                    _ => false\n-                }\n-            }\n-            ty_bool => {\n-                match (*other) {\n-                    ty_bool => true,\n-                    _ => false\n-                }\n-            }\n-            ty_int(e0a) => {\n-                match (*other) {\n-                    ty_int(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_uint(e0a) => {\n-                match (*other) {\n-                    ty_uint(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_float(e0a) => {\n-                match (*other) {\n-                    ty_float(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_estr(e0a) => {\n-                match (*other) {\n-                    ty_estr(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_enum(e0a, e1a) => {\n-                match (*other) {\n-                    ty_enum(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            ty_box(e0a) => {\n-                match (*other) {\n-                    ty_box(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_uniq(e0a) => {\n-                match (*other) {\n-                    ty_uniq(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_evec(e0a, e1a) => {\n-                match (*other) {\n-                    ty_evec(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            ty_ptr(e0a) => {\n-                match (*other) {\n-                    ty_ptr(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_rptr(e0a, e1a) => {\n-                match (*other) {\n-                    ty_rptr(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            ty_rec(e0a) => {\n-                match (*other) {\n-                    ty_rec(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_fn(e0a) => {\n-                match (*other) {\n-                    ty_fn(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_trait(e0a, e1a, e2a) => {\n-                match (*other) {\n-                    ty_trait(e0b, e1b, e2b) =>\n-                        e0a == e0b && e1a == e1b && e2a == e2b,\n-                    _ => false\n-                }\n-            }\n-            ty_class(e0a, e1a) => {\n-                match (*other) {\n-                    ty_class(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            ty_tup(e0a) => {\n-                match (*other) {\n-                    ty_tup(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_infer(e0a) => {\n-                match (*other) {\n-                    ty_infer(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_err => {\n-                match (*other) {\n-                    ty_err => true,\n-                    _ => false\n-                }\n-            }\n-            ty_param(e0a) => {\n-                match (*other) {\n-                    ty_param(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_self => {\n-                match (*other) {\n-                    ty_self => true,\n-                    _ => false\n-                }\n-            }\n-            ty_type => {\n-                match (*other) {\n-                    ty_type => true,\n-                    _ => false\n-                }\n-            }\n-            ty_opaque_box => {\n-                match (*other) {\n-                    ty_opaque_box => true,\n-                    _ => false\n-                }\n-            }\n-            ty_opaque_closure_ptr(e0a) => {\n-                match (*other) {\n-                    ty_opaque_closure_ptr(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_unboxed_vec(e0a) => {\n-                match (*other) {\n-                    ty_unboxed_vec(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &sty) -> bool {\n         match (*self) {\n             ty_nil => {\n@@ -5330,51 +4858,10 @@ impl sty : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &sty) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &sty) -> bool { !(*self).eq(other) }\n }\n \n impl param_bound : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &param_bound) -> bool {\n-        match self {\n-            bound_copy => {\n-                match (*other) {\n-                    bound_copy => true,\n-                    _ => false\n-                }\n-            }\n-            bound_owned => {\n-                match (*other) {\n-                    bound_owned => true,\n-                    _ => false\n-                }\n-            }\n-            bound_send => {\n-                match (*other) {\n-                    bound_send => true,\n-                    _ => false\n-                }\n-            }\n-            bound_const => {\n-                match (*other) {\n-                    bound_const => true,\n-                    _ => false\n-                }\n-            }\n-            bound_trait(e0a) => {\n-                match (*other) {\n-                    bound_trait(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &param_bound) -> bool {\n         match (*self) {\n             bound_copy => {\n@@ -5409,23 +4896,11 @@ impl param_bound : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &param_bound) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn ne(&self, other: &param_bound) -> bool { !(*self).eq(other) }\n+    pure fn ne(&self, other: &param_bound) -> bool { !self.eq(other) }\n }\n \n impl Kind : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Kind) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Kind) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Kind) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Kind) -> bool { *(*self) != *(*other) }\n }\n "}, {"sha": "6e999aeb0af5fc581f68f45a0d28068dd5df1c52", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,14 @@\n+#[legacy_exports]\n+mod alt;\n+#[legacy_exports]\n+mod vtable;\n+#[legacy_exports]\n+mod writeback;\n+#[legacy_exports]\n+mod regionmanip;\n+#[legacy_exports]\n+mod regionck;\n+#[legacy_exports]\n+mod demand;\n+#[legacy_exports]\n+pub mod method;"}, {"sha": "3ce09d454d8114cc5da95fdb91c39d6557c1b3cc", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,24 @@\n+#[legacy_exports];\n+#[legacy_exports]\n+mod assignment;\n+#[legacy_exports]\n+mod combine;\n+#[legacy_exports]\n+mod glb;\n+#[legacy_exports]\n+mod integral;\n+mod floating;\n+#[legacy_exports]\n+mod lattice;\n+#[legacy_exports]\n+mod lub;\n+#[legacy_exports]\n+mod region_inference;\n+#[legacy_exports]\n+mod resolve;\n+#[legacy_exports]\n+mod sub;\n+#[legacy_exports]\n+mod to_str;\n+#[legacy_exports]\n+mod unify;"}, {"sha": "f36112d77cbbf4225d01d15f4973c9a54aa7e783", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -469,25 +469,6 @@ enum Constraint {\n }\n \n impl Constraint : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Constraint) -> bool {\n-        match (self, (*other)) {\n-            (ConstrainVarSubVar(v0a, v1a), ConstrainVarSubVar(v0b, v1b)) => {\n-                v0a == v0b && v1a == v1b\n-            }\n-            (ConstrainRegSubVar(ra, va), ConstrainRegSubVar(rb, vb)) => {\n-                ra == rb && va == vb\n-            }\n-            (ConstrainVarSubReg(va, ra), ConstrainVarSubReg(vb, rb)) => {\n-                va == vb && ra == rb\n-            }\n-            (ConstrainVarSubVar(*), _) => false,\n-            (ConstrainRegSubVar(*), _) => false,\n-            (ConstrainVarSubReg(*), _) => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Constraint) -> bool {\n         match ((*self), (*other)) {\n             (ConstrainVarSubVar(v0a, v1a), ConstrainVarSubVar(v0b, v1b)) => {\n@@ -504,10 +485,6 @@ impl Constraint : cmp::Eq {\n             (ConstrainVarSubReg(*), _) => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Constraint) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Constraint) -> bool { !(*self).eq(other) }\n }\n \n@@ -549,19 +526,9 @@ struct TwoRegions {\n }\n \n impl TwoRegions : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &TwoRegions) -> bool {\n-        self.a == (*other).a && self.b == (*other).b\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &TwoRegions) -> bool {\n         (*self).a == (*other).a && (*self).b == (*other).b\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &TwoRegions) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &TwoRegions) -> bool { !(*self).eq(other) }\n }\n \n@@ -1093,38 +1060,18 @@ priv impl RegionVarBindings {\n enum Direction { Incoming = 0, Outgoing = 1 }\n \n impl Direction : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Direction) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Direction) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Direction) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Direction) -> bool { !(*self).eq(other) }\n }\n \n enum Classification { Expanding, Contracting }\n \n impl Classification : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Classification) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Classification) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Classification) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Classification) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "11077081d91aab7f33ad9037fb74cedd311970f9", "filename": "src/librustc/middle/typeck/mod.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,16 @@\n+#[legacy_exports];\n+\n+#[legacy_exports]\n+#[merge = \"check/mod.rs\"]\n+pub mod check;\n+#[legacy_exports]\n+mod rscope;\n+#[legacy_exports]\n+mod astconv;\n+#[merge = \"infer/mod.rs\"]\n+mod infer;\n+#[legacy_exports]\n+mod collect;\n+#[legacy_exports]\n+mod coherence;\n+mod deriving;"}, {"sha": "80592fea50007f62d70f961cb873208724cb01fe", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 310, "deletions": 110, "changes": 420, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -43,246 +43,446 @@ mod middle {\n     mod trans {\n         #[legacy_exports];\n         #[legacy_exports]\n+        #[path = \"middle/trans/inline.rs\"]\n         mod inline;\n         #[legacy_exports]\n+        #[path = \"middle/trans/monomorphize.rs\"]\n         mod monomorphize;\n         #[legacy_exports]\n+        #[path = \"middle/trans/controlflow.rs\"]\n         mod controlflow;\n         #[legacy_exports]\n+        #[path = \"middle/trans/glue.rs\"]\n         mod glue;\n         #[legacy_exports]\n+        #[path = \"middle/trans/datum.rs\"]\n         mod datum;\n         #[legacy_exports]\n+        #[path = \"middle/trans/callee.rs\"]\n         mod callee;\n         #[legacy_exports]\n+        #[path = \"middle/trans/expr.rs\"]\n         mod expr;\n         #[legacy_exports]\n+        #[path = \"middle/trans/common.rs\"]\n         mod common;\n         #[legacy_exports]\n+        #[path = \"middle/trans/consts.rs\"]\n         mod consts;\n         #[legacy_exports]\n+        #[path = \"middle/trans/type_of.rs\"]\n         mod type_of;\n         #[legacy_exports]\n+        #[path = \"middle/trans/build.rs\"]\n         mod build;\n         #[legacy_exports]\n+        #[path = \"middle/trans/base.rs\"]\n         mod base;\n         #[legacy_exports]\n+        #[path = \"middle/trans/alt.rs\"]\n         mod alt;\n         #[legacy_exports]\n+        #[path = \"middle/trans/uniq.rs\"]\n         mod uniq;\n         #[legacy_exports]\n+        #[path = \"middle/trans/closure.rs\"]\n         mod closure;\n         #[legacy_exports]\n+        #[path = \"middle/trans/tvec.rs\"]\n         mod tvec;\n         #[legacy_exports]\n+        #[path = \"middle/trans/meth.rs\"]\n         mod meth;\n         #[legacy_exports]\n+        #[path = \"middle/trans/foreign.rs\"]\n         mod foreign;\n         #[legacy_exports]\n+        #[path = \"middle/trans/reflect.rs\"]\n         mod reflect;\n         #[legacy_exports]\n+        #[path = \"middle/trans/shape.rs\"]\n         mod shape;\n         #[legacy_exports]\n+        #[path = \"middle/trans/debuginfo.rs\"]\n         mod debuginfo;\n         #[legacy_exports]\n+        #[path = \"middle/trans/type_use.rs\"]\n         mod type_use;\n         #[legacy_exports]\n+        #[path = \"middle/trans/reachable.rs\"]\n         mod reachable;\n+        #[path = \"middle/trans/machine.rs\"]\n         mod machine;\n+        #[path = \"middle/trans/deriving.rs\"]\n         mod deriving;\n     }\n     #[legacy_exports]\n+    #[path = \"middle/ty.rs\"]\n     mod ty;\n     #[legacy_exports]\n+    #[path = \"middle/resolve.rs\"]\n     mod resolve;\n-    pub mod typeck {\n-        #[legacy_exports];\n-        #[legacy_exports]\n-        pub mod check {\n-            #[legacy_exports]\n-            mod alt;\n-            #[legacy_exports]\n-            mod vtable;\n-            #[legacy_exports]\n-            mod writeback;\n-            #[legacy_exports]\n-            mod regionmanip;\n-            #[legacy_exports]\n-            mod regionck;\n-            #[legacy_exports]\n-            mod demand;\n-            #[legacy_exports]\n-            pub mod method;\n-        }\n-        #[legacy_exports]\n-        mod rscope;\n-        #[legacy_exports]\n-        mod astconv;\n-        mod infer {\n-            #[legacy_exports];\n-            #[legacy_exports]\n-            mod assignment;\n-            #[legacy_exports]\n-            mod combine;\n-            #[legacy_exports]\n-            mod glb;\n-            #[legacy_exports]\n-            mod integral;\n-            mod floating;\n-            #[legacy_exports]\n-            mod lattice;\n-            #[legacy_exports]\n-            mod lub;\n-            #[legacy_exports]\n-            mod region_inference;\n-            #[legacy_exports]\n-            mod resolve;\n-            #[legacy_exports]\n-            mod sub;\n-            #[legacy_exports]\n-            mod to_str;\n-            #[legacy_exports]\n-            mod unify;\n-            #[cfg(test)]\n-            #[legacy_exports]\n-            mod test;\n-        }\n-        #[legacy_exports]\n-        mod collect;\n-        #[legacy_exports]\n-        mod coherence;\n-        mod deriving;\n-    }\n+    #[path = \"middle/typeck.rs\"]\n+    #[merge = \"middle/typeck/mod.rs\"]\n+    pub mod typeck;\n     #[legacy_exports]\n+    #[path = \"middle/check_loop.rs\"]\n     mod check_loop;\n     #[legacy_exports]\n+    #[path = \"middle/check_alt.rs\"]\n     mod check_alt;\n     #[legacy_exports]\n+    #[path = \"middle/check_const.rs\"]\n     mod check_const;\n     #[legacy_exports]\n+    #[path = \"middle/lint.rs\"]\n     mod lint;\n-    mod borrowck {\n-        #[legacy_exports];\n-        #[legacy_exports]\n-        mod check_loans;\n-        #[legacy_exports]\n-        mod gather_loans;\n-        #[legacy_exports]\n-        mod loan;\n-        #[legacy_exports]\n-        mod preserve;\n-    }\n+    #[path = \"middle/borrowck.rs\"]\n+    #[merge = \"middle/borrowck/mod.rs\"]\n+    mod borrowck;\n     #[legacy_exports]\n+    #[path = \"middle/mem_categorization.rs\"]\n     mod mem_categorization;\n     #[legacy_exports]\n+    #[path = \"middle/liveness.rs\"]\n     mod liveness;\n     #[legacy_exports]\n+    #[path = \"middle/kind.rs\"]\n     mod kind;\n     #[legacy_exports]\n+    #[path = \"middle/freevars.rs\"]\n     mod freevars;\n     #[legacy_exports]\n+    #[path = \"middle/capture.rs\"]\n     mod capture;\n     #[legacy_exports]\n+    #[path = \"middle/pat_util.rs\"]\n     mod pat_util;\n     #[legacy_exports]\n+    #[path = \"middle/region.rs\"]\n     mod region;\n     #[legacy_exports]\n+    #[path = \"middle/const_eval.rs\"]\n     mod const_eval;\n     #[legacy_exports]\n+    #[path = \"middle/astencode.rs\"]\n     mod astencode;\n     #[legacy_exports]\n+    #[path = \"middle/lang_items.rs\"]\n     mod lang_items;\n     #[legacy_exports]\n+    #[path = \"middle/privacy.rs\"]\n     mod privacy;\n }\n \n mod front {\n     #[legacy_exports];\n     #[legacy_exports]\n+    #[path = \"front/config.rs\"]\n     mod config;\n     #[legacy_exports]\n+    #[path = \"front/test.rs\"]\n     mod test;\n     #[legacy_exports]\n+    #[path = \"front/core_inject.rs\"]\n     mod core_inject;\n     #[legacy_exports]\n+    #[path = \"front/intrinsic_inject.rs\"]\n     mod intrinsic_inject;\n }\n \n mod back {\n     #[legacy_exports];\n     #[legacy_exports]\n+    #[path = \"back/link.rs\"]\n     mod link;\n     #[legacy_exports]\n+    #[path = \"back/abi.rs\"]\n     mod abi;\n     #[legacy_exports]\n+    #[path = \"back/upcall.rs\"]\n     mod upcall;\n     #[legacy_exports]\n+    #[path = \"back/x86.rs\"]\n     mod x86;\n     #[legacy_exports]\n+    #[path = \"back/x86_64.rs\"]\n     mod x86_64;\n     #[legacy_exports]\n+    #[path = \"back/rpath.rs\"]\n     mod rpath;\n     #[legacy_exports]\n+    #[path = \"back/target_strs.rs\"]\n     mod target_strs;\n }\n \n-mod metadata {\n-    #[legacy_exports];\n-    export encoder;\n-    export creader;\n-    export cstore;\n-    export csearch;\n-    export common;\n-    export decoder;\n-    export tyencode;\n-    export tydecode;\n-    export loader;\n-    export filesearch;\n+#[merge = \"metadata/mod.rs\"]\n+mod metadata;\n \n-    #[legacy_exports]\n-    mod common;\n-    #[legacy_exports]\n-    mod tyencode;\n-    #[legacy_exports]\n-    mod tydecode;\n-    #[legacy_exports]\n-    mod encoder;\n-    #[legacy_exports]\n-    mod decoder;\n-    #[legacy_exports]\n-    mod creader;\n-    #[legacy_exports]\n-    mod cstore;\n-    #[legacy_exports]\n-    mod csearch;\n-    #[legacy_exports]\n-    mod loader;\n-    #[legacy_exports]\n-    mod filesearch;\n-}\n-\n-mod driver {\n-    #[legacy_exports];\n-    #[legacy_exports]\n-    mod driver;\n-    #[legacy_exports]\n-    mod session;\n-}\n+#[merge = \"driver/mod.rs\"]\n+mod driver;\n \n mod util {\n     #[legacy_exports];\n     #[legacy_exports]\n+    #[path = \"util/common.rs\"]\n     mod common;\n     #[legacy_exports]\n+    #[path = \"util/ppaux.rs\"]\n     mod ppaux;\n }\n \n mod lib {\n     #[legacy_exports];\n     #[legacy_exports]\n+    #[path = \"lib/llvm.rs\"]\n     mod llvm;\n }\n \n+use result::{Ok, Err};\n+use io::ReaderUtil;\n+use std::getopts;\n+use std::map::HashMap;\n+use getopts::{opt_present};\n+use getopts::groups;\n+use syntax::codemap;\n+use syntax::diagnostic;\n+use driver::driver::{host_triple, optgroups, early_error,\n+                     str_input, file_input, build_session_options,\n+                     build_session, build_configuration, parse_pretty,\n+                     pp_mode, pretty_print_input, list_metadata,\n+                     compile_input};\n+use driver::session;\n+use middle::lint;\n+\n+fn version(argv0: &str) {\n+    let mut vers = ~\"unknown version\";\n+    let env_vers = env!(\"CFG_VERSION\");\n+    if env_vers.len() != 0 { vers = env_vers; }\n+    io::println(fmt!(\"%s %s\", argv0, vers));\n+    io::println(fmt!(\"host: %s\", host_triple()));\n+}\n+\n+fn usage(argv0: &str) {\n+    let message = fmt!(\"Usage: %s [OPTIONS] INPUT\", argv0);\n+    io::println(groups::usage(message, optgroups()) +\n+                ~\"Additional help:\n+    -W help             Print 'lint' options and default settings\n+    -Z help             Print internal options for debugging rustc\n+\");\n+}\n+\n+fn describe_warnings() {\n+    io::println(fmt!(\"\n+Available lint options:\n+    -W <foo>           Warn about <foo>\n+    -A <foo>           Allow <foo>\n+    -D <foo>           Deny <foo>\n+    -F <foo>           Forbid <foo> (deny, and deny all overrides)\n+\"));\n+\n+    let lint_dict = lint::get_lint_dict();\n+    let mut max_key = 0;\n+    for lint_dict.each_key |k| { max_key = uint::max(k.len(), max_key); }\n+    fn padded(max: uint, s: &str) -> ~str {\n+        str::from_bytes(vec::from_elem(max - s.len(), ' ' as u8)) + s\n+    }\n+    io::println(fmt!(\"\\nAvailable lint checks:\\n\"));\n+    io::println(fmt!(\"    %s  %7.7s  %s\",\n+                     padded(max_key, ~\"name\"), ~\"default\", ~\"meaning\"));\n+    io::println(fmt!(\"    %s  %7.7s  %s\\n\",\n+                     padded(max_key, ~\"----\"), ~\"-------\", ~\"-------\"));\n+    for lint_dict.each |k, v| {\n+        let k = str::replace(k, ~\"_\", ~\"-\");\n+        io::println(fmt!(\"    %s  %7.7s  %s\",\n+                         padded(max_key, k),\n+                         match v.default {\n+                             lint::allow => ~\"allow\",\n+                             lint::warn => ~\"warn\",\n+                             lint::deny => ~\"deny\",\n+                             lint::forbid => ~\"forbid\"\n+                         },\n+                         v.desc));\n+    }\n+    io::println(~\"\");\n+}\n+\n+fn describe_debug_flags() {\n+    io::println(fmt!(\"\\nAvailable debug options:\\n\"));\n+    for session::debugging_opts_map().each |pair| {\n+        let (name, desc, _) = *pair;\n+        io::println(fmt!(\"    -Z %-20s -- %s\", name, desc));\n+    }\n+}\n+\n+fn run_compiler(args: &~[~str], demitter: diagnostic::emitter) {\n+    // Don't display log spew by default. Can override with RUST_LOG.\n+    logging::console_off();\n+\n+    let mut args = *args;\n+    let binary = args.shift();\n+\n+    if args.is_empty() { usage(binary); return; }\n+\n+    let matches =\n+        &match getopts::groups::getopts(args, optgroups()) {\n+          Ok(m) => m,\n+          Err(f) => {\n+            early_error(demitter, getopts::fail_str(f))\n+          }\n+        };\n+\n+    if opt_present(matches, ~\"h\") || opt_present(matches, ~\"help\") {\n+        usage(binary);\n+        return;\n+    }\n+\n+    let lint_flags = vec::append(getopts::opt_strs(matches, ~\"W\"),\n+                                 getopts::opt_strs(matches, ~\"warn\"));\n+    if lint_flags.contains(&~\"help\") {\n+        describe_warnings();\n+        return;\n+    }\n+\n+    if getopts::opt_strs(matches, ~\"Z\").contains(&~\"help\") {\n+        describe_debug_flags();\n+        return;\n+    }\n+\n+    if opt_present(matches, ~\"v\") || opt_present(matches, ~\"version\") {\n+        version(binary);\n+        return;\n+    }\n+    let input = match vec::len(matches.free) {\n+      0u => early_error(demitter, ~\"no input filename given\"),\n+      1u => {\n+        let ifile = matches.free[0];\n+        if ifile == ~\"-\" {\n+            let src = str::from_bytes(io::stdin().read_whole_stream());\n+            str_input(src)\n+        } else {\n+            file_input(Path(ifile))\n+        }\n+      }\n+      _ => early_error(demitter, ~\"multiple input filenames provided\")\n+    };\n+\n+    let sopts = build_session_options(binary, matches, demitter);\n+    let sess = build_session(sopts, demitter);\n+    let odir = getopts::opt_maybe_str(matches, ~\"out-dir\");\n+    let odir = odir.map(|o| Path(*o));\n+    let ofile = getopts::opt_maybe_str(matches, ~\"o\");\n+    let ofile = ofile.map(|o| Path(*o));\n+    let cfg = build_configuration(sess, binary, input);\n+    let pretty =\n+        option::map(&getopts::opt_default(matches, ~\"pretty\",\n+                                         ~\"normal\"),\n+                    |a| parse_pretty(sess, *a) );\n+    match pretty {\n+      Some::<pp_mode>(ppm) => {\n+        pretty_print_input(sess, cfg, input, ppm);\n+        return;\n+      }\n+      None::<pp_mode> => {/* continue */ }\n+    }\n+    let ls = opt_present(matches, ~\"ls\");\n+    if ls {\n+        match input {\n+          file_input(ifile) => {\n+            list_metadata(sess, &ifile, io::stdout());\n+          }\n+          str_input(_) => {\n+            early_error(demitter, ~\"can not list metadata for stdin\");\n+          }\n+        }\n+        return;\n+    }\n+\n+    compile_input(sess, cfg, input, &odir, &ofile);\n+}\n+\n+enum monitor_msg {\n+    fatal,\n+    done,\n+}\n+\n+impl monitor_msg : cmp::Eq {\n+    pure fn eq(&self, other: &monitor_msg) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(&self, other: &monitor_msg) -> bool { !(*self).eq(other) }\n+}\n+\n+/*\n+This is a sanity check that any failure of the compiler is performed\n+through the diagnostic module and reported properly - we shouldn't be calling\n+plain-old-fail on any execution path that might be taken. Since we have\n+console logging off by default, hitting a plain fail statement would make the\n+compiler silently exit, which would be terrible.\n+\n+This method wraps the compiler in a subtask and injects a function into the\n+diagnostic emitter which records when we hit a fatal error. If the task\n+fails without recording a fatal error then we've encountered a compiler\n+bug and need to present an error.\n+*/\n+fn monitor(+f: fn~(diagnostic::emitter)) {\n+    let p = comm::Port();\n+    let ch = comm::Chan(&p);\n+\n+    match do task::try |move f| {\n+\n+        // The 'diagnostics emitter'. Every error, warning, etc. should\n+        // go through this function.\n+        let demitter = fn@(cmsp: Option<(@codemap::CodeMap, codemap::span)>,\n+                           msg: &str, lvl: diagnostic::level) {\n+            if lvl == diagnostic::fatal {\n+                comm::send(ch, fatal);\n+            }\n+            diagnostic::emit(cmsp, msg, lvl);\n+        };\n+\n+        struct finally {\n+            ch: comm::Chan<monitor_msg>,\n+            drop { comm::send(self.ch, done); }\n+        }\n+\n+        let _finally = finally { ch: ch };\n+\n+        f(demitter)\n+    } {\n+        result::Ok(_) => { /* fallthrough */ }\n+        result::Err(_) => {\n+            // Task failed without emitting a fatal diagnostic\n+            if comm::recv(p) == done {\n+                diagnostic::emit(\n+                    None,\n+                    diagnostic::ice_msg(~\"unexpected failure\"),\n+                    diagnostic::error);\n+\n+                for [\n+                    ~\"the compiler hit an unexpected failure path. \\\n+                     this is a bug\",\n+                    ~\"try running with RUST_LOG=rustc=1,::rt::backtrace \\\n+                     to get further details and report the results \\\n+                     to github.com/mozilla/rust/issues\"\n+                ].each |note| {\n+                    diagnostic::emit(None, *note, diagnostic::note)\n+                }\n+            }\n+            // Fail so the process returns a failure code\n+            fail;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let mut args = os::args();\n+    do monitor |move args, demitter| {\n+        run_compiler(&args, demitter);\n+    }\n+}\n+\n+\n // Local Variables:\n // fill-column: 78;\n // indent-tabs-mode: nil"}, {"sha": "8f2b83a8c1c1ad53cc5aba1853857e9fbd38b914", "filename": "src/librustc/rustc.rs", "status": "removed", "additions": 0, "deletions": 261, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,261 +0,0 @@\n-// -*- rust -*-\n-use result::{Ok, Err};\n-use io::ReaderUtil;\n-use std::getopts;\n-use std::map::HashMap;\n-use getopts::{opt_present};\n-use getopts::groups;\n-use syntax::codemap;\n-use syntax::diagnostic;\n-use driver::driver::{host_triple, optgroups, early_error,\n-                     str_input, file_input, build_session_options,\n-                     build_session, build_configuration, parse_pretty,\n-                     pp_mode, pretty_print_input, list_metadata,\n-                     compile_input};\n-use driver::session;\n-use middle::lint;\n-\n-fn version(argv0: &str) {\n-    let mut vers = ~\"unknown version\";\n-    let env_vers = env!(\"CFG_VERSION\");\n-    if env_vers.len() != 0 { vers = env_vers; }\n-    io::println(fmt!(\"%s %s\", argv0, vers));\n-    io::println(fmt!(\"host: %s\", host_triple()));\n-}\n-\n-fn usage(argv0: &str) {\n-    let message = fmt!(\"Usage: %s [OPTIONS] INPUT\", argv0);\n-    io::println(groups::usage(message, optgroups()) +\n-                ~\"Additional help:\n-    -W help             Print 'lint' options and default settings\n-    -Z help             Print internal options for debugging rustc\n-\");\n-}\n-\n-fn describe_warnings() {\n-    io::println(fmt!(\"\n-Available lint options:\n-    -W <foo>           Warn about <foo>\n-    -A <foo>           Allow <foo>\n-    -D <foo>           Deny <foo>\n-    -F <foo>           Forbid <foo> (deny, and deny all overrides)\n-\"));\n-\n-    let lint_dict = lint::get_lint_dict();\n-    let mut max_key = 0;\n-    for lint_dict.each_key |k| { max_key = uint::max(k.len(), max_key); }\n-    fn padded(max: uint, s: &str) -> ~str {\n-        str::from_bytes(vec::from_elem(max - s.len(), ' ' as u8)) + s\n-    }\n-    io::println(fmt!(\"\\nAvailable lint checks:\\n\"));\n-    io::println(fmt!(\"    %s  %7.7s  %s\",\n-                     padded(max_key, ~\"name\"), ~\"default\", ~\"meaning\"));\n-    io::println(fmt!(\"    %s  %7.7s  %s\\n\",\n-                     padded(max_key, ~\"----\"), ~\"-------\", ~\"-------\"));\n-    for lint_dict.each |k, v| {\n-        let k = str::replace(k, ~\"_\", ~\"-\");\n-        io::println(fmt!(\"    %s  %7.7s  %s\",\n-                         padded(max_key, k),\n-                         match v.default {\n-                             lint::allow => ~\"allow\",\n-                             lint::warn => ~\"warn\",\n-                             lint::deny => ~\"deny\",\n-                             lint::forbid => ~\"forbid\"\n-                         },\n-                         v.desc));\n-    }\n-    io::println(~\"\");\n-}\n-\n-fn describe_debug_flags() {\n-    io::println(fmt!(\"\\nAvailable debug options:\\n\"));\n-    for session::debugging_opts_map().each |pair| {\n-        let (name, desc, _) = *pair;\n-        io::println(fmt!(\"    -Z %-20s -- %s\", name, desc));\n-    }\n-}\n-\n-fn run_compiler(args: &~[~str], demitter: diagnostic::emitter) {\n-    // Don't display log spew by default. Can override with RUST_LOG.\n-    logging::console_off();\n-\n-    let mut args = *args;\n-    let binary = args.shift();\n-\n-    if args.is_empty() { usage(binary); return; }\n-\n-    let matches =\n-        &match getopts::groups::getopts(args, optgroups()) {\n-          Ok(m) => m,\n-          Err(f) => {\n-            early_error(demitter, getopts::fail_str(f))\n-          }\n-        };\n-\n-    if opt_present(matches, ~\"h\") || opt_present(matches, ~\"help\") {\n-        usage(binary);\n-        return;\n-    }\n-\n-    let lint_flags = vec::append(getopts::opt_strs(matches, ~\"W\"),\n-                                 getopts::opt_strs(matches, ~\"warn\"));\n-    if lint_flags.contains(&~\"help\") {\n-        describe_warnings();\n-        return;\n-    }\n-\n-    if getopts::opt_strs(matches, ~\"Z\").contains(&~\"help\") {\n-        describe_debug_flags();\n-        return;\n-    }\n-\n-    if opt_present(matches, ~\"v\") || opt_present(matches, ~\"version\") {\n-        version(binary);\n-        return;\n-    }\n-    let input = match vec::len(matches.free) {\n-      0u => early_error(demitter, ~\"no input filename given\"),\n-      1u => {\n-        let ifile = matches.free[0];\n-        if ifile == ~\"-\" {\n-            let src = str::from_bytes(io::stdin().read_whole_stream());\n-            str_input(src)\n-        } else {\n-            file_input(Path(ifile))\n-        }\n-      }\n-      _ => early_error(demitter, ~\"multiple input filenames provided\")\n-    };\n-\n-    let sopts = build_session_options(binary, matches, demitter);\n-    let sess = build_session(sopts, demitter);\n-    let odir = getopts::opt_maybe_str(matches, ~\"out-dir\");\n-    let odir = odir.map(|o| Path(*o));\n-    let ofile = getopts::opt_maybe_str(matches, ~\"o\");\n-    let ofile = ofile.map(|o| Path(*o));\n-    let cfg = build_configuration(sess, binary, input);\n-    let pretty =\n-        option::map(&getopts::opt_default(matches, ~\"pretty\",\n-                                         ~\"normal\"),\n-                    |a| parse_pretty(sess, *a) );\n-    match pretty {\n-      Some::<pp_mode>(ppm) => {\n-        pretty_print_input(sess, cfg, input, ppm);\n-        return;\n-      }\n-      None::<pp_mode> => {/* continue */ }\n-    }\n-    let ls = opt_present(matches, ~\"ls\");\n-    if ls {\n-        match input {\n-          file_input(ifile) => {\n-            list_metadata(sess, &ifile, io::stdout());\n-          }\n-          str_input(_) => {\n-            early_error(demitter, ~\"can not list metadata for stdin\");\n-          }\n-        }\n-        return;\n-    }\n-\n-    compile_input(sess, cfg, input, &odir, &ofile);\n-}\n-\n-enum monitor_msg {\n-    fatal,\n-    done,\n-}\n-\n-impl monitor_msg : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &monitor_msg) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn eq(&self, other: &monitor_msg) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &monitor_msg) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn ne(&self, other: &monitor_msg) -> bool { !(*self).eq(other) }\n-}\n-\n-/*\n-This is a sanity check that any failure of the compiler is performed\n-through the diagnostic module and reported properly - we shouldn't be calling\n-plain-old-fail on any execution path that might be taken. Since we have\n-console logging off by default, hitting a plain fail statement would make the\n-compiler silently exit, which would be terrible.\n-\n-This method wraps the compiler in a subtask and injects a function into the\n-diagnostic emitter which records when we hit a fatal error. If the task\n-fails without recording a fatal error then we've encountered a compiler\n-bug and need to present an error.\n-*/\n-fn monitor(+f: fn~(diagnostic::emitter)) {\n-    let p = comm::Port();\n-    let ch = comm::Chan(&p);\n-\n-    match do task::try |move f| {\n-\n-        // The 'diagnostics emitter'. Every error, warning, etc. should\n-        // go through this function.\n-        let demitter = fn@(cmsp: Option<(@codemap::CodeMap, codemap::span)>,\n-                           msg: &str, lvl: diagnostic::level) {\n-            if lvl == diagnostic::fatal {\n-                comm::send(ch, fatal);\n-            }\n-            diagnostic::emit(cmsp, msg, lvl);\n-        };\n-\n-        struct finally {\n-            ch: comm::Chan<monitor_msg>,\n-            drop { comm::send(self.ch, done); }\n-        }\n-\n-        let _finally = finally { ch: ch };\n-\n-        f(demitter)\n-    } {\n-        result::Ok(_) => { /* fallthrough */ }\n-        result::Err(_) => {\n-            // Task failed without emitting a fatal diagnostic\n-            if comm::recv(p) == done {\n-                diagnostic::emit(\n-                    None,\n-                    diagnostic::ice_msg(~\"unexpected failure\"),\n-                    diagnostic::error);\n-\n-                for [\n-                    ~\"the compiler hit an unexpected failure path. \\\n-                     this is a bug\",\n-                    ~\"try running with RUST_LOG=rustc=1,::rt::backtrace \\\n-                     to get further details and report the results \\\n-                     to github.com/mozilla/rust/issues\"\n-                ].each |note| {\n-                    diagnostic::emit(None, *note, diagnostic::note)\n-                }\n-            }\n-            // Fail so the process returns a failure code\n-            fail;\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let mut args = os::args();\n-    do monitor |move args, demitter| {\n-        run_compiler(&args, demitter);\n-    }\n-}\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "b722d7144fdceafe248ab186854c3e4ba386e9d0", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -11,19 +11,9 @@ pub enum OutputFormat {\n }\n \n impl OutputFormat : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &OutputFormat) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &OutputFormat) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &OutputFormat) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &OutputFormat) -> bool { !(*self).eq(other) }\n }\n \n@@ -36,19 +26,9 @@ pub enum OutputStyle {\n }\n \n impl OutputStyle : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &OutputStyle) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &OutputStyle) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &OutputStyle) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &OutputStyle) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "16fba7a9ffd4e3ba1daaded373178d2ef98dce6d", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 0, "deletions": 289, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -7,19 +7,9 @@ pub type Doc_ = {\n };\n \n impl Doc_ : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Doc_) -> bool {\n-        self.pages == (*other).pages\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Doc_) -> bool {\n         (*self).pages == (*other).pages\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Doc_) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Doc_) -> bool { !(*self).eq(other) }\n }\n \n@@ -28,15 +18,7 @@ pub enum Doc {\n }\n \n impl Doc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Doc) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Doc) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Doc) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Doc) -> bool { *(*self) != *(*other) }\n }\n \n@@ -46,25 +28,6 @@ pub enum Page {\n }\n \n impl Page : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Page) -> bool {\n-        match self {\n-            CratePage(e0a) => {\n-                match (*other) {\n-                    CratePage(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ItemPage(e0a) => {\n-                match (*other) {\n-                    ItemPage(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Page) -> bool {\n         match (*self) {\n             CratePage(e0a) => {\n@@ -81,10 +44,6 @@ impl Page : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Page) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Page) -> bool { !(*self).eq(other) }\n }\n \n@@ -94,19 +53,9 @@ pub enum Implementation {\n }\n \n impl Implementation : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Implementation) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Implementation) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Implementation) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Implementation) -> bool { !(*self).eq(other) }\n }\n \n@@ -121,19 +70,9 @@ pub type Section = {\n };\n \n impl Section : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Section) -> bool {\n-        self.header == (*other).header && self.body == (*other).body\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Section) -> bool {\n         (*self).header == (*other).header && (*self).body == (*other).body\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Section) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Section) -> bool { !(*self).eq(other) }\n }\n \n@@ -145,19 +84,9 @@ pub type CrateDoc = {\n };\n \n impl CrateDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &CrateDoc) -> bool {\n-        self.topmod == (*other).topmod\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &CrateDoc) -> bool {\n         (*self).topmod == (*other).topmod\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &CrateDoc) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &CrateDoc) -> bool { !(*self).eq(other) }\n }\n \n@@ -174,67 +103,6 @@ pub enum ItemTag {\n }\n \n impl ItemTag : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ItemTag) -> bool {\n-        match self {\n-            ModTag(e0a) => {\n-                match (*other) {\n-                    ModTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            NmodTag(e0a) => {\n-                match (*other) {\n-                    NmodTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ConstTag(e0a) => {\n-                match (*other) {\n-                    ConstTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            FnTag(e0a) => {\n-                match (*other) {\n-                    FnTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            EnumTag(e0a) => {\n-                match (*other) {\n-                    EnumTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            TraitTag(e0a) => {\n-                match (*other) {\n-                    TraitTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ImplTag(e0a) => {\n-                match (*other) {\n-                    ImplTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            TyTag(e0a) => {\n-                match (*other) {\n-                    TyTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            StructTag(e0a) => {\n-                match (*other) {\n-                    StructTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ItemTag) -> bool {\n         match (*self) {\n             ModTag(e0a) => {\n@@ -293,10 +161,6 @@ impl ItemTag : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ItemTag) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ItemTag) -> bool { !(*self).eq(other) }\n }\n \n@@ -312,18 +176,6 @@ pub type ItemDoc = {\n };\n \n impl ItemDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ItemDoc) -> bool {\n-        self.id == (*other).id &&\n-        self.name == (*other).name &&\n-        self.path == (*other).path &&\n-        self.brief == (*other).brief &&\n-        self.desc == (*other).desc &&\n-        self.sections == (*other).sections &&\n-        self.reexport == (*other).reexport\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ItemDoc) -> bool {\n         (*self).id == (*other).id &&\n         (*self).name == (*other).name &&\n@@ -333,10 +185,6 @@ impl ItemDoc : cmp::Eq {\n         (*self).sections == (*other).sections &&\n         (*self).reexport == (*other).reexport\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ItemDoc) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ItemDoc) -> bool { !(*self).eq(other) }\n }\n \n@@ -346,19 +194,9 @@ pub type SimpleItemDoc = {\n };\n \n impl SimpleItemDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &SimpleItemDoc) -> bool {\n-        self.item == (*other).item && self.sig == (*other).sig\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &SimpleItemDoc) -> bool {\n         (*self).item == (*other).item && (*self).sig == (*other).sig\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &SimpleItemDoc) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &SimpleItemDoc) -> bool { !(*self).eq(other) }\n }\n \n@@ -369,23 +207,11 @@ pub type ModDoc_ = {\n };\n \n impl ModDoc_ : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ModDoc_) -> bool {\n-        self.item == (*other).item &&\n-        self.items == (*other).items &&\n-        self.index == (*other).index\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ModDoc_) -> bool {\n         (*self).item == (*other).item &&\n         (*self).items == (*other).items &&\n         (*self).index == (*other).index\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ModDoc_) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ModDoc_) -> bool { !(*self).eq(other) }\n }\n \n@@ -394,15 +220,7 @@ pub enum ModDoc {\n }\n \n impl ModDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ModDoc) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ModDoc) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ModDoc) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ModDoc) -> bool { *(*self) != *(*other) }\n }\n \n@@ -413,23 +231,11 @@ pub type NmodDoc = {\n };\n \n impl NmodDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &NmodDoc) -> bool {\n-        self.item == (*other).item &&\n-        self.fns == (*other).fns &&\n-        self.index == (*other).index\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &NmodDoc) -> bool {\n         (*self).item == (*other).item &&\n         (*self).fns == (*other).fns &&\n         (*self).index == (*other).index\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &NmodDoc) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &NmodDoc) -> bool { !(*self).eq(other) }\n }\n \n@@ -443,19 +249,9 @@ pub type EnumDoc = {\n };\n \n impl EnumDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &EnumDoc) -> bool {\n-        self.item == (*other).item && self.variants == (*other).variants\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &EnumDoc) -> bool {\n         (*self).item == (*other).item && (*self).variants == (*other).variants\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &EnumDoc) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &EnumDoc) -> bool { !(*self).eq(other) }\n }\n \n@@ -466,23 +262,11 @@ pub type VariantDoc = {\n };\n \n impl VariantDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &VariantDoc) -> bool {\n-        self.name == (*other).name &&\n-        self.desc == (*other).desc &&\n-        self.sig == (*other).sig\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &VariantDoc) -> bool {\n         (*self).name == (*other).name &&\n         (*self).desc == (*other).desc &&\n         (*self).sig == (*other).sig\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &VariantDoc) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &VariantDoc) -> bool { !(*self).eq(other) }\n }\n \n@@ -492,19 +276,9 @@ pub type TraitDoc = {\n };\n \n impl TraitDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &TraitDoc) -> bool {\n-        self.item == (*other).item && self.methods == (*other).methods\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &TraitDoc) -> bool {\n         (*self).item == (*other).item && (*self).methods == (*other).methods\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &TraitDoc) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &TraitDoc) -> bool { !(*self).eq(other) }\n }\n \n@@ -518,17 +292,6 @@ pub type MethodDoc = {\n };\n \n impl MethodDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &MethodDoc) -> bool {\n-        self.name == (*other).name &&\n-        self.brief == (*other).brief &&\n-        self.desc == (*other).desc &&\n-        self.sections == (*other).sections &&\n-        self.sig == (*other).sig &&\n-        self.implementation == (*other).implementation\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &MethodDoc) -> bool {\n         (*self).name == (*other).name &&\n         (*self).brief == (*other).brief &&\n@@ -537,10 +300,6 @@ impl MethodDoc : cmp::Eq {\n         (*self).sig == (*other).sig &&\n         (*self).implementation == (*other).implementation\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &MethodDoc) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &MethodDoc) -> bool { !(*self).eq(other) }\n }\n \n@@ -552,25 +311,12 @@ pub type ImplDoc = {\n };\n \n impl ImplDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ImplDoc) -> bool {\n-        self.item == (*other).item &&\n-        self.trait_types == (*other).trait_types &&\n-        self.self_ty == (*other).self_ty &&\n-        self.methods == (*other).methods\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ImplDoc) -> bool {\n         (*self).item == (*other).item &&\n         (*self).trait_types == (*other).trait_types &&\n         (*self).self_ty == (*other).self_ty &&\n         (*self).methods == (*other).methods\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ImplDoc) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ImplDoc) -> bool { !(*self).eq(other) }\n }\n \n@@ -583,23 +329,11 @@ pub type StructDoc = {\n };\n \n impl StructDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &StructDoc) -> bool {\n-        return self.item == other.item\n-            && self.fields == other.fields\n-            && self.sig == other.sig;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &StructDoc) -> bool {\n         return (*self).item == other.item\n             && (*self).fields == other.fields\n             && (*self).sig == other.sig;\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &StructDoc) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &StructDoc) -> bool { !(*self).eq(other) }\n }\n \n@@ -608,19 +342,9 @@ pub type Index = {\n };\n \n impl Index : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Index) -> bool {\n-        self.entries == (*other).entries\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Index) -> bool {\n         (*self).entries == (*other).entries\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Index) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Index) -> bool { !(*self).eq(other) }\n }\n \n@@ -642,25 +366,12 @@ pub type IndexEntry = {\n };\n \n impl IndexEntry : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &IndexEntry) -> bool {\n-        self.kind == (*other).kind &&\n-        self.name == (*other).name &&\n-        self.brief == (*other).brief &&\n-        self.link == (*other).link\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &IndexEntry) -> bool {\n         (*self).kind == (*other).kind &&\n         (*self).name == (*other).name &&\n         (*self).brief == (*other).brief &&\n         (*self).link == (*other).link\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &IndexEntry) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &IndexEntry) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "bfbf8b40f300bed396a01d5f3e7f5159544a5ff7", "filename": "src/librustdoc/rustdoc.rc", "status": "modified", "additions": 93, "deletions": 1, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rc?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -52,4 +52,96 @@ mod page_pass;\n mod sectionalize_pass;\n mod escape_pass;\n mod prune_private_pass;\n-mod util;\n\\ No newline at end of file\n+mod util;\n+\n+use doc::ItemUtils;\n+use doc::Item;\n+use pass::Pass;\n+use config::Config;\n+\n+fn main() {\n+    let args = os::args();\n+\n+    if args.contains(&~\"-h\") || args.contains(&~\"--help\") {\n+        config::usage();\n+        return;\n+    }\n+\n+    let config = match config::parse_config(args) {\n+      Ok(config) => config,\n+      Err(err) => {\n+        io::println(fmt!(\"error: %s\", err));\n+        return;\n+      }\n+    };\n+\n+    run(config);\n+}\n+\n+/// Runs rustdoc over the given file\n+fn run(config: Config) {\n+\n+    let source_file = config.input_crate;\n+\n+    // Create an AST service from the source code\n+    do astsrv::from_file(source_file.to_str()) |srv| {\n+\n+        // Just time how long it takes for the AST to become available\n+        do time(~\"wait_ast\") {\n+            do astsrv::exec(srv) |_ctxt| { }\n+        };\n+\n+        // Extract the initial doc tree from the AST. This contains\n+        // just names and node ids.\n+        let doc = time(~\"extract\", || {\n+            let default_name = source_file;\n+            extract::from_srv(srv, default_name.to_str())\n+        });\n+\n+        // Refine and publish the document\n+        pass::run_passes(srv, doc, ~[\n+            // Generate type and signature strings\n+            tystr_pass::mk_pass(),\n+            // Record the full paths to various nodes\n+            path_pass::mk_pass(),\n+            // Extract the docs attributes and attach them to doc nodes\n+            attr_pass::mk_pass(),\n+            // Perform various text escaping\n+            escape_pass::mk_pass(),\n+            // Remove things marked doc(hidden)\n+            prune_hidden_pass::mk_pass(),\n+            // Remove things that are private\n+            // XXX enable this after 'export' is removed in favor of 'pub'\n+            // prune_private_pass::mk_pass(),\n+            // Extract brief documentation from the full descriptions\n+            desc_to_brief_pass::mk_pass(),\n+            // Massage the text to remove extra indentation\n+            unindent_pass::mk_pass(),\n+            // Split text into multiple sections according to headers\n+            sectionalize_pass::mk_pass(),\n+            // Trim extra spaces from text\n+            trim_pass::mk_pass(),\n+            // Sort items by name\n+            sort_item_name_pass::mk_pass(),\n+            // Sort items again by kind\n+            sort_item_type_pass::mk_pass(),\n+            // Create indexes appropriate for markdown\n+            markdown_index_pass::mk_pass(config),\n+            // Break the document into pages if required by the\n+            // output format\n+            page_pass::mk_pass(config.output_style),\n+            // Render\n+            markdown_pass::mk_pass(\n+                markdown_writer::make_writer_factory(config)\n+            )\n+        ]);\n+    }\n+}\n+\n+fn time<T>(what: ~str, f: fn() -> T) -> T {\n+    let start = std::time::precise_time_s();\n+    let rv = f();\n+    let end = std::time::precise_time_s();\n+    info!(\"time: %3.3f s    %s\", end - start, what);\n+    move rv\n+}"}, {"sha": "e09f57339a7c6451a3fbef70bdfd2c49616eed80", "filename": "src/librustdoc/rustdoc.rs", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,91 +0,0 @@\n-use doc::ItemUtils;\n-use doc::Item;\n-use pass::Pass;\n-use config::Config;\n-\n-fn main() {\n-    let args = os::args();\n-\n-    if args.contains(&~\"-h\") || args.contains(&~\"--help\") {\n-        config::usage();\n-        return;\n-    }\n-\n-    let config = match config::parse_config(args) {\n-      Ok(config) => config,\n-      Err(err) => {\n-        io::println(fmt!(\"error: %s\", err));\n-        return;\n-      }\n-    };\n-\n-    run(config);\n-}\n-\n-/// Runs rustdoc over the given file\n-fn run(config: Config) {\n-\n-    let source_file = config.input_crate;\n-\n-    // Create an AST service from the source code\n-    do astsrv::from_file(source_file.to_str()) |srv| {\n-\n-        // Just time how long it takes for the AST to become available\n-        do time(~\"wait_ast\") {\n-            do astsrv::exec(srv) |_ctxt| { }\n-        };\n-\n-        // Extract the initial doc tree from the AST. This contains\n-        // just names and node ids.\n-        let doc = time(~\"extract\", || {\n-            let default_name = source_file;\n-            extract::from_srv(srv, default_name.to_str())\n-        });\n-\n-        // Refine and publish the document\n-        pass::run_passes(srv, doc, ~[\n-            // Generate type and signature strings\n-            tystr_pass::mk_pass(),\n-            // Record the full paths to various nodes\n-            path_pass::mk_pass(),\n-            // Extract the docs attributes and attach them to doc nodes\n-            attr_pass::mk_pass(),\n-            // Perform various text escaping\n-            escape_pass::mk_pass(),\n-            // Remove things marked doc(hidden)\n-            prune_hidden_pass::mk_pass(),\n-            // Remove things that are private\n-            // XXX enable this after 'export' is removed in favor of 'pub'\n-            // prune_private_pass::mk_pass(),\n-            // Extract brief documentation from the full descriptions\n-            desc_to_brief_pass::mk_pass(),\n-            // Massage the text to remove extra indentation\n-            unindent_pass::mk_pass(),\n-            // Split text into multiple sections according to headers\n-            sectionalize_pass::mk_pass(),\n-            // Trim extra spaces from text\n-            trim_pass::mk_pass(),\n-            // Sort items by name\n-            sort_item_name_pass::mk_pass(),\n-            // Sort items again by kind\n-            sort_item_type_pass::mk_pass(),\n-            // Create indexes appropriate for markdown\n-            markdown_index_pass::mk_pass(config),\n-            // Break the document into pages if required by the\n-            // output format\n-            page_pass::mk_pass(config.output_style),\n-            // Render\n-            markdown_pass::mk_pass(\n-                markdown_writer::make_writer_factory(config)\n-            )\n-        ]);\n-    }\n-}\n-\n-fn time<T>(what: ~str, f: fn() -> T) -> T {\n-    let start = std::time::precise_time_s();\n-    let rv = f();\n-    let end = std::time::precise_time_s();\n-    info!(\"time: %3.3f s    %s\", end - start, what);\n-    move rv\n-}"}, {"sha": "1b90a227098223e4009cb5180c65aa07c047e3eb", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 382, "deletions": 0, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -31,3 +31,385 @@ use syntax::ast_util::*;\n use parse::token;\n use print::{pp, pprust};\n use std::rl;\n+\n+/**\n+ * A structure shared across REPL instances for storing history\n+ * such as statements and view items. I wish the AST was sendable.\n+ */\n+struct Repl {\n+    prompt: ~str,\n+    binary: ~str,\n+    running: bool,\n+    view_items: ~str,\n+    stmts: ~str\n+}\n+\n+// Action to do after reading a :command\n+enum CmdAction {\n+    action_none,\n+    action_run_line(~str),\n+}\n+\n+/// A utility function that hands off a pretty printer to a callback.\n+fn with_pp(intr: @token::ident_interner,\n+           cb: fn(pprust::ps, io::Writer)) -> ~str {\n+    do io::with_str_writer |writer| {\n+        let pp = pprust::rust_printer(writer, intr);\n+\n+        cb(pp, writer);\n+        pp::eof(pp.s);\n+    }\n+}\n+\n+/**\n+ * The AST (or the rest of rustc) are not sendable yet,\n+ * so recorded things are printed to strings. A terrible hack that\n+ * needs changes to rustc in order to be outed. This is unfortunately\n+ * going to cause the REPL to regress in parser performance,\n+ * because it has to parse the statements and view_items on each\n+ * input.\n+ */\n+fn record(repl: Repl, blk: @ast::blk, intr: @token::ident_interner) -> Repl {\n+    let view_items = if blk.node.view_items.len() > 0 {\n+        let new_view_items = do with_pp(intr) |pp, writer| {\n+            for blk.node.view_items.each |view_item| {\n+                pprust::print_view_item(pp, *view_item);\n+                writer.write_line(~\"\");\n+            }\n+        };\n+\n+        debug!(\"new view items %s\", new_view_items);\n+\n+        repl.view_items + \"\\n\" + new_view_items\n+    } else { repl.view_items };\n+    let stmts = if blk.node.stmts.len() > 0 {\n+        let new_stmts = do with_pp(intr) |pp, writer| {\n+            for blk.node.stmts.each |stmt| {\n+                match stmt.node {\n+                    ast::stmt_decl(*) => {\n+                        pprust::print_stmt(pp, **stmt);\n+                        writer.write_line(~\"\");\n+                    }\n+                    ast::stmt_expr(expr, _) | ast::stmt_semi(expr, _) => {\n+                        match expr.node {\n+                            ast::expr_assign(*) |\n+                            ast::expr_assign_op(*) |\n+                            ast::expr_swap(*) => {\n+                                pprust::print_stmt(pp, **stmt);\n+                                writer.write_line(~\"\");\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                }\n+            }\n+        };\n+\n+        debug!(\"new stmts %s\", new_stmts);\n+\n+        repl.stmts + \"\\n\" + new_stmts\n+    } else { repl.stmts };\n+\n+    Repl{\n+        view_items: view_items,\n+        stmts: stmts,\n+        .. repl\n+    }\n+}\n+\n+/// Run an input string in a Repl, returning the new Repl.\n+fn run(repl: Repl, input: ~str) -> Repl {\n+    let options: @session::options = @{\n+        crate_type: session::unknown_crate,\n+        binary: repl.binary,\n+        addl_lib_search_paths: ~[os::getcwd()],\n+        .. *session::basic_options()\n+    };\n+\n+    debug!(\"building driver input\");\n+    let head = include_str!(\"wrapper.rs\");\n+    let foot = fmt!(\"%s\\nfn main() {\\n%s\\n\\nprint({\\n%s\\n})\\n}\",\n+                    repl.view_items, repl.stmts, input);\n+    let wrapped = driver::str_input(head + foot);\n+\n+    debug!(\"inputting %s\", head + foot);\n+\n+    debug!(\"building a driver session\");\n+    let sess = driver::build_session(options, diagnostic::emit);\n+\n+    debug!(\"building driver configuration\");\n+    let cfg = driver::build_configuration(sess,\n+                                          repl.binary,\n+                                          wrapped);\n+\n+    debug!(\"parsing\");\n+    let mut crate = driver::parse_input(sess, cfg, wrapped);\n+    let mut opt = None;\n+\n+    for crate.node.module.items.each |item| {\n+        match item.node {\n+            ast::item_fn(_, _, _, blk) => {\n+                if item.ident == sess.ident_of(~\"main\") {\n+                    opt = blk.node.expr;\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    let blk = match opt.get().node {\n+        ast::expr_call(_, exprs, _) => {\n+            match exprs[0].node {\n+                ast::expr_block(blk) => @blk,\n+                _ => fail\n+            }\n+        }\n+        _ => fail\n+    };\n+\n+    debug!(\"configuration\");\n+    crate = front::config::strip_unconfigured_items(crate);\n+\n+    debug!(\"maybe building test harness\");\n+    crate = front::test::modify_for_testing(sess, crate);\n+\n+    debug!(\"expansion\");\n+    crate = syntax::ext::expand::expand_crate(sess.parse_sess,\n+                                              sess.opts.cfg,\n+                                              crate);\n+\n+    debug!(\"intrinsic injection\");\n+    crate = front::intrinsic_inject::inject_intrinsic(sess, crate);\n+\n+    debug!(\"core injection\");\n+    crate = front::core_inject::maybe_inject_libcore_ref(sess, crate);\n+\n+    debug!(\"building lint settings table\");\n+    lint::build_settings_crate(sess, crate);\n+\n+    debug!(\"ast indexing\");\n+    let ast_map = syntax::ast_map::map_crate(sess.diagnostic(), *crate);\n+\n+    debug!(\"external crate/lib resolution\");\n+    creader::read_crates(sess.diagnostic(), *crate, sess.cstore,\n+                         sess.filesearch,\n+                         session::sess_os_to_meta_os(sess.targ_cfg.os),\n+                         sess.opts.static, sess.parse_sess.interner);\n+\n+    debug!(\"language item collection\");\n+    let lang_items = middle::lang_items::collect_language_items(crate, sess);\n+\n+    debug!(\"resolution\");\n+    let {def_map: def_map,\n+         exp_map2: exp_map2,\n+         trait_map: trait_map} = middle::resolve::resolve_crate(sess,\n+                                                                lang_items,\n+                                                                crate);\n+\n+    debug!(\"freevar finding\");\n+    let freevars = freevars::annotate_freevars(def_map, crate);\n+\n+    debug!(\"region_resolution\");\n+    let region_map = middle::region::resolve_crate(sess, def_map, crate);\n+\n+    debug!(\"region paramaterization inference\");\n+    let rp_set = middle::region::determine_rp_in_crate(sess, ast_map,\n+                                                       def_map, crate);\n+\n+    debug!(\"typechecking\");\n+    let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars,\n+                            region_map, rp_set, move lang_items, crate);\n+    let (method_map, vtable_map) = typeck::check_crate(ty_cx, trait_map,\n+                                                       crate);\n+\n+    debug!(\"const marking\");\n+    middle::const_eval::process_crate(crate, def_map, ty_cx);\n+\n+    debug!(\"const checking\");\n+    middle::check_const::check_crate(sess, crate, ast_map, def_map,\n+                                     method_map, ty_cx);\n+\n+    debug!(\"privacy checking\");\n+    middle::privacy::check_crate(ty_cx, &method_map, crate);\n+\n+    debug!(\"loop checking\");\n+    middle::check_loop::check_crate(ty_cx, crate);\n+\n+    debug!(\"alt checking\");\n+    middle::check_alt::check_crate(ty_cx, crate);\n+\n+    debug!(\"liveness checking\");\n+    let last_use_map = middle::liveness::check_crate(ty_cx,\n+                                                     method_map, crate);\n+\n+    debug!(\"borrow checking\");\n+    let (root_map, mutbl_map) = middle::borrowck::check_crate(ty_cx,\n+                                                              method_map,\n+                                                              last_use_map,\n+                                                              crate);\n+\n+    debug!(\"kind checking\");\n+    kind::check_crate(ty_cx, method_map, last_use_map, crate);\n+\n+    debug!(\"lint checking\");\n+    lint::check_crate(ty_cx, crate);\n+\n+    let maps = {mutbl_map: mutbl_map,\n+                root_map: root_map,\n+                last_use_map: last_use_map,\n+                method_map: method_map,\n+                vtable_map: vtable_map};\n+\n+    debug!(\"translation\");\n+    let (llmod, _) = trans::base::trans_crate(sess, crate, ty_cx,\n+                                              ~path::from_str(\"<repl>\"),\n+                                              exp_map2, maps);\n+    let pm = llvm::LLVMCreatePassManager();\n+\n+    debug!(\"executing jit\");\n+    back::link::jit::exec(sess, pm, llmod, 0, false);\n+    llvm::LLVMDisposePassManager(pm);\n+\n+    debug!(\"recording input into repl history\");\n+    record(repl, blk, sess.parse_sess.interner)\n+}\n+\n+/// Tries to get a line from rl after outputting a prompt. Returns\n+/// None if no input was read (e.g. EOF was reached).\n+fn get_line(prompt: ~str) -> Option<~str> {\n+    let result = unsafe { rl::read(prompt) };\n+\n+    if result.is_none() {\n+        return None;\n+    }\n+\n+    let line = result.get();\n+\n+    unsafe { rl::add_history(line) };\n+\n+    return Some(line);\n+}\n+\n+/// Run a command, e.g. :clear, :exit, etc.\n+fn run_cmd(repl: &mut Repl, _in: io::Reader, _out: io::Writer,\n+           cmd: ~str, _args: ~[~str]) -> CmdAction {\n+    let mut action = action_none;\n+    match cmd {\n+        ~\"exit\" => repl.running = false,\n+        ~\"clear\" => {\n+            repl.view_items = ~\"\";\n+            repl.stmts = ~\"\";\n+\n+            // XXX: Win32 version of linenoise can't do this\n+            //rl::clear();\n+        }\n+        ~\"help\" => {\n+            io::println(\n+                ~\":{\\\\n ..lines.. \\\\n:}\\\\n - execute multiline command\\n\" +\n+                ~\":clear - clear the screen\\n\" +\n+                ~\":exit - exit from the repl\\n\" +\n+                ~\":help - show this message\");\n+        }\n+        ~\"{\" => {\n+            let mut multiline_cmd = ~\"\";\n+            let mut end_multiline = false;\n+            while (!end_multiline) {\n+                match get_line(~\"rusti| \") {\n+                    None => fail ~\"unterminated multiline command :{ .. :}\",\n+                    Some(line) => {\n+                        if str::trim(line) == ~\":}\" {\n+                            end_multiline = true;\n+                        } else {\n+                            multiline_cmd += line + ~\"\\n\";\n+                        }\n+                    }\n+                }\n+            }\n+            action = action_run_line(multiline_cmd);\n+        }\n+        _ => io::println(~\"unknown cmd: \" + cmd)\n+    }\n+    return action;\n+}\n+\n+/// Executes a line of input, which may either be rust code or a\n+/// :command. Returns a new Repl if it has changed.\n+fn run_line(repl: &mut Repl, in: io::Reader, out: io::Writer, line: ~str)\n+    -> Option<Repl> {\n+    if line.starts_with(~\":\") {\n+        let full = line.substr(1, line.len() - 1);\n+        let split = str::words(full);\n+        let len = split.len();\n+\n+        if len > 0 {\n+            let cmd = split[0];\n+\n+            if !cmd.is_empty() {\n+                let args = if len > 1 {\n+                    do vec::view(split, 1, len - 1).map |arg| {\n+                        *arg\n+                    }\n+                } else { ~[] };\n+\n+                match run_cmd(repl, in, out, cmd, args) {\n+                    action_none => { }\n+                    action_run_line(multiline_cmd) => {\n+                        if !multiline_cmd.is_empty() {\n+                            return run_line(repl, in, out, multiline_cmd);\n+                        }\n+                    }\n+                }\n+                return None;\n+            }\n+        }\n+    }\n+\n+    let r = *repl;\n+    let result = do task::try |copy r| {\n+        run(r, line)\n+    };\n+\n+    if result.is_ok() {\n+        return Some(result.get());\n+    }\n+    return None;\n+}\n+\n+pub fn main() {\n+    let args = os::args();\n+    let in = io::stdin();\n+    let out = io::stdout();\n+    let mut repl = Repl {\n+        prompt: ~\"rusti> \",\n+        binary: args[0],\n+        running: true,\n+        view_items: ~\"\",\n+        stmts: ~\"\"\n+    };\n+\n+    unsafe {\n+        do rl::complete |line, suggest| {\n+            if line.starts_with(\":\") {\n+                suggest(~\":clear\");\n+                suggest(~\":exit\");\n+                suggest(~\":help\");\n+            }\n+        }\n+    }\n+\n+    while repl.running {\n+        match get_line(repl.prompt) {\n+            None => break,\n+            Some(line) => {\n+                if line.is_empty() {\n+                    io::println(~\"()\");\n+                    loop;\n+                }\n+                match run_line(&mut repl, in, out, line) {\n+                    Some(new_repl) => repl = new_repl,\n+                    None => { }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "79009761467489cd71058d054dbfc574a8d56fb9", "filename": "src/librusti/rusti.rs", "status": "removed", "additions": 0, "deletions": 381, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,381 +0,0 @@\n-/**\n- * A structure shared across REPL instances for storing history\n- * such as statements and view items. I wish the AST was sendable.\n- */\n-struct Repl {\n-    prompt: ~str,\n-    binary: ~str,\n-    running: bool,\n-    view_items: ~str,\n-    stmts: ~str\n-}\n-\n-// Action to do after reading a :command\n-enum CmdAction {\n-    action_none,\n-    action_run_line(~str),\n-}\n-\n-/// A utility function that hands off a pretty printer to a callback.\n-fn with_pp(intr: @token::ident_interner,\n-           cb: fn(pprust::ps, io::Writer)) -> ~str {\n-    do io::with_str_writer |writer| {\n-        let pp = pprust::rust_printer(writer, intr);\n-\n-        cb(pp, writer);\n-        pp::eof(pp.s);\n-    }\n-}\n-\n-/**\n- * The AST (or the rest of rustc) are not sendable yet,\n- * so recorded things are printed to strings. A terrible hack that\n- * needs changes to rustc in order to be outed. This is unfortunately\n- * going to cause the REPL to regress in parser performance,\n- * because it has to parse the statements and view_items on each\n- * input.\n- */\n-fn record(repl: Repl, blk: @ast::blk, intr: @token::ident_interner) -> Repl {\n-    let view_items = if blk.node.view_items.len() > 0 {\n-        let new_view_items = do with_pp(intr) |pp, writer| {\n-            for blk.node.view_items.each |view_item| {\n-                pprust::print_view_item(pp, *view_item);\n-                writer.write_line(~\"\");\n-            }\n-        };\n-\n-        debug!(\"new view items %s\", new_view_items);\n-\n-        repl.view_items + \"\\n\" + new_view_items\n-    } else { repl.view_items };\n-    let stmts = if blk.node.stmts.len() > 0 {\n-        let new_stmts = do with_pp(intr) |pp, writer| {\n-            for blk.node.stmts.each |stmt| {\n-                match stmt.node {\n-                    ast::stmt_decl(*) => {\n-                        pprust::print_stmt(pp, **stmt);\n-                        writer.write_line(~\"\");\n-                    }\n-                    ast::stmt_expr(expr, _) | ast::stmt_semi(expr, _) => {\n-                        match expr.node {\n-                            ast::expr_assign(*) |\n-                            ast::expr_assign_op(*) |\n-                            ast::expr_swap(*) => {\n-                                pprust::print_stmt(pp, **stmt);\n-                                writer.write_line(~\"\");\n-                            }\n-                            _ => {}\n-                        }\n-                    }\n-                }\n-            }\n-        };\n-\n-        debug!(\"new stmts %s\", new_stmts);\n-\n-        repl.stmts + \"\\n\" + new_stmts\n-    } else { repl.stmts };\n-\n-    Repl{\n-        view_items: view_items,\n-        stmts: stmts,\n-        .. repl\n-    }\n-}\n-\n-/// Run an input string in a Repl, returning the new Repl.\n-fn run(repl: Repl, input: ~str) -> Repl {\n-    let options: @session::options = @{\n-        crate_type: session::unknown_crate,\n-        binary: repl.binary,\n-        addl_lib_search_paths: ~[os::getcwd()],\n-        .. *session::basic_options()\n-    };\n-\n-    debug!(\"building driver input\");\n-    let head = include_str!(\"wrapper.rs\");\n-    let foot = fmt!(\"%s\\nfn main() {\\n%s\\n\\nprint({\\n%s\\n})\\n}\",\n-                    repl.view_items, repl.stmts, input);\n-    let wrapped = driver::str_input(head + foot);\n-\n-    debug!(\"inputting %s\", head + foot);\n-\n-    debug!(\"building a driver session\");\n-    let sess = driver::build_session(options, diagnostic::emit);\n-\n-    debug!(\"building driver configuration\");\n-    let cfg = driver::build_configuration(sess,\n-                                          repl.binary,\n-                                          wrapped);\n-\n-    debug!(\"parsing\");\n-    let mut crate = driver::parse_input(sess, cfg, wrapped);\n-    let mut opt = None;\n-\n-    for crate.node.module.items.each |item| {\n-        match item.node {\n-            ast::item_fn(_, _, _, blk) => {\n-                if item.ident == sess.ident_of(~\"main\") {\n-                    opt = blk.node.expr;\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    let blk = match opt.get().node {\n-        ast::expr_call(_, exprs, _) => {\n-            match exprs[0].node {\n-                ast::expr_block(blk) => @blk,\n-                _ => fail\n-            }\n-        }\n-        _ => fail\n-    };\n-\n-    debug!(\"configuration\");\n-    crate = front::config::strip_unconfigured_items(crate);\n-\n-    debug!(\"maybe building test harness\");\n-    crate = front::test::modify_for_testing(sess, crate);\n-\n-    debug!(\"expansion\");\n-    crate = syntax::ext::expand::expand_crate(sess.parse_sess,\n-                                              sess.opts.cfg,\n-                                              crate);\n-\n-    debug!(\"intrinsic injection\");\n-    crate = front::intrinsic_inject::inject_intrinsic(sess, crate);\n-\n-    debug!(\"core injection\");\n-    crate = front::core_inject::maybe_inject_libcore_ref(sess, crate);\n-\n-    debug!(\"building lint settings table\");\n-    lint::build_settings_crate(sess, crate);\n-\n-    debug!(\"ast indexing\");\n-    let ast_map = syntax::ast_map::map_crate(sess.diagnostic(), *crate);\n-\n-    debug!(\"external crate/lib resolution\");\n-    creader::read_crates(sess.diagnostic(), *crate, sess.cstore,\n-                         sess.filesearch,\n-                         session::sess_os_to_meta_os(sess.targ_cfg.os),\n-                         sess.opts.static, sess.parse_sess.interner);\n-\n-    debug!(\"language item collection\");\n-    let lang_items = middle::lang_items::collect_language_items(crate, sess);\n-\n-    debug!(\"resolution\");\n-    let {def_map: def_map,\n-         exp_map2: exp_map2,\n-         trait_map: trait_map} = middle::resolve::resolve_crate(sess,\n-                                                                lang_items,\n-                                                                crate);\n-\n-    debug!(\"freevar finding\");\n-    let freevars = freevars::annotate_freevars(def_map, crate);\n-\n-    debug!(\"region_resolution\");\n-    let region_map = middle::region::resolve_crate(sess, def_map, crate);\n-\n-    debug!(\"region paramaterization inference\");\n-    let rp_set = middle::region::determine_rp_in_crate(sess, ast_map,\n-                                                       def_map, crate);\n-\n-    debug!(\"typechecking\");\n-    let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars,\n-                            region_map, rp_set, move lang_items, crate);\n-    let (method_map, vtable_map) = typeck::check_crate(ty_cx, trait_map,\n-                                                       crate);\n-\n-    debug!(\"const marking\");\n-    middle::const_eval::process_crate(crate, def_map, ty_cx);\n-\n-    debug!(\"const checking\");\n-    middle::check_const::check_crate(sess, crate, ast_map, def_map,\n-                                     method_map, ty_cx);\n-\n-    debug!(\"privacy checking\");\n-    middle::privacy::check_crate(ty_cx, &method_map, crate);\n-\n-    debug!(\"loop checking\");\n-    middle::check_loop::check_crate(ty_cx, crate);\n-\n-    debug!(\"alt checking\");\n-    middle::check_alt::check_crate(ty_cx, crate);\n-\n-    debug!(\"liveness checking\");\n-    let last_use_map = middle::liveness::check_crate(ty_cx,\n-                                                     method_map, crate);\n-\n-    debug!(\"borrow checking\");\n-    let (root_map, mutbl_map) = middle::borrowck::check_crate(ty_cx,\n-                                                              method_map,\n-                                                              last_use_map,\n-                                                              crate);\n-\n-    debug!(\"kind checking\");\n-    kind::check_crate(ty_cx, method_map, last_use_map, crate);\n-\n-    debug!(\"lint checking\");\n-    lint::check_crate(ty_cx, crate);\n-\n-    let maps = {mutbl_map: mutbl_map,\n-                root_map: root_map,\n-                last_use_map: last_use_map,\n-                method_map: method_map,\n-                vtable_map: vtable_map};\n-\n-    debug!(\"translation\");\n-    let (llmod, _) = trans::base::trans_crate(sess, crate, ty_cx,\n-                                              ~path::from_str(\"<repl>\"),\n-                                              exp_map2, maps);\n-    let pm = llvm::LLVMCreatePassManager();\n-\n-    debug!(\"executing jit\");\n-    back::link::jit::exec(sess, pm, llmod, 0, false);\n-    llvm::LLVMDisposePassManager(pm);\n-\n-    debug!(\"recording input into repl history\");\n-    record(repl, blk, sess.parse_sess.interner)\n-}\n-\n-/// Tries to get a line from rl after outputting a prompt. Returns\n-/// None if no input was read (e.g. EOF was reached).\n-fn get_line(prompt: ~str) -> Option<~str> {\n-    let result = unsafe { rl::read(prompt) };\n-\n-    if result.is_none() {\n-        return None;\n-    }\n-\n-    let line = result.get();\n-\n-    unsafe { rl::add_history(line) };\n-\n-    return Some(line);\n-}\n-\n-/// Run a command, e.g. :clear, :exit, etc.\n-fn run_cmd(repl: &mut Repl, _in: io::Reader, _out: io::Writer,\n-           cmd: ~str, _args: ~[~str]) -> CmdAction {\n-    let mut action = action_none;\n-    match cmd {\n-        ~\"exit\" => repl.running = false,\n-        ~\"clear\" => {\n-            repl.view_items = ~\"\";\n-            repl.stmts = ~\"\";\n-\n-            // XXX: Win32 version of linenoise can't do this\n-            //rl::clear();\n-        }\n-        ~\"help\" => {\n-            io::println(\n-                ~\":{\\\\n ..lines.. \\\\n:}\\\\n - execute multiline command\\n\" +\n-                ~\":clear - clear the screen\\n\" +\n-                ~\":exit - exit from the repl\\n\" +\n-                ~\":help - show this message\");\n-        }\n-        ~\"{\" => {\n-            let mut multiline_cmd = ~\"\";\n-            let mut end_multiline = false;\n-            while (!end_multiline) {\n-                match get_line(~\"rusti| \") {\n-                    None => fail ~\"unterminated multiline command :{ .. :}\",\n-                    Some(line) => {\n-                        if str::trim(line) == ~\":}\" {\n-                            end_multiline = true;\n-                        } else {\n-                            multiline_cmd += line + ~\"\\n\";\n-                        }\n-                    }\n-                }\n-            }\n-            action = action_run_line(multiline_cmd);\n-        }\n-        _ => io::println(~\"unknown cmd: \" + cmd)\n-    }\n-    return action;\n-}\n-\n-/// Executes a line of input, which may either be rust code or a\n-/// :command. Returns a new Repl if it has changed.\n-fn run_line(repl: &mut Repl, in: io::Reader, out: io::Writer, line: ~str)\n-    -> Option<Repl> {\n-    if line.starts_with(~\":\") {\n-        let full = line.substr(1, line.len() - 1);\n-        let split = str::words(full);\n-        let len = split.len();\n-\n-        if len > 0 {\n-            let cmd = split[0];\n-\n-            if !cmd.is_empty() {\n-                let args = if len > 1 {\n-                    do vec::view(split, 1, len - 1).map |arg| {\n-                        *arg\n-                    }\n-                } else { ~[] };\n-\n-                match run_cmd(repl, in, out, cmd, args) {\n-                    action_none => { }\n-                    action_run_line(multiline_cmd) => {\n-                        if !multiline_cmd.is_empty() {\n-                            return run_line(repl, in, out, multiline_cmd);\n-                        }\n-                    }\n-                }\n-                return None;\n-            }\n-        }\n-    }\n-\n-    let r = *repl;\n-    let result = do task::try |copy r| {\n-        run(r, line)\n-    };\n-\n-    if result.is_ok() {\n-        return Some(result.get());\n-    }\n-    return None;\n-}\n-\n-pub fn main() {\n-    let args = os::args();\n-    let in = io::stdin();\n-    let out = io::stdout();\n-    let mut repl = Repl {\n-        prompt: ~\"rusti> \",\n-        binary: args[0],\n-        running: true,\n-        view_items: ~\"\",\n-        stmts: ~\"\"\n-    };\n-\n-    unsafe {\n-        do rl::complete |line, suggest| {\n-            if line.starts_with(\":\") {\n-                suggest(~\":clear\");\n-                suggest(~\":exit\");\n-                suggest(~\":help\");\n-            }\n-        }\n-    }\n-\n-    while repl.running {\n-        match get_line(repl.prompt) {\n-            None => break,\n-            Some(line) => {\n-                if line.is_empty() {\n-                    io::println(~\"()\");\n-                    loop;\n-                }\n-                match run_line(&mut repl, in, out, line) {\n-                    Some(new_repl) => repl = new_repl,\n-                    None => { }\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "f33ff892f367db542569c38b0bef5c98a7e8bc82", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -239,25 +239,6 @@ mod tests {\n     type RecCy = {x: int, y: int, t: Taggy};\n \n     impl Taggy : Eq {\n-        #[cfg(stage0)]\n-        pure fn eq(other: &Taggy) -> bool {\n-            match self {\n-              One(a1) => match (*other) {\n-                One(b1) => return a1 == b1,\n-                _ => return false\n-              },\n-              Two(a1, a2) => match (*other) {\n-                Two(b1, b2) => return a1 == b1 && a2 == b2,\n-                _ => return false\n-              },\n-              Three(a1, a2, a3) => match (*other) {\n-                Three(b1, b2, b3) => return a1 == b1 && a2 == b2 && a3 == b3,\n-                _ => return false\n-              }\n-            }\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn eq(&self, other: &Taggy) -> bool {\n             match (*self) {\n               One(a1) => match (*other) {\n@@ -274,36 +255,11 @@ mod tests {\n               }\n             }\n         }\n-        #[cfg(stage0)]\n-        pure fn ne(other: &Taggy) -> bool { !self.eq(other) }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn ne(&self, other: &Taggy) -> bool { !(*self).eq(other) }\n     }\n \n     impl Taggypar<int> : Eq {\n         //let eq4: EqFn<Taggypar<int>> = |x,y| taggypareq::<int>(x, y);\n-        #[cfg(stage0)]\n-        pure fn eq(other: &Taggypar<int>) -> bool {\n-                  match self {\n-                    Onepar::<int>(a1) => match (*other) {\n-                      Onepar::<int>(b1) => return a1 == b1,\n-                      _ => return false\n-                    },\n-                    Twopar::<int>(a1, a2) => match (*other) {\n-                      Twopar::<int>(b1, b2) => return a1 == b1 && a2 == b2,\n-                      _ => return false\n-                    },\n-                    Threepar::<int>(a1, a2, a3) => match (*other) {\n-                      Threepar::<int>(b1, b2, b3) => {\n-                          return a1 == b1 && a2 == b2 && a3 == b3\n-                      }\n-                      _ => return false\n-                    }\n-                  }\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn eq(&self, other: &Taggypar<int>) -> bool {\n                   match (*self) {\n                     Onepar::<int>(a1) => match (*other) {\n@@ -322,33 +278,16 @@ mod tests {\n                     }\n                   }\n         }\n-        #[cfg(stage0)]\n-        pure fn ne(other: &Taggypar<int>) -> bool {\n-            !self.eq(other)\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn ne(&self, other: &Taggypar<int>) -> bool {\n             !(*self).eq(other)\n         }\n     }\n \n     impl RecCy : Eq {\n-        #[cfg(stage0)]\n-        pure fn eq(other: &RecCy) -> bool {\n-          return self.x == (*other).x && self.y == (*other).y &&\n-                 self.t == (*other).t;\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn eq(&self, other: &RecCy) -> bool {\n           return (*self).x == (*other).x && (*self).y == (*other).y &&\n                  (*self).t == (*other).t;\n         }\n-        #[cfg(stage0)]\n-        pure fn ne(other: &RecCy) -> bool { !self.eq(other) }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn ne(&self, other: &RecCy) -> bool { !(*self).eq(other) }\n     }\n "}, {"sha": "ec6e1d558d4cdfcdc07912439e42ab18452811ff", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 3, "deletions": 139, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -88,25 +88,6 @@ fn mkname(nm: &str) -> Name {\n }\n \n impl Name : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Name) -> bool {\n-        match self {\n-            Long(ref e0a) => {\n-                match (*other) {\n-                    Long(ref e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            Short(e0a) => {\n-                match (*other) {\n-                    Short(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Name) -> bool {\n         match (*self) {\n             Long(ref e0a) => {\n@@ -123,65 +104,29 @@ impl Name : Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Name) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Name) -> bool { !(*self).eq(other) }\n }\n \n impl Occur : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Occur) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Occur) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Occur) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Occur) -> bool { !(*self).eq(other) }\n }\n \n impl HasArg : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &HasArg) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &HasArg) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &HasArg) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &HasArg) -> bool { !(*self).eq(other) }\n }\n \n impl Opt : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Opt) -> bool {\n-        self.name   == (*other).name   &&\n-        self.hasarg == (*other).hasarg &&\n-        self.occur  == (*other).occur\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Opt) -> bool {\n         (*self).name   == (*other).name   &&\n         (*self).hasarg == (*other).hasarg &&\n         (*self).occur  == (*other).occur\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Opt) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Opt) -> bool { !(*self).eq(other) }\n }\n \n@@ -227,17 +172,6 @@ enum Optval { Val(~str), Given, }\n pub type Matches = {opts: ~[Opt], vals: ~[~[Optval]], free: ~[~str]};\n \n impl Optval : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Optval) -> bool {\n-        match self {\n-            Val(ref s) => match *other { Val (ref os) => s == os,\n-                                          Given => false },\n-            Given       => match *other { Val(_) => false,\n-                                          Given => true }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Optval) -> bool {\n         match (*self) {\n             Val(ref s) => match *other { Val (ref os) => s == os,\n@@ -246,31 +180,15 @@ impl Optval : Eq {\n                                           Given => true }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Optval) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Optval) -> bool { !(*self).eq(other) }\n }\n \n impl Matches : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Matches) -> bool {\n-        self.opts == (*other).opts &&\n-        self.vals == (*other).vals &&\n-        self.free == (*other).free\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Matches) -> bool {\n         (*self).opts == (*other).opts &&\n         (*self).vals == (*other).vals &&\n         (*self).free == (*other).free\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Matches) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Matches) -> bool { !(*self).eq(other) }\n }\n \n@@ -303,33 +221,6 @@ pub enum Fail_ {\n \n impl Fail_ : Eq {\n     // this whole thing should be easy to infer...\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Fail_) -> bool {\n-        match self {\n-            ArgumentMissing(ref s) => {\n-                match *other { ArgumentMissing(ref so)    => s == so,\n-                               _                          => false }\n-            }\n-            UnrecognizedOption(ref s) => {\n-                match *other { UnrecognizedOption(ref so) => s == so,\n-                               _                          => false }\n-            }\n-            OptionMissing(ref s) => {\n-                match *other { OptionMissing(ref so)      => s == so,\n-                               _                          => false }\n-            }\n-            OptionDuplicated(ref s) => {\n-                match *other { OptionDuplicated(ref so)   => s == so,\n-                               _                          => false }\n-            }\n-            UnexpectedArgument(ref s) => {\n-                match *other { UnexpectedArgument(ref so) => s == so,\n-                               _                          => false }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Fail_) -> bool {\n         match (*self) {\n             ArgumentMissing(ref s) => {\n@@ -354,10 +245,6 @@ impl Fail_ : Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Fail_) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Fail_) -> bool { !(*self).eq(other) }\n }\n \n@@ -627,19 +514,9 @@ enum FailType {\n }\n \n impl FailType : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &FailType) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &FailType) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &FailType) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &FailType) -> bool { !(*self).eq(other) }\n }\n \n@@ -661,17 +538,6 @@ pub mod groups {\n     };\n \n     impl OptGroup : Eq {\n-        #[cfg(stage0)]\n-        pure fn eq(other: &OptGroup) -> bool {\n-            self.short_name == (*other).short_name &&\n-            self.long_name  == (*other).long_name  &&\n-            self.hint       == (*other).hint       &&\n-            self.desc       == (*other).desc       &&\n-            self.hasarg     == (*other).hasarg     &&\n-            self.occur      == (*other).occur\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn eq(&self, other: &OptGroup) -> bool {\n             (*self).short_name == (*other).short_name &&\n             (*self).long_name  == (*other).long_name  &&\n@@ -680,11 +546,9 @@ pub mod groups {\n             (*self).hasarg     == (*other).hasarg     &&\n             (*self).occur      == (*other).occur\n         }\n-        #[cfg(stage0)]\n-        pure fn ne(other: &OptGroup) -> bool { !self.eq(other) }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n-        pure fn ne(&self, other: &OptGroup) -> bool { !(*self).eq(other) }\n+        pure fn ne(&self, other: &OptGroup) -> bool {\n+            !self.eq(other)\n+        }\n     }\n \n     /// Create a long option that is required and takes an argument"}, {"sha": "8551072d4616f0739f232e8f4835c2a777853316", "filename": "src/libstd/json.rs", "status": "modified", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -905,44 +905,6 @@ pub impl Deserializer: serialization::Deserializer {\n }\n \n impl Json : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Json) -> bool {\n-        // XXX: This is ugly because matching on references is broken, and\n-        // we can't match on dereferenced tuples without a copy.\n-        match self {\n-            Number(f0) =>\n-                match *other { Number(f1) => f0 == f1, _ => false },\n-            String(ref s0) =>\n-                match *other { String(ref s1) => s0 == s1, _ => false },\n-            Boolean(b0) =>\n-                match *other { Boolean(b1) => b0 == b1, _ => false },\n-            Null =>\n-                match *other { Null => true, _ => false },\n-            List(v0) =>\n-                match *other { List(v1) => v0 == v1, _ => false },\n-            Object(ref d0) => {\n-                match *other {\n-                    Object(ref d1) => {\n-                        if d0.len() == d1.len() {\n-                            let mut equal = true;\n-                            for d0.each |k, v0| {\n-                                match d1.find_ref(k) {\n-                                    Some(v1) if v0 == v1 => { },\n-                                    _ => { equal = false; break }\n-                                }\n-                            };\n-                            equal\n-                        } else {\n-                            false\n-                        }\n-                    }\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Json) -> bool {\n         // XXX: This is ugly because matching on references is broken, and\n         // we can't match on dereferenced tuples without a copy.\n@@ -978,88 +940,11 @@ impl Json : Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Json) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Json) -> bool { !(*self).eq(other) }\n }\n \n /// Test if two json values are less than one another\n impl Json : Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: &Json) -> bool {\n-        match self {\n-            Number(f0) => {\n-                match *other {\n-                    Number(f1) => f0 < f1,\n-                    String(_) | Boolean(_) | List(_) | Object(_) |\n-                    Null => true\n-                }\n-            }\n-\n-            String(ref s0) => {\n-                match *other {\n-                    Number(_) => false,\n-                    String(ref s1) => s0 < s1,\n-                    Boolean(_) | List(_) | Object(_) | Null => true\n-                }\n-            }\n-\n-            Boolean(b0) => {\n-                match *other {\n-                    Number(_) | String(_) => false,\n-                    Boolean(b1) => b0 < b1,\n-                    List(_) | Object(_) | Null => true\n-                }\n-            }\n-\n-            List(l0) => {\n-                match *other {\n-                    Number(_) | String(_) | Boolean(_) => false,\n-                    List(l1) => l0 < l1,\n-                    Object(_) | Null => true\n-                }\n-            }\n-\n-            Object(ref d0) => {\n-                match *other {\n-                    Number(_) | String(_) | Boolean(_) | List(_) => false,\n-                    Object(ref d1) => {\n-                        unsafe {\n-                            let mut d0_flat = ~[];\n-                            let mut d1_flat = ~[];\n-\n-                            // XXX: this is horribly inefficient...\n-                            for d0.each |k, v| {\n-                                 d0_flat.push((@copy *k, @copy *v));\n-                            }\n-                            d0_flat.qsort();\n-\n-                            for d1.each |k, v| {\n-                                d1_flat.push((@copy *k, @copy *v));\n-                            }\n-                            d1_flat.qsort();\n-\n-                            d0_flat < d1_flat\n-                        }\n-                    }\n-                    Null => true\n-                }\n-            }\n-\n-            Null => {\n-                match *other {\n-                    Number(_) | String(_) | Boolean(_) | List(_) |\n-                    Object(_) =>\n-                        false,\n-                    Null => true\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &Json) -> bool {\n         match (*self) {\n             Number(f0) => {\n@@ -1130,41 +1015,17 @@ impl Json : Ord {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn le(other: &Json) -> bool { !(*other).lt(&self) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &Json) -> bool { !(*other).lt(&(*self)) }\n-    #[cfg(stage0)]\n-    pure fn ge(other: &Json) -> bool { !self.lt(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &Json) -> bool { !(*self).lt(other) }\n-    #[cfg(stage0)]\n-    pure fn gt(other: &Json) -> bool { (*other).lt(&self)  }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &Json) -> bool { (*other).lt(&(*self))  }\n }\n \n impl Error : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Error) -> bool {\n-        self.line == other.line &&\n-        self.col == other.col &&\n-        self.msg == other.msg\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Error) -> bool {\n         (*self).line == other.line &&\n         (*self).col == other.col &&\n         (*self).msg == other.msg\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Error) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Error) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "ccff91634b8e11b8e8f99963ba40945b650ef784", "filename": "src/libstd/list.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -148,25 +148,6 @@ pub fn each<T>(l: @List<T>, f: fn(&T) -> bool) {\n }\n \n impl<T:Eq> List<T> : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &List<T>) -> bool {\n-        match self {\n-            Cons(ref e0a, e1a) => {\n-                match (*other) {\n-                    Cons(ref e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            Nil => {\n-                match (*other) {\n-                    Nil => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &List<T>) -> bool {\n         match (*self) {\n             Cons(ref e0a, e1a) => {\n@@ -183,10 +164,6 @@ impl<T:Eq> List<T> : Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &List<T>) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &List<T>) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "500d37604bc0fa9af54db40893b2d1359fa24fd5", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -315,19 +315,9 @@ pure fn userinfo_to_str(userinfo: UserInfo) -> ~str {\n }\n \n impl UserInfo : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &UserInfo) -> bool {\n-        self.user == (*other).user && self.pass == (*other).pass\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &UserInfo) -> bool {\n         (*self).user == (*other).user && (*self).pass == (*other).pass\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &UserInfo) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &UserInfo) -> bool { !(*self).eq(other) }\n }\n \n@@ -389,19 +379,6 @@ enum Input {\n }\n \n impl Input : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Input) -> bool {\n-        match (self, (*other)) {\n-            (Digit, Digit) => true,\n-            (Hex, Hex) => true,\n-            (Unreserved, Unreserved) => true,\n-            (Digit, _) => false,\n-            (Hex, _) => false,\n-            (Unreserved, _) => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Input) -> bool {\n         match ((*self), (*other)) {\n             (Digit, Digit) => true,\n@@ -412,10 +389,6 @@ impl Input : Eq {\n             (Unreserved, _) => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Input) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Input) -> bool { !(*self).eq(other) }\n }\n \n@@ -749,18 +722,6 @@ impl Url: to_str::ToStr {\n }\n \n impl Url : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Url) -> bool {\n-        self.scheme == (*other).scheme\n-            && self.user == (*other).user\n-            && self.host == (*other).host\n-            && self.port == (*other).port\n-            && self.path == (*other).path\n-            && self.query == (*other).query\n-            && self.fragment == (*other).fragment\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Url) -> bool {\n         (*self).scheme == (*other).scheme\n             && (*self).user == (*other).user\n@@ -771,12 +732,6 @@ impl Url : Eq {\n             && (*self).fragment == (*other).fragment\n     }\n \n-    #[cfg(stage0)]\n-    pure fn ne(other: &Url) -> bool {\n-        !self.eq(other)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Url) -> bool {\n         !(*self).eq(other)\n     }"}, {"sha": "c6e8c72e6d64990409b5a9004acfc7174633003b", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -871,37 +871,15 @@ mod test_tim_sort {\n     }\n \n     impl CVal: Ord {\n-        #[cfg(stage0)]\n-        pure fn lt(other: &CVal) -> bool {\n-            unsafe {\n-                let rng = rand::Rng();\n-                if rng.gen_float() > 0.995 { fail ~\"It's happening!!!\"; }\n-            }\n-            self.val < other.val\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn lt(&self, other: &CVal) -> bool {\n             unsafe {\n                 let rng = rand::Rng();\n                 if rng.gen_float() > 0.995 { fail ~\"It's happening!!!\"; }\n             }\n             (*self).val < other.val\n         }\n-        #[cfg(stage0)]\n-        pure fn le(other: &CVal) -> bool { self.val <= other.val }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn le(&self, other: &CVal) -> bool { (*self).val <= other.val }\n-        #[cfg(stage0)]\n-        pure fn gt(other: &CVal) -> bool { self.val > other.val }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn gt(&self, other: &CVal) -> bool { (*self).val > other.val }\n-        #[cfg(stage0)]\n-        pure fn ge(other: &CVal) -> bool { self.val >= other.val }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn ge(&self, other: &CVal) -> bool { (*self).val >= other.val }\n     }\n \n@@ -957,16 +935,6 @@ mod test_tim_sort {\n \n     struct DVal { val: uint }\n \n-    #[cfg(stage0)]\n-    impl DVal: Ord {\n-        pure fn lt(_x: &DVal) -> bool { true }\n-        pure fn le(_x: &DVal) -> bool { true }\n-        pure fn gt(_x: &DVal) -> bool { true }\n-        pure fn ge(_x: &DVal) -> bool { true }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     impl DVal: Ord {\n         pure fn lt(&self, _x: &DVal) -> bool { true }\n         pure fn le(&self, _x: &DVal) -> bool { true }\n@@ -1183,39 +1151,15 @@ mod big_tests {\n     }\n \n     impl LVal: Ord {\n-        #[cfg(stage0)]\n-        pure fn lt(other: &a/LVal/&self) -> bool {\n-            self.val < other.val\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn lt(&self, other: &a/LVal/&self) -> bool {\n             (*self).val < other.val\n         }\n-        #[cfg(stage0)]\n-        pure fn le(other: &a/LVal/&self) -> bool {\n-            self.val <= other.val\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn le(&self, other: &a/LVal/&self) -> bool {\n             (*self).val <= other.val\n         }\n-        #[cfg(stage0)]\n-        pure fn gt(other: &a/LVal/&self) -> bool {\n-            self.val > other.val\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn gt(&self, other: &a/LVal/&self) -> bool {\n             (*self).val > other.val\n         }\n-        #[cfg(stage0)]\n-        pure fn ge(other: &a/LVal/&self) -> bool {\n-            self.val >= other.val\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn ge(&self, other: &a/LVal/&self) -> bool {\n             (*self).val >= other.val\n         }"}, {"sha": "b4d15e1507a91160b0bb38bdca2b7edec28633f4", "filename": "src/libstd/test.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -85,19 +85,9 @@ fn parse_opts(args: &[~str]) -> OptRes {\n pub enum TestResult { TrOk, TrFailed, TrIgnored, }\n \n impl TestResult : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &TestResult) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &TestResult) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &TestResult) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &TestResult) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "7596f4282b7a8402528881037a6730203d73c41d", "filename": "src/libstd/time.rs", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -24,19 +24,9 @@ extern mod rustrt {\n pub type Timespec = {sec: i64, nsec: i32};\n \n impl Timespec : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Timespec) -> bool {\n-        self.sec == (*other).sec && self.nsec == (*other).nsec\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Timespec) -> bool {\n         (*self).sec == (*other).sec && (*self).nsec == (*other).nsec\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Timespec) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Timespec) -> bool { !(*self).eq(other) }\n }\n \n@@ -91,23 +81,6 @@ type Tm_ = {\n };\n \n impl Tm_ : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Tm_) -> bool {\n-        self.tm_sec == (*other).tm_sec &&\n-        self.tm_min == (*other).tm_min &&\n-        self.tm_hour == (*other).tm_hour &&\n-        self.tm_mday == (*other).tm_mday &&\n-        self.tm_mon == (*other).tm_mon &&\n-        self.tm_year == (*other).tm_year &&\n-        self.tm_wday == (*other).tm_wday &&\n-        self.tm_yday == (*other).tm_yday &&\n-        self.tm_isdst == (*other).tm_isdst &&\n-        self.tm_gmtoff == (*other).tm_gmtoff &&\n-        self.tm_zone == (*other).tm_zone &&\n-        self.tm_nsec == (*other).tm_nsec\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Tm_) -> bool {\n         (*self).tm_sec == (*other).tm_sec &&\n         (*self).tm_min == (*other).tm_min &&\n@@ -122,10 +95,6 @@ impl Tm_ : Eq {\n         (*self).tm_zone == (*other).tm_zone &&\n         (*self).tm_nsec == (*other).tm_nsec\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Tm_) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Tm_) -> bool { !(*self).eq(other) }\n }\n \n@@ -134,15 +103,7 @@ pub enum Tm {\n }\n \n impl Tm : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Tm) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Tm) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Tm) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Tm) -> bool { *(*self) != *(*other) }\n }\n "}, {"sha": "1adcadf1b6a2f0af53aefd52e928fb1e2eae506c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 656, "changes": 657, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -50,15 +50,7 @@ impl<D: Deserializer> ident: Deserializable<D> {\n }\n \n impl ident: cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ident) -> bool { self.repr == other.repr }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ident) -> bool { (*self).repr == other.repr }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ident) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ident) -> bool { !(*self).eq(other) }\n }\n \n@@ -97,19 +89,9 @@ type node_id = int;\n type def_id = {crate: crate_num, node: node_id};\n \n impl def_id : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &def_id) -> bool {\n-        self.crate == (*other).crate && self.node == (*other).node\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &def_id) -> bool {\n         (*self).crate == (*other).crate && (*self).node == (*other).node\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &def_id) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &def_id) -> bool { !(*self).eq(other) }\n }\n \n@@ -158,129 +140,6 @@ enum def {\n }\n \n impl def : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &def) -> bool {\n-        match self {\n-            def_fn(e0a, e1a) => {\n-                match (*other) {\n-                    def_fn(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_static_method(e0a, e1a, e2a) => {\n-                match (*other) {\n-                    def_static_method(e0b, e1b, e2b) =>\n-                    e0a == e0b && e1a == e1b && e2a == e2b,\n-                    _ => false\n-                }\n-            }\n-            def_self(e0a) => {\n-                match (*other) {\n-                    def_self(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_mod(e0a) => {\n-                match (*other) {\n-                    def_mod(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_foreign_mod(e0a) => {\n-                match (*other) {\n-                    def_foreign_mod(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_const(e0a) => {\n-                match (*other) {\n-                    def_const(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_arg(e0a, e1a) => {\n-                match (*other) {\n-                    def_arg(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_local(e0a, e1a) => {\n-                match (*other) {\n-                    def_local(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_variant(e0a, e1a) => {\n-                match (*other) {\n-                    def_variant(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_ty(e0a) => {\n-                match (*other) {\n-                    def_ty(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_prim_ty(e0a) => {\n-                match (*other) {\n-                    def_prim_ty(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_ty_param(e0a, e1a) => {\n-                match (*other) {\n-                    def_ty_param(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_binding(e0a, e1a) => {\n-                match (*other) {\n-                    def_binding(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_use(e0a) => {\n-                match (*other) {\n-                    def_use(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_upvar(e0a, e1a, e2a, e3a) => {\n-                match (*other) {\n-                    def_upvar(e0b, e1b, e2b, e3b) =>\n-                        e0a == e0b && e1a == e1b && e2a == e2b && e3a == e3b,\n-                    _ => false\n-                }\n-            }\n-            def_class(e0a) => {\n-                match (*other) {\n-                    def_class(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_typaram_binder(e0a) => {\n-                match (*other) {\n-                    def_typaram_binder(e1a) => e0a == e1a,\n-                    _ => false\n-                }\n-            }\n-            def_region(e0a) => {\n-                match (*other) {\n-                    def_region(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_label(e0a) => {\n-                match (*other) {\n-                    def_label(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &def) -> bool {\n         match (*self) {\n             def_fn(e0a, e1a) => {\n@@ -401,10 +260,6 @@ impl def : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &def) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &def) -> bool { !(*self).eq(other) }\n }\n \n@@ -415,25 +270,10 @@ type crate_cfg = ~[@meta_item];\n type crate = spanned<crate_>;\n \n type crate_ =\n-    {directives: ~[@crate_directive],\n-     module: _mod,\n+    {module: _mod,\n      attrs: ~[attribute],\n      config: crate_cfg};\n \n-enum crate_directive_ {\n-    cdir_src_mod(visibility, ident, ~[attribute]),\n-    cdir_dir_mod(visibility, ident, ~[@crate_directive], ~[attribute]),\n-\n-    // NB: cdir_view_item is *not* processed by the rest of the compiler, the\n-    // attached view_items are sunk into the crate's module during parsing,\n-    // and processed (resolved, imported, etc.) there. This enum-variant\n-    // exists only to preserve the view items in order in case we decide to\n-    // pretty-print crates in the future.\n-    cdir_view_item(@view_item),\n-}\n-\n-type crate_directive = spanned<crate_directive_>;\n-\n type meta_item = spanned<meta_item_>;\n \n #[auto_serialize]\n@@ -507,37 +347,6 @@ impl binding_mode : to_bytes::IterBytes {\n }\n \n impl binding_mode : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &binding_mode) -> bool {\n-        match self {\n-            bind_by_value => {\n-                match (*other) {\n-                    bind_by_value => true,\n-                    _ => false\n-                }\n-            }\n-            bind_by_move => {\n-                match (*other) {\n-                    bind_by_move => true,\n-                    _ => false\n-                }\n-            }\n-            bind_by_ref(e0a) => {\n-                match (*other) {\n-                    bind_by_ref(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            bind_by_implicit_ref => {\n-                match (*other) {\n-                    bind_by_implicit_ref => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &binding_mode) -> bool {\n         match (*self) {\n             bind_by_value => {\n@@ -566,10 +375,6 @@ impl binding_mode : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &binding_mode) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &binding_mode) -> bool { !(*self).eq(other) }\n }\n \n@@ -617,19 +422,9 @@ impl mutability : to_bytes::IterBytes {\n }\n \n impl mutability : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &mutability) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &mutability) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &mutability) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &mutability) -> bool { !(*self).eq(other) }\n }\n \n@@ -643,19 +438,9 @@ pub enum Proto {\n }\n \n impl Proto : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Proto) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Proto) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Proto) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Proto) -> bool { !(*self).eq(other) }\n }\n \n@@ -726,19 +511,9 @@ enum binop {\n }\n \n impl binop : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &binop) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &binop) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &binop) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &binop) -> bool { !(*self).eq(other) }\n }\n \n@@ -753,43 +528,6 @@ enum unop {\n }\n \n impl unop : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &unop) -> bool {\n-        match self {\n-            box(e0a) => {\n-                match (*other) {\n-                    box(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            uniq(e0a) => {\n-                match (*other) {\n-                    uniq(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            deref => {\n-                match (*other) {\n-                    deref => true,\n-                    _ => false\n-                }\n-            }\n-            not => {\n-                match (*other) {\n-                    not => true,\n-                    _ => false\n-                }\n-            }\n-            neg => {\n-                match (*other) {\n-                    neg => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &unop) -> bool {\n         match (*self) {\n             box(e0a) => {\n@@ -824,12 +562,6 @@ impl unop : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &unop) -> bool {\n-        !self.eq(other)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &unop) -> bool {\n         !(*self).eq(other)\n     }\n@@ -872,25 +604,6 @@ impl<T: to_bytes::IterBytes> inferable<T> : to_bytes::IterBytes {\n }\n \n impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &inferable<T>) -> bool {\n-        match self {\n-            expl(e0a) => {\n-                match (*other) {\n-                    expl(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            infer(e0a) => {\n-                match (*other) {\n-                    infer(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &inferable<T>) -> bool {\n         match (*self) {\n             expl(e0a) => {\n@@ -907,10 +620,6 @@ impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &inferable<T>) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &inferable<T>) -> bool { !(*self).eq(other) }\n }\n \n@@ -935,19 +644,9 @@ impl rmode : to_bytes::IterBytes {\n \n \n impl rmode : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &rmode) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &rmode) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &rmode) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &rmode) -> bool { !(*self).eq(other) }\n }\n \n@@ -998,17 +697,6 @@ type field = spanned<field_>;\n enum blk_check_mode { default_blk, unsafe_blk, }\n \n impl blk_check_mode : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &blk_check_mode) -> bool {\n-        match (self, (*other)) {\n-            (default_blk, default_blk) => true,\n-            (unsafe_blk, unsafe_blk) => true,\n-            (default_blk, _) => false,\n-            (unsafe_blk, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &blk_check_mode) -> bool {\n         match ((*self), (*other)) {\n             (default_blk, default_blk) => true,\n@@ -1017,10 +705,6 @@ impl blk_check_mode : cmp::Eq {\n             (unsafe_blk, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &blk_check_mode) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &blk_check_mode) -> bool { !(*self).eq(other) }\n }\n \n@@ -1237,35 +921,6 @@ enum lit_ {\n }\n \n impl ast::lit_: cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ast::lit_) -> bool {\n-        match (self, *other) {\n-            (lit_str(a), lit_str(b)) => a == b,\n-            (lit_int(val_a, ty_a), lit_int(val_b, ty_b)) => {\n-                val_a == val_b && ty_a == ty_b\n-            }\n-            (lit_uint(val_a, ty_a), lit_uint(val_b, ty_b)) => {\n-                val_a == val_b && ty_a == ty_b\n-            }\n-            (lit_int_unsuffixed(a), lit_int_unsuffixed(b)) => a == b,\n-            (lit_float(val_a, ty_a), lit_float(val_b, ty_b)) => {\n-                val_a == val_b && ty_a == ty_b\n-            }\n-            (lit_float_unsuffixed(a), lit_float_unsuffixed(b)) => a == b,\n-            (lit_nil, lit_nil) => true,\n-            (lit_bool(a), lit_bool(b)) => a == b,\n-            (lit_str(_), _) => false,\n-            (lit_int(*), _) => false,\n-            (lit_uint(*), _) => false,\n-            (lit_int_unsuffixed(*), _) => false,\n-            (lit_float(*), _) => false,\n-            (lit_float_unsuffixed(*), _) => false,\n-            (lit_nil, _) => false,\n-            (lit_bool(_), _) => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ast::lit_) -> bool {\n         match ((*self), *other) {\n             (lit_str(a), lit_str(b)) => a == b,\n@@ -1292,10 +947,6 @@ impl ast::lit_: cmp::Eq {\n             (lit_bool(_), _) => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ast::lit_) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ast::lit_) -> bool { !(*self).eq(other) }\n }\n \n@@ -1346,25 +997,6 @@ impl int_ty : to_bytes::IterBytes {\n }\n \n impl int_ty : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &int_ty) -> bool {\n-        match (self, (*other)) {\n-            (ty_i, ty_i) => true,\n-            (ty_char, ty_char) => true,\n-            (ty_i8, ty_i8) => true,\n-            (ty_i16, ty_i16) => true,\n-            (ty_i32, ty_i32) => true,\n-            (ty_i64, ty_i64) => true,\n-            (ty_i, _) => false,\n-            (ty_char, _) => false,\n-            (ty_i8, _) => false,\n-            (ty_i16, _) => false,\n-            (ty_i32, _) => false,\n-            (ty_i64, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &int_ty) -> bool {\n         match ((*self), (*other)) {\n             (ty_i, ty_i) => true,\n@@ -1381,10 +1013,6 @@ impl int_ty : cmp::Eq {\n             (ty_i64, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &int_ty) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &int_ty) -> bool { !(*self).eq(other) }\n }\n \n@@ -1407,23 +1035,6 @@ impl uint_ty : to_bytes::IterBytes {\n }\n \n impl uint_ty : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &uint_ty) -> bool {\n-        match (self, (*other)) {\n-            (ty_u, ty_u) => true,\n-            (ty_u8, ty_u8) => true,\n-            (ty_u16, ty_u16) => true,\n-            (ty_u32, ty_u32) => true,\n-            (ty_u64, ty_u64) => true,\n-            (ty_u, _) => false,\n-            (ty_u8, _) => false,\n-            (ty_u16, _) => false,\n-            (ty_u32, _) => false,\n-            (ty_u64, _) => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &uint_ty) -> bool {\n         match ((*self), (*other)) {\n             (ty_u, ty_u) => true,\n@@ -1438,10 +1049,6 @@ impl uint_ty : cmp::Eq {\n             (ty_u64, _) => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &uint_ty) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &uint_ty) -> bool { !(*self).eq(other) }\n }\n \n@@ -1464,25 +1071,12 @@ impl float_ty : to_bytes::IterBytes {\n }\n \n impl float_ty : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &float_ty) -> bool {\n-        match (self, (*other)) {\n-            (ty_f, ty_f) | (ty_f32, ty_f32) | (ty_f64, ty_f64) => true,\n-            (ty_f, _) | (ty_f32, _) | (ty_f64, _) => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &float_ty) -> bool {\n         match ((*self), (*other)) {\n             (ty_f, ty_f) | (ty_f32, ty_f32) | (ty_f64, ty_f64) => true,\n             (ty_f, _) | (ty_f32, _) | (ty_f64, _) => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &float_ty) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &float_ty) -> bool { !(*self).eq(other) }\n }\n \n@@ -1502,43 +1096,6 @@ enum prim_ty {\n }\n \n impl prim_ty : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &prim_ty) -> bool {\n-        match self {\n-            ty_int(e0a) => {\n-                match (*other) {\n-                    ty_int(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_uint(e0a) => {\n-                match (*other) {\n-                    ty_uint(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_float(e0a) => {\n-                match (*other) {\n-                    ty_float(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_str => {\n-                match (*other) {\n-                    ty_str => true,\n-                    _ => false\n-                }\n-            }\n-            ty_bool => {\n-                match (*other) {\n-                    ty_bool => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &prim_ty) -> bool {\n         match (*self) {\n             ty_int(e0a) => {\n@@ -1573,10 +1130,6 @@ impl prim_ty : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &prim_ty) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &prim_ty) -> bool { !(*self).eq(other) }\n }\n \n@@ -1601,27 +1154,12 @@ enum Onceness {\n }\n \n impl Onceness : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Onceness) -> bool {\n-        match (self, *other) {\n-            (Once, Once) | (Many, Many) => true,\n-            _ => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Onceness) -> bool {\n         match ((*self), *other) {\n             (Once, Once) | (Many, Many) => true,\n             _ => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Onceness) -> bool {\n-        !self.eq(other)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Onceness) -> bool {\n         !(*self).eq(other)\n     }\n@@ -1663,21 +1201,9 @@ enum ty_ {\n // Equality and byte-iter (hashing) can be quite approximate for AST types.\n // since we only care about this for normalizing them to \"real\" types.\n impl Ty : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Ty) -> bool {\n-        ptr::addr_of(&self) == ptr::addr_of(&(*other))\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Ty) -> bool {\n         ptr::addr_of(&(*self)) == ptr::addr_of(&(*other))\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Ty) -> bool {\n-        ptr::addr_of(&self) != ptr::addr_of(&(*other))\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Ty) -> bool {\n         ptr::addr_of(&(*self)) != ptr::addr_of(&(*other))\n     }\n@@ -1735,19 +1261,9 @@ impl purity : to_bytes::IterBytes {\n }\n \n impl purity : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &purity) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &purity) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &purity) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &purity) -> bool { !(*self).eq(other) }\n }\n \n@@ -1774,17 +1290,6 @@ impl ret_style : to_bytes::IterBytes {\n }\n \n impl ret_style : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ret_style) -> bool {\n-        match (self, (*other)) {\n-            (noreturn, noreturn) => true,\n-            (return_val, return_val) => true,\n-            (noreturn, _) => false,\n-            (return_val, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ret_style) -> bool {\n         match ((*self), (*other)) {\n             (noreturn, noreturn) => true,\n@@ -1793,10 +1298,6 @@ impl ret_style : cmp::Eq {\n             (return_val, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ret_style) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ret_style) -> bool { !(*self).eq(other) }\n }\n \n@@ -1812,49 +1313,6 @@ enum self_ty_ {\n }\n \n impl self_ty_ : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &self_ty_) -> bool {\n-        match self {\n-            sty_static => {\n-                match (*other) {\n-                    sty_static => true,\n-                    _ => false\n-                }\n-            }\n-            sty_by_ref => {\n-                match (*other) {\n-                    sty_by_ref => true,\n-                    _ => false\n-                }\n-            }\n-            sty_value => {\n-                match (*other) {\n-                    sty_value => true,\n-                    _ => false\n-                }\n-            }\n-            sty_region(e0a) => {\n-                match (*other) {\n-                    sty_region(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            sty_box(e0a) => {\n-                match (*other) {\n-                    sty_box(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            sty_uniq(e0a) => {\n-                match (*other) {\n-                    sty_uniq(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &self_ty_) -> bool {\n         match (*self) {\n             sty_static => {\n@@ -1895,10 +1353,6 @@ impl self_ty_ : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &self_ty_) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &self_ty_) -> bool { !(*self).eq(other) }\n }\n \n@@ -1930,36 +1384,13 @@ enum foreign_abi {\n enum foreign_mod_sort { named, anonymous }\n \n impl foreign_mod_sort : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &foreign_mod_sort) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &foreign_mod_sort) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &foreign_mod_sort) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &foreign_mod_sort) -> bool { !(*self).eq(other) }\n }\n \n impl foreign_abi : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &foreign_abi) -> bool {\n-        match (self, (*other)) {\n-            (foreign_abi_rust_intrinsic, foreign_abi_rust_intrinsic) => true,\n-            (foreign_abi_cdecl, foreign_abi_cdecl) => true,\n-            (foreign_abi_stdcall, foreign_abi_stdcall) => true,\n-            (foreign_abi_rust_intrinsic, _) => false,\n-            (foreign_abi_cdecl, _) => false,\n-            (foreign_abi_stdcall, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &foreign_abi) -> bool {\n         match ((*self), (*other)) {\n             (foreign_abi_rust_intrinsic, foreign_abi_rust_intrinsic) => true,\n@@ -1970,10 +1401,6 @@ impl foreign_abi : cmp::Eq {\n             (foreign_abi_stdcall, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &foreign_abi) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &foreign_abi) -> bool { !(*self).eq(other) }\n }\n \n@@ -2023,19 +1450,9 @@ type path_list_ident = spanned<path_list_ident_>;\n enum namespace { module_ns, type_value_ns }\n \n impl namespace : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &namespace) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &namespace) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &namespace) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &namespace) -> bool { !(*self).eq(other) }\n }\n \n@@ -2083,19 +1500,9 @@ type attribute = spanned<attribute_>;\n enum attr_style { attr_outer, attr_inner, }\n \n impl attr_style : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &attr_style) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &attr_style) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &attr_style) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &attr_style) -> bool { !(*self).eq(other) }\n }\n \n@@ -2122,19 +1529,6 @@ type trait_ref = {path: @path, ref_id: node_id, impl_id: node_id};\n enum visibility { public, private, inherited }\n \n impl visibility : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &visibility) -> bool {\n-        match (self, (*other)) {\n-            (public, public) => true,\n-            (private, private) => true,\n-            (inherited, inherited) => true,\n-            (public, _) => false,\n-            (private, _) => false,\n-            (inherited, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &visibility) -> bool {\n         match ((*self), (*other)) {\n             (public, public) => true,\n@@ -2145,10 +1539,6 @@ impl visibility : cmp::Eq {\n             (inherited, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &visibility) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &visibility) -> bool { !(*self).eq(other) }\n }\n \n@@ -2170,30 +1560,6 @@ enum struct_field_kind {\n }\n \n impl struct_field_kind : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &struct_field_kind) -> bool {\n-        match self {\n-            named_field(ident_a, class_mutability_a, visibility_a) => {\n-                match *other {\n-                    named_field(ident_b, class_mutability_b, visibility_b)\n-                            => {\n-                        ident_a == ident_b &&\n-                        class_mutability_a == class_mutability_b &&\n-                        visibility_a == visibility_b\n-                    }\n-                    unnamed_field => false\n-                }\n-            }\n-            unnamed_field => {\n-                match *other {\n-                    named_field(*) => false,\n-                    unnamed_field => true\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &struct_field_kind) -> bool {\n         match (*self) {\n             named_field(ident_a, class_mutability_a, visibility_a) => {\n@@ -2215,12 +1581,6 @@ impl struct_field_kind : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &struct_field_kind) -> bool {\n-        !self.eq(other)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &struct_field_kind) -> bool {\n         !(*self).eq(other)\n     }\n@@ -2287,17 +1647,6 @@ impl class_mutability : to_bytes::IterBytes {\n }\n \n impl class_mutability : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &class_mutability) -> bool {\n-        match (self, (*other)) {\n-            (class_mutable, class_mutable) => true,\n-            (class_immutable, class_immutable) => true,\n-            (class_mutable, _) => false,\n-            (class_immutable, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &class_mutability) -> bool {\n         match ((*self), (*other)) {\n             (class_mutable, class_mutable) => true,\n@@ -2306,10 +1655,6 @@ impl class_mutability : cmp::Eq {\n             (class_immutable, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &class_mutability) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &class_mutability) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "3251ea5d2e9360fd420d927c6f8c7e35995e177e", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -12,25 +12,6 @@ enum path_elt {\n }\n \n impl path_elt : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &path_elt) -> bool {\n-        match self {\n-            path_mod(e0a) => {\n-                match (*other) {\n-                    path_mod(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            path_name(e0a) => {\n-                match (*other) {\n-                    path_name(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &path_elt) -> bool {\n         match (*self) {\n             path_mod(e0a) => {\n@@ -47,10 +28,6 @@ impl path_elt : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &path_elt) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &path_elt) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "468704c9affba0dba7c1eae5407676d72d85821b", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -338,19 +338,9 @@ enum inline_attr {\n }\n \n impl inline_attr : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &inline_attr) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &inline_attr) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &inline_attr) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &inline_attr) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "8126f1d720074b65173a2b740a00d79a4c312fec", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -37,29 +37,11 @@ impl BytePos: Pos {\n     pure fn to_uint(&self) -> uint { **self }\n }\n \n-#[cfg(stage0)]\n-impl BytePos: cmp::Eq {\n-    pure fn eq(other: &BytePos) -> bool { *self == **other }\n-    pure fn ne(other: &BytePos) -> bool { !self.eq(other) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl BytePos: cmp::Eq {\n     pure fn eq(&self, other: &BytePos) -> bool { **self == **other }\n     pure fn ne(&self, other: &BytePos) -> bool { !(*self).eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl BytePos: cmp::Ord {\n-    pure fn lt(other: &BytePos) -> bool { *self < **other }\n-    pure fn le(other: &BytePos) -> bool { *self <= **other }\n-    pure fn ge(other: &BytePos) -> bool { *self >= **other }\n-    pure fn gt(other: &BytePos) -> bool { *self > **other }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl BytePos: cmp::Ord {\n     pure fn lt(&self, other: &BytePos) -> bool { **self < **other }\n     pure fn le(&self, other: &BytePos) -> bool { **self <= **other }\n@@ -110,29 +92,11 @@ impl CharPos: Pos {\n     pure fn to_uint(&self) -> uint { **self }\n }\n \n-#[cfg(stage0)]\n-impl CharPos: cmp::Eq {\n-    pure fn eq(other: &CharPos) -> bool { *self == **other }\n-    pure fn ne(other: &CharPos) -> bool { !self.eq(other) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl CharPos: cmp::Eq {\n     pure fn eq(&self, other: &CharPos) -> bool { **self == **other }\n     pure fn ne(&self, other: &CharPos) -> bool { !(*self).eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl CharPos: cmp::Ord {\n-    pure fn lt(other: &CharPos) -> bool { *self < **other }\n-    pure fn le(other: &CharPos) -> bool { *self <= **other }\n-    pure fn ge(other: &CharPos) -> bool { *self >= **other }\n-    pure fn gt(other: &CharPos) -> bool { *self > **other }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl CharPos: cmp::Ord {\n     pure fn lt(&self, other: &CharPos) -> bool { **self < **other }\n     pure fn le(&self, other: &CharPos) -> bool { **self <= **other }\n@@ -190,19 +154,9 @@ pub struct span {\n }\n \n impl span : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &span) -> bool {\n-        return self.lo == (*other).lo && self.hi == (*other).hi;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &span) -> bool {\n         return (*self).lo == (*other).lo && (*self).hi == (*other).hi;\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &span) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &span) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "8784b3837f17c19a2170c986d358f960142727a1", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -149,19 +149,9 @@ enum level {\n }\n \n impl level : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &level) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &level) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &level) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &level) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "638ccad0143fc91b881c723a30e6608e700ce458", "filename": "src/libsyntax/ext/pipes/mod.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,12 @@\n+#[legacy_exports]\n+mod ast_builder;\n+#[legacy_exports]\n+mod parse_proto;\n+#[legacy_exports]\n+mod pipec;\n+#[legacy_exports]\n+mod proto;\n+#[legacy_exports]\n+mod check;\n+#[legacy_exports]\n+mod liveness;"}, {"sha": "18caef0f72f6078123659421604801a5b98fdbc6", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -6,17 +6,6 @@ use ast_builder::{path, append_types};\n enum direction { send, recv }\n \n impl direction : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &direction) -> bool {\n-        match (self, (*other)) {\n-            (send, send) => true,\n-            (recv, recv) => true,\n-            (send, _) => false,\n-            (recv, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &direction) -> bool {\n         match ((*self), (*other)) {\n             (send, send) => true,\n@@ -25,10 +14,6 @@ impl direction : cmp::Eq {\n             (recv, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &direction) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &direction) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "1db37418370833bc1e700374ed5919af18fda3f6", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -21,7 +21,6 @@ export extensions;\n \n trait ast_fold {\n     fn fold_crate(crate) -> crate;\n-    fn fold_crate_directive(&&v: @crate_directive) -> @crate_directive;\n     fn fold_view_item(&&v: @view_item) -> @view_item;\n     fn fold_foreign_item(&&v: @foreign_item) -> @foreign_item;\n     fn fold_item(&&v: @item) -> Option<@item>;\n@@ -51,8 +50,6 @@ trait ast_fold {\n type ast_fold_precursor = @{\n     //unlike the others, item_ is non-trivial\n     fold_crate: fn@(crate_, span, ast_fold) -> (crate_, span),\n-    fold_crate_directive: fn@(crate_directive_, span,\n-                              ast_fold) -> (crate_directive_, span),\n     fold_view_item: fn@(view_item_, ast_fold) -> view_item_,\n     fold_foreign_item: fn@(&&v: @foreign_item, ast_fold) -> @foreign_item,\n     fold_item: fn@(&&v: @item, ast_fold) -> Option<@item>,\n@@ -150,29 +147,12 @@ fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n     return {\n-        directives: vec::map(c.directives, |x| fld.fold_crate_directive(*x)),\n         module: fld.fold_mod(c.module),\n         attrs: vec::map(c.attrs, |x| fold_attribute(*x)),\n         config: vec::map(c.config, |x| fold_meta_item(*x))\n     };\n }\n \n-fn noop_fold_crate_directive(cd: crate_directive_, fld: ast_fold) ->\n-   crate_directive_ {\n-    return match cd {\n-          cdir_src_mod(vis, id, attrs) => {\n-            cdir_src_mod(vis, fld.fold_ident(id),\n-                         /* FIXME (#2543) */ copy attrs)\n-          }\n-          cdir_dir_mod(vis, id, cds, attrs) => {\n-            cdir_dir_mod(vis, fld.fold_ident(id),\n-                         vec::map(cds, |x| fld.fold_crate_directive(*x)),\n-                         /* FIXME (#2543) */ copy attrs)\n-          }\n-          cdir_view_item(vi) => cdir_view_item(fld.fold_view_item(vi)),\n-        }\n-}\n-\n fn noop_fold_view_item(vi: view_item_, _fld: ast_fold) -> view_item_ {\n     return /* FIXME (#2543) */ copy vi;\n }\n@@ -636,7 +616,6 @@ fn noop_span(sp: span) -> span { return sp; }\n \n fn default_ast_fold() -> ast_fold_precursor {\n     return @{fold_crate: wrap(noop_fold_crate),\n-          fold_crate_directive: wrap(noop_fold_crate_directive),\n           fold_view_item: noop_fold_view_item,\n           fold_foreign_item: noop_fold_foreign_item,\n           fold_item: noop_fold_item,\n@@ -667,12 +646,6 @@ impl ast_fold_precursor: ast_fold {\n         let (n, s) = self.fold_crate(c.node, c.span, self as ast_fold);\n         return {node: n, span: self.new_span(s)};\n     }\n-    fn fold_crate_directive(&&c: @crate_directive) -> @crate_directive {\n-        let (n, s) = self.fold_crate_directive(c.node, c.span,\n-                                               self as ast_fold);\n-        return @{node: n,\n-              span: self.new_span(s)};\n-    }\n     fn fold_view_item(&&x: @view_item) ->\n        @view_item {\n         return @{node: self.fold_view_item(x.node, self as ast_fold),"}, {"sha": "ccca4139c9b2ebf577664be1c4cb48bf92ede6eb", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 23, "deletions": 34, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -1,5 +1,16 @@\n //! The main parser interface\n \n+#[legacy_exports];\n+\n+export parser;\n+export common;\n+export lexer;\n+export token;\n+export comments;\n+export prec;\n+export classify;\n+export attr;\n+\n export parse_sess;\n export new_parse_sess, new_parse_sess_special_handler;\n export next_node_id;\n@@ -51,40 +62,6 @@ fn new_parse_sess_special_handler(sh: span_handler, cm: @codemap::CodeMap)\n \n fn parse_crate_from_file(input: &Path, cfg: ast::crate_cfg,\n                          sess: parse_sess) -> @ast::crate {\n-    if input.filetype() == Some(~\".rc\") {\n-        parse_crate_from_crate_file(input, cfg, sess)\n-    } else if input.filetype() == Some(~\".rs\") {\n-        parse_crate_from_source_file(input, cfg, sess)\n-    } else {\n-        sess.span_diagnostic.handler().fatal(~\"unknown input file type: \" +\n-                                             input.to_str())\n-    }\n-}\n-\n-fn parse_crate_from_crate_file(input: &Path, cfg: ast::crate_cfg,\n-                               sess: parse_sess) -> @ast::crate {\n-    let p = new_crate_parser_from_file(sess, cfg, input);\n-    let lo = p.span.lo;\n-    let prefix = input.dir_path();\n-    let leading_attrs = p.parse_inner_attrs_and_next();\n-    let { inner: crate_attrs, next: first_cdir_attr } = leading_attrs;\n-    let cdirs = p.parse_crate_directives(token::EOF, first_cdir_attr);\n-    let cx = @{sess: sess, cfg: /* FIXME (#2543) */ copy p.cfg};\n-    let companionmod = input.filestem().map(|s| Path(*s));\n-    let (m, attrs) = eval::eval_crate_directives_to_mod(\n-        cx, cdirs, &prefix, &companionmod);\n-    let mut hi = p.span.hi;\n-    p.expect(token::EOF);\n-    p.abort_if_errors();\n-    return @ast_util::respan(ast_util::mk_sp(lo, hi),\n-                          {directives: cdirs,\n-                           module: m,\n-                           attrs: vec::append(crate_attrs, attrs),\n-                           config: /* FIXME (#2543) */ copy p.cfg});\n-}\n-\n-fn parse_crate_from_source_file(input: &Path, cfg: ast::crate_cfg,\n-                                sess: parse_sess) -> @ast::crate {\n     let p = new_crate_parser_from_file(sess, cfg, input);\n     let r = p.parse_crate_mod(cfg);\n     return r;\n@@ -175,6 +152,18 @@ fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n                         path: &Path) -> Result<Parser, ~str> {\n     match io::read_whole_file_str(path) {\n       result::Ok(move src) => {\n+\n+          // HACK: If the file contains a special token use a different\n+          // source file. Used to send the stage1+ parser (the stage0 parser\n+          // doesn't have this hack) to a different crate file.\n+          // Transitional. Remove me.\n+          let src = if src.starts_with(\"// DIVERT\") {\n+              let actual_path = &path.with_filestem(\"alternate_crate\");\n+              result::unwrap(io::read_whole_file_str(actual_path))\n+          } else {\n+              move src\n+          };\n+\n           let filemap = sess.cm.new_filemap(path.to_str(), @move src);\n           let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap,\n                                               sess.interner);"}, {"sha": "4f7bfb0d4e9f1d26dba864549ffbc7ea1f7a0532", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -20,21 +20,9 @@ enum cmnt_style {\n }\n \n impl cmnt_style : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &cmnt_style) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &cmnt_style) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &cmnt_style) -> bool {\n-        (self as uint) != ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &cmnt_style) -> bool {\n         ((*self) as uint) != ((*other) as uint)\n     }"}, {"sha": "cdfd8a9bceccde7699c27568fd8a35f1b670c489", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -5,6 +5,7 @@ use codemap::span;\n \n export eval_crate_directives_to_mod;\n export eval_src_mod;\n+export eval_src_mod_from_path;\n \n type ctx =\n     @{sess: parse::parse_sess,\n@@ -84,15 +85,23 @@ fn cdir_path_opt(default: ~str, attrs: ~[ast::attribute]) -> ~str {\n     }\n }\n \n-fn eval_src_mod(cx: ctx, prefix: &Path, id: ast::ident,\n+fn eval_src_mod(cx: ctx, prefix: &Path,\n                 outer_attrs: ~[ast::attribute],\n-                sp: span) -> (ast::item_, ~[ast::attribute]) {\n+                id: ast::ident, sp: span\n+               ) -> (ast::item_, ~[ast::attribute]) {\n     let file_path = Path(cdir_path_opt(\n         cx.sess.interner.get(id) + ~\".rs\", outer_attrs));\n-    let full_path = if file_path.is_absolute {\n-        copy file_path\n+    eval_src_mod_from_path(cx, prefix, &file_path, outer_attrs, sp)\n+}\n+\n+fn eval_src_mod_from_path(cx: ctx, prefix: &Path, path: &Path,\n+                          outer_attrs: ~[ast::attribute],\n+                          sp: span\n+                         ) -> (ast::item_, ~[ast::attribute]) {\n+    let full_path = if path.is_absolute {\n+        copy *path\n     } else {\n-        prefix.push_many(file_path.components)\n+        prefix.push_many(path.components)\n     };\n     let p0 =\n         new_sub_parser_from_file(cx.sess, cx.cfg,\n@@ -121,7 +130,7 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: &Path,\n                         items: &mut ~[@ast::item]) {\n     match cdir.node {\n       ast::cdir_src_mod(vis, id, attrs) => {\n-        let (m, mod_attrs) = eval_src_mod(cx, prefix, id, attrs, cdir.span);\n+        let (m, mod_attrs) = eval_src_mod(cx, prefix, attrs, id, cdir.span);\n         let i = mk_item(cx, cdir.span.lo, cdir.span.hi,\n                            /* FIXME (#2543) */ copy id,\n                            m, vis, mod_attrs);"}, {"sha": "a7c5f20fedfe1a8b347c6c8499c941a9eae35a04", "filename": "src/libsyntax/parse/mod.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,28 @@\n+\n+#[legacy_exports]\n+mod lexer;\n+#[legacy_exports]\n+mod parser;\n+#[legacy_exports]\n+mod token;\n+#[legacy_exports]\n+mod comments;\n+#[legacy_exports]\n+mod attr;\n+#[legacy_exports]\n+\n+/// Common routines shared by parser mods\n+#[legacy_exports]\n+mod common;\n+\n+/// Functions dealing with operator precedence\n+#[legacy_exports]\n+mod prec;\n+\n+/// Routines the parser uses to classify AST nodes\n+#[legacy_exports]\n+mod classify;\n+\n+/// Reporting obsolete syntax\n+#[legacy_exports]\n+mod obsolete;"}, {"sha": "07ce7f4a268b5f27735211aaeaae182c3f460570", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -29,21 +29,9 @@ pub enum ObsoleteSyntax {\n }\n \n impl ObsoleteSyntax : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ObsoleteSyntax) -> bool {\n-        self as uint == (*other) as uint\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ObsoleteSyntax) -> bool {\n         (*self) as uint == (*other) as uint\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ObsoleteSyntax) -> bool {\n-        !self.eq(other)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ObsoleteSyntax) -> bool {\n         !(*self).eq(other)\n     }"}, {"sha": "d95f4fb3f75f86bcdafdbccc45aa9b4f1d51b38d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 82, "deletions": 96, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -27,9 +27,8 @@ use ast::{_mod, add, arg, arm, attribute,\n              bind_by_ref, bind_by_implicit_ref, bind_by_value, bind_by_move,\n              bitand, bitor, bitxor, blk, blk_check_mode, box, by_copy,\n              by_move, by_ref, by_val, capture_clause,\n-             capture_item, cdir_dir_mod, cdir_src_mod, cdir_view_item,\n-             class_immutable, class_mutable,\n-             crate, crate_cfg, crate_directive, decl, decl_item, decl_local,\n+             capture_item, class_immutable, class_mutable,\n+             crate, crate_cfg, decl, decl_item, decl_local,\n              default_blk, deref, div, enum_def, enum_variant_kind, expl, expr,\n              expr_, expr_addr_of, expr_match, expr_again, expr_assert,\n              expr_assign, expr_assign_op, expr_binary, expr_block, expr_break,\n@@ -2967,24 +2966,94 @@ impl Parser {\n     fn parse_item_mod(outer_attrs: ~[ast::attribute]) -> item_info {\n         let id_span = self.span;\n         let id = self.parse_ident();\n-        if self.token == token::SEMI {\n+        let info_ = if self.token == token::SEMI {\n             self.bump();\n             // This mod is in an external file. Let's go get it!\n-            let eval_ctx = @{\n-                sess: self.sess,\n-                cfg: self.cfg\n-            };\n-            let prefix = Path(self.sess.cm.span_to_filename(copy self.span));\n-            let prefix = prefix.dir_path();\n-            let (m, attrs) = eval::eval_src_mod(eval_ctx, &prefix, id,\n-                                                outer_attrs, id_span);\n+            let (m, attrs) = self.eval_src_mod(id, outer_attrs, id_span);\n             (id, m, Some(move attrs))\n         } else {\n             self.expect(token::LBRACE);\n             let inner_attrs = self.parse_inner_attrs_and_next();\n             let m = self.parse_mod_items(token::RBRACE, inner_attrs.next);\n             self.expect(token::RBRACE);\n             (id, item_mod(m), Some(inner_attrs.inner))\n+        };\n+\n+        // XXX: Transitionary hack to do the template work inside core\n+        // (int-template, iter-trait). If there's a 'merge' attribute\n+        // on the mod, then we'll go and suck in another file and merge\n+        // its contents\n+        match ::attr::first_attr_value_str_by_name(outer_attrs, ~\"merge\") {\n+            Some(path) => {\n+                let prefix = Path(\n+                    self.sess.cm.span_to_filename(copy self.span));\n+                let prefix = prefix.dir_path();\n+                let path = Path(path);\n+                let (new_mod_item, new_attrs) = self.eval_src_mod_from_path(\n+                    prefix, path, ~[], id_span);\n+\n+                let (main_id, main_mod_item, main_attrs) = info_;\n+                let main_attrs = main_attrs.get();\n+\n+                let (main_mod, new_mod) =\n+                    match (main_mod_item, new_mod_item) {\n+                    (item_mod(m), item_mod(n)) => (m, n),\n+                    _ => self.bug(~\"parsed mod item should be mod\")\n+                };\n+                let merged_mod = {\n+                    view_items: main_mod.view_items + new_mod.view_items,\n+                    items: main_mod.items + new_mod.items\n+                };\n+\n+                let merged_attrs = main_attrs + new_attrs;\n+                (main_id, item_mod(merged_mod), Some(merged_attrs))\n+            }\n+            None => info_\n+        }\n+    }\n+\n+    fn eval_src_mod(id: ast::ident,\n+                    outer_attrs: ~[ast::attribute],\n+                    id_sp: span) -> (ast::item_, ~[ast::attribute]) {\n+        let prefix = Path(self.sess.cm.span_to_filename(copy self.span));\n+        let prefix = prefix.dir_path();\n+        let default_path = self.sess.interner.get(id) + ~\".rs\";\n+        let file_path = match ::attr::first_attr_value_str_by_name(\n+            outer_attrs, ~\"path\") {\n+\n+            Some(d) => d,\n+            None => default_path\n+        };\n+\n+        let file_path = Path(file_path);\n+        self.eval_src_mod_from_path(prefix, file_path,\n+                                    outer_attrs, id_sp)\n+    }\n+\n+    fn eval_src_mod_from_path(prefix: Path, path: Path,\n+                              outer_attrs: ~[ast::attribute],\n+                              id_sp: span\n+                             ) -> (ast::item_, ~[ast::attribute]) {\n+\n+        let full_path = if path.is_absolute {\n+            path\n+        } else {\n+            prefix.push_many(path.components)\n+        };\n+        let p0 =\n+            new_sub_parser_from_file(self.sess, self.cfg,\n+                                     &full_path, id_sp);\n+        let inner_attrs = p0.parse_inner_attrs_and_next();\n+        let mod_attrs = vec::append(outer_attrs, inner_attrs.inner);\n+        let first_item_outer_attrs = inner_attrs.next;\n+        let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n+        return (ast::item_mod(m0), mod_attrs);\n+\n+        fn cdir_path_opt(default: ~str, attrs: ~[ast::attribute]) -> ~str {\n+            match ::attr::first_attr_value_str_by_name(attrs, ~\"path\") {\n+                Some(d) => d,\n+                None => default\n+            }\n         }\n     }\n \n@@ -3702,8 +3771,7 @@ impl Parser {\n         let first_item_outer_attrs = crate_attrs.next;\n         let m = self.parse_mod_items(token::EOF, first_item_outer_attrs);\n         return @spanned(lo, self.span.lo,\n-                     {directives: ~[],\n-                      module: m,\n+                     {module: m,\n                       attrs: crate_attrs.inner,\n                       config: self.cfg});\n     }\n@@ -3714,94 +3782,12 @@ impl Parser {\n           _ =>  self.fatal(~\"expected string literal\")\n         }\n     }\n-\n-    // Logic for parsing crate files (.rc)\n-    //\n-    // Each crate file is a sequence of directives.\n-    //\n-    // Each directive imperatively extends its environment with 0 or more\n-    // items.\n-    fn parse_crate_directive(first_outer_attr: ~[attribute]) ->\n-        crate_directive {\n-\n-        // Collect the next attributes\n-        let outer_attrs = vec::append(first_outer_attr,\n-                                      self.parse_outer_attributes());\n-        // In a crate file outer attributes are only going to apply to mods\n-        let expect_mod = vec::len(outer_attrs) > 0u;\n-\n-        let lo = self.span.lo;\n-        let vis = self.parse_visibility();\n-        if expect_mod || self.is_keyword(~\"mod\") {\n-\n-            self.expect_keyword(~\"mod\");\n-\n-            let id = self.parse_ident();\n-            match self.token {\n-              // mod x = \"foo.rs\";\n-              token::SEMI => {\n-                let mut hi = self.span.hi;\n-                self.bump();\n-                return spanned(lo, hi, cdir_src_mod(vis, id, outer_attrs));\n-              }\n-              // mod x = \"foo_dir\" { ...directives... }\n-              token::LBRACE => {\n-                self.bump();\n-                let inner_attrs = self.parse_inner_attrs_and_next();\n-                let mod_attrs = vec::append(outer_attrs, inner_attrs.inner);\n-                let next_outer_attr = inner_attrs.next;\n-                let cdirs = self.parse_crate_directives(token::RBRACE,\n-                                                        next_outer_attr);\n-                let mut hi = self.span.hi;\n-                self.expect(token::RBRACE);\n-                return spanned(lo, hi,\n-                            cdir_dir_mod(vis, id, cdirs, mod_attrs));\n-              }\n-              _ => self.unexpected()\n-            }\n-        } else if self.is_view_item() {\n-            let vi = self.parse_view_item(outer_attrs, vis);\n-            return spanned(lo, vi.span.hi, cdir_view_item(vi));\n-        }\n-        return self.fatal(~\"expected crate directive\");\n-    }\n-\n-    fn parse_crate_directives(term: token::Token,\n-                              first_outer_attr: ~[attribute]) ->\n-        ~[@crate_directive] {\n-\n-        // This is pretty ugly. If we have an outer attribute then we can't\n-        // accept seeing the terminator next, so if we do see it then fail the\n-        // same way parse_crate_directive would\n-        if vec::len(first_outer_attr) > 0u && self.token == term {\n-            self.expect_keyword(~\"mod\");\n-        }\n-\n-        let mut cdirs: ~[@crate_directive] = ~[];\n-        let mut first_outer_attr = first_outer_attr;\n-        while self.token != term {\n-            let cdir = @self.parse_crate_directive(first_outer_attr);\n-            cdirs.push(cdir);\n-            first_outer_attr = ~[];\n-        }\n-        return cdirs;\n-    }\n }\n \n impl restriction : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &restriction) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &restriction) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &restriction) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &restriction) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "99c12be498063767204120e06a9c975cddf644cc", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 285, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -465,294 +465,13 @@ fn reserved_keyword_table() -> HashMap<~str, ()> {\n }\n \n impl binop : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &binop) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &binop) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &binop) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &binop) -> bool { !(*self).eq(other) }\n }\n \n impl Token : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Token) -> bool {\n-        match self {\n-            EQ => {\n-                match (*other) {\n-                    EQ => true,\n-                    _ => false\n-                }\n-            }\n-            LT => {\n-                match (*other) {\n-                    LT => true,\n-                    _ => false\n-                }\n-            }\n-            LE => {\n-                match (*other) {\n-                    LE => true,\n-                    _ => false\n-                }\n-            }\n-            EQEQ => {\n-                match (*other) {\n-                    EQEQ => true,\n-                    _ => false\n-                }\n-            }\n-            NE => {\n-                match (*other) {\n-                    NE => true,\n-                    _ => false\n-                }\n-            }\n-            GE => {\n-                match (*other) {\n-                    GE => true,\n-                    _ => false\n-                }\n-            }\n-            GT => {\n-                match (*other) {\n-                    GT => true,\n-                    _ => false\n-                }\n-            }\n-            ANDAND => {\n-                match (*other) {\n-                    ANDAND => true,\n-                    _ => false\n-                }\n-            }\n-            OROR => {\n-                match (*other) {\n-                    OROR => true,\n-                    _ => false\n-                }\n-            }\n-            NOT => {\n-                match (*other) {\n-                    NOT => true,\n-                    _ => false\n-                }\n-            }\n-            TILDE => {\n-                match (*other) {\n-                    TILDE => true,\n-                    _ => false\n-                }\n-            }\n-            BINOP(e0a) => {\n-                match (*other) {\n-                    BINOP(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            BINOPEQ(e0a) => {\n-                match (*other) {\n-                    BINOPEQ(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            AT => {\n-                match (*other) {\n-                    AT => true,\n-                    _ => false\n-                }\n-            }\n-            DOT => {\n-                match (*other) {\n-                    DOT => true,\n-                    _ => false\n-                }\n-            }\n-            DOTDOT => {\n-                match (*other) {\n-                    DOTDOT => true,\n-                    _ => false\n-                }\n-            }\n-            ELLIPSIS => {\n-                match (*other) {\n-                    ELLIPSIS => true,\n-                    _ => false\n-                }\n-            }\n-            COMMA => {\n-                match (*other) {\n-                    COMMA => true,\n-                    _ => false\n-                }\n-            }\n-            SEMI => {\n-                match (*other) {\n-                    SEMI => true,\n-                    _ => false\n-                }\n-            }\n-            COLON => {\n-                match (*other) {\n-                    COLON => true,\n-                    _ => false\n-                }\n-            }\n-            MOD_SEP => {\n-                match (*other) {\n-                    MOD_SEP => true,\n-                    _ => false\n-                }\n-            }\n-            RARROW => {\n-                match (*other) {\n-                    RARROW => true,\n-                    _ => false\n-                }\n-            }\n-            LARROW => {\n-                match (*other) {\n-                    LARROW => true,\n-                    _ => false\n-                }\n-            }\n-            DARROW => {\n-                match (*other) {\n-                    DARROW => true,\n-                    _ => false\n-                }\n-            }\n-            FAT_ARROW => {\n-                match (*other) {\n-                    FAT_ARROW => true,\n-                    _ => false\n-                }\n-            }\n-            LPAREN => {\n-                match (*other) {\n-                    LPAREN => true,\n-                    _ => false\n-                }\n-            }\n-            RPAREN => {\n-                match (*other) {\n-                    RPAREN => true,\n-                    _ => false\n-                }\n-            }\n-            LBRACKET => {\n-                match (*other) {\n-                    LBRACKET => true,\n-                    _ => false\n-                }\n-            }\n-            RBRACKET => {\n-                match (*other) {\n-                    RBRACKET => true,\n-                    _ => false\n-                }\n-            }\n-            LBRACE => {\n-                match (*other) {\n-                    LBRACE => true,\n-                    _ => false\n-                }\n-            }\n-            RBRACE => {\n-                match (*other) {\n-                    RBRACE => true,\n-                    _ => false\n-                }\n-            }\n-            POUND => {\n-                match (*other) {\n-                    POUND => true,\n-                    _ => false\n-                }\n-            }\n-            DOLLAR => {\n-                match (*other) {\n-                    DOLLAR => true,\n-                    _ => false\n-                }\n-            }\n-            LIT_INT(e0a, e1a) => {\n-                match (*other) {\n-                    LIT_INT(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            LIT_UINT(e0a, e1a) => {\n-                match (*other) {\n-                    LIT_UINT(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            LIT_INT_UNSUFFIXED(e0a) => {\n-                match (*other) {\n-                    LIT_INT_UNSUFFIXED(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            LIT_FLOAT(e0a, e1a) => {\n-                match (*other) {\n-                    LIT_FLOAT(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            LIT_FLOAT_UNSUFFIXED(e0a) => {\n-                match (*other) {\n-                    LIT_FLOAT_UNSUFFIXED(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            LIT_STR(e0a) => {\n-                match (*other) {\n-                    LIT_STR(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            IDENT(e0a, e1a) => {\n-                match (*other) {\n-                    IDENT(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            UNDERSCORE => {\n-                match (*other) {\n-                    UNDERSCORE => true,\n-                    _ => false\n-                }\n-            }\n-            INTERPOLATED(_) => {\n-                match (*other) {\n-                    INTERPOLATED(_) => true,\n-                    _ => false\n-                }\n-            }\n-            DOC_COMMENT(e0a) => {\n-                match (*other) {\n-                    DOC_COMMENT(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            EOF => {\n-                match (*other) {\n-                    EOF => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Token) -> bool {\n         match (*self) {\n             EQ => {\n@@ -1021,10 +740,6 @@ impl Token : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Token) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Token) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "014d564b84e4d53f2ecfacb3c6a4ac00c7f35b43", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -56,17 +56,6 @@ use dvec::DVec;\n enum breaks { consistent, inconsistent, }\n \n impl breaks : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &breaks) -> bool {\n-        match (self, (*other)) {\n-            (consistent, consistent) => true,\n-            (inconsistent, inconsistent) => true,\n-            (consistent, _) => false,\n-            (inconsistent, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &breaks) -> bool {\n         match ((*self), (*other)) {\n             (consistent, consistent) => true,\n@@ -75,10 +64,6 @@ impl breaks : cmp::Eq {\n             (inconsistent, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &breaks) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &breaks) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "d5a28a716ecc8b5cda1531042fb7708f6794f844", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 27, "deletions": 56, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -40,118 +40,89 @@ mod fold;\n mod util {\n     #[legacy_exports];\n     #[legacy_exports]\n+    #[path = \"util/interner.rs\"]\n     mod interner;\n }\n \n-mod parse {\n-    #[legacy_exports];\n-    export parser;\n-    export common;\n-    export lexer;\n-    export token;\n-    export comments;\n-    export prec;\n-    export classify;\n-    export attr;\n-\n-    #[legacy_exports]\n-    mod eval;\n-    #[legacy_exports]\n-    mod lexer;\n-    #[legacy_exports]\n-    mod parser;\n-    #[legacy_exports]\n-    mod token;\n-    #[legacy_exports]\n-    mod comments;\n-    #[legacy_exports]\n-    mod attr;\n-    #[legacy_exports]\n-\n-    /// Common routines shared by parser mods\n-    #[legacy_exports]\n-    mod common;\n-\n-    /// Functions dealing with operator precedence\n-    #[legacy_exports]\n-    mod prec;\n-\n-    /// Routines the parser uses to classify AST nodes\n-    #[legacy_exports]\n-    mod classify;\n-\n-    /// Reporting obsolete syntax\n-    #[legacy_exports]\n-    mod obsolete;\n-}\n+#[merge = \"parse/mod.rs\"]\n+mod parse;\n \n mod print {\n     #[legacy_exports];\n     #[legacy_exports]\n+    #[path = \"print/pp.rs\"]\n     mod pp;\n     #[legacy_exports]\n+    #[path = \"print/pprust.rs\"]\n     mod pprust;\n }\n \n mod ext {\n     #[legacy_exports];\n     #[legacy_exports]\n+    #[path = \"ext/base.rs\"]\n     mod base;\n     #[legacy_exports]\n+    #[path = \"ext/expand.rs\"]\n     mod expand;\n     #[legacy_exports]\n+    #[path = \"ext/qquote.rs\"]\n     mod qquote;\n \n+    #[path = \"ext/quote.rs\"]\n     mod quote;\n+    #[path = \"ext/deriving.rs\"]\n     mod deriving;\n \n     #[legacy_exports]\n+    #[path = \"ext/build.rs\"]\n     mod build;\n \n     mod tt {\n         #[legacy_exports];\n         #[legacy_exports]\n+        #[path = \"ext/tt/transcribe.rs\"]\n         mod transcribe;\n         #[legacy_exports]\n+        #[path = \"ext/tt/macro_parser.rs\"]\n         mod macro_parser;\n         #[legacy_exports]\n+        #[path = \"ext/tt/macro_rules.rs\"]\n         mod macro_rules;\n     }\n \n \n     #[legacy_exports]\n+    #[path = \"ext/simplext.rs\"]\n     mod simplext;\n     #[legacy_exports]\n+    #[path = \"ext/fmt.rs\"]\n     mod fmt;\n     #[legacy_exports]\n+    #[path = \"ext/env.rs\"]\n     mod env;\n     #[legacy_exports]\n+    #[path = \"ext/concat_idents.rs\"]\n     mod concat_idents;\n     #[legacy_exports]\n+    #[path = \"ext/ident_to_str.rs\"]\n     mod ident_to_str;\n     #[legacy_exports]\n+    #[path = \"ext/log_syntax.rs\"]\n     mod log_syntax;\n     #[legacy_exports]\n+    #[path = \"ext/auto_serialize.rs\"]\n     mod auto_serialize;\n     #[legacy_exports]\n+    #[path = \"ext/source_util.rs\"]\n     mod source_util;\n \n-    mod pipes {\n-        #[legacy_exports];\n-        #[legacy_exports]\n-        mod ast_builder;\n-        #[legacy_exports]\n-        mod parse_proto;\n-        #[legacy_exports]\n-        mod pipec;\n-        #[legacy_exports]\n-        mod proto;\n-        #[legacy_exports]\n-        mod check;\n-        #[legacy_exports]\n-        mod liveness;\n-    }\n+    #[legacy_exports]\n+    #[path = \"ext/pipes.rs\"]\n+    #[merge = \"ext/pipes/mod.rs\"]\n+    mod pipes;\n \n     #[legacy_exports]\n+    #[path = \"ext/trace_macros.rs\"]\n     mod trace_macros;\n }"}, {"sha": "afd928a9fbc4e3924c3983af650d7a84d6a17ead", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -93,16 +93,6 @@ fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n     v.visit_mod(c.node.module, c.span, crate_node_id, e, v);\n }\n \n-fn visit_crate_directive<E>(cd: @crate_directive, e: E, v: vt<E>) {\n-    match cd.node {\n-      cdir_src_mod(_, _, _) => (),\n-      cdir_dir_mod(_, _, cdirs, _) => for cdirs.each |cdir| {\n-        visit_crate_directive(*cdir, e, v);\n-      },\n-      cdir_view_item(vi) => v.visit_view_item(vi, e, v),\n-    }\n-}\n-\n fn visit_mod<E>(m: _mod, _sp: span, _id: node_id, e: E, v: vt<E>) {\n     for m.view_items.each |vi| { v.visit_view_item(*vi, e, v); }\n     for m.items.each |i| { v.visit_item(*i, e, v); }"}, {"sha": "cf216fe923c79d0005ce6dc14b208fd20cf0e6b4", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -1,3 +1,11 @@\n+S 2012-11-26 be6613e\n+  winnt-i386 f800925ce98d23f842a03be65f01aae0dfa1e897\n+  freebsd-x86_64 23462b234b8ff3c0b6d6f94e5952178dbcef3488\n+  linux-i386 e5fc408495952b61c3c103265cf1f54e2ab51e05\n+  linux-x86_64 beb6454c57267c9fb198e4f0f8d4773e28f5bdf4\n+  macos-i386 46b83a3fec0731198e010827c6842f2854cc79df\n+  macos-x86_64 d06b16853e2a81fa5edb7fb2de73e6665c1ccd28\n+\n S 2012-11-18 68c73dc\n   freebsd-x86_64 976e75614c455557e3763e270cbf7b5fce1c5c67\n   linux-i386 d44088ce7183622921626038becf9c5e2d76cb66"}, {"sha": "8d1d15138fdcd4c18bca8ab95b85cf0f8037d898", "filename": "src/test/compile-fail/attr-bad-crate-attr.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Ftest%2Fcompile-fail%2Fattr-bad-crate-attr.rc", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Ftest%2Fcompile-fail%2Fattr-bad-crate-attr.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-bad-crate-attr.rc?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: expected `mod`\n+// error-pattern: expected item\n \n #[attr = \"val\"];\n #[attr = \"val\"] // Unterminated"}, {"sha": "e4350ab4ee707da6765b9c3046c80827febeb4ed", "filename": "src/test/run-pass/companionmod-src/b.rs", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fb.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,2 +0,0 @@\n-use g = x::f;\n-export g;\n\\ No newline at end of file"}, {"sha": "d81ff2ba9a50751021f2ea0d671584f1520d2b9c", "filename": "src/test/run-pass/companionmod-src/b/x.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fb%2Fx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fb%2Fx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fb%2Fx.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1 +0,0 @@\n-fn f() -> ~str { ~\"ralph\" }\n\\ No newline at end of file"}, {"sha": "e4350ab4ee707da6765b9c3046c80827febeb4ed", "filename": "src/test/run-pass/companionmod-src/d.rs", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fd.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,2 +0,0 @@\n-use g = x::f;\n-export g;\n\\ No newline at end of file"}, {"sha": "b27e39327f172c0d51b1b6ee38895fc77f0f7c76", "filename": "src/test/run-pass/companionmod-src/d/x.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fd%2Fx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fd%2Fx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcompanionmod-src%2Fd%2Fx.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1 +0,0 @@\n-fn f() -> ~str { ~\"nelson\" }\n\\ No newline at end of file"}, {"sha": "8736345c9827c8bbd6bad48462ce77ea1c5e6e1f", "filename": "src/test/run-pass/companionmod.rc", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fcompanionmod.rc", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fcompanionmod.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcompanionmod.rc?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,19 +0,0 @@\n-// xfail-win32 don't understand what's wrong\n-// Test that crates and directory modules can contain code\n-#[legacy_exports];\n-\n-#[path = \"companionmod-src\"]\n-mod a {\n-    #[legacy_exports];\n-    mod b {\n-        #[legacy_exports];\n-        #[legacy_exports]\n-        mod x;\n-    }\n-    #[path = \"d\"]\n-    mod c {\n-        #[legacy_exports];\n-        #[legacy_exports]\n-        mod x;\n-    }\n-}"}, {"sha": "ff15fe580567aed921d2adc43a02cefd3a03a1ff", "filename": "src/test/run-pass/companionmod.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fcompanionmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fcompanionmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcompanionmod.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,8 +0,0 @@\n-// This isn't really xfailed; it's used by the companionmod.rc test\n-// xfail-test\n-\n-#[legacy_exports];\n-fn main() {\n-    assert a::b::g() == ~\"ralph\";\n-    assert a::c::g() == ~\"nelson\";\n-}\n\\ No newline at end of file"}, {"sha": "7086ebf2ea8733cad205ce0612894d2c4c71cd30", "filename": "src/test/run-pass/crate-attributes-src/foo.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fcrate-attributes-src%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fcrate-attributes-src%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrate-attributes-src%2Ffoo.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,9 +0,0 @@\n-// These are attributes of the foo module\n-#[legacy_exports];\n-#[attr1 = \"val\"];\n-#[attr2 = \"val\"];\n-\n-// Attributes of the following function\n-#[attr1 = \"val\"]\n-#[attr2 = \"val\"]\n-fn main() { }"}, {"sha": "2ee41913f40d14fbcb167f60e1daac94a108bc26", "filename": "src/test/run-pass/crate-attributes.rc", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fcrate-attributes.rc", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fcrate-attributes.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrate-attributes.rc?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,13 +0,0 @@\n-#[name = \"crate-attributes\"];\n-#[vers = \"1.0\"];\n-\n-#[attr1]\n-#[path = \"crate-attributes-src\"]\n-mod m {\n-    #[legacy_exports];\n-  #[attr_inner];\n-\n-  #[attr2]\n-    #[legacy_exports]\n-  mod foo;\n-}"}, {"sha": "d61c6383ee53d8059a3706c01b19da7ca181a813", "filename": "src/test/run-pass/mod-merge-hack-inst.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Ftest%2Frun-pass%2Fmod-merge-hack-inst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Ftest%2Frun-pass%2Fmod-merge-hack-inst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmod-merge-hack-inst.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,6 @@\n+// xfail-test not a test. used by mod-merge-hack.rs\n+\n+mod inst {\n+    pub type T = i32;\n+    pub const bits: uint = 32;\n+}"}, {"sha": "a659d8b0e5f6f6ad376d171e27b547878f9c9cc5", "filename": "src/test/run-pass/mod-merge-hack-template.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Ftest%2Frun-pass%2Fmod-merge-hack-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Ftest%2Frun-pass%2Fmod-merge-hack-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmod-merge-hack-template.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,6 @@\n+// xfail-test not a test. used by mod-merge-hack.rs\n+\n+use T = inst::T;\n+\n+pub const bits: uint = inst::bits;\n+pub pure fn min(x: T, y: T) -> T { if x < y { x } else { y } }"}, {"sha": "c6e0901779b0b7eecd1a73f933a257b909b5c9f0", "filename": "src/test/run-pass/mod-merge-hack.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Ftest%2Frun-pass%2Fmod-merge-hack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6/src%2Ftest%2Frun-pass%2Fmod-merge-hack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmod-merge-hack.rs?ref=fc06114ddfd2bcdbc4f29076c226a7a1d66ea8d6", "patch": "@@ -0,0 +1,9 @@\n+// xfail-pretty\n+#[path = \"mod-merge-hack-template.rs\"]\n+#[merge = \"mod-merge-hack-inst.rs\"]\n+mod myint32;\n+\n+fn main() {\n+    assert myint32::bits == 32;\n+    assert myint32::min(10, 20) == 10;\n+}\n\\ No newline at end of file"}, {"sha": "ea7d8fd77a0762efb03751e7cc6d7d69cbcb39c3", "filename": "src/test/run-pass/module-polymorphism-files/inst_f32.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Finst_f32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Finst_f32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Finst_f32.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1 +0,0 @@\n-type T = f32;\n\\ No newline at end of file"}, {"sha": "8811863b27c55ba7fa3bc7e6b265a2d01bef6679", "filename": "src/test/run-pass/module-polymorphism-files/inst_f64.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Finst_f64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Finst_f64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Finst_f64.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1 +0,0 @@\n-type T = f64;\n\\ No newline at end of file"}, {"sha": "5726ccf7ad068f09c469a68cae0e7ba531012f43", "filename": "src/test/run-pass/module-polymorphism-files/inst_float.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Finst_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Finst_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Finst_float.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1 +0,0 @@\n-type T = float;\n\\ No newline at end of file"}, {"sha": "c8d52145cab950ce5643344c4101ac9a5238ed87", "filename": "src/test/run-pass/module-polymorphism-files/template.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Ftemplate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Ftemplate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism-files%2Ftemplate.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,3 +0,0 @@\n-fn plus(x: T, y: T) -> T {\n-    x + y\n-}\n\\ No newline at end of file"}, {"sha": "bce2d80e045a87ac11150a9ded267437d3152319", "filename": "src/test/run-pass/module-polymorphism.rc", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism.rc", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism.rc?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,51 +0,0 @@\n-#[path = \"module-polymorphism-files\"]\n-mod my_float {\n-    #[legacy_exports];\n-\n-    // The type of the float\n-    use inst::T;\n-\n-    // Define T as float\n-    #[path = \"inst_float.rs\"]\n-    #[legacy_exports]\n-    mod inst;\n-\n-    // Add in the implementation from a single source file\n-    #[path = \"template.rs\"]\n-    #[legacy_exports]\n-    mod template;\n-\n-}\n-\n-#[path = \"module-polymorphism-files\"]\n-mod my_f64 {\n-    #[legacy_exports];\n-\n-    use inst::T;\n-\n-    // Define T as f64\n-    #[path = \"inst_f64.rs\"]\n-    #[legacy_exports]\n-    mod inst;\n-\n-    // Use the implementation for the same source file!\n-    #[path = \"template.rs\"]\n-    #[legacy_exports]\n-    mod template;\n-\n-}\n-\n-#[path = \"module-polymorphism-files\"]\n-mod my_f32 {\n-    #[legacy_exports];\n-    use inst::T;\n-\n-    #[path = \"inst_f32.rs\"]\n-    #[legacy_exports]\n-    mod inst;\n-\n-    #[path = \"template.rs\"]\n-    #[legacy_exports]\n-    mod template;\n-\n-}"}, {"sha": "26c3582d6a635b55b7b05d5b5454e5d25dfbc416", "filename": "src/test/run-pass/module-polymorphism.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,11 +0,0 @@\n-// This isn't really xfailed; it's used by the\n-// module-polymorphism.rc test\n-// xfail-test\n-\n-fn main() {\n-    // All of these functions are defined by a single module\n-    // source file but instantiated for different types\n-    assert my_float::template::plus(1.0f, 2.0f) == 3.0f;\n-    assert my_f64::template::plus(1.0f64, 2.0f64) == 3.0f64;\n-    assert my_f32::template::plus(1.0f32, 2.0f32) == 3.0f32;\n-}\n\\ No newline at end of file"}, {"sha": "ea7d8fd77a0762efb03751e7cc6d7d69cbcb39c3", "filename": "src/test/run-pass/module-polymorphism2-files/float-template/inst_f32.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Finst_f32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Finst_f32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Finst_f32.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1 +0,0 @@\n-type T = f32;\n\\ No newline at end of file"}, {"sha": "8811863b27c55ba7fa3bc7e6b265a2d01bef6679", "filename": "src/test/run-pass/module-polymorphism2-files/float-template/inst_f64.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Finst_f64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Finst_f64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Finst_f64.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1 +0,0 @@\n-type T = f64;\n\\ No newline at end of file"}, {"sha": "5726ccf7ad068f09c469a68cae0e7ba531012f43", "filename": "src/test/run-pass/module-polymorphism2-files/float-template/inst_float.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Finst_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Finst_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Finst_float.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1 +0,0 @@\n-type T = float;\n\\ No newline at end of file"}, {"sha": "c8d52145cab950ce5643344c4101ac9a5238ed87", "filename": "src/test/run-pass/module-polymorphism2-files/float-template/template.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Ftemplate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Ftemplate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2-files%2Ffloat-template%2Ftemplate.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,3 +0,0 @@\n-fn plus(x: T, y: T) -> T {\n-    x + y\n-}\n\\ No newline at end of file"}, {"sha": "49cd60fc0a93a2a00c5dfccdfbb7b6133b89fdc0", "filename": "src/test/run-pass/module-polymorphism2.rc", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2.rc", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2.rc?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,68 +0,0 @@\n-#[path = \"module-polymorphism2-files\"]\n-mod mystd {\n-    #[legacy_exports];\n-\n-    #[path = \"float-template\"]\n-    mod float {\n-        #[legacy_exports];\n-        // The type of the float\n-        use inst::T;\n-\n-        // Unfortunate\n-        use template::*;\n-        export plus;\n-\n-        // Define T as float\n-        #[path = \"inst_float.rs\"]\n-        #[legacy_exports]\n-        mod inst;\n-\n-        // Add in the implementation from a single source file\n-        #[path = \"template.rs\"]\n-        #[legacy_exports]\n-        mod template;\n-    }\n-\n-\n-    #[path = \"float-template\"]\n-    mod f64 {\n-        #[legacy_exports];\n-\n-        use inst::T;\n-\n-        // Unfortunate\n-        use template::*;\n-        export plus;\n-\n-        // Define T as f64\n-        #[path = \"inst_f64.rs\"]\n-        #[legacy_exports]\n-        mod inst;\n-\n-        // Use the implementation for the same source file!\n-        #[path = \"template.rs\"]\n-        #[legacy_exports]\n-        mod template;\n-\n-    }\n-\n-    #[path = \"float-template\"]\n-    mod f32 {\n-        #[legacy_exports];\n-        use inst::T;\n-\n-        // Unfortunate\n-        use template::*;\n-        export plus;\n-\n-        #[path = \"inst_f32.rs\"]\n-        #[legacy_exports]\n-        mod inst;\n-\n-        #[path = \"template.rs\"]\n-        #[legacy_exports]\n-        mod template;\n-\n-    }\n-\n-}\n\\ No newline at end of file"}, {"sha": "7bb55c454306dcb514bfce95bd85c6768004f0b4", "filename": "src/test/run-pass/module-polymorphism2.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism2.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,11 +0,0 @@\n-// This isn't really xfailed; it's used by the\n-// module-polymorphism.rc test\n-// xfail-test\n-\n-fn main() {\n-    // All of these functions are defined by a single module\n-    // source file but instantiated for different types\n-    assert mystd::float::plus(1.0f, 2.0f) == 3.0f;\n-    assert mystd::f64::plus(1.0f64, 2.0f64) == 3.0f64;\n-    assert mystd::f32::plus(1.0f32, 2.0f32) == 3.0f32;\n-}\n\\ No newline at end of file"}, {"sha": "c8d52145cab950ce5643344c4101ac9a5238ed87", "filename": "src/test/run-pass/module-polymorphism3-files/float-template.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,3 +0,0 @@\n-fn plus(x: T, y: T) -> T {\n-    x + y\n-}\n\\ No newline at end of file"}, {"sha": "ea7d8fd77a0762efb03751e7cc6d7d69cbcb39c3", "filename": "src/test/run-pass/module-polymorphism3-files/float-template/inst_f32.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_f32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_f32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_f32.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1 +0,0 @@\n-type T = f32;\n\\ No newline at end of file"}, {"sha": "8811863b27c55ba7fa3bc7e6b265a2d01bef6679", "filename": "src/test/run-pass/module-polymorphism3-files/float-template/inst_f64.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_f64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_f64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_f64.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1 +0,0 @@\n-type T = f64;\n\\ No newline at end of file"}, {"sha": "5726ccf7ad068f09c469a68cae0e7ba531012f43", "filename": "src/test/run-pass/module-polymorphism3-files/float-template/inst_float.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_float.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1 +0,0 @@\n-type T = float;\n\\ No newline at end of file"}, {"sha": "27d9753d9d520fb9bcb353daedbce0eeeff4f239", "filename": "src/test/run-pass/module-polymorphism3.rc", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3.rc", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3.rc?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,41 +0,0 @@\n-// Use one template module to specify in a single file the implementation\n-// of functions for multiple types\n-\n-#[path = \"module-polymorphism3-files\"]\n-mod mystd {\n-    #[legacy_exports];\n-\n-    // The template is specified in float-template.rs\n-    #[path = \"float-template\"]\n-    mod float {\n-        #[legacy_exports];\n-        // The type of the float\n-        use inst::T;\n-\n-        // Define T as appropriate for platform\n-        #[path = \"inst_float.rs\"]\n-        mod inst;\n-    }\n-\n-    // Use the same template\n-    #[path = \"float-template\"]\n-    mod f64 {\n-        #[legacy_exports];\n-\n-        use inst::T;\n-\n-        // Define T as f64\n-        #[path = \"inst_f64.rs\"]\n-        mod inst;\n-    }\n-\n-    #[path = \"float-template\"]\n-    mod f32 {\n-        #[legacy_exports];\n-        use inst::T;\n-\n-        #[path = \"inst_f32.rs\"]\n-        mod inst;\n-    }\n-\n-}\n\\ No newline at end of file"}, {"sha": "7bb55c454306dcb514bfce95bd85c6768004f0b4", "filename": "src/test/run-pass/module-polymorphism3.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,11 +0,0 @@\n-// This isn't really xfailed; it's used by the\n-// module-polymorphism.rc test\n-// xfail-test\n-\n-fn main() {\n-    // All of these functions are defined by a single module\n-    // source file but instantiated for different types\n-    assert mystd::float::plus(1.0f, 2.0f) == 3.0f;\n-    assert mystd::f64::plus(1.0f64, 2.0f64) == 3.0f64;\n-    assert mystd::f32::plus(1.0f32, 2.0f32) == 3.0f32;\n-}\n\\ No newline at end of file"}, {"sha": "f19b72ed18176fa5775f63c7a8f7ed08c87695fb", "filename": "src/test/run-pass/module-polymorphism4-files/cat.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Fcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Fcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Fcat.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,14 +0,0 @@\n-type T = cat;\n-\n-enum cat {\n-    howlycat,\n-    meowlycat\n-}\n-\n-fn animal() -> ~str { ~\"cat\" }\n-fn talk(c: cat) -> ~str {\n-    match c {\n-      howlycat =>  { ~\"howl\" }\n-      meowlycat => { ~\"meow\" }\n-    }\n-}"}, {"sha": "4fd212deb8d7f7a658aebf5531bd5db7ae45701e", "filename": "src/test/run-pass/module-polymorphism4-files/dog.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Fdog.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Fdog.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Fdog.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,9 +0,0 @@\n-type T = dog;\n-\n-enum dog {\n-    dog\n-}\n-\n-fn animal() -> ~str { ~\"dog\" }\n-fn talk(_d: dog) -> ~str { ~\"woof\" }\n-"}, {"sha": "983a4039eeb2e284acc4860a94f8bd20377230ee", "filename": "src/test/run-pass/module-polymorphism4-files/trait_.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Ftrait_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Ftrait_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4-files%2Ftrait_.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,13 +0,0 @@\n-trait says {\n-    fn says() -> ~str;\n-}\n-\n-impl T: says {\n-\n-    // 'animal' and 'talk' functions are implemented by the module\n-    // instantiating the talky trait. They are 'abstract'\n-    fn says() -> ~str {\n-        animal() + ~\" says '\" + talk(self) + ~\"'\"\n-    }\n-\n-}"}, {"sha": "4cb7acf8f03b7e5de5ab4c600f2f8dd6359f3bcd", "filename": "src/test/run-pass/module-polymorphism4.rc", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4.rc", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4.rc?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,32 +0,0 @@\n-\n-#[path = \"module-polymorphism4-files\"]\n-mod cat {\n-    #[legacy_exports];\n-\n-    use inst::*;\n-\n-    #[path = \"cat.rs\"]\n-    #[legacy_exports]\n-    mod inst;\n-\n-    #[path = \"trait_.rs\"]\n-    #[legacy_exports]\n-    mod trait_;\n-\n-}\n-\n-#[path = \"module-polymorphism4-files\"]\n-mod dog {\n-    #[legacy_exports];\n-\n-    use inst::*;\n-\n-    #[path = \"dog.rs\"]\n-    #[legacy_exports]\n-    mod inst;\n-\n-    #[path = \"trait_.rs\"]\n-    #[legacy_exports]\n-    mod trait_;\n-\n-}"}, {"sha": "0824e5b49bb479272c176f8ef2b540ed363cc4ce", "filename": "src/test/run-pass/module-polymorphism4.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism4.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,12 +0,0 @@\n-// This isn't really xfailed; it's used by the\n-// module-polymorphism.rc test\n-// xfail-test\n-\n-fn main() {\n-    let cat1 = cat::inst::meowlycat;\n-    let cat2 = cat::inst::howlycat;\n-    let dog = dog::inst::dog;\n-    assert cat1.says() == ~\"cat says 'meow'\";\n-    assert cat2.says() == ~\"cat says 'howl'\";\n-    assert dog.says() == ~\"dog says 'woof'\";\n-}\n\\ No newline at end of file"}, {"sha": "33699ac4f849a91bbdc2bd681df4e5c25b2b4b1c", "filename": "src/test/run-pass/multi-src/bar.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmulti-src%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmulti-src%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmulti-src%2Fbar.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,3 +0,0 @@\n-\n-\n-fn other() { debug!(\"yes\"); }"}, {"sha": "466b6b9be56781f12708ed8e88da95ef7f595291", "filename": "src/test/run-pass/multi-src/foo.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmulti-src%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmulti-src%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmulti-src%2Ffoo.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,3 +0,0 @@\n-\n-\n-fn main() { debug!(\"hello, multi-file world.\"); bar::other(); }"}, {"sha": "61c81030bbabf5d846e0d114c04b8035d2c1a55e", "filename": "src/test/run-pass/multi.rc", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmulti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Fmulti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmulti.rc?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,11 +0,0 @@\n-#[path = \"multi-src\"]\n-mod multi {\n-    #[legacy_exports];\n-  // implicitly #[path = \"foo.rs\"]\n-  #[legacy_exports]\n-  mod foo;\n-\n-  #[path  = \"bar.rs\"]\n-  #[legacy_exports]\n-  mod bar;\n-}"}, {"sha": "818f41de262f7e1ec726a2e11faa89731bb4553c", "filename": "src/test/run-pass/trait-mix.rc", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Ftrait-mix.rc", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Ftrait-mix.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-mix.rc?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,8 +0,0 @@\n-mod trait_mix {\n-    #[legacy_exports];\n-    #[path = \"trait-mix.rs\"]\n-    #[legacy_exports]\n-    mod trait_mix;\n-    #[legacy_exports]\n-    mod u_trait_mix;\n-}"}, {"sha": "800fb4f90063a8a921cf2923ad93949d1b1a751b", "filename": "src/test/run-pass/trait_mix/trait-mix.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Ftrait_mix%2Ftrait-mix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Ftrait_mix%2Ftrait-mix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait_mix%2Ftrait-mix.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,27 +0,0 @@\n-\n-impl f32: u_trait_mix::num {\n-    pure fn add(&&other: f32)    -> f32 { return self + other; }\n-    pure fn sub(&&other: f32)    -> f32 { return self - other; }\n-    pure fn mul(&&other: f32)    -> f32 { return self * other; }\n-    pure fn div(&&other: f32)    -> f32 { return self / other; }\n-    pure fn modulo(&&other: f32) -> f32 { return self % other; }\n-    pure fn neg()                -> f32 { return -self;        }\n-\n-    pure fn to_int()         -> int { return self as int; }\n-    static pure fn from_int(n: int) -> f32 { return n as f32;    }\n-}\n-\n-/*\n-It seems that this will fail if I try using it from another crate.\n-\n-*/\n-\n-/*\n-\n-// ICEs if I put this in num -- ???\n-trait from_int {\n-\n-}\n-*/\n-\n-fn main() {}"}, {"sha": "260955e687a1bb2aeb545689eb002aea129c7386", "filename": "src/test/run-pass/trait_mix/u_trait_mix.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Ftrait_mix%2Fu_trait_mix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669fbddc4435a9ab152332df06a7fcca789c8059/src%2Ftest%2Frun-pass%2Ftrait_mix%2Fu_trait_mix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait_mix%2Fu_trait_mix.rs?ref=669fbddc4435a9ab152332df06a7fcca789c8059", "patch": "@@ -1,13 +0,0 @@\n-trait num {\n-    // FIXME: Trait composition. (#2616)\n-    pure fn add(&&other: self) -> self;\n-    pure fn sub(&&other: self) -> self;\n-    pure fn mul(&&other: self) -> self;\n-    pure fn div(&&other: self) -> self;\n-    pure fn modulo(&&other: self) -> self;\n-    pure fn neg() -> self;\n-\n-    pure fn to_int() -> int;\n-    static pure fn from_int(n: int) -> self;\n-}\n-"}]}