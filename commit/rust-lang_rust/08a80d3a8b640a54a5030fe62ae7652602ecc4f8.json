{"sha": "08a80d3a8b640a54a5030fe62ae7652602ecc4f8", "node_id": "C_kwDOAAsO6NoAKDA4YTgwZDNhOGI2NDBhNTRhNTAzMGZlNjJhZTc2NTI2MDJlY2M0Zjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-25T15:59:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-25T15:59:47Z"}, "message": "Auto merge of #9944 - flip1995:move-syntax-tree-patterns, r=Manishearth\n\nMove syntax tree patterns RFC to the book\n\nr? `@Manishearth`\n\nFollow up to #3875\n\nchangelog: none", "tree": {"sha": "579041d836ae27404ca0be7a526f30788ac61a83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/579041d836ae27404ca0be7a526f30788ac61a83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08a80d3a8b640a54a5030fe62ae7652602ecc4f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08a80d3a8b640a54a5030fe62ae7652602ecc4f8", "html_url": "https://github.com/rust-lang/rust/commit/08a80d3a8b640a54a5030fe62ae7652602ecc4f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08a80d3a8b640a54a5030fe62ae7652602ecc4f8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efadb55733f1f852e18427376d3c5268139225cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/efadb55733f1f852e18427376d3c5268139225cd", "html_url": "https://github.com/rust-lang/rust/commit/efadb55733f1f852e18427376d3c5268139225cd"}, {"sha": "c6a1184e4d4ca23fcbc6656913ba5a5a21d54368", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6a1184e4d4ca23fcbc6656913ba5a5a21d54368", "html_url": "https://github.com/rust-lang/rust/commit/c6a1184e4d4ca23fcbc6656913ba5a5a21d54368"}], "stats": {"total": 1776, "additions": 987, "deletions": 789}, "files": [{"sha": "1f0b8db28a152e19c48ccd93f46285036a18e9ef", "filename": "book/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08a80d3a8b640a54a5030fe62ae7652602ecc4f8/book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/08a80d3a8b640a54a5030fe62ae7652602ecc4f8/book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2FSUMMARY.md?ref=08a80d3a8b640a54a5030fe62ae7652602ecc4f8", "patch": "@@ -21,3 +21,4 @@\n         - [The Clippy Book](development/infrastructure/book.md)\n     - [Proposals](development/proposals/README.md)\n         - [Roadmap 2021](development/proposals/roadmap-2021.md)\n+        - [Syntax Tree Patterns](development/proposals/syntax-tree-patterns.md)"}, {"sha": "c5587c4bf9089eff4283f327d0029d079462df4f", "filename": "book/src/development/proposals/syntax-tree-patterns.md", "status": "added", "additions": 986, "deletions": 0, "changes": 986, "blob_url": "https://github.com/rust-lang/rust/blob/08a80d3a8b640a54a5030fe62ae7652602ecc4f8/book%2Fsrc%2Fdevelopment%2Fproposals%2Fsyntax-tree-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/08a80d3a8b640a54a5030fe62ae7652602ecc4f8/book%2Fsrc%2Fdevelopment%2Fproposals%2Fsyntax-tree-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fproposals%2Fsyntax-tree-patterns.md?ref=08a80d3a8b640a54a5030fe62ae7652602ecc4f8", "patch": "@@ -0,0 +1,986 @@\n+- Feature Name: syntax-tree-patterns\n+- Start Date: 2019-03-12\n+- RFC PR: [#3875](https://github.com/rust-lang/rust-clippy/pull/3875)\n+\n+# Summary\n+\n+Introduce a domain-specific language (similar to regular expressions) that\n+allows to describe lints using *syntax tree patterns*.\n+\n+\n+# Motivation\n+\n+Finding parts of a syntax tree (AST, HIR, ...) that have certain properties\n+(e.g. \"*an if that has a block as its condition*\") is a major task when writing\n+lints. For non-trivial lints, it often requires nested pattern matching of AST /\n+HIR nodes. For example, testing that an expression is a boolean literal requires\n+the following checks:\n+\n+```rust\n+if let ast::ExprKind::Lit(lit) = &expr.node {\n+    if let ast::LitKind::Bool(_) = &lit.node {\n+        ...\n+    }\n+}\n+```\n+\n+Writing this kind of matching code quickly becomes a complex task and the\n+resulting code is often hard to comprehend. The code below shows a simplified\n+version of the pattern matching required by the `collapsible_if` lint:\n+\n+```rust\n+// simplified version of the collapsible_if lint\n+if let ast::ExprKind::If(check, then, None) = &expr.node {\n+    if then.stmts.len() == 1 {\n+        if let ast::StmtKind::Expr(inner) | ast::StmtKind::Semi(inner) = &then.stmts[0].node {\n+            if let ast::ExprKind::If(check_inner, content, None) = &inner.node {\n+                ...\n+            }\n+        }\n+    }\n+}\n+```\n+\n+The `if_chain` macro can improve readability by flattening the nested if\n+statements, but the resulting code is still quite hard to read:\n+\n+```rust\n+// simplified version of the collapsible_if lint\n+if_chain! {\n+    if let ast::ExprKind::If(check, then, None) = &expr.node;\n+    if then.stmts.len() == 1;\n+    if let ast::StmtKind::Expr(inner) | ast::StmtKind::Semi(inner) = &then.stmts[0].node;\n+    if let ast::ExprKind::If(check_inner, content, None) = &inner.node;\n+    then {\n+        ...\n+    }\n+}\n+```\n+\n+The code above matches if expressions that contain only another if expression\n+(where both ifs don't have an else branch). While it's easy to explain what the\n+lint does, it's hard to see that from looking at the code samples above.\n+\n+Following the motivation above, the first goal this RFC is to **simplify writing\n+and reading lints**.\n+\n+The second part of the motivation is clippy's dependence on unstable\n+compiler-internal data structures. Clippy lints are currently written against\n+the compiler's AST / HIR which means that even small changes in these data\n+structures might break a lot of lints. The second goal of this RFC is to **make\n+lints independant of the compiler's AST / HIR data structures**.\n+\n+# Approach\n+\n+A lot of complexity in writing lints currently seems to come from having to\n+manually implement the matching logic (see code samples above). It's an\n+imparative style that describes *how* to match a syntax tree node instead of\n+specifying *what* should be matched against declaratively. In other areas, it's\n+common to use declarative patterns to describe desired information and let the\n+implementation do the actual matching. A well-known example of this approach are\n+[regular expressions](https://en.wikipedia.org/wiki/Regular_expression). Instead\n+of writing code that detects certain character sequences, one can describe a\n+search pattern using a domain-specific language and search for matches using\n+that pattern. The advantage of using a declarative domain-specific language is\n+that its limited domain (e.g. matching character sequences in the case of\n+regular expressions) allows to express entities in that domain in a very natural\n+and expressive way.\n+\n+While regular expressions are very useful when searching for patterns in flat\n+character sequences, they cannot easily be applied to hierarchical data\n+structures like syntax trees. This RFC therefore proposes a pattern matching\n+system that is inspired by regular expressions and designed for hierarchical\n+syntax trees.\n+\n+# Guide-level explanation\n+\n+This proposal adds a `pattern!` macro that can be used to specify a syntax tree\n+pattern to search for. A simple pattern is shown below:\n+\n+```rust\n+pattern!{\n+    my_pattern: Expr =\n+        Lit(Bool(false))\n+}\n+```\n+\n+This macro call defines a pattern named `my_pattern` that can be matched against\n+an `Expr` syntax tree node. The actual pattern (`Lit(Bool(false))` in this case)\n+defines which syntax trees should match the pattern. This pattern matches\n+expressions that are boolean literals with value `false`.\n+\n+The pattern can then be used to implement lints in the following way:\n+\n+```rust\n+...\n+\n+impl EarlyLintPass for MyAwesomeLint {\n+    fn check_expr(&mut self, cx: &EarlyContext, expr: &syntax::ast::Expr) {\n+\n+        if my_pattern(expr).is_some() {\n+            cx.span_lint(\n+                MY_AWESOME_LINT,\n+                expr.span,\n+                \"This is a match for a simple pattern. Well done!\",\n+            );\n+        }\n+\n+    }\n+}\n+```\n+\n+The `pattern!` macro call expands to a function `my_pattern` that expects a\n+syntax tree expression as its argument and returns an `Option` that indicates\n+whether the pattern matched.\n+\n+> Note: The result type is explained in more detail in [a later\n+> section](#the-result-type). For now, it's enough to know that the result is\n+> `Some` if the pattern matched and `None` otherwise.\n+\n+## Pattern syntax\n+\n+The following examples demonstate the pattern syntax:\n+\n+\n+#### Any (`_`)\n+\n+The simplest pattern is the any pattern. It matches anything and is therefore\n+similar to regex's `*`.\n+\n+```rust\n+pattern!{\n+    // matches any expression\n+    my_pattern: Expr =\n+        _\n+}\n+```\n+\n+#### Node (`<node-name>(<args>)`)\n+\n+Nodes are used to match a specific variant of an AST node. A node has a name and\n+a number of arguments that depends on the node type. For example, the `Lit` node\n+has a single argument that describes the type of the literal. As another\n+example, the `If` node has three arguments describing the if's condition, then\n+block and else block.\n+\n+```rust\n+pattern!{\n+    // matches any expression that is a literal\n+    my_pattern: Expr =\n+        Lit(_)\n+}\n+\n+pattern!{\n+    // matches any expression that is a boolean literal\n+    my_pattern: Expr =\n+        Lit(Bool(_))\n+}\n+\n+pattern!{\n+    // matches if expressions that have a boolean literal in their condition\n+    // Note: The `_?` syntax here means that the else branch is optional and can be anything.\n+    //       This is discussed in more detail in the section `Repetition`.\n+    my_pattern: Expr =\n+        If( Lit(Bool(_)) , _, _?)\n+}\n+```\n+\n+\n+#### Literal (`<lit>`)\n+\n+A pattern can also contain Rust literals. These literals match themselves.\n+\n+```rust\n+pattern!{\n+    // matches the boolean literal false\n+    my_pattern: Expr =\n+        Lit(Bool(false))\n+}\n+\n+pattern!{\n+    // matches the character literal 'x'\n+    my_pattern: Expr =\n+        Lit(Char('x'))\n+}\n+```\n+\n+#### Alternations (`a | b`)\n+\n+```rust\n+pattern!{\n+    // matches if the literal is a boolean or integer literal\n+    my_pattern: Lit =\n+        Bool(_) | Int(_)\n+}\n+\n+pattern!{\n+    // matches if the expression is a char literal with value 'x' or 'y'\n+    my_pattern: Expr =\n+        Lit( Char('x' | 'y') )\n+}\n+```\n+\n+#### Empty (`()`)\n+\n+The empty pattern represents an empty sequence or the `None` variant of an\n+optional.\n+\n+```rust\n+pattern!{\n+    // matches if the expression is an empty array\n+    my_pattern: Expr =\n+        Array( () )\n+}\n+\n+pattern!{\n+    // matches if expressions that don't have an else clause\n+    my_pattern: Expr =\n+        If(_, _, ())\n+}\n+```\n+\n+#### Sequence (`<a> <b>`)\n+\n+```rust\n+pattern!{\n+    // matches the array [true, false]\n+    my_pattern: Expr =\n+        Array( Lit(Bool(true)) Lit(Bool(false)) )\n+}\n+```\n+\n+#### Repetition (`<a>*`, `<a>+`, `<a>?`, `<a>{n}`, `<a>{n,m}`, `<a>{n,}`)\n+\n+Elements may be repeated. The syntax for specifying repetitions is identical to\n+[regex's syntax](https://docs.rs/regex/1.1.2/regex/#repetitions).\n+\n+```rust\n+pattern!{\n+    // matches arrays that contain 2 'x's as their last or second-last elements\n+    // Examples:\n+    //     ['x', 'x']                         match\n+    //     ['x', 'x', 'y']                    match\n+    //     ['a', 'b', 'c', 'x', 'x', 'y']     match\n+    //     ['x', 'x', 'y', 'z']               no match\n+    my_pattern: Expr =\n+        Array( _* Lit(Char('x')){2} _? )\n+}\n+\n+pattern!{\n+    // matches if expressions that **may or may not** have an else block\n+    // Attn: `If(_, _, _)` matches only ifs that **have** an else block\n+    //\n+    //              | if with else block | if witout else block\n+    // If(_, _, _)  |       match        |       no match\n+    // If(_, _, _?) |       match        |        match\n+    // If(_, _, ()) |      no match      |        match\n+    my_pattern: Expr =\n+        If(_, _, _?)\n+}\n+```\n+\n+#### Named submatch (`<a>#<name>`)\n+\n+```rust\n+pattern!{\n+    // matches character literals and gives the literal the name foo\n+    my_pattern: Expr =\n+        Lit(Char(_)#foo)\n+}\n+\n+pattern!{\n+    // matches character literals and gives the char the name bar\n+    my_pattern: Expr =\n+        Lit(Char(_#bar))\n+}\n+\n+pattern!{\n+    // matches character literals and gives the expression the name baz\n+    my_pattern: Expr =\n+        Lit(Char(_))#baz\n+}\n+```\n+\n+The reason for using named submatches is described in the section [The result\n+type](#the-result-type).\n+\n+### Summary\n+\n+The following table gives an summary of the pattern syntax:\n+\n+| Syntax                  | Concept          | Examples                                   |\n+|-------------------------|------------------|--------------------------------------------|\n+|`_`                      | Any              | `_`                                        |\n+|`<node-name>(<args>)`    | Node             | `Lit(Bool(true))`, `If(_, _, _)`           |\n+|`<lit>`                  | Literal          | `'x'`, `false`, `101`                      |\n+|`<a> \\| <b>`             | Alternation      | `Char(_) \\| Bool(_)`                       |\n+|`()`                     | Empty            | `Array( () )`                              |\n+|`<a> <b>`                | Sequence         | `Tuple( Lit(Bool(_)) Lit(Int(_)) Lit(_) )` |\n+|`<a>*` <br> `<a>+` <br> `<a>?` <br> `<a>{n}` <br> `<a>{n,m}` <br> `<a>{n,}` | Repetition <br> <br> <br> <br> <br><br> | `Array( _* )`, <br> `Block( Semi(_)+ )`, <br> `If(_, _, Block(_)?)`, <br> `Array( Lit(_){10} )`, <br> `Lit(_){5,10}`, <br> `Lit(Bool(_)){10,}` |\n+|`<a>#<name>`             | Named submatch   | `Lit(Int(_))#foo` `Lit(Int(_#bar))`        |\n+\n+\n+## The result type\n+\n+A lot of lints require checks that go beyond what the pattern syntax described\n+above can express. For example, a lint might want to check whether a node was\n+created as part of a macro expansion or whether there's no comment above a node.\n+Another example would be a lint that wants to match two nodes that have the same\n+value (as needed by lints like `almost_swapped`). Instead of allowing users to\n+write these checks into the pattern directly (which might make patterns hard to\n+read), the proposed solution allows users to assign names to parts of a pattern\n+expression. When matching a pattern against a syntax tree node, the return value\n+will contain references to all nodes that were matched by these named\n+subpatterns. This is similar to capture groups in regular expressions.\n+\n+For example, given the following pattern\n+\n+```rust\n+pattern!{\n+    // matches character literals\n+    my_pattern: Expr =\n+        Lit(Char(_#val_inner)#val)#val_outer\n+}\n+```\n+\n+one could get references to the nodes that matched the subpatterns in the\n+following way:\n+\n+```rust\n+...\n+fn check_expr(expr: &syntax::ast::Expr) {\n+    if let Some(result) = my_pattern(expr) {\n+        result.val_inner  // type: &char\n+        result.val        // type: &syntax::ast::Lit\n+        result.val_outer  // type: &syntax::ast::Expr\n+    }\n+}\n+```\n+\n+The types in the `result` struct depend on the pattern. For example, the\n+following pattern\n+\n+```rust\n+pattern!{\n+    // matches arrays of character literals\n+    my_pattern_seq: Expr =\n+        Array( Lit(_)*#foo )\n+}\n+```\n+\n+matches arrays that consist of any number of literal expressions. Because those\n+expressions are named `foo`, the result struct contains a `foo` attribute which\n+is a vector of expressions:\n+\n+```rust\n+...\n+if let Some(result) = my_pattern_seq(expr) {\n+    result.foo        // type: Vec<&syntax::ast::Expr>\n+}\n+```\n+\n+Another result type occurs when a name is only defined in one branch of an\n+alternation:\n+\n+```rust\n+pattern!{\n+    // matches if expression is a boolean or integer literal\n+    my_pattern_alt: Expr =\n+        Lit( Bool(_#bar) | Int(_) )\n+}\n+```\n+\n+In the pattern above, the `bar` name is only defined if the pattern matches a\n+boolean literal. If it matches an integer literal, the name isn't set. To\n+account for this, the result struct's `bar` attribute is an option type:\n+\n+```rust\n+...\n+if let Some(result) = my_pattern_alt(expr) {\n+    result.bar        // type: Option<&bool>\n+}\n+```\n+\n+It's also possible to use a name in multiple alternation branches if they have\n+compatible types:\n+\n+```rust\n+pattern!{\n+    // matches if expression is a boolean or integer literal\n+    my_pattern_mult: Expr =\n+        Lit(_#baz) | Array( Lit(_#baz) )\n+}\n+...\n+if let Some(result) = my_pattern_mult(expr) {\n+    result.baz        // type: &syntax::ast::Lit\n+}\n+```\n+\n+Named submatches are a **flat** namespace and this is intended. In the example\n+above, two different sub-structures are assigned to a flat name. I expect that\n+for most lints, a flat namespace is sufficient and easier to work with than a\n+hierarchical one.\n+\n+#### Two stages\n+\n+Using named subpatterns, users can write lints in two stages. First, a coarse\n+selection of possible matches is produced by the pattern syntax. In the second\n+stage, the named subpattern references can be used to do additional tests like\n+asserting that a node hasn't been created as part of a macro expansion.\n+\n+## Implementing clippy lints using patterns\n+\n+As a \"real-world\" example, I re-implemented the `collapsible_if` lint using\n+patterns. The code can be found\n+[here](https://github.com/fkohlgrueber/rust-clippy-pattern/blob/039b07ecccaf96d6aa7504f5126720d2c9cceddd/clippy_lints/src/collapsible_if.rs#L88-L163).\n+The pattern-based version passes all test cases that were written for\n+`collapsible_if`.\n+\n+\n+# Reference-level explanation\n+\n+## Overview\n+\n+The following diagram shows the dependencies between the main parts of the\n+proposed solution:\n+\n+```\n+                          Pattern syntax\n+                                |\n+                                |  parsing / lowering\n+                                v\n+                           PatternTree\n+                                ^\n+                                |\n+                                |\n+                          IsMatch trait\n+                                |\n+                                |\n+             +---------------+-----------+---------+\n+             |               |           |         |\n+             v               v           v         v\n+        syntax::ast     rustc::hir      syn       ...\n+```\n+\n+The pattern syntax described in the previous section is parsed / lowered into\n+the so-called *PatternTree* data structure that represents a valid syntax tree\n+pattern. Matching a *PatternTree* against an actual syntax tree (e.g. rust ast /\n+hir or the syn ast, ...) is done using the *IsMatch* trait.\n+\n+The *PatternTree* and the *IsMatch* trait are introduced in more detail in the\n+following sections.\n+\n+## PatternTree\n+\n+The core data structure of this RFC is the **PatternTree**.\n+\n+It's a data structure similar to rust's AST / HIR, but with the following\n+differences:\n+\n+- The PatternTree doesn't contain parsing information like `Span`s\n+- The PatternTree can represent alternatives, sequences and optionals\n+\n+The code below shows a simplified version of the current PatternTree:\n+\n+> Note: The current implementation can be found\n+> [here](https://github.com/fkohlgrueber/pattern-matching/blob/dfb3bc9fbab69cec7c91e72564a63ebaa2ede638/pattern-match/src/pattern_tree.rs#L50-L96).\n+\n+\n+```rust\n+pub enum Expr {\n+    Lit(Alt<Lit>),\n+    Array(Seq<Expr>),\n+    Block_(Alt<BlockType>),\n+    If(Alt<Expr>, Alt<BlockType>, Opt<Expr>),\n+    IfLet(\n+        Alt<BlockType>,\n+        Opt<Expr>,\n+    ),\n+}\n+\n+pub enum Lit {\n+    Char(Alt<char>),\n+    Bool(Alt<bool>),\n+    Int(Alt<u128>),\n+}\n+\n+pub enum Stmt {\n+    Expr(Alt<Expr>),\n+    Semi(Alt<Expr>),\n+}\n+\n+pub enum BlockType {\n+    Block(Seq<Stmt>),\n+}\n+```\n+\n+The `Alt`, `Seq` and `Opt` structs look like these:\n+\n+> Note: The current implementation can be found\n+> [here](https://github.com/fkohlgrueber/pattern-matching/blob/dfb3bc9fbab69cec7c91e72564a63ebaa2ede638/pattern-match/src/matchers.rs#L35-L60).\n+\n+```rust\n+pub enum Alt<T> {\n+    Any,\n+    Elmt(Box<T>),\n+    Alt(Box<Self>, Box<Self>),\n+    Named(Box<Self>, ...)\n+}\n+\n+pub enum Opt<T> {\n+    Any,  // anything, but not None\n+    Elmt(Box<T>),\n+    None,\n+    Alt(Box<Self>, Box<Self>),\n+    Named(Box<Self>, ...)\n+}\n+\n+pub enum Seq<T> {\n+    Any,\n+    Empty,\n+    Elmt(Box<T>),\n+    Repeat(Box<Self>, RepeatRange),\n+    Seq(Box<Self>, Box<Self>),\n+    Alt(Box<Self>, Box<Self>),\n+    Named(Box<Self>, ...)\n+}\n+\n+pub struct RepeatRange {\n+    pub start: usize,\n+    pub end: Option<usize>  // exclusive\n+}\n+```\n+\n+## Parsing / Lowering\n+\n+The input of a `pattern!` macro call is parsed into a `ParseTree` first and then\n+lowered to a `PatternTree`.\n+\n+Valid patterns depend on the *PatternTree* definitions. For example, the pattern\n+`Lit(Bool(_)*)` isn't valid because the parameter type of the `Lit` variant of\n+the `Expr` enum is `Any<Lit>` and therefore doesn't support repetition (`*`). As\n+another example, `Array( Lit(_)* )` is a valid pattern because the parameter of\n+`Array` is of type `Seq<Expr>` which allows sequences and repetitions.\n+\n+> Note: names in the pattern syntax correspond to *PatternTree* enum\n+> **variants**. For example, the `Lit` in the pattern above refers to the `Lit`\n+> variant of the `Expr` enum (`Expr::Lit`), not the `Lit` enum.\n+\n+## The IsMatch Trait\n+\n+The pattern syntax and the *PatternTree* are independant of specific syntax tree\n+implementations (rust ast / hir, syn, ...). When looking at the different\n+pattern examples in the previous sections, it can be seen that the patterns\n+don't contain any information specific to a certain syntax tree implementation.\n+In contrast, clippy lints currently match against ast / hir syntax tree nodes\n+and therefore directly depend on their implementation.\n+\n+The connection between the *PatternTree* and specific syntax tree\n+implementations is the `IsMatch` trait. It defines how to match *PatternTree*\n+nodes against specific syntax tree nodes. A simplified implementation of the\n+`IsMatch` trait is shown below:\n+\n+```rust\n+pub trait IsMatch<O> {\n+    fn is_match(&self, other: &'o O) -> bool;\n+}\n+```\n+\n+This trait needs to be implemented on each enum of the *PatternTree* (for the\n+corresponding syntax tree types). For example, the `IsMatch` implementation for\n+matching `ast::LitKind` against the *PatternTree's* `Lit` enum might look like\n+this:\n+\n+```rust\n+impl IsMatch<ast::LitKind> for Lit {\n+    fn is_match(&self, other: &ast::LitKind) -> bool {\n+        match (self, other) {\n+            (Lit::Char(i), ast::LitKind::Char(j)) => i.is_match(j),\n+            (Lit::Bool(i), ast::LitKind::Bool(j)) => i.is_match(j),\n+            (Lit::Int(i), ast::LitKind::Int(j, _)) => i.is_match(j),\n+            _ => false,\n+        }\n+    }\n+}\n+```\n+\n+All `IsMatch` implementations for matching the current *PatternTree* against\n+`syntax::ast` can be found\n+[here](https://github.com/fkohlgrueber/pattern-matching/blob/dfb3bc9fbab69cec7c91e72564a63ebaa2ede638/pattern-match/src/ast_match.rs).\n+\n+\n+# Drawbacks\n+\n+#### Performance\n+\n+The pattern matching code is currently not optimized for performance, so it\n+might be slower than hand-written matching code. Additionally, the two-stage\n+approach (matching against the coarse pattern first and checking for additional\n+properties later) might be slower than the current practice of checking for\n+structure and additional properties in one pass. For example, the following lint\n+\n+```rust\n+pattern!{\n+    pat_if_without_else: Expr =\n+        If(\n+            _,\n+            Block(\n+                Expr( If(_, _, ())#inner )\n+                | Semi( If(_, _, ())#inner )\n+            )#then,\n+            ()\n+        )\n+}\n+...\n+fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n+    if let Some(result) = pat_if_without_else(expr) {\n+        if !block_starts_with_comment(cx, result.then) {\n+            ...\n+        }\n+}\n+```\n+\n+first matches against the pattern and then checks that the `then` block doesn't\n+start with a comment. Using clippy's current approach, it's possible to check\n+for these conditions earlier:\n+\n+```rust\n+fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n+    if_chain! {\n+        if let ast::ExprKind::If(ref check, ref then, None) = expr.node;\n+        if !block_starts_with_comment(cx, then);\n+        if let Some(inner) = expr_block(then);\n+        if let ast::ExprKind::If(ref check_inner, ref content, None) = inner.node;\n+        then {\n+            ...\n+        }\n+    }\n+}\n+```\n+\n+Whether or not this causes performance regressions depends on actual patterns.\n+If it turns out to be a problem, the pattern matching algorithms could be\n+extended to allow \"early filtering\" (see the [Early Filtering](#early-filtering)\n+section in Future Possibilities).\n+\n+That being said, I don't see any conceptual limitations regarding pattern\n+matching performance.\n+\n+#### Applicability\n+\n+Even though I'd expect that a lot of lints can be written using the proposed\n+pattern syntax, it's unlikely that all lints can be expressed using patterns. I\n+suspect that there will still be lints that need to be implemented by writing\n+custom pattern matching code. This would lead to mix within clippy's codebase\n+where some lints are implemented using patterns and others aren't. This\n+inconsistency might be considered a drawback.\n+\n+\n+# Rationale and alternatives\n+\n+Specifying lints using syntax tree patterns has a couple of advantages compared\n+to the current approach of manually writing matching code. First, syntax tree\n+patterns allow users to describe patterns in a simple and expressive way. This\n+makes it easier to write new lints for both novices and experts and also makes\n+reading / modifying existing lints simpler.\n+\n+Another advantage is that lints are independent of specific syntax tree\n+implementations (e.g. AST / HIR, ...). When these syntax tree implementations\n+change, only the `IsMatch` trait implementations need to be adapted and existing\n+lints can remain unchanged. This also means that if the `IsMatch` trait\n+implementations were integrated into the compiler, updating the `IsMatch`\n+implementations would be required for the compiler to compile successfully. This\n+could reduce the number of times clippy breaks because of changes in the\n+compiler. Another advantage of the pattern's independence is that converting an\n+`EarlyLintPass` lint into a `LatePassLint` wouldn't require rewriting the whole\n+pattern matching code. In fact, the pattern might work just fine without any\n+adaptions.\n+\n+\n+## Alternatives\n+\n+### Rust-like pattern syntax\n+\n+The proposed pattern syntax requires users to know the structure of the\n+`PatternTree` (which is very similar to the AST's / HIR's structure) and also\n+the pattern syntax. An alternative would be to introduce a pattern syntax that\n+is similar to actual Rust syntax (probably like the `quote!` macro). For\n+example, a pattern that matches `if` expressions that have `false` in their\n+condition could look like this:\n+\n+```rust\n+if false {\n+    #[*]\n+}\n+```\n+\n+#### Problems\n+\n+Extending Rust syntax (which is quite complex by itself) with additional syntax\n+needed for specifying patterns (alternations, sequences, repetisions, named\n+submatches, ...) might become difficult to read and really hard to parse\n+properly.\n+\n+For example, a pattern that matches a binary operation that has `0` on both\n+sides might look like this:\n+\n+```\n+0 #[*:BinOpKind] 0\n+```\n+\n+Now consider this slightly more complex example:\n+\n+```\n+1 + 0 #[*:BinOpKind] 0\n+```\n+\n+The parser would need to know the precedence of `#[*:BinOpKind]` because it\n+affects the structure of the resulting AST. `1 + 0 + 0` is parsed as `(1 + 0) +\n+0` while `1 + 0 * 0` is parsed as `1 + (0 * 0)`. Since the pattern could be any\n+`BinOpKind`, the precedence cannot be known in advance.\n+\n+Another example of a problem would be named submatches. Take a look at this\n+pattern:\n+\n+```rust\n+fn test() {\n+    1 #foo\n+}\n+```\n+\n+Which node is `#foo` referring to? `int`, `ast::Lit`, `ast::Expr`, `ast::Stmt`?\n+Naming subpatterns in a rust-like syntax is difficult because a lot of AST nodes\n+don't have a syntactic element that can be used to put the name tag on. In these\n+situations, the only sensible option would be to assign the name tag to the\n+outermost node (`ast::Stmt` in the example above), because the information of\n+all child nodes can be retrieved through the outermost node. The problem with\n+this then would be that accessing inner nodes (like `ast::Lit`) would again\n+require manual pattern matching.\n+\n+In general, Rust syntax contains a lot of code structure implicitly. This\n+structure is reconstructed during parsing (e.g. binary operations are\n+reconstructed using operator precedence and left-to-right) and is one of the\n+reasons why parsing is a complex task. The advantage of this approach is that\n+writing code is simpler for users.\n+\n+When writing *syntax tree patterns*, each element of the hierarchy might have\n+alternatives, repetitions, etc.. Respecting that while still allowing\n+human-friendly syntax that contains structure implicitly seems to be really\n+complex, if not impossible.\n+\n+Developing such a syntax would also require to maintain a custom parser that is\n+at least as complex as the Rust parser itself. Additionally, future changes in\n+the Rust syntax might be incompatible with such a syntax.\n+\n+In summary, I think that developing such a syntax would introduce a lot of\n+complexity to solve a relatively minor problem.\n+\n+The issue of users not knowing about the *PatternTree* structure could be solved\n+by a tool that, given a rust program, generates a pattern that matches only this\n+program (similar to the clippy author lint).\n+\n+For some simple cases (like the first example above), it might be possible to\n+successfully mix Rust and pattern syntax. This space could be further explored\n+in a future extension.\n+\n+# Prior art\n+\n+The pattern syntax is heavily inspired by regular expressions (repetitions,\n+alternatives, sequences, ...).\n+\n+From what I've seen until now, other linters also implement lints that directly\n+work on syntax tree data structures, just like clippy does currently. I would\n+therefore consider the pattern syntax to be *new*, but please correct me if I'm\n+wrong.\n+\n+# Unresolved questions\n+\n+#### How to handle multiple matches?\n+\n+When matching a syntax tree node against a pattern, there are possibly multiple\n+ways in which the pattern can be matched. A simple example of this would be the\n+following pattern:\n+\n+```rust\n+pattern!{\n+    my_pattern: Expr =\n+        Array( _* Lit(_)+#literals)\n+}\n+```\n+\n+This pattern matches arrays that end with at least one literal. Now given the\n+array `[x, 1, 2]`, should `1` be matched as part of the `_*` or the `Lit(_)+`\n+part of the pattern? The difference is important because the named submatch\n+`#literals` would contain 1 or 2 elements depending how the pattern is matched.\n+In regular expressions, this problem is solved by matching \"greedy\" by default\n+and \"non-greedy\" optionally.\n+\n+I haven't looked much into this yet because I don't know how relevant it is for\n+most lints. The current implementation simply returns the first match it finds.\n+\n+# Future possibilities\n+\n+#### Implement rest of Rust Syntax\n+\n+The current project only implements a small part of the Rust syntax. In the\n+future, this should incrementally be extended to more syntax to allow\n+implementing more lints. Implementing more of the Rust syntax requires extending\n+the `PatternTree` and `IsMatch` implementations, but should be relatively\n+straight-forward.\n+\n+#### Early filtering\n+\n+As described in the *Drawbacks/Performance* section, allowing additional checks\n+during the pattern matching might be beneficial.\n+\n+The pattern below shows how this could look like:\n+\n+```rust\n+pattern!{\n+    pat_if_without_else: Expr =\n+        If(\n+            _,\n+            Block(\n+                Expr( If(_, _, ())#inner )\n+                | Semi( If(_, _, ())#inner )\n+            )#then,\n+            ()\n+        )\n+    where\n+        !in_macro(#then.span);\n+}\n+```\n+\n+The difference compared to the currently proposed two-stage filtering is that\n+using early filtering, the condition (`!in_macro(#then.span)` in this case)\n+would be evaluated as soon as the `Block(_)#then` was matched.\n+\n+Another idea in this area would be to introduce a syntax for backreferences.\n+They could be used to require that multiple parts of a pattern should match the\n+same value. For example, the `assign_op_pattern` lint that searches for `a = a\n+op b` and recommends changing it to `a op= b` requires that both occurrances of\n+`a` are the same. Using `=#...` as syntax for backreferences, the lint could be\n+implemented like this:\n+\n+```rust\n+pattern!{\n+    assign_op_pattern: Expr =\n+        Assign(_#target, Binary(_, =#target, _)\n+}\n+```\n+\n+#### Match descendant\n+\n+A lot of lints currently implement custom visitors that check whether any\n+subtree (which might not be a direct descendant) of the current node matches\n+some properties. This cannot be expressed with the proposed pattern syntax.\n+Extending the pattern syntax to allow patterns like \"a function that contains at\n+least two return statements\" could be a practical addition.\n+\n+#### Negation operator for alternatives\n+\n+For patterns like \"a literal that is not a boolean literal\" one currently needs\n+to list all alternatives except the boolean case. Introducing a negation\n+operator that allows to write `Lit(!Bool(_))` might be a good idea. This pattern\n+would be eqivalent to `Lit( Char(_) | Int(_) )` (given that currently only three\n+literal types are implemented).\n+\n+#### Functional composition\n+\n+Patterns currently don't have any concept of composition. This leads to\n+repetitions within patterns. For example, one of the collapsible-if patterns\n+currently has to be written like this:\n+\n+```rust\n+pattern!{\n+    pat_if_else: Expr =\n+        If(\n+            _,\n+            _,\n+            Block_(\n+                Block(\n+                    Expr((If(_, _, _?) | IfLet(_, _?))#else_) |\n+                    Semi((If(_, _, _?) | IfLet(_, _?))#else_)\n+                )#block_inner\n+            )#block\n+        ) |\n+        IfLet(\n+            _,\n+            Block_(\n+                Block(\n+                    Expr((If(_, _, _?) | IfLet(_, _?))#else_) |\n+                    Semi((If(_, _, _?) | IfLet(_, _?))#else_)\n+                )#block_inner\n+            )#block\n+        )\n+}\n+```\n+\n+If patterns supported defining functions of subpatterns, the code could be\n+simplified as follows:\n+\n+```rust\n+pattern!{\n+    fn expr_or_semi(expr: Expr) -> Stmt {\n+        Expr(expr) | Semi(expr)\n+    }\n+    fn if_or_if_let(then: Block, else: Opt<Expr>) -> Expr {\n+        If(_, then, else) | IfLet(then, else)\n+    }\n+    pat_if_else: Expr =\n+        if_or_if_let(\n+            _,\n+            Block_(\n+                Block(\n+                    expr_or_semi( if_or_if_let(_, _?)#else_ )\n+                )#block_inner\n+            )#block\n+        )\n+}\n+```\n+\n+Additionally, common patterns like `expr_or_semi` could be shared between\n+different lints.\n+\n+#### Clippy Pattern Author\n+\n+Another improvement could be to create a tool that, given some valid Rust\n+syntax, generates a pattern that matches this syntax exactly. This would make\n+starting to write a pattern easier. A user could take a look at the patterns\n+generated for a couple of Rust code examples and use that information to write a\n+pattern that matches all of them.\n+\n+This is similar to clippy's author lint.\n+\n+#### Supporting other syntaxes\n+\n+Most of the proposed system is language-agnostic. For example, the pattern\n+syntax could also be used to describe patterns for other programming languages.\n+\n+In order to support other languages' syntaxes, one would need to implement\n+another `PatternTree` that sufficiently describes the languages' AST and\n+implement `IsMatch` for this `PatternTree` and the languages' AST.\n+\n+One aspect of this is that it would even be possible to write lints that work on\n+the pattern syntax itself. For example, when writing the following pattern\n+\n+\n+```rust\n+pattern!{\n+    my_pattern: Expr =\n+        Array( Lit(Bool(false)) Lit(Bool(false)) )\n+}\n+```\n+\n+a lint that works on the pattern syntax's AST could suggest using this pattern\n+instead:\n+\n+```rust\n+pattern!{\n+    my_pattern: Expr =\n+        Array( Lit(Bool(false)){2} )\n+}\n+```\n+\n+In the future, clippy could use this system to also provide lints for custom\n+syntaxes like those found in macros."}, {"sha": "9161986a7b7745b37e5a561cc9c3fd531942f2bc", "filename": "rfcs/0001-syntax-tree-patterns.md", "status": "removed", "additions": 0, "deletions": 789, "changes": 789, "blob_url": "https://github.com/rust-lang/rust/blob/efadb55733f1f852e18427376d3c5268139225cd/rfcs%2F0001-syntax-tree-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/efadb55733f1f852e18427376d3c5268139225cd/rfcs%2F0001-syntax-tree-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rfcs%2F0001-syntax-tree-patterns.md?ref=efadb55733f1f852e18427376d3c5268139225cd", "patch": "@@ -1,789 +0,0 @@\n-<!--lint disable maximum-line-length-->\n-\n-- Feature Name: syntax-tree-patterns\n-- Start Date: 2019-03-12\n-- RFC PR: (leave this empty)\n-- Rust Issue: (leave this empty)\n-\n-> Note: This project is part of my Master's Thesis (supervised by [@oli-obk](https://github.com/oli-obk))\n-\n-# Summary\n-\n-Introduce a domain-specific language (similar to regular expressions) that allows to describe lints using *syntax tree patterns*.\n-\n-\n-# Motivation\n-\n-\n-Finding parts of a syntax tree (AST, HIR, ...) that have certain properties (e.g. \"*an if that has a block as its condition*\") is a major task when writing lints. For non-trivial lints, it often requires nested pattern matching of AST / HIR nodes. For example, testing that an expression is a boolean literal requires the following checks:\n-\n-```\n-if let ast::ExprKind::Lit(lit) = &expr.node {\n-    if let ast::LitKind::Bool(_) = &lit.node {\n-        ...\n-    }\n-}\n-```\n-\n-Writing this kind of matching code quickly becomes a complex task and the resulting code is often hard to comprehend. The code below shows a simplified version of the pattern matching required by the `collapsible_if` lint:\n-\n-```\n-// simplified version of the collapsible_if lint\n-if let ast::ExprKind::If(check, then, None) = &expr.node {\n-    if then.stmts.len() == 1 {\n-        if let ast::StmtKind::Expr(inner) | ast::StmtKind::Semi(inner) = &then.stmts[0].node {\n-            if let ast::ExprKind::If(check_inner, content, None) = &inner.node {\n-                ...\n-            }\n-        }\n-    }\n-}\n-```\n-\n-The `if_chain` macro can improve readability by flattening the nested if statements, but the resulting code is still quite hard to read:\n-\n-```\n-// simplified version of the collapsible_if lint\n-if_chain! {\n-    if let ast::ExprKind::If(check, then, None) = &expr.node;\n-    if then.stmts.len() == 1;\n-    if let ast::StmtKind::Expr(inner) | ast::StmtKind::Semi(inner) = &then.stmts[0].node;\n-    if let ast::ExprKind::If(check_inner, content, None) = &inner.node;\n-    then {\n-        ...\n-    }\n-}\n-```\n-\n-The code above matches if expressions that contain only another if expression (where both ifs don't have an else branch). While it's easy to explain what the lint does, it's hard to see that from looking at the code samples above.\n-\n-Following the motivation above, the first goal this RFC is to **simplify writing and reading lints**. \n-\n-The second part of the motivation is clippy's dependence on unstable compiler-internal data structures. Clippy lints are currently written against the compiler's AST / HIR which means that even small changes in these data structures might break a lot of lints. The second goal of this RFC is to **make lints independant of the compiler's AST / HIR data structures**.\n-\n-# Approach\n-\n-A lot of complexity in writing lints currently seems to come from having to manually implement the matching logic (see code samples above). It's an imparative style that describes *how* to match a syntax tree node instead of specifying *what* should be matched against declaratively. In other areas, it's common to use declarative patterns to describe desired information and let the implementation do the actual matching. A well-known example of this approach are [regular expressions](https://en.wikipedia.org/wiki/Regular_expression). Instead of writing code that detects certain character sequences, one can describe a search pattern using a domain-specific language and search for matches using that pattern. The advantage of using a declarative domain-specific language is that its limited domain (e.g. matching character sequences in the case of regular expressions) allows to express entities in that domain in a very natural and expressive way.\n-\n-While regular expressions are very useful when searching for patterns in flat character sequences, they cannot easily be applied to hierarchical data structures like syntax trees. This RFC therefore proposes a pattern matching system that is inspired by regular expressions and designed for hierarchical syntax trees.\n-\n-# Guide-level explanation\n-\n-This proposal adds a `pattern!` macro that can be used to specify a syntax tree pattern to search for. A simple pattern is shown below:\n-\n-```\n-pattern!{\n-    my_pattern: Expr = \n-        Lit(Bool(false))\n-}\n-```\n-\n-This macro call defines a pattern named `my_pattern` that can be matched against an `Expr` syntax tree node. The actual pattern (`Lit(Bool(false))` in this case) defines which syntax trees should match the pattern. This pattern matches expressions that are boolean literals with value `false`.\n-\n-The pattern can then be used to implement lints in the following way:\n-\n-```\n-...\n-\n-impl EarlyLintPass for MyAwesomeLint {\n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &syntax::ast::Expr) {\n-        \n-        if my_pattern(expr).is_some() {\n-            cx.span_lint(\n-                MY_AWESOME_LINT,\n-                expr.span,\n-                \"This is a match for a simple pattern. Well done!\",\n-            );\n-        }\n-        \n-    }\n-}\n-```\n-\n-The `pattern!` macro call expands to a function `my_pattern` that expects a syntax tree expression as its argument and returns an `Option` that indicates whether the pattern matched.\n-\n-> Note: The result type is explained in more detail in [a later section](#the-result-type). For now, it's enough to know that the result is `Some` if the pattern matched and `None` otherwise.\n-\n-## Pattern syntax\n-\n-The following examples demonstate the pattern syntax:\n-\n-\n-#### Any (`_`)\n-\n-The simplest pattern is the any pattern. It matches anything and is therefore similar to regex's `*`.\n-\n-```\n-pattern!{\n-    // matches any expression\n-    my_pattern: Expr = \n-        _\n-}\n-```\n-\n-#### Node (`<node-name>(<args>)`)\n-\n-Nodes are used to match a specific variant of an AST node. A node has a name and a number of arguments that depends on the node type. For example, the `Lit` node has a single argument that describes the type of the literal. As another example, the `If` node has three arguments describing the if's condition, then block and else block.\n-\n-```\n-pattern!{\n-    // matches any expression that is a literal\n-    my_pattern: Expr = \n-        Lit(_)\n-}\n-\n-pattern!{\n-    // matches any expression that is a boolean literal\n-    my_pattern: Expr = \n-        Lit(Bool(_))\n-}\n-\n-pattern!{\n-    // matches if expressions that have a boolean literal in their condition\n-    // Note: The `_?` syntax here means that the else branch is optional and can be anything. \n-    //       This is discussed in more detail in the section `Repetition`.\n-    my_pattern: Expr = \n-        If( Lit(Bool(_)) , _, _?)\n-}\n-```\n-\n-\n-#### Literal (`<lit>`)\n-\n-A pattern can also contain Rust literals. These literals match themselves.\n-\n-```\n-pattern!{\n-    // matches the boolean literal false\n-    my_pattern: Expr = \n-        Lit(Bool(false))\n-}\n-\n-pattern!{\n-    // matches the character literal 'x'\n-    my_pattern: Expr = \n-        Lit(Char('x'))\n-}\n-```\n-\n-#### Alternations (`a | b`)\n-\n-```\n-pattern!{\n-    // matches if the literal is a boolean or integer literal\n-    my_pattern: Lit = \n-        Bool(_) | Int(_)\n-}\n-\n-pattern!{\n-    // matches if the expression is a char literal with value 'x' or 'y'\n-    my_pattern: Expr = \n-        Lit( Char('x' | 'y') )\n-}\n-```\n-\n-#### Empty (`()`)\n-\n-The empty pattern represents an empty sequence or the `None` variant of an optional.\n-\n-```\n-pattern!{\n-    // matches if the expression is an empty array\n-    my_pattern: Expr = \n-        Array( () )\n-}\n-\n-pattern!{\n-    // matches if expressions that don't have an else clause\n-    my_pattern: Expr = \n-        If(_, _, ())\n-}\n-```\n-\n-#### Sequence (`<a> <b>`)\n-\n-```\n-pattern!{\n-    // matches the array [true, false]\n-    my_pattern: Expr = \n-        Array( Lit(Bool(true)) Lit(Bool(false)) )\n-}\n-```\n-\n-#### Repetition (`<a>*`, `<a>+`, `<a>?`, `<a>{n}`, `<a>{n,m}`, `<a>{n,}`)\n-\n-Elements may be repeated. The syntax for specifying repetitions is identical to [regex's syntax](https://docs.rs/regex/1.1.2/regex/#repetitions).\n-\n-```\n-pattern!{\n-    // matches arrays that contain 2 'x's as their last or second-last elements\n-    // Examples:\n-    //     ['x', 'x']                         match\n-    //     ['x', 'x', 'y']                    match\n-    //     ['a', 'b', 'c', 'x', 'x', 'y']     match\n-    //     ['x', 'x', 'y', 'z']               no match\n-    my_pattern: Expr = \n-        Array( _* Lit(Char('x')){2} _? )\n-}\n-\n-pattern!{\n-    // matches if expressions that **may or may not** have an else block\n-    // Attn: `If(_, _, _)` matches only ifs that **have** an else block\n-    //\n-    //              | if with else block | if witout else block\n-    // If(_, _, _)  |       match        |       no match\n-    // If(_, _, _?) |       match        |        match\n-    // If(_, _, ()) |      no match      |        match\n-    my_pattern: Expr = \n-        If(_, _, _?)\n-}\n-```\n-\n-#### Named submatch (`<a>#<name>`)\n-\n-```\n-pattern!{\n-    // matches character literals and gives the literal the name foo\n-    my_pattern: Expr = \n-        Lit(Char(_)#foo)\n-}\n-\n-pattern!{\n-    // matches character literals and gives the char the name bar\n-    my_pattern: Expr = \n-        Lit(Char(_#bar))\n-}\n-\n-pattern!{\n-    // matches character literals and gives the expression the name baz\n-    my_pattern: Expr = \n-        Lit(Char(_))#baz\n-}\n-```\n-\n-The reason for using named submatches is described in the section [The result type](#the-result-type).\n-\n-### Summary\n-\n-The following table gives an summary of the pattern syntax:\n-\n-| Syntax                  | Concept          | Examples                                   |\n-|-------------------------|------------------|--------------------------------------------|\n-|`_`                      | Any              | `_`                                        |\n-|`<node-name>(<args>)`    | Node             | `Lit(Bool(true))`, `If(_, _, _)`           |\n-|`<lit>`                  | Literal          | `'x'`, `false`, `101`                      |\n-|`<a> \\| <b>`             | Alternation      | `Char(_) \\| Bool(_)`                       |\n-|`()`                     | Empty            | `Array( () )`                              |\n-|`<a> <b>`                | Sequence         | `Tuple( Lit(Bool(_)) Lit(Int(_)) Lit(_) )` |\n-|`<a>*` <br> `<a>+` <br> `<a>?` <br> `<a>{n}` <br> `<a>{n,m}` <br> `<a>{n,}` | Repetition <br> <br> <br> <br> <br><br> | `Array( _* )`, <br> `Block( Semi(_)+ )`, <br> `If(_, _, Block(_)?)`, <br> `Array( Lit(_){10} )`, <br> `Lit(_){5,10}`, <br> `Lit(Bool(_)){10,}` |\n-|`<a>#<name>`             | Named submatch   | `Lit(Int(_))#foo` `Lit(Int(_#bar))`        |\n-\n-\n-## The result type\n-\n-A lot of lints require checks that go beyond what the pattern syntax described above can express. For example, a lint might want to check whether a node was created as part of a macro expansion or whether there's no comment above a node. Another example would be a lint that wants to match two nodes that have the same value (as needed by lints like `almost_swapped`). Instead of allowing users to write these checks into the pattern directly (which might make patterns hard to read), the proposed solution allows users to assign names to parts of a pattern expression. When matching a pattern against a syntax tree node, the return value will contain references to all nodes that were matched by these named subpatterns. This is similar to capture groups in regular expressions.\n-\n-For example, given the following pattern\n-\n-```\n-pattern!{\n-    // matches character literals\n-    my_pattern: Expr = \n-        Lit(Char(_#val_inner)#val)#val_outer\n-}\n-```\n-\n-one could get references to the nodes that matched the subpatterns in the following way:\n-\n-```\n-...\n-fn check_expr(expr: &syntax::ast::Expr) {\n-    if let Some(result) = my_pattern(expr) {\n-        result.val_inner  // type: &char\n-        result.val        // type: &syntax::ast::Lit\n-        result.val_outer  // type: &syntax::ast::Expr\n-    }\n-}\n-```\n-\n-The types in the `result` struct depend on the pattern. For example, the following pattern\n-\n-```\n-pattern!{\n-    // matches arrays of character literals\n-    my_pattern_seq: Expr = \n-        Array( Lit(_)*#foo )\n-}\n-```\n-\n-matches arrays that consist of any number of literal expressions. Because those expressions are named `foo`, the result struct contains a `foo` attribute which is a vector of expressions:\n-\n-```\n-...\n-if let Some(result) = my_pattern_seq(expr) {\n-    result.foo        // type: Vec<&syntax::ast::Expr>\n-}\n-```\n-\n-Another result type occurs when a name is only defined in one branch of an alternation:\n-\n-```\n-pattern!{\n-    // matches if expression is a boolean or integer literal\n-    my_pattern_alt: Expr = \n-        Lit( Bool(_#bar) | Int(_) )\n-}\n-```\n-\n-In the pattern above, the `bar` name is only defined if the pattern matches a boolean literal. If it matches an integer literal, the name isn't set. To account fot this, the result struct's `bar` attribute is an option type:\n-\n-```\n-...\n-if let Some(result) = my_pattern_alt(expr) {\n-    result.bar        // type: Option<&bool>\n-}\n-```\n-\n-It's also possible to use a name in multiple alternation branches if they have compatible types:\n-\n-```\n-pattern!{\n-    // matches if expression is a boolean or integer literal\n-    my_pattern_mult: Expr = \n-        Lit(_#baz) | Array( Lit(_#baz) )\n-}\n-...\n-if let Some(result) = my_pattern_mult(expr) {\n-    result.baz        // type: &syntax::ast::Lit\n-}\n-```\n-\n-Named submatches are a **flat** namespace and this is intended. In the example above, two different sub-structures are assigned to a flat name. I expect that for most lints, a flat namespace is sufficient and easier to work with than a hierarchical one.\n-\n-#### Two stages\n-\n-Using named subpatterns, users can write lints in two stages. First, a coarse selection of possible matches is produced by the pattern syntax. In the second stage, the named subpattern references can be used to do additional tests like asserting that a node hasn't been created as part of a macro expansion.\n-\n-## Implementing clippy lints using patterns\n-\n-As a \"real-world\" example, I re-implemented the `collapsible_if` lint using patterns. The code can be found [here](https://github.com/fkohlgrueber/rust-clippy-pattern/blob/039b07ecccaf96d6aa7504f5126720d2c9cceddd/clippy_lints/src/collapsible_if.rs#L88-L163). The pattern-based version passes all test cases that were written for `collapsible_if`.\n-\n-\n-# Reference-level explanation\n-\n-## Overview\n-\n-The following diagram shows the dependencies between the main parts of the proposed solution:\n-\n-```\n-                          Pattern syntax                                     \n-                                |                                           \n-                                |  parsing / lowering                       \n-                                v                                           \n-                           PatternTree                                      \n-                                ^                                             \n-                                |                                             \n-                                |                                             \n-                          IsMatch trait                                       \n-                                |                                             \n-                                |                                             \n-             +---------------+-----------+---------+                      \n-             |               |           |         |                      \n-             v               v           v         v                      \n-        syntax::ast     rustc::hir      syn       ...               \n-```\n-\n-The pattern syntax described in the previous section is parsed / lowered into the so-called *PatternTree* data structure that represents a valid syntax tree pattern. Matching a *PatternTree* against an actual syntax tree (e.g. rust ast / hir or the syn ast, ...) is done using the *IsMatch* trait.\n-\n-The *PatternTree* and the *IsMatch* trait are introduced in more detail in the following sections.\n-\n-## PatternTree\n-\n-The core data structure of this RFC is the **PatternTree**. \n-\n-It's a data structure similar to rust's AST / HIR, but with the following differences:\n-\n-- The PatternTree doesn't contain parsing information like `Span`s\n-- The PatternTree can represent alternatives, sequences and optionals\n-\n-The code below shows a simplified version of the current PatternTree:\n-\n-> Note: The current implementation can be found [here](https://github.com/fkohlgrueber/pattern-matching/blob/dfb3bc9fbab69cec7c91e72564a63ebaa2ede638/pattern-match/src/pattern_tree.rs#L50-L96).\n-\n-\n-```\n-pub enum Expr {\n-    Lit(Alt<Lit>),\n-    Array(Seq<Expr>),\n-    Block_(Alt<BlockType>),\n-    If(Alt<Expr>, Alt<BlockType>, Opt<Expr>),\n-    IfLet(\n-        Alt<BlockType>,\n-        Opt<Expr>,\n-    ),\n-}\n-\n-pub enum Lit {\n-    Char(Alt<char>),\n-    Bool(Alt<bool>),\n-    Int(Alt<u128>),\n-}\n-\n-pub enum Stmt {\n-    Expr(Alt<Expr>),\n-    Semi(Alt<Expr>),\n-}\n-\n-pub enum BlockType {\n-    Block(Seq<Stmt>),\n-}\n-```\n-\n-The `Alt`, `Seq` and `Opt` structs look like these:\n-\n-> Note: The current implementation can be found [here](https://github.com/fkohlgrueber/pattern-matching/blob/dfb3bc9fbab69cec7c91e72564a63ebaa2ede638/pattern-match/src/matchers.rs#L35-L60).\n-\n-```\n-pub enum Alt<T> {\n-    Any,\n-    Elmt(Box<T>),\n-    Alt(Box<Self>, Box<Self>),\n-    Named(Box<Self>, ...)\n-}\n-\n-pub enum Opt<T> {\n-    Any,  // anything, but not None\n-    Elmt(Box<T>),\n-    None,\n-    Alt(Box<Self>, Box<Self>),\n-    Named(Box<Self>, ...)\n-}\n-\n-pub enum Seq<T> {\n-    Any,\n-    Empty,\n-    Elmt(Box<T>),\n-    Repeat(Box<Self>, RepeatRange),\n-    Seq(Box<Self>, Box<Self>),\n-    Alt(Box<Self>, Box<Self>),\n-    Named(Box<Self>, ...)\n-}\n-\n-pub struct RepeatRange {\n-    pub start: usize,\n-    pub end: Option<usize>  // exclusive\n-}\n-```\n-\n-## Parsing / Lowering\n-\n-The input of a `pattern!` macro call is parsed into a `ParseTree` first and then lowered to a `PatternTree`.\n-\n-Valid patterns depend on the *PatternTree* definitions. For example, the pattern `Lit(Bool(_)*)` isn't valid because the parameter type of the `Lit` variant of the `Expr` enum is `Any<Lit>` and therefore doesn't support repetition (`*`). As another example, `Array( Lit(_)* )` is a valid pattern because the parameter of `Array` is of type `Seq<Expr>` which allows sequences and repetitions.\n-\n-> Note: names in the pattern syntax correspond to *PatternTree* enum **variants**. For example, the `Lit` in the pattern above refers to the `Lit` variant of the `Expr` enum (`Expr::Lit`), not the `Lit` enum.\n-\n-## The IsMatch Trait\n-\n-The pattern syntax and the *PatternTree* are independant of specific syntax tree implementations (rust ast / hir, syn, ...). When looking at the different pattern examples in the previous sections, it can be seen that the patterns don't contain any information specific to a certain syntax tree implementation. In contrast, clippy lints currently match against ast / hir syntax tree nodes and therefore directly depend on their implementation.\n-\n-The connection between the *PatternTree* and specific syntax tree implementations is the `IsMatch` trait. It defines how to match *PatternTree* nodes against specific syntax tree nodes. A simplified implementation of the `IsMatch` trait is shown below:\n-\n-```\n-pub trait IsMatch<O> {\n-    fn is_match(&self, other: &'o O) -> bool;\n-}\n-```\n-\n-This trait needs to be implemented on each enum of the *PatternTree* (for the corresponding syntax tree types). For example, the `IsMatch` implementation for matching `ast::LitKind` against the *PatternTree's* `Lit` enum might look like this:\n-\n-```\n-impl IsMatch<ast::LitKind> for Lit {\n-    fn is_match(&self, other: &ast::LitKind) -> bool {\n-        match (self, other) {\n-            (Lit::Char(i), ast::LitKind::Char(j)) => i.is_match(j),\n-            (Lit::Bool(i), ast::LitKind::Bool(j)) => i.is_match(j),\n-            (Lit::Int(i), ast::LitKind::Int(j, _)) => i.is_match(j),\n-            _ => false,\n-        }\n-    }\n-}\n-```\n-\n-All `IsMatch` implementations for matching the current *PatternTree* against `syntax::ast` can be found [here](https://github.com/fkohlgrueber/pattern-matching/blob/dfb3bc9fbab69cec7c91e72564a63ebaa2ede638/pattern-match/src/ast_match.rs).\n-\n-\n-# Drawbacks\n-\n-#### Performance\n-\n-The pattern matching code is currently not optimized for performance, so it might be slower than hand-written matching code.\n-Additionally, the two-stage approach (matching against the coarse pattern first and checking for additional properties later) might be slower than the current practice of checking for structure and additional properties in one pass. For example, the following lint\n-\n-```\n-pattern!{\n-    pat_if_without_else: Expr = \n-        If(\n-            _,\n-            Block(\n-                Expr( If(_, _, ())#inner )\n-                | Semi( If(_, _, ())#inner ) \n-            )#then, \n-            ()\n-        )\n-}\n-...\n-fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n-    if let Some(result) = pat_if_without_else(expr) {\n-        if !block_starts_with_comment(cx, result.then) {\n-            ...\n-        }\n-}\n-```\n-\n-first matches against the pattern and then checks that the `then` block doesn't start with a comment. Using clippy's current approach, it's possible to check for these conditions earlier:\n-\n-```\n-fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n-    if_chain! {\n-        if let ast::ExprKind::If(ref check, ref then, None) = expr.node;\n-        if !block_starts_with_comment(cx, then);\n-        if let Some(inner) = expr_block(then);\n-        if let ast::ExprKind::If(ref check_inner, ref content, None) = inner.node;\n-        then {\n-            ...\n-        }\n-    }\n-}\n-```\n-\n-Whether or not this causes performance regressions depends on actual patterns. If it turns out to be a problem, the pattern matching algorithms could be extended to allow \"early filtering\" (see the [Early Filtering](#early-filtering) section in Future Possibilities).\n-\n-That being said, I don't see any conceptual limitations regarding pattern matching performance.\n-\n-#### Applicability\n-\n-Even though I'd expect that a lot of lints can be written using the proposed pattern syntax, it's unlikely that all lints can be expressed using patterns. I suspect that there will still be lints that need to be implemented by writing custom pattern matching code. This would lead to mix within clippy's codebase where some lints are implemented using patterns and others aren't. This inconsistency might be considered a drawback.\n-\n-\n-# Rationale and alternatives\n-\n-Specifying lints using syntax tree patterns has a couple of advantages compared to the current approach of manually writing matching code. First, syntax tree patterns allow users to describe patterns in a simple and expressive way. This makes it easier to write new lints for both novices and experts and also makes reading / modifying existing lints simpler. \n-\n-Another advantage is that lints are independent of specific syntax tree implementations (e.g. AST / HIR, ...). When these syntax tree implementations change, only the `IsMatch` trait implementations need to be adapted and existing lints can remain unchanged. This also means that if the `IsMatch` trait implementations were integrated into the compiler, updating the `IsMatch` implementations would be required for the compiler to compile successfully. This could reduce the number of times clippy breaks because of changes in the compiler. Another advantage of the pattern's independence is that converting an `EarlyLintPass` lint into a `LatePassLint` wouldn't require rewriting the whole pattern matching code. In fact, the pattern might work just fine without any adaptions.\n-\n-\n-\n-## Alternatives\n-\n-### Rust-like pattern syntax\n-\n-The proposed pattern syntax requires users to know the structure of the `PatternTree` (which is very similar to the AST's / HIR's structure) and also the pattern syntax. An alternative would be to introduce a pattern syntax that is similar to actual Rust syntax (probably like the `quote!` macro). For example, a pattern that matches `if` expressions that have `false` in their condition could look like this:\n-\n-```\n-if false {\n-    #[*]\n-}\n-```\n-\n-#### Problems\n-\n-Extending Rust syntax (which is quite complex by itself) with additional syntax needed for specifying patterns (alternations, sequences, repetisions, named submatches, ...) might become difficult to read and really hard to parse properly.\n-\n-For example, a pattern that matches a binary operation that has `0` on both sides might look like this:\n-\n-```\n-0 #[*:BinOpKind] 0\n-```\n-\n-Now consider this slightly more complex example:\n-\n-```\n-1 + 0 #[*:BinOpKind] 0\n-```\n-\n-The parser would need to know the precedence of `#[*:BinOpKind]` because it affects the structure of the resulting AST. `1 + 0 + 0` is parsed as `(1 + 0) + 0` while `1 + 0 * 0` is parsed as `1 + (0 * 0)`. Since the pattern could be any `BinOpKind`, the precedence cannot be known in advance.\n-\n-Another example of a problem would be named submatches. Take a look at this pattern:\n-\n-```\n-fn test() {\n-    1 #foo\n-}\n-```\n-\n-Which node is `#foo` referring to? `int`, `ast::Lit`, `ast::Expr`, `ast::Stmt`? Naming subpatterns in a rust-like syntax is difficult because a lot of AST nodes don't have a syntactic element that can be used to put the name tag on. In these situations, the only sensible option would be to assign the name tag to the outermost node (`ast::Stmt` in the example above), because the information of all child nodes can be retrieved through the outermost node. The problem with this then would be that accessing inner nodes (like `ast::Lit`) would again require manual pattern matching.\n-\n-In general, Rust syntax contains a lot of code structure implicitly. This structure is reconstructed during parsing (e.g. binary operations are reconstructed using operator precedence and left-to-right) and is one of the reasons why parsing is a complex task. The advantage of this approach is that writing code is simpler for users.\n-\n-When writing *syntax tree patterns*, each element of the hierarchy might have alternatives, repetitions, etc.. Respecting that while still allowing human-friendly syntax that contains structure implicitly seems to be really complex, if not impossible.\n-\n-Developing such a syntax would also require to maintain a custom parser that is at least as complex as the Rust parser itself. Additionally, future changes in the Rust syntax might be incompatible with such a syntax.\n-\n-In summary, I think that developing such a syntax would introduce a lot of complexity to solve a relatively minor problem.\n-\n-The issue of users not knowing about the *PatternTree* structure could be solved by a tool that, given a rust program, generates a pattern that matches only this program (similar to the clippy author lint).\n-\n-For some simple cases (like the first example above), it might be possible to successfully mix Rust and pattern syntax. This space could be further explored in a future extension.\n-\n-# Prior art\n-\n-The pattern syntax is heavily inspired by regular expressions (repetitions, alternatives, sequences, ...).\n-\n-From what I've seen until now, other linters also implement lints that directly work on syntax tree data structures, just like clippy does currently. I would therefore consider the pattern syntax to be *new*, but please correct me if I'm wrong.\n-\n-# Unresolved questions\n-\n-#### How to handle multiple matches?\n-\n-When matching a syntax tree node against a pattern, there are possibly multiple ways in which the pattern can be matched. A simple example of this would be the following pattern:\n-\n-```\n-pattern!{\n-    my_pattern: Expr = \n-        Array( _* Lit(_)+#literals)\n-}\n-```\n-\n-This pattern matches arrays that end with at least one literal. Now given the array `[x, 1, 2]`, should `1` be matched as part of the `_*` or the `Lit(_)+` part of the pattern? The difference is important because the named submatch `#literals` would contain 1 or 2 elements depending how the pattern is matched. In regular expressions, this problem is solved by matching \"greedy\" by default and \"non-greedy\" optionally.\n-\n-I haven't looked much into this yet because I don't know how relevant it is for most lints. The current implementation simply returns the first match it finds.\n-\n-# Future possibilities\n-\n-#### Implement rest of Rust Syntax\n-\n-The current project only implements a small part of the Rust syntax. In the future, this should incrementally be extended to more syntax to allow implementing more lints. Implementing more of the Rust syntax requires extending the `PatternTree` and `IsMatch` implementations, but should be relatively straight-forward.\n-\n-#### Early filtering\n-\n-As described in the *Drawbacks/Performance* section, allowing additional checks during the pattern matching might be beneficial.\n-\n-The pattern below shows how this could look like:\n-\n-```\n-pattern!{\n-    pat_if_without_else: Expr = \n-        If(\n-            _,\n-            Block(\n-                Expr( If(_, _, ())#inner )\n-                | Semi( If(_, _, ())#inner ) \n-            )#then, \n-            ()\n-        )\n-    where\n-        !in_macro(#then.span);\n-}\n-```\n-\n-The difference compared to the currently proposed two-stage filtering is that using early filtering, the condition (`!in_macro(#then.span)` in this case) would be evaluated as soon as the `Block(_)#then` was matched.\n-\n-Another idea in this area would be to introduce a syntax for backreferences. They could be used to require that multiple parts of a pattern should match the same value. For example, the `assign_op_pattern` lint that searches for `a = a op b` and recommends changing it to `a op= b` requires that both occurrances of `a` are the same. Using `=#...` as syntax for backreferences, the lint could be implemented like this:\n-\n-```\n-pattern!{\n-    assign_op_pattern: Expr = \n-        Assign(_#target, Binary(_, =#target, _)\n-}\n-```\n-\n-#### Match descendant\n-\n-A lot of lints currently implement custom visitors that check whether any subtree (which might not be a direct descendant) of the current node matches some properties. This cannot be expressed with the proposed pattern syntax. Extending the pattern syntax to allow patterns like \"a function that contains at least two return statements\" could be a practical addition.\n-\n-#### Negation operator for alternatives\n-\n-For patterns like \"a literal that is not a boolean literal\" one currently needs to list all alternatives except the boolean case. Introducing a negation operator that allows to write `Lit(!Bool(_))` might be a good idea. This pattern would be eqivalent to `Lit( Char(_) | Int(_) )` (given that currently only three literal types are implemented).\n-\n-#### Functional composition\n-\n-Patterns currently don't have any concept of composition. This leads to repetitions within patterns. For example, one of the collapsible-if patterns currently has to be written like this:\n-\n-```\n-pattern!{\n-    pat_if_else: Expr = \n-        If(\n-            _, \n-            _, \n-            Block_(\n-                Block(\n-                    Expr((If(_, _, _?) | IfLet(_, _?))#else_) | \n-                    Semi((If(_, _, _?) | IfLet(_, _?))#else_)\n-                )#block_inner\n-            )#block\n-        ) |\n-        IfLet(\n-            _, \n-            Block_(\n-                Block(\n-                    Expr((If(_, _, _?) | IfLet(_, _?))#else_) | \n-                    Semi((If(_, _, _?) | IfLet(_, _?))#else_)\n-                )#block_inner\n-            )#block\n-        )\n-}\n-```\n-\n-If patterns supported defining functions of subpatterns, the code could be simplified as follows:\n-\n-```\n-pattern!{\n-    fn expr_or_semi(expr: Expr) -> Stmt {\n-        Expr(expr) | Semi(expr)\n-    }\n-    fn if_or_if_let(then: Block, else: Opt<Expr>) -> Expr {\n-        If(_, then, else) | IfLet(then, else)\n-    }\n-    pat_if_else: Expr = \n-        if_or_if_let(\n-            _,\n-            Block_(\n-                Block(\n-                    expr_or_semi( if_or_if_let(_, _?)#else_ )\n-                )#block_inner\n-            )#block\n-        )\n-}\n-```\n-\n-Additionally, common patterns like `expr_or_semi` could be shared between different lints.\n-\n-#### Clippy Pattern Author\n-\n-Another improvement could be to create a tool that, given some valid Rust syntax, generates a pattern that matches this syntax exactly. This would make starting to write a pattern easier. A user could take a look at the patterns generated for a couple of Rust code examples and use that information to write a pattern that matches all of them.\n-\n-This is similar to clippy's author lint.\n-\n-#### Supporting other syntaxes\n-\n-Most of the proposed system is language-agnostic. For example, the pattern syntax could also be used to describe patterns for other programming languages.\n-\n-In order to support other languages' syntaxes, one would need to implement another `PatternTree` that sufficiently describes the languages' AST and implement `IsMatch` for this `PatternTree` and the languages' AST.\n-\n-One aspect of this is that it would even be possible to write lints that work on the pattern syntax itself. For example, when writing the following pattern\n-\n-\n-```\n-pattern!{\n-    my_pattern: Expr = \n-        Array( Lit(Bool(false)) Lit(Bool(false)) )\n-}\n-```\n-\n-a lint that works on the pattern syntax's AST could suggest using this pattern instead:\n-\n-```\n-pattern!{\n-    my_pattern: Expr = \n-        Array( Lit(Bool(false)){2} )\n-}\n-```\n-\n-In the future, clippy could use this system to also provide lints for custom syntaxes like those found in macros.\n-\n-# Final Note\n-\n-This is the first RFC I've ever written and it might be a little rough around the edges.\n-\n-I'm looking forward to hearing your feedback and discussing the proposal."}]}