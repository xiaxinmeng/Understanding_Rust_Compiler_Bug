{"sha": "ae024919845a44473c22b8c3f1dfa075c9c5c75d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMDI0OTE5ODQ1YTQ0NDczYzIyYjhjM2YxZGZhMDc1YzljNWM3NWQ=", "commit": {"author": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-07-20T03:44:35Z"}, "committer": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-07-20T03:46:11Z"}, "message": "Better errors when we don't have implicit statics in trait objects", "tree": {"sha": "79fcbba5a7327021df2855e912af000217f13c5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79fcbba5a7327021df2855e912af000217f13c5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae024919845a44473c22b8c3f1dfa075c9c5c75d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae024919845a44473c22b8c3f1dfa075c9c5c75d", "html_url": "https://github.com/rust-lang/rust/commit/ae024919845a44473c22b8c3f1dfa075c9c5c75d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae024919845a44473c22b8c3f1dfa075c9c5c75d/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cd5ad5cd7d85fc36c3696e3022bef5c5af088d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cd5ad5cd7d85fc36c3696e3022bef5c5af088d2", "html_url": "https://github.com/rust-lang/rust/commit/3cd5ad5cd7d85fc36c3696e3022bef5c5af088d2"}], "stats": {"total": 193, "additions": 155, "deletions": 38}, "files": [{"sha": "55173c6f8696e419545ef1e8c9a6d8f2157db138", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae024919845a44473c22b8c3f1dfa075c9c5c75d/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae024919845a44473c22b8c3f1dfa075c9c5c75d/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=ae024919845a44473c22b8c3f1dfa075c9c5c75d", "patch": "@@ -336,6 +336,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             insertion_sp,\n                             suggestion,\n                         );\n+                        err.note(\"assuming a `'static` lifetime...\");\n                         err.emit();\n                     }\n                     AnonymousLifetimeMode::PassThrough | AnonymousLifetimeMode::ReportError => {"}, {"sha": "cca195417270bd5289d45d8e82f921ec06572094", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mismatched_static_lifetime.rs", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ae024919845a44473c22b8c3f1dfa075c9c5c75d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae024919845a44473c22b8c3f1dfa075c9c5c75d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs?ref=ae024919845a44473c22b8c3f1dfa075c9c5c75d", "patch": "@@ -6,6 +6,7 @@ use crate::infer::error_reporting::note_and_explain_region;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::ObligationCauseCode;\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_errors::{Applicability, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::intravisit::Visitor;\n@@ -42,13 +43,12 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         multi_span\n             .push_span_label(binding_span, \"introduces a `'static` lifetime requirement\".into());\n         err.span_note(multi_span, \"because this has an unmet lifetime requirement\");\n-        note_and_explain_region(self.tcx(), &mut err, \"...\", sup, \"...\");\n+        note_and_explain_region(self.tcx(), &mut err, \"\", sup, \"...\");\n         if let Some(impl_node) = self.tcx().hir().get_if_local(*impl_def_id) {\n-            let ty = self.tcx().type_of(*impl_def_id);\n-            let mut v = super::static_impl_trait::TraitObjectVisitor(vec![]);\n-            v.visit_ty(ty);\n-            let matching_def_ids = v.0;\n+            // If an impl is local, then maybe this isn't what they want. Try to\n+            // be as helpful as possible with implicit lifetimes.\n \n+            // First, let's get the hir self type of the impl\n             let impl_self_ty = match impl_node {\n                 hir::Node::Item(hir::Item {\n                     kind: hir::ItemKind::Impl(hir::Impl { self_ty, .. }),\n@@ -57,26 +57,45 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 _ => bug!(\"Node not an impl.\"),\n             };\n \n-            for matching_def_id in matching_def_ids {\n+            // Next, let's figure out the set of trait objects with implict static bounds\n+            let ty = self.tcx().type_of(*impl_def_id);\n+            let mut v = super::static_impl_trait::TraitObjectVisitor(FxHashSet::default());\n+            v.visit_ty(ty);\n+            let mut traits = vec![];\n+            for matching_def_id in v.0 {\n                 let mut hir_v =\n-                    super::static_impl_trait::HirTraitObjectVisitor(vec![], matching_def_id);\n+                    super::static_impl_trait::HirTraitObjectVisitor(&mut traits, matching_def_id);\n                 hir_v.visit_ty(&impl_self_ty);\n+            }\n \n-                let mut multi_span: MultiSpan = hir_v.0.clone().into();\n-                for span in &hir_v.0 {\n-                    multi_span.push_span_label(\n-                        *span,\n-                        \"this has an implicit `'static` lifetime requirement\".to_string(),\n-                    );\n+            if traits.is_empty() {\n+                // If there are no trait object traits to point at, either because\n+                // there aren't trait objects or because none are implicit, then just\n+                // write a single note on the impl itself.\n+\n+                let impl_span = self.tcx().def_span(*impl_def_id);\n+                err.span_note(impl_span, \"...does not necessarily outlive the static lifetime introduced by the compatible `impl`\");\n+            } else {\n+                // Otherwise, point at all implicit static lifetimes\n+\n+                err.note(\"...does not necessarily outlive the static lifetime introduced by the compatible `impl`\");\n+                for span in &traits {\n+                    err.span_note(*span, \"this has an implicit `'static` lifetime requirement\");\n+                    // It would be nice to put this immediately under the above note, but they get\n+                    // pushed to the end.\n                     err.span_suggestion_verbose(\n                         span.shrink_to_hi(),\n                         \"consider relaxing the implicit `'static` requirement\",\n                         \" + '_\".to_string(),\n                         Applicability::MaybeIncorrect,\n                     );\n                 }\n-                err.span_note(multi_span, \"...does not necessarily outlive the static lifetime introduced by the compatible `impl`\");\n             }\n+        } else {\n+            // Otherwise just point out the impl.\n+\n+            let impl_span = self.tcx().def_span(*impl_def_id);\n+            err.span_note(impl_span, \"...does not necessarily outlive the static lifetime introduced by the compatible `impl`\");\n         }\n         err.emit();\n         Some(ErrorReported)"}, {"sha": "fde4ec05ffc867f74ec0aeced86aa748bc26d07e", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ae024919845a44473c22b8c3f1dfa075c9c5c75d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae024919845a44473c22b8c3f1dfa075c9c5c75d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=ae024919845a44473c22b8c3f1dfa075c9c5c75d", "patch": "@@ -4,6 +4,7 @@ use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCauseCode, UnifyReceiverContext};\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_ty, ErasedMap, NestedVisitorMap, Visitor};\n@@ -193,13 +194,12 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 // Same case of `impl Foo for dyn Bar { fn qux(&self) {} }` introducing a `'static`\n                 // lifetime as above, but called using a fully-qualified path to the method:\n                 // `Foo::qux(bar)`.\n-                let mut v = TraitObjectVisitor(vec![]);\n+                let mut v = TraitObjectVisitor(FxHashSet::default());\n                 v.visit_ty(param.param_ty);\n                 if let Some((ident, self_ty)) =\n-                    self.get_impl_ident_and_self_ty_from_trait(item_def_id, &v.0[..])\n+                    self.get_impl_ident_and_self_ty_from_trait(item_def_id, &v.0)\n                 {\n-                    if self.suggest_constrain_dyn_trait_in_impl(&mut err, &v.0[..], ident, self_ty)\n-                    {\n+                    if self.suggest_constrain_dyn_trait_in_impl(&mut err, &v.0, ident, self_ty) {\n                         override_error_code = Some(ident);\n                     }\n                 }\n@@ -340,7 +340,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     fn get_impl_ident_and_self_ty_from_trait(\n         &self,\n         def_id: DefId,\n-        trait_objects: &[DefId],\n+        trait_objects: &FxHashSet<DefId>,\n     ) -> Option<(Ident, &'tcx hir::Ty<'tcx>)> {\n         let tcx = self.tcx();\n         match tcx.hir().get_if_local(def_id) {\n@@ -377,9 +377,10 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                                         // multiple `impl`s for the same trait like\n                                         // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n                                         // In that case, only the first one will get suggestions.\n-                                        let mut hir_v = HirTraitObjectVisitor(vec![], *did);\n+                                        let mut traits = vec![];\n+                                        let mut hir_v = HirTraitObjectVisitor(&mut traits, *did);\n                                         hir_v.visit_ty(self_ty);\n-                                        !hir_v.0.is_empty()\n+                                        !traits.is_empty()\n                                     }) =>\n                                     {\n                                         Some(self_ty)\n@@ -421,33 +422,34 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             _ => return false,\n         };\n \n-        let mut v = TraitObjectVisitor(vec![]);\n+        let mut v = TraitObjectVisitor(FxHashSet::default());\n         v.visit_ty(ty);\n \n         // Get the `Ident` of the method being called and the corresponding `impl` (to point at\n         // `Bar` in `impl Foo for dyn Bar {}` and the definition of the method being called).\n         let (ident, self_ty) =\n-            match self.get_impl_ident_and_self_ty_from_trait(instance.def_id(), &v.0[..]) {\n+            match self.get_impl_ident_and_self_ty_from_trait(instance.def_id(), &v.0) {\n                 Some((ident, self_ty)) => (ident, self_ty),\n                 None => return false,\n             };\n \n         // Find the trait object types in the argument, so we point at *only* the trait object.\n-        self.suggest_constrain_dyn_trait_in_impl(err, &v.0[..], ident, self_ty)\n+        self.suggest_constrain_dyn_trait_in_impl(err, &v.0, ident, self_ty)\n     }\n \n     fn suggest_constrain_dyn_trait_in_impl(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        found_dids: &[DefId],\n+        found_dids: &FxHashSet<DefId>,\n         ident: Ident,\n         self_ty: &hir::Ty<'_>,\n     ) -> bool {\n         let mut suggested = false;\n         for found_did in found_dids {\n-            let mut hir_v = HirTraitObjectVisitor(vec![], *found_did);\n+            let mut traits = vec![];\n+            let mut hir_v = HirTraitObjectVisitor(&mut traits, *found_did);\n             hir_v.visit_ty(&self_ty);\n-            for span in &hir_v.0 {\n+            for span in &traits {\n                 let mut multi_span: MultiSpan = vec![*span].into();\n                 multi_span.push_span_label(\n                     *span,\n@@ -472,14 +474,14 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n }\n \n /// Collect all the trait objects in a type that could have received an implicit `'static` lifetime.\n-pub(super) struct TraitObjectVisitor(pub(super) Vec<DefId>);\n+pub(super) struct TraitObjectVisitor(pub(super) FxHashSet<DefId>);\n \n impl TypeVisitor<'_> for TraitObjectVisitor {\n     fn visit_ty(&mut self, t: Ty<'_>) -> ControlFlow<Self::BreakTy> {\n         match t.kind() {\n             ty::Dynamic(preds, RegionKind::ReStatic) => {\n                 if let Some(def_id) = preds.principal_def_id() {\n-                    self.0.push(def_id);\n+                    self.0.insert(def_id);\n                 }\n                 ControlFlow::CONTINUE\n             }\n@@ -489,9 +491,9 @@ impl TypeVisitor<'_> for TraitObjectVisitor {\n }\n \n /// Collect all `hir::Ty<'_>` `Span`s for trait objects with an implicit lifetime.\n-pub(super) struct HirTraitObjectVisitor(pub(super) Vec<Span>, pub(super) DefId);\n+pub(super) struct HirTraitObjectVisitor<'a>(pub(super) &'a mut Vec<Span>, pub(super) DefId);\n \n-impl<'tcx> Visitor<'tcx> for HirTraitObjectVisitor {\n+impl<'a, 'tcx> Visitor<'tcx> for HirTraitObjectVisitor<'a> {\n     type Map = ErasedMap<'tcx>;\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {"}, {"sha": "36fb73a8dde247e5b8b03bc273512fab66b36605", "filename": "src/test/ui/async-await/async-fn-path-elision.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae024919845a44473c22b8c3f1dfa075c9c5c75d/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-path-elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ae024919845a44473c22b8c3f1dfa075c9c5c75d/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-path-elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-path-elision.stderr?ref=ae024919845a44473c22b8c3f1dfa075c9c5c75d", "patch": "@@ -3,6 +3,8 @@ error[E0726]: implicit elided lifetime not allowed here\n    |\n LL | async fn error(lt: HasLifetime) {\n    |                    ^^^^^^^^^^^- help: indicate the anonymous lifetime: `<'_>`\n+   |\n+   = note: assuming a `'static` lifetime...\n \n error: aborting due to previous error\n "}, {"sha": "850d83be6845dc44b1e54c876cd8264d960a2d2c", "filename": "src/test/ui/generic-associated-types/issue-78113-lifetime-mismatch-dyn-trait-box.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ae024919845a44473c22b8c3f1dfa075c9c5c75d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-78113-lifetime-mismatch-dyn-trait-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae024919845a44473c22b8c3f1dfa075c9c5c75d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-78113-lifetime-mismatch-dyn-trait-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-78113-lifetime-mismatch-dyn-trait-box.rs?ref=ae024919845a44473c22b8c3f1dfa075c9c5c75d", "patch": "@@ -13,7 +13,28 @@ pub trait B {\n }\n \n impl B for () {\n+    // `'a` doesn't match implicit `'static`: suggest `'_`\n     type T<'a> = Box<dyn A + 'a>; //~ incompatible lifetime on type\n }\n \n+trait C {}\n+impl C for Box<dyn A + 'static> {}\n+pub trait D {\n+    type T<'a>: C;\n+}\n+impl D for () {\n+    // `'a` doesn't match explicit `'static`: we *should* suggest removing `'static`\n+    type T<'a> = Box<dyn A + 'a>; //~ incompatible lifetime on type\n+}\n+\n+trait E {}\n+impl E for (Box<dyn A>, Box<dyn A>) {}\n+pub trait F {\n+    type T<'a>: E;\n+}\n+impl F for () {\n+    // `'a` doesn't match explicit `'static`: suggest `'_`\n+    type T<'a> = (Box<dyn A + 'a>, Box<dyn A + 'a>); //~ incompatible lifetime on type\n+}\n+\n fn main() {}"}, {"sha": "fedc6a341cad3d53f12a09817e811a2ffc6016d8", "filename": "src/test/ui/generic-associated-types/issue-78113-lifetime-mismatch-dyn-trait-box.stderr", "status": "modified", "additions": 65, "deletions": 6, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/ae024919845a44473c22b8c3f1dfa075c9c5c75d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-78113-lifetime-mismatch-dyn-trait-box.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ae024919845a44473c22b8c3f1dfa075c9c5c75d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-78113-lifetime-mismatch-dyn-trait-box.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-78113-lifetime-mismatch-dyn-trait-box.stderr?ref=ae024919845a44473c22b8c3f1dfa075c9c5c75d", "patch": "@@ -1,5 +1,5 @@\n error: incompatible lifetime on type\n-  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:16:5\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:17:5\n    |\n LL |     type T<'a> = Box<dyn A + 'a>;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -9,20 +9,79 @@ note: because this has an unmet lifetime requirement\n    |\n LL |     type T<'a>: A;\n    |                 ^ introduces a `'static` lifetime requirement\n-note: ...the lifetime `'a` as defined on the associated item at 16:12...\n-  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:16:12\n+note: the lifetime `'a` as defined on the associated item at 17:12...\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:17:12\n    |\n LL |     type T<'a> = Box<dyn A + 'a>;\n    |            ^^\n-note: ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n+   = note: ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n+note: this has an implicit `'static` lifetime requirement\n   --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:9:20\n    |\n LL | impl A for Box<dyn A> {}\n-   |                    ^ this has an implicit `'static` lifetime requirement\n+   |                    ^\n help: consider relaxing the implicit `'static` requirement\n    |\n LL | impl A for Box<dyn A + '_> {}\n    |                      ^^^^\n \n-error: aborting due to previous error\n+error: incompatible lifetime on type\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:27:5\n+   |\n+LL |     type T<'a> = Box<dyn A + 'a>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: because this has an unmet lifetime requirement\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:23:17\n+   |\n+LL |     type T<'a>: C;\n+   |                 ^ introduces a `'static` lifetime requirement\n+note: the lifetime `'a` as defined on the associated item at 27:12...\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:27:12\n+   |\n+LL |     type T<'a> = Box<dyn A + 'a>;\n+   |            ^^\n+note: ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:21:1\n+   |\n+LL | impl C for Box<dyn A + 'static> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: incompatible lifetime on type\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:37:5\n+   |\n+LL |     type T<'a> = (Box<dyn A + 'a>, Box<dyn A + 'a>);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: because this has an unmet lifetime requirement\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:33:17\n+   |\n+LL |     type T<'a>: E;\n+   |                 ^ introduces a `'static` lifetime requirement\n+note: the lifetime `'a` as defined on the associated item at 37:12...\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:37:12\n+   |\n+LL |     type T<'a> = (Box<dyn A + 'a>, Box<dyn A + 'a>);\n+   |            ^^\n+   = note: ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n+note: this has an implicit `'static` lifetime requirement\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:31:21\n+   |\n+LL | impl E for (Box<dyn A>, Box<dyn A>) {}\n+   |                     ^\n+note: this has an implicit `'static` lifetime requirement\n+  --> $DIR/issue-78113-lifetime-mismatch-dyn-trait-box.rs:31:33\n+   |\n+LL | impl E for (Box<dyn A>, Box<dyn A>) {}\n+   |                                 ^\n+help: consider relaxing the implicit `'static` requirement\n+   |\n+LL | impl E for (Box<dyn A + '_>, Box<dyn A>) {}\n+   |                       ^^^^\n+help: consider relaxing the implicit `'static` requirement\n+   |\n+LL | impl E for (Box<dyn A>, Box<dyn A + '_>) {}\n+   |                                   ^^^^\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "1c81c69620165df971959f6fc3ecb7d024f75f99", "filename": "src/test/ui/impl-header-lifetime-elision/path-elided.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae024919845a44473c22b8c3f1dfa075c9c5c75d/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fpath-elided.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ae024919845a44473c22b8c3f1dfa075c9c5c75d/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fpath-elided.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fpath-elided.stderr?ref=ae024919845a44473c22b8c3f1dfa075c9c5c75d", "patch": "@@ -3,6 +3,8 @@ error[E0726]: implicit elided lifetime not allowed here\n    |\n LL | impl MyTrait for Foo {\n    |                  ^^^- help: indicate the anonymous lifetime: `<'_>`\n+   |\n+   = note: assuming a `'static` lifetime...\n \n error: aborting due to previous error\n "}, {"sha": "735f01379f09fc4f50ceb45157e0543f25d9a483", "filename": "src/test/ui/impl-header-lifetime-elision/trait-elided.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae024919845a44473c22b8c3f1dfa075c9c5c75d/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ae024919845a44473c22b8c3f1dfa075c9c5c75d/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.stderr?ref=ae024919845a44473c22b8c3f1dfa075c9c5c75d", "patch": "@@ -3,6 +3,8 @@ error[E0726]: implicit elided lifetime not allowed here\n    |\n LL | impl MyTrait for u32 {\n    |      ^^^^^^^- help: indicate the anonymous lifetime: `<'_>`\n+   |\n+   = note: assuming a `'static` lifetime...\n \n error: aborting due to previous error\n "}, {"sha": "9d181eab7fbcdf1cd51989d3143f792224b6b557", "filename": "src/test/ui/issues/issue-10412.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae024919845a44473c22b8c3f1dfa075c9c5c75d/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ae024919845a44473c22b8c3f1dfa075c9c5c75d/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr?ref=ae024919845a44473c22b8c3f1dfa075c9c5c75d", "patch": "@@ -45,6 +45,8 @@ error[E0726]: implicit elided lifetime not allowed here\n    |\n LL | impl<'self> Serializable<str> for &'self str {\n    |             ^^^^^^^^^^^^^^^^^ help: indicate the anonymous lifetime: `Serializable<'_, str>`\n+   |\n+   = note: assuming a `'static` lifetime...\n \n error[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> $DIR/issue-10412.rs:6:13"}, {"sha": "4e927cd983d0d4d906defe475a6d98e19fe3c4cc", "filename": "src/test/ui/wf/wf-in-foreign-fn-decls-issue-80468.stderr", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ae024919845a44473c22b8c3f1dfa075c9c5c75d/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ae024919845a44473c22b8c3f1dfa075c9c5c75d/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.stderr?ref=ae024919845a44473c22b8c3f1dfa075c9c5c75d", "patch": "@@ -3,6 +3,8 @@ error[E0726]: implicit elided lifetime not allowed here\n    |\n LL | impl Trait for Ref {}\n    |                ^^^- help: indicate the anonymous lifetime: `<'_>`\n+   |\n+   = note: assuming a `'static` lifetime...\n \n error: incompatible lifetime on type\n   --> $DIR/wf-in-foreign-fn-decls-issue-80468.rs:16:21\n@@ -15,11 +17,16 @@ note: because this has an unmet lifetime requirement\n    |\n LL | pub struct Wrapper<T: Trait>(T);\n    |                       ^^^^^ introduces a `'static` lifetime requirement\n-note: ...the anonymous lifetime #1 defined on the method body at 16:5...\n+note: the anonymous lifetime #1 defined on the method body at 16:5...\n   --> $DIR/wf-in-foreign-fn-decls-issue-80468.rs:16:5\n    |\n LL |     pub fn repro(_: Wrapper<Ref>);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n+  --> $DIR/wf-in-foreign-fn-decls-issue-80468.rs:13:1\n+   |\n+LL | impl Trait for Ref {}\n+   | ^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}]}