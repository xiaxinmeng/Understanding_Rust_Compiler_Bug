{"sha": "59de3853be3b7d9e5306522bdfdb76be69555703", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5ZGUzODUzYmUzYjdkOWU1MzA2NTIyYmRmZGI3NmJlNjk1NTU3MDM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-08T02:51:04Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-08T14:54:41Z"}, "message": "core: Remove the dvec module", "tree": {"sha": "64b7af564d4494ef02cb58d5137665d1ee5da93c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64b7af564d4494ef02cb58d5137665d1ee5da93c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59de3853be3b7d9e5306522bdfdb76be69555703", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59de3853be3b7d9e5306522bdfdb76be69555703", "html_url": "https://github.com/rust-lang/rust/commit/59de3853be3b7d9e5306522bdfdb76be69555703", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59de3853be3b7d9e5306522bdfdb76be69555703/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c87920f5274ad2df2071ba295e533d606780cf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c87920f5274ad2df2071ba295e533d606780cf6", "html_url": "https://github.com/rust-lang/rust/commit/2c87920f5274ad2df2071ba295e533d606780cf6"}], "stats": {"total": 404, "additions": 4, "deletions": 400}, "files": [{"sha": "79a5d297178e3e1644fa3fc9b00ec61fd3417a7c", "filename": "src/libcore/core.rc", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/59de3853be3b7d9e5306522bdfdb76be69555703/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/59de3853be3b7d9e5306522bdfdb76be69555703/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=59de3853be3b7d9e5306522bdfdb76be69555703", "patch": "@@ -21,10 +21,10 @@ used features.\n the floating point types, the `bool` type, tuples, characters, strings,\n vectors (`vec`), managed boxes (`managed`), owned boxes (`owned`), and unsafe\n and borrowed pointers (`ptr`).  Additionally, `core` provides task management\n-and creation (`task`), communication primitives (`comm` and `pipes`), an\n-efficient vector builder (`dvec`), platform abstractions (`os` and `path`),\n-basic I/O abstractions (`io`), common traits (`cmp`, `num`, `to_str`), and\n-complete bindings to the C standard library (`libc`).\n+and creation (`task`), communication primitives (`comm` and `pipes`), platform\n+abstractions (`os` and `path`), basic I/O abstractions (`io`), common traits\n+(`cmp`, `num`, `to_str`), and complete bindings to the C standard library\n+(`libc`).\n \n `core` is linked to all crates by default and its contents imported.\n Implicitly, all crates behave as if they included the following prologue:\n@@ -141,9 +141,6 @@ pub mod container;\n pub mod option;\n pub mod result;\n pub mod either;\n-pub mod dvec;\n-#[path=\"iter-trait.rs\"] #[merge = \"iter-trait/dvec.rs\"]\n-pub mod dvec_iter;\n pub mod dlist;\n #[path=\"iter-trait.rs\"] #[merge = \"iter-trait/dlist.rs\"]\n pub mod dlist_iter;"}, {"sha": "43daf5fa6a5daa2332d6830b77cd3e69399b4413", "filename": "src/libcore/dvec.rs", "status": "removed", "additions": 0, "deletions": 355, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/2c87920f5274ad2df2071ba295e533d606780cf6/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c87920f5274ad2df2071ba295e533d606780cf6/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=2c87920f5274ad2df2071ba295e533d606780cf6", "patch": "@@ -1,355 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Dynamic vector\n-\n-A growable vector that makes use of unique pointers so that the\n-result can be sent between tasks and so forth.\n-\n-Note that recursive use is not permitted.\n-\n-*/\n-\n-use cast;\n-use prelude::*;\n-use ptr::null;\n-use vec;\n-\n-/**\n- * A growable, modifiable vector type that accumulates elements into a\n- * unique vector.\n- *\n- * # Limitations on recursive use\n- *\n- * This class works by swapping the unique vector out of the data\n- * structure whenever it is to be used.  Therefore, recursive use is not\n- * permitted.  That is, while iterating through a vector, you cannot\n- * access the vector in any other way or else the program will fail.  If\n- * you wish, you can use the `swap()` method to gain access to the raw\n- * vector and transform it or use it any way you like.  Eventually, we\n- * may permit read-only access during iteration or other use.\n- *\n- * # WARNING\n- *\n- * For maximum performance, this type is implemented using some rather\n- * unsafe code.  In particular, this innocent looking `~[mut A]` pointer\n- * *may be null!*  Therefore, it is important you not reach into the\n- * data structure manually but instead use the provided extensions.\n- *\n- * The reason that I did not use an unsafe pointer in the structure\n- * itself is that I wanted to ensure that the vector would be freed when\n- * the dvec is dropped.  The reason that I did not use an `Option<T>`\n- * instead of a nullable pointer is that I found experimentally that it\n- * becomes approximately 50% slower. This can probably be improved\n- * through optimization.  You can run your own experiments using\n- * `src/test/bench/vec-append.rs`. My own tests found that using null\n- * pointers achieved about 103 million pushes/second.  Using an option\n- * type could only produce 47 million pushes/second.\n- */\n-pub struct DVec<A> {\n-    mut data: ~[A]\n-}\n-\n-/// Creates a new, empty dvec\n-pub pure fn DVec<A>() -> DVec<A> {\n-    DVec {data: ~[]}\n-}\n-\n-/// Creates a new dvec with a single element\n-pub pure fn from_elem<A>(e: A) -> DVec<A> {\n-    DVec {data: ~[e]}\n-}\n-\n-/// Creates a new dvec with the contents of a vector\n-pub pure fn from_vec<A>(v: ~[A]) -> DVec<A> {\n-    DVec {data: v}\n-}\n-\n-/// Consumes the vector and returns its contents\n-pub pure fn unwrap<A>(d: DVec<A>) -> ~[A] {\n-    let DVec {data: v} = d;\n-    v\n-}\n-\n-priv impl<A> DVec<A> {\n-    #[inline(always)]\n-    pure fn check_not_borrowed(&self) {\n-        unsafe {\n-            let data: *() = cast::reinterpret_cast(&self.data);\n-            if data.is_null() {\n-                fail!(~\"Recursive use of dvec\");\n-            }\n-        }\n-    }\n-\n-    #[inline(always)]\n-    fn give_back(&self, data: ~[A]) {\n-        unsafe {\n-            self.data = data;\n-        }\n-    }\n-\n-    #[inline(always)]\n-    fn unwrap(self) -> ~[A] { unwrap(self) }\n-}\n-\n-// In theory, most everything should work with any A, but in practice\n-// almost nothing works without the copy bound due to limitations\n-// around closures.\n-pub impl<A> DVec<A> {\n-    // FIXME (#3758): This should not need to be public.\n-    #[inline(always)]\n-    fn check_out<B>(&self, f: &fn(v: ~[A]) -> B) -> B {\n-        unsafe {\n-            let mut data = cast::reinterpret_cast(&null::<()>());\n-            data <-> self.data;\n-            let data_ptr: *() = cast::reinterpret_cast(&data);\n-            if data_ptr.is_null() { fail!(~\"Recursive use of dvec\"); }\n-            return f(data);\n-        }\n-    }\n-\n-    /// Reserves space for N elements\n-    fn reserve(&self, count: uint) {\n-        vec::reserve(&mut self.data, count)\n-    }\n-\n-    /**\n-     * Swaps out the current vector and hands it off to a user-provided\n-     * function `f`.  The function should transform it however is desired\n-     * and return a new vector to replace it with.\n-     */\n-    #[inline(always)]\n-    fn swap(&self, f: &fn(v: ~[A]) -> ~[A]) {\n-        self.check_out(|v| self.give_back(f(v)))\n-    }\n-\n-    /// Returns the number of elements currently in the dvec\n-    #[inline(always)]\n-    pure fn len(&self) -> uint {\n-        self.check_not_borrowed();\n-        return self.data.len();\n-    }\n-\n-    /// Overwrite the current contents\n-    #[inline(always)]\n-    fn set(&self, w: ~[A]) {\n-        self.check_not_borrowed();\n-        self.data = w;\n-    }\n-\n-    /// Remove and return the last element\n-    fn pop(&self) -> A {\n-        do self.check_out |v| {\n-            let mut v = v;\n-            let result = v.pop();\n-            self.give_back(v);\n-            result\n-        }\n-    }\n-\n-    /// Insert a single item at the front of the list\n-    fn unshift(&self, t: A) {\n-        unsafe {\n-            let mut data = cast::reinterpret_cast(&null::<()>());\n-            data <-> self.data;\n-            let data_ptr: *() = cast::reinterpret_cast(&data);\n-            if data_ptr.is_null() { fail!(~\"Recursive use of dvec\"); }\n-            self.data = ~[t];\n-            self.data.push_all_move(data);\n-        }\n-    }\n-\n-    /// Append a single item to the end of the list\n-    #[inline(always)]\n-    fn push(&self, t: A) {\n-        self.check_not_borrowed();\n-        self.data.push(t);\n-    }\n-\n-    /// Remove and return the first element\n-    fn shift(&self) -> A {\n-        do self.check_out |v| {\n-            let mut v = v;\n-            let result = v.shift();\n-            self.give_back(v);\n-            result\n-        }\n-    }\n-\n-    /// Reverse the elements in the list, in place\n-    fn reverse(&self) {\n-        do self.check_out |v| {\n-            let mut v = v;\n-            vec::reverse(v);\n-            self.give_back(v);\n-        }\n-    }\n-\n-    /// Gives access to the vector as a slice with immutable contents\n-    fn borrow<R>(&self, op: fn(x: &[A]) -> R) -> R {\n-        do self.check_out |v| {\n-            let result = op(v);\n-            self.give_back(v);\n-            result\n-        }\n-    }\n-\n-    /// Gives access to the vector as a slice with mutable contents\n-    fn borrow_mut<R>(&self, op: &fn(x: &mut [A]) -> R) -> R {\n-        do self.check_out |v| {\n-            let mut v = v;\n-            let result = op(v);\n-            self.give_back(v);\n-            result\n-        }\n-    }\n-}\n-\n-pub impl<A:Copy> DVec<A> {\n-    /**\n-     * Append all elements of a vector to the end of the list\n-     *\n-     * Equivalent to `append_iter()` but potentially more efficient.\n-     */\n-    fn push_all(&self, ts: &[const A]) {\n-        self.push_slice(ts, 0u, vec::len(ts));\n-    }\n-\n-    /// Appends elements from `from_idx` to `to_idx` (exclusive)\n-    fn push_slice(&self, ts: &[const A], from_idx: uint, to_idx: uint) {\n-        do self.swap |v| {\n-            let mut v = v;\n-            let new_len = vec::len(v) + to_idx - from_idx;\n-            vec::reserve(&mut v, new_len);\n-            let mut i = from_idx;\n-            while i < to_idx {\n-                v.push(ts[i]);\n-                i += 1u;\n-            }\n-            v\n-        }\n-    }\n-\n-    /**\n-     * Append all elements of an iterable.\n-     *\n-     * Failure will occur if the iterable's `each()` method\n-     * attempts to access this vector.\n-     */\n-    /*\n-    fn append_iter<A, I:iter::base_iter<A>>(ts: I) {\n-        do self.swap |v| {\n-           let mut v = match ts.size_hint() {\n-             none { v }\n-             Some(h) {\n-               let len = v.len() + h;\n-               let mut v = v;\n-               vec::reserve(v, len);\n-               v\n-            }\n-           };\n-\n-        for ts.each |t| { v.push(*t) };\n-           v\n-        }\n-    }\n-    */\n-\n-    /**\n-     * Gets a copy of the current contents.\n-     *\n-     * See `unwrap()` if you do not wish to copy the contents.\n-     */\n-    pure fn get(&self) -> ~[A] {\n-        unsafe {\n-            do self.check_out |v| {\n-                let w = copy v;\n-                self.give_back(v);\n-                w\n-            }\n-        }\n-    }\n-\n-    /// Copy out an individual element\n-    #[inline(always)]\n-    pure fn get_elt(&self, idx: uint) -> A {\n-        self.check_not_borrowed();\n-        return self.data[idx];\n-    }\n-\n-    /// Overwrites the contents of the element at `idx` with `a`\n-    fn set_elt(&self, idx: uint, a: A) {\n-        self.check_not_borrowed();\n-        self.data[idx] = a;\n-    }\n-\n-    /**\n-     * Overwrites the contents of the element at `idx` with `a`,\n-     * growing the vector if necessary.  New elements will be initialized\n-     * with `initval`\n-     */\n-    fn grow_set_elt(&self, idx: uint, initval: &A, val: A) {\n-        do self.swap |v| {\n-            let mut v = v;\n-            v.grow_set(idx, initval, val);\n-            v\n-        }\n-    }\n-\n-    /// Returns the last element, failing if the vector is empty\n-    #[inline(always)]\n-    pure fn last(&self) -> A {\n-        self.check_not_borrowed();\n-\n-        let length = self.len();\n-        if length == 0 {\n-            fail!(~\"attempt to retrieve the last element of an empty vector\");\n-        }\n-\n-        return self.data[length - 1];\n-    }\n-\n-    /// Iterates over the elements in reverse order\n-    #[inline(always)]\n-    fn rev_each(&self, f: fn(v: &A) -> bool) {\n-        do self.swap |v| {\n-            // FIXME(#2263)---we should be able to write\n-            // `vec::rev_each(v, f);` but we cannot write now\n-            for vec::rev_each(v) |e| {\n-                if !f(e) { break; }\n-            }\n-            v\n-        }\n-    }\n-\n-    /// Iterates over the elements and indices in reverse order\n-    #[inline(always)]\n-    fn rev_eachi(&self, f: fn(uint, v: &A) -> bool) {\n-        do self.swap |v| {\n-            // FIXME(#2263)---we should be able to write\n-            // `vec::rev_eachi(v, f);` but we cannot write now\n-            for vec::rev_eachi(v) |i, e| {\n-                if !f(i, e) { break; }\n-            }\n-            v\n-        }\n-    }\n-}\n-\n-impl<A:Copy> Index<uint,A> for DVec<A> {\n-    #[inline(always)]\n-    pure fn index(&self, idx: uint) -> A {\n-        self.get_elt(idx)\n-    }\n-}\n-"}, {"sha": "986aa18ad4ab18274de18e2c9a3fc26f926df44c", "filename": "src/libcore/iter-trait/dvec.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2c87920f5274ad2df2071ba295e533d606780cf6/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c87920f5274ad2df2071ba295e533d606780cf6/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdvec.rs?ref=2c87920f5274ad2df2071ba295e533d606780cf6", "patch": "@@ -1,37 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-mod inst {\n-    use dvec;\n-    use option::{Option, Some};\n-\n-    #[allow(non_camel_case_types)]\n-    pub type IMPL_T<A> = dvec::DVec<A>;\n-\n-    /**\n-    * Iterates through the current contents.\n-    *\n-    * Attempts to access this dvec during iteration will fail.\n-    */\n-    #[inline(always)]\n-    pub pure fn EACH<A>(self: &IMPL_T<A>, f: fn(v: &A) -> bool) {\n-        unsafe {\n-            do self.swap |v| {\n-                v.each(f);\n-                v\n-            }\n-        }\n-    }\n-\n-    #[inline(always)]\n-    pub pure fn SIZE_HINT<A>(self: &IMPL_T<A>) -> Option<uint> {\n-        Some(self.len())\n-    }\n-}"}, {"sha": "2f575ce7d28119ae1fd2025c3f563dd3f9fa13ff", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59de3853be3b7d9e5306522bdfdb76be69555703/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59de3853be3b7d9e5306522bdfdb76be69555703/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=59de3853be3b7d9e5306522bdfdb76be69555703", "patch": "@@ -50,7 +50,6 @@ pub use bool;\n pub use cast;\n pub use char;\n pub use cmp;\n-pub use dvec;\n pub use either;\n pub use f32;\n pub use f64;"}]}