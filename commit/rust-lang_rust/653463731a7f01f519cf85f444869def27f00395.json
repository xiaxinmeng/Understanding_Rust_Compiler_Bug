{"sha": "653463731a7f01f519cf85f444869def27f00395", "node_id": "C_kwDOAAsO6NoAKDY1MzQ2MzczMWE3ZjAxZjUxOWNmODVmNDQ0ODY5ZGVmMjdmMDAzOTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-22T09:00:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-22T09:00:30Z"}, "message": "Auto merge of #95563 - dingxiangfei2009:dxf-rfc66-refactor, r=nikomatsakis\n\nMove the extended lifetime resolution into typeck context\n\nRelated to #15023\n\nThis PR is based on the [idea](https://github.com/rust-lang/rust/issues/15023#issuecomment-1070931433) of #15023 by `@nikomatsakis.`\n\nThis PR specifically proposes to\n- Delay the resolution of scopes of rvalues to a later stage, so that enough type information is available to refine those scopes based on relationships of lifetimes.\n- Highlight relevant parts that would help future reviews on the next installments of works to fully implement a solution to RFC 66.", "tree": {"sha": "c7aae89d48561cc902ba2c3c9636614d7b0ec953", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7aae89d48561cc902ba2c3c9636614d7b0ec953"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/653463731a7f01f519cf85f444869def27f00395", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/653463731a7f01f519cf85f444869def27f00395", "html_url": "https://github.com/rust-lang/rust/commit/653463731a7f01f519cf85f444869def27f00395", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/653463731a7f01f519cf85f444869def27f00395/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acfd327fd4e3a302ebb0a077f422a527a7935333", "url": "https://api.github.com/repos/rust-lang/rust/commits/acfd327fd4e3a302ebb0a077f422a527a7935333", "html_url": "https://github.com/rust-lang/rust/commit/acfd327fd4e3a302ebb0a077f422a527a7935333"}, {"sha": "6044fbe4625579dadb6ef58305f97f2fb414c8cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/6044fbe4625579dadb6ef58305f97f2fb414c8cc", "html_url": "https://github.com/rust-lang/rust/commit/6044fbe4625579dadb6ef58305f97f2fb414c8cc"}], "stats": {"total": 555, "additions": 363, "deletions": 192}, "files": [{"sha": "cebf68769361b7cdec6573485220c34939c15552", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -1370,7 +1370,7 @@ pub enum UnsafeSource {\n     UserProvided,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n pub struct BodyId {\n     pub hir_id: HirId,\n }"}, {"sha": "2f0bb24537e4fa9b180ffba4b7846114cb7486ed", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -33,7 +33,6 @@ macro_rules! arena_types {\n             [] const_allocs: rustc_middle::mir::interpret::Allocation,\n             // Required for the incremental on-disk cache\n             [] mir_keys: rustc_hir::def_id::DefIdSet,\n-            [] region_scope_tree: rustc_middle::middle::region::ScopeTree,\n             [] dropck_outlives:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx,"}, {"sha": "30ef6b775f5e3c131c704fa337c5e8d8f07b7034", "filename": "compiler/rustc_middle/src/middle/region.rs", "status": "modified", "additions": 33, "deletions": 45, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -203,7 +203,7 @@ impl Scope {\n pub type ScopeDepth = u32;\n \n /// The region scope tree encodes information about region relationships.\n-#[derive(Default, Debug)]\n+#[derive(TyEncodable, TyDecodable, Default, Debug)]\n pub struct ScopeTree {\n     /// If not empty, this body is the root of this region hierarchy.\n     pub root_body: Option<hir::HirId>,\n@@ -223,15 +223,12 @@ pub struct ScopeTree {\n     /// Maps from a `NodeId` to the associated destruction scope (if any).\n     destruction_scopes: FxIndexMap<hir::ItemLocalId, Scope>,\n \n-    /// `rvalue_scopes` includes entries for those expressions whose\n-    /// cleanup scope is larger than the default. The map goes from the\n-    /// expression ID to the cleanup scope id. For rvalues not present in\n-    /// this table, the appropriate cleanup scope is the innermost\n-    /// enclosing statement, conditional expression, or repeating\n-    /// block (see `terminating_scopes`).\n-    /// In constants, None is used to indicate that certain expressions\n-    /// escape into 'static and should have no local cleanup scope.\n-    rvalue_scopes: FxHashMap<hir::ItemLocalId, Option<Scope>>,\n+    /// Identifies expressions which, if captured into a temporary, ought to\n+    /// have a temporary whose lifetime extends to the end of the enclosing *block*,\n+    /// and not the enclosing *statement*. Expressions that are not present in this\n+    /// table are not rvalue candidates. The set of rvalue candidates is computed\n+    /// during type check based on a traversal of the AST.\n+    pub rvalue_candidates: FxHashMap<hir::HirId, RvalueCandidateType>,\n \n     /// If there are any `yield` nested within a scope, this map\n     /// stores the `Span` of the last one and its index in the\n@@ -315,6 +312,17 @@ pub struct ScopeTree {\n     pub body_expr_count: FxHashMap<hir::BodyId, usize>,\n }\n \n+/// Identifies the reason that a given expression is an rvalue candidate\n+/// (see the `rvalue_candidates` field for more information what rvalue\n+/// candidates in general). In constants, the `lifetime` field is None\n+/// to indicate that certain expressions escape into 'static and\n+/// should have no local cleanup scope.\n+#[derive(Debug, Copy, Clone, TyEncodable, TyDecodable, HashStable)]\n+pub enum RvalueCandidateType {\n+    Borrow { target: hir::ItemLocalId, lifetime: Option<Scope> },\n+    Pattern { target: hir::ItemLocalId, lifetime: Option<Scope> },\n+}\n+\n #[derive(Debug, Copy, Clone, TyEncodable, TyDecodable, HashStable)]\n pub struct YieldData {\n     /// The `Span` of the yield.\n@@ -349,12 +357,20 @@ impl ScopeTree {\n         self.var_map.insert(var, lifetime);\n     }\n \n-    pub fn record_rvalue_scope(&mut self, var: hir::ItemLocalId, lifetime: Option<Scope>) {\n-        debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n-        if let Some(lifetime) = lifetime {\n-            assert!(var != lifetime.item_local_id());\n+    pub fn record_rvalue_candidate(\n+        &mut self,\n+        var: hir::HirId,\n+        candidate_type: RvalueCandidateType,\n+    ) {\n+        debug!(\"record_rvalue_candidate(var={var:?}, type={candidate_type:?})\");\n+        match &candidate_type {\n+            RvalueCandidateType::Borrow { lifetime: Some(lifetime), .. }\n+            | RvalueCandidateType::Pattern { lifetime: Some(lifetime), .. } => {\n+                assert!(var.local_id != lifetime.item_local_id())\n+            }\n+            _ => {}\n         }\n-        self.rvalue_scopes.insert(var, lifetime);\n+        self.rvalue_candidates.insert(var, candidate_type);\n     }\n \n     /// Returns the narrowest scope that encloses `id`, if any.\n@@ -367,34 +383,6 @@ impl ScopeTree {\n         self.var_map.get(&var_id).cloned()\n     }\n \n-    /// Returns the scope when the temp created by `expr_id` will be cleaned up.\n-    pub fn temporary_scope(&self, expr_id: hir::ItemLocalId) -> Option<Scope> {\n-        // Check for a designated rvalue scope.\n-        if let Some(&s) = self.rvalue_scopes.get(&expr_id) {\n-            debug!(\"temporary_scope({:?}) = {:?} [custom]\", expr_id, s);\n-            return s;\n-        }\n-\n-        // Otherwise, locate the innermost terminating scope\n-        // if there's one. Static items, for instance, won't\n-        // have an enclosing scope, hence no scope will be\n-        // returned.\n-        let mut id = Scope { id: expr_id, data: ScopeData::Node };\n-\n-        while let Some(&(p, _)) = self.parent_map.get(&id) {\n-            match p.data {\n-                ScopeData::Destruction => {\n-                    debug!(\"temporary_scope({:?}) = {:?} [enclosing]\", expr_id, id);\n-                    return Some(id);\n-                }\n-                _ => id = p,\n-            }\n-        }\n-\n-        debug!(\"temporary_scope({:?}) = None\", expr_id);\n-        None\n-    }\n-\n     /// Returns `true` if `subscope` is equal to or is lexically nested inside `superscope`, and\n     /// `false` otherwise.\n     ///\n@@ -439,7 +427,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ScopeTree {\n             ref parent_map,\n             ref var_map,\n             ref destruction_scopes,\n-            ref rvalue_scopes,\n+            ref rvalue_candidates,\n             ref yield_in_scope,\n         } = *self;\n \n@@ -448,7 +436,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ScopeTree {\n         parent_map.hash_stable(hcx, hasher);\n         var_map.hash_stable(hcx, hasher);\n         destruction_scopes.hash_stable(hcx, hasher);\n-        rvalue_scopes.hash_stable(hcx, hasher);\n+        rvalue_candidates.hash_stable(hcx, hasher);\n         yield_in_scope.hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "0c936b7ae101bd7c3d7d6a5eff3884837792410d", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -1048,12 +1048,6 @@ rustc_queries! {\n         desc { \"reachability\" }\n     }\n \n-    /// Per-body `region::ScopeTree`. The `DefId` should be the owner `DefId` for the body;\n-    /// in the case of closures, this will be redirected to the enclosing function.\n-    query region_scope_tree(def_id: DefId) -> &'tcx region::ScopeTree {\n-        desc { |tcx| \"computing drop scopes for `{}`\", tcx.def_path_str(def_id) }\n-    }\n-\n     /// Generates a MIR body for the shim.\n     query mir_shims(key: ty::InstanceDef<'tcx>) -> mir::Body<'tcx> {\n         storage(ArenaCacheSelector<'tcx>)"}, {"sha": "6b92a4c0a2ea6249d2c5d72ba7edc9411c22c36c", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -6,6 +6,7 @@ use crate::hir::place::Place as HirPlace;\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n use crate::lint::{struct_lint_level, LintDiagnosticBuilder, LintLevelSource};\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n+use crate::middle::region::ScopeTree;\n use crate::middle::resolve_lifetime::{self, LifetimeScopeForPath};\n use crate::middle::stability;\n use crate::mir::interpret::{self, Allocation, ConstAllocation, ConstValue, Scalar};\n@@ -74,6 +75,8 @@ use std::mem;\n use std::ops::{Bound, Deref};\n use std::sync::Arc;\n \n+use super::RvalueScopes;\n+\n pub trait OnDiskCache<'tcx>: rustc_data_structures::sync::Sync {\n     /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n     fn new(sess: &'tcx Session, data: Mmap, start_pos: usize) -> Self\n@@ -535,6 +538,17 @@ pub struct TypeckResults<'tcx> {\n     /// issue by fake reading `t`.\n     pub closure_fake_reads: FxHashMap<DefId, Vec<(HirPlace<'tcx>, FakeReadCause, hir::HirId)>>,\n \n+    /// Tracks critical information about regions in a body.\n+    /// This includes containment relationship between regions,\n+    /// liveness relationship between variables and regions and\n+    /// information about yield points.\n+    pub region_scope_tree: ScopeTree,\n+\n+    /// Tracks the rvalue scoping rules which defines finer scoping for rvalue expressions\n+    /// by applying extended parameter rules.\n+    /// Details may be find in `rustc_typeck::check::rvalue_scopes`.\n+    pub rvalue_scopes: RvalueScopes,\n+\n     /// Stores the type, expression, span and optional scope span of all types\n     /// that are live across the yield of this generator (if a generator).\n     pub generator_interior_types: ty::Binder<'tcx, Vec<GeneratorInteriorTypeCause<'tcx>>>,\n@@ -572,6 +586,8 @@ impl<'tcx> TypeckResults<'tcx> {\n             concrete_opaque_types: Default::default(),\n             closure_min_captures: Default::default(),\n             closure_fake_reads: Default::default(),\n+            region_scope_tree: Default::default(),\n+            rvalue_scopes: Default::default(),\n             generator_interior_types: ty::Binder::dummy(Default::default()),\n             treat_byte_string_as_slice: Default::default(),\n             closure_size_eval: Default::default(),"}, {"sha": "775b06c6c3832e45414948877264ba04b15cc29a", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -72,6 +72,7 @@ pub use self::context::{\n };\n pub use self::instance::{Instance, InstanceDef};\n pub use self::list::List;\n+pub use self::rvalue_scopes::RvalueScopes;\n pub use self::sty::BoundRegionKind::*;\n pub use self::sty::RegionKind::*;\n pub use self::sty::TyKind::*;\n@@ -118,6 +119,7 @@ mod generics;\n mod impls_ty;\n mod instance;\n mod list;\n+mod rvalue_scopes;\n mod structural_impls;\n mod sty;\n "}, {"sha": "65f41c5266d17d808300c1a142526146cf457f54", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -6,7 +6,6 @@ use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n use crate::middle::lib_features::LibFeatures;\n use crate::middle::privacy::AccessLevels;\n-use crate::middle::region;\n use crate::middle::resolve_lifetime::{\n     LifetimeScopeForPath, ObjectLifetimeDefault, Region, ResolveLifetimes,\n };"}, {"sha": "e86dafae338f2e1fa5ec0e844a4fc91962f916ea", "filename": "compiler/rustc_middle/src/ty/rvalue_scopes.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_middle%2Fsrc%2Fty%2Frvalue_scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_middle%2Fsrc%2Fty%2Frvalue_scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frvalue_scopes.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -0,0 +1,57 @@\n+use crate::middle::region::{Scope, ScopeData, ScopeTree};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir as hir;\n+\n+/// `RvalueScopes` is a mapping from sub-expressions to _extended_ lifetime as determined by\n+/// rules laid out in `rustc_typeck::check::rvalue_scopes`.\n+#[derive(TyEncodable, TyDecodable, Clone, Debug, Default, Eq, PartialEq, HashStable)]\n+pub struct RvalueScopes {\n+    map: FxHashMap<hir::ItemLocalId, Option<Scope>>,\n+}\n+\n+impl RvalueScopes {\n+    pub fn new() -> Self {\n+        Self { map: <_>::default() }\n+    }\n+\n+    /// Returns the scope when the temp created by `expr_id` will be cleaned up.\n+    pub fn temporary_scope(\n+        &self,\n+        region_scope_tree: &ScopeTree,\n+        expr_id: hir::ItemLocalId,\n+    ) -> Option<Scope> {\n+        // Check for a designated rvalue scope.\n+        if let Some(&s) = self.map.get(&expr_id) {\n+            debug!(\"temporary_scope({expr_id:?}) = {s:?} [custom]\");\n+            return s;\n+        }\n+\n+        // Otherwise, locate the innermost terminating scope\n+        // if there's one. Static items, for instance, won't\n+        // have an enclosing scope, hence no scope will be\n+        // returned.\n+        let mut id = Scope { id: expr_id, data: ScopeData::Node };\n+\n+        while let Some(&(p, _)) = region_scope_tree.parent_map.get(&id) {\n+            match p.data {\n+                ScopeData::Destruction => {\n+                    debug!(\"temporary_scope({expr_id:?}) = {id:?} [enclosing]\");\n+                    return Some(id);\n+                }\n+                _ => id = p,\n+            }\n+        }\n+\n+        debug!(\"temporary_scope({expr_id:?}) = None\");\n+        None\n+    }\n+\n+    /// Make an association between a sub-expression and an extended lifetime\n+    pub fn record_rvalue_scope(&mut self, var: hir::ItemLocalId, lifetime: Option<Scope>) {\n+        debug!(\"record_rvalue_scope(var={var:?}, lifetime={lifetime:?})\");\n+        if let Some(lifetime) = lifetime {\n+            assert!(var != lifetime.item_local_id());\n+        }\n+        self.map.insert(var, lifetime);\n+    }\n+}"}, {"sha": "e8b939fb51d9db3bcf596d7b08464833558dbe8b", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -108,7 +108,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let_scope_stack.push(remainder_scope);\n \n                     // Declare the bindings, which may create a source scope.\n-                    let remainder_span = remainder_scope.span(this.tcx, this.region_scope_tree);\n+                    let remainder_span =\n+                        remainder_scope.span(this.tcx, &this.typeck_results.region_scope_tree);\n \n                     let visibility_scope =\n                         Some(this.new_source_scope(remainder_span, LintLevel::Inherited, None));"}, {"sha": "56acf65d9c5aaedd1bfdb083e4df3081aab39def", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -699,7 +699,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.cfg.push(block, Statement { source_info, kind: StatementKind::StorageLive(local_id) });\n         // Altough there is almost always scope for given variable in corner cases\n         // like #92893 we might get variable with no scope.\n-        if let Some(region_scope) = self.region_scope_tree.var_scope(var.local_id) && schedule_drop{\n+        if let Some(region_scope) = self.typeck_results.region_scope_tree.var_scope(var.local_id) && schedule_drop{\n             self.schedule_drop(span, region_scope, local_id, DropKind::Storage);\n         }\n         Place::from(local_id)\n@@ -712,7 +712,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         for_guard: ForGuard,\n     ) {\n         let local_id = self.var_local_id(var, for_guard);\n-        if let Some(region_scope) = self.region_scope_tree.var_scope(var.local_id) {\n+        if let Some(region_scope) = self.typeck_results.region_scope_tree.var_scope(var.local_id) {\n             self.schedule_drop(span, region_scope, local_id, DropKind::Value);\n         }\n     }"}, {"sha": "c42f2b3a67a4f7a5218a79b30dde574bf07e05a3", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -398,7 +398,6 @@ struct Builder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     typeck_results: &'tcx TypeckResults<'tcx>,\n-    region_scope_tree: &'tcx region::ScopeTree,\n     param_env: ty::ParamEnv<'tcx>,\n \n     thir: &'a Thir<'tcx>,\n@@ -881,7 +880,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             tcx,\n             infcx,\n             typeck_results: tcx.typeck_opt_const_arg(def),\n-            region_scope_tree: tcx.region_scope_tree(def.did),\n             param_env,\n             def_id: def.did.to_def_id(),\n             hir_id,"}, {"sha": "53f9706f021eeb26f9f081cf01bd4dea455ffcc2", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -916,7 +916,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             if scope.region_scope == region_scope {\n-                let region_scope_span = region_scope.span(self.tcx, &self.region_scope_tree);\n+                let region_scope_span =\n+                    region_scope.span(self.tcx, &self.typeck_results.region_scope_tree);\n                 // Attribute scope exit drops to scope's closing brace.\n                 let scope_end = self.tcx.sess.source_map().end_point(region_scope_span);\n "}, {"sha": "480c5b195cc2d43db1de7cb8ef41147714230483", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -32,7 +32,8 @@ impl<'tcx> Cx<'tcx> {\n     }\n \n     pub(super) fn mirror_expr_inner(&mut self, hir_expr: &'tcx hir::Expr<'tcx>) -> ExprId {\n-        let temp_lifetime = self.region_scope_tree.temporary_scope(hir_expr.hir_id.local_id);\n+        let temp_lifetime =\n+            self.rvalue_scopes.temporary_scope(self.region_scope_tree, hir_expr.hir_id.local_id);\n         let expr_scope =\n             region::Scope { id: hir_expr.hir_id.local_id, data: region::ScopeData::Node };\n \n@@ -161,7 +162,8 @@ impl<'tcx> Cx<'tcx> {\n         let tcx = self.tcx;\n         let expr_ty = self.typeck_results().expr_ty(expr);\n         let expr_span = expr.span;\n-        let temp_lifetime = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+        let temp_lifetime =\n+            self.rvalue_scopes.temporary_scope(self.region_scope_tree, expr.hir_id.local_id);\n \n         let kind = match expr.kind {\n             // Here comes the interesting stuff:\n@@ -575,7 +577,9 @@ impl<'tcx> Cx<'tcx> {\n             },\n             hir::ExprKind::Loop(ref body, ..) => {\n                 let block_ty = self.typeck_results().node_type(body.hir_id);\n-                let temp_lifetime = self.region_scope_tree.temporary_scope(body.hir_id.local_id);\n+                let temp_lifetime = self\n+                    .rvalue_scopes\n+                    .temporary_scope(self.region_scope_tree, body.hir_id.local_id);\n                 let block = self.mirror_block(body);\n                 let body = self.thir.exprs.push(Expr {\n                     ty: block_ty,\n@@ -776,7 +780,8 @@ impl<'tcx> Cx<'tcx> {\n         span: Span,\n         overloaded_callee: Option<(DefId, SubstsRef<'tcx>)>,\n     ) -> Expr<'tcx> {\n-        let temp_lifetime = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+        let temp_lifetime =\n+            self.rvalue_scopes.temporary_scope(self.region_scope_tree, expr.hir_id.local_id);\n         let (def_id, substs, user_ty) = match overloaded_callee {\n             Some((def_id, substs)) => (def_id, substs, None),\n             None => {\n@@ -863,7 +868,9 @@ impl<'tcx> Cx<'tcx> {\n             // a constant reference (or constant raw pointer for `static mut`) in MIR\n             Res::Def(DefKind::Static(_), id) => {\n                 let ty = self.tcx.static_ptr_ty(id);\n-                let temp_lifetime = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+                let temp_lifetime = self\n+                    .rvalue_scopes\n+                    .temporary_scope(self.region_scope_tree, expr.hir_id.local_id);\n                 let kind = if self.tcx.is_thread_local_static(id) {\n                     ExprKind::ThreadLocalRef(id)\n                 } else {\n@@ -939,7 +946,8 @@ impl<'tcx> Cx<'tcx> {\n \n         // construct the complete expression `foo()` for the overloaded call,\n         // which will yield the &T type\n-        let temp_lifetime = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+        let temp_lifetime =\n+            self.rvalue_scopes.temporary_scope(self.region_scope_tree, expr.hir_id.local_id);\n         let fun = self.method_callee(expr, span, overloaded_callee);\n         let fun = self.thir.exprs.push(fun);\n         let fun_ty = self.thir[fun].ty;\n@@ -959,7 +967,9 @@ impl<'tcx> Cx<'tcx> {\n         closure_expr: &'tcx hir::Expr<'tcx>,\n         place: HirPlace<'tcx>,\n     ) -> Expr<'tcx> {\n-        let temp_lifetime = self.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n+        let temp_lifetime = self\n+            .rvalue_scopes\n+            .temporary_scope(self.region_scope_tree, closure_expr.hir_id.local_id);\n         let var_ty = place.base_ty;\n \n         // The result of capture analysis in `rustc_typeck/check/upvar.rs`represents a captured path\n@@ -1014,7 +1024,9 @@ impl<'tcx> Cx<'tcx> {\n         let upvar_capture = captured_place.info.capture_kind;\n         let captured_place_expr =\n             self.convert_captured_hir_place(closure_expr, captured_place.place.clone());\n-        let temp_lifetime = self.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n+        let temp_lifetime = self\n+            .rvalue_scopes\n+            .temporary_scope(self.region_scope_tree, closure_expr.hir_id.local_id);\n \n         match upvar_capture {\n             ty::UpvarCapture::ByValue => captured_place_expr,"}, {"sha": "13b4e90ca09ce05a530840433566157898b80905", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -16,7 +16,7 @@ use rustc_middle::middle::region;\n use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n use rustc_middle::mir::ConstantKind;\n use rustc_middle::thir::*;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, RvalueScopes, Ty, TyCtxt};\n use rustc_span::Span;\n \n pub(crate) fn thir_body<'tcx>(\n@@ -51,6 +51,7 @@ struct Cx<'tcx> {\n \n     pub(crate) region_scope_tree: &'tcx region::ScopeTree,\n     pub(crate) typeck_results: &'tcx ty::TypeckResults<'tcx>,\n+    pub(crate) rvalue_scopes: &'tcx RvalueScopes,\n \n     /// When applying adjustments to the expression\n     /// with the given `HirId`, use the given `Span`,\n@@ -71,8 +72,9 @@ impl<'tcx> Cx<'tcx> {\n             tcx,\n             thir: Thir::new(),\n             param_env: tcx.param_env(def.did),\n-            region_scope_tree: tcx.region_scope_tree(def.did),\n+            region_scope_tree: &typeck_results.region_scope_tree,\n             typeck_results,\n+            rvalue_scopes: &typeck_results.rvalue_scopes,\n             body_owner: def.did.to_def_id(),\n             adjustment_span: None,\n         }"}, {"sha": "510280ee38637259b9427e8792e194082445bb03", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -38,7 +38,6 @@ mod liveness;\n pub mod loops;\n mod naked_functions;\n mod reachable;\n-mod region;\n pub mod stability;\n mod upvars;\n mod weak_lang_items;\n@@ -57,7 +56,6 @@ pub fn provide(providers: &mut Providers) {\n     liveness::provide(providers);\n     intrinsicck::provide(providers);\n     reachable::provide(providers);\n-    region::provide(providers);\n     stability::provide(providers);\n     upvars::provide(providers);\n }"}, {"sha": "649bc21132163ef67052931976c53686e92705e7", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -4,6 +4,7 @@ use crate::astconv::{\n };\n use crate::check::callee::{self, DeferredCallResolution};\n use crate::check::method::{self, MethodCallee, SelfSource};\n+use crate::check::{region, rvalue_scopes};\n use crate::check::{BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy};\n \n use rustc_data_structures::captures::Captures;\n@@ -620,6 +621,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.normalize_associated_types_in(span, field.ty(self.tcx, substs))\n     }\n \n+    pub(in super::super) fn resolve_rvalue_scopes(&self, def_id: DefId) {\n+        let scope_tree = region::region_scope_tree(self.tcx, def_id);\n+        let rvalue_scopes = { rvalue_scopes::resolve_rvalue_scopes(self, &scope_tree, def_id) };\n+        let mut typeck_results = self.inh.typeck_results.borrow_mut();\n+        typeck_results.region_scope_tree = scope_tree;\n+        typeck_results.rvalue_scopes = rvalue_scopes;\n+    }\n+\n     pub(in super::super) fn resolve_generator_interiors(&self, def_id: DefId) {\n         let mut generators = self.deferred_generator_interiors.borrow_mut();\n         for (body_id, interior, kind) in generators.drain(..) {"}, {"sha": "02167ddef448641edc22719103aa4493f8efa526", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -14,7 +14,7 @@ use rustc_hir::hir_id::HirIdSet;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind};\n use rustc_middle::middle::region::{self, Scope, ScopeData, YieldData};\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, RvalueScopes, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use tracing::debug;\n@@ -23,8 +23,9 @@ mod drop_ranges;\n \n struct InteriorVisitor<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n+    region_scope_tree: &'a region::ScopeTree,\n     types: FxIndexSet<ty::GeneratorInteriorTypeCause<'tcx>>,\n-    region_scope_tree: &'tcx region::ScopeTree,\n+    rvalue_scopes: &'a RvalueScopes,\n     expr_count: usize,\n     kind: hir::GeneratorKind,\n     prev_unresolved_span: Option<Span>,\n@@ -179,10 +180,12 @@ pub fn resolve_interior<'a, 'tcx>(\n     kind: hir::GeneratorKind,\n ) {\n     let body = fcx.tcx.hir().body(body_id);\n+    let typeck_results = fcx.inh.typeck_results.borrow();\n     let mut visitor = InteriorVisitor {\n         fcx,\n         types: FxIndexSet::default(),\n-        region_scope_tree: fcx.tcx.region_scope_tree(def_id),\n+        region_scope_tree: &typeck_results.region_scope_tree,\n+        rvalue_scopes: &typeck_results.rvalue_scopes,\n         expr_count: 0,\n         kind,\n         prev_unresolved_span: None,\n@@ -192,7 +195,7 @@ pub fn resolve_interior<'a, 'tcx>(\n     intravisit::walk_body(&mut visitor, body);\n \n     // Check that we visited the same amount of expressions as the RegionResolutionVisitor\n-    let region_expr_count = visitor.region_scope_tree.body_expr_count(body_id).unwrap();\n+    let region_expr_count = typeck_results.region_scope_tree.body_expr_count(body_id).unwrap();\n     assert_eq!(region_expr_count, visitor.expr_count);\n \n     // The types are already kept in insertion order.\n@@ -248,8 +251,9 @@ pub fn resolve_interior<'a, 'tcx>(\n     let witness =\n         fcx.tcx.mk_generator_witness(ty::Binder::bind_with_vars(type_list, bound_vars.clone()));\n \n+    drop(typeck_results);\n     // Store the generator types and spans into the typeck results for this generator.\n-    visitor.fcx.inh.typeck_results.borrow_mut().generator_interior_types =\n+    fcx.inh.typeck_results.borrow_mut().generator_interior_types =\n         ty::Binder::bind_with_vars(type_causes, bound_vars);\n \n     debug!(\n@@ -381,12 +385,14 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         // temporary on the stack that is live for the current temporary scope and then return a\n         // reference to it. That value may be live across the entire temporary scope.\n         let scope = if self.drop_ranges.is_borrowed_temporary(expr) {\n-            self.region_scope_tree.temporary_scope(expr.hir_id.local_id)\n+            self.rvalue_scopes.temporary_scope(self.region_scope_tree, expr.hir_id.local_id)\n         } else {\n             debug!(\"parent_node: {:?}\", self.fcx.tcx.hir().find_parent_node(expr.hir_id));\n             match self.fcx.tcx.hir().find_parent_node(expr.hir_id) {\n                 Some(parent) => Some(Scope { id: parent.local_id, data: ScopeData::Node }),\n-                None => self.region_scope_tree.temporary_scope(expr.hir_id.local_id),\n+                None => {\n+                    self.rvalue_scopes.temporary_scope(self.region_scope_tree, expr.hir_id.local_id)\n+                }\n             }\n         };\n "}, {"sha": "ba6fcb9892493d7f8abdaeeeaf1191271a5c76da", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -41,11 +41,12 @@ pub fn compute_drop_ranges<'a, 'tcx>(\n     if fcx.sess().opts.debugging_opts.drop_tracking {\n         let consumed_borrowed_places = find_consumed_and_borrowed(fcx, def_id, body);\n \n-        let num_exprs = fcx.tcx.region_scope_tree(def_id).body_expr_count(body.id()).unwrap_or(0);\n+        let typeck_results = &fcx.typeck_results.borrow();\n+        let num_exprs = typeck_results.region_scope_tree.body_expr_count(body.id()).unwrap_or(0);\n         let (mut drop_ranges, borrowed_temporaries) = build_control_flow_graph(\n             fcx.tcx.hir(),\n             fcx.tcx,\n-            &fcx.typeck_results.borrow(),\n+            typeck_results,\n             consumed_borrowed_places,\n             body,\n             num_exprs,"}, {"sha": "280fae5fe6dddf788887de770cc463ddcc04619a", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -85,7 +85,9 @@ pub mod method;\n mod op;\n mod pat;\n mod place_op;\n+mod region;\n mod regionck;\n+pub mod rvalue_scopes;\n mod upvar;\n mod wfcheck;\n pub mod writeback;\n@@ -473,6 +475,9 @@ fn typeck_with_fallback<'tcx>(\n         // because they don't constrain other type variables.\n         fcx.closure_analyze(body);\n         assert!(fcx.deferred_call_resolutions.borrow().is_empty());\n+        // Before the generator analysis, temporary scopes shall be marked to provide more\n+        // precise information on types to be captured.\n+        fcx.resolve_rvalue_scopes(def_id.to_def_id());\n         fcx.resolve_generator_interiors(def_id.to_def_id());\n \n         for (ty, span, code) in fcx.deferred_sized_obligations.borrow_mut().drain(..) {"}, {"sha": "43d189abcf7e4402052414fea12700b2abaf381c", "filename": "compiler/rustc_typeck/src/check/region.rs", "status": "renamed", "additions": 30, "deletions": 60, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -14,7 +14,6 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{Arm, Block, Expr, Local, Pat, PatKind, Stmt};\n use rustc_index::vec::Idx;\n use rustc_middle::middle::region::*;\n-use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::source_map;\n use rustc_span::Span;\n@@ -527,7 +526,13 @@ fn resolve_local<'tcx>(\n \n         if let Some(pat) = pat {\n             if is_binding_pat(pat) {\n-                record_rvalue_scope(visitor, &expr, blk_scope);\n+                visitor.scope_tree.record_rvalue_candidate(\n+                    expr.hir_id,\n+                    RvalueCandidateType::Pattern {\n+                        target: expr.hir_id.local_id,\n+                        lifetime: blk_scope,\n+                    },\n+                );\n             }\n         }\n     }\n@@ -625,9 +630,15 @@ fn resolve_local<'tcx>(\n         blk_id: Option<Scope>,\n     ) {\n         match expr.kind {\n-            hir::ExprKind::AddrOf(_, _, ref subexpr) => {\n-                record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n-                record_rvalue_scope(visitor, &subexpr, blk_id);\n+            hir::ExprKind::AddrOf(_, _, subexpr) => {\n+                record_rvalue_scope_if_borrow_expr(visitor, subexpr, blk_id);\n+                visitor.scope_tree.record_rvalue_candidate(\n+                    subexpr.hir_id,\n+                    RvalueCandidateType::Borrow {\n+                        target: subexpr.hir_id.local_id,\n+                        lifetime: blk_id,\n+                    },\n+                );\n             }\n             hir::ExprKind::Struct(_, fields, _) => {\n                 for field in fields {\n@@ -647,52 +658,15 @@ fn resolve_local<'tcx>(\n                     record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n                 }\n             }\n-            _ => {}\n-        }\n-    }\n-\n-    /// Applied to an expression `expr` if `expr` -- or something owned or partially owned by\n-    /// `expr` -- is going to be indirectly referenced by a variable in a let statement. In that\n-    /// case, the \"temporary lifetime\" or `expr` is extended to be the block enclosing the `let`\n-    /// statement.\n-    ///\n-    /// More formally, if `expr` matches the grammar `ET`, record the rvalue scope of the matching\n-    /// `<rvalue>` as `blk_id`:\n-    ///\n-    /// ```text\n-    ///     ET = *ET\n-    ///        | ET[...]\n-    ///        | ET.f\n-    ///        | (ET)\n-    ///        | <rvalue>\n-    /// ```\n-    ///\n-    /// Note: ET is intended to match \"rvalues or places based on rvalues\".\n-    fn record_rvalue_scope<'tcx>(\n-        visitor: &mut RegionResolutionVisitor<'tcx>,\n-        expr: &hir::Expr<'_>,\n-        blk_scope: Option<Scope>,\n-    ) {\n-        let mut expr = expr;\n-        loop {\n-            // Note: give all the expressions matching `ET` with the\n-            // extended temporary lifetime, not just the innermost rvalue,\n-            // because in codegen if we must compile e.g., `*rvalue()`\n-            // into a temporary, we request the temporary scope of the\n-            // outer expression.\n-            visitor.scope_tree.record_rvalue_scope(expr.hir_id.local_id, blk_scope);\n-\n-            match expr.kind {\n-                hir::ExprKind::AddrOf(_, _, ref subexpr)\n-                | hir::ExprKind::Unary(hir::UnOp::Deref, ref subexpr)\n-                | hir::ExprKind::Field(ref subexpr, _)\n-                | hir::ExprKind::Index(ref subexpr, _) => {\n-                    expr = &subexpr;\n-                }\n-                _ => {\n-                    return;\n-                }\n+            hir::ExprKind::Call(..) | hir::ExprKind::MethodCall(..) => {\n+                // FIXME(@dingxiangfei2009): choose call arguments here\n+                // for candidacy for extended parameter rule application\n+            }\n+            hir::ExprKind::Index(..) => {\n+                // FIXME(@dingxiangfei2009): select the indices\n+                // as candidate for rvalue scope rules\n             }\n+            _ => {}\n         }\n     }\n }\n@@ -821,14 +795,16 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n     }\n }\n \n-fn region_scope_tree(tcx: TyCtxt<'_>, def_id: DefId) -> &ScopeTree {\n+/// Per-body `region::ScopeTree`. The `DefId` should be the owner `DefId` for the body;\n+/// in the case of closures, this will be redirected to the enclosing function.\n+pub fn region_scope_tree(tcx: TyCtxt<'_>, def_id: DefId) -> ScopeTree {\n     let typeck_root_def_id = tcx.typeck_root_def_id(def_id);\n     if typeck_root_def_id != def_id {\n-        return tcx.region_scope_tree(typeck_root_def_id);\n+        return region_scope_tree(tcx, typeck_root_def_id);\n     }\n \n     let id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-    let scope_tree = if let Some(body_id) = tcx.hir().maybe_body_owned_by(id) {\n+    if let Some(body_id) = tcx.hir().maybe_body_owned_by(id) {\n         let mut visitor = RegionResolutionVisitor {\n             tcx,\n             scope_tree: ScopeTree::default(),\n@@ -845,11 +821,5 @@ fn region_scope_tree(tcx: TyCtxt<'_>, def_id: DefId) -> &ScopeTree {\n         visitor.scope_tree\n     } else {\n         ScopeTree::default()\n-    };\n-\n-    tcx.arena.alloc(scope_tree)\n-}\n-\n-pub fn provide(providers: &mut Providers) {\n-    *providers = Providers { region_scope_tree, ..*providers };\n+    }\n }", "previous_filename": "compiler/rustc_passes/src/region.rs"}, {"sha": "01a76ce558682658505b1c19b613c03cd1d3a6ec", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -75,7 +75,6 @@\n use crate::check::dropck;\n use crate::check::FnCtxt;\n use crate::mem_categorization as mc;\n-use crate::middle::region;\n use crate::outlives::outlives_bounds::InferCtxtExt as _;\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_hir as hir;\n@@ -219,8 +218,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n pub struct RegionCtxt<'a, 'tcx> {\n     pub fcx: &'a FnCtxt<'a, 'tcx>,\n \n-    pub region_scope_tree: &'tcx region::ScopeTree,\n-\n     outlives_environment: OutlivesEnvironment<'tcx>,\n \n     // id of innermost fn body id\n@@ -247,11 +244,9 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         Subject(subject): Subject,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> RegionCtxt<'a, 'tcx> {\n-        let region_scope_tree = fcx.tcx.region_scope_tree(subject);\n         let outlives_environment = OutlivesEnvironment::new(param_env);\n         RegionCtxt {\n             fcx,\n-            region_scope_tree,\n             body_id: initial_body_id,\n             body_owner: subject,\n             subject_def_id: subject,"}, {"sha": "22c9e7961070c6d14e6761bd16f230e408b8d3f1", "filename": "compiler/rustc_typeck/src/check/rvalue_scopes.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Frvalue_scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Frvalue_scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Frvalue_scopes.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -0,0 +1,83 @@\n+use super::FnCtxt;\n+use hir::def_id::DefId;\n+use hir::Node;\n+use rustc_hir as hir;\n+use rustc_middle::middle::region::{RvalueCandidateType, Scope, ScopeTree};\n+use rustc_middle::ty::RvalueScopes;\n+\n+/// Applied to an expression `expr` if `expr` -- or something owned or partially owned by\n+/// `expr` -- is going to be indirectly referenced by a variable in a let statement. In that\n+/// case, the \"temporary lifetime\" or `expr` is extended to be the block enclosing the `let`\n+/// statement.\n+///\n+/// More formally, if `expr` matches the grammar `ET`, record the rvalue scope of the matching\n+/// `<rvalue>` as `blk_id`:\n+///\n+/// ```text\n+///     ET = *ET\n+///        | ET[...]\n+///        | ET.f\n+///        | (ET)\n+///        | <rvalue>\n+/// ```\n+///\n+/// Note: ET is intended to match \"rvalues or places based on rvalues\".\n+fn record_rvalue_scope_rec(\n+    rvalue_scopes: &mut RvalueScopes,\n+    mut expr: &hir::Expr<'_>,\n+    lifetime: Option<Scope>,\n+) {\n+    loop {\n+        // Note: give all the expressions matching `ET` with the\n+        // extended temporary lifetime, not just the innermost rvalue,\n+        // because in codegen if we must compile e.g., `*rvalue()`\n+        // into a temporary, we request the temporary scope of the\n+        // outer expression.\n+\n+        rvalue_scopes.record_rvalue_scope(expr.hir_id.local_id, lifetime);\n+\n+        match expr.kind {\n+            hir::ExprKind::AddrOf(_, _, subexpr)\n+            | hir::ExprKind::Unary(hir::UnOp::Deref, subexpr)\n+            | hir::ExprKind::Field(subexpr, _)\n+            | hir::ExprKind::Index(subexpr, _) => {\n+                expr = subexpr;\n+            }\n+            _ => {\n+                return;\n+            }\n+        }\n+    }\n+}\n+fn record_rvalue_scope(\n+    rvalue_scopes: &mut RvalueScopes,\n+    expr: &hir::Expr<'_>,\n+    candidate: &RvalueCandidateType,\n+) {\n+    debug!(\"resolve_rvalue_scope(expr={expr:?}, candidate={candidate:?})\");\n+    match candidate {\n+        RvalueCandidateType::Borrow { lifetime, .. }\n+        | RvalueCandidateType::Pattern { lifetime, .. } => {\n+            record_rvalue_scope_rec(rvalue_scopes, expr, *lifetime)\n+        } // FIXME(@dingxiangfei2009): handle the candidates in the function call arguments\n+    }\n+}\n+\n+pub fn resolve_rvalue_scopes<'a, 'tcx>(\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n+    scope_tree: &'a ScopeTree,\n+    def_id: DefId,\n+) -> RvalueScopes {\n+    let tcx = &fcx.tcx;\n+    let hir_map = tcx.hir();\n+    let mut rvalue_scopes = RvalueScopes::new();\n+    debug!(\"start resolving rvalue scopes, def_id={def_id:?}\");\n+    debug!(\"rvalue_scope: rvalue_candidates={:?}\", scope_tree.rvalue_candidates);\n+    for (&hir_id, candidate) in &scope_tree.rvalue_candidates {\n+        let Some(Node::Expr(expr)) = hir_map.find(hir_id) else {\n+            bug!(\"hir node does not exist\")\n+        };\n+        record_rvalue_scope(&mut rvalue_scopes, expr, candidate);\n+    }\n+    rvalue_scopes\n+}"}, {"sha": "16096ea3d74c54270f7be568bb0888a4c0e3e683", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -71,6 +71,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         wbcx.visit_user_provided_sigs();\n         wbcx.visit_generator_interior_types();\n \n+        wbcx.typeck_results.region_scope_tree =\n+            mem::take(&mut self.typeck_results.borrow_mut().region_scope_tree);\n+        wbcx.typeck_results.rvalue_scopes =\n+            mem::take(&mut self.typeck_results.borrow_mut().rvalue_scopes);\n+\n         let used_trait_imports =\n             mem::take(&mut self.typeck_results.borrow_mut().used_trait_imports);\n         debug!(\"used_trait_imports({:?}) = {:?}\", item_def_id, used_trait_imports);"}, {"sha": "e2b82f9fd02ad2552bf5bd8910705e7fdc13a381", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 53, "deletions": 23, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -3,7 +3,9 @@ use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n use clippy_utils::source::snippet;\n use clippy_utils::ty::has_iter_method;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{contains_name, higher, is_integer_const, match_trait_method, paths, sugg, SpanlessEq};\n+use clippy_utils::{\n+    contains_name, higher, is_integer_const, match_trait_method, paths, sugg, SpanlessEq,\n+};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -27,12 +29,7 @@ pub(super) fn check<'tcx>(\n     body: &'tcx Expr<'_>,\n     expr: &'tcx Expr<'_>,\n ) {\n-    if let Some(higher::Range {\n-        start: Some(start),\n-        ref end,\n-        limits,\n-    }) = higher::Range::hir(arg)\n-    {\n+    if let Some(higher::Range { start: Some(start), ref end, limits }) = higher::Range::hir(arg) {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, ident, _) = pat.kind {\n             let mut visitor = VarVisitor {\n@@ -58,7 +55,11 @@ pub(super) fn check<'tcx>(\n                 // ensure that the indexed variable was declared before the loop, see #601\n                 if let Some(indexed_extent) = indexed_extent {\n                     let parent_def_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n-                    let region_scope_tree = cx.tcx.region_scope_tree(parent_def_id);\n+                    let parent_body_id = cx\n+                        .tcx\n+                        .hir()\n+                        .body_owned_by(cx.tcx.hir().local_def_id_to_hir_id(parent_def_id));\n+                    let region_scope_tree = &cx.tcx.typeck_body(parent_body_id).region_scope_tree;\n                     let pat_extent = region_scope_tree.var_scope(pat.hir_id.local_id).unwrap();\n                     if region_scope_tree.is_subscope_of(indexed_extent, pat_extent) {\n                         return;\n@@ -107,17 +108,22 @@ pub(super) fn check<'tcx>(\n                         }\n                     }\n \n-                    if is_len_call(end, indexed) || is_end_eq_array_len(cx, end, limits, indexed_ty) {\n+                    if is_len_call(end, indexed) || is_end_eq_array_len(cx, end, limits, indexed_ty)\n+                    {\n                         String::new()\n-                    } else if visitor.indexed_mut.contains(&indexed) && contains_name(indexed, take_expr) {\n+                    } else if visitor.indexed_mut.contains(&indexed)\n+                        && contains_name(indexed, take_expr)\n+                    {\n                         return;\n                     } else {\n                         match limits {\n                             ast::RangeLimits::Closed => {\n                                 let take_expr = sugg::Sugg::hir(cx, take_expr, \"<count>\");\n                                 format!(\".take({})\", take_expr + sugg::ONE)\n-                            },\n-                            ast::RangeLimits::HalfOpen => format!(\".take({})\", snippet(cx, take_expr.span, \"..\")),\n+                            }\n+                            ast::RangeLimits::HalfOpen => {\n+                                format!(\".take({})\", snippet(cx, take_expr.span, \"..\"))\n+                            }\n                         }\n                     }\n                 } else {\n@@ -143,7 +149,10 @@ pub(super) fn check<'tcx>(\n                         cx,\n                         NEEDLESS_RANGE_LOOP,\n                         arg.span,\n-                        &format!(\"the loop variable `{}` is used to index `{}`\", ident.name, indexed),\n+                        &format!(\n+                            \"the loop variable `{}` is used to index `{}`\",\n+                            ident.name, indexed\n+                        ),\n                         |diag| {\n                             multispan_sugg(\n                                 diag,\n@@ -152,7 +161,10 @@ pub(super) fn check<'tcx>(\n                                     (pat.span, format!(\"({}, <item>)\", ident.name)),\n                                     (\n                                         arg.span,\n-                                        format!(\"{}.{}().enumerate(){}{}\", indexed, method, method_1, method_2),\n+                                        format!(\n+                                            \"{}.{}().enumerate(){}{}\",\n+                                            indexed, method, method_1, method_2\n+                                        ),\n                                     ),\n                                 ],\n                             );\n@@ -169,7 +181,10 @@ pub(super) fn check<'tcx>(\n                         cx,\n                         NEEDLESS_RANGE_LOOP,\n                         arg.span,\n-                        &format!(\"the loop variable `{}` is only used to index `{}`\", ident.name, indexed),\n+                        &format!(\n+                            \"the loop variable `{}` is only used to index `{}`\",\n+                            ident.name, indexed\n+                        ),\n                         |diag| {\n                             multispan_sugg(\n                                 diag,\n@@ -246,7 +261,12 @@ struct VarVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n-    fn check(&mut self, idx: &'tcx Expr<'_>, seqexpr: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) -> bool {\n+    fn check(\n+        &mut self,\n+        idx: &'tcx Expr<'_>,\n+        seqexpr: &'tcx Expr<'_>,\n+        expr: &'tcx Expr<'_>,\n+    ) -> bool {\n         if_chain! {\n             // the indexed container is referenced by a name\n             if let ExprKind::Path(ref seqpath) = seqexpr.kind;\n@@ -262,7 +282,16 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                 match res {\n                     Res::Local(hir_id) => {\n                         let parent_def_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n-                        let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id).unwrap();\n+                        let parent_body_id = self.cx\n+                            .tcx\n+                            .hir()\n+                            .body_owned_by(self.cx.tcx.hir().local_def_id_to_hir_id(parent_def_id));\n+                        let extent = self.cx\n+                            .tcx\n+                            .typeck_body(parent_body_id)\n+                            .region_scope_tree\n+                            .var_scope(hir_id.local_id)\n+                            .unwrap();\n                         if index_used_directly {\n                             self.indexed_directly.insert(\n                                 seqvar.segments[0].ident.name,\n@@ -331,13 +360,13 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                 self.visit_expr(lhs);\n                 self.prefer_mutable = false;\n                 self.visit_expr(rhs);\n-            },\n+            }\n             ExprKind::AddrOf(BorrowKind::Ref, mutbl, expr) => {\n                 if mutbl == Mutability::Mut {\n                     self.prefer_mutable = true;\n                 }\n                 self.visit_expr(expr);\n-            },\n+            }\n             ExprKind::Call(f, args) => {\n                 self.visit_expr(f);\n                 for expr in args {\n@@ -350,10 +379,11 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                     }\n                     self.visit_expr(expr);\n                 }\n-            },\n+            }\n             ExprKind::MethodCall(_, args, _) => {\n                 let def_id = self.cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n-                for (ty, expr) in iter::zip(self.cx.tcx.fn_sig(def_id).inputs().skip_binder(), args) {\n+                for (ty, expr) in iter::zip(self.cx.tcx.fn_sig(def_id).inputs().skip_binder(), args)\n+                {\n                     self.prefer_mutable = false;\n                     if let ty::Ref(_, _, mutbl) = *ty.kind() {\n                         if mutbl == Mutability::Mut {\n@@ -362,11 +392,11 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                     }\n                     self.visit_expr(expr);\n                 }\n-            },\n+            }\n             ExprKind::Closure(_, _, body_id, ..) => {\n                 let body = self.cx.tcx.hir().body(body_id);\n                 self.visit_expr(&body.value);\n-            },\n+            }\n             _ => walk_expr(self, expr),\n         }\n         self.prefer_mutable = old;"}, {"sha": "db32b8d740b3ed26573392add794115279f1d862", "filename": "src/tools/clippy/clippy_lints/src/shadow.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/653463731a7f01f519cf85f444869def27f00395/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653463731a7f01f519cf85f444869def27f00395/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs?ref=653463731a7f01f519cf85f444869def27f00395", "patch": "@@ -5,7 +5,9 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::hir_id::ItemLocalId;\n-use rustc_hir::{Block, Body, BodyOwnerKind, Expr, ExprKind, HirId, Let, Node, Pat, PatKind, QPath, UnOp};\n+use rustc_hir::{\n+    Block, Body, BodyOwnerKind, Expr, ExprKind, HirId, Let, Node, Pat, PatKind, QPath, UnOp,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{Span, Symbol};\n@@ -139,27 +141,31 @@ impl<'tcx> LateLintPass<'tcx> for Shadow {\n \n     fn check_body(&mut self, cx: &LateContext<'_>, body: &Body<'_>) {\n         let hir = cx.tcx.hir();\n-        if !matches!(\n-            hir.body_owner_kind(hir.body_owner_def_id(body.id())),\n-            BodyOwnerKind::Closure\n-        ) {\n+        if !matches!(hir.body_owner_kind(hir.body_owner_def_id(body.id())), BodyOwnerKind::Closure)\n+        {\n             self.bindings.push(FxHashMap::default());\n         }\n     }\n \n     fn check_body_post(&mut self, cx: &LateContext<'_>, body: &Body<'_>) {\n         let hir = cx.tcx.hir();\n-        if !matches!(\n-            hir.body_owner_kind(hir.body_owner_def_id(body.id())),\n-            BodyOwnerKind::Closure\n-        ) {\n+        if !matches!(hir.body_owner_kind(hir.body_owner_def_id(body.id())), BodyOwnerKind::Closure)\n+        {\n             self.bindings.pop();\n         }\n     }\n }\n \n-fn is_shadow(cx: &LateContext<'_>, owner: LocalDefId, first: ItemLocalId, second: ItemLocalId) -> bool {\n-    let scope_tree = cx.tcx.region_scope_tree(owner.to_def_id());\n+fn is_shadow(\n+    cx: &LateContext<'_>,\n+    owner: LocalDefId,\n+    first: ItemLocalId,\n+    second: ItemLocalId,\n+) -> bool {\n+    let scope_tree = &cx\n+        .tcx\n+        .typeck_body(cx.tcx.hir().body_owned_by(cx.tcx.hir().local_def_id_to_hir_id(owner)))\n+        .region_scope_tree;\n     let first_scope = scope_tree.var_scope(first).unwrap();\n     let second_scope = scope_tree.var_scope(second).unwrap();\n     scope_tree.is_subscope_of(second_scope, first_scope)\n@@ -174,15 +180,16 @@ fn lint_shadow(cx: &LateContext<'_>, pat: &Pat<'_>, shadowed: HirId, span: Span)\n                 snippet(cx, expr.span, \"..\")\n             );\n             (SHADOW_SAME, msg)\n-        },\n+        }\n         Some(expr) if is_local_used(cx, expr, shadowed) => {\n             let msg = format!(\"`{}` is shadowed\", snippet(cx, pat.span, \"_\"));\n             (SHADOW_REUSE, msg)\n-        },\n+        }\n         _ => {\n-            let msg = format!(\"`{}` shadows a previous, unrelated binding\", snippet(cx, pat.span, \"_\"));\n+            let msg =\n+                format!(\"`{}` shadows a previous, unrelated binding\", snippet(cx, pat.span, \"_\"));\n             (SHADOW_UNRELATED, msg)\n-        },\n+        }\n     };\n     span_lint_and_note(\n         cx,\n@@ -211,14 +218,7 @@ fn is_self_shadow(cx: &LateContext<'_>, pat: &Pat<'_>, mut expr: &Expr<'_>, hir_\n         expr = match expr.kind {\n             ExprKind::Box(e)\n             | ExprKind::AddrOf(_, _, e)\n-            | ExprKind::Block(\n-                &Block {\n-                    stmts: [],\n-                    expr: Some(e),\n-                    ..\n-                },\n-                _,\n-            )\n+            | ExprKind::Block(&Block { stmts: [], expr: Some(e), .. }, _)\n             | ExprKind::Unary(UnOp::Deref, e) => e,\n             ExprKind::Path(QPath::Resolved(None, path)) => break path.res == Res::Local(hir_id),\n             _ => break false,"}]}