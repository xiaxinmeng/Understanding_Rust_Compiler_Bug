{"sha": "ac24a517bcc04eeea7e49e985482d2c25328a685", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjMjRhNTE3YmNjMDRlZWVhN2U0OWU5ODU0ODJkMmMyNTMyOGE2ODU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-27T19:44:00Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-27T19:44:00Z"}, "message": "rollup merge of #23486: nikomatsakis/issue-23485\n\nWhen testing whether a default method predicates are satisfiable,\ncombine normalization with this check so that we also skip the\ndefault method if normalization fails. Fixes #23485.\n\nr? @nrc (I tried to address your nit from before as well)", "tree": {"sha": "34db358c3e72681f6a9220a873ed7c1e4dd18905", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34db358c3e72681f6a9220a873ed7c1e4dd18905"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac24a517bcc04eeea7e49e985482d2c25328a685", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac24a517bcc04eeea7e49e985482d2c25328a685", "html_url": "https://github.com/rust-lang/rust/commit/ac24a517bcc04eeea7e49e985482d2c25328a685", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac24a517bcc04eeea7e49e985482d2c25328a685/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f1d57fcdede5c436c8b788691b9e25b289f9a27", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f1d57fcdede5c436c8b788691b9e25b289f9a27", "html_url": "https://github.com/rust-lang/rust/commit/3f1d57fcdede5c436c8b788691b9e25b289f9a27"}, {"sha": "70042cff9740f1c428f82d15e40c700bbb16cd2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/70042cff9740f1c428f82d15e40c700bbb16cd2c", "html_url": "https://github.com/rust-lang/rust/commit/70042cff9740f1c428f82d15e40c700bbb16cd2c"}], "stats": {"total": 152, "additions": 119, "deletions": 33}, "files": [{"sha": "8809abdd70e62b10d664263917bdab2ed643f5b6", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac24a517bcc04eeea7e49e985482d2c25328a685/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac24a517bcc04eeea7e49e985482d2c25328a685/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=ac24a517bcc04eeea7e49e985482d2c25328a685", "patch": "@@ -39,6 +39,7 @@ pub use self::object_safety::is_object_safe;\n pub use self::object_safety::object_safety_violations;\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n+pub use self::object_safety::is_vtable_safe_method;\n pub use self::select::SelectionContext;\n pub use self::select::SelectionCache;\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};"}, {"sha": "af6bb4ccccd8026d35a4d3d9d7c5d7f57a597695", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ac24a517bcc04eeea7e49e985482d2c25328a685/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac24a517bcc04eeea7e49e985482d2c25328a685/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=ac24a517bcc04eeea7e49e985482d2c25328a685", "patch": "@@ -96,7 +96,7 @@ fn object_safety_violations_for_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .flat_map(|item| {\n             match *item {\n                 ty::MethodTraitItem(ref m) => {\n-                    object_safety_violations_for_method(tcx, trait_def_id, &**m)\n+                    object_safety_violation_for_method(tcx, trait_def_id, &**m)\n                         .map(|code| ObjectSafetyViolation::Method(m.clone(), code))\n                         .into_iter()\n                 }\n@@ -193,17 +193,42 @@ fn generics_require_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n         })\n }\n \n-fn object_safety_violations_for_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                             trait_def_id: ast::DefId,\n-                                             method: &ty::Method<'tcx>)\n-                                             -> Option<MethodViolationCode>\n+/// Returns `Some(_)` if this method makes the containing trait not object safe.\n+fn object_safety_violation_for_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                            trait_def_id: ast::DefId,\n+                                            method: &ty::Method<'tcx>)\n+                                            -> Option<MethodViolationCode>\n {\n     // Any method that has a `Self : Sized` requisite is otherwise\n     // exempt from the regulations.\n     if generics_require_sized_self(tcx, &method.generics, &method.predicates) {\n         return None;\n     }\n \n+    virtual_call_violation_for_method(tcx, trait_def_id, method)\n+}\n+\n+/// We say a method is *vtable safe* if it can be invoked on a trait\n+/// object.  Note that object-safe traits can have some\n+/// non-vtable-safe methods, so long as they require `Self:Sized` or\n+/// otherwise ensure that they cannot be used when `Self=Trait`.\n+pub fn is_vtable_safe_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                   trait_def_id: ast::DefId,\n+                                   method: &ty::Method<'tcx>)\n+                                   -> bool\n+{\n+    virtual_call_violation_for_method(tcx, trait_def_id, method).is_none()\n+}\n+\n+/// Returns `Some(_)` if this method cannot be called on a trait\n+/// object; this does not necessarily imply that the enclosing trait\n+/// is not object safe, because the method might have a where clause\n+/// `Self:Sized`.\n+fn virtual_call_violation_for_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                           trait_def_id: ast::DefId,\n+                                           method: &ty::Method<'tcx>)\n+                                           -> Option<MethodViolationCode>\n+{\n     // The method's first parameter must be something that derefs (or\n     // autorefs) to `&self`. For now, we only accept `self`, `&self`\n     // and `Box<Self>`."}, {"sha": "745098d6e87d11f9b1b8cac372e313dadbb91e40", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ac24a517bcc04eeea7e49e985482d2c25328a685/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac24a517bcc04eeea7e49e985482d2c25328a685/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=ac24a517bcc04eeea7e49e985482d2c25328a685", "patch": "@@ -1069,17 +1069,30 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     vtable\n }\n \n-pub fn predicates_hold<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                 predicates: Vec<ty::Predicate<'tcx>>)\n-                                 -> bool\n+/// Normalizes the predicates and checks whether they hold.  If this\n+/// returns false, then either normalize encountered an error or one\n+/// of the predicates did not hold. Used when creating vtables to\n+/// check for unsatisfiable methods.\n+pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                               predicates: Vec<ty::Predicate<'tcx>>)\n+                                               -> bool\n {\n-    debug!(\"predicates_hold(predicates={})\",\n+    debug!(\"normalize_and_test_predicates(predicates={})\",\n            predicates.repr(ccx.tcx()));\n \n-    let infcx = infer::new_infer_ctxt(ccx.tcx());\n+    let tcx = ccx.tcx();\n+    let infcx = infer::new_infer_ctxt(tcx);\n+    let typer = NormalizingClosureTyper::new(tcx);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n     let mut fulfill_cx = traits::FulfillmentContext::new();\n+    let cause = traits::ObligationCause::dummy();\n+    let traits::Normalized { value: predicates, obligations } =\n+        traits::normalize(&mut selcx, cause.clone(), &predicates);\n+    for obligation in obligations {\n+        fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+    }\n     for predicate in predicates {\n-        let obligation = traits::Obligation::new(traits::ObligationCause::dummy(), predicate);\n+        let obligation = traits::Obligation::new(cause.clone(), predicate);\n         fulfill_cx.register_predicate_obligation(&infcx, obligation);\n     }\n     drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()).is_ok()"}, {"sha": "190e44c9674cb5a13d10826aa60156fb15b40adc", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ac24a517bcc04eeea7e49e985482d2c25328a685/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac24a517bcc04eeea7e49e985482d2c25328a685/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=ac24a517bcc04eeea7e49e985482d2c25328a685", "patch": "@@ -13,7 +13,7 @@ use back::abi;\n use back::link;\n use llvm::{ValueRef, get_param};\n use metadata::csearch;\n-use middle::subst::Substs;\n+use middle::subst::{Subst, Substs};\n use middle::subst::VecPerParamSpace;\n use middle::subst;\n use middle::traits;\n@@ -784,6 +784,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     ty::populate_implementations_for_trait_if_necessary(tcx, trt_id);\n \n+    let nullptr = C_null(Type::nil(ccx).ptr_to());\n     let trait_item_def_ids = ty::trait_item_def_ids(tcx, trt_id);\n     trait_item_def_ids\n         .iter()\n@@ -809,6 +810,12 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             };\n             let name = trait_method_type.name;\n \n+            // Some methods cannot be called on an object; skip those.\n+            if !traits::is_vtable_safe_method(tcx, trt_id, &trait_method_type) {\n+                debug!(\"emit_vtable_methods: not vtable safe\");\n+                return nullptr;\n+            }\n+\n             debug!(\"emit_vtable_methods: trait_method_type={}\",\n                    trait_method_type.repr(tcx));\n \n@@ -820,35 +827,17 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 ty::TypeTraitItem(_) => ccx.sess().bug(\"should be a method, not assoc type\")\n             };\n \n-            debug!(\"emit_vtable_methods: m={}\",\n+            debug!(\"emit_vtable_methods: impl_method_type={}\",\n                    impl_method_type.repr(tcx));\n \n-            let nullptr = C_null(Type::nil(ccx).ptr_to());\n-\n-            if impl_method_type.generics.has_type_params(subst::FnSpace) {\n-                debug!(\"emit_vtable_methods: generic\");\n-                return nullptr;\n-            }\n-\n-            let bare_fn_ty =\n-                ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(impl_method_type.fty.clone()));\n-            if ty::type_has_self(bare_fn_ty) {\n-                debug!(\"emit_vtable_methods: type_has_self {}\",\n-                       bare_fn_ty.repr(tcx));\n-                return nullptr;\n-            }\n-\n             // If this is a default method, it's possible that it\n             // relies on where clauses that do not hold for this\n             // particular set of type parameters. Note that this\n             // method could then never be called, so we do not want to\n             // try and trans it, in that case. Issue #23435.\n             if ty::provided_source(tcx, impl_method_def_id).is_some() {\n-                let predicates =\n-                    monomorphize::apply_param_substs(tcx,\n-                                                     &substs,\n-                                                     &impl_method_type.predicates.predicates);\n-                if !predicates_hold(ccx, predicates.into_vec()) {\n+                let predicates = impl_method_type.predicates.predicates.subst(tcx, &substs);\n+                if !normalize_and_test_predicates(ccx, predicates.into_vec()) {\n                     debug!(\"emit_vtable_methods: predicates do not hold\");\n                     return nullptr;\n                 }"}, {"sha": "aad410c4abf259b6d9643e2b018b7f6b3a0d7420", "filename": "src/test/run-pass/issue-23485.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ac24a517bcc04eeea7e49e985482d2c25328a685/src%2Ftest%2Frun-pass%2Fissue-23485.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac24a517bcc04eeea7e49e985482d2c25328a685/src%2Ftest%2Frun-pass%2Fissue-23485.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23485.rs?ref=ac24a517bcc04eeea7e49e985482d2c25328a685", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test for an ICE that occured when a default method implementation\n+// was applied to a type that did not meet the prerequisites. The\n+// problem occurred specifically because normalizing\n+// `Self::Item::Target` was impossible in this case.\n+\n+use std::boxed::Box;\n+use std::marker::Sized;\n+use std::clone::Clone;\n+use std::ops::Deref;\n+use std::option::Option;\n+use std::option::Option::{Some,None};\n+\n+trait Iterator {\n+    type Item;\n+\n+    fn next(&mut self) -> Option<Self::Item>;\n+\n+    fn clone_first(mut self) -> Option<<Self::Item as Deref>::Target> where\n+        Self: Sized,\n+        Self::Item: Deref,\n+        <Self::Item as Deref>::Target: Clone,\n+    {\n+        self.next().cloned()\n+    }\n+}\n+\n+struct Counter {\n+    value: i32\n+}\n+\n+struct Token {\n+    value: i32\n+}\n+\n+impl Iterator for Counter {\n+    type Item = Token;\n+\n+    fn next(&mut self) -> Option<Token> {\n+        let x = self.value;\n+        self.value += 1;\n+        Some(Token { value: x })\n+    }\n+}\n+\n+fn main() {\n+    let mut x: Box<Iterator<Item=Token>> = Box::new(Counter { value: 22 });\n+    assert_eq!(x.next().unwrap().value, 22);\n+}"}]}