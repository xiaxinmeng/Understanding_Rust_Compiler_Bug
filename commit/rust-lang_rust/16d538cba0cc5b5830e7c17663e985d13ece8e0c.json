{"sha": "16d538cba0cc5b5830e7c17663e985d13ece8e0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZDUzOGNiYTBjYzViNTgzMGU3YzE3NjYzZTk4NWQxM2VjZThlMGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-24T07:45:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-24T07:45:59Z"}, "message": "auto merge of #16706 : pnkfelix/rust/fsk-fix-nojem-realloc, r=thestinger\n\nCopy only up to `min(new_size, old_size)` when doing reallocate.\r\n\r\nThis was a bug when running with jemalloc disabled.\r\n\r\nFix #16687", "tree": {"sha": "294ccfb06762fd94a30f9d2f2397cae7e39e5829", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/294ccfb06762fd94a30f9d2f2397cae7e39e5829"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16d538cba0cc5b5830e7c17663e985d13ece8e0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16d538cba0cc5b5830e7c17663e985d13ece8e0c", "html_url": "https://github.com/rust-lang/rust/commit/16d538cba0cc5b5830e7c17663e985d13ece8e0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16d538cba0cc5b5830e7c17663e985d13ece8e0c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c556ca9853961793af433b3cfe58966a68a791c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c556ca9853961793af433b3cfe58966a68a791c5", "html_url": "https://github.com/rust-lang/rust/commit/c556ca9853961793af433b3cfe58966a68a791c5"}, {"sha": "b1f7d3aaa021d626b4083ddaa706b26f3521d343", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1f7d3aaa021d626b4083ddaa706b26f3521d343", "html_url": "https://github.com/rust-lang/rust/commit/b1f7d3aaa021d626b4083ddaa706b26f3521d343"}], "stats": {"total": 170, "additions": 169, "deletions": 1}, "files": [{"sha": "ab686cb01d66c945c754bf51f2b2490df5c9d129", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16d538cba0cc5b5830e7c17663e985d13ece8e0c/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d538cba0cc5b5830e7c17663e985d13ece8e0c/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=16d538cba0cc5b5830e7c17663e985d13ece8e0c", "patch": "@@ -208,6 +208,7 @@ mod imp {\n \n #[cfg(not(jemalloc), unix)]\n mod imp {\n+    use core::cmp;\n     use core::mem;\n     use core::ptr;\n     use libc;\n@@ -248,7 +249,7 @@ mod imp {\n     pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n                              old_size: uint) -> *mut u8 {\n         let new_ptr = allocate(size, align);\n-        ptr::copy_memory(new_ptr, ptr as *const u8, old_size);\n+        ptr::copy_memory(new_ptr, ptr as *const u8, cmp::min(size, old_size));\n         deallocate(ptr, old_size, align);\n         return new_ptr;\n     }"}, {"sha": "2e8c23fe5ba2c0fd36eed01d04ea98e7f7868ca5", "filename": "src/test/run-pass/realloc-16687.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/16d538cba0cc5b5830e7c17663e985d13ece8e0c/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d538cba0cc5b5830e7c17663e985d13ece8e0c/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=16d538cba0cc5b5830e7c17663e985d13ece8e0c", "patch": "@@ -0,0 +1,167 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// alloc::heap::reallocate test.\n+//\n+// Ideally this would be revised to use no_std, but for now it serves\n+// well enough to reproduce (and illustrate) the bug from #16687.\n+\n+extern crate alloc;\n+\n+use alloc::heap;\n+use std::ptr;\n+\n+fn main() {\n+    unsafe {\n+        assert!(test_triangle());\n+    }\n+}\n+\n+unsafe fn test_triangle() -> bool {\n+    static COUNT : uint = 16;\n+    let mut ascend = Vec::from_elem(COUNT, ptr::mut_null());\n+    let ascend = ascend.as_mut_slice();\n+    static ALIGN : uint = 1;\n+\n+    // Checks that `ascend` forms triangle of acending size formed\n+    // from pairs of rows (where each pair of rows is equally sized),\n+    // and the elements of the triangle match their row-pair index.\n+    unsafe fn sanity_check(ascend: &[*mut u8]) {\n+        for i in range(0u, COUNT / 2) {\n+            let (p0, p1, size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n+            for j in range(0u, size) {\n+                assert_eq!(*p0.offset(j as int), i as u8);\n+                assert_eq!(*p1.offset(j as int), i as u8);\n+            }\n+        }\n+    }\n+\n+    static PRINT : bool = false;\n+\n+    unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+        if PRINT { println!(\"allocate(size={:u} align={:u})\", size, align); }\n+\n+        let ret = heap::allocate(size, align);\n+\n+        if PRINT { println!(\"allocate(size={:u} align={:u}) ret: 0x{:010x}\",\n+                            size, align, ret as uint);\n+        }\n+\n+        ret\n+    }\n+    unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n+                             old_size: uint) -> *mut u8 {\n+        if PRINT {\n+            println!(\"reallocate(ptr=0x{:010x} size={:u} align={:u} old_size={:u})\",\n+                     ptr as uint, size, align, old_size);\n+        }\n+\n+        let ret = heap::reallocate(ptr, size, align, old_size);\n+\n+        if PRINT {\n+            println!(\"reallocate(ptr=0x{:010x} size={:u} align={:u} old_size={:u}) \\\n+                      ret: 0x{:010x}\",\n+                     ptr as uint, size, align, old_size, ret as uint);\n+        }\n+        ret\n+    }\n+\n+    fn idx_to_size(i: uint) -> uint { (i+1) * 10 }\n+\n+    // Allocate pairs of rows that form a triangle shape.  (Hope is\n+    // that at least two rows will be allocated near each other, so\n+    // that we trigger the bug (a buffer overrun) in an observable\n+    // way.)\n+    for i in range(0u, COUNT / 2) {\n+        let size = idx_to_size(i);\n+        ascend[2*i]   = allocate(size, ALIGN);\n+        ascend[2*i+1] = allocate(size, ALIGN);\n+    }\n+\n+    // Initialize each pair of rows to distinct value.\n+    for i in range(0u, COUNT / 2) {\n+        let (p0, p1, size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n+        for j in range(0, size) {\n+            *p0.offset(j as int) = i as u8;\n+            *p1.offset(j as int) = i as u8;\n+        }\n+    }\n+\n+    sanity_check(ascend.as_slice());\n+    test_1(ascend);\n+    test_2(ascend);\n+    test_3(ascend);\n+    test_4(ascend);\n+\n+    return true;\n+\n+    // Test 1: turn the triangle into a square (in terms of\n+    // allocation; initialized portion remains a triangle) by\n+    // realloc'ing each row from top to bottom, and checking all the\n+    // rows as we go.\n+    unsafe fn test_1(ascend: &mut [*mut u8]) {\n+        let new_size = idx_to_size(COUNT-1);\n+        for i in range(0u, COUNT / 2) {\n+            let (p0, p1, old_size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n+            assert!(old_size < new_size);\n+\n+            ascend[2*i] = reallocate(p0, new_size, ALIGN, old_size);\n+            sanity_check(ascend.as_slice());\n+\n+            ascend[2*i+1] = reallocate(p1, new_size, ALIGN, old_size);\n+            sanity_check(ascend.as_slice());\n+        }\n+    }\n+\n+    // Test 2: turn the square back into a triangle, top to bottom.\n+    unsafe fn test_2(ascend: &mut [*mut u8]) {\n+        let old_size = idx_to_size(COUNT-1);\n+        for i in range(0u, COUNT / 2) {\n+            let (p0, p1, new_size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n+            assert!(new_size < old_size);\n+\n+            ascend[2*i] = reallocate(p0, new_size, ALIGN, old_size);\n+            sanity_check(ascend.as_slice());\n+\n+            ascend[2*i+1] = reallocate(p1, new_size, ALIGN, old_size);\n+            sanity_check(ascend.as_slice());\n+        }\n+    }\n+\n+    // Test 3: turn triangle into a square, bottom to top.\n+    unsafe fn test_3(ascend: &mut [*mut u8]) {\n+        let new_size = idx_to_size(COUNT-1);\n+        for i in range(0u, COUNT / 2).rev() {\n+            let (p0, p1, old_size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n+            assert!(old_size < new_size);\n+\n+            ascend[2*i+1] = reallocate(p1, new_size, ALIGN, old_size);\n+            sanity_check(ascend.as_slice());\n+\n+            ascend[2*i] = reallocate(p0, new_size, ALIGN, old_size);\n+            sanity_check(ascend.as_slice());\n+        }\n+    }\n+\n+    // Test 4: turn the square back into a triangle, bottom to top.\n+    unsafe fn test_4(ascend: &mut [*mut u8]) {\n+        let old_size = idx_to_size(COUNT-1);\n+        for i in range(0u, COUNT / 2).rev() {\n+            let (p0, p1, new_size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n+            assert!(new_size < old_size);\n+\n+            ascend[2*i+1] = reallocate(p1, new_size, ALIGN, old_size);\n+            sanity_check(ascend.as_slice());\n+\n+            ascend[2*i] = reallocate(p0, new_size, ALIGN, old_size);\n+            sanity_check(ascend.as_slice());\n+        }\n+    }\n+}"}]}