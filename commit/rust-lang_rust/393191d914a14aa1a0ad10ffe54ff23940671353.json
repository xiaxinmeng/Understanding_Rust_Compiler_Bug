{"sha": "393191d914a14aa1a0ad10ffe54ff23940671353", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5MzE5MWQ5MTRhMTRhYTFhMGFkMTBmZmU1NGZmMjM5NDA2NzEzNTM=", "commit": {"author": {"name": "Matthias Einwag", "email": "matthias.einwag@live.com", "date": "2014-01-12T12:27:59Z"}, "committer": {"name": "Matthias Einwag", "email": "matthias.einwag@live.com", "date": "2014-01-12T12:27:59Z"}, "message": "Update guide-ffi.md\n\nSimplified the first examples to demonstrate callbacks without other threads involved and shortened the elaboration about async callbacks.", "tree": {"sha": "2dd7fc4377105218c0b65f25e8a17c08350e40c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dd7fc4377105218c0b65f25e8a17c08350e40c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/393191d914a14aa1a0ad10ffe54ff23940671353", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/393191d914a14aa1a0ad10ffe54ff23940671353", "html_url": "https://github.com/rust-lang/rust/commit/393191d914a14aa1a0ad10ffe54ff23940671353", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/393191d914a14aa1a0ad10ffe54ff23940671353/comments", "author": {"login": "Matthias247", "id": 6330334, "node_id": "MDQ6VXNlcjYzMzAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Matthias247", "html_url": "https://github.com/Matthias247", "followers_url": "https://api.github.com/users/Matthias247/followers", "following_url": "https://api.github.com/users/Matthias247/following{/other_user}", "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}", "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions", "organizations_url": "https://api.github.com/users/Matthias247/orgs", "repos_url": "https://api.github.com/users/Matthias247/repos", "events_url": "https://api.github.com/users/Matthias247/events{/privacy}", "received_events_url": "https://api.github.com/users/Matthias247/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Matthias247", "id": 6330334, "node_id": "MDQ6VXNlcjYzMzAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Matthias247", "html_url": "https://github.com/Matthias247", "followers_url": "https://api.github.com/users/Matthias247/followers", "following_url": "https://api.github.com/users/Matthias247/following{/other_user}", "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}", "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions", "organizations_url": "https://api.github.com/users/Matthias247/orgs", "repos_url": "https://api.github.com/users/Matthias247/repos", "events_url": "https://api.github.com/users/Matthias247/events{/privacy}", "received_events_url": "https://api.github.com/users/Matthias247/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67d83ac40af2c2e20c44e4c16b53e500880a7439", "url": "https://api.github.com/repos/rust-lang/rust/commits/67d83ac40af2c2e20c44e4c16b53e500880a7439", "html_url": "https://github.com/rust-lang/rust/commit/67d83ac40af2c2e20c44e4c16b53e500880a7439"}], "stats": {"total": 158, "additions": 60, "deletions": 98}, "files": [{"sha": "02c4059dc37493873319d9f6de88bf58da70e359", "filename": "doc/guide-ffi.md", "status": "modified", "additions": 60, "deletions": 98, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/393191d914a14aa1a0ad10ffe54ff23940671353/doc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/393191d914a14aa1a0ad10ffe54ff23940671353/doc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-ffi.md?ref=393191d914a14aa1a0ad10ffe54ff23940671353", "patch": "@@ -251,9 +251,8 @@ fn main() {\n \n # Callbacks from C code to Rust functions\n \n-Some external libraries require the usage of callbacks. \n-E.g. because they start background threads and use callbacks to signal events\n-like the availability of new data.\n+Some external libraries require the usage of callbacks to report back their\n+current state or intermediate data to the caller.\n It is possible to pass functions defined in Rust to an external library.\n The requirement for this is that the callback function is marked as `extern`\n with the correct calling convention to make it callable from C code.\n@@ -265,24 +264,25 @@ A basic example is:\n \n Rust code:\n ~~~~\n-extern \"C\" fn callback(a:i32) {\n+extern fn callback(a:i32) {\n     println!(\"I'm called from C with value {0}\", a);\n }\n \n #[link(name = \"extlib\")]\n extern {\n    fn register_callback(cb: extern \"C\" fn(i32)) -> i32;\n+   fn trigger_callback();\n }\n \n fn main() {\n     unsafe {\n         register_callback(callback);\n+        trigger_callback(); // Triggers the callback\n     }\n-    ... // Do sth. and wait for callbacks\n }\n ~~~~\n \n-C-Code:\n+C code:\n ~~~~\n typedef void (*rust_callback)(int32_t);\n rust_callback cb;\n@@ -292,15 +292,14 @@ int32_t register_callback(rust_callback callback) {\n     return 1;\n }\n \n-void thread() {\n-  // do sth\n+void trigger_callback() {\n   cb(7); // Will call callback(7) in Rust\n }\n ~~~~\n \n-Keep in mind that `callback()` will be called from a C thread and not from\n-a Rust thread or even your main thread. Therefore each data access is\n-especially unsafe and synchronization mechanisms must be used.\n+In this example will Rust's `main()` will call `do_callback()` in C,\n+which would call back to `callback()` in Rust.\n+\n \n ## Targetting callbacks to Rust objects\n \n@@ -314,115 +313,78 @@ C library. The C library can then include the pointer to the Rust object in\n the notification. This will provide a unsafe possibility to access the \n referenced Rust object in callback.\n \n-If this mechanism is used it is absolutely necessary that no more callbacks\n-are performed  by C library after the respective Rust object get's\n-destroyed. This can be achieved by unregistering the callback it the object's\n-destructor and designing the library in a way that guarantees that no\n-callback will be performed after unregistration.\n-\n-## Sychronzing callbacks with channels\n-\n-As already explained accessing data of a Rust object in a callback is unsafe\n-without synchronisation. Channels in Rust provide a mechanism\n-which can be used to forward events into Rust tasks. The idea is to create a\n-channel where the writing end (`Chan`) is used exclusively from the C callback\n-to queue events. The reading end (`Port`) is used in the Rust task which owns\n-the wrapper object.\n-\n-Depending on the type of data in the event you might want to convert callback\n-data from C into a more suitable Rust structure before sending it into the\n-channel. E.g. it makes sense to convert C strings (`char*`) into Rust strings.\n-You could also use Rust enumerations to differentiate between multiple types\n-of events and their data.\n-\n-Putting this together a wrapper for a library that uses a background thread\n-that sends events could look like:\n-\n Rust code:\n ~~~~\n \n-#[link(name = \"extlib\")]\n-extern {\n-   fn init(target: *ExtLibWrapper, cb: extern \"C\" fn(*ExtLibWrapper, EventData));\n-   fn unregister();\n-}\n-\n-struct EventData {\n-    ... // Contains data that describes the event\n+struct RustObject {\n+    a: i32,\n+    // other members\n }\n \n-pub struct ExtLibWrapper {\n-    // Channel is used privately\n-    priv chan: comm::Chan<EventData>,\n-    \n-    // The port is used by the Rust task to receive notifications\n-    port: comm::Port<EventData>\n-}\n-\n-impl ExtLibWrapper {\n-    pub fn new() -> ~ EventData {\n-        let (p,c):(Port<EventData>,Chan<EventData>) \n-                = comm::Chan::new();\n-\n-        let wrapper = ~ExtLibWrapper{chan:c, port:p};\n-\n-        unsafe {\n-            let wrapper_addr:*ExtLibWrapper = ptr::to_unsafe_ptr(wrapper);\n-            init(wrapper_addr, callback);\n-        }\n-    }\n+extern fn callback(target: *RustObject, a:i32) {\n+    println!(\"I'm called from C with value {0}\", a);\n+    (*target).a = a; // Update the value in RustObject with the value received from the callback\n }\n \n-impl Drop for ExtLibWrapper {\n-    fn drop(&mut self) {\n-        // Unregister to avoid further callbacks\n-        unsafe { unregister(); }\n-    }\n+#[link(name = \"extlib\")]\n+extern {\n+   fn register_callback(target: *RustObject, cb: extern \"C\" fn(*RustObject, i32)) -> i32;\n+   fn trigger_callback();\n }\n \n-extern \"C\" fn callback(target: *ExtLibWrapper, data: EventData) {\n-    unsafe  {\n-        (*target).chan.send(data); // Forward the event data through channel\n+fn main() {\n+    // Create the object that will be referenced in the callback\n+    let rust_object = ~RustObject{a: 5, ...};\n+     \n+    unsafe {\n+        // Gets a raw pointer to the object\n+        let target_addr:*RustObject = ptr::to_unsafe_ptr(rust_object);\n+        register_callback(target_addr, callback);\n+        trigger_callback(); // Triggers the callback\n     }\n }\n ~~~~\n \n-C-Code:\n+C code:\n ~~~~\n-typedef void (*rust_callback)(void* target, EventData data);\n-void* rust_target;\n+typedef void (*rust_callback)(int32_t);\n+void* cb_target;\n rust_callback cb;\n-mutex mtx; // Example mutex\n \n-void init(void* target, rust_callback callback) {\n-    rust_target = target;\n+int32_t register_callback(void* callback_target, rust_callback callback) {\n+    cb_target = callback_target;\n     cb = callback;\n+    return 1;\n }\n \n-void background_thread() {\n-    // do sth\n-  \n-    // Lock the mutex to guarantee that callback is not performed after Rust\n-    // object is destroyed\n-    mutex_lock(mtx); \n-    if (rust_target != 0) cb(rust_target, event_data);\n-    mutex_unlock(mtx);\n-  \n-    // do sth\n-}\n-\n-void unregister() {\n-    mutex_lock(mtx);\n-    rust_target = 0;\n-    mutex_unlock(mtx);\n+void trigger_callback() {\n+  cb(cb_target, 7); // Will call callback(&rustObject, 7) in Rust\n }\n ~~~~\n \n-Remark: This example will not work correctly if more than a single \n-`ExtLibWrapper` object is created. If this is required additional handles\n-have to be introduced which identify each object. E.g. `ExtLibWrapper` would\n-have to store the member of the associated C object as member and pass it\n-on each function call.\n+## Asynchronous callbacks\n+\n+In the already given examples the callbacks are invoked as a direct reaction\n+to a function call to the external C library.\n+The control over the current thread switched from Rust to C to Rust for the\n+execution of the callback, but in the end the callback is executed on the\n+same thread (and Rust task) that lead called the function which triggered\n+the callback.\n+\n+Things get more complicated when the external library spawns it's own threads\n+and invokes callbacks from there.\n+In these cases access to Rust data structures inside he callbacks is\n+especially unsafe and proper synchronization mechanisms must be used.\n+Besides classical synchronization mechanisms like mutexes one possibility in\n+Rust is to use channels (in `std::comm`) to forward data from the C thread\n+that invoked the callback into a Rust task.\n+\n+If an asychronous callback targets a special object in the Rust address space\n+it is also absolutely necessary that no more callbacks are performed by the \n+C library after the respective Rust object get's destroyed. \n+This can be achieved by unregistering the callback it the object's\n+destructor and designing the library in a way that guarantees that no\n+callback will be performed after unregistration.\n \n # Linking\n "}]}