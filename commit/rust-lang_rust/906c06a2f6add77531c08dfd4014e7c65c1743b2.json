{"sha": "906c06a2f6add77531c08dfd4014e7c65c1743b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwNmMwNmEyZjZhZGQ3NzUzMWMwOGRmZDQwMTRlN2M2NWMxNzQzYjI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-02-26T14:21:08Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-03T11:54:18Z"}, "message": "make operands live to the end of their containing expression\n\nIn MIR construction, operands need to live exactly until they are used,\nwhich is during the (sub)expression that made the call to `as_operand`.\n\nBefore this PR, operands lived until the end of the temporary scope,\nwhich was sometimes unnecessarily longer and sometimes too short.\n\nFixes #38669.", "tree": {"sha": "e551f93b29cc14efb0f68cb252c89945c18d4a93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e551f93b29cc14efb0f68cb252c89945c18d4a93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/906c06a2f6add77531c08dfd4014e7c65c1743b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/906c06a2f6add77531c08dfd4014e7c65c1743b2", "html_url": "https://github.com/rust-lang/rust/commit/906c06a2f6add77531c08dfd4014e7c65c1743b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/906c06a2f6add77531c08dfd4014e7c65c1743b2/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6755fb8ba2300a121cb14bd79327c3eb730bc55d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6755fb8ba2300a121cb14bd79327c3eb730bc55d", "html_url": "https://github.com/rust-lang/rust/commit/6755fb8ba2300a121cb14bd79327c3eb730bc55d"}], "stats": {"total": 313, "additions": 257, "deletions": 56}, "files": [{"sha": "8886a310429ea2fd86657c94040d62f7423d453f", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=906c06a2f6add77531c08dfd4014e7c65c1743b2", "patch": "@@ -56,8 +56,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let (usize_ty, bool_ty) = (this.hir.usize_ty(), this.hir.bool_ty());\n \n                 let slice = unpack!(block = this.as_lvalue(block, lhs));\n-\n-                let idx = unpack!(block = this.as_operand(block, index));\n+                // extent=None so lvalue indexes live forever. They are scalars so they\n+                // do not need storage annotations, and they are often copied between\n+                // places.\n+                let idx = unpack!(block = this.as_operand(block, None, index));\n \n                 // bounds check:\n                 let (len, lt) = (this.temp(usize_ty.clone()), this.temp(bool_ty));\n@@ -121,7 +123,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     Some(Category::Lvalue) => false,\n                     _ => true,\n                 });\n-                this.as_temp(block, expr)\n+                this.as_temp(block, expr.temp_lifetime, expr)\n             }\n         }\n     }"}, {"sha": "8d79e755685d0842b125103533b9ad3591e57a51", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=906c06a2f6add77531c08dfd4014e7c65c1743b2", "patch": "@@ -13,29 +13,52 @@\n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::Category;\n use hair::*;\n+use rustc::middle::region::CodeExtent;\n use rustc::mir::*;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n+    /// Returns an operand suitable for use until the end of the current\n+    /// scope expression.\n+    ///\n+    /// The operand returned from this function will *not be valid* after\n+    /// an ExprKind::Scope is passed, so please do *not* return it from\n+    /// functions to avoid bad miscompiles.\n+    pub fn as_local_operand<M>(&mut self, block: BasicBlock, expr: M)\n+                             -> BlockAnd<Operand<'tcx>>\n+        where M: Mirror<'tcx, Output = Expr<'tcx>>\n+    {\n+        let topmost_scope = self.topmost_scope(); // FIXME(#6393)\n+        self.as_operand(block, Some(topmost_scope), expr)\n+    }\n+\n     /// Compile `expr` into a value that can be used as an operand.\n     /// If `expr` is an lvalue like `x`, this will introduce a\n     /// temporary `tmp = x`, so that we capture the value of `x` at\n     /// this time.\n-    pub fn as_operand<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Operand<'tcx>>\n+    ///\n+    /// The operand is known to be live until the end of `scope`.\n+    pub fn as_operand<M>(&mut self,\n+                         block: BasicBlock,\n+                         scope: Option<CodeExtent>,\n+                         expr: M) -> BlockAnd<Operand<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n         let expr = self.hir.mirror(expr);\n-        self.expr_as_operand(block, expr)\n+        self.expr_as_operand(block, scope, expr)\n     }\n \n     fn expr_as_operand(&mut self,\n                        mut block: BasicBlock,\n+                       scope: Option<CodeExtent>,\n                        expr: Expr<'tcx>)\n                        -> BlockAnd<Operand<'tcx>> {\n         debug!(\"expr_as_operand(block={:?}, expr={:?})\", block, expr);\n         let this = self;\n \n         if let ExprKind::Scope { extent, value } = expr.kind {\n-            return this.in_scope(extent, block, |this| this.as_operand(block, value));\n+            return this.in_scope(extent, block, |this| {\n+                this.as_operand(block, scope, value)\n+            });\n         }\n \n         let category = Category::of(&expr.kind).unwrap();\n@@ -47,7 +70,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             Category::Lvalue |\n             Category::Rvalue(..) => {\n-                let operand = unpack!(block = this.as_temp(block, expr));\n+                let operand =\n+                    unpack!(block = this.as_temp(block, scope, expr));\n                 block.and(Operand::Consume(operand))\n             }\n         }"}, {"sha": "961713bcfe6d5353464e0742702e4e4ac7a8900b", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=906c06a2f6add77531c08dfd4014e7c65c1743b2", "patch": "@@ -21,22 +21,34 @@ use build::expr::category::{Category, RvalueFunc};\n use hair::*;\n use rustc_const_math::{ConstInt, ConstIsize};\n use rustc::middle::const_val::ConstVal;\n+use rustc::middle::region::CodeExtent;\n use rustc::ty;\n use rustc::mir::*;\n use syntax::ast;\n use syntax_pos::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n+    /// See comment on `as_local_operand`\n+    pub fn as_local_rvalue<M>(&mut self, block: BasicBlock, expr: M)\n+                             -> BlockAnd<Rvalue<'tcx>>\n+        where M: Mirror<'tcx, Output = Expr<'tcx>>\n+    {\n+        let topmost_scope = self.topmost_scope(); // FIXME(#6393)\n+        self.as_rvalue(block, Some(topmost_scope), expr)\n+    }\n+\n     /// Compile `expr`, yielding an rvalue.\n-    pub fn as_rvalue<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Rvalue<'tcx>>\n+    pub fn as_rvalue<M>(&mut self, block: BasicBlock, scope: Option<CodeExtent>, expr: M)\n+                        -> BlockAnd<Rvalue<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n         let expr = self.hir.mirror(expr);\n-        self.expr_as_rvalue(block, expr)\n+        self.expr_as_rvalue(block, scope, expr)\n     }\n \n     fn expr_as_rvalue(&mut self,\n                       mut block: BasicBlock,\n+                      scope: Option<CodeExtent>,\n                       expr: Expr<'tcx>)\n                       -> BlockAnd<Rvalue<'tcx>> {\n         debug!(\"expr_as_rvalue(block={:?}, expr={:?})\", block, expr);\n@@ -47,24 +59,24 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n-                this.in_scope(extent, block, |this| this.as_rvalue(block, value))\n+                this.in_scope(extent, block, |this| this.as_rvalue(block, scope, value))\n             }\n             ExprKind::Repeat { value, count } => {\n-                let value_operand = unpack!(block = this.as_operand(block, value));\n+                let value_operand = unpack!(block = this.as_operand(block, scope, value));\n                 block.and(Rvalue::Repeat(value_operand, count))\n             }\n             ExprKind::Borrow { region, borrow_kind, arg } => {\n                 let arg_lvalue = unpack!(block = this.as_lvalue(block, arg));\n                 block.and(Rvalue::Ref(region, borrow_kind, arg_lvalue))\n             }\n             ExprKind::Binary { op, lhs, rhs } => {\n-                let lhs = unpack!(block = this.as_operand(block, lhs));\n-                let rhs = unpack!(block = this.as_operand(block, rhs));\n+                let lhs = unpack!(block = this.as_operand(block, scope, lhs));\n+                let rhs = unpack!(block = this.as_operand(block, scope, rhs));\n                 this.build_binary_op(block, op, expr_span, expr.ty,\n                                      lhs, rhs)\n             }\n             ExprKind::Unary { op, arg } => {\n-                let arg = unpack!(block = this.as_operand(block, arg));\n+                let arg = unpack!(block = this.as_operand(block, scope, arg));\n                 // Check for -MIN on signed integers\n                 if this.hir.check_overflow() && op == UnOp::Neg && expr.ty.is_signed() {\n                     let bool_ty = this.hir.bool_ty();\n@@ -97,27 +109,27 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Cast { source } => {\n                 let source = this.hir.mirror(source);\n \n-                let source = unpack!(block = this.as_operand(block, source));\n+                let source = unpack!(block = this.as_operand(block, scope, source));\n                 block.and(Rvalue::Cast(CastKind::Misc, source, expr.ty))\n             }\n             ExprKind::Use { source } => {\n-                let source = unpack!(block = this.as_operand(block, source));\n+                let source = unpack!(block = this.as_operand(block, scope, source));\n                 block.and(Rvalue::Use(source))\n             }\n             ExprKind::ReifyFnPointer { source } => {\n-                let source = unpack!(block = this.as_operand(block, source));\n+                let source = unpack!(block = this.as_operand(block, scope, source));\n                 block.and(Rvalue::Cast(CastKind::ReifyFnPointer, source, expr.ty))\n             }\n             ExprKind::UnsafeFnPointer { source } => {\n-                let source = unpack!(block = this.as_operand(block, source));\n+                let source = unpack!(block = this.as_operand(block, scope, source));\n                 block.and(Rvalue::Cast(CastKind::UnsafeFnPointer, source, expr.ty))\n             }\n             ExprKind::ClosureFnPointer { source } => {\n-                let source = unpack!(block = this.as_operand(block, source));\n+                let source = unpack!(block = this.as_operand(block, scope, source));\n                 block.and(Rvalue::Cast(CastKind::ClosureFnPointer, source, expr.ty))\n             }\n             ExprKind::Unsize { source } => {\n-                let source = unpack!(block = this.as_operand(block, source));\n+                let source = unpack!(block = this.as_operand(block, scope, source));\n                 block.and(Rvalue::Cast(CastKind::Unsize, source, expr.ty))\n             }\n             ExprKind::Array { fields } => {\n@@ -150,7 +162,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // first process the set of fields\n                 let fields: Vec<_> =\n                     fields.into_iter()\n-                          .map(|f| unpack!(block = this.as_operand(block, f)))\n+                          .map(|f| unpack!(block = this.as_operand(block, scope, f)))\n                           .collect();\n \n                 block.and(Rvalue::Aggregate(AggregateKind::Array, fields))\n@@ -159,15 +171,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // first process the set of fields\n                 let fields: Vec<_> =\n                     fields.into_iter()\n-                          .map(|f| unpack!(block = this.as_operand(block, f)))\n+                          .map(|f| unpack!(block = this.as_operand(block, scope, f)))\n                           .collect();\n \n                 block.and(Rvalue::Aggregate(AggregateKind::Tuple, fields))\n             }\n             ExprKind::Closure { closure_id, substs, upvars } => { // see (*) above\n                 let upvars =\n                     upvars.into_iter()\n-                          .map(|upvar| unpack!(block = this.as_operand(block, upvar)))\n+                          .map(|upvar| unpack!(block = this.as_operand(block, scope, upvar)))\n                           .collect();\n                 block.and(Rvalue::Aggregate(AggregateKind::Closure(closure_id, substs), upvars))\n             }\n@@ -179,10 +191,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 // first process the set of fields that were provided\n                 // (evaluating them in order given by user)\n-                let fields_map: FxHashMap<_, _> =\n-                    fields.into_iter()\n-                          .map(|f| (f.name, unpack!(block = this.as_operand(block, f.expr))))\n-                          .collect();\n+                let fields_map: FxHashMap<_, _> = fields.into_iter()\n+                    .map(|f| (f.name, unpack!(block = this.as_operand(block, scope, f.expr))))\n+                    .collect();\n \n                 let field_names = this.hir.all_fields(adt_def, variant_index);\n \n@@ -235,7 +246,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     Some(Category::Rvalue(RvalueFunc::AsRvalue)) => false,\n                     _ => true,\n                 });\n-                let operand = unpack!(block = this.as_operand(block, expr));\n+                let operand = unpack!(block = this.as_operand(block, scope, expr));\n                 block.and(Rvalue::Use(operand))\n             }\n         }"}, {"sha": "69b95702009213432d1528cd281e09e85e3bc761", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=906c06a2f6add77531c08dfd4014e7c65c1743b2", "patch": "@@ -13,29 +13,38 @@\n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::Category;\n use hair::*;\n+use rustc::middle::region::CodeExtent;\n use rustc::mir::*;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr` into a fresh temporary. This is used when building\n     /// up rvalues so as to freeze the value that will be consumed.\n-    pub fn as_temp<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Lvalue<'tcx>>\n+    pub fn as_temp<M>(&mut self,\n+                      block: BasicBlock,\n+                      temp_lifetime: Option<CodeExtent>,\n+                      expr: M)\n+                      -> BlockAnd<Lvalue<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n         let expr = self.hir.mirror(expr);\n-        self.expr_as_temp(block, expr)\n+        self.expr_as_temp(block, temp_lifetime, expr)\n     }\n \n-    fn expr_as_temp(&mut self, mut block: BasicBlock, expr: Expr<'tcx>) -> BlockAnd<Lvalue<'tcx>> {\n+    fn expr_as_temp(&mut self,\n+                    mut block: BasicBlock,\n+                    temp_lifetime: Option<CodeExtent>,\n+                    expr: Expr<'tcx>)\n+                    -> BlockAnd<Lvalue<'tcx>> {\n         debug!(\"expr_as_temp(block={:?}, expr={:?})\", block, expr);\n         let this = self;\n \n-        if let ExprKind::Scope { extent, value } = expr.kind {\n-            return this.in_scope(extent, block, |this| this.as_temp(block, value));\n+        if let ExprKind::Scope { .. } = expr.kind {\n+            span_bug!(expr.span, \"unexpected scope expression in as_temp: {:?}\",\n+                      expr);\n         }\n \n         let expr_ty = expr.ty.clone();\n         let temp = this.temp(expr_ty.clone());\n-        let temp_lifetime = expr.temp_lifetime;\n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n "}, {"sha": "dab85106873299e2747b79e954f36c2c41941620", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=906c06a2f6add77531c08dfd4014e7c65c1743b2", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     _ => false,\n                 };\n \n-                unpack!(block = this.as_rvalue(block, source));\n+                unpack!(block = this.as_local_rvalue(block, source));\n \n                 // This is an optimization. If the expression was a call then we already have an\n                 // unreachable block. Don't bother to terminate it and create a new one.\n@@ -65,7 +65,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n             }\n             ExprKind::If { condition: cond_expr, then: then_expr, otherwise: else_expr } => {\n-                let operand = unpack!(block = this.as_operand(block, cond_expr));\n+                let operand = unpack!(block = this.as_local_operand(block, cond_expr));\n \n                 let mut then_block = this.cfg.start_new_block();\n                 let mut else_block = this.cfg.start_new_block();\n@@ -107,15 +107,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     (this.cfg.start_new_block(), this.cfg.start_new_block(),\n                      this.cfg.start_new_block(), this.cfg.start_new_block());\n \n-                let lhs = unpack!(block = this.as_operand(block, lhs));\n+                let lhs = unpack!(block = this.as_local_operand(block, lhs));\n                 let blocks = match op {\n                     LogicalOp::And => (else_block, false_block),\n                     LogicalOp::Or => (true_block, else_block),\n                 };\n                 let term = TerminatorKind::if_(this.hir.tcx(), lhs, blocks.0, blocks.1);\n                 this.cfg.terminate(block, source_info, term);\n \n-                let rhs = unpack!(else_block = this.as_operand(else_block, rhs));\n+                let rhs = unpack!(else_block = this.as_local_operand(else_block, rhs));\n                 let term = TerminatorKind::if_(this.hir.tcx(), rhs, true_block, false_block);\n                 this.cfg.terminate(else_block, source_info, term);\n \n@@ -173,7 +173,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         if let Some(cond_expr) = opt_cond_expr {\n                             let loop_block_end;\n                             let cond = unpack!(\n-                                loop_block_end = this.as_operand(loop_block, cond_expr));\n+                                loop_block_end = this.as_local_operand(loop_block, cond_expr));\n                             body_block = this.cfg.start_new_block();\n                             let term = TerminatorKind::if_(this.hir.tcx(), cond,\n                                                            body_block, exit_block);\n@@ -206,10 +206,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                     _ => false\n                 };\n-                let fun = unpack!(block = this.as_operand(block, fun));\n+                let fun = unpack!(block = this.as_local_operand(block, fun));\n                 let args: Vec<_> =\n                     args.into_iter()\n-                        .map(|arg| unpack!(block = this.as_operand(block, arg)))\n+                        .map(|arg| unpack!(block = this.as_local_operand(block, arg)))\n                         .collect();\n \n                 let success = this.cfg.start_new_block();\n@@ -265,7 +265,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     _ => true,\n                 });\n \n-                let rvalue = unpack!(block = this.as_rvalue(block, expr));\n+                let rvalue = unpack!(block = this.as_local_rvalue(block, expr));\n                 this.cfg.push_assign(block, source_info, destination, rvalue);\n                 block.unit()\n             }"}, {"sha": "be39dcbf6d08d84a3940a32188dffb6838710cfb", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=906c06a2f6add77531c08dfd4014e7c65c1743b2", "patch": "@@ -38,14 +38,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // Generate better code for things that don't need to be\n                 // dropped.\n                 if this.hir.needs_drop(lhs.ty) {\n-                    let rhs = unpack!(block = this.as_operand(block, rhs));\n+                    let rhs = unpack!(block = this.as_local_operand(block, rhs));\n                     let lhs = unpack!(block = this.as_lvalue(block, lhs));\n                     unpack!(block = this.build_drop_and_replace(\n                         block, lhs_span, lhs, rhs\n                     ));\n                     block.unit()\n                 } else {\n-                    let rhs = unpack!(block = this.as_rvalue(block, rhs));\n+                    let rhs = unpack!(block = this.as_local_rvalue(block, rhs));\n                     let lhs = unpack!(block = this.as_lvalue(block, lhs));\n                     this.cfg.push_assign(block, source_info, &lhs, rhs);\n                     block.unit()\n@@ -64,7 +64,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let lhs_ty = lhs.ty;\n \n                 // As above, RTL.\n-                let rhs = unpack!(block = this.as_operand(block, rhs));\n+                let rhs = unpack!(block = this.as_local_operand(block, rhs));\n                 let lhs = unpack!(block = this.as_lvalue(block, lhs));\n \n                 // we don't have to drop prior contents or anything\n@@ -122,7 +122,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     unpack!(block = this.as_lvalue(block, output))\n                 }).collect();\n                 let inputs = inputs.into_iter().map(|input| {\n-                    unpack!(block = this.as_operand(block, input))\n+                    unpack!(block = this.as_local_operand(block, input))\n                 }).collect();\n                 this.cfg.push(block, Statement {\n                     source_info: source_info,"}, {"sha": "705eb1f56608e49be2b7fdd1bef2458804f047a8", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=906c06a2f6add77531c08dfd4014e7c65c1743b2", "patch": "@@ -661,7 +661,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // guard, this block is simply unreachable\n             let guard = self.hir.mirror(guard);\n             let source_info = self.source_info(guard.span);\n-            let cond = unpack!(block = self.as_operand(block, guard));\n+            let cond = unpack!(block = self.as_local_operand(block, guard));\n             let otherwise = self.cfg.start_new_block();\n             self.cfg.terminate(block, source_info,\n                                TerminatorKind::if_(self.hir.tcx(), cond, arm_block, otherwise));"}, {"sha": "3dab1717f6b2e4a466534457c6eb971435eef903", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=906c06a2f6add77531c08dfd4014e7c65c1743b2", "patch": "@@ -253,9 +253,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             f: F)\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>)\n     {\n-        let extent = self.scopes.last().map(|scope| scope.extent).unwrap();\n+        let extent = self.topmost_scope();\n         let loop_scope = LoopScope {\n-            extent: extent.clone(),\n+            extent: extent,\n             continue_block: loop_block,\n             break_block: break_block,\n             break_destination: break_destination,\n@@ -416,6 +416,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         self.scopes[1].extent\n     }\n \n+    /// Returns the topmost active scope, which is known to be alive until\n+    /// the next scope expression.\n+    pub fn topmost_scope(&self) -> CodeExtent {\n+        self.scopes.last().expect(\"topmost_scope: no scopes present\").extent\n+    }\n+\n     // Scheduling drops\n     // ================\n     /// Indicates that `lvalue` should be dropped on exit from"}, {"sha": "9c924a23903f975d59ff6b9506500118af1dd342", "filename": "src/test/mir-opt/basic_assignment.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs?ref=906c06a2f6add77531c08dfd4014e7c65c1743b2", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// this tests move up progration, which is not yet implemented\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that codegen of assignment expressions is sane. Assignments\n+// tend to be absent in simple code, so subtle breakage in them can\n+// leave a quite hard-to-find trail of destruction.\n+\n+fn main() {\n+    let nodrop_x = false;\n+    let nodrop_y;\n+\n+    nodrop_y = nodrop_x;\n+\n+    let drop_x : Option<Box<u32>> = None;\n+    let drop_y;\n+\n+    drop_y = drop_x;\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node4.SimplifyCfg.initial-after.mir\n+//     bb0: {\n+//         StorageLive(_1);\n+//         _1 = const false;\n+//         StorageLive(_2);\n+//         StorageLive(_3);\n+//         _3 = _1;\n+//         _2 = _3;\n+//         StorageDead(_3);\n+//         StorageLive(_4);\n+//         _4 = std::option::Option<std::boxed::Box<u32>>::None;\n+//         StorageLive(_6);\n+//         StorageLive(_7);\n+//         _7 = _4;\n+//         replace(_6 <- _7) -> [return: bb5, unwind: bb4];\n+//     }\n+//     bb1: {\n+//         resume;\n+//     }\n+//     bb2: {\n+//         drop(_4) -> bb1;\n+//     }\n+//     bb3: {\n+//         drop(_6) -> bb2;\n+//     }\n+//     bb4: {\n+//         drop(_7) -> bb3;\n+//     }\n+//     bb5: {\n+//         drop(_7) -> [return: bb6, unwind: bb3];\n+//     }\n+//     bb6: {\n+//         StorageDead(_7);\n+//         _0 = ();\n+//         drop(_6) -> [return: bb7, unwind: bb2];\n+//     }\n+//     bb7: {\n+//         StorageDead(_6);\n+//         drop(_4) -> bb8;\n+//     }\n+//     bb8: {\n+//         StorageDead(_4);\n+//         StorageDead(_2);\n+//         StorageDead(_1);\n+//         return;\n+//     }\n+// END rustc.node4.SimplifyCfg.initial-after.mir"}, {"sha": "1d452907cf59acad2c58c4fedb74da2b66e302cb", "filename": "src/test/mir-opt/issue-38669.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Ftest%2Fmir-opt%2Fissue-38669.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Ftest%2Fmir-opt%2Fissue-38669.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-38669.rs?ref=906c06a2f6add77531c08dfd4014e7c65c1743b2", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that we don't StorageDead booleans before they are used\n+\n+fn main() {\n+    let mut should_break = false;\n+    loop {\n+        if should_break {\n+            break;\n+        }\n+        should_break = true;\n+    }\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node4.SimplifyCfg.initial-after.mir\n+//     bb0: {\n+//         StorageLive(_1);\n+//         _1 = const false;\n+//         goto -> bb1;\n+//     }\n+//\n+//     bb1: {\n+//         StorageLive(_4);\n+//         _4 = _1;\n+//         switchInt(_4) -> [0u8: bb3, otherwise: bb2];\n+//     }\n+//\n+//     bb2: {\n+//         StorageLive(_6);\n+//         _0 = ();\n+//         StorageDead(_4);\n+//         StorageDead(_1);\n+//         return;\n+//     }\n+//\n+//     bb3: {\n+//         _3 = ();\n+//         StorageDead(_4);\n+//         _1 = const true;\n+//         _2 = ();\n+//         goto -> bb1;\n+//     }\n+// END rustc.node4.SimplifyCfg.initial-after.mir"}, {"sha": "3fbd1a36f2f169bcb935b452a0e38d75c90ff955", "filename": "src/test/mir-opt/storage_ranges.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs?ref=906c06a2f6add77531c08dfd4014e7c65c1743b2", "patch": "@@ -28,8 +28,8 @@ fn main() {\n //         StorageLive(_5);\n //         _5 = _1;\n //         _4 = std::option::Option<i32>::Some(_5,);\n-//         _3 = &_4;\n //         StorageDead(_5);\n+//         _3 = &_4;\n //         _2 = ();\n //         StorageDead(_3);\n //         StorageDead(_4);\n@@ -38,6 +38,5 @@ fn main() {\n //         _0 = ();\n //         StorageDead(_6);\n //         StorageDead(_1);\n-//         return;\n-//     }\n+//      }\n // END rustc.node4.TypeckMir.before.mir"}, {"sha": "e7da43597f1691dfd4f4457d5583bb4041a60398", "filename": "src/test/run-pass/mir_drop_order.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Ftest%2Frun-pass%2Fmir_drop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906c06a2f6add77531c08dfd4014e7c65c1743b2/src%2Ftest%2Frun-pass%2Fmir_drop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_drop_order.rs?ref=906c06a2f6add77531c08dfd4014e7c65c1743b2", "patch": "@@ -9,23 +9,27 @@\n // except according to those terms.\n \n use std::cell::RefCell;\n+use std::panic;\n \n pub struct DropLogger<'a> {\n     id: usize,\n-    log: &'a RefCell<Vec<usize>>\n+    log: &'a panic::AssertUnwindSafe<RefCell<Vec<usize>>>\n }\n \n impl<'a> Drop for DropLogger<'a> {\n     fn drop(&mut self) {\n-        self.log.borrow_mut().push(self.id);\n+        self.log.0.borrow_mut().push(self.id);\n     }\n }\n \n+struct InjectedFailure;\n+\n+#[allow(unreachable_code)]\n fn main() {\n-    let log = RefCell::new(vec![]);\n+    let log = panic::AssertUnwindSafe(RefCell::new(vec![]));\n     let d = |id| DropLogger { id: id, log: &log };\n     let get = || -> Vec<_> {\n-        let mut m = log.borrow_mut();\n+        let mut m = log.0.borrow_mut();\n         let n = m.drain(..);\n         n.collect()\n     };\n@@ -39,4 +43,13 @@ fn main() {\n     // *after* the let result (tho they have the same scope\n     // as far as scope-based borrowck goes).\n     assert_eq!(get(), vec![0, 2, 3, 1]);\n+\n+    let _ = std::panic::catch_unwind(|| {\n+        (d(4), &d(5), d(6), &d(7), panic!(InjectedFailure));\n+    });\n+\n+    // here, the temporaries (5/7) live until the end of the\n+    // containing statement, which is destroyed after the operands\n+    // (4/6) on a panic.\n+    assert_eq!(get(), vec![6, 4, 7, 5]);\n }"}]}