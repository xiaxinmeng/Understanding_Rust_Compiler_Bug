{"sha": "88b21f592c7238e89f2b08ecd291059b2e239a41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4YjIxZjU5MmM3MjM4ZTg5ZjJiMDhlY2QyOTEwNTliMmUyMzlhNDE=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2013-08-02T20:39:57Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2013-08-06T19:22:11Z"}, "message": "Add to_ascii_upper, to_ascii_lower and eq_ignore_ascii_case in std::ascii", "tree": {"sha": "4c607805ba287d8f2596eb396472828636547c79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c607805ba287d8f2596eb396472828636547c79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88b21f592c7238e89f2b08ecd291059b2e239a41", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88b21f592c7238e89f2b08ecd291059b2e239a41", "html_url": "https://github.com/rust-lang/rust/commit/88b21f592c7238e89f2b08ecd291059b2e239a41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88b21f592c7238e89f2b08ecd291059b2e239a41/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dfb55ab09a8533da7c5bf559c923685d5d64dc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dfb55ab09a8533da7c5bf559c923685d5d64dc1", "html_url": "https://github.com/rust-lang/rust/commit/3dfb55ab09a8533da7c5bf559c923685d5d64dc1"}], "stats": {"total": 180, "additions": 169, "deletions": 11}, "files": [{"sha": "1be4d07dfa477ccdf7056e1117362d7d2f6bab4c", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 169, "deletions": 11, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/88b21f592c7238e89f2b08ecd291059b2e239a41/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b21f592c7238e89f2b08ecd291059b2e239a41/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=88b21f592c7238e89f2b08ecd291059b2e239a41", "patch": "@@ -13,7 +13,10 @@\n use to_str::{ToStr,ToStrConsume};\n use str;\n use str::StrSlice;\n+use str::OwnedStr;\n+use container::Container;\n use cast;\n+use ptr;\n use iterator::{Iterator, IteratorUtil};\n use vec::{CopyableVector, ImmutableVector, OwnedVector};\n use to_bytes::IterBytes;\n@@ -39,27 +42,19 @@ impl Ascii {\n     /// Convert to lowercase.\n     #[inline]\n     pub fn to_lower(self) -> Ascii {\n-        if self.chr >= 65 && self.chr <= 90 {\n-            Ascii{chr: self.chr | 0x20 }\n-        } else {\n-            self\n-        }\n+        Ascii{chr: ASCII_LOWER_MAP[self.chr]}\n     }\n \n     /// Convert to uppercase.\n     #[inline]\n     pub fn to_upper(self) -> Ascii {\n-        if self.chr >= 97 && self.chr <= 122 {\n-            Ascii{chr: self.chr & !0x20 }\n-        } else {\n-            self\n-        }\n+        Ascii{chr: ASCII_UPPER_MAP[self.chr]}\n     }\n \n     /// Compares two ascii characters of equality, ignoring case.\n     #[inline]\n     pub fn eq_ignore_case(self, other: Ascii) -> bool {\n-        self.to_lower().chr == other.to_lower().chr\n+        ASCII_LOWER_MAP[self.chr] == ASCII_LOWER_MAP[other.chr]\n     }\n }\n \n@@ -261,10 +256,124 @@ impl ToBytesConsume for ~[Ascii] {\n     }\n }\n \n+\n+/// Convert the string to ASCII upper case:\n+/// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+/// but non-ASCII letters are unchanged.\n+#[inline]\n+pub fn to_ascii_upper(string: &str) -> ~str {\n+    map_bytes(string, ASCII_UPPER_MAP)\n+}\n+\n+/// Convert the string to ASCII lower case:\n+/// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+/// but non-ASCII letters are unchanged.\n+#[inline]\n+pub fn to_ascii_lower(string: &str) -> ~str {\n+    map_bytes(string, ASCII_LOWER_MAP)\n+}\n+\n+#[inline]\n+priv fn map_bytes(string: &str, map: &'static [u8]) -> ~str {\n+    let len = string.len();\n+    let mut result = str::with_capacity(len);\n+    unsafe {\n+        do result.as_mut_buf |mut buf, _| {\n+            for c in string.as_bytes().iter() {\n+                *buf = map[*c];\n+                buf = ptr::mut_offset(buf, 1)\n+            }\n+        }\n+        str::raw::set_len(&mut result, len);\n+    }\n+    result\n+}\n+\n+/// Check that two strings are an ASCII case-insensitive match.\n+/// Same as `to_ascii_lower(a) == to_ascii_lower(b)`,\n+/// but without allocating and copying temporary strings.\n+#[inline]\n+pub fn eq_ignore_ascii_case(a: &str, b: &str) -> bool {\n+    a.len() == b.len() && a.as_bytes().iter().zip(b.as_bytes().iter()).all(\n+        |(byte_a, byte_b)| ASCII_LOWER_MAP[*byte_a] == ASCII_LOWER_MAP[*byte_b])\n+}\n+\n+priv static ASCII_LOWER_MAP: &'static [u8] = &[\n+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n+    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n+    0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n+    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n+    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n+    0x78, 0x79, 0x7a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n+    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n+    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n+    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n+    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n+    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n+    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n+    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n+    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n+    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n+    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n+    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n+    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n+    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n+    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n+    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n+    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n+    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n+    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n+    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n+];\n+\n+priv static ASCII_UPPER_MAP: &'static [u8] = &[\n+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n+    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n+    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n+    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n+    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n+    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n+    0x60, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n+    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n+    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n+    0x58, 0x59, 0x5a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n+    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n+    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n+    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n+    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n+    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n+    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n+    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n+    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n+    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n+    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n+    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n+    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n+    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n+    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n+    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n+];\n+\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n     use to_bytes::ToBytes;\n+    use str::from_char;\n \n     macro_rules! v2ascii (\n         ( [$($e:expr),*]) => ( [$(Ascii{chr:$e}),*]);\n@@ -347,4 +456,53 @@ mod tests {\n \n     #[test] #[should_fail]\n     fn test_ascii_fail_char_slice() { '\u03bb'.to_ascii(); }\n+\n+    #[test]\n+    fn test_to_ascii_upper() {\n+        assert_eq!(to_ascii_upper(\"url()URL()uRl()\u00fcrl\"), ~\"URL()URL()URL()\u00fcRL\");\n+        assert_eq!(to_ascii_upper(\"h\u0131\u212a\u00df\"), ~\"H\u0131\u212a\u00df\");\n+\n+        let mut i = 0;\n+        while i <= 500 {\n+            let c = i as char;\n+            let upper = if 'a' <= c && c <= 'z' { c + 'A' - 'a' } else { c };\n+            assert_eq!(to_ascii_upper(from_char(i as char)), from_char(upper))\n+            i += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_to_ascii_lower() {\n+        assert_eq!(to_ascii_lower(\"url()URL()uRl()\u00dcrl\"), ~\"url()url()url()\u00dcrl\");\n+        // Dotted capital I, Kelvin sign, Sharp S.\n+        assert_eq!(to_ascii_lower(\"H\u0130\u212a\u00df\"), ~\"h\u0130\u212a\u00df\");\n+\n+        let mut i = 0;\n+        while i <= 500 {\n+            let c = i as char;\n+            let lower = if 'A' <= c && c <= 'Z' { c + 'a' - 'A' } else { c };\n+            assert_eq!(to_ascii_lower(from_char(i as char)), from_char(lower))\n+            i += 1;\n+        }\n+    }\n+\n+\n+    #[test]\n+    fn test_eq_ignore_ascii_case() {\n+        assert!(eq_ignore_ascii_case(\"url()URL()uRl()\u00dcrl\", \"url()url()url()\u00dcrl\"));\n+        assert!(!eq_ignore_ascii_case(\"\u00dcrl\", \"\u00fcrl\"));\n+        // Dotted capital I, Kelvin sign, Sharp S.\n+        assert!(eq_ignore_ascii_case(\"H\u0130\u212a\u00df\", \"h\u0130\u212a\u00df\"));\n+        assert!(!eq_ignore_ascii_case(\"\u0130\", \"i\"));\n+        assert!(!eq_ignore_ascii_case(\"\u212a\", \"k\"));\n+        assert!(!eq_ignore_ascii_case(\"\u00df\", \"s\"));\n+\n+        let mut i = 0;\n+        while i <= 500 {\n+            let c = i as char;\n+            let lower = if 'A' <= c && c <= 'Z' { c + 'a' - 'A' } else { c };\n+            assert!(eq_ignore_ascii_case(from_char(i as char), from_char(lower)));\n+            i += 1;\n+        }\n+    }\n }"}]}