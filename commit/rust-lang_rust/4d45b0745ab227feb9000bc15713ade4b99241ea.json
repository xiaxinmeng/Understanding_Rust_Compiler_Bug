{"sha": "4d45b0745ab227feb9000bc15713ade4b99241ea", "node_id": "C_kwDOAAsO6NoAKDRkNDViMDc0NWFiMjI3ZmViOTAwMGJjMTU3MTNhZGU0Yjk5MjQxZWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-25T08:16:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-25T08:16:43Z"}, "message": "Auto merge of #100571 - cjgillot:mir-cost-visit, r=compiler-errors\n\nCheck projection types before inlining MIR\n\nFixes https://github.com/rust-lang/rust/issues/100550\n\nI'm very unhappy with this solution, having to duplicate MIR validation code, but at least it removes the ICE.\n\nr? `@compiler-errors`", "tree": {"sha": "2078905d665f2677547f54fe9dbc434be8a03615", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2078905d665f2677547f54fe9dbc434be8a03615"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d45b0745ab227feb9000bc15713ade4b99241ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d45b0745ab227feb9000bc15713ade4b99241ea", "html_url": "https://github.com/rust-lang/rust/commit/4d45b0745ab227feb9000bc15713ade4b99241ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d45b0745ab227feb9000bc15713ade4b99241ea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76531befc4b0352247ada67bd225e8cf71ee5686", "url": "https://api.github.com/repos/rust-lang/rust/commits/76531befc4b0352247ada67bd225e8cf71ee5686", "html_url": "https://github.com/rust-lang/rust/commit/76531befc4b0352247ada67bd225e8cf71ee5686"}, {"sha": "911cbaed962006df6d70b8c1abdd7656be5adcaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/911cbaed962006df6d70b8c1abdd7656be5adcaf", "html_url": "https://github.com/rust-lang/rust/commit/911cbaed962006df6d70b8c1abdd7656be5adcaf"}], "stats": {"total": 374, "additions": 266, "deletions": 108}, "files": [{"sha": "1a14cd79fa0690a8cb618e702ca40e61548bca1a", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4d45b0745ab227feb9000bc15713ade4b99241ea/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d45b0745ab227feb9000bc15713ade4b99241ea/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=4d45b0745ab227feb9000bc15713ade4b99241ea", "patch": "@@ -89,22 +89,20 @@ pub fn equal_up_to_regions<'tcx>(\n \n     // Normalize lifetimes away on both sides, then compare.\n     let normalize = |ty: Ty<'tcx>| {\n-        tcx.normalize_erasing_regions(\n-            param_env,\n-            ty.fold_with(&mut BottomUpFolder {\n-                tcx,\n-                // FIXME: We erase all late-bound lifetimes, but this is not fully correct.\n-                // If you have a type like `<for<'a> fn(&'a u32) as SomeTrait>::Assoc`,\n-                // this is not necessarily equivalent to `<fn(&'static u32) as SomeTrait>::Assoc`,\n-                // since one may have an `impl SomeTrait for fn(&32)` and\n-                // `impl SomeTrait for fn(&'static u32)` at the same time which\n-                // specify distinct values for Assoc. (See also #56105)\n-                lt_op: |_| tcx.lifetimes.re_erased,\n-                // Leave consts and types unchanged.\n-                ct_op: |ct| ct,\n-                ty_op: |ty| ty,\n-            }),\n-        )\n+        let ty = ty.fold_with(&mut BottomUpFolder {\n+            tcx,\n+            // FIXME: We erase all late-bound lifetimes, but this is not fully correct.\n+            // If you have a type like `<for<'a> fn(&'a u32) as SomeTrait>::Assoc`,\n+            // this is not necessarily equivalent to `<fn(&'static u32) as SomeTrait>::Assoc`,\n+            // since one may have an `impl SomeTrait for fn(&32)` and\n+            // `impl SomeTrait for fn(&'static u32)` at the same time which\n+            // specify distinct values for Assoc. (See also #56105)\n+            lt_op: |_| tcx.lifetimes.re_erased,\n+            // Leave consts and types unchanged.\n+            ct_op: |ct| ct,\n+            ty_op: |ty| ty,\n+        });\n+        tcx.try_normalize_erasing_regions(param_env, ty).unwrap_or(ty)\n     };\n     tcx.infer_ctxt().enter(|infcx| infcx.can_eq(param_env, normalize(src), normalize(dest)).is_ok())\n }"}, {"sha": "d7d298401880476589b0b0b4fd82ce97f59ac0aa", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 222, "deletions": 92, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/4d45b0745ab227feb9000bc15713ade4b99241ea/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d45b0745ab227feb9000bc15713ade4b99241ea/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=4d45b0745ab227feb9000bc15713ade4b99241ea", "patch": "@@ -12,6 +12,7 @@ use rustc_middle::ty::{self, ConstKind, Instance, InstanceDef, ParamEnv, Ty, TyC\n use rustc_session::config::OptLevel;\n use rustc_span::def_id::DefId;\n use rustc_span::{hygiene::ExpnKind, ExpnData, LocalExpnId, Span};\n+use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n \n use super::simplify::{remove_dead_blocks, CfgSimplifier};\n@@ -414,118 +415,60 @@ impl<'tcx> Inliner<'tcx> {\n         debug!(\"    final inline threshold = {}\", threshold);\n \n         // FIXME: Give a bonus to functions with only a single caller\n-        let mut first_block = true;\n-        let mut cost = 0;\n+        let diverges = matches!(\n+            callee_body.basic_blocks()[START_BLOCK].terminator().kind,\n+            TerminatorKind::Unreachable | TerminatorKind::Call { target: None, .. }\n+        );\n+        if diverges && !matches!(callee_attrs.inline, InlineAttr::Always) {\n+            return Err(\"callee diverges unconditionally\");\n+        }\n+\n+        let mut checker = CostChecker {\n+            tcx: self.tcx,\n+            param_env: self.param_env,\n+            instance: callsite.callee,\n+            callee_body,\n+            cost: 0,\n+            validation: Ok(()),\n+        };\n \n-        // Traverse the MIR manually so we can account for the effects of\n-        // inlining on the CFG.\n+        // Traverse the MIR manually so we can account for the effects of inlining on the CFG.\n         let mut work_list = vec![START_BLOCK];\n         let mut visited = BitSet::new_empty(callee_body.basic_blocks().len());\n         while let Some(bb) = work_list.pop() {\n             if !visited.insert(bb.index()) {\n                 continue;\n             }\n+\n             let blk = &callee_body.basic_blocks()[bb];\n+            checker.visit_basic_block_data(bb, blk);\n \n-            for stmt in &blk.statements {\n-                // Don't count StorageLive/StorageDead in the inlining cost.\n-                match stmt.kind {\n-                    StatementKind::StorageLive(_)\n-                    | StatementKind::StorageDead(_)\n-                    | StatementKind::Deinit(_)\n-                    | StatementKind::Nop => {}\n-                    _ => cost += INSTR_COST,\n-                }\n-            }\n             let term = blk.terminator();\n-            let mut is_drop = false;\n-            match term.kind {\n-                TerminatorKind::Drop { ref place, target, unwind }\n-                | TerminatorKind::DropAndReplace { ref place, target, unwind, .. } => {\n-                    is_drop = true;\n-                    work_list.push(target);\n-                    // If the place doesn't actually need dropping, treat it like\n-                    // a regular goto.\n-                    let ty = callsite.callee.subst_mir(self.tcx, &place.ty(callee_body, tcx).ty);\n-                    if ty.needs_drop(tcx, self.param_env) {\n-                        cost += CALL_PENALTY;\n-                        if let Some(unwind) = unwind {\n-                            cost += LANDINGPAD_PENALTY;\n-                            work_list.push(unwind);\n-                        }\n-                    } else {\n-                        cost += INSTR_COST;\n-                    }\n-                }\n-\n-                TerminatorKind::Unreachable | TerminatorKind::Call { target: None, .. }\n-                    if first_block =>\n-                {\n-                    // If the function always diverges, don't inline\n-                    // unless the cost is zero\n-                    threshold = 0;\n-                }\n-\n-                TerminatorKind::Call { func: Operand::Constant(ref f), cleanup, .. } => {\n-                    if let ty::FnDef(def_id, _) =\n-                        *callsite.callee.subst_mir(self.tcx, &f.literal.ty()).kind()\n-                    {\n-                        // Don't give intrinsics the extra penalty for calls\n-                        if tcx.is_intrinsic(def_id) {\n-                            cost += INSTR_COST;\n-                        } else {\n-                            cost += CALL_PENALTY;\n-                        }\n-                    } else {\n-                        cost += CALL_PENALTY;\n-                    }\n-                    if cleanup.is_some() {\n-                        cost += LANDINGPAD_PENALTY;\n-                    }\n-                }\n-                TerminatorKind::Assert { cleanup, .. } => {\n-                    cost += CALL_PENALTY;\n-\n-                    if cleanup.is_some() {\n-                        cost += LANDINGPAD_PENALTY;\n-                    }\n-                }\n-                TerminatorKind::Resume => cost += RESUME_PENALTY,\n-                TerminatorKind::InlineAsm { cleanup, .. } => {\n-                    cost += INSTR_COST;\n+            if let TerminatorKind::Drop { ref place, target, unwind }\n+            | TerminatorKind::DropAndReplace { ref place, target, unwind, .. } = term.kind\n+            {\n+                work_list.push(target);\n \n-                    if cleanup.is_some() {\n-                        cost += LANDINGPAD_PENALTY;\n+                // If the place doesn't actually need dropping, treat it like a regular goto.\n+                let ty = callsite.callee.subst_mir(self.tcx, &place.ty(callee_body, tcx).ty);\n+                if ty.needs_drop(tcx, self.param_env) && let Some(unwind) = unwind {\n+                        work_list.push(unwind);\n                     }\n-                }\n-                _ => cost += INSTR_COST,\n-            }\n-\n-            if !is_drop {\n-                for succ in term.successors() {\n-                    work_list.push(succ);\n-                }\n+            } else {\n+                work_list.extend(term.successors())\n             }\n-\n-            first_block = false;\n         }\n \n         // Count up the cost of local variables and temps, if we know the size\n         // use that, otherwise we use a moderately-large dummy cost.\n-\n-        let ptr_size = tcx.data_layout.pointer_size.bytes();\n-\n         for v in callee_body.vars_and_temps_iter() {\n-            let ty = callsite.callee.subst_mir(self.tcx, &callee_body.local_decls[v].ty);\n-            // Cost of the var is the size in machine-words, if we know\n-            // it.\n-            if let Some(size) = type_size_of(tcx, self.param_env, ty) {\n-                cost += ((size + ptr_size - 1) / ptr_size) as usize;\n-            } else {\n-                cost += UNKNOWN_SIZE_COST;\n-            }\n+            checker.visit_local_decl(v, &callee_body.local_decls[v]);\n         }\n \n+        // Abort if type validation found anything fishy.\n+        checker.validation?;\n+\n+        let cost = checker.cost;\n         if let InlineAttr::Always = callee_attrs.inline {\n             debug!(\"INLINING {:?} because inline(always) [cost={}]\", callsite, cost);\n             Ok(())\n@@ -799,6 +742,193 @@ fn type_size_of<'tcx>(\n     tcx.layout_of(param_env.and(ty)).ok().map(|layout| layout.size.bytes())\n }\n \n+/// Verify that the callee body is compatible with the caller.\n+///\n+/// This visitor mostly computes the inlining cost,\n+/// but also needs to verify that types match because of normalization failure.\n+struct CostChecker<'b, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    cost: usize,\n+    callee_body: &'b Body<'tcx>,\n+    instance: ty::Instance<'tcx>,\n+    validation: Result<(), &'static str>,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n+    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n+        // Don't count StorageLive/StorageDead in the inlining cost.\n+        match statement.kind {\n+            StatementKind::StorageLive(_)\n+            | StatementKind::StorageDead(_)\n+            | StatementKind::Deinit(_)\n+            | StatementKind::Nop => {}\n+            _ => self.cost += INSTR_COST,\n+        }\n+\n+        self.super_statement(statement, location);\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        let tcx = self.tcx;\n+        match terminator.kind {\n+            TerminatorKind::Drop { ref place, unwind, .. }\n+            | TerminatorKind::DropAndReplace { ref place, unwind, .. } => {\n+                // If the place doesn't actually need dropping, treat it like a regular goto.\n+                let ty = self.instance.subst_mir(tcx, &place.ty(self.callee_body, tcx).ty);\n+                if ty.needs_drop(tcx, self.param_env) {\n+                    self.cost += CALL_PENALTY;\n+                    if unwind.is_some() {\n+                        self.cost += LANDINGPAD_PENALTY;\n+                    }\n+                } else {\n+                    self.cost += INSTR_COST;\n+                }\n+            }\n+            TerminatorKind::Call { func: Operand::Constant(ref f), cleanup, .. } => {\n+                let fn_ty = self.instance.subst_mir(tcx, &f.literal.ty());\n+                self.cost += if let ty::FnDef(def_id, _) = *fn_ty.kind() && tcx.is_intrinsic(def_id) {\n+                    // Don't give intrinsics the extra penalty for calls\n+                    INSTR_COST\n+                } else {\n+                    CALL_PENALTY\n+                };\n+                if cleanup.is_some() {\n+                    self.cost += LANDINGPAD_PENALTY;\n+                }\n+            }\n+            TerminatorKind::Assert { cleanup, .. } => {\n+                self.cost += CALL_PENALTY;\n+                if cleanup.is_some() {\n+                    self.cost += LANDINGPAD_PENALTY;\n+                }\n+            }\n+            TerminatorKind::Resume => self.cost += RESUME_PENALTY,\n+            TerminatorKind::InlineAsm { cleanup, .. } => {\n+                self.cost += INSTR_COST;\n+                if cleanup.is_some() {\n+                    self.cost += LANDINGPAD_PENALTY;\n+                }\n+            }\n+            _ => self.cost += INSTR_COST,\n+        }\n+\n+        self.super_terminator(terminator, location);\n+    }\n+\n+    /// Count up the cost of local variables and temps, if we know the size\n+    /// use that, otherwise we use a moderately-large dummy cost.\n+    fn visit_local_decl(&mut self, local: Local, local_decl: &LocalDecl<'tcx>) {\n+        let tcx = self.tcx;\n+        let ptr_size = tcx.data_layout.pointer_size.bytes();\n+\n+        let ty = self.instance.subst_mir(tcx, &local_decl.ty);\n+        // Cost of the var is the size in machine-words, if we know\n+        // it.\n+        if let Some(size) = type_size_of(tcx, self.param_env, ty) {\n+            self.cost += ((size + ptr_size - 1) / ptr_size) as usize;\n+        } else {\n+            self.cost += UNKNOWN_SIZE_COST;\n+        }\n+\n+        self.super_local_decl(local, local_decl)\n+    }\n+\n+    /// This method duplicates code from MIR validation in an attempt to detect type mismatches due\n+    /// to normalization failure.\n+    fn visit_projection_elem(\n+        &mut self,\n+        local: Local,\n+        proj_base: &[PlaceElem<'tcx>],\n+        elem: PlaceElem<'tcx>,\n+        context: PlaceContext,\n+        location: Location,\n+    ) {\n+        if let ProjectionElem::Field(f, ty) = elem {\n+            let parent = Place { local, projection: self.tcx.intern_place_elems(proj_base) };\n+            let parent_ty = parent.ty(&self.callee_body.local_decls, self.tcx);\n+            let check_equal = |this: &mut Self, f_ty| {\n+                if !equal_up_to_regions(this.tcx, this.param_env, ty, f_ty) {\n+                    trace!(?ty, ?f_ty);\n+                    this.validation = Err(\"failed to normalize projection type\");\n+                    return;\n+                }\n+            };\n+\n+            let kind = match parent_ty.ty.kind() {\n+                &ty::Opaque(def_id, substs) => {\n+                    self.tcx.bound_type_of(def_id).subst(self.tcx, substs).kind()\n+                }\n+                kind => kind,\n+            };\n+\n+            match kind {\n+                ty::Tuple(fields) => {\n+                    let Some(f_ty) = fields.get(f.as_usize()) else {\n+                        self.validation = Err(\"malformed MIR\");\n+                        return;\n+                    };\n+                    check_equal(self, *f_ty);\n+                }\n+                ty::Adt(adt_def, substs) => {\n+                    let var = parent_ty.variant_index.unwrap_or(VariantIdx::from_u32(0));\n+                    let Some(field) = adt_def.variant(var).fields.get(f.as_usize()) else {\n+                        self.validation = Err(\"malformed MIR\");\n+                        return;\n+                    };\n+                    check_equal(self, field.ty(self.tcx, substs));\n+                }\n+                ty::Closure(_, substs) => {\n+                    let substs = substs.as_closure();\n+                    let Some(f_ty) = substs.upvar_tys().nth(f.as_usize()) else {\n+                        self.validation = Err(\"malformed MIR\");\n+                        return;\n+                    };\n+                    check_equal(self, f_ty);\n+                }\n+                &ty::Generator(def_id, substs, _) => {\n+                    let f_ty = if let Some(var) = parent_ty.variant_index {\n+                        let gen_body = if def_id == self.callee_body.source.def_id() {\n+                            self.callee_body\n+                        } else {\n+                            self.tcx.optimized_mir(def_id)\n+                        };\n+\n+                        let Some(layout) = gen_body.generator_layout() else {\n+                            self.validation = Err(\"malformed MIR\");\n+                            return;\n+                        };\n+\n+                        let Some(&local) = layout.variant_fields[var].get(f) else {\n+                            self.validation = Err(\"malformed MIR\");\n+                            return;\n+                        };\n+\n+                        let Some(&f_ty) = layout.field_tys.get(local) else {\n+                            self.validation = Err(\"malformed MIR\");\n+                            return;\n+                        };\n+\n+                        f_ty\n+                    } else {\n+                        let Some(f_ty) = substs.as_generator().prefix_tys().nth(f.index()) else {\n+                            self.validation = Err(\"malformed MIR\");\n+                            return;\n+                        };\n+\n+                        f_ty\n+                    };\n+\n+                    check_equal(self, f_ty);\n+                }\n+                _ => self.validation = Err(\"malformed MIR\"),\n+            }\n+        }\n+\n+        self.super_projection_elem(local, proj_base, elem, context, location);\n+    }\n+}\n+\n /**\n  * Integrator.\n  *"}, {"sha": "f67b0735481676475411bbf39b90228ee753b77a", "filename": "src/test/ui/mir/mir-inlining/ice-issue-100550-unnormalized-projection.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4d45b0745ab227feb9000bc15713ade4b99241ea/src%2Ftest%2Fui%2Fmir%2Fmir-inlining%2Fice-issue-100550-unnormalized-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d45b0745ab227feb9000bc15713ade4b99241ea/src%2Ftest%2Fui%2Fmir%2Fmir-inlining%2Fice-issue-100550-unnormalized-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir-inlining%2Fice-issue-100550-unnormalized-projection.rs?ref=4d45b0745ab227feb9000bc15713ade4b99241ea", "patch": "@@ -0,0 +1,30 @@\n+// This test verifies that we do not ICE due to MIR inlining in case of normalization failure\n+// in a projection.\n+//\n+// compile-flags: --crate-type lib -C opt-level=3\n+// build-pass\n+\n+pub trait Trait {\n+    type Associated;\n+}\n+impl<T> Trait for T {\n+    type Associated = T;\n+}\n+\n+pub struct Struct<T>(<T as Trait>::Associated);\n+\n+pub fn foo<T>() -> Struct<T>\n+where\n+    T: Trait,\n+{\n+    bar()\n+}\n+\n+#[inline]\n+fn bar<T>() -> Struct<T> {\n+    Struct(baz())\n+}\n+\n+fn baz<T>() -> T {\n+    unimplemented!()\n+}"}]}