{"sha": "b851d1cdb47b5961a4b37b0645232a18e122663f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NTFkMWNkYjQ3YjU5NjFhNGIzN2IwNjQ1MjMyYTE4ZTEyMjY2M2Y=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-05-31T16:52:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-31T16:52:45Z"}, "message": "Rollup merge of #42196 - tommyip:explain_closure_err, r=nikomatsakis\n\nExplain why a closure is `FnOnce` in closure errors.\n\nIssue: #42065\n@nikomatsakis Am I going the right direction with this?\n\n~~I am stuck in a few bits:~~\n~~1. How to trace the code to get the upvar instead of the original variable's span?~~\n~~2. How to find the node id of the upvar where the move occured?~~", "tree": {"sha": "82d2b94279f3e0b9e33925389f06f53a33b7693c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82d2b94279f3e0b9e33925389f06f53a33b7693c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b851d1cdb47b5961a4b37b0645232a18e122663f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b851d1cdb47b5961a4b37b0645232a18e122663f", "html_url": "https://github.com/rust-lang/rust/commit/b851d1cdb47b5961a4b37b0645232a18e122663f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b851d1cdb47b5961a4b37b0645232a18e122663f/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5a7fd585fd3f0e98c99db74cf5071efdbd1a59a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5a7fd585fd3f0e98c99db74cf5071efdbd1a59a", "html_url": "https://github.com/rust-lang/rust/commit/d5a7fd585fd3f0e98c99db74cf5071efdbd1a59a"}, {"sha": "c2f7e945526bff3b7d812137d81b235263060ee8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2f7e945526bff3b7d812137d81b235263060ee8", "html_url": "https://github.com/rust-lang/rust/commit/c2f7e945526bff3b7d812137d81b235263060ee8"}], "stats": {"total": 98, "additions": 66, "deletions": 32}, "files": [{"sha": "a6dbbee79a48c83dfa6ab3651e4259f97d03eafc", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b851d1cdb47b5961a4b37b0645232a18e122663f/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b851d1cdb47b5961a4b37b0645232a18e122663f/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=b851d1cdb47b5961a4b37b0645232a18e122663f", "patch": "@@ -1682,7 +1682,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         if let InferTables::InProgress(tables) = self.tables {\n             if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                return tables.borrow().closure_kinds.get(&id).cloned();\n+                return tables.borrow()\n+                             .closure_kinds\n+                             .get(&id)\n+                             .cloned()\n+                             .map(|(kind, _)| kind);\n             }\n         }\n "}, {"sha": "e3d7aeb22e1fad5390d584d224fbac8bfffd3645", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b851d1cdb47b5961a4b37b0645232a18e122663f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b851d1cdb47b5961a4b37b0645232a18e122663f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b851d1cdb47b5961a4b37b0645232a18e122663f", "patch": "@@ -58,6 +58,7 @@ use syntax::abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::symbol::{Symbol, keywords};\n+use syntax_pos::Span;\n \n use hir;\n \n@@ -229,8 +230,9 @@ pub struct TypeckTables<'tcx> {\n     /// Records the type of each closure.\n     pub closure_tys: NodeMap<ty::PolyFnSig<'tcx>>,\n \n-    /// Records the kind of each closure.\n-    pub closure_kinds: NodeMap<ty::ClosureKind>,\n+    /// Records the kind of each closure and the span and name of the variable\n+    /// that caused the closure to be this kind.\n+    pub closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n \n     /// For each fn, records the \"liberated\" types of its arguments\n     /// and return type. Liberated means that all bound regions"}, {"sha": "9b084acc1938fd39eedea5e390239e564171fb1f", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b851d1cdb47b5961a4b37b0645232a18e122663f/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b851d1cdb47b5961a4b37b0645232a18e122663f/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=b851d1cdb47b5961a4b37b0645232a18e122663f", "patch": "@@ -39,8 +39,6 @@ use rustc::middle::free_region::RegionRelations;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n \n-use syntax_pos::DUMMY_SP;\n-\n use std::fmt;\n use std::rc::Rc;\n use std::hash::{Hash, Hasher};\n@@ -587,9 +585,15 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     verb, msg, nl);\n                 let need_note = match lp.ty.sty {\n                     ty::TypeVariants::TyClosure(id, _) => {\n-                        if let Ok(ty::ClosureKind::FnOnce) =\n-                           ty::queries::closure_kind::try_get(self.tcx, DUMMY_SP, id) {\n-                            err.help(\"closure was moved because it only implements `FnOnce`\");\n+                        let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n+                        if let Some(&(ty::ClosureKind::FnOnce, Some((span, name)))) =\n+                            self.tables.closure_kinds.get(&node_id)\n+                        {\n+                            err.span_note(span, &format!(\n+                                \"closure cannot be invoked more than once because \\\n+                                it moves the variable `{}` out of its environment\",\n+                                name\n+                            ));\n                             false\n                         } else {\n                             true"}, {"sha": "c2e8269aafef94091e5b2c437c6bb78cc3879713", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b851d1cdb47b5961a4b37b0645232a18e122663f/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b851d1cdb47b5961a4b37b0645232a18e122663f/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=b851d1cdb47b5961a4b37b0645232a18e122663f", "patch": "@@ -103,7 +103,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.tables.borrow_mut().closure_tys.insert(expr.id, sig);\n         match opt_kind {\n             Some(kind) => {\n-                self.tables.borrow_mut().closure_kinds.insert(expr.id, kind);\n+                self.tables.borrow_mut().closure_kinds.insert(expr.id, (kind, None));\n             }\n             None => {}\n         }"}, {"sha": "1a1a9361a89f9929cec3266baa18ceb59676ee12", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b851d1cdb47b5961a4b37b0645232a18e122663f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b851d1cdb47b5961a4b37b0645232a18e122663f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=b851d1cdb47b5961a4b37b0645232a18e122663f", "patch": "@@ -814,7 +814,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n             let closure_kinds = &self.tables.borrow().closure_kinds;\n             let closure_kind = match closure_kinds.get(&closure_id) {\n-                Some(&k) => k,\n+                Some(&(k, _)) => k,\n                 None => {\n                     return Err(MethodError::ClosureAmbiguity(trait_def_id));\n                 }"}, {"sha": "3a6fd51693e73539bbc5d085a4727e2a292bd9d2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b851d1cdb47b5961a4b37b0645232a18e122663f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b851d1cdb47b5961a4b37b0645232a18e122663f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b851d1cdb47b5961a4b37b0645232a18e122663f", "patch": "@@ -702,7 +702,7 @@ fn closure_kind<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           def_id: DefId)\n                           -> ty::ClosureKind {\n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    tcx.typeck_tables_of(def_id).closure_kinds[&node_id]\n+    tcx.typeck_tables_of(def_id).closure_kinds[&node_id].0\n }\n \n fn adt_destructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "114290c52d195469dc23d6fe2b92d29ce182caab", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b851d1cdb47b5961a4b37b0645232a18e122663f/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b851d1cdb47b5961a4b37b0645232a18e122663f/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=b851d1cdb47b5961a4b37b0645232a18e122663f", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n struct SeedBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    temp_closure_kinds: NodeMap<ty::ClosureKind>,\n+    temp_closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n }\n \n impl<'a, 'gcx, 'tcx> Visitor<'gcx> for SeedBorrowKind<'a, 'gcx, 'tcx> {\n@@ -107,7 +107,7 @@ impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n                      capture_clause: hir::CaptureClause)\n     {\n         if !self.fcx.tables.borrow().closure_kinds.contains_key(&expr.id) {\n-            self.temp_closure_kinds.insert(expr.id, ty::ClosureKind::Fn);\n+            self.temp_closure_kinds.insert(expr.id, (ty::ClosureKind::Fn, None));\n             debug!(\"check_closure: adding closure {:?} as Fn\", expr.id);\n         }\n \n@@ -143,12 +143,12 @@ impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n \n struct AdjustBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    temp_closure_kinds: NodeMap<ty::ClosureKind>,\n+    temp_closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n }\n \n impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-           temp_closure_kinds: NodeMap<ty::ClosureKind>)\n+           temp_closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>)\n            -> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         AdjustBorrowKind { fcx: fcx, temp_closure_kinds: temp_closure_kinds }\n     }\n@@ -211,8 +211,8 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n \n         // If we are also inferred the closure kind here, update the\n         // main table and process any deferred resolutions.\n-        if let Some(&kind) = self.temp_closure_kinds.get(&id) {\n-            self.fcx.tables.borrow_mut().closure_kinds.insert(id, kind);\n+        if let Some(&(kind, context)) = self.temp_closure_kinds.get(&id) {\n+            self.fcx.tables.borrow_mut().closure_kinds.insert(id, (kind, context));\n             let closure_def_id = self.fcx.tcx.hir.local_def_id(id);\n             debug!(\"closure_kind({:?}) = {:?}\", closure_def_id, kind);\n \n@@ -272,6 +272,8 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n             euv::Move(_) => { }\n         }\n \n+        let tcx = self.fcx.tcx;\n+\n         // watch out for a move of the deref of a borrowed pointer;\n         // for that to be legal, the upvar would have to be borrowed\n         // by value instead\n@@ -289,7 +291,9 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n \n                         // to move out of an upvar, this must be a FnOnce closure\n                         self.adjust_closure_kind(upvar_id.closure_expr_id,\n-                                                 ty::ClosureKind::FnOnce);\n+                                                 ty::ClosureKind::FnOnce,\n+                                                 guarantor.span,\n+                                                 tcx.hir.name(upvar_id.var_id));\n \n                         let upvar_capture_map =\n                             &mut self.fcx.tables.borrow_mut().upvar_capture_map;\n@@ -303,7 +307,9 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                         // to be a FnOnce closure to permit moves out\n                         // of the environment.\n                         self.adjust_closure_kind(upvar_id.closure_expr_id,\n-                                                 ty::ClosureKind::FnOnce);\n+                                                 ty::ClosureKind::FnOnce,\n+                                                 guarantor.span,\n+                                                 tcx.hir.name(upvar_id.var_id));\n                     }\n                     mc::NoteNone => {\n                     }\n@@ -331,7 +337,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n \n             Categorization::Deref(base, _, mc::BorrowedPtr(..)) |\n             Categorization::Deref(base, _, mc::Implicit(..)) => {\n-                if !self.try_adjust_upvar_deref(&cmt.note, ty::MutBorrow) {\n+                if !self.try_adjust_upvar_deref(cmt, ty::MutBorrow) {\n                     // assignment to deref of an `&mut`\n                     // borrowed pointer implies that the\n                     // pointer itself must be unique, but not\n@@ -365,7 +371,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n \n             Categorization::Deref(base, _, mc::BorrowedPtr(..)) |\n             Categorization::Deref(base, _, mc::Implicit(..)) => {\n-                if !self.try_adjust_upvar_deref(&cmt.note, ty::UniqueImmBorrow) {\n+                if !self.try_adjust_upvar_deref(cmt, ty::UniqueImmBorrow) {\n                     // for a borrowed pointer to be unique, its\n                     // base must be unique\n                     self.adjust_upvar_borrow_kind_for_unique(base);\n@@ -382,7 +388,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     }\n \n     fn try_adjust_upvar_deref(&mut self,\n-                              note: &mc::Note,\n+                              cmt: mc::cmt<'tcx>,\n                               borrow_kind: ty::BorrowKind)\n                               -> bool\n     {\n@@ -394,7 +400,9 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n             ty::ImmBorrow => false,\n         });\n \n-        match *note {\n+        let tcx = self.fcx.tcx;\n+\n+        match cmt.note {\n             mc::NoteUpvarRef(upvar_id) => {\n                 // if this is an implicit deref of an\n                 // upvar, then we need to modify the\n@@ -407,15 +415,21 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                 }\n \n                 // also need to be in an FnMut closure since this is not an ImmBorrow\n-                self.adjust_closure_kind(upvar_id.closure_expr_id, ty::ClosureKind::FnMut);\n+                self.adjust_closure_kind(upvar_id.closure_expr_id,\n+                                         ty::ClosureKind::FnMut,\n+                                         cmt.span,\n+                                         tcx.hir.name(upvar_id.var_id));\n \n                 true\n             }\n             mc::NoteClosureEnv(upvar_id) => {\n                 // this kind of deref occurs in a `move` closure, or\n                 // for a by-value upvar; in either case, to mutate an\n                 // upvar, we need to be an FnMut closure\n-                self.adjust_closure_kind(upvar_id.closure_expr_id, ty::ClosureKind::FnMut);\n+                self.adjust_closure_kind(upvar_id.closure_expr_id,\n+                                         ty::ClosureKind::FnMut,\n+                                         cmt.span,\n+                                         tcx.hir.name(upvar_id.var_id));\n \n                 true\n             }\n@@ -462,11 +476,13 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n \n     fn adjust_closure_kind(&mut self,\n                            closure_id: ast::NodeId,\n-                           new_kind: ty::ClosureKind) {\n-        debug!(\"adjust_closure_kind(closure_id={}, new_kind={:?})\",\n-               closure_id, new_kind);\n+                           new_kind: ty::ClosureKind,\n+                           upvar_span: Span,\n+                           var_name: ast::Name) {\n+        debug!(\"adjust_closure_kind(closure_id={}, new_kind={:?}, upvar_span={:?}, var_name={})\",\n+               closure_id, new_kind, upvar_span, var_name);\n \n-        if let Some(&existing_kind) = self.temp_closure_kinds.get(&closure_id) {\n+        if let Some(&(existing_kind, _)) = self.temp_closure_kinds.get(&closure_id) {\n             debug!(\"adjust_closure_kind: closure_id={}, existing_kind={:?}, new_kind={:?}\",\n                    closure_id, existing_kind, new_kind);\n \n@@ -482,7 +498,10 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                 (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n                 (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n                     // new kind is stronger than the old kind\n-                    self.temp_closure_kinds.insert(closure_id, new_kind);\n+                    self.temp_closure_kinds.insert(\n+                        closure_id,\n+                        (new_kind, Some((upvar_span, var_name)))\n+                    );\n                 }\n             }\n         }"}, {"sha": "409964082f2b6582302fad782c72d9932e0936a6", "filename": "src/test/ui/fn_once-moved.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b851d1cdb47b5961a4b37b0645232a18e122663f/src%2Ftest%2Fui%2Ffn_once-moved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b851d1cdb47b5961a4b37b0645232a18e122663f/src%2Ftest%2Fui%2Ffn_once-moved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn_once-moved.rs?ref=b851d1cdb47b5961a4b37b0645232a18e122663f", "patch": "@@ -20,5 +20,6 @@ fn main() {\n     debug_dump_dict();\n     debug_dump_dict();\n     //~^ ERROR use of moved value: `debug_dump_dict`\n-    //~| NOTE closure was moved because it only implements `FnOnce`\n+    //~| NOTE closure cannot be invoked more than once because it moves the\n+    //~| variable `dict` out of its environment\n }"}, {"sha": "27b7d91d1d4b63eb3fdf74074f5bf91f7182a026", "filename": "src/test/ui/fn_once-moved.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b851d1cdb47b5961a4b37b0645232a18e122663f/src%2Ftest%2Fui%2Ffn_once-moved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b851d1cdb47b5961a4b37b0645232a18e122663f/src%2Ftest%2Fui%2Ffn_once-moved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn_once-moved.stderr?ref=b851d1cdb47b5961a4b37b0645232a18e122663f", "patch": "@@ -6,7 +6,11 @@ error[E0382]: use of moved value: `debug_dump_dict`\n 21 |     debug_dump_dict();\n    |     ^^^^^^^^^^^^^^^ value used here after move\n    |\n-   = help: closure was moved because it only implements `FnOnce`\n+note: closure cannot be invoked more than once because it moves the variable `dict` out of its environment\n+  --> $DIR/fn_once-moved.rs:16:29\n+   |\n+16 |         for (key, value) in dict {\n+   |                             ^^^^\n \n error: aborting due to previous error(s)\n "}]}