{"sha": "494896f2dd4ff541c371a8952b8f38cb02409835", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5NDg5NmYyZGQ0ZmY1NDFjMzcxYTg5NTJiOGYzOGNiMDI0MDk4MzU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-20T23:38:50Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-24T05:03:54Z"}, "message": "serialize: Remove base64 support\n\nThis is not used in-tree and is available out-of-tree", "tree": {"sha": "0b7febf6967e0a43ed5435b144419faef57e824e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b7febf6967e0a43ed5435b144419faef57e824e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/494896f2dd4ff541c371a8952b8f38cb02409835", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/494896f2dd4ff541c371a8952b8f38cb02409835", "html_url": "https://github.com/rust-lang/rust/commit/494896f2dd4ff541c371a8952b8f38cb02409835", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/494896f2dd4ff541c371a8952b8f38cb02409835/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4be79d6acde9eed3a9b5281a46f385bcb4ce736c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4be79d6acde9eed3a9b5281a46f385bcb4ce736c", "html_url": "https://github.com/rust-lang/rust/commit/4be79d6acde9eed3a9b5281a46f385bcb4ce736c"}], "stats": {"total": 425, "additions": 0, "deletions": 425}, "files": [{"sha": "c97d67ba1b9b4229bbe1cf642c8c1efcc1c83aab", "filename": "src/libserialize/base64.rs", "status": "removed", "additions": 0, "deletions": 424, "changes": 424, "blob_url": "https://github.com/rust-lang/rust/blob/4be79d6acde9eed3a9b5281a46f385bcb4ce736c/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be79d6acde9eed3a9b5281a46f385bcb4ce736c/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=4be79d6acde9eed3a9b5281a46f385bcb4ce736c", "patch": "@@ -1,424 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// ignore-lexer-test FIXME #15679\n-\n-//! Base64 binary-to-text encoding\n-\n-pub use self::FromBase64Error::*;\n-pub use self::CharacterSet::*;\n-\n-use std::fmt;\n-use std::error;\n-\n-/// Available encoding character sets\n-#[derive(Copy)]\n-pub enum CharacterSet {\n-    /// The standard character set (uses `+` and `/`)\n-    Standard,\n-    /// The URL safe character set (uses `-` and `_`)\n-    UrlSafe\n-}\n-\n-/// Available newline types\n-#[derive(Copy)]\n-pub enum Newline {\n-    /// A linefeed (i.e. Unix-style newline)\n-    LF,\n-    /// A carriage return and a linefeed (i.e. Windows-style newline)\n-    CRLF\n-}\n-\n-/// Contains configuration parameters for `to_base64`.\n-#[derive(Copy)]\n-pub struct Config {\n-    /// Character set to use\n-    pub char_set: CharacterSet,\n-    /// Newline to use\n-    pub newline: Newline,\n-    /// True to pad output with `=` characters\n-    pub pad: bool,\n-    /// `Some(len)` to wrap lines at `len`, `None` to disable line wrapping\n-    pub line_length: Option<uint>\n-}\n-\n-/// Configuration for RFC 4648 standard base64 encoding\n-pub static STANDARD: Config =\n-    Config {char_set: Standard, newline: Newline::CRLF, pad: true, line_length: None};\n-\n-/// Configuration for RFC 4648 base64url encoding\n-pub static URL_SAFE: Config =\n-    Config {char_set: UrlSafe, newline: Newline::CRLF, pad: false, line_length: None};\n-\n-/// Configuration for RFC 2045 MIME base64 encoding\n-pub static MIME: Config =\n-    Config {char_set: Standard, newline: Newline::CRLF, pad: true, line_length: Some(76)};\n-\n-static STANDARD_CHARS: &'static[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n-                                        abcdefghijklmnopqrstuvwxyz\\\n-                                        0123456789+/\";\n-\n-static URLSAFE_CHARS: &'static[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n-                                       abcdefghijklmnopqrstuvwxyz\\\n-                                       0123456789-_\";\n-\n-/// A trait for converting a value to base64 encoding.\n-pub trait ToBase64 {\n-    /// Converts the value of `self` to a base64 value following the specified\n-    /// format configuration, returning the owned string.\n-    fn to_base64(&self, config: Config) -> String;\n-}\n-\n-impl ToBase64 for [u8] {\n-    /// Turn a vector of `u8` bytes into a base64 string.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// extern crate serialize;\n-    /// use serialize::base64::{ToBase64, STANDARD};\n-    ///\n-    /// fn main () {\n-    ///     let str = [52,32].to_base64(STANDARD);\n-    ///     println!(\"base 64 output: {}\", str);\n-    /// }\n-    /// ```\n-    fn to_base64(&self, config: Config) -> String {\n-        let bytes = match config.char_set {\n-            Standard => STANDARD_CHARS,\n-            UrlSafe => URLSAFE_CHARS\n-        };\n-\n-        // In general, this Vec only needs (4/3) * self.len() memory, but\n-        // addition is faster than multiplication and division.\n-        let mut v = Vec::with_capacity(self.len() + self.len());\n-        let mut i = 0;\n-        let mut cur_length = 0;\n-        let len = self.len();\n-        let mod_len = len % 3;\n-        let cond_len = len - mod_len;\n-        let newline = match config.newline {\n-            Newline::LF => b\"\\n\",\n-            Newline::CRLF => b\"\\r\\n\"\n-        };\n-        while i < cond_len {\n-            let (first, second, third) = (self[i], self[i + 1], self[i + 2]);\n-            if let Some(line_length) = config.line_length {\n-                if cur_length >= line_length {\n-                    v.push_all(newline);\n-                    cur_length = 0;\n-                }\n-            }\n-\n-            let n = (first  as u32) << 16 |\n-                    (second as u32) << 8 |\n-                    (third  as u32);\n-\n-            // This 24-bit number gets separated into four 6-bit numbers.\n-            v.push(bytes[((n >> 18) & 63) as uint]);\n-            v.push(bytes[((n >> 12) & 63) as uint]);\n-            v.push(bytes[((n >> 6 ) & 63) as uint]);\n-            v.push(bytes[(n & 63) as uint]);\n-\n-            cur_length += 4;\n-            i += 3;\n-        }\n-\n-        if mod_len != 0 {\n-            if let Some(line_length) = config.line_length {\n-                if cur_length >= line_length {\n-                    v.push_all(newline);\n-                }\n-            }\n-        }\n-\n-        // Heh, would be cool if we knew this was exhaustive\n-        // (the dream of bounded integer types)\n-        match mod_len {\n-            0 => (),\n-            1 => {\n-                let n = (self[i] as u32) << 16;\n-                v.push(bytes[((n >> 18) & 63) as uint]);\n-                v.push(bytes[((n >> 12) & 63) as uint]);\n-                if config.pad {\n-                    v.push(b'=');\n-                    v.push(b'=');\n-                }\n-            }\n-            2 => {\n-                let n = (self[i] as u32) << 16 |\n-                    (self[i + 1u] as u32) << 8;\n-                v.push(bytes[((n >> 18) & 63) as uint]);\n-                v.push(bytes[((n >> 12) & 63) as uint]);\n-                v.push(bytes[((n >> 6 ) & 63) as uint]);\n-                if config.pad {\n-                    v.push(b'=');\n-                }\n-            }\n-            _ => panic!(\"Algebra is broken, please alert the math police\")\n-        }\n-\n-        unsafe { String::from_utf8_unchecked(v) }\n-    }\n-}\n-\n-/// A trait for converting from base64 encoded values.\n-pub trait FromBase64 {\n-    /// Converts the value of `self`, interpreted as base64 encoded data, into\n-    /// an owned vector of bytes, returning the vector.\n-    fn from_base64(&self) -> Result<Vec<u8>, FromBase64Error>;\n-}\n-\n-/// Errors that can occur when decoding a base64 encoded string\n-#[derive(Copy, Show)]\n-pub enum FromBase64Error {\n-    /// The input contained a character not part of the base64 format\n-    InvalidBase64Byte(u8, uint),\n-    /// The input had an invalid length\n-    InvalidBase64Length,\n-}\n-\n-impl fmt::Display for FromBase64Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            InvalidBase64Byte(ch, idx) =>\n-                write!(f, \"Invalid character '{}' at position {}\", ch, idx),\n-            InvalidBase64Length => write!(f, \"Invalid length\"),\n-        }\n-    }\n-}\n-\n-impl error::Error for FromBase64Error {\n-    fn description(&self) -> &str {\n-        match *self {\n-            InvalidBase64Byte(_, _) => \"invalid character\",\n-            InvalidBase64Length => \"invalid length\",\n-        }\n-    }\n-}\n-\n-impl FromBase64 for str {\n-    /// Convert any base64 encoded string (literal, `@`, `&`, or `~`)\n-    /// to the byte values it encodes.\n-    ///\n-    /// You can use the `String::from_utf8` function to turn a `Vec<u8>` into a\n-    /// string with characters corresponding to those values.\n-    ///\n-    /// # Example\n-    ///\n-    /// This converts a string literal to base64 and back.\n-    ///\n-    /// ```rust\n-    /// extern crate serialize;\n-    /// use serialize::base64::{ToBase64, FromBase64, STANDARD};\n-    ///\n-    /// fn main () {\n-    ///     let hello_str = b\"Hello, World\".to_base64(STANDARD);\n-    ///     println!(\"base64 output: {}\", hello_str);\n-    ///     let res = hello_str.as_slice().from_base64();\n-    ///     if res.is_ok() {\n-    ///       let opt_bytes = String::from_utf8(res.unwrap());\n-    ///       if opt_bytes.is_ok() {\n-    ///         println!(\"decoded from base64: {}\", opt_bytes.unwrap());\n-    ///       }\n-    ///     }\n-    /// }\n-    /// ```\n-    #[inline]\n-    fn from_base64(&self) -> Result<Vec<u8>, FromBase64Error> {\n-        self.as_bytes().from_base64()\n-    }\n-}\n-\n-impl FromBase64 for [u8] {\n-    fn from_base64(&self) -> Result<Vec<u8>, FromBase64Error> {\n-        let mut r = Vec::with_capacity(self.len());\n-        let mut buf: u32 = 0;\n-        let mut modulus = 0i;\n-\n-        let mut it = self.iter().enumerate();\n-        for (idx, &byte) in it {\n-            let val = byte as u32;\n-\n-            match byte {\n-                b'A'...b'Z' => buf |= val - 0x41,\n-                b'a'...b'z' => buf |= val - 0x47,\n-                b'0'...b'9' => buf |= val + 0x04,\n-                b'+' | b'-' => buf |= 0x3E,\n-                b'/' | b'_' => buf |= 0x3F,\n-                b'\\r' | b'\\n' => continue,\n-                b'=' => break,\n-                _ => return Err(InvalidBase64Byte(self[idx], idx)),\n-            }\n-\n-            buf <<= 6;\n-            modulus += 1;\n-            if modulus == 4 {\n-                modulus = 0;\n-                r.push((buf >> 22) as u8);\n-                r.push((buf >> 14) as u8);\n-                r.push((buf >> 6 ) as u8);\n-            }\n-        }\n-\n-        for (idx, &byte) in it {\n-            match byte {\n-                b'=' | b'\\r' | b'\\n' => continue,\n-                _ => return Err(InvalidBase64Byte(self[idx], idx)),\n-            }\n-        }\n-\n-        match modulus {\n-            2 => {\n-                r.push((buf >> 10) as u8);\n-            }\n-            3 => {\n-                r.push((buf >> 16) as u8);\n-                r.push((buf >> 8 ) as u8);\n-            }\n-            0 => (),\n-            _ => return Err(InvalidBase64Length),\n-        }\n-\n-        Ok(r)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    extern crate test;\n-    use self::test::Bencher;\n-    use base64::{Config, Newline, FromBase64, ToBase64, STANDARD, URL_SAFE};\n-\n-    #[test]\n-    fn test_to_base64_basic() {\n-        assert_eq!(\"\".as_bytes().to_base64(STANDARD), \"\");\n-        assert_eq!(\"f\".as_bytes().to_base64(STANDARD), \"Zg==\");\n-        assert_eq!(\"fo\".as_bytes().to_base64(STANDARD), \"Zm8=\");\n-        assert_eq!(\"foo\".as_bytes().to_base64(STANDARD), \"Zm9v\");\n-        assert_eq!(\"foob\".as_bytes().to_base64(STANDARD), \"Zm9vYg==\");\n-        assert_eq!(\"fooba\".as_bytes().to_base64(STANDARD), \"Zm9vYmE=\");\n-        assert_eq!(\"foobar\".as_bytes().to_base64(STANDARD), \"Zm9vYmFy\");\n-    }\n-\n-    #[test]\n-    fn test_to_base64_crlf_line_break() {\n-        assert!(![0u8; 1000].to_base64(Config {line_length: None, ..STANDARD})\n-                              .contains(\"\\r\\n\"));\n-        assert_eq!(b\"foobar\".to_base64(Config {line_length: Some(4),\n-                                               ..STANDARD}),\n-                   \"Zm9v\\r\\nYmFy\");\n-    }\n-\n-    #[test]\n-    fn test_to_base64_lf_line_break() {\n-        assert!(![0u8; 1000].to_base64(Config {line_length: None,\n-                                                 newline: Newline::LF,\n-                                                 ..STANDARD})\n-                              .as_slice()\n-                              .contains(\"\\n\"));\n-        assert_eq!(b\"foobar\".to_base64(Config {line_length: Some(4),\n-                                               newline: Newline::LF,\n-                                               ..STANDARD}),\n-                   \"Zm9v\\nYmFy\");\n-    }\n-\n-    #[test]\n-    fn test_to_base64_padding() {\n-        assert_eq!(\"f\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zg\");\n-        assert_eq!(\"fo\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zm8\");\n-    }\n-\n-    #[test]\n-    fn test_to_base64_url_safe() {\n-        assert_eq!([251, 255].to_base64(URL_SAFE), \"-_8\");\n-        assert_eq!([251, 255].to_base64(STANDARD), \"+/8=\");\n-    }\n-\n-    #[test]\n-    fn test_from_base64_basic() {\n-        assert_eq!(\"\".from_base64().unwrap(), b\"\");\n-        assert_eq!(\"Zg==\".from_base64().unwrap(), b\"f\");\n-        assert_eq!(\"Zm8=\".from_base64().unwrap(), b\"fo\");\n-        assert_eq!(\"Zm9v\".from_base64().unwrap(), b\"foo\");\n-        assert_eq!(\"Zm9vYg==\".from_base64().unwrap(), b\"foob\");\n-        assert_eq!(\"Zm9vYmE=\".from_base64().unwrap(), b\"fooba\");\n-        assert_eq!(\"Zm9vYmFy\".from_base64().unwrap(), b\"foobar\");\n-    }\n-\n-    #[test]\n-    fn test_from_base64_bytes() {\n-        assert_eq!(b\"Zm9vYmFy\".from_base64().unwrap(), b\"foobar\");\n-    }\n-\n-    #[test]\n-    fn test_from_base64_newlines() {\n-        assert_eq!(\"Zm9v\\r\\nYmFy\".from_base64().unwrap(),\n-                   b\"foobar\");\n-        assert_eq!(\"Zm9vYg==\\r\\n\".from_base64().unwrap(),\n-                   b\"foob\");\n-        assert_eq!(\"Zm9v\\nYmFy\".from_base64().unwrap(),\n-                   b\"foobar\");\n-        assert_eq!(\"Zm9vYg==\\n\".from_base64().unwrap(),\n-                   b\"foob\");\n-    }\n-\n-    #[test]\n-    fn test_from_base64_urlsafe() {\n-        assert_eq!(\"-_8\".from_base64().unwrap(), \"+/8=\".from_base64().unwrap());\n-    }\n-\n-    #[test]\n-    fn test_from_base64_invalid_char() {\n-        assert!(\"Zm$=\".from_base64().is_err());\n-        assert!(\"Zg==$\".from_base64().is_err());\n-    }\n-\n-    #[test]\n-    fn test_from_base64_invalid_padding() {\n-        assert!(\"Z===\".from_base64().is_err());\n-    }\n-\n-    #[test]\n-    fn test_base64_random() {\n-        use std::rand::{thread_rng, random, Rng};\n-\n-        for _ in range(0u, 1000) {\n-            let times = thread_rng().gen_range(1u, 100);\n-            let v = thread_rng().gen_iter::<u8>().take(times).collect::<Vec<_>>();\n-            assert_eq!(v.to_base64(STANDARD)\n-                        .from_base64()\n-                        .unwrap(),\n-                       v);\n-        }\n-    }\n-\n-    #[bench]\n-    pub fn bench_to_base64(b: &mut Bencher) {\n-        let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n-                 \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n-        b.iter(|| {\n-            s.as_bytes().to_base64(STANDARD);\n-        });\n-        b.bytes = s.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn bench_from_base64(b: &mut Bencher) {\n-        let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n-                 \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n-        let sb = s.as_bytes().to_base64(STANDARD);\n-        b.iter(|| {\n-            sb.from_base64().unwrap();\n-        });\n-        b.bytes = sb.len() as u64;\n-    }\n-\n-}"}, {"sha": "45dc297330be684708453679e632347b2cb2a1df", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/494896f2dd4ff541c371a8952b8f38cb02409835/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494896f2dd4ff541c371a8952b8f38cb02409835/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=494896f2dd4ff541c371a8952b8f38cb02409835", "patch": "@@ -43,7 +43,6 @@ pub use self::serialize::{Decoder, Encoder, Decodable, Encodable,\n mod serialize;\n mod collection_impls;\n \n-pub mod base64;\n pub mod hex;\n pub mod json;\n "}]}