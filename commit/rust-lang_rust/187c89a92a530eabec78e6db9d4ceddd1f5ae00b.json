{"sha": "187c89a92a530eabec78e6db9d4ceddd1f5ae00b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4N2M4OWE5MmE1MzBlYWJlYzc4ZTZkYjlkNGNlZGRkMWY1YWUwMGI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-12-04T18:51:18Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-12-18T01:14:46Z"}, "message": "Address the comments", "tree": {"sha": "5b3a3b74294fce51fe18889dcbeb783f37a153fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b3a3b74294fce51fe18889dcbeb783f37a153fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/187c89a92a530eabec78e6db9d4ceddd1f5ae00b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/187c89a92a530eabec78e6db9d4ceddd1f5ae00b", "html_url": "https://github.com/rust-lang/rust/commit/187c89a92a530eabec78e6db9d4ceddd1f5ae00b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/187c89a92a530eabec78e6db9d4ceddd1f5ae00b/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcbd553f0fb12f226df9ba5648a319bc1e8a2af4", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcbd553f0fb12f226df9ba5648a319bc1e8a2af4", "html_url": "https://github.com/rust-lang/rust/commit/fcbd553f0fb12f226df9ba5648a319bc1e8a2af4"}], "stats": {"total": 86, "additions": 47, "deletions": 39}, "files": [{"sha": "3fbe3bc200534ac4a93173652b28a653af81221f", "filename": "src/librustc_privacy/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/187c89a92a530eabec78e6db9d4ceddd1f5ae00b/src%2Flibrustc_privacy%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/187c89a92a530eabec78e6db9d4ceddd1f5ae00b/src%2Flibrustc_privacy%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Fdiagnostics.rs?ref=187c89a92a530eabec78e6db9d4ceddd1f5ae00b", "patch": "@@ -43,7 +43,7 @@ pub fn foo<T: Foo> (t: T) {} // ok!\n \"##,\n \n E0446: r##\"\n-A private type was used in an public type signature. Erroneous code example:\n+A private type was used in a public type signature. Erroneous code example:\n \n ```\n mod Foo {"}, {"sha": "81abf3515446b5396863ee541298b8a9fdafc64e", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 43, "deletions": 37, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/187c89a92a530eabec78e6db9d4ceddd1f5ae00b/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/187c89a92a530eabec78e6db9d4ceddd1f5ae00b/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=187c89a92a530eabec78e6db9d4ceddd1f5ae00b", "patch": "@@ -1467,11 +1467,14 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n         // public, even if the type alias itself is private. So, something\n         // like `type A = u8; pub fn f() -> A {...}` doesn't cause an error.\n         if let hir::ItemTy(ref ty, ref generics) = item.node {\n-            let mut check = SearchInterfaceForPrivateItemsVisitor {\n-                tcx: self.tcx, is_quiet: self.is_quiet,\n-                is_public: true, old_error_set: self.old_error_set,\n-            };\n+            let mut check = SearchInterfaceForPrivateItemsVisitor { is_public: true, ..*self };\n             check.visit_ty(ty);\n+            // If a private type alias with default type parameters is used in public\n+            // interface we must ensure, that the defaults are public if they are actually used.\n+            // ```\n+            // type Alias<T = Private> = T;\n+            // pub fn f() -> Alias {...} // `Private` is implicitly used here, so it must be public\n+            // ```\n             let provided_params = path.segments.last().unwrap().parameters.types().len();\n             for ty_param in &generics.ty_params[provided_params..] {\n                 if let Some(ref default_ty) = ty_param.default {\n@@ -1500,29 +1503,32 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n                 def::DefAssociatedTy(..) if self.is_quiet => {\n                     // Conservatively approximate the whole type alias as public without\n                     // recursing into its components when determining impl publicity.\n+                    // For example, `impl <Type as Trait>::Alias {...}` may be a public impl\n+                    // even if both `Type` and `Trait` are private.\n+                    // Ideally, associated types should be substituted in the same way as\n+                    // free type aliases, but this isn't done yet.\n                     return\n                 }\n                 def::DefStruct(def_id) | def::DefTy(def_id, _) |\n                 def::DefTrait(def_id) | def::DefAssociatedTy(def_id, _) => {\n-                    // Non-local means public, local needs to be checked\n+                    // Non-local means public (private items can't leave their crate, modulo bugs)\n                     if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n-                        if let Some(ast_map::NodeItem(ref item)) = self.tcx.map.find(node_id) {\n-                            if item.vis != hir::Public && !self.is_public_type_alias(item, path) {\n-                                if !self.is_quiet {\n-                                    if self.old_error_set.contains(&ty.id) {\n-                                        span_err!(self.tcx.sess, ty.span, E0446,\n-                                                  \"private type in public interface\");\n-                                    } else {\n-                                        self.tcx.sess.add_lint (\n-                                            lint::builtin::PRIVATE_IN_PUBLIC,\n-                                            node_id,\n-                                            ty.span,\n-                                            \"private type in public interface\".to_string()\n-                                        );\n-                                    }\n+                        let item = self.tcx.map.expect_item(node_id);\n+                        if item.vis != hir::Public && !self.is_public_type_alias(item, path) {\n+                            if !self.is_quiet {\n+                                if self.old_error_set.contains(&ty.id) {\n+                                    span_err!(self.tcx.sess, ty.span, E0446,\n+                                              \"private type in public interface\");\n+                                } else {\n+                                    self.tcx.sess.add_lint (\n+                                        lint::builtin::PRIVATE_IN_PUBLIC,\n+                                        node_id,\n+                                        ty.span,\n+                                        \"private type in public interface (error E0446)\".to_string()\n+                                    );\n                                 }\n-                                self.is_public = false;\n                             }\n+                            self.is_public = false;\n                         }\n                     }\n                 }\n@@ -1538,24 +1544,24 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n             // We are in quiet mode and a private type is already found, no need to proceed\n             return\n         }\n-        // Non-local means public, local needs to be checked\n+        // Non-local means public (private items can't leave their crate, modulo bugs)\n         let def_id = self.tcx.trait_ref_to_def_id(trait_ref);\n         if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n-            if let Some(ast_map::NodeItem(ref item)) = self.tcx.map.find(node_id) {\n-                if item.vis != hir::Public {\n-                    if !self.is_quiet {\n-                        if self.old_error_set.contains(&trait_ref.ref_id) {\n-                            span_err!(self.tcx.sess, trait_ref.path.span, E0445,\n-                                      \"private trait in public interface\");\n-                        } else {\n-                            self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                                   node_id,\n-                                                   trait_ref.path.span,\n-                                                   \"private trait in public interface\".to_string());\n-                        }\n+            let item = self.tcx.map.expect_item(node_id);\n+            if item.vis != hir::Public {\n+                if !self.is_quiet {\n+                    if self.old_error_set.contains(&trait_ref.ref_id) {\n+                        span_err!(self.tcx.sess, trait_ref.path.span, E0445,\n+                                  \"private trait in public interface\");\n+                    } else {\n+                        self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                               node_id,\n+                                               trait_ref.path.span,\n+                                               \"private trait in public interface (error E0445)\"\n+                                                    .to_string());\n                     }\n-                    self.is_public = false;\n                 }\n+                self.is_public = false;\n             }\n         }\n \n@@ -1585,8 +1591,8 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n         check.is_public\n     }\n \n-    // A trait is considered public if it doesn't contain any private components\n-    fn is_public_trait(&self, trait_ref: &hir::TraitRef) -> bool {\n+    // A trait reference is considered public if it doesn't contain any private components\n+    fn is_public_trait_ref(&self, trait_ref: &hir::TraitRef) -> bool {\n         let mut check = SearchInterfaceForPrivateItemsVisitor {\n             tcx: self.tcx, is_quiet: true, is_public: true, old_error_set: self.old_error_set\n         };\n@@ -1650,7 +1656,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity\n             hir::ItemImpl(_, _, ref generics, Some(ref trait_ref), ref ty, ref impl_items) => {\n-                if self.is_public_ty(ty) && self.is_public_trait(trait_ref) {\n+                if self.is_public_ty(ty) && self.is_public_trait_ref(trait_ref) {\n                     check.visit_generics(generics);\n                     for impl_item in impl_items {\n                         check.visit_impl_item(impl_item);"}, {"sha": "1d98aa36e8fc82803e30b261af98bd3e65cb2cfc", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/187c89a92a530eabec78e6db9d4ceddd1f5ae00b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/187c89a92a530eabec78e6db9d4ceddd1f5ae00b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=187c89a92a530eabec78e6db9d4ceddd1f5ae00b", "patch": "@@ -905,9 +905,11 @@ impl fmt::Debug for Module {\n bitflags! {\n     #[derive(Debug)]\n     flags DefModifiers: u8 {\n+        // Enum variants are always considered `PUBLIC`, this is needed for `use Enum::Variant`\n+        // or `use Enum::*` to work on private enums.\n         const PUBLIC     = 1 << 0,\n         const IMPORTABLE = 1 << 1,\n-        // All variants are considered `PUBLIC`, but some of them live in private enums.\n+        // Variants are considered `PUBLIC`, but some of them live in private enums.\n         // We need to track them to prohibit reexports like `pub use PrivEnum::Variant`.\n         const PRIVATE_VARIANT = 1 << 2,\n     }"}]}