{"sha": "d13ded6cbc8b835807f08606db90bedf18643154", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxM2RlZDZjYmM4YjgzNTgwN2YwODYwNmRiOTBiZWRmMTg2NDMxNTQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-30T08:34:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-30T08:34:08Z"}, "message": "Merge #5101\n\n5101: Add expect -- a light-weight alternative to insta r=matklad a=matklad\n\nThis PR implements a small snapshot-testing library. Snapshot updating is done by setting an env var, or by using editor feature (which runs  a test with env-var set). \r\n\r\nHere's workflow for updating a failing test:\r\n\r\n![expect](https://user-images.githubusercontent.com/1711539/85926956-28afa080-b8a3-11ea-9260-c6d0d8914d0b.gif)\r\n\r\nHere's workflow for adding a new test:\r\n\r\n![expect-fresh](https://user-images.githubusercontent.com/1711539/85926961-306f4500-b8a3-11ea-9369-f2373e327a3f.gif)\r\n\r\nNote that colorized diffs are not implemented in this PR, but should be easy to add (we already use them in test_utils). \r\n\r\nMain differences from insta (which is essential for rust-analyzer development, thanks @mitsuhiko!):\r\n* self-updating tests, no need for a separate tool\r\n* fewer features (only inline snapshots, no redactions)\r\n* fewer deps (no yaml, no persistence)\r\n* tighter integration with editor\r\n* first-class snapshot object, which can be used to write test functions (as opposed to testing macros)\r\n* trivial to tweak for rust-analyzer needs, by virtue of being a workspace member. \r\n\r\nI think eventually we should converge to a single snapshot testing library, but I am not sure that `expect` is exactly right, so I suggest rolling with both insta and expect for some time (if folks agree that expect might be better in the first place!). \r\n\r\n# Editor Integration Implementation \r\n\r\nThe thing I am most excited about is the ability to update a specific snapshot from the editor. I want this to be available to other snapshot-testing libraries (cc @mitsuhiko, @aaronabramov), so I want to document how this works. \r\n\r\nThe ideal UI here would be a code action (:bulb:). Unfortunately, it seems like it is impossible to implement without some kind of persistence (if you save test failures into some kind of a database, like insta does, than you can read the database from the editor plugin). Note that it is possible to highlight error by outputing error message in rustc's format. Unfortunately, one can't use the same trick to implement a quick fix. \r\n\r\nFor this reason, expect makes use of another rust-analyzer feature -- ability to run a single test at the cursor position. This does need some expect-specific code in rust-analyzer unfortunately. Specifically, if rust-analyzer notices that the cursor is on `expect!` macro, it adds a special flag to runnable's JSON. However, given #5017 it is possible to approximate this well-enough without rust-analyzer integration. Specifically, an extension can register a special runner which checks (using regexes) if rust-anlyzer runnable covers text with specific macro invocation and do special magic in that case. \r\n\r\ncloses #3835 \r\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "d77c573d3ed0cadc5d318b2cfe57b8e8d4426fa7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d77c573d3ed0cadc5d318b2cfe57b8e8d4426fa7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d13ded6cbc8b835807f08606db90bedf18643154", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe+vkACRBK7hj4Ov3rIwAAdHIIAGBE4Y1541P+RTd3DGHnZFEN\nSuEMnfrVmJKIsPiUZqCbbuwJEIOVccvAVYJ31C72ZWsbE77ihx9xZDXywpGWnWyI\nCVRpPnu6UqxoVK5Y1pjEHTUs00VsFna+MKKvO1v2y46qkHbV1DKOLvB3L37B43Ch\n6A2oQw7dUJ0SqyOtq63mKo3in/vDE2TEV30uK/d1uenLsRVUwjhkP0W9HXfT0Ywe\nANpoO2JsROoNlL6q9j5NbPX3XduBMcPOyXBM4hzCmM6EmzYPNwUqqACH+19lEA6U\njh0GcrHDbNVLhRTv9QJ8mz5qbmMqEFdtiFpi9P/7oiDW2AzdWtOyK/zwR447eU4=\n=MUI6\n-----END PGP SIGNATURE-----\n", "payload": "tree d77c573d3ed0cadc5d318b2cfe57b8e8d4426fa7\nparent 2bd717139918e15e537dcd833bb003e85d24b3d1\nparent a4f934efa8e37d3bc822575109d103998ecd8fe1\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593506048 +0000\ncommitter GitHub <noreply@github.com> 1593506048 +0000\n\nMerge #5101\n\n5101: Add expect -- a light-weight alternative to insta r=matklad a=matklad\n\nThis PR implements a small snapshot-testing library. Snapshot updating is done by setting an env var, or by using editor feature (which runs  a test with env-var set). \r\n\r\nHere's workflow for updating a failing test:\r\n\r\n![expect](https://user-images.githubusercontent.com/1711539/85926956-28afa080-b8a3-11ea-9260-c6d0d8914d0b.gif)\r\n\r\nHere's workflow for adding a new test:\r\n\r\n![expect-fresh](https://user-images.githubusercontent.com/1711539/85926961-306f4500-b8a3-11ea-9369-f2373e327a3f.gif)\r\n\r\nNote that colorized diffs are not implemented in this PR, but should be easy to add (we already use them in test_utils). \r\n\r\nMain differences from insta (which is essential for rust-analyzer development, thanks @mitsuhiko!):\r\n* self-updating tests, no need for a separate tool\r\n* fewer features (only inline snapshots, no redactions)\r\n* fewer deps (no yaml, no persistence)\r\n* tighter integration with editor\r\n* first-class snapshot object, which can be used to write test functions (as opposed to testing macros)\r\n* trivial to tweak for rust-analyzer needs, by virtue of being a workspace member. \r\n\r\nI think eventually we should converge to a single snapshot testing library, but I am not sure that `expect` is exactly right, so I suggest rolling with both insta and expect for some time (if folks agree that expect might be better in the first place!). \r\n\r\n# Editor Integration Implementation \r\n\r\nThe thing I am most excited about is the ability to update a specific snapshot from the editor. I want this to be available to other snapshot-testing libraries (cc @mitsuhiko, @aaronabramov), so I want to document how this works. \r\n\r\nThe ideal UI here would be a code action (:bulb:). Unfortunately, it seems like it is impossible to implement without some kind of persistence (if you save test failures into some kind of a database, like insta does, than you can read the database from the editor plugin). Note that it is possible to highlight error by outputing error message in rustc's format. Unfortunately, one can't use the same trick to implement a quick fix. \r\n\r\nFor this reason, expect makes use of another rust-analyzer feature -- ability to run a single test at the cursor position. This does need some expect-specific code in rust-analyzer unfortunately. Specifically, if rust-analyzer notices that the cursor is on `expect!` macro, it adds a special flag to runnable's JSON. However, given #5017 it is possible to approximate this well-enough without rust-analyzer integration. Specifically, an extension can register a special runner which checks (using regexes) if rust-anlyzer runnable covers text with specific macro invocation and do special magic in that case. \r\n\r\ncloses #3835 \r\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d13ded6cbc8b835807f08606db90bedf18643154", "html_url": "https://github.com/rust-lang/rust/commit/d13ded6cbc8b835807f08606db90bedf18643154", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d13ded6cbc8b835807f08606db90bedf18643154/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bd717139918e15e537dcd833bb003e85d24b3d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bd717139918e15e537dcd833bb003e85d24b3d1", "html_url": "https://github.com/rust-lang/rust/commit/2bd717139918e15e537dcd833bb003e85d24b3d1"}, {"sha": "a4f934efa8e37d3bc822575109d103998ecd8fe1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4f934efa8e37d3bc822575109d103998ecd8fe1", "html_url": "https://github.com/rust-lang/rust/commit/a4f934efa8e37d3bc822575109d103998ecd8fe1"}], "stats": {"total": 390, "additions": 377, "deletions": 13}, "files": [{"sha": "c1080364594aad4f63fe30d230381528fe9bde06", "filename": "Cargo.lock", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d13ded6cbc8b835807f08606db90bedf18643154/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d13ded6cbc8b835807f08606db90bedf18643154/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d13ded6cbc8b835807f08606db90bedf18643154", "patch": "@@ -351,6 +351,15 @@ dependencies = [\n  \"log\",\n ]\n \n+[[package]]\n+name = \"expect\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"difference\",\n+ \"once_cell\",\n+ \"stdx\",\n+]\n+\n [[package]]\n name = \"filetime\"\n version = \"0.2.10\"\n@@ -1134,6 +1143,7 @@ name = \"ra_ide\"\n version = \"0.1.0\"\n dependencies = [\n  \"either\",\n+ \"expect\",\n  \"indexmap\",\n  \"insta\",\n  \"itertools\","}, {"sha": "caee4310674a7334ff92c0699c76452bb7dad2e4", "filename": "crates/expect/Cargo.toml", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d13ded6cbc8b835807f08606db90bedf18643154/crates%2Fexpect%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d13ded6cbc8b835807f08606db90bedf18643154/crates%2Fexpect%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fexpect%2FCargo.toml?ref=d13ded6cbc8b835807f08606db90bedf18643154", "patch": "@@ -0,0 +1,10 @@\n+[package]\n+name = \"expect\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n+\n+[dependencies]\n+once_cell = \"1\"\n+difference = \"2\"\n+stdx = { path = \"../stdx\" }"}, {"sha": "dd7b96aab2678fd6e5fa61c0ed8ca2ee62db09f9", "filename": "crates/expect/src/lib.rs", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/d13ded6cbc8b835807f08606db90bedf18643154/crates%2Fexpect%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d13ded6cbc8b835807f08606db90bedf18643154/crates%2Fexpect%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fexpect%2Fsrc%2Flib.rs?ref=d13ded6cbc8b835807f08606db90bedf18643154", "patch": "@@ -0,0 +1,293 @@\n+//! Snapshot testing library, see\n+//! https://github.com/rust-analyzer/rust-analyzer/pull/5101\n+use std::{\n+    collections::HashMap,\n+    env, fmt, fs,\n+    ops::Range,\n+    panic,\n+    path::{Path, PathBuf},\n+    sync::Mutex,\n+};\n+\n+use difference::Changeset;\n+use once_cell::sync::Lazy;\n+use stdx::{lines_with_ends, trim_indent};\n+\n+const HELP: &str = \"\n+You can update all `expect![[]]` tests by:\n+\n+    env UPDATE_EXPECT=1 cargo test\n+\n+To update a single test, place the cursor on `expect` token and use `run` feature of rust-analyzer.\n+\";\n+\n+fn update_expect() -> bool {\n+    env::var(\"UPDATE_EXPECT\").is_ok()\n+}\n+\n+/// expect![[\"\"]]\n+#[macro_export]\n+macro_rules! expect {\n+    [[$lit:literal]] => {$crate::Expect {\n+        file: file!(),\n+        line: line!(),\n+        column: column!(),\n+        data: $lit,\n+    }};\n+    [[]] => { $crate::expect![[\"\"]] };\n+}\n+\n+#[derive(Debug)]\n+pub struct Expect {\n+    pub file: &'static str,\n+    pub line: u32,\n+    pub column: u32,\n+    pub data: &'static str,\n+}\n+\n+impl Expect {\n+    pub fn assert_eq(&self, actual: &str) {\n+        let trimmed = self.trimmed();\n+        if &trimmed == actual {\n+            return;\n+        }\n+        Runtime::fail(self, &trimmed, actual);\n+    }\n+    pub fn assert_debug_eq(&self, actual: &impl fmt::Debug) {\n+        let actual = format!(\"{:#?}\\n\", actual);\n+        self.assert_eq(&actual)\n+    }\n+\n+    fn trimmed(&self) -> String {\n+        if !self.data.contains('\\n') {\n+            return self.data.to_string();\n+        }\n+        trim_indent(self.data)\n+    }\n+\n+    fn locate(&self, file: &str) -> Location {\n+        let mut target_line = None;\n+        let mut line_start = 0;\n+        for (i, line) in lines_with_ends(file).enumerate() {\n+            if i == self.line as usize - 1 {\n+                let pat = \"expect![[\";\n+                let offset = line.find(pat).unwrap();\n+                let literal_start = line_start + offset + pat.len();\n+                let indent = line.chars().take_while(|&it| it == ' ').count();\n+                target_line = Some((literal_start, indent));\n+                break;\n+            }\n+            line_start += line.len();\n+        }\n+        let (literal_start, line_indent) = target_line.unwrap();\n+        let literal_length =\n+            file[literal_start..].find(\"]]\").expect(\"Couldn't find matching `]]` for `expect![[`.\");\n+        let literal_range = literal_start..literal_start + literal_length;\n+        Location { line_indent, literal_range }\n+    }\n+}\n+\n+#[derive(Default)]\n+struct Runtime {\n+    help_printed: bool,\n+    per_file: HashMap<&'static str, FileRuntime>,\n+}\n+static RT: Lazy<Mutex<Runtime>> = Lazy::new(Default::default);\n+\n+impl Runtime {\n+    fn fail(expect: &Expect, expected: &str, actual: &str) {\n+        let mut rt = RT.lock().unwrap_or_else(|poisoned| poisoned.into_inner());\n+        let mut updated = \"\";\n+        if update_expect() {\n+            updated = \" (updated)\";\n+            rt.per_file\n+                .entry(expect.file)\n+                .or_insert_with(|| FileRuntime::new(expect))\n+                .update(expect, actual);\n+        }\n+        let print_help = !rt.help_printed && !update_expect();\n+        rt.help_printed = true;\n+\n+        let help = if print_help { HELP } else { \"\" };\n+\n+        let diff = Changeset::new(actual, expected, \"\\n\");\n+\n+        println!(\n+            \"\\n\n+\\x1b[1m\\x1b[91merror\\x1b[97m: expect test failed\\x1b[0m{}\n+   \\x1b[1m\\x1b[34m-->\\x1b[0m {}:{}:{}\n+{}\n+\\x1b[1mExpect\\x1b[0m:\n+----\n+{}\n+----\n+\n+\\x1b[1mActual\\x1b[0m:\n+----\n+{}\n+----\n+\n+\\x1b[1mDiff\\x1b[0m:\n+----\n+{}\n+----\n+\",\n+            updated, expect.file, expect.line, expect.column, help, expected, actual, diff\n+        );\n+        // Use resume_unwind instead of panic!() to prevent a backtrace, which is unnecessary noise.\n+        panic::resume_unwind(Box::new(()));\n+    }\n+}\n+\n+struct FileRuntime {\n+    path: PathBuf,\n+    original_text: String,\n+    patchwork: Patchwork,\n+}\n+\n+impl FileRuntime {\n+    fn new(expect: &Expect) -> FileRuntime {\n+        let path = workspace_root().join(expect.file);\n+        let original_text = fs::read_to_string(&path).unwrap();\n+        let patchwork = Patchwork::new(original_text.clone());\n+        FileRuntime { path, original_text, patchwork }\n+    }\n+    fn update(&mut self, expect: &Expect, actual: &str) {\n+        let loc = expect.locate(&self.original_text);\n+        let patch = format_patch(loc.line_indent.clone(), actual);\n+        self.patchwork.patch(loc.literal_range, &patch);\n+        fs::write(&self.path, &self.patchwork.text).unwrap()\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct Location {\n+    line_indent: usize,\n+    literal_range: Range<usize>,\n+}\n+\n+#[derive(Debug)]\n+struct Patchwork {\n+    text: String,\n+    indels: Vec<(Range<usize>, usize)>,\n+}\n+\n+impl Patchwork {\n+    fn new(text: String) -> Patchwork {\n+        Patchwork { text, indels: Vec::new() }\n+    }\n+    fn patch(&mut self, mut range: Range<usize>, patch: &str) {\n+        self.indels.push((range.clone(), patch.len()));\n+        self.indels.sort_by_key(|(delete, _insert)| delete.start);\n+\n+        let (delete, insert) = self\n+            .indels\n+            .iter()\n+            .take_while(|(delete, _)| delete.start < range.start)\n+            .map(|(delete, insert)| (delete.end - delete.start, insert))\n+            .fold((0usize, 0usize), |(x1, y1), (x2, y2)| (x1 + x2, y1 + y2));\n+\n+        for pos in &mut [&mut range.start, &mut range.end] {\n+            **pos -= delete;\n+            **pos += insert;\n+        }\n+\n+        self.text.replace_range(range, &patch);\n+    }\n+}\n+\n+fn format_patch(line_indent: usize, patch: &str) -> String {\n+    let mut max_hashes = 0;\n+    let mut cur_hashes = 0;\n+    for byte in patch.bytes() {\n+        if byte != b'#' {\n+            cur_hashes = 0;\n+            continue;\n+        }\n+        cur_hashes += 1;\n+        max_hashes = max_hashes.max(cur_hashes);\n+    }\n+    let hashes = &\"#\".repeat(max_hashes + 1);\n+    let indent = &\" \".repeat(line_indent);\n+    let is_multiline = patch.contains('\\n');\n+\n+    let mut buf = String::new();\n+    buf.push('r');\n+    buf.push_str(hashes);\n+    buf.push('\"');\n+    if is_multiline {\n+        buf.push('\\n');\n+    }\n+    let mut final_newline = false;\n+    for line in lines_with_ends(patch) {\n+        if is_multiline {\n+            buf.push_str(indent);\n+            buf.push_str(\"    \");\n+        }\n+        buf.push_str(line);\n+        final_newline = line.ends_with('\\n');\n+    }\n+    if final_newline {\n+        buf.push_str(indent);\n+    }\n+    buf.push('\"');\n+    buf.push_str(hashes);\n+    buf\n+}\n+\n+fn workspace_root() -> PathBuf {\n+    Path::new(\n+        &env::var(\"CARGO_MANIFEST_DIR\").unwrap_or_else(|_| env!(\"CARGO_MANIFEST_DIR\").to_owned()),\n+    )\n+    .ancestors()\n+    .nth(2)\n+    .unwrap()\n+    .to_path_buf()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_format_patch() {\n+        let patch = format_patch(0, \"hello\\nworld\\n\");\n+        expect![[r##\"\n+            r#\"\n+                hello\n+                world\n+            \"#\"##]]\n+        .assert_eq(&patch);\n+\n+        let patch = format_patch(4, \"single line\");\n+        expect![[r##\"r#\"single line\"#\"##]].assert_eq(&patch);\n+    }\n+\n+    #[test]\n+    fn test_patchwork() {\n+        let mut patchwork = Patchwork::new(\"one two three\".to_string());\n+        patchwork.patch(4..7, \"zwei\");\n+        patchwork.patch(0..3, \"\u043e\u0434\u0438\u043d\");\n+        patchwork.patch(8..13, \"3\");\n+        expect![[r#\"\n+            Patchwork {\n+                text: \"\u043e\u0434\u0438\u043d zwei 3\",\n+                indels: [\n+                    (\n+                        0..3,\n+                        8,\n+                    ),\n+                    (\n+                        4..7,\n+                        4,\n+                    ),\n+                    (\n+                        8..13,\n+                        1,\n+                    ),\n+                ],\n+            }\n+        \"#]]\n+        .assert_debug_eq(&patchwork);\n+    }\n+}"}, {"sha": "8e889230939840de52b474723c48756a04d0db95", "filename": "crates/ra_ide/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d13ded6cbc8b835807f08606db90bedf18643154/crates%2Fra_ide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d13ded6cbc8b835807f08606db90bedf18643154/crates%2Fra_ide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2FCargo.toml?ref=d13ded6cbc8b835807f08606db90bedf18643154", "patch": "@@ -28,6 +28,7 @@ ra_cfg = { path = \"../ra_cfg\" }\n ra_fmt = { path = \"../ra_fmt\" }\n ra_prof = { path = \"../ra_prof\" }\n test_utils = { path = \"../test_utils\" }\n+expect = { path = \"../expect\" }\n ra_assists = { path = \"../ra_assists\" }\n ra_ssr = { path = \"../ra_ssr\" }\n "}, {"sha": "969d5e0ffc7f76870967adeeee444f148e94e9c9", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d13ded6cbc8b835807f08606db90bedf18643154/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d13ded6cbc8b835807f08606db90bedf18643154/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=d13ded6cbc8b835807f08606db90bedf18643154", "patch": "@@ -103,6 +103,7 @@ pub(crate) fn reference_definition(\n \n #[cfg(test)]\n mod tests {\n+    use expect::{expect, Expect};\n     use test_utils::assert_eq_text;\n \n     use crate::mock_analysis::analysis_and_position;\n@@ -142,16 +143,40 @@ mod tests {\n         nav.assert_match(expected);\n     }\n \n+    fn check(ra_fixture: &str, expect: Expect) {\n+        let (analysis, pos) = analysis_and_position(ra_fixture);\n+\n+        let mut navs = analysis.goto_definition(pos).unwrap().unwrap().info;\n+        if navs.len() == 0 {\n+            panic!(\"unresolved reference\")\n+        }\n+        assert_eq!(navs.len(), 1);\n+\n+        let nav = navs.pop().unwrap();\n+        let file_text = analysis.file_text(nav.file_id()).unwrap();\n+\n+        let mut actual = nav.debug_render();\n+        actual += \"\\n\";\n+        actual += &file_text[nav.full_range()].to_string();\n+        if let Some(focus) = nav.focus_range() {\n+            actual += \"|\";\n+            actual += &file_text[focus];\n+            actual += \"\\n\";\n+        }\n+        expect.assert_eq(&actual);\n+    }\n+\n     #[test]\n     fn goto_def_in_items() {\n-        check_goto(\n-            \"\n-            //- /lib.rs\n-            struct Foo;\n-            enum E { X(Foo<|>) }\n-            \",\n-            \"Foo STRUCT_DEF FileId(1) 0..11 7..10\",\n-            \"struct Foo;|Foo\",\n+        check(\n+            r#\"\n+struct Foo;\n+enum E { X(Foo<|>) }\n+\"#,\n+            expect![[r#\"\n+                Foo STRUCT_DEF FileId(1) 0..11 7..10\n+                struct Foo;|Foo\n+            \"#]],\n         );\n     }\n "}, {"sha": "0940fcc2875169c0edbda9a59674064a66146167", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d13ded6cbc8b835807f08606db90bedf18643154/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d13ded6cbc8b835807f08606db90bedf18643154/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=d13ded6cbc8b835807f08606db90bedf18643154", "patch": "@@ -23,7 +23,7 @@ use ra_ide::{\n };\n use ra_prof::profile;\n use ra_project_model::TargetKind;\n-use ra_syntax::{AstNode, SyntaxKind, TextRange, TextSize};\n+use ra_syntax::{algo, ast, AstNode, SyntaxKind, TextRange, TextSize};\n use serde::{Deserialize, Serialize};\n use serde_json::to_value;\n use stdx::{format_to, split_delim};\n@@ -407,8 +407,19 @@ pub(crate) fn handle_runnables(\n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n     let line_index = snap.analysis.file_line_index(file_id)?;\n     let offset = params.position.map(|it| from_proto::offset(&line_index, it));\n-    let mut res = Vec::new();\n     let cargo_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n+\n+    let expect_test = match offset {\n+        Some(offset) => {\n+            let source_file = snap.analysis.parse(file_id)?;\n+            algo::find_node_at_offset::<ast::MacroCall>(source_file.syntax(), offset)\n+                .and_then(|it| it.path()?.segment()?.name_ref())\n+                .map_or(false, |it| it.text() == \"expect\")\n+        }\n+        None => false,\n+    };\n+\n+    let mut res = Vec::new();\n     for runnable in snap.analysis.runnables(file_id)? {\n         if let Some(offset) = offset {\n             if !runnable.nav.full_range().contains_inclusive(offset) {\n@@ -418,8 +429,12 @@ pub(crate) fn handle_runnables(\n         if should_skip_target(&runnable, cargo_spec.as_ref()) {\n             continue;\n         }\n-\n-        res.push(to_proto::runnable(&snap, file_id, runnable)?);\n+        let mut runnable = to_proto::runnable(&snap, file_id, runnable)?;\n+        if expect_test {\n+            runnable.label = format!(\"{} + expect\", runnable.label);\n+            runnable.args.expect_test = Some(true);\n+        }\n+        res.push(runnable);\n     }\n \n     // Add `cargo check` and `cargo test` for the whole package\n@@ -438,6 +453,7 @@ pub(crate) fn handle_runnables(\n                             spec.package.clone(),\n                         ],\n                         executable_args: Vec::new(),\n+                        expect_test: None,\n                     },\n                 })\n             }\n@@ -451,6 +467,7 @@ pub(crate) fn handle_runnables(\n                     workspace_root: None,\n                     cargo_args: vec![\"check\".to_string(), \"--workspace\".to_string()],\n                     executable_args: Vec::new(),\n+                    expect_test: None,\n                 },\n             });\n         }"}, {"sha": "1befe678c132137445d6b837e23270116370a97e", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d13ded6cbc8b835807f08606db90bedf18643154/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d13ded6cbc8b835807f08606db90bedf18643154/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=d13ded6cbc8b835807f08606db90bedf18643154", "patch": "@@ -161,6 +161,8 @@ pub struct CargoRunnable {\n     pub cargo_args: Vec<String>,\n     // stuff after --\n     pub executable_args: Vec<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub expect_test: Option<bool>,\n }\n \n pub enum InlayHints {}"}, {"sha": "a03222ae96bd590a09850fd48c2af82415e83380", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d13ded6cbc8b835807f08606db90bedf18643154/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d13ded6cbc8b835807f08606db90bedf18643154/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=d13ded6cbc8b835807f08606db90bedf18643154", "patch": "@@ -666,6 +666,7 @@ pub(crate) fn runnable(\n             workspace_root: workspace_root.map(|it| it.into()),\n             cargo_args,\n             executable_args,\n+            expect_test: None,\n         },\n     })\n }"}, {"sha": "fdb99956b5137a0c91a1b4f38aba6a2eae7f1e2b", "filename": "editors/code/src/lsp_ext.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d13ded6cbc8b835807f08606db90bedf18643154/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "raw_url": "https://github.com/rust-lang/rust/raw/d13ded6cbc8b835807f08606db90bedf18643154/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Flsp_ext.ts?ref=d13ded6cbc8b835807f08606db90bedf18643154", "patch": "@@ -60,6 +60,7 @@ export interface Runnable {\n         workspaceRoot?: string;\n         cargoArgs: string[];\n         executableArgs: string[];\n+        expectTest?: boolean;\n     };\n }\n export const runnables = new lc.RequestType<RunnablesParams, Runnable[], void>(\"experimental/runnables\");"}, {"sha": "e1430e31f76174addecc123b961d87ecfc0df16b", "filename": "editors/code/src/run.ts", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d13ded6cbc8b835807f08606db90bedf18643154/editors%2Fcode%2Fsrc%2Frun.ts", "raw_url": "https://github.com/rust-lang/rust/raw/d13ded6cbc8b835807f08606db90bedf18643154/editors%2Fcode%2Fsrc%2Frun.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Frun.ts?ref=d13ded6cbc8b835807f08606db90bedf18643154", "patch": "@@ -108,12 +108,16 @@ export async function createTask(runnable: ra.Runnable, config: Config): Promise\n     if (runnable.args.executableArgs.length > 0) {\n         args.push('--', ...runnable.args.executableArgs);\n     }\n+    const env: { [key: string]: string } = { \"RUST_BACKTRACE\": \"short\" };\n+    if (runnable.args.expectTest) {\n+        env[\"UPDATE_EXPECT\"] = \"1\";\n+    }\n     const definition: tasks.CargoTaskDefinition = {\n         type: tasks.TASK_TYPE,\n         command: args[0], // run, test, etc...\n         args: args.slice(1),\n         cwd: runnable.args.workspaceRoot,\n-        env: Object.assign({}, process.env as { [key: string]: string }, { \"RUST_BACKTRACE\": \"short\" }),\n+        env: Object.assign({}, process.env as { [key: string]: string }, env),\n     };\n \n     const target = vscode.workspace.workspaceFolders![0]; // safe, see main activate()"}]}