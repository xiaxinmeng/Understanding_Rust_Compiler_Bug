{"sha": "cd6dad641ca635f0c71d7dd0a34de8211939e8d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNmRhZDY0MWNhNjM1ZjBjNzFkN2RkMGEzNGRlODIxMTkzOWU4ZDk=", "commit": {"author": {"name": "Waffle", "email": "waffle.lapkin@gmail.com", "date": "2021-02-02T22:56:51Z"}, "committer": {"name": "Waffle", "email": "waffle.lapkin@gmail.com", "date": "2021-02-02T22:56:51Z"}, "message": "Make Vec::split_at_spare_mut public\n\nThis commit introduces a new method to the public API, under\n`vec_split_at_spare` feature gate:\n\n```rust\nimpl<T, A: Allocator> impl Vec<T, A> {\n    pub fn split_at_spare_mut(&mut self) -> (&mut [T], &mut [MaybeUninit<T>]);\n}\n```\n\nThe method returns 2 slices, one slice references the content of the vector,\nand the other references the remaining spare capacity.\n\nThe method was previously implemented while adding `Vec::extend_from_within`,\nand used to implement `Vec::spare_capacity_mut` (as the later is just a\nsubset of former one).", "tree": {"sha": "624c515f6e7b3808ee5ea5ec88b7993d824bd29f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/624c515f6e7b3808ee5ea5ec88b7993d824bd29f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd6dad641ca635f0c71d7dd0a34de8211939e8d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6dad641ca635f0c71d7dd0a34de8211939e8d9", "html_url": "https://github.com/rust-lang/rust/commit/cd6dad641ca635f0c71d7dd0a34de8211939e8d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd6dad641ca635f0c71d7dd0a34de8211939e8d9/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3182375e064b8fa90437aee1465bccafd8187d89", "url": "https://api.github.com/repos/rust-lang/rust/commits/3182375e064b8fa90437aee1465bccafd8187d89", "html_url": "https://github.com/rust-lang/rust/commit/3182375e064b8fa90437aee1465bccafd8187d89"}], "stats": {"total": 39, "additions": 38, "deletions": 1}, "files": [{"sha": "91535e9b527b1691123392d11423199cdadd5f17", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cd6dad641ca635f0c71d7dd0a34de8211939e8d9/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6dad641ca635f0c71d7dd0a34de8211939e8d9/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=cd6dad641ca635f0c71d7dd0a34de8211939e8d9", "patch": "@@ -1828,8 +1828,45 @@ impl<T, A: Allocator> Vec<T, A> {\n         self.split_at_spare_mut().1\n     }\n \n+    /// Returns vector content as a slice of `T`, among with the remaining spare\n+    /// capacity of the vector as a slice of `MaybeUninit<T>`.\n+    ///\n+    /// The returned spare capacity slice can be used to fill the vector with data\n+    /// (e.g. by reading from a file) before marking the data as initialized using\n+    /// the [`set_len`] method.\n+    ///\n+    /// [`set_len`]: Vec::set_len\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(vec_split_at_spare, maybe_uninit_extra)]\n+    ///\n+    /// let mut v = vec![1, 1, 2];\n+    ///\n+    /// // Reserve additional space big enough for 10 elements.\n+    /// v.reserve(10);\n+    ///\n+    /// let (init, uninit) = v.split_at_spare_mut();\n+    /// let sum = init.iter().copied().sum::<u32>();\n+    ///\n+    /// // Fill in the next 4 elements.\n+    /// uninit[0].write(sum);\n+    /// uninit[1].write(sum * 2);\n+    /// uninit[2].write(sum * 3);\n+    /// uninit[3].write(sum * 4);\n+    ///\n+    /// // Mark the 4 elements of the vector as being initialized.\n+    /// unsafe {\n+    ///     let len = v.len();\n+    ///     v.set_len(len + 4);\n+    /// }\n+    ///\n+    /// assert_eq!(&v, &[1, 1, 2, 4, 8, 12, 16]);\n+    /// ```\n+    #[unstable(feature = \"vec_split_at_spare\", issue = \"none\")]\n     #[inline]\n-    fn split_at_spare_mut(&mut self) -> (&mut [T], &mut [MaybeUninit<T>]) {\n+    pub fn split_at_spare_mut(&mut self) -> (&mut [T], &mut [MaybeUninit<T>]) {\n         let ptr = self.as_mut_ptr();\n \n         // Safety:"}]}