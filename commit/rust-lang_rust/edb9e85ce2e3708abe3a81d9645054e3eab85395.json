{"sha": "edb9e85ce2e3708abe3a81d9645054e3eab85395", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkYjllODVjZTJlMzcwOGFiZTNhODFkOTY0NTA1NGUzZWFiODUzOTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-05T00:51:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-05T00:51:23Z"}, "message": "auto merge of #10690 : thestinger/rust/doc, r=alexcrichton\n\nThis begins a rewrite of some sections the tutorial as an introduction\r\nto concepts through the implementation of a simple data structure. I\r\nthink this would be a good way to introduce references, generics, traits\r\nand many other concepts too. For example, the section introducing\r\nalternatives to ownership can demonstrate a persistent list.", "tree": {"sha": "debaa9b5e913781ea7ec5a1f79baf7c3adf4a7bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/debaa9b5e913781ea7ec5a1f79baf7c3adf4a7bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edb9e85ce2e3708abe3a81d9645054e3eab85395", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edb9e85ce2e3708abe3a81d9645054e3eab85395", "html_url": "https://github.com/rust-lang/rust/commit/edb9e85ce2e3708abe3a81d9645054e3eab85395", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edb9e85ce2e3708abe3a81d9645054e3eab85395/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad58e2c31c7abf88590c321bb939583ee8e4048f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad58e2c31c7abf88590c321bb939583ee8e4048f", "html_url": "https://github.com/rust-lang/rust/commit/ad58e2c31c7abf88590c321bb939583ee8e4048f"}, {"sha": "c1eb20b5f830a6181ec8f9818a50107c891ff3b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1eb20b5f830a6181ec8f9818a50107c891ff3b0", "html_url": "https://github.com/rust-lang/rust/commit/c1eb20b5f830a6181ec8f9818a50107c891ff3b0"}], "stats": {"total": 407, "additions": 361, "deletions": 46}, "files": [{"sha": "58bfd047d9504eb166afee5bd180e7a1fcba09cf", "filename": "doc/tutorial.md", "status": "modified", "additions": 361, "deletions": 46, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/edb9e85ce2e3708abe3a81d9645054e3eab85395/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/edb9e85ce2e3708abe3a81d9645054e3eab85395/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=edb9e85ce2e3708abe3a81d9645054e3eab85395", "patch": "@@ -914,36 +914,377 @@ between tasks. Custom destructors can only be implemented directly on types\n that are `Owned`, but garbage-collected boxes can still *contain* types with\n custom destructors.\n \n-# Boxes\n+# Implementing a linked list\n+\n+An `enum` is a natural fit for describing a linked list, because it can express\n+a `List` type as being *either* the end of the list (`Nil`) or another node\n+(`Cons`). The full definition of the `Cons` variant will require some thought.\n+\n+~~~ {.xfail-test}\n+enum List {\n+    Cons(...), // an incomplete definition of the next element in a List\n+    Nil        // the end of a List\n+}\n+~~~\n+\n+The obvious approach is to define `Cons` as containing an element in the list\n+along with the next `List` node. However, this will generate a compiler error.\n+\n+~~~ {.xfail-test}\n+// error: illegal recursive enum type; wrap the inner value in a box to make it representable\n+enum List {\n+    Cons(u32, List), // an element (`u32`) and the next node in the list\n+    Nil\n+}\n+~~~\n+\n+This error message is related to Rust's precise control over memory layout, and\n+solving it will require introducing the concept of *boxing*.\n+\n+## Boxes\n \n A value in Rust is stored directly inside the owner. If a `struct` contains\n-four `int` fields, it will be four times as large as a single `int`.  The\n-following `struct` type is invalid, as it would have an infinite size:\n+four `u32` fields, it will be four times as large as a single `u32`.\n \n-~~~~ {.xfail-test}\n-struct List {\n-    next: Option<List>,\n-    data: int\n+~~~\n+use std::mem::size_of; // bring `size_of` into the current scope, for convenience\n+\n+struct Foo {\n+    a: u32,\n+    b: u32,\n+    c: u32,\n+    d: u32\n }\n-~~~~\n \n-> ***Note:*** The `Option` type is an enum representing an *optional* value.\n-> It's comparable to a nullable pointer in many other languages, but stores the\n-> contained value unboxed.\n+assert_eq!(size_of::<Foo>(), size_of::<u32>() * 4);\n+\n+struct Bar {\n+    a: Foo,\n+    b: Foo,\n+    c: Foo,\n+    d: Foo\n+}\n+\n+assert_eq!(size_of::<Bar>(), size_of::<u32>() * 16);\n+~~~\n+\n+Our previous attempt at defining the `List` type included an `u32` and a `List`\n+directly inside `Cons`, making it at least as big as the sum of both types. The\n+type was invalid because the size was infinite!\n \n-An *owned box* (`~`) uses a heap allocation to provide the invariant of always\n-being the size of a pointer, regardless of the contained type. This can be\n-leveraged to create a valid recursive `struct` type with a finite size:\n+An *owned box* (`~`) uses a dynamic memory allocation to provide the invariant\n+of always being the size of a pointer, regardless of the contained type. This\n+can be leverage to create a valid `List` definition:\n+\n+~~~\n+enum List {\n+    Cons(u32, ~List),\n+    Nil\n+}\n+~~~\n+\n+Defining a recursive data structure like this is the canonical example of an\n+owned box. Much like an unboxed value, an owned box has a single owner and is\n+therefore limited to expressing a tree-like data structure.\n+\n+Consider an instance of our `List` type:\n+\n+~~~\n+# enum List {\n+#     Cons(u32, ~List),\n+#     Nil\n+# }\n+let list = Cons(1, ~Cons(2, ~Cons(3, ~Nil)));\n+~~~\n+\n+It represents an owned tree of values, inheriting mutability down the tree and\n+being destroyed along with the owner. Since the `list` variable above is\n+immutable, the whole list is immutable. The memory allocation itself is the\n+box, while the owner holds onto a pointer to it:\n+\n+      Cons cell        Cons cell        Cons cell\n+    +-----------+    +-----+-----+    +-----+-----+\n+    |  1  |  ~  | -> |  2  |  ~  | -> |  3  |  ~  | -> Nil\n+    +-----------+    +-----+-----+    +-----+-----+\n+\n+An owned box is a common example of a type with a destructor. The allocated\n+memory is cleaned up when the box is destroyed.\n+\n+## Move semantics\n+\n+Rust uses a shallow copy for parameter passing, assignment and returning from\n+functions. Passing around the `List` will copy only as deep as the pointer to\n+the box rather than doing an implicit heap allocation.\n+\n+~~~\n+# enum List {\n+#     Cons(u32, ~List),\n+#     Nil\n+# }\n+let xs = Cons(1, ~Cons(2, ~Cons(3, ~Nil)));\n+let ys = xs; // copies `Cons(u32, pointer)` shallowly\n+~~~\n \n+Rust will consider a shallow copy of a type with a destructor like `List` to\n+*move ownership* of the value. After a value has been moved, the source\n+location cannot be used unless it is reinitialized.\n+\n+~~~\n+# enum List {\n+#     Cons(u32, ~List),\n+#     Nil\n+# }\n+let mut xs = Nil;\n+let ys = xs;\n+\n+// attempting to use `xs` will result in an error here\n+\n+xs = Nil;\n+\n+// `xs` can be used again\n+~~~\n+\n+A destructor call will only occur for a variable that has not been moved from,\n+as it is only called a single time.\n+\n+\n+Avoiding a move can be done with the library-defined `clone` method:\n+\n+~~~~\n+let x = ~5;\n+let y = x.clone(); // y is a newly allocated box\n+let z = x; // no new memory allocated, x can no longer be used\n ~~~~\n-struct List {\n-    next: Option<~List>,\n-    data: int\n+\n+The `clone` method is provided by the `Clone` trait, and can be derived for\n+our `List` type. Traits will be explained in detail later.\n+\n+~~~{.xfail-test}\n+#[deriving(Clone)]\n+enum List {\n+    Cons(u32, ~List),\n+    Nil\n }\n+\n+let x = Cons(5, ~Nil);\n+let y = x.clone();\n+\n+// `x` can still be used!\n+\n+let z = x;\n+\n+// and now, it can no longer be used since it has been moved from\n+~~~\n+\n+The mutability of a value may be changed by moving it to a new owner:\n+\n+~~~~\n+let r = ~13;\n+let mut s = r; // box becomes mutable\n+*s += 1;\n+let t = s; // box becomes immutable\n ~~~~\n \n-Since an owned box has a single owner, they are limited to representing\n-tree-like data structures.\n+A simple way to define a function prepending to the `List` type is to take\n+advantage of moves:\n+\n+~~~\n+enum List {\n+    Cons(u32, ~List),\n+    Nil\n+}\n+\n+fn prepend(xs: List, value: u32) -> List {\n+    Cons(value, ~xs)\n+}\n+\n+let mut xs = Nil;\n+xs = prepend(xs, 1);\n+xs = prepend(xs, 2);\n+xs = prepend(xs, 3);\n+~~~\n+\n+However, this is not a very flexible definition of `prepend` as it requires\n+ownership of a list to be passed in rather than just mutating it in-place.\n+\n+## References\n+\n+The obvious signature for a `List` equality comparison is the following:\n+\n+~~~{.xfail-test}\n+fn eq(xs: List, ys: List) -> bool { ... }\n+~~~\n+\n+However, this will cause both lists to be moved into the function. Ownership\n+isn't required to compare the lists, so the function should take *references*\n+(&T) instead.\n+\n+~~~{.xfail-test}\n+fn eq(xs: &List, ys: &List) -> bool { ... }\n+~~~\n+\n+A reference is a *non-owning* view of a value. A reference can be obtained with the `&` (address-of)\n+operator. It can be dereferenced by using the `*` operator. In a pattern, such as `match` expression\n+branches, the `ref` keyword can be used to bind to a variable name by-reference rather than\n+by-value. A recursive definition of equality using references is as follows:\n+\n+~~~\n+# enum List {\n+#     Cons(u32, ~List),\n+#     Nil\n+# }\n+fn eq(xs: &List, ys: &List) -> bool {\n+    // Match on the next node in both lists.\n+    match (xs, ys) {\n+        // If we have reached the end of both lists, they are equal.\n+        (&Nil, &Nil) => true,\n+        // If the current element in both lists is equal, keep going.\n+        (&Cons(x, ~ref next_xs), &Cons(y, ~ref next_ys)) if x == y => eq(next_xs, next_ys),\n+        // If the current elements are not equal, the lists are not equal.\n+        _ => false\n+    }\n+}\n+\n+let xs = Cons(5, ~Cons(10, ~Nil));\n+let ys = Cons(5, ~Cons(10, ~Nil));\n+assert!(eq(&xs, &ys));\n+~~~\n+\n+Note that Rust doesn't guarantee [tail-call](http://en.wikipedia.org/wiki/Tail_call) optimization,\n+but LLVM is able to handle a simple case like this with optimizations enabled.\n+\n+## Lists of other types\n+\n+Our `List` type is currently always a list of 32-bit unsigned integers. By\n+leveraging Rust's support for generics, it can be extended to work for any\n+element type.\n+\n+The `u32` in the previous definition can be substituted with a type parameter:\n+\n+~~~\n+enum List<T> {\n+    Cons(T, ~List<T>),\n+    Nil\n+}\n+~~~\n+\n+The old `List` of `u32` is now available as `List<u32>`. The `prepend`\n+definition has to be updated too:\n+\n+~~~\n+# enum List<T> {\n+#     Cons(T, ~List<T>),\n+#     Nil\n+# }\n+fn prepend<T>(xs: List<T>, value: T) -> List<T> {\n+    Cons(value, ~xs)\n+}\n+~~~\n+\n+Generic functions and types like this are equivalent to defining specialized\n+versions for each set of type parameters.\n+\n+Using the generic `List<T>` works much like before, thanks to type inference:\n+\n+~~~\n+# enum List<T> {\n+#     Cons(T, ~List<T>),\n+#     Nil\n+# }\n+# fn prepend<T>(xs: List<T>, value: T) -> List<T> {\n+#     Cons(value, ~xs)\n+# }\n+let mut xs = Nil; // Unknown type! This is a `List<T>`, but `T` can be anything.\n+xs = prepend(xs, 10); // The compiler infers the type of `xs` as `List<int>` from this.\n+xs = prepend(xs, 15);\n+xs = prepend(xs, 20);\n+~~~\n+\n+The code sample above demonstrates type inference making most type annotations optional. It is\n+equivalent to the following type-annotated code:\n+\n+~~~\n+# enum List<T> {\n+#     Cons(T, ~List<T>),\n+#     Nil\n+# }\n+# fn prepend<T>(xs: List<T>, value: T) -> List<T> {\n+#     Cons(value, ~xs)\n+# }\n+let mut xs: List<int> = Nil::<int>;\n+xs = prepend::<int>(xs, 10);\n+xs = prepend::<int>(xs, 15);\n+xs = prepend::<int>(xs, 20);\n+~~~\n+\n+In the type grammar, the language uses `Type<T, U, V>` to describe a list of\n+type parameters, but expressions use `identifier::<T, U, V>`.\n+\n+## Defining list equality with generics\n+\n+Generic functions are type-checked from the definition, so any necessary properties of the type must\n+be specified up-front. Our previous definition of list equality relied on the element type having\n+the `==` operator available, and took advantage of the lack of a destructor on `u32` to copy it\n+without a move of ownership.\n+\n+We can add a *trait bound* on the `Eq` trait to require that the type implement the `==` operator.\n+Two more `ref` annotations need to be added to avoid attempting to move out the element types:\n+\n+~~~\n+# enum List<T> {\n+#     Cons(T, ~List<T>),\n+#     Nil\n+# }\n+fn eq<T: Eq>(xs: &List<T>, ys: &List<T>) -> bool {\n+    // Match on the next node in both lists.\n+    match (xs, ys) {\n+        // If we have reached the end of both lists, they are equal.\n+        (&Nil, &Nil) => true,\n+        // If the current element in both lists is equal, keep going.\n+        (&Cons(ref x, ~ref next_xs), &Cons(ref y, ~ref next_ys)) if x == y => eq(next_xs, next_ys),\n+        // If the current elements are not equal, the lists are not equal.\n+        _ => false\n+    }\n+}\n+\n+let xs = Cons('c', ~Cons('a', ~Cons('t', ~Nil)));\n+let ys = Cons('c', ~Cons('a', ~Cons('t', ~Nil)));\n+assert!(eq(&xs, &ys));\n+~~~\n+\n+This would be a good opportunity to implement the `Eq` trait for our list type, making the `==` and\n+`!=` operators available. We'll need to provide an `impl` for the `Eq` trait and a definition of the\n+`eq` method. In a method, the `self` parameter refers to an instance of the type we're implementing\n+on.\n+\n+~~~\n+# enum List<T> {\n+#     Cons(T, ~List<T>),\n+#     Nil\n+# }\n+impl<T: Eq> Eq for List<T> {\n+    fn eq(&self, ys: &List<T>) -> bool {\n+        // Match on the next node in both lists.\n+        match (self, ys) {\n+            // If we have reached the end of both lists, they are equal.\n+            (&Nil, &Nil) => true,\n+            // If the current element in both lists is equal, keep going.\n+            (&Cons(ref x, ~ref next_xs), &Cons(ref y, ~ref next_ys)) if x == y => next_xs == next_ys,\n+            // If the current elements are not equal, the lists are not equal.\n+            _ => false\n+        }\n+    }\n+}\n+\n+let xs = Cons(5, ~Cons(10, ~Nil));\n+let ys = Cons(5, ~Cons(10, ~Nil));\n+assert!(xs.eq(&ys));\n+assert!(xs == ys);\n+assert!(!xs.ne(&ys));\n+assert!(!(xs != ys));\n+~~~\n+\n+# More on boxes\n \n The most common use case for owned boxes is creating recursive data structures\n like a binary search tree. Rust's trait-based generics system (covered later in\n@@ -961,7 +1302,7 @@ value is returned via a hidden output parameter, and the decision on where to\n place the return value should be left to the caller:\n \n ~~~~\n-fn foo() -> (int, int, int, int, int, int) {\n+fn foo() -> (u64, u64, u64, u64, u64, u64) {\n     (5, 5, 5, 5, 5, 5)\n }\n \n@@ -981,32 +1322,6 @@ let mut y = ~5; // mutable\n *y += 2; // the * operator is needed to access the contained value\n ~~~~\n \n-As covered earlier, an owned box has a destructor to clean up the allocated\n-memory. This makes it more restricted than an unboxed type with no destructor\n-by introducing *move semantics*.\n-\n-# Move semantics\n-\n-Rust uses a shallow copy for parameter passing, assignment and returning from\n-functions. This is considered a move of ownership for types with destructors.\n-After a value has been moved, it can no longer be used from the source location\n-and will not be destroyed when the source goes out of scope.\n-\n-~~~~\n-let x = ~5;\n-let y = x.clone(); // y is a newly allocated box\n-let z = x; // no new memory allocated, x can no longer be used\n-~~~~\n-\n-The mutability of a value may be changed by moving it to a new owner:\n-\n-~~~~\n-let r = ~13;\n-let mut s = r; // box becomes mutable\n-*s += 1;\n-let t = s; // box becomes immutable\n-~~~~\n-\n # Borrowed pointers\n \n Rust's borrowed pointers are a general purpose reference type. In contrast with"}]}