{"sha": "c97b05141ab6bf5410d55d8a879690ca6d51d667", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5N2IwNTE0MWFiNmJmNTQxMGQ1NWQ4YTg3OTY5MGNhNmQ1MWQ2Njc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-13T20:05:55Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-13T20:06:34Z"}, "message": "rustc: Add write_type() wherever ann_types are written, except for triv_ann()", "tree": {"sha": "cade1a0a0b2f8d953c2d155ba304c274b89e5b12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cade1a0a0b2f8d953c2d155ba304c274b89e5b12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c97b05141ab6bf5410d55d8a879690ca6d51d667", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c97b05141ab6bf5410d55d8a879690ca6d51d667", "html_url": "https://github.com/rust-lang/rust/commit/c97b05141ab6bf5410d55d8a879690ca6d51d667", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c97b05141ab6bf5410d55d8a879690ca6d51d667/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7647b838a16e10ec930bedd827164c16b9c500e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7647b838a16e10ec930bedd827164c16b9c500e8", "html_url": "https://github.com/rust-lang/rust/commit/7647b838a16e10ec930bedd827164c16b9c500e8"}], "stats": {"total": 71, "additions": 56, "deletions": 15}, "files": [{"sha": "b3d9977e1038d510ee1b39c76e8e70bfe8ea1435", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c97b05141ab6bf5410d55d8a879690ca6d51d667/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c97b05141ab6bf5410d55d8a879690ca6d51d667/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=c97b05141ab6bf5410d55d8a879690ca6d51d667", "patch": "@@ -163,7 +163,8 @@ type type_store = rec(mutable vec[raw_t] others,\n                       hashmap[raw_t,uint] other_structural);\n \n type ty_param_substs_opt_and_ty = tup(option::t[vec[ty::t]], ty::t);\n-type node_type_table = vec[mutable option::t[ty::ty_param_substs_opt_and_ty]];\n+type node_type_table =\n+    @mutable vec[mutable option::t[ty::ty_param_substs_opt_and_ty]];\n \n fn mk_type_store() -> @type_store {\n     let vec[raw_t] others = vec();\n@@ -1469,6 +1470,18 @@ fn ann_to_type_params(&node_type_table ntt, &ast::ann ann) -> vec[t] {\n     }\n }\n \n+fn ann_to_ty_param_substs_opt_and_ty(&node_type_table ntt, &ast::ann ann)\n+        -> ty_param_substs_opt_and_ty {\n+    alt (ann) {\n+        case (ast::ann_none(_)) {\n+            log_err \"ann_to_ty_param_substs_opt_and_ty() called on a node \" +\n+                \"with no type params\";\n+            fail;\n+        }\n+        case (ast::ann_type(_, ?t, ?tps, _)) { ret tup(tps, t); }\n+    }\n+}\n+\n // Returns the type of an annotation, with type parameter substitutions\n // performed if applicable.\n fn ann_to_monotype(ctxt cx,  &node_type_table ntt, ast::ann a) -> t {"}, {"sha": "3e0ed783ba434d624ca18c1883d567de9ce7ee59", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 42, "deletions": 14, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c97b05141ab6bf5410d55d8a879690ca6d51d667/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c97b05141ab6bf5410d55d8a879690ca6d51d667/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=c97b05141ab6bf5410d55d8a879690ca6d51d667", "patch": "@@ -72,7 +72,7 @@ type crate_ctxt = rec(session::session sess,\n                       mutable uint cache_hits,\n                       mutable uint cache_misses,\n                       ty::ctxt tcx,\n-                      mutable node_type_table node_types);\n+                      node_type_table node_types);\n \n type fn_ctxt = rec(ty::t ret_ty,\n                    ast::purity purity,\n@@ -372,12 +372,13 @@ fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast::ty ast_ty) -> ty::t {\n }\n \n // Writes a type parameter count and type pair into the node type table.\n-fn write_type(&@crate_ctxt cx, uint node_id,\n+fn write_type(&node_type_table ntt, uint node_id,\n               &ty_param_substs_opt_and_ty tpot) {\n-    _vec::grow_set[option::t[ty::ty_param_substs_opt_and_ty]](cx.node_types,\n-        0u,\n-        none[ty_param_substs_opt_and_ty],\n-        some[ty_param_substs_opt_and_ty](tpot));\n+    _vec::grow_set[option::t[ty::ty_param_substs_opt_and_ty]]\n+        (*ntt,\n+         0u,\n+         none[ty_param_substs_opt_and_ty],\n+         some[ty_param_substs_opt_and_ty](tpot));\n }\n \n \n@@ -396,7 +397,8 @@ mod Collect {\n     type ctxt = rec(session::session sess,\n                     @ty_item_table id_to_ty_item,\n                     ty::type_cache type_cache,\n-                    ty::ctxt tcx);\n+                    ty::ctxt tcx,\n+                    node_type_table node_types);\n     type env = rec(@ctxt cx, ast::native_abi abi);\n \n     fn ty_of_fn_decl(&@ctxt cx,\n@@ -824,16 +826,23 @@ mod Collect {\n                                   ast::ann_type(ast::ann_tag(a), typ,\n                                                 none[vec[ty::t]],\n                                                 none[@ts_ann]));\n+        write_type(e.cx.node_types, ast::ann_tag(a),\n+                   tup(none[vec[ty::t]], typ));\n         ret @fold::respan[ast::item_](sp, item);\n     }\n \n     fn collect_item_types(&session::session sess, &ty::ctxt tcx,\n                           &@ast::crate crate)\n-            -> tup(@ast::crate, ty::type_cache, @ty_item_table) {\n+            -> tup(@ast::crate, ty::type_cache, @ty_item_table,\n+                   node_type_table) {\n         // First pass: collect all type item IDs:\n         auto module = crate.node.module;\n         auto id_to_ty_item = @common::new_def_hash[any_item]();\n \n+        let vec[mutable option::t[ty::ty_param_substs_opt_and_ty]] ntt_sub =\n+            vec(mutable);\n+        let node_type_table ntt = @mutable ntt_sub;\n+\n         auto fld_1 = fold::new_identity_fold[@ty_item_table]();\n         fld_1 = @rec(update_env_for_item = bind collect(_, _),\n                      update_env_for_native_item = bind collect_native(_, _)\n@@ -846,7 +855,8 @@ mod Collect {\n         auto cx = @rec(sess=sess,\n                        id_to_ty_item=id_to_ty_item,\n                        type_cache=type_cache,\n-                       tcx=tcx);\n+                       tcx=tcx,\n+                       node_types=ntt);\n \n         let @env e = @rec(cx=cx, abi=ast::native_abi_cdecl);\n \n@@ -863,7 +873,7 @@ mod Collect {\n                  fold_item_tag   = bind fold_item_tag(_,_,_,_,_,_,_)\n                  with *fld_2);\n         auto crate_ = fold::fold_crate[@env](e, fld_2, crate);\n-        ret tup(crate_, type_cache, id_to_ty_item);\n+        ret tup(crate_, type_cache, id_to_ty_item, ntt);\n     }\n }\n \n@@ -1135,13 +1145,17 @@ mod Pushdown {\n                 p_1 = ast::pat_wild(ast::ann_type(ast::ann_tag(ann), t,\n                                                 none[vec[ty::t]],\n                                                 none[@ts_ann]));\n+                write_type(fcx.ccx.node_types, ast::ann_tag(ann),\n+                           tup(none[vec[ty::t]], t));\n             }\n             case (ast::pat_lit(?lit, ?ann)) {\n                 auto t = Demand::simple(fcx, pat.span, expected,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n                 p_1 = ast::pat_lit(lit, ast::ann_type(ast::ann_tag(ann), t,\n                                                     none[vec[ty::t]],\n                                                     none[@ts_ann]));\n+                write_type(fcx.ccx.node_types, ast::ann_tag(ann),\n+                           tup(none[vec[ty::t]], t));\n             }\n             case (ast::pat_bind(?id, ?did, ?ann)) {\n                 auto t = Demand::simple(fcx, pat.span, expected,\n@@ -1151,6 +1165,8 @@ mod Pushdown {\n                                                            t,\n                                                            none[vec[ty::t]],\n                                                            none[@ts_ann]));\n+                write_type(fcx.ccx.node_types, ast::ann_tag(ann),\n+                           tup(none[vec[ty::t]], t));\n             }\n             case (ast::pat_tag(?id, ?subpats, ?ann)) {\n                 // Take the variant's type parameters out of the expected\n@@ -1182,6 +1198,9 @@ mod Pushdown {\n \n                 // TODO: push down type from \"expected\".\n                 p_1 = ast::pat_tag(id, subpats_1, ann);\n+                write_type(fcx.ccx.node_types, ast::ann_tag(ann),\n+                    ty::ann_to_ty_param_substs_opt_and_ty(fcx.ccx.node_types,\n+                                                          ann));\n             }\n         }\n \n@@ -1438,8 +1457,10 @@ mod Pushdown {\n \n                 e_1 = ast::expr_path(pth,\n                                     ast::ann_type(ast::ann_tag(ann), t,\n-                                                 ty_params_opt,\n-                                                 none[@ts_ann]));\n+                                                  ty_params_opt,\n+                                                  none[@ts_ann]));\n+                write_type(fcx.ccx.node_types, ast::ann_tag(ann),\n+                           tup(ty_params_opt, t));\n             }\n             case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?ann)) {\n                 auto t = Demand::autoderef(fcx, e.span, expected,\n@@ -1595,6 +1616,7 @@ fn resolve_local_types_in_annotation(&option::t[@fn_ctxt] env, &ast::ann ann)\n             auto f = bind resolver(fcx, _);\n             auto new_type = ty::fold_ty(fcx.ccx.tcx, f,\n                                         ann_to_type(fcx.ccx.node_types, ann));\n+            write_type(fcx.ccx.node_types, tg, tup(tps, new_type));\n             ret ast::ann_type(tg, new_type, tps, ts_info);\n         }\n     }\n@@ -1689,6 +1711,8 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat) -> @ast::pat {\n                     new_pat = ast::pat_tag(p, new_subpats,\n                         ast::ann_type(ast::ann_tag(old_ann), path_tpot._1,\n                                       path_tpot._0, none[@ts_ann]));\n+                    write_type(fcx.ccx.node_types, ast::ann_tag(old_ann),\n+                               path_tpot);\n                 }\n \n                 // Nullary variants have tag types.\n@@ -1709,6 +1733,8 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat) -> @ast::pat {\n                     new_pat = ast::pat_tag(p, subpats,\n                         ast::ann_type(ast::ann_tag(old_ann), path_tpot._1,\n                                       path_tpot._0, none[@ts_ann]));\n+                    write_type(fcx.ccx.node_types, ast::ann_tag(old_ann),\n+                               path_tpot);\n                 }\n             }\n         }\n@@ -1960,6 +1986,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                     ast::expr_path(pth,\n                         ast::ann_type(ast::ann_tag(old_ann), path_tpot._1,\n                                       path_tpot._0, none[@ts_ann])));\n+                    write_type(fcx.ccx.node_types, ast::ann_tag(old_ann),\n+                               path_tpot);\n             }\n \n             // The definition doesn't take type parameters. If the programmer\n@@ -3033,7 +3061,7 @@ fn check_crate(&ty::ctxt tcx, &@ast::crate crate) -> typecheck_result {\n         map::mk_hashmap[unify_cache_entry,ty::Unify::result](hasher, eqer);\n     auto fpt =\n         mk_fn_purity_table(crate); // use a variation on Collect\n-    let node_type_table node_types = vec(mutable);\n+    let node_type_table node_types = result._3;\n \n     auto ccx = @rec(sess=sess,\n                     type_cache=result._1,\n@@ -3046,7 +3074,7 @@ fn check_crate(&ty::ctxt tcx, &@ast::crate crate) -> typecheck_result {\n                     mutable cache_hits=0u,\n                     mutable cache_misses=0u,\n                     tcx=tcx,\n-                    mutable node_types=node_types);\n+                    node_types=node_types);\n \n     auto fld = fold::new_identity_fold[@crate_ctxt]();\n "}]}