{"sha": "f67b81e8d4dc198ad10ad50a7624e43cc1e25802", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2N2I4MWU4ZDRkYzE5OGFkMTBhZDUwYTc2MjRlNDNjYzFlMjU4MDI=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-01-05T23:45:18Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-01-06T17:04:48Z"}, "message": "Stabilize std::thread\n\nThis commit takes a first pass at stabilizing `std::thread`:\n\n* It removes the `detach` method in favor of two constructors -- `spawn`\n  for detached threads, `scoped` for \"scoped\" (i.e., must-join)\n  threads. This addresses some of the surprise/frustrating debug\n  sessions with the previous API, in which `spawn` produced a guard that\n  on destruction joined the thread (unless `detach` was called).\n\n  The reason to have the division in part is that `Send` will soon not\n  imply `'static`, which means that `scoped` thread creation can take a\n  closure over *shared stack data* of the parent thread. On the other\n  hand, this means that the parent must not pop the relevant stack\n  frames while the child thread is running. The `JoinGuard` is used to\n  prevent this from happening by joining on drop (if you have not\n  already explicitly `join`ed.) The APIs around `scoped` are\n  future-proofed for the `Send` changes by taking an additional lifetime\n  parameter. With the current definition of `Send`, this is forced to be\n  `'static`, but when `Send` changes these APIs will gain their full\n  flexibility immediately.\n\n  Threads that are `spawn`ed, on the other hand, are detached from the\n  start and do not yield an RAII guard.\n\n  The hope is that, by making `scoped` an explicit opt-in with a very\n  suggestive name, it will be drastically less likely to be caught by a\n  surprising deadlock due to an implicit join at the end of a scope.\n\n* The module itself is marked stable.\n\n* Existing methods other than `spawn` and `scoped` are marked stable.\n\nThe migration path is:\n\n```rust\nThread::spawn(f).detached()\n```\n\nbecomes\n\n```rust\nThread::spawn(f)\n```\n\nwhile\n\n```rust\nlet res = Thread::spawn(f);\nres.join()\n```\n\nbecomes\n\n```rust\nlet res = Thread::scoped(f);\nres.join()\n```\n\n[breaking-change]", "tree": {"sha": "213cb90db24aa02a376b8ff793b106c7d604805f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/213cb90db24aa02a376b8ff793b106c7d604805f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f67b81e8d4dc198ad10ad50a7624e43cc1e25802", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f67b81e8d4dc198ad10ad50a7624e43cc1e25802", "html_url": "https://github.com/rust-lang/rust/commit/f67b81e8d4dc198ad10ad50a7624e43cc1e25802", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f67b81e8d4dc198ad10ad50a7624e43cc1e25802/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8efd9901b628d687d11a4d0ccc153553b38ada49", "url": "https://api.github.com/repos/rust-lang/rust/commits/8efd9901b628d687d11a4d0ccc153553b38ada49", "html_url": "https://github.com/rust-lang/rust/commit/8efd9901b628d687d11a4d0ccc153553b38ada49"}], "stats": {"total": 159, "additions": 115, "deletions": 44}, "files": [{"sha": "9e12a7b592ae31210671cac81353e2ebfe0dc3f0", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 115, "deletions": 44, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/f67b81e8d4dc198ad10ad50a7624e43cc1e25802/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67b81e8d4dc198ad10ad50a7624e43cc1e25802/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=f67b81e8d4dc198ad10ad50a7624e43cc1e25802", "patch": "@@ -16,7 +16,7 @@\n //! each with their own stack and local state.\n //!\n //! Communication between threads can be done through\n-//! [channels](../../std/comm/index.html), Rust's message-passing\n+//! [channels](../../std/sync/mpsc/index.html), Rust's message-passing\n //! types, along with [other forms of thread\n //! synchronization](../../std/sync/index.html) and shared-memory data\n //! structures. In particular, types that are guaranteed to be\n@@ -58,25 +58,45 @@\n //! ```rust\n //! use std::thread::Thread;\n //!\n-//! let guard = Thread::spawn(move || {\n+//! let thread = Thread::spawn(move || {\n //!     println!(\"Hello, World!\");\n //!     // some computation here\n //! });\n-//! let result = guard.join();\n //! ```\n //!\n-//! The `spawn` function doesn't return a `Thread` directly; instead, it returns\n-//! a *join guard* from which a `Thread` can be extracted. The join guard is an\n-//! RAII-style guard that will automatically join the child thread (block until\n-//! it terminates) when it is dropped. You can join the child thread in advance\n-//! by calling the `join` method on the guard, which will also return the result\n-//! produced by the thread.\n+//! The spawned thread is \"detached\" from the current thread, meaning that it\n+//! can outlive the thread that spawned it. (Note, however, that when the main\n+//! thread terminates all detached threads are terminated as well.) The returned\n+//! `Thread` handle can be used for low-level synchronization as described below.\n+//!\n+//! ## Scoped threads\n+//!\n+//! Often a parent thread uses a child thread to perform some particular task,\n+//! and at some point must wait for the child to complete before continuing.\n+//! For this scenario, use the `scoped` constructor:\n+//!\n+//! ```rust\n+//! use std::thread::Thread;\n+//!\n+//! let guard = Thread::scoped(move || {\n+//!     println!(\"Hello, World!\");\n+//!     // some computation here\n+//! });\n+//! // do some other work in the meantime\n+//! let result = guard.join();\n+//! ```\n //!\n-//! If you instead wish to *detach* the child thread, allowing it to outlive its\n-//! parent, you can use the `detach` method on the guard,\n+//! The `scoped` function doesn't return a `Thread` directly; instead, it\n+//! returns a *join guard* from which a `Thread` can be extracted. The join\n+//! guard is an RAII-style guard that will automatically join the child thread\n+//! (block until it terminates) when it is dropped. You can join the child\n+//! thread in advance by calling the `join` method on the guard, which will also\n+//! return the result produced by the thread.  A handle to the thread itself is\n+//! available via the `thread` method on the join guard.\n //!\n-//! A handle to the thread itself is available via the `thread` method on the\n-//! join guard.\n+//! (Note: eventually, the `scoped` constructor will allow the parent and child\n+//! threads to data that lives on the parent thread's stack, but some language\n+//! changes are needed before this is possible.)\n //!\n //! ## Configuring threads\n //!\n@@ -89,7 +109,7 @@\n //!\n //! thread::Builder::new().name(\"child1\".to_string()).spawn(move || {\n //!     println!(\"Hello, world!\")\n-//! }).detach();\n+//! });\n //! ```\n //!\n //! ## Blocking support: park and unpark\n@@ -124,6 +144,8 @@\n //!\n //! * It can be implemented highly efficiently on many platforms.\n \n+#![stable]\n+\n use any::Any;\n use boxed::Box;\n use cell::UnsafeCell;\n@@ -144,6 +166,7 @@ use sys_common::{stack, thread_info};\n \n /// Thread configuation. Provides detailed control over the properties\n /// and behavior of new threads.\n+#[stable]\n pub struct Builder {\n     // A name for the thread-to-be, for identification in panic messages\n     name: Option<String>,\n@@ -158,6 +181,7 @@ pub struct Builder {\n impl Builder {\n     /// Generate the base configuration for spawning a thread, from which\n     /// configuration methods can be chained.\n+    #[stable]\n     pub fn new() -> Builder {\n         Builder {\n             name: None,\n@@ -169,12 +193,14 @@ impl Builder {\n \n     /// Name the thread-to-be. Currently the name is used for identification\n     /// only in panic messages.\n+    #[stable]\n     pub fn name(mut self, name: String) -> Builder {\n         self.name = Some(name);\n         self\n     }\n \n     /// Set the size of the stack for the new thread.\n+    #[stable]\n     pub fn stack_size(mut self, size: uint) -> Builder {\n         self.stack_size = Some(size);\n         self\n@@ -194,19 +220,41 @@ impl Builder {\n         self\n     }\n \n-    /// Spawn a new joinable thread, and return a JoinGuard guard for it.\n+    /// Spawn a new detached thread, and return a handle to it.\n     ///\n     /// See `Thead::spawn` and the module doc for more details.\n-    pub fn spawn<T, F>(self, f: F) -> JoinGuard<T> where\n-        T: Send, F: FnOnce() -> T, F: Send\n-    {\n-        self.spawn_inner(Thunk::new(f))\n+    #[unstable = \"may change with specifics of new Send semantics\"]\n+    pub fn spawn<F>(self, f: F) -> Thread where F: FnOnce(), F: Send + 'static {\n+        let (native, thread) = self.spawn_inner(Thunk::new(f), Thunk::with_arg(|_| {}));\n+        unsafe { imp::detach(native) };\n+        thread\n     }\n \n-    fn spawn_inner<T: Send>(self, f: Thunk<(), T>) -> JoinGuard<T> {\n+    /// Spawn a new child thread that must be joined within a given\n+    /// scope, and return a `JoinGuard`.\n+    ///\n+    /// See `Thead::scoped` and the module doc for more details.\n+    #[unstable = \"may change with specifics of new Send semantics\"]\n+    pub fn scoped<'a, T, F>(self, f: F) -> JoinGuard<'a, T> where\n+        T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n+    {\n         let my_packet = Packet(Arc::new(UnsafeCell::new(None)));\n         let their_packet = Packet(my_packet.0.clone());\n+        let (native, thread) = self.spawn_inner(Thunk::new(f), Thunk::with_arg(move |: ret| unsafe {\n+            *their_packet.0.get() = Some(ret);\n+        }));\n \n+        JoinGuard {\n+            native: native,\n+            joined: false,\n+            packet: my_packet,\n+            thread: thread,\n+        }\n+    }\n+\n+    fn spawn_inner<T: Send>(self, f: Thunk<(), T>, finish: Thunk<Result<T>, ()>)\n+                      -> (imp::rust_thread, Thread)\n+    {\n         let Builder { name, stack_size, stdout, stderr } = self;\n \n         let stack_size = stack_size.unwrap_or(rt::min_stack());\n@@ -258,21 +306,14 @@ impl Builder {\n                     unwind::try(move || *ptr = Some(f.invoke(())))\n                 }\n             };\n-            unsafe {\n-                *their_packet.0.get() = Some(match (output, try_result) {\n-                    (Some(data), Ok(_)) => Ok(data),\n-                    (None, Err(cause)) => Err(cause),\n-                    _ => unreachable!()\n-                });\n-            }\n+            finish.invoke(match (output, try_result) {\n+                (Some(data), Ok(_)) => Ok(data),\n+                (None, Err(cause)) => Err(cause),\n+                _ => unreachable!()\n+            });\n         };\n \n-        JoinGuard {\n-            native: unsafe { imp::create(stack_size, Thunk::new(main)) },\n-            joined: false,\n-            packet: my_packet,\n-            thread: my_thread,\n-        }\n+        (unsafe { imp::create(stack_size, Thunk::new(main)) }, my_thread)\n     }\n }\n \n@@ -285,11 +326,13 @@ struct Inner {\n unsafe impl Sync for Inner {}\n \n #[derive(Clone)]\n+#[stable]\n /// A handle to a thread.\n pub struct Thread {\n     inner: Arc<Inner>,\n }\n \n+#[stable]\n unsafe impl Sync for Thread {}\n \n impl Thread {\n@@ -304,30 +347,47 @@ impl Thread {\n         }\n     }\n \n-    /// Spawn a new joinable thread, returning a `JoinGuard` for it.\n+    /// Spawn a new detached thread, returning a handle to it.\n+    ///\n+    /// The child thread may outlive the parent (unless the parent thread is the\n+    /// main thread; the whole process is terminated when the main thread\n+    /// finishes.) The thread handle can be used for low-level\n+    /// synchronization. See the module documentation for additional details.\n+    #[unstable = \"may change with specifics of new Send semantics\"]\n+    pub fn spawn<F>(f: F) -> Thread where F: FnOnce(), F: Send + 'static {\n+        Builder::new().spawn(f)\n+    }\n+\n+    /// Spawn a new *scoped* thread, returning a `JoinGuard` for it.\n     ///\n     /// The join guard can be used to explicitly join the child thread (via\n     /// `join`), returning `Result<T>`, or it will implicitly join the child\n-    /// upon being dropped. To detach the child, allowing it to outlive the\n-    /// current thread, use `detach`.  See the module documentation for additional details.\n-    pub fn spawn<T, F>(f: F) -> JoinGuard<T> where\n-        T: Send, F: FnOnce() -> T, F: Send\n+    /// upon being dropped. Because the child thread may refer to data on the\n+    /// current thread's stack (hence the \"scoped\" name), it cannot be detached;\n+    /// it *must* be joined before the relevant stack frame is popped. See the\n+    /// module documentation for additional details.\n+    #[unstable = \"may change with specifics of new Send semantics\"]\n+    pub fn scoped<'a, T, F>(f: F) -> JoinGuard<'a, T> where\n+        T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n     {\n-        Builder::new().spawn(f)\n+        Builder::new().scoped(f)\n     }\n \n     /// Gets a handle to the thread that invokes it.\n+    #[stable]\n     pub fn current() -> Thread {\n         thread_info::current_thread()\n     }\n \n     /// Cooperatively give up a timeslice to the OS scheduler.\n+    #[unstable = \"name may change\"]\n     pub fn yield_now() {\n         unsafe { imp::yield_now() }\n     }\n \n     /// Determines whether the current thread is panicking.\n     #[inline]\n+    #[stable]\n     pub fn panicking() -> bool {\n         unwind::panicking()\n     }\n@@ -341,6 +401,7 @@ impl Thread {\n     // future, this will be implemented in a more efficient way, perhaps along the lines of\n     //   http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n     // or futuxes, and in either case may allow spurious wakeups.\n+    #[unstable = \"recently introduced\"]\n     pub fn park() {\n         let thread = Thread::current();\n         let mut guard = thread.inner.lock.lock().unwrap();\n@@ -353,6 +414,7 @@ impl Thread {\n     /// Atomically makes the handle's token available if it is not already.\n     ///\n     /// See the module doc for more detail.\n+    #[unstable = \"recently introduced\"]\n     pub fn unpark(&self) {\n         let mut guard = self.inner.lock.lock().unwrap();\n         if !*guard {\n@@ -362,6 +424,7 @@ impl Thread {\n     }\n \n     /// Get the thread's name.\n+    #[stable]\n     pub fn name(&self) -> Option<&str> {\n         self.inner.name.as_ref().map(|s| s.as_slice())\n     }\n@@ -375,28 +438,32 @@ impl thread_info::NewThread for Thread {\n /// Indicates the manner in which a thread exited.\n ///\n /// A thread that completes without panicking is considered to exit successfully.\n+#[stable]\n pub type Result<T> = ::result::Result<T, Box<Any + Send>>;\n \n struct Packet<T>(Arc<UnsafeCell<Option<Result<T>>>>);\n \n unsafe impl<T:'static+Send> Send for Packet<T> {}\n unsafe impl<T> Sync for Packet<T> {}\n \n-#[must_use]\n /// An RAII-style guard that will block until thread termination when dropped.\n ///\n /// The type `T` is the return type for the thread's main function.\n-pub struct JoinGuard<T> {\n+#[must_use]\n+#[unstable = \"may change with specifics of new Send semantics\"]\n+pub struct JoinGuard<'a, T: 'a> {\n     native: imp::rust_thread,\n     thread: Thread,\n     joined: bool,\n     packet: Packet<T>,\n }\n \n-unsafe impl<T: Send> Sync for JoinGuard<T> {}\n+#[stable]\n+unsafe impl<'a, T: Send + 'a> Sync for JoinGuard<'a, T> {}\n \n-impl<T: Send> JoinGuard<T> {\n+impl<'a, T: Send + 'a> JoinGuard<'a, T> {\n     /// Extract a handle to the thread this guard will join on.\n+    #[stable]\n     pub fn thread(&self) -> &Thread {\n         &self.thread\n     }\n@@ -406,6 +473,7 @@ impl<T: Send> JoinGuard<T> {\n     ///\n     /// If the child thread panics, `Err` is returned with the parameter given\n     /// to `panic`.\n+    #[stable]\n     pub fn join(mut self) -> Result<T> {\n         assert!(!self.joined);\n         unsafe { imp::join(self.native) };\n@@ -414,8 +482,11 @@ impl<T: Send> JoinGuard<T> {\n             (*self.packet.0.get()).take().unwrap()\n         }\n     }\n+}\n \n+impl<T: Send> JoinGuard<'static, T> {\n     /// Detaches the child thread, allowing it to outlive its parent.\n+    #[experimental = \"unsure whether this API imposes limitations elsewhere\"]\n     pub fn detach(mut self) {\n         unsafe { imp::detach(self.native) };\n         self.joined = true; // avoid joining in the destructor\n@@ -424,7 +495,7 @@ impl<T: Send> JoinGuard<T> {\n \n #[unsafe_destructor]\n #[stable]\n-impl<T: Send> Drop for JoinGuard<T> {\n+impl<'a, T: Send + 'a> Drop for JoinGuard<'a, T> {\n     fn drop(&mut self) {\n         if !self.joined {\n             unsafe { imp::join(self.native) };"}]}