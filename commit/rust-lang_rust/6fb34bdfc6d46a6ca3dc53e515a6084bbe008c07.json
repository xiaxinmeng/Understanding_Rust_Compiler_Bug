{"sha": "6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmYjM0YmRmYzZkNDZhNmNhM2RjNTNlNTE1YTYwODRiYmUwMDhjMDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-12T22:48:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-12T22:48:16Z"}, "message": "Auto merge of #50536 - leodasvacas:report-fullfilment-errors-in-copy-derive, r=estebank\n\nBetter error reporting in Copy derive\n\nIn Copy derive, report all fulfillment erros when present and do not report errors for types tainted with `TyErr`. Also report all fields which are not Copy rather than just the first.\n\nAlso refactored `fn fully_normalize`, removing the not very useful helper function along with a FIXME to the closed issue #26721 that looks out of context now.\n\nFixes #50480\n\nr? @estebank", "tree": {"sha": "9a34e1d8780de0c62fad38748262ad0320f6efaf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a34e1d8780de0c62fad38748262ad0320f6efaf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07", "html_url": "https://github.com/rust-lang/rust/commit/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff2ac35db93a80b2de5daa4f280bf1503d62c164", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff2ac35db93a80b2de5daa4f280bf1503d62c164", "html_url": "https://github.com/rust-lang/rust/commit/ff2ac35db93a80b2de5daa4f280bf1503d62c164"}, {"sha": "6389f35ef985f6bf354b7cd848c94e446d08d2bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/6389f35ef985f6bf354b7cd848c94e446d08d2bc", "html_url": "https://github.com/rust-lang/rust/commit/6389f35ef985f6bf354b7cd848c94e446d08d2bc"}], "stats": {"total": 144, "additions": 84, "deletions": 60}, "files": [{"sha": "d6a7d5e8472ac086dab3b6dec23b6cc37664f8cd", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07", "patch": "@@ -764,7 +764,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                      \"unions with `Drop` implementations are unstable\");\n                 } else {\n                     let param_env = self.tcx.param_env(def_id);\n-                    if !param_env.can_type_implement_copy(self.tcx, ty, item.span).is_ok() {\n+                    if !param_env.can_type_implement_copy(self.tcx, ty).is_ok() {\n                         emit_feature_err(&self.tcx.sess.parse_sess,\n                                         \"untagged_unions\", item.span, GateIssue::Language,\n                                         \"unions with non-`Copy` fields are unstable\");"}, {"sha": "a765ffe2396bf471db0e385e17a0bc36286bd5a6", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 33, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07", "patch": "@@ -674,7 +674,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // we move over to lazy normalization *anyway*.\n         let fulfill_cx = FulfillmentContext::new_ignoring_regions();\n \n-        let predicates = match fully_normalize_with_fulfillcx(\n+        let predicates = match fully_normalize(\n             &infcx,\n             fulfill_cx,\n             cause,\n@@ -734,31 +734,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     })\n }\n \n-pub fn fully_normalize<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                          cause: ObligationCause<'tcx>,\n-                                          param_env: ty::ParamEnv<'tcx>,\n-                                          value: &T)\n-                                          -> Result<T, Vec<FulfillmentError<'tcx>>>\n-    where T : TypeFoldable<'tcx>\n-{\n-    // FIXME (@jroesch) ISSUE 26721\n-    // I'm not sure if this is a bug or not, needs further investigation.\n-    // It appears that by reusing the fulfillment_cx here we incur more\n-    // obligations and later trip an assertion on regionck.rs line 337.\n-    //\n-    // The two possibilities I see is:\n-    //      - normalization is not actually fully happening and we\n-    //        have a bug else where\n-    //      - we are adding a duplicate bound into the list causing\n-    //        its size to change.\n-    //\n-    // I think we should probably land this refactor and then come\n-    // back to this is a follow-up patch.\n-    let fulfillcx = FulfillmentContext::new();\n-    fully_normalize_with_fulfillcx(infcx, fulfillcx, cause, param_env, value)\n-}\n-\n-pub fn fully_normalize_with_fulfillcx<'a, 'gcx, 'tcx, T>(\n+pub fn fully_normalize<'a, 'gcx, 'tcx, T>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     mut fulfill_cx: FulfillmentContext<'tcx>,\n     cause: ObligationCause<'tcx>,\n@@ -779,13 +755,7 @@ pub fn fully_normalize_with_fulfillcx<'a, 'gcx, 'tcx, T>(\n     }\n \n     debug!(\"fully_normalize: select_all_or_error start\");\n-    match fulfill_cx.select_all_or_error(infcx) {\n-        Ok(()) => { }\n-        Err(e) => {\n-            debug!(\"fully_normalize: error={:?}\", e);\n-            return Err(e);\n-        }\n-    }\n+    fulfill_cx.select_all_or_error(infcx)?;\n     debug!(\"fully_normalize: select_all_or_error complete\");\n     let resolved_value = infcx.resolve_type_vars_if_possible(&normalized_value);\n     debug!(\"fully_normalize: resolved_value={:?}\", resolved_value);"}, {"sha": "d33806285142e4ba90de19eeac6cf240684892f0", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07", "patch": "@@ -196,6 +196,7 @@ pub(super) fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // that this always succeeds.\n         let impl1_trait_ref =\n             match traits::fully_normalize(&infcx,\n+                                          FulfillmentContext::new(),\n                                           ObligationCause::dummy(),\n                                           penv,\n                                           &impl1_trait_ref) {"}, {"sha": "fdd0754730febb72bf0d37a73f73d95bf00c864f", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07", "patch": "@@ -16,7 +16,7 @@ use hir::map::{DefPathData, Node};\n use hir;\n use ich::NodeIdHashingMode;\n use middle::const_val::ConstVal;\n-use traits;\n+use traits::{self, ObligationCause};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::TypeVisitor;\n use ty::subst::UnpackedKind;\n@@ -166,9 +166,9 @@ impl IntTypeExt for attr::IntType {\n }\n \n \n-#[derive(Copy, Clone)]\n+#[derive(Clone)]\n pub enum CopyImplementationError<'tcx> {\n-    InfrigingField(&'tcx ty::FieldDef),\n+    InfrigingFields(Vec<&'tcx ty::FieldDef>),\n     NotAnAdt,\n     HasDestructor,\n }\n@@ -191,7 +191,7 @@ pub enum Representability {\n impl<'tcx> ty::ParamEnv<'tcx> {\n     pub fn can_type_implement_copy<'a>(self,\n                                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       self_type: Ty<'tcx>, span: Span)\n+                                       self_type: Ty<'tcx>)\n                                        -> Result<(), CopyImplementationError<'tcx>> {\n         // FIXME: (@jroesch) float this code up\n         tcx.infer_ctxt().enter(|infcx| {\n@@ -207,22 +207,29 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n                 _ => return Err(CopyImplementationError::NotAnAdt),\n             };\n \n-            let field_implements_copy = |field: &ty::FieldDef| {\n-                let cause = traits::ObligationCause::dummy();\n-                match traits::fully_normalize(&infcx, cause, self, &field.ty(tcx, substs)) {\n-                    Ok(ty) => !infcx.type_moves_by_default(self, ty, span),\n-                    Err(..) => false,\n-                }\n-            };\n-\n+            let mut infringing = Vec::new();\n             for variant in &adt.variants {\n                 for field in &variant.fields {\n-                    if !field_implements_copy(field) {\n-                        return Err(CopyImplementationError::InfrigingField(field));\n+                    let span = tcx.def_span(field.did);\n+                    let ty = field.ty(tcx, substs);\n+                    if ty.references_error() {\n+                        continue;\n                     }\n+                    let cause = ObligationCause { span, ..ObligationCause::dummy() };\n+                    let ctx = traits::FulfillmentContext::new();\n+                    match traits::fully_normalize(&infcx, ctx, cause, self, &ty) {\n+                        Ok(ty) => if infcx.type_moves_by_default(self, ty, span) {\n+                            infringing.push(field);\n+                        }\n+                        Err(errors) => {\n+                            infcx.report_fulfillment_errors(&errors, None, false);\n+                        }\n+                    };\n                 }\n             }\n-\n+            if !infringing.is_empty() {\n+                return Err(CopyImplementationError::InfrigingFields(infringing));\n+            }\n             if adt.has_dtor(tcx) {\n                 return Err(CopyImplementationError::HasDestructor);\n             }"}, {"sha": "cbb0177fe4f4eefe6401d43634228f4a60dbdd9c", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07", "patch": "@@ -541,7 +541,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n         if !ty.moves_by_default(cx.tcx, param_env, item.span) {\n             return;\n         }\n-        if param_env.can_type_implement_copy(cx.tcx, ty, item.span).is_ok() {\n+        if param_env.can_type_implement_copy(cx.tcx, ty).is_ok() {\n             cx.span_lint(MISSING_COPY_IMPLEMENTATIONS,\n                          item.span,\n                          \"type could implement `Copy`; consider adding `impl \\"}, {"sha": "2f08a54e10f08839b6cffbb4d58899f9d42af86f", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07", "patch": "@@ -111,24 +111,24 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"visit_implementation_of_copy: self_type={:?} (free)\",\n            self_type);\n \n-    match param_env.can_type_implement_copy(tcx, self_type, span) {\n+    match param_env.can_type_implement_copy(tcx, self_type) {\n         Ok(()) => {}\n-        Err(CopyImplementationError::InfrigingField(field)) => {\n+        Err(CopyImplementationError::InfrigingFields(fields)) => {\n             let item = tcx.hir.expect_item(impl_node_id);\n             let span = if let ItemImpl(.., Some(ref tr), _, _) = item.node {\n                 tr.path.span\n             } else {\n                 span\n             };\n \n-            struct_span_err!(tcx.sess,\n-                             span,\n-                             E0204,\n-                             \"the trait `Copy` may not be implemented for this type\")\n-                .span_label(\n-                    tcx.def_span(field.did),\n-                    \"this field does not implement `Copy`\")\n-                .emit()\n+            let mut err = struct_span_err!(tcx.sess,\n+                                          span,\n+                                          E0204,\n+                                          \"the trait `Copy` may not be implemented for this type\");\n+            for span in fields.iter().map(|f| tcx.def_span(f.did)) {\n+                    err.span_label(span, \"this field does not implement `Copy`\");\n+            }\n+            err.emit()\n         }\n         Err(CopyImplementationError::NotAnAdt) => {\n             let item = tcx.hir.expect_item(impl_node_id);"}, {"sha": "3427cf6bf9ca2d810fbfde47c0fe60c3cdf9eb1e", "filename": "src/test/ui/issue-50480.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07/src%2Ftest%2Fui%2Fissue-50480.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07/src%2Ftest%2Fui%2Fissue-50480.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-50480.rs?ref=6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[derive(Clone, Copy)]\n+//~^ ERROR the trait `Copy` may not be implemented for this type\n+struct Foo(NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n+//~^ ERROR cannot find type `NotDefined` in this scope\n+//~| ERROR the trait bound `i32: std::iter::Iterator` is not satisfied\n+\n+fn main() {}"}, {"sha": "f5281fec4d1eac5ec7bf4c0a86c40e0b145bab5c", "filename": "src/test/ui/issue-50480.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07/src%2Ftest%2Fui%2Fissue-50480.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07/src%2Ftest%2Fui%2Fissue-50480.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-50480.stderr?ref=6fb34bdfc6d46a6ca3dc53e515a6084bbe008c07", "patch": "@@ -0,0 +1,29 @@\n+error[E0412]: cannot find type `NotDefined` in this scope\n+  --> $DIR/issue-50480.rs:13:12\n+   |\n+LL | struct Foo(NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n+   |            ^^^^^^^^^^ not found in this scope\n+\n+error[E0277]: the trait bound `i32: std::iter::Iterator` is not satisfied\n+  --> $DIR/issue-50480.rs:13:24\n+   |\n+LL | struct Foo(NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^ `i32` is not an iterator; maybe try calling `.iter()` or a similar method\n+   |\n+   = help: the trait `std::iter::Iterator` is not implemented for `i32`\n+\n+error[E0204]: the trait `Copy` may not be implemented for this type\n+  --> $DIR/issue-50480.rs:11:17\n+   |\n+LL | #[derive(Clone, Copy)]\n+   |                 ^^^^\n+LL | //~^ ERROR the trait `Copy` may not be implemented for this type\n+LL | struct Foo(NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n+   |                                                 --------  ------ this field does not implement `Copy`\n+   |                                                 |\n+   |                                                 this field does not implement `Copy`\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors occurred: E0204, E0277, E0412.\n+For more information about an error, try `rustc --explain E0204`."}]}