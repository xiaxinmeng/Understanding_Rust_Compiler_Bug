{"sha": "928a295718d252a908bffcbde747550510407a10", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyOGEyOTU3MThkMjUyYTkwOGJmZmNiZGU3NDc1NTA1MTA0MDdhMTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-08T03:02:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-08T03:02:35Z"}, "message": "Auto merge of #44983 - vitiral:dirty_clean_groups, r=michaelwoerister\n\ngroundwork for rustc_clean/dirty improvements\n\nThis is a WIP PR that needs mentoring from @michaelwoerister.\n\nThere are several TODOs but no outstanding questions (except for the main one -- **is this the right approach?**)\n\nThis is the plumbing for supporing groups in `rustc_clean(labels=\"...\")`, as well as supporting an `except=\"...\"` which will remove the excepted labels in the \"clean\" check and then assert that they are dirty (this is still TODO).\n\nSee the code TODO's and example comments for a rough design.\n\nI'd like to know if this is the design you would like to do, and then I can go about actually filling out the groups and implementing the remaining logic.", "tree": {"sha": "b58a351068007bfd4ae69c032623a564ade82516", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b58a351068007bfd4ae69c032623a564ade82516"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/928a295718d252a908bffcbde747550510407a10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/928a295718d252a908bffcbde747550510407a10", "html_url": "https://github.com/rust-lang/rust/commit/928a295718d252a908bffcbde747550510407a10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/928a295718d252a908bffcbde747550510407a10/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f47f53c9f4f14fc276f3c83be1eefec057d5ec0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f47f53c9f4f14fc276f3c83be1eefec057d5ec0b", "html_url": "https://github.com/rust-lang/rust/commit/f47f53c9f4f14fc276f3c83be1eefec057d5ec0b"}, {"sha": "ad9b1ed9c286d26666b7892145c5cae7f98488bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad9b1ed9c286d26666b7892145c5cae7f98488bc", "html_url": "https://github.com/rust-lang/rust/commit/ad9b1ed9c286d26666b7892145c5cae7f98488bc"}], "stats": {"total": 76, "additions": 64, "deletions": 12}, "files": [{"sha": "cbe69afd57fd25e239e67535af920cf36969df50", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/928a295718d252a908bffcbde747550510407a10/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928a295718d252a908bffcbde747550510407a10/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=928a295718d252a908bffcbde747550510407a10", "patch": "@@ -339,6 +339,25 @@ macro_rules! define_dep_nodes {\n                     Ok(DepNode::new_no_params(kind))\n                 }\n             }\n+\n+            /// Used in testing\n+            pub fn has_label_string(label: &str) -> bool {\n+                match label {\n+                    $(\n+                        stringify!($variant) => true,\n+                    )*\n+                    _ => false,\n+                }\n+            }\n+        }\n+\n+        /// Contains variant => str representations for constructing\n+        /// DepNode groups for tests.\n+        #[allow(dead_code, non_upper_case_globals)]\n+        pub mod label_strs {\n+           $(\n+                pub const $variant: &'static str = stringify!($variant);\n+            )*\n         }\n     );\n }"}, {"sha": "0270e3618e24fcd6ab31d5f54fedecc4c1ccdab0", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 45, "deletions": 12, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/928a295718d252a908bffcbde747550510407a10/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/928a295718d252a908bffcbde747550510407a10/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=928a295718d252a908bffcbde747550510407a10", "patch": "@@ -39,6 +39,8 @@\n //! previous revision to compare things to.\n //!\n \n+use std::collections::HashSet;\n+use std::vec::Vec;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -54,6 +56,8 @@ use rustc::ty::TyCtxt;\n const LABEL: &'static str = \"label\";\n const CFG: &'static str = \"cfg\";\n \n+type Labels = HashSet<String>;\n+\n pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // can't add `#[rustc_dirty]` etc without opting in to this feature\n     if !tcx.sess.features.borrow().rustc_attrs {\n@@ -87,23 +91,46 @@ pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n }\n \n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n-    fn dep_node(&self, attr: &Attribute, def_id: DefId) -> DepNode {\n-        let def_path_hash = self.tcx.def_path_hash(def_id);\n+    fn labels(&self, attr: &Attribute) -> Labels {\n         for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n             if item.check_name(LABEL) {\n                 let value = expect_associated_value(self.tcx, &item);\n-                match DepNode::from_label_string(&value.as_str(), def_path_hash) {\n-                    Ok(dep_node) => return dep_node,\n-                    Err(()) => {\n-                        self.tcx.sess.span_fatal(\n-                            item.span,\n-                            &format!(\"dep-node label `{}` not recognized\", value));\n-                    }\n+                return self.resolve_labels(&item, value.as_str().as_ref());\n+            }\n+        }\n+        self.tcx.sess.span_fatal(attr.span, \"no `label` found\");\n+    }\n+\n+    fn resolve_labels(&self, item: &NestedMetaItem, value: &str) -> Labels {\n+        let mut out: Labels = HashSet::new();\n+        for label in value.split(',') {\n+            let label = label.trim();\n+            if DepNode::has_label_string(label) {\n+                if out.contains(label) {\n+                    self.tcx.sess.span_fatal(\n+                        item.span,\n+                        &format!(\"dep-node label `{}` is repeated\", label));\n                 }\n+                out.insert(label.to_string());\n+            } else {\n+                self.tcx.sess.span_fatal(\n+                    item.span,\n+                    &format!(\"dep-node label `{}` not recognized\", label));\n             }\n         }\n+        out\n+    }\n \n-        self.tcx.sess.span_fatal(attr.span, \"no `label` found\");\n+    fn dep_nodes(&self, labels: &Labels, def_id: DefId) -> Vec<DepNode> {\n+        let mut out = Vec::with_capacity(labels.len());\n+        let def_path_hash = self.tcx.def_path_hash(def_id);\n+        for label in labels.iter() {\n+            match DepNode::from_label_string(label, def_path_hash) {\n+                Ok(dep_node) => out.push(dep_node),\n+                Err(()) => unreachable!(),\n+            }\n+        }\n+        out\n     }\n \n     fn dep_node_str(&self, dep_node: &DepNode) -> String {\n@@ -150,12 +177,18 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n             if attr.check_name(ATTR_DIRTY) {\n                 if check_config(self.tcx, attr) {\n                     self.checked_attrs.insert(attr.id);\n-                    self.assert_dirty(item_span, self.dep_node(attr, def_id));\n+                    let labels = self.labels(attr);\n+                    for dep_node in self.dep_nodes(&labels, def_id) {\n+                        self.assert_dirty(item_span, dep_node);\n+                    }\n                 }\n             } else if attr.check_name(ATTR_CLEAN) {\n                 if check_config(self.tcx, attr) {\n                     self.checked_attrs.insert(attr.id);\n-                    self.assert_clean(item_span, self.dep_node(attr, def_id));\n+                    let labels = self.labels(attr);\n+                    for dep_node in self.dep_nodes(&labels, def_id) {\n+                        self.assert_clean(item_span, dep_node);\n+                    }\n                 }\n             }\n         }"}]}