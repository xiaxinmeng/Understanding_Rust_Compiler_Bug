{"sha": "be23bd47b771de902d6c0b79ef1dfbdb869b7109", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMjNiZDQ3Yjc3MWRlOTAyZDZjMGI3OWVmMWRmYmRiODY5YjcxMDk=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-06-15T16:37:19Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-06-25T21:41:22Z"}, "message": "Unify `return`, `break` and `continue` handling", "tree": {"sha": "f85c3ffc5943d3fb5342fcb6a5446a1b8c421733", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f85c3ffc5943d3fb5342fcb6a5446a1b8c421733"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be23bd47b771de902d6c0b79ef1dfbdb869b7109", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be23bd47b771de902d6c0b79ef1dfbdb869b7109", "html_url": "https://github.com/rust-lang/rust/commit/be23bd47b771de902d6c0b79ef1dfbdb869b7109", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be23bd47b771de902d6c0b79ef1dfbdb869b7109/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82a1a89d55305351a428247a7ad90dee77d85f04", "url": "https://api.github.com/repos/rust-lang/rust/commits/82a1a89d55305351a428247a7ad90dee77d85f04", "html_url": "https://github.com/rust-lang/rust/commit/82a1a89d55305351a428247a7ad90dee77d85f04"}], "stats": {"total": 381, "additions": 200, "deletions": 181}, "files": [{"sha": "cf3d8778da19366db21d46aa1323fd709ec2e555", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 4, "deletions": 61, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/be23bd47b771de902d6c0b79ef1dfbdb869b7109/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be23bd47b771de902d6c0b79ef1dfbdb869b7109/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=be23bd47b771de902d6c0b79ef1dfbdb869b7109", "patch": "@@ -1,4 +1,4 @@\n-use crate::build::scope::BreakableScope;\n+use crate::build::scope::BreakableTarget;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use crate::hair::*;\n use rustc::middle::region;\n@@ -98,70 +98,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block.unit()\n             }\n             ExprKind::Continue { label } => {\n-                let BreakableScope {\n-                    continue_block,\n-                    region_scope,\n-                    ..\n-                } = *this.find_breakable_scope(expr_span, label);\n-                let continue_block = continue_block\n-                    .expect(\"Attempted to continue in non-continuable breakable block\");\n-                this.exit_scope(\n-                    expr_span,\n-                    (region_scope, source_info),\n-                    block,\n-                    continue_block,\n-                );\n-                this.cfg.start_new_block().unit()\n+                this.break_scope(block, None, BreakableTarget::Continue(label), source_info)\n             }\n             ExprKind::Break { label, value } => {\n-                let (break_block, region_scope, destination) = {\n-                    let BreakableScope {\n-                        break_block,\n-                        region_scope,\n-                        ref break_destination,\n-                        ..\n-                    } = *this.find_breakable_scope(expr_span, label);\n-                    (break_block, region_scope, break_destination.clone())\n-                };\n-                if let Some(value) = value {\n-                    debug!(\"stmt_expr Break val block_context.push(SubExpr) : {:?}\", expr2);\n-                    this.block_context.push(BlockFrame::SubExpr);\n-                    unpack!(block = this.into(&destination, block, value));\n-                    this.block_context.pop();\n-                } else {\n-                    this.cfg.push_assign_unit(block, source_info, &destination)\n-                }\n-                this.exit_scope(expr_span, (region_scope, source_info), block, break_block);\n-                this.cfg.start_new_block().unit()\n+                this.break_scope(block, value, BreakableTarget::Break(label), source_info)\n             }\n             ExprKind::Return { value } => {\n-                block = match value {\n-                    Some(value) => {\n-                        debug!(\"stmt_expr Return val block_context.push(SubExpr) : {:?}\", expr2);\n-                        this.block_context.push(BlockFrame::SubExpr);\n-                        let result = unpack!(\n-                            this.into(\n-                                &Place::RETURN_PLACE,\n-                                block,\n-                                value\n-                            )\n-                        );\n-                        this.block_context.pop();\n-                        result\n-                    }\n-                    None => {\n-                        this.cfg.push_assign_unit(\n-                            block,\n-                            source_info,\n-                            &Place::RETURN_PLACE,\n-                        );\n-                        block\n-                    }\n-                };\n-                let region_scope = this.region_scope_of_return_scope();\n-                let return_block = this.return_block();\n-                this.exit_scope(expr_span, (region_scope, source_info), block, return_block);\n-                this.cfg.start_new_block().unit()\n+                this.break_scope(block, value, BreakableTarget::Return, source_info)\n             }\n             ExprKind::InlineAsm {\n                 asm,"}, {"sha": "ff4841cb57fbda91b705bb7fd532105eda71ff24", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/be23bd47b771de902d6c0b79ef1dfbdb869b7109/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be23bd47b771de902d6c0b79ef1dfbdb869b7109/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=be23bd47b771de902d6c0b79ef1dfbdb869b7109", "patch": "@@ -251,7 +251,7 @@ struct Builder<'a, 'tcx> {\n \n     /// The current set of scopes, updated as we traverse;\n     /// see the `scope` module for more details.\n-    scopes: Vec<scope::Scope<'tcx>>,\n+    scopes: scope::Scopes<'tcx>,\n \n     /// The block-context: each time we build the code within an hair::Block,\n     /// we push a frame here tracking whether we are building a statement or\n@@ -274,10 +274,6 @@ struct Builder<'a, 'tcx> {\n     /// The number of `push_unsafe_block` levels in scope.\n     push_unsafe_count: usize,\n \n-    /// The current set of breakables; see the `scope` module for more\n-    /// details.\n-    breakable_scopes: Vec<scope::BreakableScope<'tcx>>,\n-\n     /// The vector of all scopes that we have created thus far;\n     /// we track this for debuginfo later.\n     source_scopes: IndexVec<SourceScope, SourceScopeData>,\n@@ -714,15 +710,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             fn_span: span,\n             arg_count,\n             is_generator,\n-            scopes: vec![],\n+            scopes: Default::default(),\n             block_context: BlockContext::new(),\n             source_scopes: IndexVec::new(),\n             source_scope: OUTERMOST_SOURCE_SCOPE,\n             source_scope_local_data: IndexVec::new(),\n             guard_context: vec![],\n             push_unsafe_count: 0,\n             unpushed_unsafe: safety,\n-            breakable_scopes: vec![],\n             local_decls: IndexVec::from_elem_n(\n                 LocalDecl::new_return_place(return_ty, return_span),\n                 1,\n@@ -865,7 +860,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         let body = self.hir.mirror(ast_body);\n-        self.into(&Place::RETURN_PLACE, block, body)\n+        // `return_block` is called when we evaluate a `return` expression, so\n+        // we just use `START_BLOCK` here.\n+        self.in_breakable_scope(None, START_BLOCK, Place::RETURN_PLACE, |this| {\n+            this.into(&Place::RETURN_PLACE, block, body)\n+        })\n     }\n \n     fn get_unit_temp(&mut self) -> Place<'tcx> {"}, {"sha": "32b69082557b53fae6a79a1bcdf4d220d1a3193f", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 189, "deletions": 112, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/be23bd47b771de902d6c0b79ef1dfbdb869b7109/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be23bd47b771de902d6c0b79ef1dfbdb869b7109/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=be23bd47b771de902d6c0b79ef1dfbdb869b7109", "patch": "@@ -82,8 +82,8 @@ should go to.\n \n */\n \n-use crate::build::{BlockAnd, BlockAndExtension, Builder, CFG};\n-use crate::hair::LintLevel;\n+use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder, CFG};\n+use crate::hair::{ExprRef, LintLevel};\n use rustc::middle::region;\n use rustc::ty::Ty;\n use rustc::hir;\n@@ -94,7 +94,7 @@ use std::collections::hash_map::Entry;\n use std::mem;\n \n #[derive(Debug)]\n-pub struct Scope<'tcx> {\n+struct Scope<'tcx> {\n     /// The source scope this scope was created in.\n     source_scope: SourceScope,\n \n@@ -133,6 +133,13 @@ pub struct Scope<'tcx> {\n     cached_unwind: CachedBlock,\n }\n \n+#[derive(Debug, Default)]\n+pub struct Scopes<'tcx> {\n+    scopes: Vec<Scope<'tcx>>,\n+    /// The current set of breakable scopes. See module comment for more details.\n+    breakable_scopes: Vec<BreakableScope<'tcx>>,\n+}\n+\n #[derive(Debug)]\n struct DropData<'tcx> {\n     /// span where drop obligation was incurred (typically where place was declared)\n@@ -172,17 +179,25 @@ pub(crate) enum DropKind {\n }\n \n #[derive(Clone, Debug)]\n-pub struct BreakableScope<'tcx> {\n+struct BreakableScope<'tcx> {\n     /// Region scope of the loop\n-    pub region_scope: region::Scope,\n+    region_scope: region::Scope,\n     /// Where the body of the loop begins. `None` if block\n-    pub continue_block: Option<BasicBlock>,\n+    continue_block: Option<BasicBlock>,\n     /// Block to branch into when the loop or block terminates (either by being `break`-en out\n     /// from, or by having its condition to become false)\n-    pub break_block: BasicBlock,\n+    break_block: BasicBlock,\n     /// The destination of the loop/block expression itself (i.e., where to put the result of a\n     /// `break` expression)\n-    pub break_destination: Place<'tcx>,\n+    break_destination: Place<'tcx>,\n+}\n+\n+/// The target of an expression that breaks out of a scope\n+#[derive(Clone, Copy, Debug)]\n+pub enum BreakableTarget {\n+    Continue(region::Scope),\n+    Break(region::Scope),\n+    Return,\n }\n \n impl CachedBlock {\n@@ -208,15 +223,6 @@ impl CachedBlock {\n     }\n }\n \n-impl DropKind {\n-    fn may_panic(&self) -> bool {\n-        match *self {\n-            DropKind::Value => true,\n-            DropKind::Storage => false\n-        }\n-    }\n-}\n-\n impl<'tcx> Scope<'tcx> {\n     /// Invalidates all the cached blocks in the scope.\n     ///\n@@ -257,30 +263,128 @@ impl<'tcx> Scope<'tcx> {\n     }\n }\n \n+impl<'tcx> Scopes<'tcx> {\n+    fn len(&self) -> usize {\n+        self.scopes.len()\n+    }\n+\n+    fn push_scope(&mut self, region_scope: (region::Scope, SourceInfo), vis_scope: SourceScope) {\n+        debug!(\"push_scope({:?})\", region_scope);\n+        self.scopes.push(Scope {\n+            source_scope: vis_scope,\n+            region_scope: region_scope.0,\n+            region_scope_span: region_scope.1.span,\n+            needs_cleanup: false,\n+            drops: vec![],\n+            cached_generator_drop: None,\n+            cached_exits: Default::default(),\n+            cached_unwind: CachedBlock::default(),\n+        });\n+    }\n+\n+    fn pop_scope(\n+        &mut self,\n+        region_scope: (region::Scope, SourceInfo),\n+    ) -> (Scope<'tcx>, Option<BasicBlock>) {\n+        let scope = self.scopes.pop().unwrap();\n+        assert_eq!(scope.region_scope, region_scope.0);\n+        let unwind_to = self.scopes.last()\n+            .and_then(|next_scope| next_scope.cached_unwind.get(false));\n+        (scope, unwind_to)\n+    }\n+\n+    fn may_panic(&self, scope_count: usize) -> bool {\n+        let len = self.len();\n+        self.scopes[(len - scope_count)..].iter().any(|s| s.needs_cleanup)\n+    }\n+\n+    /// Finds the breakable scope for a given label. This is used for\n+    /// resolving `return`, `break` and `continue`.\n+    fn find_breakable_scope(\n+        &self,\n+        span: Span,\n+        target: BreakableTarget,\n+    ) -> (BasicBlock, region::Scope, Option<Place<'tcx>>) {\n+        let get_scope = |scope: region::Scope| {\n+            // find the loop-scope by its `region::Scope`.\n+            self.breakable_scopes.iter()\n+                .rfind(|breakable_scope| breakable_scope.region_scope == scope)\n+                .unwrap_or_else(|| span_bug!(span, \"no enclosing breakable scope found\"))\n+        };\n+        match target {\n+            BreakableTarget::Return => {\n+                let scope = &self.breakable_scopes[0];\n+                if scope.break_destination != Place::RETURN_PLACE {\n+                    span_bug!(span, \"`return` in item with no return scope\");\n+                }\n+                (scope.break_block, scope.region_scope, Some(scope.break_destination.clone()))\n+            }\n+            BreakableTarget::Break(scope) => {\n+                let scope = get_scope(scope);\n+                (scope.break_block, scope.region_scope, Some(scope.break_destination.clone()))\n+            }\n+            BreakableTarget::Continue(scope) => {\n+                let scope = get_scope(scope);\n+                let continue_block = scope.continue_block\n+                    .unwrap_or_else(|| span_bug!(span, \"missing `continue` block\"));\n+                (continue_block, scope.region_scope, None)\n+            }\n+        }\n+    }\n+\n+    fn num_scopes_to(&self, region_scope: (region::Scope, SourceInfo), span: Span) -> usize {\n+        let scope_count = 1 + self.scopes.iter().rev()\n+            .position(|scope| scope.region_scope == region_scope.0)\n+            .unwrap_or_else(|| {\n+                span_bug!(span, \"region_scope {:?} does not enclose\", region_scope)\n+            });\n+        let len = self.len();\n+        assert!(scope_count < len, \"should not use `exit_scope` to pop ALL scopes\");\n+        scope_count\n+    }\n+\n+    fn iter_mut(&mut self) -> impl DoubleEndedIterator<Item=&mut Scope<'tcx>> + '_ {\n+        self.scopes.iter_mut().rev()\n+    }\n+\n+    fn top_scopes(&mut self, count: usize) -> impl DoubleEndedIterator<Item=&mut Scope<'tcx>> + '_ {\n+        let len = self.len();\n+        self.scopes[len - count..].iter_mut()\n+    }\n+\n+    /// Returns the topmost active scope, which is known to be alive until\n+    /// the next scope expression.\n+    fn topmost(&self) -> region::Scope {\n+        self.scopes.last().expect(\"topmost_scope: no scopes present\").region_scope\n+    }\n+\n+    fn source_info(&self, index: usize, span: Span) -> SourceInfo {\n+        self.scopes[self.len() - index].source_info(span)\n+    }\n+}\n+\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     // Adding and removing scopes\n     // ==========================\n-    /// Start a breakable scope, which tracks where `continue` and `break`\n-    /// should branch to. See module comment for more details.\n-    ///\n-    /// Returns the might_break attribute of the BreakableScope used.\n+    //  Start a breakable scope, which tracks where `continue`, `break` and\n+    //  `return` should branch to.\n     pub fn in_breakable_scope<F, R>(&mut self,\n                                     loop_block: Option<BasicBlock>,\n                                     break_block: BasicBlock,\n                                     break_destination: Place<'tcx>,\n                                     f: F) -> R\n         where F: FnOnce(&mut Builder<'a, 'tcx>) -> R\n     {\n-        let region_scope = self.topmost_scope();\n+        let region_scope = self.scopes.topmost();\n         let scope = BreakableScope {\n             region_scope,\n             continue_block: loop_block,\n             break_block,\n             break_destination,\n         };\n-        self.breakable_scopes.push(scope);\n+        self.scopes.breakable_scopes.push(scope);\n         let res = f(self);\n-        let breakable_scope = self.breakable_scopes.pop().unwrap();\n+        let breakable_scope = self.scopes.breakable_scopes.pop().unwrap();\n         assert!(breakable_scope.region_scope == region_scope);\n         res\n     }\n@@ -350,18 +454,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// calls must be paired; using `in_scope` as a convenience\n     /// wrapper maybe preferable.\n     pub fn push_scope(&mut self, region_scope: (region::Scope, SourceInfo)) {\n-        debug!(\"push_scope({:?})\", region_scope);\n-        let vis_scope = self.source_scope;\n-        self.scopes.push(Scope {\n-            source_scope: vis_scope,\n-            region_scope: region_scope.0,\n-            region_scope_span: region_scope.1.span,\n-            needs_cleanup: false,\n-            drops: vec![],\n-            cached_generator_drop: None,\n-            cached_exits: Default::default(),\n-            cached_unwind: CachedBlock::default(),\n-        });\n+        self.scopes.push_scope(region_scope, self.source_scope);\n     }\n \n     /// Pops a scope, which should have region scope `region_scope`,\n@@ -374,17 +467,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         debug!(\"pop_scope({:?}, {:?})\", region_scope, block);\n         // If we are emitting a `drop` statement, we need to have the cached\n         // diverge cleanup pads ready in case that drop panics.\n-        let may_panic =\n-            self.scopes.last().unwrap().drops.iter().any(|s| s.kind.may_panic());\n-        if may_panic {\n+        if self.scopes.may_panic(1) {\n             self.diverge_cleanup();\n         }\n-        let scope = self.scopes.pop().unwrap();\n-        assert_eq!(scope.region_scope, region_scope.0);\n-\n-        let unwind_to = self.scopes.last().and_then(|next_scope| {\n-            next_scope.cached_unwind.get(false)\n-        }).unwrap_or_else(|| self.resume_block());\n+        let (scope, unwind_to) = self.scopes.pop_scope(region_scope);\n+        let unwind_to = unwind_to.unwrap_or_else(|| self.resume_block());\n \n         unpack!(block = build_scope_drops(\n             &mut self.cfg,\n@@ -399,6 +486,37 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         block.unit()\n     }\n \n+    pub fn break_scope(\n+        &mut self,\n+        mut block: BasicBlock,\n+        value: Option<ExprRef<'tcx>>,\n+        scope: BreakableTarget,\n+        source_info: SourceInfo,\n+    ) -> BlockAnd<()> {\n+        let (mut target_block, region_scope, destination)\n+            = self.scopes.find_breakable_scope(source_info.span, scope);\n+        if let BreakableTarget::Return = scope {\n+            // We call this now, rather than when we start lowering the\n+            // function so that the return block doesn't precede the entire\n+            // rest of the CFG. Some passes and LLVM prefer blocks to be in\n+            // approximately CFG order.\n+            target_block = self.return_block();\n+        }\n+        if let Some(destination) = destination {\n+            if let Some(value) = value {\n+                debug!(\"stmt_expr Break val block_context.push(SubExpr)\");\n+                self.block_context.push(BlockFrame::SubExpr);\n+                unpack!(block = self.into(&destination, block, value));\n+                self.block_context.pop();\n+            } else {\n+                self.cfg.push_assign_unit(block, source_info, &destination)\n+            }\n+        } else {\n+            assert!(value.is_none(), \"`return` and `break` should have a destination\");\n+        }\n+        self.exit_scope(source_info.span, (region_scope, source_info), block, target_block);\n+        self.cfg.start_new_block().unit()\n+    }\n \n     /// Branch out of `block` to `target`, exiting all scopes up to\n     /// and including `region_scope`. This will insert whatever drops are\n@@ -410,22 +528,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                       target: BasicBlock) {\n         debug!(\"exit_scope(region_scope={:?}, block={:?}, target={:?})\",\n                region_scope, block, target);\n-        let scope_count = 1 + self.scopes.iter().rev()\n-            .position(|scope| scope.region_scope == region_scope.0)\n-            .unwrap_or_else(|| {\n-                span_bug!(span, \"region_scope {:?} does not enclose\", region_scope)\n-            });\n-        let len = self.scopes.len();\n-        assert!(scope_count < len, \"should not use `exit_scope` to pop ALL scopes\");\n+        let scope_count = self.scopes.num_scopes_to(region_scope, span);\n \n         // If we are emitting a `drop` statement, we need to have the cached\n         // diverge cleanup pads ready in case that drop panics.\n-        let may_panic = self.scopes[(len - scope_count)..].iter().any(|s| s.needs_cleanup);\n+        let may_panic = self.scopes.may_panic(scope_count);\n         if may_panic {\n             self.diverge_cleanup();\n         }\n \n-        let mut scopes = self.scopes[(len - scope_count - 1)..].iter_mut().rev();\n+        let mut scopes = self.scopes.top_scopes(scope_count + 1).rev();\n         let mut scope = scopes.next().unwrap();\n         for next_scope in scopes {\n             if scope.drops.is_empty() {\n@@ -466,9 +578,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             scope = next_scope;\n         }\n \n-        let scope = &self.scopes[len - scope_count];\n-        self.cfg.terminate(block, scope.source_info(span),\n-                           TerminatorKind::Goto { target });\n+        let source_info = self.scopes.source_info(scope_count, span);\n+        self.cfg.terminate(block, source_info, TerminatorKind::Goto { target });\n     }\n \n     /// Creates a path that performs all required cleanup for dropping a generator.\n@@ -479,9 +590,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Fill in the cache for unwinds\n         self.diverge_cleanup_gen(true);\n \n-        let src_info = self.scopes[0].source_info(self.fn_span);\n+        let src_info = self.scopes.source_info(self.scopes.len(), self.fn_span);\n         let resume_block = self.resume_block();\n-        let mut scopes = self.scopes.iter_mut().rev().peekable();\n+        let mut scopes = self.scopes.iter_mut().peekable();\n         let mut block = self.cfg.start_new_block();\n         let result = block;\n \n@@ -547,22 +658,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         scope\n     }\n \n-    // Finding scopes\n-    // ==============\n-    /// Finds the breakable scope for a given label. This is used for\n-    /// resolving `break` and `continue`.\n-    pub fn find_breakable_scope(&self,\n-                                span: Span,\n-                                label: region::Scope)\n-                                -> &BreakableScope<'tcx> {\n-        // find the loop-scope with the correct id\n-        self.breakable_scopes.iter()\n-            .rev()\n-            .filter(|breakable_scope| breakable_scope.region_scope == label)\n-            .next()\n-            .unwrap_or_else(|| span_bug!(span, \"no enclosing breakable scope found\"))\n-    }\n-\n     /// Given a span and the current source scope, make a SourceInfo.\n     pub fn source_info(&self, span: Span) -> SourceInfo {\n         SourceInfo {\n@@ -571,25 +666,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    /// Returns the `region::Scope` of the scope which should be exited by a\n-    /// return.\n-    pub fn region_scope_of_return_scope(&self) -> region::Scope {\n-        // The outermost scope (`scopes[0]`) will be the `CallSiteScope`.\n-        // We want `scopes[1]`, which is the `ParameterScope`.\n-        assert!(self.scopes.len() >= 2);\n-        assert!(match self.scopes[1].region_scope.data {\n-            region::ScopeData::Arguments => true,\n-            _ => false,\n-        });\n-        self.scopes[1].region_scope\n-    }\n-\n-    /// Returns the topmost active scope, which is known to be alive until\n-    /// the next scope expression.\n-    pub fn topmost_scope(&self) -> region::Scope {\n-        self.scopes.last().expect(\"topmost_scope: no scopes present\").region_scope\n-    }\n-\n+    // Finding scopes\n+    // ==============\n     /// Returns the scope that we should use as the lifetime of an\n     /// operand. Basically, an operand must live until it is consumed.\n     /// This is similar to, but not quite the same as, the temporary\n@@ -620,20 +698,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 None,\n             hir::BodyOwnerKind::Closure |\n             hir::BodyOwnerKind::Fn =>\n-                Some(self.topmost_scope()),\n+                Some(self.scopes.topmost()),\n         }\n     }\n \n     // Schedule an abort block - this is used for some ABIs that cannot unwind\n     pub fn schedule_abort(&mut self) -> BasicBlock {\n-        self.scopes[0].needs_cleanup = true;\n+        let source_info = self.scopes.source_info(self.scopes.len(), self.fn_span);\n         let abortblk = self.cfg.start_new_cleanup_block();\n-        let source_info = self.scopes[0].source_info(self.fn_span);\n         self.cfg.terminate(abortblk, source_info, TerminatorKind::Abort);\n         self.cached_resume_block = Some(abortblk);\n         abortblk\n     }\n \n+    // Scheduling drops\n+    // ================\n     pub fn schedule_drop_storage_and_value(\n         &mut self,\n         span: Span,\n@@ -645,8 +724,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.schedule_drop(span, region_scope, place, place_ty, DropKind::Value);\n     }\n \n-    // Scheduling drops\n-    // ================\n     /// Indicates that `place` should be dropped on exit from\n     /// `region_scope`.\n     ///\n@@ -679,7 +756,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n-        for scope in self.scopes.iter_mut().rev() {\n+        for scope in self.scopes.iter_mut() {\n             let this_scope = scope.region_scope == region_scope;\n             // When building drops, we try to cache chains of drops in such a way so these drops\n             // could be reused by the drops which would branch into the cached (already built)\n@@ -790,14 +867,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         // Find the last cached block\n         debug!(\"diverge_cleanup_gen(self.scopes = {:?})\", self.scopes);\n-        let (mut target, first_uncached) = if let Some(cached_index) = self.scopes.iter()\n-            .rposition(|scope| scope.cached_unwind.get(generator_drop).is_some()) {\n-            (self.scopes[cached_index].cached_unwind.get(generator_drop).unwrap(), cached_index + 1)\n-        } else {\n-            (self.resume_block(), 0)\n-        };\n+        let cached_cleanup = self.scopes.iter_mut().enumerate()\n+            .find_map(|(idx, ref scope)| {\n+                let cached_block = scope.cached_unwind.get(generator_drop)?;\n+                Some((cached_block, idx))\n+            });\n+        let (mut target, first_uncached) = cached_cleanup\n+            .unwrap_or_else(|| (self.resume_block(), self.scopes.len()));\n \n-        for scope in self.scopes[first_uncached..].iter_mut() {\n+        for scope in self.scopes.top_scopes(first_uncached) {\n             target = build_diverge_scope(&mut self.cfg, scope.region_scope_span,\n                                          scope, target, generator_drop, self.is_generator);\n         }\n@@ -856,8 +934,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// This is only needed for `match` arm scopes, because they have one\n     /// entrance per pattern, but only one exit.\n-    pub fn clear_top_scope(&mut self, region_scope: region::Scope) {\n-        let top_scope = self.scopes.last_mut().unwrap();\n+    pub(crate) fn clear_top_scope(&mut self, region_scope: region::Scope) {\n+        let top_scope = self.scopes.scopes.last_mut().unwrap();\n \n         assert_eq!(top_scope.region_scope, region_scope);\n \n@@ -880,13 +958,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// * There is only one exit for the arm scope\n     /// * The guard expression scope is too short, it ends just before the\n     ///   boolean is tested.\n-    pub fn pop_variable(\n+    pub(crate) fn pop_variable(\n         &mut self,\n         block: BasicBlock,\n         region_scope: region::Scope,\n         variable: Local,\n     ) {\n-        let top_scope = self.scopes.last_mut().unwrap();\n+        let top_scope = self.scopes.scopes.last_mut().unwrap();\n \n         assert_eq!(top_scope.region_scope, region_scope);\n \n@@ -915,7 +993,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         top_scope.invalidate_cache(true, self.is_generator, true);\n     }\n-\n }\n \n /// Builds drops for pop_scope and exit_scope."}]}