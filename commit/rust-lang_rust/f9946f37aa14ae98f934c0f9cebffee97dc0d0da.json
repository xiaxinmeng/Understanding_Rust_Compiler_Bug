{"sha": "f9946f37aa14ae98f934c0f9cebffee97dc0d0da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5OTQ2ZjM3YWExNGFlOThmOTM0YzBmOWNlYmZmZWU5N2RjMGQwZGE=", "commit": {"author": {"name": "Daniel Patterson", "email": "dbp@riseup.net", "date": "2012-08-09T23:31:47Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-11T20:04:50Z"}, "message": "syntax: better formatting of closures in pretty printer and more verbose debugging messages", "tree": {"sha": "6f469603c052e3658af5dbde8e2b2aff492a0a17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f469603c052e3658af5dbde8e2b2aff492a0a17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9946f37aa14ae98f934c0f9cebffee97dc0d0da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9946f37aa14ae98f934c0f9cebffee97dc0d0da", "html_url": "https://github.com/rust-lang/rust/commit/f9946f37aa14ae98f934c0f9cebffee97dc0d0da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9946f37aa14ae98f934c0f9cebffee97dc0d0da/comments", "author": null, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06b2804c2790243cdd049dfd50ff4197fa59926f", "url": "https://api.github.com/repos/rust-lang/rust/commits/06b2804c2790243cdd049dfd50ff4197fa59926f", "html_url": "https://github.com/rust-lang/rust/commit/06b2804c2790243cdd049dfd50ff4197fa59926f"}], "stats": {"total": 93, "additions": 72, "deletions": 21}, "files": [{"sha": "a04b5ebe3c94d8b467b8b1655fcaa41c2670ac25", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f9946f37aa14ae98f934c0f9cebffee97dc0d0da/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9946f37aa14ae98f934c0f9cebffee97dc0d0da/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=f9946f37aa14ae98f934c0f9cebffee97dc0d0da", "patch": "@@ -254,7 +254,8 @@ impl printer {\n                 self.left = 0u;\n                 self.right = 0u;\n             } else { self.advance_right(); }\n-            debug!{\"pp BEGIN/buffer ~[%u,%u]\", self.left, self.right};\n+            debug!{\"pp BEGIN(%d)/buffer ~[%u,%u]\",\n+                   b.offset, self.left, self.right};\n             self.token[self.right] = t;\n             self.size[self.right] = -self.right_total;\n             self.scan_push(self.right);\n@@ -278,7 +279,8 @@ impl printer {\n                 self.left = 0u;\n                 self.right = 0u;\n             } else { self.advance_right(); }\n-            debug!{\"pp BREAK/buffer ~[%u,%u]\", self.left, self.right};\n+            debug!{\"pp BREAK(%d)/buffer ~[%u,%u]\",\n+                   b.offset, self.left, self.right};\n             self.check_stack(0);\n             self.scan_push(self.right);\n             self.token[self.right] = t;\n@@ -287,10 +289,12 @@ impl printer {\n           }\n           STRING(s, len) => {\n             if self.scan_stack_empty {\n-                debug!{\"pp STRING/print ~[%u,%u]\", self.left, self.right};\n+                debug!{\"pp STRING('%s')/print ~[%u,%u]\",\n+                       *s, self.left, self.right};\n                 self.print(t, len);\n             } else {\n-                debug!{\"pp STRING/buffer ~[%u,%u]\", self.left, self.right};\n+                debug!{\"pp STRING('%s')/buffer ~[%u,%u]\",\n+                       *s, self.left, self.right};\n                 self.advance_right();\n                 self.token[self.right] = t;\n                 self.size[self.right] = len;\n@@ -444,30 +448,33 @@ impl printer {\n             let top = self.get_top();\n             match top.pbreak {\n               fits => {\n-                debug!{\"print BREAK in fitting block\"};\n+                debug!{\"print BREAK(%d) in fitting block\", b.blank_space};\n                 self.space -= b.blank_space;\n                 self.indent(b.blank_space);\n               }\n               broken(consistent) => {\n-                debug!{\"print BREAK in consistent block\"};\n+                debug!{\"print BREAK(%d+%d) in consistent block\",\n+                       top.offset, b.offset};\n                 self.print_newline(top.offset + b.offset);\n                 self.space = self.margin - (top.offset + b.offset);\n               }\n               broken(inconsistent) => {\n                 if L > self.space {\n-                    debug!{\"print BREAK w/ newline in inconsistent\"};\n+                    debug!{\"print BREAK(%d+%d) w/ newline in inconsistent\",\n+                           top.offset, b.offset};\n                     self.print_newline(top.offset + b.offset);\n                     self.space = self.margin - (top.offset + b.offset);\n                 } else {\n-                    debug!{\"print BREAK w/o newline in inconsistent\"};\n+                    debug!{\"print BREAK(%d) w/o newline in inconsistent\",\n+                           b.blank_space};\n                     self.indent(b.blank_space);\n                     self.space -= b.blank_space;\n                 }\n               }\n             }\n           }\n           STRING(s, len) => {\n-            debug!{\"print STRING\"};\n+            debug!{\"print STRING(%s)\", *s};\n             assert (L == len);\n             // assert L <= space;\n             self.space -= len;"}, {"sha": "be4786e7b1d0d2f9cd34d551d1e4ddf2ae544c89", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 56, "deletions": 12, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f9946f37aa14ae98f934c0f9cebffee97dc0d0da/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9946f37aa14ae98f934c0f9cebffee97dc0d0da/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f9946f37aa14ae98f934c0f9cebffee97dc0d0da", "patch": "@@ -237,10 +237,16 @@ fn bopen(s: ps) {\n }\n \n fn bclose_(s: ps, span: codemap::span, indented: uint) {\n+    bclose_maybe_open(s, span, indented, true);\n+}\n+fn bclose_maybe_open (s: ps, span: codemap::span, indented: uint,\n+                     close_box: bool) {\n     maybe_print_comment(s, span.hi);\n     break_offset_if_not_bol(s, 1u, -(indented as int));\n     word(s.s, ~\"}\");\n-    end(s); // close the outer-box\n+    if close_box {\n+        end(s); // close the outer-box\n+    }\n }\n fn bclose(s: ps, span: codemap::span) { bclose_(s, span, indent_unit); }\n \n@@ -827,20 +833,27 @@ fn print_block(s: ps, blk: ast::blk) {\n     print_possibly_embedded_block(s, blk, block_normal, indent_unit);\n }\n \n+fn print_block_unclosed(s: ps, blk: ast::blk) {\n+    print_possibly_embedded_block_(s, blk, block_normal, indent_unit, ~[],\n+                                 false);\n+}\n+\n fn print_block_with_attrs(s: ps, blk: ast::blk, attrs: ~[ast::attribute]) {\n-    print_possibly_embedded_block_(s, blk, block_normal, indent_unit, attrs);\n+    print_possibly_embedded_block_(s, blk, block_normal, indent_unit, attrs,\n+                                  true);\n }\n \n enum embed_type { block_block_fn, block_normal, }\n \n fn print_possibly_embedded_block(s: ps, blk: ast::blk, embedded: embed_type,\n                                  indented: uint) {\n     print_possibly_embedded_block_(\n-        s, blk, embedded, indented, ~[]);\n+        s, blk, embedded, indented, ~[], true);\n }\n \n fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n-                                  indented: uint, attrs: ~[ast::attribute]) {\n+                                  indented: uint, attrs: ~[ast::attribute],\n+                                  close_box: bool) {\n     match blk.node.rules {\n       ast::unchecked_blk => word(s.s, ~\"unchecked\"),\n       ast::unsafe_blk => word(s.s, ~\"unsafe\"),\n@@ -868,7 +881,7 @@ fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n       }\n       _ => ()\n     }\n-    bclose_(s, blk.span, indented);\n+    bclose_maybe_open(s, blk.span, indented, close_box);\n     s.ann.post(ann_node);\n }\n \n@@ -1060,9 +1073,9 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         let blk = if has_block {\n             let blk_arg = vec::pop(base_args);\n             match blk_arg.node {\n-              ast::expr_loop_body(_) => word_nbsp(s, ~\"for\"),\n-              ast::expr_do_body(_) => word_nbsp(s, ~\"do\"),\n-              _ => ()\n+              ast::expr_loop_body(_) => { head(s, ~\"for\"); }\n+              ast::expr_do_body(_) => { head(s, ~\"do\"); }\n+              _ => {}\n             }\n             some(blk_arg)\n         } else { none };\n@@ -1074,7 +1087,19 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         }\n         if has_block {\n             nbsp(s);\n-            print_expr(s, option::get(blk));\n+            match blk.get().node {\n+              // need to handle closures specifically\n+              ast::expr_do_body(e) | ast::expr_loop_body(e) => {\n+                end(s); // we close our head box; closure\n+                        // will create it's own.\n+                print_expr(s, e);\n+                end(s); // close outer box, as closures don't\n+              }\n+              _ => {\n+                // not sure if this can happen.\n+                print_expr(s, blk.get());\n+              }\n+            }\n         }\n       }\n       ast::expr_binary(op, lhs, rhs) => {\n@@ -1174,12 +1199,31 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         print_block(s, body);\n       }\n       ast::expr_fn_block(decl, body, cap_clause) => {\n+        // in do/for blocks we don't want to show an empty\n+        // argument list, but at this point we don't know which\n+        // we are inside.\n+        //\n+        // if !decl.inputs.is_empty() {\n         print_fn_block_args(s, decl, *cap_clause);\n-        // The parser always adds an extra implicit block around lambdas\n+        space(s.s);\n+        // }\n         assert body.node.stmts.is_empty();\n         assert body.node.expr.is_some();\n-        space(s.s);\n-        print_expr(s, body.node.expr.get());\n+        // we extract the block, so as not to create another set of boxes\n+        match body.node.expr.get().node {\n+            ast::expr_block(blk) => {\n+                print_block_unclosed(s, blk);\n+            }\n+            _ => {\n+                // this is a bare expression\n+                print_expr(s, body.node.expr.get());\n+                end(s); // need to close a box\n+            }\n+        }\n+        // a box will be closed by print_expr, but we didn't want an overall\n+        // wrapper so we closed the corresponding opening. so create an\n+        // empty box to satisfy the close.\n+        ibox(s, 0);\n       }\n       ast::expr_loop_body(body) => {\n         print_expr(s, body);"}]}