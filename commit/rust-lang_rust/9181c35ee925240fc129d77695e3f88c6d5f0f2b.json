{"sha": "9181c35ee925240fc129d77695e3f88c6d5f0f2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxODFjMzVlZTkyNTI0MGZjMTI5ZDc3Njk1ZTNmODhjNmQ1ZjBmMmI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-24T01:47:01Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-25T08:18:10Z"}, "message": "rustdoc: Inline names of function arguments", "tree": {"sha": "a75a9e72c1dcea25a8464064276d52442ddf1b24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a75a9e72c1dcea25a8464064276d52442ddf1b24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9181c35ee925240fc129d77695e3f88c6d5f0f2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9181c35ee925240fc129d77695e3f88c6d5f0f2b", "html_url": "https://github.com/rust-lang/rust/commit/9181c35ee925240fc129d77695e3f88c6d5f0f2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9181c35ee925240fc129d77695e3f88c6d5f0f2b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ee9109c8b1eb170b7fb6fac6d248801dcd42817", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ee9109c8b1eb170b7fb6fac6d248801dcd42817", "html_url": "https://github.com/rust-lang/rust/commit/6ee9109c8b1eb170b7fb6fac6d248801dcd42817"}], "stats": {"total": 75, "additions": 44, "deletions": 31}, "files": [{"sha": "b12de2aee09f572e265c9079aba048c668b0797f", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9181c35ee925240fc129d77695e3f88c6d5f0f2b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9181c35ee925240fc129d77695e3f88c6d5f0f2b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9181c35ee925240fc129d77695e3f88c6d5f0f2b", "patch": "@@ -774,23 +774,27 @@ fn encode_info_for_method(ecx: &EncodeContext,\n         } else {\n             encode_symbol(ecx, ebml_w, m.def_id.node);\n         }\n+        encode_method_argument_names(ebml_w, &*ast_method.decl);\n+    }\n \n-        ebml_w.start_tag(tag_method_argument_names);\n-        for arg in ast_method.decl.inputs.iter() {\n-            ebml_w.start_tag(tag_method_argument_name);\n-            match arg.pat.node {\n-                ast::PatIdent(_, ref name, _) => {\n-                    let name = name.segments.last().unwrap().identifier;\n-                    let name = token::get_ident(name);\n-                    ebml_w.writer.write(name.get().as_bytes());\n-                }\n-                _ => {}\n+    ebml_w.end_tag();\n+}\n+\n+fn encode_method_argument_names(ebml_w: &mut Encoder,\n+                                decl: &ast::FnDecl) {\n+    ebml_w.start_tag(tag_method_argument_names);\n+    for arg in decl.inputs.iter() {\n+        ebml_w.start_tag(tag_method_argument_name);\n+        match arg.pat.node {\n+            ast::PatIdent(_, ref name, _) => {\n+                let name = name.segments.last().unwrap().identifier;\n+                let name = token::get_ident(name);\n+                ebml_w.writer.write(name.get().as_bytes());\n             }\n-            ebml_w.end_tag();\n+            _ => {}\n         }\n         ebml_w.end_tag();\n     }\n-\n     ebml_w.end_tag();\n }\n \n@@ -910,7 +914,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_visibility(ebml_w, vis);\n         ebml_w.end_tag();\n       }\n-      ItemFn(_, fn_style, _, ref generics, _) => {\n+      ItemFn(ref decl, fn_style, _, ref generics, _) => {\n         add_to_index(item, ebml_w, index);\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n@@ -926,6 +930,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             encode_symbol(ecx, ebml_w, item.id);\n         }\n         encode_visibility(ebml_w, vis);\n+        encode_method_argument_names(ebml_w, &**decl);\n         ebml_w.end_tag();\n       }\n       ItemMod(ref m) => {"}, {"sha": "79f687b06248495b1db1cd76ce473c587895e395", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9181c35ee925240fc129d77695e3f88c6d5f0f2b/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9181c35ee925240fc129d77695e3f88c6d5f0f2b/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=9181c35ee925240fc129d77695e3f88c6d5f0f2b", "patch": "@@ -722,18 +722,35 @@ impl Clean<FnDecl> for ast::FnDecl {\n     }\n }\n \n-impl Clean<FnDecl> for ty::FnSig {\n+impl<'a> Clean<FnDecl> for (ast::DefId, &'a ty::FnSig) {\n     fn clean(&self) -> FnDecl {\n+        let cx = super::ctxtkey.get().unwrap();\n+        let tcx = match cx.maybe_typed {\n+            core::Typed(ref tcx) => tcx,\n+            core::NotTyped(_) => fail!(),\n+        };\n+        let (did, sig) = *self;\n+        let mut names = if did.node != 0 {\n+            csearch::get_method_arg_names(&tcx.sess.cstore, did).move_iter()\n+        } else {\n+            Vec::new().move_iter()\n+        }.peekable();\n+        if names.peek().map(|s| s.as_slice()) == Some(\"self\") {\n+            let _ = names.next();\n+        }\n+        if did.node == 0 {\n+            let _ = names.len();\n+        }\n         FnDecl {\n-            output: self.output.clean(),\n+            output: sig.output.clean(),\n             cf: Return,\n-            attrs: Vec::new(), // FIXME: this is likely wrong\n+            attrs: Vec::new(),\n             inputs: Arguments {\n-                values: self.inputs.iter().map(|t| {\n+                values: sig.inputs.iter().map(|t| {\n                     Argument {\n                         type_: t.clean(),\n                         id: 0,\n-                        name: \"\".to_strbuf(), // FIXME: where are the names?\n+                        name: names.next().unwrap_or(\"\".to_strbuf()),\n                     }\n                 }).collect(),\n             },\n@@ -868,15 +885,6 @@ impl Clean<TraitMethod> for ty::Method {\n                 (s, sig)\n             }\n         };\n-        let mut names = csearch::get_method_arg_names(&tcx.sess.cstore,\n-                                                      self.def_id).move_iter();\n-        if self_ != SelfStatic {\n-            names.next();\n-        }\n-        let mut decl = sig.clean();\n-        for (name, slot) in names.zip(decl.inputs.values.mut_iter()) {\n-            slot.name = name;\n-        }\n \n         m(Item {\n             name: Some(self.ident.clean()),\n@@ -888,7 +896,7 @@ impl Clean<TraitMethod> for ty::Method {\n                 fn_style: self.fty.fn_style,\n                 generics: self.generics.clean(),\n                 self_: self_,\n-                decl: decl,\n+                decl: (self.def_id, &sig).clean(),\n             })\n         })\n     }\n@@ -1005,13 +1013,13 @@ impl Clean<Type> for ty::t {\n                 generics: Generics {\n                     lifetimes: Vec::new(), type_params: Vec::new()\n                 },\n-                decl: fty.sig.clean(),\n+                decl: (ast_util::local_def(0), &fty.sig).clean(),\n                 abi: fty.abi.to_str().to_strbuf(),\n             }),\n             ty::ty_closure(ref fty) => {\n                 let decl = box ClosureDecl {\n                     lifetimes: Vec::new(), // FIXME: this looks wrong...\n-                    decl: fty.sig.clean(),\n+                    decl: (ast_util::local_def(0), &fty.sig).clean(),\n                     onceness: fty.onceness,\n                     fn_style: fty.fn_style,\n                     bounds: fty.bounds.iter().map(|i| i.clean()).collect(),\n@@ -1855,7 +1863,7 @@ fn build_external_function(tcx: &ty::ctxt,\n     let t = ty::lookup_item_type(tcx, did);\n     Function {\n         decl: match ty::get(t.ty).sty {\n-            ty::ty_bare_fn(ref f) => f.sig.clean(),\n+            ty::ty_bare_fn(ref f) => (did, &f.sig).clean(),\n             _ => fail!(\"bad function\"),\n         },\n         generics: t.generics.clean(),"}]}