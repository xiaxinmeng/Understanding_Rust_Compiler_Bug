{"sha": "b122d1636ac502dad51c827c16dc95d80d96c838", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxMjJkMTYzNmFjNTAyZGFkNTFjODI3YzE2ZGM5NWQ4MGQ5NmM4Mzg=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-23T19:57:22Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T16:19:50Z"}, "message": "trans: simplify the declare interface.", "tree": {"sha": "67c06fefcbc85d646fc4bbb10e1c6f4c0b1df1d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67c06fefcbc85d646fc4bbb10e1c6f4c0b1df1d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b122d1636ac502dad51c827c16dc95d80d96c838", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b122d1636ac502dad51c827c16dc95d80d96c838", "html_url": "https://github.com/rust-lang/rust/commit/b122d1636ac502dad51c827c16dc95d80d96c838", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b122d1636ac502dad51c827c16dc95d80d96c838/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee", "html_url": "https://github.com/rust-lang/rust/commit/c6d214bdeb1bfc9664ad14085c94bf2cbc5af6ee"}], "stats": {"total": 179, "additions": 65, "deletions": 114}, "files": [{"sha": "5e412baa9cea1b544bd9fe744e739a7959517ea6", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b122d1636ac502dad51c827c16dc95d80d96c838/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b122d1636ac502dad51c827c16dc95d80d96c838/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=b122d1636ac502dad51c827c16dc95d80d96c838", "patch": "@@ -337,7 +337,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     //\n     let function_name = link::mangle_internal_name_by_type_and_seq(ccx, bare_fn_ty,\n                                                                    \"fn_pointer_shim\");\n-    let llfn = declare::declare_internal_rust_fn(ccx, &function_name[..], tuple_fn_ty);\n+    let llfn = declare::define_internal_fn(ccx, &function_name, tuple_fn_ty);\n \n     //\n     let empty_substs = tcx.mk_substs(Substs::trans_empty());"}, {"sha": "91bbcef9ce6387815788f6cbef9bf36c50b32c37", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b122d1636ac502dad51c827c16dc95d80d96c838/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b122d1636ac502dad51c827c16dc95d80d96c838/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=b122d1636ac502dad51c827c16dc95d80d96c838", "patch": "@@ -155,7 +155,7 @@ pub fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let symbol = mangle_internal_name_by_path_and_seq(path, \"closure\");\n \n     let function_type = ccx.tcx().mk_closure_from_closure_substs(closure_id, Box::new(substs));\n-    let llfn = declare::define_internal_rust_fn(ccx, &symbol[..], function_type);\n+    let llfn = declare::define_internal_fn(ccx, &symbol, function_type);\n \n     // set an inline hint for all closures\n     attributes::inline(llfn, attributes::InlineAttr::Hint);\n@@ -357,8 +357,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // Create the by-value helper.\n     let function_name = link::mangle_internal_name_by_type_and_seq(ccx, llonce_fn_ty, \"once_shim\");\n-    let lloncefn = declare::define_internal_rust_fn(ccx, &function_name,\n-                                                    llonce_fn_ty);\n+    let lloncefn = declare::define_internal_fn(ccx, &function_name, llonce_fn_ty);\n \n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();"}, {"sha": "655a57b6f20fb3372b083cdd542248051f435dd1", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b122d1636ac502dad51c827c16dc95d80d96c838/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b122d1636ac502dad51c827c16dc95d80d96c838/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=b122d1636ac502dad51c827c16dc95d80d96c838", "patch": "@@ -12,8 +12,6 @@\n \n //! Code that is useful in various trans modules.\n \n-pub use self::ExprOrMethodCall::*;\n-\n use session::Session;\n use llvm;\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef, TypeKind};\n@@ -23,11 +21,11 @@ use middle::def::Def;\n use middle::def_id::DefId;\n use middle::infer;\n use middle::lang_items::LangItem;\n-use middle::subst::{self, Substs};\n+use middle::subst::Substs;\n use trans::base;\n use trans::build;\n use trans::builder::Builder;\n-use trans::callee;\n+use trans::callee::Callee;\n use trans::cleanup;\n use trans::consts;\n use trans::datum;\n@@ -43,14 +41,15 @@ use middle::traits::{self, SelectionContext, ProjectionMode};\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n use rustc_front::hir;\n use rustc::mir::repr::Mir;\n-use util::nodemap::{FnvHashMap, NodeMap};\n+use util::nodemap::NodeMap;\n \n use arena::TypedArena;\n use libc::{c_uint, c_char};\n use std::ops::Deref;\n use std::ffi::CString;\n use std::cell::{Cell, RefCell};\n-use std::vec::Vec;\n+\n+use syntax::abi::Abi;\n use syntax::ast;\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n@@ -253,8 +252,6 @@ pub fn BuilderRef_res(b: BuilderRef) -> BuilderRef_res {\n     }\n }\n \n-pub type ExternMap = FnvHashMap<String, ValueRef>;\n-\n pub fn validate_substs(substs: &Substs) {\n     assert!(!substs.types.needs_infer());\n }\n@@ -539,31 +536,33 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n \n     // Returns a ValueRef of the \"eh_unwind_resume\" lang item if one is defined,\n     // otherwise declares it as an external function.\n-    pub fn eh_unwind_resume(&self) -> ValueRef {\n+    pub fn eh_unwind_resume(&self) -> Callee<'tcx> {\n         use trans::attributes;\n-        assert!(self.ccx.sess().target.target.options.custom_unwind_resume);\n-        match self.ccx.tcx().lang_items.eh_unwind_resume() {\n-            Some(def_id) => {\n-                callee::trans_fn_ref(self.ccx, def_id, ExprId(0),\n-                                     self.param_substs).val\n-            }\n-            None => {\n-                let mut unwresume = self.ccx.eh_unwind_resume().borrow_mut();\n-                match *unwresume {\n-                    Some(llfn) => llfn,\n-                    None => {\n-                        let fty = Type::func(&[Type::i8p(self.ccx)], &Type::void(self.ccx));\n-                        let llfn = declare::declare_fn(self.ccx,\n-                                                       \"rust_eh_unwind_resume\",\n-                                                       llvm::CCallConv,\n-                                                       fty, ty::FnDiverging);\n-                        attributes::unwind(llfn, true);\n-                        *unwresume = Some(llfn);\n-                        llfn\n-                    }\n-                }\n-            }\n+        let ccx = self.ccx;\n+        let tcx = ccx.tcx();\n+        assert!(ccx.sess().target.target.options.custom_unwind_resume);\n+        if let Some(def_id) = tcx.lang_items.eh_unwind_resume() {\n+            return Callee::def(ccx, def_id, tcx.mk_substs(Substs::empty()));\n+        }\n+\n+        let ty = tcx.mk_fn_ptr(ty::BareFnTy {\n+            unsafety: hir::Unsafety::Unsafe,\n+            abi: Abi::C,\n+            sig: ty::Binder(ty::FnSig {\n+                inputs: vec![tcx.mk_mut_ptr(tcx.types.u8)],\n+                output: ty::FnDiverging,\n+                variadic: false\n+            }),\n+        });\n+\n+        let unwresume = ccx.eh_unwind_resume();\n+        if let Some(llfn) = unwresume.get() {\n+            return Callee::ptr(datum::immediate_rvalue(llfn, ty));\n         }\n+        let llfn = declare::declare_fn(ccx, \"rust_eh_unwind_resume\", ty);\n+        attributes::unwind(llfn, true);\n+        unwresume.set(Some(llfn));\n+        Callee::ptr(datum::immediate_rvalue(llfn, ty))\n     }\n }\n "}, {"sha": "d77fd6f10a0b2a50cafc7bbd6a0bfe51dc9bb87f", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 29, "deletions": 76, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/b122d1636ac502dad51c827c16dc95d80d96c838/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b122d1636ac502dad51c827c16dc95d80d96c838/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=b122d1636ac502dad51c827c16dc95d80d96c838", "patch": "@@ -26,6 +26,7 @@ use middle::traits::ProjectionMode;\n use syntax::abi::Abi;\n use trans::attributes;\n use trans::base;\n+use trans::cabi::FnType;\n use trans::context::CrateContext;\n use trans::type_::Type;\n use trans::type_of;\n@@ -51,8 +52,6 @@ pub fn declare_global(ccx: &CrateContext, name: &str, ty: Type) -> llvm::ValueRe\n \n /// Declare a function.\n ///\n-/// For rust functions use `declare_rust_fn` instead.\n-///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing ValueRef instead.\n fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty: Type) -> ValueRef {\n@@ -81,7 +80,7 @@ fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n /// Declare a C ABI function.\n ///\n /// Only use this for foreign function ABIs and glue. For Rust functions use\n-/// `declare_rust_fn` instead.\n+/// `declare_fn` instead.\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing ValueRef instead.\n@@ -94,8 +93,8 @@ pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type) -> ValueRef {\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing ValueRef instead.\n-pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n-                                 fn_type: ty::Ty<'tcx>) -> ValueRef {\n+pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n+                            fn_type: ty::Ty<'tcx>) -> ValueRef {\n     debug!(\"declare_rust_fn(name={:?}, fn_type={:?})\", name,\n            fn_type);\n \n@@ -118,28 +117,33 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n         _ => ccx.sess().bug(\"expected closure or fn\")\n     };\n \n+\n     let sig = ccx.tcx().erase_late_bound_regions(sig);\n     let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n     debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n-    let llfty = type_of::type_of_rust_fn(ccx, env, &sig, abi);\n-    debug!(\"declare_rust_fn llfty={:?}\", llfty);\n+\n+    let (cconv, llfty) = if abi == Abi::Rust || abi == Abi::RustCall {\n+        (llvm::CCallConv, type_of::type_of_rust_fn(ccx, env, &sig, abi))\n+    } else {\n+        let fty = FnType::new(ccx, abi, &sig, &[]);\n+        (fty.cconv, fty.to_llvm(ccx))\n+    };\n \n     // it is ok to directly access sig.0.output because we erased all\n     // late-bound-regions above\n-    let llfn = declare_fn(ccx, name, llvm::CCallConv, llfty, sig.output);\n-    attributes::from_fn_type(ccx, fn_type).apply_llfn(llfn);\n-    llfn\n-}\n+        debug!(\"declare_rust_fn llfty={:?}\", llfty);\n+    let llfn = declare_raw_fn(ccx, name, cconv, llfty);\n \n+    if sig.output == ty::FnDiverging {\n+        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoReturn);\n+    }\n+\n+    if abi == Abi::Rust || abi == Abi::RustCall {\n+        attributes::from_fn_type(ccx, fn_type).apply_llfn(llfn);\n+    } else {\n+        FnType::new(ccx, abi, &sig, &[]).add_attributes(llfn);\n+    }\n \n-/// Declare a Rust function with internal linkage.\n-///\n-/// If there\u2019s a value with the same name already declared, the function will\n-/// update the declaration and return existing ValueRef instead.\n-pub fn declare_internal_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n-                                          fn_type: ty::Ty<'tcx>) -> ValueRef {\n-    let llfn = declare_rust_fn(ccx, name, fn_type);\n-    llvm::SetLinkage(llfn, llvm::InternalLinkage);\n     llfn\n }\n \n@@ -159,71 +163,20 @@ pub fn define_global(ccx: &CrateContext, name: &str, ty: Type) -> Option<ValueRe\n }\n \n \n-/// Declare a function with an intention to define it.\n-///\n-/// For rust functions use `define_rust_fn` instead.\n-///\n-/// Use this function when you intend to define a function. This function will\n-/// return None if the name already has a definition associated with it. In that\n-/// case an error should be reported to the user, because it usually happens due\n-/// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n-pub fn define_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv,\n-                 fn_type: Type, output: ty::FnOutput) -> Option<ValueRef> {\n-    if get_defined_value(ccx, name).is_some() {\n-        None\n-    } else {\n-        Some(declare_fn(ccx, name, callconv, fn_type, output))\n-    }\n-}\n-\n-\n-/// Declare a C ABI function with an intention to define it.\n-///\n-/// Use this function when you intend to define a function. This function will\n-/// return None if the name already has a definition associated with it. In that\n-/// case an error should be reported to the user, because it usually happens due\n-/// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n-///\n-/// Only use this for foreign function ABIs and glue. For Rust functions use\n-/// `declare_rust_fn` instead.\n-pub fn define_cfn(ccx: &CrateContext, name: &str, fn_type: Type,\n-                  output: ty::Ty) -> Option<ValueRef> {\n-    if get_defined_value(ccx, name).is_some() {\n-        None\n-    } else {\n-        Some(declare_cfn(ccx, name, fn_type, output))\n-    }\n-}\n-\n-\n-/// Declare a Rust function with an intention to define it.\n-///\n-/// Use this function when you intend to define a function. This function will\n-/// return None if the name already has a definition associated with it. In that\n-/// case an error should be reported to the user, because it usually happens due\n-/// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n-pub fn define_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n-                                fn_type: ty::Ty<'tcx>) -> Option<ValueRef> {\n-    if get_defined_value(ccx, name).is_some() {\n-        None\n-    } else {\n-        Some(declare_rust_fn(ccx, name, fn_type))\n-    }\n-}\n-\n-\n /// Declare a Rust function with an intention to define it.\n ///\n /// Use this function when you intend to define a function. This function will\n /// return panic if the name already has a definition associated with it. This\n /// can happen with #[no_mangle] or #[export_name], for example.\n-pub fn define_internal_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                         name: &str,\n-                                         fn_type: ty::Ty<'tcx>) -> ValueRef {\n+pub fn define_internal_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                    name: &str,\n+                                    fn_type: ty::Ty<'tcx>) -> ValueRef {\n     if get_defined_value(ccx, name).is_some() {\n         ccx.sess().fatal(&format!(\"symbol `{}` already defined\", name))\n     } else {\n-        declare_internal_rust_fn(ccx, name, fn_type)\n+        let llfn = declare_fn(ccx, name, fn_type);\n+        llvm::SetLinkage(llfn, llvm::InternalLinkage);\n+        llfn\n     }\n }\n "}, {"sha": "27d2c07893b6b2dd6fc37abf59378e4cc91a0a2f", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b122d1636ac502dad51c827c16dc95d80d96c838/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b122d1636ac502dad51c827c16dc95d80d96c838/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=b122d1636ac502dad51c827c16dc95d80d96c838", "patch": "@@ -530,7 +530,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                ccx.tcx().map.path_to_string(id),\n                id, rust_fn_ty);\n \n-        let llfn = declare::define_internal_rust_fn(ccx, &ps, t);\n+        let llfn = declare::define_internal_fn(ccx, &ps, rust_fn_ty);\n         attributes::from_fn_attrs(ccx, attrs, llfn);\n         base::trans_fn(ccx, decl, body, llfn, param_substs, id, attrs);\n         llfn"}, {"sha": "46afeaa4d9e7ca513d958c3c2866c2b12cd75e8d", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b122d1636ac502dad51c827c16dc95d80d96c838/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b122d1636ac502dad51c827c16dc95d80d96c838/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=b122d1636ac502dad51c827c16dc95d80d96c838", "patch": "@@ -1275,7 +1275,7 @@ fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n                     trans: &mut for<'b> FnMut(Block<'b, 'tcx>))\n                     -> ValueRef {\n     let ccx = fcx.ccx;\n-    let llfn = declare::define_internal_rust_fn(ccx, name, ty);\n+    let llfn = declare::define_internal_fn(ccx, name, ty);\n     let (fcx, block_arena);\n     block_arena = TypedArena::new();\n     fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,"}, {"sha": "2a51c3937176efa6db99928bdfbb65987fc016db", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b122d1636ac502dad51c827c16dc95d80d96c838/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b122d1636ac502dad51c827c16dc95d80d96c838/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=b122d1636ac502dad51c827c16dc95d80d96c838", "patch": "@@ -108,7 +108,7 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n \n     //\n     let function_name = link::mangle_internal_name_by_type_and_seq(ccx, shim_fn_ty, \"object_shim\");\n-    let llfn = declare::define_internal_rust_fn(ccx, &function_name, shim_fn_ty);\n+    let llfn = declare::define_internal_fn(ccx, &function_name, shim_fn_ty);\n \n     let empty_substs = tcx.mk_substs(Substs::trans_empty());\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);"}]}