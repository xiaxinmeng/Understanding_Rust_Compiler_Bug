{"sha": "eacf7aeb42d7ba54c305664773e77eb592b51b99", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhY2Y3YWViNDJkN2JhNTRjMzA1NjY0NzczZTc3ZWI1OTJiNTFiOTk=", "commit": {"author": {"name": "Bernardo", "email": "berublan@gmail.com", "date": "2019-01-19T21:28:51Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-26T08:46:27Z"}, "message": "ignore check event dir for ignore, cleanup tests", "tree": {"sha": "db4cec298738212beeb43f1cf428fa955df35b9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db4cec298738212beeb43f1cf428fa955df35b9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eacf7aeb42d7ba54c305664773e77eb592b51b99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eacf7aeb42d7ba54c305664773e77eb592b51b99", "html_url": "https://github.com/rust-lang/rust/commit/eacf7aeb42d7ba54c305664773e77eb592b51b99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eacf7aeb42d7ba54c305664773e77eb592b51b99/comments", "author": {"login": "vemoo", "id": 4866051, "node_id": "MDQ6VXNlcjQ4NjYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4866051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vemoo", "html_url": "https://github.com/vemoo", "followers_url": "https://api.github.com/users/vemoo/followers", "following_url": "https://api.github.com/users/vemoo/following{/other_user}", "gists_url": "https://api.github.com/users/vemoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/vemoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vemoo/subscriptions", "organizations_url": "https://api.github.com/users/vemoo/orgs", "repos_url": "https://api.github.com/users/vemoo/repos", "events_url": "https://api.github.com/users/vemoo/events{/privacy}", "received_events_url": "https://api.github.com/users/vemoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb1d748a2c49597934337432a78be2a5a098ca0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb1d748a2c49597934337432a78be2a5a098ca0e", "html_url": "https://github.com/rust-lang/rust/commit/fb1d748a2c49597934337432a78be2a5a098ca0e"}], "stats": {"total": 192, "additions": 129, "deletions": 63}, "files": [{"sha": "f0ef9bc0eac82104239ece62bec0a466eb6a347c", "filename": "crates/ra_vfs/src/watcher.rs", "status": "modified", "additions": 47, "deletions": 14, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/eacf7aeb42d7ba54c305664773e77eb592b51b99/crates%2Fra_vfs%2Fsrc%2Fwatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eacf7aeb42d7ba54c305664773e77eb592b51b99/crates%2Fra_vfs%2Fsrc%2Fwatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fwatcher.rs?ref=eacf7aeb42d7ba54c305664773e77eb592b51b99", "patch": "@@ -1,7 +1,7 @@\n use crate::io;\n use crossbeam_channel::Sender;\n use drop_bomb::DropBomb;\n-use ignore;\n+use ignore::{gitignore::Gitignore, Walk};\n use notify::{DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher as NotifyWatcher};\n use parking_lot::Mutex;\n use std::{\n@@ -40,8 +40,11 @@ fn handle_change_event(\n             sender.send(io::Task::HandleChange(WatcherChange::Rescan))?;\n         }\n         DebouncedEvent::Create(path) => {\n-            if path.is_dir() {\n-                watch_recursive(watcher, &path);\n+            // we have to check if `path` is ignored because Walk iterator doesn't check it\n+            // also childs are only ignored if they match a pattern\n+            // (see `matched` vs `matched_path_or_any_parents` in `Gitignore`)\n+            if path.is_dir() && !should_ignore_dir(&path) {\n+                watch_recursive(watcher, &path, Some(sender));\n             }\n             sender.send(io::Task::HandleChange(WatcherChange::Create(path)))?;\n         }\n@@ -63,15 +66,18 @@ fn handle_change_event(\n     Ok(())\n }\n \n-fn watch_one(watcher: &mut RecommendedWatcher, path: &Path) {\n-    match watcher.watch(path, RecursiveMode::NonRecursive) {\n-        Ok(()) => log::debug!(\"watching \\\"{}\\\"\", path.display()),\n-        Err(e) => log::warn!(\"could not watch \\\"{}\\\": {}\", path.display(), e),\n+fn watch_one(watcher: &mut RecommendedWatcher, dir: &Path) {\n+    match watcher.watch(dir, RecursiveMode::NonRecursive) {\n+        Ok(()) => log::debug!(\"watching \\\"{}\\\"\", dir.display()),\n+        Err(e) => log::warn!(\"could not watch \\\"{}\\\": {}\", dir.display(), e),\n     }\n }\n \n-fn watch_recursive(watcher: &Arc<Mutex<Option<RecommendedWatcher>>>, path: &Path) {\n-    log::debug!(\"watch_recursive \\\"{}\\\"\", path.display());\n+fn watch_recursive(\n+    watcher: &Arc<Mutex<Option<RecommendedWatcher>>>,\n+    dir: &Path,\n+    sender: Option<&Sender<io::Task>>,\n+) {\n     let mut watcher = watcher.lock();\n     let mut watcher = match *watcher {\n         Some(ref mut watcher) => watcher,\n@@ -80,28 +86,55 @@ fn watch_recursive(watcher: &Arc<Mutex<Option<RecommendedWatcher>>>, path: &Path\n             return;\n         }\n     };\n-    // TODO it seems path itself isn't checked against ignores\n-    // check if path should be ignored before walking it\n-    for res in ignore::Walk::new(path) {\n+    for res in Walk::new(dir) {\n         match res {\n             Ok(entry) => {\n                 if entry.path().is_dir() {\n                     watch_one(&mut watcher, entry.path());\n                 }\n+                if let Some(sender) = sender {\n+                    // emit as create because we haven't seen it yet\n+                    if let Err(e) = sender.send(io::Task::HandleChange(WatcherChange::Create(\n+                        entry.path().to_path_buf(),\n+                    ))) {\n+                        log::warn!(\"watcher error: {}\", e)\n+                    }\n+                }\n             }\n             Err(e) => log::warn!(\"watcher error: {}\", e),\n         }\n     }\n }\n \n+fn should_ignore_dir(dir: &Path) -> bool {\n+    let mut parent = dir;\n+    loop {\n+        parent = match parent.parent() {\n+            Some(p) => p,\n+            None => break,\n+        };\n+        let gitignore = parent.join(\".gitignore\");\n+        if gitignore.exists() {\n+            let gitignore = Gitignore::new(gitignore).0;\n+            if gitignore.matched_path_or_any_parents(dir, true).is_ignore() {\n+                log::debug!(\"ignored {}\", dir.display());\n+                return true;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+const WATCHER_DELAY: Duration = Duration::from_millis(250);\n+\n impl Watcher {\n     pub(crate) fn start(\n         output_sender: Sender<io::Task>,\n     ) -> Result<Watcher, Box<std::error::Error>> {\n         let (input_sender, input_receiver) = mpsc::channel();\n         let watcher = Arc::new(Mutex::new(Some(notify::watcher(\n             input_sender,\n-            Duration::from_millis(250),\n+            WATCHER_DELAY,\n         )?)));\n         let w = watcher.clone();\n         let thread = thread::spawn(move || {\n@@ -119,7 +152,7 @@ impl Watcher {\n     }\n \n     pub fn watch(&mut self, root: impl AsRef<Path>) {\n-        watch_recursive(&self.watcher, root.as_ref());\n+        watch_recursive(&self.watcher, root.as_ref(), None);\n     }\n \n     pub fn shutdown(mut self) -> thread::Result<()> {"}, {"sha": "71b25a5c9695453ccbc9fb9d30f11801848536e4", "filename": "crates/ra_vfs/tests/vfs.rs", "status": "modified", "additions": 82, "deletions": 49, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/eacf7aeb42d7ba54c305664773e77eb592b51b99/crates%2Fra_vfs%2Ftests%2Fvfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eacf7aeb42d7ba54c305664773e77eb592b51b99/crates%2Fra_vfs%2Ftests%2Fvfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Ftests%2Fvfs.rs?ref=eacf7aeb42d7ba54c305664773e77eb592b51b99", "patch": "@@ -11,23 +11,38 @@ fn process_tasks(vfs: &mut Vfs, num_tasks: u32) {\n     }\n }\n \n+macro_rules! assert_match {\n+    ($x:expr, $pat:pat) => {\n+        assert_match!($x, $pat, assert!(true))\n+    };\n+    ($x:expr, $pat:pat, $assert:expr) => {\n+        match $x {\n+            $pat => $assert,\n+            x => assert!(false, \"Expected {}, got {:?}\", stringify!($pat), x),\n+        };\n+    };\n+}\n+\n #[test]\n fn test_vfs_works() -> std::io::Result<()> {\n-    // Logger::with_str(\"debug\").start().unwrap();\n+    // Logger::with_str(\"vfs=debug,ra_vfs=debug\").start().unwrap();\n \n     let files = [\n         (\"a/foo.rs\", \"hello\"),\n         (\"a/bar.rs\", \"world\"),\n         (\"a/b/baz.rs\", \"nested hello\"),\n     ];\n \n-    let dir = tempdir()?;\n+    let dir = tempdir().unwrap();\n     for (path, text) in files.iter() {\n         let file_path = dir.path().join(path);\n-        fs::create_dir_all(file_path.parent().unwrap())?;\n+        fs::create_dir_all(file_path.parent().unwrap()).unwrap();\n         fs::write(file_path, text)?\n     }\n \n+    let gitignore = dir.path().join(\"a/.gitignore\");\n+    fs::write(gitignore, \"/target\").unwrap();\n+\n     let a_root = dir.path().join(\"a\");\n     let b_root = dir.path().join(\"a/b\");\n \n@@ -62,79 +77,97 @@ fn test_vfs_works() -> std::io::Result<()> {\n     }\n \n     fs::write(&dir.path().join(\"a/b/baz.rs\"), \"quux\").unwrap();\n-    // 2 tasks per watcher change, first for HandleChange then for LoadChange\n+    // 2 tasks per change, HandleChange and then LoadChange\n     process_tasks(&mut vfs, 2);\n-    match vfs.commit_changes().as_slice() {\n-        [VfsChange::ChangeFile { text, .. }] => assert_eq!(text.as_str(), \"quux\"),\n-        xs => panic!(\"unexpected changes {:?}\", xs),\n-    }\n+    assert_match!(\n+        vfs.commit_changes().as_slice(),\n+        [VfsChange::ChangeFile { text, .. }],\n+        assert_eq!(text.as_str(), \"quux\")\n+    );\n \n     vfs.change_file_overlay(&dir.path().join(\"a/b/baz.rs\"), \"m\".to_string());\n-    match vfs.commit_changes().as_slice() {\n-        [VfsChange::ChangeFile { text, .. }] => assert_eq!(text.as_str(), \"m\"),\n-        xs => panic!(\"unexpected changes {:?}\", xs),\n-    }\n+    assert_match!(\n+        vfs.commit_changes().as_slice(),\n+        [VfsChange::ChangeFile { text, .. }],\n+        assert_eq!(text.as_str(), \"m\")\n+    );\n \n     // removing overlay restores data on disk\n     vfs.remove_file_overlay(&dir.path().join(\"a/b/baz.rs\"));\n-    match vfs.commit_changes().as_slice() {\n-        [VfsChange::ChangeFile { text, .. }] => assert_eq!(text.as_str(), \"quux\"),\n-        xs => panic!(\"unexpected changes {:?}\", xs),\n-    }\n+    assert_match!(\n+        vfs.commit_changes().as_slice(),\n+        [VfsChange::ChangeFile { text, .. }],\n+        assert_eq!(text.as_str(), \"quux\")\n+    );\n \n     vfs.add_file_overlay(&dir.path().join(\"a/b/spam.rs\"), \"spam\".to_string());\n-    match vfs.commit_changes().as_slice() {\n-        [VfsChange::AddFile { text, path, .. }] => {\n+    assert_match!(\n+        vfs.commit_changes().as_slice(),\n+        [VfsChange::AddFile { text, path, .. }],\n+        {\n             assert_eq!(text.as_str(), \"spam\");\n             assert_eq!(path, \"spam.rs\");\n         }\n-        xs => panic!(\"unexpected changes {:?}\", xs),\n-    }\n+    );\n \n     vfs.remove_file_overlay(&dir.path().join(\"a/b/spam.rs\"));\n-    match vfs.commit_changes().as_slice() {\n-        [VfsChange::RemoveFile { path, .. }] => assert_eq!(path, \"spam.rs\"),\n-        xs => panic!(\"unexpected changes {:?}\", xs),\n-    }\n-\n-    fs::write(&dir.path().join(\"a/new.rs\"), \"new hello\").unwrap();\n-    process_tasks(&mut vfs, 2);\n-    match vfs.commit_changes().as_slice() {\n-        [VfsChange::AddFile { text, path, .. }] => {\n+    assert_match!(\n+        vfs.commit_changes().as_slice(),\n+        [VfsChange::RemoveFile { path, .. }],\n+        assert_eq!(path, \"spam.rs\")\n+    );\n+\n+    fs::create_dir_all(dir.path().join(\"a/c\")).unwrap();\n+    fs::write(dir.path().join(\"a/c/new.rs\"), \"new hello\").unwrap();\n+    process_tasks(&mut vfs, 4);\n+    assert_match!(\n+        vfs.commit_changes().as_slice(),\n+        [VfsChange::AddFile { text, path, .. }],\n+        {\n             assert_eq!(text.as_str(), \"new hello\");\n-            assert_eq!(path, \"new.rs\");\n+            assert_eq!(path, \"c/new.rs\");\n         }\n-        xs => panic!(\"unexpected changes {:?}\", xs),\n-    }\n+    );\n \n-    fs::rename(&dir.path().join(\"a/new.rs\"), &dir.path().join(\"a/new1.rs\")).unwrap();\n+    fs::rename(\n+        &dir.path().join(\"a/c/new.rs\"),\n+        &dir.path().join(\"a/c/new1.rs\"),\n+    )\n+    .unwrap();\n     process_tasks(&mut vfs, 4);\n-    match vfs.commit_changes().as_slice() {\n+    assert_match!(\n+        vfs.commit_changes().as_slice(),\n         [VfsChange::RemoveFile {\n             path: removed_path, ..\n         }, VfsChange::AddFile {\n             text,\n             path: added_path,\n             ..\n-        }] => {\n-            assert_eq!(removed_path, \"new.rs\");\n-            assert_eq!(added_path, \"new1.rs\");\n+        }],\n+        {\n+            assert_eq!(removed_path, \"c/new.rs\");\n+            assert_eq!(added_path, \"c/new1.rs\");\n             assert_eq!(text.as_str(), \"new hello\");\n         }\n-        xs => panic!(\"unexpected changes {:?}\", xs),\n-    }\n+    );\n \n-    fs::remove_file(&dir.path().join(\"a/new1.rs\")).unwrap();\n+    fs::remove_file(&dir.path().join(\"a/c/new1.rs\")).unwrap();\n     process_tasks(&mut vfs, 2);\n-    match vfs.commit_changes().as_slice() {\n-        [VfsChange::RemoveFile { path, .. }] => assert_eq!(path, \"new1.rs\"),\n-        xs => panic!(\"unexpected changes {:?}\", xs),\n-    }\n-\n-    match vfs.task_receiver().try_recv() {\n-        Err(crossbeam_channel::TryRecvError::Empty) => (),\n-        res => panic!(\"unexpected {:?}\", res),\n-    }\n+    assert_match!(\n+        vfs.commit_changes().as_slice(),\n+        [VfsChange::RemoveFile { path, .. }],\n+        assert_eq!(path, \"c/new1.rs\")\n+    );\n+\n+    fs::create_dir_all(dir.path().join(\"a/target\")).unwrap();\n+    // should be ignored\n+    fs::write(&dir.path().join(\"a/target/new.rs\"), \"ignore me\").unwrap();\n+    process_tasks(&mut vfs, 1); // 1 task because no LoadChange will happen, just HandleChange for dir creation\n+\n+    assert_match!(\n+        vfs.task_receiver().try_recv(),\n+        Err(crossbeam_channel::TryRecvError::Empty)\n+    );\n \n     vfs.shutdown().unwrap();\n     Ok(())"}]}