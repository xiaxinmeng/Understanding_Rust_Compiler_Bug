{"sha": "2bdf723da7c465e052a1b1fc448c0014c46b9e51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiZGY3MjNkYTdjNDY1ZTA1MmExYjFmYzQ0OGMwMDE0YzQ2YjllNTE=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-06-28T19:34:56Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-10-06T10:19:30Z"}, "message": "Ensure that associated types for trait objects satisfy their bounds", "tree": {"sha": "7a8bec8c03d6787d713f912f59e9e7db9da699af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a8bec8c03d6787d713f912f59e9e7db9da699af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bdf723da7c465e052a1b1fc448c0014c46b9e51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bdf723da7c465e052a1b1fc448c0014c46b9e51", "html_url": "https://github.com/rust-lang/rust/commit/2bdf723da7c465e052a1b1fc448c0014c46b9e51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bdf723da7c465e052a1b1fc448c0014c46b9e51/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a76584dcc6dd6ae8f32f905dde379a99da7e516", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a76584dcc6dd6ae8f32f905dde379a99da7e516", "html_url": "https://github.com/rust-lang/rust/commit/0a76584dcc6dd6ae8f32f905dde379a99da7e516"}], "stats": {"total": 184, "additions": 166, "deletions": 18}, "files": [{"sha": "1ed4cca107e7716bd927fda3401721cb9406d2bd", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 51, "deletions": 13, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2bdf723da7c465e052a1b1fc448c0014c46b9e51/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bdf723da7c465e052a1b1fc448c0014c46b9e51/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=2bdf723da7c465e052a1b1fc448c0014c46b9e51", "patch": "@@ -9,7 +9,7 @@\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::bit_set::GrowableBitSet;\n-use rustc_infer::infer::InferOk;\n+use rustc_infer::infer::{self, InferOk};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n use rustc_middle::ty::{self, Ty};\n use rustc_middle::ty::{ToPolyTraitRef, ToPredicate, WithConstness};\n@@ -342,21 +342,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> ImplSourceObjectData<'tcx, PredicateObligation<'tcx>> {\n         debug!(\"confirm_object_candidate({:?})\", obligation);\n \n-        // FIXME(nmatsakis) skipping binder here seems wrong -- we should\n-        // probably flatten the binder from the obligation and the binder\n-        // from the object. Have to try to make a broken test case that\n-        // results.\n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n-        let poly_trait_ref = match self_ty.kind() {\n-            ty::Dynamic(data, ..) => data\n-                .principal()\n-                .unwrap_or_else(|| {\n-                    span_bug!(obligation.cause.span, \"object candidate with no principal\")\n-                })\n-                .with_self_ty(self.tcx(), self_ty),\n+        let self_ty = self.infcx.replace_bound_vars_with_placeholders(&obligation.self_ty());\n+        let data = match self_ty.kind() {\n+            ty::Dynamic(data, ..) => data,\n             _ => span_bug!(obligation.cause.span, \"object candidate with non-object\"),\n         };\n \n+        let poly_trait_ref = data\n+            .principal()\n+            .unwrap_or_else(|| {\n+                span_bug!(obligation.cause.span, \"object candidate with no principal\")\n+            })\n+            .with_self_ty(self.tcx(), self_ty);\n+\n         let mut upcast_trait_ref = None;\n         let mut nested = vec![];\n         let vtable_base;\n@@ -388,6 +386,46 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             vtable_base = nonmatching.map(|t| super::util::count_own_vtable_entries(tcx, t)).sum();\n         }\n \n+        for bound in data.skip_binder() {\n+            match bound {\n+                ty::ExistentialPredicate::Projection(projection) => {\n+                    // This maybe belongs in wf, but that can't (doesn't) handle\n+                    // higher-ranked things.\n+                    // Prevent, e.g., `dyn Iterator<Item = str>`.\n+                    // FIXME(generic_associated_types): We need some way to\n+                    // ensure that for `dyn for<'a> X<Item<'a> = &'a ()>` the\n+                    // bound holds for all `'a`.\n+                    let (infer_projection, _) = self.infcx.replace_bound_vars_with_fresh_vars(\n+                        obligation.cause.span,\n+                        infer::HigherRankedType,\n+                        &ty::Binder::bind(projection),\n+                    );\n+                    let substs: Vec<_> =\n+                        iter::once(self_ty.into()).chain(infer_projection.substs).collect();\n+                    let bounds =\n+                        self.tcx().item_bounds(projection.item_def_id).iter().map(|bound| {\n+                            // In the example above, `bound` is `<Self as Iterator>::Item: Sized`\n+                            // `subst_bound` is `str: Sized`.\n+                            let subst_bound = util::subst_assoc_item_bound(\n+                                self.tcx(),\n+                                bound,\n+                                infer_projection.ty,\n+                                &substs,\n+                            );\n+                            Obligation::new(\n+                                obligation.cause.clone(),\n+                                obligation.param_env.clone(),\n+                                subst_bound,\n+                            )\n+                        });\n+                    debug!(\"confirm_object_candidate: adding bounds: {:?}\", bounds);\n+                    nested.extend(bounds);\n+                }\n+                ty::ExistentialPredicate::Trait(_) | ty::ExistentialPredicate::AutoTrait(_) => {}\n+            }\n+        }\n+\n+        debug!(\"confirm_object_candidate: nested: {:?}\", nested);\n         ImplSourceObjectData { upcast_trait_ref: upcast_trait_ref.unwrap(), vtable_base, nested }\n     }\n "}, {"sha": "ebdc5cb6dbe5de82aabbc4e82fdf8d3768cd2855", "filename": "src/test/ui/issues/issue-41139.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2bdf723da7c465e052a1b1fc448c0014c46b9e51/src%2Ftest%2Fui%2Fissues%2Fissue-41139.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bdf723da7c465e052a1b1fc448c0014c46b9e51/src%2Ftest%2Fui%2Fissues%2Fissue-41139.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41139.rs?ref=2bdf723da7c465e052a1b1fc448c0014c46b9e51", "patch": "@@ -3,6 +3,8 @@ trait Trait {}\n fn get_function<'a>() -> &'a dyn Fn() -> dyn Trait { panic!(\"\") }\n \n fn main() {\n+    // This isn't great. The issue here is that `dyn Trait` is not sized, so\n+    // `dyn Fn() -> dyn Trait` is not well-formed.\n     let t : &dyn Trait = &get_function()();\n-    //~^ ERROR cannot move a value of type dyn Trait\n+    //~^ ERROR expected function, found `&dyn std::ops::Fn() -> (dyn Trait + 'static)`\n }"}, {"sha": "083c413c316df6dd6dfe635bd40289600a1b8879", "filename": "src/test/ui/issues/issue-41139.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2bdf723da7c465e052a1b1fc448c0014c46b9e51/src%2Ftest%2Fui%2Fissues%2Fissue-41139.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bdf723da7c465e052a1b1fc448c0014c46b9e51/src%2Ftest%2Fui%2Fissues%2Fissue-41139.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41139.stderr?ref=2bdf723da7c465e052a1b1fc448c0014c46b9e51", "patch": "@@ -1,9 +1,14 @@\n-error[E0161]: cannot move a value of type dyn Trait: the size of dyn Trait cannot be statically determined\n-  --> $DIR/issue-41139.rs:6:27\n+error[E0618]: expected function, found `&dyn std::ops::Fn() -> (dyn Trait + 'static)`\n+  --> $DIR/issue-41139.rs:8:27\n    |\n+LL | fn get_function<'a>() -> &'a dyn Fn() -> dyn Trait { panic!(\"\") }\n+   | ----------------------------------------------------------------- `get_function` defined here returns `&dyn std::ops::Fn() -> (dyn Trait + 'static)`\n+...\n LL |     let t : &dyn Trait = &get_function()();\n-   |                           ^^^^^^^^^^^^^^^^\n+   |                           ^^^^^^^^^^^^^^--\n+   |                           |\n+   |                           call expression requires function\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0161`.\n+For more information about this error, try `rustc --explain E0618`."}, {"sha": "ad908a750b431d990e553628b504f2fae383e689", "filename": "src/test/ui/traits/check-trait-object-bounds-1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2bdf723da7c465e052a1b1fc448c0014c46b9e51/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bdf723da7c465e052a1b1fc448c0014c46b9e51/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-1.rs?ref=2bdf723da7c465e052a1b1fc448c0014c46b9e51", "patch": "@@ -0,0 +1,14 @@\n+// Check that we validate associated type bounds for trait objects\n+\n+trait X {\n+    type Y: Clone;\n+}\n+\n+fn f<T: X + ?Sized>() {\n+    None::<T::Y>.clone();\n+}\n+\n+fn main() {\n+    f::<dyn X<Y = str>>();\n+    //~^ ERROR the trait bound `str: std::clone::Clone` is not satisfied\n+}"}, {"sha": "c53c91d42a754d2a02ab9212485076d1d97d88bd", "filename": "src/test/ui/traits/check-trait-object-bounds-1.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2bdf723da7c465e052a1b1fc448c0014c46b9e51/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bdf723da7c465e052a1b1fc448c0014c46b9e51/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-1.stderr?ref=2bdf723da7c465e052a1b1fc448c0014c46b9e51", "patch": "@@ -0,0 +1,12 @@\n+error[E0277]: the trait bound `str: std::clone::Clone` is not satisfied\n+  --> $DIR/check-trait-object-bounds-1.rs:12:5\n+   |\n+LL | fn f<T: X + ?Sized>() {\n+   |         - required by this bound in `f`\n+...\n+LL |     f::<dyn X<Y = str>>();\n+   |     ^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` is not implemented for `str`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "1422dda276b9b0a78eba0956d6ac92543f909b3f", "filename": "src/test/ui/traits/check-trait-object-bounds-2-ok.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2bdf723da7c465e052a1b1fc448c0014c46b9e51/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-2-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bdf723da7c465e052a1b1fc448c0014c46b9e51/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-2-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-2-ok.rs?ref=2bdf723da7c465e052a1b1fc448c0014c46b9e51", "patch": "@@ -0,0 +1,15 @@\n+// Make sure that we're handling bound lifetimes correctly when validating trait\n+// bounds.\n+// run-pass\n+\n+trait X<'a> {\n+    type F: FnOnce(&i32) -> &'a i32;\n+}\n+\n+fn f<T: for<'r> X<'r> + ?Sized>() {\n+    None::<T::F>.map(|f| f(&0));\n+}\n+\n+fn main() {\n+    f::<dyn for<'x> X<'x, F = fn(&i32) -> &'x i32>>();\n+}"}, {"sha": "f825008c6a2331b7f98950106a7a896129458a49", "filename": "src/test/ui/traits/check-trait-object-bounds-2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2bdf723da7c465e052a1b1fc448c0014c46b9e51/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bdf723da7c465e052a1b1fc448c0014c46b9e51/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-2.rs?ref=2bdf723da7c465e052a1b1fc448c0014c46b9e51", "patch": "@@ -0,0 +1,15 @@\n+// Check that we validate associated type bounds for trait objects when they\n+// have bound lifetimes\n+\n+trait X<'a> {\n+    type F: FnOnce(&i32) -> &'a i32;\n+}\n+\n+fn f<T: for<'r> X<'r> + ?Sized>() {\n+    None::<T::F>.map(|f| f(&0));\n+}\n+\n+fn main() {\n+    f::<dyn for<'x> X<'x, F = i32>>();\n+    //~^ expected a `std::ops::FnOnce<(&i32,)>` closure, found `i32`\n+}"}, {"sha": "1241fc8cb51df0b3ab8f670e39173d8b8542f55b", "filename": "src/test/ui/traits/check-trait-object-bounds-2.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2bdf723da7c465e052a1b1fc448c0014c46b9e51/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bdf723da7c465e052a1b1fc448c0014c46b9e51/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-2.stderr?ref=2bdf723da7c465e052a1b1fc448c0014c46b9e51", "patch": "@@ -0,0 +1,14 @@\n+error[E0277]: expected a `std::ops::FnOnce<(&i32,)>` closure, found `i32`\n+  --> $DIR/check-trait-object-bounds-2.rs:13:5\n+   |\n+LL | fn f<T: for<'r> X<'r> + ?Sized>() {\n+   |         ------------- required by this bound in `f`\n+...\n+LL |     f::<dyn for<'x> X<'x, F = i32>>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected an `FnOnce<(&i32,)>` closure, found `i32`\n+   |\n+   = help: the trait `for<'r> std::ops::FnOnce<(&'r i32,)>` is not implemented for `i32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "d05aa14f2cf5f2bddb15c6da21b26d1c13d9848a", "filename": "src/test/ui/traits/check-trait-object-bounds-3.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2bdf723da7c465e052a1b1fc448c0014c46b9e51/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bdf723da7c465e052a1b1fc448c0014c46b9e51/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-3.rs?ref=2bdf723da7c465e052a1b1fc448c0014c46b9e51", "patch": "@@ -0,0 +1,21 @@\n+// Check that we validate associated type bounds for trait objects\n+\n+trait X<'a> {\n+    type Y: Into<&'static str> + From<&'a str>;\n+}\n+\n+fn f<'a, T: X<'a> + ?Sized>(s: &'a str) -> &'static str {\n+    T::Y::from(s).into()\n+}\n+\n+pub fn main() {\n+    let z;\n+    {\n+        let s = String::from(\"abcdef\");\n+        z = f::<dyn X<Y = &str>>(&s);\n+        //~^ ERROR `s` does not live long enough\n+    }\n+\n+    println!(\"{}\", z)\n+}\n+"}, {"sha": "e2a4341454a63c8da5e53b86f7cf5b3c0205f171", "filename": "src/test/ui/traits/check-trait-object-bounds-3.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2bdf723da7c465e052a1b1fc448c0014c46b9e51/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bdf723da7c465e052a1b1fc448c0014c46b9e51/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-3.stderr?ref=2bdf723da7c465e052a1b1fc448c0014c46b9e51", "patch": "@@ -0,0 +1,12 @@\n+error[E0277]: the trait bound `str: std::clone::Clone` is not satisfied\n+  --> $DIR/check-trait-object-bounds-3.rs:12:5\n+   |\n+LL | fn f<T: X + ?Sized>() {\n+   |         - required by this bound in `f`\n+...\n+LL |     f::<dyn X<Y = str>>();\n+   |     ^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` is not implemented for `str`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}