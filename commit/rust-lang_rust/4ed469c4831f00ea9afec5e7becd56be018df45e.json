{"sha": "4ed469c4831f00ea9afec5e7becd56be018df45e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlZDQ2OWM0ODMxZjAwZWE5YWZlYzVlN2JlY2Q1NmJlMDE4ZGY0NWU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-31T07:54:37Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-31T07:54:37Z"}, "message": "turn ptr type method docs into links to docs of free functions, to avoid duplication and inconsistency", "tree": {"sha": "4480bbe9b4bb33ba94133af3822bb333e38ee539", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4480bbe9b4bb33ba94133af3822bb333e38ee539"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ed469c4831f00ea9afec5e7becd56be018df45e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ed469c4831f00ea9afec5e7becd56be018df45e", "html_url": "https://github.com/rust-lang/rust/commit/4ed469c4831f00ea9afec5e7becd56be018df45e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ed469c4831f00ea9afec5e7becd56be018df45e/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18a7bdb568b222b20e1bf30f23f945a10ea60c78", "url": "https://api.github.com/repos/rust-lang/rust/commits/18a7bdb568b222b20e1bf30f23f945a10ea60c78", "html_url": "https://github.com/rust-lang/rust/commit/18a7bdb568b222b20e1bf30f23f945a10ea60c78"}], "stats": {"total": 477, "additions": 44, "deletions": 433}, "files": [{"sha": "f112a96ea15f54acd383ed2321a414afe8866a26", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 44, "deletions": 433, "changes": 477, "blob_url": "https://github.com/rust-lang/rust/blob/4ed469c4831f00ea9afec5e7becd56be018df45e/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed469c4831f00ea9afec5e7becd56be018df45e/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=4ed469c4831f00ea9afec5e7becd56be018df45e", "patch": "@@ -1401,29 +1401,9 @@ impl<T: ?Sized> *const T {\n     /// Reads the value from `self` without moving it. This leaves the\n     /// memory in `self` unchanged.\n     ///\n-    /// # Safety\n-    ///\n-    /// Beyond accepting a raw pointer, this is unsafe because it semantically\n-    /// moves the value out of `self` without preventing further usage of `self`.\n-    /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-    /// `self` is not used before the data is overwritten again (e.g. with `write`,\n-    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n-    /// because it will attempt to drop the value previously at `*self`.\n-    ///\n-    /// The pointer must be aligned; use `read_unaligned` if that is not the case.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let x = 12;\n-    /// let y = &x as *const i32;\n+    /// See [`ptr::read`] for safety concerns and examples.\n     ///\n-    /// unsafe {\n-    ///     assert_eq!(y.read(), 12);\n-    /// }\n-    /// ```\n+    /// [`ptr::read`]: ./ptr/fn.read.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read(self) -> T\n@@ -1439,47 +1419,9 @@ impl<T: ?Sized> *const T {\n     /// to not be elided or reordered by the compiler across other volatile\n     /// operations.\n     ///\n-    /// # Notes\n-    ///\n-    /// Rust does not currently have a rigorously and formally defined memory model,\n-    /// so the precise semantics of what \"volatile\" means here is subject to change\n-    /// over time. That being said, the semantics will almost always end up pretty\n-    /// similar to [C11's definition of volatile][c11].\n-    ///\n-    /// The compiler shouldn't change the relative order or number of volatile\n-    /// memory operations. However, volatile memory operations on zero-sized types\n-    /// (e.g. if a zero-sized type is passed to `read_volatile`) are no-ops\n-    /// and may be ignored.\n-    ///\n-    /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n-    ///\n-    /// # Safety\n-    ///\n-    /// Beyond accepting a raw pointer, this is unsafe because it semantically\n-    /// moves the value out of `self` without preventing further usage of `self`.\n-    /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-    /// `self` is not used before the data is overwritten again (e.g. with `write`,\n-    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n-    /// because it will attempt to drop the value previously at `*self`.\n-    ///\n-    /// Just like in C, whether an operation is volatile has no bearing whatsoever\n-    /// on questions involving concurrent access from multiple threads. Volatile\n-    /// accesses behave exactly like non-atomic accesses in that regard. In particular,\n-    /// a race between a `read_volatile` and any write operation to the same location\n-    /// is undefined behavior.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let x = 12;\n-    /// let y = &x as *const i32;\n+    /// See [`ptr::read_volatile`] for safety concerns and examples.\n     ///\n-    /// unsafe {\n-    ///     assert_eq!(y.read_volatile(), 12);\n-    /// }\n-    /// ```\n+    /// [`ptr::read_volatile`]: ./ptr/fn.read_volatile.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_volatile(self) -> T\n@@ -1493,27 +1435,9 @@ impl<T: ?Sized> *const T {\n     ///\n     /// Unlike `read`, the pointer may be unaligned.\n     ///\n-    /// # Safety\n-    ///\n-    /// Beyond accepting a raw pointer, this is unsafe because it semantically\n-    /// moves the value out of `self` without preventing further usage of `self`.\n-    /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-    /// `self` is not used before the data is overwritten again (e.g. with `write`,\n-    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n-    /// because it will attempt to drop the value previously at `*self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let x = 12;\n-    /// let y = &x as *const i32;\n+    /// See [`ptr::read_unaligned`] for safety concerns and examples.\n     ///\n-    /// unsafe {\n-    ///     assert_eq!(y.read_unaligned(), 12);\n-    /// }\n-    /// ```\n+    /// [`ptr::read_unaligned`]: ./ptr/fn.read_unaligned.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_unaligned(self) -> T\n@@ -1525,30 +1449,11 @@ impl<T: ?Sized> *const T {\n     /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n     /// and destination may overlap.\n     ///\n-    /// NOTE: this has the *same* argument order as `ptr::copy`.\n-    ///\n-    /// This is semantically equivalent to C's `memmove`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// Care must be taken with the ownership of `self` and `dest`.\n-    /// This method semantically moves the values of `self` into `dest`.\n-    /// However it does not drop the contents of `dest`, or prevent the contents\n-    /// of `self` from being dropped or used.\n-    ///\n-    /// # Examples\n+    /// NOTE: this has the *same* argument order as [`ptr::copy`].\n     ///\n-    /// Efficiently create a Rust vector from an unsafe buffer:\n+    /// See [`ptr::copy`] for safety concerns and examples.\n     ///\n-    /// ```\n-    /// # #[allow(dead_code)]\n-    /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n-    ///     let mut dst = Vec::with_capacity(elts);\n-    ///     dst.set_len(elts);\n-    ///     ptr.copy_to(dst.as_mut_ptr(), elts);\n-    ///     dst\n-    /// }\n-    /// ```\n+    /// [`ptr::copy`]: ./ptr/fn.copy.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to(self, dest: *mut T, count: usize)\n@@ -1560,32 +1465,11 @@ impl<T: ?Sized> *const T {\n     /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n     /// and destination may *not* overlap.\n     ///\n-    /// NOTE: this has the *same* argument order as `ptr::copy_nonoverlapping`.\n+    /// NOTE: this has the *same* argument order as [`ptr::copy_nonoverlapping`].\n     ///\n-    /// `copy_nonoverlapping` is semantically equivalent to C's `memcpy`.\n+    /// See [`ptr::copy_nonoverlapping`] for safety concerns and examples.\n     ///\n-    /// # Safety\n-    ///\n-    /// Beyond requiring that the program must be allowed to access both regions\n-    /// of memory, it is Undefined Behavior for source and destination to\n-    /// overlap. Care must also be taken with the ownership of `self` and\n-    /// `self`. This method semantically moves the values of `self` into `dest`.\n-    /// However it does not drop the contents of `dest`, or prevent the contents\n-    /// of `self` from being dropped or used.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Efficiently create a Rust vector from an unsafe buffer:\n-    ///\n-    /// ```\n-    /// # #[allow(dead_code)]\n-    /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n-    ///     let mut dst = Vec::with_capacity(elts);\n-    ///     dst.set_len(elts);\n-    ///     ptr.copy_to_nonoverlapping(dst.as_mut_ptr(), elts);\n-    ///     dst\n-    /// }\n-    /// ```\n+    /// [`ptr::copy_nonoverlapping`]: ./ptr/fn.copy_nonoverlapping.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n@@ -2155,29 +2039,9 @@ impl<T: ?Sized> *mut T {\n     /// Reads the value from `self` without moving it. This leaves the\n     /// memory in `self` unchanged.\n     ///\n-    /// # Safety\n-    ///\n-    /// Beyond accepting a raw pointer, this is unsafe because it semantically\n-    /// moves the value out of `self` without preventing further usage of `self`.\n-    /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-    /// `self` is not used before the data is overwritten again (e.g. with `write`,\n-    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n-    /// because it will attempt to drop the value previously at `*self`.\n-    ///\n-    /// The pointer must be aligned; use `read_unaligned` if that is not the case.\n+    /// See [`ptr::read`] for safety concerns and examples.\n     ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let x = 12;\n-    /// let y = &x as *const i32;\n-    ///\n-    /// unsafe {\n-    ///     assert_eq!(y.read(), 12);\n-    /// }\n-    /// ```\n+    /// [`ptr::read`]: ./ptr/fn.read.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read(self) -> T\n@@ -2193,47 +2057,9 @@ impl<T: ?Sized> *mut T {\n     /// to not be elided or reordered by the compiler across other volatile\n     /// operations.\n     ///\n-    /// # Notes\n-    ///\n-    /// Rust does not currently have a rigorously and formally defined memory model,\n-    /// so the precise semantics of what \"volatile\" means here is subject to change\n-    /// over time. That being said, the semantics will almost always end up pretty\n-    /// similar to [C11's definition of volatile][c11].\n-    ///\n-    /// The compiler shouldn't change the relative order or number of volatile\n-    /// memory operations. However, volatile memory operations on zero-sized types\n-    /// (e.g. if a zero-sized type is passed to `read_volatile`) are no-ops\n-    /// and may be ignored.\n-    ///\n-    /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n+    /// See [`ptr::read_volatile`] for safety concerns and examples.\n     ///\n-    /// # Safety\n-    ///\n-    /// Beyond accepting a raw pointer, this is unsafe because it semantically\n-    /// moves the value out of `self` without preventing further usage of `self`.\n-    /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-    /// `self` is not used before the data is overwritten again (e.g. with `write`,\n-    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n-    /// because it will attempt to drop the value previously at `*self`.\n-    ///\n-    /// Just like in C, whether an operation is volatile has no bearing whatsoever\n-    /// on questions involving concurrent access from multiple threads. Volatile\n-    /// accesses behave exactly like non-atomic accesses in that regard. In particular,\n-    /// a race between a `read_volatile` and any write operation to the same location\n-    /// is undefined behavior.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let x = 12;\n-    /// let y = &x as *const i32;\n-    ///\n-    /// unsafe {\n-    ///     assert_eq!(y.read_volatile(), 12);\n-    /// }\n-    /// ```\n+    /// [`ptr::read_volatile`]: ./ptr/fn.read_volatile.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_volatile(self) -> T\n@@ -2247,27 +2073,9 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// Unlike `read`, the pointer may be unaligned.\n     ///\n-    /// # Safety\n-    ///\n-    /// Beyond accepting a raw pointer, this is unsafe because it semantically\n-    /// moves the value out of `self` without preventing further usage of `self`.\n-    /// If `T` is not `Copy`, then care must be taken to ensure that the value at\n-    /// `self` is not used before the data is overwritten again (e.g. with `write`,\n-    /// `write_bytes`, or `copy`). Note that `*self = foo` counts as a use\n-    /// because it will attempt to drop the value previously at `*self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let x = 12;\n-    /// let y = &x as *const i32;\n+    /// See [`ptr::read_unaligned`] for safety concerns and examples.\n     ///\n-    /// unsafe {\n-    ///     assert_eq!(y.read_unaligned(), 12);\n-    /// }\n-    /// ```\n+    /// [`ptr::read_unaligned`]: ./ptr/fn.read_unaligned.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn read_unaligned(self) -> T\n@@ -2279,30 +2087,11 @@ impl<T: ?Sized> *mut T {\n     /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n     /// and destination may overlap.\n     ///\n-    /// NOTE: this has the *same* argument order as `ptr::copy`.\n+    /// NOTE: this has the *same* argument order as [`ptr::copy`].\n     ///\n-    /// This is semantically equivalent to C's `memmove`.\n+    /// See [`ptr::copy`] for safety concerns and examples.\n     ///\n-    /// # Safety\n-    ///\n-    /// Care must be taken with the ownership of `self` and `dest`.\n-    /// This method semantically moves the values of `self` into `dest`.\n-    /// However it does not drop the contents of `self`, or prevent the contents\n-    /// of `dest` from being dropped or used.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Efficiently create a Rust vector from an unsafe buffer:\n-    ///\n-    /// ```\n-    /// # #[allow(dead_code)]\n-    /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n-    ///     let mut dst = Vec::with_capacity(elts);\n-    ///     dst.set_len(elts);\n-    ///     ptr.copy_to(dst.as_mut_ptr(), elts);\n-    ///     dst\n-    /// }\n-    /// ```\n+    /// [`ptr::copy`]: ./ptr/fn.copy.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to(self, dest: *mut T, count: usize)\n@@ -2314,32 +2103,11 @@ impl<T: ?Sized> *mut T {\n     /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n     /// and destination may *not* overlap.\n     ///\n-    /// NOTE: this has the *same* argument order as `ptr::copy_nonoverlapping`.\n-    ///\n-    /// `copy_nonoverlapping` is semantically equivalent to C's `memcpy`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// Beyond requiring that the program must be allowed to access both regions\n-    /// of memory, it is Undefined Behavior for source and destination to\n-    /// overlap. Care must also be taken with the ownership of `self` and\n-    /// `self`. This method semantically moves the values of `self` into `dest`.\n-    /// However it does not drop the contents of `dest`, or prevent the contents\n-    /// of `self` from being dropped or used.\n-    ///\n-    /// # Examples\n+    /// NOTE: this has the *same* argument order as [`ptr::copy_nonoverlapping`].\n     ///\n-    /// Efficiently create a Rust vector from an unsafe buffer:\n+    /// See [`ptr::copy_nonoverlapping`] for safety concerns and examples.\n     ///\n-    /// ```\n-    /// # #[allow(dead_code)]\n-    /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n-    ///     let mut dst = Vec::with_capacity(elts);\n-    ///     dst.set_len(elts);\n-    ///     ptr.copy_to_nonoverlapping(dst.as_mut_ptr(), elts);\n-    ///     dst\n-    /// }\n-    /// ```\n+    /// [`ptr::copy_nonoverlapping`]: ./ptr/fn.copy_nonoverlapping.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n@@ -2351,30 +2119,11 @@ impl<T: ?Sized> *mut T {\n     /// Copies `count * size_of<T>` bytes from `src` to `self`. The source\n     /// and destination may overlap.\n     ///\n-    /// NOTE: this has the *opposite* argument order of `ptr::copy`.\n-    ///\n-    /// This is semantically equivalent to C's `memmove`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// Care must be taken with the ownership of `src` and `self`.\n-    /// This method semantically moves the values of `src` into `self`.\n-    /// However it does not drop the contents of `self`, or prevent the contents\n-    /// of `src` from being dropped or used.\n-    ///\n-    /// # Examples\n+    /// NOTE: this has the *opposite* argument order of [`ptr::copy`].\n     ///\n-    /// Efficiently create a Rust vector from an unsafe buffer:\n+    /// See [`ptr::copy`] for safety concerns and examples.\n     ///\n-    /// ```\n-    /// # #[allow(dead_code)]\n-    /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n-    ///     let mut dst: Vec<T> = Vec::with_capacity(elts);\n-    ///     dst.set_len(elts);\n-    ///     dst.as_mut_ptr().copy_from(ptr, elts);\n-    ///     dst\n-    /// }\n-    /// ```\n+    /// [`ptr::copy`]: ./ptr/fn.copy.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_from(self, src: *const T, count: usize)\n@@ -2386,32 +2135,11 @@ impl<T: ?Sized> *mut T {\n     /// Copies `count * size_of<T>` bytes from `src` to `self`. The source\n     /// and destination may *not* overlap.\n     ///\n-    /// NOTE: this has the *opposite* argument order of `ptr::copy_nonoverlapping`.\n-    ///\n-    /// `copy_nonoverlapping` is semantically equivalent to C's `memcpy`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// Beyond requiring that the program must be allowed to access both regions\n-    /// of memory, it is Undefined Behavior for source and destination to\n-    /// overlap. Care must also be taken with the ownership of `src` and\n-    /// `self`. This method semantically moves the values of `src` into `self`.\n-    /// However it does not drop the contents of `self`, or prevent the contents\n-    /// of `src` from being dropped or used.\n-    ///\n-    /// # Examples\n+    /// NOTE: this has the *opposite* argument order of [`ptr::copy_nonoverlapping`].\n     ///\n-    /// Efficiently create a Rust vector from an unsafe buffer:\n+    /// See [`ptr::copy_nonoverlapping`] for safety concerns and examples.\n     ///\n-    /// ```\n-    /// # #[allow(dead_code)]\n-    /// unsafe fn from_buf_raw<T: Copy>(ptr: *const T, elts: usize) -> Vec<T> {\n-    ///     let mut dst: Vec<T> = Vec::with_capacity(elts);\n-    ///     dst.set_len(elts);\n-    ///     dst.as_mut_ptr().copy_from_nonoverlapping(ptr, elts);\n-    ///     dst\n-    /// }\n-    /// ```\n+    /// [`ptr::copy_nonoverlapping`]: ./ptr/fn.copy_nonoverlapping.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn copy_from_nonoverlapping(self, src: *const T, count: usize)\n@@ -2422,21 +2150,9 @@ impl<T: ?Sized> *mut T {\n \n     /// Executes the destructor (if any) of the pointed-to value.\n     ///\n-    /// This has two use cases:\n+    /// See [`ptr::drop_in_place`] for safety concerns and examples.\n     ///\n-    /// * It is *required* to use `drop_in_place` to drop unsized types like\n-    ///   trait objects, because they can't be read out onto the stack and\n-    ///   dropped normally.\n-    ///\n-    /// * It is friendlier to the optimizer to do this over `ptr::read` when\n-    ///   dropping manually allocated memory (e.g. when writing Box/Rc/Vec),\n-    ///   as the compiler doesn't need to prove that it's sound to elide the\n-    ///   copy.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This has all the same safety problems as `ptr::read` with respect to\n-    /// invalid pointers, types, and double drops.\n+    /// [`ptr::drop_in_place`]: ./ptr/fn.drop_in_place.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn drop_in_place(self) {\n@@ -2446,36 +2162,9 @@ impl<T: ?Sized> *mut T {\n     /// Overwrites a memory location with the given value without reading or\n     /// dropping the old value.\n     ///\n-    /// # Safety\n-    ///\n-    /// This operation is marked unsafe because it writes through a raw pointer.\n-    ///\n-    /// It does not drop the contents of `self`. This is safe, but it could leak\n-    /// allocations or resources, so care must be taken not to overwrite an object\n-    /// that should be dropped.\n-    ///\n-    /// Additionally, it does not drop `val`. Semantically, `val` is moved into the\n-    /// location pointed to by `self`.\n-    ///\n-    /// This is appropriate for initializing uninitialized memory, or overwriting\n-    /// memory that has previously been `read` from.\n-    ///\n-    /// The pointer must be aligned; use `write_unaligned` if that is not the case.\n-    ///\n-    /// # Examples\n+    /// See [`ptr::write`] for safety concerns and examples.\n     ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut x = 0;\n-    /// let y = &mut x as *mut i32;\n-    /// let z = 12;\n-    ///\n-    /// unsafe {\n-    ///     y.write(z);\n-    ///     assert_eq!(y.read(), 12);\n-    /// }\n-    /// ```\n+    /// [`ptr::write`]: ./ptr/fn.write.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write(self, val: T)\n@@ -2487,16 +2176,9 @@ impl<T: ?Sized> *mut T {\n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n     /// bytes of memory starting at `self` to `val`.\n     ///\n-    /// # Examples\n+    /// See [`ptr::write_bytes`] for safety concerns and examples.\n     ///\n-    /// ```\n-    /// let mut vec = vec![0; 4];\n-    /// unsafe {\n-    ///     let vec_ptr = vec.as_mut_ptr();\n-    ///     vec_ptr.write_bytes(b'a', 2);\n-    /// }\n-    /// assert_eq!(vec, [b'a', b'a', 0, 0]);\n-    /// ```\n+    /// [`ptr::write_bytes`]: ./ptr/fn.write_bytes.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write_bytes(self, val: u8, count: usize)\n@@ -2512,51 +2194,9 @@ impl<T: ?Sized> *mut T {\n     /// to not be elided or reordered by the compiler across other volatile\n     /// operations.\n     ///\n-    /// # Notes\n+    /// See [`ptr::write_volatile`] for safety concerns and examples.\n     ///\n-    /// Rust does not currently have a rigorously and formally defined memory model,\n-    /// so the precise semantics of what \"volatile\" means here is subject to change\n-    /// over time. That being said, the semantics will almost always end up pretty\n-    /// similar to [C11's definition of volatile][c11].\n-    ///\n-    /// The compiler shouldn't change the relative order or number of volatile\n-    /// memory operations. However, volatile memory operations on zero-sized types\n-    /// (e.g. if a zero-sized type is passed to `write_volatile`) are no-ops\n-    /// and may be ignored.\n-    ///\n-    /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n-    ///\n-    /// # Safety\n-    ///\n-    /// This operation is marked unsafe because it accepts a raw pointer.\n-    ///\n-    /// It does not drop the contents of `self`. This is safe, but it could leak\n-    /// allocations or resources, so care must be taken not to overwrite an object\n-    /// that should be dropped.\n-    ///\n-    /// This is appropriate for initializing uninitialized memory, or overwriting\n-    /// memory that has previously been `read` from.\n-    ///\n-    /// Just like in C, whether an operation is volatile has no bearing whatsoever\n-    /// on questions involving concurrent access from multiple threads. Volatile\n-    /// accesses behave exactly like non-atomic accesses in that regard. In particular,\n-    /// a race between a `write_volatile` and any other operation (reading or writing)\n-    /// on the same location is undefined behavior.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut x = 0;\n-    /// let y = &mut x as *mut i32;\n-    /// let z = 12;\n-    ///\n-    /// unsafe {\n-    ///     y.write_volatile(z);\n-    ///     assert_eq!(y.read_volatile(), 12);\n-    /// }\n-    /// ```\n+    /// [`ptr::write_volatile`]: ./ptr/fn.write_volatile.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write_volatile(self, val: T)\n@@ -2570,34 +2210,9 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// Unlike `write`, the pointer may be unaligned.\n     ///\n-    /// # Safety\n-    ///\n-    /// This operation is marked unsafe because it writes through a raw pointer.\n-    ///\n-    /// It does not drop the contents of `self`. This is safe, but it could leak\n-    /// allocations or resources, so care must be taken not to overwrite an object\n-    /// that should be dropped.\n+    /// See [`ptr::write_unaligned`] for safety concerns and examples.\n     ///\n-    /// Additionally, it does not drop `self`. Semantically, `self` is moved into the\n-    /// location pointed to by `val`.\n-    ///\n-    /// This is appropriate for initializing uninitialized memory, or overwriting\n-    /// memory that has previously been `read` from.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let mut x = 0;\n-    /// let y = &mut x as *mut i32;\n-    /// let z = 12;\n-    ///\n-    /// unsafe {\n-    ///     y.write_unaligned(z);\n-    ///     assert_eq!(y.read_unaligned(), 12);\n-    /// }\n-    /// ```\n+    /// [`ptr::write_unaligned`]: ./ptr/fn.write_unaligned.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn write_unaligned(self, val: T)\n@@ -2609,10 +2224,9 @@ impl<T: ?Sized> *mut T {\n     /// Replaces the value at `self` with `src`, returning the old\n     /// value, without dropping either.\n     ///\n-    /// # Safety\n+    /// See [`ptr::replace`] for safety concerns and examples.\n     ///\n-    /// This is only unsafe because it accepts a raw pointer.\n-    /// Otherwise, this operation is identical to `mem::replace`.\n+    /// [`ptr::replace`]: ./ptr/fn.replace.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn replace(self, src: T) -> T\n@@ -2625,12 +2239,9 @@ impl<T: ?Sized> *mut T {\n     /// deinitializing either. They may overlap, unlike `mem::swap` which is\n     /// otherwise equivalent.\n     ///\n-    /// # Safety\n-    ///\n-    /// This function copies the memory through the raw pointers passed to it\n-    /// as arguments.\n+    /// See [`ptr::swap`] for safety concerns and examples.\n     ///\n-    /// Ensure that these pointers are valid before calling `swap`.\n+    /// [`ptr::swap`]: ./ptr/fn.swap.html\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn swap(self, with: *mut T)"}]}