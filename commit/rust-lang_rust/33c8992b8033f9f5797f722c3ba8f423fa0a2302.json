{"sha": "33c8992b8033f9f5797f722c3ba8f423fa0a2302", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzYzg5OTJiODAzM2Y5ZjU3OTdmNzIyYzNiYThmNDIzZmEwYTIzMDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-09T11:24:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-09T11:24:50Z"}, "message": "Auto merge of #34109 - pnkfelix:fix-issue-34101, r=arielb1\n\nFix issue #34101\n\nFix issue #34101: do not track subcontent of type with dtor nor gather flags for untracked content.\n\n(Includes a regression test, which needed to go into `compile-fail/`\ndue to weaknesses when combining `#[deny(warnings)]` with\n`tcx.sess.span_warn(..)`)", "tree": {"sha": "6f19310b5ed07c94deae061b3ede07d183e61d3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f19310b5ed07c94deae061b3ede07d183e61d3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33c8992b8033f9f5797f722c3ba8f423fa0a2302", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33c8992b8033f9f5797f722c3ba8f423fa0a2302", "html_url": "https://github.com/rust-lang/rust/commit/33c8992b8033f9f5797f722c3ba8f423fa0a2302", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33c8992b8033f9f5797f722c3ba8f423fa0a2302/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24526cc3cc53cecb6e73275ae96b4e698b305931", "url": "https://api.github.com/repos/rust-lang/rust/commits/24526cc3cc53cecb6e73275ae96b4e698b305931", "html_url": "https://github.com/rust-lang/rust/commit/24526cc3cc53cecb6e73275ae96b4e698b305931"}, {"sha": "4b6a68e4470f5c150a7a460f3e0b5aa7462f05d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b6a68e4470f5c150a7a460f3e0b5aa7462f05d3", "html_url": "https://github.com/rust-lang/rust/commit/4b6a68e4470f5c150a7a460f3e0b5aa7462f05d3"}], "stats": {"total": 131, "additions": 103, "deletions": 28}, "files": [{"sha": "d5539f953fb02e5a7b208960efa29d44a98400c5", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/33c8992b8033f9f5797f722c3ba8f423fa0a2302/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c8992b8033f9f5797f722c3ba8f423fa0a2302/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=33c8992b8033f9f5797f722c3ba8f423fa0a2302", "patch": "@@ -197,31 +197,21 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     }\n \n     /// Returns whether this lvalue is tracked by drop elaboration. This\n-    /// includes all lvalues, except these behind references or arrays.\n-    ///\n-    /// Lvalues behind references or arrays are not tracked by elaboration\n-    /// and are always assumed to be initialized when accessible. As\n-    /// references and indexes can be reseated, trying to track them\n-    /// can only lead to trouble.\n+    /// includes all lvalues, except these (1.) behind references or arrays,\n+    ///  or (2.) behind ADT's with a Drop impl.\n     fn lvalue_is_tracked(&self, lv: &Lvalue<'tcx>) -> bool\n     {\n+        // `lvalue_contents_drop_state_cannot_differ` only compares\n+        // the `lv` to its immediate contents, while this recursively\n+        // follows parent chain formed by `base` of each projection.\n         if let &Lvalue::Projection(ref data) = lv {\n-            self.lvalue_contents_are_tracked(&data.base)\n+            !super::lvalue_contents_drop_state_cannot_differ(self.tcx, self.mir, &data.base) &&\n+                self.lvalue_is_tracked(&data.base)\n         } else {\n             true\n         }\n     }\n \n-    fn lvalue_contents_are_tracked(&self, lv: &Lvalue<'tcx>) -> bool {\n-        let ty = self.mir.lvalue_ty(self.tcx, lv).to_ty(self.tcx);\n-        match ty.sty {\n-            ty::TyArray(..) | ty::TySlice(..) | ty::TyRef(..) | ty::TyRawPtr(..) => {\n-                false\n-            }\n-            _ => self.lvalue_is_tracked(lv)\n-        }\n-    }\n-\n     fn collect_drop_flags(&mut self)\n     {\n         for bb in self.mir.all_basic_blocks() {"}, {"sha": "32ffce6440bbc67b4ce803845457bc5d36f50810", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/33c8992b8033f9f5797f722c3ba8f423fa0a2302/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c8992b8033f9f5797f722c3ba8f423fa0a2302/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=33c8992b8033f9f5797f722c3ba8f423fa0a2302", "patch": "@@ -235,6 +235,45 @@ fn move_path_children_matching<'tcx, F>(move_paths: &MovePathData<'tcx>,\n     None\n }\n \n+/// When enumerating the child fragments of a path, don't recurse into\n+/// paths (1.) past arrays, slices, and pointers, nor (2.) into a type\n+/// that implements `Drop`.\n+///\n+/// Lvalues behind references or arrays are not tracked by elaboration\n+/// and are always assumed to be initialized when accessible. As\n+/// references and indexes can be reseated, trying to track them can\n+/// only lead to trouble.\n+///\n+/// Lvalues behind ADT's with a Drop impl are not tracked by\n+/// elaboration since they can never have a drop-flag state that\n+/// differs from that of the parent with the Drop impl.\n+///\n+/// In both cases, the contents can only be accessed if and only if\n+/// their parents are initialized. This implies for example that there\n+/// is no need to maintain separate drop flags to track such state.\n+///\n+/// FIXME: we have to do something for moving slice patterns.\n+fn lvalue_contents_drop_state_cannot_differ<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                      mir: &Mir<'tcx>,\n+                                                      lv: &repr::Lvalue<'tcx>) -> bool {\n+    let ty = mir.lvalue_ty(tcx, lv).to_ty(tcx);\n+    match ty.sty {\n+        ty::TyArray(..) | ty::TySlice(..) | ty::TyRef(..) | ty::TyRawPtr(..) => {\n+            debug!(\"lvalue_contents_drop_state_cannot_differ lv: {:?} ty: {:?} refd => false\",\n+                   lv, ty);\n+            true\n+        }\n+        ty::TyStruct(def, _) | ty::TyEnum(def, _) if def.has_dtor() => {\n+            debug!(\"lvalue_contents_drop_state_cannot_differ lv: {:?} ty: {:?} Drop => false\",\n+                   lv, ty);\n+            true\n+        }\n+        _ => {\n+            false\n+        }\n+    }\n+}\n+\n fn on_all_children_bits<'a, 'tcx, F>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &Mir<'tcx>,\n@@ -251,17 +290,7 @@ fn on_all_children_bits<'a, 'tcx, F>(\n     {\n         match move_data.move_paths[path].content {\n             MovePathContent::Lvalue(ref lvalue) => {\n-                match mir.lvalue_ty(tcx, lvalue).to_ty(tcx).sty {\n-                    // don't trace paths past arrays, slices, and\n-                    // pointers. They can only be accessed while\n-                    // their parents are initialized.\n-                    //\n-                    // FIXME: we have to do something for moving\n-                    // slice patterns.\n-                    ty::TyArray(..) | ty::TySlice(..) |\n-                    ty::TyRef(..) | ty::TyRawPtr(..) => true,\n-                    _ => false\n-                }\n+                lvalue_contents_drop_state_cannot_differ(tcx, mir, lvalue)\n             }\n             _ => true\n         }"}, {"sha": "2940b891534d39f29d6f3967b92a264f08e8ec05", "filename": "src/test/compile-fail/no-warn-on-field-replace-issue-34101.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/33c8992b8033f9f5797f722c3ba8f423fa0a2302/src%2Ftest%2Fcompile-fail%2Fno-warn-on-field-replace-issue-34101.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c8992b8033f9f5797f722c3ba8f423fa0a2302/src%2Ftest%2Fcompile-fail%2Fno-warn-on-field-replace-issue-34101.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-warn-on-field-replace-issue-34101.rs?ref=33c8992b8033f9f5797f722c3ba8f423fa0a2302", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue 34101: Circa 2016-06-05, `fn inline` below issued an\n+// erroneous warning from the elaborate_drops pass about moving out of\n+// a field in `Foo`, which has a destructor (and thus cannot have\n+// content moved out of it). The reason that the warning is erroneous\n+// in this case is that we are doing a *replace*, not a move, of the\n+// content in question, and it is okay to replace fields within `Foo`.\n+//\n+// Another more subtle problem was that the elaborate_drops was\n+// creating a separate drop flag for that internally replaced content,\n+// even though the compiler should enforce an invariant that any drop\n+// flag for such subcontent of `Foo` will always have the same value\n+// as the drop flag for `Foo` itself.\n+//\n+// This test is structured in a funny way; we cannot test for emission\n+// of the warning in question via the lint system, and therefore\n+// `#![deny(warnings)]` does nothing to detect it.\n+//\n+// So instead we use `#[rustc_error]` and put the test into\n+// `compile_fail`, where the emitted warning *will* be caught.\n+\n+#![feature(rustc_attrs)]\n+\n+struct Foo(String);\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) {}\n+}\n+\n+fn inline() {\n+    // (dummy variable so `f` gets assigned `var1` in MIR for both fn's)\n+    let _s = ();\n+    let mut f = Foo(String::from(\"foo\"));\n+    f.0 = String::from(\"bar\");\n+}\n+\n+fn outline() {\n+    let _s = String::from(\"foo\");\n+    let mut f = Foo(_s);\n+    f.0 = String::from(\"bar\");\n+}\n+\n+#[rustc_error]\n+fn main() { //~ ERROR compilation successful\n+    inline();\n+    outline();\n+}"}]}