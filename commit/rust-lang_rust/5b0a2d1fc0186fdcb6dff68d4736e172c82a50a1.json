{"sha": "5b0a2d1fc0186fdcb6dff68d4736e172c82a50a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViMGEyZDFmYzAxODZmZGNiNmRmZjY4ZDQ3MzZlMTcyYzgyYTUwYTE=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-02-26T19:15:08Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-02-27T10:30:15Z"}, "message": "treemap: improve the lazy iterator\n\n* replace the dual next() and get() calls with a single next() function\n* drop one of the pointer members from the struct\n* add a method for using the lazy iterator with a for loop", "tree": {"sha": "97f33233282a8881996ab816dd6eff59b11123a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97f33233282a8881996ab816dd6eff59b11123a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b0a2d1fc0186fdcb6dff68d4736e172c82a50a1", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b0a2d1fc0186fdcb6dff68d4736e172c82a50a1", "html_url": "https://github.com/rust-lang/rust/commit/5b0a2d1fc0186fdcb6dff68d4736e172c82a50a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b0a2d1fc0186fdcb6dff68d4736e172c82a50a1/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40ffaeaea8f434d59f5dffbe8fc7be958a625e03", "url": "https://api.github.com/repos/rust-lang/rust/commits/40ffaeaea8f434d59f5dffbe8fc7be958a625e03", "html_url": "https://github.com/rust-lang/rust/commit/40ffaeaea8f434d59f5dffbe8fc7be958a625e03"}], "stats": {"total": 206, "additions": 93, "deletions": 113}, "files": [{"sha": "0e593ba42d12951ac6ebe5f9f1facbf95ed4f725", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 93, "deletions": 113, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/5b0a2d1fc0186fdcb6dff68d4736e172c82a50a1/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0a2d1fc0186fdcb6dff68d4736e172c82a50a1/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=5b0a2d1fc0186fdcb6dff68d4736e172c82a50a1", "patch": "@@ -48,13 +48,8 @@ impl<K:Eq + Ord,V:Eq> Eq for TreeMap<K, V> {\n             let mut y = other.iter();\n             for self.len().times {\n                 unsafe { // unsafe as a purity workaround\n-                    map_next(&mut x);\n-                    map_next(&mut y);\n-                    // FIXME: #4492 (ICE), x.get() == y.get()\n-                    let (x1, x2) = x.get().unwrap();\n-                    let (y1, y2) = y.get().unwrap();\n-\n-                    if x1 != y1 || x2 != y2 {\n+                    if map_next(&mut x).unwrap() !=\n+                       map_next(&mut y).unwrap() {\n                         return false\n                     }\n                 }\n@@ -73,10 +68,8 @@ pure fn lt<K:Ord,V>(a: &TreeMap<K, V>, b: &TreeMap<K, V>) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     for uint::min(a_len, b_len).times {\n         unsafe { // purity workaround\n-            map_next(&mut x);\n-            map_next(&mut y);\n-            let (key_a,_) = x.get().unwrap();\n-            let (key_b,_) = y.get().unwrap();\n+            let (key_a,_) = map_next(&mut x).unwrap();\n+            let (key_b,_) = map_next(&mut y).unwrap();\n             if *key_a < *key_b { return true; }\n             if *key_a > *key_b { return false; }\n         }\n@@ -201,30 +194,21 @@ impl <K:Ord,V> TreeMap<K, V> {\n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n     pure fn iter(&self) -> TreeMapIterator/&self<K, V> {\n-        TreeMapIterator{stack: ~[], node: &self.root, current: None}\n+        TreeMapIterator{stack: ~[], node: &self.root}\n     }\n }\n \n /// Lazy forward iterator over a map\n pub struct TreeMapIterator<K, V> {\n     priv stack: ~[&~TreeNode<K, V>],\n-    priv node: &Option<~TreeNode<K, V>>,\n-    priv current: Option<&~TreeNode<K, V>>\n+    priv node: &Option<~TreeNode<K, V>>\n }\n \n-impl <K:Ord,V> TreeMapIterator<K, V> {\n-    // Returns the current node, or None if this iterator is at the end.\n-    fn get(&const self) -> Option<(&self/K, &self/V)> {\n-        match self.current {\n-          Some(res) => Some((&res.key, &res.value)),\n-          None => None\n-        }\n-    }\n-}\n-\n-/// Advance the iterator to the next node (in order). If this iterator\n-/// is finished, does nothing.\n-pub fn map_next<K:Ord,V>(iter: &mut TreeMapIterator/&a<K, V>) {\n+/// Advance the iterator to the next node (in order) and return a\n+/// tuple with a reference to the key and value. If there are no\n+/// more nodes, return `None`.\n+fn map_next<K: Ord, V>(iter: &mut TreeMapIterator/&r<K, V>)\n+ -> Option<(&r/K, &r/V)> {\n     while !iter.stack.is_empty() || iter.node.is_some() {\n         match *iter.node {\n           Some(ref x) => {\n@@ -234,12 +218,24 @@ pub fn map_next<K:Ord,V>(iter: &mut TreeMapIterator/&a<K, V>) {\n           None => {\n             let res = iter.stack.pop();\n             iter.node = &res.right;\n-            iter.current = Some(res);\n-            return;\n+            return Some((&res.key, &res.value));\n           }\n         }\n     }\n-    iter.current = None;\n+    None\n+}\n+\n+/// Advance the iterator through the map\n+fn map_advance<K: Ord, V>(iter: &mut TreeMapIterator/&r<K, V>,\n+                          f: fn((&r/K, &r/V)) -> bool) {\n+    loop {\n+        match map_next(iter) {\n+          Some(x) => {\n+            if !f(x) { return }\n+          }\n+          None => return\n+        }\n+    }\n }\n \n pub struct TreeSet<T> {\n@@ -308,19 +304,15 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n         let mut x = self.iter();\n         let mut y = other.iter();\n         unsafe { // purity workaround\n-            set_next(&mut x);\n-            set_next(&mut y);\n-            let mut a = x.get();\n-            let mut b = y.get();\n+            let mut a = set_next(&mut x);\n+            let mut b = set_next(&mut y);\n             while a.is_some() && b.is_some() {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n                 if a1 < b1 {\n-                    set_next(&mut x);\n-                    a = x.get();\n+                    a = set_next(&mut x);\n                 } else if b1 < a1 {\n-                    set_next(&mut y);\n-                    b = y.get();\n+                    b = set_next(&mut y);\n                 } else {\n                     return false;\n                 }\n@@ -339,10 +331,8 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n         let mut x = self.iter();\n         let mut y = other.iter();\n         unsafe { // purity workaround\n-            set_next(&mut x);\n-            set_next(&mut y);\n-            let mut a = x.get();\n-            let mut b = y.get();\n+            let mut a = set_next(&mut x);\n+            let mut b = set_next(&mut y);\n             while b.is_some() {\n                 if a.is_none() {\n                     return false\n@@ -356,11 +346,9 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n                 }\n \n                 if !(a1 < b1) {\n-                    set_next(&mut y);\n-                    b = y.get();\n+                    b = set_next(&mut y);\n                 }\n-                set_next(&mut x);\n-                a = x.get();\n+                a = set_next(&mut x);\n             }\n         }\n         true\n@@ -372,15 +360,13 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            set_next(&mut x);\n-            set_next(&mut y);\n-            let mut a = x.get();\n-            let mut b = y.get();\n+            let mut a = set_next(&mut x);\n+            let mut b = set_next(&mut y);\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { set_next(&mut x); x.get() } else { None }\n+                        if f(a1) { set_next(&mut x) } else { None }\n                     }\n                 }\n \n@@ -389,12 +375,10 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n \n                 if a1 < b1 {\n                     if !f(a1) { return }\n-                    set_next(&mut x);\n-                    a = x.get();\n+                    a = set_next(&mut x);\n                 } else {\n-                    if !(b1 < a1) { set_next(&mut x); a = x.get() }\n-                    set_next(&mut y);\n-                    b = y.get();\n+                    if !(b1 < a1) { a = set_next(&mut x) }\n+                    b = set_next(&mut y);\n                 }\n             }\n         }\n@@ -407,15 +391,13 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            set_next(&mut x);\n-            set_next(&mut y);\n-            let mut a = x.get();\n-            let mut b = y.get();\n+            let mut a = set_next(&mut x);\n+            let mut b = set_next(&mut y);\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { set_next(&mut x); x.get() } else { None }\n+                        if f(a1) { set_next(&mut x) } else { None }\n                     }\n                 }\n \n@@ -424,21 +406,18 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n \n                 if a1 < b1 {\n                     if !f(a1) { return }\n-                    set_next(&mut x);\n-                    a = x.get();\n+                    a = set_next(&mut x);\n                 } else {\n                     if b1 < a1 {\n                         if !f(b1) { return }\n                     } else {\n-                        set_next(&mut x);\n-                        a = x.get();\n+                        a = set_next(&mut x);\n                     }\n-                    set_next(&mut y);\n-                    b = y.get();\n+                    b = set_next(&mut y);\n                 }\n             }\n             do b.while_some |b1| {\n-                if f(b1) { set_next(&mut y); y.get() } else { None }\n+                if f(b1) { set_next(&mut y) } else { None }\n             }\n         }\n     }\n@@ -449,23 +428,19 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            set_next(&mut x);\n-            set_next(&mut y);\n-            let mut a = x.get();\n-            let mut b = y.get();\n+            let mut a = set_next(&mut x);\n+            let mut b = set_next(&mut y);\n \n             while a.is_some() && b.is_some() {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n                 if a1 < b1 {\n-                    set_next(&mut x);\n-                    a = x.get();\n+                    a = set_next(&mut x);\n                 } else {\n                     if !(b1 < a1) {\n                         if !f(a1) { return }\n                     }\n-                    set_next(&mut y);\n-                    b = y.get();\n+                    b = set_next(&mut y);\n                 }\n             }\n         }\n@@ -477,15 +452,13 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            set_next(&mut x);\n-            set_next(&mut y);\n-            let mut a = x.get();\n-            let mut b = y.get();\n+            let mut a = set_next(&mut x);\n+            let mut b = set_next(&mut y);\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { set_next(&mut x); x.get() } else { None }\n+                        if f(a1) { set_next(&mut x) } else { None }\n                     }\n                 }\n \n@@ -494,16 +467,13 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n \n                 if b1 < a1 {\n                     if !f(b1) { return }\n-                    set_next(&mut y);\n-                    b = y.get();\n+                    b = set_next(&mut y);\n                 } else {\n                     if !f(a1) { return }\n                     if !(a1 < b1) {\n-                        set_next(&mut y);\n-                        b = y.get()\n+                        b = set_next(&mut y);\n                     }\n-                    set_next(&mut x);\n-                    a = x.get();\n+                    a = set_next(&mut x);\n                 }\n             }\n         }\n@@ -526,20 +496,16 @@ pub struct TreeSetIterator<T> {\n     priv iter: TreeMapIterator<T, ()>\n }\n \n-impl <T:Ord> TreeSetIterator<T> {\n-    /// Returns the current node, or None if this iterator is at the end.\n-    fn get(&const self) -> Option<&self/T> {\n-        match self.iter.get() {\n-          None => None,\n-          Some((k, _)) => Some(k)\n-        }\n-    }\n-}\n-\n /// Advance the iterator to the next node (in order). If this iterator is\n /// finished, does nothing.\n-pub fn set_next<T:Ord>(iter: &mut TreeSetIterator/&a<T>) {\n-    map_next(&mut iter.iter);\n+pub fn set_next<T: Ord>(iter: &mut TreeSetIterator/&r<T>) -> Option<&r/T> {\n+    do map_next(&mut iter.iter).map |&(value, _)| { value }\n+}\n+\n+/// Advance the iterator through the set\n+fn set_advance<T: Ord>(iter: &mut TreeSetIterator/&r<T>,\n+                       f: fn(&r/T) -> bool) {\n+    do map_advance(&mut iter.iter) |(k, _)| { f(k) }\n }\n \n // Nodes keep track of their level in the tree, starting at 1 in the\n@@ -983,23 +949,37 @@ mod test_treemap {\n         assert m.insert(x5, y5);\n \n         let m = m;\n-        let mut iter = m.iter();\n+        let mut a = m.iter();\n \n         // FIXME: #4492 (ICE): iter.get() == Some((&x1, &y1))\n \n-        map_next(&mut iter);\n-        assert iter.get().unwrap() == (&x1, &y1);\n-        map_next(&mut iter);\n-        assert iter.get().unwrap() == (&x2, &y2);\n-        map_next(&mut iter);\n-        assert iter.get().unwrap() == (&x3, &y3);\n-        map_next(&mut iter);\n-        assert iter.get().unwrap() == (&x4, &y4);\n-        map_next(&mut iter);\n-        assert iter.get().unwrap() == (&x5, &y5);\n-\n-        map_next(&mut iter);\n-        assert iter.get().is_none();\n+        assert map_next(&mut a).unwrap() == (&x1, &y1);\n+        assert map_next(&mut a).unwrap() == (&x2, &y2);\n+        assert map_next(&mut a).unwrap() == (&x3, &y3);\n+        assert map_next(&mut a).unwrap() == (&x4, &y4);\n+        assert map_next(&mut a).unwrap() == (&x5, &y5);\n+\n+        assert map_next(&mut a).is_none();\n+\n+        let mut b = m.iter();\n+\n+        let expected = [(&x1, &y1), (&x2, &y2), (&x3, &y3), (&x4, &y4),\n+                        (&x5, &y5)];\n+        let mut i = 0;\n+\n+        for map_advance(&mut b) |x| {\n+            assert expected[i] == x;\n+            i += 1;\n+\n+            if i == 2 {\n+                break\n+            }\n+        }\n+\n+        for map_advance(&mut b) |x| {\n+            assert expected[i] == x;\n+            i += 1;\n+        }\n     }\n }\n "}]}