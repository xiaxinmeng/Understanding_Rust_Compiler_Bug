{"sha": "93335141021df7d53ba597f6315a8014fe21195f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzMzM1MTQxMDIxZGY3ZDUzYmE1OTdmNjMxNWE4MDE0ZmUyMTE5NWY=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2019-09-14T11:00:16Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2019-09-28T00:11:13Z"}, "message": "Move Ref-from-arg checking from `step.rs` to `const_prop.rs`", "tree": {"sha": "8232ec3f578f25b6e761b5255d11bc32ca8b6f99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8232ec3f578f25b6e761b5255d11bc32ca8b6f99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93335141021df7d53ba597f6315a8014fe21195f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93335141021df7d53ba597f6315a8014fe21195f", "html_url": "https://github.com/rust-lang/rust/commit/93335141021df7d53ba597f6315a8014fe21195f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93335141021df7d53ba597f6315a8014fe21195f/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15d2b7ae8122c19c4c4133a6206f90f676a60dff", "url": "https://api.github.com/repos/rust-lang/rust/commits/15d2b7ae8122c19c4c4133a6206f90f676a60dff", "html_url": "https://github.com/rust-lang/rust/commit/15d2b7ae8122c19c4c4133a6206f90f676a60dff"}], "stats": {"total": 194, "additions": 95, "deletions": 99}, "files": [{"sha": "daca7a25787ca5d734bb137b3efe93fc5fa17e3b", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/93335141021df7d53ba597f6315a8014fe21195f/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93335141021df7d53ba597f6315a8014fe21195f/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=93335141021df7d53ba597f6315a8014fe21195f", "patch": "@@ -2,11 +2,11 @@\n //!\n //! The main entry point is the `step` method.\n \n-use rustc::mir::{self, Place, PlaceBase};\n+use rustc::mir;\n use rustc::ty::layout::LayoutOf;\n use rustc::mir::interpret::{InterpResult, Scalar, PointerArithmetic};\n \n-use super::{InterpCx, LocalValue, Machine};\n+use super::{InterpCx, Machine};\n \n /// Classify whether an operator is \"left-homogeneous\", i.e., the LHS has the\n /// same type as the result.\n@@ -240,23 +240,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             Ref(_, _, ref place) => {\n-                // FIXME(wesleywiser) we don't currently handle the case where we try to make a ref\n-                // from a function argument that hasn't been assigned to in this function. So just\n-                // report those as uninitialized for now.\n-                if let Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box []\n-                } = place {\n-                    let alive =\n-                        if let LocalValue::Live(_) = self.frame().locals[*local].value {\n-                            true\n-                        } else { false };\n-\n-                    if local.as_usize() <= self.frame().body.arg_count && !alive {\n-                        trace!(\"skipping Ref({:?})\", place);\n-                        throw_unsup!(UninitializedLocal);\n-                    }\n-                }\n                 let src = self.eval_place(place)?;\n                 let place = self.force_allocation(src)?;\n                 if place.layout.size.bytes() > 0 {"}, {"sha": "d7d58327865b9bfc4167f40e2cf6207a3481a4be", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 93, "deletions": 80, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/93335141021df7d53ba597f6315a8014fe21195f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93335141021df7d53ba597f6315a8014fe21195f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=93335141021df7d53ba597f6315a8014fe21195f", "patch": "@@ -24,7 +24,7 @@ use rustc::ty::layout::{\n \n use crate::interpret::{\n     self, InterpCx, ScalarMaybeUndef, Immediate, OpTy,\n-    ImmTy, StackPopCleanup, LocalValue, LocalState,\n+    StackPopCleanup, LocalValue, LocalState,\n };\n use crate::const_eval::{\n     CompileTimeInterpreter, error_to_const_error, mk_eval_cx,\n@@ -311,102 +311,115 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         place: &Place<'tcx>,\n     ) -> Option<Const<'tcx>> {\n         let span = source_info.span;\n-        match *rvalue {\n+\n+        // if this isn't a supported operation, then return None\n+        match rvalue {\n             Rvalue::Repeat(..) |\n             Rvalue::Aggregate(..) |\n             Rvalue::NullaryOp(NullOp::Box, _) |\n-            Rvalue::Discriminant(..) => None,\n+            Rvalue::Discriminant(..) => return None,\n \n             Rvalue::Use(_) |\n             Rvalue::Len(_) |\n             Rvalue::Cast(..) |\n             Rvalue::NullaryOp(..) |\n             Rvalue::CheckedBinaryOp(..) |\n-            Rvalue::Ref(..) => {\n-                self.use_ecx(source_info, |this| {\n-                    this.ecx.eval_rvalue_into_place(rvalue, place)?;\n-                    this.ecx.eval_place_to_op(place, Some(place_layout))\n-                })\n-            },\n+            Rvalue::Ref(..) |\n+            Rvalue::UnaryOp(..) |\n+            Rvalue::BinaryOp(..) => { }\n+        }\n \n-            Rvalue::UnaryOp(op, ref arg) => {\n-                let overflow_check = self.tcx.sess.overflow_checks();\n-\n-                self.use_ecx(source_info, |this| {\n-                    // We check overflow in debug mode already\n-                    // so should only check in release mode.\n-                    if op == UnOp::Neg && !overflow_check {\n-                        let ty = arg.ty(&this.local_decls, this.tcx);\n-\n-                        if ty.is_integral() {\n-                            let arg = this.ecx.eval_operand(arg, None)?;\n-                            let prim = this.ecx.read_immediate(arg)?;\n-                            // Need to do overflow check here: For actual CTFE, MIR\n-                            // generation emits code that does this before calling the op.\n-                            if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n-                                throw_panic!(OverflowNeg)\n-                            }\n+        // perform any special checking for specific Rvalue types\n+        if let Rvalue::UnaryOp(op, arg) = rvalue {\n+            trace!(\"checking UnaryOp(op = {:?}, arg = {:?})\", op, arg);\n+            let overflow_check = self.tcx.sess.overflow_checks();\n+\n+            self.use_ecx(source_info, |this| {\n+                // We check overflow in debug mode already\n+                // so should only check in release mode.\n+                if *op == UnOp::Neg && !overflow_check {\n+                    let ty = arg.ty(&this.local_decls, this.tcx);\n+\n+                    if ty.is_integral() {\n+                        let arg = this.ecx.eval_operand(arg, None)?;\n+                        let prim = this.ecx.read_immediate(arg)?;\n+                        // Need to do overflow check here: For actual CTFE, MIR\n+                        // generation emits code that does this before calling the op.\n+                        if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n+                            throw_panic!(OverflowNeg)\n                         }\n                     }\n-\n-                    this.ecx.eval_rvalue_into_place(rvalue, place)?;\n-                    this.ecx.eval_place_to_op(place, Some(place_layout))\n-                })\n-            }\n-            Rvalue::BinaryOp(op, ref left, ref right) => {\n-                trace!(\"rvalue binop {:?} for {:?} and {:?}\", op, left, right);\n-\n-                let r = self.use_ecx(source_info, |this| {\n-                    this.ecx.read_immediate(this.ecx.eval_operand(right, None)?)\n-                })?;\n-                if op == BinOp::Shr || op == BinOp::Shl {\n-                    let left_bits = place_layout.size.bits();\n-                    let right_size = r.layout.size;\n-                    let r_bits = r.to_scalar().and_then(|r| r.to_bits(right_size));\n-                    if r_bits.ok().map_or(false, |b| b >= left_bits as u128) {\n-                        let source_scope_local_data = match self.source_scope_local_data {\n-                            ClearCrossCrate::Set(ref data) => data,\n-                            ClearCrossCrate::Clear => return None,\n-                        };\n-                        let dir = if op == BinOp::Shr {\n-                            \"right\"\n-                        } else {\n-                            \"left\"\n-                        };\n-                        let hir_id = source_scope_local_data[source_info.scope].lint_root;\n-                        self.tcx.lint_hir(\n-                            ::rustc::lint::builtin::EXCEEDING_BITSHIFTS,\n-                            hir_id,\n-                            span,\n-                            &format!(\"attempt to shift {} with overflow\", dir));\n-                        return None;\n-                    }\n                 }\n-                trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n-                let val = self.use_ecx(source_info, |this| {\n-                    let l = this.ecx.read_immediate(this.ecx.eval_operand(left, None)?)?;\n-                    let (val, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n-\n-                    // We check overflow in debug mode already\n-                    // so should only check in release mode.\n-                    if !this.tcx.sess.overflow_checks() && overflow {\n-                        let err = err_panic!(Overflow(op)).into();\n-                        return Err(err);\n-                    }\n \n-                    let val = ImmTy {\n-                        imm: Immediate::Scalar(val.into()),\n-                        layout: place_layout,\n+                Ok(())\n+            })?;\n+        } else if let Rvalue::BinaryOp(op, left, right) = rvalue {\n+            trace!(\"checking BinaryOp(op = {:?}, left = {:?}, right = {:?})\", op, left, right);\n+\n+            let r = self.use_ecx(source_info, |this| {\n+                this.ecx.read_immediate(this.ecx.eval_operand(right, None)?)\n+            })?;\n+            if *op == BinOp::Shr || *op == BinOp::Shl {\n+                let left_bits = place_layout.size.bits();\n+                let right_size = r.layout.size;\n+                let r_bits = r.to_scalar().and_then(|r| r.to_bits(right_size));\n+                if r_bits.ok().map_or(false, |b| b >= left_bits as u128) {\n+                    let source_scope_local_data = match self.source_scope_local_data {\n+                        ClearCrossCrate::Set(ref data) => data,\n+                        ClearCrossCrate::Clear => return None,\n                     };\n+                    let dir = if *op == BinOp::Shr {\n+                        \"right\"\n+                    } else {\n+                        \"left\"\n+                    };\n+                    let hir_id = source_scope_local_data[source_info.scope].lint_root;\n+                    self.tcx.lint_hir(\n+                        ::rustc::lint::builtin::EXCEEDING_BITSHIFTS,\n+                        hir_id,\n+                        span,\n+                        &format!(\"attempt to shift {} with overflow\", dir));\n+                    return None;\n+                }\n+            }\n+            self.use_ecx(source_info, |this| {\n+                let l = this.ecx.read_immediate(this.ecx.eval_operand(left, None)?)?;\n+                let (_, overflow, _ty) = this.ecx.overflowing_binary_op(*op, l, r)?;\n+\n+                // We check overflow in debug mode already\n+                // so should only check in release mode.\n+                if !this.tcx.sess.overflow_checks() && overflow {\n+                    let err = err_panic!(Overflow(*op)).into();\n+                    return Err(err);\n+                }\n \n-                    let dest = this.ecx.eval_place(place)?;\n-                    this.ecx.write_immediate(*val, dest)?;\n-\n-                    Ok(val)\n-                })?;\n-                Some(val.into())\n-            },\n+                Ok(())\n+            })?;\n+        } else if let Rvalue::Ref(_, _, place) = rvalue {\n+            trace!(\"checking Ref({:?})\", place);\n+            // FIXME(wesleywiser) we don't currently handle the case where we try to make a ref\n+            // from a function argument that hasn't been assigned to in this function.\n+            if let Place {\n+                base: PlaceBase::Local(local),\n+                projection: box []\n+            } = place {\n+                let alive =\n+                    if let LocalValue::Live(_) = self.ecx.frame().locals[*local].value {\n+                        true\n+                    } else { false };\n+\n+                if local.as_usize() <= self.ecx.frame().body.arg_count && !alive {\n+                    trace!(\"skipping Ref({:?})\", place);\n+                    return None;\n+                }\n+            }\n         }\n+\n+        self.use_ecx(source_info, |this| {\n+            trace!(\"calling eval_rvalue_into_place(rvalue = {:?}, place = {:?})\", rvalue, place);\n+            this.ecx.eval_rvalue_into_place(rvalue, place)?;\n+            this.ecx.eval_place_to_op(place, Some(place_layout))\n+        })\n     }\n \n     fn operand_from_scalar(&self, scalar: Scalar, ty: Ty<'tcx>, span: Span) -> Operand<'tcx> {"}]}