{"sha": "5d1d285623f8d454a62ca16cf8ec2533aad23305", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkMWQyODU2MjNmOGQ0NTRhNjJjYTE2Y2Y4ZWMyNTMzYWFkMjMzMDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-09T04:51:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-09T04:51:48Z"}, "message": "auto merge of #12758 : rgawdzik/rust/master, r=alexcrichton\n\nRefactored get_metadata_section to return a Result<MetadataBlob,~str> instead of a Option<MetadataBlob>. This provides more clarity to the user through the debug output when using --ls.\r\n\r\nThis is kind of a continuation of my original closed pull request 2 months ago (#11544), but I think the time-span constitutes a new pull request.", "tree": {"sha": "b41b3e52d04d46e659082a30b4f830973730889b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b41b3e52d04d46e659082a30b4f830973730889b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d1d285623f8d454a62ca16cf8ec2533aad23305", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d1d285623f8d454a62ca16cf8ec2533aad23305", "html_url": "https://github.com/rust-lang/rust/commit/5d1d285623f8d454a62ca16cf8ec2533aad23305", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d1d285623f8d454a62ca16cf8ec2533aad23305/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f64adc44b1245ba644f66c29d6bbc5c940422c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f64adc44b1245ba644f66c29d6bbc5c940422c9", "html_url": "https://github.com/rust-lang/rust/commit/5f64adc44b1245ba644f66c29d6bbc5c940422c9"}, {"sha": "3bf724e44bd691871e700d90e0665743112577d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bf724e44bd691871e700d90e0665743112577d5", "html_url": "https://github.com/rust-lang/rust/commit/3bf724e44bd691871e700d90e0665743112577d5"}], "stats": {"total": 45, "additions": 28, "deletions": 17}, "files": [{"sha": "3a0f7edfb5dbc89c6d68229615f2953daea7bbfa", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5d1d285623f8d454a62ca16cf8ec2533aad23305/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d1d285623f8d454a62ca16cf8ec2533aad23305/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=5d1d285623f8d454a62ca16cf8ec2533aad23305", "patch": "@@ -299,17 +299,17 @@ impl<'a> Context<'a> {\n \n         let lib = m.move_iter().next().unwrap();\n         if slot.is_none() {\n-            info!(\"{} reading meatadata from: {}\", flavor, lib.display());\n+            info!(\"{} reading metadata from: {}\", flavor, lib.display());\n             match get_metadata_section(self.os, &lib) {\n-                Some(blob) => {\n+                Ok(blob) => {\n                     if self.crate_matches(blob.as_slice()) {\n                         *slot = Some(blob);\n                     } else {\n                         info!(\"metadata mismatch\");\n                         return None;\n                     }\n                 }\n-                None => {\n+                Err(_) => {\n                     info!(\"no metadata found\");\n                     return None\n                 }\n@@ -388,15 +388,18 @@ impl ArchiveMetadata {\n }\n \n // Just a small wrapper to time how long reading metadata takes.\n-fn get_metadata_section(os: Os, filename: &Path) -> Option<MetadataBlob> {\n+fn get_metadata_section(os: Os, filename: &Path) -> Result<MetadataBlob, ~str> {\n     let start = time::precise_time_ns();\n     let ret = get_metadata_section_imp(os, filename);\n     info!(\"reading {} => {}ms\", filename.filename_display(),\n            (time::precise_time_ns() - start) / 1000000);\n     return ret;\n }\n \n-fn get_metadata_section_imp(os: Os, filename: &Path) -> Option<MetadataBlob> {\n+fn get_metadata_section_imp(os: Os, filename: &Path) -> Result<MetadataBlob, ~str> {\n+    if !filename.exists() {\n+        return Err(format!(\"no such file: '{}'\", filename.display()));\n+    }\n     if filename.filename_str().unwrap().ends_with(\".rlib\") {\n         // Use ArchiveRO for speed here, it's backed by LLVM and uses mmap\n         // internally to read the file. We also avoid even using a memcpy by\n@@ -405,19 +408,26 @@ fn get_metadata_section_imp(os: Os, filename: &Path) -> Option<MetadataBlob> {\n             Some(ar) => ar,\n             None => {\n                 debug!(\"llvm didn't like `{}`\", filename.display());\n-                return None;\n+                return Err(format!(\"failed to read rlib metadata: '{}'\",\n+                                   filename.display()));\n             }\n         };\n-        return ArchiveMetadata::new(archive).map(|ar| MetadataArchive(ar));\n+        return match ArchiveMetadata::new(archive).map(|ar| MetadataArchive(ar)) {\n+            None => return Err(format!(\"failed to read rlib metadata: '{}'\",\n+                                       filename.display())),\n+            Some(blob) => return Ok(blob)\n+        }\n     }\n     unsafe {\n         let mb = filename.with_c_str(|buf| {\n             llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n         });\n-        if mb as int == 0 { return None }\n+        if mb as int == 0 {\n+            return Err(format!(\"error reading library: '{}'\",filename.display()))\n+        }\n         let of = match ObjectFile::new(mb) {\n             Some(of) => of,\n-            _ => return None\n+            _ => return Err(format!(\"provided path not an object file: '{}'\", filename.display()))\n         };\n         let si = mk_section_iter(of.llof);\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n@@ -427,30 +437,31 @@ fn get_metadata_section_imp(os: Os, filename: &Path) -> Option<MetadataBlob> {\n             if read_meta_section_name(os) == name {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n-                let mut found = None;\n+                let mut found = Err(format!(\"metadata not found: '{}'\", filename.display()));\n                 let cvbuf: *u8 = cast::transmute(cbuf);\n                 let vlen = encoder::metadata_encoding_version.len();\n                 debug!(\"checking {} bytes of metadata-version stamp\",\n                        vlen);\n                 let minsz = cmp::min(vlen, csz);\n                 let version_ok = vec::raw::buf_as_slice(cvbuf, minsz,\n                     |buf0| buf0 == encoder::metadata_encoding_version);\n-                if !version_ok { return None; }\n+                if !version_ok { return Err(format!(\"incompatible metadata version found: '{}'\",\n+                                                    filename.display()));}\n \n                 let cvbuf1 = cvbuf.offset(vlen as int);\n                 debug!(\"inflating {} bytes of compressed metadata\",\n                        csz - vlen);\n                 vec::raw::buf_as_slice(cvbuf1, csz-vlen, |bytes| {\n                     let inflated = flate::inflate_bytes(bytes);\n-                    found = Some(MetadataVec(inflated));\n+                    found = Ok(MetadataVec(inflated));\n                 });\n-                if found.is_some() {\n+                if found.is_ok() {\n                     return found;\n                 }\n             }\n             llvm::LLVMMoveToNextSection(si.llsi);\n         }\n-        return None;\n+        return Err(format!(\"metadata not found: '{}'\", filename.display()));\n     }\n }\n \n@@ -478,9 +489,9 @@ pub fn read_meta_section_name(os: Os) -> &'static str {\n pub fn list_file_metadata(os: Os, path: &Path,\n                           out: &mut io::Writer) -> io::IoResult<()> {\n     match get_metadata_section(os, path) {\n-        Some(bytes) => decoder::list_crate_metadata(bytes.as_slice(), out),\n-        None => {\n-            write!(out, \"could not find metadata in {}.\\n\", path.display())\n+        Ok(bytes) => decoder::list_crate_metadata(bytes.as_slice(), out),\n+        Err(msg) => {\n+            write!(out, \"{}\\n\", msg)\n         }\n     }\n }"}]}