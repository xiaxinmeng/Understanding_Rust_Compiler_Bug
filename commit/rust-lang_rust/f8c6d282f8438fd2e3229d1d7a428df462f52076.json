{"sha": "f8c6d282f8438fd2e3229d1d7a428df462f52076", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4YzZkMjgyZjg0MzhmZDJlMzIyOWQxZDdhNDI4ZGY0NjJmNTIwNzY=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-19T02:14:01Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-19T19:01:14Z"}, "message": "Add a pass that finds all of the free variables.", "tree": {"sha": "66b333a31d8ce21b670b0f9d642bd258cffd441a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66b333a31d8ce21b670b0f9d642bd258cffd441a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8c6d282f8438fd2e3229d1d7a428df462f52076", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8c6d282f8438fd2e3229d1d7a428df462f52076", "html_url": "https://github.com/rust-lang/rust/commit/f8c6d282f8438fd2e3229d1d7a428df462f52076", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8c6d282f8438fd2e3229d1d7a428df462f52076/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4bcd0a44d64d43a5c1dfde73d4e3f94e2419da7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4bcd0a44d64d43a5c1dfde73d4e3f94e2419da7", "html_url": "https://github.com/rust-lang/rust/commit/c4bcd0a44d64d43a5c1dfde73d4e3f94e2419da7"}], "stats": {"total": 87, "additions": 69, "deletions": 18}, "files": [{"sha": "b24dedffdd0c8f30444bbaebffe5057e0772d8f2", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8c6d282f8438fd2e3229d1d7a428df462f52076/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8c6d282f8438fd2e3229d1d7a428df462f52076/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=f8c6d282f8438fd2e3229d1d7a428df462f52076", "patch": "@@ -10,6 +10,7 @@ import syntax::codemap;\n import front::attr;\n import middle::trans;\n import middle::resolve;\n+import middle::freevars;\n import middle::ty;\n import middle::typeck;\n import middle::tstate::ck;\n@@ -131,7 +132,10 @@ fn compile_input(session::session sess, ast::crate_cfg cfg, str input,\n     auto d =\n         time(time_passes, \"resolution\",\n              bind resolve::resolve_crate(sess, ast_map, crate));\n-    auto ty_cx = ty::mk_ctxt(sess, d._0, d._1, ast_map);\n+    auto freevars =\n+        time(time_passes, \"freevar finding\",\n+             bind freevars::annotate_freevars(sess, d._0, crate));\n+    auto ty_cx = ty::mk_ctxt(sess, d._0, d._1, ast_map, freevars);\n     time[()](time_passes, \"typechecking\",\n              bind typeck::check_crate(ty_cx, crate));\n     if (sess.get_opts().run_typestate) {\n@@ -196,7 +200,8 @@ fn pretty_print_input(session::session sess, ast::crate_cfg cfg,\n         case (ppm_typed) {\n             auto amap = middle::ast_map::map_crate(*crate);\n             auto d = resolve::resolve_crate(sess, amap, crate);\n-            auto ty_cx = ty::mk_ctxt(sess, d._0, d._1, amap);\n+            auto freevars = freevars::annotate_freevars(sess, d._0, crate);\n+            auto ty_cx = ty::mk_ctxt(sess, d._0, d._1, amap, freevars);\n             typeck::check_crate(ty_cx, crate);\n             ann = rec(pre=ann_paren_for_expr,\n                       post=bind ann_typed_post(ty_cx, _));"}, {"sha": "4b88f2945c8d4e275bf7238a9ca4f531dfd0094c", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 56, "deletions": 9, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f8c6d282f8438fd2e3229d1d7a428df462f52076/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8c6d282f8438fd2e3229d1d7a428df462f52076/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=f8c6d282f8438fd2e3229d1d7a428df462f52076", "patch": "@@ -1,23 +1,29 @@\n-// A pass that annotates for each loops with the free variables that\n-// they contain.\n+// A pass that annotates for each loops and functions with the free\n+// variables that they contain.\n \n import std::map;\n import std::map::*;\n import syntax::ast;\n import syntax::walk;\n import driver::session;\n-import middle::ty;\n+import middle::resolve;\n import syntax::codemap::span;\n \n+export annotate_freevars;\n+export freevar_set;\n+export freevar_map;\n \n+type freevar_set = ast::node_id[];\n+type freevar_map = hashmap[ast::node_id, freevar_set];\n \n // Searches through part of the AST for all references to locals or\n // upvars in this frame and returns the list of definition IDs thus found.\n // Since we want to be able to collect upvars in some arbitrary piece\n // of the AST, we take a walker function that we invoke with a visitor\n // in order to start the search.\n-fn collect_upvars(&ty::ctxt tcx, &fn (&walk::ast_visitor) walker,\n-                  ast::node_id[] initial_decls) -> ast::node_id[] {\n+fn collect_freevars(&resolve::def_map def_map, &session::session sess,\n+                    &fn (&walk::ast_visitor) walker,\n+                    ast::node_id[] initial_decls) -> ast::node_id[] {\n     type env =\n         @rec(mutable ast::node_id[] refs,\n              hashmap[ast::node_id, ()] decls,\n@@ -33,7 +39,7 @@ fn collect_upvars(&ty::ctxt tcx, &fn (&walk::ast_visitor) walker,\n             case (ast::expr_path(?path)) {\n                 if (! e.def_map.contains_key(expr.id)) {\n                     e.sess.span_fatal(expr.span,\n-                       \"internal error in collect_upvars\");\n+                       \"internal error in collect_freevars\");\n                 }\n                 alt (e.def_map.get(expr.id)) {\n                     case (ast::def_arg(?did)) { e.refs += ~[did._1]; }\n@@ -62,17 +68,17 @@ fn collect_upvars(&ty::ctxt tcx, &fn (&walk::ast_visitor) walker,\n     let env e =\n         @rec(mutable refs=~[],\n              decls=decls,\n-             def_map=tcx.def_map,\n-             sess=tcx.sess);\n+             def_map=def_map,\n+             sess=sess);\n     auto visitor =\n         @rec(visit_fn_pre=bind walk_fn(e, _, _, _, _, _),\n              visit_local_pre=bind walk_local(e, _),\n              visit_expr_pre=bind walk_expr(e, _),\n              visit_pat_pre=bind walk_pat(e, _)\n              with walk::default_visitor());\n     walker(*visitor);\n-    // Calculate (refs - decls). This is the set of captured upvars.\n \n+    // Calculate (refs - decls). This is the set of captured upvars.\n     let ast::node_id[] result = ~[];\n     for (ast::node_id ref_id_ in e.refs) {\n         auto ref_id = ref_id_;\n@@ -81,6 +87,47 @@ fn collect_upvars(&ty::ctxt tcx, &fn (&walk::ast_visitor) walker,\n     ret result;\n }\n \n+// Build a map from every function and for-each body to a set of the\n+// freevars contained in it. The implementation is not particularly\n+// efficient as it fully recomputes the free variables at every\n+// node of interest rather than building up the free variables in\n+// one pass. This could be improved upon if it turns out to matter.\n+fn annotate_freevars(&session::session sess, &resolve::def_map def_map,\n+                     &@ast::crate crate) -> freevar_map {\n+    type env =\n+        rec(freevar_map freevars,\n+            resolve::def_map def_map,\n+            session::session sess);\n+\n+    fn walk_fn(env e, &ast::_fn f, &ast::ty_param[] tps, &span sp,\n+               &ast::fn_ident i, ast::node_id nid) {\n+        auto walker = bind walk::walk_fn(_, f, tps, sp, i, nid);\n+        auto vars = collect_freevars(e.def_map, e.sess, walker, ~[]);\n+        e.freevars.insert(nid, vars);\n+    }\n+    fn walk_expr(env e, &@ast::expr expr) {\n+        alt (expr.node) {\n+            ast::expr_for_each(?local, _, ?body) {\n+                auto vars = collect_freevars(e.def_map, e.sess,\n+                                             bind walk::walk_block(_, body),\n+                                             ~[local.node.id]);\n+                e.freevars.insert(body.node.id, vars);\n+            }\n+            _ {}\n+        }\n+    }\n+\n+    let env e =\n+        rec(freevars = new_int_hash(), def_map=def_map, sess=sess);\n+    auto visitor =\n+        rec(visit_fn_pre=bind walk_fn(e, _, _, _, _, _),\n+            visit_expr_pre=bind walk_expr(e, _)\n+            with walk::default_visitor());\n+    walk::walk_crate(visitor, *crate);\n+\n+    ret e.freevars;\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "ee290dc18d5bc845e15f71d7808242d4a88332a1", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f8c6d282f8438fd2e3229d1d7a428df462f52076/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8c6d282f8438fd2e3229d1d7a428df462f52076/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=f8c6d282f8438fd2e3229d1d7a428df462f52076", "patch": "@@ -4276,17 +4276,14 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n      *\n      */\n \n-    // Step 1: walk body and figure out which references it makes\n-    // escape. This could be determined upstream, and probably ought\n-    // to be so, eventualy.\n+    // Step 1: Generate code to build an environment containing pointers\n+    // to all of the upvars\n     auto lcx = cx.fcx.lcx;\n \n     // FIXME: possibly support alias-mode here?\n     auto decl_ty = node_id_type(lcx.ccx, local.node.id);\n     auto decl_id = local.node.id;\n-    auto upvars = freevars::collect_upvars(cx.fcx.lcx.ccx.tcx,\n-                                           bind walk::walk_block(_, body),\n-                                           ~[decl_id]);\n+    auto upvars = cx.fcx.lcx.ccx.tcx.freevars.get(body.node.id);\n \n     auto environment_data = build_environment(cx, upvars);\n     auto llenvptr = environment_data._0;"}, {"sha": "30c04a7492263c0ee9a14d3749a0fc5109e399be", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8c6d282f8438fd2e3229d1d7a428df462f52076/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8c6d282f8438fd2e3229d1d7a428df462f52076/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=f8c6d282f8438fd2e3229d1d7a428df462f52076", "patch": "@@ -210,6 +210,7 @@ type ctxt =\n         resolve::def_map def_map,\n         node_type_table node_types,\n         ast_map::map items,\n+        freevars::freevar_map freevars,\n \n         constr_table fn_constrs,\n         type_cache tcache,\n@@ -392,7 +393,7 @@ fn mk_rcache() -> creader_cache {\n }\n \n fn mk_ctxt(session::session s, resolve::def_map dm, constr_table cs,\n-           ast_map::map amap) -> ctxt {\n+           ast_map::map amap, freevars::freevar_map freevars) -> ctxt {\n     let node_type_table ntt =\n         @smallintmap::mk[ty::ty_param_substs_opt_and_ty]();\n     auto tcache = new_def_hash[ty::ty_param_count_and_ty]();\n@@ -403,6 +404,7 @@ fn mk_ctxt(session::session s, resolve::def_map dm, constr_table cs,\n             def_map=dm,\n             node_types=ntt,\n             items=amap,\n+            freevars=freevars,\n             fn_constrs=cs,\n             tcache=tcache,\n             rcache=mk_rcache(),"}]}