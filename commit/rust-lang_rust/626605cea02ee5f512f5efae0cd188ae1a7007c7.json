{"sha": "626605cea02ee5f512f5efae0cd188ae1a7007c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyNjYwNWNlYTAyZWU1ZjUxMmY1ZWZhZTBjZDE4OGFlMWE3MDA3Yzc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-07-12T18:29:05Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-07-14T16:17:49Z"}, "message": "consistently treat None-tagged pointers as ints; get rid of some deprecated Scalar methods", "tree": {"sha": "f5ca5be22c69768e444371f0b64230ab763c3159", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5ca5be22c69768e444371f0b64230ab763c3159"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/626605cea02ee5f512f5efae0cd188ae1a7007c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/626605cea02ee5f512f5efae0cd188ae1a7007c7", "html_url": "https://github.com/rust-lang/rust/commit/626605cea02ee5f512f5efae0cd188ae1a7007c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/626605cea02ee5f512f5efae0cd188ae1a7007c7/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4f7dd670226a4235ea4cf900c14eb9c6a536843", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4f7dd670226a4235ea4cf900c14eb9c6a536843", "html_url": "https://github.com/rust-lang/rust/commit/d4f7dd670226a4235ea4cf900c14eb9c6a536843"}], "stats": {"total": 282, "additions": 144, "deletions": 138}, "files": [{"sha": "35e72621c565d6473423b398758fb201f925c8e5", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -243,7 +243,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                     self.const_bitcast(llval, llty)\n                 }\n             }\n-            Scalar::Ptr(ptr) => {\n+            Scalar::Ptr(ptr, _size) => {\n                 let (alloc_id, offset) = ptr.into_parts();\n                 let (base_addr, base_addr_space) = match self.tcx.global_alloc(alloc_id) {\n                     GlobalAlloc::Memory(alloc) => {"}, {"sha": "3ca295f4a7e89396658d0e002151e7ae6c0f8309", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -11,7 +11,7 @@ use rustc_codegen_ssa::traits::*;\n use rustc_hir::def_id::DefId;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::interpret::{\n-    read_target_uint, Allocation, ErrorHandled, GlobalAlloc, Pointer,\n+    read_target_uint, Allocation, ErrorHandled, GlobalAlloc, Pointer, Scalar as InterpScalar,\n };\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n@@ -55,7 +55,10 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n         };\n \n         llvals.push(cx.scalar_to_backend(\n-            Pointer::new(alloc_id, Size::from_bytes(ptr_offset)).into(),\n+            InterpScalar::from_pointer(\n+                Pointer::new(alloc_id, Size::from_bytes(ptr_offset)),\n+                &cx.tcx,\n+            ),\n             &Scalar { value: Primitive::Pointer, valid_range: 0..=!0 },\n             cx.type_i8p_ext(address_space),\n         ));"}, {"sha": "3e8386bc88feda1facf37b2d13ed2765d2147f53", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -90,10 +90,10 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                     Abi::ScalarPair(ref a, _) => a,\n                     _ => bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout),\n                 };\n-                let a = Scalar::from(Pointer::new(\n-                    bx.tcx().create_memory_alloc(data),\n-                    Size::from_bytes(start),\n-                ));\n+                let a = Scalar::from_pointer(\n+                    Pointer::new(bx.tcx().create_memory_alloc(data), Size::from_bytes(start)),\n+                    &bx.tcx(),\n+                );\n                 let a_llval = bx.scalar_to_backend(\n                     a,\n                     a_scalar,"}, {"sha": "1f2227f6ea02c10ac1217fa1b0816c006a112788", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -333,7 +333,7 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n             // Maybe a pointer.\n             if let Some(&prov) = self.relocations.get(&range.start) {\n                 let ptr = Pointer::new(prov, Size::from_bytes(bits));\n-                return Ok(ScalarMaybeUninit::Scalar(ptr.into()));\n+                return Ok(ScalarMaybeUninit::from_pointer(ptr, cx));\n             }\n         }\n         // We don't. Just return the bits.\n@@ -363,7 +363,7 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n             }\n         };\n \n-        let (bytes, provenance) = match val.to_bits_or_ptr(range.size, cx) {\n+        let (bytes, provenance) = match val.to_bits_or_ptr(range.size) {\n             Err(val) => {\n                 let (provenance, offset) = val.into_parts();\n                 (u128::from(offset.bytes()), Some(provenance))"}, {"sha": "3d6ee49a19e0f801c7af5029d8e8e43a992288de", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -87,7 +87,7 @@ impl<T: HasDataLayout> PointerArithmetic for T {}\n /// mostly opaque; the `Machine` trait extends it with some more operations that also have access to\n /// some global state.\n pub trait Provenance: Copy {\n-    /// Says whether the `offset` field of `Pointer` is the actual physical address.\n+    /// Says whether the `offset` field of `Pointer`s with this provenance is the actual physical address.\n     /// If `true, ptr-to-int casts work by simply discarding the provenance.\n     /// If `false`, ptr-to-int casts are not supported.\n     const OFFSET_IS_ADDR: bool;"}, {"sha": "831a4d33ca20b7ba066c5fadcbafcf3f0b533914", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 66, "deletions": 79, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -128,7 +128,11 @@ pub enum Scalar<Tag = AllocId> {\n     /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n     /// relocations, but a `Scalar` is only large enough to contain one, so we just represent the\n     /// relocation and its associated offset together as a `Pointer` here.\n-    Ptr(Pointer<Tag>),\n+    ///\n+    /// We also store the size of the pointer, such that a `Scalar` always knows how big it is.\n+    /// The size is always the pointer size of the current target, but this is not information\n+    /// that we always have readily available.\n+    Ptr(Pointer<Tag>, u8),\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n@@ -139,7 +143,7 @@ pub enum Scalar<Tag = AllocId> {\n impl<Tag: Provenance> fmt::Debug for Scalar<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            Scalar::Ptr(ptr) => write!(f, \"{:?}\", ptr),\n+            Scalar::Ptr(ptr, _size) => write!(f, \"{:?}\", ptr),\n             Scalar::Int(int) => write!(f, \"{:?}\", int),\n         }\n     }\n@@ -148,7 +152,7 @@ impl<Tag: Provenance> fmt::Debug for Scalar<Tag> {\n impl<Tag: Provenance> fmt::Display for Scalar<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            Scalar::Ptr(ptr) => write!(f, \"pointer to {:?}\", ptr),\n+            Scalar::Ptr(ptr, _size) => write!(f, \"pointer to {:?}\", ptr),\n             Scalar::Int(int) => write!(f, \"{:?}\", int),\n         }\n     }\n@@ -168,13 +172,6 @@ impl<Tag> From<Double> for Scalar<Tag> {\n     }\n }\n \n-impl<Tag> From<Pointer<Tag>> for Scalar<Tag> {\n-    #[inline(always)]\n-    fn from(ptr: Pointer<Tag>) -> Self {\n-        Scalar::Ptr(ptr)\n-    }\n-}\n-\n impl<Tag> From<ScalarInt> for Scalar<Tag> {\n     #[inline(always)]\n     fn from(ptr: ScalarInt) -> Self {\n@@ -185,21 +182,26 @@ impl<Tag> From<ScalarInt> for Scalar<Tag> {\n impl<'tcx, Tag> Scalar<Tag> {\n     pub const ZST: Self = Scalar::Int(ScalarInt::ZST);\n \n-    #[inline]\n-    pub fn null_ptr(cx: &impl HasDataLayout) -> Self {\n-        Scalar::Int(ScalarInt::null(cx.data_layout().pointer_size))\n+    #[inline(always)]\n+    pub fn from_pointer(ptr: Pointer<Tag>, cx: &impl HasDataLayout) -> Self {\n+        Scalar::Ptr(ptr, u8::try_from(cx.pointer_size().bytes()).unwrap())\n     }\n \n     /// Create a Scalar from a pointer with an `Option<_>` tag (where `None` represents a plain integer).\n     pub fn from_maybe_pointer(ptr: Pointer<Option<Tag>>, cx: &impl HasDataLayout) -> Self {\n         match ptr.into_parts() {\n-            (Some(tag), offset) => Scalar::Ptr(Pointer::new(tag, offset)),\n+            (Some(tag), offset) => Scalar::from_pointer(Pointer::new(tag, offset), cx),\n             (None, offset) => {\n                 Scalar::Int(ScalarInt::try_from_uint(offset.bytes(), cx.pointer_size()).unwrap())\n             }\n         }\n     }\n \n+    #[inline]\n+    pub fn null_ptr(cx: &impl HasDataLayout) -> Self {\n+        Scalar::Int(ScalarInt::null(cx.pointer_size()))\n+    }\n+\n     #[inline(always)]\n     fn ptr_op(\n         self,\n@@ -209,7 +211,10 @@ impl<'tcx, Tag> Scalar<Tag> {\n     ) -> InterpResult<'tcx, Self> {\n         match self {\n             Scalar::Int(int) => Ok(Scalar::Int(int.ptr_sized_op(dl, f_int)?)),\n-            Scalar::Ptr(ptr) => Ok(Scalar::Ptr(f_ptr(ptr)?)),\n+            Scalar::Ptr(ptr, sz) => {\n+                debug_assert_eq!(u64::from(sz), dl.pointer_size().bytes());\n+                Ok(Scalar::Ptr(f_ptr(ptr)?, sz))\n+            }\n         }\n     }\n \n@@ -334,59 +339,18 @@ impl<'tcx, Tag> Scalar<Tag> {\n     /// This is almost certainly not the method you want!  You should dispatch on the type\n     /// and use `to_{u8,u16,...}`/`scalar_to_ptr` to perform ptr-to-int / int-to-ptr casts as needed.\n     ///\n-    /// This method only exists for the benefit of low-level memory operations\n-    /// as well as the implementation of the above methods.\n+    /// This method only exists for the benefit of low-level memory operations.\n     #[inline]\n-    pub fn to_bits_or_ptr(\n-        self,\n-        target_size: Size,\n-        cx: &impl HasDataLayout,\n-    ) -> Result<u128, Pointer<Tag>> {\n+    pub fn to_bits_or_ptr(self, target_size: Size) -> Result<u128, Pointer<Tag>> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         match self {\n             Scalar::Int(int) => Ok(int.assert_bits(target_size)),\n-            Scalar::Ptr(ptr) => {\n-                assert_eq!(target_size, cx.data_layout().pointer_size);\n+            Scalar::Ptr(ptr, sz) => {\n+                assert_eq!(target_size.bytes(), u64::from(sz));\n                 Err(ptr)\n             }\n         }\n     }\n-\n-    /// Do not call this method! It does not do ptr-to-int casts when needed.\n-    #[inline(always)]\n-    pub fn assert_bits(self, target_size: Size) -> u128 {\n-        self.assert_int().assert_bits(target_size)\n-    }\n-\n-    /// Do not call this method! It does not do ptr-to-int casts when needed.\n-    #[inline]\n-    pub fn assert_int(self) -> ScalarInt {\n-        match self {\n-            Scalar::Ptr(_) => bug!(\"expected an int but got an abstract pointer\"),\n-            Scalar::Int(int) => int,\n-        }\n-    }\n-\n-    /// Do not call this method! It does not do int-to-ptr casts when needed.\n-    #[inline]\n-    pub fn assert_ptr(self) -> Pointer<Tag> {\n-        match self {\n-            Scalar::Ptr(p) => p,\n-            Scalar::Int { .. } => bug!(\"expected a Pointer but got Raw bits\"),\n-        }\n-    }\n-\n-    /// Do not call this method!  Dispatch based on the type instead.\n-    #[inline]\n-    pub fn is_bits(self) -> bool {\n-        matches!(self, Scalar::Int { .. })\n-    }\n-\n-    /// Do not call this method!  Dispatch based on the type instead.\n-    #[inline]\n-    pub fn is_ptr(self) -> bool {\n-        matches!(self, Scalar::Ptr(_))\n-    }\n }\n \n impl<'tcx, Tag: Provenance> Scalar<Tag> {\n@@ -396,7 +360,7 @@ impl<'tcx, Tag: Provenance> Scalar<Tag> {\n     #[inline]\n     pub fn erase_for_fmt(self) -> Scalar {\n         match self {\n-            Scalar::Ptr(ptr) => Scalar::Ptr(ptr.erase_for_fmt()),\n+            Scalar::Ptr(ptr, sz) => Scalar::Ptr(ptr.erase_for_fmt(), sz),\n             Scalar::Int(int) => Scalar::Int(int),\n         }\n     }\n@@ -405,25 +369,45 @@ impl<'tcx, Tag: Provenance> Scalar<Tag> {\n     /// likely want to use instead.\n     ///\n     /// Will perform ptr-to-int casts if needed and possible.\n+    #[inline]\n+    pub fn try_to_int(self) -> Option<ScalarInt> {\n+        match self {\n+            Scalar::Int(int) => Some(int),\n+            Scalar::Ptr(ptr, sz) => {\n+                if Tag::OFFSET_IS_ADDR {\n+                    Some(\n+                        ScalarInt::try_from_uint(ptr.offset.bytes(), Size::from_bytes(sz)).unwrap(),\n+                    )\n+                } else {\n+                    None\n+                }\n+            }\n+        }\n+    }\n+\n+    #[inline(always)]\n+    pub fn assert_int(self) -> ScalarInt {\n+        self.try_to_int().unwrap()\n+    }\n+\n     #[inline]\n     pub fn to_bits(self, target_size: Size) -> InterpResult<'tcx, u128> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n-        match self {\n-            Scalar::Int(int) => int.to_bits(target_size).map_err(|size| {\n+        self.try_to_int()\n+            .ok_or_else(|| err_unsup!(ReadPointerAsBytes))?\n+            .to_bits(target_size)\n+            .map_err(|size| {\n                 err_ub!(ScalarSizeMismatch {\n                     target_size: target_size.bytes(),\n                     data_size: size.bytes(),\n                 })\n                 .into()\n-            }),\n-            Scalar::Ptr(ptr) => {\n-                if Tag::OFFSET_IS_ADDR {\n-                    Ok(ptr.offset.bytes().into())\n-                } else {\n-                    throw_unsup!(ReadPointerAsBytes)\n-                }\n-            }\n-        }\n+            })\n+    }\n+\n+    #[inline(always)]\n+    pub fn assert_bits(self, target_size: Size) -> u128 {\n+        self.to_bits(target_size).unwrap()\n     }\n \n     pub fn to_bool(self) -> InterpResult<'tcx, bool> {\n@@ -547,13 +531,6 @@ impl<Tag> From<Scalar<Tag>> for ScalarMaybeUninit<Tag> {\n     }\n }\n \n-impl<Tag> From<Pointer<Tag>> for ScalarMaybeUninit<Tag> {\n-    #[inline(always)]\n-    fn from(s: Pointer<Tag>) -> Self {\n-        ScalarMaybeUninit::Scalar(s.into())\n-    }\n-}\n-\n // We want the `Debug` output to be readable as it is used by `derive(Debug)` for\n // all the Miri types.\n impl<Tag: Provenance> fmt::Debug for ScalarMaybeUninit<Tag> {\n@@ -575,6 +552,16 @@ impl<Tag: Provenance> fmt::Display for ScalarMaybeUninit<Tag> {\n }\n \n impl<Tag> ScalarMaybeUninit<Tag> {\n+    #[inline]\n+    pub fn from_pointer(ptr: Pointer<Tag>, cx: &impl HasDataLayout) -> Self {\n+        ScalarMaybeUninit::Scalar(Scalar::from_pointer(ptr, cx))\n+    }\n+\n+    #[inline]\n+    pub fn from_maybe_pointer(ptr: Pointer<Option<Tag>>, cx: &impl HasDataLayout) -> Self {\n+        ScalarMaybeUninit::Scalar(Scalar::from_maybe_pointer(ptr, cx))\n+    }\n+\n     #[inline]\n     pub fn check_init(self) -> InterpResult<'static, Scalar<Tag>> {\n         match self {"}, {"sha": "da0d2575dcbe3377663318d64b83766be84b48fe", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -2458,7 +2458,7 @@ pub enum ConstantKind<'tcx> {\n impl Constant<'tcx> {\n     pub fn check_static_ptr(&self, tcx: TyCtxt<'_>) -> Option<DefId> {\n         match self.literal.const_for_ty()?.val.try_to_scalar() {\n-            Some(Scalar::Ptr(ptr)) => match tcx.global_alloc(ptr.provenance) {\n+            Some(Scalar::Ptr(ptr, _size)) => match tcx.global_alloc(ptr.provenance) {\n                 GlobalAlloc::Static(def_id) => {\n                     assert!(!tcx.is_thread_local_static(def_id));\n                     Some(def_id)"}, {"sha": "dbdca44952f4580ff3fca862b9f201f919b84a96", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -974,7 +974,7 @@ pub trait PrettyPrinter<'tcx>:\n         print_ty: bool,\n     ) -> Result<Self::Const, Self::Error> {\n         match scalar {\n-            Scalar::Ptr(ptr) => self.pretty_print_const_scalar_ptr(ptr, ty, print_ty),\n+            Scalar::Ptr(ptr, _size) => self.pretty_print_const_scalar_ptr(ptr, ty, print_ty),\n             Scalar::Int(int) => self.pretty_print_const_scalar_int(int, ty, print_ty),\n         }\n     }"}, {"sha": "a4c36be21992b36b56743a1ca6a14edd7ad7180b", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -595,7 +595,10 @@ fn check_const_value_eq<R: TypeRelation<'tcx>>(\n         (ConstValue::Scalar(Scalar::Int(a_val)), ConstValue::Scalar(Scalar::Int(b_val))) => {\n             a_val == b_val\n         }\n-        (ConstValue::Scalar(Scalar::Ptr(a_val)), ConstValue::Scalar(Scalar::Ptr(b_val))) => {\n+        (\n+            ConstValue::Scalar(Scalar::Ptr(a_val, _a_size)),\n+            ConstValue::Scalar(Scalar::Ptr(b_val, _b_size)),\n+        ) => {\n             a_val == b_val\n                 || match (tcx.global_alloc(a_val.provenance), tcx.global_alloc(b_val.provenance)) {\n                     (GlobalAlloc::Function(a_instance), GlobalAlloc::Function(b_instance)) => {"}, {"sha": "78109fc7b5713beeeb494c7e5d56ef4ad77e96bc", "filename": "compiler/rustc_middle/src/ty/vtable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -1,6 +1,6 @@\n use std::convert::TryFrom;\n \n-use crate::mir::interpret::{alloc_range, AllocId, Allocation, Pointer, Scalar};\n+use crate::mir::interpret::{alloc_range, AllocId, Allocation, Pointer, Scalar, ScalarMaybeUninit};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::{self, DefId, SubstsRef, Ty, TyCtxt};\n use rustc_ast::Mutability;\n@@ -74,7 +74,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     let instance = ty::Instance::resolve_drop_in_place(tcx, ty);\n                     let fn_alloc_id = tcx.create_fn_alloc(instance);\n                     let fn_ptr = Pointer::from(fn_alloc_id);\n-                    fn_ptr.into()\n+                    ScalarMaybeUninit::from_pointer(fn_ptr, &tcx)\n                 }\n                 VtblEntry::MetadataSize => Scalar::from_uint(size, ptr_size).into(),\n                 VtblEntry::MetadataAlign => Scalar::from_uint(align, ptr_size).into(),\n@@ -90,7 +90,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                             .polymorphize(tcx);\n                     let fn_alloc_id = tcx.create_fn_alloc(instance);\n                     let fn_ptr = Pointer::from(fn_alloc_id);\n-                    fn_ptr.into()\n+                    ScalarMaybeUninit::from_pointer(fn_ptr, &tcx)\n                 }\n             };\n             vtable"}, {"sha": "dc6a6b0b9f3d8bca119dcd52d4dde902e5ac5a29", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -139,6 +139,7 @@ pub(super) fn op_to_const<'tcx>(\n         op.try_as_mplace()\n     };\n \n+    // We know `offset` is relative to the allocation, so we can use `into_parts`.\n     let to_const_value = |mplace: &MPlaceTy<'_>| match mplace.ptr.into_parts() {\n         (Some(alloc_id), offset) => {\n             let alloc = ecx.tcx.global_alloc(alloc_id).unwrap_memory();\n@@ -164,6 +165,7 @@ pub(super) fn op_to_const<'tcx>(\n                 ScalarMaybeUninit::Uninit => to_const_value(&op.assert_mem_place()),\n             },\n             Immediate::ScalarPair(a, b) => {\n+                // We know `offset` is relative to the allocation, so we can use `into_parts`.\n                 let (data, start) = match ecx.scalar_to_ptr(a.check_init().unwrap()).into_parts() {\n                     (Some(alloc_id), offset) => {\n                         (ecx.tcx.global_alloc(alloc_id).unwrap_memory(), offset.bytes())"}, {"sha": "2bebbc65c24c2ff5f43cd5c2607147377bc3a190", "filename": "compiler/rustc_mir/src/const_eval/machine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -168,11 +168,11 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n             // Comparisons between integers are always known.\n             (Scalar::Int { .. }, Scalar::Int { .. }) => a == b,\n             // Equality with integers can never be known for sure.\n-            (Scalar::Int { .. }, Scalar::Ptr(_)) | (Scalar::Ptr(_), Scalar::Int { .. }) => false,\n+            (Scalar::Int { .. }, Scalar::Ptr(..)) | (Scalar::Ptr(..), Scalar::Int { .. }) => false,\n             // FIXME: return `true` for when both sides are the same pointer, *except* that\n             // some things (like functions and vtables) do not have stable addresses\n             // so we need to be careful around them (see e.g. #73722).\n-            (Scalar::Ptr(_), Scalar::Ptr(_)) => false,\n+            (Scalar::Ptr(..), Scalar::Ptr(..)) => false,\n         }\n     }\n \n@@ -183,13 +183,13 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n             // Comparisons of abstract pointers with null pointers are known if the pointer\n             // is in bounds, because if they are in bounds, the pointer can't be null.\n             // Inequality with integers other than null can never be known for sure.\n-            (Scalar::Int(int), Scalar::Ptr(ptr)) | (Scalar::Ptr(ptr), Scalar::Int(int)) => {\n+            (Scalar::Int(int), Scalar::Ptr(ptr, _)) | (Scalar::Ptr(ptr, _), Scalar::Int(int)) => {\n                 int.is_null() && !self.memory.ptr_may_be_null(ptr.into())\n             }\n             // FIXME: return `true` for at least some comparisons where we can reliably\n             // determine the result of runtime inequality tests at compile-time.\n             // Examples include comparison of addresses in different static items.\n-            (Scalar::Ptr(_), Scalar::Ptr(_)) => false,\n+            (Scalar::Ptr(..), Scalar::Ptr(..)) => false,\n         }\n     }\n }\n@@ -312,7 +312,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                     align,\n                     interpret::MemoryKind::Machine(MemoryKind::Heap),\n                 )?;\n-                ecx.write_scalar(Scalar::Ptr(ptr), dest)?;\n+                ecx.write_scalar(Scalar::from_pointer(ptr, &*ecx.tcx), dest)?;\n             }\n             _ => {\n                 return Err(ConstEvalErrKind::NeedsRfc(format!("}, {"sha": "78124428787cd3ca3a1161fddb55b6a4a47ce78c", "filename": "compiler/rustc_mir/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -35,7 +35,7 @@ pub(crate) fn const_caller_location(\n     if intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &loc_place).is_err() {\n         bug!(\"intern_const_alloc_recursive should not error in this case\")\n     }\n-    ConstValue::Scalar(Scalar::Ptr(loc_place.ptr.into_pointer_or_offset().unwrap()))\n+    ConstValue::Scalar(Scalar::from_pointer(loc_place.ptr.into_pointer_or_offset().unwrap(), &tcx))\n }\n \n /// Convert an evaluated constant to a type level constant"}, {"sha": "ca7fd7010f3d196540372b94bab7702b0d542038", "filename": "compiler/rustc_mir/src/interpret/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -57,7 +57,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         .ok_or_else(|| err_inval!(TooGeneric))?;\n \n                         let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n-                        self.write_scalar(fn_ptr, dest)?;\n+                        self.write_scalar(Scalar::from_pointer(fn_ptr, &*self.tcx), dest)?;\n                     }\n                     _ => span_bug!(self.cur_span(), \"reify fn pointer on {:?}\", src.layout.ty),\n                 }\n@@ -88,7 +88,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             ty::ClosureKind::FnOnce,\n                         );\n                         let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n-                        self.write_scalar(fn_ptr, dest)?;\n+                        self.write_scalar(Scalar::from_pointer(fn_ptr, &*self.tcx), dest)?;\n                     }\n                     _ => span_bug!(self.cur_span(), \"closure fn pointer on {:?}\", src.layout.ty),\n                 }\n@@ -280,7 +280,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Initial cast from sized to dyn trait\n                 let vtable = self.get_vtable(src_pointee_ty, data.principal())?;\n                 let ptr = self.read_immediate(src)?.to_scalar()?;\n-                let val = Immediate::new_dyn_trait(ptr, vtable);\n+                let val = Immediate::new_dyn_trait(ptr, vtable, &*self.tcx);\n                 self.write_immediate(val, dest)\n             }\n "}, {"sha": "71e4652ac00377c21f57e3552ce945929bd4f71d", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -993,16 +993,16 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> std::fmt::Debug\n                     }\n                     LocalValue::Live(Operand::Immediate(Immediate::Scalar(val))) => {\n                         write!(fmt, \" {:?}\", val)?;\n-                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr)) = val {\n+                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr, _size)) = val {\n                             allocs.push(ptr.provenance.erase_for_fmt());\n                         }\n                     }\n                     LocalValue::Live(Operand::Immediate(Immediate::ScalarPair(val1, val2))) => {\n                         write!(fmt, \" ({:?}, {:?})\", val1, val2)?;\n-                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr)) = val1 {\n+                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr, _size)) = val1 {\n                             allocs.push(ptr.provenance.erase_for_fmt());\n                         }\n-                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr)) = val2 {\n+                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr, _size)) = val2 {\n                             allocs.push(ptr.provenance.erase_for_fmt());\n                         }\n                     }"}, {"sha": "4e2db2f13f17770721ba17bcc4ce68a34dee0f28", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -362,9 +362,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 //\n                 // Control flow is weird because we cannot early-return (to reach the\n                 // `go_to_block` at the end).\n-                let done = if a.is_bits() && b.is_bits() {\n-                    let a = a.to_machine_usize(self)?;\n-                    let b = b.to_machine_usize(self)?;\n+                let done = if let (Some(a), Some(b)) = (a.try_to_int(), b.try_to_int()) {\n+                    let a = a.try_to_machine_usize(*self.tcx).unwrap();\n+                    let b = b.try_to_machine_usize(*self.tcx).unwrap();\n                     if a == b && a != 0 {\n                         self.write_scalar(Scalar::from_machine_isize(0, self), dest)?;\n                         true"}, {"sha": "c135e4f996342445448bb1718a2b7dae36a8e939", "filename": "compiler/rustc_mir/src/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -283,6 +283,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// this will return an unusable tag (i.e., accesses will be UB)!\n     ///\n     /// Called on the id returned by `thread_local_static_alloc_id` and `extern_static_alloc_id`, if needed.\n+    ///\n+    /// `offset` is relative inside the allocation.\n     fn tag_global_base_pointer(\n         memory_extra: &Self::MemoryExtra,\n         ptr: Pointer,\n@@ -485,6 +487,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n         _mem: &Memory<$mir, $tcx, Self>,\n         ptr: Pointer<AllocId>,\n     ) -> (Option<AllocId>, Size) {\n+        // We know `offset` is relative to the allocation, so we can use `into_parts`.\n         let (alloc_id, offset) = ptr.into_parts();\n         (Some(alloc_id), offset)\n     }"}, {"sha": "5e5a969c26ab890c14bdebcc8d93e0d988658d27", "filename": "compiler/rustc_mir/src/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -165,6 +165,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         &self,\n         ptr: Pointer<AllocId>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n+        // We know `offset` is relative to the allocation, so we can use `into_parts`.\n         let (alloc_id, offset) = ptr.into_parts();\n         // We need to handle `extern static`.\n         let alloc_id = match self.tcx.get_global_alloc(alloc_id) {\n@@ -450,7 +451,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // we want the error to be about the bounds.\n                 if let Some(align) = align {\n                     if M::force_int_for_alignment_check(&self.extra) {\n-                        let addr = Scalar::from(ptr)\n+                        let addr = Scalar::from_pointer(ptr, &self.tcx)\n                             .to_machine_usize(&self.tcx)\n                             .expect(\"ptr-to-int cast for align check should never fail\");\n                         check_offset_align(addr, align)?;\n@@ -1131,7 +1132,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n /// Machine pointer introspection.\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn scalar_to_ptr(&self, scalar: Scalar<M::PointerTag>) -> Pointer<Option<M::PointerTag>> {\n-        match scalar.to_bits_or_ptr(self.pointer_size(), &self.tcx) {\n+        match scalar.to_bits_or_ptr(self.pointer_size()) {\n             Err(ptr) => ptr.into(),\n             Ok(bits) => {\n                 let addr = u64::try_from(bits).unwrap();"}, {"sha": "e10f4fb7ff9ac819de3dcb8e3289f787f5e092ce", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -60,20 +60,21 @@ impl<Tag> From<Scalar<Tag>> for Immediate<Tag> {\n     }\n }\n \n-impl<Tag> From<Pointer<Tag>> for Immediate<Tag> {\n-    #[inline(always)]\n-    fn from(val: Pointer<Tag>) -> Self {\n-        Immediate::Scalar(Scalar::from(val).into())\n+impl<'tcx, Tag> Immediate<Tag> {\n+    pub fn from_pointer(p: Pointer<Tag>, cx: &impl HasDataLayout) -> Self {\n+        Immediate::Scalar(ScalarMaybeUninit::from_pointer(p, cx))\n+    }\n+\n+    pub fn from_maybe_pointer(p: Pointer<Option<Tag>>, cx: &impl HasDataLayout) -> Self {\n+        Immediate::Scalar(ScalarMaybeUninit::from_maybe_pointer(p, cx))\n     }\n-}\n \n-impl<'tcx, Tag> Immediate<Tag> {\n     pub fn new_slice(val: Scalar<Tag>, len: u64, cx: &impl HasDataLayout) -> Self {\n         Immediate::ScalarPair(val.into(), Scalar::from_machine_usize(len, cx).into())\n     }\n \n-    pub fn new_dyn_trait(val: Scalar<Tag>, vtable: Pointer<Tag>) -> Self {\n-        Immediate::ScalarPair(val.into(), vtable.into())\n+    pub fn new_dyn_trait(val: Scalar<Tag>, vtable: Pointer<Tag>, cx: &impl HasDataLayout) -> Self {\n+        Immediate::ScalarPair(val.into(), ScalarMaybeUninit::from_pointer(vtable, cx))\n     }\n \n     #[inline]\n@@ -252,7 +253,10 @@ impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    pub fn to_const_int(self) -> ConstInt {\n+    pub fn to_const_int(self) -> ConstInt\n+    where\n+        Tag: Provenance,\n+    {\n         assert!(self.layout.ty.is_integral());\n         let int = self.to_scalar().expect(\"to_const_int doesn't work on scalar pairs\").assert_int();\n         ConstInt::new(int, self.layout.ty.is_signed(), self.layout.ty.is_ptr_sized_integral())\n@@ -599,7 +603,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Other cases need layout.\n         let tag_scalar = |scalar| -> InterpResult<'tcx, _> {\n             Ok(match scalar {\n-                Scalar::Ptr(ptr) => Scalar::Ptr(self.global_base_pointer(ptr)?),\n+                Scalar::Ptr(ptr, size) => Scalar::Ptr(self.global_base_pointer(ptr)?, size),\n                 Scalar::Int(int) => Scalar::Int(int),\n             })\n         };\n@@ -621,7 +625,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Size::from_bytes(start), // offset: `start`\n                 );\n                 Operand::Immediate(Immediate::new_slice(\n-                    self.global_base_pointer(ptr)?.into(),\n+                    Scalar::from_pointer(self.global_base_pointer(ptr)?, &*self.tcx),\n                     u64::try_from(end.checked_sub(start).unwrap()).unwrap(), // len: `end - start`\n                     self,\n                 ))\n@@ -716,7 +720,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // discriminant (encoded in niche/tag) and variant index are the same.\n                 let variants_start = niche_variants.start().as_u32();\n                 let variants_end = niche_variants.end().as_u32();\n-                let variant = match tag_val.to_bits_or_ptr(tag_layout.size, self) {\n+                let variant = match tag_val.to_bits_or_ptr(tag_layout.size) {\n                     Err(ptr) => {\n                         // The niche must be just 0 (which an inbounds pointer value never is)\n                         let ptr_valid = niche_start == 0"}, {"sha": "040262c5dc67c3060fb0aabfbda75cd1b1e2c9d4", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -752,7 +752,7 @@ where\n             // This is a very common path, avoid some checks in release mode\n             assert!(!dest.layout.is_unsized(), \"Cannot write unsized data\");\n             match src {\n-                Immediate::Scalar(ScalarMaybeUninit::Scalar(Scalar::Ptr(_))) => assert_eq!(\n+                Immediate::Scalar(ScalarMaybeUninit::Scalar(Scalar::Ptr(..))) => assert_eq!(\n                     self.pointer_size(),\n                     dest.layout.size,\n                     \"Size mismatch when writing pointer\""}, {"sha": "f0787ad0c660db655c1881cc5aae1a85fcfb0f34", "filename": "compiler/rustc_mir/src/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -164,7 +164,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ThreadLocalRef(did) => {\n                 let id = M::thread_local_static_alloc_id(self, did)?;\n                 let val = self.global_base_pointer(id.into())?;\n-                self.write_scalar(val, &dest)?;\n+                self.write_scalar(Scalar::from_pointer(val, &*self.tcx), &dest)?;\n             }\n \n             Use(ref operand) => {"}, {"sha": "c633c87e19e41b0a7480bbc971a5767444b895bb", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -539,7 +539,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // types below!\n                 if self.ctfe_mode.is_some() {\n                     // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n-                    let is_bits = value.check_init().map_or(false, |v| v.is_bits());\n+                    let is_bits = value.check_init().map_or(false, |v| v.try_to_int().is_some());\n                     if !is_bits {\n                         throw_validation_failure!(self.path,\n                             { \"{}\", value } expected { \"initialized plain (non-pointer) bytes\" }\n@@ -657,7 +657,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             err_ub!(InvalidUninitBytes(None)) => { \"{}\", value }\n                 expected { \"something {}\", wrapping_range_format(valid_range, max_hi) },\n         );\n-        let bits = match value.to_bits_or_ptr(op.layout.size, self.ecx) {\n+        let bits = match value.to_bits_or_ptr(op.layout.size) {\n             Err(ptr) => {\n                 if lo == 1 && hi == max_hi {\n                     // Only null is the niche.  So make sure the ptr is NOT null."}, {"sha": "2ce7cf71116bbf9125ff8ba57777fcfcb093b2c6", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -1402,7 +1402,7 @@ fn collect_const_value<'tcx>(\n     output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n ) {\n     match value {\n-        ConstValue::Scalar(Scalar::Ptr(ptr)) => collect_miri(tcx, ptr.provenance, output),\n+        ConstValue::Scalar(Scalar::Ptr(ptr, _size)) => collect_miri(tcx, ptr.provenance, output),\n         ConstValue::Slice { data: alloc, start: _, end: _ } | ConstValue::ByRef { alloc, .. } => {\n             for &id in alloc.relocations().values() {\n                 collect_miri(tcx, id, output);"}, {"sha": "73bbb38a93a93723f3c7c31d13bdefa3388944ec", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -582,8 +582,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             let left_size = self.ecx.layout_of(left_ty).ok()?.size;\n             let right_size = r.layout.size;\n             let r_bits = r.to_scalar().ok();\n-            // This is basically `force_bits`.\n-            let r_bits = r_bits.and_then(|r| r.to_bits_or_ptr(right_size, &self.tcx).ok());\n+            let r_bits = r_bits.and_then(|r| r.to_bits(right_size).ok());\n             if r_bits.map_or(false, |b| b >= left_size.bits() as u128) {\n                 debug!(\"check_binary_op: reporting assert for {:?}\", source_info);\n                 self.report_assert_as_lint(\n@@ -922,12 +921,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         match **op {\n             interpret::Operand::Immediate(Immediate::Scalar(ScalarMaybeUninit::Scalar(s))) => {\n-                s.is_bits()\n+                s.try_to_int().is_some()\n             }\n             interpret::Operand::Immediate(Immediate::ScalarPair(\n                 ScalarMaybeUninit::Scalar(l),\n                 ScalarMaybeUninit::Scalar(r),\n-            )) => l.is_bits() && r.is_bits(),\n+            )) => l.try_to_int().is_some() && r.try_to_int().is_some(),\n             _ => false,\n         }\n     }"}, {"sha": "1ddf7c9cd0c9e096c16b2fe73d9adb5d4aa762f3", "filename": "compiler/rustc_mir/src/transform/simplify_comparison_integral.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -46,7 +46,7 @@ impl<'tcx> MirPass<'tcx> for SimplifyComparisonIntegral {\n                         .expect(\"if we have an evaluated constant we must know the layout\");\n                     int.assert_bits(layout.size)\n                 }\n-                Scalar::Ptr(_) => continue,\n+                Scalar::Ptr(..) => continue,\n             };\n             const FALSE: u128 = 0;\n "}, {"sha": "d0b1bc47ea80063cf6a7ea21651653915cebfc31", "filename": "compiler/rustc_mir/src/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -669,7 +669,7 @@ pub fn write_allocations<'tcx>(\n     }\n     fn alloc_ids_from_const(val: ConstValue<'_>) -> impl Iterator<Item = AllocId> + '_ {\n         match val {\n-            ConstValue::Scalar(interpret::Scalar::Ptr(ptr)) => {\n+            ConstValue::Scalar(interpret::Scalar::Ptr(ptr, _size)) => {\n                 Either::Left(Either::Left(std::iter::once(ptr.provenance)))\n             }\n             ConstValue::Scalar(interpret::Scalar::Int { .. }) => {"}, {"sha": "b3799aa063fa45c28dca255eca520f3627461a1e", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -38,7 +38,7 @@ crate fn lit_to_const<'tcx>(\n         }\n         (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n             let id = tcx.allocate_bytes(data);\n-            ConstValue::Scalar(Scalar::Ptr(id.into()))\n+            ConstValue::Scalar(Scalar::from_pointer(id.into(), &tcx))\n         }\n         (ast::LitKind::Byte(n), ty::Uint(ty::UintTy::U8)) => {\n             ConstValue::Scalar(Scalar::from_uint(*n, Size::from_bytes(1)))"}, {"sha": "c3908ddd4fbe85dfb2b813e1b9131a36baa7edda", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -928,7 +928,11 @@ impl<'tcx> Cx<'tcx> {\n                 } else {\n                     let ptr = self.tcx.create_static_alloc(id);\n                     ExprKind::StaticRef {\n-                        literal: ty::Const::from_scalar(self.tcx, Scalar::Ptr(ptr.into()), ty),\n+                        literal: ty::Const::from_scalar(\n+                            self.tcx,\n+                            Scalar::from_pointer(ptr.into(), &self.tcx),\n+                            ty,\n+                        ),\n                         def_id: id,\n                     }\n                 };"}, {"sha": "db15f6dad3c48153d09f1f3c2e93f84bbe82156c", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626605cea02ee5f512f5efae0cd188ae1a7007c7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=626605cea02ee5f512f5efae0cd188ae1a7007c7", "patch": "@@ -123,7 +123,7 @@ impl IntRange {\n                     // straight to the result, after doing a bit of checking. (We\n                     // could remove this branch and just fall through, which\n                     // is more general but much slower.)\n-                    if let Ok(bits) = scalar.to_bits_or_ptr(target_size, &tcx) {\n+                    if let Ok(bits) = scalar.to_bits_or_ptr(target_size) {\n                         return Some(bits);\n                     }\n                 }"}]}