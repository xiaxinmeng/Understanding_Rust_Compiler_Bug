{"sha": "e6ee8a0d44fcedb583067bbaf36bcdf325029cdd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ZWU4YTBkNDRmY2VkYjU4MzA2N2JiYWYzNmJjZGYzMjUwMjljZGQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-06-20T12:00:31Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-06-25T12:34:57Z"}, "message": "rustc: produce AST instead of HIR from `hir::lowering::Resolver` methods.", "tree": {"sha": "61aa3a01884ff71d9581cdbe44320c013dcfee81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61aa3a01884ff71d9581cdbe44320c013dcfee81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6ee8a0d44fcedb583067bbaf36bcdf325029cdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6ee8a0d44fcedb583067bbaf36bcdf325029cdd", "html_url": "https://github.com/rust-lang/rust/commit/e6ee8a0d44fcedb583067bbaf36bcdf325029cdd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6ee8a0d44fcedb583067bbaf36bcdf325029cdd/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53ae6d2eb5352cc20f2e9b92847d92e935639f3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/53ae6d2eb5352cc20f2e9b92847d92e935639f3c", "html_url": "https://github.com/rust-lang/rust/commit/53ae6d2eb5352cc20f2e9b92847d92e935639f3c"}], "stats": {"total": 92, "additions": 46, "deletions": 46}, "files": [{"sha": "1b8e2999afe6ae3060a669bafcd482d51cbca856", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e6ee8a0d44fcedb583067bbaf36bcdf325029cdd/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ee8a0d44fcedb583067bbaf36bcdf325029cdd/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e6ee8a0d44fcedb583067bbaf36bcdf325029cdd", "patch": "@@ -148,11 +148,11 @@ pub struct LoweringContext<'a> {\n \n pub trait Resolver {\n     /// Resolve a path generated by the lowerer when expanding `for`, `if let`, etc.\n-    fn resolve_hir_path(\n+    fn resolve_ast_path(\n         &mut self,\n         path: &ast::Path,\n         is_value: bool,\n-    ) -> hir::Path;\n+    ) -> Res<NodeId>;\n \n     /// Obtain resolution for a `NodeId` with a single resolution.\n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes>;\n@@ -167,15 +167,15 @@ pub trait Resolver {\n     /// This should only return `None` during testing.\n     fn definitions(&mut self) -> &mut Definitions;\n \n-    /// Given suffix `[\"b\", \"c\", \"d\"]`, creates a HIR path for `[::crate_root]::b::c::d` and\n+    /// Given suffix `[\"b\", \"c\", \"d\"]`, creates an AST path for `[::crate_root]::b::c::d` and\n     /// resolves it based on `is_value`.\n     fn resolve_str_path(\n         &mut self,\n         span: Span,\n         crate_root: Option<Symbol>,\n         components: &[Symbol],\n         is_value: bool,\n-    ) -> hir::Path;\n+    ) -> (ast::Path, Res<NodeId>);\n }\n \n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n@@ -5546,16 +5546,26 @@ impl<'a> LoweringContext<'a> {\n         params: Option<P<hir::GenericArgs>>,\n         is_value: bool,\n     ) -> hir::Path {\n-        let mut path = self.resolver\n+        let (path, res) = self.resolver\n             .resolve_str_path(span, self.crate_root, components, is_value);\n-        path.segments.last_mut().unwrap().args = params;\n \n-        for seg in path.segments.iter_mut() {\n-            if seg.hir_id.is_some() {\n-                seg.hir_id = Some(self.next_id());\n+        let mut segments: Vec<_> = path.segments.iter().map(|segment| {\n+            let res = self.expect_full_res(segment.id);\n+            hir::PathSegment {\n+                ident: segment.ident,\n+                hir_id: Some(self.lower_node_id(segment.id)),\n+                res: Some(self.lower_res(res)),\n+                infer_args: true,\n+                args: None,\n             }\n+        }).collect();\n+        segments.last_mut().unwrap().args = params;\n+\n+        hir::Path {\n+            span,\n+            res: res.map_id(|_| panic!(\"unexpected node_id\")),\n+            segments: segments.into(),\n         }\n-        path\n     }\n \n     fn ty_path(&mut self, mut hir_id: hir::HirId, span: Span, qpath: hir::QPath) -> hir::Ty {"}, {"sha": "81adfac0a291aa3647c76a41c9a7107fe00f5f1a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e6ee8a0d44fcedb583067bbaf36bcdf325029cdd/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ee8a0d44fcedb583067bbaf36bcdf325029cdd/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e6ee8a0d44fcedb583067bbaf36bcdf325029cdd", "patch": "@@ -1744,12 +1744,12 @@ impl<'a, 'b> ty::DefIdTree for &'a Resolver<'b> {\n /// This interface is used through the AST\u2192HIR step, to embed full paths into the HIR. After that\n /// the resolver is no longer needed as all the relevant information is inline.\n impl<'a> hir::lowering::Resolver for Resolver<'a> {\n-    fn resolve_hir_path(\n+    fn resolve_ast_path(\n         &mut self,\n         path: &ast::Path,\n         is_value: bool,\n-    ) -> hir::Path {\n-        self.resolve_hir_path_cb(path, is_value,\n+    ) -> Res {\n+        self.resolve_ast_path_cb(path, is_value,\n                                  |resolver, span, error| resolve_error(resolver, span, error))\n     }\n \n@@ -1759,7 +1759,7 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         crate_root: Option<Symbol>,\n         components: &[Symbol],\n         is_value: bool\n-    ) -> hir::Path {\n+    ) -> (ast::Path, Res) {\n         let root = if crate_root.is_some() {\n             kw::PathRoot\n         } else {\n@@ -1777,7 +1777,8 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n             segments,\n         };\n \n-        self.resolve_hir_path(&path, is_value)\n+        let res = self.resolve_ast_path(&path, is_value);\n+        (path, res)\n     }\n \n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes> {\n@@ -1803,7 +1804,7 @@ impl<'a> Resolver<'a> {\n     /// and also it's a private type. Fortunately rustdoc doesn't need to know the error,\n     /// just that an error occurred.\n     pub fn resolve_str_path_error(&mut self, span: Span, path_str: &str, is_value: bool)\n-        -> Result<hir::Path, ()> {\n+        -> Result<(ast::Path, Res), ()> {\n         let mut errored = false;\n \n         let path = if path_str.starts_with(\"::\") {\n@@ -1826,29 +1827,29 @@ impl<'a> Resolver<'a> {\n                     .collect(),\n             }\n         };\n-        let path = self.resolve_hir_path_cb(&path, is_value, |_, _, _| errored = true);\n-        if errored || path.res == def::Res::Err {\n+        let res = self.resolve_ast_path_cb(&path, is_value, |_, _, _| errored = true);\n+        if errored || res == def::Res::Err {\n             Err(())\n         } else {\n-            Ok(path)\n+            Ok((path, res))\n         }\n     }\n \n-    /// Like `resolve_hir_path`, but takes a callback in case there was an error.\n-    fn resolve_hir_path_cb<F>(\n+    /// Like `resolve_ast_path`, but takes a callback in case there was an error.\n+    // FIXME(eddyb) use `Result` or something instead of callbacks.\n+    fn resolve_ast_path_cb<F>(\n         &mut self,\n         path: &ast::Path,\n         is_value: bool,\n         error_callback: F,\n-    ) -> hir::Path\n+    ) -> Res\n         where F: for<'c, 'b> FnOnce(&'c mut Resolver<'_>, Span, ResolutionError<'b>)\n     {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n         let span = path.span;\n-        let segments = &path.segments;\n         let path = Segment::from_path(&path);\n         // FIXME(Manishearth): intra-doc links won't get warned of epoch changes.\n-        let res = match self.resolve_path_without_parent_scope(&path, Some(namespace), true,\n+        match self.resolve_path_without_parent_scope(&path, Some(namespace), true,\n                                                                span, CrateLint::No) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n                 module.res().unwrap(),\n@@ -1869,19 +1870,6 @@ impl<'a> Resolver<'a> {\n                 });\n                 Res::Err\n             }\n-        };\n-\n-        let segments: Vec<_> = segments.iter().map(|seg| {\n-            let mut hir_seg = hir::PathSegment::from_ident(seg.ident);\n-            hir_seg.res = Some(self.partial_res_map.get(&seg.id).map_or(def::Res::Err, |p| {\n-                p.base_res().map_id(|_| panic!(\"unexpected node_id\"))\n-            }));\n-            hir_seg\n-        }).collect();\n-        hir::Path {\n-            span,\n-            res: res.map_id(|_| panic!(\"unexpected node_id\")),\n-            segments: segments.into(),\n         }\n     }\n "}, {"sha": "bb85fe898dabda019f9edc965b5231f57a3b1529", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e6ee8a0d44fcedb583067bbaf36bcdf325029cdd/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6ee8a0d44fcedb583067bbaf36bcdf325029cdd/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=e6ee8a0d44fcedb583067bbaf36bcdf325029cdd", "patch": "@@ -71,15 +71,16 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 })\n             });\n \n-            if let Ok(result) = result {\n+            if let Ok((_, res)) = result {\n+                let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n                 // In case this is a trait item, skip the\n                 // early return and try looking for the trait.\n-                let value = match result.res {\n+                let value = match res {\n                     Res::Def(DefKind::Method, _) | Res::Def(DefKind::AssocConst, _) => true,\n                     Res::Def(DefKind::AssocTy, _) => false,\n-                    Res::Def(DefKind::Variant, _) => return handle_variant(cx, result.res),\n+                    Res::Def(DefKind::Variant, _) => return handle_variant(cx, res),\n                     // Not a trait item; just return what we found.\n-                    _ => return Ok((result.res, None))\n+                    _ => return Ok((res, None))\n                 };\n \n                 if value != (ns == ValueNS) {\n@@ -129,10 +130,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n             // FIXME: `with_scope` requires the `NodeId` of a module.\n             let node_id = cx.tcx.hir().hir_to_node_id(id);\n-            let ty = cx.enter_resolver(|resolver| resolver.with_scope(node_id, |resolver| {\n+            let (_, ty_res) = cx.enter_resolver(|resolver| resolver.with_scope(node_id, |resolver| {\n                     resolver.resolve_str_path_error(DUMMY_SP, &path, false)\n             }))?;\n-            match ty.res {\n+            let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n+            match ty_res {\n                 Res::Def(DefKind::Struct, did)\n                 | Res::Def(DefKind::Union, did)\n                 | Res::Def(DefKind::Enum, did)\n@@ -147,7 +149,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             ty::AssocKind::Const if ns == ValueNS => \"associatedconstant\",\n                             _ => return Err(())\n                         };\n-                        Ok((ty.res, Some(format!(\"{}.{}\", out, item_name))))\n+                        Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n                     } else {\n                         match cx.tcx.type_of(did).sty {\n                             ty::Adt(def, _) => {\n@@ -159,7 +161,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                        .iter()\n                                        .find(|item| item.ident.name == item_name)\n                                 } {\n-                                    Ok((ty.res,\n+                                    Ok((ty_res,\n                                         Some(format!(\"{}.{}\",\n                                                      if def.is_enum() {\n                                                          \"variant\"\n@@ -193,7 +195,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             _ => return Err(())\n                         };\n \n-                        Ok((ty.res, Some(format!(\"{}.{}\", kind, item_name))))\n+                        Ok((ty_res, Some(format!(\"{}.{}\", kind, item_name))))\n                     } else {\n                         Err(())\n                     }"}]}