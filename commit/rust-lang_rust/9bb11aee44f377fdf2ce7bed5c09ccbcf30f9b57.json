{"sha": "9bb11aee44f377fdf2ce7bed5c09ccbcf30f9b57", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYjExYWVlNDRmMzc3ZmRmMmNlN2JlZDVjMDljY2JjZjMwZjliNTc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-20T21:31:12Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-20T21:31:12Z"}, "message": "populate resolve from unresolved imports", "tree": {"sha": "881bfa5cf8479690ed3c127b8a27457885a00736", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/881bfa5cf8479690ed3c127b8a27457885a00736"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bb11aee44f377fdf2ce7bed5c09ccbcf30f9b57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bb11aee44f377fdf2ce7bed5c09ccbcf30f9b57", "html_url": "https://github.com/rust-lang/rust/commit/9bb11aee44f377fdf2ce7bed5c09ccbcf30f9b57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bb11aee44f377fdf2ce7bed5c09ccbcf30f9b57/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aab71bff8eb89fb65f4aba8e90df2ae586ecb0a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/aab71bff8eb89fb65f4aba8e90df2ae586ecb0a6", "html_url": "https://github.com/rust-lang/rust/commit/aab71bff8eb89fb65f4aba8e90df2ae586ecb0a6"}], "stats": {"total": 113, "additions": 97, "deletions": 16}, "files": [{"sha": "2d0bfa64c3de60f8eb78f3e8cafc82db4d5b5f7e", "filename": "crates/ra_analysis/src/descriptors/module/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9bb11aee44f377fdf2ce7bed5c09ccbcf30f9b57/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb11aee44f377fdf2ce7bed5c09ccbcf30f9b57/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs?ref=9bb11aee44f377fdf2ce7bed5c09ccbcf30f9b57", "patch": "@@ -103,9 +103,11 @@ impl ModuleDescriptor {\n \n     /// The root of the tree this module is part of\n     pub fn crate_root(&self) -> ModuleDescriptor {\n-        generate(Some(self.clone()), |it| it.parent())\n-            .last()\n-            .unwrap()\n+        let root_id = self.module_id.crate_root(&self.tree);\n+        ModuleDescriptor {\n+            module_id: root_id,\n+            ..self.clone()\n+        }\n     }\n \n     /// `name` is `None` for the crate's root module\n@@ -205,6 +207,11 @@ impl ModuleId {\n         let link = self.parent_link(tree)?;\n         Some(tree.link(link).owner)\n     }\n+    fn crate_root(self, tree: &ModuleTree) -> ModuleId {\n+        generate(Some(self), move |it| it.parent(tree))\n+            .last()\n+            .unwrap()\n+    }\n     fn child(self, tree: &ModuleTree, name: &str) -> Option<ModuleId> {\n         let link = tree\n             .module(self)"}, {"sha": "058e64ad1830ff0f2831d0d95dd3ac382a42d3bb", "filename": "crates/ra_analysis/src/descriptors/module/nameres.rs", "status": "modified", "additions": 87, "deletions": 13, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/9bb11aee44f377fdf2ce7bed5c09ccbcf30f9b57/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb11aee44f377fdf2ce7bed5c09ccbcf30f9b57/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fnameres.rs?ref=9bb11aee44f377fdf2ce7bed5c09ccbcf30f9b57", "patch": "@@ -52,10 +52,18 @@ struct ItemMap {\n \n #[derive(Debug, Default)]\n struct ModuleItems {\n-    items: FxHashMap<SmolStr, DefId>,\n+    items: FxHashMap<SmolStr, Resolution>,\n     import_resolutions: FxHashMap<LocalSyntaxPtr, DefId>,\n }\n \n+/// Resolution is basically `DefId` atm, but it should account for stuff like\n+/// multiple namespaces, ambiguity and errors.\n+#[derive(Debug, Clone)]\n+struct Resolution {\n+    /// None for unresolved\n+    def_id: Option<DefId>,\n+}\n+\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n enum Namespace {\n     Types,\n@@ -221,22 +229,27 @@ where\n {\n     fn resolve(&mut self) {\n         for (&module_id, items) in self.input.iter() {\n-            self.populate_module(\n-                module_id,\n-                items,\n-            )\n+            self.populate_module(module_id, items)\n+        }\n+\n+        for &module_id in self.input.keys() {\n+            self.resolve_imports(module_id);\n         }\n     }\n \n-    fn populate_module(\n-        &mut self,\n-        module_id: ModuleId,\n-        input: &InputModuleItems,\n-    ) {\n+    fn populate_module(&mut self, module_id: ModuleId, input: &InputModuleItems) {\n         let file_id = module_id.source(&self.module_tree).file_id();\n \n         let mut module_items = ModuleItems::default();\n \n+        for import in input.imports.iter() {\n+            if let Some((_, name)) = import.segments.last() {\n+                module_items\n+                    .items\n+                    .insert(name.clone(), Resolution { def_id: None });\n+            }\n+        }\n+\n         for item in input.items.iter() {\n             if item.kind == MODULE {\n                 // handle submodules separatelly\n@@ -245,7 +258,10 @@ where\n             let ptr = item.ptr.into_global(file_id);\n             let def_loc = DefLoc::Item { ptr };\n             let def_id = self.db.id_maps().def_id(def_loc);\n-            module_items.items.insert(item.name.clone(), def_id);\n+            let resolution = Resolution {\n+                def_id: Some(def_id),\n+            };\n+            module_items.items.insert(item.name.clone(), resolution);\n         }\n \n         for (name, mod_id) in module_id.children(&self.module_tree) {\n@@ -254,11 +270,69 @@ where\n                 source_root: self.source_root,\n             };\n             let def_id = self.db.id_maps().def_id(def_loc);\n-            module_items.items.insert(name, def_id);\n+            let resolution = Resolution {\n+                def_id: Some(def_id),\n+            };\n+            module_items.items.insert(name, resolution);\n         }\n \n         self.result.per_module.insert(module_id, module_items);\n     }\n-}\n \n+    fn resolve_imports(&mut self, module_id: ModuleId) {\n+        for import in self.input[&module_id].imports.iter() {\n+            self.resolve_import(module_id, import);\n+        }\n+    }\n+\n+    fn resolve_import(&mut self, module_id: ModuleId, import: &Path) {\n+        let mut curr = match import.kind {\n+            // TODO: handle extern crates\n+            PathKind::Abs => return,\n+            PathKind::Self_ => module_id,\n+            PathKind::Super => {\n+                match module_id.parent(&self.module_tree) {\n+                    Some(it) => it,\n+                    // TODO: error\n+                    None => return,\n+                }\n+            }\n+            PathKind::Crate => module_id.crate_root(&self.module_tree),\n+        };\n+\n+        for (i, (ptr, name)) in import.segments.iter().enumerate() {\n+            let is_last = i == import.segments.len() - 1;\n+\n+            let def_id = match self.result.per_module[&curr].items.get(name) {\n+                None => return,\n+                Some(res) => match res.def_id {\n+                    Some(it) => it,\n+                    None => return,\n+                },\n+            };\n+\n+            self.update(module_id, |items| {\n+                items.import_resolutions.insert(*ptr, def_id);\n+            });\n \n+            if !is_last {\n+                curr = match self.db.id_maps().def_loc(def_id) {\n+                    DefLoc::Module { id, .. } => id,\n+                    _ => return,\n+                }\n+            } else {\n+                self.update(module_id, |items| {\n+                    let res = Resolution {\n+                        def_id: Some(def_id),\n+                    };\n+                    items.items.insert(name.clone(), res);\n+                })\n+            }\n+        }\n+    }\n+\n+    fn update(&mut self, module_id: ModuleId, f: impl FnOnce(&mut ModuleItems)) {\n+        let module_items = self.result.per_module.get_mut(&module_id).unwrap();\n+        f(module_items)\n+    }\n+}"}]}