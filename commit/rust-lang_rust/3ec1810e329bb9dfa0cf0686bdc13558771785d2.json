{"sha": "3ec1810e329bb9dfa0cf0686bdc13558771785d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlYzE4MTBlMzI5YmI5ZGZhMGNmMDY4NmJkYzEzNTU4NzcxNzg1ZDI=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2018-09-15T00:40:52Z"}, "committer": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2018-09-17T23:31:33Z"}, "message": "Cleanup and fix method resolution issue", "tree": {"sha": "bb9f39ea9e7c740e1b8635f77868b3948a1e5b99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb9f39ea9e7c740e1b8635f77868b3948a1e5b99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ec1810e329bb9dfa0cf0686bdc13558771785d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ec1810e329bb9dfa0cf0686bdc13558771785d2", "html_url": "https://github.com/rust-lang/rust/commit/3ec1810e329bb9dfa0cf0686bdc13558771785d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ec1810e329bb9dfa0cf0686bdc13558771785d2/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "974bdc80fe3214159dc30e0bbb76694900e613c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/974bdc80fe3214159dc30e0bbb76694900e613c0", "html_url": "https://github.com/rust-lang/rust/commit/974bdc80fe3214159dc30e0bbb76694900e613c0"}], "stats": {"total": 190, "additions": 117, "deletions": 73}, "files": [{"sha": "744b611c061b0c55b90def3e2c8256435658c2e5", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ec1810e329bb9dfa0cf0686bdc13558771785d2/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ec1810e329bb9dfa0cf0686bdc13558771785d2/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=3ec1810e329bb9dfa0cf0686bdc13558771785d2", "patch": "@@ -98,8 +98,9 @@ impl<T> Box<T> {\n     }\n \n     #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[inline(always)]\n     pub fn pinned(x: T) -> Pin<Box<T>> {\n-        unsafe { Pin::new_unchecked(box x) }\n+        (box x).into()\n     }\n }\n \n@@ -434,6 +435,9 @@ impl<T> From<T> for Box<T> {\n #[unstable(feature = \"pin\", issue = \"49150\")]\n impl<T> From<Box<T>> for Pin<Box<T>> {\n     fn from(boxed: Box<T>) -> Self {\n+        // It's not possible to move or replace the insides of a `Pin<Box<T>>`\n+        // when `T: !Unpin`,  so it's safe to pin it directly without any\n+        // additional requirements.\n         unsafe { Pin::new_unchecked(boxed) }\n     }\n }"}, {"sha": "f4b5cf95e37fb89cb2c240403bc1b3fa3b48854c", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3ec1810e329bb9dfa0cf0686bdc13558771785d2/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ec1810e329bb9dfa0cf0686bdc13558771785d2/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=3ec1810e329bb9dfa0cf0686bdc13558771785d2", "patch": "@@ -104,14 +104,14 @@ impl<'a, F: ?Sized + Future + Unpin> Future for &'a mut F {\n     }\n }\n \n-impl<P, F> Future for Pin<P> where\n-    P: ops::DerefMut<Target = F> + Unpin,\n-    F: Future + ?Sized,\n+impl<P> Future for Pin<P>\n+where\n+    P: ops::DerefMut,\n+    P::Target: Future,\n {\n-    type Output = F::Output;\n+    type Output = <<P as ops::Deref>::Target as Future>::Output;\n \n-    fn poll(mut self: Pin<&mut Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n-        let pin: Pin<&mut F> = Pin::as_mut(&mut *self);\n-        F::poll(pin, cx)\n+    fn poll(self: Pin<&mut Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n+        Pin::get_mut(self).as_mut().poll(cx)\n     }\n }"}, {"sha": "5d81d21d1dfcac8e15f01ddff057f5d08407e184", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ec1810e329bb9dfa0cf0686bdc13558771785d2/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ec1810e329bb9dfa0cf0686bdc13558771785d2/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=3ec1810e329bb9dfa0cf0686bdc13558771785d2", "patch": "@@ -276,8 +276,7 @@ impl<T> Option<T> {\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n     pub fn as_pin_ref<'a>(self: Pin<&'a Option<T>>) -> Option<Pin<&'a T>> {\n         unsafe {\n-            let option: Option<&'a T> = Pin::get(self).as_ref();\n-            option.map(|x| Pin::new_unchecked(x))\n+            Pin::get_ref(self).as_ref().map(|x| Pin::new_unchecked(x))\n         }\n     }\n \n@@ -286,8 +285,7 @@ impl<T> Option<T> {\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n     pub fn as_pin_mut<'a>(self: Pin<&'a mut Option<T>>) -> Option<Pin<&'a mut T>> {\n         unsafe {\n-            let option: Option<&'a mut T> = Pin::get_mut_unchecked(self).as_mut();\n-            option.map(|x| Pin::new_unchecked(x))\n+            Pin::get_mut_unchecked(self).as_mut().map(|x| Pin::new_unchecked(x))\n         }\n     }\n "}, {"sha": "3ab6dcd8531d138356d7abd82cbdc24f6d8c7749", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 93, "deletions": 49, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/3ec1810e329bb9dfa0cf0686bdc13558771785d2/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ec1810e329bb9dfa0cf0686bdc13558771785d2/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=3ec1810e329bb9dfa0cf0686bdc13558771785d2", "patch": "@@ -7,15 +7,15 @@\n //! since moving an object with pointers to itself will invalidate them,\n //! which could cause undefined behavior.\n //!\n-//! In order to prevent objects from moving, they must be *pinned*,\n+//! In order to prevent objects from moving, they must be pinned\n //! by wrapping a pointer to the data in the [`Pin`] type. A pointer wrapped\n //! in a `Pin` is otherwise equivalent to its normal version, e.g. `Pin<Box<T>>`\n //! and `Box<T>` work the same way except that the first is pinning the value\n //! of `T` in place.\n //!\n //! First of all, these are pointer types because pinned data mustn't be passed around by value\n //! (that would change its location in memory).\n-//! Secondly, since data can be moved out of `&mut` and [`Box`] with functions such as [`swap`],\n+//! Secondly, since data can be moved out of `&mut` and `Box` with functions such as [`swap`],\n //! which causes their contents to swap places in memory,\n //! we need dedicated types that prohibit such operations.\n //!\n@@ -28,7 +28,7 @@\n //! [`Pin`]: struct.Pin.html\n //! [`Unpin`]: trait.Unpin.html\n //! [`swap`]: ../../std/mem/fn.swap.html\n-//! [`Box`]: ../boxed/struct.Box.html\n+//! [`Box`]: ../../std/boxed/struct.Box.html\n //!\n //! # Examples\n //!\n@@ -66,7 +66,7 @@\n //!\n //!         let slice = NonNull::from(&boxed.data);\n //!         // we know this is safe because modifying a field doesn't move the whole struct\n-//!         unsafe { \n+//!         unsafe {\n //!             let mut_ref: Pin<&mut Self> = Pin::as_mut(&mut boxed);\n //!             Pin::get_mut_unchecked(mut_ref).slice = slice;\n //!         }\n@@ -90,9 +90,12 @@\n #![unstable(feature = \"pin\", issue = \"49150\")]\n \n use fmt;\n-use marker::{Sized, Unpin, Unsize};\n+use marker::Sized;\n use ops::{Deref, DerefMut, CoerceUnsized};\n \n+#[doc(inline)]\n+pub use marker::Unpin;\n+\n /// A pinned pointer.\n ///\n /// This is a wrapper around a kind of pointer which makes that pointer \"pin\" its\n@@ -103,71 +106,78 @@ use ops::{Deref, DerefMut, CoerceUnsized};\n ///\n /// [`Unpin`]: ../../std/marker/trait.Unpin.html\n /// [`pin` module]: ../../std/pin/index.html\n+//\n+// Note: the derives below are allowed because they all only use `&P`, so they\n+// cannot move the value behind `pointer`.\n #[unstable(feature = \"pin\", issue = \"49150\")]\n #[fundamental]\n #[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]\n pub struct Pin<P> {\n     pointer: P,\n }\n \n-impl<P, T> Pin<P> where\n-    P: Deref<Target = T>,\n-    T: ?Sized + Unpin,\n+impl<P: Deref> Pin<P>\n+where\n+    P::Target: Unpin,\n {\n     /// Construct a new `Pin` around a pointer to some data of a type that\n     /// implements `Unpin`.\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[inline(always)]\n     pub fn new(pointer: P) -> Pin<P> {\n+        // Safety: the value pointed to is `Unpin`, and so has no requirements\n+        // around pinning.\n         unsafe { Pin::new_unchecked(pointer) }\n     }\n }\n \n-impl<P, T> Pin<P> where\n-    P: Deref<Target = T>,\n-    T: ?Sized,\n-{\n+impl<P: Deref> Pin<P> {\n     /// Construct a new `Pin` around a reference to some data of a type that\n     /// may or may not implement `Unpin`.\n     ///\n     /// # Safety\n     ///\n-    /// This constructor is unsafe because we cannot guarantee that the target data\n-    /// is properly pinned by this pointer. If the constructed `Pin<P>` does not guarantee\n-    /// that the data is \"pinned,\" constructing a `Pin<P>` is undefined behavior and could lead\n-    /// to segmentation faults or worse.\n+    /// This constructor is unsafe because we cannot guarantee that the data\n+    /// pointed to by `pointer` is pinned. If the constructed `Pin<P>` does\n+    /// not guarantee that the data `P` points to is pinned, constructing a\n+    /// `Pin<P>` is undefined behavior.\n+    ///\n+    /// If `pointer` dereferences to an `Unpin` type, `Pin::new` should be used\n+    /// instead.\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[inline(always)]\n     pub unsafe fn new_unchecked(pointer: P) -> Pin<P> {\n         Pin { pointer }\n     }\n \n-\n     /// Get a pinned shared reference from this pinned pointer.\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn as_ref(this: &Pin<P>) -> Pin<&T> {\n-        unsafe { Pin::new_unchecked(&**this) }\n+    #[inline(always)]\n+    pub fn as_ref(self: &Pin<P>) -> Pin<&P::Target> {\n+        unsafe { Pin::new_unchecked(&**self) }\n     }\n }\n \n-impl<P, T> Pin<P> where\n-    P: DerefMut<Target = T>,\n-    T: ?Sized,\n-{\n+impl<P: DerefMut> Pin<P> {\n     /// Get a pinned mutable reference from this pinned pointer.\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn as_mut(this: &mut Pin<P>) -> Pin<&mut T> {\n-        unsafe { Pin::new_unchecked(&mut *this.pointer) }\n+    #[inline(always)]\n+    pub fn as_mut(self: &mut Pin<P>) -> Pin<&mut P::Target> {\n+        unsafe { Pin::new_unchecked(&mut *self.pointer) }\n     }\n \n     /// Assign a new value to the memory behind the pinned reference.\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn set(this: Pin<&mut T>, value: T)\n-        where T: Sized,\n+    #[inline(always)]\n+    pub fn set(mut self: Pin<P>, value: P::Target)\n+    where\n+        P::Target: Sized,\n     {\n-        *this.pointer = value;\n+        *self.pointer = value;\n     }\n }\n \n-impl<'a, T> Pin<&'a T> {\n+impl<'a, T: ?Sized> Pin<&'a T> {\n     /// Construct a new pin by mapping the interior value.\n     ///\n     /// For example, if you  wanted to get a `Pin` of a field of something,\n@@ -188,22 +198,57 @@ impl<'a, T> Pin<&'a T> {\n         Pin::new_unchecked(new_pointer)\n     }\n \n-    /// Get a safe reference out of a pin.\n+    /// Get a shared reference out of a pin.\n+    ///\n+    /// Note: `Pin` also implements `Deref` to the target, which can be used\n+    /// to access the inner value. However, `Deref` only provides a reference\n+    /// that lives for as long as the borrow of the `Pin`, not the lifetime of\n+    /// the `Pin` itself. This method allows turning the `Pin` into a reference\n+    /// with the same lifetime as the original `Pin`.\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn get(this: Pin<&'a T>) -> &'a T {\n+    #[inline(always)]\n+    pub fn get_ref(this: Pin<&'a T>) -> &'a T {\n         this.pointer\n     }\n }\n \n impl<'a, T> Pin<&'a mut T> {\n+    /// Convert this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[inline(always)]\n+    pub fn into_ref(this: Pin<&'a mut T>) -> Pin<&'a T> {\n+        Pin { pointer: this.pointer }\n+    }\n+\n+    /// Get a mutable reference to the data inside of this `Pin`.\n+    ///\n+    /// This requires that the data inside this `Pin` is `Unpin`.\n+    ///\n+    /// Note: `Pin` also implements `DerefMut` to the data, which can be used\n+    /// to access the inner value. However, `DerefMut` only provides a reference\n+    /// that lives for as long as the borrow of the `Pin`, not the lifetime of\n+    /// the `Pin` itself. This method allows turning the `Pin` into a reference\n+    /// with the same lifetime as the original `Pin`.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[inline(always)]\n+    pub fn get_mut(this: Pin<&'a mut T>) -> &'a mut T\n+        where T: Unpin,\n+    {\n+        this.pointer\n+    }\n+\n     /// Get a mutable reference to the data inside of this `Pin`.\n     ///\n     /// # Safety\n     ///\n     /// This function is unsafe. You must guarantee that you will never move\n     /// the data out of the mutable reference you receive when you call this\n     /// function, so that the invariants on the `Pin` type can be upheld.\n+    ///\n+    /// If the underlying data is `Unpin`, `Pin::get_mut` should be used\n+    /// instead.\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[inline(always)]\n     pub unsafe fn get_mut_unchecked(this: Pin<&'a mut T>) -> &'a mut T {\n         this.pointer\n     }\n@@ -230,22 +275,19 @@ impl<'a, T> Pin<&'a mut T> {\n }\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<P, T> Deref for Pin<P> where\n-    P: Deref<Target = T>,\n-    T: ?Sized,\n-{\n-    type Target = T;\n-    fn deref(&self) -> &T {\n+impl<P: Deref> Deref for Pin<P> {\n+    type Target = P::Target;\n+    fn deref(&self) -> &P::Target {\n         &*self.pointer\n     }\n }\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<P, T> DerefMut for Pin<P> where\n-    P: DerefMut<Target = T>,\n-    T: ?Sized + Unpin,\n+impl<P: DerefMut> DerefMut for Pin<P>\n+where\n+    P::Target: Unpin\n {\n-    fn deref_mut(&mut self) -> &mut T {\n+    fn deref_mut(&mut self) -> &mut P::Target {\n         &mut *self.pointer\n     }\n }\n@@ -271,14 +313,16 @@ impl<'a, P: fmt::Pointer> fmt::Pointer for Pin<P> {\n     }\n }\n \n+// Note: this means that any impl of `CoerceUnsized` that allows coercing from\n+// a type that impls `Deref<Target=impl !Unpin>` to a type that impls\n+// `Deref<Target=Unpin>` is unsound. Any such impl would probably be unsound\n+// for other reasons, though, so we just need to take care not to allow such\n+// impls to land in std.\n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Pin<&'a U>> for Pin<&'a T> {}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Pin<&'a mut U>> for Pin<&'a mut T> {}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized> Unpin for Pin<&'a T> {}\n+impl<'a, P, U> CoerceUnsized<Pin<U>> for Pin<P>\n+where\n+    P: CoerceUnsized<U>,\n+{}\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized> Unpin for Pin<&'a mut T> {}\n+impl<'a, P> Unpin for Pin<P> {}"}, {"sha": "cdd65bfddd3c7e1734a4cb8e95861a89f3f87262", "filename": "src/test/run-pass/async-await.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3ec1810e329bb9dfa0cf0686bdc13558771785d2/src%2Ftest%2Frun-pass%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ec1810e329bb9dfa0cf0686bdc13558771785d2/src%2Ftest%2Frun-pass%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await.rs?ref=3ec1810e329bb9dfa0cf0686bdc13558771785d2", "patch": "@@ -12,8 +12,7 @@\n \n #![feature(arbitrary_self_types, async_await, await_macro, futures_api, pin)]\n \n-use std::pin::PinBox;\n-use std::pin::PinMut;\n+use std::pin::Pin;\n use std::future::Future;\n use std::sync::{\n     Arc,\n@@ -49,7 +48,7 @@ fn wake_and_yield_once() -> WakeOnceThenComplete { WakeOnceThenComplete(false) }\n \n impl Future for WakeOnceThenComplete {\n     type Output = ();\n-    fn poll(mut self: PinMut<Self>, cx: &mut Context) -> Poll<()> {\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<()> {\n         if self.0 {\n             Poll::Ready(())\n         } else {\n@@ -124,16 +123,16 @@ where\n     F: FnOnce(u8) -> Fut,\n     Fut: Future<Output = u8>,\n {\n-    let mut fut = PinBox::new(f(9));\n+    let mut fut = Box::pinned(f(9));\n     let counter = Arc::new(Counter { wakes: AtomicUsize::new(0) });\n     let waker = local_waker_from_nonlocal(counter.clone());\n     let spawner = &mut NoopSpawner;\n     let cx = &mut Context::new(&waker, spawner);\n \n     assert_eq!(0, counter.wakes.load(atomic::Ordering::SeqCst));\n-    assert_eq!(Poll::Pending, fut.as_pin_mut().poll(cx));\n+    assert_eq!(Poll::Pending, fut.as_mut().poll(cx));\n     assert_eq!(1, counter.wakes.load(atomic::Ordering::SeqCst));\n-    assert_eq!(Poll::Ready(9), fut.as_pin_mut().poll(cx));\n+    assert_eq!(Poll::Ready(9), fut.as_mut().poll(cx));\n }\n \n fn main() {"}, {"sha": "6e757fb4f9a42f16ce74b5ceab74d996429b008c", "filename": "src/test/run-pass/futures-api.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3ec1810e329bb9dfa0cf0686bdc13558771785d2/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ec1810e329bb9dfa0cf0686bdc13558771785d2/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffutures-api.rs?ref=3ec1810e329bb9dfa0cf0686bdc13558771785d2", "patch": "@@ -11,9 +11,8 @@\n #![feature(arbitrary_self_types, futures_api, pin)]\n #![allow(unused)]\n \n-use std::pin::PinBox;\n use std::future::Future;\n-use std::pin::PinMut;\n+use std::pin::Pin;\n use std::rc::Rc;\n use std::sync::{\n     Arc,\n@@ -54,12 +53,12 @@ struct MyFuture;\n \n impl Future for MyFuture {\n     type Output = ();\n-    fn poll(self: PinMut<Self>, cx: &mut Context) -> Poll<Self::Output> {\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n         // Ensure all the methods work appropriately\n         cx.waker().wake();\n         cx.waker().wake();\n         cx.local_waker().wake();\n-        cx.spawner().spawn_obj(PinBox::new(MyFuture).into()).unwrap();\n+        cx.spawner().spawn_obj(Box::pinned(MyFuture).into()).unwrap();\n         Poll::Ready(())\n     }\n }\n@@ -72,7 +71,7 @@ fn test_local_waker() {\n     let waker = unsafe { local_waker(counter.clone()) };\n     let spawner = &mut NoopSpawner;\n     let cx = &mut Context::new(&waker, spawner);\n-    assert_eq!(Poll::Ready(()), PinMut::new(&mut MyFuture).poll(cx));\n+    assert_eq!(Poll::Ready(()), Pin::new(&mut MyFuture).poll(cx));\n     assert_eq!(1, counter.local_wakes.load(atomic::Ordering::SeqCst));\n     assert_eq!(2, counter.nonlocal_wakes.load(atomic::Ordering::SeqCst));\n }\n@@ -85,7 +84,7 @@ fn test_local_as_nonlocal_waker() {\n     let waker: LocalWaker = local_waker_from_nonlocal(counter.clone());\n     let spawner = &mut NoopSpawner;\n     let cx = &mut Context::new(&waker, spawner);\n-    assert_eq!(Poll::Ready(()), PinMut::new(&mut MyFuture).poll(cx));\n+    assert_eq!(Poll::Ready(()), Pin::new(&mut MyFuture).poll(cx));\n     assert_eq!(0, counter.local_wakes.load(atomic::Ordering::SeqCst));\n     assert_eq!(3, counter.nonlocal_wakes.load(atomic::Ordering::SeqCst));\n }"}]}