{"sha": "fe93675e8ac2b55d051156151489dbe0496efec3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlOTM2NzVlOGFjMmI1NWQwNTExNTYxNTE0ODlkYmUwNDk2ZWZlYzM=", "commit": {"author": {"name": "Timo Freiberg", "email": "timo.freiberg@gmail.com", "date": "2020-04-25T14:57:59Z"}, "committer": {"name": "Timo Freiberg", "email": "timo.freiberg@gmail.com", "date": "2020-05-08T15:12:18Z"}, "message": "New HirDisplay method for displaying sourcecode", "tree": {"sha": "d01e03cd79aff92b553a25ba58b2e4b95262ab5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d01e03cd79aff92b553a25ba58b2e4b95262ab5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe93675e8ac2b55d051156151489dbe0496efec3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe93675e8ac2b55d051156151489dbe0496efec3", "html_url": "https://github.com/rust-lang/rust/commit/fe93675e8ac2b55d051156151489dbe0496efec3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe93675e8ac2b55d051156151489dbe0496efec3/comments", "author": {"login": "TimoFreiberg", "id": 5281645, "node_id": "MDQ6VXNlcjUyODE2NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/5281645?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimoFreiberg", "html_url": "https://github.com/TimoFreiberg", "followers_url": "https://api.github.com/users/TimoFreiberg/followers", "following_url": "https://api.github.com/users/TimoFreiberg/following{/other_user}", "gists_url": "https://api.github.com/users/TimoFreiberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimoFreiberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimoFreiberg/subscriptions", "organizations_url": "https://api.github.com/users/TimoFreiberg/orgs", "repos_url": "https://api.github.com/users/TimoFreiberg/repos", "events_url": "https://api.github.com/users/TimoFreiberg/events{/privacy}", "received_events_url": "https://api.github.com/users/TimoFreiberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TimoFreiberg", "id": 5281645, "node_id": "MDQ6VXNlcjUyODE2NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/5281645?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimoFreiberg", "html_url": "https://github.com/TimoFreiberg", "followers_url": "https://api.github.com/users/TimoFreiberg/followers", "following_url": "https://api.github.com/users/TimoFreiberg/following{/other_user}", "gists_url": "https://api.github.com/users/TimoFreiberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimoFreiberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimoFreiberg/subscriptions", "organizations_url": "https://api.github.com/users/TimoFreiberg/orgs", "repos_url": "https://api.github.com/users/TimoFreiberg/repos", "events_url": "https://api.github.com/users/TimoFreiberg/events{/privacy}", "received_events_url": "https://api.github.com/users/TimoFreiberg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3eb9d8eafbebca7da95fa8a4813b92eb5080500", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3eb9d8eafbebca7da95fa8a4813b92eb5080500", "html_url": "https://github.com/rust-lang/rust/commit/d3eb9d8eafbebca7da95fa8a4813b92eb5080500"}], "stats": {"total": 225, "additions": 184, "deletions": 41}, "files": [{"sha": "be18c845c643d7a8dcf2c0b346a1e84e913ef1d8", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe93675e8ac2b55d051156151489dbe0496efec3/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe93675e8ac2b55d051156151489dbe0496efec3/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=fe93675e8ac2b55d051156151489dbe0496efec3", "patch": "@@ -22,8 +22,11 @@ use hir_expand::{\n     MacroDefId, MacroDefKind,\n };\n use hir_ty::{\n-    autoderef, display::HirFormatter, expr::ExprValidator, method_resolution, ApplicationTy,\n-    Canonical, InEnvironment, Substs, TraitEnvironment, Ty, TyDefId, TypeCtor,\n+    autoderef,\n+    display::{HirDisplayError, HirFormatter},\n+    expr::ExprValidator,\n+    method_resolution, ApplicationTy, Canonical, InEnvironment, Substs, TraitEnvironment, Ty,\n+    TyDefId, TypeCtor,\n };\n use ra_db::{CrateId, CrateName, Edition, FileId};\n use ra_prof::profile;\n@@ -1319,7 +1322,7 @@ impl Type {\n }\n \n impl HirDisplay for Type {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> std::fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         self.ty.value.hir_fmt(f)\n     }\n }"}, {"sha": "f5edaea8c80683f49b29a33ff4ea069fbf0f2008", "filename": "crates/ra_hir_ty/src/display.rs", "status": "modified", "additions": 140, "deletions": 36, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/fe93675e8ac2b55d051156151489dbe0496efec3/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe93675e8ac2b55d051156151489dbe0496efec3/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs?ref=fe93675e8ac2b55d051156151489dbe0496efec3", "patch": "@@ -6,28 +6,42 @@ use crate::{\n     db::HirDatabase, utils::generics, ApplicationTy, CallableDef, FnSig, GenericPredicate,\n     Obligation, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n };\n-use hir_def::{generics::TypeParamProvenance, AdtId, AssocContainerId, Lookup};\n+use hir_def::{\n+    find_path, generics::TypeParamProvenance, item_scope::ItemInNs, AdtId, AssocContainerId,\n+    Lookup, ModuleId,\n+};\n use hir_expand::name::Name;\n \n-pub struct HirFormatter<'a, 'b> {\n+pub struct HirFormatter<'a> {\n     pub db: &'a dyn HirDatabase,\n-    fmt: &'a mut fmt::Formatter<'b>,\n+    fmt: &'a mut dyn fmt::Write,\n     buf: String,\n     curr_size: usize,\n     pub(crate) max_size: Option<usize>,\n     omit_verbose_types: bool,\n+    display_target: DisplayTarget,\n }\n \n pub trait HirDisplay {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result;\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError>;\n \n+    /// Returns a `Display`able type that is human-readable.\n+    /// Use this for showing types to the user (e.g. diagnostics)\n     fn display<'a>(&'a self, db: &'a dyn HirDatabase) -> HirDisplayWrapper<'a, Self>\n     where\n         Self: Sized,\n     {\n-        HirDisplayWrapper(db, self, None, false)\n+        HirDisplayWrapper {\n+            db,\n+            t: self,\n+            max_size: None,\n+            omit_verbose_types: false,\n+            display_target: DisplayTarget::Diagnostics,\n+        }\n     }\n \n+    /// Returns a `Display`able type that is human-readable and tries to be succinct.\n+    /// Use this for showing types to the user where space is constrained (e.g. doc popups)\n     fn display_truncated<'a>(\n         &'a self,\n         db: &'a dyn HirDatabase,\n@@ -36,16 +50,46 @@ pub trait HirDisplay {\n     where\n         Self: Sized,\n     {\n-        HirDisplayWrapper(db, self, max_size, true)\n+        HirDisplayWrapper {\n+            db,\n+            t: self,\n+            max_size,\n+            omit_verbose_types: true,\n+            display_target: DisplayTarget::Diagnostics,\n+        }\n+    }\n+\n+    /// Returns a String representation of `self` that can be inserted into the given module.\n+    /// Use this when generating code (e.g. assists)\n+    fn display_source_code<'a>(\n+        &'a self,\n+        db: &'a dyn HirDatabase,\n+        module_id: ModuleId,\n+    ) -> Result<String, DisplaySourceCodeError> {\n+        let mut result = String::new();\n+        match self.hir_fmt(&mut HirFormatter {\n+            db,\n+            fmt: &mut result,\n+            buf: String::with_capacity(20),\n+            curr_size: 0,\n+            max_size: None,\n+            omit_verbose_types: false,\n+            display_target: DisplayTarget::SourceCode { module_id },\n+        }) {\n+            Ok(()) => {}\n+            Err(HirDisplayError::FmtError) => panic!(\"Writing to String can't fail!\"),\n+            Err(HirDisplayError::DisplaySourceCodeError(e)) => return Err(e),\n+        };\n+        Ok(result)\n     }\n }\n \n-impl<'a, 'b> HirFormatter<'a, 'b> {\n+impl<'a> HirFormatter<'a> {\n     pub fn write_joined<T: HirDisplay>(\n         &mut self,\n         iter: impl IntoIterator<Item = T>,\n         sep: &str,\n-    ) -> fmt::Result {\n+    ) -> Result<(), HirDisplayError> {\n         let mut first = true;\n         for e in iter {\n             if !first {\n@@ -58,14 +102,14 @@ impl<'a, 'b> HirFormatter<'a, 'b> {\n     }\n \n     /// This allows using the `write!` macro directly with a `HirFormatter`.\n-    pub fn write_fmt(&mut self, args: fmt::Arguments) -> fmt::Result {\n+    pub fn write_fmt(&mut self, args: fmt::Arguments) -> Result<(), HirDisplayError> {\n         // We write to a buffer first to track output size\n         self.buf.clear();\n         fmt::write(&mut self.buf, args)?;\n         self.curr_size += self.buf.len();\n \n         // Then we write to the internal formatter from the buffer\n-        self.fmt.write_str(&self.buf)\n+        self.fmt.write_str(&self.buf).map_err(HirDisplayError::from)\n     }\n \n     pub fn should_truncate(&self) -> bool {\n@@ -81,34 +125,76 @@ impl<'a, 'b> HirFormatter<'a, 'b> {\n     }\n }\n \n-pub struct HirDisplayWrapper<'a, T>(&'a dyn HirDatabase, &'a T, Option<usize>, bool);\n+#[derive(Clone, Copy)]\n+enum DisplayTarget {\n+    /// Display types for inlays, doc popups, autocompletion, etc...\n+    /// Showing `{unknown}` or not qualifying paths is fine here.\n+    /// There's no reason for this to fail.\n+    Diagnostics,\n+    /// Display types for inserting them in source files.\n+    /// The generated code should compile, so paths need to be qualified.\n+    SourceCode { module_id: ModuleId },\n+}\n+\n+#[derive(Debug)]\n+pub enum DisplaySourceCodeError {\n+    PathNotFound,\n+}\n+\n+pub enum HirDisplayError {\n+    /// Errors that can occur when generating source code\n+    DisplaySourceCodeError(DisplaySourceCodeError),\n+    /// `FmtError` is required to be compatible with std::fmt::Display\n+    FmtError,\n+}\n+impl From<fmt::Error> for HirDisplayError {\n+    fn from(_: fmt::Error) -> Self {\n+        Self::FmtError\n+    }\n+}\n+\n+pub struct HirDisplayWrapper<'a, T> {\n+    db: &'a dyn HirDatabase,\n+    t: &'a T,\n+    max_size: Option<usize>,\n+    omit_verbose_types: bool,\n+    display_target: DisplayTarget,\n+}\n \n impl<'a, T> fmt::Display for HirDisplayWrapper<'a, T>\n where\n     T: HirDisplay,\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.1.hir_fmt(&mut HirFormatter {\n-            db: self.0,\n+        match self.t.hir_fmt(&mut HirFormatter {\n+            db: self.db,\n             fmt: f,\n             buf: String::with_capacity(20),\n             curr_size: 0,\n-            max_size: self.2,\n-            omit_verbose_types: self.3,\n-        })\n+            max_size: self.max_size,\n+            omit_verbose_types: self.omit_verbose_types,\n+            display_target: self.display_target,\n+        }) {\n+            Ok(()) => Ok(()),\n+            Err(HirDisplayError::FmtError) => Err(fmt::Error),\n+            Err(HirDisplayError::DisplaySourceCodeError(_)) => {\n+                // This should never happen\n+                panic!(\"HirDisplay failed when calling Display::fmt!\")\n+            }\n+        }\n     }\n }\n \n const TYPE_HINT_TRUNCATION: &str = \"\u2026\";\n \n impl HirDisplay for &Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         HirDisplay::hir_fmt(*self, f)\n     }\n }\n \n impl HirDisplay for ApplicationTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -191,12 +277,30 @@ impl HirDisplay for ApplicationTy {\n                 }\n             }\n             TypeCtor::Adt(def_id) => {\n-                let name = match def_id {\n-                    AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n-                    AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n-                    AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n-                };\n-                write!(f, \"{}\", name)?;\n+                match f.display_target {\n+                    DisplayTarget::Diagnostics => {\n+                        let name = match def_id {\n+                            AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n+                            AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n+                            AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n+                        };\n+                        write!(f, \"{}\", name)?;\n+                    }\n+                    DisplayTarget::SourceCode { module_id } => {\n+                        if let Some(path) = find_path::find_path(\n+                            f.db.upcast(),\n+                            ItemInNs::Types(def_id.into()),\n+                            module_id,\n+                        ) {\n+                            write!(f, \"{}\", path)?;\n+                        } else {\n+                            return Err(HirDisplayError::DisplaySourceCodeError(\n+                                DisplaySourceCodeError::PathNotFound,\n+                            ));\n+                        }\n+                    }\n+                }\n+\n                 if self.parameters.len() > 0 {\n                     let mut non_default_parameters = Vec::with_capacity(self.parameters.len());\n                     let parameters_to_write = if f.omit_verbose_types() {\n@@ -269,7 +373,7 @@ impl HirDisplay for ApplicationTy {\n }\n \n impl HirDisplay for ProjectionTy {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -287,7 +391,7 @@ impl HirDisplay for ProjectionTy {\n }\n \n impl HirDisplay for Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -332,7 +436,7 @@ impl HirDisplay for Ty {\n fn write_bounds_like_dyn_trait(\n     predicates: &[GenericPredicate],\n     f: &mut HirFormatter,\n-) -> fmt::Result {\n+) -> Result<(), HirDisplayError> {\n     // Note: This code is written to produce nice results (i.e.\n     // corresponding to surface Rust) for types that can occur in\n     // actual Rust. It will have weird results if the predicates\n@@ -394,7 +498,7 @@ fn write_bounds_like_dyn_trait(\n }\n \n impl TraitRef {\n-    fn hir_fmt_ext(&self, f: &mut HirFormatter, use_as: bool) -> fmt::Result {\n+    fn hir_fmt_ext(&self, f: &mut HirFormatter, use_as: bool) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -416,19 +520,19 @@ impl TraitRef {\n }\n \n impl HirDisplay for TraitRef {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         self.hir_fmt_ext(f, false)\n     }\n }\n \n impl HirDisplay for &GenericPredicate {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         HirDisplay::hir_fmt(*self, f)\n     }\n }\n \n impl HirDisplay for GenericPredicate {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n@@ -452,15 +556,15 @@ impl HirDisplay for GenericPredicate {\n }\n \n impl HirDisplay for Obligation {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> fmt::Result {\n-        match self {\n-            Obligation::Trait(tr) => write!(f, \"Implements({})\", tr.display(f.db)),\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        Ok(match self {\n+            Obligation::Trait(tr) => write!(f, \"Implements({})\", tr.display(f.db))?,\n             Obligation::Projection(proj) => write!(\n                 f,\n                 \"Normalize({} => {})\",\n                 proj.projection_ty.display(f.db),\n                 proj.ty.display(f.db)\n-            ),\n-        }\n+            )?,\n+        })\n     }\n }"}, {"sha": "623d000106658b29aa7b980868e7592d823452bf", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fe93675e8ac2b55d051156151489dbe0496efec3/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe93675e8ac2b55d051156151489dbe0496efec3/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=fe93675e8ac2b55d051156151489dbe0496efec3", "patch": "@@ -6,6 +6,7 @@ mod patterns;\n mod traits;\n mod method_resolution;\n mod macros;\n+mod display_source_code;\n \n use std::sync::Arc;\n \n@@ -16,7 +17,7 @@ use hir_def::{\n     item_scope::ItemScope,\n     keys,\n     nameres::CrateDefMap,\n-    AssocItemId, DefWithBodyId, LocalModuleId, Lookup, ModuleDefId,\n+    AssocItemId, DefWithBodyId, LocalModuleId, Lookup, ModuleDefId, ModuleId,\n };\n use hir_expand::{db::AstDatabase, InFile};\n use insta::assert_snapshot;\n@@ -37,6 +38,18 @@ use crate::{\n // update the snapshots.\n \n fn type_at_pos(db: &TestDB, pos: FilePosition) -> String {\n+    type_at_pos_displayed(db, pos, |ty, _| ty.display(db).to_string())\n+}\n+\n+fn displayed_source_at_pos(db: &TestDB, pos: FilePosition) -> String {\n+    type_at_pos_displayed(db, pos, |ty, module_id| ty.display_source_code(db, module_id).unwrap())\n+}\n+\n+fn type_at_pos_displayed(\n+    db: &TestDB,\n+    pos: FilePosition,\n+    display_fn: impl FnOnce(&Ty, ModuleId) -> String,\n+) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();\n     let fn_def = expr.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n@@ -49,7 +62,7 @@ fn type_at_pos(db: &TestDB, pos: FilePosition) -> String {\n     if let Some(expr_id) = source_map.node_expr(InFile::new(pos.file_id.into(), &expr)) {\n         let infer = db.infer(func.into());\n         let ty = &infer[expr_id];\n-        return ty.display(db).to_string();\n+        return display_fn(ty, module);\n     }\n     panic!(\"Can't find expression\")\n }"}, {"sha": "ca17486152e2be017b9baa498cdc5c6dc8c3965a", "filename": "crates/ra_hir_ty/src/tests/display_source_code.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fe93675e8ac2b55d051156151489dbe0496efec3/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe93675e8ac2b55d051156151489dbe0496efec3/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=fe93675e8ac2b55d051156151489dbe0496efec3", "patch": "@@ -0,0 +1,23 @@\n+use super::displayed_source_at_pos;\n+use crate::test_db::TestDB;\n+use ra_db::fixture::WithFixture;\n+\n+#[test]\n+fn qualify_path_to_submodule() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs\n+\n+mod foo {\n+    pub struct Foo;\n+}\n+\n+fn bar() {\n+    let foo: foo::Foo = foo::Foo;\n+    foo<|>\n+}\n+\n+\"#,\n+    );\n+    assert_eq!(\"foo::Foo\", displayed_source_at_pos(&db, pos));\n+}"}]}