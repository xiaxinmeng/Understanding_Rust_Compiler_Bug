{"sha": "49bba315e4adea34617193ec51f89c3416b95b6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5YmJhMzE1ZTRhZGVhMzQ2MTcxOTNlYzUxZjg5YzM0MTZiOTViNmM=", "commit": {"author": {"name": "scott-linder", "email": "scott.b.linder@wmich.edu", "date": "2017-06-12T12:38:29Z"}, "committer": {"name": "scott-linder", "email": "scott.b.linder@wmich.edu", "date": "2017-06-12T12:38:29Z"}, "message": "Merge nested `if` into adjacent `if_let_chain!`", "tree": {"sha": "795e605a6c0ac48e2b370667767e7a0b2e29206f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/795e605a6c0ac48e2b370667767e7a0b2e29206f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49bba315e4adea34617193ec51f89c3416b95b6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49bba315e4adea34617193ec51f89c3416b95b6c", "html_url": "https://github.com/rust-lang/rust/commit/49bba315e4adea34617193ec51f89c3416b95b6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49bba315e4adea34617193ec51f89c3416b95b6c/comments", "author": null, "committer": null, "parents": [{"sha": "54b52054c98e641b18e3043fff3f6c6deaa001bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/54b52054c98e641b18e3043fff3f6c6deaa001bb", "html_url": "https://github.com/rust-lang/rust/commit/54b52054c98e641b18e3043fff3f6c6deaa001bb"}], "stats": {"total": 62, "additions": 30, "deletions": 32}, "files": [{"sha": "b3d2a374865e38ea7a17ec48ee47f29d19b466cc", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/49bba315e4adea34617193ec51f89c3416b95b6c/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49bba315e4adea34617193ec51f89c3416b95b6c/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=49bba315e4adea34617193ec51f89c3416b95b6c", "patch": "@@ -187,38 +187,36 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n             match ty.node {\n                 TyPath(ref qpath) => {\n                     let def = cx.tables.qpath_def(qpath, ast_ty.id);\n-                    if let Some(def_id) = opt_def_id(def) {\n-                        if Some(def_id) == cx.tcx.lang_items.owned_box() {\n-                            if_let_chain! {[\n-                                let QPath::Resolved(None, ref path) = *qpath,\n-                                let [ref bx] = *path.segments,\n-                                let PathParameters::AngleBracketedParameters(ref ab_data) = bx.parameters,\n-                                let [ref inner] = *ab_data.types\n-                            ], {\n-                                let ltopt = if lt.is_elided() {\n-                                    \"\".to_owned()\n-                                } else {\n-                                    format!(\"{} \", lt.name.as_str())\n-                                };\n-                                let mutopt = if *mutbl == Mutability::MutMutable {\n-                                    \"mut \"\n-                                } else {\n-                                    \"\"\n-                                };\n-                                span_lint_and_then(cx,\n-                                    BORROWED_BOX,\n-                                    ast_ty.span,\n-                                    \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n-                                    |db| {\n-                                        db.span_suggestion(ast_ty.span,\n-                                            \"try\",\n-                                            format!(\"&{}{}{}\", ltopt, mutopt, &snippet(cx, inner.span, \"..\")));\n-                                    }\n-                                );\n-                                return; // don't recurse into the type\n-                            }};\n-                        }\n-                    }\n+                    if_let_chain! {[\n+                        let Some(def_id) = opt_def_id(def),\n+                        Some(def_id) == cx.tcx.lang_items.owned_box(),\n+                        let QPath::Resolved(None, ref path) = *qpath,\n+                        let [ref bx] = *path.segments,\n+                        let PathParameters::AngleBracketedParameters(ref ab_data) = bx.parameters,\n+                        let [ref inner] = *ab_data.types\n+                    ], {\n+                        let ltopt = if lt.is_elided() {\n+                            \"\".to_owned()\n+                        } else {\n+                            format!(\"{} \", lt.name.as_str())\n+                        };\n+                        let mutopt = if *mutbl == Mutability::MutMutable {\n+                            \"mut \"\n+                        } else {\n+                            \"\"\n+                        };\n+                        span_lint_and_then(cx,\n+                            BORROWED_BOX,\n+                            ast_ty.span,\n+                            \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n+                            |db| {\n+                                db.span_suggestion(ast_ty.span,\n+                                    \"try\",\n+                                    format!(\"&{}{}{}\", ltopt, mutopt, &snippet(cx, inner.span, \"..\")));\n+                            }\n+                        );\n+                        return; // don't recurse into the type\n+                    }};\n                     check_ty(cx, ty, is_local);\n                 },\n                 _ => check_ty(cx, ty, is_local),"}]}