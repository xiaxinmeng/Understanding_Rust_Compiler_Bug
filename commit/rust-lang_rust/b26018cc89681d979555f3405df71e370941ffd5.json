{"sha": "b26018cc89681d979555f3405df71e370941ffd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNjAxOGNjODk2ODFkOTc5NTU1ZjM0MDVkZjcxZTM3MDk0MWZmZDU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-27T22:11:01Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-03T22:01:58Z"}, "message": "librustc: De-`@mut` (and de-`@`) the pretty printer", "tree": {"sha": "0a37c52d02d783598ce9528b00ba00e8da4c3219", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a37c52d02d783598ce9528b00ba00e8da4c3219"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b26018cc89681d979555f3405df71e370941ffd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b26018cc89681d979555f3405df71e370941ffd5", "html_url": "https://github.com/rust-lang/rust/commit/b26018cc89681d979555f3405df71e370941ffd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b26018cc89681d979555f3405df71e370941ffd5/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d66af2698fd2ff2d19d68cda4eb804b5d319e5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d66af2698fd2ff2d19d68cda4eb804b5d319e5b", "html_url": "https://github.com/rust-lang/rust/commit/4d66af2698fd2ff2d19d68cda4eb804b5d319e5b"}], "stats": {"total": 846, "additions": 435, "deletions": 411}, "files": [{"sha": "b5f9ee68f7c28a8cdbaf796b383dc1e6eeed1d73", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b26018cc89681d979555f3405df71e370941ffd5/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26018cc89681d979555f3405df71e370941ffd5/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=b26018cc89681d979555f3405df71e370941ffd5", "patch": "@@ -517,20 +517,20 @@ impl pprust::pp_ann for IdentifiedAnnotation {\n     fn post(&self, node: pprust::ann_node) {\n         match node {\n             pprust::node_item(s, item) => {\n-                pp::space(s.s);\n+                pp::space(&mut s.s);\n                 pprust::synth_comment(s, item.id.to_str());\n             }\n-            pprust::node_block(s, ref blk) => {\n-                pp::space(s.s);\n+            pprust::node_block(s, blk) => {\n+                pp::space(&mut s.s);\n                 pprust::synth_comment(s, ~\"block \" + blk.id.to_str());\n             }\n             pprust::node_expr(s, expr) => {\n-                pp::space(s.s);\n+                pp::space(&mut s.s);\n                 pprust::synth_comment(s, expr.id.to_str());\n                 pprust::pclose(s);\n             }\n             pprust::node_pat(s, pat) => {\n-                pp::space(s.s);\n+                pp::space(&mut s.s);\n                 pprust::synth_comment(s, ~\"pat \" + pat.id.to_str());\n             }\n         }\n@@ -552,10 +552,10 @@ impl pprust::pp_ann for TypedAnnotation {\n         let tcx = self.analysis.ty_cx;\n         match node {\n             pprust::node_expr(s, expr) => {\n-                pp::space(s.s);\n-                pp::word(s.s, \"as\");\n-                pp::space(s.s);\n-                pp::word(s.s, ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n+                pp::space(&mut s.s);\n+                pp::word(&mut s.s, \"as\");\n+                pp::space(&mut s.s);\n+                pp::word(&mut s.s, ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n                 pprust::pclose(s);\n             }\n             _ => ()"}, {"sha": "6d0c2b497ca49b476a7b94b744f877c7489714b8", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b26018cc89681d979555f3405df71e370941ffd5/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26018cc89681d979555f3405df71e370941ffd5/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=b26018cc89681d979555f3405df71e370941ffd5", "patch": "@@ -118,7 +118,7 @@ impl<O:DataFlowOperator> pprust::pp_ann for DataFlowContext<O> {\n             let comment_str = format!(\"id {}: {}{}{}\",\n                                       id, entry_str, gens_str, kills_str);\n             pprust::synth_comment(ps, comment_str);\n-            pp::space(ps.s);\n+            pp::space(&mut ps.s);\n         }\n     }\n }\n@@ -353,13 +353,13 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n     }\n \n     fn pretty_print_to(@self, wr: @mut io::Writer, blk: &ast::Block) {\n-        let ps = pprust::rust_printer_annotated(wr,\n-                                                self.tcx.sess.intr(),\n-                                                self as @pprust::pp_ann);\n-        pprust::cbox(ps, pprust::indent_unit);\n-        pprust::ibox(ps, 0u);\n-        pprust::print_block(ps, blk);\n-        pp::eof(ps.s);\n+        let mut ps = pprust::rust_printer_annotated(wr,\n+                                                    self.tcx.sess.intr(),\n+                                                    self as @pprust::pp_ann);\n+        pprust::cbox(&mut ps, pprust::indent_unit);\n+        pprust::ibox(&mut ps, 0u);\n+        pprust::print_block(&mut ps, blk);\n+        pp::eof(&mut ps.s);\n     }\n }\n "}, {"sha": "ad55d64494bcb32f9bbc7f96c1883773de536814", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b26018cc89681d979555f3405df71e370941ffd5/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26018cc89681d979555f3405df71e370941ffd5/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=b26018cc89681d979555f3405df71e370941ffd5", "patch": "@@ -148,15 +148,15 @@ pub struct print_stack_elt {\n \n pub static size_infinity: int = 0xffff;\n \n-pub fn mk_printer(out: @mut io::Writer, linewidth: uint) -> @mut Printer {\n+pub fn mk_printer(out: @mut io::Writer, linewidth: uint) -> Printer {\n     // Yes 3, it makes the ring buffers big enough to never\n     // fall behind.\n     let n: uint = 3 * linewidth;\n     debug!(\"mk_printer {}\", linewidth);\n     let token: ~[token] = vec::from_elem(n, EOF);\n     let size: ~[int] = vec::from_elem(n, 0);\n     let scan_stack: ~[uint] = vec::from_elem(n, 0u);\n-    @mut Printer {\n+    Printer {\n         out: out,\n         buf_len: n,\n         margin: linewidth as int,\n@@ -557,47 +557,47 @@ impl Printer {\n // Convenience functions to talk to the printer.\n //\n // \"raw box\"\n-pub fn rbox(p: @mut Printer, indent: uint, b: breaks) {\n+pub fn rbox(p: &mut Printer, indent: uint, b: breaks) {\n     p.pretty_print(BEGIN(begin_t {\n         offset: indent as int,\n         breaks: b\n     }));\n }\n \n-pub fn ibox(p: @mut Printer, indent: uint) { rbox(p, indent, inconsistent); }\n+pub fn ibox(p: &mut Printer, indent: uint) { rbox(p, indent, inconsistent); }\n \n-pub fn cbox(p: @mut Printer, indent: uint) { rbox(p, indent, consistent); }\n+pub fn cbox(p: &mut Printer, indent: uint) { rbox(p, indent, consistent); }\n \n-pub fn break_offset(p: @mut Printer, n: uint, off: int) {\n+pub fn break_offset(p: &mut Printer, n: uint, off: int) {\n     p.pretty_print(BREAK(break_t {\n         offset: off,\n         blank_space: n as int\n     }));\n }\n \n-pub fn end(p: @mut Printer) { p.pretty_print(END); }\n+pub fn end(p: &mut Printer) { p.pretty_print(END); }\n \n-pub fn eof(p: @mut Printer) { p.pretty_print(EOF); }\n+pub fn eof(p: &mut Printer) { p.pretty_print(EOF); }\n \n-pub fn word(p: @mut Printer, wrd: &str) {\n+pub fn word(p: &mut Printer, wrd: &str) {\n     p.pretty_print(STRING(/* bad */ wrd.to_managed(), wrd.len() as int));\n }\n \n-pub fn huge_word(p: @mut Printer, wrd: &str) {\n+pub fn huge_word(p: &mut Printer, wrd: &str) {\n     p.pretty_print(STRING(/* bad */ wrd.to_managed(), size_infinity));\n }\n \n-pub fn zero_word(p: @mut Printer, wrd: &str) {\n+pub fn zero_word(p: &mut Printer, wrd: &str) {\n     p.pretty_print(STRING(/* bad */ wrd.to_managed(), 0));\n }\n \n-pub fn spaces(p: @mut Printer, n: uint) { break_offset(p, n, 0); }\n+pub fn spaces(p: &mut Printer, n: uint) { break_offset(p, n, 0); }\n \n-pub fn zerobreak(p: @mut Printer) { spaces(p, 0u); }\n+pub fn zerobreak(p: &mut Printer) { spaces(p, 0u); }\n \n-pub fn space(p: @mut Printer) { spaces(p, 1u); }\n+pub fn space(p: &mut Printer) { spaces(p, 1u); }\n \n-pub fn hardbreak(p: @mut Printer) { spaces(p, size_infinity as uint); }\n+pub fn hardbreak(p: &mut Printer) { spaces(p, size_infinity as uint); }\n \n pub fn hardbreak_tok_offset(off: int) -> token {\n     BREAK(break_t {offset: off, blank_space: size_infinity})"}, {"sha": "7cf47cc1fd4b2bff7e4712818219594da55bf7c1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 403, "deletions": 379, "changes": 782, "blob_url": "https://github.com/rust-lang/rust/blob/b26018cc89681d979555f3405df71e370941ffd5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26018cc89681d979555f3405df71e370941ffd5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b26018cc89681d979555f3405df71e370941ffd5", "patch": "@@ -33,12 +33,12 @@ use std::io;\n use std::io::Decorator;\n use std::io::mem::MemWriter;\n \n-// The @ps is stored here to prevent recursive type.\n-pub enum ann_node<'a> {\n-    node_block(@ps, &'a ast::Block),\n-    node_item(@ps, &'a ast::item),\n-    node_expr(@ps, &'a ast::Expr),\n-    node_pat(@ps, &'a ast::Pat),\n+// The &mut ps is stored here to prevent recursive type.\n+pub enum ann_node<'a,'b> {\n+    node_block(&'b mut ps, &'a ast::Block),\n+    node_item(&'b mut ps, &'a ast::item),\n+    node_expr(&'b mut ps, &'a ast::Expr),\n+    node_pat(&'b mut ps, &'a ast::Pat),\n }\n \n pub trait pp_ann {\n@@ -66,7 +66,7 @@ pub struct CurrentCommentAndLiteral {\n }\n \n pub struct ps {\n-    s: @mut pp::Printer,\n+    s: pp::Printer,\n     cm: Option<@CodeMap>,\n     intr: @token::ident_interner,\n     comments: Option<~[comments::cmnt]>,\n@@ -76,25 +76,25 @@ pub struct ps {\n     ann: @pp_ann\n }\n \n-pub fn ibox(s: @ps, u: uint) {\n+pub fn ibox(s: &mut ps, u: uint) {\n     s.boxes.push(pp::inconsistent);\n-    pp::ibox(s.s, u);\n+    pp::ibox(&mut s.s, u);\n }\n \n-pub fn end(s: @ps) {\n+pub fn end(s: &mut ps) {\n     s.boxes.pop();\n-    pp::end(s.s);\n+    pp::end(&mut s.s);\n }\n \n-pub fn rust_printer(writer: @mut io::Writer, intr: @ident_interner) -> @ps {\n+pub fn rust_printer(writer: @mut io::Writer, intr: @ident_interner) -> ps {\n     return rust_printer_annotated(writer, intr, @no_ann::new() as @pp_ann);\n }\n \n pub fn rust_printer_annotated(writer: @mut io::Writer,\n                               intr: @ident_interner,\n                               ann: @pp_ann)\n-                              -> @ps {\n-    return @ps {\n+                              -> ps {\n+    return ps {\n         s: pp::mk_printer(writer, default_columns),\n         cm: None::<@CodeMap>,\n         intr: intr,\n@@ -130,7 +130,7 @@ pub fn print_crate(cm: @CodeMap,\n         filename,\n         input\n     );\n-    let s = @ps {\n+    let mut s = ps {\n         s: pp::mk_printer(out, default_columns),\n         cm: Some(cm),\n         intr: intr,\n@@ -150,13 +150,13 @@ pub fn print_crate(cm: @CodeMap,\n         boxes: @mut ~[],\n         ann: ann\n     };\n-    print_crate_(s, crate);\n+    print_crate_(&mut s, crate);\n }\n \n-pub fn print_crate_(s: @ps, crate: &ast::Crate) {\n+pub fn print_crate_(s: &mut ps, crate: &ast::Crate) {\n     print_mod(s, &crate.module, crate.attrs);\n     print_remaining_comments(s);\n-    eof(s.s);\n+    eof(&mut s.s);\n }\n \n pub fn ty_to_str(ty: &ast::Ty, intr: @ident_interner) -> ~str {\n@@ -204,24 +204,24 @@ pub fn fun_to_str(decl: &ast::fn_decl, purity: ast::purity, name: ast::Ident,\n                   opt_explicit_self: Option<ast::explicit_self_>,\n                   generics: &ast::Generics, intr: @ident_interner) -> ~str {\n     let wr = @mut MemWriter::new();\n-    let s = rust_printer(wr as @mut io::Writer, intr);\n-    print_fn(s, decl, Some(purity), AbiSet::Rust(),\n+    let mut s = rust_printer(wr as @mut io::Writer, intr);\n+    print_fn(&mut s, decl, Some(purity), AbiSet::Rust(),\n              name, generics, opt_explicit_self, ast::inherited);\n-    end(s); // Close the head box\n-    end(s); // Close the outer box\n-    eof(s.s);\n+    end(&mut s); // Close the head box\n+    end(&mut s); // Close the outer box\n+    eof(&mut s.s);\n     str::from_utf8_owned(wr.inner_ref().to_owned())\n }\n \n pub fn block_to_str(blk: &ast::Block, intr: @ident_interner) -> ~str {\n     let wr = @mut MemWriter::new();\n-    let s = rust_printer(wr as @mut io::Writer, intr);\n+    let mut s = rust_printer(wr as @mut io::Writer, intr);\n     // containing cbox, will be closed by print-block at }\n-    cbox(s, indent_unit);\n+    cbox(&mut s, indent_unit);\n     // head-ibox, will be closed by print-block after {\n-    ibox(s, 0u);\n-    print_block(s, blk);\n-    eof(s.s);\n+    ibox(&mut s, 0u);\n+    print_block(&mut s, blk);\n+    eof(&mut s.s);\n     str::from_utf8_owned(wr.inner_ref().to_owned())\n }\n \n@@ -237,28 +237,28 @@ pub fn variant_to_str(var: &ast::variant, intr: @ident_interner) -> ~str {\n     to_str(var, print_variant, intr)\n }\n \n-pub fn cbox(s: @ps, u: uint) {\n+pub fn cbox(s: &mut ps, u: uint) {\n     s.boxes.push(pp::consistent);\n-    pp::cbox(s.s, u);\n+    pp::cbox(&mut s.s, u);\n }\n \n // \"raw box\"\n-pub fn rbox(s: @ps, u: uint, b: pp::breaks) {\n+pub fn rbox(s: &mut ps, u: uint, b: pp::breaks) {\n     s.boxes.push(b);\n-    pp::rbox(s.s, u, b);\n+    pp::rbox(&mut s.s, u, b);\n }\n \n-pub fn nbsp(s: @ps) { word(s.s, \" \"); }\n+pub fn nbsp(s: &mut ps) { word(&mut s.s, \" \"); }\n \n-pub fn word_nbsp(s: @ps, w: &str) { word(s.s, w); nbsp(s); }\n+pub fn word_nbsp(s: &mut ps, w: &str) { word(&mut s.s, w); nbsp(s); }\n \n-pub fn word_space(s: @ps, w: &str) { word(s.s, w); space(s.s); }\n+pub fn word_space(s: &mut ps, w: &str) { word(&mut s.s, w); space(&mut s.s); }\n \n-pub fn popen(s: @ps) { word(s.s, \"(\"); }\n+pub fn popen(s: &mut ps) { word(&mut s.s, \"(\"); }\n \n-pub fn pclose(s: @ps) { word(s.s, \")\"); }\n+pub fn pclose(s: &mut ps) { word(&mut s.s, \")\"); }\n \n-pub fn head(s: @ps, w: &str) {\n+pub fn head(s: &mut ps, w: &str) {\n     // outer-box is consistent\n     cbox(s, indent_unit);\n     // head-box is inconsistent\n@@ -269,49 +269,53 @@ pub fn head(s: @ps, w: &str) {\n     }\n }\n \n-pub fn bopen(s: @ps) {\n-    word(s.s, \"{\");\n+pub fn bopen(s: &mut ps) {\n+    word(&mut s.s, \"{\");\n     end(s); // close the head-box\n }\n \n-pub fn bclose_(s: @ps, span: codemap::Span, indented: uint) {\n+pub fn bclose_(s: &mut ps, span: codemap::Span, indented: uint) {\n     bclose_maybe_open(s, span, indented, true);\n }\n-pub fn bclose_maybe_open (s: @ps, span: codemap::Span, indented: uint,\n+pub fn bclose_maybe_open (s: &mut ps, span: codemap::Span, indented: uint,\n                           close_box: bool) {\n     maybe_print_comment(s, span.hi);\n     break_offset_if_not_bol(s, 1u, -(indented as int));\n-    word(s.s, \"}\");\n+    word(&mut s.s, \"}\");\n     if close_box {\n         end(s); // close the outer-box\n     }\n }\n-pub fn bclose(s: @ps, span: codemap::Span) { bclose_(s, span, indent_unit); }\n+pub fn bclose(s: &mut ps, span: codemap::Span) { bclose_(s, span, indent_unit); }\n \n-pub fn is_begin(s: @ps) -> bool {\n+pub fn is_begin(s: &mut ps) -> bool {\n     match s.s.last_token() { pp::BEGIN(_) => true, _ => false }\n }\n \n-pub fn is_end(s: @ps) -> bool {\n+pub fn is_end(s: &mut ps) -> bool {\n     match s.s.last_token() { pp::END => true, _ => false }\n }\n \n-pub fn is_bol(s: @ps) -> bool {\n+pub fn is_bol(s: &mut ps) -> bool {\n     return s.s.last_token().is_eof() || s.s.last_token().is_hardbreak_tok();\n }\n \n-pub fn in_cbox(s: @ps) -> bool {\n+pub fn in_cbox(s: &mut ps) -> bool {\n     let boxes = &*s.boxes;\n     let len = boxes.len();\n     if len == 0u { return false; }\n     return boxes[len - 1u] == pp::consistent;\n }\n \n-pub fn hardbreak_if_not_bol(s: @ps) { if !is_bol(s) { hardbreak(s.s); } }\n-pub fn space_if_not_bol(s: @ps) { if !is_bol(s) { space(s.s); } }\n-pub fn break_offset_if_not_bol(s: @ps, n: uint, off: int) {\n+pub fn hardbreak_if_not_bol(s: &mut ps) {\n     if !is_bol(s) {\n-        break_offset(s.s, n, off);\n+        hardbreak(&mut s.s)\n+    }\n+}\n+pub fn space_if_not_bol(s: &mut ps) { if !is_bol(s) { space(&mut s.s); } }\n+pub fn break_offset_if_not_bol(s: &mut ps, n: uint, off: int) {\n+    if !is_bol(s) {\n+        break_offset(&mut s.s, n, off);\n     } else {\n         if off != 0 && s.s.last_token().is_hardbreak_tok() {\n             // We do something pretty sketchy here: tuck the nonzero\n@@ -324,15 +328,15 @@ pub fn break_offset_if_not_bol(s: @ps, n: uint, off: int) {\n \n // Synthesizes a comment that was not textually present in the original source\n // file.\n-pub fn synth_comment(s: @ps, text: ~str) {\n-    word(s.s, \"/*\");\n-    space(s.s);\n-    word(s.s, text);\n-    space(s.s);\n-    word(s.s, \"*/\");\n+pub fn synth_comment(s: &mut ps, text: ~str) {\n+    word(&mut s.s, \"/*\");\n+    space(&mut s.s);\n+    word(&mut s.s, text);\n+    space(&mut s.s);\n+    word(&mut s.s, \"*/\");\n }\n \n-pub fn commasep<T>(s: @ps, b: breaks, elts: &[T], op: |@ps, &T|) {\n+pub fn commasep<T>(s: &mut ps, b: breaks, elts: &[T], op: |&mut ps, &T|) {\n     rbox(s, 0u, b);\n     let mut first = true;\n     for elt in elts.iter() {\n@@ -344,10 +348,10 @@ pub fn commasep<T>(s: @ps, b: breaks, elts: &[T], op: |@ps, &T|) {\n \n \n pub fn commasep_cmnt<T>(\n-                     s: @ps,\n+                     s: &mut ps,\n                      b: breaks,\n                      elts: &[T],\n-                     op: |@ps, &T|,\n+                     op: |&mut ps, &T|,\n                      get_span: |&T| -> codemap::Span) {\n     rbox(s, 0u, b);\n     let len = elts.len();\n@@ -357,7 +361,7 @@ pub fn commasep_cmnt<T>(\n         op(s, elt);\n         i += 1u;\n         if i < len {\n-            word(s.s, \",\");\n+            word(&mut s.s, \",\");\n             maybe_print_trailing_comment(s, get_span(elt),\n                                          Some(get_span(&elts[i]).hi));\n             space_if_not_bol(s);\n@@ -366,19 +370,19 @@ pub fn commasep_cmnt<T>(\n     end(s);\n }\n \n-pub fn commasep_exprs(s: @ps, b: breaks, exprs: &[@ast::Expr]) {\n+pub fn commasep_exprs(s: &mut ps, b: breaks, exprs: &[@ast::Expr]) {\n     commasep_cmnt(s, b, exprs, |p, &e| print_expr(p, e), |e| e.span);\n }\n \n-pub fn print_mod(s: @ps, _mod: &ast::_mod, attrs: &[ast::Attribute]) {\n+pub fn print_mod(s: &mut ps, _mod: &ast::_mod, attrs: &[ast::Attribute]) {\n     print_inner_attributes(s, attrs);\n     for vitem in _mod.view_items.iter() {\n         print_view_item(s, vitem);\n     }\n     for item in _mod.items.iter() { print_item(s, *item); }\n }\n \n-pub fn print_foreign_mod(s: @ps, nmod: &ast::foreign_mod,\n+pub fn print_foreign_mod(s: &mut ps, nmod: &ast::foreign_mod,\n                          attrs: &[ast::Attribute]) {\n     print_inner_attributes(s, attrs);\n     for vitem in nmod.view_items.iter() {\n@@ -387,37 +391,37 @@ pub fn print_foreign_mod(s: @ps, nmod: &ast::foreign_mod,\n     for item in nmod.items.iter() { print_foreign_item(s, *item); }\n }\n \n-pub fn print_opt_lifetime(s: @ps, lifetime: &Option<ast::Lifetime>) {\n+pub fn print_opt_lifetime(s: &mut ps, lifetime: &Option<ast::Lifetime>) {\n     for l in lifetime.iter() {\n         print_lifetime(s, l);\n         nbsp(s);\n     }\n }\n \n-pub fn print_type(s: @ps, ty: &ast::Ty) {\n+pub fn print_type(s: &mut ps, ty: &ast::Ty) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n     match ty.node {\n-      ast::ty_nil => word(s.s, \"()\"),\n-      ast::ty_bot => word(s.s, \"!\"),\n-      ast::ty_box(ref mt) => { word(s.s, \"@\"); print_mt(s, mt); }\n-      ast::ty_uniq(ty) => { word(s.s, \"~\"); print_type(s, ty); }\n+      ast::ty_nil => word(&mut s.s, \"()\"),\n+      ast::ty_bot => word(&mut s.s, \"!\"),\n+      ast::ty_box(ref mt) => { word(&mut s.s, \"@\"); print_mt(s, mt); }\n+      ast::ty_uniq(ty) => { word(&mut s.s, \"~\"); print_type(s, ty); }\n       ast::ty_vec(ty) => {\n-        word(s.s, \"[\");\n+        word(&mut s.s, \"[\");\n         print_type(s, ty);\n-        word(s.s, \"]\");\n+        word(&mut s.s, \"]\");\n       }\n-      ast::ty_ptr(ref mt) => { word(s.s, \"*\"); print_mt(s, mt); }\n+      ast::ty_ptr(ref mt) => { word(&mut s.s, \"*\"); print_mt(s, mt); }\n       ast::ty_rptr(ref lifetime, ref mt) => {\n-          word(s.s, \"&\");\n+          word(&mut s.s, \"&\");\n           print_opt_lifetime(s, lifetime);\n           print_mt(s, mt);\n       }\n       ast::ty_tup(ref elts) => {\n         popen(s);\n         commasep(s, inconsistent, *elts, print_type_ref);\n         if elts.len() == 1 {\n-            word(s.s, \",\");\n+            word(&mut s.s, \",\");\n         }\n         pclose(s);\n       }\n@@ -441,16 +445,16 @@ pub fn print_type(s: @ps, ty: &ast::Ty) {\n       }\n       ast::ty_path(ref path, ref bounds, _) => print_bounded_path(s, path, bounds),\n       ast::ty_fixed_length_vec(ty, v) => {\n-        word(s.s, \"[\");\n+        word(&mut s.s, \"[\");\n         print_type(s, ty);\n-        word(s.s, \", ..\");\n+        word(&mut s.s, \", ..\");\n         print_expr(s, v);\n-        word(s.s, \"]\");\n+        word(&mut s.s, \"]\");\n       }\n       ast::ty_typeof(e) => {\n-          word(s.s, \"typeof(\");\n+          word(&mut s.s, \"typeof(\");\n           print_expr(s, e);\n-          word(s.s, \")\");\n+          word(&mut s.s, \")\");\n       }\n       ast::ty_infer => {\n           fail!(\"print_type shouldn't see a ty_infer\");\n@@ -460,11 +464,11 @@ pub fn print_type(s: @ps, ty: &ast::Ty) {\n     end(s);\n }\n \n-pub fn print_type_ref(s: @ps, ty: &P<ast::Ty>) {\n+pub fn print_type_ref(s: &mut ps, ty: &P<ast::Ty>) {\n     print_type(s, *ty);\n }\n \n-pub fn print_foreign_item(s: @ps, item: &ast::foreign_item) {\n+pub fn print_foreign_item(s: &mut ps, item: &ast::foreign_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -473,7 +477,7 @@ pub fn print_foreign_item(s: @ps, item: &ast::foreign_item) {\n         print_fn(s, decl, None, AbiSet::Rust(), item.ident, generics, None,\n                  item.vis);\n         end(s); // end head-ibox\n-        word(s.s, \";\");\n+        word(&mut s.s, \";\");\n         end(s); // end the outer fn box\n       }\n       ast::foreign_item_static(t, m) => {\n@@ -484,19 +488,21 @@ pub fn print_foreign_item(s: @ps, item: &ast::foreign_item) {\n         print_ident(s, item.ident);\n         word_space(s, \":\");\n         print_type(s, t);\n-        word(s.s, \";\");\n+        word(&mut s.s, \";\");\n         end(s); // end the head-ibox\n         end(s); // end the outer cbox\n       }\n     }\n }\n \n-pub fn print_item(s: @ps, item: &ast::item) {\n+pub fn print_item(s: &mut ps, item: &ast::item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n-    let ann_node = node_item(s, item);\n-    s.ann.pre(ann_node);\n+    {\n+        let ann_node = node_item(s, item);\n+        s.ann.pre(ann_node);\n+    }\n     match item.node {\n       ast::item_static(ty, m, expr) => {\n         head(s, visibility_qualified(item.vis, \"static\"));\n@@ -506,12 +512,12 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         print_ident(s, item.ident);\n         word_space(s, \":\");\n         print_type(s, ty);\n-        space(s.s);\n+        space(&mut s.s);\n         end(s); // end the head-ibox\n \n         word_space(s, \"=\");\n         print_expr(s, expr);\n-        word(s.s, \";\");\n+        word(&mut s.s, \";\");\n         end(s); // end the outer cbox\n \n       }\n@@ -526,7 +532,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n             None,\n             item.vis\n         );\n-        word(s.s, \" \");\n+        word(&mut s.s, \" \");\n         print_block_with_attrs(s, body, item.attrs);\n       }\n       ast::item_mod(ref _mod) => {\n@@ -552,10 +558,10 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         print_generics(s, params);\n         end(s); // end the inner ibox\n \n-        space(s.s);\n+        space(&mut s.s);\n         word_space(s, \"=\");\n         print_type(s, ty);\n-        word(s.s, \";\");\n+        word(&mut s.s, \";\");\n         end(s); // end the outer ibox\n       }\n       ast::item_enum(ref enum_definition, ref params) => {\n@@ -577,21 +583,21 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         head(s, visibility_qualified(item.vis, \"impl\"));\n         if generics.is_parameterized() {\n             print_generics(s, generics);\n-            space(s.s);\n+            space(&mut s.s);\n         }\n \n         match opt_trait {\n             &Some(ref t) => {\n                 print_trait_ref(s, t);\n-                space(s.s);\n+                space(&mut s.s);\n                 word_space(s, \"for\");\n             }\n             &None => ()\n         };\n \n         print_type(s, ty);\n \n-        space(s.s);\n+        space(&mut s.s);\n         bopen(s);\n         print_inner_attributes(s, item.attrs);\n         for meth in methods.iter() {\n@@ -604,7 +610,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         print_ident(s, item.ident);\n         print_generics(s, generics);\n         if traits.len() != 0u {\n-            word(s.s, \":\");\n+            word(&mut s.s, \":\");\n             for (i, trait_) in traits.iter().enumerate() {\n                 nbsp(s);\n                 if i != 0 {\n@@ -613,7 +619,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n                 print_path(s, &trait_.path, false);\n             }\n         }\n-        word(s.s, \" \");\n+        word(&mut s.s, \" \");\n         bopen(s);\n         for meth in methods.iter() {\n             print_trait_method(s, meth);\n@@ -625,7 +631,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n                                    ..}) => {\n         print_visibility(s, item.vis);\n         print_path(s, pth, false);\n-        word(s.s, \"! \");\n+        word(&mut s.s, \"! \");\n         print_ident(s, item.ident);\n         cbox(s, indent_unit);\n         popen(s);\n@@ -634,24 +640,27 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         end(s);\n       }\n     }\n-    s.ann.post(ann_node);\n+    {\n+        let ann_node = node_item(s, item);\n+        s.ann.post(ann_node);\n+    }\n }\n \n-fn print_trait_ref(s: @ps, t: &ast::trait_ref) {\n+fn print_trait_ref(s: &mut ps, t: &ast::trait_ref) {\n     print_path(s, &t.path, false);\n }\n \n-pub fn print_enum_def(s: @ps, enum_definition: &ast::enum_def,\n+pub fn print_enum_def(s: &mut ps, enum_definition: &ast::enum_def,\n                       generics: &ast::Generics, ident: ast::Ident,\n                       span: codemap::Span, visibility: ast::visibility) {\n     head(s, visibility_qualified(visibility, \"enum\"));\n     print_ident(s, ident);\n     print_generics(s, generics);\n-    space(s.s);\n+    space(&mut s.s);\n     print_variants(s, enum_definition.variants, span);\n }\n \n-pub fn print_variants(s: @ps,\n+pub fn print_variants(s: &mut ps,\n                       variants: &[P<ast::variant>],\n                       span: codemap::Span) {\n     bopen(s);\n@@ -661,7 +670,7 @@ pub fn print_variants(s: @ps,\n         print_outer_attributes(s, v.node.attrs);\n         ibox(s, indent_unit);\n         print_variant(s, v);\n-        word(s.s, \",\");\n+        word(&mut s.s, \",\");\n         end(s);\n         maybe_print_trailing_comment(s, v.span, None);\n     }\n@@ -683,15 +692,15 @@ pub fn visibility_qualified(vis: ast::visibility, s: &str) -> ~str {\n     }\n }\n \n-pub fn print_visibility(s: @ps, vis: ast::visibility) {\n+pub fn print_visibility(s: &mut ps, vis: ast::visibility) {\n     match vis {\n         ast::private | ast::public =>\n         word_nbsp(s, visibility_to_str(vis)),\n         ast::inherited => ()\n     }\n }\n \n-pub fn print_struct(s: @ps,\n+pub fn print_struct(s: &mut ps,\n                     struct_def: &ast::struct_def,\n                     generics: &ast::Generics,\n                     ident: ast::Ident,\n@@ -712,7 +721,7 @@ pub fn print_struct(s: @ps,\n             });\n             pclose(s);\n         }\n-        word(s.s, \";\");\n+        word(&mut s.s, \";\");\n         end(s);\n         end(s); // close the outer-box\n     } else {\n@@ -731,7 +740,7 @@ pub fn print_struct(s: @ps,\n                     print_ident(s, ident);\n                     word_nbsp(s, \":\");\n                     print_type(s, field.node.ty);\n-                    word(s.s, \",\");\n+                    word(&mut s.s, \",\");\n                 }\n             }\n         }\n@@ -747,48 +756,48 @@ pub fn print_struct(s: @ps,\n /// appropriate macro, transcribe back into the grammar we just parsed from,\n /// and then pretty-print the resulting AST nodes (so, e.g., we print\n /// expression arguments as expressions). It can be done! I think.\n-pub fn print_tt(s: @ps, tt: &ast::token_tree) {\n+pub fn print_tt(s: &mut ps, tt: &ast::token_tree) {\n     match *tt {\n       ast::tt_delim(ref tts) => print_tts(s, &(tts.as_slice())),\n       ast::tt_tok(_, ref tk) => {\n-          word(s.s, parse::token::to_str(s.intr, tk));\n+          word(&mut s.s, parse::token::to_str(s.intr, tk));\n       }\n       ast::tt_seq(_, ref tts, ref sep, zerok) => {\n-        word(s.s, \"$(\");\n+        word(&mut s.s, \"$(\");\n         for tt_elt in (*tts).iter() { print_tt(s, tt_elt); }\n-        word(s.s, \")\");\n+        word(&mut s.s, \")\");\n         match (*sep) {\n-          Some(ref tk) => word(s.s, parse::token::to_str(s.intr, tk)),\n+          Some(ref tk) => word(&mut s.s, parse::token::to_str(s.intr, tk)),\n           None => ()\n         }\n-        word(s.s, if zerok { \"*\" } else { \"+\" });\n+        word(&mut s.s, if zerok { \"*\" } else { \"+\" });\n       }\n       ast::tt_nonterminal(_, name) => {\n-        word(s.s, \"$\");\n+        word(&mut s.s, \"$\");\n         print_ident(s, name);\n       }\n     }\n }\n \n-pub fn print_tts(s: @ps, tts: & &[ast::token_tree]) {\n+pub fn print_tts(s: &mut ps, tts: & &[ast::token_tree]) {\n     ibox(s, 0);\n     for (i, tt) in tts.iter().enumerate() {\n         if i != 0 {\n-            space(s.s);\n+            space(&mut s.s);\n         }\n         print_tt(s, tt);\n     }\n     end(s);\n }\n \n-pub fn print_variant(s: @ps, v: &ast::variant) {\n+pub fn print_variant(s: &mut ps, v: &ast::variant) {\n     print_visibility(s, v.node.vis);\n     match v.node.kind {\n         ast::tuple_variant_kind(ref args) => {\n             print_ident(s, v.node.name);\n             if !args.is_empty() {\n                 popen(s);\n-                fn print_variant_arg(s: @ps, arg: &ast::variant_arg) {\n+                fn print_variant_arg(s: &mut ps, arg: &ast::variant_arg) {\n                     print_type(s, arg.ty);\n                 }\n                 commasep(s, consistent, *args, print_variant_arg);\n@@ -803,15 +812,15 @@ pub fn print_variant(s: @ps, v: &ast::variant) {\n     }\n     match v.node.disr_expr {\n       Some(d) => {\n-        space(s.s);\n+        space(&mut s.s);\n         word_space(s, \"=\");\n         print_expr(s, d);\n       }\n       _ => ()\n     }\n }\n \n-pub fn print_ty_method(s: @ps, m: &ast::TypeMethod) {\n+pub fn print_ty_method(s: &mut ps, m: &ast::TypeMethod) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n@@ -826,28 +835,28 @@ pub fn print_ty_method(s: @ps, m: &ast::TypeMethod) {\n                 &None,\n                 Some(&m.generics),\n                 Some(m.explicit_self.node));\n-    word(s.s, \";\");\n+    word(&mut s.s, \";\");\n }\n \n-pub fn print_trait_method(s: @ps, m: &ast::trait_method) {\n+pub fn print_trait_method(s: &mut ps, m: &ast::trait_method) {\n     match *m {\n         required(ref ty_m) => print_ty_method(s, ty_m),\n         provided(m) => print_method(s, m)\n     }\n }\n \n-pub fn print_method(s: @ps, meth: &ast::method) {\n+pub fn print_method(s: &mut ps, meth: &ast::method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, meth.span.lo);\n     print_outer_attributes(s, meth.attrs);\n     print_fn(s, meth.decl, Some(meth.purity), AbiSet::Rust(),\n              meth.ident, &meth.generics, Some(meth.explicit_self.node),\n              meth.vis);\n-    word(s.s, \" \");\n+    word(&mut s.s, \" \");\n     print_block_with_attrs(s, meth.body, meth.attrs);\n }\n \n-pub fn print_outer_attributes(s: @ps, attrs: &[ast::Attribute]) {\n+pub fn print_outer_attributes(s: &mut ps, attrs: &[ast::Attribute]) {\n     let mut count = 0;\n     for attr in attrs.iter() {\n         match attr.node.style {\n@@ -858,14 +867,14 @@ pub fn print_outer_attributes(s: @ps, attrs: &[ast::Attribute]) {\n     if count > 0 { hardbreak_if_not_bol(s); }\n }\n \n-pub fn print_inner_attributes(s: @ps, attrs: &[ast::Attribute]) {\n+pub fn print_inner_attributes(s: &mut ps, attrs: &[ast::Attribute]) {\n     let mut count = 0;\n     for attr in attrs.iter() {\n         match attr.node.style {\n           ast::AttrInner => {\n             print_attribute(s, attr);\n             if !attr.node.is_sugared_doc {\n-                word(s.s, \";\");\n+                word(&mut s.s, \";\");\n             }\n             count += 1;\n           }\n@@ -875,21 +884,21 @@ pub fn print_inner_attributes(s: @ps, attrs: &[ast::Attribute]) {\n     if count > 0 { hardbreak_if_not_bol(s); }\n }\n \n-pub fn print_attribute(s: @ps, attr: &ast::Attribute) {\n+pub fn print_attribute(s: &mut ps, attr: &ast::Attribute) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, attr.span.lo);\n     if attr.node.is_sugared_doc {\n         let comment = attr.value_str().unwrap();\n-        word(s.s, comment);\n+        word(&mut s.s, comment);\n     } else {\n-        word(s.s, \"#[\");\n+        word(&mut s.s, \"#[\");\n         print_meta_item(s, attr.meta());\n-        word(s.s, \"]\");\n+        word(&mut s.s, \"]\");\n     }\n }\n \n \n-pub fn print_stmt(s: @ps, st: &ast::Stmt) {\n+pub fn print_stmt(s: &mut ps, st: &ast::Stmt) {\n     maybe_print_comment(s, st.span.lo);\n     match st.node {\n       ast::StmtDecl(decl, _) => {\n@@ -902,33 +911,33 @@ pub fn print_stmt(s: @ps, st: &ast::Stmt) {\n       ast::StmtSemi(expr, _) => {\n         space_if_not_bol(s);\n         print_expr(s, expr);\n-        word(s.s, \";\");\n+        word(&mut s.s, \";\");\n       }\n       ast::StmtMac(ref mac, semi) => {\n         space_if_not_bol(s);\n         print_mac(s, mac);\n-        if semi { word(s.s, \";\"); }\n+        if semi { word(&mut s.s, \";\"); }\n       }\n     }\n-    if parse::classify::stmt_ends_with_semi(st) { word(s.s, \";\"); }\n+    if parse::classify::stmt_ends_with_semi(st) { word(&mut s.s, \";\"); }\n     maybe_print_trailing_comment(s, st.span, None);\n }\n \n-pub fn print_block(s: @ps, blk: &ast::Block) {\n+pub fn print_block(s: &mut ps, blk: &ast::Block) {\n     print_possibly_embedded_block(s, blk, block_normal, indent_unit);\n }\n \n-pub fn print_block_unclosed(s: @ps, blk: &ast::Block) {\n+pub fn print_block_unclosed(s: &mut ps, blk: &ast::Block) {\n     print_possibly_embedded_block_(s, blk, block_normal, indent_unit, &[],\n                                  false);\n }\n \n-pub fn print_block_unclosed_indent(s: @ps, blk: &ast::Block, indented: uint) {\n+pub fn print_block_unclosed_indent(s: &mut ps, blk: &ast::Block, indented: uint) {\n     print_possibly_embedded_block_(s, blk, block_normal, indented, &[],\n                                    false);\n }\n \n-pub fn print_block_with_attrs(s: @ps,\n+pub fn print_block_with_attrs(s: &mut ps,\n                               blk: &ast::Block,\n                               attrs: &[ast::Attribute]) {\n     print_possibly_embedded_block_(s, blk, block_normal, indent_unit, attrs,\n@@ -937,15 +946,15 @@ pub fn print_block_with_attrs(s: @ps,\n \n pub enum embed_type { block_block_fn, block_normal, }\n \n-pub fn print_possibly_embedded_block(s: @ps,\n+pub fn print_possibly_embedded_block(s: &mut ps,\n                                      blk: &ast::Block,\n                                      embedded: embed_type,\n                                      indented: uint) {\n     print_possibly_embedded_block_(\n         s, blk, embedded, indented, &[], true);\n }\n \n-pub fn print_possibly_embedded_block_(s: @ps,\n+pub fn print_possibly_embedded_block_(s: &mut ps,\n                                       blk: &ast::Block,\n                                       embedded: embed_type,\n                                       indented: uint,\n@@ -956,8 +965,10 @@ pub fn print_possibly_embedded_block_(s: @ps,\n       ast::DefaultBlock => ()\n     }\n     maybe_print_comment(s, blk.span.lo);\n-    let ann_node = node_block(s, blk);\n-    s.ann.pre(ann_node);\n+    {\n+        let ann_node = node_block(s, blk);\n+        s.ann.pre(ann_node);\n+    }\n     match embedded {\n       block_block_fn => end(s),\n       block_normal => bopen(s)\n@@ -978,35 +989,38 @@ pub fn print_possibly_embedded_block_(s: @ps,\n       _ => ()\n     }\n     bclose_maybe_open(s, blk.span, indented, close_box);\n-    s.ann.post(ann_node);\n+    {\n+        let ann_node = node_block(s, blk);\n+        s.ann.post(ann_node);\n+    }\n }\n \n-pub fn print_if(s: @ps, test: &ast::Expr, blk: &ast::Block,\n+pub fn print_if(s: &mut ps, test: &ast::Expr, blk: &ast::Block,\n                 elseopt: Option<@ast::Expr>, chk: bool) {\n     head(s, \"if\");\n     if chk { word_nbsp(s, \"check\"); }\n     print_expr(s, test);\n-    space(s.s);\n+    space(&mut s.s);\n     print_block(s, blk);\n-    fn do_else(s: @ps, els: Option<@ast::Expr>) {\n+    fn do_else(s: &mut ps, els: Option<@ast::Expr>) {\n         match els {\n           Some(_else) => {\n             match _else.node {\n               // \"another else-if\"\n               ast::ExprIf(i, t, e) => {\n                 cbox(s, indent_unit - 1u);\n                 ibox(s, 0u);\n-                word(s.s, \" else if \");\n+                word(&mut s.s, \" else if \");\n                 print_expr(s, i);\n-                space(s.s);\n+                space(&mut s.s);\n                 print_block(s, t);\n                 do_else(s, e);\n               }\n               // \"final else\"\n               ast::ExprBlock(b) => {\n                 cbox(s, indent_unit - 1u);\n                 ibox(s, 0u);\n-                word(s.s, \" else \");\n+                word(&mut s.s, \" else \");\n                 print_block(s, b);\n               }\n               // BLEAH, constraints would be great here\n@@ -1021,49 +1035,49 @@ pub fn print_if(s: @ps, test: &ast::Expr, blk: &ast::Block,\n     do_else(s, elseopt);\n }\n \n-pub fn print_mac(s: @ps, m: &ast::mac) {\n+pub fn print_mac(s: &mut ps, m: &ast::mac) {\n     match m.node {\n       // I think it's reasonable to hide the ctxt here:\n       ast::mac_invoc_tt(ref pth, ref tts, _) => {\n         print_path(s, pth, false);\n-        word(s.s, \"!\");\n+        word(&mut s.s, \"!\");\n         popen(s);\n         print_tts(s, &tts.as_slice());\n         pclose(s);\n       }\n     }\n }\n \n-pub fn print_vstore(s: @ps, t: ast::Vstore) {\n+pub fn print_vstore(s: &mut ps, t: ast::Vstore) {\n     match t {\n-        ast::VstoreFixed(Some(i)) => word(s.s, format!(\"{}\", i)),\n-        ast::VstoreFixed(None) => word(s.s, \"_\"),\n-        ast::VstoreUniq => word(s.s, \"~\"),\n-        ast::VstoreBox => word(s.s, \"@\"),\n+        ast::VstoreFixed(Some(i)) => word(&mut s.s, format!(\"{}\", i)),\n+        ast::VstoreFixed(None) => word(&mut s.s, \"_\"),\n+        ast::VstoreUniq => word(&mut s.s, \"~\"),\n+        ast::VstoreBox => word(&mut s.s, \"@\"),\n         ast::VstoreSlice(ref r) => {\n-            word(s.s, \"&\");\n+            word(&mut s.s, \"&\");\n             print_opt_lifetime(s, r);\n         }\n     }\n }\n \n-pub fn print_expr_vstore(s: @ps, t: ast::ExprVstore) {\n+pub fn print_expr_vstore(s: &mut ps, t: ast::ExprVstore) {\n     match t {\n-      ast::ExprVstoreUniq => word(s.s, \"~\"),\n-      ast::ExprVstoreBox => word(s.s, \"@\"),\n+      ast::ExprVstoreUniq => word(&mut s.s, \"~\"),\n+      ast::ExprVstoreBox => word(&mut s.s, \"@\"),\n       ast::ExprVstoreMutBox => {\n-        word(s.s, \"@\");\n-        word(s.s, \"mut\");\n+        word(&mut s.s, \"@\");\n+        word(&mut s.s, \"mut\");\n       }\n-      ast::ExprVstoreSlice => word(s.s, \"&\"),\n+      ast::ExprVstoreSlice => word(&mut s.s, \"&\"),\n       ast::ExprVstoreMutSlice => {\n-        word(s.s, \"&\");\n-        word(s.s, \"mut\");\n+        word(&mut s.s, \"&\");\n+        word(&mut s.s, \"mut\");\n       }\n     }\n }\n \n-pub fn print_call_pre(s: @ps,\n+pub fn print_call_pre(s: &mut ps,\n                       sugar: ast::CallSugar,\n                       base_args: &mut ~[@ast::Expr])\n                    -> Option<@ast::Expr> {\n@@ -1080,7 +1094,7 @@ pub fn print_call_pre(s: @ps,\n     }\n }\n \n-pub fn print_call_post(s: @ps,\n+pub fn print_call_post(s: &mut ps,\n                        sugar: ast::CallSugar,\n                        blk: &Option<@ast::Expr>,\n                        base_args: &mut ~[@ast::Expr]) {\n@@ -1107,8 +1121,8 @@ pub fn print_call_post(s: @ps,\n     }\n }\n \n-pub fn print_expr(s: @ps, expr: &ast::Expr) {\n-    fn print_field(s: @ps, field: &ast::Field) {\n+pub fn print_expr(s: &mut ps, expr: &ast::Expr) {\n+    fn print_field(s: &mut ps, field: &ast::Field) {\n         ibox(s, indent_unit);\n         print_ident(s, field.ident.node);\n         word_space(s, \":\");\n@@ -1119,62 +1133,64 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n \n     maybe_print_comment(s, expr.span.lo);\n     ibox(s, indent_unit);\n-    let ann_node = node_expr(s, expr);\n-    s.ann.pre(ann_node);\n+    {\n+        let ann_node = node_expr(s, expr);\n+        s.ann.pre(ann_node);\n+    }\n     match expr.node {\n         ast::ExprVstore(e, v) => {\n             print_expr_vstore(s, v);\n             print_expr(s, e);\n         },\n       ast::ExprVec(ref exprs, mutbl) => {\n         ibox(s, indent_unit);\n-        word(s.s, \"[\");\n+        word(&mut s.s, \"[\");\n         if mutbl == ast::MutMutable {\n-            word(s.s, \"mut\");\n+            word(&mut s.s, \"mut\");\n             if exprs.len() > 0u { nbsp(s); }\n         }\n         commasep_exprs(s, inconsistent, *exprs);\n-        word(s.s, \"]\");\n+        word(&mut s.s, \"]\");\n         end(s);\n       }\n \n       ast::ExprRepeat(element, count, mutbl) => {\n         ibox(s, indent_unit);\n-        word(s.s, \"[\");\n+        word(&mut s.s, \"[\");\n         if mutbl == ast::MutMutable {\n-            word(s.s, \"mut\");\n+            word(&mut s.s, \"mut\");\n             nbsp(s);\n         }\n         print_expr(s, element);\n-        word(s.s, \",\");\n-        word(s.s, \"..\");\n+        word(&mut s.s, \",\");\n+        word(&mut s.s, \"..\");\n         print_expr(s, count);\n-        word(s.s, \"]\");\n+        word(&mut s.s, \"]\");\n         end(s);\n       }\n \n       ast::ExprStruct(ref path, ref fields, wth) => {\n         print_path(s, path, true);\n-        word(s.s, \"{\");\n+        word(&mut s.s, \"{\");\n         commasep_cmnt(s, consistent, (*fields), print_field, get_span);\n         match wth {\n             Some(expr) => {\n                 ibox(s, indent_unit);\n-                word(s.s, \",\");\n-                space(s.s);\n-                word(s.s, \"..\");\n+                word(&mut s.s, \",\");\n+                space(&mut s.s);\n+                word(&mut s.s, \"..\");\n                 print_expr(s, expr);\n                 end(s);\n             }\n-            _ => (word(s.s, \",\"))\n+            _ => (word(&mut s.s, \",\"))\n         }\n-        word(s.s, \"}\");\n+        word(&mut s.s, \"}\");\n       }\n       ast::ExprTup(ref exprs) => {\n         popen(s);\n         commasep_exprs(s, inconsistent, *exprs);\n         if exprs.len() == 1 {\n-            word(s.s, \",\");\n+            word(&mut s.s, \",\");\n         }\n         pclose(s);\n       }\n@@ -1188,39 +1204,39 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n         let mut base_args = (*args).clone();\n         let blk = print_call_pre(s, sugar, &mut base_args);\n         print_expr(s, func);\n-        word(s.s, \".\");\n+        word(&mut s.s, \".\");\n         print_ident(s, ident);\n         if tys.len() > 0u {\n-            word(s.s, \"::<\");\n+            word(&mut s.s, \"::<\");\n             commasep(s, inconsistent, *tys, print_type_ref);\n-            word(s.s, \">\");\n+            word(&mut s.s, \">\");\n         }\n         print_call_post(s, sugar, &blk, &mut base_args);\n       }\n       ast::ExprBinary(_, op, lhs, rhs) => {\n         print_expr(s, lhs);\n-        space(s.s);\n+        space(&mut s.s);\n         word_space(s, ast_util::binop_to_str(op));\n         print_expr(s, rhs);\n       }\n       ast::ExprUnary(_, op, expr) => {\n-        word(s.s, ast_util::unop_to_str(op));\n+        word(&mut s.s, ast_util::unop_to_str(op));\n         print_expr(s, expr);\n       }\n       ast::ExprAddrOf(m, expr) => {\n-        word(s.s, \"&\");\n+        word(&mut s.s, \"&\");\n         print_mutability(s, m);\n         // Avoid `& &e` => `&&e`.\n         match (m, &expr.node) {\n-            (ast::MutImmutable, &ast::ExprAddrOf(..)) => space(s.s),\n+            (ast::MutImmutable, &ast::ExprAddrOf(..)) => space(&mut s.s),\n             _ => { }\n         }\n         print_expr(s, expr);\n       }\n       ast::ExprLit(lit) => print_literal(s, lit),\n       ast::ExprCast(expr, ty) => {\n         print_expr(s, expr);\n-        space(s.s);\n+        space(&mut s.s);\n         word_space(s, \"as\");\n         print_type(s, ty);\n       }\n@@ -1230,58 +1246,58 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n       ast::ExprWhile(test, blk) => {\n         head(s, \"while\");\n         print_expr(s, test);\n-        space(s.s);\n+        space(&mut s.s);\n         print_block(s, blk);\n       }\n       ast::ExprForLoop(pat, iter, blk, opt_ident) => {\n         for ident in opt_ident.iter() {\n-            word(s.s, \"'\");\n+            word(&mut s.s, \"'\");\n             print_ident(s, *ident);\n             word_space(s, \":\");\n         }\n         head(s, \"for\");\n         print_pat(s, pat);\n-        space(s.s);\n+        space(&mut s.s);\n         word_space(s, \"in\");\n         print_expr(s, iter);\n-        space(s.s);\n+        space(&mut s.s);\n         print_block(s, blk);\n       }\n       ast::ExprLoop(blk, opt_ident) => {\n         for ident in opt_ident.iter() {\n-            word(s.s, \"'\");\n+            word(&mut s.s, \"'\");\n             print_ident(s, *ident);\n             word_space(s, \":\");\n         }\n         head(s, \"loop\");\n-        space(s.s);\n+        space(&mut s.s);\n         print_block(s, blk);\n       }\n       ast::ExprMatch(expr, ref arms) => {\n         cbox(s, indent_unit);\n         ibox(s, 4);\n         word_nbsp(s, \"match\");\n         print_expr(s, expr);\n-        space(s.s);\n+        space(&mut s.s);\n         bopen(s);\n         let len = arms.len();\n         for (i, arm) in arms.iter().enumerate() {\n-            space(s.s);\n+            space(&mut s.s);\n             cbox(s, indent_unit);\n             ibox(s, 0u);\n             let mut first = true;\n             for p in arm.pats.iter() {\n                 if first {\n                     first = false;\n-                } else { space(s.s); word_space(s, \"|\"); }\n+                } else { space(&mut s.s); word_space(s, \"|\"); }\n                 print_pat(s, *p);\n             }\n-            space(s.s);\n+            space(&mut s.s);\n             match arm.guard {\n               Some(e) => {\n                 word_space(s, \"if\");\n                 print_expr(s, e);\n-                space(s.s);\n+                space(&mut s.s);\n               }\n               None => ()\n             }\n@@ -1309,7 +1325,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n                         }\n                         if !expr_is_simple_block(expr)\n                             && i < len - 1 {\n-                            word(s.s, \",\");\n+                            word(&mut s.s, \",\");\n                         }\n                         end(s); // close enclosing cbox\n                     }\n@@ -1329,7 +1345,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n         //\n         // if !decl.inputs.is_empty() {\n         print_fn_block_args(s, decl);\n-        space(s.s);\n+        space(&mut s.s);\n         // }\n         assert!(body.stmts.is_empty());\n         assert!(body.expr.is_some());\n@@ -1356,7 +1372,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n         //\n         // if !decl.inputs.is_empty() {\n         print_proc_args(s, decl);\n-        space(s.s);\n+        space(&mut s.s);\n         // }\n         assert!(body.stmts.is_empty());\n         assert!(body.expr.is_some());\n@@ -1388,70 +1404,70 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n       }\n       ast::ExprAssign(lhs, rhs) => {\n         print_expr(s, lhs);\n-        space(s.s);\n+        space(&mut s.s);\n         word_space(s, \"=\");\n         print_expr(s, rhs);\n       }\n       ast::ExprAssignOp(_, op, lhs, rhs) => {\n         print_expr(s, lhs);\n-        space(s.s);\n-        word(s.s, ast_util::binop_to_str(op));\n+        space(&mut s.s);\n+        word(&mut s.s, ast_util::binop_to_str(op));\n         word_space(s, \"=\");\n         print_expr(s, rhs);\n       }\n       ast::ExprField(expr, id, ref tys) => {\n         print_expr(s, expr);\n-        word(s.s, \".\");\n+        word(&mut s.s, \".\");\n         print_ident(s, id);\n         if tys.len() > 0u {\n-            word(s.s, \"::<\");\n+            word(&mut s.s, \"::<\");\n             commasep(s, inconsistent, *tys, print_type_ref);\n-            word(s.s, \">\");\n+            word(&mut s.s, \">\");\n         }\n       }\n       ast::ExprIndex(_, expr, index) => {\n         print_expr(s, expr);\n-        word(s.s, \"[\");\n+        word(&mut s.s, \"[\");\n         print_expr(s, index);\n-        word(s.s, \"]\");\n+        word(&mut s.s, \"]\");\n       }\n       ast::ExprPath(ref path) => print_path(s, path, true),\n-      ast::ExprSelf => word(s.s, \"self\"),\n+      ast::ExprSelf => word(&mut s.s, \"self\"),\n       ast::ExprBreak(opt_ident) => {\n-        word(s.s, \"break\");\n-        space(s.s);\n+        word(&mut s.s, \"break\");\n+        space(&mut s.s);\n         for ident in opt_ident.iter() {\n-            word(s.s, \"'\");\n+            word(&mut s.s, \"'\");\n             print_name(s, *ident);\n-            space(s.s);\n+            space(&mut s.s);\n         }\n       }\n       ast::ExprAgain(opt_ident) => {\n-        word(s.s, \"continue\");\n-        space(s.s);\n+        word(&mut s.s, \"continue\");\n+        space(&mut s.s);\n         for ident in opt_ident.iter() {\n-            word(s.s, \"'\");\n+            word(&mut s.s, \"'\");\n             print_name(s, *ident);\n-            space(s.s)\n+            space(&mut s.s)\n         }\n       }\n       ast::ExprRet(result) => {\n-        word(s.s, \"return\");\n+        word(&mut s.s, \"return\");\n         match result {\n-          Some(expr) => { word(s.s, \" \"); print_expr(s, expr); }\n+          Some(expr) => { word(&mut s.s, \" \"); print_expr(s, expr); }\n           _ => ()\n         }\n       }\n       ast::ExprLogLevel => {\n-        word(s.s, \"__log_level\");\n+        word(&mut s.s, \"__log_level\");\n         popen(s);\n         pclose(s);\n       }\n       ast::ExprInlineAsm(ref a) => {\n         if a.volatile {\n-            word(s.s, \"__volatile__ asm!\");\n+            word(&mut s.s, \"__volatile__ asm!\");\n         } else {\n-            word(s.s, \"asm!\");\n+            word(&mut s.s, \"asm!\");\n         }\n         popen(s);\n         print_string(s, a.asm, a.asm_str_style);\n@@ -1482,27 +1498,30 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n           pclose(s);\n       }\n     }\n-    s.ann.post(ann_node);\n+    {\n+        let ann_node = node_expr(s, expr);\n+        s.ann.post(ann_node);\n+    }\n     end(s);\n }\n \n-pub fn print_local_decl(s: @ps, loc: &ast::Local) {\n+pub fn print_local_decl(s: &mut ps, loc: &ast::Local) {\n     print_pat(s, loc.pat);\n     match loc.ty.node {\n       ast::ty_infer => (),\n       _ => { word_space(s, \":\"); print_type(s, loc.ty); }\n     }\n }\n \n-pub fn print_decl(s: @ps, decl: &ast::Decl) {\n+pub fn print_decl(s: &mut ps, decl: &ast::Decl) {\n     maybe_print_comment(s, decl.span.lo);\n     match decl.node {\n       ast::DeclLocal(ref loc) => {\n         space_if_not_bol(s);\n         ibox(s, indent_unit);\n         word_nbsp(s, \"let\");\n \n-        fn print_local(s: @ps, loc: &ast::Local) {\n+        fn print_local(s: &mut ps, loc: &ast::Local) {\n             ibox(s, indent_unit);\n             print_local_decl(s, loc);\n             end(s);\n@@ -1523,36 +1542,36 @@ pub fn print_decl(s: @ps, decl: &ast::Decl) {\n     }\n }\n \n-pub fn print_ident(s: @ps, ident: ast::Ident) {\n-    word(s.s, ident_to_str(&ident));\n+pub fn print_ident(s: &mut ps, ident: ast::Ident) {\n+    word(&mut s.s, ident_to_str(&ident));\n }\n \n-pub fn print_name(s: @ps, name: ast::Name) {\n-    word(s.s, interner_get(name));\n+pub fn print_name(s: &mut ps, name: ast::Name) {\n+    word(&mut s.s, interner_get(name));\n }\n \n-pub fn print_for_decl(s: @ps, loc: &ast::Local, coll: &ast::Expr) {\n+pub fn print_for_decl(s: &mut ps, loc: &ast::Local, coll: &ast::Expr) {\n     print_local_decl(s, loc);\n-    space(s.s);\n+    space(&mut s.s);\n     word_space(s, \"in\");\n     print_expr(s, coll);\n }\n \n-fn print_path_(s: @ps,\n+fn print_path_(s: &mut ps,\n                path: &ast::Path,\n                colons_before_params: bool,\n                opt_bounds: &Option<OptVec<ast::TyParamBound>>) {\n     maybe_print_comment(s, path.span.lo);\n     if path.global {\n-        word(s.s, \"::\");\n+        word(&mut s.s, \"::\");\n     }\n \n     let mut first = true;\n     for (i, segment) in path.segments.iter().enumerate() {\n         if first {\n             first = false\n         } else {\n-            word(s.s, \"::\")\n+            word(&mut s.s, \"::\")\n         }\n \n         print_ident(s, segment.identifier);\n@@ -1567,9 +1586,9 @@ fn print_path_(s: @ps,\n \n         if !segment.lifetimes.is_empty() || !segment.types.is_empty() {\n             if colons_before_params {\n-                word(s.s, \"::\")\n+                word(&mut s.s, \"::\")\n             }\n-            word(s.s, \"<\");\n+            word(&mut s.s, \"<\");\n \n             let mut comma = false;\n             for lifetime in segment.lifetimes.iter() {\n@@ -1590,29 +1609,31 @@ fn print_path_(s: @ps,\n                          print_type_ref);\n             }\n \n-            word(s.s, \">\")\n+            word(&mut s.s, \">\")\n         }\n     }\n }\n \n-pub fn print_path(s: @ps, path: &ast::Path, colons_before_params: bool) {\n+pub fn print_path(s: &mut ps, path: &ast::Path, colons_before_params: bool) {\n     print_path_(s, path, colons_before_params, &None)\n }\n \n-pub fn print_bounded_path(s: @ps, path: &ast::Path,\n+pub fn print_bounded_path(s: &mut ps, path: &ast::Path,\n                           bounds: &Option<OptVec<ast::TyParamBound>>) {\n     print_path_(s, path, false, bounds)\n }\n \n-pub fn print_pat(s: @ps, pat: &ast::Pat) {\n+pub fn print_pat(s: &mut ps, pat: &ast::Pat) {\n     maybe_print_comment(s, pat.span.lo);\n-    let ann_node = node_pat(s, pat);\n-    s.ann.pre(ann_node);\n+    {\n+        let ann_node = node_pat(s, pat);\n+        s.ann.pre(ann_node);\n+    }\n     /* Pat isn't normalized, but the beauty of it\n      is that it doesn't matter */\n     match pat.node {\n-      ast::PatWild => word(s.s, \"_\"),\n-      ast::PatWildMulti => word(s.s, \"..\"),\n+      ast::PatWild => word(&mut s.s, \"_\"),\n+      ast::PatWildMulti => word(&mut s.s, \"..\"),\n       ast::PatIdent(binding_mode, ref path, sub) => {\n           match binding_mode {\n               ast::BindByRef(mutbl) => {\n@@ -1627,7 +1648,7 @@ pub fn print_pat(s: @ps, pat: &ast::Pat) {\n           print_path(s, path, true);\n           match sub {\n               Some(p) => {\n-                  word(s.s, \"@\");\n+                  word(&mut s.s, \"@\");\n                   print_pat(s, p);\n               }\n               None => ()\n@@ -1636,7 +1657,7 @@ pub fn print_pat(s: @ps, pat: &ast::Pat) {\n       ast::PatEnum(ref path, ref args_) => {\n         print_path(s, path, true);\n         match *args_ {\n-          None => word(s.s, \"(..)\"),\n+          None => word(&mut s.s, \"(..)\"),\n           Some(ref args) => {\n             if !args.is_empty() {\n               popen(s);\n@@ -1649,8 +1670,8 @@ pub fn print_pat(s: @ps, pat: &ast::Pat) {\n       }\n       ast::PatStruct(ref path, ref fields, etc) => {\n         print_path(s, path, true);\n-        word(s.s, \"{\");\n-        fn print_field(s: @ps, f: &ast::FieldPat) {\n+        word(&mut s.s, \"{\");\n+        fn print_field(s: &mut ps, f: &ast::FieldPat) {\n             cbox(s, indent_unit);\n             print_ident(s, f.ident);\n             word_space(s, \":\");\n@@ -1663,88 +1684,91 @@ pub fn print_pat(s: @ps, pat: &ast::Pat) {\n                       get_span);\n         if etc {\n             if fields.len() != 0u { word_space(s, \",\"); }\n-            word(s.s, \"..\");\n+            word(&mut s.s, \"..\");\n         }\n-        word(s.s, \"}\");\n+        word(&mut s.s, \"}\");\n       }\n       ast::PatTup(ref elts) => {\n         popen(s);\n         commasep(s, inconsistent, *elts, |s, &p| print_pat(s, p));\n         if elts.len() == 1 {\n-            word(s.s, \",\");\n+            word(&mut s.s, \",\");\n         }\n         pclose(s);\n       }\n       ast::PatBox(inner) => {\n-          word(s.s, \"@\");\n+          word(&mut s.s, \"@\");\n           print_pat(s, inner);\n       }\n       ast::PatUniq(inner) => {\n-          word(s.s, \"~\");\n+          word(&mut s.s, \"~\");\n           print_pat(s, inner);\n       }\n       ast::PatRegion(inner) => {\n-          word(s.s, \"&\");\n+          word(&mut s.s, \"&\");\n           print_pat(s, inner);\n       }\n       ast::PatLit(e) => print_expr(s, e),\n       ast::PatRange(begin, end) => {\n         print_expr(s, begin);\n-        space(s.s);\n-        word(s.s, \"..\");\n+        space(&mut s.s);\n+        word(&mut s.s, \"..\");\n         print_expr(s, end);\n       }\n       ast::PatVec(ref before, slice, ref after) => {\n-        word(s.s, \"[\");\n+        word(&mut s.s, \"[\");\n         commasep(s, inconsistent, *before, |s, &p| print_pat(s, p));\n         for &p in slice.iter() {\n             if !before.is_empty() { word_space(s, \",\"); }\n             match p {\n                 @ast::Pat { node: ast::PatWildMulti, .. } => {\n                     // this case is handled by print_pat\n                 }\n-                _ => word(s.s, \"..\"),\n+                _ => word(&mut s.s, \"..\"),\n             }\n             print_pat(s, p);\n             if !after.is_empty() { word_space(s, \",\"); }\n         }\n         commasep(s, inconsistent, *after, |s, &p| print_pat(s, p));\n-        word(s.s, \"]\");\n+        word(&mut s.s, \"]\");\n       }\n     }\n-    s.ann.post(ann_node);\n+    {\n+        let ann_node = node_pat(s, pat);\n+        s.ann.post(ann_node);\n+    }\n }\n \n pub fn explicit_self_to_str(explicit_self: &ast::explicit_self_, intr: @ident_interner) -> ~str {\n     to_str(explicit_self, |a, &b| { print_explicit_self(a, b); () }, intr)\n }\n \n // Returns whether it printed anything\n-pub fn print_explicit_self(s: @ps, explicit_self: ast::explicit_self_) -> bool {\n+pub fn print_explicit_self(s: &mut ps, explicit_self: ast::explicit_self_) -> bool {\n     match explicit_self {\n         ast::sty_static => { return false; }\n         ast::sty_value(m) => {\n             print_mutability(s, m);\n-            word(s.s, \"self\");\n+            word(&mut s.s, \"self\");\n         }\n         ast::sty_uniq(m) => {\n             print_mutability(s, m);\n-            word(s.s, \"~self\");\n+            word(&mut s.s, \"~self\");\n         }\n         ast::sty_region(ref lt, m) => {\n-            word(s.s, \"&\");\n+            word(&mut s.s, \"&\");\n             print_opt_lifetime(s, lt);\n             print_mutability(s, m);\n-            word(s.s, \"self\");\n+            word(&mut s.s, \"self\");\n         }\n         ast::sty_box(m) => {\n-            word(s.s, \"@\"); print_mutability(s, m); word(s.s, \"self\");\n+            word(&mut s.s, \"@\"); print_mutability(s, m); word(&mut s.s, \"self\");\n         }\n     }\n     return true;\n }\n \n-pub fn print_fn(s: @ps,\n+pub fn print_fn(s: &mut ps,\n                 decl: &ast::fn_decl,\n                 purity: Option<ast::purity>,\n                 abis: AbiSet,\n@@ -1760,7 +1784,7 @@ pub fn print_fn(s: @ps,\n     print_fn_args_and_ret(s, decl, opt_explicit_self);\n }\n \n-pub fn print_fn_args(s: @ps, decl: &ast::fn_decl,\n+pub fn print_fn_args(s: &mut ps, decl: &ast::fn_decl,\n                  opt_explicit_self: Option<ast::explicit_self_>) {\n     // It is unfortunate to duplicate the commasep logic, but we want the\n     // self type and the args all in the same box.\n@@ -1778,12 +1802,12 @@ pub fn print_fn_args(s: @ps, decl: &ast::fn_decl,\n     end(s);\n }\n \n-pub fn print_fn_args_and_ret(s: @ps, decl: &ast::fn_decl,\n+pub fn print_fn_args_and_ret(s: &mut ps, decl: &ast::fn_decl,\n                              opt_explicit_self: Option<ast::explicit_self_>) {\n     popen(s);\n     print_fn_args(s, decl, opt_explicit_self);\n     if decl.variadic {\n-        word(s.s, \", ...\");\n+        word(&mut s.s, \", ...\");\n     }\n     pclose(s);\n \n@@ -1798,10 +1822,10 @@ pub fn print_fn_args_and_ret(s: @ps, decl: &ast::fn_decl,\n     }\n }\n \n-pub fn print_fn_block_args(s: @ps, decl: &ast::fn_decl) {\n-    word(s.s, \"|\");\n+pub fn print_fn_block_args(s: &mut ps, decl: &ast::fn_decl) {\n+    word(&mut s.s, \"|\");\n     print_fn_args(s, decl, None);\n-    word(s.s, \"|\");\n+    word(&mut s.s, \"|\");\n \n     match decl.output.node {\n         ast::ty_infer => {}\n@@ -1815,11 +1839,11 @@ pub fn print_fn_block_args(s: @ps, decl: &ast::fn_decl) {\n     maybe_print_comment(s, decl.output.span.lo);\n }\n \n-pub fn print_proc_args(s: @ps, decl: &ast::fn_decl) {\n-    word(s.s, \"proc\");\n-    word(s.s, \"(\");\n+pub fn print_proc_args(s: &mut ps, decl: &ast::fn_decl) {\n+    word(&mut s.s, \"proc\");\n+    word(&mut s.s, \"(\");\n     print_fn_args(s, decl, None);\n-    word(s.s, \")\");\n+    word(&mut s.s, \")\");\n \n     match decl.output.node {\n         ast::ty_infer => {}\n@@ -1833,10 +1857,10 @@ pub fn print_proc_args(s: @ps, decl: &ast::fn_decl) {\n     maybe_print_comment(s, decl.output.span.lo);\n }\n \n-pub fn print_bounds(s: @ps, bounds: &OptVec<ast::TyParamBound>,\n+pub fn print_bounds(s: &mut ps, bounds: &OptVec<ast::TyParamBound>,\n                     print_colon_anyway: bool) {\n     if !bounds.is_empty() {\n-        word(s.s, \":\");\n+        word(&mut s.s, \":\");\n         let mut first = true;\n         for bound in bounds.iter() {\n             nbsp(s);\n@@ -1848,24 +1872,24 @@ pub fn print_bounds(s: @ps, bounds: &OptVec<ast::TyParamBound>,\n \n             match *bound {\n                 TraitTyParamBound(ref tref) => print_trait_ref(s, tref),\n-                RegionTyParamBound => word(s.s, \"'static\"),\n+                RegionTyParamBound => word(&mut s.s, \"'static\"),\n             }\n         }\n     } else if print_colon_anyway {\n-        word(s.s, \":\");\n+        word(&mut s.s, \":\");\n     }\n }\n \n-pub fn print_lifetime(s: @ps, lifetime: &ast::Lifetime) {\n-    word(s.s, \"'\");\n+pub fn print_lifetime(s: &mut ps, lifetime: &ast::Lifetime) {\n+    word(&mut s.s, \"'\");\n     print_ident(s, lifetime.ident);\n }\n \n-pub fn print_generics(s: @ps, generics: &ast::Generics) {\n+pub fn print_generics(s: &mut ps, generics: &ast::Generics) {\n     let total = generics.lifetimes.len() + generics.ty_params.len();\n     if total > 0 {\n-        word(s.s, \"<\");\n-        fn print_item(s: @ps, generics: &ast::Generics, idx: uint) {\n+        word(&mut s.s, \"<\");\n+        fn print_item(s: &mut ps, generics: &ast::Generics, idx: uint) {\n             if idx < generics.lifetimes.len() {\n                 let lifetime = generics.lifetimes.get(idx);\n                 print_lifetime(s, lifetime);\n@@ -1884,21 +1908,21 @@ pub fn print_generics(s: @ps, generics: &ast::Generics) {\n \n         commasep(s, inconsistent, ints,\n                  |s, &i| print_item(s, generics, i));\n-        word(s.s, \">\");\n+        word(&mut s.s, \">\");\n     }\n }\n \n-pub fn print_meta_item(s: @ps, item: &ast::MetaItem) {\n+pub fn print_meta_item(s: &mut ps, item: &ast::MetaItem) {\n     ibox(s, indent_unit);\n     match item.node {\n-      ast::MetaWord(name) => word(s.s, name),\n+      ast::MetaWord(name) => word(&mut s.s, name),\n       ast::MetaNameValue(name, value) => {\n         word_space(s, name);\n         word_space(s, \"=\");\n         print_literal(s, &value);\n       }\n       ast::MetaList(name, ref items) => {\n-        word(s.s, name);\n+        word(&mut s.s, name);\n         popen(s);\n         commasep(s,\n                  consistent,\n@@ -1910,43 +1934,43 @@ pub fn print_meta_item(s: @ps, item: &ast::MetaItem) {\n     end(s);\n }\n \n-pub fn print_view_path(s: @ps, vp: &ast::view_path) {\n+pub fn print_view_path(s: &mut ps, vp: &ast::view_path) {\n     match vp.node {\n       ast::view_path_simple(ident, ref path, _) => {\n         // FIXME(#6993) can't compare identifiers directly here\n         if path.segments.last().identifier.name != ident.name {\n             print_ident(s, ident);\n-            space(s.s);\n+            space(&mut s.s);\n             word_space(s, \"=\");\n         }\n         print_path(s, path, false);\n       }\n \n       ast::view_path_glob(ref path, _) => {\n         print_path(s, path, false);\n-        word(s.s, \"::*\");\n+        word(&mut s.s, \"::*\");\n       }\n \n       ast::view_path_list(ref path, ref idents, _) => {\n         if path.segments.is_empty() {\n-            word(s.s, \"{\");\n+            word(&mut s.s, \"{\");\n         } else {\n             print_path(s, path, false);\n-            word(s.s, \"::{\");\n+            word(&mut s.s, \"::{\");\n         }\n         commasep(s, inconsistent, (*idents), |s, w| {\n             print_ident(s, w.node.name);\n         });\n-        word(s.s, \"}\");\n+        word(&mut s.s, \"}\");\n       }\n     }\n }\n \n-pub fn print_view_paths(s: @ps, vps: &[@ast::view_path]) {\n+pub fn print_view_paths(s: &mut ps, vps: &[@ast::view_path]) {\n     commasep(s, inconsistent, vps, |p, &vp| print_view_path(p, vp));\n }\n \n-pub fn print_view_item(s: @ps, item: &ast::view_item) {\n+pub fn print_view_item(s: &mut ps, item: &ast::view_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -1956,9 +1980,9 @@ pub fn print_view_item(s: @ps, item: &ast::view_item) {\n             head(s, \"extern mod\");\n             print_ident(s, id);\n             for &(ref p, style) in optional_path.iter() {\n-                space(s.s);\n-                word(s.s, \"=\");\n-                space(s.s);\n+                space(&mut s.s);\n+                word(&mut s.s, \"=\");\n+                space(&mut s.s);\n                 print_string(s, *p, style);\n             }\n         }\n@@ -1968,24 +1992,24 @@ pub fn print_view_item(s: @ps, item: &ast::view_item) {\n             print_view_paths(s, *vps);\n         }\n     }\n-    word(s.s, \";\");\n+    word(&mut s.s, \";\");\n     end(s); // end inner head-block\n     end(s); // end outer head-block\n }\n \n-pub fn print_mutability(s: @ps, mutbl: ast::Mutability) {\n+pub fn print_mutability(s: &mut ps, mutbl: ast::Mutability) {\n     match mutbl {\n       ast::MutMutable => word_nbsp(s, \"mut\"),\n       ast::MutImmutable => {/* nothing */ }\n     }\n }\n \n-pub fn print_mt(s: @ps, mt: &ast::mt) {\n+pub fn print_mt(s: &mut ps, mt: &ast::mt) {\n     print_mutability(s, mt.mutbl);\n     print_type(s, mt.ty);\n }\n \n-pub fn print_arg(s: @ps, input: &ast::arg) {\n+pub fn print_arg(s: &mut ps, input: &ast::arg) {\n     ibox(s, indent_unit);\n     match input.ty.node {\n       ast::ty_infer => print_pat(s, input.pat),\n@@ -1999,8 +2023,8 @@ pub fn print_arg(s: @ps, input: &ast::arg) {\n             }\n             _ => {\n                 print_pat(s, input.pat);\n-                word(s.s, \":\");\n-                space(s.s);\n+                word(&mut s.s, \":\");\n+                space(&mut s.s);\n             }\n         }\n         print_type(s, input.ty);\n@@ -2009,7 +2033,7 @@ pub fn print_arg(s: @ps, input: &ast::arg) {\n     end(s);\n }\n \n-pub fn print_ty_fn(s: @ps,\n+pub fn print_ty_fn(s: &mut ps,\n                    opt_abis: Option<AbiSet>,\n                    opt_sigil: Option<ast::Sigil>,\n                    opt_region: &Option<ast::Lifetime>,\n@@ -2025,7 +2049,7 @@ pub fn print_ty_fn(s: @ps,\n     // Duplicates the logic in `print_fn_header_info()`.  This is because that\n     // function prints the sigil in the wrong place.  That should be fixed.\n     if opt_sigil == Some(ast::OwnedSigil) && onceness == ast::Once {\n-        word(s.s, \"proc\");\n+        word(&mut s.s, \"proc\");\n     } else if opt_sigil == Some(ast::BorrowedSigil) {\n         print_extern_opt_abis(s, opt_abis);\n         for lifetime in opt_region.iter() {\n@@ -2039,20 +2063,20 @@ pub fn print_ty_fn(s: @ps,\n         print_opt_lifetime(s, opt_region);\n         print_purity(s, purity);\n         print_onceness(s, onceness);\n-        word(s.s, \"fn\");\n+        word(&mut s.s, \"fn\");\n     }\n \n-    match id { Some(id) => { word(s.s, \" \"); print_ident(s, id); } _ => () }\n+    match id { Some(id) => { word(&mut s.s, \" \"); print_ident(s, id); } _ => () }\n \n     if opt_sigil != Some(ast::BorrowedSigil) {\n         opt_bounds.as_ref().map(|bounds| print_bounds(s, bounds, true));\n     }\n \n     match generics { Some(g) => print_generics(s, g), _ => () }\n-    zerobreak(s.s);\n+    zerobreak(&mut s.s);\n \n     if opt_sigil == Some(ast::BorrowedSigil) {\n-        word(s.s, \"|\");\n+        word(&mut s.s, \"|\");\n     } else {\n         popen(s);\n     }\n@@ -2071,12 +2095,12 @@ pub fn print_ty_fn(s: @ps,\n     end(s);\n \n     if opt_sigil == Some(ast::BorrowedSigil) {\n-        word(s.s, \"|\");\n+        word(&mut s.s, \"|\");\n \n         opt_bounds.as_ref().map(|bounds| print_bounds(s, bounds, true));\n     } else {\n         if decl.variadic {\n-            word(s.s, \", ...\");\n+            word(&mut s.s, \", ...\");\n         }\n         pclose(s);\n     }\n@@ -2098,7 +2122,7 @@ pub fn print_ty_fn(s: @ps,\n     end(s);\n }\n \n-pub fn maybe_print_trailing_comment(s: @ps, span: codemap::Span,\n+pub fn maybe_print_trailing_comment(s: &mut ps, span: codemap::Span,\n                                     next_pos: Option<BytePos>) {\n     let cm;\n     match s.cm { Some(ccm) => cm = ccm, _ => return }\n@@ -2119,10 +2143,10 @@ pub fn maybe_print_trailing_comment(s: @ps, span: codemap::Span,\n     }\n }\n \n-pub fn print_remaining_comments(s: @ps) {\n+pub fn print_remaining_comments(s: &mut ps) {\n     // If there aren't any remaining comments, then we need to manually\n     // make sure there is a line break at the end.\n-    if next_comment(s).is_none() { hardbreak(s.s); }\n+    if next_comment(s).is_none() { hardbreak(&mut s.s); }\n     loop {\n         match next_comment(s) {\n           Some(ref cmnt) => {\n@@ -2134,11 +2158,11 @@ pub fn print_remaining_comments(s: @ps) {\n     }\n }\n \n-pub fn print_literal(s: @ps, lit: &ast::lit) {\n+pub fn print_literal(s: &mut ps, lit: &ast::lit) {\n     maybe_print_comment(s, lit.span.lo);\n     match next_lit(s, lit.span.lo) {\n       Some(ref ltrl) => {\n-        word(s.s, (*ltrl).lit);\n+        word(&mut s.s, (*ltrl).lit);\n         return;\n       }\n       _ => ()\n@@ -2149,45 +2173,45 @@ pub fn print_literal(s: @ps, lit: &ast::lit) {\n           let mut res = ~\"'\";\n           char::from_u32(ch).unwrap().escape_default(|c| res.push_char(c));\n           res.push_char('\\'');\n-          word(s.s, res);\n+          word(&mut s.s, res);\n       }\n       ast::lit_int(i, t) => {\n         if i < 0_i64 {\n-            word(s.s,\n+            word(&mut s.s,\n                  ~\"-\" + (-i as u64).to_str_radix(10u)\n                  + ast_util::int_ty_to_str(t));\n         } else {\n-            word(s.s,\n+            word(&mut s.s,\n                  (i as u64).to_str_radix(10u)\n                  + ast_util::int_ty_to_str(t));\n         }\n       }\n       ast::lit_uint(u, t) => {\n-        word(s.s,\n+        word(&mut s.s,\n              u.to_str_radix(10u)\n              + ast_util::uint_ty_to_str(t));\n       }\n       ast::lit_int_unsuffixed(i) => {\n         if i < 0_i64 {\n-            word(s.s, ~\"-\" + (-i as u64).to_str_radix(10u));\n+            word(&mut s.s, ~\"-\" + (-i as u64).to_str_radix(10u));\n         } else {\n-            word(s.s, (i as u64).to_str_radix(10u));\n+            word(&mut s.s, (i as u64).to_str_radix(10u));\n         }\n       }\n       ast::lit_float(f, t) => {\n-        word(s.s, f.to_owned() + ast_util::float_ty_to_str(t));\n+        word(&mut s.s, f.to_owned() + ast_util::float_ty_to_str(t));\n       }\n-      ast::lit_float_unsuffixed(f) => word(s.s, f),\n-      ast::lit_nil => word(s.s, \"()\"),\n+      ast::lit_float_unsuffixed(f) => word(&mut s.s, f),\n+      ast::lit_nil => word(&mut s.s, \"()\"),\n       ast::lit_bool(val) => {\n-        if val { word(s.s, \"true\"); } else { word(s.s, \"false\"); }\n+        if val { word(&mut s.s, \"true\"); } else { word(&mut s.s, \"false\"); }\n       }\n       ast::lit_binary(arr) => {\n         ibox(s, indent_unit);\n-        word(s.s, \"[\");\n-        commasep_cmnt(s, inconsistent, arr, |s, u| word(s.s, format!(\"{}\", *u)),\n+        word(&mut s.s, \"[\");\n+        commasep_cmnt(s, inconsistent, arr, |s, u| word(&mut s.s, format!(\"{}\", *u)),\n                       |_| lit.span);\n-        word(s.s, \"]\");\n+        word(&mut s.s, \"]\");\n         end(s);\n       }\n     }\n@@ -2197,7 +2221,7 @@ pub fn lit_to_str(l: &ast::lit) -> ~str {\n     return to_str(l, print_literal, parse::token::mk_fake_ident_interner());\n }\n \n-pub fn next_lit(s: @ps, pos: BytePos) -> Option<comments::lit> {\n+pub fn next_lit(s: &mut ps, pos: BytePos) -> Option<comments::lit> {\n     match s.literals {\n       Some(ref lits) => {\n         while s.cur_cmnt_and_lit.cur_lit < lits.len() {\n@@ -2212,7 +2236,7 @@ pub fn next_lit(s: @ps, pos: BytePos) -> Option<comments::lit> {\n     }\n }\n \n-pub fn maybe_print_comment(s: @ps, pos: BytePos) {\n+pub fn maybe_print_comment(s: &mut ps, pos: BytePos) {\n     loop {\n         match next_comment(s) {\n           Some(ref cmnt) => {\n@@ -2226,33 +2250,33 @@ pub fn maybe_print_comment(s: @ps, pos: BytePos) {\n     }\n }\n \n-pub fn print_comment(s: @ps, cmnt: &comments::cmnt) {\n+pub fn print_comment(s: &mut ps, cmnt: &comments::cmnt) {\n     match cmnt.style {\n       comments::mixed => {\n         assert_eq!(cmnt.lines.len(), 1u);\n-        zerobreak(s.s);\n-        word(s.s, cmnt.lines[0]);\n-        zerobreak(s.s);\n+        zerobreak(&mut s.s);\n+        word(&mut s.s, cmnt.lines[0]);\n+        zerobreak(&mut s.s);\n       }\n       comments::isolated => {\n         pprust::hardbreak_if_not_bol(s);\n         for line in cmnt.lines.iter() {\n             // Don't print empty lines because they will end up as trailing\n             // whitespace\n-            if !line.is_empty() { word(s.s, *line); }\n-            hardbreak(s.s);\n+            if !line.is_empty() { word(&mut s.s, *line); }\n+            hardbreak(&mut s.s);\n         }\n       }\n       comments::trailing => {\n-        word(s.s, \" \");\n+        word(&mut s.s, \" \");\n         if cmnt.lines.len() == 1u {\n-            word(s.s, cmnt.lines[0]);\n-            hardbreak(s.s);\n+            word(&mut s.s, cmnt.lines[0]);\n+            hardbreak(&mut s.s);\n         } else {\n             ibox(s, 0u);\n             for line in cmnt.lines.iter() {\n-                if !line.is_empty() { word(s.s, *line); }\n-                hardbreak(s.s);\n+                if !line.is_empty() { word(&mut s.s, *line); }\n+                hardbreak(&mut s.s);\n             }\n             end(s);\n         }\n@@ -2264,30 +2288,30 @@ pub fn print_comment(s: @ps, cmnt: &comments::cmnt) {\n               pp::STRING(s, _) => \";\" == s,\n               _ => false\n             };\n-        if is_semi || is_begin(s) || is_end(s) { hardbreak(s.s); }\n-        hardbreak(s.s);\n+        if is_semi || is_begin(s) || is_end(s) { hardbreak(&mut s.s); }\n+        hardbreak(&mut s.s);\n       }\n     }\n }\n \n-pub fn print_string(s: @ps, st: &str, style: ast::StrStyle) {\n+pub fn print_string(s: &mut ps, st: &str, style: ast::StrStyle) {\n     let st = match style {\n         ast::CookedStr => format!(\"\\\"{}\\\"\", st.escape_default()),\n         ast::RawStr(n) => format!(\"r{delim}\\\"{string}\\\"{delim}\",\n                                   delim=\"#\".repeat(n), string=st)\n     };\n-    word(s.s, st);\n+    word(&mut s.s, st);\n }\n \n-pub fn to_str<T>(t: &T, f: |@ps, &T|, intr: @ident_interner) -> ~str {\n+pub fn to_str<T>(t: &T, f: |&mut ps, &T|, intr: @ident_interner) -> ~str {\n     let wr = @mut MemWriter::new();\n-    let s = rust_printer(wr as @mut io::Writer, intr);\n-    f(s, t);\n-    eof(s.s);\n+    let mut s = rust_printer(wr as @mut io::Writer, intr);\n+    f(&mut s, t);\n+    eof(&mut s.s);\n     str::from_utf8_owned(wr.inner_ref().to_owned())\n }\n \n-pub fn next_comment(s: @ps) -> Option<comments::cmnt> {\n+pub fn next_comment(s: &mut ps) -> Option<comments::cmnt> {\n     match s.comments {\n       Some(ref cmnts) => {\n         if s.cur_cmnt_and_lit.cur_cmnt < cmnts.len() {\n@@ -2300,7 +2324,7 @@ pub fn next_comment(s: @ps) -> Option<comments::cmnt> {\n     }\n }\n \n-pub fn print_opt_purity(s: @ps, opt_purity: Option<ast::purity>) {\n+pub fn print_opt_purity(s: &mut ps, opt_purity: Option<ast::purity>) {\n     match opt_purity {\n         Some(ast::impure_fn) => { }\n         Some(purity) => {\n@@ -2310,7 +2334,7 @@ pub fn print_opt_purity(s: @ps, opt_purity: Option<ast::purity>) {\n     }\n }\n \n-pub fn print_opt_abis_and_extern_if_nondefault(s: @ps,\n+pub fn print_opt_abis_and_extern_if_nondefault(s: &mut ps,\n                                                opt_abis: Option<AbiSet>) {\n     match opt_abis {\n         Some(abis) if !abis.is_rust() => {\n@@ -2321,7 +2345,7 @@ pub fn print_opt_abis_and_extern_if_nondefault(s: @ps,\n     };\n }\n \n-pub fn print_extern_opt_abis(s: @ps, opt_abis: Option<AbiSet>) {\n+pub fn print_extern_opt_abis(s: &mut ps, opt_abis: Option<AbiSet>) {\n     match opt_abis {\n         Some(abis) => {\n             word_nbsp(s, \"extern\");\n@@ -2331,23 +2355,23 @@ pub fn print_extern_opt_abis(s: @ps, opt_abis: Option<AbiSet>) {\n     };\n }\n \n-pub fn print_opt_sigil(s: @ps, opt_sigil: Option<ast::Sigil>) {\n+pub fn print_opt_sigil(s: &mut ps, opt_sigil: Option<ast::Sigil>) {\n     match opt_sigil {\n-        Some(ast::BorrowedSigil) => { word(s.s, \"&\"); }\n-        Some(ast::OwnedSigil) => { word(s.s, \"~\"); }\n-        Some(ast::ManagedSigil) => { word(s.s, \"@\"); }\n+        Some(ast::BorrowedSigil) => { word(&mut s.s, \"&\"); }\n+        Some(ast::OwnedSigil) => { word(&mut s.s, \"~\"); }\n+        Some(ast::ManagedSigil) => { word(&mut s.s, \"@\"); }\n         None => {}\n     };\n }\n \n-pub fn print_fn_header_info(s: @ps,\n+pub fn print_fn_header_info(s: &mut ps,\n                             _opt_explicit_self: Option<ast::explicit_self_>,\n                             opt_purity: Option<ast::purity>,\n                             abis: AbiSet,\n                             onceness: ast::Onceness,\n                             opt_sigil: Option<ast::Sigil>,\n                             vis: ast::visibility) {\n-    word(s.s, visibility_qualified(vis, \"\"));\n+    word(&mut s.s, visibility_qualified(vis, \"\"));\n \n     if abis != AbiSet::Rust() {\n         word_nbsp(s, \"extern\");\n@@ -2361,7 +2385,7 @@ pub fn print_fn_header_info(s: @ps,\n     }\n \n     print_onceness(s, onceness);\n-    word(s.s, \"fn\");\n+    word(&mut s.s, \"fn\");\n     print_opt_sigil(s, opt_sigil);\n }\n \n@@ -2380,14 +2404,14 @@ pub fn onceness_to_str(o: ast::Onceness) -> &'static str {\n     }\n }\n \n-pub fn print_purity(s: @ps, p: ast::purity) {\n+pub fn print_purity(s: &mut ps, p: ast::purity) {\n     match p {\n       ast::impure_fn => (),\n       _ => word_nbsp(s, purity_to_str(p))\n     }\n }\n \n-pub fn print_onceness(s: @ps, o: ast::Onceness) {\n+pub fn print_onceness(s: &mut ps, o: ast::Onceness) {\n     match o {\n         ast::Once => { word_nbsp(s, \"once\"); }\n         ast::Many => {}"}]}