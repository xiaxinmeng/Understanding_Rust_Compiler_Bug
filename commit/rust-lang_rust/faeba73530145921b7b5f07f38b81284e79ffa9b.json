{"sha": "faeba73530145921b7b5f07f38b81284e79ffa9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhZWJhNzM1MzAxNDU5MjFiN2I1ZjA3ZjM4YjgxMjg0ZTc5ZmZhOWI=", "commit": {"author": {"name": "Andrey Tonkih", "email": "xosmig@gmail.com", "date": "2016-04-14T23:18:52Z"}, "committer": {"name": "Andrey Tonkih", "email": "xosmig@gmail.com", "date": "2016-04-15T21:38:59Z"}, "message": "collections: add append and extend specialization for binary heap", "tree": {"sha": "96001a98da5ce69de5f6e5a316174e57f8a53304", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96001a98da5ce69de5f6e5a316174e57f8a53304"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/faeba73530145921b7b5f07f38b81284e79ffa9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/faeba73530145921b7b5f07f38b81284e79ffa9b", "html_url": "https://github.com/rust-lang/rust/commit/faeba73530145921b7b5f07f38b81284e79ffa9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/faeba73530145921b7b5f07f38b81284e79ffa9b/comments", "author": {"login": "xosmig", "id": 16969945, "node_id": "MDQ6VXNlcjE2OTY5OTQ1", "avatar_url": "https://avatars.githubusercontent.com/u/16969945?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xosmig", "html_url": "https://github.com/xosmig", "followers_url": "https://api.github.com/users/xosmig/followers", "following_url": "https://api.github.com/users/xosmig/following{/other_user}", "gists_url": "https://api.github.com/users/xosmig/gists{/gist_id}", "starred_url": "https://api.github.com/users/xosmig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xosmig/subscriptions", "organizations_url": "https://api.github.com/users/xosmig/orgs", "repos_url": "https://api.github.com/users/xosmig/repos", "events_url": "https://api.github.com/users/xosmig/events{/privacy}", "received_events_url": "https://api.github.com/users/xosmig/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xosmig", "id": 16969945, "node_id": "MDQ6VXNlcjE2OTY5OTQ1", "avatar_url": "https://avatars.githubusercontent.com/u/16969945?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xosmig", "html_url": "https://github.com/xosmig", "followers_url": "https://api.github.com/users/xosmig/followers", "following_url": "https://api.github.com/users/xosmig/following{/other_user}", "gists_url": "https://api.github.com/users/xosmig/gists{/gist_id}", "starred_url": "https://api.github.com/users/xosmig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xosmig/subscriptions", "organizations_url": "https://api.github.com/users/xosmig/orgs", "repos_url": "https://api.github.com/users/xosmig/repos", "events_url": "https://api.github.com/users/xosmig/events{/privacy}", "received_events_url": "https://api.github.com/users/xosmig/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74b3684d009c0e243a282c9a573ef5e29a2681d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/74b3684d009c0e243a282c9a573ef5e29a2681d9", "html_url": "https://github.com/rust-lang/rust/commit/74b3684d009c0e243a282c9a573ef5e29a2681d9"}], "stats": {"total": 126, "additions": 121, "deletions": 5}, "files": [{"sha": "b01a09a2fe3a596e667e87fee24a8ac5f60b898c", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 88, "deletions": 5, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/faeba73530145921b7b5f07f38b81284e79ffa9b/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faeba73530145921b7b5f07f38b81284e79ffa9b/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=faeba73530145921b7b5f07f38b81284e79ffa9b", "patch": "@@ -153,12 +153,15 @@\n \n use core::iter::FromIterator;\n use core::mem::swap;\n+use core::mem::size_of;\n use core::ptr;\n use core::fmt;\n \n use slice;\n use vec::{self, Vec};\n \n+use super::SpecExtend;\n+\n /// A priority queue implemented with a binary heap.\n ///\n /// This will be a max-heap.\n@@ -738,6 +741,71 @@ impl<T: Ord> BinaryHeap<T> {\n     pub fn clear(&mut self) {\n         self.drain();\n     }\n+\n+    fn rebuild(&mut self) {\n+        let mut n = self.len() / 2;\n+        while n > 0 {\n+            n -= 1;\n+            self.sift_down(n);\n+        }\n+    }\n+\n+    /// Moves all the elements of `other` into `self`, leaving `other` empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(binary_heap_append)]\n+    ///\n+    /// use std::collections::BinaryHeap;\n+    ///\n+    /// let v = vec![-10, 1, 2, 3, 3];\n+    /// let mut a = BinaryHeap::from(v);\n+    ///\n+    /// let v = vec![-20, 5, 43];\n+    /// let mut b = BinaryHeap::from(v);\n+    ///\n+    /// a.append(&mut b);\n+    ///\n+    /// assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\n+    /// assert!(b.is_empty());\n+    /// ```\n+    #[unstable(feature = \"binary_heap_append\",\n+           reason = \"needs to be audited\",\n+           issue = \"32526\")]\n+    pub fn append(&mut self, other: &mut Self) {\n+        if self.len() < other.len() {\n+            swap(self, other);\n+        }\n+\n+        if other.is_empty() {\n+            return;\n+        }\n+\n+        #[inline(always)]\n+        fn log2_fast(x: usize) -> usize {\n+            8 * size_of::<usize>() - (x.leading_zeros() as usize) - 1\n+        }\n+\n+        // `rebuild` takes O(len1 + len2) operations\n+        // and about 2 * (len1 + len2) comparisons in the worst case\n+        // while `extend` takes O(len2 * log_2(len1)) operations\n+        // and about 1 * len2 * log_2(len1) comparisons in the worst case,\n+        // assuming len1 >= len2.\n+        #[inline]\n+        fn better_to_rebuild(len1: usize, len2: usize) -> bool {\n+            2 * (len1 + len2) < len2 * log2_fast(len1)\n+        }\n+\n+        if better_to_rebuild(self.len(), other.len()) {\n+            self.data.append(&mut other.data);\n+            self.rebuild();\n+        } else {\n+            self.extend(other.drain());\n+        }\n+    }\n }\n \n /// Hole represents a hole in a slice i.e. an index without valid value\n@@ -917,11 +985,7 @@ impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n impl<T: Ord> From<Vec<T>> for BinaryHeap<T> {\n     fn from(vec: Vec<T>) -> BinaryHeap<T> {\n         let mut heap = BinaryHeap { data: vec };\n-        let mut n = heap.len() / 2;\n-        while n > 0 {\n-            n -= 1;\n-            heap.sift_down(n);\n-        }\n+        heap.rebuild();\n         heap\n     }\n }\n@@ -980,7 +1044,26 @@ impl<'a, T> IntoIterator for &'a BinaryHeap<T> where T: Ord {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BinaryHeap<T> {\n+    #[inline]\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n+        <Self as SpecExtend<I>>::spec_extend(self, iter);\n+    }\n+}\n+\n+impl<T: Ord, I: IntoIterator<Item = T>> SpecExtend<I> for BinaryHeap<T> {\n+    default fn spec_extend(&mut self, iter: I) {\n+        self.extend_desugared(iter.into_iter());\n+    }\n+}\n+\n+impl<T: Ord> SpecExtend<BinaryHeap<T>> for BinaryHeap<T> {\n+    fn spec_extend(&mut self, ref mut other: BinaryHeap<T>) {\n+        self.append(other);\n+    }\n+}\n+\n+impl<T: Ord> BinaryHeap<T> {\n+    fn extend_desugared<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         let iterator = iter.into_iter();\n         let (lower, _) = iterator.size_hint();\n "}, {"sha": "58194fe75f79aa3895e9d7e2f71a3be34060ff61", "filename": "src/libcollectionstest/binary_heap.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/faeba73530145921b7b5f07f38b81284e79ffa9b/src%2Flibcollectionstest%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faeba73530145921b7b5f07f38b81284e79ffa9b/src%2Flibcollectionstest%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbinary_heap.rs?ref=faeba73530145921b7b5f07f38b81284e79ffa9b", "patch": "@@ -242,3 +242,35 @@ fn test_extend_ref() {\n     assert_eq!(a.len(), 5);\n     assert_eq!(a.into_sorted_vec(), [1, 2, 3, 4, 5]);\n }\n+\n+#[test]\n+fn test_append() {\n+    let mut a = BinaryHeap::from(vec![-10, 1, 2, 3, 3]);\n+    let mut b = BinaryHeap::from(vec![-20, 5, 43]);\n+\n+    a.append(&mut b);\n+\n+    assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\n+    assert!(b.is_empty());\n+}\n+\n+#[test]\n+fn test_append_to_empty() {\n+    let mut a = BinaryHeap::new();\n+    let mut b = BinaryHeap::from(vec![-20, 5, 43]);\n+\n+    a.append(&mut b);\n+\n+    assert_eq!(a.into_sorted_vec(), [-20, 5, 43]);\n+    assert!(b.is_empty());\n+}\n+\n+#[test]\n+fn test_extend_specialization() {\n+    let mut a = BinaryHeap::from(vec![-10, 1, 2, 3, 3]);\n+    let b = BinaryHeap::from(vec![-20, 5, 43]);\n+\n+    a.extend(b);\n+\n+    assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\n+}"}, {"sha": "4e08cab6db9014d03c2a2cce261525972a3aa11f", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/faeba73530145921b7b5f07f38b81284e79ffa9b/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faeba73530145921b7b5f07f38b81284e79ffa9b/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=faeba73530145921b7b5f07f38b81284e79ffa9b", "patch": "@@ -11,6 +11,7 @@\n #![deny(warnings)]\n \n #![feature(binary_heap_extras)]\n+#![feature(binary_heap_append)]\n #![feature(box_syntax)]\n #![feature(btree_range)]\n #![feature(collections)]"}]}