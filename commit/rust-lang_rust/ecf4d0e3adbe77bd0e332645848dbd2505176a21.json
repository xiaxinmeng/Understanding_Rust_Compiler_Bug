{"sha": "ecf4d0e3adbe77bd0e332645848dbd2505176a21", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjZjRkMGUzYWRiZTc3YmQwZTMzMjY0NTg0OGRiZDI1MDUxNzZhMjE=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-12-15T18:46:39Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-01-06T11:57:51Z"}, "message": "Add Resume Terminator which corresponds to resume\n\nDiverge should eventually go away", "tree": {"sha": "942124637730a88606d647338ecff190d0f50390", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/942124637730a88606d647338ecff190d0f50390"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecf4d0e3adbe77bd0e332645848dbd2505176a21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecf4d0e3adbe77bd0e332645848dbd2505176a21", "html_url": "https://github.com/rust-lang/rust/commit/ecf4d0e3adbe77bd0e332645848dbd2505176a21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecf4d0e3adbe77bd0e332645848dbd2505176a21/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f18b559dfbfde2677fc2b1450fdcbc5c2a5566a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f18b559dfbfde2677fc2b1450fdcbc5c2a5566a", "html_url": "https://github.com/rust-lang/rust/commit/6f18b559dfbfde2677fc2b1450fdcbc5c2a5566a"}], "stats": {"total": 115, "additions": 70, "deletions": 45}, "files": [{"sha": "8cdb804c599ea2c4895321e80a5bd2defb4879ab", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ecf4d0e3adbe77bd0e332645848dbd2505176a21/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecf4d0e3adbe77bd0e332645848dbd2505176a21/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=ecf4d0e3adbe77bd0e332645848dbd2505176a21", "patch": "@@ -251,6 +251,10 @@ pub enum Terminator<'tcx> {\n     /// well-known diverging block actually diverges.\n     Diverge,\n \n+    /// Indicates that the landing pad is finished and unwinding should\n+    /// continue. Emitted by build::scope::diverge_cleanup.\n+    Resume,\n+\n     /// Indicates a normal return. The ReturnPointer lvalue should\n     /// have been filled in by now. This should only occur in the\n     /// `END_BLOCK`.\n@@ -288,6 +292,14 @@ pub enum CallTargets {\n }\n \n impl CallTargets {\n+    pub fn new(ret: BasicBlock, cleanup: Option<BasicBlock>) -> CallTargets {\n+        if let Some(c) = cleanup {\n+            CallTargets::WithCleanup((ret, c))\n+        } else {\n+            CallTargets::Return(ret)\n+        }\n+    }\n+\n     pub fn as_slice(&self) -> &[BasicBlock] {\n         match *self {\n             CallTargets::Return(ref b) => slice::ref_slice(b),\n@@ -313,6 +325,7 @@ impl<'tcx> Terminator<'tcx> {\n             Switch { targets: ref b, .. } => b,\n             SwitchInt { targets: ref b, .. } => b,\n             Diverge => &[],\n+            Resume => &[],\n             Return => &[],\n             Call { targets: ref b, .. } => b.as_slice(),\n             DivergingCall { cleanup: ref b, .. } => if let Some(b) = b.as_ref() {\n@@ -332,6 +345,7 @@ impl<'tcx> Terminator<'tcx> {\n             Switch { targets: ref mut b, .. } => b,\n             SwitchInt { targets: ref mut b, .. } => b,\n             Diverge => &mut [],\n+            Resume => &mut [],\n             Return => &mut [],\n             Call { targets: ref mut b, .. } => b.as_mut_slice(),\n             DivergingCall { cleanup: ref mut b, .. } => if let Some(b) = b.as_mut() {\n@@ -393,6 +407,7 @@ impl<'tcx> Terminator<'tcx> {\n             SwitchInt { discr: ref lv, .. } => write!(fmt, \"switchInt({:?})\", lv),\n             Diverge => write!(fmt, \"diverge\"),\n             Return => write!(fmt, \"return\"),\n+            Resume => write!(fmt, \"resume\"),\n             Call { .. } => {\n                 // the author didn\u2019t bother rebasing this\n                 unimplemented!()\n@@ -408,7 +423,7 @@ impl<'tcx> Terminator<'tcx> {\n     pub fn fmt_successor_labels(&self) -> Vec<Cow<'static, str>> {\n         use self::Terminator::*;\n         match *self {\n-            Diverge | Return => vec![],\n+            Diverge | Return | Resume => vec![],\n             Goto { .. } | Panic { .. } => vec![\"\".into_cow()],\n             If { .. } => vec![\"true\".into_cow(), \"false\".into_cow()],\n             Call { .. } => vec![\"return\".into_cow(), \"unwind\".into_cow()],"}, {"sha": "41fd505682378c69220d00705fb003616f304d89", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecf4d0e3adbe77bd0e332645848dbd2505176a21/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecf4d0e3adbe77bd0e332645848dbd2505176a21/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=ecf4d0e3adbe77bd0e332645848dbd2505176a21", "patch": "@@ -134,6 +134,7 @@ pub trait Visitor<'tcx> {\n             }\n \n             Terminator::Diverge |\n+            Terminator::Resume |\n             Terminator::Return => {\n             }\n \n@@ -431,6 +432,7 @@ pub trait MutVisitor<'tcx> {\n             }\n \n             Terminator::Diverge |\n+            Terminator::Resume |\n             Terminator::Return => {\n             }\n "}, {"sha": "e23b5517cadf3a663d11de875043a54c1a15137c", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecf4d0e3adbe77bd0e332645848dbd2505176a21/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecf4d0e3adbe77bd0e332645848dbd2505176a21/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=ecf4d0e3adbe77bd0e332645848dbd2505176a21", "patch": "@@ -225,13 +225,13 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 let success = this.cfg.start_new_block();\n                 let cleanup = this.diverge_cleanup();\n                 let term = if diverges {\n-                    Terminator::DivergingCall { func: fun, args: args, cleanup: Some(cleanup) }\n+                    Terminator::DivergingCall { func: fun, args: args, cleanup: cleanup }\n                 } else {\n                     Terminator::Call {\n                         func: fun,\n                         args: args,\n                         destination: destination.clone(),\n-                        targets: CallTargets::WithCleanup((success, cleanup))\n+                        targets: CallTargets::new(success, cleanup)\n                     }\n                 };\n                 this.cfg.terminate(block, term);"}, {"sha": "e7f3794c043b0e2dbcd78014ec33423a64863e52", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ecf4d0e3adbe77bd0e332645848dbd2505176a21/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecf4d0e3adbe77bd0e332645848dbd2505176a21/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=ecf4d0e3adbe77bd0e332645848dbd2505176a21", "patch": "@@ -86,7 +86,7 @@ should go to.\n \n */\n \n-use build::{BlockAnd, BlockAndExtension, Builder, CFG};\n+use build::{BlockAnd, BlockAndExtension, Builder};\n use rustc::middle::region::CodeExtent;\n use rustc::middle::ty::Ty;\n use rustc::mir::repr::*;\n@@ -227,16 +227,44 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         self.cfg.terminate(block, Terminator::Goto { target: target });\n     }\n \n-    /// Creates a path that performs all required cleanup for\n-    /// unwinding. This path terminates in DIVERGE. Returns the start\n-    /// of the path. See module comment for more details.\n-    pub fn diverge_cleanup(&mut self) -> BasicBlock {\n-        diverge_cleanup_helper(&mut self.cfg, &mut self.scopes)\n+    /// Creates a path that performs all required cleanup for unwinding.\n+    ///\n+    /// This path terminates in Resume. Returns the start of the path.\n+    /// See module comment for more details. None indicates there\u2019s no\n+    /// cleanup to do at this point.\n+    pub fn diverge_cleanup(&mut self) -> Option<BasicBlock> {\n+        if self.scopes.is_empty() {\n+            return None;\n+        }\n+\n+        let mut terminator = Terminator::Resume;\n+        // Given an array of scopes, we generate these from the outermost scope to the innermost\n+        // one. Thus for array [S0, S1, S2] with corresponding cleanup blocks [B0, B1, B2], we will\n+        // generate B0 <- B1 <- B2 in left-to-right order. The outermost scope (B0) will always\n+        // terminate with a Resume terminator.\n+        for scope in self.scopes.iter_mut().filter(|s| !s.drops.is_empty()) {\n+            if let Some(b) = scope.cached_block {\n+                terminator = Terminator::Goto { target: b };\n+                continue;\n+            } else {\n+                let new_block = self.cfg.start_new_block();\n+                self.cfg.terminate(new_block, terminator);\n+                terminator = Terminator::Goto { target: new_block };\n+                for &(kind, span, ref lvalue) in scope.drops.iter().rev() {\n+                    self.cfg.push_drop(new_block, span, kind, lvalue);\n+                }\n+                scope.cached_block = Some(new_block);\n+            }\n+        }\n+        // Return the innermost cached block, most likely the one we just generated.\n+        // Note that if there are no cleanups in scope we return None.\n+        self.scopes.iter().rev().flat_map(|b| b.cached_block).next()\n     }\n \n     /// Create diverge cleanup and branch to it from `block`.\n     pub fn panic(&mut self, block: BasicBlock) {\n-        let cleanup = self.diverge_cleanup();\n+        // FIXME: panic terminator should also have conditional cleanup?\n+        let cleanup = self.diverge_cleanup().unwrap_or(DIVERGE_BLOCK);\n         self.cfg.terminate(block, Terminator::Panic { target: cleanup });\n     }\n \n@@ -249,14 +277,18 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                          lvalue: &Lvalue<'tcx>,\n                          lvalue_ty: Ty<'tcx>) {\n         if self.hir.needs_drop(lvalue_ty) {\n-            match self.scopes.iter_mut().rev().find(|s| s.extent == extent) {\n-                Some(scope) => {\n+            for scope in self.scopes.iter_mut().rev() {\n+                // We must invalidate all the cached_blocks leading up to the scope we\u2019re looking\n+                // for, because otherwise some/most of the blocks in the chain might become\n+                // incorrect (i.e. they still are pointing at old cached_block).\n+                scope.cached_block = None;\n+                if scope.extent == extent {\n                     scope.drops.push((kind, span, lvalue.clone()));\n-                    scope.cached_block = None;\n+                    return;\n                 }\n-                None => self.hir.span_bug(span, &format!(\"extent {:?} not in scope to drop {:?}\",\n-                                                         extent, lvalue)),\n             }\n+            self.hir.span_bug(span,\n+                              &format!(\"extent {:?} not in scope to drop {:?}\", extent, lvalue));\n         }\n     }\n \n@@ -268,28 +300,3 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         self.scopes.first().map(|scope| scope.extent).unwrap()\n     }\n }\n-\n-fn diverge_cleanup_helper<'tcx>(cfg: &mut CFG<'tcx>, scopes: &mut [Scope<'tcx>]) -> BasicBlock {\n-    let len = scopes.len();\n-\n-    if len == 0 {\n-        return DIVERGE_BLOCK;\n-    }\n-\n-    let (remaining, scope) = scopes.split_at_mut(len - 1);\n-    let scope = &mut scope[0];\n-\n-    if let Some(b) = scope.cached_block {\n-        return b;\n-    }\n-\n-    let block = cfg.start_new_block();\n-    for &(kind, span, ref lvalue) in &scope.drops {\n-        cfg.push_drop(block, span, kind, lvalue);\n-    }\n-    scope.cached_block = Some(block);\n-\n-    let remaining_cleanup_block = diverge_cleanup_helper(cfg, remaining);\n-    cfg.terminate(block, Terminator::Goto { target: remaining_cleanup_block });\n-    block\n-}"}, {"sha": "3f5e18b7e79689bcdd52ced4774c2660f2dada00", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ecf4d0e3adbe77bd0e332645848dbd2505176a21/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecf4d0e3adbe77bd0e332645848dbd2505176a21/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=ecf4d0e3adbe77bd0e332645848dbd2505176a21", "patch": "@@ -80,6 +80,7 @@ impl<'a, 'tcx> EraseRegions<'a, 'tcx> {\n         match *terminator {\n             Terminator::Goto { .. } |\n             Terminator::Diverge |\n+            Terminator::Resume |\n             Terminator::Return |\n             Terminator::Panic { .. } => {\n                 /* nothing to do */"}, {"sha": "ddd3ed34e8f93f0218a71b1c356d4329ee9e7dcf", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ecf4d0e3adbe77bd0e332645848dbd2505176a21/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecf4d0e3adbe77bd0e332645848dbd2505176a21/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=ecf4d0e3adbe77bd0e332645848dbd2505176a21", "patch": "@@ -87,16 +87,16 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             mir::Terminator::Diverge => {\n+                build::Unreachable(bcx);\n+            }\n+\n+            mir::Terminator::Resume => {\n                 if let Some(llpersonalityslot) = self.llpersonalityslot {\n                     let lp = build::Load(bcx, llpersonalityslot);\n                     // FIXME(lifetime) base::call_lifetime_end(bcx, self.personality);\n                     build::Resume(bcx, lp);\n                 } else {\n-                    // This fn never encountered anything fallible, so\n-                    // a Diverge cannot actually happen. Note that we\n-                    // do a total hack to ensure that we visit the\n-                    // DIVERGE block last.\n-                    build::Unreachable(bcx);\n+                    panic!(\"resume terminator without personality slot\")\n                 }\n             }\n "}]}