{"sha": "df39932090887086c2d7ce6aa8d30827ab458fd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmMzk5MzIwOTA4ODcwODZjMmQ3Y2U2YWE4ZDMwODI3YWI0NThmZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-29T23:46:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-29T23:46:32Z"}, "message": "auto merge of #7452 : dotdash/rust/self_indirection, r=cmr\n\nCurrently we pass all \"self\" arguments by reference, for the pointer\r\nvariants this means that we end up with double indirection which causes\r\na unnecessary performance hit.\r\n\r\nThe fix itself is pretty straight-forward and just means that \"self\"\r\nneeds to be handled like any other argument, except for by-value \"self\"\r\nwhich still needs to be passed by reference. This is because\r\nnon-pointer types can't just be stuffed into the environment slot which\r\nis used to pass \"self\".\r\n\r\nWhat made things tricky is that there was also a bug in the typechecker\r\nwhere the method map entries are created. For type impls, that stored\r\nthe base type instead of the actual self-type in the method map, e.g.\r\nFoo instead of &Foo for &self. That worked with pass-by-reference, but\r\nfails with pass-by-value which needs the real type.\r\n\r\nCode that makes use of methods seems to be about 10% faster with this\r\nchange. Also, build times are reduced by about 4%.\r\n\r\nFixes #4355, #4402, #5280, #4406 and #7285", "tree": {"sha": "f9fb7d5101731c4d7f8088e1c3277ee2aef19329", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9fb7d5101731c4d7f8088e1c3277ee2aef19329"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df39932090887086c2d7ce6aa8d30827ab458fd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df39932090887086c2d7ce6aa8d30827ab458fd1", "html_url": "https://github.com/rust-lang/rust/commit/df39932090887086c2d7ce6aa8d30827ab458fd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df39932090887086c2d7ce6aa8d30827ab458fd1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "439b13f071a4a884ea8645670df83162ffcf129f", "url": "https://api.github.com/repos/rust-lang/rust/commits/439b13f071a4a884ea8645670df83162ffcf129f", "html_url": "https://github.com/rust-lang/rust/commit/439b13f071a4a884ea8645670df83162ffcf129f"}, {"sha": "765a2901d58625f5995c9cf4a32c85b6573e12b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/765a2901d58625f5995c9cf4a32c85b6573e12b0", "html_url": "https://github.com/rust-lang/rust/commit/765a2901d58625f5995c9cf4a32c85b6573e12b0"}], "stats": {"total": 209, "additions": 82, "deletions": 127}, "files": [{"sha": "81a69dfca248c46aedfd090ad6eaf1775a78413a", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df39932090887086c2d7ce6aa8d30827ab458fd1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df39932090887086c2d7ce6aa8d30827ab458fd1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=df39932090887086c2d7ce6aa8d30827ab458fd1", "patch": "@@ -41,7 +41,6 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n             callee::trans_arg_expr(bcx,\n                                    expr_ty(bcx, out),\n                                    ty::ByCopy,\n-                                   ast::sty_static,\n                                    out,\n                                    &mut cleanups,\n                                    None,\n@@ -57,7 +56,6 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n             callee::trans_arg_expr(bcx,\n                                    expr_ty(bcx, e),\n                                    ty::ByCopy,\n-                                   ast::sty_static,\n                                    e,\n                                    &mut cleanups,\n                                    None,\n@@ -79,7 +77,6 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n             callee::trans_arg_expr(bcx,\n                                    expr_ty(bcx, in),\n                                    ty::ByCopy,\n-                                   ast::sty_static,\n                                    in,\n                                    &mut cleanups,\n                                    None,"}, {"sha": "60f4096cf9e5fb2a9062cd9bc64cce28d7b77c60", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/df39932090887086c2d7ce6aa8d30827ab458fd1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df39932090887086c2d7ce6aa8d30827ab458fd1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=df39932090887086c2d7ce6aa8d30827ab458fd1", "patch": "@@ -1626,18 +1626,11 @@ pub fn create_llargs_for_fn_args(cx: fn_ctxt,\n     let _icx = push_ctxt(\"create_llargs_for_fn_args\");\n \n     match self_arg {\n-      impl_self(tt) => {\n+      impl_self(tt, self_mode) => {\n         cx.llself = Some(ValSelfData {\n             v: cx.llenv,\n             t: tt,\n-            is_owned: false\n-        });\n-      }\n-      impl_owned_self(tt) => {\n-        cx.llself = Some(ValSelfData {\n-            v: cx.llenv,\n-            t: tt,\n-            is_owned: true\n+            is_copy: self_mode == ty::ByCopy\n         });\n       }\n       no_self => ()\n@@ -1676,12 +1669,18 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n \n     match fcx.llself {\n         Some(slf) => {\n-            let self_val = PointerCast(bcx, slf.v, type_of(bcx.ccx(), slf.t).ptr_to());\n-            fcx.llself = Some(ValSelfData {v: self_val, ..slf});\n+            let self_val = if slf.is_copy\n+                    && datum::appropriate_mode(slf.t).is_by_value() {\n+                let tmp = BitCast(bcx, slf.v, type_of(bcx.ccx(), slf.t));\n+                let alloc = alloc_ty(bcx, slf.t);\n+                Store(bcx, tmp, alloc);\n+                alloc\n+            } else {\n+                PointerCast(bcx, slf.v, type_of(bcx.ccx(), slf.t).ptr_to())\n+            };\n \n-            if slf.is_owned {\n-                add_clean(bcx, slf.v, slf.t);\n-            }\n+            fcx.llself = Some(ValSelfData {v: self_val, ..slf});\n+            add_clean(bcx, self_val, slf.t);\n         }\n         _ => {}\n     }\n@@ -1758,7 +1757,7 @@ pub fn tie_up_header_blocks(fcx: fn_ctxt, lltop: BasicBlockRef) {\n     }\n }\n \n-pub enum self_arg { impl_self(ty::t), impl_owned_self(ty::t), no_self, }\n+pub enum self_arg { impl_self(ty::t, ty::SelfMode), no_self, }\n \n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be"}, {"sha": "ffeb4f2754af2470ef94cf9d1ec52a94453434c6", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 19, "deletions": 33, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/df39932090887086c2d7ce6aa8d30827ab458fd1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df39932090887086c2d7ce6aa8d30827ab458fd1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=df39932090887086c2d7ce6aa8d30827ab458fd1", "patch": "@@ -62,9 +62,9 @@ pub struct FnData {\n pub struct MethodData {\n     llfn: ValueRef,\n     llself: ValueRef,\n+    temp_cleanup: Option<ValueRef>,\n     self_ty: ty::t,\n     self_mode: ty::SelfMode,\n-    explicit_self: ast::explicit_self_\n }\n \n pub enum CalleeData {\n@@ -615,10 +615,7 @@ pub fn trans_call_inner(in_cx: block,\n                 }\n                 Method(d) => {\n                     // Weird but true: we pass self in the *environment* slot!\n-                    let llself = PointerCast(bcx,\n-                                             d.llself,\n-                                             Type::opaque_box(ccx).ptr_to());\n-                    (d.llfn, llself)\n+                    (d.llfn, d.llself)\n                 }\n                 Closure(d) => {\n                     // Closures are represented as (llfn, llclosure) pair:\n@@ -647,11 +644,12 @@ pub fn trans_call_inner(in_cx: block,\n \n \n         // Now that the arguments have finished evaluating, we need to revoke\n-        // the cleanup for the self argument, if it exists\n+        // the cleanup for the self argument\n         match callee.data {\n-            Method(d) if d.self_mode == ty::ByCopy ||\n-                         d.explicit_self == ast::sty_value => {\n-                revoke_clean(bcx, d.llself);\n+            Method(d) => {\n+                for d.temp_cleanup.iter().advance |&v| {\n+                    revoke_clean(bcx, v);\n+                }\n             }\n             _ => {}\n         }\n@@ -772,7 +770,6 @@ pub fn trans_args(cx: block,\n                 trans_arg_expr(bcx,\n                                arg_tys[i],\n                                ty::ByCopy,\n-                               ast::sty_static,\n                                *arg_expr,\n                                &mut temp_cleanups,\n                                if i == last { ret_flag } else { None },\n@@ -806,18 +803,16 @@ pub enum AutorefArg {\n pub fn trans_arg_expr(bcx: block,\n                       formal_arg_ty: ty::t,\n                       self_mode: ty::SelfMode,\n-                      ex_self: ast::explicit_self_,\n                       arg_expr: @ast::expr,\n                       temp_cleanups: &mut ~[ValueRef],\n                       ret_flag: Option<ValueRef>,\n                       autoref_arg: AutorefArg) -> Result {\n     let _icx = push_ctxt(\"trans_arg_expr\");\n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_arg_expr(formal_arg_ty=(%s), explicit_self=%? self_mode=%?, arg_expr=%s, \\\n+    debug!(\"trans_arg_expr(formal_arg_ty=(%s), self_mode=%?, arg_expr=%s, \\\n             ret_flag=%?)\",\n            formal_arg_ty.repr(bcx.tcx()),\n-           ex_self,\n            self_mode,\n            arg_expr.repr(bcx.tcx()),\n            ret_flag.map(|v| bcx.val_to_str(*v)));\n@@ -877,9 +872,15 @@ pub fn trans_arg_expr(bcx: block,\n                 val = arg_datum.to_ref_llval(bcx);\n             }\n             DontAutorefArg => {\n-                match (self_mode, ex_self) {\n-                    (ty::ByRef, ast::sty_value) => {\n-                        debug!(\"by value self with type %s, storing to scratch\",\n+                match self_mode {\n+                    ty::ByRef => {\n+                        // This assertion should really be valid, but because\n+                        // the explicit self code currently passes by-ref, it\n+                        // does not hold.\n+                        //\n+                        //assert !bcx.ccx().maps.moves_map.contains_key(\n+                        //    &arg_expr.id);\n+                        debug!(\"by ref arg with type %s, storing to scratch\",\n                                bcx.ty_to_str(arg_datum.ty));\n                         let scratch = scratch_datum(bcx, arg_datum.ty, false);\n \n@@ -896,18 +897,7 @@ pub fn trans_arg_expr(bcx: block,\n \n                         val = scratch.to_ref_llval(bcx);\n                     }\n-                    (ty::ByRef, _) => {\n-                        // This assertion should really be valid, but because\n-                        // the explicit self code currently passes by-ref, it\n-                        // does not hold.\n-                        //\n-                        //assert !bcx.ccx().maps.moves_map.contains_key(\n-                        //    &arg_expr.id);\n-                        debug!(\"by ref arg with type %s\",\n-                               bcx.ty_to_str(arg_datum.ty));\n-                        val = arg_datum.to_ref_llval(bcx);\n-                    }\n-                    (ty::ByCopy, _) => {\n+                    ty::ByCopy => {\n                         if ty::type_needs_drop(bcx.tcx(), arg_datum.ty) ||\n                                 arg_datum.appropriate_mode().is_by_ref() {\n                             debug!(\"by copy arg with type %s, storing to scratch\",\n@@ -930,7 +920,7 @@ pub fn trans_arg_expr(bcx: block,\n                                 ByRef(_) => val = scratch.val,\n                             }\n                         } else {\n-                            debug!(\"by copy arg with type %s\");\n+                            debug!(\"by copy arg with type %s\", bcx.ty_to_str(arg_datum.ty));\n                             match arg_datum.mode {\n                                 ByRef(_) => val = Load(bcx, arg_datum.val),\n                                 ByValue => val = arg_datum.val,\n@@ -944,10 +934,6 @@ pub fn trans_arg_expr(bcx: block,\n         if formal_arg_ty != arg_datum.ty {\n             // this could happen due to e.g. subtyping\n             let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, &formal_arg_ty);\n-            let llformal_arg_ty = match self_mode {\n-                ty::ByRef => llformal_arg_ty.ptr_to(),\n-                ty::ByCopy => llformal_arg_ty,\n-            };\n             debug!(\"casting actual type (%s) to match formal (%s)\",\n                    bcx.val_to_str(val), bcx.llty_str(llformal_arg_ty));\n             val = PointerCast(bcx, val, llformal_arg_ty);"}, {"sha": "229cacef2fedf30d0b5e9cb826a0485cd12db1b0", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df39932090887086c2d7ce6aa8d30827ab458fd1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df39932090887086c2d7ce6aa8d30827ab458fd1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=df39932090887086c2d7ce6aa8d30827ab458fd1", "patch": "@@ -125,7 +125,7 @@ pub type ExternMap = HashMap<@str, ValueRef>;\n pub struct ValSelfData {\n     v: ValueRef,\n     t: ty::t,\n-    is_owned: bool\n+    is_copy: bool,\n }\n \n // Here `self_ty` is the real type of the self parameter to this method. It"}, {"sha": "9ca174d3f2de2ecf04bf1012345692a399befff5", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/df39932090887086c2d7ce6aa8d30827ab458fd1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df39932090887086c2d7ce6aa8d30827ab458fd1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=df39932090887086c2d7ce6aa8d30827ab458fd1", "patch": "@@ -425,12 +425,7 @@ pub fn trans_struct_drop_flag(bcx: block, t: ty::t, v0: ValueRef, dtor_did: ast:\n         // just consist of the environment (self)\n         assert_eq!(params.len(), 1);\n \n-        // Take a reference to the class (because it's using the Drop trait),\n-        // do so now.\n-        let llval = alloca(bcx, val_ty(v0));\n-        Store(bcx, v0, llval);\n-\n-        let self_arg = PointerCast(bcx, llval, params[0]);\n+        let self_arg = PointerCast(bcx, v0, params[0]);\n         let args = ~[self_arg];\n \n         Call(bcx, dtor_addr, args);\n@@ -465,12 +460,7 @@ pub fn trans_struct_drop(mut bcx: block, t: ty::t, v0: ValueRef, dtor_did: ast::\n     // just consist of the environment (self)\n     assert_eq!(params.len(), 1);\n \n-    // Take a reference to the class (because it's using the Drop trait),\n-    // do so now.\n-    let llval = alloca(bcx, val_ty(v0));\n-    Store(bcx, v0, llval);\n-\n-    let self_arg = PointerCast(bcx, llval, params[0]);\n+    let self_arg = PointerCast(bcx, v0, params[0]);\n     let args = ~[self_arg];\n \n     Call(bcx, dtor_addr, args);"}, {"sha": "0d7b5d5ed5afd6b3f1b8e7bdb24ab2c4d1b22059", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df39932090887086c2d7ce6aa8d30827ab458fd1/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df39932090887086c2d7ce6aa8d30827ab458fd1/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=df39932090887086c2d7ce6aa8d30827ab458fd1", "patch": "@@ -12,7 +12,7 @@ use core::prelude::*;\n \n use metadata::csearch;\n use middle::astencode;\n-use middle::trans::base::{push_ctxt,impl_owned_self, impl_self, no_self};\n+use middle::trans::base::{push_ctxt, impl_self, no_self};\n use middle::trans::base::{trans_item, get_item_val, trans_fn};\n use middle::trans::common::*;\n use middle::ty;\n@@ -114,8 +114,8 @@ pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::def_id,\n                       debug!(\"calling inline trans_fn with self_ty %s\",\n                              ty_to_str(ccx.tcx, self_ty));\n                       match mth.explicit_self.node {\n-                          ast::sty_value => impl_owned_self(self_ty),\n-                          _ => impl_self(self_ty),\n+                          ast::sty_value => impl_self(self_ty, ty::ByRef),\n+                          _ => impl_self(self_ty, ty::ByCopy),\n                       }\n                   }\n               };"}, {"sha": "65e4859b217511658fac94c1d51508c65d0f7167", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 34, "deletions": 56, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/df39932090887086c2d7ce6aa8d30827ab458fd1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df39932090887086c2d7ce6aa8d30827ab458fd1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=df39932090887086c2d7ce6aa8d30827ab458fd1", "patch": "@@ -20,6 +20,7 @@ use middle::trans::build::*;\n use middle::trans::callee::*;\n use middle::trans::callee;\n use middle::trans::common::*;\n+use middle::trans::datum::*;\n use middle::trans::expr::{SaveIn, Ignore};\n use middle::trans::expr;\n use middle::trans::glue;\n@@ -107,10 +108,8 @@ pub fn trans_method(ccx: @mut CrateContext,\n         debug!(\"calling trans_fn with self_ty %s\",\n                self_ty.repr(ccx.tcx));\n         match method.explicit_self.node {\n-          ast::sty_value => impl_owned_self(self_ty),\n-          _ => {\n-            impl_self(self_ty)\n-          }\n+          ast::sty_value => impl_self(self_ty, ty::ByRef),\n+          _ => impl_self(self_ty, ty::ByCopy),\n         }\n       }\n     };\n@@ -129,28 +128,19 @@ pub fn trans_method(ccx: @mut CrateContext,\n \n pub fn trans_self_arg(bcx: block,\n                       base: @ast::expr,\n+                      temp_cleanups: &mut ~[ValueRef],\n                       mentry: typeck::method_map_entry) -> Result {\n     let _icx = push_ctxt(\"impl::trans_self_arg\");\n-    let mut temp_cleanups = ~[];\n-\n-    // Compute the type of self.\n-    let self_ty = monomorphize_type(bcx, mentry.self_ty);\n-    let result = trans_arg_expr(bcx,\n-                                self_ty,\n-                                mentry.self_mode,\n-                                mentry.explicit_self,\n-                                base,\n-                                &mut temp_cleanups,\n-                                None,\n-                                DontAutorefArg);\n \n-    // FIXME(#3446)---this is wrong, actually.  The temp_cleanups\n-    // should be revoked only after all arguments have been passed.\n-    for temp_cleanups.iter().advance |c| {\n-        revoke_clean(bcx, *c)\n-    }\n-\n-    return result;\n+    // self is passed as an opaque box in the environment slot\n+    let self_ty = ty::mk_opaque_box(bcx.tcx());\n+    trans_arg_expr(bcx,\n+                   self_ty,\n+                   mentry.self_mode,\n+                   base,\n+                   temp_cleanups,\n+                   None,\n+                   DontAutorefArg)\n }\n \n pub fn trans_method_callee(bcx: block,\n@@ -203,15 +193,16 @@ pub fn trans_method_callee(bcx: block,\n     match origin {\n         typeck::method_static(did) => {\n             let callee_fn = callee::trans_fn_ref(bcx, did, callee_id);\n-            let Result {bcx, val} = trans_self_arg(bcx, this, mentry);\n+            let mut temp_cleanups = ~[];\n+            let Result {bcx, val} = trans_self_arg(bcx, this, &mut temp_cleanups, mentry);\n             Callee {\n                 bcx: bcx,\n                 data: Method(MethodData {\n                     llfn: callee_fn.llfn,\n                     llself: val,\n+                    temp_cleanup: temp_cleanups.head_opt().map(|&v| *v),\n                     self_ty: node_id_type(bcx, this.id),\n                     self_mode: mentry.self_mode,\n-                    explicit_self: mentry.explicit_self\n                 })\n             }\n         }\n@@ -254,9 +245,8 @@ pub fn trans_method_callee(bcx: block,\n                                store,\n                                mentry.explicit_self)\n         }\n-            typeck::method_super(*) => {\n-            fail!(\"method_super should have been handled \\\n-                   above\")\n+        typeck::method_super(*) => {\n+            fail!(\"method_super should have been handled above\")\n         }\n     }\n }\n@@ -413,8 +403,9 @@ pub fn trans_monomorphized_callee(bcx: block,\n               bcx.ccx(), impl_did, mname);\n \n           // obtain the `self` value:\n+          let mut temp_cleanups = ~[];\n           let Result {bcx, val: llself_val} =\n-              trans_self_arg(bcx, base, mentry);\n+              trans_self_arg(bcx, base, &mut temp_cleanups, mentry);\n \n           // create a concatenated set of substitutions which includes\n           // those from the impl and those from the method:\n@@ -441,9 +432,9 @@ pub fn trans_monomorphized_callee(bcx: block,\n               data: Method(MethodData {\n                   llfn: llfn_val,\n                   llself: llself_val,\n+                  temp_cleanup: temp_cleanups.head_opt().map(|&v| *v),\n                   self_ty: node_id_type(bcx, base.id),\n                   self_mode: mentry.self_mode,\n-                  explicit_self: mentry.explicit_self\n               })\n           }\n       }\n@@ -573,10 +564,10 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n     // necessary:\n     let mut llself;\n     debug!(\"(translating trait callee) loading second index from pair\");\n-    let llbox = Load(bcx, GEPi(bcx, llpair, [0u, abi::trt_field_box]));\n+    let llboxptr = GEPi(bcx, llpair, [0u, abi::trt_field_box]);\n+    let llbox = Load(bcx, llboxptr);\n \n     // Munge `llself` appropriately for the type of `self` in the method.\n-    let self_mode;\n     match explicit_self {\n         ast::sty_static => {\n             bcx.tcx().sess.bug(\"shouldn't see static method here\");\n@@ -586,8 +577,6 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n                                 called on objects\");\n         }\n         ast::sty_region(*) => {\n-            // As before, we need to pass a pointer to a pointer to the\n-            // payload.\n             match store {\n                 ty::BoxTraitStore |\n                 ty::UniqTraitStore => {\n@@ -597,30 +586,18 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n                     llself = llbox;\n                 }\n             }\n-\n-            let llscratch = alloca(bcx, val_ty(llself));\n-            Store(bcx, llself, llscratch);\n-            llself = llscratch;\n-\n-            self_mode = ty::ByRef;\n         }\n         ast::sty_box(_) => {\n             // Bump the reference count on the box.\n             debug!(\"(translating trait callee) callee type is `%s`\",\n                    bcx.ty_to_str(callee_ty));\n-            bcx = glue::take_ty(bcx, llbox, callee_ty);\n+            glue::incr_refcnt_of_boxed(bcx, llbox);\n \n             // Pass a pointer to the box.\n             match store {\n                 ty::BoxTraitStore => llself = llbox,\n                 _ => bcx.tcx().sess.bug(\"@self receiver with non-@Trait\")\n             }\n-\n-            let llscratch = alloca(bcx, val_ty(llself));\n-            Store(bcx, llself, llscratch);\n-            llself = llscratch;\n-\n-            self_mode = ty::ByRef;\n         }\n         ast::sty_uniq => {\n             // Pass the unique pointer.\n@@ -629,14 +606,15 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n                 _ => bcx.tcx().sess.bug(\"~self receiver with non-~Trait\")\n             }\n \n-            let llscratch = alloca(bcx, val_ty(llself));\n-            Store(bcx, llself, llscratch);\n-            llself = llscratch;\n-\n-            self_mode = ty::ByRef;\n+            zero_mem(bcx, llboxptr, ty::mk_opaque_box(bcx.tcx()));\n         }\n     }\n \n+    llself = PointerCast(bcx, llself, Type::opaque_box(ccx).ptr_to());\n+    let scratch = scratch_datum(bcx, ty::mk_opaque_box(bcx.tcx()), false);\n+    Store(bcx, llself, scratch.val);\n+    scratch.add_clean(bcx);\n+\n     // Load the function from the vtable and cast it to the expected type.\n     debug!(\"(translating trait callee) loading method\");\n     let llcallee_ty = type_of_fn_from_ty(ccx, callee_ty);\n@@ -650,10 +628,10 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n         bcx: bcx,\n         data: Method(MethodData {\n             llfn: mptr,\n-            llself: llself,\n-            self_ty: ty::mk_opaque_box(bcx.tcx()),\n-            self_mode: self_mode,\n-            explicit_self: explicit_self\n+            llself: scratch.to_value_llval(bcx),\n+            temp_cleanup: Some(scratch.val),\n+            self_ty: scratch.ty,\n+            self_mode: ty::ByCopy,\n             /* XXX: Some(llbox) */\n         })\n     };"}, {"sha": "d6d2a15abd620e2e9d94bc2da6027582971c0c4b", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/df39932090887086c2d7ce6aa8d30827ab458fd1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df39932090887086c2d7ce6aa8d30827ab458fd1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=df39932090887086c2d7ce6aa8d30827ab458fd1", "patch": "@@ -976,9 +976,7 @@ impl<'self> LookupContext<'self> {\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {sig: fn_sig, ..bare_fn_ty});\n         debug!(\"after replacing bound regions, fty=%s\", self.ty_to_str(fty));\n \n-        // FIXME(#7411): We always pass self by-ref since we stuff it in the environment slot.\n-        // Eventually that should not be the case\n-        let self_mode = ty::ByRef;\n+        let self_mode = get_mode_from_explicit_self(candidate.method_ty.explicit_self);\n \n         // before we only checked whether self_ty could be a subtype\n         // of rcvr_ty; now we actually make it so (this may cause\n@@ -998,7 +996,7 @@ impl<'self> LookupContext<'self> {\n         self.fcx.write_ty(self.callee_id, fty);\n         self.fcx.write_substs(self.callee_id, all_substs);\n         method_map_entry {\n-            self_ty: candidate.rcvr_ty,\n+            self_ty: rcvr_ty,\n             self_mode: self_mode,\n             explicit_self: candidate.method_ty.explicit_self,\n             origin: candidate.origin,\n@@ -1253,3 +1251,10 @@ impl<'self> LookupContext<'self> {\n         self.tcx().sess.bug(s)\n     }\n }\n+\n+pub fn get_mode_from_explicit_self(explicit_self: ast::explicit_self_) -> SelfMode {\n+    match explicit_self {\n+        sty_value => ty::ByRef,\n+        _ => ty::ByCopy,\n+    }\n+}"}]}