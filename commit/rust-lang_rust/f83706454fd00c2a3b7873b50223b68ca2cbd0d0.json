{"sha": "f83706454fd00c2a3b7873b50223b68ca2cbd0d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4MzcwNjQ1NGZkMDBjMmEzYjc4NzNiNTAyMjNiNjhjYTJjYmQwZDA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-24T15:48:44Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-30T11:55:29Z"}, "message": "coercion now depends on whether the expression diverges\n\nBefore I was checking this in `demand_coerce` but that's not really the\nright place. The right place is to move that into the coercion routine\nitself.", "tree": {"sha": "6f84bed551903fe2500fed322e07c8055c4bcb3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f84bed551903fe2500fed322e07c8055c4bcb3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f83706454fd00c2a3b7873b50223b68ca2cbd0d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f83706454fd00c2a3b7873b50223b68ca2cbd0d0", "html_url": "https://github.com/rust-lang/rust/commit/f83706454fd00c2a3b7873b50223b68ca2cbd0d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f83706454fd00c2a3b7873b50223b68ca2cbd0d0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bad79484fb99d40f48e3b84776699526a37513e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/bad79484fb99d40f48e3b84776699526a37513e0", "html_url": "https://github.com/rust-lang/rust/commit/bad79484fb99d40f48e3b84776699526a37513e0"}], "stats": {"total": 92, "additions": 55, "deletions": 37}, "files": [{"sha": "e83b786b9a8387dd33059e9c25d5efec1de8935a", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f83706454fd00c2a3b7873b50223b68ca2cbd0d0/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83706454fd00c2a3b7873b50223b68ca2cbd0d0/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=f83706454fd00c2a3b7873b50223b68ca2cbd0d0", "patch": "@@ -504,7 +504,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     arm_span: arm.body.span,\n                     source: match_src\n                 });\n-                coercion.coerce(self, &cause, &arm.body, arm_ty);\n+                coercion.coerce(self, &cause, &arm.body, arm_ty, self.diverges.get());\n             }\n         }\n "}, {"sha": "ea0aad007dd73700587d9a93b4b59d22b02e6dc7", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f83706454fd00c2a3b7873b50223b68ca2cbd0d0/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83706454fd00c2a3b7873b50223b68ca2cbd0d0/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=f83706454fd00c2a3b7873b50223b68ca2cbd0d0", "patch": "@@ -38,7 +38,7 @@\n //! expression, `e as U2` is not necessarily so (in fact it will only be valid if\n //! `U1` coerces to `U2`).\n \n-use super::FnCtxt;\n+use super::{Diverges, FnCtxt};\n \n use lint;\n use hir::def_id::DefId;\n@@ -376,7 +376,10 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             (None, Some(t_cast)) => {\n                 if let ty::TyFnDef(.., f) = self.expr_ty.sty {\n                     // Attempt a coercion to a fn pointer type.\n-                    let res = fcx.try_coerce(self.expr, self.expr_ty, fcx.tcx.mk_fn_ptr(f));\n+                    let res = fcx.try_coerce(self.expr,\n+                                             self.expr_ty,\n+                                             Diverges::Maybe, // TODO\n+                                             fcx.tcx.mk_fn_ptr(f));\n                     if !res.is_ok() {\n                         return Err(CastError::NonScalar);\n                     }\n@@ -542,7 +545,8 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn try_coercion_cast(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        fcx.try_coerce(self.expr, self.expr_ty, self.cast_ty).is_ok()\n+        // TODO\n+        fcx.try_coerce(self.expr, self.expr_ty, Diverges::Maybe, self.cast_ty).is_ok()\n     }\n }\n "}, {"sha": "a737b82700e347c819ab09fc931b9c3464a9b1f6", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f83706454fd00c2a3b7873b50223b68ca2cbd0d0/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83706454fd00c2a3b7873b50223b68ca2cbd0d0/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=f83706454fd00c2a3b7873b50223b68ca2cbd0d0", "patch": "@@ -60,7 +60,7 @@\n //! sort of a minor point so I've opted to leave it for later---after all\n //! we may want to adjust precisely when coercions occur.\n \n-use check::FnCtxt;\n+use check::{Diverges, FnCtxt};\n \n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -156,7 +156,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn coerce<E>(&self, exprs: &[E], a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx>\n+    fn coerce<E>(&self,\n+                 exprs: &[E],\n+                 a: Ty<'tcx>,\n+                 b: Ty<'tcx>)\n+                 -> CoerceResult<'tcx>\n         where E: AsCoercionSite\n     {\n         let a = self.shallow_resolve(a);\n@@ -689,11 +693,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn try_coerce(&self,\n                       expr: &hir::Expr,\n                       expr_ty: Ty<'tcx>,\n+                      expr_diverges: Diverges,\n                       target: Ty<'tcx>)\n                       -> RelateResult<'tcx, Ty<'tcx>> {\n         let source = self.resolve_type_vars_with_obligations(expr_ty);\n         debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n \n+        // Special-ish case: we can coerce any type `T` into the `!`\n+        // type, but only if the source expression diverges.\n+        if target.is_never() && expr_diverges.always() {\n+            debug!(\"permit coercion to `!` because expr diverges\");\n+            return Ok(target);\n+        }\n+\n         let cause = self.cause(expr.span, ObligationCauseCode::ExprAssignable);\n         let coerce = Coerce::new(self, cause);\n         self.commit_if_ok(|_| {\n@@ -721,15 +733,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 exprs: &[E],\n                                 prev_ty: Ty<'tcx>,\n                                 new: &hir::Expr,\n-                                new_ty: Ty<'tcx>)\n+                                new_ty: Ty<'tcx>,\n+                                new_diverges: Diverges)\n                                 -> RelateResult<'tcx, Ty<'tcx>>\n         where E: AsCoercionSite\n     {\n-\n         let prev_ty = self.resolve_type_vars_with_obligations(prev_ty);\n         let new_ty = self.resolve_type_vars_with_obligations(new_ty);\n         debug!(\"coercion::try_find_lub({:?}, {:?})\", prev_ty, new_ty);\n \n+        // Special-ish case: we can coerce any type `T` into the `!`\n+        // type, but only if the source expression diverges.\n+        if prev_ty.is_never() && new_diverges.always() {\n+            debug!(\"permit coercion to `!` because expr diverges\");\n+            return Ok(prev_ty);\n+        }\n+\n         let trace = TypeTrace::types(cause, true, prev_ty, new_ty);\n \n         // Special-case that coercion alone cannot handle:\n@@ -982,9 +1001,10 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                       fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                       cause: &ObligationCause<'tcx>,\n                       expression: &'gcx hir::Expr,\n-                      expression_ty: Ty<'tcx>)\n+                      expression_ty: Ty<'tcx>,\n+                      expression_diverges: Diverges)\n     {\n-        self.coerce_inner(fcx, cause, Some(expression), expression_ty)\n+        self.coerce_inner(fcx, cause, Some(expression), expression_ty, expression_diverges)\n     }\n \n     /// Indicates that one of the inputs is a \"forced unit\". This\n@@ -1002,7 +1022,8 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n         self.coerce_inner(fcx,\n                           cause,\n                           None,\n-                          fcx.tcx.mk_nil())\n+                          fcx.tcx.mk_nil(),\n+                          Diverges::Maybe)\n     }\n \n     /// The inner coercion \"engine\". If `expression` is `None`, this\n@@ -1012,7 +1033,8 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                         fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                         cause: &ObligationCause<'tcx>,\n                         expression: Option<&'gcx hir::Expr>,\n-                        mut expression_ty: Ty<'tcx>)\n+                        mut expression_ty: Ty<'tcx>,\n+                        expression_diverges: Diverges)\n     {\n         // Incorporate whatever type inference information we have\n         // until now; in principle we might also want to process\n@@ -1035,21 +1057,23 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n             if self.pushed == 0 {\n                 // Special-case the first expression we are coercing.\n                 // To be honest, I'm not entirely sure why we do this.\n-                fcx.try_coerce(expression, expression_ty, self.expected_ty)\n+                fcx.try_coerce(expression, expression_ty, expression_diverges, self.expected_ty)\n             } else {\n                 match self.expressions {\n                     Expressions::Dynamic(ref exprs) =>\n                         fcx.try_find_coercion_lub(cause,\n                                                   exprs,\n                                                   self.merged_ty(),\n                                                   expression,\n-                                                  expression_ty),\n+                                                  expression_ty,\n+                                                  expression_diverges),\n                     Expressions::UpFront(ref coercion_sites) =>\n                         fcx.try_find_coercion_lub(cause,\n                                                   &coercion_sites[0..self.pushed],\n                                                   self.merged_ty(),\n                                                   expression,\n-                                                  expression_ty),\n+                                                  expression_ty,\n+                                                  expression_diverges),\n                 }\n             }\n         } else {"}, {"sha": "e922c7447ff85384ceb3b9822e9f9058482ec33d", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f83706454fd00c2a3b7873b50223b68ca2cbd0d0/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83706454fd00c2a3b7873b50223b68ca2cbd0d0/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=f83706454fd00c2a3b7873b50223b68ca2cbd0d0", "patch": "@@ -77,21 +77,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          expected: Ty<'tcx>) {\n         let expected = self.resolve_type_vars_with_obligations(expected);\n \n-        // If we are \"assigning\" to a `!` location, then we can permit\n-        // any type to be assigned there, so long as we are in\n-        // dead-code. This applies to e.g. `fn foo() -> ! { return; 22\n-        // }` but also `fn foo() { let x: ! = { return; 22 }; }`.\n-        //\n-        // You might imagine that we could just *always* bail if we\n-        // are in dead-code, but we don't want to do that, because\n-        // that leaves a lot of type variables unconstrained. See\n-        // e.g. #39808 and #39984.\n-        let in_dead_code = self.diverges.get().always();\n-        if expected.is_never() && in_dead_code {\n-            return;\n-        }\n-\n-        if let Err(e) = self.try_coerce(expr, checked_ty, expected) {\n+        if let Err(e) = self.try_coerce(expr, checked_ty, self.diverges.get(), expected) {\n             let cause = self.misc(expr.span);\n             let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n             let mode = probe::Mode::MethodCall;"}, {"sha": "539f16ec6709b78d77fd80a0eeb5df1852a7b395", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f83706454fd00c2a3b7873b50223b68ca2cbd0d0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83706454fd00c2a3b7873b50223b68ca2cbd0d0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f83706454fd00c2a3b7873b50223b68ca2cbd0d0", "patch": "@@ -366,7 +366,7 @@ impl UnsafetyState {\n /// as diverging), with some manual adjustments for control-flow\n /// primitives (approximating a CFG).\n #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n-enum Diverges {\n+pub enum Diverges {\n     /// Potentially unknown, some cases converge,\n     /// others require a CFG to determine them.\n     Maybe,\n@@ -2833,7 +2833,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     .coerce(self,\n                             &self.misc(return_expr.span),\n                             return_expr,\n-                            return_expr_ty);\n+                            return_expr_ty,\n+                            self.diverges.get());\n     }\n \n \n@@ -2864,13 +2865,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut coerce: DynamicCoerceMany = CoerceMany::new(coerce_to_ty);\n \n         let if_cause = self.cause(sp, ObligationCauseCode::IfExpression);\n-        coerce.coerce(self, &if_cause, then_expr, then_ty);\n+        coerce.coerce(self, &if_cause, then_expr, then_ty, then_diverges);\n \n         if let Some(else_expr) = opt_else_expr {\n             let else_ty = self.check_expr_with_expectation(else_expr, expected);\n             let else_diverges = self.diverges.get();\n \n-            coerce.coerce(self, &if_cause, else_expr, else_ty);\n+            coerce.coerce(self, &if_cause, else_expr, else_ty, else_diverges);\n \n             // We won't diverge unless both branches do (or the condition does).\n             self.diverges.set(cond_diverges | then_diverges & else_diverges);\n@@ -3553,7 +3554,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           }\n           hir::ExprBreak(destination, ref expr_opt) => {\n               if let Some(target_id) = destination.target_id.opt_id() {\n-                  let (e_ty, cause);\n+                  let (e_ty, e_diverges, cause);\n                   if let Some(ref e) = *expr_opt {\n                       // If this is a break with a value, we need to type-check\n                       // the expression. Get an expected type from the loop context.\n@@ -3572,11 +3573,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                       // Recurse without `enclosing_breakables` borrowed.\n                       e_ty = self.check_expr_with_hint(e, coerce_to);\n+                      e_diverges = self.diverges.get();\n                       cause = self.misc(e.span);\n                   } else {\n                       // Otherwise, this is a break *without* a value. That's\n                       // always legal, and is equivalent to `break ()`.\n                       e_ty = tcx.mk_nil();\n+                      e_diverges = Diverges::Maybe;\n                       cause = self.misc(expr.span);\n                   }\n \n@@ -3587,7 +3590,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   let ctxt = enclosing_breakables.find_breakable(target_id);\n                   if let Some(ref mut coerce) = ctxt.coerce {\n                       if let Some(ref e) = *expr_opt {\n-                          coerce.coerce(self, &cause, e, e_ty);\n+                          coerce.coerce(self, &cause, e, e_ty, e_diverges);\n                       } else {\n                           assert!(e_ty.is_nil());\n                           coerce.coerce_forced_unit(self, &cause);\n@@ -3769,10 +3772,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   let coerce_to = uty.unwrap_or_else(\n                       || self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span)));\n                   let mut coerce = CoerceMany::with_coercion_sites(coerce_to, args);\n+                  assert_eq!(self.diverges.get(), Diverges::Maybe);\n                   for e in args {\n                       let e_ty = self.check_expr_with_hint(e, coerce_to);\n                       let cause = self.misc(e.span);\n-                      coerce.coerce(self, &cause, e, e_ty);\n+                      coerce.coerce(self, &cause, e, e_ty, self.diverges.get());\n                   }\n                   coerce.complete(self)\n               } else {"}]}