{"sha": "47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3YmM3NzRhYjZiMjNmMGUwMWJmNDY3MmQzNmVkOWY4ZDdlM2U3OTg=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-05-16T21:58:08Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-05-17T00:35:39Z"}, "message": "Avoid allocations in `opt_normalize_projection_type`.\n\nThis patch changes `opt_normalize_project_type` so it appends\nobligations to a given obligations vector, instead of returning a new\nobligations vector.\n\nThis change avoids lots of allocations. In the most extreme case, for a\nclean \"Check\" build of serde it reduces the total number of allocations\nby 20%.", "tree": {"sha": "539b7294e5662af08a05ab06431ae2f33b768f4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/539b7294e5662af08a05ab06431ae2f33b768f4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798", "html_url": "https://github.com/rust-lang/rust/commit/47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f778bdefdd9663aa78c31ffc7773e31bcae4fb39", "url": "https://api.github.com/repos/rust-lang/rust/commits/f778bdefdd9663aa78c31ffc7773e31bcae4fb39", "html_url": "https://github.com/rust-lang/rust/commit/f778bdefdd9663aa78c31ffc7773e31bcae4fb39"}], "stats": {"total": 199, "additions": 108, "deletions": 91}, "files": [{"sha": "e10379ea176857e54b48c842e878fe370a9346a6", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798", "patch": "@@ -202,17 +202,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     obligation.cause.span,\n                     infer::LateBoundRegionConversionTime::HigherRankedType,\n                     data);\n-                let normalized = super::normalize_projection_type(\n+                let mut obligations = vec![];\n+                let normalized_ty = super::normalize_projection_type(\n                     &mut selcx,\n                     obligation.param_env,\n                     data.projection_ty,\n                     obligation.cause.clone(),\n-                    0\n+                    0,\n+                    &mut obligations\n                 );\n                 if let Err(error) = self.at(&obligation.cause, obligation.param_env)\n-                                        .eq(normalized.value, data.ty) {\n+                                        .eq(normalized_ty, data.ty) {\n                     values = Some(infer::ValuePairs::Types(ExpectedFound {\n-                        expected: normalized.value,\n+                        expected: normalized_ty,\n                         found: data.ty,\n                     }));\n                     err_buf = error;"}, {"sha": "faf77af5981fee0fb0598e20543f62ea69081702", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798", "patch": "@@ -161,19 +161,18 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         // FIXME(#20304) -- cache\n \n         let mut selcx = SelectionContext::new(infcx);\n-        let normalized = project::normalize_projection_type(&mut selcx,\n-                                                            param_env,\n-                                                            projection_ty,\n-                                                            cause,\n-                                                            0);\n-\n-        for obligation in normalized.obligations {\n-            self.register_predicate_obligation(infcx, obligation);\n-        }\n-\n-        debug!(\"normalize_projection_type: result={:?}\", normalized.value);\n-\n-        normalized.value\n+        let mut obligations = vec![];\n+        let normalized_ty = project::normalize_projection_type(&mut selcx,\n+                                                               param_env,\n+                                                               projection_ty,\n+                                                               cause,\n+                                                               0,\n+                                                               &mut obligations);\n+        self.register_predicate_obligations(infcx, obligations);\n+\n+        debug!(\"normalize_projection_type: result={:?}\", normalized_ty);\n+\n+        normalized_ty\n     }\n \n     /// Requires that `ty` must implement the trait with `def_id` in"}, {"sha": "8a089dff1537805da5d0de9ff22eb77200fe71f4", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 72, "deletions": 54, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798", "patch": "@@ -225,12 +225,14 @@ fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n     debug!(\"project_and_unify_type(obligation={:?})\",\n            obligation);\n \n-    let Normalized { value: normalized_ty, mut obligations } =\n+    let mut obligations = vec![];\n+    let normalized_ty =\n         match opt_normalize_projection_type(selcx,\n                                             obligation.param_env,\n                                             obligation.predicate.projection_ty,\n                                             obligation.cause.clone(),\n-                                            obligation.recursion_depth) {\n+                                            obligation.recursion_depth,\n+                                            &mut obligations) {\n             Some(n) => n,\n             None => return Ok(None),\n         };\n@@ -386,16 +388,15 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                 // binder). It would be better to normalize in a\n                 // binding-aware fashion.\n \n-                let Normalized { value: normalized_ty, obligations } =\n-                    normalize_projection_type(self.selcx,\n-                                              self.param_env,\n-                                              data.clone(),\n-                                              self.cause.clone(),\n-                                              self.depth);\n-                debug!(\"AssociatedTypeNormalizer: depth={} normalized {:?} to {:?} \\\n-                        with {} add'l obligations\",\n-                       self.depth, ty, normalized_ty, obligations.len());\n-                self.obligations.extend(obligations);\n+                let normalized_ty = normalize_projection_type(self.selcx,\n+                                                              self.param_env,\n+                                                              data.clone(),\n+                                                              self.cause.clone(),\n+                                                              self.depth,\n+                                                              &mut self.obligations);\n+                debug!(\"AssociatedTypeNormalizer: depth={} normalized {:?} to {:?}, \\\n+                        now with {} obligations\",\n+                       self.depth, ty, normalized_ty, self.obligations.len());\n                 normalized_ty\n             }\n \n@@ -471,10 +472,12 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n-    depth: usize)\n-    -> NormalizedTy<'tcx>\n+    depth: usize,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>)\n+    -> Ty<'tcx>\n {\n-    opt_normalize_projection_type(selcx, param_env, projection_ty.clone(), cause.clone(), depth)\n+    opt_normalize_projection_type(selcx, param_env, projection_ty.clone(), cause.clone(), depth,\n+                                  obligations)\n         .unwrap_or_else(move || {\n             // if we bottom out in ambiguity, create a type variable\n             // and a deferred predicate to resolve this when more type\n@@ -490,24 +493,29 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             });\n             let obligation = Obligation::with_depth(\n                 cause, depth + 1, param_env, projection.to_predicate());\n-            Normalized {\n-                value: ty_var,\n-                obligations: vec![obligation]\n-            }\n+            obligations.push(obligation);\n+            ty_var\n         })\n }\n \n /// The guts of `normalize`: normalize a specific projection like `<T\n /// as Trait>::Item`. The result is always a type (and possibly\n /// additional obligations). Returns `None` in the case of ambiguity,\n /// which indicates that there are unbound type variables.\n+///\n+/// This function used to return `Option<NormalizedTy<'tcx>>`, which contains a\n+/// `Ty<'tcx>` and an obligations vector. But that obligation vector was very\n+/// often immediately appended to another obligations vector. So now this\n+/// function takes an obligations vector and appends to it directly, which is\n+/// slightly uglier but avoids the need for an extra short-lived allocation.\n fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n     selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n-    depth: usize)\n-    -> Option<NormalizedTy<'tcx>>\n+    depth: usize,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>)\n+    -> Option<Ty<'tcx>>\n {\n     let infcx = selcx.infcx();\n \n@@ -579,7 +587,9 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                                                     projection_ty);\n             selcx.infcx().report_overflow_error(&obligation, false);\n         }\n-        Err(ProjectionCacheEntry::NormalizedTy(mut ty)) => {\n+        Err(ProjectionCacheEntry::NormalizedTy(ty)) => {\n+            // This is the hottest path in this function.\n+            //\n             // If we find the value in the cache, then return it along\n             // with the obligations that went along with it. Note\n             // that, when using a fulfillment context, these\n@@ -597,28 +607,31 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             // can ignore the `obligations` from that point on.\n             if !infcx.any_unresolved_type_vars(&ty.value) {\n                 infcx.projection_cache.borrow_mut().complete_normalized(cache_key, &ty);\n-                ty.obligations = vec![];\n+                // No need to extend `obligations`.\n+            } else {\n+                obligations.extend(ty.obligations);\n             }\n \n-            push_paranoid_cache_value_obligation(infcx,\n-                                                 param_env,\n-                                                 projection_ty,\n-                                                 cause,\n-                                                 depth,\n-                                                 &mut ty);\n-\n-            return Some(ty);\n+            obligations.push(get_paranoid_cache_value_obligation(infcx,\n+                                                                 param_env,\n+                                                                 projection_ty,\n+                                                                 cause,\n+                                                                 depth));\n+            return Some(ty.value);\n         }\n         Err(ProjectionCacheEntry::Error) => {\n             debug!(\"opt_normalize_projection_type: \\\n                     found error\");\n-            return Some(normalize_to_error(selcx, param_env, projection_ty, cause, depth));\n+            let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n+            obligations.extend(result.obligations);\n+            return Some(result.value)\n         }\n     }\n \n     let obligation = Obligation::with_depth(cause.clone(), depth, param_env, projection_ty);\n     match project_type(selcx, &obligation) {\n-        Ok(ProjectedTy::Progress(Progress { ty: projected_ty, mut obligations })) => {\n+        Ok(ProjectedTy::Progress(Progress { ty: projected_ty,\n+                                            obligations: mut projected_obligations })) => {\n             // if projection succeeded, then what we get out of this\n             // is also non-normalized (consider: it was derived from\n             // an impl, where-clause etc) and hence we must\n@@ -627,10 +640,10 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             debug!(\"opt_normalize_projection_type: \\\n                     projected_ty={:?} \\\n                     depth={} \\\n-                    obligations={:?}\",\n+                    projected_obligations={:?}\",\n                    projected_ty,\n                    depth,\n-                   obligations);\n+                   projected_obligations);\n \n             let result = if projected_ty.has_projections() {\n                 let mut normalizer = AssociatedTypeNormalizer::new(selcx,\n@@ -644,22 +657,22 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                        normalized_ty,\n                        depth);\n \n-                obligations.extend(normalizer.obligations);\n+                projected_obligations.extend(normalizer.obligations);\n                 Normalized {\n                     value: normalized_ty,\n-                    obligations,\n+                    obligations: projected_obligations,\n                 }\n             } else {\n                 Normalized {\n                     value: projected_ty,\n-                    obligations,\n+                    obligations: projected_obligations,\n                 }\n             };\n \n             let cache_value = prune_cache_value_obligations(infcx, &result);\n             infcx.projection_cache.borrow_mut().insert_ty(cache_key, cache_value);\n-\n-            Some(result)\n+            obligations.extend(result.obligations);\n+            Some(result.value)\n         }\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n             debug!(\"opt_normalize_projection_type: \\\n@@ -670,7 +683,8 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                 obligations: vec![]\n             };\n             infcx.projection_cache.borrow_mut().insert_ty(cache_key, result.clone());\n-            Some(result)\n+            // No need to extend `obligations`.\n+            Some(result.value)\n         }\n         Err(ProjectionTyError::TooManyCandidates) => {\n             debug!(\"opt_normalize_projection_type: \\\n@@ -688,7 +702,9 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n \n             infcx.projection_cache.borrow_mut()\n                                   .error(cache_key);\n-            Some(normalize_to_error(selcx, param_env, projection_ty, cause, depth))\n+            let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n+            obligations.extend(result.obligations);\n+            Some(result.value)\n         }\n     }\n }\n@@ -737,7 +753,7 @@ fn prune_cache_value_obligations<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx,\n /// may or may not be necessary -- in principle, all the obligations\n /// that must be proven to show that `T: Trait` were also returned\n /// when the cache was first populated. But there are some vague concerns,\n-/// and so we take the precatuionary measure of including `T: Trait` in\n+/// and so we take the precautionary measure of including `T: Trait` in\n /// the result:\n ///\n /// Concern #1. The current setup is fragile. Perhaps someone could\n@@ -754,19 +770,21 @@ fn prune_cache_value_obligations<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx,\n /// that may yet turn out to be wrong.  This *may* lead to some sort\n /// of trouble, though we don't have a concrete example of how that\n /// can occur yet.  But it seems risky at best.\n-fn push_paranoid_cache_value_obligation<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-                                                        param_env: ty::ParamEnv<'tcx>,\n-                                                        projection_ty: ty::ProjectionTy<'tcx>,\n-                                                        cause: ObligationCause<'tcx>,\n-                                                        depth: usize,\n-                                                        result: &mut NormalizedTy<'tcx>)\n+fn get_paranoid_cache_value_obligation<'a, 'gcx, 'tcx>(\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    projection_ty: ty::ProjectionTy<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize)\n+    -> PredicateObligation<'tcx>\n {\n     let trait_ref = projection_ty.trait_ref(infcx.tcx).to_poly_trait_ref();\n-    let trait_obligation = Obligation { cause,\n-                                        recursion_depth: depth,\n-                                        param_env,\n-                                        predicate: trait_ref.to_predicate() };\n-    result.obligations.push(trait_obligation);\n+    Obligation {\n+        cause,\n+        recursion_depth: depth,\n+        param_env,\n+        predicate: trait_ref.to_predicate(),\n+    }\n }\n \n /// If we are projecting `<T as Trait>::Item`, but `T: Trait` does not"}, {"sha": "a9ac53972e4756cad51c3490b767a73936b89b10", "filename": "src/librustc_traits/normalize_projection_ty.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs?ref=47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n use rustc::infer::canonical::{Canonical, QueryResult};\n-use rustc::traits::{self, FulfillmentContext, Normalized, ObligationCause,\n-                    SelectionContext};\n+use rustc::traits::{self, FulfillmentContext, ObligationCause, SelectionContext};\n use rustc::traits::query::{CanonicalProjectionGoal, NoSolution, normalize::NormalizationResult};\n use rustc::ty::{ParamEnvAnd, TyCtxt};\n use rustc_data_structures::sync::Lrc;\n@@ -37,10 +36,9 @@ crate fn normalize_projection_ty<'tcx>(\n         let fulfill_cx = &mut FulfillmentContext::new();\n         let selcx = &mut SelectionContext::new(infcx);\n         let cause = ObligationCause::misc(DUMMY_SP, DUMMY_NODE_ID);\n-        let Normalized {\n-            value: answer,\n-            obligations,\n-        } = traits::normalize_projection_type(selcx, param_env, goal, cause, 0);\n+        let mut obligations = vec![];\n+        let answer =\n+            traits::normalize_projection_type(selcx, param_env, goal, cause, 0, &mut obligations);\n         fulfill_cx.register_predicate_obligations(infcx, obligations);\n \n         // Now that we have fulfilled as much as we can, create a solution"}, {"sha": "4274e5c1e1f7562d75d70d54059f5f758b3c68ac", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798", "patch": "@@ -129,20 +129,20 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         }\n \n         let mut selcx = traits::SelectionContext::new(self.fcx);\n-        let normalized = traits::normalize_projection_type(&mut selcx,\n-                                                           self.fcx.param_env,\n-                                                           ty::ProjectionTy::from_ref_and_name(\n-                                                               tcx,\n-                                                               trait_ref,\n-                                                               Symbol::intern(\"Target\"),\n-                                                           ),\n-                                                           cause,\n-                                                           0);\n-\n-        debug!(\"overloaded_deref_ty({:?}) = {:?}\", ty, normalized);\n-        self.obligations.extend(normalized.obligations);\n-\n-        Some(self.fcx.resolve_type_vars_if_possible(&normalized.value))\n+        let normalized_ty = traits::normalize_projection_type(&mut selcx,\n+                                                              self.fcx.param_env,\n+                                                              ty::ProjectionTy::from_ref_and_name(\n+                                                                  tcx,\n+                                                                  trait_ref,\n+                                                                  Symbol::intern(\"Target\"),\n+                                                              ),\n+                                                              cause,\n+                                                              0,\n+                                                              &mut self.obligations);\n+\n+        debug!(\"overloaded_deref_ty({:?}) = {:?}\", ty, normalized_ty);\n+\n+        Some(self.fcx.resolve_type_vars_if_possible(&normalized_ty))\n     }\n \n     /// Returns the final type, generating an error if it is an"}]}