{"sha": "c0c485c3ad7017c99137d8c9bc9afc729e7db534", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYzQ4NWMzYWQ3MDE3Yzk5MTM3ZDhjOWJjOWFmYzcyOWU3ZGI1MzQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-01-24T18:47:02Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: don't thread existential projections through path_generic_args.", "tree": {"sha": "b29a7bdc33f68097fbab6f70b48986f3a00c0d75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b29a7bdc33f68097fbab6f70b48986f3a00c0d75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0c485c3ad7017c99137d8c9bc9afc729e7db534", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0c485c3ad7017c99137d8c9bc9afc729e7db534", "html_url": "https://github.com/rust-lang/rust/commit/c0c485c3ad7017c99137d8c9bc9afc729e7db534", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0c485c3ad7017c99137d8c9bc9afc729e7db534/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffa00d4628aac6503d7ef04b9f37a52ed6104dfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffa00d4628aac6503d7ef04b9f37a52ed6104dfc", "html_url": "https://github.com/rust-lang/rust/commit/ffa00d4628aac6503d7ef04b9f37a52ed6104dfc"}], "stats": {"total": 407, "additions": 251, "deletions": 156}, "files": [{"sha": "10c34aaf5b78091a7653da293e66d4562e5b17a5", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c0c485c3ad7017c99137d8c9bc9afc729e7db534/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0c485c3ad7017c99137d8c9bc9afc729e7db534/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=c0c485c3ad7017c99137d8c9bc9afc729e7db534", "patch": "@@ -58,7 +58,7 @@ use crate::traits::{ObligationCause, ObligationCauseCode};\n use crate::ty::error::TypeError;\n use crate::ty::{self, subst::{Subst, SubstsRef}, Region, Ty, TyCtxt, TyKind, TypeFoldable};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n-use std::{cmp, fmt, iter};\n+use std::{cmp, fmt};\n use syntax_pos::{Pos, Span};\n \n mod note;\n@@ -458,6 +458,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             type Path = Vec<String>;\n             type Region = !;\n             type Type = !;\n+            type DynExistential = !;\n \n             fn print_region(\n                 self: PrintCx<'_, '_, '_, Self>,\n@@ -473,6 +474,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 Err(NonTrivialPath)\n             }\n \n+            fn print_dyn_existential<'tcx>(\n+                self: PrintCx<'_, '_, 'tcx, Self>,\n+                _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+            ) -> Result<Self::DynExistential, Self::Error> {\n+                Err(NonTrivialPath)\n+            }\n+\n             fn path_crate(\n                 self: PrintCx<'_, '_, '_, Self>,\n                 cnum: CrateNum,\n@@ -513,8 +521,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 print_prefix: impl FnOnce(\n                     PrintCx<'_, 'gcx, 'tcx, Self>,\n                 ) -> Result<Self::Path, Self::Error>,\n-                _args: impl Iterator<Item = Kind<'tcx>> + Clone,\n-                _projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n+                _args: &[Kind<'tcx>],\n             ) -> Result<Self::Path, Self::Error> {\n                 print_prefix(self)\n             }\n@@ -526,7 +533,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             if !(did1.is_local() || did2.is_local()) && did1.krate != did2.krate {\n                 let abs_path = |def_id| {\n                     PrintCx::new(self.tcx, AbsolutePathPrinter)\n-                        .print_def_path(def_id, None, iter::empty())\n+                        .print_def_path(def_id, None)\n                 };\n \n                 // We compare strings because DefPath can be different"}, {"sha": "d1574bb322dd34dcc5d3366808a7932d068f1b22", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0c485c3ad7017c99137d8c9bc9afc729e7db534/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0c485c3ad7017c99137d8c9bc9afc729e7db534/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=c0c485c3ad7017c99137d8c9bc9afc729e7db534", "patch": "@@ -2409,7 +2409,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         let f = &mut *fmt;\n                         PrintCx::with_tls_tcx(FmtPrinter::new(f, Namespace::ValueNS), |cx| {\n                             let substs = cx.tcx.lift(&substs).expect(\"could not lift for printing\");\n-                            cx.print_def_path(variant_def.did, Some(substs), iter::empty())?;\n+                            cx.print_def_path(variant_def.did, Some(substs))?;\n                             Ok(())\n                         })?;\n "}, {"sha": "66c99a7c4fc09f9ede8b5ac62a03d3f4f7122c2d", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0c485c3ad7017c99137d8c9bc9afc729e7db534/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0c485c3ad7017c99137d8c9bc9afc729e7db534/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=c0c485c3ad7017c99137d8c9bc9afc729e7db534", "patch": "@@ -178,7 +178,7 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         PrintCx::with_tls_tcx(FmtPrinter::new(&mut *f, Namespace::ValueNS), |cx| {\n             let substs = cx.tcx.lift(&self.substs).expect(\"could not lift for printing\");\n-            cx.print_def_path(self.def_id(), Some(substs), iter::empty())?;\n+            cx.print_def_path(self.def_id(), Some(substs))?;\n             Ok(())\n         })?;\n "}, {"sha": "4e81533589e5999fbe72c1bea97dd4398552fe91", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c0c485c3ad7017c99137d8c9bc9afc729e7db534/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0c485c3ad7017c99137d8c9bc9afc729e7db534/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=c0c485c3ad7017c99137d8c9bc9afc729e7db534", "patch": "@@ -5,7 +5,6 @@ use crate::ty::subst::{Kind, Subst, SubstsRef};\n \n use rustc_data_structures::fx::FxHashSet;\n \n-use std::iter;\n use std::ops::{Deref, DerefMut};\n \n // `pretty` is a separate module only for organization.\n@@ -64,14 +63,14 @@ pub trait Printer: Sized {\n     type Path;\n     type Region;\n     type Type;\n+    type DynExistential;\n \n     fn print_def_path(\n         self: PrintCx<'_, '_, 'tcx, Self>,\n         def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n-        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n-        self.default_print_def_path(def_id, substs, projections)\n+        self.default_print_def_path(def_id, substs)\n     }\n     fn print_impl_path(\n         self: PrintCx<'_, '_, 'tcx, Self>,\n@@ -93,6 +92,11 @@ pub trait Printer: Sized {\n         ty: Ty<'tcx>,\n     ) -> Result<Self::Type, Self::Error>;\n \n+    fn print_dyn_existential(\n+        self: PrintCx<'_, '_, 'tcx, Self>,\n+        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    ) -> Result<Self::DynExistential, Self::Error>;\n+\n     fn path_crate(\n         self: PrintCx<'_, '_, '_, Self>,\n         cnum: CrateNum,\n@@ -123,8 +127,7 @@ pub trait Printer: Sized {\n         print_prefix: impl FnOnce(\n             PrintCx<'_, 'gcx, 'tcx, Self>,\n         ) -> Result<Self::Path, Self::Error>,\n-        args: impl Iterator<Item = Kind<'tcx>> + Clone,\n-        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n+        args: &[Kind<'tcx>],\n     ) -> Result<Self::Path, Self::Error>;\n }\n \n@@ -133,7 +136,6 @@ impl<P: Printer> PrintCx<'_, 'gcx, 'tcx, P> {\n         self,\n         def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n-        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n     ) -> Result<P::Path, P::Error> {\n         debug!(\"default_print_def_path: def_id={:?}, substs={:?}\", def_id, substs);\n         let key = self.tcx.def_key(def_id);\n@@ -175,10 +177,10 @@ impl<P: Printer> PrintCx<'_, 'gcx, 'tcx, P> {\n                             let trait_ref = ty::TraitRef::new(parent_def_id, substs);\n                             cx.path_qualified(trait_ref.self_ty(), Some(trait_ref))\n                         } else {\n-                            cx.print_def_path(parent_def_id, substs, iter::empty())\n+                            cx.print_def_path(parent_def_id, substs)\n                         }\n                     } else {\n-                        cx.print_def_path(parent_def_id, None, iter::empty())\n+                        cx.print_def_path(parent_def_id, None)\n                     }\n                 };\n                 let print_path = |cx: PrintCx<'_, 'gcx, 'tcx, P>| {\n@@ -197,7 +199,7 @@ impl<P: Printer> PrintCx<'_, 'gcx, 'tcx, P> {\n \n                 if let (Some(generics), Some(substs)) = (generics, substs) {\n                     let args = self.generic_args_to_print(generics, substs);\n-                    self.path_generic_args(print_path, args, projections)\n+                    self.path_generic_args(print_path, args)\n                 } else {\n                     print_path(self)\n                 }\n@@ -209,13 +211,16 @@ impl<P: Printer> PrintCx<'_, 'gcx, 'tcx, P> {\n         &self,\n         generics: &'tcx ty::Generics,\n         substs: SubstsRef<'tcx>,\n-    ) -> impl Iterator<Item = Kind<'tcx>> + Clone {\n+    ) -> &'tcx [Kind<'tcx>] {\n+        let mut own_params = generics.parent_count..generics.count();\n+\n         // Don't print args for `Self` parameters (of traits).\n-        let has_own_self = generics.has_self && generics.parent_count == 0;\n-        let params = &generics.params[has_own_self as usize..];\n+        if generics.has_self && own_params.start == 0 {\n+            own_params.start = 1;\n+        }\n \n         // Don't print args that are the defaults of their respective parameters.\n-        let num_supplied_defaults = params.iter().rev().take_while(|param| {\n+        own_params.end -= generics.params.iter().rev().take_while(|param| {\n             match param.kind {\n                 ty::GenericParamDefKind::Lifetime => false,\n                 ty::GenericParamDefKind::Type { has_default, .. } => {\n@@ -226,9 +231,8 @@ impl<P: Printer> PrintCx<'_, 'gcx, 'tcx, P> {\n                 ty::GenericParamDefKind::Const => false, // FIXME(const_generics:defaults)\n             }\n         }).count();\n-        params[..params.len() - num_supplied_defaults].iter().map(move |param| {\n-            substs[param.index as usize]\n-        })\n+\n+        &substs[own_params]\n     }\n \n     fn default_print_impl_path(\n@@ -261,7 +265,7 @@ impl<P: Printer> PrintCx<'_, 'gcx, 'tcx, P> {\n             // trait-type, then fallback to a format that identifies\n             // the module more clearly.\n             self.path_append_impl(\n-                |cx| cx.print_def_path(parent_def_id, None, iter::empty()),\n+                |cx| cx.print_def_path(parent_def_id, None),\n                 self_ty,\n                 impl_trait_ref,\n             )\n@@ -344,3 +348,11 @@ impl<P: Printer> Print<'tcx, P> for Ty<'tcx> {\n         cx.print_type(self)\n     }\n }\n+\n+impl<P: Printer> Print<'tcx, P> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n+    type Output = P::DynExistential;\n+    type Error = P::Error;\n+    fn print(&self, cx: PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error> {\n+        cx.print_dyn_existential(self)\n+    }\n+}"}, {"sha": "d27e64b27a2e45691cf48ad3489f6940a12ff71d", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 151, "deletions": 117, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/c0c485c3ad7017c99137d8c9bc9afc729e7db534/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0c485c3ad7017c99137d8c9bc9afc729e7db534/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=c0c485c3ad7017c99137d8c9bc9afc729e7db534", "patch": "@@ -14,7 +14,6 @@ use syntax::symbol::InternedString;\n \n use std::cell::Cell;\n use std::fmt::{self, Write as _};\n-use std::iter;\n use std::ops::{Deref, DerefMut};\n \n // `pretty` is a separate module only for organization.\n@@ -177,6 +176,7 @@ pub trait PrettyPrinter:\n         Path = Self,\n         Region = Self,\n         Type = Self,\n+        DynExistential = Self,\n     > +\n     fmt::Write\n {\n@@ -195,7 +195,7 @@ pub trait PrettyPrinter:\n         def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n-        self.print_def_path(def_id, substs, iter::empty())\n+        self.print_def_path(def_id, substs)\n     }\n \n     fn in_binder<T>(\n@@ -211,14 +211,13 @@ pub trait PrettyPrinter:\n     fn comma_sep<T>(\n         mut self: PrintCx<'_, '_, 'tcx, Self>,\n         mut elems: impl Iterator<Item = T>,\n-        comma: &str,\n     ) -> Result<Self, Self::Error>\n         where T: Print<'tcx, Self, Output = Self, Error = Self::Error>\n     {\n         if let Some(first) = elems.next() {\n             self = self.nest(|cx| first.print(cx))?;\n             for elem in elems {\n-                self.write_str(comma)?;\n+                self.write_str(\", \")?;\n                 self = self.nest(|cx| elem.print(cx))?;\n             }\n         }\n@@ -272,7 +271,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"def_path_str: def_id={:?}, ns={:?}\", def_id, ns);\n         let mut s = String::new();\n         let _ = PrintCx::new(self, FmtPrinter::new(&mut s, ns))\n-            .print_def_path(def_id, None, iter::empty());\n+            .print_def_path(def_id, None);\n         s\n     }\n }\n@@ -317,7 +316,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                 }) => {\n                     debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n                     return Ok((if !span.is_dummy() {\n-                        self.print_def_path(def_id, None, iter::empty())?\n+                        self.print_def_path(def_id, None)?\n                     } else {\n                         self.path_crate(cnum)?\n                     }, true));\n@@ -485,33 +484,6 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             cx.ok()\n         })\n     }\n-\n-    pub fn pretty_path_generic_args(\n-        mut self,\n-        print_prefix: impl FnOnce(\n-            PrintCx<'_, 'gcx, 'tcx, P>,\n-        ) -> Result<P::Path, P::Error>,\n-        mut args: impl Iterator<Item = Kind<'tcx>>,\n-        mut projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n-    ) -> Result<P::Path, P::Error> {\n-        self = self.nest(print_prefix)?;\n-\n-        let arg0 = args.next();\n-        let projection0 = projections.next();\n-        if arg0.is_none() && projection0.is_none() {\n-            return self.ok();\n-        }\n-        let args = arg0.into_iter().chain(args);\n-        let projections = projection0.into_iter().chain(projections);\n-\n-        self.generic_delimiters(|mut cx| {\n-            cx = cx.nest(|cx| cx.comma_sep(args, \", \"))?;\n-            if arg0.is_some() && projection0.is_some() {\n-                write!(cx, \", \")?;\n-            }\n-            cx.comma_sep(projections, \", \")\n-        })\n-    }\n }\n \n // HACK(eddyb) boxed to avoid moving around a large struct by-value.\n@@ -570,12 +542,12 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n     type Path = Self;\n     type Region = Self;\n     type Type = Self;\n+    type DynExistential = Self;\n \n     fn print_def_path(\n         mut self: PrintCx<'_, '_, 'tcx, Self>,\n         def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n-        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n         // FIXME(eddyb) avoid querying `tcx.generics_of` and `tcx.def_key`\n         // both here and in `default_print_def_path`.\n@@ -590,7 +562,7 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n             if visible_path_success {\n                 return if let (Some(generics), Some(substs)) = (generics, substs) {\n                     let args = self.generic_args_to_print(generics, substs);\n-                    self.path_generic_args(|cx| cx.ok(), args, projections)\n+                    self.path_generic_args(|cx| cx.ok(), args)\n                 } else {\n                     self.ok()\n                 };\n@@ -615,13 +587,13 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n                 let parent_def_id = DefId { index: key.parent.unwrap(), ..def_id };\n                 let span = self.tcx.def_span(def_id);\n                 return self.path_append(\n-                    |cx| cx.print_def_path(parent_def_id, None, iter::empty()),\n+                    |cx| cx.print_def_path(parent_def_id, None),\n                     &format!(\"<impl at {:?}>\", span),\n                 );\n             }\n         }\n \n-        self.default_print_def_path(def_id, substs, projections)\n+        self.default_print_def_path(def_id, substs)\n     }\n \n     fn print_region(\n@@ -638,6 +610,13 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         self.pretty_print_type(ty)\n     }\n \n+    fn print_dyn_existential(\n+        self: PrintCx<'_, '_, 'tcx, Self>,\n+        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    ) -> Result<Self::DynExistential, Self::Error> {\n+        self.pretty_print_dyn_existential(predicates)\n+    }\n+\n     fn path_crate(\n         mut self: PrintCx<'_, '_, '_, Self>,\n         cnum: CrateNum,\n@@ -703,27 +682,33 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         Ok(path)\n     }\n     fn path_generic_args<'gcx, 'tcx>(\n-        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+        mut self: PrintCx<'_, 'gcx, 'tcx, Self>,\n         print_prefix: impl FnOnce(\n             PrintCx<'_, 'gcx, 'tcx, Self>,\n         ) -> Result<Self::Path, Self::Error>,\n-        args: impl Iterator<Item = Kind<'tcx>> + Clone,\n-        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n+        args: &[Kind<'tcx>],\n     ) -> Result<Self::Path, Self::Error> {\n+        self = self.nest(print_prefix)?;\n+\n         // Don't print `'_` if there's no unerased regions.\n-        let print_regions = args.clone().any(|arg| {\n+        let print_regions = args.iter().any(|arg| {\n             match arg.unpack() {\n                 UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n                 _ => false,\n             }\n         });\n-        let args = args.filter(|arg| {\n+        let args = args.iter().cloned().filter(|arg| {\n             match arg.unpack() {\n                 UnpackedKind::Lifetime(_) => print_regions,\n                 _ => true,\n             }\n         });\n-        self.pretty_path_generic_args(print_prefix, args, projections)\n+\n+        if args.clone().next().is_some() {\n+            self.generic_delimiters(|cx| cx.comma_sep(args))\n+        } else {\n+            self.ok()\n+        }\n     }\n }\n \n@@ -745,7 +730,7 @@ impl<F: fmt::Write> PrettyPrinter for FmtPrinter<F> {\n         substs: Option<SubstsRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n         let was_in_value = std::mem::replace(&mut self.in_value, true);\n-        let mut path = self.print_def_path(def_id, substs, iter::empty())?;\n+        let mut path = self.print_def_path(def_id, substs)?;\n         path.in_value = was_in_value;\n \n         Ok(path)\n@@ -995,7 +980,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                 }\n             }\n             ty::Adt(def, substs) => {\n-                nest!(|cx| cx.print_def_path(def.did, Some(substs), iter::empty()));\n+                nest!(|cx| cx.print_def_path(def.did, Some(substs)));\n             }\n             ty::Dynamic(data, r) => {\n                 let print_r = self.region_should_not_be_omitted(r);\n@@ -1008,7 +993,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                 }\n             }\n             ty::Foreign(def_id) => {\n-                nest!(|cx| cx.print_def_path(def_id, None, iter::empty()));\n+                nest!(|cx| cx.print_def_path(def_id, None));\n             }\n             ty::Projection(ref data) => p!(print(data)),\n             ty::UnnormalizedProjection(ref data) => {\n@@ -1184,6 +1169,105 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n         self.ok()\n     }\n \n+    fn pretty_print_dyn_existential(\n+        mut self,\n+        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    ) -> Result<P::DynExistential, P::Error> {\n+        define_scoped_cx!(self);\n+\n+        // Generate the main trait ref, including associated types.\n+        let mut first = true;\n+\n+        if let Some(principal) = predicates.principal() {\n+            nest!(|cx| cx.print_def_path(principal.def_id, None));\n+\n+            let mut resugared = false;\n+\n+            // Special-case `Fn(...) -> ...` and resugar it.\n+            let fn_trait_kind = self.tcx.lang_items().fn_trait_kind(principal.def_id);\n+            if !self.tcx.sess.verbose() && fn_trait_kind.is_some() {\n+                if let ty::Tuple(ref args) = principal.substs.type_at(0).sty {\n+                    let mut projections = predicates.projection_bounds();\n+                    if let (Some(proj), None) = (projections.next(), projections.next()) {\n+                        nest!(|cx| cx.pretty_fn_sig(args, false, proj.ty));\n+                        resugared = true;\n+                    }\n+                }\n+            }\n+\n+            // HACK(eddyb) this duplicates `FmtPrinter`'s `path_generic_args`,\n+            // in order to place the projections inside the `<...>`.\n+            if !resugared {\n+                // Use a type that can't appear in defaults of type parameters.\n+                let dummy_self = self.tcx.mk_infer(ty::FreshTy(0));\n+                let principal = principal.with_self_ty(self.tcx, dummy_self);\n+\n+                let args = self.generic_args_to_print(\n+                    self.tcx.generics_of(principal.def_id),\n+                    principal.substs,\n+                );\n+\n+                // Don't print `'_` if there's no unerased regions.\n+                let print_regions = args.iter().any(|arg| {\n+                    match arg.unpack() {\n+                        UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n+                        _ => false,\n+                    }\n+                });\n+                let mut args = args.iter().cloned().filter(|arg| {\n+                    match arg.unpack() {\n+                        UnpackedKind::Lifetime(_) => print_regions,\n+                        _ => true,\n+                    }\n+                });\n+                let mut projections = predicates.projection_bounds();\n+\n+                let arg0 = args.next();\n+                let projection0 = projections.next();\n+                if arg0.is_some() || projection0.is_some() {\n+                    let args = arg0.into_iter().chain(args);\n+                    let projections = projection0.into_iter().chain(projections);\n+\n+                    nest!(|cx| cx.generic_delimiters(|mut cx| {\n+                        cx = cx.nest(|cx| cx.comma_sep(args))?;\n+                        if arg0.is_some() && projection0.is_some() {\n+                            write!(cx, \", \")?;\n+                        }\n+                        cx.comma_sep(projections)\n+                    }));\n+                }\n+            }\n+            first = false;\n+        }\n+\n+        // Builtin bounds.\n+        // FIXME(eddyb) avoid printing twice (needed to ensure\n+        // that the auto traits are sorted *and* printed via cx).\n+        let mut auto_traits: Vec<_> = predicates.auto_traits().map(|did| {\n+            (self.tcx.def_path_str(did), did)\n+        }).collect();\n+\n+        // The auto traits come ordered by `DefPathHash`. While\n+        // `DefPathHash` is *stable* in the sense that it depends on\n+        // neither the host nor the phase of the moon, it depends\n+        // \"pseudorandomly\" on the compiler version and the target.\n+        //\n+        // To avoid that causing instabilities in compiletest\n+        // output, sort the auto-traits alphabetically.\n+        auto_traits.sort();\n+\n+        for (_, def_id) in auto_traits {\n+            if !first {\n+                p!(write(\" + \"));\n+            }\n+            first = false;\n+\n+            nest!(|cx| cx.print_def_path(def_id, None));\n+        }\n+\n+        self.ok()\n+    }\n+\n     pub fn pretty_fn_sig(\n         mut self,\n         inputs: &[Ty<'tcx>],\n@@ -1399,6 +1483,7 @@ macro_rules! define_print_and_forward_display {\n \n forward_display_to_print!(ty::RegionKind);\n forward_display_to_print!(Ty<'tcx>);\n+forward_display_to_print!(&'tcx ty::List<ty::ExistentialPredicate<'tcx>>);\n forward_display_to_print!(<T> ty::Binder<T>);\n \n define_print_and_forward_display! {\n@@ -1412,70 +1497,6 @@ define_print_and_forward_display! {\n define_print_and_forward_display! {\n     (self, cx):\n \n-    &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n-        // Generate the main trait ref, including associated types.\n-        let mut first = true;\n-\n-        if let Some(principal) = self.principal() {\n-            let mut resugared_principal = false;\n-\n-            // Special-case `Fn(...) -> ...` and resugar it.\n-            let fn_trait_kind = cx.tcx.lang_items().fn_trait_kind(principal.def_id);\n-            if !cx.tcx.sess.verbose() && fn_trait_kind.is_some() {\n-                if let ty::Tuple(ref args) = principal.substs.type_at(0).sty {\n-                    let mut projections = self.projection_bounds();\n-                    if let (Some(proj), None) = (projections.next(), projections.next()) {\n-                        nest!(|cx| cx.print_def_path(principal.def_id, None, iter::empty()));\n-                        nest!(|cx| cx.pretty_fn_sig(args, false, proj.ty));\n-                        resugared_principal = true;\n-                    }\n-                }\n-            }\n-\n-            if !resugared_principal {\n-                // Use a type that can't appear in defaults of type parameters.\n-                let dummy_self = cx.tcx.mk_infer(ty::FreshTy(0));\n-                let principal = principal.with_self_ty(cx.tcx, dummy_self);\n-                nest!(|cx| cx.print_def_path(\n-                    principal.def_id,\n-                    Some(principal.substs),\n-                    self.projection_bounds(),\n-                ));\n-            }\n-            first = false;\n-        }\n-\n-        // Builtin bounds.\n-        // FIXME(eddyb) avoid printing twice (needed to ensure\n-        // that the auto traits are sorted *and* printed via cx).\n-        let mut auto_traits: Vec<_> = self.auto_traits().map(|did| {\n-            (cx.tcx.def_path_str(did), did)\n-        }).collect();\n-\n-        // The auto traits come ordered by `DefPathHash`. While\n-        // `DefPathHash` is *stable* in the sense that it depends on\n-        // neither the host nor the phase of the moon, it depends\n-        // \"pseudorandomly\" on the compiler version and the target.\n-        //\n-        // To avoid that causing instabilities in compiletest\n-        // output, sort the auto-traits alphabetically.\n-        auto_traits.sort();\n-\n-        for (_, def_id) in auto_traits {\n-            if !first {\n-                p!(write(\" + \"));\n-            }\n-            first = false;\n-\n-            nest!(|cx| cx.print_def_path(def_id, None, iter::empty()));\n-        }\n-    }\n-\n-    ty::ExistentialProjection<'tcx> {\n-        let name = cx.tcx.associated_item(self.item_def_id).ident;\n-        p!(write(\"{}=\", name), print(self.ty))\n-    }\n-\n     &'tcx ty::List<Ty<'tcx>> {\n         p!(write(\"{{\"));\n         let mut tys = self.iter();\n@@ -1494,14 +1515,27 @@ define_print_and_forward_display! {\n     }\n \n     ty::ExistentialTraitRef<'tcx> {\n+        // Use a type that can't appear in defaults of type parameters.\n         let dummy_self = cx.tcx.mk_infer(ty::FreshTy(0));\n-\n-        let trait_ref = *ty::Binder::bind(*self)\n-            .with_self_ty(cx.tcx, dummy_self)\n-            .skip_binder();\n+        let trait_ref = self.with_self_ty(cx.tcx, dummy_self);\n         p!(print(trait_ref))\n     }\n \n+    ty::ExistentialProjection<'tcx> {\n+        let name = cx.tcx.associated_item(self.item_def_id).ident;\n+        p!(write(\"{}=\", name), print(self.ty))\n+    }\n+\n+    ty::ExistentialPredicate<'tcx> {\n+        match *self {\n+            ty::ExistentialPredicate::Trait(x) => p!(print(x)),\n+            ty::ExistentialPredicate::Projection(x) => p!(print(x)),\n+            ty::ExistentialPredicate::AutoTrait(def_id) => {\n+                nest!(|cx| cx.print_def_path(def_id, None))\n+            }\n+        }\n+    }\n+\n     ty::FnSig<'tcx> {\n         if self.unsafety == hir::Unsafety::Unsafe {\n             p!(write(\"unsafe \"));\n@@ -1531,7 +1565,7 @@ define_print_and_forward_display! {\n     }\n \n     ty::TraitRef<'tcx> {\n-        nest!(|cx| cx.print_def_path(self.def_id, Some(self.substs), iter::empty()));\n+        nest!(|cx| cx.print_def_path(self.def_id, Some(self.substs)));\n     }\n \n     ConstValue<'tcx> {\n@@ -1575,7 +1609,7 @@ define_print_and_forward_display! {\n     }\n \n     ty::ProjectionTy<'tcx> {\n-        nest!(|cx| cx.print_def_path(self.item_def_id, Some(self.substs), iter::empty()));\n+        nest!(|cx| cx.print_def_path(self.item_def_id, Some(self.substs)));\n     }\n \n     ty::ClosureKind {\n@@ -1596,7 +1630,7 @@ define_print_and_forward_display! {\n             ty::Predicate::WellFormed(ty) => p!(print(ty), write(\" well-formed\")),\n             ty::Predicate::ObjectSafe(trait_def_id) => {\n                 p!(write(\"the trait `\"));\n-                nest!(|cx| cx.print_def_path(trait_def_id, None, iter::empty()));\n+                nest!(|cx| cx.print_def_path(trait_def_id, None));\n                 p!(write(\"` is object-safe\"))\n             }\n             ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) => {"}, {"sha": "32a39c2eb883da5a3a219f539103d072bc8f390e", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c0c485c3ad7017c99137d8c9bc9afc729e7db534/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0c485c3ad7017c99137d8c9bc9afc729e7db534/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=c0c485c3ad7017c99137d8c9bc9afc729e7db534", "patch": "@@ -14,7 +14,6 @@ use smallvec::SmallVec;\n use crate::mir::interpret;\n \n use std::fmt;\n-use std::iter;\n use std::marker::PhantomData;\n use std::rc::Rc;\n \n@@ -36,7 +35,7 @@ impl fmt::Debug for ty::GenericParamDef {\n impl fmt::Debug for ty::TraitDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         PrintCx::with_tls_tcx(FmtPrinter::new(f, Namespace::TypeNS), |cx| {\n-            cx.print_def_path(self.def_id, None, iter::empty())?;\n+            cx.print_def_path(self.def_id, None)?;\n             Ok(())\n         })\n     }\n@@ -45,7 +44,7 @@ impl fmt::Debug for ty::TraitDef {\n impl fmt::Debug for ty::AdtDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         PrintCx::with_tls_tcx(FmtPrinter::new(f, Namespace::TypeNS), |cx| {\n-            cx.print_def_path(self.did, None, iter::empty())?;\n+            cx.print_def_path(self.did, None)?;\n             Ok(())\n         })\n     }"}, {"sha": "9620c3efda07f481fd2fba9ffd7076e98ce84165", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 45, "deletions": 9, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c0c485c3ad7017c99137d8c9bc9afc729e7db534/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0c485c3ad7017c99137d8c9bc9afc729e7db534/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=c0c485c3ad7017c99137d8c9bc9afc729e7db534", "patch": "@@ -92,7 +92,7 @@ use rustc::hir::Node;\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::ich::NodeIdHashingMode;\n-use rustc::ty::print::{PrettyPrinter, PrintCx, Printer};\n+use rustc::ty::print::{PrettyPrinter, PrintCx, Printer, Print};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::{Kind, SubstsRef, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -106,7 +106,6 @@ use syntax_pos::symbol::Symbol;\n use log::debug;\n \n use std::fmt::{self, Write};\n-use std::iter;\n use std::mem::{self, discriminant};\n \n pub fn provide(providers: &mut Providers<'_>) {\n@@ -225,7 +224,7 @@ fn get_symbol_hash<'a, 'tcx>(\n \n fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::SymbolName {\n     PrintCx::new(tcx, SymbolPath::new(tcx))\n-        .print_def_path(def_id, None, iter::empty())\n+        .print_def_path(def_id, None)\n         .unwrap()\n         .into_interned()\n }\n@@ -409,6 +408,7 @@ impl Printer for SymbolPath {\n     type Path = Self;\n     type Region = Self;\n     type Type = Self;\n+    type DynExistential = Self;\n \n     fn print_region(\n         self: PrintCx<'_, '_, '_, Self>,\n@@ -429,12 +429,27 @@ impl Printer for SymbolPath {\n             ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n             ty::Closure(def_id, ty::ClosureSubsts { substs }) |\n             ty::Generator(def_id, ty::GeneratorSubsts { substs }, _) => {\n-                self.print_def_path(def_id, Some(substs), iter::empty())\n+                self.print_def_path(def_id, Some(substs))\n             }\n             _ => self.pretty_print_type(ty),\n         }\n     }\n \n+    fn print_dyn_existential(\n+        mut self: PrintCx<'_, '_, 'tcx, Self>,\n+        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    ) -> Result<Self::DynExistential, Self::Error> {\n+        let mut first = false;\n+        for p in predicates {\n+            if !first {\n+                write!(self, \"+\")?;\n+            }\n+            first = false;\n+            self = self.nest(|cx| p.print(cx))?;\n+        }\n+        self.ok()\n+    }\n+\n     fn path_crate(\n         mut self: PrintCx<'_, '_, '_, Self>,\n         cnum: CrateNum,\n@@ -499,20 +514,26 @@ impl Printer for SymbolPath {\n         Ok(path)\n     }\n     fn path_generic_args<'gcx, 'tcx>(\n-        self: PrintCx<'_, 'gcx, 'tcx, Self>,\n+        mut self: PrintCx<'_, 'gcx, 'tcx, Self>,\n         print_prefix: impl FnOnce(\n             PrintCx<'_, 'gcx, 'tcx, Self>,\n         ) -> Result<Self::Path, Self::Error>,\n-        args: impl Iterator<Item = Kind<'tcx>> + Clone,\n-        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n+        args: &[Kind<'tcx>],\n     )  -> Result<Self::Path, Self::Error> {\n-        let args = args.filter(|arg| {\n+        self = self.nest(print_prefix)?;\n+\n+        let args = args.iter().cloned().filter(|arg| {\n             match arg.unpack() {\n                 UnpackedKind::Lifetime(_) => false,\n                 _ => true,\n             }\n         });\n-        self.pretty_path_generic_args(print_prefix, args, projections)\n+\n+        if args.clone().next().is_some() {\n+            self.generic_delimiters(|cx| cx.comma_sep(args))\n+        } else {\n+            self.ok()\n+        }\n     }\n }\n \n@@ -523,6 +544,21 @@ impl PrettyPrinter for SymbolPath {\n     ) -> bool {\n         false\n     }\n+    fn comma_sep<T>(\n+        mut self: PrintCx<'_, '_, 'tcx, Self>,\n+        mut elems: impl Iterator<Item = T>,\n+    ) -> Result<Self, Self::Error>\n+        where T: Print<'tcx, Self, Output = Self, Error = Self::Error>\n+    {\n+        if let Some(first) = elems.next() {\n+            self = self.nest(|cx| first.print(cx))?;\n+            for elem in elems {\n+                self.write_str(\",\")?;\n+                self = self.nest(|cx| elem.print(cx))?;\n+            }\n+        }\n+        self.ok()\n+    }\n \n     fn generic_delimiters<'gcx, 'tcx>(\n         mut self: PrintCx<'_, 'gcx, 'tcx, Self>,"}, {"sha": "6822de2bcebae619b18aedf8dd677df4c24a59ea", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c0c485c3ad7017c99137d8c9bc9afc729e7db534/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0c485c3ad7017c99137d8c9bc9afc729e7db534/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c0c485c3ad7017c99137d8c9bc9afc729e7db534", "patch": "@@ -39,7 +39,7 @@ use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::default::Default;\n use std::{mem, slice, vec};\n-use std::iter::{self, FromIterator, once};\n+use std::iter::{FromIterator, once};\n use std::rc::Rc;\n use std::str::FromStr;\n use std::cell::RefCell;\n@@ -4235,6 +4235,7 @@ where F: Fn(DefId) -> Def {\n         type Path = Vec<String>;\n         type Region = ();\n         type Type = ();\n+        type DynExistential = ();\n \n         fn print_region(\n             self: PrintCx<'_, '_, '_, Self>,\n@@ -4250,6 +4251,13 @@ where F: Fn(DefId) -> Def {\n             Ok(())\n         }\n \n+        fn print_dyn_existential<'tcx>(\n+            self: PrintCx<'_, '_, 'tcx, Self>,\n+            _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+        ) -> Result<Self::DynExistential, Self::Error> {\n+            Ok(())\n+        }\n+\n         fn path_crate(\n             self: PrintCx<'_, '_, '_, Self>,\n             cnum: CrateNum,\n@@ -4304,15 +4312,14 @@ where F: Fn(DefId) -> Def {\n             print_prefix: impl FnOnce(\n                 PrintCx<'_, 'gcx, 'tcx, Self>,\n             ) -> Result<Self::Path, Self::Error>,\n-            _args: impl Iterator<Item = Kind<'tcx>> + Clone,\n-            _projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>>,\n+            _args: &[Kind<'tcx>],\n         ) -> Result<Self::Path, Self::Error> {\n             print_prefix(self)\n         }\n     }\n \n     let names = PrintCx::new(tcx, AbsolutePathPrinter)\n-        .print_def_path(def_id, None, iter::empty())\n+        .print_def_path(def_id, None)\n         .unwrap();\n \n     hir::Path {"}]}