{"sha": "e90acaf59629a5997b00f057d8afab67c20b1661", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5MGFjYWY1OTYyOWE1OTk3YjAwZjA1N2Q4YWZhYjY3YzIwYjE2NjE=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-12-03T15:52:53Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-12-03T15:52:53Z"}, "message": "Merge pull request #460 from oli-obk/cyclomatic_complexity\n\nCyclomatic complexity", "tree": {"sha": "a4a1848b05cb814863389e4df73914c7c68a5b71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4a1848b05cb814863389e4df73914c7c68a5b71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e90acaf59629a5997b00f057d8afab67c20b1661", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e90acaf59629a5997b00f057d8afab67c20b1661", "html_url": "https://github.com/rust-lang/rust/commit/e90acaf59629a5997b00f057d8afab67c20b1661", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e90acaf59629a5997b00f057d8afab67c20b1661/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41bad83360ec5ac25e531e4d3639172b994699cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/41bad83360ec5ac25e531e4d3639172b994699cf", "html_url": "https://github.com/rust-lang/rust/commit/41bad83360ec5ac25e531e4d3639172b994699cf"}, {"sha": "04524c549eaa96a437e7ffd4c509b9de79370e3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/04524c549eaa96a437e7ffd4c509b9de79370e3c", "html_url": "https://github.com/rust-lang/rust/commit/04524c549eaa96a437e7ffd4c509b9de79370e3c"}], "stats": {"total": 681, "additions": 531, "deletions": 150}, "files": [{"sha": "acb3c020fe72778f6455f8d3d63f56392dd4733b", "filename": ".gitignore", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e90acaf59629a5997b00f057d8afab67c20b1661/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/e90acaf59629a5997b00f057d8afab67c20b1661/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=e90acaf59629a5997b00f057d8afab67c20b1661", "patch": "@@ -12,3 +12,6 @@\n \n # We don't pin yet\n Cargo.lock\n+\n+# Generated by dogfood\n+/target_recur/"}, {"sha": "206d86ec1ee16af5682be8f6375ab921140d8019", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e90acaf59629a5997b00f057d8afab67c20b1661/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/e90acaf59629a5997b00f057d8afab67c20b1661/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=e90acaf59629a5997b00f057d8afab67c20b1661", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 79 lints included in this crate:\n+There are 80 lints included in this crate:\n \n name                                                                                                     | default | meaning\n ---------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -22,6 +22,7 @@ name\n [cmp_nan](https://github.com/Manishearth/rust-clippy/wiki#cmp_nan)                                       | deny    | comparisons to NAN (which will always return false, which is probably not intended)\n [cmp_owned](https://github.com/Manishearth/rust-clippy/wiki#cmp_owned)                                   | warn    | creating owned instances for comparing with others, e.g. `x == \"foo\".to_string()`\n [collapsible_if](https://github.com/Manishearth/rust-clippy/wiki#collapsible_if)                         | warn    | two nested `if`-expressions can be collapsed into one, e.g. `if x { if y { foo() } }` can be written as `if x && y { foo() }`\n+[cyclomatic_complexity](https://github.com/Manishearth/rust-clippy/wiki#cyclomatic_complexity)           | warn    | finds functions that should be split up into multiple functions\n [empty_loop](https://github.com/Manishearth/rust-clippy/wiki#empty_loop)                                 | warn    | empty `loop {}` detected\n [eq_op](https://github.com/Manishearth/rust-clippy/wiki#eq_op)                                           | warn    | equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\n [explicit_counter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_counter_loop)           | warn    | for-looping with an explicit counter when `_.enumerate()` would do"}, {"sha": "678ebe866cb8efa4f9db8321f39c4dc7ad8ab2b8", "filename": "src/cyclomatic_complexity.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/e90acaf59629a5997b00f057d8afab67c20b1661/src%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90acaf59629a5997b00f057d8afab67c20b1661/src%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcyclomatic_complexity.rs?ref=e90acaf59629a5997b00f057d8afab67c20b1661", "patch": "@@ -0,0 +1,105 @@\n+//! calculate cyclomatic complexity and warn about overly complex functions\n+\n+use rustc::lint::*;\n+use rustc_front::hir::*;\n+use rustc::middle::cfg::CFG;\n+use syntax::codemap::Span;\n+use syntax::attr::*;\n+use syntax::ast::Attribute;\n+use rustc_front::intravisit::{Visitor, walk_expr};\n+\n+use utils::{in_macro, LimitStack};\n+\n+declare_lint! { pub CYCLOMATIC_COMPLEXITY, Warn,\n+    \"finds functions that should be split up into multiple functions\" }\n+\n+pub struct CyclomaticComplexity {\n+    limit: LimitStack,\n+}\n+\n+impl CyclomaticComplexity {\n+    pub fn new(limit: u64) -> Self {\n+        CyclomaticComplexity {\n+            limit: LimitStack::new(limit),\n+        }\n+    }\n+}\n+\n+impl LintPass for CyclomaticComplexity {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(CYCLOMATIC_COMPLEXITY)\n+    }\n+}\n+\n+impl CyclomaticComplexity {\n+    fn check(&mut self, cx: &LateContext, block: &Block, span: Span) {\n+        if in_macro(cx, span) { return; }\n+        let cfg = CFG::new(cx.tcx, block);\n+        let n = cfg.graph.len_nodes() as u64;\n+        let e = cfg.graph.len_edges() as u64;\n+        let cc = e + 2 - n;\n+        let mut arm_counter = MatchArmCounter(0);\n+        arm_counter.visit_block(block);\n+        let mut narms = arm_counter.0;\n+        if narms > 0 {\n+            narms = narms - 1;\n+        }\n+        if cc < narms {\n+            println!(\"cc = {}, arms = {}\", cc, narms);\n+            println!(\"{:?}\", block);\n+            println!(\"{:?}\", span);\n+            panic!(\"cc = {}, arms = {}\", cc, narms);\n+        }\n+        let rust_cc = cc - narms;\n+        if rust_cc > self.limit.limit() {\n+            cx.span_lint_help(CYCLOMATIC_COMPLEXITY, span,\n+            &format!(\"The function has a cyclomatic complexity of {}.\", rust_cc),\n+            \"You could split it up into multiple smaller functions\");\n+        }\n+    }\n+}\n+\n+impl LateLintPass for CyclomaticComplexity {\n+    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+        if let ItemFn(_, _, _, _, _, ref block) = item.node {\n+            self.check(cx, block, item.span);\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n+        if let ImplItemKind::Method(_, ref block) = item.node {\n+            self.check(cx, block, item.span);\n+        }\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n+        if let MethodTraitItem(_, Some(ref block)) = item.node {\n+            self.check(cx, block, item.span);\n+        }\n+    }\n+\n+    fn enter_lint_attrs(&mut self, cx: &LateContext, attrs: &[Attribute]) {\n+        self.limit.push_attrs(cx.sess(), attrs, \"cyclomatic_complexity\");\n+    }\n+    fn exit_lint_attrs(&mut self, cx: &LateContext, attrs: &[Attribute]) {\n+        self.limit.pop_attrs(cx.sess(), attrs, \"cyclomatic_complexity\");\n+    }\n+}\n+\n+struct MatchArmCounter(u64);\n+\n+impl<'a> Visitor<'a> for MatchArmCounter {\n+    fn visit_expr(&mut self, e: &'a Expr) {\n+        match e.node {\n+            ExprMatch(_, ref arms, _) => {\n+                walk_expr(self, e);\n+                let arms_n: u64 = arms.iter().map(|arm| arm.pats.len() as u64).sum();\n+                if arms_n > 0 {\n+                    self.0 += arms_n - 1;\n+                }\n+            },\n+            ExprClosure(..) => {},\n+            _ => walk_expr(self, e),\n+        }\n+    }\n+}"}, {"sha": "57a92f9990012ca6d8eb35755976a7d65accf1c8", "filename": "src/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e90acaf59629a5997b00f057d8afab67c20b1661/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90acaf59629a5997b00f057d8afab67c20b1661/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=e90acaf59629a5997b00f057d8afab67c20b1661", "patch": "@@ -1,8 +1,12 @@\n #![feature(plugin_registrar, box_syntax)]\n #![feature(rustc_private, core, collections)]\n-#![feature(num_bits_bytes)]\n+#![feature(num_bits_bytes, iter_arith)]\n #![allow(unknown_lints)]\n \n+// this only exists to allow the \"dogfood\" integration test to work\n+#[allow(dead_code)]\n+fn main() { println!(\"What are you doing? Don't run clippy as an executable\"); }\n+\n #[macro_use]\n extern crate syntax;\n #[macro_use]\n@@ -59,6 +63,7 @@ pub mod needless_update;\n pub mod no_effect;\n pub mod temporary_assignment;\n pub mod transmute;\n+pub mod cyclomatic_complexity;\n \n mod reexport {\n     pub use syntax::ast::{Name, Ident, NodeId};\n@@ -110,6 +115,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box map_clone::MapClonePass);\n     reg.register_late_lint_pass(box temporary_assignment::TemporaryAssignmentPass);\n     reg.register_late_lint_pass(box transmute::UselessTransmute);\n+    reg.register_late_lint_pass(box cyclomatic_complexity::CyclomaticComplexity::new(25));\n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n         methods::OPTION_UNWRAP_USED,\n@@ -138,6 +144,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         block_in_if_condition::BLOCK_IN_IF_CONDITION_EXPR,\n         block_in_if_condition::BLOCK_IN_IF_CONDITION_STMT,\n         collapsible_if::COLLAPSIBLE_IF,\n+        cyclomatic_complexity::CYCLOMATIC_COMPLEXITY,\n         eq_op::EQ_OP,\n         eta_reduction::REDUNDANT_CLOSURE,\n         identity_op::IDENTITY_OP,"}, {"sha": "97eb7fa67a354a0bf787736b44bf89a3b07fc3e8", "filename": "src/lifetimes.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e90acaf59629a5997b00f057d8afab67c20b1661/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90acaf59629a5997b00f057d8afab67c20b1661/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=e90acaf59629a5997b00f057d8afab67c20b1661", "patch": "@@ -108,7 +108,7 @@ fn could_use_elision(cx: &LateContext, func: &FnDecl, slf: Option<&ExplicitSelf>\n \n     // no input lifetimes? easy case!\n     if input_lts.is_empty() {\n-        return false;\n+        false\n     } else if output_lts.is_empty() {\n         // no output lifetimes, check distinctness of input lifetimes\n \n@@ -117,9 +117,7 @@ fn could_use_elision(cx: &LateContext, func: &FnDecl, slf: Option<&ExplicitSelf>\n             return false;\n         }\n         // we have no output reference, so we only need all distinct lifetimes\n-        if input_lts.len() == unique_lifetimes(&input_lts) {\n-            return true;\n-        }\n+        input_lts.len() == unique_lifetimes(&input_lts)\n     } else {\n         // we have output references, so we need one input reference,\n         // and all output lifetimes must be the same\n@@ -128,15 +126,16 @@ fn could_use_elision(cx: &LateContext, func: &FnDecl, slf: Option<&ExplicitSelf>\n         }\n         if input_lts.len() == 1 {\n             match (&input_lts[0], &output_lts[0]) {\n-                (&Named(n1), &Named(n2)) if n1 == n2 => { return true; }\n-                (&Named(_), &Unnamed) => { return true; }\n-                (&Unnamed, &Named(_)) => { return true; }\n-                _ => { } // already elided, different named lifetimes\n-                         // or something static going on\n+                (&Named(n1), &Named(n2)) if n1 == n2 => true,\n+                (&Named(_), &Unnamed) => true,\n+                (&Unnamed, &Named(_)) => true,\n+                _ => false // already elided, different named lifetimes\n+                           // or something static going on\n             }\n+        } else {\n+            false\n         }\n     }\n-    false\n }\n \n fn allowed_lts_from(named_lts: &[LifetimeDef]) -> HashSet<RefLt> {"}, {"sha": "393c92b16ef5ee4efe3edd92ca4f3d6e150052df", "filename": "src/loops.rs", "status": "modified", "additions": 114, "deletions": 110, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/e90acaf59629a5997b00f057d8afab67c20b1661/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90acaf59629a5997b00f057d8afab67c20b1661/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=e90acaf59629a5997b00f057d8afab67c20b1661", "patch": "@@ -56,116 +56,7 @@ impl LintPass for LoopsPass {\n impl LateLintPass for LoopsPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let Some((pat, arg, body)) = recover_for_loop(expr) {\n-            // check for looping over a range and then indexing a sequence with it\n-            // -> the iteratee must be a range literal\n-            if let ExprRange(Some(ref l), _) = arg.node {\n-                // Range should start with `0`\n-                if let ExprLit(ref lit) = l.node {\n-                    if let LitInt(0, _) = lit.node {\n-\n-                        // the var must be a single name\n-                        if let PatIdent(_, ref ident, _) = pat.node {\n-                            let mut visitor = VarVisitor { cx: cx, var: ident.node.name,\n-                                                           indexed: HashSet::new(), nonindex: false };\n-                            walk_expr(&mut visitor, body);\n-                            // linting condition: we only indexed one variable\n-                            if visitor.indexed.len() == 1 {\n-                                let indexed = visitor.indexed.into_iter().next().expect(\n-                                    \"Len was nonzero, but no contents found\");\n-                                if visitor.nonindex {\n-                                    span_lint(cx, NEEDLESS_RANGE_LOOP, expr.span, &format!(\n-                                        \"the loop variable `{}` is used to index `{}`. Consider using \\\n-                                         `for ({}, item) in {}.iter().enumerate()` or similar iterators\",\n-                                        ident.node.name, indexed, ident.node.name, indexed));\n-                                } else {\n-                                    span_lint(cx, NEEDLESS_RANGE_LOOP, expr.span, &format!(\n-                                        \"the loop variable `{}` is only used to index `{}`. \\\n-                                         Consider using `for item in &{}` or similar iterators\",\n-                                        ident.node.name, indexed, indexed));\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // if this for loop is iterating over a two-sided range...\n-            if let ExprRange(Some(ref start_expr), Some(ref stop_expr)) = arg.node {\n-                // ...and both sides are compile-time constant integers...\n-                if let Some(start_idx @ Constant::ConstantInt(..)) = constant_simple(start_expr) {\n-                    if let Some(stop_idx @ Constant::ConstantInt(..)) = constant_simple(stop_expr) {\n-                        // ...and the start index is greater than the stop index,\n-                        // this loop will never run. This is often confusing for developers\n-                        // who think that this will iterate from the larger value to the\n-                        // smaller value.\n-                        if start_idx > stop_idx {\n-                            span_help_and_lint(cx, REVERSE_RANGE_LOOP, expr.span,\n-                                \"this range is empty so this for loop will never run\",\n-                                &format!(\"Consider using `({}..{}).rev()` if you are attempting to \\\n-                                iterate over this range in reverse\", stop_idx, start_idx));\n-                        } else if start_idx == stop_idx {\n-                            // if they are equal, it's also problematic - this loop\n-                            // will never run.\n-                            span_lint(cx, REVERSE_RANGE_LOOP, expr.span,\n-                                \"this range is empty so this for loop will never run\");\n-                        }\n-                    }\n-                }\n-            }\n-\n-            if let ExprMethodCall(ref method, _, ref args) = arg.node {\n-                // just the receiver, no arguments\n-                if args.len() == 1 {\n-                    let method_name = method.node;\n-                    // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n-                    if method_name.as_str() == \"iter\" || method_name.as_str() == \"iter_mut\" {\n-                        if is_ref_iterable_type(cx, &args[0]) {\n-                            let object = snippet(cx, args[0].span, \"_\");\n-                            span_lint(cx, EXPLICIT_ITER_LOOP, expr.span, &format!(\n-                                \"it is more idiomatic to loop over `&{}{}` instead of `{}.{}()`\",\n-                                if method_name.as_str() == \"iter_mut\" { \"mut \" } else { \"\" },\n-                                object, object, method_name));\n-                        }\n-                    }\n-                    // check for looping over Iterator::next() which is not what you want\n-                    else if method_name.as_str() == \"next\" &&\n-                            match_trait_method(cx, arg, &[\"core\", \"iter\", \"Iterator\"]) {\n-                        span_lint(cx, ITER_NEXT_LOOP, expr.span,\n-                                  \"you are iterating over `Iterator::next()` which is an Option; \\\n-                                   this will compile but is probably not what you want\");\n-                    }\n-                }\n-            }\n-\n-            // Look for variables that are incremented once per loop iteration.\n-            let mut visitor = IncrementVisitor { cx: cx, states: HashMap::new(), depth: 0, done: false };\n-            walk_expr(&mut visitor, body);\n-\n-            // For each candidate, check the parent block to see if\n-            // it's initialized to zero at the start of the loop.\n-            let map = &cx.tcx.map;\n-            let parent_scope = map.get_enclosing_scope(expr.id).and_then(|id| map.get_enclosing_scope(id) );\n-            if let Some(parent_id) = parent_scope {\n-                if let NodeBlock(block) = map.get(parent_id) {\n-                    for (id, _) in visitor.states.iter().filter( |&(_,v)| *v == VarState::IncrOnce) {\n-                        let mut visitor2 = InitializeVisitor { cx: cx, end_expr: expr, var_id: id.clone(),\n-                                                               state: VarState::IncrOnce, name: None,\n-                                                               depth: 0,\n-                                                               past_loop: false };\n-                        walk_block(&mut visitor2, block);\n-\n-                        if visitor2.state == VarState::Warn {\n-                            if let Some(name) = visitor2.name {\n-                                span_lint(cx, EXPLICIT_COUNTER_LOOP, expr.span,\n-                                          &format!(\"the variable `{0}` is used as a loop counter. Consider \\\n-                                                    using `for ({0}, item) in {1}.enumerate()` \\\n-                                                    or similar iterators\",\n-                                                   name, snippet(cx, arg.span, \"_\")));\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n+            check_for_loop(cx, pat, arg, body, expr);\n         }\n         // check for `loop { if let {} else break }` that could be `while let`\n         // (also matches an explicit \"match\" instead of \"if let\")\n@@ -271,6 +162,119 @@ impl LateLintPass for LoopsPass {\n     }\n }\n \n+fn check_for_loop(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n+    // check for looping over a range and then indexing a sequence with it\n+    // -> the iteratee must be a range literal\n+    if let ExprRange(Some(ref l), _) = arg.node {\n+        // Range should start with `0`\n+        if let ExprLit(ref lit) = l.node {\n+            if let LitInt(0, _) = lit.node {\n+\n+                // the var must be a single name\n+                if let PatIdent(_, ref ident, _) = pat.node {\n+                    let mut visitor = VarVisitor { cx: cx, var: ident.node.name,\n+                                                   indexed: HashSet::new(), nonindex: false };\n+                    walk_expr(&mut visitor, body);\n+                    // linting condition: we only indexed one variable\n+                    if visitor.indexed.len() == 1 {\n+                        let indexed = visitor.indexed.into_iter().next().expect(\n+                            \"Len was nonzero, but no contents found\");\n+                        if visitor.nonindex {\n+                            span_lint(cx, NEEDLESS_RANGE_LOOP, expr.span, &format!(\n+                                \"the loop variable `{}` is used to index `{}`. Consider using \\\n+                                 `for ({}, item) in {}.iter().enumerate()` or similar iterators\",\n+                                ident.node.name, indexed, ident.node.name, indexed));\n+                        } else {\n+                            span_lint(cx, NEEDLESS_RANGE_LOOP, expr.span, &format!(\n+                                \"the loop variable `{}` is only used to index `{}`. \\\n+                                 Consider using `for item in &{}` or similar iterators\",\n+                                ident.node.name, indexed, indexed));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // if this for loop is iterating over a two-sided range...\n+    if let ExprRange(Some(ref start_expr), Some(ref stop_expr)) = arg.node {\n+        // ...and both sides are compile-time constant integers...\n+        if let Some(start_idx @ Constant::ConstantInt(..)) = constant_simple(start_expr) {\n+            if let Some(stop_idx @ Constant::ConstantInt(..)) = constant_simple(stop_expr) {\n+                // ...and the start index is greater than the stop index,\n+                // this loop will never run. This is often confusing for developers\n+                // who think that this will iterate from the larger value to the\n+                // smaller value.\n+                if start_idx > stop_idx {\n+                    span_help_and_lint(cx, REVERSE_RANGE_LOOP, expr.span,\n+                        \"this range is empty so this for loop will never run\",\n+                        &format!(\"Consider using `({}..{}).rev()` if you are attempting to \\\n+                        iterate over this range in reverse\", stop_idx, start_idx));\n+                } else if start_idx == stop_idx {\n+                    // if they are equal, it's also problematic - this loop\n+                    // will never run.\n+                    span_lint(cx, REVERSE_RANGE_LOOP, expr.span,\n+                        \"this range is empty so this for loop will never run\");\n+                }\n+            }\n+        }\n+    }\n+\n+    if let ExprMethodCall(ref method, _, ref args) = arg.node {\n+        // just the receiver, no arguments\n+        if args.len() == 1 {\n+            let method_name = method.node;\n+            // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n+            if method_name.as_str() == \"iter\" || method_name.as_str() == \"iter_mut\" {\n+                if is_ref_iterable_type(cx, &args[0]) {\n+                    let object = snippet(cx, args[0].span, \"_\");\n+                    span_lint(cx, EXPLICIT_ITER_LOOP, expr.span, &format!(\n+                        \"it is more idiomatic to loop over `&{}{}` instead of `{}.{}()`\",\n+                        if method_name.as_str() == \"iter_mut\" { \"mut \" } else { \"\" },\n+                        object, object, method_name));\n+                }\n+            }\n+            // check for looping over Iterator::next() which is not what you want\n+            else if method_name.as_str() == \"next\" &&\n+                    match_trait_method(cx, arg, &[\"core\", \"iter\", \"Iterator\"]) {\n+                span_lint(cx, ITER_NEXT_LOOP, expr.span,\n+                          \"you are iterating over `Iterator::next()` which is an Option; \\\n+                           this will compile but is probably not what you want\");\n+            }\n+        }\n+    }\n+\n+    // Look for variables that are incremented once per loop iteration.\n+    let mut visitor = IncrementVisitor { cx: cx, states: HashMap::new(), depth: 0, done: false };\n+    walk_expr(&mut visitor, body);\n+\n+    // For each candidate, check the parent block to see if\n+    // it's initialized to zero at the start of the loop.\n+    let map = &cx.tcx.map;\n+    let parent_scope = map.get_enclosing_scope(expr.id).and_then(|id| map.get_enclosing_scope(id) );\n+    if let Some(parent_id) = parent_scope {\n+        if let NodeBlock(block) = map.get(parent_id) {\n+            for (id, _) in visitor.states.iter().filter( |&(_,v)| *v == VarState::IncrOnce) {\n+                let mut visitor2 = InitializeVisitor { cx: cx, end_expr: expr, var_id: id.clone(),\n+                                                       state: VarState::IncrOnce, name: None,\n+                                                       depth: 0,\n+                                                       past_loop: false };\n+                walk_block(&mut visitor2, block);\n+\n+                if visitor2.state == VarState::Warn {\n+                    if let Some(name) = visitor2.name {\n+                        span_lint(cx, EXPLICIT_COUNTER_LOOP, expr.span,\n+                                  &format!(\"the variable `{0}` is used as a loop counter. Consider \\\n+                                            using `for ({0}, item) in {1}.enumerate()` \\\n+                                            or similar iterators\",\n+                                           name, snippet(cx, arg.span, \"_\")));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// Recover the essential nodes of a desugared for loop:\n /// `for pat in arg { body }` becomes `(pat, arg, body)`.\n fn recover_for_loop(expr: &Expr) -> Option<(&Pat, &Expr, &Expr)> {"}, {"sha": "2c7f0830a5393eb4cbeecbd958e3d7fd6e0958f0", "filename": "src/matches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e90acaf59629a5997b00f057d8afab67c20b1661/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90acaf59629a5997b00f057d8afab67c20b1661/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=e90acaf59629a5997b00f057d8afab67c20b1661", "patch": "@@ -59,7 +59,7 @@ impl LateLintPass for MatchPass {\n                 if arms.len() == 2 && arms[0].pats.len() == 1 { // no guards\n                     let exprs = if let PatLit(ref arm_bool) = arms[0].pats[0].node {\n                         if let ExprLit(ref lit) = arm_bool.node {\n-                            if let LitBool(val) = lit.node { \n+                            if let LitBool(val) = lit.node {\n                                 if val {\n                                     Some((&*arms[0].body, &*arms[1].body))\n                                 } else {"}, {"sha": "f1c868bec07ebbc27a704b3aa717d2e20063d105", "filename": "src/methods.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e90acaf59629a5997b00f057d8afab67c20b1661/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90acaf59629a5997b00f057d8afab67c20b1661/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=e90acaf59629a5997b00f057d8afab67c20b1661", "patch": "@@ -54,20 +54,19 @@ impl LateLintPass for MethodsPass {\n \n         if let ExprMethodCall(ref name, _, ref args) = expr.node {\n             let (obj_ty, ptr_depth) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&args[0]));\n-            if name.node.as_str() == \"unwrap\" {\n-                if match_type(cx, obj_ty, &OPTION_PATH) {\n+            match &*name.node.as_str() {\n+                \"unwrap\" if match_type(cx, obj_ty, &OPTION_PATH) => {\n                     span_lint(cx, OPTION_UNWRAP_USED, expr.span,\n                               \"used unwrap() on an Option value. If you don't want \\\n                                to handle the None case gracefully, consider using \\\n                                expect() to provide a better panic message\");\n-                } else if match_type(cx, obj_ty, &RESULT_PATH) {\n+                },\n+                \"unwrap\" if match_type(cx, obj_ty, &RESULT_PATH) => {\n                     span_lint(cx, RESULT_UNWRAP_USED, expr.span,\n                               \"used unwrap() on a Result value. Graceful handling \\\n                                of Err values is preferred\");\n-                }\n-            }\n-            else if name.node.as_str() == \"to_string\" {\n-                if obj_ty.sty == ty::TyStr {\n+                },\n+                \"to_string\" if obj_ty.sty == ty::TyStr => {\n                     let mut arg_str = snippet(cx, args[0].span, \"_\");\n                     if ptr_depth > 1 {\n                         arg_str = Cow::Owned(format!(\n@@ -77,13 +76,12 @@ impl LateLintPass for MethodsPass {\n                     }\n                     span_lint(cx, STR_TO_STRING, expr.span, &format!(\n                         \"`{}.to_owned()` is faster\", arg_str));\n-                } else if match_type(cx, obj_ty, &STRING_PATH) {\n+                },\n+                \"to_string\" if match_type(cx, obj_ty, &STRING_PATH) => {\n                     span_lint(cx, STRING_TO_STRING, expr.span, \"`String.to_string()` is a no-op; use \\\n                                                                 `clone()` to make a copy\");\n-                }\n-            }\n-            else if name.node.as_str() == \"expect\" {\n-                if let ExprMethodCall(ref inner_name, _, ref inner_args) = args[0].node {\n+                },\n+                \"expect\" => if let ExprMethodCall(ref inner_name, _, ref inner_args) = args[0].node {\n                     if inner_name.node.as_str() == \"ok\"\n                             && match_type(cx, cx.tcx.expr_ty(&inner_args[0]), &RESULT_PATH) {\n                         let result_type = cx.tcx.expr_ty(&inner_args[0]);\n@@ -96,11 +94,9 @@ impl LateLintPass for MethodsPass {\n                             }\n                         }\n                     }\n-                }\n-            }\n-            // check Option.map(_).unwrap_or(_)\n-            else if name.node.as_str() == \"unwrap_or\" {\n-                if let ExprMethodCall(ref inner_name, _, ref inner_args) = args[0].node {\n+                },\n+                // check Option.map(_).unwrap_or(_)\n+                \"unwrap_or\" => if let ExprMethodCall(ref inner_name, _, ref inner_args) = args[0].node {\n                     if inner_name.node.as_str() == \"map\"\n                             && match_type(cx, cx.tcx.expr_ty(&inner_args[0]), &OPTION_PATH) {\n                         // lint message\n@@ -126,11 +122,9 @@ impl LateLintPass for MethodsPass {\n                             span_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg);\n                         };\n                     }\n-                }\n-            }\n-            // check Option.map(_).unwrap_or_else(_)\n-            else if name.node.as_str() == \"unwrap_or_else\" {\n-                if let ExprMethodCall(ref inner_name, _, ref inner_args) = args[0].node {\n+                },\n+                // check Option.map(_).unwrap_or_else(_)\n+                \"unwrap_or_else\" => if let ExprMethodCall(ref inner_name, _, ref inner_args) = args[0].node {\n                     if inner_name.node.as_str() == \"map\"\n                             && match_type(cx, cx.tcx.expr_ty(&inner_args[0]), &OPTION_PATH) {\n                         // lint message\n@@ -156,7 +150,8 @@ impl LateLintPass for MethodsPass {\n                             span_lint(cx, OPTION_MAP_UNWRAP_OR_ELSE, expr.span, msg);\n                         };\n                     }\n-                }\n+                },\n+                _ => {},\n             }\n         }\n     }"}, {"sha": "365fc1bf99d5743f54d208889d622a286398a698", "filename": "src/utils.rs", "status": "modified", "additions": 64, "deletions": 2, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e90acaf59629a5997b00f057d8afab67c20b1661/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90acaf59629a5997b00f057d8afab67c20b1661/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=e90acaf59629a5997b00f057d8afab67c20b1661", "patch": "@@ -9,6 +9,9 @@ use std::borrow::Cow;\n use syntax::ast::Lit_::*;\n use syntax::ast;\n \n+use rustc::session::Session;\n+use std::str::FromStr;\n+\n // module DefPaths for certain structs/enums we check for\n pub const OPTION_PATH: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n pub const RESULT_PATH: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n@@ -65,8 +68,8 @@ macro_rules! if_let_chain {\n     };\n }\n \n-/// returns true this expn_info was expanded by any macro\n-pub fn in_macro(cx: &LateContext, span: Span) -> bool {\n+/// returns true if this expn_info was expanded by any macro\n+pub fn in_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n     cx.sess().codemap().with_expn_info(span.expn_id,\n             |info| info.is_some())\n }\n@@ -397,3 +400,62 @@ macro_rules! if_let_chain {\n         }\n     };\n }\n+\n+pub struct LimitStack {\n+    stack: Vec<u64>,\n+}\n+\n+impl Drop for LimitStack {\n+    fn drop(&mut self) {\n+        assert_eq!(self.stack.len(), 1);\n+    }\n+}\n+\n+impl LimitStack {\n+    pub fn new(limit: u64) -> LimitStack {\n+        LimitStack {\n+            stack: vec![limit],\n+        }\n+    }\n+    pub fn limit(&self) -> u64 {\n+        *self.stack.last().expect(\"there should always be a value in the stack\")\n+    }\n+    pub fn push_attrs(&mut self, sess: &Session, attrs: &[ast::Attribute], name: &'static str) {\n+        let stack = &mut self.stack;\n+        parse_attrs(\n+            sess,\n+            attrs,\n+            name,\n+            |val| stack.push(val),\n+        );\n+    }\n+    pub fn pop_attrs(&mut self, sess: &Session, attrs: &[ast::Attribute], name: &'static str) {\n+        let stack = &mut self.stack;\n+        parse_attrs(\n+            sess,\n+            attrs,\n+            name,\n+            |val| assert_eq!(stack.pop(), Some(val)),\n+        );\n+    }\n+}\n+\n+fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'static str, mut f: F) {\n+    for attr in attrs {\n+        let attr = &attr.node;\n+        if attr.is_sugared_doc { continue; }\n+        if let ast::MetaNameValue(ref key, ref value) = attr.value.node {\n+            if *key == name {\n+                if let LitStr(ref s, _) = value.node {\n+                    if let Ok(value) = FromStr::from_str(s) {\n+                        f(value)\n+                    } else {\n+                        sess.span_err(value.span, \"not a number\");\n+                    }\n+                } else {\n+                    unreachable!()\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "8e3bf123c26fd5cb93ce9687eac14f1c61eceb1e", "filename": "tests/compile-fail/cyclomatic_complexity.rs", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/e90acaf59629a5997b00f057d8afab67c20b1661/tests%2Fcompile-fail%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90acaf59629a5997b00f057d8afab67c20b1661/tests%2Fcompile-fail%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcyclomatic_complexity.rs?ref=e90acaf59629a5997b00f057d8afab67c20b1661", "patch": "@@ -0,0 +1,181 @@\n+#![feature(plugin, custom_attribute)]\n+#![plugin(clippy)]\n+#![deny(clippy)]\n+#![deny(cyclomatic_complexity)]\n+#![allow(unused)]\n+\n+fn main() { //~ ERROR: The function has a cyclomatic complexity of 28.\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+    if true {\n+        println!(\"a\");\n+    }\n+}\n+\n+#[cyclomatic_complexity = \"0\"]\n+fn kaboom() {  //~ ERROR: The function has a cyclomatic complexity of 6\n+    let n = 0;\n+    'a: for i in 0..20 {\n+        'b: for j in i..20 {\n+            for k in j..20 {\n+                if k == 5 {\n+                    break 'b;\n+                }\n+                if j == 3 && k == 6 {\n+                    continue 'a;\n+                }\n+                if k == j {\n+                    continue;\n+                }\n+                println!(\"bake\");\n+            }\n+        }\n+        println!(\"cake\");\n+    }\n+}\n+\n+fn bloo() {\n+    match 42 {\n+        0 => println!(\"hi\"),\n+        1 => println!(\"hai\"),\n+        2 => println!(\"hey\"),\n+        3 => println!(\"hallo\"),\n+        4 => println!(\"hello\"),\n+        5 => println!(\"salut\"),\n+        6 => println!(\"good morning\"),\n+        7 => println!(\"good evening\"),\n+        8 => println!(\"good afternoon\"),\n+        9 => println!(\"good night\"),\n+        10 => println!(\"bonjour\"),\n+        11 => println!(\"hej\"),\n+        12 => println!(\"hej hej\"),\n+        13 => println!(\"greetings earthling\"),\n+        14 => println!(\"take us to you leader\"),\n+        15 | 17 | 19 | 21 | 23 | 25 | 27 | 29 | 31 | 33 => println!(\"take us to you leader\"),\n+        35 | 37 | 39 | 41 | 43 | 45 | 47 | 49 | 51 | 53 => println!(\"there is no undefined behavior\"),\n+        55 | 57 | 59 | 61 | 63 | 65 | 67 | 69 | 71 | 73 => println!(\"I know borrow-fu\"),\n+        _ => println!(\"bye\"),\n+    }\n+}\n+\n+#[cyclomatic_complexity = \"0\"]\n+fn baa() { //~ ERROR: The function has a cyclomatic complexity of 2\n+    let x = || match 99 {\n+        0 => true,\n+        1 => false,\n+        2 => true,\n+        4 => true,\n+        6 => true,\n+        9 => true,\n+        _ => false,\n+    };\n+    if x() {\n+        println!(\"x\");\n+    } else {\n+        println!(\"not x\");\n+    }\n+}\n+\n+#[cyclomatic_complexity = \"0\"]\n+fn bar() { //~ ERROR: The function has a cyclomatic complexity of 2\n+    match 99 {\n+        0 => println!(\"hi\"),\n+        _ => println!(\"bye\"),\n+    }\n+}\n+\n+#[cyclomatic_complexity = \"0\"]\n+fn barr() { //~ ERROR: The function has a cyclomatic complexity of 2\n+    match 99 {\n+        0 => println!(\"hi\"),\n+        1 => println!(\"bla\"),\n+        2 | 3 => println!(\"blub\"),\n+        _ => println!(\"bye\"),\n+    }\n+}\n+\n+enum Void {}\n+\n+#[cyclomatic_complexity = \"0\"]\n+fn void(void: Void) { //~ ERROR: The function has a cyclomatic complexity of 1\n+    if true {\n+        match void {\n+        }\n+    }\n+}"}, {"sha": "7a18c210d0c7329a4a8ffa6b0ec13e6d7b45bc30", "filename": "tests/compile-fail/for_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e90acaf59629a5997b00f057d8afab67c20b1661/tests%2Fcompile-fail%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90acaf59629a5997b00f057d8afab67c20b1661/tests%2Fcompile-fail%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffor_loop.rs?ref=e90acaf59629a5997b00f057d8afab67c20b1661", "patch": "@@ -16,7 +16,7 @@ impl Unrelated {\n \n #[deny(needless_range_loop, explicit_iter_loop, iter_next_loop, reverse_range_loop, explicit_counter_loop)]\n #[deny(unused_collect)]\n-#[allow(linkedlist,shadow_unrelated,unnecessary_mut_passed)]\n+#[allow(linkedlist,shadow_unrelated,unnecessary_mut_passed, cyclomatic_complexity)]\n fn main() {\n     let mut vec = vec![1, 2, 3, 4];\n     let vec2 = vec![1, 2, 3, 4];"}, {"sha": "ee8e4622e0ec2476fa59973692bdfd3c01898d72", "filename": "tests/compile-fail/while_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e90acaf59629a5997b00f057d8afab67c20b1661/tests%2Fcompile-fail%2Fwhile_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90acaf59629a5997b00f057d8afab67c20b1661/tests%2Fcompile-fail%2Fwhile_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fwhile_loop.rs?ref=e90acaf59629a5997b00f057d8afab67c20b1661", "patch": "@@ -2,7 +2,7 @@\n #![plugin(clippy)]\n \n #![deny(while_let_loop, empty_loop, while_let_on_iterator)]\n-#![allow(dead_code, unused)]\n+#![allow(dead_code, unused, cyclomatic_complexity)]\n \n fn main() {\n     let y = Some(true);"}, {"sha": "61e37c28c94525857ff06f28530274ed13980a17", "filename": "tests/dogfood.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e90acaf59629a5997b00f057d8afab67c20b1661/tests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90acaf59629a5997b00f057d8afab67c20b1661/tests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdogfood.rs?ref=e90acaf59629a5997b00f057d8afab67c20b1661", "patch": "@@ -0,0 +1,24 @@\n+extern crate compiletest_rs as compiletest;\n+\n+use std::path::Path;\n+use std::env::var;\n+\n+#[test]\n+fn dogfood() {\n+    let mut config = compiletest::default_config();\n+\n+    let cfg_mode = \"run-pass\".parse().ok().expect(\"Invalid mode\");\n+    let mut s = String::new();\n+    s.push_str(\" -L target/debug/\");\n+    s.push_str(\" -L target/debug/deps\");\n+    s.push_str(\" -Zextra-plugins=clippy -Ltarget_recur/debug -Dclippy_pedantic -Dclippy\");\n+    config.target_rustcflags = Some(s);\n+    if let Ok(name) = var::<&str>(\"TESTNAME\") {\n+        let s : String = name.to_owned();\n+        config.filter = Some(s)\n+    }\n+\n+    config.mode = cfg_mode;\n+\n+    compiletest::runtest::run(config, &Path::new(\"src/lib.rs\"));\n+}"}]}