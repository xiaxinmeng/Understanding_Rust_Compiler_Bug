{"sha": "8c4fc9d9a45b0577f583abda870386f1f940c706", "node_id": "C_kwDOAAsO6NoAKDhjNGZjOWQ5YTQ1YjA1NzdmNTgzYWJkYTg3MDM4NmYxZjk0MGM3MDY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-06T09:43:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-06T09:43:57Z"}, "message": "Auto merge of #94598 - scottmcm:prefix-free-hasher-methods, r=Amanieu\n\nAdd a dedicated length-prefixing method to `Hasher`\n\nThis accomplishes two main goals:\n- Make it clear who is responsible for prefix-freedom, including how they should do it\n- Make it feasible for a `Hasher` that *doesn't* care about Hash-DoS resistance to get better performance by not hashing lengths\n\nThis does not change rustc-hash, since that's in an external crate, but that could potentially use it in future.\n\nFixes #94026\n\nr? rust-lang/libs\n\n---\n\nThe core of this change is the following two new methods on `Hasher`:\n\n```rust\npub trait Hasher {\n    /// Writes a length prefix into this hasher, as part of being prefix-free.\n    ///\n    /// If you're implementing [`Hash`] for a custom collection, call this before\n    /// writing its contents to this `Hasher`.  That way\n    /// `(collection![1, 2, 3], collection![4, 5])` and\n    /// `(collection![1, 2], collection![3, 4, 5])` will provide different\n    /// sequences of values to the `Hasher`\n    ///\n    /// The `impl<T> Hash for [T]` includes a call to this method, so if you're\n    /// hashing a slice (or array or vector) via its `Hash::hash` method,\n    /// you should **not** call this yourself.\n    ///\n    /// This method is only for providing domain separation.  If you want to\n    /// hash a `usize` that represents part of the *data*, then it's important\n    /// that you pass it to [`Hasher::write_usize`] instead of to this method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(hasher_prefixfree_extras)]\n    /// # // Stubs to make the `impl` below pass the compiler\n    /// # struct MyCollection<T>(Option<T>);\n    /// # impl<T> MyCollection<T> {\n    /// #     fn len(&self) -> usize { todo!() }\n    /// # }\n    /// # impl<'a, T> IntoIterator for &'a MyCollection<T> {\n    /// #     type Item = T;\n    /// #     type IntoIter = std::iter::Empty<T>;\n    /// #     fn into_iter(self) -> Self::IntoIter { todo!() }\n    /// # }\n    ///\n    /// use std::hash::{Hash, Hasher};\n    /// impl<T: Hash> Hash for MyCollection<T> {\n    ///     fn hash<H: Hasher>(&self, state: &mut H) {\n    ///         state.write_length_prefix(self.len());\n    ///         for elt in self {\n    ///             elt.hash(state);\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// # Note to Implementers\n    ///\n    /// If you've decided that your `Hasher` is willing to be susceptible to\n    /// Hash-DoS attacks, then you might consider skipping hashing some or all\n    /// of the `len` provided in the name of increased performance.\n    #[inline]\n    #[unstable(feature = \"hasher_prefixfree_extras\", issue = \"88888888\")]\n    fn write_length_prefix(&mut self, len: usize) {\n        self.write_usize(len);\n    }\n\n    /// Writes a single `str` into this hasher.\n    ///\n    /// If you're implementing [`Hash`], you generally do not need to call this,\n    /// as the `impl Hash for str` does, so you can just use that.\n    ///\n    /// This includes the domain separator for prefix-freedom, so you should\n    /// **not** call `Self::write_length_prefix` before calling this.\n    ///\n    /// # Note to Implementers\n    ///\n    /// The default implementation of this method includes a call to\n    /// [`Self::write_length_prefix`], so if your implementation of `Hasher`\n    /// doesn't care about prefix-freedom and you've thus overridden\n    /// that method to do nothing, there's no need to override this one.\n    ///\n    /// This method is available to be overridden separately from the others\n    /// as `str` being UTF-8 means that it never contains `0xFF` bytes, which\n    /// can be used to provide prefix-freedom cheaper than hashing a length.\n    ///\n    /// For example, if your `Hasher` works byte-by-byte (perhaps by accumulating\n    /// them into a buffer), then you can hash the bytes of the `str` followed\n    /// by a single `0xFF` byte.\n    ///\n    /// If your `Hasher` works in chunks, you can also do this by being careful\n    /// about how you pad partial chunks.  If the chunks are padded with `0x00`\n    /// bytes then just hashing an extra `0xFF` byte doesn't necessarily\n    /// provide prefix-freedom, as `\"ab\"` and `\"ab\\u{0}\"` would likely hash\n    /// the same sequence of chunks.  But if you pad with `0xFF` bytes instead,\n    /// ensuring at least one padding byte, then it can often provide\n    /// prefix-freedom cheaper than hashing the length would.\n    #[inline]\n    #[unstable(feature = \"hasher_prefixfree_extras\", issue = \"88888888\")]\n    fn write_str(&mut self, s: &str) {\n        self.write_length_prefix(s.len());\n        self.write(s.as_bytes());\n    }\n}\n```\n\nWith updates to the `Hash` implementations for slices and containers to call `write_length_prefix` instead of `write_usize`.\n\n`write_str` defaults to using `write_length_prefix` since, as was pointed out in the issue, the `write_u8(0xFF)` approach is insufficient for hashers that work in chunks, as those would hash `\"a\\u{0}\"` and `\"a\"` to the same thing.  But since `SipHash` works byte-wise (there's an internal buffer to accumulate bytes until a full chunk is available) it overrides `write_str` to continue to use the add-non-UTF-8-byte approach.\n\n---\n\nCompatibility:\n\nBecause the default implementation of `write_length_prefix` calls `write_usize`, the changed hash implementation for slices will do the same thing the old one did on existing `Hasher`s.", "tree": {"sha": "83d34377b91bfa28ca3fe9d27448f50eceb4cf13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83d34377b91bfa28ca3fe9d27448f50eceb4cf13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c4fc9d9a45b0577f583abda870386f1f940c706", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c4fc9d9a45b0577f583abda870386f1f940c706", "html_url": "https://github.com/rust-lang/rust/commit/8c4fc9d9a45b0577f583abda870386f1f940c706", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c4fc9d9a45b0577f583abda870386f1f940c706/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059", "html_url": "https://github.com/rust-lang/rust/commit/7f9e013ba62e7bf77a95ba29bcb2c5740b7b2059"}, {"sha": "ebdcb08abf00f193b3787dc32cea97ce74a14963", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebdcb08abf00f193b3787dc32cea97ce74a14963", "html_url": "https://github.com/rust-lang/rust/commit/ebdcb08abf00f193b3787dc32cea97ce74a14963"}], "stats": {"total": 203, "additions": 197, "deletions": 6}, "files": [{"sha": "76ae17f28c6132c8f2d5618062c2162736d31337", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c4fc9d9a45b0577f583abda870386f1f940c706/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4fc9d9a45b0577f583abda870386f1f940c706/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=8c4fc9d9a45b0577f583abda870386f1f940c706", "patch": "@@ -17,6 +17,7 @@\n #![feature(generators)]\n #![feature(let_else)]\n #![feature(hash_raw_entry)]\n+#![feature(hasher_prefixfree_extras)]\n #![feature(maybe_uninit_uninit_array)]\n #![feature(min_specialization)]\n #![feature(never_type)]"}, {"sha": "abd25f46ad54fa2d60b065e6fddcbc71b74dcb7f", "filename": "compiler/rustc_data_structures/src/sip128.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c4fc9d9a45b0577f583abda870386f1f940c706/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4fc9d9a45b0577f583abda870386f1f940c706/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs?ref=8c4fc9d9a45b0577f583abda870386f1f940c706", "patch": "@@ -462,6 +462,14 @@ impl Hasher for SipHasher128 {\n         self.slice_write(msg);\n     }\n \n+    #[inline]\n+    fn write_str(&mut self, s: &str) {\n+        // This hasher works byte-wise, and `0xFF` cannot show up in a `str`,\n+        // so just hashing the one extra byte is enough to be prefix-free.\n+        self.write(s.as_bytes());\n+        self.write_u8(0xFF);\n+    }\n+\n     fn finish(&self) -> u64 {\n         panic!(\"SipHasher128 cannot provide valid 64 bit hashes\")\n     }"}, {"sha": "c8bb4fc5e6af6f2cbccfd9aa78b705e2bbda15a5", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c4fc9d9a45b0577f583abda870386f1f940c706/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4fc9d9a45b0577f583abda870386f1f940c706/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=8c4fc9d9a45b0577f583abda870386f1f940c706", "patch": "@@ -73,6 +73,17 @@ impl Hasher for StableHasher {\n         self.state.write(bytes);\n     }\n \n+    #[inline]\n+    fn write_str(&mut self, s: &str) {\n+        self.state.write_str(s);\n+    }\n+\n+    #[inline]\n+    fn write_length_prefix(&mut self, len: usize) {\n+        // Our impl for `usize` will extend it if needed.\n+        self.write_usize(len);\n+    }\n+\n     #[inline]\n     fn write_u8(&mut self, i: u8) {\n         self.state.write_u8(i);"}, {"sha": "c07536f0d0ce1c997a3d415d8886fec4237ec1cd", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=8c4fc9d9a45b0577f583abda870386f1f940c706", "patch": "@@ -1369,6 +1369,12 @@ impl<T: ?Sized + Hasher, A: Allocator> Hasher for Box<T, A> {\n     fn write_isize(&mut self, i: isize) {\n         (**self).write_isize(i)\n     }\n+    fn write_length_prefix(&mut self, len: usize) {\n+        (**self).write_length_prefix(len)\n+    }\n+    fn write_str(&mut self, s: &str) {\n+        (**self).write_str(s)\n+    }\n }\n \n #[cfg(not(no_global_oom_handling))]"}, {"sha": "264c217c9ef235faa2e96b2b5e485f868a84f3d7", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=8c4fc9d9a45b0577f583abda870386f1f940c706", "patch": "@@ -1990,7 +1990,7 @@ impl<'a, K: Ord + Copy, V: Copy> Extend<(&'a K, &'a V)> for BTreeMap<K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Hash, V: Hash> Hash for BTreeMap<K, V> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.len().hash(state);\n+        state.write_length_prefix(self.len());\n         for elt in self {\n             elt.hash(state);\n         }"}, {"sha": "67dc4f30f3179c9d6681f900443cf224f2ac8f5a", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=8c4fc9d9a45b0577f583abda870386f1f940c706", "patch": "@@ -1944,7 +1944,7 @@ impl<T: fmt::Debug> fmt::Debug for LinkedList<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Hash> Hash for LinkedList<T> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.len().hash(state);\n+        state.write_length_prefix(self.len());\n         for elt in self {\n             elt.hash(state);\n         }"}, {"sha": "04900ead579a14510ae7b23004c3d47c18399c53", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=8c4fc9d9a45b0577f583abda870386f1f940c706", "patch": "@@ -2899,7 +2899,7 @@ impl<T: Ord, A: Allocator> Ord for VecDeque<T, A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Hash, A: Allocator> Hash for VecDeque<T, A> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.len().hash(state);\n+        state.write_length_prefix(self.len());\n         // It's not possible to use Hash::hash_slice on slices\n         // returned by as_slices method as their length can vary\n         // in otherwise identical deques."}, {"sha": "ecebc7ed9ac850692661f014e4df15f024b04199", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=8c4fc9d9a45b0577f583abda870386f1f940c706", "patch": "@@ -117,6 +117,7 @@\n #![feature(extend_one)]\n #![feature(fmt_internals)]\n #![feature(fn_traits)]\n+#![feature(hasher_prefixfree_extras)]\n #![feature(inplace_iteration)]\n #![feature(iter_advance_by)]\n #![feature(layout_for_ptr)]"}, {"sha": "9d64c786d67b5111167a92e3b92d81c4733690fc", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 135, "deletions": 3, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=8c4fc9d9a45b0577f583abda870386f1f940c706", "patch": "@@ -333,6 +333,12 @@ pub trait Hasher {\n     ///\n     /// println!(\"Hash is {:x}!\", hasher.finish());\n     /// ```\n+    ///\n+    /// # Note to Implementers\n+    ///\n+    /// You generally should not do length-prefixing as part of implementing\n+    /// this method.  It's up to the [`Hash`] implementation to call\n+    /// [`Hasher::write_length_prefix`] before sequences that need it.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write(&mut self, bytes: &[u8]);\n \n@@ -409,6 +415,127 @@ pub trait Hasher {\n     fn write_isize(&mut self, i: isize) {\n         self.write_usize(i as usize)\n     }\n+\n+    /// Writes a length prefix into this hasher, as part of being prefix-free.\n+    ///\n+    /// If you're implementing [`Hash`] for a custom collection, call this before\n+    /// writing its contents to this `Hasher`.  That way\n+    /// `(collection![1, 2, 3], collection![4, 5])` and\n+    /// `(collection![1, 2], collection![3, 4, 5])` will provide different\n+    /// sequences of values to the `Hasher`\n+    ///\n+    /// The `impl<T> Hash for [T]` includes a call to this method, so if you're\n+    /// hashing a slice (or array or vector) via its `Hash::hash` method,\n+    /// you should **not** call this yourself.\n+    ///\n+    /// This method is only for providing domain separation.  If you want to\n+    /// hash a `usize` that represents part of the *data*, then it's important\n+    /// that you pass it to [`Hasher::write_usize`] instead of to this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(hasher_prefixfree_extras)]\n+    /// # // Stubs to make the `impl` below pass the compiler\n+    /// # struct MyCollection<T>(Option<T>);\n+    /// # impl<T> MyCollection<T> {\n+    /// #     fn len(&self) -> usize { todo!() }\n+    /// # }\n+    /// # impl<'a, T> IntoIterator for &'a MyCollection<T> {\n+    /// #     type Item = T;\n+    /// #     type IntoIter = std::iter::Empty<T>;\n+    /// #     fn into_iter(self) -> Self::IntoIter { todo!() }\n+    /// # }\n+    ///\n+    /// use std::hash::{Hash, Hasher};\n+    /// impl<T: Hash> Hash for MyCollection<T> {\n+    ///     fn hash<H: Hasher>(&self, state: &mut H) {\n+    ///         state.write_length_prefix(self.len());\n+    ///         for elt in self {\n+    ///             elt.hash(state);\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// # Note to Implementers\n+    ///\n+    /// If you've decided that your `Hasher` is willing to be susceptible to\n+    /// Hash-DoS attacks, then you might consider skipping hashing some or all\n+    /// of the `len` provided in the name of increased performance.\n+    #[inline]\n+    #[unstable(feature = \"hasher_prefixfree_extras\", issue = \"96762\")]\n+    fn write_length_prefix(&mut self, len: usize) {\n+        self.write_usize(len);\n+    }\n+\n+    /// Writes a single `str` into this hasher.\n+    ///\n+    /// If you're implementing [`Hash`], you generally do not need to call this,\n+    /// as the `impl Hash for str` does, so you should prefer that instead.\n+    ///\n+    /// This includes the domain separator for prefix-freedom, so you should\n+    /// **not** call `Self::write_length_prefix` before calling this.\n+    ///\n+    /// # Note to Implementers\n+    ///\n+    /// There are at least two reasonable default ways to implement this.\n+    /// Which one will be the default is not yet decided, so for now\n+    /// you probably want to override it specifically.\n+    ///\n+    /// ## The general answer\n+    ///\n+    /// It's always correct to implement this with a length prefix:\n+    ///\n+    /// ```\n+    /// # #![feature(hasher_prefixfree_extras)]\n+    /// # struct Foo;\n+    /// # impl std::hash::Hasher for Foo {\n+    /// # fn finish(&self) -> u64 { unimplemented!() }\n+    /// # fn write(&mut self, _bytes: &[u8]) { unimplemented!() }\n+    /// fn write_str(&mut self, s: &str) {\n+    ///     self.write_length_prefix(s.len());\n+    ///     self.write(s.as_bytes());\n+    /// }\n+    /// # }\n+    /// ```\n+    ///\n+    /// And, if your `Hasher` works in `usize` chunks, this is likely a very\n+    /// efficient way to do it, as anything more complicated may well end up\n+    /// slower than just running the round with the length.\n+    ///\n+    /// ## If your `Hasher` works byte-wise\n+    ///\n+    /// One nice thing about `str` being UTF-8 is that the `b'\\xFF'` byte\n+    /// never happens.  That means that you can append that to the byte stream\n+    /// being hashed and maintain prefix-freedom:\n+    ///\n+    /// ```\n+    /// # #![feature(hasher_prefixfree_extras)]\n+    /// # struct Foo;\n+    /// # impl std::hash::Hasher for Foo {\n+    /// # fn finish(&self) -> u64 { unimplemented!() }\n+    /// # fn write(&mut self, _bytes: &[u8]) { unimplemented!() }\n+    /// fn write_str(&mut self, s: &str) {\n+    ///     self.write(s.as_bytes());\n+    ///     self.write_u8(0xff);\n+    /// }\n+    /// # }\n+    /// ```\n+    ///\n+    /// This does require that your implementation not add extra padding, and\n+    /// thus generally requires that you maintain a buffer, running a round\n+    /// only once that buffer is full (or `finish` is called).\n+    ///\n+    /// That's because if `write` pads data out to a fixed chunk size, it's\n+    /// likely that it does it in such a way that `\"a\"` and `\"a\\x00\"` would\n+    /// end up hashing the same sequence of things, introducing conflicts.\n+    #[inline]\n+    #[unstable(feature = \"hasher_prefixfree_extras\", issue = \"96762\")]\n+    fn write_str(&mut self, s: &str) {\n+        self.write(s.as_bytes());\n+        self.write_u8(0xff);\n+    }\n }\n \n #[stable(feature = \"indirect_hasher_impl\", since = \"1.22.0\")]\n@@ -455,6 +582,12 @@ impl<H: Hasher + ?Sized> Hasher for &mut H {\n     fn write_isize(&mut self, i: isize) {\n         (**self).write_isize(i)\n     }\n+    fn write_length_prefix(&mut self, len: usize) {\n+        (**self).write_length_prefix(len)\n+    }\n+    fn write_str(&mut self, s: &str) {\n+        (**self).write_str(s)\n+    }\n }\n \n /// A trait for creating instances of [`Hasher`].\n@@ -709,8 +842,7 @@ mod impls {\n     impl Hash for str {\n         #[inline]\n         fn hash<H: Hasher>(&self, state: &mut H) {\n-            state.write(self.as_bytes());\n-            state.write_u8(0xff)\n+            state.write_str(self);\n         }\n     }\n \n@@ -767,7 +899,7 @@ mod impls {\n     impl<T: Hash> Hash for [T] {\n         #[inline]\n         fn hash<H: Hasher>(&self, state: &mut H) {\n-            self.len().hash(state);\n+            state.write_length_prefix(self.len());\n             Hash::hash_slice(self, state)\n         }\n     }"}, {"sha": "9d7daf1f1a075f9cb9a390eafc8fabcb2d44487f", "filename": "library/core/src/hash/sip.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs?ref=8c4fc9d9a45b0577f583abda870386f1f940c706", "patch": "@@ -233,6 +233,11 @@ impl super::Hasher for SipHasher {\n         self.0.hasher.write(msg)\n     }\n \n+    #[inline]\n+    fn write_str(&mut self, s: &str) {\n+        self.0.hasher.write_str(s);\n+    }\n+\n     #[inline]\n     fn finish(&self) -> u64 {\n         self.0.hasher.finish()\n@@ -246,6 +251,11 @@ impl super::Hasher for SipHasher13 {\n         self.hasher.write(msg)\n     }\n \n+    #[inline]\n+    fn write_str(&mut self, s: &str) {\n+        self.hasher.write_str(s);\n+    }\n+\n     #[inline]\n     fn finish(&self) -> u64 {\n         self.hasher.finish()\n@@ -307,6 +317,14 @@ impl<S: Sip> super::Hasher for Hasher<S> {\n         self.ntail = left;\n     }\n \n+    #[inline]\n+    fn write_str(&mut self, s: &str) {\n+        // This hasher works byte-wise, and `0xFF` cannot show up in a `str`,\n+        // so just hashing the one extra byte is enough to be prefix-free.\n+        self.write(s.as_bytes());\n+        self.write_u8(0xFF);\n+    }\n+\n     #[inline]\n     fn finish(&self) -> u64 {\n         let mut state = self.state;"}, {"sha": "5bc6aac1778f50a62249da8c9a5778d0b1fd09ab", "filename": "library/core/tests/hash/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Fcore%2Ftests%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Fcore%2Ftests%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fhash%2Fmod.rs?ref=8c4fc9d9a45b0577f583abda870386f1f940c706", "patch": "@@ -20,6 +20,10 @@ impl Hasher for MyHasher {\n             self.hash += *byte as u64;\n         }\n     }\n+    fn write_str(&mut self, s: &str) {\n+        self.write(s.as_bytes());\n+        self.write_u8(0xFF);\n+    }\n     fn finish(&self) -> u64 {\n         self.hash\n     }"}, {"sha": "31b764a6e2d52d9c08e9453502de313cc36acc2a", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=8c4fc9d9a45b0577f583abda870386f1f940c706", "patch": "@@ -36,6 +36,7 @@\n #![feature(future_join)]\n #![feature(future_poll_fn)]\n #![feature(array_from_fn)]\n+#![feature(hasher_prefixfree_extras)]\n #![feature(hashmap_internals)]\n #![feature(try_find)]\n #![feature(inline_const)]"}, {"sha": "e38368790e69a10693aa1e7f8e5311c8bd79edd5", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=8c4fc9d9a45b0577f583abda870386f1f940c706", "patch": "@@ -3006,11 +3006,19 @@ impl Default for DefaultHasher {\n \n #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n impl Hasher for DefaultHasher {\n+    // The underlying `SipHasher13` doesn't override the other\n+    // `write_*` methods, so it's ok not to forward them here.\n+\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         self.0.write(msg)\n     }\n \n+    #[inline]\n+    fn write_str(&mut self, s: &str) {\n+        self.0.write_str(s);\n+    }\n+\n     #[inline]\n     fn finish(&self) -> u64 {\n         self.0.finish()"}, {"sha": "c394865d886e85bdc8e120c7753006897b6b9965", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4fc9d9a45b0577f583abda870386f1f940c706/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=8c4fc9d9a45b0577f583abda870386f1f940c706", "patch": "@@ -271,6 +271,7 @@\n #![feature(exact_size_is_empty)]\n #![feature(extend_one)]\n #![feature(float_minimum_maximum)]\n+#![feature(hasher_prefixfree_extras)]\n #![feature(hashmap_internals)]\n #![feature(int_error_internals)]\n #![feature(maybe_uninit_slice)]"}]}