{"sha": "7fe2c4b00dfbc33643e1af4b293eb057306a8339", "node_id": "C_kwDOAAsO6NoAKDdmZTJjNGIwMGRmYmMzMzY0M2UxYWY0YjI5M2ViMDU3MzA2YTgzMzk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-07T11:08:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-07T11:08:58Z"}, "message": "Auto merge of #97825 - Dylan-DPC:rollup-ya51k1k, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #97058 (Various refactors to the incr comp workproduct handling)\n - #97301 (Allow unstable items to be re-exported unstably without requiring the feature be enabled)\n - #97738 (Fix ICEs from zsts within unsized types with non-zero offsets)\n - #97771 (Remove SIGIO reference on Haiku)\n - #97808 (Add some unstable target features for the wasm target codegen)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "89cb7f71b608fa16f00b3efd70c4afbefd51280a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89cb7f71b608fa16f00b3efd70c4afbefd51280a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fe2c4b00dfbc33643e1af4b293eb057306a8339", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fe2c4b00dfbc33643e1af4b293eb057306a8339", "html_url": "https://github.com/rust-lang/rust/commit/7fe2c4b00dfbc33643e1af4b293eb057306a8339", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fe2c4b00dfbc33643e1af4b293eb057306a8339/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91cacb3faf987805675e39aca41859ec1fcabef3", "url": "https://api.github.com/repos/rust-lang/rust/commits/91cacb3faf987805675e39aca41859ec1fcabef3", "html_url": "https://github.com/rust-lang/rust/commit/91cacb3faf987805675e39aca41859ec1fcabef3"}, {"sha": "95266530d5b97a51b4ad110733fa276f85c27b43", "url": "https://api.github.com/repos/rust-lang/rust/commits/95266530d5b97a51b4ad110733fa276f85c27b43", "html_url": "https://github.com/rust-lang/rust/commit/95266530d5b97a51b4ad110733fa276f85c27b43"}], "stats": {"total": 399, "additions": 284, "deletions": 115}, "files": [{"sha": "05457ce15e9a7d8bfce0d6747bd888373e25f033", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=7fe2c4b00dfbc33643e1af4b293eb057306a8339", "patch": "@@ -66,11 +66,7 @@ fn emit_module(\n     let work_product = if backend_config.disable_incr_cache {\n         None\n     } else {\n-        rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(\n-            tcx.sess,\n-            &name,\n-            &Some(tmp_file.clone()),\n-        )\n+        rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(tcx.sess, &name, &tmp_file)\n     };\n \n     ModuleCodegenResult(\n@@ -84,29 +80,24 @@ fn reuse_workproduct_for_cgu(\n     cgu: &CodegenUnit<'_>,\n     work_products: &mut FxHashMap<WorkProductId, WorkProduct>,\n ) -> CompiledModule {\n-    let mut object = None;\n-    let work_product = cgu.work_product(tcx);\n-    if let Some(saved_file) = &work_product.saved_file {\n-        let obj_out =\n-            tcx.output_filenames(()).temp_path(OutputType::Object, Some(cgu.name().as_str()));\n-        object = Some(obj_out.clone());\n-        let source_file = rustc_incremental::in_incr_comp_dir_sess(&tcx.sess, &saved_file);\n-        if let Err(err) = rustc_fs_util::link_or_copy(&source_file, &obj_out) {\n-            tcx.sess.err(&format!(\n-                \"unable to copy {} to {}: {}\",\n-                source_file.display(),\n-                obj_out.display(),\n-                err\n-            ));\n-        }\n+    let work_product = cgu.previous_work_product(tcx);\n+    let obj_out = tcx.output_filenames(()).temp_path(OutputType::Object, Some(cgu.name().as_str()));\n+    let source_file = rustc_incremental::in_incr_comp_dir_sess(&tcx.sess, &work_product.saved_file);\n+    if let Err(err) = rustc_fs_util::link_or_copy(&source_file, &obj_out) {\n+        tcx.sess.err(&format!(\n+            \"unable to copy {} to {}: {}\",\n+            source_file.display(),\n+            obj_out.display(),\n+            err\n+        ));\n     }\n \n     work_products.insert(cgu.work_product_id(), work_product);\n \n     CompiledModule {\n         name: cgu.name().to_string(),\n         kind: ModuleKind::Regular,\n-        object,\n+        object: Some(obj_out),\n         dwarf_object: None,\n         bytecode: None,\n     }"}, {"sha": "02c7c1a435fae2537b260f8cb9e88b27719f720d", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=7fe2c4b00dfbc33643e1af4b293eb057306a8339", "patch": "@@ -494,12 +494,12 @@ fn copy_all_cgu_workproducts_to_incr_comp_cache_dir(\n     let _timer = sess.timer(\"copy_all_cgu_workproducts_to_incr_comp_cache_dir\");\n \n     for module in compiled_modules.modules.iter().filter(|m| m.kind == ModuleKind::Regular) {\n-        let path = module.object.as_ref().cloned();\n-\n-        if let Some((id, product)) =\n-            copy_cgu_workproduct_to_incr_comp_cache_dir(sess, &module.name, &path)\n-        {\n-            work_products.insert(id, product);\n+        if let Some(path) = &module.object {\n+            if let Some((id, product)) =\n+                copy_cgu_workproduct_to_incr_comp_cache_dir(sess, &module.name, path)\n+            {\n+                work_products.insert(id, product);\n+            }\n         }\n     }\n \n@@ -853,35 +853,31 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n     module: CachedModuleCodegen,\n     module_config: &ModuleConfig,\n ) -> WorkItemResult<B> {\n+    assert!(module_config.emit_obj != EmitObj::None);\n+\n     let incr_comp_session_dir = cgcx.incr_comp_session_dir.as_ref().unwrap();\n-    let mut object = None;\n-    if let Some(saved_file) = module.source.saved_file {\n-        let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, Some(&module.name));\n-        object = Some(obj_out.clone());\n-        let source_file = in_incr_comp_dir(&incr_comp_session_dir, &saved_file);\n-        debug!(\n-            \"copying pre-existing module `{}` from {:?} to {}\",\n-            module.name,\n-            source_file,\n-            obj_out.display()\n-        );\n-        if let Err(err) = link_or_copy(&source_file, &obj_out) {\n-            let diag_handler = cgcx.create_diag_handler();\n-            diag_handler.err(&format!(\n-                \"unable to copy {} to {}: {}\",\n-                source_file.display(),\n-                obj_out.display(),\n-                err\n-            ));\n-        }\n+    let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, Some(&module.name));\n+    let source_file = in_incr_comp_dir(&incr_comp_session_dir, &module.source.saved_file);\n+    debug!(\n+        \"copying pre-existing module `{}` from {:?} to {}\",\n+        module.name,\n+        source_file,\n+        obj_out.display()\n+    );\n+    if let Err(err) = link_or_copy(&source_file, &obj_out) {\n+        let diag_handler = cgcx.create_diag_handler();\n+        diag_handler.err(&format!(\n+            \"unable to copy {} to {}: {}\",\n+            source_file.display(),\n+            obj_out.display(),\n+            err\n+        ));\n     }\n \n-    assert_eq!(object.is_some(), module_config.emit_obj != EmitObj::None);\n-\n     WorkItemResult::Compiled(CompiledModule {\n         name: module.name,\n         kind: ModuleKind::Regular,\n-        object,\n+        object: Some(obj_out),\n         dwarf_object: None,\n         bytecode: None,\n     })"}, {"sha": "7e2e85ead5469044af314f1cf226195cc19dd08e", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=7fe2c4b00dfbc33643e1af4b293eb057306a8339", "patch": "@@ -216,11 +216,12 @@ pub fn unsize_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             let mut result = None;\n             for i in 0..src_layout.fields.count() {\n                 let src_f = src_layout.field(bx.cx(), i);\n-                assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n-                assert_eq!(dst_layout.fields.offset(i).bytes(), 0);\n                 if src_f.is_zst() {\n                     continue;\n                 }\n+\n+                assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n+                assert_eq!(dst_layout.fields.offset(i).bytes(), 0);\n                 assert_eq!(src_layout.size, src_f.size);\n \n                 let dst_f = dst_layout.field(bx.cx(), i);\n@@ -716,7 +717,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n                     &ongoing_codegen.coordinator_send,\n                     CachedModuleCodegen {\n                         name: cgu.name().to_string(),\n-                        source: cgu.work_product(tcx),\n+                        source: cgu.previous_work_product(tcx),\n                     },\n                 );\n                 true\n@@ -727,7 +728,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n                     &ongoing_codegen.coordinator_send,\n                     CachedModuleCodegen {\n                         name: cgu.name().to_string(),\n-                        source: cgu.work_product(tcx),\n+                        source: cgu.previous_work_product(tcx),\n                     },\n                 );\n                 true"}, {"sha": "bfdef2dc0e80c802894518c24638ab8c575c9c9b", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=7fe2c4b00dfbc33643e1af4b293eb057306a8339", "patch": "@@ -246,6 +246,9 @@ const WASM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"simd128\", None),\n     (\"atomics\", Some(sym::wasm_target_feature)),\n     (\"nontrapping-fptoint\", Some(sym::wasm_target_feature)),\n+    (\"bulk-memory\", Some(sym::wasm_target_feature)),\n+    (\"mutable-globals\", Some(sym::wasm_target_feature)),\n+    (\"reference-types\", Some(sym::wasm_target_feature)),\n ];\n \n const BPF_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[(\"alu32\", Some(sym::bpf_target_feature))];"}, {"sha": "9de14950aa8d33d23ad9bd353261e5d1eff99bf6", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=7fe2c4b00dfbc33643e1af4b293eb057306a8339", "patch": "@@ -162,18 +162,16 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n \n             for swp in work_products {\n                 let mut all_files_exist = true;\n-                if let Some(ref file_name) = swp.work_product.saved_file {\n-                    let path = in_incr_comp_dir_sess(sess, file_name);\n-                    if !path.exists() {\n-                        all_files_exist = false;\n-\n-                        if sess.opts.debugging_opts.incremental_info {\n-                            eprintln!(\n-                                \"incremental: could not find file for work \\\n+                let path = in_incr_comp_dir_sess(sess, &swp.work_product.saved_file);\n+                if !path.exists() {\n+                    all_files_exist = false;\n+\n+                    if sess.opts.debugging_opts.incremental_info {\n+                        eprintln!(\n+                            \"incremental: could not find file for work \\\n                                     product: {}\",\n-                                path.display()\n-                            );\n-                        }\n+                            path.display()\n+                        );\n                     }\n                 }\n "}, {"sha": "0223976b08a5bf7e36640daafdba3c8adc106c30", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=7fe2c4b00dfbc33643e1af4b293eb057306a8339", "patch": "@@ -107,20 +107,15 @@ pub fn save_work_product_index(\n     for (id, wp) in previous_work_products.iter() {\n         if !new_work_products.contains_key(id) {\n             work_product::delete_workproduct_files(sess, wp);\n-            debug_assert!(\n-                wp.saved_file.as_ref().map_or(true, |file_name| {\n-                    !in_incr_comp_dir_sess(sess, &file_name).exists()\n-                })\n-            );\n+            debug_assert!(!in_incr_comp_dir_sess(sess, &wp.saved_file).exists());\n         }\n     }\n \n     // Check that we did not delete one of the current work-products:\n     debug_assert!({\n         new_work_products\n             .iter()\n-            .flat_map(|(_, wp)| wp.saved_file.iter())\n-            .map(|name| in_incr_comp_dir_sess(sess, name))\n+            .map(|(_, wp)| in_incr_comp_dir_sess(sess, &wp.saved_file))\n             .all(|path| path.exists())\n     });\n }"}, {"sha": "4789c0f581fdb952971d28d748ceeedb1c0c72ea", "filename": "compiler/rustc_incremental/src/persist/work_product.rs", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fwork_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fwork_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fwork_product.rs?ref=7fe2c4b00dfbc33643e1af4b293eb057306a8339", "patch": "@@ -7,34 +7,30 @@ use rustc_fs_util::link_or_copy;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_session::Session;\n use std::fs as std_fs;\n-use std::path::PathBuf;\n+use std::path::Path;\n \n /// Copies a CGU work product to the incremental compilation directory, so next compilation can find and reuse it.\n pub fn copy_cgu_workproduct_to_incr_comp_cache_dir(\n     sess: &Session,\n     cgu_name: &str,\n-    path: &Option<PathBuf>,\n+    path: &Path,\n ) -> Option<(WorkProductId, WorkProduct)> {\n     debug!(\"copy_cgu_workproduct_to_incr_comp_cache_dir({:?},{:?})\", cgu_name, path);\n     sess.opts.incremental.as_ref()?;\n \n-    let saved_file = if let Some(path) = path {\n-        let file_name = format!(\"{}.o\", cgu_name);\n-        let path_in_incr_dir = in_incr_comp_dir_sess(sess, &file_name);\n-        match link_or_copy(path, &path_in_incr_dir) {\n-            Ok(_) => Some(file_name),\n-            Err(err) => {\n-                sess.warn(&format!(\n-                    \"error copying object file `{}` to incremental directory as `{}`: {}\",\n-                    path.display(),\n-                    path_in_incr_dir.display(),\n-                    err\n-                ));\n-                return None;\n-            }\n+    let file_name = format!(\"{}.o\", cgu_name);\n+    let path_in_incr_dir = in_incr_comp_dir_sess(sess, &file_name);\n+    let saved_file = match link_or_copy(path, &path_in_incr_dir) {\n+        Ok(_) => file_name,\n+        Err(err) => {\n+            sess.warn(&format!(\n+                \"error copying object file `{}` to incremental directory as `{}`: {}\",\n+                path.display(),\n+                path_in_incr_dir.display(),\n+                err\n+            ));\n+            return None;\n         }\n-    } else {\n-        None\n     };\n \n     let work_product = WorkProduct { cgu_name: cgu_name.to_string(), saved_file };\n@@ -45,17 +41,15 @@ pub fn copy_cgu_workproduct_to_incr_comp_cache_dir(\n \n /// Removes files for a given work product.\n pub fn delete_workproduct_files(sess: &Session, work_product: &WorkProduct) {\n-    if let Some(ref file_name) = work_product.saved_file {\n-        let path = in_incr_comp_dir_sess(sess, file_name);\n-        match std_fs::remove_file(&path) {\n-            Ok(()) => {}\n-            Err(err) => {\n-                sess.warn(&format!(\n-                    \"file-system error deleting outdated file `{}`: {}\",\n-                    path.display(),\n-                    err\n-                ));\n-            }\n+    let path = in_incr_comp_dir_sess(sess, &work_product.saved_file);\n+    match std_fs::remove_file(&path) {\n+        Ok(()) => {}\n+        Err(err) => {\n+            sess.warn(&format!(\n+                \"file-system error deleting outdated file `{}`: {}\",\n+                path.display(),\n+                err\n+            ));\n         }\n     }\n }"}, {"sha": "62e0fec06615ed347df5916e3ad23aef13395c09", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 69, "deletions": 8, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=7fe2c4b00dfbc33643e1af4b293eb057306a8339", "patch": "@@ -9,10 +9,9 @@ use rustc_attr::{self as attr, ConstStability, Deprecation, Stability};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_feature::GateIssue;\n-use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_hir::{self, HirId};\n+use rustc_hir::{self as hir, HirId};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_session::lint::builtin::{DEPRECATED, DEPRECATED_IN_FUTURE, SOFT_UNSTABLE};\n use rustc_session::lint::{BuiltinLintDiagnostics, Level, Lint, LintBuffer};\n@@ -306,6 +305,14 @@ fn suggestion_for_allocator_api(\n     None\n }\n \n+/// An override option for eval_stability.\n+pub enum AllowUnstable {\n+    /// Don't emit an unstable error for the item\n+    Yes,\n+    /// Handle the item normally\n+    No,\n+}\n+\n impl<'tcx> TyCtxt<'tcx> {\n     /// Evaluates the stability of an item.\n     ///\n@@ -322,6 +329,28 @@ impl<'tcx> TyCtxt<'tcx> {\n         id: Option<HirId>,\n         span: Span,\n         method_span: Option<Span>,\n+    ) -> EvalResult {\n+        self.eval_stability_allow_unstable(def_id, id, span, method_span, AllowUnstable::No)\n+    }\n+\n+    /// Evaluates the stability of an item.\n+    ///\n+    /// Returns `EvalResult::Allow` if the item is stable, or unstable but the corresponding\n+    /// `#![feature]` has been provided. Returns `EvalResult::Deny` which describes the offending\n+    /// unstable feature otherwise.\n+    ///\n+    /// If `id` is `Some(_)`, this function will also check if the item at `def_id` has been\n+    /// deprecated. If the item is indeed deprecated, we will emit a deprecation lint attached to\n+    /// `id`.\n+    ///\n+    /// Pass `AllowUnstable::Yes` to `allow_unstable` to force an unstable item to be allowed. Deprecation warnings will be emitted normally.\n+    pub fn eval_stability_allow_unstable(\n+        self,\n+        def_id: DefId,\n+        id: Option<HirId>,\n+        span: Span,\n+        method_span: Option<Span>,\n+        allow_unstable: AllowUnstable,\n     ) -> EvalResult {\n         // Deprecated attributes apply in-crate and cross-crate.\n         if let Some(id) = id {\n@@ -419,6 +448,10 @@ impl<'tcx> TyCtxt<'tcx> {\n                     }\n                 }\n \n+                if matches!(allow_unstable, AllowUnstable::Yes) {\n+                    return EvalResult::Allow;\n+                }\n+\n                 let suggestion = suggestion_for_allocator_api(self, def_id, span, feature);\n                 EvalResult::Deny { feature, reason, issue, suggestion, is_soft }\n             }\n@@ -445,11 +478,38 @@ impl<'tcx> TyCtxt<'tcx> {\n         span: Span,\n         method_span: Option<Span>,\n     ) {\n-        self.check_optional_stability(def_id, id, span, method_span, |span, def_id| {\n-            // The API could be uncallable for other reasons, for example when a private module\n-            // was referenced.\n-            self.sess.delay_span_bug(span, &format!(\"encountered unmarked API: {:?}\", def_id));\n-        })\n+        self.check_stability_allow_unstable(def_id, id, span, method_span, AllowUnstable::No)\n+    }\n+\n+    /// Checks if an item is stable or error out.\n+    ///\n+    /// If the item defined by `def_id` is unstable and the corresponding `#![feature]` does not\n+    /// exist, emits an error.\n+    ///\n+    /// This function will also check if the item is deprecated.\n+    /// If so, and `id` is not `None`, a deprecated lint attached to `id` will be emitted.\n+    ///\n+    /// Pass `AllowUnstable::Yes` to `allow_unstable` to force an unstable item to be allowed. Deprecation warnings will be emitted normally.\n+    pub fn check_stability_allow_unstable(\n+        self,\n+        def_id: DefId,\n+        id: Option<HirId>,\n+        span: Span,\n+        method_span: Option<Span>,\n+        allow_unstable: AllowUnstable,\n+    ) {\n+        self.check_optional_stability(\n+            def_id,\n+            id,\n+            span,\n+            method_span,\n+            allow_unstable,\n+            |span, def_id| {\n+                // The API could be uncallable for other reasons, for example when a private module\n+                // was referenced.\n+                self.sess.delay_span_bug(span, &format!(\"encountered unmarked API: {:?}\", def_id));\n+            },\n+        )\n     }\n \n     /// Like `check_stability`, except that we permit items to have custom behaviour for\n@@ -462,14 +522,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         id: Option<HirId>,\n         span: Span,\n         method_span: Option<Span>,\n+        allow_unstable: AllowUnstable,\n         unmarked: impl FnOnce(Span, DefId),\n     ) {\n         let soft_handler = |lint, span, msg: &_| {\n             self.struct_span_lint_hir(lint, id.unwrap_or(hir::CRATE_HIR_ID), span, |lint| {\n                 lint.build(msg).emit();\n             })\n         };\n-        match self.eval_stability(def_id, id, span, method_span) {\n+        match self.eval_stability_allow_unstable(def_id, id, span, method_span, allow_unstable) {\n             EvalResult::Allow => {}\n             EvalResult::Deny { feature, reason, issue, suggestion, is_soft } => report_unstable(\n                 self.sess,"}, {"sha": "021f2782736460e043fdc2b090527496cf7266f1", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=7fe2c4b00dfbc33643e1af4b293eb057306a8339", "patch": "@@ -336,7 +336,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n         WorkProductId::from_cgu_name(self.name().as_str())\n     }\n \n-    pub fn work_product(&self, tcx: TyCtxt<'_>) -> WorkProduct {\n+    pub fn previous_work_product(&self, tcx: TyCtxt<'_>) -> WorkProduct {\n         let work_product_id = self.work_product_id();\n         tcx.dep_graph\n             .previous_work_product(&work_product_id)"}, {"sha": "144a60faad265610c7e937d137b0370119ef2cf4", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=7fe2c4b00dfbc33643e1af4b293eb057306a8339", "patch": "@@ -9,10 +9,10 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::hir_id::CRATE_HIR_ID;\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{FieldDef, Generics, HirId, Item, TraitRef, Ty, TyKind, Variant};\n+use rustc_hir::{FieldDef, Generics, HirId, Item, ItemKind, TraitRef, Ty, TyKind, Variant};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::privacy::AccessLevels;\n-use rustc_middle::middle::stability::{DeprecationEntry, Index};\n+use rustc_middle::middle::stability::{AllowUnstable, DeprecationEntry, Index};\n use rustc_middle::ty::{self, query::Providers, TyCtxt};\n use rustc_session::lint;\n use rustc_session::lint::builtin::{INEFFECTIVE_UNSTABLE_TRAIT_IMPL, USELESS_DEPRECATED};\n@@ -807,12 +807,46 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n     fn visit_path(&mut self, path: &'tcx hir::Path<'tcx>, id: hir::HirId) {\n         if let Some(def_id) = path.res.opt_def_id() {\n             let method_span = path.segments.last().map(|s| s.ident.span);\n-            self.tcx.check_stability(def_id, Some(id), path.span, method_span)\n+            self.tcx.check_stability_allow_unstable(\n+                def_id,\n+                Some(id),\n+                path.span,\n+                method_span,\n+                if is_unstable_reexport(self.tcx, id) {\n+                    AllowUnstable::Yes\n+                } else {\n+                    AllowUnstable::No\n+                },\n+            )\n         }\n         intravisit::walk_path(self, path)\n     }\n }\n \n+/// Check whether a path is a `use` item that has been marked as unstable.\n+///\n+/// See issue #94972 for details on why this is a special case\n+fn is_unstable_reexport<'tcx>(tcx: TyCtxt<'tcx>, id: hir::HirId) -> bool {\n+    // Get the LocalDefId so we can lookup the item to check the kind.\n+    let Some(def_id) = tcx.hir().opt_local_def_id(id) else { return false; };\n+\n+    let Some(stab) = tcx.stability().local_stability(def_id) else {\n+        return false;\n+    };\n+\n+    if stab.level.is_stable() {\n+        // The re-export is not marked as unstable, don't override\n+        return false;\n+    }\n+\n+    // If this is a path that isn't a use, we don't need to do anything special\n+    if !matches!(tcx.hir().item(hir::ItemId { def_id }).kind, ItemKind::Use(..)) {\n+        return false;\n+    }\n+\n+    true\n+}\n+\n struct CheckTraitImplStable<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     fully_stable: bool,"}, {"sha": "bb2179a24953bfbcbd0d72c20c5ec137f8558ae3", "filename": "compiler/rustc_query_system/src/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=7fe2c4b00dfbc33643e1af4b293eb057306a8339", "patch": "@@ -164,7 +164,6 @@ pub struct WorkProductId {\n impl WorkProductId {\n     pub fn from_cgu_name(cgu_name: &str) -> WorkProductId {\n         let mut hasher = StableHasher::new();\n-        cgu_name.len().hash(&mut hasher);\n         cgu_name.hash(&mut hasher);\n         WorkProductId { hash: hasher.finish() }\n     }"}, {"sha": "f6d06e4362c5339e24c62800f3c152283e405965", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=7fe2c4b00dfbc33643e1af4b293eb057306a8339", "patch": "@@ -887,7 +887,7 @@ impl<K: DepKind> DepGraph<K> {\n pub struct WorkProduct {\n     pub cgu_name: String,\n     /// Saved file associated with this CGU.\n-    pub saved_file: Option<String>,\n+    pub saved_file: String,\n }\n \n // Index type for `DepNodeData`'s edges."}, {"sha": "b83fdd02da915f1b7dd215dace96b64c3b3e9177", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe2c4b00dfbc33643e1af4b293eb057306a8339/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=7fe2c4b00dfbc33643e1af4b293eb057306a8339", "patch": "@@ -24,6 +24,7 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{walk_generics, Visitor as _};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{GenericArg, GenericArgs};\n+use rustc_middle::middle::stability::AllowUnstable;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, Subst, SubstsRef};\n use rustc_middle::ty::GenericParamDefKind;\n use rustc_middle::ty::{self, Const, DefIdTree, EarlyBinder, Ty, TyCtxt, TypeFoldable};\n@@ -426,6 +427,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             Some(arg.id()),\n                             arg.span(),\n                             None,\n+                            AllowUnstable::No,\n                             |_, _| {\n                                 // Default generic parameters may not be marked\n                                 // with stability attributes, i.e. when the"}, {"sha": "75bb92437fd929e9034b9c5089037f24d98998cd", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fe2c4b00dfbc33643e1af4b293eb057306a8339/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe2c4b00dfbc33643e1af4b293eb057306a8339/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=7fe2c4b00dfbc33643e1af4b293eb057306a8339", "patch": "@@ -730,6 +730,7 @@ fn signal_string(signal: i32) -> &'static str {\n         libc::SIGVTALRM => \" (SIGVTALRM)\",\n         libc::SIGPROF => \" (SIGPROF)\",\n         libc::SIGWINCH => \" (SIGWINCH)\",\n+        #[cfg(not(target_os = \"haiku\"))]\n         libc::SIGIO => \" (SIGIO)\",\n         libc::SIGSYS => \" (SIGSYS)\",\n         // For information on Linux signals, run `man 7 signal`"}, {"sha": "937913954a7910d937ccfe4031d068592c702b1b", "filename": "src/test/ui/stability-attribute/allow-unstable-reexport.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7fe2c4b00dfbc33643e1af4b293eb057306a8339/src%2Ftest%2Fui%2Fstability-attribute%2Fallow-unstable-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe2c4b00dfbc33643e1af4b293eb057306a8339/src%2Ftest%2Fui%2Fstability-attribute%2Fallow-unstable-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fallow-unstable-reexport.rs?ref=7fe2c4b00dfbc33643e1af4b293eb057306a8339", "patch": "@@ -0,0 +1,30 @@\n+// Allow an unstable re-export without requiring a feature gate.\n+// #94972\n+\n+// aux-build:lint-stability.rs\n+// aux-build:lint-stability-reexport.rs\n+#![feature(staged_api)]\n+#![stable(feature = \"lint_stability\", since = \"1.0.0\")]\n+\n+extern crate lint_stability;\n+extern crate lint_stability_reexport;\n+\n+#[unstable(feature = \"unstable_test_feature\", issue = \"none\")]\n+pub use lint_stability::unstable;\n+\n+// We want to confirm that using a re-export through another crate behaves\n+// the same way as using an item directly\n+#[unstable(feature = \"unstable_test_feature\", issue = \"none\")]\n+pub use lint_stability_reexport::unstable_text;\n+\n+// Ensure items which aren't marked as unstable can't re-export unstable items\n+#[stable(feature = \"lint_stability\", since = \"1.0.0\")]\n+pub use lint_stability::unstable as unstable2;\n+//~^ ERROR use of unstable library feature 'unstable_test_feature'\n+\n+fn main() {\n+    // Since we didn't enable the feature in this crate, we still can't\n+    // use these items, even though they're in scope from the `use`s which are now allowed.\n+    unstable(); //~ ERROR use of unstable library feature 'unstable_test_feature'\n+    unstable_text(); //~ ERROR use of unstable library feature 'unstable_test_feature'\n+}"}, {"sha": "a11da9dc8a7beb290a5212ac2b575359da47c7fc", "filename": "src/test/ui/stability-attribute/allow-unstable-reexport.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7fe2c4b00dfbc33643e1af4b293eb057306a8339/src%2Ftest%2Fui%2Fstability-attribute%2Fallow-unstable-reexport.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fe2c4b00dfbc33643e1af4b293eb057306a8339/src%2Ftest%2Fui%2Fstability-attribute%2Fallow-unstable-reexport.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fallow-unstable-reexport.stderr?ref=7fe2c4b00dfbc33643e1af4b293eb057306a8339", "patch": "@@ -0,0 +1,27 @@\n+error[E0658]: use of unstable library feature 'unstable_test_feature'\n+  --> $DIR/allow-unstable-reexport.rs:22:9\n+   |\n+LL | pub use lint_stability::unstable as unstable2;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add `#![feature(unstable_test_feature)]` to the crate attributes to enable\n+\n+error[E0658]: use of unstable library feature 'unstable_test_feature'\n+  --> $DIR/allow-unstable-reexport.rs:28:5\n+   |\n+LL |     unstable();\n+   |     ^^^^^^^^\n+   |\n+   = help: add `#![feature(unstable_test_feature)]` to the crate attributes to enable\n+\n+error[E0658]: use of unstable library feature 'unstable_test_feature': text\n+  --> $DIR/allow-unstable-reexport.rs:29:5\n+   |\n+LL |     unstable_text();\n+   |     ^^^^^^^^^^^^^\n+   |\n+   = help: add `#![feature(unstable_test_feature)]` to the crate attributes to enable\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "9884731d562e9fc5c749c8fb80b490bb347d989c", "filename": "src/test/ui/stability-attribute/auxiliary/lint-stability-reexport.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7fe2c4b00dfbc33643e1af4b293eb057306a8339/src%2Ftest%2Fui%2Fstability-attribute%2Fauxiliary%2Flint-stability-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe2c4b00dfbc33643e1af4b293eb057306a8339/src%2Ftest%2Fui%2Fstability-attribute%2Fauxiliary%2Flint-stability-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fauxiliary%2Flint-stability-reexport.rs?ref=7fe2c4b00dfbc33643e1af4b293eb057306a8339", "patch": "@@ -0,0 +1,9 @@\n+#![crate_type = \"lib\"]\n+#![feature(staged_api)]\n+#![stable(feature = \"lint_stability\", since = \"1.0.0\")]\n+\n+extern crate lint_stability;\n+\n+// Re-exporting without enabling the feature \"unstable_test_feature\" in this crate\n+#[unstable(feature = \"unstable_test_feature\", issue = \"none\")]\n+pub use lint_stability::unstable_text;"}, {"sha": "72f765033969a69ecc50266c6a90078e6084257c", "filename": "src/test/ui/unsized/issue-97732.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7fe2c4b00dfbc33643e1af4b293eb057306a8339/src%2Ftest%2Fui%2Funsized%2Fissue-97732.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe2c4b00dfbc33643e1af4b293eb057306a8339/src%2Ftest%2Fui%2Funsized%2Fissue-97732.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Fissue-97732.rs?ref=7fe2c4b00dfbc33643e1af4b293eb057306a8339", "patch": "@@ -0,0 +1,28 @@\n+// check-pass\n+\n+#![feature(coerce_unsized)]\n+\n+// Ensure that unsizing structs that contain ZSTs at non-zero offsets don't ICE\n+\n+use std::ops::CoerceUnsized;\n+\n+#[repr(C)]\n+pub struct BoxWithZstTail<T: ?Sized>(Box<T>, ());\n+\n+impl<S: ?Sized, T: ?Sized> CoerceUnsized<BoxWithZstTail<T>> for BoxWithZstTail<S> where\n+    Box<S>: CoerceUnsized<Box<T>>\n+{\n+}\n+\n+pub fn noop_dyn_upcast_with_zst_tail(\n+    b: BoxWithZstTail<dyn ToString + Send>,\n+) -> BoxWithZstTail<dyn ToString> {\n+    b\n+}\n+\n+fn main() {\n+    let original = \"foo\";\n+    let boxed = BoxWithZstTail(Box::new(original) as Box<dyn ToString + Send>, ());\n+    let noop_upcasted = noop_dyn_upcast_with_zst_tail(boxed);\n+    assert_eq!(original, noop_upcasted.0.to_string());\n+}"}]}