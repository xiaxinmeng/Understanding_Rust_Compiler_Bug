{"sha": "13e7f9c0a7ced7c20ea909e46bc6c520a9a2b260", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzZTdmOWMwYTdjZWQ3YzIwZWE5MDllNDZiYzZjNTIwYTlhMmIyNjA=", "commit": {"author": {"name": "Brian Koropoff", "email": "bkoropoff@gmail.com", "date": "2014-12-13T22:40:38Z"}, "committer": {"name": "Brian Koropoff", "email": "bkoropoff@gmail.com", "date": "2014-12-16T02:26:05Z"}, "message": "Handle higher-rank lifetimes when generating type IDs\n\nNormalize late-bound regions in bare functions, stack closures,\nand traits and include them in the generated hash.\n\nCloses #19791", "tree": {"sha": "675050dabd74209a74c2f5112eee643fdac7df43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/675050dabd74209a74c2f5112eee643fdac7df43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13e7f9c0a7ced7c20ea909e46bc6c520a9a2b260", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13e7f9c0a7ced7c20ea909e46bc6c520a9a2b260", "html_url": "https://github.com/rust-lang/rust/commit/13e7f9c0a7ced7c20ea909e46bc6c520a9a2b260", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13e7f9c0a7ced7c20ea909e46bc6c520a9a2b260/comments", "author": {"login": "bkoropoff", "id": 2101303, "node_id": "MDQ6VXNlcjIxMDEzMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2101303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bkoropoff", "html_url": "https://github.com/bkoropoff", "followers_url": "https://api.github.com/users/bkoropoff/followers", "following_url": "https://api.github.com/users/bkoropoff/following{/other_user}", "gists_url": "https://api.github.com/users/bkoropoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bkoropoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bkoropoff/subscriptions", "organizations_url": "https://api.github.com/users/bkoropoff/orgs", "repos_url": "https://api.github.com/users/bkoropoff/repos", "events_url": "https://api.github.com/users/bkoropoff/events{/privacy}", "received_events_url": "https://api.github.com/users/bkoropoff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bkoropoff", "id": 2101303, "node_id": "MDQ6VXNlcjIxMDEzMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2101303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bkoropoff", "html_url": "https://github.com/bkoropoff", "followers_url": "https://api.github.com/users/bkoropoff/followers", "following_url": "https://api.github.com/users/bkoropoff/following{/other_user}", "gists_url": "https://api.github.com/users/bkoropoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bkoropoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bkoropoff/subscriptions", "organizations_url": "https://api.github.com/users/bkoropoff/orgs", "repos_url": "https://api.github.com/users/bkoropoff/repos", "events_url": "https://api.github.com/users/bkoropoff/events{/privacy}", "received_events_url": "https://api.github.com/users/bkoropoff/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0669a432a2e09ad08886cb2138dbe9f5d681fb7f", "html_url": "https://github.com/rust-lang/rust/commit/0669a432a2e09ad08886cb2138dbe9f5d681fb7f"}], "stats": {"total": 272, "additions": 158, "deletions": 114}, "files": [{"sha": "3a59fb5016075e54c31d66cb634d825f0d0af2fc", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 158, "deletions": 114, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/13e7f9c0a7ced7c20ea909e46bc6c520a9a2b260/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13e7f9c0a7ced7c20ea909e46bc6c520a9a2b260/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=13e7f9c0a7ced7c20ea909e46bc6c520a9a2b260", "patch": "@@ -5825,126 +5825,153 @@ pub fn trait_item_of_item(tcx: &ctxt, def_id: ast::DefId)\n /// context it's calculated within. This is used by the `type_id` intrinsic.\n pub fn hash_crate_independent(tcx: &ctxt, ty: Ty, svh: &Svh) -> u64 {\n     let mut state = sip::SipState::new();\n-    macro_rules! byte( ($b:expr) => { ($b as u8).hash(&mut state) } );\n-    macro_rules! hash( ($e:expr) => { $e.hash(&mut state) } );\n-\n-    let region = |_state: &mut sip::SipState, r: Region| {\n-        match r {\n-            ReStatic => {}\n-\n-            ReEmpty |\n-            ReEarlyBound(..) |\n-            ReLateBound(..) |\n-            ReFree(..) |\n-            ReScope(..) |\n-            ReInfer(..) => {\n-                tcx.sess.bug(\"non-static region found when hashing a type\")\n+    helper(tcx, ty, svh, &mut state);\n+    return state.result();\n+\n+    fn helper(tcx: &ctxt, ty: Ty, svh: &Svh, state: &mut sip::SipState) {\n+        macro_rules! byte( ($b:expr) => { ($b as u8).hash(state) } );\n+        macro_rules! hash( ($e:expr) => { $e.hash(state) } );\n+\n+        let region = |state: &mut sip::SipState, r: Region| {\n+            match r {\n+                ReStatic => {}\n+                ReLateBound(db, BrAnon(i)) => {\n+                    db.hash(state);\n+                    i.hash(state);\n+                }\n+                ReEmpty |\n+                ReEarlyBound(..) |\n+                ReLateBound(..) |\n+                ReFree(..) |\n+                ReScope(..) |\n+                ReInfer(..) => {\n+                    tcx.sess.bug(\"unexpected region found when hashing a type\")\n+                }\n             }\n-        }\n-    };\n-    let did = |state: &mut sip::SipState, did: DefId| {\n-        let h = if ast_util::is_local(did) {\n-            svh.clone()\n-        } else {\n-            tcx.sess.cstore.get_crate_hash(did.krate)\n         };\n-        h.as_str().hash(state);\n-        did.node.hash(state);\n-    };\n-    let mt = |state: &mut sip::SipState, mt: mt| {\n-        mt.mutbl.hash(state);\n-    };\n-    ty::walk_ty(ty, |ty| {\n-        match ty.sty {\n-            ty_bool => byte!(2),\n-            ty_char => byte!(3),\n-            ty_int(i) => {\n-                byte!(4);\n-                hash!(i);\n-            }\n-            ty_uint(u) => {\n-                byte!(5);\n-                hash!(u);\n-            }\n-            ty_float(f) => {\n-                byte!(6);\n-                hash!(f);\n-            }\n-            ty_str => {\n-                byte!(7);\n-            }\n-            ty_enum(d, _) => {\n-                byte!(8);\n-                did(&mut state, d);\n-            }\n-            ty_uniq(_) => {\n-                byte!(9);\n-            }\n-            ty_vec(_, Some(n)) => {\n-                byte!(10);\n-                n.hash(&mut state);\n-            }\n-            ty_vec(_, None) => {\n-                byte!(11);\n-            }\n-            ty_ptr(m) => {\n-                byte!(12);\n-                mt(&mut state, m);\n-            }\n-            ty_rptr(r, m) => {\n-                byte!(13);\n-                region(&mut state, r);\n-                mt(&mut state, m);\n-            }\n-            ty_bare_fn(ref b) => {\n-                byte!(14);\n-                hash!(b.unsafety);\n-                hash!(b.abi);\n+        let did = |state: &mut sip::SipState, did: DefId| {\n+            let h = if ast_util::is_local(did) {\n+                svh.clone()\n+            } else {\n+                tcx.sess.cstore.get_crate_hash(did.krate)\n+            };\n+            h.as_str().hash(state);\n+            did.node.hash(state);\n+        };\n+        let mt = |state: &mut sip::SipState, mt: mt| {\n+            mt.mutbl.hash(state);\n+        };\n+        let fn_sig = |state: &mut sip::SipState, sig: &FnSig| {\n+            let sig = anonymize_late_bound_regions(tcx, sig);\n+            for a in sig.inputs.iter() { helper(tcx, *a, svh, state); }\n+            if let ty::FnConverging(output) = sig.output {\n+                helper(tcx, output, svh, state);\n             }\n-            ty_closure(ref c) => {\n-                byte!(15);\n-                hash!(c.unsafety);\n-                hash!(c.onceness);\n-                hash!(c.bounds);\n-                match c.store {\n-                    UniqTraitStore => byte!(0),\n-                    RegionTraitStore(r, m) => {\n-                        byte!(1)\n-                        region(&mut state, r);\n-                        assert_eq!(m, ast::MutMutable);\n+        };\n+        maybe_walk_ty(ty, |ty| {\n+            match ty.sty {\n+                ty_bool => byte!(2),\n+                ty_char => byte!(3),\n+                ty_int(i) => {\n+                    byte!(4);\n+                    hash!(i);\n+                }\n+                ty_uint(u) => {\n+                    byte!(5);\n+                    hash!(u);\n+                }\n+                ty_float(f) => {\n+                    byte!(6);\n+                    hash!(f);\n+                }\n+                ty_str => {\n+                    byte!(7);\n+                }\n+                ty_enum(d, _) => {\n+                    byte!(8);\n+                    did(state, d);\n+                }\n+                ty_uniq(_) => {\n+                    byte!(9);\n+                }\n+                ty_vec(_, Some(n)) => {\n+                    byte!(10);\n+                    n.hash(state);\n+                }\n+                ty_vec(_, None) => {\n+                    byte!(11);\n+                }\n+                ty_ptr(m) => {\n+                    byte!(12);\n+                    mt(state, m);\n+                }\n+                ty_rptr(r, m) => {\n+                    byte!(13);\n+                    region(state, r);\n+                    mt(state, m);\n+                }\n+                ty_bare_fn(ref b) => {\n+                    byte!(14);\n+                    hash!(b.unsafety);\n+                    hash!(b.abi);\n+                    fn_sig(state, &b.sig);\n+                    return false;\n+                }\n+                ty_closure(ref c) => {\n+                    byte!(15);\n+                    hash!(c.unsafety);\n+                    hash!(c.onceness);\n+                    hash!(c.bounds);\n+                    match c.store {\n+                        UniqTraitStore => byte!(0),\n+                        RegionTraitStore(r, m) => {\n+                            byte!(1);\n+                            region(state, r);\n+                            assert_eq!(m, ast::MutMutable);\n+                        }\n                     }\n+\n+                    fn_sig(state, &c.sig);\n+\n+                    return false;\n                 }\n-            }\n-            ty_trait(box TyTrait { ref principal, bounds }) => {\n-                byte!(17);\n-                did(&mut state, principal.def_id);\n-                hash!(bounds);\n-            }\n-            ty_struct(d, _) => {\n-                byte!(18);\n-                did(&mut state, d);\n-            }\n-            ty_tup(ref inner) => {\n-                byte!(19);\n-                hash!(inner.len());\n-            }\n-            ty_param(p) => {\n-                byte!(20);\n-                hash!(p.idx);\n-                did(&mut state, p.def_id);\n-            }\n-            ty_open(_) => byte!(22),\n-            ty_infer(_) => unreachable!(),\n-            ty_err => byte!(23),\n-            ty_unboxed_closure(d, r, _) => {\n-                byte!(24);\n-                did(&mut state, d);\n-                region(&mut state, r);\n-            }\n-        }\n-    });\n+                ty_trait(box TyTrait { ref principal, bounds }) => {\n+                    byte!(17);\n+                    did(state, principal.def_id);\n+                    hash!(bounds);\n+\n+                    let principal = anonymize_late_bound_regions(tcx, principal);\n+                    for subty in principal.substs.types.iter() {\n+                        helper(tcx, *subty, svh, state);\n+                    }\n \n-    state.result()\n+                    return false;\n+                }\n+                ty_struct(d, _) => {\n+                    byte!(18);\n+                    did(state, d);\n+                }\n+                ty_tup(ref inner) => {\n+                    byte!(19);\n+                    hash!(inner.len());\n+                }\n+                ty_param(p) => {\n+                    byte!(20);\n+                    hash!(p.idx);\n+                    did(state, p.def_id);\n+                }\n+                ty_open(_) => byte!(22),\n+                ty_infer(_) => unreachable!(),\n+                ty_err => byte!(23),\n+                ty_unboxed_closure(d, r, _) => {\n+                    byte!(24);\n+                    did(state, d);\n+                    region(state, r);\n+                }\n+            }\n+            true\n+        });\n+    }\n }\n \n impl Variance {\n@@ -6284,6 +6311,23 @@ pub fn erase_late_bound_regions<'tcx, HR>(\n     replace_late_bound_regions(tcx, value, |_, _| ty::ReStatic).0\n }\n \n+/// Rewrite any late-bound regions so that they are anonymous.  Region numbers are\n+/// assigned starting at 1 and increasing monotonically in the order traversed\n+/// by the fold operation.\n+///\n+/// The chief purpose of this function is to canonicalize regions so that two\n+/// `FnSig`s or `TraitRef`s which are equivalent up to region naming will become\n+/// structurally identical.  For example, `for<'a, 'b> fn(&'a int, &'b int)` and\n+/// `for<'a, 'b> fn(&'b int, &'a int)` will become identical after anonymization.\n+pub fn anonymize_late_bound_regions<'tcx, HR>(tcx: &ctxt<'tcx>, sig: &HR) -> HR\n+                                              where HR: HigherRankedFoldable<'tcx> {\n+    let mut counter = 0;\n+    replace_late_bound_regions(tcx, sig, |_, db| {\n+        counter += 1;\n+        ReLateBound(db, BrAnon(counter))\n+    }).0\n+}\n+\n /// Replaces the late-bound-regions in `value` that are bound by `value`.\n pub fn replace_late_bound_regions<'tcx, HR, F>(\n     tcx: &ty::ctxt<'tcx>,"}]}