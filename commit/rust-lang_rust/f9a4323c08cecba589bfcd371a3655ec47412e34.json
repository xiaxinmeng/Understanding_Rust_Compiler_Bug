{"sha": "f9a4323c08cecba589bfcd371a3655ec47412e34", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5YTQzMjNjMDhjZWNiYTU4OWJmY2QzNzFhMzY1NWVjNDc0MTJlMzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-09T13:21:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-09T13:21:20Z"}, "message": "auto merge of #16340 : thestinger/rust/pie, r=brson\n\nRust already builds all code as position independent by default, so the\r\nlinker can be told to build a position independent executable if it's\r\nnot disabled with `-C relocation-model=dynamic-no-pic`. Position\r\nindependent code does have a significant cost on i686 (not on x86_64 or\r\nARM) but there's no significant cost to linking code that's already\r\nposition independent as a position independent executable.\r\n\r\nAddress space layout randomization makes exploiting vulnerabilities much\r\nmore difficult by providing a statistical defence against an attempt to\r\nfind or modify existing code / data. Without ASLR, it's trivial to use a\r\nvulnerability to take over control of the process via return-oriented\r\nprogramming.\r\n\r\nRust code can be used for return-oriented programming whether it is safe\r\nor unsafe, so even a fully safe application needs to be built as a\r\nposition independent executable to defend against vulnerabilities in\r\nunsafe blocks or C libraries.\r\n\r\nSample program:\r\n\r\n    extern crate libc;\r\n\r\n    use std::mem;\r\n\r\n    static mut global: u32 = 5;\r\n    static constant: u32 = 5;\r\n    fn foo() {}\r\n\r\n    fn main() {\r\n        let local = 5;\r\n        println!(\"stack: {}, global: {}, constant: {}, fn: {}, lib fn: {}\",\r\n                 &local as *const u32,\r\n                 unsafe { &global as *const u32 },\r\n                 &constant as *const u32,\r\n                 unsafe { mem::transmute::<_, *const ()>(foo) },\r\n                 unsafe { mem::transmute::<_, *const ()>(libc::mprotect) });\r\n    }\r\n\r\nBefore:\r\n\r\n    stack: 0x3ff15eb9f94, global: 0x6ab488, constant: 0x47db40, fn: 0x4030e0, lib fn: 0x32749547530\r\n    stack: 0x3b5d47d80e4, global: 0x6ab488, constant: 0x47db40, fn: 0x4030e0, lib fn: 0x394469a7530\r\n    stack: 0x3fe2c4e5564, global: 0x6ab488, constant: 0x47db40, fn: 0x4030e0, lib fn: 0x399734a2530\r\n    stack: 0x3e525e0fb24, global: 0x6ab488, constant: 0x47db40, fn: 0x4030e0, lib fn: 0x2f62a810530\r\n    stack: 0x3b50fb3eae4, global: 0x6ab488, constant: 0x47db40, fn: 0x4030e0, lib fn: 0x2e590e86530\r\n\r\nAfter:\r\n\r\n    stack: 0x38cf12c90a4, global: 0x3e2d46b488, constant: 0x3e2d23cf80, fn: 0x3e2d1c2510, lib fn: 0x2617d3b4530\r\n    stack: 0x3d733faf474, global: 0x7eb1839488, constant: 0x7eb160af80, fn: 0x7eb1590510, lib fn: 0x32d30c1f530\r\n    stack: 0x3bb42212ec4, global: 0x5bbb365488, constant: 0x5bbb136f80, fn: 0x5bbb0bc510, lib fn: 0x3595e6c1530\r\n    stack: 0x39f678c1ab4, global: 0x22c4e3c488, constant: 0x22c4c0df80, fn: 0x22c4b93510, lib fn: 0x3835b727530\r\n    stack: 0x3afb25bd394, global: 0x493eab2488, constant: 0x493e883f80, fn: 0x493e809510, lib fn: 0x3478d6a7530\r\n\r\nThis may also be necessary on other platforms, but I can only test on\r\nLinux right now. Note that GDB gained support for debugging position\r\nindependent executables in version 7.1 (March 2010).", "tree": {"sha": "35a1e34593246462a819d60e6f6e4e9c8c1b1dc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35a1e34593246462a819d60e6f6e4e9c8c1b1dc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9a4323c08cecba589bfcd371a3655ec47412e34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9a4323c08cecba589bfcd371a3655ec47412e34", "html_url": "https://github.com/rust-lang/rust/commit/f9a4323c08cecba589bfcd371a3655ec47412e34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9a4323c08cecba589bfcd371a3655ec47412e34/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1712ab2300df3a319c4e9595cd7fa4fd1c8a3aab", "url": "https://api.github.com/repos/rust-lang/rust/commits/1712ab2300df3a319c4e9595cd7fa4fd1c8a3aab", "html_url": "https://github.com/rust-lang/rust/commit/1712ab2300df3a319c4e9595cd7fa4fd1c8a3aab"}, {"sha": "3cbff72da24d2a45552dd51eb7735ae3ee235bf3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cbff72da24d2a45552dd51eb7735ae3ee235bf3", "html_url": "https://github.com/rust-lang/rust/commit/3cbff72da24d2a45552dd51eb7735ae3ee235bf3"}], "stats": {"total": 18, "additions": 15, "deletions": 3}, "files": [{"sha": "7c9844dbe33fb4693616efda8aaa6400786f96a6", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f9a4323c08cecba589bfcd371a3655ec47412e34/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9a4323c08cecba589bfcd371a3655ec47412e34/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=f9a4323c08cecba589bfcd371a3655ec47412e34", "patch": "@@ -1400,6 +1400,20 @@ fn link_args(cmd: &mut Command,\n         cmd.arg(\"-Wl,--gc-sections\");\n     }\n \n+    let used_link_args = sess.cstore.get_used_link_args().borrow();\n+\n+    // Dynamically linked executables can be compiled as position independent if the default\n+    // relocation model of position independent code is not changed. This is a requirement to take\n+    // advantage of ASLR, as otherwise the functions in the executable are not randomized and can\n+    // be used during an exploit of a vulnerability in any code.\n+    if sess.targ_cfg.os == abi::OsLinux {\n+        let mut args = sess.opts.cg.link_args.iter().chain(used_link_args.iter());\n+        if !dylib && sess.opts.cg.relocation_model.as_slice() == \"pic\" &&\n+            !args.any(|x| x.as_slice() == \"-static\") {\n+            cmd.arg(\"-pie\");\n+        }\n+    }\n+\n     if sess.targ_cfg.os == abi::OsLinux || sess.targ_cfg.os == abi::OsDragonfly {\n         // GNU-style linkers will use this to omit linking to libraries which\n         // don't actually fulfill any relocations, but only for libraries which\n@@ -1568,9 +1582,7 @@ fn link_args(cmd: &mut Command,\n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n     cmd.args(sess.opts.cg.link_args.as_slice());\n-    for arg in sess.cstore.get_used_link_args().borrow().iter() {\n-        cmd.arg(arg.as_slice());\n-    }\n+    cmd.args(used_link_args.as_slice());\n }\n \n // # Native library linking"}]}