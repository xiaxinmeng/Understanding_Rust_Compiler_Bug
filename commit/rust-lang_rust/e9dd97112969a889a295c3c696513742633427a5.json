{"sha": "e9dd97112969a889a295c3c696513742633427a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5ZGQ5NzExMjk2OWE4ODlhMjk1YzNjNjk2NTEzNzQyNjMzNDI3YTU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-28T01:11:40Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-28T02:04:56Z"}, "message": "Capture stderr when running compile tests. Closes #755", "tree": {"sha": "fd7a15b5871c4a3618bf96853876f91ecd99a49b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd7a15b5871c4a3618bf96853876f91ecd99a49b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9dd97112969a889a295c3c696513742633427a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9dd97112969a889a295c3c696513742633427a5", "html_url": "https://github.com/rust-lang/rust/commit/e9dd97112969a889a295c3c696513742633427a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9dd97112969a889a295c3c696513742633427a5/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "452765255c6be2118d316818fc0da6fe06c13472", "url": "https://api.github.com/repos/rust-lang/rust/commits/452765255c6be2118d316818fc0da6fe06c13472", "html_url": "https://github.com/rust-lang/rust/commit/452765255c6be2118d316818fc0da6fe06c13472"}], "stats": {"total": 116, "additions": 74, "deletions": 42}, "files": [{"sha": "795ab033b05d3f58b9e5420f0908cb5bde355386", "filename": "src/test/compiletest/compiletest.rs", "status": "modified", "additions": 74, "deletions": 42, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/e9dd97112969a889a295c3c696513742633427a5/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9dd97112969a889a295c3c696513742633427a5/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rs?ref=e9dd97112969a889a295c3c696513742633427a5", "patch": "@@ -299,33 +299,6 @@ fn output_base_name(config: &config, testfile: &str) -> str {\n     #fmt(\"%s%s.%s\", base, filename, config.stage_id)\n }\n \n-#[cfg(target_os = \"win32\")]\n-#[cfg(target_os = \"linux\")]\n-fn dump_output(config: &config, testfile: &str, out: &str) {\n-    let outfile = make_out_name(config, testfile);\n-    let writer = io::file_writer(outfile, [io::create, io::truncate]);\n-    writer.write_str(out);\n-    maybe_dump_to_stdout(config, out);\n-}\n-\n-// FIXME (726): Can't use file_writer on mac\n-#[cfg(target_os = \"macos\")]\n-fn dump_output(config: &config, testfile: &str, out: &str) {\n-    maybe_dump_to_stdout(config, out);\n-}\n-\n-fn maybe_dump_to_stdout(config: &config, out: &str) {\n-    if config.verbose {\n-        io::stdout().write_line(\"------------------------------------------\");\n-        io::stdout().write_line(out);\n-        io::stdout().write_line(\"------------------------------------------\");\n-    }\n-}\n-\n-fn make_out_name(config: &config, testfile: &str) -> str {\n-    output_base_name(config, testfile) + \".out\"\n-}\n-\n fn logv(config: &config, s: &str) {\n     log s;\n     if config.verbose { io::stdout().write_line(s); }\n@@ -472,7 +445,7 @@ mod runtest {\n \n         let next_err_idx = 0u;\n         let next_err_pat = props.error_patterns.(next_err_idx);\n-        for line: str  in str::split(procres.out, '\\n' as u8) {\n+        for line: str  in str::split(procres.stdout, '\\n' as u8) {\n                 if str::find(line, next_err_pat) > 0 {\n                         log #fmt(\"found error pattern %s\", next_err_pat);\n                         next_err_idx += 1u;\n@@ -500,7 +473,7 @@ mod runtest {\n \n     type procargs = {prog: str, args: vec[str]};\n \n-    type procres = {status: int, out: str, cmdline: str};\n+    type procres = {status: int, stdout: str, stderr: str, cmdline: str};\n \n     fn compile_test(cx: &cx, props: &test_props, testfile: &str) -> procres {\n         compose_and_run(cx, testfile, bind make_compile_args(_, props, _),\n@@ -554,8 +527,52 @@ mod runtest {\n                 cmdline\n             };\n         let res = procsrv::run(cx.procsrv, lib_path, prog, args);\n-        dump_output(cx.config, testfile, res.out);\n-        ret {status: res.status, out: res.out, cmdline: cmdline};\n+        dump_output(cx.config, testfile, res.out, res.err);\n+        ret {status: res.status, stdout: res.out,\n+             stderr: res.err, cmdline: cmdline};\n+    }\n+\n+    fn dump_output(config: &config, testfile: &str,\n+                   out: &str, err: &str) {\n+        dump_output_file(config, testfile, out, \"out\");\n+        dump_output_file(config, testfile, err, \"err\");\n+        maybe_dump_to_stdout(config, out, err);\n+    }\n+\n+    #[cfg(target_os = \"win32\")]\n+    #[cfg(target_os = \"linux\")]\n+    fn dump_output_file(config: &config, testfile: &str,\n+                        out: &str, extension: &str) {\n+        let outfile = make_out_name(config, testfile, extension);\n+        let writer = io::file_writer(outfile, [io::create, io::truncate]);\n+        writer.write_str(out);\n+    }\n+\n+    // FIXME (726): Can't use file_writer on mac\n+    #[cfg(target_os = \"macos\")]\n+    fn dump_output_file(config: &config, testfile: &str,\n+                        out: &str, extension: &str) {\n+    }\n+\n+    fn make_out_name(config: &config, testfile: &str,\n+                     extension: &str) -> str {\n+        output_base_name(config, testfile) + \".\" + extension\n+    }\n+\n+    fn maybe_dump_to_stdout(config: &config,\n+                            out: &str, err: &str) {\n+        if config.verbose {\n+            let sep1 = #fmt(\"-%s-----------------------------------\",\n+                            \"stdout\");\n+            let sep2 = #fmt(\"-%s-----------------------------------\",\n+                            \"stderr\");\n+            let sep3 = \"------------------------------------------\";\n+            io::stdout().write_line(sep1);\n+            io::stdout().write_line(out);\n+            io::stdout().write_line(sep2);\n+            io::stdout().write_line(err);\n+            io::stdout().write_line(sep3);\n+        }\n     }\n \n     fn error(err: &str) { io::stdout().write_line(#fmt(\"\\nerror: %s\", err)); }\n@@ -567,12 +584,16 @@ mod runtest {\n             #fmt(\"\\n\\\n                   error: %s\\n\\\n                   command: %s\\n\\\n-                  output:\\n\\\n+                  stdout:\\n\\\n+                  ------------------------------------------\\n\\\n+                  %s\\n\\\n+                  ------------------------------------------\\n\\\n+                  stderr:\\n\\\n                   ------------------------------------------\\n\\\n                   %s\\n\\\n                   ------------------------------------------\\n\\\n                   \\n\",\n-                 err, procres.cmdline, procres.out);\n+                 err, procres.cmdline, procres.stdout, procres.stderr);\n         io::stdout().write_str(msg);\n         fail;\n     }\n@@ -599,7 +620,7 @@ mod procsrv {\n \n     tag request { exec(str, str, vec[str], chan[response]); stop; }\n \n-    type response = {pid: int, outfd: int};\n+    type response = {pid: int, outfd: int, errfd: int};\n \n     fn mk() -> handle {\n         let setupport = port();\n@@ -629,22 +650,28 @@ mod procsrv {\n     }\n \n     fn run(handle: &handle, lib_path: &str, prog: &str, args: &vec[str]) ->\n-       {status: int, out: str} {\n+        {status: int, out: str, err: str} {\n         let p = port[response]();\n         let ch = chan(p);\n         task::send(handle.chan, exec(lib_path, prog, args, ch));\n-\n         let resp = task::recv(p);\n+        let output = readclose(resp.outfd);\n+        let errput = readclose(resp.errfd);\n+        let status = os::waitpid(resp.pid);\n+        ret {status: status, out: output, err: errput};\n+    }\n+\n+    fn readclose(fd: int) -> str {\n         // Copied from run::program_output\n-        let outfile = os::fd_FILE(resp.outfd);\n-        let reader = io::new_reader(io::FILE_buf_reader(outfile, false));\n+        let file = os::fd_FILE(fd);\n+        let reader = io::new_reader(io::FILE_buf_reader(file, false));\n         let buf = \"\";\n         while !reader.eof() {\n             let bytes = reader.read_bytes(4096u);\n             buf += str::unsafe_from_bytes(bytes);\n         }\n-        os::libc::fclose(outfile);\n-        ret {status: os::waitpid(resp.pid), out: buf};\n+        os::libc::fclose(file);\n+        ret buf;\n     }\n \n     fn worker(p: port[request]) {\n@@ -654,15 +681,20 @@ mod procsrv {\n                 // This is copied from run::start_program\n                 let pipe_in = os::pipe();\n                 let pipe_out = os::pipe();\n+                let pipe_err = os::pipe();\n                 let spawnproc =\n                     bind run::spawn_process(prog, args, pipe_in.in,\n-                                            pipe_out.out, 0);\n+                                            pipe_out.out, pipe_err.out);\n                 let pid = with_lib_path(lib_path, spawnproc);\n                 if pid == -1 { fail; }\n                 os::libc::close(pipe_in.in);\n                 os::libc::close(pipe_in.out);\n                 os::libc::close(pipe_out.out);\n-                task::send(respchan, {pid: pid, outfd: pipe_out.in});\n+                os::libc::close(pipe_err.out);\n+                task::send(respchan,\n+                           {pid: pid,\n+                            outfd: pipe_out.in,\n+                            errfd: pipe_err.in});\n               }\n               stop. { ret; }\n             }"}]}