{"sha": "db47aa5bdf308213b4198b81e9d2e406ec716189", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiNDdhYTViZGYzMDgyMTNiNDE5OGI4MWU5ZDJlNDA2ZWM3MTYxODk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-31T08:26:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-31T08:26:30Z"}, "message": "auto merge of #16895 : alexcrichton/rust/rollup, r=alexcrichton\n\nLet's try this again!", "tree": {"sha": "4657767a7108317107eaf5789017729157449b41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4657767a7108317107eaf5789017729157449b41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db47aa5bdf308213b4198b81e9d2e406ec716189", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db47aa5bdf308213b4198b81e9d2e406ec716189", "html_url": "https://github.com/rust-lang/rust/commit/db47aa5bdf308213b4198b81e9d2e406ec716189", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db47aa5bdf308213b4198b81e9d2e406ec716189/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "499a40e59f62f6e860eb201d91f9ba9cecb99d35", "url": "https://api.github.com/repos/rust-lang/rust/commits/499a40e59f62f6e860eb201d91f9ba9cecb99d35", "html_url": "https://github.com/rust-lang/rust/commit/499a40e59f62f6e860eb201d91f9ba9cecb99d35"}, {"sha": "33029c5ddd255725f9ae701dec0a571256f8856c", "url": "https://api.github.com/repos/rust-lang/rust/commits/33029c5ddd255725f9ae701dec0a571256f8856c", "html_url": "https://github.com/rust-lang/rust/commit/33029c5ddd255725f9ae701dec0a571256f8856c"}], "stats": {"total": 613, "additions": 385, "deletions": 228}, "files": [{"sha": "6492400a2cfc7bc477939b73110657444e33e85b", "filename": "src/doc/guide-pointers.md", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Fdoc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Fdoc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-pointers.md?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -729,6 +729,31 @@ This part is coming soon.\n \n This part is coming soon.\n \n+# Patterns and `ref`\n+\n+When you're trying to match something that's stored in a pointer, there may be\n+a situation where matching directly isn't the best option available. Let's see\n+how to properly handle this:\n+\n+```{rust,ignore}\n+fn possibly_print(x: &Option<String>) {\n+    match *x {\n+        // BAD: cannot move out of a `&`\n+        Some(s) => println!(\"{}\", s)\n+\n+        // GOOD: instead take a reference into the memory of the `Option`\n+        Some(ref s) => println!(\"{}\", *s),\n+        None => {}\n+    }\n+}\n+```\n+\n+The `ref s` here means that `s` will be of type `&String`, rather than type\n+`String`.\n+\n+This is important when the type you're trying to get access to has a destructor\n+and you don't want to move it, you just want a reference to it.\n+\n # Cheat Sheet\n \n Here's a quick rundown of Rust's pointer types:"}, {"sha": "feba76dbf8457cfd30d38a6515d997311dca27da", "filename": "src/doc/guide.md", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -297,7 +297,7 @@ $ mv hello_world.rs src/hello_world.rs\n ```\n \n Cargo expects your source files to live inside a `src` directory. That leaves\n-the top level for other things, like READMEs, licence information, and anything\n+the top level for other things, like READMEs, license information, and anything\n not related to your code. Cargo helps us keep our projects nice and tidy. A\n place for everything, and everything in its place.\n \n@@ -315,7 +315,7 @@ Put this inside:\n [package]\n \n name = \"hello_world\"\n-version = \"0.1.0\"\n+version = \"0.0.1\"\n authors = [ \"Your name <you@example.com>\" ]\n \n [[bin]]\n@@ -630,7 +630,7 @@ In Rust, however, using `let` to introduce a binding is _not_ an expression. The\n following will produce a compile-time error:\n \n ```{ignore}\n-let x = (let y = 5i); // found `let` in ident position\n+let x = (let y = 5i); // expected identifier, found keyword `let`\n ```\n \n The compiler is telling us here that it was expecting to see the beginning of\n@@ -1743,7 +1743,7 @@ fn main() {\n }\n ```\n \n-Sometimes, this makes things more readable. Sometimes, less. Use your judgement\n+Sometimes, this makes things more readable. Sometimes, less. Use your judgment\n here.\n \n That's all you need to get basic input from the standard input! It's not too\n@@ -1813,7 +1813,7 @@ Try it out:\n \n ```{notrust,ignore}\n $ cargo run\n-   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n Hello, world!\n ```\n@@ -1959,7 +1959,7 @@ Try running our new program a few times:\n \n ```{notrust,ignore}\n $ cargo run\n-   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n Guess the number!\n The secret number is: 7\n@@ -2012,7 +2012,7 @@ And trying it out:\n \n ```{notrust,ignore}\n $ cargo run\n-   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n Guess the number!\n The secret number is: 57\n@@ -2283,7 +2283,7 @@ print an error message and return. Let's give this a shot:\n \n ```{notrust,ignore}\n $ cargo run\n-   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n Guess the number!\n The secret number is: 17\n@@ -2348,7 +2348,7 @@ Let's try it!\n \n ```{notrust,ignore}\n $ cargo run\n-   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n Guess the number!\n The secret number is: 58\n@@ -2425,7 +2425,7 @@ that `return`? If we give a non-number answer, we'll `return` and quit. Observe:\n \n ```{notrust,ignore}\n $ cargo run\n-   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n Guess the number!\n The secret number is: 59\n@@ -2557,7 +2557,7 @@ Now we should be good! Let's try:\n \n ```{notrust,ignore}\n $ cargo run\n-   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n      Running `target/guessing_game`\n Guess the number!\n The secret number is: 61\n@@ -2659,7 +2659,7 @@ modules, which can contain other modules, as deeply as you'd like.\n Note that we haven't mentioned anything about files yet. Rust does not impose a\n particular relationship between your filesystem structure and your module\n structure. That said, there is a conventional approach to how Rust looks for\n-modules on the file system, but it's also overrideable.\n+modules on the file system, but it's also overridable.\n \n Enough talk, let's build something! Let's make a new project called `modules`.\n \n@@ -2670,10 +2670,10 @@ $ cargo new modules --bin\n \n Let's double check our work by compiling:\n \n-```{bash,ignore}\n-$ cargo build\n+```{bash,notrust}\n+$ cargo run\n    Compiling modules v0.0.1 (file:///home/you/projects/modules)\n-$ ./target/modules\n+     Running `target/modules`\n Hello, world!\n ```\n \n@@ -3011,7 +3011,7 @@ markers.\n Rust provides six attributes to indicate the stability level of various\n parts of your library. The six levels are:\n \n-* deprecated: this item should no longer be used. No guarantee of backwards\n+* deprecated: This item should no longer be used. No guarantee of backwards\n   compatibility.\n * experimental: This item was only recently introduced or is otherwise in a\n   state of flux. It may change significantly, or even be removed. No guarantee\n@@ -3300,7 +3300,7 @@ To learn more, run the command again with --verbose.\n \n Rust can't find this function. That makes sense, as we didn't write it yet!\n \n-In order to share this codes with our tests, we'll need to make a library crate.\n+In order to share this code with our tests, we'll need to make a library crate.\n This is also just good software design: as we mentioned before, it's a good idea\n to put most of your functionality into a library crate, and have your executable\n crate use that library. This allows for code re-use.\n@@ -3511,7 +3511,7 @@ exporting the name again, somewhere else.\n \n We've now covered the basics of testing. Rust's tools are primitive, but they\n work well in the simple cases. There are some Rustaceans working on building\n-more complicated frameworks on top of all of this, but thery're just starting\n+more complicated frameworks on top of all of this, but they're just starting\n out.\n \n # Pointers\n@@ -3668,15 +3668,20 @@ because it's easy. And if you need precise control over when something is\n deallocated, leaving it up to your runtime can make this difficult.\n \n Rust chooses a different path, and that path is called **ownership**. Any\n-binding that creates a resource is the **owner** of that resource.  Being an\n-owner gives you three privileges, with two restrictions:\n+binding that creates a resource is the **owner** of that resource.\n+\n+Being an owner affords you some privileges:\n \n 1. You control when that resource is deallocated.\n 2. You may lend that resource, immutably, to as many borrowers as you'd like.\n-3. You may lend that resource, mutably, to a single borrower. **BUT**\n-4. Once you've done so, you may not also lend it out otherwise, mutably or\n-   immutably.\n-5. You may not lend it out mutably if you're currently lending it to someone.\n+3. You may lend that resource, mutably, to a single borrower.\n+\n+But it also comes with some restrictions:\n+\n+1. If someone is borrowing your resource (either mutably or immutably), you may\n+   not mutate the resource or mutably lend it to someone.\n+2. If someone is mutably borrowing your resource, you may not lend it out at\n+   all (mutably or immutably) or access it in any way.\n \n What's up with all this 'lending' and 'borrowing'? When you allocate memory,\n you get a pointer to that memory. This pointer allows you to manipulate said\n@@ -4063,7 +4068,7 @@ match x {\n }\n ```\n \n-If you have a struct, you can desugar it inside of a pattern:\n+If you have a struct, you can destructure it inside of a pattern:\n \n ```{rust}\n struct Point {\n@@ -4223,7 +4228,7 @@ don't need to declare one. This is different from named functions, which\n default to returning unit (`()`).\n \n There's one big difference between a closure and named functions, and it's in\n-the name: a function \"closes over its environment.\" What's that mean? It means\n+the name: a closure \"closes over its environment.\" What's that mean? It means\n this:\n \n ```{rust}\n@@ -5494,7 +5499,7 @@ fn main() {\n \n Whew! This isn't too terrible. You can see that we still `let x = 5i`,\n but then things get a little bit hairy. Three more bindings get set: a\n-static format string, an argument vector, and the aruments. We then\n+static format string, an argument vector, and the arguments. We then\n invoke the `println_args` function with the generated arguments.\n \n This is the code (well, the full version) that Rust actually compiles. You can\n@@ -5510,7 +5515,7 @@ Guide can help you if you want to write your own.\n \n # Unsafe\n \n-Finally, there's one more concept that you should be aware in Rust: `unsafe`.\n+Finally, there's one more Rust concept that you should be aware of: `unsafe`.\n There are two circumstances where Rust's safety provisions don't work well.\n The first is when interfacing with C code, and the second is when building\n certain kinds of abstractions."}, {"sha": "ba5a01f899f850dc8be00b22b6cde1f2dd808a6d", "filename": "src/doc/rust.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -2215,14 +2215,14 @@ These types help drive the compiler's analysis\n \n * `begin_unwind`\n   : ___Needs filling in___\n+* `managed_bound`\n+  : This type implements \"managed\"\n * `no_copy_bound`\n   : This type does not implement \"copy\", even if eligible\n * `no_send_bound`\n   : This type does not implement \"send\", even if eligible\n-* `no_sync_bound`\n-  : This type does not implement \"sync\", even if eligible\n-* `managed_bound`\n-  : This type implements \"managed\"\n+* `no_share_bound`\n+  : This type does not implement \"share\", even if eligible\n * `eh_personality`\n   : ___Needs filling in___\n * `exchange_free`"}, {"sha": "503c484e469d7eebfaff61c65697221fc6e5ced3", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -12,7 +12,7 @@\n //!\n //! This is the lowest level library through which allocation in Rust can be\n //! performed where the allocation is assumed to succeed. This library will\n-//! trigger a task failure when allocation fails.\n+//! abort the process when allocation fails.\n //!\n //! This library, like libcore, is not intended for general usage, but rather as\n //! a building block of other libraries. The types and interfaces in this"}, {"sha": "6d6ca59ce01eda067a5d8e5b70c51510543c9a83", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -160,6 +160,8 @@ pub trait Signed: Num + Neg<Self> {\n     /// Computes the absolute value.\n     ///\n     /// For `f32` and `f64`, `NaN` will be returned if the number is `NaN`.\n+    ///\n+    /// For signed integers, `::MIN` will be returned if the number is `::MIN`.\n     fn abs(&self) -> Self;\n \n     /// The positive difference of two numbers.\n@@ -176,7 +178,7 @@ pub trait Signed: Num + Neg<Self> {\n     /// * `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n     /// * `NaN` if the number is `NaN`\n     ///\n-    /// For `int`:\n+    /// For signed integers:\n     ///\n     /// * `0` if the number is zero\n     /// * `1` if the number is positive\n@@ -272,6 +274,8 @@ signed_float_impl!(f64, f64::NAN, f64::INFINITY, f64::NEG_INFINITY,\n /// Computes the absolute value.\n ///\n /// For `f32` and `f64`, `NaN` will be returned if the number is `NaN`\n+///\n+/// For signed integers, `::MIN` will be returned if the number is `::MIN`.\n #[inline(always)]\n pub fn abs<T: Signed>(value: T) -> T {\n     value.abs()\n@@ -294,7 +298,7 @@ pub fn abs_sub<T: Signed>(x: T, y: T) -> T {\n /// * `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n /// * `NaN` if the number is `NaN`\n ///\n-/// For int:\n+/// For signed integers:\n ///\n /// * `0` if the number is zero\n /// * `1` if the number is positive"}, {"sha": "0dbb355a6b2a629256a586b684b9190086a38096", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -57,31 +57,31 @@ use raw::Slice as RawSlice;\n // Extension traits\n //\n \n-/// Extension methods for vectors\n+/// Extension methods for immutable slices.\n #[unstable = \"may merge with other traits; region parameter may disappear\"]\n pub trait ImmutableSlice<'a, T> {\n-    /**\n-     * Returns a slice of self spanning the interval [`start`, `end`).\n-     *\n-     * Fails when the slice (or part of it) is outside the bounds of self,\n-     * or when `start` > `end`.\n-     */\n+    /// Returns a subslice spanning the interval [`start`, `end`).\n+    ///\n+    /// Fails when the end of the new slice lies beyond the end of the\n+    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n+    ///\n+    /// Slicing with `start` equal to `end` yields an empty slice.\n     #[unstable]\n     fn slice(&self, start: uint, end: uint) -> &'a [T];\n \n-    /**\n-     * Returns a slice of self from `start` to the end of the vec.\n-     *\n-     * Fails when `start` points outside the bounds of self.\n-     */\n+    /// Returns a subslice from `start` to the end of the slice.\n+    ///\n+    /// Fails when `start` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing from `self.len()` yields an empty slice.\n     #[unstable]\n     fn slice_from(&self, start: uint) -> &'a [T];\n \n-    /**\n-     * Returns a slice of self from the start of the vec to `end`.\n-     *\n-     * Fails when `end` points outside the bounds of self.\n-     */\n+    /// Returns a subslice from the start of the slice to `end`.\n+    ///\n+    /// Fails when `end` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing to `0` yields an empty slice.\n     #[unstable]\n     fn slice_to(&self, end: uint) -> &'a [T];\n \n@@ -486,21 +486,26 @@ pub trait MutableSlice<'a, T> {\n     /// Primarily intended for getting a &mut [T] from a [T, ..N].\n     fn as_mut_slice(self) -> &'a mut [T];\n \n-    /// Return a slice that points into another slice.\n+    /// Returns a mutable subslice spanning the interval [`start`, `end`).\n+    ///\n+    /// Fails when the end of the new slice lies beyond the end of the\n+    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n+    ///\n+    /// Slicing with `start` equal to `end` yields an empty slice.\n     fn mut_slice(self, start: uint, end: uint) -> &'a mut [T];\n \n-    /**\n-     * Returns a slice of self from `start` to the end of the vec.\n-     *\n-     * Fails when `start` points outside the bounds of self.\n-     */\n+    /// Returns a mutable subslice from `start` to the end of the slice.\n+    ///\n+    /// Fails when `start` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing from `self.len()` yields an empty slice.\n     fn mut_slice_from(self, start: uint) -> &'a mut [T];\n \n-    /**\n-     * Returns a slice of self from the start of the vec to `end`.\n-     *\n-     * Fails when `end` points outside the bounds of self.\n-     */\n+    /// Returns a mutable subslice from the start of the slice to `end`.\n+    ///\n+    /// Fails when `end` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing to `0` yields an empty slice.\n     fn mut_slice_to(self, end: uint) -> &'a mut [T];\n \n     /// Returns an iterator that allows modifying each value\n@@ -515,14 +520,14 @@ pub trait MutableSlice<'a, T> {\n     fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T>;\n \n     /**\n-     * Returns an iterator over `size` elements of the vector at a time.\n-     * The chunks are mutable and do not overlap. If `size` does not divide the\n-     * length of the vector, then the last chunk will not have length\n-     * `size`.\n+     * Returns an iterator over `chunk_size` elements of the vector at a time.\n+     * The chunks are mutable and do not overlap. If `chunk_size` does\n+     * not divide the length of the vector, then the last chunk will not\n+     * have length `chunk_size`.\n      *\n      * # Failure\n      *\n-     * Fails if `size` is 0.\n+     * Fails if `chunk_size` is 0.\n      */\n     fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T>;\n "}, {"sha": "32222fb16ce61a9eb6ee1d8f2e7ea920ae1452dd", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 148, "deletions": 114, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -8,120 +8,154 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n-\n-Utilities for program-wide and customizable logging\n-\n-## Example\n-\n-```\n-#![feature(phase)]\n-#[phase(plugin, link)] extern crate log;\n-\n-fn main() {\n-    debug!(\"this is a debug {}\", \"message\");\n-    error!(\"this is printed by default\");\n-\n-    if log_enabled!(log::INFO) {\n-        let x = 3i * 4i; // expensive computation\n-        info!(\"the answer was: {}\", x);\n-    }\n-}\n-```\n-\n-## Logging Macros\n-\n-There are five macros that the logging subsystem uses:\n-\n-* `log!(level, ...)` - the generic logging macro, takes a level as a u32 and any\n-                       related `format!` arguments\n-* `debug!(...)` - a macro hard-wired to the log level of `DEBUG`\n-* `info!(...)` - a macro hard-wired to the log level of `INFO`\n-* `warn!(...)` - a macro hard-wired to the log level of `WARN`\n-* `error!(...)` - a macro hard-wired to the log level of `ERROR`\n-\n-All of these macros use the same style of syntax as the `format!` syntax\n-extension. Details about the syntax can be found in the documentation of\n-`std::fmt` along with the Rust tutorial/manual.\n-\n-If you want to check at runtime if a given logging level is enabled (e.g. if the\n-information you would want to log is expensive to produce), you can use the\n-following macro:\n-\n-* `log_enabled!(level)` - returns true if logging of the given level is enabled\n-\n-## Enabling logging\n-\n-Log levels are controlled on a per-module basis, and by default all logging is\n-disabled except for `error!` (a log level of 1). Logging is controlled via the\n-`RUST_LOG` environment variable. The value of this environment variable is a\n-comma-separated list of logging directives. A logging directive is of the form:\n-\n-```text\n-path::to::module=log_level\n-```\n-\n-The path to the module is rooted in the name of the crate it was compiled for,\n-so if your program is contained in a file `hello.rs`, for example, to turn on\n-logging for this file you would use a value of `RUST_LOG=hello`.\n-Furthermore, this path is a prefix-search, so all modules nested in the\n-specified module will also have logging enabled.\n-\n-The actual `log_level` is optional to specify. If omitted, all logging will be\n-enabled. If specified, the it must be either a numeric in the range of 1-255, or\n-it must be one of the strings `debug`, `error`, `info`, or `warn`. If a numeric\n-is specified, then all logging less than or equal to that numeral is enabled.\n-For example, if logging level 3 is active, error, warn, and info logs will be\n-printed, but debug will be omitted.\n-\n-As the log level for a module is optional, the module to enable logging for is\n-also optional. If only a `log_level` is provided, then the global log level for\n-all modules is set to this value.\n-\n-Some examples of valid values of `RUST_LOG` are:\n-\n-* `hello` turns on all logging for the 'hello' module\n-* `info` turns on all info logging\n-* `hello=debug` turns on debug logging for 'hello'\n-* `hello=3` turns on info logging for 'hello'\n-* `hello,std::option` turns on hello, and std's option logging\n-* `error,hello=warn` turn on global error logging and also warn for hello\n-\n-## Filtering results\n-\n-A RUST_LOG directive may include a regex filter. The syntax is to append `/`\n-followed by a regex. Each message is checked against the regex, and is only\n-logged if it matches. Note that the matching is done after formatting the log\n-string but before adding any logging meta-data. There is a single filter for all\n-modules.\n-\n-Some examples:\n-\n-* `hello/foo` turns on all logging for the 'hello' module where the log message\n-includes 'foo'.\n-* `info/f.o` turns on all info logging where the log message includes 'foo',\n-'f1o', 'fao', etc.\n-* `hello=debug/foo*foo` turns on debug logging for 'hello' where the the log\n-message includes 'foofoo' or 'fofoo' or 'fooooooofoo', etc.\n-* `error,hello=warn/[0-9] scopes` turn on global error logging and also warn for\n- hello. In both cases the log message must include a single digit number\n- followed by 'scopes'\n-\n-## Performance and Side Effects\n-\n-Each of these macros will expand to code similar to:\n-\n-```rust,ignore\n-if log_level <= my_module_log_level() {\n-    ::log::log(log_level, format!(...));\n-}\n-```\n-\n-What this means is that each of these macros are very cheap at runtime if\n-they're turned off (just a load and an integer comparison). This also means that\n-if logging is disabled, none of the components of the log will be executed.\n-\n-*/\n+//! Utilities for program-wide and customizable logging\n+//!\n+//! ## Example\n+//!\n+//! ```\n+//! #![feature(phase)]\n+//! #[phase(plugin, link)] extern crate log;\n+//!\n+//! fn main() {\n+//!     debug!(\"this is a debug {}\", \"message\");\n+//!     error!(\"this is printed by default\");\n+//!\n+//!     if log_enabled!(log::INFO) {\n+//!         let x = 3i * 4i; // expensive computation\n+//!         info!(\"the answer was: {}\", x);\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! Assumes the binary is `main`:\n+//!\n+//! ```{.bash}\n+//! $ RUST_LOG=error ./main\n+//! ERROR:main: this is printed by default\n+//! ```\n+//!\n+//! ```{.bash}\n+//! $ RUST_LOG=info ./main\n+//! ERROR:main: this is printed by default\n+//! INFO:main: the answer was: 12\n+//! ```\n+//!\n+//! ```{.bash}\n+//! $ RUST_LOG=debug ./main\n+//! DEBUG:main: this is a debug message\n+//! ERROR:main: this is printed by default\n+//! INFO:main: the answer was: 12\n+//! ```\n+//!\n+//! You can also set the log level on a per module basis:\n+//!\n+//! ```{.bash}\n+//! $ RUST_LOG=main=info ./main\n+//! ERROR:main: this is printed by default\n+//! INFO:main: the answer was: 12\n+//! ```\n+//!\n+//! And enable all logging:\n+//!\n+//! ```{.bash}\n+//! $ RUST_LOG=main ./main\n+//! DEBUG:main: this is a debug message\n+//! ERROR:main: this is printed by default\n+//! INFO:main: the answer was: 12\n+//! ```\n+//!\n+//!\n+//! ## Logging Macros\n+//!\n+//! There are five macros that the logging subsystem uses:\n+//!\n+//! * `log!(level, ...)` - the generic logging macro, takes a level as a u32 and any\n+//!                        related `format!` arguments\n+//! * `debug!(...)` - a macro hard-wired to the log level of `DEBUG`\n+//! * `info!(...)` - a macro hard-wired to the log level of `INFO`\n+//! * `warn!(...)` - a macro hard-wired to the log level of `WARN`\n+//! * `error!(...)` - a macro hard-wired to the log level of `ERROR`\n+//!\n+//! All of these macros use the same style of syntax as the `format!` syntax\n+//! extension. Details about the syntax can be found in the documentation of\n+//! `std::fmt` along with the Rust tutorial/manual.\n+//!\n+//! If you want to check at runtime if a given logging level is enabled (e.g. if the\n+//! information you would want to log is expensive to produce), you can use the\n+//! following macro:\n+//!\n+//! * `log_enabled!(level)` - returns true if logging of the given level is enabled\n+//!\n+//! ## Enabling logging\n+//!\n+//! Log levels are controlled on a per-module basis, and by default all logging is\n+//! disabled except for `error!` (a log level of 1). Logging is controlled via the\n+//! `RUST_LOG` environment variable. The value of this environment variable is a\n+//! comma-separated list of logging directives. A logging directive is of the form:\n+//!\n+//! ```text\n+//! path::to::module=log_level\n+//! ```\n+//!\n+//! The path to the module is rooted in the name of the crate it was compiled for,\n+//! so if your program is contained in a file `hello.rs`, for example, to turn on\n+//! logging for this file you would use a value of `RUST_LOG=hello`.\n+//! Furthermore, this path is a prefix-search, so all modules nested in the\n+//! specified module will also have logging enabled.\n+//!\n+//! The actual `log_level` is optional to specify. If omitted, all logging will be\n+//! enabled. If specified, the it must be either a numeric in the range of 1-255, or\n+//! it must be one of the strings `debug`, `error`, `info`, or `warn`. If a numeric\n+//! is specified, then all logging less than or equal to that numeral is enabled.\n+//! For example, if logging level 3 is active, error, warn, and info logs will be\n+//! printed, but debug will be omitted.\n+//!\n+//! As the log level for a module is optional, the module to enable logging for is\n+//! also optional. If only a `log_level` is provided, then the global log level for\n+//! all modules is set to this value.\n+//!\n+//! Some examples of valid values of `RUST_LOG` are:\n+//!\n+//! * `hello` turns on all logging for the 'hello' module\n+//! * `info` turns on all info logging\n+//! * `hello=debug` turns on debug logging for 'hello'\n+//! * `hello=3` turns on info logging for 'hello'\n+//! * `hello,std::option` turns on hello, and std's option logging\n+//! * `error,hello=warn` turn on global error logging and also warn for hello\n+//!\n+//! ## Filtering results\n+//!\n+//! A RUST_LOG directive may include a regex filter. The syntax is to append `/`\n+//! followed by a regex. Each message is checked against the regex, and is only\n+//! logged if it matches. Note that the matching is done after formatting the log\n+//! string but before adding any logging meta-data. There is a single filter for all\n+//! modules.\n+//!\n+//! Some examples:\n+//!\n+//! * `hello/foo` turns on all logging for the 'hello' module where the log message\n+//! includes 'foo'.\n+//! * `info/f.o` turns on all info logging where the log message includes 'foo',\n+//! 'f1o', 'fao', etc.\n+//! * `hello=debug/foo*foo` turns on debug logging for 'hello' where the the log\n+//! message includes 'foofoo' or 'fofoo' or 'fooooooofoo', etc.\n+//! * `error,hello=warn/[0-9] scopes` turn on global error logging and also warn for\n+//!  hello. In both cases the log message must include a single digit number\n+//!  followed by 'scopes'\n+//!\n+//! ## Performance and Side Effects\n+//!\n+//! Each of these macros will expand to code similar to:\n+//!\n+//! ```rust,ignore\n+//! if log_level <= my_module_log_level() {\n+//!     ::log::log(log_level, format!(...));\n+//! }\n+//! ```\n+//!\n+//! What this means is that each of these macros are very cheap at runtime if\n+//! they're turned off (just a load and an integer comparison). This also means that\n+//! if logging is disabled, none of the components of the log will be executed.\n \n #![crate_name = \"log\"]\n #![experimental]"}, {"sha": "4f8837083ae57d5c00443cbf571e82573195fe92", "filename": "src/liblog/macros.rs", "status": "modified", "additions": 88, "deletions": 27, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Fliblog%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Fliblog%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fmacros.rs?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -24,11 +24,31 @@\n /// #![feature(phase)]\n /// #[phase(plugin, link)] extern crate log;\n ///\n-/// # fn main() {\n-/// log!(log::DEBUG, \"this is a debug message\");\n-/// log!(log::WARN, \"this is a warning {}\", \"message\");\n-/// log!(6, \"this is a custom logging level: {level}\", level=6u);\n-/// # }\n+/// fn main() {\n+///     log!(log::WARN, \"this is a warning {}\", \"message\");\n+///     log!(log::DEBUG, \"this is a debug message\");\n+///     log!(6, \"this is a custom logging level: {level}\", level=6u);\n+/// }\n+/// ```\n+///\n+/// Assumes the binary is `main`:\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=warn ./main\n+/// WARN:main: this is a warning message\n+/// ```\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=debug ./main\n+/// DEBUG:main: this is a debug message\n+/// WARN:main: this is a warning message\n+/// ```\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=6 ./main\n+/// DEBUG:main: this is a debug message\n+/// WARN:main: this is a warning message\n+/// 6:main: this is a custom logging level: 6\n /// ```\n #[macro_export]\n macro_rules! log(\n@@ -53,11 +73,19 @@ macro_rules! log(\n /// #![feature(phase)]\n /// #[phase(plugin, link)] extern crate log;\n ///\n-/// # fn main() {\n-/// # let error = 3u;\n-/// error!(\"the build has failed with error code: {}\", error);\n-/// # }\n+/// fn main() {\n+///     let error = 3u;\n+///     error!(\"the build has failed with error code: {}\", error);\n+/// }\n+/// ```\n+///\n+/// Assumes the binary is `main`:\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=error ./main\n+/// ERROR:main: the build has failed with error code: 3\n /// ```\n+///\n #[macro_export]\n macro_rules! error(\n     ($($arg:tt)*) => (log!(::log::ERROR, $($arg)*))\n@@ -71,10 +99,17 @@ macro_rules! error(\n /// #![feature(phase)]\n /// #[phase(plugin, link)] extern crate log;\n ///\n-/// # fn main() {\n-/// # let code = 3u;\n-/// warn!(\"you may like to know that a process exited with: {}\", code);\n-/// # }\n+/// fn main() {\n+///     let code = 3u;\n+///     warn!(\"you may like to know that a process exited with: {}\", code);\n+/// }\n+/// ```\n+///\n+/// Assumes the binary is `main`:\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=warn ./main\n+/// WARN:main: you may like to know that a process exited with: 3\n /// ```\n #[macro_export]\n macro_rules! warn(\n@@ -89,10 +124,17 @@ macro_rules! warn(\n /// #![feature(phase)]\n /// #[phase(plugin, link)] extern crate log;\n ///\n-/// # fn main() {\n-/// # let ret = 3i;\n-/// info!(\"this function is about to return: {}\", ret);\n-/// # }\n+/// fn main() {\n+///     let ret = 3i;\n+///     info!(\"this function is about to return: {}\", ret);\n+/// }\n+/// ```\n+///\n+/// Assumes the binary is `main`:\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=info ./main\n+/// INFO:main: this function is about to return: 3\n /// ```\n #[macro_export]\n macro_rules! info(\n@@ -109,9 +151,16 @@ macro_rules! info(\n /// #![feature(phase)]\n /// #[phase(plugin, link)] extern crate log;\n ///\n-/// # fn main() {\n-/// debug!(\"x = {x}, y = {y}\", x=10i, y=20i);\n-/// # }\n+/// fn main() {\n+///     debug!(\"x = {x}, y = {y}\", x=10i, y=20i);\n+/// }\n+/// ```\n+///\n+/// Assumes the binary is `main`:\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=debug ./main\n+/// DEBUG:main: x = 10, y = 20\n /// ```\n #[macro_export]\n macro_rules! debug(\n@@ -126,14 +175,26 @@ macro_rules! debug(\n /// #![feature(phase)]\n /// #[phase(plugin, link)] extern crate log;\n ///\n-/// # fn main() {\n-/// # struct Point { x: int, y: int }\n-/// # fn some_expensive_computation() -> Point { Point { x: 1, y: 2 } }\n-/// if log_enabled!(log::DEBUG) {\n-///     let x = some_expensive_computation();\n-///     debug!(\"x.x = {}, x.y = {}\", x.x, x.y);\n+/// struct Point { x: int, y: int }\n+/// fn some_expensive_computation() -> Point { Point { x: 1, y: 2 } }\n+///\n+/// fn main() {\n+///     if log_enabled!(log::DEBUG) {\n+///         let x = some_expensive_computation();\n+///         debug!(\"x.x = {}, x.y = {}\", x.x, x.y);\n+///     }\n /// }\n-/// # }\n+/// ```\n+///\n+/// Assumes the binary is `main`:\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=error ./main\n+/// ```\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=debug ./main\n+/// DEBUG:main: x.x = 1, x.y = 2\n /// ```\n #[macro_export]\n macro_rules! log_enabled("}, {"sha": "6f85460ab956e4ad5956dd3dde7edc1b551a2334", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -137,15 +137,14 @@ impl<T: Clone + Integer + PartialOrd>\n     }\n \n     /// Rounds to the nearest integer. Rounds half-way cases away from zero.\n-    ///\n-    /// Note: This function is currently broken and always rounds away from zero.\n     #[inline]\n     pub fn round(&self) -> Ratio<T> {\n-        // FIXME(#15826)\n         if *self < Zero::zero() {\n-            Ratio::from_integer((self.numer - self.denom + One::one()) / self.denom)\n+            // a/b - 1/2 = (2*a - b)/(2*b)\n+            Ratio::from_integer((self.numer + self.numer - self.denom) / (self.denom + self.denom))\n         } else {\n-            Ratio::from_integer((self.numer + self.denom - One::one()) / self.denom)\n+            // a/b + 1/2 = (2*a + b)/(2*b)\n+            Ratio::from_integer((self.numer + self.numer + self.denom) / (self.denom + self.denom))\n         }\n     }\n \n@@ -388,7 +387,11 @@ mod test {\n     pub static _2: Rational = Ratio { numer: 2, denom: 1};\n     pub static _1_2: Rational = Ratio { numer: 1, denom: 2};\n     pub static _3_2: Rational = Ratio { numer: 3, denom: 2};\n-    pub static _neg1_2: Rational =  Ratio { numer: -1, denom: 2};\n+    pub static _neg1_2: Rational = Ratio { numer: -1, denom: 2};\n+    pub static _1_3: Rational = Ratio { numer: 1, denom: 3};\n+    pub static _neg1_3: Rational = Ratio { numer: -1, denom: 3};\n+    pub static _2_3: Rational = Ratio { numer: 2, denom: 3};\n+    pub static _neg2_3: Rational = Ratio { numer: -2, denom: 3};\n \n     pub fn to_big(n: Rational) -> BigRational {\n         Ratio::new(\n@@ -578,6 +581,26 @@ mod test {\n \n     #[test]\n     fn test_round() {\n+        assert_eq!(_1_3.ceil(), _1);\n+        assert_eq!(_1_3.floor(), _0);\n+        assert_eq!(_1_3.round(), _0);\n+        assert_eq!(_1_3.trunc(), _0);\n+\n+        assert_eq!(_neg1_3.ceil(), _0);\n+        assert_eq!(_neg1_3.floor(), -_1);\n+        assert_eq!(_neg1_3.round(), _0);\n+        assert_eq!(_neg1_3.trunc(), _0);\n+\n+        assert_eq!(_2_3.ceil(), _1);\n+        assert_eq!(_2_3.floor(), _0);\n+        assert_eq!(_2_3.round(), _1);\n+        assert_eq!(_2_3.trunc(), _0);\n+\n+        assert_eq!(_neg2_3.ceil(), _0);\n+        assert_eq!(_neg2_3.floor(), -_1);\n+        assert_eq!(_neg2_3.round(), -_1);\n+        assert_eq!(_neg2_3.trunc(), _0);\n+\n         assert_eq!(_1_2.ceil(), _1);\n         assert_eq!(_1_2.floor(), _0);\n         assert_eq!(_1_2.round(), _1);"}, {"sha": "2305434726599d0d4968f8c12d14be30a8e1cdde", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -417,7 +417,7 @@ pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n                             sess.span_err(mi.span, \"feature has been removed\");\n                         }\n                         Some(&(_, Accepted)) => {\n-                            sess.span_warn(mi.span, \"feature has added to rust, \\\n+                            sess.span_warn(mi.span, \"feature has been added to Rust, \\\n                                                      directive not necessary\");\n                         }\n                         None => {"}, {"sha": "fc93e482adc931181b193eb914ba45a3621f63a6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -599,7 +599,7 @@ impl<'a> Parser<'a> {\n             let token_str = self.this_token_to_string();\n             let span = self.span;\n             self.span_err(span,\n-                          format!(\"found `{}` in ident position\",\n+                          format!(\"expected identifier, found keyword `{}`\",\n                                   token_str).as_slice());\n         }\n     }"}, {"sha": "ca10bdd9848ece78f7f018e68b6dac5b2ca10249", "filename": "src/test/compile-fail/bad-value-ident-false.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Fbad-value-ident-false.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Fbad-value-ident-false.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-value-ident-false.rs?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn false() { } //~ ERROR found `false` in ident position\n+fn false() { } //~ ERROR expected identifier, found keyword `false`\n fn main() { }"}, {"sha": "4508d5219a21735f71c93fa9f4a50123b96da25a", "filename": "src/test/compile-fail/bad-value-ident-true.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Fbad-value-ident-true.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Fbad-value-ident-true.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-value-ident-true.rs?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn true() { } //~ ERROR found `true` in ident position\n+fn true() { } //~ ERROR expected identifier, found keyword `true`\n fn main() { }"}, {"sha": "39cd3e3b86afefb7857816323cb2dad10abf979e", "filename": "src/test/compile-fail/gated-bad-feature.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Fgated-bad-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Fgated-bad-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgated-bad-feature.rs?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -20,4 +20,4 @@\n #![feature = \"foo\"] //~ ERROR: malformed feature\n \n #![feature(test_removed_feature)] //~ ERROR: feature has been removed\n-#![feature(test_accepted_feature)] //~ WARNING: feature has added\n+#![feature(test_accepted_feature)] //~ WARNING: feature has been added"}, {"sha": "6cbc8aa1ea642509af53ea077ab9b765315b3bda", "filename": "src/test/compile-fail/keyword-super.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Fkeyword-super.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Fkeyword-super.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkeyword-super.rs?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    let super: int; //~ ERROR found `super` in ident position\n+    let super: int; //~ ERROR expected identifier, found keyword `super`\n }"}, {"sha": "64eac47e69b329b97d9ce93409c560b413c03ca9", "filename": "src/test/compile-fail/keyword.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkeyword.rs?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n pub mod break {\n-    //~^ ERROR found `break` in ident position\n+    //~^ ERROR expected identifier, found keyword `break`\n }"}, {"sha": "c8711598163a0c199278b71def8a6f1176060491", "filename": "src/test/compile-fail/removed-syntax-field-let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-field-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-field-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-field-let.rs?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -10,6 +10,6 @@\n \n struct s {\n     let foo: (),\n-    //~^  ERROR found `let` in ident position\n+    //~^  ERROR expected identifier, found keyword `let`\n     //~^^ ERROR expected `:`, found `foo`\n }"}, {"sha": "b20da6346f775decc0e124afde42598dd2b2cd22", "filename": "src/test/compile-fail/removed-syntax-mut-vec-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-expr.rs?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -10,6 +10,6 @@\n \n fn f() {\n     let v = [mut 1, 2, 3, 4];\n-    //~^  ERROR found `mut` in ident position\n+    //~^  ERROR expected identifier, found keyword `mut`\n     //~^^ ERROR expected `]`, found `1`\n }"}, {"sha": "c5eec2ef6e19930f43e35458c3b3fa5fed3fa4ba", "filename": "src/test/compile-fail/removed-syntax-mut-vec-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-mut-vec-ty.rs?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n type v = [mut int];\n-    //~^  ERROR found `mut` in ident position\n+    //~^  ERROR expected identifier, found keyword `mut`\n     //~^^ ERROR expected `]`, found `int`"}, {"sha": "124b3738fab5ffd6e9041f0eb67010adf3732504", "filename": "src/test/compile-fail/removed-syntax-uniq-mut-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-expr.rs?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -10,6 +10,6 @@\n \n fn f() {\n     let a_box = box mut 42;\n-    //~^  ERROR found `mut` in ident position\n+    //~^  ERROR expected identifier, found keyword `mut`\n     //~^^ ERROR expected `;`, found `42`\n }"}, {"sha": "579bfed1331ed5e4467d52b6f5244fbbef4442a8", "filename": "src/test/compile-fail/removed-syntax-uniq-mut-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fremoved-syntax-uniq-mut-ty.rs?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n type mut_box = Box<mut int>;\n-    //~^  ERROR found `mut` in ident position\n+    //~^  ERROR expected identifier, found keyword `mut`\n     //~^^ ERROR expected `,`, found `int`"}, {"sha": "c5f9e8d5991938878d669152669f493ef2cb874b", "filename": "src/test/compile-fail/unsized2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Funsized2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db47aa5bdf308213b4198b81e9d2e406ec716189/src%2Ftest%2Fcompile-fail%2Funsized2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized2.rs?ref=db47aa5bdf308213b4198b81e9d2e406ec716189", "patch": "@@ -13,5 +13,5 @@\n fn f<X>() {}\n \n pub fn main() {\n-    f<type>(); //~ ERROR found `type` in ident position\n+    f<type>(); //~ ERROR expected identifier, found keyword `type`\n }"}]}