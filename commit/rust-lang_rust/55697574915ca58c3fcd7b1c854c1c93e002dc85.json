{"sha": "55697574915ca58c3fcd7b1c854c1c93e002dc85", "node_id": "C_kwDOAAsO6NoAKDU1Njk3NTc0OTE1Y2E1OGMzZmNkN2IxYzg1NGMxYzkzZTAwMmRjODU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-15T11:59:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-15T11:59:37Z"}, "message": "Auto merge of #93148 - nnethercote:Uniq, r=fee1-dead\n\nOverhaul interning.\n\nA number of types are interned and `eq` and `hash` are implemented on\nthe pointer rather than the contents. But this is not well enforced\nwithin the type system like you might expect.\n\nThis PR introduces a new type `Interned` which encapsulates this concept\nmore rigorously, and uses it to convert a couple of the less common\ninterned types.\n\nr? `@fee1-dead`", "tree": {"sha": "43f8669ead4f7dbe2812b96a39d1d52bffc62e62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43f8669ead4f7dbe2812b96a39d1d52bffc62e62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55697574915ca58c3fcd7b1c854c1c93e002dc85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55697574915ca58c3fcd7b1c854c1c93e002dc85", "html_url": "https://github.com/rust-lang/rust/commit/55697574915ca58c3fcd7b1c854c1c93e002dc85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55697574915ca58c3fcd7b1c854c1c93e002dc85/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6421a499a50adbaa7b5d0234bdd4817d970f0933", "url": "https://api.github.com/repos/rust-lang/rust/commits/6421a499a50adbaa7b5d0234bdd4817d970f0933", "html_url": "https://github.com/rust-lang/rust/commit/6421a499a50adbaa7b5d0234bdd4817d970f0933"}, {"sha": "80632de4a1f9d1c0dfe16170fc079e940f42776a", "url": "https://api.github.com/repos/rust-lang/rust/commits/80632de4a1f9d1c0dfe16170fc079e940f42776a", "html_url": "https://github.com/rust-lang/rust/commit/80632de4a1f9d1c0dfe16170fc079e940f42776a"}], "stats": {"total": 3598, "additions": 1913, "deletions": 1685}, "files": [{"sha": "22edee33c5c1b6c978a9f54fb9384ea53821a845", "filename": "compiler/rustc_borrowck/src/constraint_generation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -60,8 +60,8 @@ impl<'cg, 'cx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'tcx> {\n \n     /// We sometimes have `region` within an rvalue, or within a\n     /// call. Make them live at the location where they appear.\n-    fn visit_region(&mut self, region: &ty::Region<'tcx>, location: Location) {\n-        self.add_regular_live_constraint(*region, location);\n+    fn visit_region(&mut self, region: ty::Region<'tcx>, location: Location) {\n+        self.add_regular_live_constraint(region, location);\n         self.super_region(region);\n     }\n "}, {"sha": "904a8a22e0182fea510e4cc4616a75f2e030c963", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -356,8 +356,8 @@ fn try_extract_error_from_fulfill_cx<'tcx>(\n     })?;\n \n     debug!(?sub_region, \"cause = {:#?}\", cause);\n-    let nice_error = match (error_region, sub_region) {\n-        (Some(error_region), &ty::ReVar(vid)) => NiceRegionError::new(\n+    let nice_error = match (error_region, *sub_region) {\n+        (Some(error_region), ty::ReVar(vid)) => NiceRegionError::new(\n             infcx,\n             RegionResolutionError::SubSupConflict(\n                 vid,\n@@ -374,7 +374,7 @@ fn try_extract_error_from_fulfill_cx<'tcx>(\n             RegionResolutionError::ConcreteFailure(cause.clone(), error_region, placeholder_region),\n         ),\n         // Note universe here is wrong...\n-        (None, &ty::ReVar(vid)) => NiceRegionError::new(\n+        (None, ty::ReVar(vid)) => NiceRegionError::new(\n             infcx,\n             RegionResolutionError::UpperBoundUniverseConflict(\n                 vid,"}, {"sha": "fce5ed0ef42390539b10fbdc8d97373ab3269061", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -2324,7 +2324,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // This is also case 2 from above but for functions, return type is still an\n                 // anonymous reference so we select the first argument.\n                 let argument_span = fn_decl.inputs.first()?.span;\n-                let argument_ty = sig.inputs().skip_binder().first()?;\n+                let argument_ty = *sig.inputs().skip_binder().first()?;\n \n                 let return_span = fn_decl.output.span();\n                 let return_ty = sig.output().skip_binder();\n@@ -2379,27 +2379,27 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n         diag: &mut DiagnosticBuilder<'_>,\n     ) -> String {\n         match self {\n-            AnnotatedBorrowFnSignature::Closure { argument_ty, argument_span } => {\n+            &AnnotatedBorrowFnSignature::Closure { argument_ty, argument_span } => {\n                 diag.span_label(\n-                    *argument_span,\n+                    argument_span,\n                     format!(\"has type `{}`\", cx.get_name_for_ty(argument_ty, 0)),\n                 );\n \n                 cx.get_region_name_for_ty(argument_ty, 0)\n             }\n-            AnnotatedBorrowFnSignature::AnonymousFunction {\n+            &AnnotatedBorrowFnSignature::AnonymousFunction {\n                 argument_ty,\n                 argument_span,\n                 return_ty,\n                 return_span,\n             } => {\n                 let argument_ty_name = cx.get_name_for_ty(argument_ty, 0);\n-                diag.span_label(*argument_span, format!(\"has type `{}`\", argument_ty_name));\n+                diag.span_label(argument_span, format!(\"has type `{}`\", argument_ty_name));\n \n                 let return_ty_name = cx.get_name_for_ty(return_ty, 0);\n                 let types_equal = return_ty_name == argument_ty_name;\n                 diag.span_label(\n-                    *return_span,\n+                    return_span,\n                     format!(\n                         \"{}has type `{}`\",\n                         if types_equal { \"also \" } else { \"\" },\n@@ -2419,7 +2419,7 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n             }\n             AnnotatedBorrowFnSignature::NamedFunction { arguments, return_ty, return_span } => {\n                 // Region of return type and arguments checked to be the same earlier.\n-                let region_name = cx.get_region_name_for_ty(return_ty, 0);\n+                let region_name = cx.get_region_name_for_ty(*return_ty, 0);\n                 for (_, argument_span) in arguments {\n                     diag.span_label(*argument_span, format!(\"has lifetime `{}`\", region_name));\n                 }"}, {"sha": "5da2021e7110adfc2280f5f92a1abaa4c0da1dbe", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -331,18 +331,18 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match place {\n             PlaceRef { local, projection: [] } => {\n                 let local = &self.body.local_decls[local];\n-                self.describe_field_from_ty(&local.ty, field, None)\n+                self.describe_field_from_ty(local.ty, field, None)\n             }\n             PlaceRef { local, projection: [proj_base @ .., elem] } => match elem {\n                 ProjectionElem::Deref => {\n                     self.describe_field(PlaceRef { local, projection: proj_base }, field)\n                 }\n                 ProjectionElem::Downcast(_, variant_index) => {\n                     let base_ty = place.ty(self.body, self.infcx.tcx).ty;\n-                    self.describe_field_from_ty(&base_ty, field, Some(*variant_index))\n+                    self.describe_field_from_ty(base_ty, field, Some(*variant_index))\n                 }\n                 ProjectionElem::Field(_, field_type) => {\n-                    self.describe_field_from_ty(&field_type, field, None)\n+                    self.describe_field_from_ty(*field_type, field, None)\n                 }\n                 ProjectionElem::Index(..)\n                 | ProjectionElem::ConstantIndex { .. }\n@@ -362,7 +362,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> String {\n         if ty.is_box() {\n             // If the type is a box, the field is described from the boxed type\n-            self.describe_field_from_ty(&ty.boxed_ty(), field, variant_index)\n+            self.describe_field_from_ty(ty.boxed_ty(), field, variant_index)\n         } else {\n             match *ty.kind() {\n                 ty::Adt(def, _) => {\n@@ -376,10 +376,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n                 ty::Tuple(_) => field.index().to_string(),\n                 ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                    self.describe_field_from_ty(&ty, field, variant_index)\n+                    self.describe_field_from_ty(ty, field, variant_index)\n                 }\n                 ty::Array(ty, _) | ty::Slice(ty) => {\n-                    self.describe_field_from_ty(&ty, field, variant_index)\n+                    self.describe_field_from_ty(ty, field, variant_index)\n                 }\n                 ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n                     // We won't be borrowck'ing here if the closure came from another crate,\n@@ -497,14 +497,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // We need to add synthesized lifetimes where appropriate. We do\n         // this by hooking into the pretty printer and telling it to label the\n         // lifetimes without names with the value `'0`.\n-        match ty.kind() {\n-            ty::Ref(\n-                ty::RegionKind::ReLateBound(_, ty::BoundRegion { kind: br, .. })\n-                | ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }),\n-                _,\n-                _,\n-            ) => printer.region_highlight_mode.highlighting_bound_region(*br, counter),\n-            _ => {}\n+        if let ty::Ref(region, ..) = ty.kind() {\n+            match **region {\n+                ty::ReLateBound(_, ty::BoundRegion { kind: br, .. })\n+                | ty::RePlaceholder(ty::PlaceholderRegion { name: br, .. }) => {\n+                    printer.region_highlight_mode.highlighting_bound_region(br, counter)\n+                }\n+                _ => {}\n+            }\n         }\n \n         let _ = ty.print(printer);\n@@ -517,19 +517,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let mut s = String::new();\n         let mut printer = ty::print::FmtPrinter::new(self.infcx.tcx, &mut s, Namespace::TypeNS);\n \n-        let region = match ty.kind() {\n-            ty::Ref(region, _, _) => {\n-                match region {\n-                    ty::RegionKind::ReLateBound(_, ty::BoundRegion { kind: br, .. })\n-                    | ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }) => {\n-                        printer.region_highlight_mode.highlighting_bound_region(*br, counter)\n-                    }\n-                    _ => {}\n+        let region = if let ty::Ref(region, ..) = ty.kind() {\n+            match **region {\n+                ty::ReLateBound(_, ty::BoundRegion { kind: br, .. })\n+                | ty::RePlaceholder(ty::PlaceholderRegion { name: br, .. }) => {\n+                    printer.region_highlight_mode.highlighting_bound_region(br, counter)\n                 }\n-\n-                region\n+                _ => {}\n             }\n-            _ => bug!(\"ty for annotation of borrow region is not a reference\"),\n+            region\n+        } else {\n+            bug!(\"ty for annotation of borrow region is not a reference\");\n         };\n \n         let _ = region.print(printer);"}, {"sha": "cc6566882ad5d800e21098dec46b597e1fb2fa8d", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -246,18 +246,18 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             );\n             (\n                 match kind {\n-                    IllegalMoveOriginKind::BorrowedContent { target_place } => self\n+                    &IllegalMoveOriginKind::BorrowedContent { target_place } => self\n                         .report_cannot_move_from_borrowed_content(\n                             original_path,\n-                            *target_place,\n+                            target_place,\n                             span,\n                             use_spans,\n                         ),\n-                    IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n+                    &IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n                         self.cannot_move_out_of_interior_of_drop(span, ty)\n                     }\n-                    IllegalMoveOriginKind::InteriorOfSliceOrArray { ty, is_index } => {\n-                        self.cannot_move_out_of_interior_noncopy(span, ty, Some(*is_index))\n+                    &IllegalMoveOriginKind::InteriorOfSliceOrArray { ty, is_index } => {\n+                        self.cannot_move_out_of_interior_noncopy(span, ty, Some(is_index))\n                     }\n                 },\n                 span,"}, {"sha": "ca1e77ff8fdc05a8e003d26044a78062a25ce69c", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n     /// Returns `true` if a closure is inferred to be an `FnMut` closure.\n     fn is_closure_fn_mut(&self, fr: RegionVid) -> bool {\n-        if let Some(ty::ReFree(free_region)) = self.to_error_region(fr) {\n+        if let Some(ty::ReFree(free_region)) = self.to_error_region(fr).as_deref() {\n             if let ty::BoundRegionKind::BrEnv = free_region.bound_region {\n                 if let DefiningTy::Closure(_, substs) =\n                     self.regioncx.universal_regions().defining_ty\n@@ -628,8 +628,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         fr_name: RegionName,\n         outlived_fr: RegionVid,\n     ) {\n-        if let (Some(f), Some(ty::RegionKind::ReStatic)) =\n-            (self.to_error_region(fr), self.to_error_region(outlived_fr))\n+        if let (Some(f), Some(ty::ReStatic)) =\n+            (self.to_error_region(fr), self.to_error_region(outlived_fr).as_deref())\n         {\n             if let Some(&ty::Opaque(did, substs)) = self\n                 .infcx\n@@ -652,7 +652,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                             bound.kind().skip_binder()\n                         {\n                             let r = r.subst(self.infcx.tcx, substs);\n-                            if let ty::RegionKind::ReStatic = r {\n+                            if r.is_static() {\n                                 found = true;\n                                 break;\n                             } else {"}, {"sha": "3bcc9f7be384fd19772af99ffebe2750d0c11452", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -264,7 +264,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         let tcx = self.infcx.tcx;\n \n         debug!(\"give_region_a_name: error_region = {:?}\", error_region);\n-        match error_region {\n+        match *error_region {\n             ty::ReEarlyBound(ebr) => {\n                 if ebr.has_name() {\n                     let span = tcx.hir().span_if_local(ebr.def_id).unwrap_or(DUMMY_SP);\n@@ -433,7 +433,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         span: Span,\n         counter: usize,\n     ) -> RegionNameHighlight {\n-        let mut highlight = RegionHighlightMode::default();\n+        let mut highlight = RegionHighlightMode::new(self.infcx.tcx);\n         highlight.highlighting_region_vid(needle_fr, counter);\n         let type_name =\n             self.infcx.extract_inference_diagnostics_data(ty.into(), Some(highlight)).name;\n@@ -500,7 +500,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                     }\n \n                     // Otherwise, let's descend into the referent types.\n-                    search_stack.push((referent_ty, &referent_hir_ty.ty));\n+                    search_stack.push((*referent_ty, &referent_hir_ty.ty));\n                 }\n \n                 // Match up something like `Foo<'1>`\n@@ -539,7 +539,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n                 (ty::Slice(elem_ty), hir::TyKind::Slice(elem_hir_ty))\n                 | (ty::Array(elem_ty, _), hir::TyKind::Array(elem_hir_ty, _)) => {\n-                    search_stack.push((elem_ty, elem_hir_ty));\n+                    search_stack.push((*elem_ty, elem_hir_ty));\n                 }\n \n                 (ty::RawPtr(mut_ty), hir::TyKind::Ptr(mut_hir_ty)) => {\n@@ -818,7 +818,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             return None;\n         }\n \n-        let mut highlight = RegionHighlightMode::default();\n+        let mut highlight = RegionHighlightMode::new(tcx);\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n         let type_name =\n             self.infcx.extract_inference_diagnostics_data(yield_ty.into(), Some(highlight)).name;"}, {"sha": "a16bdf286738c8929ee77c5761327b3142214bf9", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::mir::{\n     BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n     Promoted,\n };\n-use rustc_middle::ty::{self, OpaqueTypeKey, RegionKind, RegionVid, Ty};\n+use rustc_middle::ty::{self, OpaqueTypeKey, Region, RegionVid, Ty};\n use rustc_span::symbol::sym;\n use std::env;\n use std::fmt::Debug;\n@@ -443,9 +443,9 @@ pub trait ToRegionVid {\n     fn to_region_vid(self) -> RegionVid;\n }\n \n-impl<'tcx> ToRegionVid for &'tcx RegionKind {\n+impl<'tcx> ToRegionVid for Region<'tcx> {\n     fn to_region_vid(self) -> RegionVid {\n-        if let ty::ReVar(vid) = self { *vid } else { bug!(\"region is not an ReVar: {:?}\", self) }\n+        if let ty::ReVar(vid) = *self { vid } else { bug!(\"region is not an ReVar: {:?}\", self) }\n     }\n }\n "}, {"sha": "dee47a3e4408f9ab13cf94a71174a7ab32895823", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -1169,7 +1169,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         match verify_bound {\n             VerifyBound::IfEq(test_ty, verify_bound1) => {\n-                self.eval_if_eq(tcx, body, generic_ty, lower_bound, test_ty, verify_bound1)\n+                self.eval_if_eq(tcx, body, generic_ty, lower_bound, *test_ty, verify_bound1)\n             }\n \n             VerifyBound::IsEmpty => {\n@@ -1178,7 +1178,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n \n             VerifyBound::OutlivedBy(r) => {\n-                let r_vid = self.to_region_vid(r);\n+                let r_vid = self.to_region_vid(*r);\n                 self.eval_outlives(r_vid, lower_bound)\n             }\n "}, {"sha": "60c48d8a7648ec65dc29b9bc9c521bb28fac327a", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -133,7 +133,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         for vid in self.rev_scc_graph.as_ref().unwrap().upper_bounds(scc) {\n                             match self.definitions[vid].external_name {\n                                 None => {}\n-                                Some(&ty::ReStatic) => {}\n+                                Some(region) if region.is_static() => {}\n                                 Some(region) => return region,\n                             }\n                         }\n@@ -183,7 +183,7 @@ fn check_opaque_type_parameter_valid(\n     for (i, arg) in opaque_type_key.substs.iter().enumerate() {\n         let arg_is_param = match arg.unpack() {\n             GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n-            GenericArgKind::Lifetime(ty::ReStatic) => {\n+            GenericArgKind::Lifetime(lt) if lt.is_static() => {\n                 tcx.sess\n                     .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n                     .span_label(\n@@ -196,9 +196,9 @@ fn check_opaque_type_parameter_valid(\n                 return false;\n             }\n             GenericArgKind::Lifetime(lt) => {\n-                matches!(lt, ty::ReEarlyBound(_) | ty::ReFree(_))\n+                matches!(*lt, ty::ReEarlyBound(_) | ty::ReFree(_))\n             }\n-            GenericArgKind::Const(ct) => matches!(ct.val, ty::ConstKind::Param(_)),\n+            GenericArgKind::Const(ct) => matches!(ct.val(), ty::ConstKind::Param(_)),\n         };\n \n         if arg_is_param {"}, {"sha": "2876d60527fe7714feacb811f933b9321f7ea16f", "filename": "compiler/rustc_borrowck/src/renumber.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -57,7 +57,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NllVisitor<'a, 'tcx> {\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, ty_context: TyContext) {\n-        *ty = self.renumber_regions(ty);\n+        *ty = self.renumber_regions(*ty);\n \n         debug!(?ty);\n     }\n@@ -72,12 +72,12 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NllVisitor<'a, 'tcx> {\n     #[instrument(skip(self), level = \"debug\")]\n     fn visit_region(&mut self, region: &mut ty::Region<'tcx>, location: Location) {\n         let old_region = *region;\n-        *region = self.renumber_regions(&old_region);\n+        *region = self.renumber_regions(old_region);\n \n         debug!(?region);\n     }\n \n-    fn visit_const(&mut self, constant: &mut &'tcx ty::Const<'tcx>, _location: Location) {\n-        *constant = self.renumber_regions(&*constant);\n+    fn visit_const(&mut self, constant: &mut ty::Const<'tcx>, _location: Location) {\n+        *constant = self.renumber_regions(*constant);\n     }\n }"}, {"sha": "5022cb98b821d0786565e1a81cbc76e60d0f6396", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -105,8 +105,8 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n                 // create new region variables, which can't be done later when\n                 // verifying these bounds.\n                 if t1.has_placeholders() {\n-                    t1 = tcx.fold_regions(&t1, &mut false, |r, _| match *r {\n-                        ty::RegionKind::RePlaceholder(placeholder) => {\n+                    t1 = tcx.fold_regions(t1, &mut false, |r, _| match *r {\n+                        ty::RePlaceholder(placeholder) => {\n                             self.constraints.placeholder_region(self.infcx, placeholder)\n                         }\n                         _ => r,\n@@ -142,8 +142,8 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n     }\n \n     fn to_region_vid(&mut self, r: ty::Region<'tcx>) -> ty::RegionVid {\n-        if let ty::RePlaceholder(placeholder) = r {\n-            self.constraints.placeholder_region(self.infcx, *placeholder).to_region_vid()\n+        if let ty::RePlaceholder(placeholder) = *r {\n+            self.constraints.placeholder_region(self.infcx, placeholder).to_region_vid()\n         } else {\n             self.universal_regions.to_region_vid(r)\n         }"}, {"sha": "9a028147a4b60a2db2648e3fb91e223bc26d4bbb", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -358,7 +358,7 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                     // `where Type:` is lowered to `where Type: 'empty` so that\n                     // we check `Type` is well formed, but there's no use for\n                     // this bound here.\n-                    if let ty::ReEmpty(_) = r1 {\n+                    if r1.is_empty() {\n                         return;\n                     }\n "}, {"sha": "46924f50d2e1ba50f7696db2796d1082e45896ee", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -383,7 +383,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n         } else {\n             let tcx = self.tcx();\n             let maybe_uneval = match constant.literal {\n-                ConstantKind::Ty(ct) => match ct.val {\n+                ConstantKind::Ty(ct) => match ct.val() {\n                     ty::ConstKind::Unevaluated(uv) => Some(uv),\n                     _ => None,\n                 },\n@@ -482,7 +482,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                     // then remove the outermost reference so we can check the\n                     // type annotation for the remaining type.\n                     if let ty::Ref(_, rty, _) = local_decl.ty.kind() {\n-                        rty\n+                        *rty\n                     } else {\n                         bug!(\"{:?} with ref binding has wrong type {}\", local, local_decl.ty);\n                     }\n@@ -716,7 +716,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 PlaceTy::from_ty(match base_ty.kind() {\n                     ty::Array(inner, _) => {\n                         assert!(!from_end, \"array subslices should not use from_end\");\n-                        tcx.mk_array(inner, to - from)\n+                        tcx.mk_array(*inner, to - from)\n                     }\n                     ty::Slice(..) => {\n                         assert!(from_end, \"slice subslices should use from_end\");\n@@ -1737,7 +1737,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 ConstraintCategory::Boring\n             };\n             if let Err(terr) =\n-                self.sub_types(op_arg_ty, fn_arg, term_location.to_locations(), category)\n+                self.sub_types(op_arg_ty, *fn_arg, term_location.to_locations(), category)\n             {\n                 span_mirbug!(\n                     self,\n@@ -1956,7 +1956,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn check_operand(&mut self, op: &Operand<'tcx>, location: Location) {\n         if let Operand::Constant(constant) = op {\n             let maybe_uneval = match constant.literal {\n-                ConstantKind::Ty(ct) => match ct.val {\n+                ConstantKind::Ty(ct) => match ct.val() {\n                     ty::ConstKind::Unevaluated(uv) => Some(uv),\n                     _ => None,\n                 },\n@@ -2048,7 +2048,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n             }\n \n-            Rvalue::NullaryOp(_, ty) => {\n+            &Rvalue::NullaryOp(_, ty) => {\n                 let trait_ref = ty::TraitRef {\n                     def_id: tcx.require_lang_item(LangItem::Sized, Some(self.last_span)),\n                     substs: tcx.mk_substs_trait(ty, &[]),\n@@ -2066,7 +2066,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n                 let trait_ref = ty::TraitRef {\n                     def_id: tcx.require_lang_item(LangItem::Sized, Some(self.last_span)),\n-                    substs: tcx.mk_substs_trait(ty, &[]),\n+                    substs: tcx.mk_substs_trait(*ty, &[]),\n                 };\n \n                 self.prove_trait_ref(\n@@ -2093,7 +2093,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let ty_fn_ptr_from = tcx.mk_fn_ptr(fn_sig);\n \n                         if let Err(terr) = self.eq_types(\n-                            ty,\n+                            *ty,\n                             ty_fn_ptr_from,\n                             location.to_locations(),\n                             ConstraintCategory::Cast,\n@@ -2117,7 +2117,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let ty_fn_ptr_from = tcx.mk_fn_ptr(tcx.signature_unclosure(sig, *unsafety));\n \n                         if let Err(terr) = self.eq_types(\n-                            ty,\n+                            *ty,\n                             ty_fn_ptr_from,\n                             location.to_locations(),\n                             ConstraintCategory::Cast,\n@@ -2146,7 +2146,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let ty_fn_ptr_from = tcx.safe_to_unsafe_fn_ty(fn_sig);\n \n                         if let Err(terr) = self.eq_types(\n-                            ty,\n+                            *ty,\n                             ty_fn_ptr_from,\n                             location.to_locations(),\n                             ConstraintCategory::Cast,\n@@ -2209,8 +2209,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             }\n                         };\n                         if let Err(terr) = self.sub_types(\n-                            ty_from,\n-                            ty_to,\n+                            *ty_from,\n+                            *ty_to,\n                             location.to_locations(),\n                             ConstraintCategory::Cast,\n                         ) {\n@@ -2278,8 +2278,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         }\n \n                         if let Err(terr) = self.sub_types(\n-                            ty_elem,\n-                            ty_to,\n+                            *ty_elem,\n+                            *ty_to,\n                             location.to_locations(),\n                             ConstraintCategory::Cast,\n                         ) {\n@@ -2297,7 +2297,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     CastKind::Misc => {\n                         let ty_from = op.ty(body, tcx);\n                         let cast_ty_from = CastTy::from_ty(ty_from);\n-                        let cast_ty_to = CastTy::from_ty(ty);\n+                        let cast_ty_to = CastTy::from_ty(*ty);\n                         match (cast_ty_from, cast_ty_to) {\n                             (None, _)\n                             | (_, None | Some(CastTy::FnPtr))\n@@ -2318,7 +2318,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n \n             Rvalue::Ref(region, _borrow_kind, borrowed_place) => {\n-                self.add_reborrow_constraint(&body, location, region, borrowed_place);\n+                self.add_reborrow_constraint(&body, location, *region, borrowed_place);\n             }\n \n             Rvalue::BinaryOp("}, {"sha": "590a7a91641557700b77108b9c4189230c43bf99", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -117,7 +117,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n \n     // We don't have to worry about the equality of consts during borrow checking\n     // as consts always have a static lifetime.\n-    fn const_equate(&mut self, _a: &'tcx Const<'tcx>, _b: &'tcx Const<'tcx>) {}\n+    fn const_equate(&mut self, _a: Const<'tcx>, _b: Const<'tcx>) {}\n \n     fn normalization() -> NormalizationStrategy {\n         NormalizationStrategy::Eager"}, {"sha": "72de3805467dc87baa4ea24eb8cee2615fef3a31", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -323,7 +323,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n \n     /// See `UniversalRegionIndices::to_region_vid`.\n     pub fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid {\n-        if let ty::ReEmpty(ty::UniverseIndex::ROOT) = r {\n+        if let ty::ReEmpty(ty::UniverseIndex::ROOT) = *r {\n             self.root_empty\n         } else {\n             self.indices.to_region_vid(r)\n@@ -512,7 +512,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             first_local_index,\n             num_universals,\n             defining_ty,\n-            unnormalized_output_ty,\n+            unnormalized_output_ty: *unnormalized_output_ty,\n             unnormalized_input_tys,\n             yield_ty,\n         }\n@@ -805,7 +805,7 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n     /// during initialization. Relies on the `indices` map having been\n     /// fully initialized.\n     pub fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid {\n-        if let ty::ReVar(..) = r {\n+        if let ty::ReVar(..) = *r {\n             r.to_region_vid()\n         } else {\n             *self"}, {"sha": "a0550860fa54531be5476ad9298b7333f4edfa72", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -544,7 +544,7 @@ pub(crate) fn codegen_drop<'tcx>(\n                 let arg_value = drop_place.place_ref(\n                     fx,\n                     fx.layout_of(fx.tcx.mk_ref(\n-                        &ty::RegionKind::ReErased,\n+                        fx.tcx.lifetimes.re_erased,\n                         TypeAndMut { ty, mutbl: crate::rustc_hir::Mutability::Mut },\n                     )),\n                 );"}, {"sha": "917afa4eae06cbb91fe44f4fca3f7958c765abde", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -79,7 +79,7 @@ pub(crate) fn codegen_fn<'tcx>(\n     let arg_uninhabited = fx\n         .mir\n         .args_iter()\n-        .any(|arg| fx.layout_of(fx.monomorphize(&fx.mir.local_decls[arg].ty)).abi.is_uninhabited());\n+        .any(|arg| fx.layout_of(fx.monomorphize(fx.mir.local_decls[arg].ty)).abi.is_uninhabited());\n \n     if !crate::constant::check_constants(&mut fx) {\n         fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n@@ -668,7 +668,7 @@ fn codegen_stmt<'tcx>(\n                     let times = fx\n                         .monomorphize(times)\n                         .eval(fx.tcx, ParamEnv::reveal_all())\n-                        .val\n+                        .val()\n                         .try_to_bits(fx.tcx.data_layout.pointer_size)\n                         .unwrap();\n                     if operand.layout().size.bytes() == 0 {\n@@ -818,16 +818,16 @@ pub(crate) fn codegen_place<'tcx>(\n                 match cplace.layout().ty.kind() {\n                     ty::Array(elem_ty, _len) => {\n                         assert!(!from_end, \"array subslices are never `from_end`\");\n-                        let elem_layout = fx.layout_of(elem_ty);\n+                        let elem_layout = fx.layout_of(*elem_ty);\n                         let ptr = cplace.to_ptr();\n                         cplace = CPlace::for_ptr(\n                             ptr.offset_i64(fx, elem_layout.size.bytes() as i64 * (from as i64)),\n-                            fx.layout_of(fx.tcx.mk_array(elem_ty, to - from)),\n+                            fx.layout_of(fx.tcx.mk_array(*elem_ty, to - from)),\n                         );\n                     }\n                     ty::Slice(elem_ty) => {\n                         assert!(from_end, \"slice subslices should be `from_end`\");\n-                        let elem_layout = fx.layout_of(elem_ty);\n+                        let elem_layout = fx.layout_of(*elem_ty);\n                         let (ptr, len) = cplace.to_ptr_maybe_unsized();\n                         let len = len.unwrap();\n                         cplace = CPlace::for_ptr_with_extra("}, {"sha": "50f98965ab5d22ac31f735a56e18385e87bd2f69", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -61,7 +61,7 @@ fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Typ\n         },\n         ty::FnPtr(_) => pointer_ty(tcx),\n         ty::RawPtr(TypeAndMut { ty: pointee_ty, mutbl: _ }) | ty::Ref(_, pointee_ty, _) => {\n-            if has_ptr_meta(tcx, pointee_ty) {\n+            if has_ptr_meta(tcx, *pointee_ty) {\n                 return None;\n             } else {\n                 pointer_ty(tcx)\n@@ -100,7 +100,7 @@ fn clif_pair_type_from_ty<'tcx>(\n             (a, b)\n         }\n         ty::RawPtr(TypeAndMut { ty: pointee_ty, mutbl: _ }) | ty::Ref(_, pointee_ty, _) => {\n-            if has_ptr_meta(tcx, pointee_ty) {\n+            if has_ptr_meta(tcx, *pointee_ty) {\n                 (pointer_ty(tcx), pointer_ty(tcx))\n             } else {\n                 return None;"}, {"sha": "274fb211b7bbb5cd2ee8dff0b37267aec5fae605", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -46,7 +46,7 @@ pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, '_>) -> bool {\n             ConstantKind::Ty(ct) => ct,\n             ConstantKind::Val(..) => continue,\n         };\n-        match const_.val {\n+        match const_.val() {\n             ConstKind::Value(_) => {}\n             ConstKind::Unevaluated(unevaluated) => {\n                 if let Err(err) =\n@@ -127,15 +127,15 @@ pub(crate) fn codegen_constant<'tcx>(\n         ConstantKind::Ty(ct) => ct,\n         ConstantKind::Val(val, ty) => return codegen_const_value(fx, val, ty),\n     };\n-    let const_val = match const_.val {\n+    let const_val = match const_.val() {\n         ConstKind::Value(const_val) => const_val,\n         ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted })\n             if fx.tcx.is_static(def.did) =>\n         {\n             assert!(substs.is_empty());\n             assert!(promoted.is_none());\n \n-            return codegen_static_ref(fx, def.did, fx.layout_of(const_.ty)).to_cvalue(fx);\n+            return codegen_static_ref(fx, def.did, fx.layout_of(const_.ty())).to_cvalue(fx);\n         }\n         ConstKind::Unevaluated(unevaluated) => {\n             match fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), unevaluated, None) {\n@@ -152,7 +152,7 @@ pub(crate) fn codegen_constant<'tcx>(\n         | ConstKind::Error(_) => unreachable!(\"{:?}\", const_),\n     };\n \n-    codegen_const_value(fx, const_val, const_.ty)\n+    codegen_const_value(fx, const_val, const_.ty())\n }\n \n pub(crate) fn codegen_const_value<'tcx>(\n@@ -465,7 +465,7 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n     match operand {\n         Operand::Constant(const_) => match const_.literal {\n             ConstantKind::Ty(const_) => {\n-                fx.monomorphize(const_).eval(fx.tcx, ParamEnv::reveal_all()).val.try_to_value()\n+                fx.monomorphize(const_).eval(fx.tcx, ParamEnv::reveal_all()).val().try_to_value()\n             }\n             ConstantKind::Val(val, _) => Some(val),\n         },\n@@ -490,7 +490,7 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n                                         return None;\n                                     }\n                                     let const_val = mir_operand_get_const_val(fx, operand)?;\n-                                    if fx.layout_of(ty).size\n+                                    if fx.layout_of(*ty).size\n                                         != const_val.try_to_scalar_int()?.size()\n                                     {\n                                         return None;"}, {"sha": "693092ba543ea947c5b448520fac7984935e697c", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -114,7 +114,7 @@ impl<'tcx> DebugContext<'tcx> {\n     }\n \n     fn dwarf_ty(&mut self, ty: Ty<'tcx>) -> UnitEntryId {\n-        if let Some(type_id) = self.types.get(ty) {\n+        if let Some(type_id) = self.types.get(&ty) {\n             return *type_id;\n         }\n \n@@ -143,7 +143,7 @@ impl<'tcx> DebugContext<'tcx> {\n                 // Ensure that type is inserted before recursing to avoid duplicates\n                 self.types.insert(ty, type_id);\n \n-                let pointee = self.dwarf_ty(pointee_ty);\n+                let pointee = self.dwarf_ty(*pointee_ty);\n \n                 let type_entry = self.dwarf.unit.get_mut(type_id);\n "}, {"sha": "8cae506e0cb62362eb56b626d02814f3d69395b2", "filename": "compiler/rustc_codegen_cranelift/src/unsize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -66,7 +66,7 @@ fn unsize_ptr<'tcx>(\n         (&ty::Ref(_, a, _), &ty::Ref(_, b, _))\n         | (&ty::Ref(_, a, _), &ty::RawPtr(ty::TypeAndMut { ty: b, .. }))\n         | (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }), &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n-            (src, unsized_info(fx, a, b, old_info))\n+            (src, unsized_info(fx, *a, *b, old_info))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             let (a, b) = (src_layout.ty.boxed_ty(), dst_layout.ty.boxed_ty());"}, {"sha": "b016af5174e018630eddbb3b1ef5ae9bac8398ab", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -514,7 +514,7 @@ impl<'tcx> CPlace<'tcx> {\n                     // Can only happen for vector types\n                     let len =\n                         u16::try_from(len.eval_usize(fx.tcx, ParamEnv::reveal_all())).unwrap();\n-                    let vector_ty = fx.clif_type(element).unwrap().by(len).unwrap();\n+                    let vector_ty = fx.clif_type(*element).unwrap().by(len).unwrap();\n \n                     let data = match from.0 {\n                         CValueInner::ByRef(ptr, None) => {\n@@ -721,8 +721,8 @@ impl<'tcx> CPlace<'tcx> {\n         index: Value,\n     ) -> CPlace<'tcx> {\n         let (elem_layout, ptr) = match self.layout().ty.kind() {\n-            ty::Array(elem_ty, _) => (fx.layout_of(elem_ty), self.to_ptr()),\n-            ty::Slice(elem_ty) => (fx.layout_of(elem_ty), self.to_ptr_maybe_unsized().0),\n+            ty::Array(elem_ty, _) => (fx.layout_of(*elem_ty), self.to_ptr()),\n+            ty::Slice(elem_ty) => (fx.layout_of(*elem_ty), self.to_ptr_maybe_unsized().0),\n             _ => bug!(\"place_index({:?})\", self.layout().ty),\n         };\n \n@@ -781,11 +781,11 @@ pub(crate) fn assert_assignable<'tcx>(\n             ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }),\n             ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }),\n         ) => {\n-            assert_assignable(fx, a, b);\n+            assert_assignable(fx, *a, *b);\n         }\n         (ty::Ref(_, a, _), ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }))\n         | (ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }), ty::Ref(_, b, _)) => {\n-            assert_assignable(fx, a, b);\n+            assert_assignable(fx, *a, *b);\n         }\n         (ty::FnPtr(_), ty::FnPtr(_)) => {\n             let from_sig = fx.tcx.normalize_erasing_late_bound_regions("}, {"sha": "1abc3fb523d1bce25955f2790d6df5a1961f2a6d", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -185,9 +185,9 @@ impl<'ll, 'tcx> TypeMap<'ll, 'tcx> {\n     ///\n     /// This function is used to remove the temporary metadata\n     /// mapping after we've computed the actual metadata.\n-    fn remove_type(&mut self, type_: Ty<'tcx>) {\n-        if self.type_to_metadata.remove(type_).is_none() {\n-            bug!(\"type metadata `Ty` '{}' is not in the `TypeMap`!\", type_);\n+    fn remove_type(&mut self, ty: Ty<'tcx>) {\n+        if self.type_to_metadata.remove(&ty).is_none() {\n+            bug!(\"type metadata `Ty` '{}' is not in the `TypeMap`!\", ty);\n         }\n     }\n \n@@ -397,7 +397,7 @@ fn fixed_size_array_metadata<'ll, 'tcx>(\n         bug!(\"fixed_size_array_metadata() called with non-ty::Array type `{:?}`\", array_type)\n     };\n \n-    let element_type_metadata = type_metadata(cx, element_type);\n+    let element_type_metadata = type_metadata(cx, *element_type);\n \n     return_if_metadata_created_in_meantime!(cx, unique_type_id);\n \n@@ -546,7 +546,7 @@ fn subroutine_type_metadata<'ll, 'tcx>(\n     )\n     .chain(\n         // regular arguments\n-        signature.inputs().iter().map(|argument_type| Some(type_metadata(cx, argument_type))),\n+        signature.inputs().iter().map(|&argument_type| Some(type_metadata(cx, argument_type))),\n     )\n     .collect();\n \n@@ -601,7 +601,7 @@ fn slice_type_metadata<'ll, 'tcx>(\n     unique_type_id: UniqueTypeId,\n ) -> MetadataCreationResult<'ll> {\n     let element_type = match slice_type.kind() {\n-        ty::Slice(element_type) => element_type,\n+        ty::Slice(element_type) => *element_type,\n         ty::Str => cx.tcx.types.u8,\n         _ => {\n             bug!("}, {"sha": "247cb9ee6e8c9f2e475a4c70238b9f4bdd02437a", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -430,9 +430,9 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                     let t = arg.layout.ty;\n                     let t = match t.kind() {\n                         ty::Array(ct, _)\n-                            if (*ct == cx.tcx.types.u8) || cx.layout_of(ct).is_zst() =>\n+                            if (*ct == cx.tcx.types.u8) || cx.layout_of(*ct).is_zst() =>\n                         {\n-                            cx.tcx.mk_imm_ptr(ct)\n+                            cx.tcx.mk_imm_ptr(*ct)\n                         }\n                         _ => t,\n                     };"}, {"sha": "cfd23f5c24e05a817234a0463d4073bdf1b041af", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -1132,8 +1132,8 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n \n     fn simd_simple_float_intrinsic<'ll, 'tcx>(\n         name: Symbol,\n-        in_elem: &::rustc_middle::ty::TyS<'_>,\n-        in_ty: &::rustc_middle::ty::TyS<'_>,\n+        in_elem: Ty<'_>,\n+        in_ty: Ty<'_>,\n         in_len: u64,\n         bx: &mut Builder<'_, 'll, 'tcx>,\n         span: Span,"}, {"sha": "b63851c195de6df091bed7ed0d4627ee3bb736ac", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -146,15 +146,15 @@ fn push_debuginfo_type_name<'tcx>(\n             if cpp_like_debuginfo {\n                 output.push_str(\"array$<\");\n                 push_debuginfo_type_name(tcx, inner_type, true, output, visited);\n-                match len.val {\n+                match len.val() {\n                     ty::ConstKind::Param(param) => write!(output, \",{}>\", param.name).unwrap(),\n                     _ => write!(output, \",{}>\", len.eval_usize(tcx, ty::ParamEnv::reveal_all()))\n                         .unwrap(),\n                 }\n             } else {\n                 output.push('[');\n                 push_debuginfo_type_name(tcx, inner_type, true, output, visited);\n-                match len.val {\n+                match len.val() {\n                     ty::ConstKind::Param(param) => write!(output, \"; {}]\", param.name).unwrap(),\n                     _ => write!(output, \"; {}]\", len.eval_usize(tcx, ty::ParamEnv::reveal_all()))\n                         .unwrap(),\n@@ -343,7 +343,7 @@ fn push_debuginfo_type_name<'tcx>(\n             // We only care about avoiding recursing\n             // directly back to the type we're currently\n             // processing\n-            visited.remove(t);\n+            visited.remove(&t);\n         }\n         ty::Closure(def_id, substs) | ty::Generator(def_id, substs, ..) => {\n             // Name will be \"{closure_env#0}<T1, T2, ...>\", \"{generator_env#0}<T1, T2, ...>\", or\n@@ -645,19 +645,19 @@ fn push_generic_params_internal<'tcx>(\n     true\n }\n \n-fn push_const_param<'tcx>(tcx: TyCtxt<'tcx>, ct: &'tcx ty::Const<'tcx>, output: &mut String) {\n-    match ct.val {\n+fn push_const_param<'tcx>(tcx: TyCtxt<'tcx>, ct: ty::Const<'tcx>, output: &mut String) {\n+    match ct.val() {\n         ty::ConstKind::Param(param) => {\n             write!(output, \"{}\", param.name)\n         }\n-        _ => match ct.ty.kind() {\n+        _ => match ct.ty().kind() {\n             ty::Int(ity) => {\n-                let bits = ct.eval_bits(tcx, ty::ParamEnv::reveal_all(), ct.ty);\n+                let bits = ct.eval_bits(tcx, ty::ParamEnv::reveal_all(), ct.ty());\n                 let val = Integer::from_int_ty(&tcx, *ity).size().sign_extend(bits) as i128;\n                 write!(output, \"{}\", val)\n             }\n             ty::Uint(_) => {\n-                let val = ct.eval_bits(tcx, ty::ParamEnv::reveal_all(), ct.ty);\n+                let val = ct.eval_bits(tcx, ty::ParamEnv::reveal_all(), ct.ty());\n                 write!(output, \"{}\", val)\n             }\n             ty::Bool => {\n@@ -672,7 +672,7 @@ fn push_const_param<'tcx>(tcx: TyCtxt<'tcx>, ct: &'tcx ty::Const<'tcx>, output:\n                 let mut hasher = StableHasher::new();\n                 hcx.while_hashing_spans(false, |hcx| {\n                     hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-                        ct.val.hash_stable(hcx, &mut hasher);\n+                        ct.val().hash_stable(hcx, &mut hasher);\n                     });\n                 });\n                 // Let's only emit 64 bits of the hash value. That should be plenty for"}, {"sha": "5cdf131b0b633d5d211807479befb4e09c1ab505", "filename": "compiler/rustc_codegen_ssa/src/mir/constant.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -29,7 +29,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::ConstantKind::Ty(ct) => ct,\n             mir::ConstantKind::Val(val, _) => return Ok(val),\n         };\n-        match ct.val {\n+        match ct.val() {\n             ty::ConstKind::Unevaluated(ct) => self\n                 .cx\n                 .tcx()\n@@ -61,11 +61,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let c = ty::Const::from_value(bx.tcx(), val, ty);\n                 let values: Vec<_> = bx\n                     .tcx()\n-                    .destructure_const(ty::ParamEnv::reveal_all().and(&c))\n+                    .destructure_const(ty::ParamEnv::reveal_all().and(c))\n                     .fields\n                     .iter()\n                     .map(|field| {\n-                        if let Some(prim) = field.val.try_to_scalar() {\n+                        if let Some(prim) = field.val().try_to_scalar() {\n                             let layout = bx.layout_of(field_ty);\n                             let scalar = match layout.abi {\n                                 Abi::Scalar(x) => x,\n@@ -78,7 +78,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     })\n                     .collect();\n                 let llval = bx.const_struct(&values, false);\n-                (llval, c.ty)\n+                (llval, c.ty())\n             })\n             .unwrap_or_else(|_| {\n                 bx.tcx().sess.span_err(span, \"could not evaluate shuffle_indices at compile time\");"}, {"sha": "eaa333fd8a9657f6ce8a3d4b6676ca3f1e84f640", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -139,14 +139,14 @@ fn const_to_valtree_inner<'tcx>(\n pub(crate) fn destructure_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    val: &'tcx ty::Const<'tcx>,\n+    val: ty::Const<'tcx>,\n ) -> mir::DestructuredConst<'tcx> {\n     trace!(\"destructure_const: {:?}\", val);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n     let op = ecx.const_to_op(val, None).unwrap();\n \n     // We go to `usize` as we cannot allocate anything bigger anyway.\n-    let (field_count, variant, down) = match val.ty.kind() {\n+    let (field_count, variant, down) = match val.ty().kind() {\n         ty::Array(_, len) => (usize::try_from(len.eval_usize(tcx, param_env)).unwrap(), None, op),\n         ty::Adt(def, _) if def.variants.is_empty() => {\n             return mir::DestructuredConst { variant: None, fields: &[] };\n@@ -173,8 +173,8 @@ pub(crate) fn destructure_const<'tcx>(\n pub(crate) fn deref_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    val: &'tcx ty::Const<'tcx>,\n-) -> &'tcx ty::Const<'tcx> {\n+    val: ty::Const<'tcx>,\n+) -> ty::Const<'tcx> {\n     trace!(\"deref_const: {:?}\", val);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n     let op = ecx.const_to_op(val, None).unwrap();\n@@ -194,7 +194,7 @@ pub(crate) fn deref_const<'tcx>(\n         // In case of unsized types, figure out the real type behind.\n         MemPlaceMeta::Meta(scalar) => match mplace.layout.ty.kind() {\n             ty::Str => bug!(\"there's no sized equivalent of a `str`\"),\n-            ty::Slice(elem_ty) => tcx.mk_array(elem_ty, scalar.to_machine_usize(&tcx).unwrap()),\n+            ty::Slice(elem_ty) => tcx.mk_array(*elem_ty, scalar.to_machine_usize(&tcx).unwrap()),\n             _ => bug!(\n                 \"type {} should not have metadata, but had {:?}\",\n                 mplace.layout.ty,\n@@ -203,5 +203,5 @@ pub(crate) fn deref_const<'tcx>(\n         },\n     };\n \n-    tcx.mk_const(ty::Const { val: ty::ConstKind::Value(op_to_const(&ecx, &mplace.into())), ty })\n+    tcx.mk_const(ty::ConstS { val: ty::ConstKind::Value(op_to_const(&ecx, &mplace.into())), ty })\n }"}, {"sha": "e2c4eb1dadc83facbfe202c929681901e4ad2ced", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -315,7 +315,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match (&src.layout.ty.kind(), &cast_ty.ty.kind()) {\n             (&ty::Ref(_, s, _), &ty::Ref(_, c, _) | &ty::RawPtr(TypeAndMut { ty: c, .. }))\n             | (&ty::RawPtr(TypeAndMut { ty: s, .. }), &ty::RawPtr(TypeAndMut { ty: c, .. })) => {\n-                self.unsize_into_ptr(src, dest, s, c)\n+                self.unsize_into_ptr(src, dest, *s, *c)\n             }\n             (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n                 assert_eq!(def_a, def_b);"}, {"sha": "e6f243e28dbc5c7a45a524b3ae66b141a559ada0", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -68,7 +68,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n         }\n     }\n \n-    fn print_const(self, ct: &'tcx ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n+    fn print_const(self, ct: ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n         self.pretty_print_const(ct, false)\n     }\n "}, {"sha": "ec5eafcd6331821b2312d00eab57cde8bd4ee065", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -561,10 +561,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// \"universe\" (param_env).\n     pub fn const_to_op(\n         &self,\n-        val: &ty::Const<'tcx>,\n+        val: ty::Const<'tcx>,\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        match val.val {\n+        match val.val() {\n             ty::ConstKind::Param(_) | ty::ConstKind::Bound(..) => throw_inval!(TooGeneric),\n             ty::ConstKind::Error(_) => throw_inval!(AlreadyReported(ErrorReported)),\n             ty::ConstKind::Unevaluated(uv) => {\n@@ -574,7 +574,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ty::ConstKind::Infer(..) | ty::ConstKind::Placeholder(..) => {\n                 span_bug!(self.cur_span(), \"const_to_op: Unexpected ConstKind {:?}\", val)\n             }\n-            ty::ConstKind::Value(val_val) => self.const_val_to_op(val_val, val.ty, layout),\n+            ty::ConstKind::Value(val_val) => self.const_val_to_op(val_val, val.ty(), layout),\n         }\n     }\n \n@@ -584,8 +584,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         match val {\n-            mir::ConstantKind::Ty(ct) => self.const_to_op(ct, layout),\n-            mir::ConstantKind::Val(val, ty) => self.const_val_to_op(*val, ty, layout),\n+            mir::ConstantKind::Ty(ct) => self.const_to_op(*ct, layout),\n+            mir::ConstantKind::Val(val, ty) => self.const_val_to_op(*val, *ty, layout),\n         }\n     }\n "}, {"sha": "7b06ffaf15d02f86f7917d36750cf663878805ef", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -462,7 +462,7 @@ where\n         let (meta, ty) = match base.layout.ty.kind() {\n             // It is not nice to match on the type, but that seems to be the only way to\n             // implement this.\n-            ty::Array(inner, _) => (MemPlaceMeta::None, self.tcx.mk_array(inner, inner_len)),\n+            ty::Array(inner, _) => (MemPlaceMeta::None, self.tcx.mk_array(*inner, inner_len)),\n             ty::Slice(..) => {\n                 let len = Scalar::from_machine_usize(inner_len, self);\n                 (MemPlaceMeta::Meta(len), base.layout.ty)"}, {"sha": "e17bd9a8c08993112f43ed8bd45c90d6a1106f09", "filename": "compiler/rustc_const_eval/src/interpret/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -55,7 +55,7 @@ where\n                                     assert!(matches!(ty.kind(), ty::Param(_)))\n                                 }\n                                 ty::subst::GenericArgKind::Const(ct) => {\n-                                    assert!(matches!(ct.val, ty::ConstKind::Param(_)))\n+                                    assert!(matches!(ct.val(), ty::ConstKind::Param(_)))\n                                 }\n                                 ty::subst::GenericArgKind::Lifetime(..) => (),\n                             },\n@@ -68,8 +68,8 @@ where\n             }\n         }\n \n-        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            match c.val {\n+        fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            match c.val() {\n                 ty::ConstKind::Param(..) => ControlFlow::Break(FoundParam),\n                 _ => c.super_visit_with(self),\n             }"}, {"sha": "4060bee7e056c1c61554069927610d644a52521e", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -553,7 +553,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 {\n                     // A mutable reference inside a const? That does not seem right (except if it is\n                     // a ZST).\n-                    let layout = self.ecx.layout_of(ty)?;\n+                    let layout = self.ecx.layout_of(*ty)?;\n                     if !layout.is_zst() {\n                         throw_validation_failure!(self.path, { \"mutable reference in a `const`\" });\n                     }\n@@ -837,7 +837,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // This is the length of the array/slice.\n                 let len = mplace.len(self.ecx)?;\n                 // This is the element type size.\n-                let layout = self.ecx.layout_of(tys)?;\n+                let layout = self.ecx.layout_of(*tys)?;\n                 // This is the size in bytes of the whole array. (This checks for overflow.)\n                 let size = layout.size * len;\n \n@@ -896,7 +896,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n             // Fast path for arrays and slices of ZSTs. We only need to check a single ZST element\n             // of an array and not all of them, because there's only a single value of a specific\n             // ZST type, so either validation fails for all elements or none.\n-            ty::Array(tys, ..) | ty::Slice(tys) if self.ecx.layout_of(tys)?.is_zst() => {\n+            ty::Array(tys, ..) | ty::Slice(tys) if self.ecx.layout_of(*tys)?.is_zst() => {\n                 // Validate just the first element (if any).\n                 self.walk_aggregate(op, fields.take(1))?\n             }"}, {"sha": "8c3f8e8816464d156eddd3235cd4f119fb365f36", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -233,7 +233,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                             let mut tmp_ty = self_ty;\n                             while let rustc_middle::ty::Ref(_, inner_ty, _) = tmp_ty.kind() {\n                                 num_refs += 1;\n-                                tmp_ty = inner_ty;\n+                                tmp_ty = *inner_ty;\n                             }\n                             let deref = \"*\".repeat(num_refs);\n "}, {"sha": "639b798be5431abad80e703acf5702b10d402d52", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -355,7 +355,7 @@ where\n \n     // Check the qualifs of the value of `const` items.\n     if let Some(ct) = constant.literal.const_for_ty() {\n-        if let ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs: _, promoted }) = ct.val {\n+        if let ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs: _, promoted }) = ct.val() {\n             // Use qualifs of the type for the promoted. Promoteds in MIR body should be possible\n             // only for `NeedsNonConstDrop` with precise drop checking. This is the only const\n             // check performed after the promotion. Verify that with an assertion."}, {"sha": "cacc0018fe93772bacd6e28caf08ece6bfb74a22", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -496,7 +496,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 if matches!(kind, CastKind::Misc) {\n                     let operand_ty = operand.ty(self.body, self.tcx);\n                     let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n-                    let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+                    let cast_out = CastTy::from_ty(*cast_ty).expect(\"bad output type for cast\");\n                     if let (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) = (cast_in, cast_out) {\n                         // ptr-to-int casts are not possible in consts and thus not promotable\n                         return Err(Unpromotable);\n@@ -839,7 +839,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                     span,\n                     user_ty: None,\n                     literal: tcx\n-                        .mk_const(ty::Const {\n+                        .mk_const(ty::ConstS {\n                             ty,\n                             val: ty::ConstKind::Unevaluated(ty::Unevaluated {\n                                 def,"}, {"sha": "c79a5ebf0933bbfba4b73418256b1964f5fb6302", "filename": "compiler/rustc_data_structures/src/intern.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -0,0 +1,98 @@\n+use std::cmp::Ordering;\n+use std::hash::{Hash, Hasher};\n+use std::ops::Deref;\n+use std::ptr;\n+\n+mod private {\n+    #[derive(Clone, Copy, Debug)]\n+    pub struct PrivateZst;\n+}\n+\n+/// A reference to a value that is interned, and is known to be unique.\n+///\n+/// Note that it is possible to have a `T` and a `Interned<T>` that are (or\n+/// refer to) equal but different values. But if you have two different\n+/// `Interned<T>`s, they both refer to the same value, at a single location in\n+/// memory. This means that equality and hashing can be done on the value's\n+/// address rather than the value's contents, which can improve performance.\n+///\n+/// The `PrivateZst` field means you can pattern match with `Interned(v, _)`\n+/// but you can only construct a `Interned` with `new_unchecked`, and not\n+/// directly.\n+#[derive(Debug)]\n+#[cfg_attr(not(bootstrap), rustc_pass_by_value)]\n+pub struct Interned<'a, T>(pub &'a T, pub private::PrivateZst);\n+\n+impl<'a, T> Interned<'a, T> {\n+    /// Create a new `Interned` value. The value referred to *must* be interned\n+    /// and thus be unique, and it *must* remain unique in the future. This\n+    /// function has `_unchecked` in the name but is not `unsafe`, because if\n+    /// the uniqueness condition is violated condition it will cause incorrect\n+    /// behaviour but will not affect memory safety.\n+    #[inline]\n+    pub const fn new_unchecked(t: &'a T) -> Self {\n+        Interned(t, private::PrivateZst)\n+    }\n+}\n+\n+impl<'a, T> Clone for Interned<'a, T> {\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+impl<'a, T> Copy for Interned<'a, T> {}\n+\n+impl<'a, T> Deref for Interned<'a, T> {\n+    type Target = T;\n+\n+    #[inline]\n+    fn deref(&self) -> &T {\n+        self.0\n+    }\n+}\n+\n+impl<'a, T> PartialEq for Interned<'a, T> {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        // Pointer equality implies equality, due to the uniqueness constraint.\n+        ptr::eq(self.0, other.0)\n+    }\n+}\n+\n+impl<'a, T> Eq for Interned<'a, T> {}\n+\n+// In practice you can't intern any `T` that doesn't implement `Eq`, because\n+// that's needed for hashing. Therefore, we won't be interning any `T` that\n+// implements `PartialOrd` without also implementing `Ord`. So we can have the\n+// bound `T: Ord` here and avoid duplication with the `Ord` impl below.\n+impl<'a, T: Ord> PartialOrd for Interned<'a, T> {\n+    fn partial_cmp(&self, other: &Interned<'a, T>) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl<'a, T: Ord> Ord for Interned<'a, T> {\n+    fn cmp(&self, other: &Interned<'a, T>) -> Ordering {\n+        // Pointer equality implies equality, due to the uniqueness constraint,\n+        // but the contents must be compared otherwise.\n+        if ptr::eq(self.0, other.0) {\n+            Ordering::Equal\n+        } else {\n+            let res = self.0.cmp(&other.0);\n+            debug_assert_ne!(res, Ordering::Equal);\n+            res\n+        }\n+    }\n+}\n+\n+impl<'a, T> Hash for Interned<'a, T> {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        // Pointer hashing is sufficient, due to the uniqueness constraint.\n+        ptr::hash(self.0, s)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "09810a0850e4d9c1df1fa8947cef0a0fb70e849d", "filename": "compiler/rustc_data_structures/src/intern/tests.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_data_structures%2Fsrc%2Fintern%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_data_structures%2Fsrc%2Fintern%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fintern%2Ftests.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -0,0 +1,59 @@\n+use super::*;\n+use std::cmp::Ordering;\n+\n+#[derive(Debug)]\n+struct S(u32);\n+\n+impl PartialEq for S {\n+    fn eq(&self, _other: &Self) -> bool {\n+        panic!(\"shouldn't be called\");\n+    }\n+}\n+\n+impl Eq for S {}\n+\n+impl PartialOrd for S {\n+    fn partial_cmp(&self, other: &S) -> Option<Ordering> {\n+        // The `==` case should be handled by `Interned`.\n+        assert_ne!(self.0, other.0);\n+        self.0.partial_cmp(&other.0)\n+    }\n+}\n+\n+impl Ord for S {\n+    fn cmp(&self, other: &S) -> Ordering {\n+        // The `==` case should be handled by `Interned`.\n+        assert_ne!(self.0, other.0);\n+        self.0.cmp(&other.0)\n+    }\n+}\n+\n+#[test]\n+fn test_uniq() {\n+    let s1 = S(1);\n+    let s2 = S(2);\n+    let s3 = S(3);\n+    let s4 = S(1); // violates uniqueness\n+\n+    let v1 = Interned::new_unchecked(&s1);\n+    let v2 = Interned::new_unchecked(&s2);\n+    let v3a = Interned::new_unchecked(&s3);\n+    let v3b = Interned::new_unchecked(&s3);\n+    let v4 = Interned::new_unchecked(&s4); // violates uniqueness\n+\n+    assert_ne!(v1, v2);\n+    assert_ne!(v2, v3a);\n+    assert_eq!(v1, v1);\n+    assert_eq!(v3a, v3b);\n+    assert_ne!(v1, v4); // same content but different addresses: not equal\n+\n+    assert_eq!(v1.cmp(&v2), Ordering::Less);\n+    assert_eq!(v3a.cmp(&v2), Ordering::Greater);\n+    assert_eq!(v1.cmp(&v1), Ordering::Equal); // only uses Interned::eq, not S::cmp\n+    assert_eq!(v3a.cmp(&v3b), Ordering::Equal); // only uses Interned::eq, not S::cmp\n+\n+    assert_eq!(v1.partial_cmp(&v2), Some(Ordering::Less));\n+    assert_eq!(v3a.partial_cmp(&v2), Some(Ordering::Greater));\n+    assert_eq!(v1.partial_cmp(&v1), Some(Ordering::Equal)); // only uses Interned::eq, not S::cmp\n+    assert_eq!(v3a.partial_cmp(&v3b), Some(Ordering::Equal)); // only uses Interned::eq, not S::cmp\n+}"}, {"sha": "80f83140f4b41a557338b02662b6c71e6d92aee8", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -21,6 +21,7 @@\n #![feature(type_alias_impl_trait)]\n #![feature(new_uninit)]\n #![feature(once_cell)]\n+#![feature(rustc_attrs)]\n #![feature(test)]\n #![feature(thread_id_value)]\n #![feature(vec_into_raw_parts)]\n@@ -68,12 +69,12 @@ pub mod flock;\n pub mod functor;\n pub mod fx;\n pub mod graph;\n+pub mod intern;\n pub mod jobserver;\n pub mod macros;\n pub mod map_in_place;\n pub mod obligation_forest;\n pub mod owning_ref;\n-pub mod ptr_key;\n pub mod sip128;\n pub mod small_c_str;\n pub mod snapshot_map;"}, {"sha": "440ccb05d86e4a577d5b0619b089ac487fe6a753", "filename": "compiler/rustc_data_structures/src/ptr_key.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6421a499a50adbaa7b5d0234bdd4817d970f0933/compiler%2Frustc_data_structures%2Fsrc%2Fptr_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6421a499a50adbaa7b5d0234bdd4817d970f0933/compiler%2Frustc_data_structures%2Fsrc%2Fptr_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fptr_key.rs?ref=6421a499a50adbaa7b5d0234bdd4817d970f0933", "patch": "@@ -1,37 +0,0 @@\n-use std::ops::Deref;\n-use std::{hash, ptr};\n-\n-/// A wrapper around reference that compares and hashes like a pointer.\n-/// Can be used as a key in sets/maps indexed by pointers to avoid `unsafe`.\n-#[derive(Debug)]\n-pub struct PtrKey<'a, T>(pub &'a T);\n-\n-impl<'a, T> Clone for PtrKey<'a, T> {\n-    fn clone(&self) -> Self {\n-        *self\n-    }\n-}\n-\n-impl<'a, T> Copy for PtrKey<'a, T> {}\n-\n-impl<'a, T> PartialEq for PtrKey<'a, T> {\n-    fn eq(&self, rhs: &Self) -> bool {\n-        ptr::eq(self.0, rhs.0)\n-    }\n-}\n-\n-impl<'a, T> Eq for PtrKey<'a, T> {}\n-\n-impl<'a, T> hash::Hash for PtrKey<'a, T> {\n-    fn hash<H: hash::Hasher>(&self, hasher: &mut H) {\n-        (self.0 as *const T).hash(hasher)\n-    }\n-}\n-\n-impl<'a, T> Deref for PtrKey<'a, T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &Self::Target {\n-        self.0\n-    }\n-}"}, {"sha": "94991fdb2011091c75af7bf1284e0ec394bbc059", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -299,7 +299,7 @@ impl<'tcx> ToTrace<'tcx> for ty::Region<'tcx> {\n     }\n }\n \n-impl<'tcx> ToTrace<'tcx> for &'tcx Const<'tcx> {\n+impl<'tcx> ToTrace<'tcx> for Const<'tcx> {\n     fn to_trace(\n         _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,"}, {"sha": "5e67c8cfa27c4a73cc0799ace0fed0efa64de974", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -179,20 +179,20 @@ impl CanonicalizeMode for CanonicalizeQueryResponse {\n         canonicalizer: &mut Canonicalizer<'_, 'tcx>,\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n-        match r {\n+        match *r {\n             ty::ReFree(_)\n             | ty::ReErased\n             | ty::ReStatic\n             | ty::ReEmpty(ty::UniverseIndex::ROOT)\n             | ty::ReEarlyBound(..) => r,\n \n             ty::RePlaceholder(placeholder) => canonicalizer.canonical_var_for_region(\n-                CanonicalVarInfo { kind: CanonicalVarKind::PlaceholderRegion(*placeholder) },\n+                CanonicalVarInfo { kind: CanonicalVarKind::PlaceholderRegion(placeholder) },\n                 r,\n             ),\n \n             ty::ReVar(vid) => {\n-                let universe = canonicalizer.region_var_universe(*vid);\n+                let universe = canonicalizer.region_var_universe(vid);\n                 canonicalizer.canonical_var_for_region(\n                     CanonicalVarInfo { kind: CanonicalVarKind::Region(universe) },\n                     r,\n@@ -240,7 +240,7 @@ impl CanonicalizeMode for CanonicalizeUserTypeAnnotation {\n         canonicalizer: &mut Canonicalizer<'_, 'tcx>,\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n-        match r {\n+        match *r {\n             ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReErased | ty::ReStatic => r,\n             ty::ReVar(_) => canonicalizer.canonical_var_for_region_in_root_universe(r),\n             _ => {\n@@ -311,11 +311,7 @@ impl CanonicalizeMode for CanonicalizeFreeRegionsOtherThanStatic {\n         canonicalizer: &mut Canonicalizer<'_, 'tcx>,\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n-        if let ty::ReStatic = r {\n-            r\n-        } else {\n-            canonicalizer.canonical_var_for_region_in_root_universe(r)\n-        }\n+        if r.is_static() { r } else { canonicalizer.canonical_var_for_region_in_root_universe(r) }\n     }\n \n     fn any(&self) -> bool {\n@@ -479,8 +475,8 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        match ct.val {\n+    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+        match ct.val() {\n             ty::ConstKind::Infer(InferConst::Var(vid)) => {\n                 debug!(\"canonical: const var found with vid {:?}\", vid);\n                 match self.infcx.probe_const_var(vid) {\n@@ -497,7 +493,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                             ui = ty::UniverseIndex::ROOT;\n                         }\n                         return self.canonicalize_const_var(\n-                            CanonicalVarInfo { kind: CanonicalVarKind::Const(ui, ct.ty) },\n+                            CanonicalVarInfo { kind: CanonicalVarKind::Const(ui, ct.ty()) },\n                             ct,\n                         );\n                     }\n@@ -773,17 +769,17 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n     fn canonicalize_const_var(\n         &mut self,\n         info: CanonicalVarInfo<'tcx>,\n-        const_var: &'tcx ty::Const<'tcx>,\n-    ) -> &'tcx ty::Const<'tcx> {\n+        const_var: ty::Const<'tcx>,\n+    ) -> ty::Const<'tcx> {\n         let infcx = self.infcx;\n         let bound_to = infcx.shallow_resolve(const_var);\n         if bound_to != const_var {\n             self.fold_const(bound_to)\n         } else {\n             let var = self.canonical_var(info, const_var.into());\n-            self.tcx().mk_const(ty::Const {\n+            self.tcx().mk_const(ty::ConstS {\n                 val: ty::ConstKind::Bound(self.binder_index, var),\n-                ty: self.fold_ty(const_var.ty),\n+                ty: self.fold_ty(const_var.ty()),\n             })\n         }\n     }"}, {"sha": "798568679851913db782e4db41f7f73c9632e661", "filename": "compiler/rustc_infer/src/infer/canonical/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -149,7 +149,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 let universe_mapped = universe_map(universe);\n                 let placeholder_mapped = ty::PlaceholderConst { universe: universe_mapped, name };\n                 self.tcx\n-                    .mk_const(ty::Const {\n+                    .mk_const(ty::ConstS {\n                         val: ty::ConstKind::Placeholder(placeholder_mapped),\n                         ty: name.ty,\n                     })"}, {"sha": "48d5c21f9eb880ee3ca13963b1a9268d04fbec1a", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -237,10 +237,9 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 v.var_values[BoundVar::new(index)]\n             });\n             match (original_value.unpack(), result_value.unpack()) {\n-                (\n-                    GenericArgKind::Lifetime(ty::ReErased),\n-                    GenericArgKind::Lifetime(ty::ReErased),\n-                ) => {\n+                (GenericArgKind::Lifetime(re1), GenericArgKind::Lifetime(re2))\n+                    if re1.is_erased() && re2.is_erased() =>\n+                {\n                     // No action needed.\n                 }\n \n@@ -429,7 +428,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 }\n                 GenericArgKind::Lifetime(result_value) => {\n                     // e.g., here `result_value` might be `'?1` in the example above...\n-                    if let &ty::RegionKind::ReLateBound(debruijn, br) = result_value {\n+                    if let ty::ReLateBound(debruijn, br) = *result_value {\n                         // ... in which case we would set `canonical_vars[0]` to `Some('static)`.\n \n                         // We only allow a `ty::INNERMOST` index in substitutions.\n@@ -438,12 +437,12 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                     }\n                 }\n                 GenericArgKind::Const(result_value) => {\n-                    if let ty::Const { val: ty::ConstKind::Bound(debrujin, b), .. } = result_value {\n+                    if let ty::ConstKind::Bound(debrujin, b) = result_value.val() {\n                         // ...in which case we would set `canonical_vars[0]` to `Some(const X)`.\n \n                         // We only allow a `ty::INNERMOST` index in substitutions.\n-                        assert_eq!(*debrujin, ty::INNERMOST);\n-                        opt_values[*b] = Some(*original_value);\n+                        assert_eq!(debrujin, ty::INNERMOST);\n+                        opt_values[b] = Some(*original_value);\n                     }\n                 }\n             }\n@@ -558,10 +557,9 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                         obligations\n                             .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n                     }\n-                    (\n-                        GenericArgKind::Lifetime(ty::ReErased),\n-                        GenericArgKind::Lifetime(ty::ReErased),\n-                    ) => {\n+                    (GenericArgKind::Lifetime(re1), GenericArgKind::Lifetime(re2))\n+                        if re1.is_erased() && re2.is_erased() =>\n+                    {\n                         // no action needed\n                     }\n                     (GenericArgKind::Lifetime(v1), GenericArgKind::Lifetime(v2)) => {\n@@ -672,7 +670,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         });\n     }\n \n-    fn const_equate(&mut self, _a: &'tcx Const<'tcx>, _b: &'tcx Const<'tcx>) {\n+    fn const_equate(&mut self, _a: Const<'tcx>, _b: Const<'tcx>) {\n         span_bug!(\n             self.cause.span(self.infcx.tcx),\n             \"generic_const_exprs: unreachable `const_equate`\""}, {"sha": "e1b5d04ccfb8fc376554d5d3cd5ddc4a39378871", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -123,9 +123,9 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n     pub fn super_combine_consts<R>(\n         &self,\n         relation: &mut R,\n-        a: &'tcx ty::Const<'tcx>,\n-        b: &'tcx ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n+        a: ty::Const<'tcx>,\n+        b: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>>\n     where\n         R: ConstEquateRelation<'tcx>,\n     {\n@@ -139,7 +139,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n \n         let a_is_expected = relation.a_is_expected();\n \n-        match (a.val, b.val) {\n+        match (a.val(), b.val()) {\n             (\n                 ty::ConstKind::Infer(InferConst::Var(a_vid)),\n                 ty::ConstKind::Infer(InferConst::Var(b_vid)),\n@@ -226,9 +226,9 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n         target_vid: ty::ConstVid<'tcx>,\n-        ct: &'tcx ty::Const<'tcx>,\n+        ct: ty::Const<'tcx>,\n         vid_is_expected: bool,\n-    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n         let (for_universe, span) = {\n             let mut inner = self.inner.borrow_mut();\n             let variable_table = &mut inner.const_unification_table();\n@@ -451,8 +451,8 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n     pub fn add_const_equate_obligation(\n         &mut self,\n         a_is_expected: bool,\n-        a: &'tcx ty::Const<'tcx>,\n-        b: &'tcx ty::Const<'tcx>,\n+        a: ty::Const<'tcx>,\n+        b: ty::Const<'tcx>,\n     ) {\n         let predicate = if a_is_expected {\n             ty::PredicateKind::ConstEquate(a, b)\n@@ -716,12 +716,12 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n \n     fn consts(\n         &mut self,\n-        c: &'tcx ty::Const<'tcx>,\n-        c2: &'tcx ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        c: ty::Const<'tcx>,\n+        c2: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n         assert_eq!(c, c2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n \n-        match c.val {\n+        match c.val() {\n             ty::ConstKind::Infer(InferConst::Var(vid)) => {\n                 let mut inner = self.infcx.inner.borrow_mut();\n                 let variable_table = &mut inner.const_unification_table();\n@@ -739,7 +739,7 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                                 origin: var_value.origin,\n                                 val: ConstVariableValue::Unknown { universe: self.for_universe },\n                             });\n-                            Ok(self.tcx().mk_const_var(new_var_id, c.ty))\n+                            Ok(self.tcx().mk_const_var(new_var_id, c.ty()))\n                         }\n                     }\n                 }\n@@ -754,8 +754,8 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                     substs,\n                     substs,\n                 )?;\n-                Ok(self.tcx().mk_const(ty::Const {\n-                    ty: c.ty,\n+                Ok(self.tcx().mk_const(ty::ConstS {\n+                    ty: c.ty(),\n                     val: ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted }),\n                 }))\n             }\n@@ -768,7 +768,7 @@ pub trait ConstEquateRelation<'tcx>: TypeRelation<'tcx> {\n     /// Register an obligation that both constants must be equal to each other.\n     ///\n     /// If they aren't equal then the relation doesn't hold.\n-    fn const_equate_obligation(&mut self, a: &'tcx ty::Const<'tcx>, b: &'tcx ty::Const<'tcx>);\n+    fn const_equate_obligation(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>);\n }\n \n pub trait RelateResultCompare<'tcx, T> {\n@@ -788,7 +788,7 @@ impl<'tcx, T: Clone + PartialEq> RelateResultCompare<'tcx, T> for RelateResult<'\n \n pub fn const_unification_error<'tcx>(\n     a_is_expected: bool,\n-    (a, b): (&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>),\n+    (a, b): (ty::Const<'tcx>, ty::Const<'tcx>),\n ) -> TypeError<'tcx> {\n     TypeError::ConstMismatch(ExpectedFound::new(a_is_expected, a, b))\n }\n@@ -915,7 +915,7 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n         debug_assert_eq!(r, _r);\n         debug!(\"ConstInferUnifier: r={:?}\", r);\n \n-        match r {\n+        match *r {\n             // Never make variables for regions bound within the type itself,\n             // nor for erased regions.\n             ty::ReLateBound(..) | ty::ReErased => {\n@@ -945,13 +945,13 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n     #[tracing::instrument(level = \"debug\", skip(self))]\n     fn consts(\n         &mut self,\n-        c: &'tcx ty::Const<'tcx>,\n-        _c: &'tcx ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        c: ty::Const<'tcx>,\n+        _c: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n         debug_assert_eq!(c, _c);\n         debug!(\"ConstInferUnifier: c={:?}\", c);\n \n-        match c.val {\n+        match c.val() {\n             ty::ConstKind::Infer(InferConst::Var(vid)) => {\n                 // Check if the current unification would end up\n                 // unifying `target_vid` with a const which contains\n@@ -985,7 +985,7 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n                                         },\n                                     },\n                                 );\n-                            Ok(self.tcx().mk_const_var(new_var_id, c.ty))\n+                            Ok(self.tcx().mk_const_var(new_var_id, c.ty()))\n                         }\n                     }\n                 }\n@@ -1000,8 +1000,8 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n                     substs,\n                     substs,\n                 )?;\n-                Ok(self.tcx().mk_const(ty::Const {\n-                    ty: c.ty,\n+                Ok(self.tcx().mk_const(ty::ConstS {\n+                    ty: c.ty(),\n                     val: ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted }),\n                 }))\n             }"}, {"sha": "5ac9ad6850c4040ce4a8029682807c5711130fe5", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -117,9 +117,9 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n \n     fn consts(\n         &mut self,\n-        a: &'tcx ty::Const<'tcx>,\n-        b: &'tcx ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        a: ty::Const<'tcx>,\n+        b: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n         self.fields.infcx.super_combine_consts(self, a, b)\n     }\n \n@@ -143,7 +143,7 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n }\n \n impl<'tcx> ConstEquateRelation<'tcx> for Equate<'_, '_, 'tcx> {\n-    fn const_equate_obligation(&mut self, a: &'tcx ty::Const<'tcx>, b: &'tcx ty::Const<'tcx>) {\n+    fn const_equate_obligation(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>) {\n         self.fields.add_const_equate_obligation(self.a_is_expected, a, b);\n     }\n }"}, {"sha": "d900379c44c629a9c29ee6d919c9c0db1dbce46c", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -239,7 +239,7 @@ pub fn unexpected_hidden_region_diagnostic<'tcx>(\n     );\n \n     // Explain the region we are capturing.\n-    match hidden_region {\n+    match *hidden_region {\n         ty::ReEmpty(ty::UniverseIndex::ROOT) => {\n             // All lifetimes shorter than the function body are `empty` in\n             // lexical region resolution. The default explanation of \"an empty\n@@ -515,7 +515,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 Err(NonTrivialPath)\n             }\n \n-            fn print_const(self, _ct: &'tcx ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n+            fn print_const(self, _ct: ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n                 Err(NonTrivialPath)\n             }\n \n@@ -915,13 +915,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) -> Option<()> {\n         for (i, ta) in sub.types().enumerate() {\n             if ta == other_ty {\n-                self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n+                self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, other_ty);\n                 return Some(());\n             }\n             if let ty::Adt(def, _) = ta.kind() {\n                 let path_ = self.tcx.def_path_str(def.did);\n                 if path_ == other_path {\n-                    self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n+                    self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, other_ty);\n                     return Some(());\n                 }\n             }\n@@ -1036,7 +1036,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let len2 = sig2.inputs().len();\n         if len1 == len2 {\n             for (i, (l, r)) in iter::zip(sig1.inputs(), sig2.inputs()).enumerate() {\n-                let (x1, x2) = self.cmp(l, r);\n+                let (x1, x2) = self.cmp(*l, *r);\n                 (values.0).0.extend(x1.0);\n                 (values.1).0.extend(x2.0);\n                 self.push_comma(&mut values.0, &mut values.1, len1, i);\n@@ -1114,7 +1114,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         fn push_ty_ref<'tcx>(\n-            region: &ty::Region<'tcx>,\n+            region: ty::Region<'tcx>,\n             ty: Ty<'tcx>,\n             mutbl: hir::Mutability,\n             s: &mut DiagnosticStyledString,\n@@ -1263,7 +1263,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             path1.clone(),\n                             sub_no_defaults_1,\n                             path2.clone(),\n-                            &t2,\n+                            t2,\n                         )\n                         .is_some()\n                     {\n@@ -1281,7 +1281,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             path2,\n                             sub_no_defaults_2,\n                             path1,\n-                            &t1,\n+                            t1,\n                         )\n                         .is_some()\n                     {\n@@ -1333,26 +1333,26 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n \n             // When finding T != &T, highlight only the borrow\n-            (&ty::Ref(r1, ref_ty1, mutbl1), _) if equals(&ref_ty1, &t2) => {\n+            (&ty::Ref(r1, ref_ty1, mutbl1), _) if equals(ref_ty1, t2) => {\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n-                push_ty_ref(&r1, ref_ty1, mutbl1, &mut values.0);\n+                push_ty_ref(r1, ref_ty1, mutbl1, &mut values.0);\n                 values.1.push_normal(t2.to_string());\n                 values\n             }\n-            (_, &ty::Ref(r2, ref_ty2, mutbl2)) if equals(&t1, &ref_ty2) => {\n+            (_, &ty::Ref(r2, ref_ty2, mutbl2)) if equals(t1, ref_ty2) => {\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n                 values.0.push_normal(t1.to_string());\n-                push_ty_ref(&r2, ref_ty2, mutbl2, &mut values.1);\n+                push_ty_ref(r2, ref_ty2, mutbl2, &mut values.1);\n                 values\n             }\n \n             // When encountering &T != &mut T, highlight only the borrow\n             (&ty::Ref(r1, ref_ty1, mutbl1), &ty::Ref(r2, ref_ty2, mutbl2))\n-                if equals(&ref_ty1, &ref_ty2) =>\n+                if equals(ref_ty1, ref_ty2) =>\n             {\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n-                push_ty_ref(&r1, ref_ty1, mutbl1, &mut values.0);\n-                push_ty_ref(&r2, ref_ty2, mutbl2, &mut values.1);\n+                push_ty_ref(r1, ref_ty1, mutbl1, &mut values.0);\n+                push_ty_ref(r2, ref_ty2, mutbl2, &mut values.1);\n                 values\n             }\n \n@@ -1923,7 +1923,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 .iter()\n                 .filter(|field| field.vis.is_accessible_from(field.did, self.tcx))\n                 .map(|field| (field.name, field.ty(self.tcx, expected_substs)))\n-                .find(|(_, ty)| same_type_modulo_infer(ty, exp_found.found))\n+                .find(|(_, ty)| same_type_modulo_infer(*ty, exp_found.found))\n             {\n                 if let ObligationCauseCode::Pattern { span: Some(span), .. } = *cause.code() {\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n@@ -2116,7 +2116,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let [expected_tup_elem] = &expected.tuple_fields().collect::<Vec<_>>()[..]\n             else { return };\n \n-        if !same_type_modulo_infer(expected_tup_elem, found) {\n+        if !same_type_modulo_infer(*expected_tup_elem, found) {\n             return;\n         }\n "}, {"sha": "aba5666b58cd7ce5f1a707dc97e08a3637b3893b", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -369,7 +369,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn extract_inference_diagnostics_data(\n         &self,\n         arg: GenericArg<'tcx>,\n-        highlight: Option<ty::print::RegionHighlightMode>,\n+        highlight: Option<ty::print::RegionHighlightMode<'tcx>>,\n     ) -> InferenceDiagnosticsData {\n         match arg.unpack() {\n             GenericArgKind::Type(ty) => {\n@@ -409,7 +409,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 }\n             }\n             GenericArgKind::Const(ct) => {\n-                match ct.val {\n+                match ct.val() {\n                     ty::ConstKind::Infer(InferConst::Var(vid)) => {\n                         let origin = self\n                             .inner\n@@ -459,7 +459,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                     }\n                                     _ => {}\n                                 },\n-                                GenericArgKind::Const(c) => match c.val {\n+                                GenericArgKind::Const(c) => match c.val() {\n                                     ty::ConstKind::Infer(InferConst::Var(_)) => {\n                                         return self.extract_inference_diagnostics_data(s, None);\n                                     }\n@@ -935,9 +935,9 @@ impl<'tcx> ResolvedTypeParamEraser<'tcx> {\n     }\n \n     /// Replace not yet inferred const params with their def name.\n-    fn replace_infers(&self, c: &'tcx Const<'tcx>, index: u32, name: Symbol) -> &'tcx Const<'tcx> {\n-        match c.val {\n-            ty::ConstKind::Infer(..) => self.tcx().mk_const_param(index, name, c.ty),\n+    fn replace_infers(&self, c: Const<'tcx>, index: u32, name: Symbol) -> Const<'tcx> {\n+        match c.val() {\n+            ty::ConstKind::Infer(..) => self.tcx().mk_const_param(index, name, c.ty()),\n             _ => c,\n         }\n     }\n@@ -962,7 +962,7 @@ impl<'tcx> TypeFolder<'tcx> for ResolvedTypeParamEraser<'tcx> {\n                     .map(|(subst, param)| match &(subst.unpack(), &param.kind) {\n                         (_, ty::GenericParamDefKind::Type { has_default: true, .. }) => subst,\n                         (crate::infer::GenericArgKind::Const(c), _) => {\n-                            self.replace_infers(c, param.index, param.name).into()\n+                            self.replace_infers(*c, param.index, param.name).into()\n                         }\n                         _ => subst.super_fold_with(self),\n                     })\n@@ -985,7 +985,7 @@ impl<'tcx> TypeFolder<'tcx> for ResolvedTypeParamEraser<'tcx> {\n                 }\n             }\n             ty::Ref(_, ty, _) => {\n-                let ty = self.fold_ty(ty);\n+                let ty = self.fold_ty(*ty);\n                 match ty.kind() {\n                     // Avoid `&_`, these can be safely presented as `_`.\n                     ty::Error(_) => self.tcx().ty_error(),\n@@ -1002,7 +1002,7 @@ impl<'tcx> TypeFolder<'tcx> for ResolvedTypeParamEraser<'tcx> {\n             | ty::Projection(_)\n             | ty::Never => t.super_fold_with(self),\n             ty::Array(ty, c) => {\n-                self.tcx().mk_ty(ty::Array(self.fold_ty(ty), self.replace_infers(c, 0, sym::N)))\n+                self.tcx().mk_ty(ty::Array(self.fold_ty(*ty), self.replace_infers(*c, 0, sym::N)))\n             }\n             // We don't want to hide type params that haven't been resolved yet.\n             // This would be the type that will be written out with the type param"}, {"sha": "ef4c9c24f3eb97c5db7c7f53c69af39ee93a0ebe", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mismatched_static_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -10,7 +10,7 @@ use rustc_data_structures::stable_set::FxHashSet;\n use rustc_errors::{Applicability, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::intravisit::Visitor;\n-use rustc_middle::ty::{self, TypeVisitor};\n+use rustc_middle::ty::TypeVisitor;\n use rustc_span::MultiSpan;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n@@ -22,7 +22,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             RegionResolutionError::ConcreteFailure(origin, sub, sup) => (origin, sub, sup),\n             _ => return None,\n         };\n-        if *sub != ty::RegionKind::ReStatic {\n+        if !sub.is_static() {\n             return None;\n         }\n         let cause = match origin {"}, {"sha": "8512597cb9137c27db21b6efcd196047cdf095e2", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -66,9 +66,9 @@ impl<'cx, 'tcx> NiceRegionError<'cx, 'tcx> {\n \n     pub fn regions(&self) -> Option<(Span, ty::Region<'tcx>, ty::Region<'tcx>)> {\n         match (&self.error, self.regions) {\n-            (Some(ConcreteFailure(origin, sub, sup)), None) => Some((origin.span(), sub, sup)),\n+            (Some(ConcreteFailure(origin, sub, sup)), None) => Some((origin.span(), *sub, *sup)),\n             (Some(SubSupConflict(_, _, origin, sub, _, sup, _)), None) => {\n-                Some((origin.span(), sub, sup))\n+                Some((origin.span(), *sub, *sup))\n             }\n             (None, Some((span, sub, sup))) => Some((span, sub, sup)),\n             _ => None,"}, {"sha": "17ff5d45c89f99180e00652b0e138be87289e4d3", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -48,7 +48,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n         // Suggesting to add a `'static` lifetime to a parameter is nearly always incorrect,\n         // and can steer users down the wrong path.\n-        if *named == ty::ReStatic {\n+        if named.is_static() {\n             return None;\n         }\n "}, {"sha": "7d82c60e6d3e073fd4f6bf952d8e32dce3b81021", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -3,13 +3,14 @@ use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::ValuePairs;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCause, ObligationCauseCode};\n+use rustc_data_structures::intern::Interned;\n use rustc_errors::DiagnosticBuilder;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::print::{FmtPrinter, Print, RegionHighlightMode};\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty::{self, RePlaceholder, ReVar, Region, TyCtxt};\n \n use std::fmt::{self, Write};\n \n@@ -31,30 +32,30 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                 vid,\n                 _,\n                 SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n-                sub_placeholder @ ty::RePlaceholder(_),\n+                sub_placeholder @ Region(Interned(RePlaceholder(_), _)),\n                 _,\n-                sup_placeholder @ ty::RePlaceholder(_),\n+                sup_placeholder @ Region(Interned(RePlaceholder(_), _)),\n                 _,\n             )) => self.try_report_trait_placeholder_mismatch(\n-                Some(self.tcx().mk_region(ty::ReVar(*vid))),\n+                Some(self.tcx().mk_region(ReVar(*vid))),\n                 cause,\n-                Some(sub_placeholder),\n-                Some(sup_placeholder),\n+                Some(*sub_placeholder),\n+                Some(*sup_placeholder),\n                 values,\n             ),\n \n             Some(RegionResolutionError::SubSupConflict(\n                 vid,\n                 _,\n                 SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n-                sub_placeholder @ ty::RePlaceholder(_),\n+                sub_placeholder @ Region(Interned(RePlaceholder(_), _)),\n                 _,\n                 _,\n                 _,\n             )) => self.try_report_trait_placeholder_mismatch(\n-                Some(self.tcx().mk_region(ty::ReVar(*vid))),\n+                Some(self.tcx().mk_region(ReVar(*vid))),\n                 cause,\n-                Some(sub_placeholder),\n+                Some(*sub_placeholder),\n                 None,\n                 values,\n             ),\n@@ -65,10 +66,10 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                 SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n                 _,\n                 _,\n-                sup_placeholder @ ty::RePlaceholder(_),\n+                sup_placeholder @ Region(Interned(RePlaceholder(_), _)),\n                 _,\n             )) => self.try_report_trait_placeholder_mismatch(\n-                Some(self.tcx().mk_region(ty::ReVar(*vid))),\n+                Some(self.tcx().mk_region(ReVar(*vid))),\n                 cause,\n                 None,\n                 Some(*sup_placeholder),\n@@ -81,10 +82,10 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                 _,\n                 _,\n                 SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n-                sup_placeholder @ ty::RePlaceholder(_),\n+                sup_placeholder @ Region(Interned(RePlaceholder(_), _)),\n                 _,\n             )) => self.try_report_trait_placeholder_mismatch(\n-                Some(self.tcx().mk_region(ty::ReVar(*vid))),\n+                Some(self.tcx().mk_region(ReVar(*vid))),\n                 cause,\n                 None,\n                 Some(*sup_placeholder),\n@@ -96,9 +97,9 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                 _,\n                 _,\n                 SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n-                sup_placeholder @ ty::RePlaceholder(_),\n+                sup_placeholder @ Region(Interned(RePlaceholder(_), _)),\n             )) => self.try_report_trait_placeholder_mismatch(\n-                Some(self.tcx().mk_region(ty::ReVar(*vid))),\n+                Some(self.tcx().mk_region(ReVar(*vid))),\n                 cause,\n                 None,\n                 Some(*sup_placeholder),\n@@ -107,8 +108,8 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n \n             Some(RegionResolutionError::ConcreteFailure(\n                 SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n-                sub_region @ ty::RePlaceholder(_),\n-                sup_region @ ty::RePlaceholder(_),\n+                sub_region @ Region(Interned(RePlaceholder(_), _)),\n+                sup_region @ Region(Interned(RePlaceholder(_), _)),\n             )) => self.try_report_trait_placeholder_mismatch(\n                 None,\n                 cause,\n@@ -119,25 +120,25 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n \n             Some(RegionResolutionError::ConcreteFailure(\n                 SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n-                sub_region @ ty::RePlaceholder(_),\n+                sub_region @ Region(Interned(RePlaceholder(_), _)),\n                 sup_region,\n             )) => self.try_report_trait_placeholder_mismatch(\n-                (!sup_region.has_name()).then_some(sup_region),\n+                (!sup_region.has_name()).then_some(*sup_region),\n                 cause,\n-                Some(sub_region),\n+                Some(*sub_region),\n                 None,\n                 values,\n             ),\n \n             Some(RegionResolutionError::ConcreteFailure(\n                 SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n                 sub_region,\n-                sup_region @ ty::RePlaceholder(_),\n+                sup_region @ Region(Interned(RePlaceholder(_), _)),\n             )) => self.try_report_trait_placeholder_mismatch(\n-                (!sub_region.has_name()).then_some(sub_region),\n+                (!sub_region.has_name()).then_some(*sub_region),\n                 cause,\n                 None,\n-                Some(sup_region),\n+                Some(*sup_region),\n                 values,\n             ),\n \n@@ -147,10 +148,10 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n \n     fn try_report_trait_placeholder_mismatch(\n         &self,\n-        vid: Option<ty::Region<'tcx>>,\n+        vid: Option<Region<'tcx>>,\n         cause: &ObligationCause<'tcx>,\n-        sub_placeholder: Option<ty::Region<'tcx>>,\n-        sup_placeholder: Option<ty::Region<'tcx>>,\n+        sub_placeholder: Option<Region<'tcx>>,\n+        sup_placeholder: Option<Region<'tcx>>,\n         value_pairs: &ValuePairs<'tcx>,\n     ) -> Option<DiagnosticBuilder<'tcx>> {\n         let (expected_substs, found_substs, trait_def_id) = match value_pairs {\n@@ -193,10 +194,10 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn report_trait_placeholder_mismatch(\n         &self,\n-        vid: Option<ty::Region<'tcx>>,\n+        vid: Option<Region<'tcx>>,\n         cause: &ObligationCause<'tcx>,\n-        sub_placeholder: Option<ty::Region<'tcx>>,\n-        sup_placeholder: Option<ty::Region<'tcx>>,\n+        sub_placeholder: Option<Region<'tcx>>,\n+        sup_placeholder: Option<Region<'tcx>>,\n         trait_def_id: DefId,\n         expected_substs: SubstsRef<'tcx>,\n         actual_substs: SubstsRef<'tcx>,\n@@ -306,13 +307,13 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n     fn explain_actual_impl_that_was_found(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        sub_placeholder: Option<ty::Region<'tcx>>,\n-        sup_placeholder: Option<ty::Region<'tcx>>,\n+        sub_placeholder: Option<Region<'tcx>>,\n+        sup_placeholder: Option<Region<'tcx>>,\n         has_sub: Option<usize>,\n         has_sup: Option<usize>,\n         expected_trait_ref: ty::TraitRef<'tcx>,\n         actual_trait_ref: ty::TraitRef<'tcx>,\n-        vid: Option<ty::Region<'tcx>>,\n+        vid: Option<Region<'tcx>>,\n         expected_has_vid: Option<usize>,\n         actual_has_vid: Option<usize>,\n         any_self_ty_has_vid: bool,\n@@ -322,7 +323,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n         #[derive(Copy, Clone)]\n         struct Highlighted<'tcx, T> {\n             tcx: TyCtxt<'tcx>,\n-            highlight: RegionHighlightMode,\n+            highlight: RegionHighlightMode<'tcx>,\n             value: T,\n         }\n \n@@ -366,7 +367,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n \n         let highlight_trait_ref = |trait_ref| Highlighted {\n             tcx: self.tcx(),\n-            highlight: RegionHighlightMode::default(),\n+            highlight: RegionHighlightMode::new(self.tcx()),\n             value: trait_ref,\n         };\n "}, {"sha": "625fd8642186d914e58fc71b82b8d5a7da3a7da8", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -10,8 +10,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_ty, Visitor};\n use rustc_hir::{self as hir, GenericBound, Item, ItemKind, Lifetime, LifetimeName, Node, TyKind};\n use rustc_middle::ty::{\n-    self, AssocItemContainer, RegionKind, StaticLifetimeVisitor, Ty, TyCtxt, TypeFoldable,\n-    TypeVisitor,\n+    self, AssocItemContainer, StaticLifetimeVisitor, Ty, TyCtxt, TypeFoldable, TypeVisitor,\n };\n use rustc_span::symbol::Ident;\n use rustc_span::{MultiSpan, Span};\n@@ -33,25 +32,23 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 sup_origin,\n                 sup_r,\n                 spans,\n-            ) if **sub_r == RegionKind::ReStatic => {\n-                (var_origin, sub_origin, sub_r, sup_origin, sup_r, spans)\n-            }\n+            ) if sub_r.is_static() => (var_origin, sub_origin, sub_r, sup_origin, sup_r, spans),\n             RegionResolutionError::ConcreteFailure(\n                 SubregionOrigin::Subtype(box TypeTrace { cause, .. }),\n                 sub_r,\n                 sup_r,\n-            ) if **sub_r == RegionKind::ReStatic => {\n+            ) if sub_r.is_static() => {\n                 // This is for an implicit `'static` requirement coming from `impl dyn Trait {}`.\n                 if let ObligationCauseCode::UnifyReceiver(ctxt) = cause.code() {\n                     // This may have a closure and it would cause ICE\n                     // through `find_param_with_region` (#78262).\n-                    let anon_reg_sup = tcx.is_suitable_region(sup_r)?;\n+                    let anon_reg_sup = tcx.is_suitable_region(*sup_r)?;\n                     let fn_returns = tcx.return_type_impl_or_dyn_traits(anon_reg_sup.def_id);\n                     if fn_returns.is_empty() {\n                         return None;\n                     }\n \n-                    let param = self.find_param_with_region(sup_r, sub_r)?;\n+                    let param = self.find_param_with_region(*sup_r, *sub_r)?;\n                     let lifetime = if sup_r.has_name() {\n                         format!(\"lifetime `{}`\", sup_r)\n                     } else {\n@@ -101,11 +98,11 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             \"try_report_static_impl_trait(var={:?}, sub={:?} {:?} sup={:?} {:?})\",\n             var_origin, sub_origin, sub_r, sup_origin, sup_r\n         );\n-        let anon_reg_sup = tcx.is_suitable_region(sup_r)?;\n+        let anon_reg_sup = tcx.is_suitable_region(*sup_r)?;\n         debug!(\"try_report_static_impl_trait: anon_reg_sup={:?}\", anon_reg_sup);\n         let sp = var_origin.span();\n         let return_sp = sub_origin.span();\n-        let param = self.find_param_with_region(sup_r, sub_r)?;\n+        let param = self.find_param_with_region(*sup_r, *sub_r)?;\n         let (lifetime_name, lifetime) = if sup_r.has_name() {\n             (sup_r.to_string(), format!(\"lifetime `{}`\", sup_r))\n         } else {\n@@ -560,7 +557,7 @@ pub(super) struct TraitObjectVisitor(pub(super) FxHashSet<DefId>);\n impl<'tcx> TypeVisitor<'tcx> for TraitObjectVisitor {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match t.kind() {\n-            ty::Dynamic(preds, RegionKind::ReStatic) => {\n+            ty::Dynamic(preds, re) if re.is_static() => {\n                 if let Some(def_id) = preds.principal_def_id() {\n                     self.0.insert(def_id);\n                 }"}, {"sha": "9216fa3ca1d31ffc6ec8d6fbabc259544d26cf62", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -42,8 +42,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                     if sup_expected_found == sub_expected_found {\n                         self.emit_err(\n                             var_origin.span(),\n-                            sub_expected,\n-                            sub_found,\n+                            *sub_expected,\n+                            *sub_found,\n                             *trait_item_def_id,\n                         );\n                         return Some(ErrorReported);\n@@ -81,21 +81,21 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n         // Mark all unnamed regions in the type with a number.\n         // This diagnostic is called in response to lifetime errors, so be informative.\n-        struct HighlightBuilder {\n-            highlight: RegionHighlightMode,\n+        struct HighlightBuilder<'tcx> {\n+            highlight: RegionHighlightMode<'tcx>,\n             counter: usize,\n         }\n \n-        impl HighlightBuilder {\n-            fn build(ty: Ty<'_>) -> RegionHighlightMode {\n+        impl<'tcx> HighlightBuilder<'tcx> {\n+            fn build(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> RegionHighlightMode<'tcx> {\n                 let mut builder =\n-                    HighlightBuilder { highlight: RegionHighlightMode::default(), counter: 1 };\n+                    HighlightBuilder { highlight: RegionHighlightMode::new(tcx), counter: 1 };\n                 builder.visit_ty(ty);\n                 builder.highlight\n             }\n         }\n \n-        impl<'tcx> ty::fold::TypeVisitor<'tcx> for HighlightBuilder {\n+        impl<'tcx> ty::fold::TypeVisitor<'tcx> for HighlightBuilder<'tcx> {\n             fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n                 if !r.has_name() && self.counter <= 3 {\n                     self.highlight.highlighting_region(r, self.counter);\n@@ -105,12 +105,12 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n         }\n \n-        let expected_highlight = HighlightBuilder::build(expected);\n+        let expected_highlight = HighlightBuilder::build(self.tcx(), expected);\n         let expected = self\n             .infcx\n             .extract_inference_diagnostics_data(expected.into(), Some(expected_highlight))\n             .name;\n-        let found_highlight = HighlightBuilder::build(found);\n+        let found_highlight = HighlightBuilder::build(self.tcx(), found);\n         let found =\n             self.infcx.extract_inference_diagnostics_data(found.into(), Some(found_highlight)).name;\n "}, {"sha": "719f6b37a434353b2d4c9bb83657a32815868119", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -70,7 +70,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 let ty = fn_sig.inputs()[index];\n                 let mut found_anon_region = false;\n                 let new_param_ty = self.tcx().fold_regions(ty, &mut false, |r, _| {\n-                    if *r == *anon_region {\n+                    if r == anon_region {\n                         found_anon_region = true;\n                         replace_region\n                     } else {"}, {"sha": "8e5efa12ac6c13de4c19aa191122764af625ca12", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -115,7 +115,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::Subtype(box trace) => {\n                 let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n                 let mut err = self.report_and_explain_type_error(trace, &terr);\n-                match (sub, sup) {\n+                match (*sub, *sup) {\n                     (ty::RePlaceholder(_), ty::RePlaceholder(_)) => {}\n                     (ty::RePlaceholder(_), _) => {\n                         note_and_explain_region("}, {"sha": "187c67df3eb31cd552c31f3066f03ab13beb717a", "filename": "compiler/rustc_infer/src/infer/free_regions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -41,8 +41,8 @@ pub struct FreeRegionMap<'tcx> {\n }\n \n impl<'tcx> FreeRegionMap<'tcx> {\n-    pub fn elements(&self) -> impl Iterator<Item = &Region<'tcx>> {\n-        self.relation.elements()\n+    pub fn elements(&self) -> impl Iterator<Item = Region<'tcx>> + '_ {\n+        self.relation.elements().copied()\n     }\n \n     pub fn is_empty(&self) -> bool {\n@@ -91,7 +91,7 @@ impl<'tcx> FreeRegionMap<'tcx> {\n \n     /// True for free regions other than `'static`.\n     pub fn is_free(&self, r: Region<'_>) -> bool {\n-        matches!(r, ty::ReEarlyBound(_) | ty::ReFree(_))\n+        matches!(*r, ty::ReEarlyBound(_) | ty::ReFree(_))\n     }\n \n     /// True if `r` is a free region or static of the sort that this"}, {"sha": "e9d3b6a8aa1a4167d777c0645541392bf9529e37", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -46,7 +46,7 @@ pub struct TypeFreshener<'a, 'tcx> {\n     ty_freshen_count: u32,\n     const_freshen_count: u32,\n     ty_freshen_map: FxHashMap<ty::InferTy, Ty<'tcx>>,\n-    const_freshen_map: FxHashMap<ty::InferConst<'tcx>, &'tcx ty::Const<'tcx>>,\n+    const_freshen_map: FxHashMap<ty::InferConst<'tcx>, ty::Const<'tcx>>,\n     keep_static: bool,\n }\n \n@@ -89,11 +89,11 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n \n     fn freshen_const<F>(\n         &mut self,\n-        opt_ct: Option<&'tcx ty::Const<'tcx>>,\n+        opt_ct: Option<ty::Const<'tcx>>,\n         key: ty::InferConst<'tcx>,\n         freshener: F,\n         ty: Ty<'tcx>,\n-    ) -> &'tcx ty::Const<'tcx>\n+    ) -> ty::Const<'tcx>\n     where\n         F: FnOnce(u32) -> ty::InferConst<'tcx>,\n     {\n@@ -221,8 +221,8 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        match ct.val {\n+    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+        match ct.val() {\n             ty::ConstKind::Infer(ty::InferConst::Var(v)) => {\n                 let opt_ct = self\n                     .infcx\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                     opt_ct,\n                     ty::InferConst::Var(v),\n                     ty::InferConst::Fresh,\n-                    ct.ty,\n+                    ct.ty(),\n                 );\n             }\n             ty::ConstKind::Infer(ty::InferConst::Fresh(i)) => {"}, {"sha": "c5c131a5b796bb074ccea1b53c2ae83f03e90069", "filename": "compiler/rustc_infer/src/infer/fudge.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -230,14 +230,14 @@ impl<'a, 'tcx> TypeFolder<'tcx> for InferenceFudger<'a, 'tcx> {\n         r\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ty::Const { val: ty::ConstKind::Infer(ty::InferConst::Var(vid)), ty } = ct {\n+    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+        if let ty::ConstKind::Infer(ty::InferConst::Var(vid)) = ct.val() {\n             if self.const_vars.0.contains(&vid) {\n                 // This variable was created during the fudging.\n                 // Recreate it with a fresh variable here.\n                 let idx = (vid.index - self.const_vars.0.start.index) as usize;\n                 let origin = self.const_vars.1[idx];\n-                self.infcx.next_const_var(ty, origin)\n+                self.infcx.next_const_var(ct.ty(), origin)\n             } else {\n                 ct\n             }"}, {"sha": "381097344ec68eec5e000f22196e5b257d862cfd", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -78,9 +78,9 @@ impl<'tcx> TypeRelation<'tcx> for Glb<'_, '_, 'tcx> {\n \n     fn consts(\n         &mut self,\n-        a: &'tcx ty::Const<'tcx>,\n-        b: &'tcx ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        a: ty::Const<'tcx>,\n+        b: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n         self.fields.infcx.super_combine_consts(self, a, b)\n     }\n \n@@ -120,7 +120,7 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Glb<'combine, 'infcx,\n }\n \n impl<'tcx> ConstEquateRelation<'tcx> for Glb<'_, '_, 'tcx> {\n-    fn const_equate_obligation(&mut self, a: &'tcx ty::Const<'tcx>, b: &'tcx ty::Const<'tcx>) {\n+    fn const_equate_obligation(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>) {\n         self.fields.add_const_equate_obligation(self.a_is_expected, a, b);\n     }\n }"}, {"sha": "82454b89156a6110d5b7a5199aab761ad56e6529", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -94,7 +94,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         };\n \n         let fld_c = |bound_var: ty::BoundVar, ty| {\n-            self.tcx.mk_const(ty::Const {\n+            self.tcx.mk_const(ty::ConstS {\n                 val: ty::ConstKind::Placeholder(ty::PlaceholderConst {\n                     universe: next_universe,\n                     name: ty::BoundConst { var: bound_var, ty },"}, {"sha": "4e50585ff524f454233fa495b5452a686331b661", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -13,6 +13,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n };\n+use rustc_data_structures::intern::Interned;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -250,8 +251,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 changes.push(b_vid);\n             }\n             if let Some(a_vid) = a_vid {\n-                match *b_data {\n-                    VarValue::Value(ReStatic) | VarValue::ErrorValue => (),\n+                match b_data {\n+                    VarValue::Value(Region(Interned(ReStatic, _))) | VarValue::ErrorValue => (),\n                     _ => {\n                         constraints[a_vid].push((a_vid, b_vid));\n                         constraints[b_vid].push((a_vid, b_vid));\n@@ -270,7 +271,10 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 if self.expand_node(a_region, b_vid, b_data) {\n                     changes.push(b_vid);\n                 }\n-                !matches!(b_data, VarValue::Value(ReStatic) | VarValue::ErrorValue)\n+                !matches!(\n+                    b_data,\n+                    VarValue::Value(Region(Interned(ReStatic, _))) | VarValue::ErrorValue\n+                )\n             });\n         }\n     }\n@@ -301,8 +305,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 // check below for a common case, here purely as an\n                 // optimization.\n                 let b_universe = self.var_infos[b_vid].universe;\n-                if let ReEmpty(a_universe) = a_region {\n-                    if *a_universe == b_universe {\n+                if let ReEmpty(a_universe) = *a_region {\n+                    if a_universe == b_universe {\n                         return false;\n                     }\n                 }\n@@ -321,7 +325,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 // tighter bound than `'static`.\n                 //\n                 // (This might e.g. arise from being asked to prove `for<'a> { 'b: 'a }`.)\n-                if let ty::RePlaceholder(p) = lub {\n+                if let ty::RePlaceholder(p) = *lub {\n                     if b_universe.cannot_name(p.universe) {\n                         lub = self.tcx().lifetimes.re_static;\n                     }\n@@ -372,12 +376,12 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     /// term \"concrete regions\").\n     #[instrument(level = \"trace\", skip(self))]\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n-        let r = match (a, b) {\n-            (&ReLateBound(..), _) | (_, &ReLateBound(..)) | (&ReErased, _) | (_, &ReErased) => {\n+        let r = match (*a, *b) {\n+            (ReLateBound(..), _) | (_, ReLateBound(..)) | (ReErased, _) | (_, ReErased) => {\n                 bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n             }\n \n-            (&ReVar(v_id), _) | (_, &ReVar(v_id)) => {\n+            (ReVar(v_id), _) | (_, ReVar(v_id)) => {\n                 span_bug!(\n                     self.var_infos[v_id].origin.span(),\n                     \"lub_concrete_regions invoked with non-concrete \\\n@@ -387,27 +391,32 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 );\n             }\n \n-            (&ReStatic, _) | (_, &ReStatic) => {\n+            (ReStatic, _) | (_, ReStatic) => {\n                 // nothing lives longer than `'static`\n                 self.tcx().lifetimes.re_static\n             }\n \n-            (&ReEmpty(_), r @ (ReEarlyBound(_) | ReFree(_)))\n-            | (r @ (ReEarlyBound(_) | ReFree(_)), &ReEmpty(_)) => {\n+            (ReEmpty(_), ReEarlyBound(_) | ReFree(_)) => {\n                 // All empty regions are less than early-bound, free,\n                 // and scope regions.\n-                r\n+                b\n             }\n \n-            (&ReEmpty(a_ui), &ReEmpty(b_ui)) => {\n+            (ReEarlyBound(_) | ReFree(_), ReEmpty(_)) => {\n+                // All empty regions are less than early-bound, free,\n+                // and scope regions.\n+                a\n+            }\n+\n+            (ReEmpty(a_ui), ReEmpty(b_ui)) => {\n                 // Empty regions are ordered according to the universe\n                 // they are associated with.\n                 let ui = a_ui.min(b_ui);\n                 self.tcx().mk_region(ReEmpty(ui))\n             }\n \n-            (&ReEmpty(empty_ui), &RePlaceholder(placeholder))\n-            | (&RePlaceholder(placeholder), &ReEmpty(empty_ui)) => {\n+            (ReEmpty(empty_ui), RePlaceholder(placeholder))\n+            | (RePlaceholder(placeholder), ReEmpty(empty_ui)) => {\n                 // If this empty region is from a universe that can\n                 // name the placeholder, then the placeholder is\n                 // larger; otherwise, the only ancestor is `'static`.\n@@ -418,13 +427,13 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 }\n             }\n \n-            (&ReEarlyBound(_) | &ReFree(_), &ReEarlyBound(_) | &ReFree(_)) => {\n+            (ReEarlyBound(_) | ReFree(_), ReEarlyBound(_) | ReFree(_)) => {\n                 self.region_rels.lub_free_regions(a, b)\n             }\n \n             // For these types, we cannot define any additional\n             // relationship:\n-            (&RePlaceholder(..), _) | (_, &RePlaceholder(..)) => {\n+            (RePlaceholder(..), _) | (_, RePlaceholder(..)) => {\n                 if a == b {\n                     a\n                 } else {\n@@ -676,7 +685,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         let node_universe = self.var_infos[node_idx].universe;\n \n         for lower_bound in &lower_bounds {\n-            let effective_lower_bound = if let ty::RePlaceholder(p) = lower_bound.region {\n+            let effective_lower_bound = if let ty::RePlaceholder(p) = *lower_bound.region {\n                 if node_universe.cannot_name(p.universe) {\n                     self.tcx().lifetimes.re_static\n                 } else {\n@@ -721,7 +730,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             .expect(\"lower_vid_bounds should at least include `node_idx`\");\n \n         for upper_bound in &upper_bounds {\n-            if let ty::RePlaceholder(p) = upper_bound.region {\n+            if let ty::RePlaceholder(p) = *upper_bound.region {\n                 if min_universe.cannot_name(p.universe) {\n                     let origin = self.var_infos[node_idx].origin;\n                     errors.push(RegionResolutionError::UpperBoundUniverseConflict(\n@@ -855,11 +864,11 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n \n             VerifyBound::OutlivedBy(r) => {\n-                self.sub_concrete_regions(min, var_values.normalize(self.tcx(), r))\n+                self.sub_concrete_regions(min, var_values.normalize(self.tcx(), *r))\n             }\n \n             VerifyBound::IsEmpty => {\n-                matches!(min, ty::ReEmpty(_))\n+                matches!(*min, ty::ReEmpty(_))\n             }\n \n             VerifyBound::AnyBound(bs) => {\n@@ -884,8 +893,8 @@ impl<'tcx> LexicalRegionResolutions<'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        tcx.fold_regions(value, &mut false, |r, _db| match r {\n-            ty::ReVar(rid) => self.resolve_var(*rid),\n+        tcx.fold_regions(value, &mut false, |r, _db| match *r {\n+            ty::ReVar(rid) => self.resolve_var(rid),\n             _ => r,\n         })\n     }"}, {"sha": "57cbe2c54f7aec978ddbee9e837b0e54cae8eda9", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -78,9 +78,9 @@ impl<'tcx> TypeRelation<'tcx> for Lub<'_, '_, 'tcx> {\n \n     fn consts(\n         &mut self,\n-        a: &'tcx ty::Const<'tcx>,\n-        b: &'tcx ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        a: ty::Const<'tcx>,\n+        b: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n         self.fields.infcx.super_combine_consts(self, a, b)\n     }\n \n@@ -103,7 +103,7 @@ impl<'tcx> TypeRelation<'tcx> for Lub<'_, '_, 'tcx> {\n }\n \n impl<'tcx> ConstEquateRelation<'tcx> for Lub<'_, '_, 'tcx> {\n-    fn const_equate_obligation(&mut self, a: &'tcx ty::Const<'tcx>, b: &'tcx ty::Const<'tcx>) {\n+    fn const_equate_obligation(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>) {\n         self.fields.add_const_equate_obligation(self.a_is_expected, a, b);\n     }\n }"}, {"sha": "f0a4ec813134c8eb44535a1f68476135a1baffcd", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -382,7 +382,7 @@ impl<'tcx> ValuePairs<'tcx> {\n             found: ty::Term::Ty(found),\n         }) = self\n         {\n-            Some((expected, found))\n+            Some((*expected, *found))\n         } else {\n             None\n         }\n@@ -1079,11 +1079,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.tcx.mk_ty_var(vid)\n     }\n \n-    pub fn next_const_var(\n-        &self,\n-        ty: Ty<'tcx>,\n-        origin: ConstVariableOrigin,\n-    ) -> &'tcx ty::Const<'tcx> {\n+    pub fn next_const_var(&self, ty: Ty<'tcx>, origin: ConstVariableOrigin) -> ty::Const<'tcx> {\n         self.tcx.mk_const_var(self.next_const_var_id(origin), ty)\n     }\n \n@@ -1092,7 +1088,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         origin: ConstVariableOrigin,\n         universe: ty::UniverseIndex,\n-    ) -> &'tcx ty::Const<'tcx> {\n+    ) -> ty::Const<'tcx> {\n         let vid = self\n             .inner\n             .borrow_mut()\n@@ -1435,7 +1431,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn probe_const_var(\n         &self,\n         vid: ty::ConstVid<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, ty::UniverseIndex> {\n+    ) -> Result<ty::Const<'tcx>, ty::UniverseIndex> {\n         match self.inner.borrow_mut().const_unification_table().probe_value(vid).val {\n             ConstVariableValue::Known { value } => Ok(value),\n             ConstVariableValue::Unknown { universe } => Err(universe),\n@@ -1501,8 +1497,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_mismatched_consts(\n         &self,\n         cause: &ObligationCause<'tcx>,\n-        expected: &'tcx ty::Const<'tcx>,\n-        actual: &'tcx ty::Const<'tcx>,\n+        expected: ty::Const<'tcx>,\n+        actual: ty::Const<'tcx>,\n         err: TypeError<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n         let trace = TypeTrace::consts(cause, true, expected, actual);\n@@ -1756,8 +1752,8 @@ impl<'tcx> TyOrConstInferVar<'tcx> {\n \n     /// Tries to extract an inference variable from a constant, returns `None`\n     /// for constants other than `ty::ConstKind::Infer(_)` (or `InferConst::Fresh`).\n-    pub fn maybe_from_const(ct: &'tcx ty::Const<'tcx>) -> Option<Self> {\n-        match ct.val {\n+    pub fn maybe_from_const(ct: ty::Const<'tcx>) -> Option<Self> {\n+        match ct.val() {\n             ty::ConstKind::Infer(InferConst::Var(v)) => Some(TyOrConstInferVar::Const(v)),\n             _ => None,\n         }\n@@ -1777,13 +1773,13 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n         self.infcx.shallow_resolve_ty(ty)\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = ct {\n+    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+        if let ty::ConstKind::Infer(InferConst::Var(vid)) = ct.val() {\n             self.infcx\n                 .inner\n                 .borrow_mut()\n                 .const_unification_table()\n-                .probe_value(*vid)\n+                .probe_value(vid)\n                 .val\n                 .known()\n                 .unwrap_or(ct)\n@@ -1813,8 +1809,8 @@ impl<'tcx> TypeTrace<'tcx> {\n     pub fn consts(\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n-        a: &'tcx ty::Const<'tcx>,\n-        b: &'tcx ty::Const<'tcx>,\n+        a: ty::Const<'tcx>,\n+        b: ty::Const<'tcx>,\n     ) -> TypeTrace<'tcx> {\n         TypeTrace {\n             cause: cause.clone(),"}, {"sha": "60f776d8c1f6783750b4a35b2257507d04f278d3", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -87,7 +87,7 @@ pub trait TypeRelatingDelegate<'tcx> {\n         info: ty::VarianceDiagInfo<'tcx>,\n     );\n \n-    fn const_equate(&mut self, a: &'tcx ty::Const<'tcx>, b: &'tcx ty::Const<'tcx>);\n+    fn const_equate(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>);\n \n     /// Creates a new universe index. Used when instantiating placeholders.\n     fn create_next_universe(&mut self) -> ty::UniverseIndex;\n@@ -244,8 +244,8 @@ where\n         scopes: &[BoundRegionScope<'tcx>],\n     ) -> ty::Region<'tcx> {\n         debug!(\"replace_bound_regions(scopes={:?})\", scopes);\n-        if let ty::ReLateBound(debruijn, br) = r {\n-            Self::lookup_bound_region(*debruijn, br, first_free_index, scopes)\n+        if let ty::ReLateBound(debruijn, br) = *r {\n+            Self::lookup_bound_region(debruijn, &br, first_free_index, scopes)\n         } else {\n             r\n         }\n@@ -450,7 +450,7 @@ impl<'tcx> VidValuePair<'tcx> for (ty::TyVid, Ty<'tcx>) {\n     where\n         D: TypeRelatingDelegate<'tcx>,\n     {\n-        relate.relate(&generalized_ty, &self.value_ty())\n+        relate.relate(generalized_ty, self.value_ty())\n     }\n }\n \n@@ -482,7 +482,7 @@ impl<'tcx> VidValuePair<'tcx> for (Ty<'tcx>, ty::TyVid) {\n     where\n         D: TypeRelatingDelegate<'tcx>,\n     {\n-        relate.relate(&self.value_ty(), &generalized_ty)\n+        relate.relate(self.value_ty(), generalized_ty)\n     }\n }\n \n@@ -609,16 +609,16 @@ where\n \n     fn consts(\n         &mut self,\n-        a: &'tcx ty::Const<'tcx>,\n-        mut b: &'tcx ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        a: ty::Const<'tcx>,\n+        mut b: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n         let a = self.infcx.shallow_resolve(a);\n \n         if !D::forbid_inference_vars() {\n             b = self.infcx.shallow_resolve(b);\n         }\n \n-        match b.val {\n+        match b.val() {\n             ty::ConstKind::Infer(InferConst::Var(_)) if D::forbid_inference_vars() => {\n                 // Forbid inference variables in the RHS.\n                 bug!(\"unexpected inference var {:?}\", b)\n@@ -745,7 +745,7 @@ impl<'tcx, D> ConstEquateRelation<'tcx> for TypeRelating<'_, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n {\n-    fn const_equate_obligation(&mut self, a: &'tcx ty::Const<'tcx>, b: &'tcx ty::Const<'tcx>) {\n+    fn const_equate_obligation(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>) {\n         self.delegate.const_equate(a, b);\n     }\n }\n@@ -779,9 +779,9 @@ impl<'me, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx> {\n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let ScopeInstantiator { bound_region_scope, next_region, .. } = self;\n \n-        match r {\n-            ty::ReLateBound(debruijn, br) if *debruijn == self.target_index => {\n-                bound_region_scope.map.entry(*br).or_insert_with(|| next_region(*br));\n+        match *r {\n+            ty::ReLateBound(debruijn, br) if debruijn == self.target_index => {\n+                bound_region_scope.map.entry(br).or_insert_with(|| next_region(br));\n             }\n \n             _ => {}\n@@ -963,8 +963,8 @@ where\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(\"TypeGeneralizer::regions(a={:?})\", a);\n \n-        if let ty::ReLateBound(debruijn, _) = a {\n-            if *debruijn < self.first_free_index {\n+        if let ty::ReLateBound(debruijn, _) = *a {\n+            if debruijn < self.first_free_index {\n                 return Ok(a);\n             }\n         }\n@@ -992,10 +992,10 @@ where\n \n     fn consts(\n         &mut self,\n-        a: &'tcx ty::Const<'tcx>,\n-        _: &'tcx ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        match a.val {\n+        a: ty::Const<'tcx>,\n+        _: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n+        match a.val() {\n             ty::ConstKind::Infer(InferConst::Var(_)) if D::forbid_inference_vars() => {\n                 bug!(\"unexpected inference variable encountered in NLL generalization: {:?}\", a);\n             }\n@@ -1010,7 +1010,7 @@ where\n                             origin: var_value.origin,\n                             val: ConstVariableValue::Unknown { universe: self.universe },\n                         });\n-                        Ok(self.tcx().mk_const_var(new_var_id, a.ty))\n+                        Ok(self.tcx().mk_const_var(new_var_id, a.ty()))\n                     }\n                 }\n             }"}, {"sha": "bd8bb9e1fa9ea2b2eb7420ca1b75afd659028484", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -2,8 +2,9 @@ use crate::infer::free_regions::FreeRegionMap;\n use crate::infer::{GenericKind, InferCtxt};\n use crate::traits::query::OutlivesBound;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::intern::Interned;\n use rustc_hir as hir;\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, ReEarlyBound, ReFree, ReVar, Region};\n \n use super::explicit_outlives_bounds;\n \n@@ -66,7 +67,7 @@ pub struct OutlivesEnvironment<'tcx> {\n /// \"Region-bound pairs\" tracks outlives relations that are known to\n /// be true, either because of explicit where-clauses like `T: 'a` or\n /// because of implied bounds.\n-pub type RegionBoundPairs<'tcx> = Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>;\n+pub type RegionBoundPairs<'tcx> = Vec<(Region<'tcx>, GenericKind<'tcx>)>;\n \n impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n     pub fn new(param_env: ty::ParamEnv<'tcx>) -> Self {\n@@ -164,10 +165,10 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n             debug!(\"add_outlives_bounds: outlives_bound={:?}\", outlives_bound);\n             match outlives_bound {\n                 OutlivesBound::RegionSubRegion(\n-                    r_a @ (&ty::ReEarlyBound(_) | &ty::ReFree(_)),\n-                    &ty::ReVar(vid_b),\n+                    r_a @ (Region(Interned(ReEarlyBound(_), _)) | Region(Interned(ReFree(_), _))),\n+                    Region(Interned(ReVar(vid_b), _)),\n                 ) => {\n-                    infcx.expect(\"no infcx provided but region vars found\").add_given(r_a, vid_b);\n+                    infcx.expect(\"no infcx provided but region vars found\").add_given(r_a, *vid_b);\n                 }\n                 OutlivesBound::RegionSubParam(r_a, param_b) => {\n                     self.region_bound_pairs_accum.push((r_a, GenericKind::Param(param_b)));"}, {"sha": "0224aba01ef2884dc22c39c3628e660d56c82ae6", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -285,7 +285,7 @@ where\n             let origin = origin.clone();\n             match component {\n                 Component::Region(region1) => {\n-                    self.delegate.push_sub_region_constraint(origin, region, region1);\n+                    self.delegate.push_sub_region_constraint(origin, region, *region1);\n                 }\n                 Component::Param(param_ty) => {\n                     self.param_ty_must_outlive(origin, region, *param_ty);"}, {"sha": "36d18aebfe2a06630dcb0920770af3e913409460", "filename": "compiler/rustc_infer/src/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -154,17 +154,17 @@ impl<'me, 'tcx> LeakCheck<'me, 'tcx> {\n             let scc = self.mini_graph.sccs.scc(*leak_check_node);\n \n             // Set the universe of each SCC to be the minimum of its constituent universes\n-            let universe = self.rcc.universe(region);\n+            let universe = self.rcc.universe(*region);\n             debug!(\n                 \"assign_placeholder_values: scc={:?} universe={:?} region={:?}\",\n                 scc, universe, region\n             );\n-            self.scc_universes[scc].take_min(universe, region);\n+            self.scc_universes[scc].take_min(universe, *region);\n \n             // Detect those SCCs that directly contain a placeholder\n-            if let ty::RePlaceholder(placeholder) = region {\n+            if let ty::RePlaceholder(placeholder) = **region {\n                 if self.universe_at_start_of_snapshot.cannot_name(placeholder.universe) {\n-                    self.assign_scc_value(scc, *placeholder)?;\n+                    self.assign_scc_value(scc, placeholder)?;\n                 }\n             }\n         }"}, {"sha": "a5bd3b15c8d8f2d890c1f55b04255d384a2d2e57", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -8,6 +8,7 @@ use super::{\n };\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::undo_log::UndoLogs;\n use rustc_data_structures::unify as ut;\n@@ -502,14 +503,15 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n             self.make_subregion(origin, sup, sub);\n \n             match (sub, sup) {\n-                (&ty::ReVar(sub), &ty::ReVar(sup)) => {\n+                (Region(Interned(ReVar(sub), _)), Region(Interned(ReVar(sup), _))) => {\n                     debug!(\"make_eqregion: unifying {:?} with {:?}\", sub, sup);\n-                    self.unification_table().union(sub, sup);\n+                    self.unification_table().union(*sub, *sup);\n                     self.any_unifications = true;\n                 }\n-                (&ty::ReVar(vid), value) | (value, &ty::ReVar(vid)) => {\n+                (Region(Interned(ReVar(vid), _)), value)\n+                | (value, Region(Interned(ReVar(vid), _))) => {\n                     debug!(\"make_eqregion: unifying {:?} with {:?}\", vid, value);\n-                    self.unification_table().union_value(vid, UnifiedRegion(Some(value)));\n+                    self.unification_table().union_value(*vid, UnifiedRegion(Some(value)));\n                     self.any_unifications = true;\n                 }\n                 (_, _) => {}\n@@ -550,20 +552,20 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         // cannot add constraints once regions are resolved\n         debug!(\"origin = {:#?}\", origin);\n \n-        match (sub, sup) {\n-            (&ReLateBound(..), _) | (_, &ReLateBound(..)) => {\n+        match (*sub, *sup) {\n+            (ReLateBound(..), _) | (_, ReLateBound(..)) => {\n                 span_bug!(origin.span(), \"cannot relate bound region: {:?} <= {:?}\", sub, sup);\n             }\n-            (_, &ReStatic) => {\n+            (_, ReStatic) => {\n                 // all regions are subregions of static, so we can ignore this\n             }\n-            (&ReVar(sub_id), &ReVar(sup_id)) => {\n+            (ReVar(sub_id), ReVar(sup_id)) => {\n                 self.add_constraint(Constraint::VarSubVar(sub_id, sup_id), origin);\n             }\n-            (_, &ReVar(sup_id)) => {\n+            (_, ReVar(sup_id)) => {\n                 self.add_constraint(Constraint::RegSubVar(sub, sup_id), origin);\n             }\n-            (&ReVar(sub_id), _) => {\n+            (ReVar(sub_id), _) => {\n                 self.add_constraint(Constraint::VarSubReg(sub_id, sup), origin);\n             }\n             _ => {\n@@ -591,16 +593,12 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n     ) -> Region<'tcx> {\n         // cannot add constraints once regions are resolved\n         debug!(\"RegionConstraintCollector: lub_regions({:?}, {:?})\", a, b);\n-        match (a, b) {\n-            (r @ &ReStatic, _) | (_, r @ &ReStatic) => {\n-                r // nothing lives longer than static\n-            }\n-\n-            _ if a == b => {\n-                a // LUB(a,a) = a\n-            }\n-\n-            _ => self.combine_vars(tcx, Lub, a, b, origin),\n+        if a.is_static() || b.is_static() {\n+            a // nothing lives longer than static\n+        } else if a == b {\n+            a // LUB(a,a) = a\n+        } else {\n+            self.combine_vars(tcx, Lub, a, b, origin)\n         }\n     }\n \n@@ -613,16 +611,14 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n     ) -> Region<'tcx> {\n         // cannot add constraints once regions are resolved\n         debug!(\"RegionConstraintCollector: glb_regions({:?}, {:?})\", a, b);\n-        match (a, b) {\n-            (&ReStatic, r) | (r, &ReStatic) => {\n-                r // static lives longer than everything else\n-            }\n-\n-            _ if a == b => {\n-                a // GLB(a,a) = a\n-            }\n-\n-            _ => self.combine_vars(tcx, Glb, a, b, origin),\n+        if a.is_static() {\n+            b // static lives longer than everything else\n+        } else if b.is_static() {\n+            a // static lives longer than everything else\n+        } else if a == b {\n+            a // GLB(a,a) = a\n+        } else {\n+            self.combine_vars(tcx, Glb, a, b, origin)\n         }\n     }\n \n@@ -639,11 +635,11 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         region: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n-        match region {\n+        match *region {\n             ty::ReVar(rid) => {\n-                let unified_region = self.unification_table().probe_value(*rid);\n+                let unified_region = self.unification_table().probe_value(rid);\n                 unified_region.0.unwrap_or_else(|| {\n-                    let root = self.unification_table().find(*rid).vid;\n+                    let root = self.unification_table().find(rid).vid;\n                     tcx.reuse_or_mk_region(region, ty::ReVar(root))\n                 })\n             }\n@@ -767,8 +763,7 @@ impl<'tcx> VerifyBound<'tcx> {\n     pub fn must_hold(&self) -> bool {\n         match self {\n             VerifyBound::IfEq(..) => false,\n-            VerifyBound::OutlivedBy(ty::ReStatic) => true,\n-            VerifyBound::OutlivedBy(_) => false,\n+            VerifyBound::OutlivedBy(re) => re.is_static(),\n             VerifyBound::IsEmpty => false,\n             VerifyBound::AnyBound(bs) => bs.iter().any(|b| b.must_hold()),\n             VerifyBound::AllBounds(bs) => bs.iter().all(|b| b.must_hold()),"}, {"sha": "08358bf506778b85af4c4a1ad8d92ca0d6b970ba", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticVarResolver<'a, 'tcx> {\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx Const<'tcx>) -> &'tcx Const<'tcx> {\n+    fn fold_const(&mut self, ct: Const<'tcx>) -> Const<'tcx> {\n         if !ct.has_infer_types_or_consts() {\n             ct // micro-optimize -- if there is nothing in this const that this fold affects...\n         } else {\n@@ -98,7 +98,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticRegionResolver<'a, 'tcx> {\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n         if !ct.has_infer_regions() {\n             ct // micro-optimize -- if there is nothing in this const that this fold affects...\n         } else {\n@@ -218,15 +218,12 @@ impl<'a, 'tcx> FallibleTypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n         }\n     }\n \n-    fn try_fold_const(\n-        &mut self,\n-        c: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+    fn try_fold_const(&mut self, c: ty::Const<'tcx>) -> Result<ty::Const<'tcx>, Self::Error> {\n         if !c.needs_infer() {\n             Ok(c) // micro-optimize -- if there is nothing in this const that this fold affects...\n         } else {\n             let c = self.infcx.shallow_resolve(c);\n-            match c.val {\n+            match c.val() {\n                 ty::ConstKind::Infer(InferConst::Var(vid)) => {\n                     return Err(FixupError::UnresolvedConst(vid));\n                 }"}, {"sha": "9ec1b3390d0ad3cf8aea208d765d6759ae19c4d0", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -151,9 +151,9 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n \n     fn consts(\n         &mut self,\n-        a: &'tcx ty::Const<'tcx>,\n-        b: &'tcx ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        a: ty::Const<'tcx>,\n+        b: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n         self.fields.infcx.super_combine_consts(self, a, b)\n     }\n \n@@ -170,7 +170,7 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n }\n \n impl<'tcx> ConstEquateRelation<'tcx> for Sub<'_, '_, 'tcx> {\n-    fn const_equate_obligation(&mut self, a: &'tcx ty::Const<'tcx>, b: &'tcx ty::Const<'tcx>) {\n+    fn const_equate_obligation(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>) {\n         self.fields.add_const_equate_obligation(self.a_is_expected, a, b);\n     }\n }"}, {"sha": "85bb727a6c8048dac439d5ff02d65dbec78f089e", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -101,7 +101,7 @@ pub enum FulfillmentErrorCode<'tcx> {\n     CodeSelectionError(SelectionError<'tcx>),\n     CodeProjectionError(MismatchedProjectionTypes<'tcx>),\n     CodeSubtypeError(ExpectedFound<Ty<'tcx>>, TypeError<'tcx>), // always comes from a SubtypePredicate\n-    CodeConstEquateError(ExpectedFound<&'tcx Const<'tcx>>, TypeError<'tcx>),\n+    CodeConstEquateError(ExpectedFound<Const<'tcx>>, TypeError<'tcx>),\n     CodeAmbiguity,\n }\n "}, {"sha": "a397db7f32921d733a573af5d95d0ab2f85f9982", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -2050,7 +2050,7 @@ impl ExplicitOutlivesRequirements {\n         inferred_outlives\n             .iter()\n             .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n-                ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => match a {\n+                ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => match *a {\n                     ty::ReEarlyBound(ebr) if ebr.index == index => Some(b),\n                     _ => None,\n                 },\n@@ -2111,10 +2111,10 @@ impl ExplicitOutlivesRequirements {\n                 if let hir::GenericBound::Outlives(lifetime) = bound {\n                     let is_inferred = match tcx.named_region(lifetime.hir_id) {\n                         Some(Region::Static) if infer_static => {\n-                            inferred_outlives.iter().any(|r| matches!(r, ty::ReStatic))\n+                            inferred_outlives.iter().any(|r| matches!(**r, ty::ReStatic))\n                         }\n                         Some(Region::EarlyBound(index, ..)) => inferred_outlives.iter().any(|r| {\n-                            if let ty::ReEarlyBound(ebr) = r { ebr.index == index } else { false }\n+                            if let ty::ReEarlyBound(ebr) = **r { ebr.index == index } else { false }\n                         }),\n                         _ => false,\n                     };\n@@ -2895,26 +2895,22 @@ impl ClashingExternDeclarations {\n                         }\n                         (Array(a_ty, a_const), Array(b_ty, b_const)) => {\n                             // For arrays, we also check the constness of the type.\n-                            a_const.val == b_const.val\n-                                && structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n+                            a_const.val() == b_const.val()\n+                                && structurally_same_type_impl(seen_types, cx, *a_ty, *b_ty, ckind)\n                         }\n                         (Slice(a_ty), Slice(b_ty)) => {\n-                            structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n+                            structurally_same_type_impl(seen_types, cx, *a_ty, *b_ty, ckind)\n                         }\n                         (RawPtr(a_tymut), RawPtr(b_tymut)) => {\n                             a_tymut.mutbl == b_tymut.mutbl\n                                 && structurally_same_type_impl(\n-                                    seen_types,\n-                                    cx,\n-                                    &a_tymut.ty,\n-                                    &b_tymut.ty,\n-                                    ckind,\n+                                    seen_types, cx, a_tymut.ty, b_tymut.ty, ckind,\n                                 )\n                         }\n                         (Ref(_a_region, a_ty, a_mut), Ref(_b_region, b_ty, b_mut)) => {\n                             // For structural sameness, we don't need the region to be same.\n                             a_mut == b_mut\n-                                && structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n+                                && structurally_same_type_impl(seen_types, cx, *a_ty, *b_ty, ckind)\n                         }\n                         (FnDef(..), FnDef(..)) => {\n                             let a_poly_sig = a.fn_sig(tcx);\n@@ -2927,7 +2923,7 @@ impl ClashingExternDeclarations {\n                             (a_sig.abi, a_sig.unsafety, a_sig.c_variadic)\n                                 == (b_sig.abi, b_sig.unsafety, b_sig.c_variadic)\n                                 && a_sig.inputs().iter().eq_by(b_sig.inputs().iter(), |a, b| {\n-                                    structurally_same_type_impl(seen_types, cx, a, b, ckind)\n+                                    structurally_same_type_impl(seen_types, cx, *a, *b, ckind)\n                                 })\n                                 && structurally_same_type_impl(\n                                     seen_types,"}, {"sha": "d2d853efda2d25db2c69b2d029118b65939c5c76", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -974,7 +974,7 @@ impl<'tcx> LateContext<'tcx> {\n                 Ok(())\n             }\n \n-            fn print_const(self, _ct: &'tcx ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n+            fn print_const(self, _ct: ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n                 Ok(())\n             }\n "}, {"sha": "c47fdc063a96544d22a4f2dbac7f0dcc1d4ab517", "filename": "compiler/rustc_lint/src/pass_by_value.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -7,9 +7,10 @@ use rustc_middle::ty;\n use rustc_span::symbol::sym;\n \n declare_tool_lint! {\n-    /// The `rustc_pass_by_value` lint marks a type with `#[rustc_pass_by_value]` requiring it to always be passed by value.\n-    /// This is usually used for types that are thin wrappers around references, so there is no benefit to an extra\n-    /// layer of indirection. (Example: `Ty` which is a reference to a `TyS`)\n+    /// The `rustc_pass_by_value` lint marks a type with `#[rustc_pass_by_value]` requiring it to\n+    /// always be passed by value. This is usually used for types that are thin wrappers around\n+    /// references, so there is no benefit to an extra layer of indirection. (Example: `Ty` which\n+    /// is a reference to an `Interned<TyS>`)\n     pub rustc::PASS_BY_VALUE,\n     Warn,\n     \"pass by reference of a type flagged as `#[rustc_pass_by_value]`\","}, {"sha": "fc88e8cd912ea92aed4f12f3303582f4e7e06db9", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -249,7 +249,7 @@ fn report_bin_hex_error(\n             ));\n         }\n         if let Some(sugg_ty) =\n-            get_type_suggestion(&cx.typeck_results().node_type(expr.hir_id), val, negative)\n+            get_type_suggestion(cx.typeck_results().node_type(expr.hir_id), val, negative)\n         {\n             if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n                 let (sans_suffix, _) = repr_str.split_at(pos);\n@@ -367,7 +367,7 @@ fn lint_int_literal<'tcx>(\n                 max,\n             ));\n             if let Some(sugg_ty) =\n-                get_type_suggestion(&cx.typeck_results().node_type(e.hir_id), v, negative)\n+                get_type_suggestion(cx.typeck_results().node_type(e.hir_id), v, negative)\n             {\n                 err.help(&format!(\"consider using the type `{}` instead\", sugg_ty));\n             }\n@@ -1095,7 +1095,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     }\n                 }\n                 for arg in sig.inputs() {\n-                    let r = self.check_type_for_ffi(cache, arg);\n+                    let r = self.check_type_for_ffi(cache, *arg);\n                     match r {\n                         FfiSafe => {}\n                         _ => {\n@@ -1257,7 +1257,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         let sig = self.cx.tcx.erase_late_bound_regions(sig);\n \n         for (input_ty, input_hir) in iter::zip(sig.inputs(), decl.inputs) {\n-            self.check_type_for_ffi_and_report_errors(input_hir.span, input_ty, false, false);\n+            self.check_type_for_ffi_and_report_errors(input_hir.span, *input_ty, false, false);\n         }\n \n         if let hir::FnRetTy::Return(ref ret_hir) = decl.output {"}, {"sha": "9b0272e7fd3b491c35f624249eac1955716d2fb6", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -117,7 +117,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     promoted_mir => { tcx.arena.alloc(cdata.get_promoted_mir(tcx, def_id.index)) }\n     thir_abstract_const => { cdata.get_thir_abstract_const(tcx, def_id.index) }\n     unused_generic_params => { cdata.get_unused_generic_params(def_id.index) }\n-    const_param_default => { tcx.mk_const(cdata.get_const_param_default(tcx, def_id.index)) }\n+    const_param_default => { cdata.get_const_param_default(tcx, def_id.index) }\n     mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n     fn_sig => { cdata.fn_sig(def_id.index, tcx) }\n     inherent_impls => { cdata.get_inherent_implementations_for_type(tcx, def_id.index) }"}, {"sha": "c4e6734aa0fa71efa23fc2c361a991e462889b35", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -88,7 +88,8 @@ macro_rules! arena_types {\n \n             // Interned types\n             [] tys: rustc_middle::ty::TyS<'tcx>,\n-            [] predicates: rustc_middle::ty::PredicateInner<'tcx>,\n+            [] predicates: rustc_middle::ty::PredicateS<'tcx>,\n+            [] consts: rustc_middle::ty::ConstS<'tcx>,\n \n             // Note that this deliberately duplicates items in the `rustc_hir::arena`,\n             // since we need to allocate this type on both the `rustc_hir` arena"}, {"sha": "419ed429246ac889076f23e8bbdf432eda48c7a5", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -328,8 +328,8 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n                         tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n                     }\n                     GenericArgKind::Const(ct) => tcx\n-                        .mk_const(ty::Const {\n-                            ty: ct.ty,\n+                        .mk_const(ty::ConstS {\n+                            ty: ct.ty(),\n                             val: ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i)),\n                         })\n                         .into(),"}, {"sha": "7a6d08fcc349b36a2ac9ff25e0062d36508f9285", "filename": "compiler/rustc_middle/src/infer/unify_key.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -95,14 +95,14 @@ pub enum ConstVariableOriginKind {\n \n #[derive(Copy, Clone, Debug)]\n pub enum ConstVariableValue<'tcx> {\n-    Known { value: &'tcx ty::Const<'tcx> },\n+    Known { value: ty::Const<'tcx> },\n     Unknown { universe: ty::UniverseIndex },\n }\n \n impl<'tcx> ConstVariableValue<'tcx> {\n     /// If this value is known, returns the const it is known to be.\n     /// Otherwise, `None`.\n-    pub fn known(&self) -> Option<&'tcx ty::Const<'tcx>> {\n+    pub fn known(&self) -> Option<ty::Const<'tcx>> {\n         match *self {\n             ConstVariableValue::Unknown { .. } => None,\n             ConstVariableValue::Known { value } => Some(value),\n@@ -130,7 +130,7 @@ impl<'tcx> UnifyKey for ty::ConstVid<'tcx> {\n }\n \n impl<'tcx> UnifyValue for ConstVarValue<'tcx> {\n-    type Error = (&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>);\n+    type Error = (ty::Const<'tcx>, ty::Const<'tcx>);\n \n     fn unify_values(&value1: &Self, &value2: &Self) -> Result<Self, Self::Error> {\n         Ok(match (value1.val, value2.val) {\n@@ -162,18 +162,18 @@ impl<'tcx> UnifyValue for ConstVarValue<'tcx> {\n     }\n }\n \n-impl<'tcx> EqUnifyValue for &'tcx ty::Const<'tcx> {}\n+impl<'tcx> EqUnifyValue for ty::Const<'tcx> {}\n \n pub fn replace_if_possible<'tcx, V, L>(\n     table: &mut UnificationTable<InPlace<ty::ConstVid<'tcx>, V, L>>,\n-    c: &'tcx ty::Const<'tcx>,\n-) -> &'tcx ty::Const<'tcx>\n+    c: ty::Const<'tcx>,\n+) -> ty::Const<'tcx>\n where\n     V: snapshot_vec::VecLike<unify::Delegate<ty::ConstVid<'tcx>>>,\n     L: UndoLogs<snapshot_vec::UndoLog<unify::Delegate<ty::ConstVid<'tcx>>>>,\n {\n-    if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = c {\n-        match table.probe_value(*vid).val.known() {\n+    if let ty::ConstKind::Infer(InferConst::Var(vid)) = c.val() {\n+        match table.probe_value(vid).val.known() {\n             Some(c) => c,\n             None => c,\n         }"}, {"sha": "e80dfab7c48ec43d8c7699793514867555b3bbc8", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -2185,7 +2185,7 @@ pub enum Rvalue<'tcx> {\n     Use(Operand<'tcx>),\n \n     /// [x; 32]\n-    Repeat(Operand<'tcx>, &'tcx ty::Const<'tcx>),\n+    Repeat(Operand<'tcx>, ty::Const<'tcx>),\n \n     /// &x or &mut x\n     Ref(Region<'tcx>, BorrowKind, Place<'tcx>),\n@@ -2335,7 +2335,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n         match *self {\n             Use(ref place) => write!(fmt, \"{:?}\", place),\n-            Repeat(ref a, ref b) => {\n+            Repeat(ref a, b) => {\n                 write!(fmt, \"[{:?}; \", a)?;\n                 pretty_print_const(b, fmt, false)?;\n                 write!(fmt, \"]\")\n@@ -2514,15 +2514,15 @@ pub struct Constant<'tcx> {\n #[derive(Lift)]\n pub enum ConstantKind<'tcx> {\n     /// This constant came from the type system\n-    Ty(&'tcx ty::Const<'tcx>),\n+    Ty(ty::Const<'tcx>),\n     /// This constant cannot go back into the type system, as it represents\n     /// something the type system cannot handle (e.g. pointers).\n     Val(interpret::ConstValue<'tcx>, Ty<'tcx>),\n }\n \n impl<'tcx> Constant<'tcx> {\n     pub fn check_static_ptr(&self, tcx: TyCtxt<'_>) -> Option<DefId> {\n-        match self.literal.const_for_ty()?.val.try_to_scalar() {\n+        match self.literal.const_for_ty()?.val().try_to_scalar() {\n             Some(Scalar::Ptr(ptr, _size)) => match tcx.global_alloc(ptr.provenance) {\n                 GlobalAlloc::Static(def_id) => {\n                     assert!(!tcx.is_thread_local_static(def_id));\n@@ -2539,33 +2539,33 @@ impl<'tcx> Constant<'tcx> {\n     }\n }\n \n-impl<'tcx> From<&'tcx ty::Const<'tcx>> for ConstantKind<'tcx> {\n+impl<'tcx> From<ty::Const<'tcx>> for ConstantKind<'tcx> {\n     #[inline]\n-    fn from(ct: &'tcx ty::Const<'tcx>) -> Self {\n+    fn from(ct: ty::Const<'tcx>) -> Self {\n         Self::Ty(ct)\n     }\n }\n \n impl<'tcx> ConstantKind<'tcx> {\n     /// Returns `None` if the constant is not trivially safe for use in the type system.\n-    pub fn const_for_ty(&self) -> Option<&'tcx ty::Const<'tcx>> {\n+    pub fn const_for_ty(&self) -> Option<ty::Const<'tcx>> {\n         match self {\n-            ConstantKind::Ty(c) => Some(c),\n+            ConstantKind::Ty(c) => Some(*c),\n             ConstantKind::Val(..) => None,\n         }\n     }\n \n     pub fn ty(&self) -> Ty<'tcx> {\n         match self {\n-            ConstantKind::Ty(c) => c.ty,\n-            ConstantKind::Val(_, ty) => ty,\n+            ConstantKind::Ty(c) => c.ty(),\n+            ConstantKind::Val(_, ty) => *ty,\n         }\n     }\n \n     #[inline]\n     pub fn try_to_value(self) -> Option<interpret::ConstValue<'tcx>> {\n         match self {\n-            ConstantKind::Ty(c) => c.val.try_to_value(),\n+            ConstantKind::Ty(c) => c.val().try_to_value(),\n             ConstantKind::Val(val, _) => Some(val),\n         }\n     }\n@@ -2829,7 +2829,7 @@ impl<'tcx> Display for ConstantKind<'tcx> {\n }\n \n fn pretty_print_const<'tcx>(\n-    c: &ty::Const<'tcx>,\n+    c: ty::Const<'tcx>,\n     fmt: &mut Formatter<'_>,\n     print_types: bool,\n ) -> fmt::Result {"}, {"sha": "4f29ef7a6402c862693d19ed7939ccaeb8847a14", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::mir::interpret::{\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::MirSource;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{self, TyCtxt, TyS, TypeFoldable, TypeVisitor};\n+use rustc_middle::ty::{self, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_target::abi::Size;\n use std::ops::ControlFlow;\n \n@@ -427,12 +427,12 @@ impl<'tcx> ExtraComments<'tcx> {\n     }\n }\n \n-fn use_verbose<'tcx>(ty: &&TyS<'tcx>, fn_def: bool) -> bool {\n-    match ty.kind() {\n+fn use_verbose<'tcx>(ty: Ty<'tcx>, fn_def: bool) -> bool {\n+    match *ty.kind() {\n         ty::Int(_) | ty::Uint(_) | ty::Bool | ty::Char | ty::Float(_) => false,\n         // Unit type\n         ty::Tuple(g_args) if g_args.is_empty() => false,\n-        ty::Tuple(g_args) => g_args.iter().any(|g_arg| use_verbose(&g_arg.expect_ty(), fn_def)),\n+        ty::Tuple(g_args) => g_args.iter().any(|g_arg| use_verbose(g_arg.expect_ty(), fn_def)),\n         ty::Array(ty, _) => use_verbose(ty, fn_def),\n         ty::FnDef(..) => fn_def,\n         _ => true,\n@@ -443,7 +443,7 @@ impl<'tcx> Visitor<'tcx> for ExtraComments<'tcx> {\n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.super_constant(constant, location);\n         let Constant { span, user_ty, literal } = constant;\n-        if use_verbose(&literal.ty(), true) {\n+        if use_verbose(literal.ty(), true) {\n             self.push(\"mir::Constant\");\n             self.push(&format!(\n                 \"+ span: {}\",\n@@ -462,9 +462,10 @@ impl<'tcx> Visitor<'tcx> for ExtraComments<'tcx> {\n         }\n     }\n \n-    fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, _: Location) {\n+    fn visit_const(&mut self, constant: ty::Const<'tcx>, _: Location) {\n         self.super_const(constant);\n-        let ty::Const { ty, val, .. } = constant;\n+        let ty = constant.ty();\n+        let val = constant.val();\n         if use_verbose(ty, false) {\n             self.push(\"ty::Const\");\n             self.push(&format!(\"+ ty: {:?}\", ty));\n@@ -683,8 +684,8 @@ pub fn write_allocations<'tcx>(\n     }\n     struct CollectAllocIds(BTreeSet<AllocId>);\n     impl<'tcx> TypeVisitor<'tcx> for CollectAllocIds {\n-        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            if let ty::ConstKind::Value(val) = c.val {\n+        fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            if let ty::ConstKind::Value(val) = c.val() {\n                 self.0.extend(alloc_ids_from_const(val));\n             }\n             c.super_visit_with(self)"}, {"sha": "5c616425957df5fef5242920d5327109e76f435b", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -387,7 +387,7 @@ pub enum ClosureOutlivesSubject<'tcx> {\n #[derive(Copy, Clone, Debug, HashStable)]\n pub struct DestructuredConst<'tcx> {\n     pub variant: Option<VariantIdx>,\n-    pub fields: &'tcx [&'tcx ty::Const<'tcx>],\n+    pub fields: &'tcx [ty::Const<'tcx>],\n }\n \n /// Coverage information summarized from a MIR if instrumented for source code coverage (see"}, {"sha": "302921cc4aa721fb30da49259460fe1a969e05d2", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -57,7 +57,7 @@ impl<'tcx> PlaceTy<'tcx> {\n     /// `PlaceElem`, where we can just use the `Ty` that is already\n     /// stored inline on field projection elems.\n     pub fn projection_ty(self, tcx: TyCtxt<'tcx>, elem: PlaceElem<'tcx>) -> PlaceTy<'tcx> {\n-        self.projection_ty_core(tcx, ty::ParamEnv::empty(), &elem, |_, _, ty| ty)\n+        self.projection_ty_core(tcx, ty::ParamEnv::empty(), &elem, |_, _, &ty| ty)\n     }\n \n     /// `place_ty.projection_ty_core(tcx, elem, |...| { ... })`\n@@ -93,11 +93,11 @@ impl<'tcx> PlaceTy<'tcx> {\n             ProjectionElem::Subslice { from, to, from_end } => {\n                 PlaceTy::from_ty(match self.ty.kind() {\n                     ty::Slice(..) => self.ty,\n-                    ty::Array(inner, _) if !from_end => tcx.mk_array(inner, (to - from) as u64),\n+                    ty::Array(inner, _) if !from_end => tcx.mk_array(*inner, (to - from) as u64),\n                     ty::Array(inner, size) if from_end => {\n                         let size = size.eval_usize(tcx, param_env);\n                         let len = size - (from as u64) - (to as u64);\n-                        tcx.mk_array(inner, len)\n+                        tcx.mk_array(*inner, len)\n                     }\n                     _ => bug!(\"cannot subslice non-array type: `{:?}`\", self),\n                 })"}, {"sha": "ae94bd121f9535bac46429ea4075e3bbf678afe2", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -430,7 +430,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n     pub fn as_switch(&self) -> Option<(&Operand<'tcx>, Ty<'tcx>, &SwitchTargets)> {\n         match self {\n             TerminatorKind::SwitchInt { discr, switch_ty, targets } => {\n-                Some((discr, switch_ty, targets))\n+                Some((discr, *switch_ty, targets))\n             }\n             _ => None,\n         }"}, {"sha": "a618800cc1bd2c12a51a8b830f77ad276227f834", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -194,13 +194,13 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_region(&mut self,\n-                            region: & $($mutability)? ty::Region<'tcx>,\n+                            region: $(& $mutability)? ty::Region<'tcx>,\n                             _: Location) {\n                 self.super_region(region);\n             }\n \n             fn visit_const(&mut self,\n-                           constant: & $($mutability)? &'tcx ty::Const<'tcx>,\n+                           constant: $(& $mutability)? ty::Const<'tcx>,\n                            _: Location) {\n                 self.super_const(constant);\n             }\n@@ -242,7 +242,7 @@ macro_rules! make_mir_visitor {\n             ) {\n                 let span = body.span;\n                 if let Some(gen) = &$($mutability)? body.generator {\n-                    if let Some(yield_ty) = &$($mutability)? gen.yield_ty {\n+                    if let Some(yield_ty) = $(& $mutability)? gen.yield_ty {\n                         self.visit_ty(\n                             yield_ty,\n                             TyContext::YieldTy(SourceInfo::outermost(span))\n@@ -266,7 +266,7 @@ macro_rules! make_mir_visitor {\n                 }\n \n                 self.visit_ty(\n-                    &$($mutability)? body.return_ty(),\n+                    $(& $mutability)? body.return_ty(),\n                     TyContext::ReturnTy(SourceInfo::outermost(body.span))\n                 );\n \n@@ -355,7 +355,7 @@ macro_rules! make_mir_visitor {\n                         ty::InstanceDef::DropGlue(_def_id, Some(ty)) |\n                         ty::InstanceDef::CloneShim(_def_id, ty) => {\n                             // FIXME(eddyb) use a better `TyContext` here.\n-                            self.visit_ty(ty, TyContext::Location(location));\n+                            self.visit_ty($(& $mutability)? *ty, TyContext::Location(location));\n                         }\n                     }\n                     self.visit_substs(callee_substs, location);\n@@ -487,7 +487,7 @@ macro_rules! make_mir_visitor {\n                         targets: _\n                     } => {\n                         self.visit_operand(discr, location);\n-                        self.visit_ty(switch_ty, TyContext::Location(location));\n+                        self.visit_ty($(& $mutability)? *switch_ty, TyContext::Location(location));\n                     }\n \n                     TerminatorKind::Drop {\n@@ -641,7 +641,7 @@ macro_rules! make_mir_visitor {\n                     Rvalue::ThreadLocalRef(_) => {}\n \n                     Rvalue::Ref(r, bk, path) => {\n-                        self.visit_region(r, location);\n+                        self.visit_region($(& $mutability)? *r, location);\n                         let ctx = match bk {\n                             BorrowKind::Shared => PlaceContext::NonMutatingUse(\n                                 NonMutatingUseContext::SharedBorrow\n@@ -680,7 +680,7 @@ macro_rules! make_mir_visitor {\n \n                     Rvalue::Cast(_cast_kind, operand, ty) => {\n                         self.visit_operand(operand, location);\n-                        self.visit_ty(ty, TyContext::Location(location));\n+                        self.visit_ty($(& $mutability)? *ty, TyContext::Location(location));\n                     }\n \n                     Rvalue::BinaryOp(_bin_op, box(lhs, rhs))\n@@ -702,14 +702,14 @@ macro_rules! make_mir_visitor {\n                     }\n \n                     Rvalue::NullaryOp(_op, ty) => {\n-                        self.visit_ty(ty, TyContext::Location(location));\n+                        self.visit_ty($(& $mutability)? *ty, TyContext::Location(location));\n                     }\n \n                     Rvalue::Aggregate(kind, operands) => {\n                         let kind = &$($mutability)? **kind;\n                         match kind {\n                             AggregateKind::Array(ty) => {\n-                                self.visit_ty(ty, TyContext::Location(location));\n+                                self.visit_ty($(& $mutability)? *ty, TyContext::Location(location));\n                             }\n                             AggregateKind::Tuple => {\n                             }\n@@ -744,7 +744,7 @@ macro_rules! make_mir_visitor {\n \n                     Rvalue::ShallowInitBox(operand, ty) => {\n                         self.visit_operand(operand, location);\n-                        self.visit_ty(ty, TyContext::Location(location));\n+                        self.visit_ty($(& $mutability)? *ty, TyContext::Location(location));\n                     }\n                 }\n             }\n@@ -815,7 +815,7 @@ macro_rules! make_mir_visitor {\n                     is_block_tail: _,\n                 } = local_decl;\n \n-                self.visit_ty(ty, TyContext::LocalDecl {\n+                self.visit_ty($(& $mutability)? *ty, TyContext::LocalDecl {\n                     local,\n                     source_info: *source_info,\n                 });\n@@ -864,8 +864,8 @@ macro_rules! make_mir_visitor {\n                 self.visit_span(span);\n                 drop(user_ty); // no visit method for this\n                 match literal {\n-                    ConstantKind::Ty(ct) => self.visit_const(ct, location),\n-                    ConstantKind::Val(_, t) => self.visit_ty(t, TyContext::Location(location)),\n+                    ConstantKind::Ty(ct) => self.visit_const($(& $mutability)? *ct, location),\n+                    ConstantKind::Val(_, ty) => self.visit_ty($(& $mutability)? *ty, TyContext::Location(location)),\n                 }\n             }\n \n@@ -894,16 +894,16 @@ macro_rules! make_mir_visitor {\n                 ty: & $($mutability)? CanonicalUserTypeAnnotation<'tcx>,\n             ) {\n                 self.visit_span(& $($mutability)? ty.span);\n-                self.visit_ty(& $($mutability)? ty.inferred_ty, TyContext::UserTy(ty.span));\n+                self.visit_ty($(& $mutability)? ty.inferred_ty, TyContext::UserTy(ty.span));\n             }\n \n             fn super_ty(&mut self, _ty: $(& $mutability)? Ty<'tcx>) {\n             }\n \n-            fn super_region(&mut self, _region: & $($mutability)? ty::Region<'tcx>) {\n+            fn super_region(&mut self, _region: $(& $mutability)? ty::Region<'tcx>) {\n             }\n \n-            fn super_const(&mut self, _const: & $($mutability)? &'tcx ty::Const<'tcx>) {\n+            fn super_const(&mut self, _const: $(& $mutability)? ty::Const<'tcx>) {\n             }\n \n             fn super_substs(&mut self, _substs: & $($mutability)? SubstsRef<'tcx>) {"}, {"sha": "77eda70bcd15138d20de582fbbfefc17a2fd5fdb", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -113,7 +113,7 @@ rustc_queries! {\n \n     /// Given the def_id of a const-generic parameter, computes the associated default const\n     /// parameter. e.g. `fn example<const N: usize=3>` called on `N` would return `3`.\n-    query const_param_default(param: DefId) -> &'tcx ty::Const<'tcx> {\n+    query const_param_default(param: DefId) -> ty::Const<'tcx> {\n         desc { |tcx| \"compute const default for a given parameter `{}`\", tcx.def_path_str(param)  }\n         separate_provide_extern\n     }\n@@ -926,7 +926,7 @@ rustc_queries! {\n     /// Destructure a constant ADT or array into its variant index and its\n     /// field values.\n     query destructure_const(\n-        key: ty::ParamEnvAnd<'tcx, &'tcx ty::Const<'tcx>>\n+        key: ty::ParamEnvAnd<'tcx, ty::Const<'tcx>>\n     ) -> mir::DestructuredConst<'tcx> {\n         desc { \"destructure constant\" }\n         remap_env_constness\n@@ -935,8 +935,8 @@ rustc_queries! {\n     /// Dereference a constant reference or raw pointer and turn the result into a constant\n     /// again.\n     query deref_const(\n-        key: ty::ParamEnvAnd<'tcx, &'tcx ty::Const<'tcx>>\n-    ) -> &'tcx ty::Const<'tcx> {\n+        key: ty::ParamEnvAnd<'tcx, ty::Const<'tcx>>\n+    ) -> ty::Const<'tcx> {\n         desc { \"deref constant\" }\n         remap_env_constness\n     }\n@@ -947,7 +947,7 @@ rustc_queries! {\n \n     query lit_to_const(\n         key: LitToConstInput<'tcx>\n-    ) -> Result<&'tcx ty::Const<'tcx>, LitToConstError> {\n+    ) -> Result<ty::Const<'tcx>, LitToConstError> {\n         desc { \"converting literal to const\" }\n     }\n \n@@ -1146,33 +1146,33 @@ rustc_queries! {\n         desc { \"computing whether `{}` is `Copy`\", env.value }\n         remap_env_constness\n     }\n-    /// Query backing `TyS::is_sized`.\n+    /// Query backing `Ty::is_sized`.\n     query is_sized_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n         desc { \"computing whether `{}` is `Sized`\", env.value }\n         remap_env_constness\n     }\n-    /// Query backing `TyS::is_freeze`.\n+    /// Query backing `Ty::is_freeze`.\n     query is_freeze_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n         desc { \"computing whether `{}` is freeze\", env.value }\n         remap_env_constness\n     }\n-    /// Query backing `TyS::is_unpin`.\n+    /// Query backing `Ty::is_unpin`.\n     query is_unpin_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n         desc { \"computing whether `{}` is `Unpin`\", env.value }\n         remap_env_constness\n     }\n-    /// Query backing `TyS::needs_drop`.\n+    /// Query backing `Ty::needs_drop`.\n     query needs_drop_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n         desc { \"computing whether `{}` needs drop\", env.value }\n         remap_env_constness\n     }\n-    /// Query backing `TyS::has_significant_drop_raw`.\n+    /// Query backing `Ty::has_significant_drop_raw`.\n     query has_significant_drop_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n         desc { \"computing whether `{}` has a significant drop\", env.value }\n         remap_env_constness\n     }\n \n-    /// Query backing `TyS::is_structural_eq_shallow`.\n+    /// Query backing `Ty::is_structural_eq_shallow`.\n     ///\n     /// This is only correct for ADTs. Call `is_structural_eq_shallow` to handle all types\n     /// correctly."}, {"sha": "40dce281c82bf2460c6885bfadde72160f236a5d", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -368,12 +368,12 @@ pub enum ExprKind<'tcx> {\n     },\n     /// An inline `const` block, e.g. `const {}`.\n     ConstBlock {\n-        value: &'tcx Const<'tcx>,\n+        value: Const<'tcx>,\n     },\n     /// An array literal constructed from one repeated element, e.g. `[1; 5]`.\n     Repeat {\n         value: ExprId,\n-        count: &'tcx Const<'tcx>,\n+        count: Const<'tcx>,\n     },\n     /// An array, e.g. `[a, b, c, d]`.\n     Array {\n@@ -407,7 +407,7 @@ pub enum ExprKind<'tcx> {\n     },\n     /// A literal.\n     Literal {\n-        literal: &'tcx Const<'tcx>,\n+        literal: Const<'tcx>,\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n         /// The `DefId` of the `const` item this literal\n         /// was produced from, if this is not a user-written\n@@ -419,7 +419,7 @@ pub enum ExprKind<'tcx> {\n     /// This is only distinguished from `Literal` so that we can register some\n     /// info for diagnostics.\n     StaticRef {\n-        literal: &'tcx Const<'tcx>,\n+        literal: Const<'tcx>,\n         def_id: DefId,\n     },\n     /// Inline assembly, i.e. `asm!()`.\n@@ -501,7 +501,7 @@ pub enum InlineAsmOperand<'tcx> {\n         out_expr: Option<ExprId>,\n     },\n     Const {\n-        value: &'tcx Const<'tcx>,\n+        value: Const<'tcx>,\n         span: Span,\n     },\n     SymFn {\n@@ -640,7 +640,7 @@ pub enum PatKind<'tcx> {\n     /// * Opaque constants, that must not be matched structurally. So anything that does not derive\n     ///   `PartialEq` and `Eq`.\n     Constant {\n-        value: &'tcx ty::Const<'tcx>,\n+        value: ty::Const<'tcx>,\n     },\n \n     Range(PatRange<'tcx>),\n@@ -670,8 +670,8 @@ pub enum PatKind<'tcx> {\n \n #[derive(Copy, Clone, Debug, PartialEq, HashStable)]\n pub struct PatRange<'tcx> {\n-    pub lo: &'tcx ty::Const<'tcx>,\n-    pub hi: &'tcx ty::Const<'tcx>,\n+    pub lo: ty::Const<'tcx>,\n+    pub hi: ty::Const<'tcx>,\n     pub end: RangeEnd,\n }\n "}, {"sha": "e3d004ed133e100e8ada645c6e1a60934a3f6de3", "filename": "compiler/rustc_middle/src/thir/abstract_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -22,7 +22,7 @@ pub enum CastKind {\n /// A node of an `AbstractConst`.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n pub enum Node<'tcx> {\n-    Leaf(&'tcx ty::Const<'tcx>),\n+    Leaf(ty::Const<'tcx>),\n     Binop(mir::BinOp, NodeId, NodeId),\n     UnaryOp(mir::UnOp, NodeId),\n     FunctionCall(NodeId, &'tcx [NodeId]),"}, {"sha": "95489ac3ab2c64c8413680dd4764fa6ef794318e", "filename": "compiler/rustc_middle/src/thir/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -26,7 +26,7 @@ pub trait Visitor<'a, 'tcx: 'a>: Sized {\n         walk_pat(self, pat);\n     }\n \n-    fn visit_const(&mut self, _cnst: &'tcx Const<'tcx>) {}\n+    fn visit_const(&mut self, _cnst: Const<'tcx>) {}\n }\n \n pub fn walk_expr<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, expr: &Expr<'tcx>) {\n@@ -209,7 +209,7 @@ pub fn walk_pat<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, pat: &Pat<'\n                 visitor.visit_pat(&subpattern.pattern);\n             }\n         }\n-        Constant { value } => visitor.visit_const(value),\n+        Constant { value } => visitor.visit_const(*value),\n         Range(range) => {\n             visitor.visit_const(range.lo);\n             visitor.visit_const(range.hi);"}, {"sha": "738c48dbb5c59c6a336e36a84ddfeea9aaa7c1dc", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -77,7 +77,7 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n             ) => Ok(a),\n \n             (&ty::Infer(_), _) | (_, &ty::Infer(_)) => {\n-                Err(TypeError::Sorts(relate::expected_found(self, &a, &b)))\n+                Err(TypeError::Sorts(relate::expected_found(self, a, b)))\n             }\n \n             (&ty::Error(_), _) | (_, &ty::Error(_)) => Ok(self.tcx().ty_error()),\n@@ -88,21 +88,21 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n \n     fn consts(\n         &mut self,\n-        a: &'tcx ty::Const<'tcx>,\n-        b: &'tcx ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        a: ty::Const<'tcx>,\n+        b: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n         debug!(\"{}.consts({:?}, {:?})\", self.tag(), a, b);\n         if a == b {\n             return Ok(a);\n         }\n \n-        match (a.val, b.val) {\n+        match (a.val(), b.val()) {\n             (_, ty::ConstKind::Infer(InferConst::Fresh(_))) => {\n                 return Ok(a);\n             }\n \n             (ty::ConstKind::Infer(_), _) | (_, ty::ConstKind::Infer(_)) => {\n-                return Err(TypeError::ConstMismatch(relate::expected_found(self, &a, &b)));\n+                return Err(TypeError::ConstMismatch(relate::expected_found(self, a, b)));\n             }\n \n             _ => {}"}, {"sha": "8ba6c1f67c94cc79046ec17e7005d1995081b4b5", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -116,7 +116,7 @@ impl<'tcx> ClosureKind {\n     }\n \n     /// Returns the representative scalar type for this closure kind.\n-    /// See `TyS::to_opt_closure_kind` for more details.\n+    /// See `Ty::to_opt_closure_kind` for more details.\n     pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match self {\n             ty::ClosureKind::Fn => tcx.types.i8,"}, {"sha": "ecd30ba441ff4c6afd892603087f4039c8ffb2f2", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -138,6 +138,18 @@ impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Predicate<'tcx> {\n     }\n }\n \n+impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Region<'tcx> {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+        self.kind().encode(e)\n+    }\n+}\n+\n+impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Const<'tcx> {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+        self.0.0.encode(e)\n+    }\n+}\n+\n impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for AllocId {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         e.encode_alloc_id(self)\n@@ -156,7 +168,6 @@ macro_rules! encodable_via_deref {\n \n encodable_via_deref! {\n     &'tcx ty::TypeckResults<'tcx>,\n-    ty::Region<'tcx>,\n     &'tcx traits::ImplSource<'tcx, ()>,\n     &'tcx mir::Body<'tcx>,\n     &'tcx mir::UnsafetyCheckResult,\n@@ -330,8 +341,8 @@ impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D>\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::Const<'tcx> {\n-    fn decode(decoder: &mut D) -> &'tcx Self {\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Const<'tcx> {\n+    fn decode(decoder: &mut D) -> Self {\n         decoder.tcx().mk_const(Decodable::decode(decoder))\n     }\n }"}, {"sha": "a794a8c0e0874f3c5c0b4e8b7a340a2509e72782", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 55, "deletions": 33, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -4,10 +4,12 @@ use crate::ty::{\n     self, InlineConstSubsts, InlineConstSubstsParts, InternalSubsts, ParamEnv, ParamEnvAnd, Ty,\n     TyCtxt, TypeFoldable,\n };\n+use rustc_data_structures::intern::Interned;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_macros::HashStable;\n+use std::fmt;\n \n mod int;\n mod kind;\n@@ -17,30 +19,50 @@ pub use int::*;\n pub use kind::*;\n pub use valtree::*;\n \n+/// Use this rather than `ConstS`, whenever possible.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable)]\n+#[cfg_attr(not(bootstrap), rustc_pass_by_value)]\n+pub struct Const<'tcx>(pub Interned<'tcx, ConstS<'tcx>>);\n+\n+impl<'tcx> fmt::Debug for Const<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // This reflects what `Const` looked liked before `Interned` was\n+        // introduced. We print it like this to avoid having to update expected\n+        // output in a lot of tests.\n+        write!(f, \"Const {{ ty: {:?}, val: {:?} }}\", self.ty(), self.val())\n+    }\n+}\n+\n /// Typed constant value.\n-#[derive(Copy, Clone, Debug, Hash, TyEncodable, TyDecodable, Eq, PartialEq, Ord, PartialOrd)]\n-#[derive(HashStable)]\n-pub struct Const<'tcx> {\n+#[derive(PartialEq, Eq, PartialOrd, Ord, Hash, HashStable, TyEncodable, TyDecodable)]\n+pub struct ConstS<'tcx> {\n     pub ty: Ty<'tcx>,\n-\n     pub val: ConstKind<'tcx>,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(Const<'_>, 48);\n+static_assert_size!(ConstS<'_>, 48);\n \n impl<'tcx> Const<'tcx> {\n+    pub fn ty(self) -> Ty<'tcx> {\n+        self.0.ty\n+    }\n+\n+    pub fn val(self) -> ConstKind<'tcx> {\n+        self.0.val\n+    }\n+\n     /// Literals and const generic parameters are eagerly converted to a constant, everything else\n     /// becomes `Unevaluated`.\n-    pub fn from_anon_const(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &'tcx Self {\n+    pub fn from_anon_const(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Self {\n         Self::from_opt_const_arg_anon_const(tcx, ty::WithOptConstParam::unknown(def_id))\n     }\n \n     #[instrument(skip(tcx), level = \"debug\")]\n     pub fn from_opt_const_arg_anon_const(\n         tcx: TyCtxt<'tcx>,\n         def: ty::WithOptConstParam<LocalDefId>,\n-    ) -> &'tcx Self {\n+    ) -> Self {\n         debug!(\"Const::from_anon_const(def={:?})\", def);\n \n         let body_id = match tcx.hir().get_by_def_id(def.did) {\n@@ -58,7 +80,7 @@ impl<'tcx> Const<'tcx> {\n \n         match Self::try_eval_lit_or_param(tcx, ty, expr) {\n             Some(v) => v,\n-            None => tcx.mk_const(ty::Const {\n+            None => tcx.mk_const(ty::ConstS {\n                 val: ty::ConstKind::Unevaluated(ty::Unevaluated {\n                     def: def.to_global(),\n                     substs: InternalSubsts::identity_for_item(tcx, def.did.to_def_id()),\n@@ -74,7 +96,7 @@ impl<'tcx> Const<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         ty: Ty<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n-    ) -> Option<&'tcx Self> {\n+    ) -> Option<Self> {\n         // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n         // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n         let expr = match &expr.kind {\n@@ -120,7 +142,7 @@ impl<'tcx> Const<'tcx> {\n                 let generics = tcx.generics_of(item_def_id.to_def_id());\n                 let index = generics.param_def_id_to_index[&def_id];\n                 let name = tcx.hir().name(hir_id);\n-                Some(tcx.mk_const(ty::Const {\n+                Some(tcx.mk_const(ty::ConstS {\n                     val: ty::ConstKind::Param(ty::ParamConst::new(index, name)),\n                     ty,\n                 }))\n@@ -129,7 +151,7 @@ impl<'tcx> Const<'tcx> {\n         }\n     }\n \n-    pub fn from_inline_const(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &'tcx Self {\n+    pub fn from_inline_const(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Self {\n         debug!(\"Const::from_inline_const(def_id={:?})\", def_id);\n \n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n@@ -155,7 +177,7 @@ impl<'tcx> Const<'tcx> {\n                 let substs =\n                     InlineConstSubsts::new(tcx, InlineConstSubstsParts { parent_substs, ty })\n                         .substs;\n-                tcx.mk_const(ty::Const {\n+                tcx.mk_const(ty::ConstS {\n                     val: ty::ConstKind::Unevaluated(ty::Unevaluated {\n                         def: ty::WithOptConstParam::unknown(def_id).to_global(),\n                         substs,\n@@ -171,19 +193,19 @@ impl<'tcx> Const<'tcx> {\n \n     /// Interns the given value as a constant.\n     #[inline]\n-    pub fn from_value(tcx: TyCtxt<'tcx>, val: ConstValue<'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n-        tcx.mk_const(Self { val: ConstKind::Value(val), ty })\n+    pub fn from_value(tcx: TyCtxt<'tcx>, val: ConstValue<'tcx>, ty: Ty<'tcx>) -> Self {\n+        tcx.mk_const(ConstS { val: ConstKind::Value(val), ty })\n     }\n \n     #[inline]\n     /// Interns the given scalar as a constant.\n-    pub fn from_scalar(tcx: TyCtxt<'tcx>, val: Scalar, ty: Ty<'tcx>) -> &'tcx Self {\n+    pub fn from_scalar(tcx: TyCtxt<'tcx>, val: Scalar, ty: Ty<'tcx>) -> Self {\n         Self::from_value(tcx, ConstValue::Scalar(val), ty)\n     }\n \n     #[inline]\n     /// Creates a constant with the given integer value and interns it.\n-    pub fn from_bits(tcx: TyCtxt<'tcx>, bits: u128, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> &'tcx Self {\n+    pub fn from_bits(tcx: TyCtxt<'tcx>, bits: u128, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> Self {\n         let size = tcx\n             .layout_of(ty)\n             .unwrap_or_else(|e| panic!(\"could not compute layout for {:?}: {:?}\", ty, e))\n@@ -193,19 +215,19 @@ impl<'tcx> Const<'tcx> {\n \n     #[inline]\n     /// Creates an interned zst constant.\n-    pub fn zero_sized(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n+    pub fn zero_sized(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Self {\n         Self::from_scalar(tcx, Scalar::ZST, ty)\n     }\n \n     #[inline]\n     /// Creates an interned bool constant.\n-    pub fn from_bool(tcx: TyCtxt<'tcx>, v: bool) -> &'tcx Self {\n+    pub fn from_bool(tcx: TyCtxt<'tcx>, v: bool) -> Self {\n         Self::from_bits(tcx, v as u128, ParamEnv::empty().and(tcx.types.bool))\n     }\n \n     #[inline]\n     /// Creates an interned usize constant.\n-    pub fn from_usize(tcx: TyCtxt<'tcx>, n: u64) -> &'tcx Self {\n+    pub fn from_usize(tcx: TyCtxt<'tcx>, n: u64) -> Self {\n         Self::from_bits(tcx, n as u128, ParamEnv::empty().and(tcx.types.usize))\n     }\n \n@@ -214,35 +236,35 @@ impl<'tcx> Const<'tcx> {\n     /// generics (or erroneous code) or if the value can't be represented as bits (e.g. because it\n     /// contains const generic parameters or pointers).\n     pub fn try_eval_bits(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         param_env: ParamEnv<'tcx>,\n         ty: Ty<'tcx>,\n     ) -> Option<u128> {\n-        assert_eq!(self.ty, ty);\n+        assert_eq!(self.ty(), ty);\n         let size = tcx.layout_of(param_env.with_reveal_all_normalized(tcx).and(ty)).ok()?.size;\n         // if `ty` does not depend on generic parameters, use an empty param_env\n-        self.val.eval(tcx, param_env).try_to_bits(size)\n+        self.val().eval(tcx, param_env).try_to_bits(size)\n     }\n \n     #[inline]\n-    pub fn try_eval_bool(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Option<bool> {\n-        self.val.eval(tcx, param_env).try_to_bool()\n+    pub fn try_eval_bool(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Option<bool> {\n+        self.val().eval(tcx, param_env).try_to_bool()\n     }\n \n     #[inline]\n-    pub fn try_eval_usize(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Option<u64> {\n-        self.val.eval(tcx, param_env).try_to_machine_usize(tcx)\n+    pub fn try_eval_usize(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Option<u64> {\n+        self.val().eval(tcx, param_env).try_to_machine_usize(tcx)\n     }\n \n     #[inline]\n     /// Tries to evaluate the constant if it is `Unevaluated`. If that doesn't succeed, return the\n     /// unevaluated constant.\n-    pub fn eval(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> &Const<'tcx> {\n-        if let Some(val) = self.val.try_eval(tcx, param_env) {\n+    pub fn eval(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Const<'tcx> {\n+        if let Some(val) = self.val().try_eval(tcx, param_env) {\n             match val {\n-                Ok(val) => Const::from_value(tcx, val, self.ty),\n-                Err(ErrorReported) => tcx.const_error(self.ty),\n+                Ok(val) => Const::from_value(tcx, val, self.ty()),\n+                Err(ErrorReported) => tcx.const_error(self.ty()),\n             }\n         } else {\n             self\n@@ -251,20 +273,20 @@ impl<'tcx> Const<'tcx> {\n \n     #[inline]\n     /// Panics if the value cannot be evaluated or doesn't contain a valid integer of the given type.\n-    pub fn eval_bits(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>, ty: Ty<'tcx>) -> u128 {\n+    pub fn eval_bits(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>, ty: Ty<'tcx>) -> u128 {\n         self.try_eval_bits(tcx, param_env, ty)\n             .unwrap_or_else(|| bug!(\"expected bits of {:#?}, got {:#?}\", ty, self))\n     }\n \n     #[inline]\n     /// Panics if the value cannot be evaluated or doesn't contain a valid `usize`.\n-    pub fn eval_usize(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> u64 {\n+    pub fn eval_usize(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> u64 {\n         self.try_eval_usize(tcx, param_env)\n             .unwrap_or_else(|| bug!(\"expected usize, got {:#?}\", self))\n     }\n }\n \n-pub fn const_param_default<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Const<'tcx> {\n+pub fn const_param_default<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Const<'tcx> {\n     let default_def_id = match tcx.hir().get_by_def_id(def_id.expect_local()) {\n         hir::Node::GenericParam(hir::GenericParam {\n             kind: hir::GenericParamKind::Const { ty: _, default: Some(ac) },"}, {"sha": "41145d250173fe479b3b4afc80071e9d74f21358", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 164, "deletions": 99, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -18,14 +18,15 @@ use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, Substs\n use crate::ty::TyKind::*;\n use crate::ty::{\n     self, AdtDef, AdtKind, Binder, BindingMode, BoundVar, CanonicalPolyFnSig,\n-    ClosureSizeProfileData, Const, ConstVid, DefIdTree, ExistentialPredicate, FloatTy, FloatVar,\n-    FloatVid, GenericParamDefKind, InferConst, InferTy, IntTy, IntVar, IntVid, List, ParamConst,\n-    ParamTy, PolyFnSig, Predicate, PredicateInner, PredicateKind, ProjectionTy, Region, RegionKind,\n-    ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut, UintTy,\n+    ClosureSizeProfileData, Const, ConstS, ConstVid, DefIdTree, ExistentialPredicate, FloatTy,\n+    FloatVar, FloatVid, GenericParamDefKind, InferConst, InferTy, IntTy, IntVar, IntVid, List,\n+    ParamConst, ParamTy, PolyFnSig, Predicate, PredicateKind, PredicateS, ProjectionTy, Region,\n+    RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut, UintTy,\n };\n use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n@@ -91,7 +92,7 @@ pub trait OnDiskCache<'tcx>: rustc_data_structures::sync::Sync {\n #[derive(TyEncodable, TyDecodable, HashStable)]\n pub struct DelaySpanBugEmitted(());\n \n-type InternedSet<'tcx, T> = ShardedHashMap<Interned<'tcx, T>, ()>;\n+type InternedSet<'tcx, T> = ShardedHashMap<InternedInSet<'tcx, T>, ()>;\n \n pub struct CtxtInterners<'tcx> {\n     /// The arena that types, regions, etc. are allocated from.\n@@ -106,11 +107,11 @@ pub struct CtxtInterners<'tcx> {\n     region: InternedSet<'tcx, RegionKind>,\n     poly_existential_predicates:\n         InternedSet<'tcx, List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>>>,\n-    predicate: InternedSet<'tcx, PredicateInner<'tcx>>,\n+    predicate: InternedSet<'tcx, PredicateS<'tcx>>,\n     predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n-    const_: InternedSet<'tcx, Const<'tcx>>,\n+    const_: InternedSet<'tcx, ConstS<'tcx>>,\n     const_allocation: InternedSet<'tcx, Allocation>,\n     bound_variable_kinds: InternedSet<'tcx, List<ty::BoundVariableKind>>,\n     layout: InternedSet<'tcx, Layout>,\n@@ -151,39 +152,40 @@ impl<'tcx> CtxtInterners<'tcx> {\n     #[allow(rustc::usage_of_ty_tykind)]\n     #[inline(never)]\n     fn intern_ty(&self, kind: TyKind<'tcx>) -> Ty<'tcx> {\n-        self.type_\n-            .intern(kind, |kind| {\n-                let flags = super::flags::FlagComputation::for_kind(&kind);\n-\n-                let ty_struct = TyS {\n-                    kind,\n-                    flags: flags.flags,\n-                    outer_exclusive_binder: flags.outer_exclusive_binder,\n-                };\n+        Ty(Interned::new_unchecked(\n+            self.type_\n+                .intern(kind, |kind| {\n+                    let flags = super::flags::FlagComputation::for_kind(&kind);\n+\n+                    let ty_struct = TyS {\n+                        kind,\n+                        flags: flags.flags,\n+                        outer_exclusive_binder: flags.outer_exclusive_binder,\n+                    };\n \n-                Interned(self.arena.alloc(ty_struct))\n-            })\n-            .0\n+                    InternedInSet(self.arena.alloc(ty_struct))\n+                })\n+                .0,\n+        ))\n     }\n \n     #[inline(never)]\n-    fn intern_predicate(\n-        &self,\n-        kind: Binder<'tcx, PredicateKind<'tcx>>,\n-    ) -> &'tcx PredicateInner<'tcx> {\n-        self.predicate\n-            .intern(kind, |kind| {\n-                let flags = super::flags::FlagComputation::for_predicate(kind);\n-\n-                let predicate_struct = PredicateInner {\n-                    kind,\n-                    flags: flags.flags,\n-                    outer_exclusive_binder: flags.outer_exclusive_binder,\n-                };\n+    fn intern_predicate(&self, kind: Binder<'tcx, PredicateKind<'tcx>>) -> Predicate<'tcx> {\n+        Predicate(Interned::new_unchecked(\n+            self.predicate\n+                .intern(kind, |kind| {\n+                    let flags = super::flags::FlagComputation::for_predicate(kind);\n+\n+                    let predicate_struct = PredicateS {\n+                        kind,\n+                        flags: flags.flags,\n+                        outer_exclusive_binder: flags.outer_exclusive_binder,\n+                    };\n \n-                Interned(self.arena.alloc(predicate_struct))\n-            })\n-            .0\n+                    InternedInSet(self.arena.alloc(predicate_struct))\n+                })\n+                .0,\n+        ))\n     }\n }\n \n@@ -227,7 +229,7 @@ pub struct CommonLifetimes<'tcx> {\n }\n \n pub struct CommonConsts<'tcx> {\n-    pub unit: &'tcx Const<'tcx>,\n+    pub unit: Const<'tcx>,\n }\n \n pub struct LocalTableInContext<'a, V> {\n@@ -858,16 +860,16 @@ impl<'tcx> CanonicalUserType<'tcx> {\n                             _ => false,\n                         },\n \n-                        GenericArgKind::Lifetime(r) => match r {\n+                        GenericArgKind::Lifetime(r) => match *r {\n                             ty::ReLateBound(debruijn, br) => {\n                                 // We only allow a `ty::INNERMOST` index in substitutions.\n-                                assert_eq!(*debruijn, ty::INNERMOST);\n+                                assert_eq!(debruijn, ty::INNERMOST);\n                                 cvar == br.var\n                             }\n                             _ => false,\n                         },\n \n-                        GenericArgKind::Const(ct) => match ct.val {\n+                        GenericArgKind::Const(ct) => match ct.val() {\n                             ty::ConstKind::Bound(debruijn, b) => {\n                                 // We only allow a `ty::INNERMOST` index in substitutions.\n                                 assert_eq!(debruijn, ty::INNERMOST);\n@@ -928,22 +930,30 @@ impl<'tcx> CommonTypes<'tcx> {\n \n impl<'tcx> CommonLifetimes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonLifetimes<'tcx> {\n-        let mk = |r| interners.region.intern(r, |r| Interned(interners.arena.alloc(r))).0;\n+        let mk = |r| {\n+            Region(Interned::new_unchecked(\n+                interners.region.intern(r, |r| InternedInSet(interners.arena.alloc(r))).0,\n+            ))\n+        };\n \n         CommonLifetimes {\n-            re_root_empty: mk(RegionKind::ReEmpty(ty::UniverseIndex::ROOT)),\n-            re_static: mk(RegionKind::ReStatic),\n-            re_erased: mk(RegionKind::ReErased),\n+            re_root_empty: mk(ty::ReEmpty(ty::UniverseIndex::ROOT)),\n+            re_static: mk(ty::ReStatic),\n+            re_erased: mk(ty::ReErased),\n         }\n     }\n }\n \n impl<'tcx> CommonConsts<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>, types: &CommonTypes<'tcx>) -> CommonConsts<'tcx> {\n-        let mk_const = |c| interners.const_.intern(c, |c| Interned(interners.arena.alloc(c))).0;\n+        let mk_const = |c| {\n+            Const(Interned::new_unchecked(\n+                interners.const_.intern(c, |c| InternedInSet(interners.arena.alloc(c))).0,\n+            ))\n+        };\n \n         CommonConsts {\n-            unit: mk_const(ty::Const {\n+            unit: mk_const(ty::ConstS {\n                 val: ty::ConstKind::Value(ConstValue::Scalar(Scalar::ZST)),\n                 ty: types.unit,\n             }),\n@@ -1215,7 +1225,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Like [TyCtxt::ty_error] but for constants.\n     #[track_caller]\n-    pub fn const_error(self, ty: Ty<'tcx>) -> &'tcx Const<'tcx> {\n+    pub fn const_error(self, ty: Ty<'tcx>) -> Const<'tcx> {\n         self.const_error_with_message(\n             ty,\n             DUMMY_SP,\n@@ -1230,9 +1240,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         ty: Ty<'tcx>,\n         span: S,\n         msg: &str,\n-    ) -> &'tcx Const<'tcx> {\n+    ) -> Const<'tcx> {\n         self.sess.delay_span_bug(span, msg);\n-        self.mk_const(ty::Const { val: ty::ConstKind::Error(DelaySpanBugEmitted(())), ty })\n+        self.mk_const(ty::ConstS { val: ty::ConstKind::Error(DelaySpanBugEmitted(())), ty })\n     }\n \n     pub fn consider_optimizing<T: Fn() -> String>(self, msg: T) -> bool {\n@@ -1627,12 +1637,28 @@ pub trait Lift<'tcx>: fmt::Debug {\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted>;\n }\n \n+// Deprecated: we are in the process of converting all uses to `nop_lift`.\n+macro_rules! nop_lift_old {\n+    ($set:ident; $ty:ty => $lifted:ty) => {\n+        impl<'a, 'tcx> Lift<'tcx> for $ty {\n+            type Lifted = $lifted;\n+            fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+                if tcx.interners.$set.contains_pointer_to(&InternedInSet(self)) {\n+                    Some(unsafe { mem::transmute(self) })\n+                } else {\n+                    None\n+                }\n+            }\n+        }\n+    };\n+}\n+\n macro_rules! nop_lift {\n     ($set:ident; $ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for $ty {\n             type Lifted = $lifted;\n             fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-                if tcx.interners.$set.contains_pointer_to(&Interned(self)) {\n+                if tcx.interners.$set.contains_pointer_to(&InternedInSet(self.0.0)) {\n                     Some(unsafe { mem::transmute(self) })\n                 } else {\n                     None\n@@ -1650,7 +1676,7 @@ macro_rules! nop_list_lift {\n                 if self.is_empty() {\n                     return Some(List::empty());\n                 }\n-                if tcx.interners.$set.contains_pointer_to(&Interned(self)) {\n+                if tcx.interners.$set.contains_pointer_to(&InternedInSet(self)) {\n                     Some(unsafe { mem::transmute(self) })\n                 } else {\n                     None\n@@ -1662,9 +1688,9 @@ macro_rules! nop_list_lift {\n \n nop_lift! {type_; Ty<'a> => Ty<'tcx>}\n nop_lift! {region; Region<'a> => Region<'tcx>}\n-nop_lift! {const_; &'a Const<'a> => &'tcx Const<'tcx>}\n-nop_lift! {const_allocation; &'a Allocation => &'tcx Allocation}\n-nop_lift! {predicate; &'a PredicateInner<'a> => &'tcx PredicateInner<'tcx>}\n+nop_lift! {const_; Const<'a> => Const<'tcx>}\n+nop_lift_old! {const_allocation; &'a Allocation => &'tcx Allocation}\n+nop_lift! {predicate; Predicate<'a> => Predicate<'tcx>}\n \n nop_list_lift! {type_list; Ty<'a> => Ty<'tcx>}\n nop_list_lift! {poly_existential_predicates; ty::Binder<'a, ExistentialPredicate<'a>> => ty::Binder<'tcx, ExistentialPredicate<'tcx>>}\n@@ -1857,7 +1883,7 @@ macro_rules! sty_debug_print {\n         #[allow(non_snake_case)]\n         mod inner {\n             use crate::ty::{self, TyCtxt};\n-            use crate::ty::context::Interned;\n+            use crate::ty::context::InternedInSet;\n \n             #[derive(Copy, Clone)]\n             struct DebugStat {\n@@ -1880,16 +1906,16 @@ macro_rules! sty_debug_print {\n \n                 let shards = tcx.interners.type_.lock_shards();\n                 let types = shards.iter().flat_map(|shard| shard.keys());\n-                for &Interned(t) in types {\n-                    let variant = match t.kind() {\n+                for &InternedInSet(t) in types {\n+                    let variant = match t.kind {\n                         ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n                             ty::Float(..) | ty::Str | ty::Never => continue,\n                         ty::Error(_) => /* unimportant */ continue,\n                         $(ty::$variant(..) => &mut $variant,)*\n                     };\n-                    let lt = t.flags().intersects(ty::TypeFlags::HAS_RE_INFER);\n-                    let ty = t.flags().intersects(ty::TypeFlags::HAS_TY_INFER);\n-                    let ct = t.flags().intersects(ty::TypeFlags::HAS_CT_INFER);\n+                    let lt = t.flags.intersects(ty::TypeFlags::HAS_RE_INFER);\n+                    let ty = t.flags.intersects(ty::TypeFlags::HAS_TY_INFER);\n+                    let ct = t.flags.intersects(ty::TypeFlags::HAS_CT_INFER);\n \n                     variant.total += 1;\n                     total.total += 1;\n@@ -1980,111 +2006,152 @@ impl<'tcx> TyCtxt<'tcx> {\n // this type just holds a pointer to it, but it still effectively owns it. It\n // impls `Borrow` so that it can be looked up using the original\n // (non-arena-memory-owning) types.\n-struct Interned<'tcx, T: ?Sized>(&'tcx T);\n+struct InternedInSet<'tcx, T: ?Sized>(&'tcx T);\n \n-impl<'tcx, T: 'tcx + ?Sized> Clone for Interned<'tcx, T> {\n+impl<'tcx, T: 'tcx + ?Sized> Clone for InternedInSet<'tcx, T> {\n     fn clone(&self) -> Self {\n-        Interned(self.0)\n+        InternedInSet(self.0)\n     }\n }\n \n-impl<'tcx, T: 'tcx + ?Sized> Copy for Interned<'tcx, T> {}\n+impl<'tcx, T: 'tcx + ?Sized> Copy for InternedInSet<'tcx, T> {}\n \n-impl<'tcx, T: 'tcx + ?Sized> IntoPointer for Interned<'tcx, T> {\n+impl<'tcx, T: 'tcx + ?Sized> IntoPointer for InternedInSet<'tcx, T> {\n     fn into_pointer(&self) -> *const () {\n         self.0 as *const _ as *const ()\n     }\n }\n \n #[allow(rustc::usage_of_ty_tykind)]\n-impl<'tcx> Borrow<TyKind<'tcx>> for Interned<'tcx, TyS<'tcx>> {\n+impl<'tcx> Borrow<TyKind<'tcx>> for InternedInSet<'tcx, TyS<'tcx>> {\n     fn borrow<'a>(&'a self) -> &'a TyKind<'tcx> {\n-        &self.0.kind()\n+        &self.0.kind\n     }\n }\n \n-impl<'tcx> PartialEq for Interned<'tcx, TyS<'tcx>> {\n-    fn eq(&self, other: &Interned<'tcx, TyS<'tcx>>) -> bool {\n+impl<'tcx> PartialEq for InternedInSet<'tcx, TyS<'tcx>> {\n+    fn eq(&self, other: &InternedInSet<'tcx, TyS<'tcx>>) -> bool {\n         // The `Borrow` trait requires that `x.borrow() == y.borrow()` equals\n         // `x == y`.\n-        self.0.kind() == other.0.kind()\n+        self.0.kind == other.0.kind\n     }\n }\n \n-impl<'tcx> Eq for Interned<'tcx, TyS<'tcx>> {}\n+impl<'tcx> Eq for InternedInSet<'tcx, TyS<'tcx>> {}\n \n-impl<'tcx> Hash for Interned<'tcx, TyS<'tcx>> {\n+impl<'tcx> Hash for InternedInSet<'tcx, TyS<'tcx>> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         // The `Borrow` trait requires that `x.borrow().hash(s) == x.hash(s)`.\n-        self.0.kind().hash(s)\n+        self.0.kind.hash(s)\n     }\n }\n \n-impl<'tcx> Borrow<Binder<'tcx, PredicateKind<'tcx>>> for Interned<'tcx, PredicateInner<'tcx>> {\n+impl<'tcx> Borrow<Binder<'tcx, PredicateKind<'tcx>>> for InternedInSet<'tcx, PredicateS<'tcx>> {\n     fn borrow<'a>(&'a self) -> &'a Binder<'tcx, PredicateKind<'tcx>> {\n         &self.0.kind\n     }\n }\n \n-impl<'tcx> PartialEq for Interned<'tcx, PredicateInner<'tcx>> {\n-    fn eq(&self, other: &Interned<'tcx, PredicateInner<'tcx>>) -> bool {\n+impl<'tcx> PartialEq for InternedInSet<'tcx, PredicateS<'tcx>> {\n+    fn eq(&self, other: &InternedInSet<'tcx, PredicateS<'tcx>>) -> bool {\n         // The `Borrow` trait requires that `x.borrow() == y.borrow()` equals\n         // `x == y`.\n         self.0.kind == other.0.kind\n     }\n }\n \n-impl<'tcx> Eq for Interned<'tcx, PredicateInner<'tcx>> {}\n+impl<'tcx> Eq for InternedInSet<'tcx, PredicateS<'tcx>> {}\n \n-impl<'tcx> Hash for Interned<'tcx, PredicateInner<'tcx>> {\n+impl<'tcx> Hash for InternedInSet<'tcx, PredicateS<'tcx>> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         // The `Borrow` trait requires that `x.borrow().hash(s) == x.hash(s)`.\n         self.0.kind.hash(s)\n     }\n }\n \n-impl<'tcx, T> Borrow<[T]> for Interned<'tcx, List<T>> {\n+impl<'tcx, T> Borrow<[T]> for InternedInSet<'tcx, List<T>> {\n     fn borrow<'a>(&'a self) -> &'a [T] {\n         &self.0[..]\n     }\n }\n \n-impl<'tcx, T: PartialEq> PartialEq for Interned<'tcx, List<T>> {\n-    fn eq(&self, other: &Interned<'tcx, List<T>>) -> bool {\n+impl<'tcx, T: PartialEq> PartialEq for InternedInSet<'tcx, List<T>> {\n+    fn eq(&self, other: &InternedInSet<'tcx, List<T>>) -> bool {\n         // The `Borrow` trait requires that `x.borrow() == y.borrow()` equals\n         // `x == y`.\n         self.0[..] == other.0[..]\n     }\n }\n \n-impl<'tcx, T: Eq> Eq for Interned<'tcx, List<T>> {}\n+impl<'tcx, T: Eq> Eq for InternedInSet<'tcx, List<T>> {}\n \n-impl<'tcx, T: Hash> Hash for Interned<'tcx, List<T>> {\n+impl<'tcx, T: Hash> Hash for InternedInSet<'tcx, List<T>> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         // The `Borrow` trait requires that `x.borrow().hash(s) == x.hash(s)`.\n         self.0[..].hash(s)\n     }\n }\n \n macro_rules! direct_interners {\n+    ($($name:ident: $method:ident($ty:ty): $ret_ctor:ident -> $ret_ty:ty,)+) => {\n+        $(impl<'tcx> Borrow<$ty> for InternedInSet<'tcx, $ty> {\n+            fn borrow<'a>(&'a self) -> &'a $ty {\n+                &self.0\n+            }\n+        }\n+\n+        impl<'tcx> PartialEq for InternedInSet<'tcx, $ty> {\n+            fn eq(&self, other: &Self) -> bool {\n+                // The `Borrow` trait requires that `x.borrow() == y.borrow()`\n+                // equals `x == y`.\n+                self.0 == other.0\n+            }\n+        }\n+\n+        impl<'tcx> Eq for InternedInSet<'tcx, $ty> {}\n+\n+        impl<'tcx> Hash for InternedInSet<'tcx, $ty> {\n+            fn hash<H: Hasher>(&self, s: &mut H) {\n+                // The `Borrow` trait requires that `x.borrow().hash(s) ==\n+                // x.hash(s)`.\n+                self.0.hash(s)\n+            }\n+        }\n+\n+        impl<'tcx> TyCtxt<'tcx> {\n+            pub fn $method(self, v: $ty) -> $ret_ty {\n+                $ret_ctor(Interned::new_unchecked(self.interners.$name.intern(v, |v| {\n+                    InternedInSet(self.interners.arena.alloc(v))\n+                }).0))\n+            }\n+        })+\n+    }\n+}\n+\n+direct_interners! {\n+    region: mk_region(RegionKind): Region -> Region<'tcx>,\n+    const_: mk_const(ConstS<'tcx>): Const -> Const<'tcx>,\n+}\n+\n+macro_rules! direct_interners_old {\n     ($($name:ident: $method:ident($ty:ty),)+) => {\n-        $(impl<'tcx> Borrow<$ty> for Interned<'tcx, $ty> {\n+        $(impl<'tcx> Borrow<$ty> for InternedInSet<'tcx, $ty> {\n             fn borrow<'a>(&'a self) -> &'a $ty {\n                 &self.0\n             }\n         }\n \n-        impl<'tcx> PartialEq for Interned<'tcx, $ty> {\n+        impl<'tcx> PartialEq for InternedInSet<'tcx, $ty> {\n             fn eq(&self, other: &Self) -> bool {\n                 // The `Borrow` trait requires that `x.borrow() == y.borrow()`\n                 // equals `x == y`.\n                 self.0 == other.0\n             }\n         }\n \n-        impl<'tcx> Eq for Interned<'tcx, $ty> {}\n+        impl<'tcx> Eq for InternedInSet<'tcx, $ty> {}\n \n-        impl<'tcx> Hash for Interned<'tcx, $ty> {\n+        impl<'tcx> Hash for InternedInSet<'tcx, $ty> {\n             fn hash<H: Hasher>(&self, s: &mut H) {\n                 // The `Borrow` trait requires that `x.borrow().hash(s) ==\n                 // x.hash(s)`.\n@@ -2095,16 +2162,15 @@ macro_rules! direct_interners {\n         impl<'tcx> TyCtxt<'tcx> {\n             pub fn $method(self, v: $ty) -> &'tcx $ty {\n                 self.interners.$name.intern(v, |v| {\n-                    Interned(self.interners.arena.alloc(v))\n+                    InternedInSet(self.interners.arena.alloc(v))\n                 }).0\n             }\n         })+\n     }\n }\n \n-direct_interners! {\n-    region: mk_region(RegionKind),\n-    const_: mk_const(Const<'tcx>),\n+// FIXME: eventually these should all be converted to `direct_interners`.\n+direct_interners_old! {\n     const_allocation: intern_const_alloc(Allocation),\n     layout: intern_layout(Layout),\n     adt_def: intern_adt_def(AdtDef),\n@@ -2117,7 +2183,7 @@ macro_rules! slice_interners {\n         impl<'tcx> TyCtxt<'tcx> {\n             $(pub fn $method(self, v: &[$ty]) -> &'tcx List<$ty> {\n                 self.interners.$field.intern_ref(v, || {\n-                    Interned(List::from_arena(&*self.arena, v))\n+                    InternedInSet(List::from_arena(&*self.arena, v))\n                 }).0\n             })+\n         }\n@@ -2217,8 +2283,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_predicate(self, binder: Binder<'tcx, PredicateKind<'tcx>>) -> Predicate<'tcx> {\n-        let inner = self.interners.intern_predicate(binder);\n-        Predicate { inner }\n+        self.interners.intern_predicate(binder)\n     }\n \n     #[inline]\n@@ -2429,8 +2494,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_const_var(self, v: ConstVid<'tcx>, ty: Ty<'tcx>) -> &'tcx Const<'tcx> {\n-        self.mk_const(ty::Const { val: ty::ConstKind::Infer(InferConst::Var(v)), ty })\n+    pub fn mk_const_var(self, v: ConstVid<'tcx>, ty: Ty<'tcx>) -> Const<'tcx> {\n+        self.mk_const(ty::ConstS { val: ty::ConstKind::Infer(InferConst::Var(v)), ty })\n     }\n \n     #[inline]\n@@ -2449,8 +2514,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_const_infer(self, ic: InferConst<'tcx>, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        self.mk_const(ty::Const { val: ty::ConstKind::Infer(ic), ty })\n+    pub fn mk_const_infer(self, ic: InferConst<'tcx>, ty: Ty<'tcx>) -> ty::Const<'tcx> {\n+        self.mk_const(ty::ConstS { val: ty::ConstKind::Infer(ic), ty })\n     }\n \n     #[inline]\n@@ -2459,8 +2524,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_const_param(self, index: u32, name: Symbol, ty: Ty<'tcx>) -> &'tcx Const<'tcx> {\n-        self.mk_const(ty::Const { val: ty::ConstKind::Param(ParamConst { index, name }), ty })\n+    pub fn mk_const_param(self, index: u32, name: Symbol, ty: Ty<'tcx>) -> Const<'tcx> {\n+        self.mk_const(ty::ConstS { val: ty::ConstKind::Param(ParamConst { index, name }), ty })\n     }\n \n     pub fn mk_param_from_def(self, param: &ty::GenericParamDef) -> GenericArg<'tcx> {"}, {"sha": "64b2edd2c3f392edf5e0d7af6b65b2404155e81f", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -1,10 +1,10 @@\n-//! Diagnostics related methods for `TyS`.\n+//! Diagnostics related methods for `Ty`.\n \n use crate::ty::subst::{GenericArg, GenericArgKind};\n use crate::ty::TyKind::*;\n use crate::ty::{\n     ConstKind, ExistentialPredicate, ExistentialProjection, ExistentialTraitRef, InferTy,\n-    ProjectionTy, Term, TyCtxt, TyS, TypeAndMut,\n+    ProjectionTy, Term, Ty, TyCtxt, TypeAndMut,\n };\n \n use rustc_errors::{Applicability, DiagnosticBuilder};\n@@ -13,9 +13,9 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::{QPath, TyKind, WhereBoundPredicate, WherePredicate};\n use rustc_span::Span;\n \n-impl<'tcx> TyS<'tcx> {\n-    /// Similar to `TyS::is_primitive`, but also considers inferred numeric values to be primitive.\n-    pub fn is_primitive_ty(&self) -> bool {\n+impl<'tcx> Ty<'tcx> {\n+    /// Similar to `Ty::is_primitive`, but also considers inferred numeric values to be primitive.\n+    pub fn is_primitive_ty(self) -> bool {\n         matches!(\n             self.kind(),\n             Bool | Char\n@@ -34,7 +34,7 @@ impl<'tcx> TyS<'tcx> {\n \n     /// Whether the type is succinctly representable as a type instead of just referred to with a\n     /// description in error messages. This is used in the main error message.\n-    pub fn is_simple_ty(&self) -> bool {\n+    pub fn is_simple_ty(self) -> bool {\n         match self.kind() {\n             Bool\n             | Char\n@@ -58,7 +58,7 @@ impl<'tcx> TyS<'tcx> {\n     /// description in error messages. This is used in the primary span label. Beyond what\n     /// `is_simple_ty` includes, it also accepts ADTs with no type arguments and references to\n     /// ADTs with no type arguments.\n-    pub fn is_simple_text(&self) -> bool {\n+    pub fn is_simple_text(self) -> bool {\n         match self.kind() {\n             Adt(_, substs) => substs.non_erasable_generics().next().is_none(),\n             Ref(_, ty, _) => ty.is_simple_text(),\n@@ -67,11 +67,11 @@ impl<'tcx> TyS<'tcx> {\n     }\n \n     /// Whether the type can be safely suggested during error recovery.\n-    pub fn is_suggestable(&self) -> bool {\n+    pub fn is_suggestable(self) -> bool {\n         fn generic_arg_is_suggestible(arg: GenericArg<'_>) -> bool {\n             match arg.unpack() {\n                 GenericArgKind::Type(ty) => ty.is_suggestable(),\n-                GenericArgKind::Const(c) => const_is_suggestable(c.val),\n+                GenericArgKind::Const(c) => const_is_suggestable(c.val()),\n                 _ => true,\n             }\n         }\n@@ -110,7 +110,7 @@ impl<'tcx> TyS<'tcx> {\n                 }) => {\n                     let term_is_suggestable = match term {\n                         Term::Ty(ty) => ty.is_suggestable(),\n-                        Term::Const(c) => const_is_suggestable(c.val),\n+                        Term::Const(c) => const_is_suggestable(c.val()),\n                     };\n                     term_is_suggestable && substs.iter().all(generic_arg_is_suggestible)\n                 }\n@@ -120,7 +120,7 @@ impl<'tcx> TyS<'tcx> {\n                 args.iter().all(generic_arg_is_suggestible)\n             }\n             Slice(ty) | RawPtr(TypeAndMut { ty, .. }) | Ref(_, ty, _) => ty.is_suggestable(),\n-            Array(ty, c) => ty.is_suggestable() && const_is_suggestable(c.val),\n+            Array(ty, c) => ty.is_suggestable() && const_is_suggestable(c.val()),\n             _ => true,\n         }\n     }"}, {"sha": "2ccfeba2b665d13a64ae5135ff52fe36907aa569", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -60,13 +60,13 @@ pub enum TypeError<'tcx> {\n     /// created a cycle (because it appears somewhere within that\n     /// type).\n     CyclicTy(Ty<'tcx>),\n-    CyclicConst(&'tcx ty::Const<'tcx>),\n+    CyclicConst(ty::Const<'tcx>),\n     ProjectionMismatched(ExpectedFound<DefId>),\n     ExistentialMismatch(\n         ExpectedFound<&'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>>,\n     ),\n     ObjectUnsafeCoercion(DefId),\n-    ConstMismatch(ExpectedFound<&'tcx ty::Const<'tcx>>),\n+    ConstMismatch(ExpectedFound<ty::Const<'tcx>>),\n \n     IntrinsicCast,\n     /// Safe `#[target_feature]` functions are not assignable to safe function pointers.\n@@ -239,8 +239,8 @@ impl<'tcx> TypeError<'tcx> {\n     }\n }\n \n-impl<'tcx> ty::TyS<'tcx> {\n-    pub fn sort_string(&self, tcx: TyCtxt<'_>) -> Cow<'static, str> {\n+impl<'tcx> Ty<'tcx> {\n+    pub fn sort_string(self, tcx: TyCtxt<'_>) -> Cow<'static, str> {\n         match *self.kind() {\n             ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str | ty::Never => {\n                 format!(\"`{}`\", self).into()\n@@ -255,7 +255,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                 }\n \n                 let n = tcx.lift(n).unwrap();\n-                if let ty::ConstKind::Value(v) = n.val {\n+                if let ty::ConstKind::Value(v) = n.val() {\n                     if let Some(n) = v.try_to_machine_usize(tcx) {\n                         return format!(\"array of {} element{}\", n, pluralize!(n)).into();\n                     }\n@@ -306,7 +306,7 @@ impl<'tcx> ty::TyS<'tcx> {\n         }\n     }\n \n-    pub fn prefix_string(&self, tcx: TyCtxt<'_>) -> Cow<'static, str> {\n+    pub fn prefix_string(self, tcx: TyCtxt<'_>) -> Cow<'static, str> {\n         match *self.kind() {\n             ty::Infer(_)\n             | ty::Error(_)"}, {"sha": "948a48c082644b2deabc5732240e836df35c259c", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -6,7 +6,7 @@ use std::slice;\n pub struct FlagComputation {\n     pub flags: TypeFlags,\n \n-    // see `TyS::outer_exclusive_binder` for details\n+    // see `Ty::outer_exclusive_binder` for details\n     pub outer_exclusive_binder: ty::DebruijnIndex,\n }\n \n@@ -28,7 +28,7 @@ impl FlagComputation {\n         result\n     }\n \n-    pub fn for_const(c: &ty::Const<'_>) -> TypeFlags {\n+    pub fn for_const(c: ty::Const<'_>) -> TypeFlags {\n         let mut result = FlagComputation::new();\n         result.add_const(c);\n         result.flags\n@@ -270,7 +270,7 @@ impl FlagComputation {\n \n     fn add_ty(&mut self, ty: Ty<'_>) {\n         self.add_flags(ty.flags());\n-        self.add_exclusive_binder(ty.outer_exclusive_binder);\n+        self.add_exclusive_binder(ty.outer_exclusive_binder());\n     }\n \n     fn add_tys(&mut self, tys: &[Ty<'_>]) {\n@@ -286,9 +286,9 @@ impl FlagComputation {\n         }\n     }\n \n-    fn add_const(&mut self, c: &ty::Const<'_>) {\n-        self.add_ty(c.ty);\n-        match c.val {\n+    fn add_const(&mut self, c: ty::Const<'_>) {\n+        self.add_ty(c.ty());\n+        match c.val() {\n             ty::ConstKind::Unevaluated(unevaluated) => self.add_unevaluated_const(unevaluated),\n             ty::ConstKind::Infer(infer) => {\n                 self.add_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE);"}, {"sha": "b3006672e222017a591df2a3238a4f5450df0eb9", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 41, "deletions": 44, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -216,7 +216,7 @@ pub trait TypeFolder<'tcx>: Sized {\n         r.super_fold_with(self)\n     }\n \n-    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx>\n+    fn fold_const(&mut self, c: ty::Const<'tcx>) -> ty::Const<'tcx>\n     where\n         Self: TypeFolder<'tcx, Error = !>,\n     {\n@@ -263,10 +263,7 @@ pub trait FallibleTypeFolder<'tcx>: TypeFolder<'tcx> {\n         r.try_super_fold_with(self)\n     }\n \n-    fn try_fold_const(\n-        &mut self,\n-        c: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+    fn try_fold_const(&mut self, c: ty::Const<'tcx>) -> Result<ty::Const<'tcx>, Self::Error> {\n         c.try_super_fold_with(self)\n     }\n \n@@ -306,10 +303,7 @@ where\n         Ok(self.fold_region(r))\n     }\n \n-    fn try_fold_const(\n-        &mut self,\n-        c: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+    fn try_fold_const(&mut self, c: ty::Const<'tcx>) -> Result<ty::Const<'tcx>, Self::Error> {\n         Ok(self.fold_const(c))\n     }\n \n@@ -346,7 +340,7 @@ pub trait TypeVisitor<'tcx>: Sized {\n         r.super_visit_with(self)\n     }\n \n-    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+    fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n         c.super_visit_with(self)\n     }\n \n@@ -366,7 +360,7 @@ pub struct BottomUpFolder<'tcx, F, G, H>\n where\n     F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n     G: FnMut(ty::Region<'tcx>) -> ty::Region<'tcx>,\n-    H: FnMut(&'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx>,\n+    H: FnMut(ty::Const<'tcx>) -> ty::Const<'tcx>,\n {\n     pub tcx: TyCtxt<'tcx>,\n     pub ty_op: F,\n@@ -378,7 +372,7 @@ impl<'tcx, F, G, H> TypeFolder<'tcx> for BottomUpFolder<'tcx, F, G, H>\n where\n     F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n     G: FnMut(ty::Region<'tcx>) -> ty::Region<'tcx>,\n-    H: FnMut(&'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx>,\n+    H: FnMut(ty::Const<'tcx>) -> ty::Const<'tcx>,\n {\n     fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.tcx\n@@ -394,7 +388,7 @@ where\n         (self.lt_op)(r)\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n         let ct = ct.super_fold_with(self);\n         (self.ct_op)(ct)\n     }\n@@ -593,15 +587,15 @@ struct BoundVarReplacer<'a, 'tcx> {\n \n     fld_r: Option<&'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a)>,\n     fld_t: Option<&'a mut (dyn FnMut(ty::BoundTy) -> Ty<'tcx> + 'a)>,\n-    fld_c: Option<&'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx> + 'a)>,\n+    fld_c: Option<&'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> ty::Const<'tcx> + 'a)>,\n }\n \n impl<'a, 'tcx> BoundVarReplacer<'a, 'tcx> {\n     fn new(\n         tcx: TyCtxt<'tcx>,\n         fld_r: Option<&'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a)>,\n         fld_t: Option<&'a mut (dyn FnMut(ty::BoundTy) -> Ty<'tcx> + 'a)>,\n-        fld_c: Option<&'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx> + 'a)>,\n+        fld_c: Option<&'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> ty::Const<'tcx> + 'a)>,\n     ) -> Self {\n         BoundVarReplacer { tcx, current_index: ty::INNERMOST, fld_r, fld_t, fld_c }\n     }\n@@ -627,7 +621,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n             ty::Bound(debruijn, bound_ty) if debruijn == self.current_index => {\n                 if let Some(fld_t) = self.fld_t.as_mut() {\n                     let ty = fld_t(bound_ty);\n-                    return ty::fold::shift_vars(self.tcx, &ty, self.current_index.as_u32());\n+                    return ty::fold::shift_vars(self.tcx, ty, self.current_index.as_u32());\n                 }\n             }\n             _ if t.has_vars_bound_at_or_above(self.current_index) => {\n@@ -660,14 +654,12 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n         r\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        match *ct {\n-            ty::Const { val: ty::ConstKind::Bound(debruijn, bound_const), ty }\n-                if debruijn == self.current_index =>\n-            {\n+    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+        match ct.val() {\n+            ty::ConstKind::Bound(debruijn, bound_const) if debruijn == self.current_index => {\n                 if let Some(fld_c) = self.fld_c.as_mut() {\n-                    let ct = fld_c(bound_const, ty);\n-                    return ty::fold::shift_vars(self.tcx, &ct, self.current_index.as_u32());\n+                    let ct = fld_c(bound_const, ct.ty());\n+                    return ty::fold::shift_vars(self.tcx, ct, self.current_index.as_u32());\n                 }\n             }\n             _ if ct.has_vars_bound_at_or_above(self.current_index) => {\n@@ -726,7 +718,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     where\n         F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n         G: FnMut(ty::BoundTy) -> Ty<'tcx>,\n-        H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx>,\n+        H: FnMut(ty::BoundVar, Ty<'tcx>) -> ty::Const<'tcx>,\n         T: TypeFoldable<'tcx>,\n     {\n         if !value.has_escaping_bound_vars() {\n@@ -751,7 +743,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     where\n         F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n         G: FnMut(ty::BoundTy) -> Ty<'tcx>,\n-        H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx>,\n+        H: FnMut(ty::BoundVar, Ty<'tcx>) -> ty::Const<'tcx>,\n         T: TypeFoldable<'tcx>,\n     {\n         let mut region_map = BTreeMap::new();\n@@ -804,7 +796,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 ))\n             },\n             |c, ty| {\n-                self.mk_const(ty::Const {\n+                self.mk_const(ty::ConstS {\n                     val: ty::ConstKind::Bound(\n                         ty::INNERMOST,\n                         ty::BoundVar::from_usize(c.as_usize() + bound_vars),\n@@ -926,7 +918,7 @@ impl<'tcx> TypeVisitor<'tcx> for ValidateBoundVars<'tcx> {\n     }\n \n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if t.outer_exclusive_binder < self.binder_index\n+        if t.outer_exclusive_binder() < self.binder_index\n             || !self.visited.insert((self.binder_index, t))\n         {\n             return ControlFlow::BREAK;\n@@ -960,10 +952,10 @@ impl<'tcx> TypeVisitor<'tcx> for ValidateBoundVars<'tcx> {\n     }\n \n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        match r {\n-            ty::ReLateBound(index, br) if *index == self.binder_index => {\n+        match *r {\n+            ty::ReLateBound(index, br) if index == self.binder_index => {\n                 if self.bound_vars.len() <= br.var.as_usize() {\n-                    bug!(\"Not enough bound vars: {:?} not found in {:?}\", *br, self.bound_vars);\n+                    bug!(\"Not enough bound vars: {:?} not found in {:?}\", br, self.bound_vars);\n                 }\n                 let list_var = self.bound_vars[br.var.as_usize()];\n                 match list_var {\n@@ -1057,13 +1049,16 @@ impl<'tcx> TypeFolder<'tcx> for Shifter<'tcx> {\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ty::Const { val: ty::ConstKind::Bound(debruijn, bound_ct), ty } = *ct {\n+    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+        if let ty::ConstKind::Bound(debruijn, bound_ct) = ct.val() {\n             if self.amount == 0 || debruijn < self.current_index {\n                 ct\n             } else {\n                 let debruijn = debruijn.shifted_in(self.amount);\n-                self.tcx.mk_const(ty::Const { val: ty::ConstKind::Bound(debruijn, bound_ct), ty })\n+                self.tcx.mk_const(ty::ConstS {\n+                    val: ty::ConstKind::Bound(debruijn, bound_ct),\n+                    ty: ct.ty(),\n+                })\n             }\n         } else {\n             ct.super_fold_with(self)\n@@ -1076,9 +1071,9 @@ pub fn shift_region<'tcx>(\n     region: ty::Region<'tcx>,\n     amount: u32,\n ) -> ty::Region<'tcx> {\n-    match region {\n+    match *region {\n         ty::ReLateBound(debruijn, br) if amount > 0 => {\n-            tcx.mk_region(ty::ReLateBound(debruijn.shifted_in(amount), *br))\n+            tcx.mk_region(ty::ReLateBound(debruijn.shifted_in(amount), br))\n         }\n         _ => region,\n     }\n@@ -1146,7 +1141,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n         // bound at `outer_index` or above (because\n         // `outer_exclusive_binder` is always 1 higher than the\n         // content in `t`). Therefore, `t` has some escaping vars.\n-        if t.outer_exclusive_binder > self.outer_index {\n+        if t.outer_exclusive_binder() > self.outer_index {\n             ControlFlow::Break(FoundEscapingVars)\n         } else {\n             ControlFlow::CONTINUE\n@@ -1165,13 +1160,13 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n         }\n     }\n \n-    fn visit_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+    fn visit_const(&mut self, ct: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n         // we don't have a `visit_infer_const` callback, so we have to\n         // hook in here to catch this case (annoying...), but\n         // otherwise we do want to remember to visit the rest of the\n         // const, as it has types/regions embedded in a lot of other\n         // places.\n-        match ct.val {\n+        match ct.val() {\n             ty::ConstKind::Bound(debruijn, _) if debruijn >= self.outer_index => {\n                 ControlFlow::Break(FoundEscapingVars)\n             }\n@@ -1181,7 +1176,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n \n     #[inline]\n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if predicate.inner.outer_exclusive_binder > self.outer_index {\n+        if predicate.outer_exclusive_binder() > self.outer_index {\n             ControlFlow::Break(FoundEscapingVars)\n         } else {\n             ControlFlow::CONTINUE\n@@ -1236,7 +1231,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n \n     #[inline]\n     #[instrument(level = \"trace\")]\n-    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+    fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let flags = FlagComputation::for_const(c);\n         trace!(r.flags=?flags);\n         if flags.intersects(self.flags) {\n@@ -1263,9 +1258,11 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n         debug!(\n             \"HasTypeFlagsVisitor: predicate={:?} predicate.flags={:?} self.flags={:?}\",\n-            predicate, predicate.inner.flags, self.flags\n+            predicate,\n+            predicate.flags(),\n+            self.flags\n         );\n-        if predicate.inner.flags.intersects(self.flags) {\n+        if predicate.flags().intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {\n             ControlFlow::CONTINUE\n@@ -1323,12 +1320,12 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n         t.super_visit_with(self)\n     }\n \n-    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+    fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n         // if we are only looking for \"constrained\" region, we have to\n         // ignore the inputs of an unevaluated const, as they may not appear\n         // in the normalized form\n         if self.just_constrained {\n-            if let ty::ConstKind::Unevaluated(..) = c.val {\n+            if let ty::ConstKind::Unevaluated(..) = c.val() {\n                 return ControlFlow::CONTINUE;\n             }\n         }"}, {"sha": "f2682b8bcd838178a28f0f87510b950c5394b839", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -3,7 +3,7 @@ pub use self::def_id_forest::DefIdForest;\n use crate::ty;\n use crate::ty::context::TyCtxt;\n use crate::ty::TyKind::*;\n-use crate::ty::{AdtDef, FieldDef, Ty, TyS, VariantDef};\n+use crate::ty::{AdtDef, FieldDef, Ty, VariantDef};\n use crate::ty::{AdtKind, Visibility};\n use crate::ty::{DefId, SubstsRef};\n \n@@ -184,10 +184,10 @@ impl<'tcx> FieldDef {\n     }\n }\n \n-impl<'tcx> TyS<'tcx> {\n+impl<'tcx> Ty<'tcx> {\n     /// Calculates the forest of `DefId`s from which this type is visibly uninhabited.\n     fn uninhabited_from(\n-        &'tcx self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> DefIdForest<'tcx> {"}, {"sha": "99c595fcdf18507072f3c5b530ce3357903a8f96", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -101,7 +101,7 @@ impl<'tcx> Instance<'tcx> {\n     /// lifetimes erased, allowing a `ParamEnv` to be specified for use during normalization.\n     pub fn ty(&self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> Ty<'tcx> {\n         let ty = tcx.type_of(self.def.def_id());\n-        tcx.subst_and_normalize_erasing_regions(self.substs, param_env, &ty)\n+        tcx.subst_and_normalize_erasing_regions(self.substs, param_env, ty)\n     }\n \n     /// Finds a crate that contains a monomorphization of this instance that\n@@ -642,7 +642,7 @@ fn polymorphize<'tcx>(\n \n         fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n             debug!(\"fold_ty: ty={:?}\", ty);\n-            match ty.kind {\n+            match *ty.kind() {\n                 ty::Closure(def_id, substs) => {\n                     let polymorphized_substs = polymorphize(\n                         self.tcx,"}, {"sha": "f0b7f2a653f45e761b1e7cca71c1af64d99f0139", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 66, "deletions": 93, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -29,6 +29,7 @@ use crate::ty::util::Discr;\n use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_hir as hir;\n@@ -42,10 +43,9 @@ use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{sym, Span};\n use rustc_target::abi::Align;\n \n-use std::cmp::Ordering;\n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n use std::ops::ControlFlow;\n-use std::{fmt, ptr, str};\n+use std::{fmt, str};\n \n pub use crate::ty::diagnostics::*;\n pub use rustc_type_ir::InferTy::*;\n@@ -59,7 +59,9 @@ pub use self::closure::{\n     RootVariableMinCaptureList, UpvarCapture, UpvarCaptureMap, UpvarId, UpvarListMap, UpvarPath,\n     CAPTURE_STRUCT_LOCAL,\n };\n-pub use self::consts::{Const, ConstInt, ConstKind, InferConst, ScalarInt, Unevaluated, ValTree};\n+pub use self::consts::{\n+    Const, ConstInt, ConstKind, ConstS, InferConst, ScalarInt, Unevaluated, ValTree,\n+};\n pub use self::context::{\n     tls, CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n     CtxtInterners, DelaySpanBugEmitted, FreeRegionInfo, GeneratorInteriorTypeCause, GlobalCtxt,\n@@ -380,21 +382,25 @@ pub struct CReaderCacheKey {\n \n /// Represents a type.\n ///\n-/// IMPORTANT: Every `TyS` is *required* to have unique contents. The type's\n-/// correctness relies on this, *but it does not enforce it*. Therefore, any\n-/// code that creates a `TyS` must ensure uniqueness itself. In practice this\n-/// is achieved by interning.\n+/// IMPORTANT:\n+/// - This is a very \"dumb\" struct (with no derives and no `impls`).\n+/// - Values of this type are always interned and thus unique, and are stored\n+///   as an `Interned<TyS>`.\n+/// - `Ty` (which contains a reference to a `Interned<TyS>`) or `Interned<TyS>`\n+///   should be used everywhere instead of `TyS`. In particular, `Ty` has most\n+///   of the relevant methods.\n+#[derive(PartialEq, Eq, PartialOrd, Ord)]\n #[allow(rustc::usage_of_ty_tykind)]\n-pub struct TyS<'tcx> {\n+crate struct TyS<'tcx> {\n     /// This field shouldn't be used directly and may be removed in the future.\n-    /// Use `TyS::kind()` instead.\n+    /// Use `Ty::kind()` instead.\n     kind: TyKind<'tcx>,\n \n     /// This field provides fast access to information that is also contained\n     /// in `kind`.\n     ///\n     /// This field shouldn't be used directly and may be removed in the future.\n-    /// Use `TyS::flags()` instead.\n+    /// Use `Ty::flags()` instead.\n     flags: TypeFlags,\n \n     /// This field provides fast access to information that is also contained\n@@ -420,72 +426,40 @@ pub struct TyS<'tcx> {\n     outer_exclusive_binder: ty::DebruijnIndex,\n }\n \n-impl<'tcx> TyS<'tcx> {\n-    /// A constructor used only for internal testing.\n-    #[allow(rustc::usage_of_ty_tykind)]\n-    pub fn make_for_test(\n-        kind: TyKind<'tcx>,\n-        flags: TypeFlags,\n-        outer_exclusive_binder: ty::DebruijnIndex,\n-    ) -> TyS<'tcx> {\n-        TyS { kind, flags, outer_exclusive_binder }\n-    }\n-}\n-\n // `TyS` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(TyS<'_>, 40);\n \n-impl<'tcx> Ord for TyS<'tcx> {\n-    fn cmp(&self, other: &TyS<'tcx>) -> Ordering {\n-        self.kind().cmp(other.kind())\n-    }\n-}\n-\n-impl<'tcx> PartialOrd for TyS<'tcx> {\n-    fn partial_cmp(&self, other: &TyS<'tcx>) -> Option<Ordering> {\n-        Some(self.kind().cmp(other.kind()))\n-    }\n-}\n-\n-impl<'tcx> PartialEq for TyS<'tcx> {\n-    #[inline]\n-    fn eq(&self, other: &TyS<'tcx>) -> bool {\n-        // Pointer equality implies equality (due to the unique contents\n-        // assumption).\n-        ptr::eq(self, other)\n-    }\n-}\n-impl<'tcx> Eq for TyS<'tcx> {}\n-\n-impl<'tcx> Hash for TyS<'tcx> {\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        // Pointer hashing is sufficient (due to the unique contents\n-        // assumption).\n-        (self as *const TyS<'_>).hash(s)\n-    }\n-}\n+/// Use this rather than `TyS`, whenever possible.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[rustc_diagnostic_item = \"Ty\"]\n+#[cfg_attr(not(bootstrap), rustc_pass_by_value)]\n+pub struct Ty<'tcx>(Interned<'tcx, TyS<'tcx>>);\n+\n+// Statics only used for internal testing.\n+pub static BOOL_TY: Ty<'static> = Ty(Interned::new_unchecked(&BOOL_TYS));\n+static BOOL_TYS: TyS<'static> = TyS {\n+    kind: ty::Bool,\n+    flags: TypeFlags::empty(),\n+    outer_exclusive_binder: DebruijnIndex::from_usize(0),\n+};\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TyS<'tcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Ty<'tcx> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let ty::TyS {\n+        let TyS {\n             ref kind,\n \n             // The other fields just provide fast access to information that is\n             // also contained in `kind`, so no need to hash them.\n             flags: _,\n \n             outer_exclusive_binder: _,\n-        } = *self;\n+        } = self.0.0;\n \n         kind.hash_stable(hcx, hasher);\n     }\n }\n \n-#[rustc_diagnostic_item = \"Ty\"]\n-#[cfg_attr(not(bootstrap), rustc_pass_by_value)]\n-pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n-\n impl ty::EarlyBoundRegion {\n     /// Does this early bound region have a name? Early bound regions normally\n     /// always have names except when using anonymous lifetimes (`'_`).\n@@ -494,51 +468,50 @@ impl ty::EarlyBoundRegion {\n     }\n }\n \n+/// Represents a predicate.\n+///\n+/// See comments on `TyS`, which apply here too (albeit for\n+/// `PredicateS`/`Predicate` rather than `TyS`/`Ty`).\n #[derive(Debug)]\n-crate struct PredicateInner<'tcx> {\n+crate struct PredicateS<'tcx> {\n     kind: Binder<'tcx, PredicateKind<'tcx>>,\n     flags: TypeFlags,\n     /// See the comment for the corresponding field of [TyS].\n     outer_exclusive_binder: ty::DebruijnIndex,\n }\n \n+// This type is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(PredicateInner<'_>, 56);\n-\n-#[derive(Clone, Copy, Lift)]\n-pub struct Predicate<'tcx> {\n-    inner: &'tcx PredicateInner<'tcx>,\n-}\n+static_assert_size!(PredicateS<'_>, 56);\n \n-impl<'tcx> PartialEq for Predicate<'tcx> {\n-    fn eq(&self, other: &Self) -> bool {\n-        // `self.kind` is always interned.\n-        ptr::eq(self.inner, other.inner)\n-    }\n-}\n-\n-impl Hash for Predicate<'_> {\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        (self.inner as *const PredicateInner<'_>).hash(s)\n-    }\n-}\n-\n-impl<'tcx> Eq for Predicate<'tcx> {}\n+/// Use this rather than `PredicateS`, whenever possible.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[cfg_attr(not(bootstrap), rustc_pass_by_value)]\n+pub struct Predicate<'tcx>(Interned<'tcx, PredicateS<'tcx>>);\n \n impl<'tcx> Predicate<'tcx> {\n     /// Gets the inner `Binder<'tcx, PredicateKind<'tcx>>`.\n     #[inline]\n     pub fn kind(self) -> Binder<'tcx, PredicateKind<'tcx>> {\n-        self.inner.kind\n+        self.0.kind\n+    }\n+\n+    #[inline(always)]\n+    pub fn flags(self) -> TypeFlags {\n+        self.0.flags\n+    }\n+\n+    #[inline(always)]\n+    pub fn outer_exclusive_binder(self) -> DebruijnIndex {\n+        self.0.outer_exclusive_binder\n     }\n \n     /// Flips the polarity of a Predicate.\n     ///\n     /// Given `T: Trait` predicate it returns `T: !Trait` and given `T: !Trait` returns `T: Trait`.\n-    pub fn flip_polarity(&self, tcx: TyCtxt<'tcx>) -> Option<Predicate<'tcx>> {\n+    pub fn flip_polarity(self, tcx: TyCtxt<'tcx>) -> Option<Predicate<'tcx>> {\n         let kind = self\n-            .inner\n-            .kind\n+            .kind()\n             .map_bound(|kind| match kind {\n                 PredicateKind::Trait(TraitPredicate { trait_ref, constness, polarity }) => {\n                     Some(PredicateKind::Trait(TraitPredicate {\n@@ -558,14 +531,14 @@ impl<'tcx> Predicate<'tcx> {\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Predicate<'tcx> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let PredicateInner {\n+        let PredicateS {\n             ref kind,\n \n             // The other fields just provide fast access to information that is\n             // also contained in `kind`, so no need to hash them.\n             flags: _,\n             outer_exclusive_binder: _,\n-        } = self.inner;\n+        } = self.0.0;\n \n         kind.hash_stable(hcx, hasher);\n     }\n@@ -621,7 +594,7 @@ pub enum PredicateKind<'tcx> {\n     ConstEvaluatable(ty::Unevaluated<'tcx, ()>),\n \n     /// Constants must be equal. The first component is the const that is expected.\n-    ConstEquate(&'tcx Const<'tcx>, &'tcx Const<'tcx>),\n+    ConstEquate(Const<'tcx>, Const<'tcx>),\n \n     /// Represents a type found in the environment that we can use for implied bounds.\n     ///\n@@ -847,7 +820,7 @@ pub type PolyCoercePredicate<'tcx> = ty::Binder<'tcx, CoercePredicate<'tcx>>;\n #[derive(HashStable, TypeFoldable)]\n pub enum Term<'tcx> {\n     Ty(Ty<'tcx>),\n-    Const(&'tcx Const<'tcx>),\n+    Const(Const<'tcx>),\n }\n \n impl<'tcx> From<Ty<'tcx>> for Term<'tcx> {\n@@ -856,18 +829,18 @@ impl<'tcx> From<Ty<'tcx>> for Term<'tcx> {\n     }\n }\n \n-impl<'tcx> From<&'tcx Const<'tcx>> for Term<'tcx> {\n-    fn from(c: &'tcx Const<'tcx>) -> Self {\n+impl<'tcx> From<Const<'tcx>> for Term<'tcx> {\n+    fn from(c: Const<'tcx>) -> Self {\n         Term::Const(c)\n     }\n }\n \n impl<'tcx> Term<'tcx> {\n     pub fn ty(&self) -> Option<Ty<'tcx>> {\n-        if let Term::Ty(ty) = self { Some(ty) } else { None }\n+        if let Term::Ty(ty) = self { Some(*ty) } else { None }\n     }\n-    pub fn ct(&self) -> Option<&'tcx Const<'tcx>> {\n-        if let Term::Const(c) = self { Some(c) } else { None }\n+    pub fn ct(&self) -> Option<Const<'tcx>> {\n+        if let Term::Const(c) = self { Some(*c) } else { None }\n     }\n }\n "}, {"sha": "808be446b2af66920b70c439e15329ad18549863", "filename": "compiler/rustc_middle/src/ty/normalize_erasing_regions.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -192,7 +192,7 @@ impl<'tcx> TypeFolder<'tcx> for NormalizeAfterErasingRegionsFolder<'tcx> {\n         self.normalize_generic_arg_after_erasing_regions(ty.into()).expect_ty()\n     }\n \n-    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(&mut self, c: ty::Const<'tcx>) -> ty::Const<'tcx> {\n         self.normalize_generic_arg_after_erasing_regions(c.into()).expect_const()\n     }\n \n@@ -244,13 +244,10 @@ impl<'tcx> FallibleTypeFolder<'tcx> for TryNormalizeAfterErasingRegionsFolder<'t\n         }\n     }\n \n-    fn try_fold_const(\n-        &mut self,\n-        c: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+    fn try_fold_const(&mut self, c: ty::Const<'tcx>) -> Result<ty::Const<'tcx>, Self::Error> {\n         match self.try_normalize_generic_arg_after_erasing_regions(c.into()) {\n             Ok(t) => Ok(t.expect_const()),\n-            Err(_) => Err(NormalizationError::Const(*c)),\n+            Err(_) => Err(NormalizationError::Const(c)),\n         }\n     }\n "}, {"sha": "086bb950f1a87406448e0ceb74ea9c8dc5e6d6a7", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -66,7 +66,7 @@ pub trait Printer<'tcx>: Sized {\n         predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     ) -> Result<Self::DynExistential, Self::Error>;\n \n-    fn print_const(self, ct: &'tcx ty::Const<'tcx>) -> Result<Self::Const, Self::Error>;\n+    fn print_const(self, ct: ty::Const<'tcx>) -> Result<Self::Const, Self::Error>;\n \n     fn path_crate(self, cnum: CrateNum) -> Result<Self::Path, Self::Error>;\n \n@@ -326,27 +326,19 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n     characteristic_def_id_of_type_cached(ty, &mut SsoHashSet::new())\n }\n \n-impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for ty::RegionKind {\n-    type Output = P::Region;\n-    type Error = P::Error;\n-    fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n-        cx.print_region(self)\n-    }\n-}\n-\n impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for ty::Region<'_> {\n     type Output = P::Region;\n     type Error = P::Error;\n     fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n-        cx.print_region(self)\n+        cx.print_region(*self)\n     }\n }\n \n impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for Ty<'tcx> {\n     type Output = P::Type;\n     type Error = P::Error;\n     fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n-        cx.print_type(self)\n+        cx.print_type(*self)\n     }\n }\n \n@@ -360,10 +352,10 @@ impl<'tcx, P: Printer<'tcx>> Print<'tcx, P>\n     }\n }\n \n-impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for &'tcx ty::Const<'tcx> {\n+impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for ty::Const<'tcx> {\n     type Output = P::Const;\n     type Error = P::Error;\n     fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n-        cx.print_const(self)\n+        cx.print_const(*self)\n     }\n }"}, {"sha": "893df1a009cfc26efc48ba94f22f8b1ffb6d9b67", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 62, "deletions": 44, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -3,6 +3,7 @@ use crate::ty::subst::{GenericArg, GenericArgKind, Subst};\n use crate::ty::{self, ConstInt, DefIdTree, ParamConst, ScalarInt, Term, Ty, TyCtxt, TypeFoldable};\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sso::SsoHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::{self, CtorKind, DefKind, Namespace};\n@@ -130,11 +131,13 @@ pub fn with_no_visible_paths<F: FnOnce() -> R, R>(f: F) -> R {\n ///\n /// Regions not selected by the region highlight mode are presently\n /// unaffected.\n-#[derive(Copy, Clone, Default)]\n-pub struct RegionHighlightMode {\n+#[derive(Copy, Clone)]\n+pub struct RegionHighlightMode<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+\n     /// If enabled, when we see the selected region, use \"`'N`\"\n     /// instead of the ordinary behavior.\n-    highlight_regions: [Option<(ty::RegionKind, usize)>; 3],\n+    highlight_regions: [Option<(ty::Region<'tcx>, usize)>; 3],\n \n     /// If enabled, when printing a \"free region\" that originated from\n     /// the given `ty::BoundRegionKind`, print it as \"`'1`\". Free regions that would ordinarily\n@@ -146,12 +149,20 @@ pub struct RegionHighlightMode {\n     highlight_bound_region: Option<(ty::BoundRegionKind, usize)>,\n }\n \n-impl RegionHighlightMode {\n+impl<'tcx> RegionHighlightMode<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>) -> Self {\n+        Self {\n+            tcx,\n+            highlight_regions: Default::default(),\n+            highlight_bound_region: Default::default(),\n+        }\n+    }\n+\n     /// If `region` and `number` are both `Some`, invokes\n     /// `highlighting_region`.\n     pub fn maybe_highlighting_region(\n         &mut self,\n-        region: Option<ty::Region<'_>>,\n+        region: Option<ty::Region<'tcx>>,\n         number: Option<usize>,\n     ) {\n         if let Some(k) = region {\n@@ -162,24 +173,24 @@ impl RegionHighlightMode {\n     }\n \n     /// Highlights the region inference variable `vid` as `'N`.\n-    pub fn highlighting_region(&mut self, region: ty::Region<'_>, number: usize) {\n+    pub fn highlighting_region(&mut self, region: ty::Region<'tcx>, number: usize) {\n         let num_slots = self.highlight_regions.len();\n         let first_avail_slot =\n             self.highlight_regions.iter_mut().find(|s| s.is_none()).unwrap_or_else(|| {\n                 bug!(\"can only highlight {} placeholders at a time\", num_slots,)\n             });\n-        *first_avail_slot = Some((*region, number));\n+        *first_avail_slot = Some((region, number));\n     }\n \n     /// Convenience wrapper for `highlighting_region`.\n     pub fn highlighting_region_vid(&mut self, vid: ty::RegionVid, number: usize) {\n-        self.highlighting_region(&ty::ReVar(vid), number)\n+        self.highlighting_region(self.tcx.mk_region(ty::ReVar(vid)), number)\n     }\n \n     /// Returns `Some(n)` with the number to use for the given region, if any.\n     fn region_highlighted(&self, region: ty::Region<'_>) -> Option<usize> {\n         self.highlight_regions.iter().find_map(|h| match h {\n-            Some((r, n)) if r == region => Some(*n),\n+            Some((r, n)) if *r == region => Some(*n),\n             _ => None,\n         })\n     }\n@@ -743,14 +754,14 @@ pub trait PrettyPrinter<'tcx>:\n                 p!(\"[\", print(ty), \"; \");\n                 if self.tcx().sess.verbose() {\n                     p!(write(\"{:?}\", sz));\n-                } else if let ty::ConstKind::Unevaluated(..) = sz.val {\n+                } else if let ty::ConstKind::Unevaluated(..) = sz.val() {\n                     // Do not try to evaluate unevaluated constants. If we are const evaluating an\n                     // array length anon const, rustc will (with debug assertions) print the\n                     // constant's path. Which will end up here again.\n                     p!(\"_\");\n-                } else if let Some(n) = sz.val.try_to_bits(self.tcx().data_layout.pointer_size) {\n+                } else if let Some(n) = sz.val().try_to_bits(self.tcx().data_layout.pointer_size) {\n                     p!(write(\"{}\", n));\n-                } else if let ty::ConstKind::Param(param) = sz.val {\n+                } else if let ty::ConstKind::Param(param) = sz.val() {\n                     p!(write(\"{}\", param));\n                 } else {\n                     p!(\"_\");\n@@ -1053,7 +1064,7 @@ pub trait PrettyPrinter<'tcx>:\n \n                     // Don't print `'_` if there's no unerased regions.\n                     let print_regions = args.iter().any(|arg| match arg.unpack() {\n-                        GenericArgKind::Lifetime(r) => *r != ty::ReErased,\n+                        GenericArgKind::Lifetime(r) => !r.is_erased(),\n                         _ => false,\n                     });\n                     let mut args = args.iter().cloned().filter(|arg| match arg.unpack() {\n@@ -1137,13 +1148,13 @@ pub trait PrettyPrinter<'tcx>:\n \n     fn pretty_print_const(\n         mut self,\n-        ct: &'tcx ty::Const<'tcx>,\n+        ct: ty::Const<'tcx>,\n         print_ty: bool,\n     ) -> Result<Self::Const, Self::Error> {\n         define_scoped_cx!(self);\n \n         if self.tcx().sess.verbose() {\n-            p!(write(\"Const({:?}: {:?})\", ct.val, ct.ty));\n+            p!(write(\"Const({:?}: {:?})\", ct.val(), ct.ty()));\n             return Ok(self);\n         }\n \n@@ -1155,7 +1166,7 @@ pub trait PrettyPrinter<'tcx>:\n                             write!(this, \"_\")?;\n                             Ok(this)\n                         },\n-                        |this| this.print_type(ct.ty),\n+                        |this| this.print_type(ct.ty()),\n                         \": \",\n                     )?;\n                 } else {\n@@ -1164,7 +1175,7 @@ pub trait PrettyPrinter<'tcx>:\n             }};\n         }\n \n-        match ct.val {\n+        match ct.val() {\n             ty::ConstKind::Unevaluated(ty::Unevaluated {\n                 def,\n                 substs,\n@@ -1195,7 +1206,7 @@ pub trait PrettyPrinter<'tcx>:\n             ty::ConstKind::Infer(..) => print_underscore!(),\n             ty::ConstKind::Param(ParamConst { name, .. }) => p!(write(\"{}\", name)),\n             ty::ConstKind::Value(value) => {\n-                return self.pretty_print_const_value(value, ct.ty, print_ty);\n+                return self.pretty_print_const_value(value, ct.ty(), print_ty);\n             }\n \n             ty::ConstKind::Bound(debruijn, bound_var) => {\n@@ -1232,16 +1243,23 @@ pub trait PrettyPrinter<'tcx>:\n             // Byte strings (&[u8; N])\n             ty::Ref(\n                 _,\n-                ty::TyS {\n-                    kind:\n-                        ty::Array(\n-                            ty::TyS { kind: ty::Uint(ty::UintTy::U8), .. },\n-                            ty::Const {\n-                                val: ty::ConstKind::Value(ConstValue::Scalar(int)), ..\n-                            },\n-                        ),\n-                    ..\n-                },\n+                Ty(Interned(\n+                    ty::TyS {\n+                        kind:\n+                            ty::Array(\n+                                Ty(Interned(ty::TyS { kind: ty::Uint(ty::UintTy::U8), .. }, _)),\n+                                ty::Const(Interned(\n+                                    ty::ConstS {\n+                                        val: ty::ConstKind::Value(ConstValue::Scalar(int)),\n+                                        ..\n+                                    },\n+                                    _,\n+                                )),\n+                            ),\n+                        ..\n+                    },\n+                    _,\n+                )),\n                 _,\n             ) => match self.tcx().get_global_alloc(alloc_id) {\n                 Some(GlobalAlloc::Memory(alloc)) => {\n@@ -1399,7 +1417,7 @@ pub trait PrettyPrinter<'tcx>:\n             // Byte/string slices, printed as (byte) string literals.\n             (\n                 ConstValue::Slice { data, start, end },\n-                ty::Ref(_, ty::TyS { kind: ty::Slice(t), .. }, _),\n+                ty::Ref(_, Ty(Interned(ty::TyS { kind: ty::Slice(t), .. }, _)), _),\n             ) if *t == u8_type => {\n                 // The `inspect` here is okay since we checked the bounds, and there are\n                 // no relocations (we have an active slice reference here). We don't use\n@@ -1409,7 +1427,7 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             (\n                 ConstValue::Slice { data, start, end },\n-                ty::Ref(_, ty::TyS { kind: ty::Str, .. }, _),\n+                ty::Ref(_, Ty(Interned(ty::TyS { kind: ty::Str, .. }, _)), _),\n             ) => {\n                 // The `inspect` here is okay since we checked the bounds, and there are no\n                 // relocations (we have an active `str` reference here). We don't use this\n@@ -1420,7 +1438,7 @@ pub trait PrettyPrinter<'tcx>:\n                 Ok(self)\n             }\n             (ConstValue::ByRef { alloc, offset }, ty::Array(t, n)) if *t == u8_type => {\n-                let n = n.val.try_to_bits(self.tcx().data_layout.pointer_size).unwrap();\n+                let n = n.val().try_to_bits(self.tcx().data_layout.pointer_size).unwrap();\n                 // cast is ok because we already checked for pointer size (32 or 64 bit) above\n                 let range = AllocRange { start: offset, size: Size::from_bytes(n) };\n \n@@ -1441,10 +1459,10 @@ pub trait PrettyPrinter<'tcx>:\n             // FIXME(eddyb) for `--emit=mir`/`-Z dump-mir`, we should provide the\n             // correct `ty::ParamEnv` to allow printing *all* constant values.\n             (_, ty::Array(..) | ty::Tuple(..) | ty::Adt(..)) if !ty.has_param_types_or_consts() => {\n-                let contents = self.tcx().destructure_const(\n-                    ty::ParamEnv::reveal_all()\n-                        .and(self.tcx().mk_const(ty::Const { val: ty::ConstKind::Value(ct), ty })),\n-                );\n+                let contents =\n+                    self.tcx().destructure_const(ty::ParamEnv::reveal_all().and(\n+                        self.tcx().mk_const(ty::ConstS { val: ty::ConstKind::Value(ct), ty }),\n+                    ));\n                 let fields = contents.fields.iter().copied();\n \n                 match *ty.kind() {\n@@ -1531,7 +1549,7 @@ pub struct FmtPrinterData<'a, 'tcx, F> {\n     binder_depth: usize,\n     printed_type_count: usize,\n \n-    pub region_highlight_mode: RegionHighlightMode,\n+    pub region_highlight_mode: RegionHighlightMode<'tcx>,\n \n     pub name_resolver: Option<Box<&'a dyn Fn(ty::TyVid) -> Option<String>>>,\n }\n@@ -1561,7 +1579,7 @@ impl<'a, 'tcx, F> FmtPrinter<'a, 'tcx, F> {\n             region_index: 0,\n             binder_depth: 0,\n             printed_type_count: 0,\n-            region_highlight_mode: RegionHighlightMode::default(),\n+            region_highlight_mode: RegionHighlightMode::new(tcx),\n             name_resolver: None,\n         }))\n     }\n@@ -1702,7 +1720,7 @@ impl<'tcx, F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         self.pretty_print_dyn_existential(predicates)\n     }\n \n-    fn print_const(self, ct: &'tcx ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n+    fn print_const(self, ct: ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n         self.pretty_print_const(ct, true)\n     }\n \n@@ -1797,7 +1815,7 @@ impl<'tcx, F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         // Don't print `'_` if there's no unerased regions.\n         let print_regions = self.tcx.sess.verbose()\n             || args.iter().any(|arg| match arg.unpack() {\n-                GenericArgKind::Lifetime(r) => *r != ty::ReErased,\n+                GenericArgKind::Lifetime(r) => !r.is_erased(),\n                 _ => false,\n             });\n         let args = args.iter().cloned().filter(|arg| match arg.unpack() {\n@@ -2056,7 +2074,7 @@ impl<'a, 'tcx> ty::TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         let name = &mut self.name;\n         let region = match *r {\n-            ty::ReLateBound(_, br) => self.region_map.entry(br).or_insert_with(|| name(br)),\n+            ty::ReLateBound(_, br) => *self.region_map.entry(br).or_insert_with(|| name(br)),\n             ty::RePlaceholder(ty::PlaceholderRegion { name: kind, .. }) => {\n                 // If this is an anonymous placeholder, don't rename. Otherwise, in some\n                 // async fns, we get a `for<'r> Send` bound\n@@ -2065,7 +2083,7 @@ impl<'a, 'tcx> ty::TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n                     _ => {\n                         // Index doesn't matter, since this is just for naming and these never get bound\n                         let br = ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind };\n-                        self.region_map.entry(br).or_insert_with(|| name(br))\n+                        *self.region_map.entry(br).or_insert_with(|| name(br))\n                     }\n                 }\n             }\n@@ -2267,7 +2285,7 @@ impl<'tcx, F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n \n             #[instrument(skip(self), level = \"trace\")]\n             fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                trace!(\"address: {:p}\", r);\n+                trace!(\"address: {:p}\", r.0.0);\n                 if let ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name), .. }) = *r {\n                     self.used_region_names.insert(name);\n                 } else if let ty::RePlaceholder(ty::PlaceholderRegion {\n@@ -2364,7 +2382,7 @@ macro_rules! define_print_and_forward_display {\n }\n \n // HACK(eddyb) this is separate because `ty::RegionKind` doesn't need lifting.\n-impl fmt::Display for ty::RegionKind {\n+impl<'tcx> fmt::Display for ty::Region<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         ty::tls::with(|tcx| {\n             self.print(FmtPrinter::new(tcx, f, Namespace::TypeNS))?;\n@@ -2439,7 +2457,7 @@ impl<'tcx> ty::PolyTraitPredicate<'tcx> {\n forward_display_to_print! {\n     Ty<'tcx>,\n     &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n-    &'tcx ty::Const<'tcx>,\n+    ty::Const<'tcx>,\n \n     // HACK(eddyb) these are exhaustive instead of generic,\n     // because `for<'tcx>` isn't possible yet."}, {"sha": "b59fb6afe6fe70eb23cc43729993ce8c28915a41", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -89,9 +89,9 @@ pub trait TypeRelation<'tcx>: Sized {\n \n     fn consts(\n         &mut self,\n-        a: &'tcx ty::Const<'tcx>,\n-        b: &'tcx ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>;\n+        a: ty::Const<'tcx>,\n+        b: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>>;\n \n     fn binders<T>(\n         &mut self,\n@@ -149,8 +149,8 @@ pub fn relate_substs<'tcx, R: TypeRelation<'tcx>>(\n             Some((ty_def_id, variances)) => {\n                 let variance = variances[i];\n                 let variance_info = if variance == ty::Invariant {\n-                    let ty =\n-                        cached_ty.get_or_insert_with(|| tcx.type_of(ty_def_id).subst(tcx, a_subst));\n+                    let ty = *cached_ty\n+                        .get_or_insert_with(|| tcx.type_of(ty_def_id).subst(tcx, a_subst));\n                     ty::VarianceDiagInfo::Invariant { ty, param_index: i.try_into().unwrap() }\n                 } else {\n                     ty::VarianceDiagInfo::default()\n@@ -545,31 +545,31 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n /// it.\n pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n     relation: &mut R,\n-    a: &'tcx ty::Const<'tcx>,\n-    b: &'tcx ty::Const<'tcx>,\n-) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+    a: ty::Const<'tcx>,\n+    b: ty::Const<'tcx>,\n+) -> RelateResult<'tcx, ty::Const<'tcx>> {\n     debug!(\"{}.super_relate_consts(a = {:?}, b = {:?})\", relation.tag(), a, b);\n     let tcx = relation.tcx();\n \n     // FIXME(oli-obk): once const generics can have generic types, this assertion\n     // will likely get triggered. Move to `normalize_erasing_regions` at that point.\n-    let a_ty = tcx.erase_regions(a.ty);\n-    let b_ty = tcx.erase_regions(b.ty);\n+    let a_ty = tcx.erase_regions(a.ty());\n+    let b_ty = tcx.erase_regions(b.ty());\n     if a_ty != b_ty {\n         relation.tcx().sess.delay_span_bug(\n             DUMMY_SP,\n             &format!(\"cannot relate constants of different types: {} != {}\", a_ty, b_ty),\n         );\n     }\n \n-    let eagerly_eval = |x: &'tcx ty::Const<'tcx>| x.eval(tcx, relation.param_env());\n+    let eagerly_eval = |x: ty::Const<'tcx>| x.eval(tcx, relation.param_env());\n     let a = eagerly_eval(a);\n     let b = eagerly_eval(b);\n \n     // Currently, the values that can be unified are primitive types,\n     // and those that derive both `PartialEq` and `Eq`, corresponding\n     // to structural-match types.\n-    let is_match = match (a.val, b.val) {\n+    let is_match = match (a.val(), b.val()) {\n         (ty::ConstKind::Infer(_), _) | (_, ty::ConstKind::Infer(_)) => {\n             // The caller should handle these cases!\n             bug!(\"var types encountered in super_relate_consts: {:?} {:?}\", a, b)\n@@ -602,13 +602,13 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n                 au.substs,\n                 bu.substs,\n             )?;\n-            return Ok(tcx.mk_const(ty::Const {\n+            return Ok(tcx.mk_const(ty::ConstS {\n                 val: ty::ConstKind::Unevaluated(ty::Unevaluated {\n                     def: au.def,\n                     substs,\n                     promoted: au.promoted,\n                 }),\n-                ty: a.ty,\n+                ty: a.ty(),\n             }));\n         }\n         _ => false,\n@@ -621,8 +621,8 @@ fn check_const_value_eq<'tcx, R: TypeRelation<'tcx>>(\n     a_val: ConstValue<'tcx>,\n     b_val: ConstValue<'tcx>,\n     // FIXME(oli-obk): these arguments should go away with valtrees\n-    a: &'tcx ty::Const<'tcx>,\n-    b: &'tcx ty::Const<'tcx>,\n+    a: ty::Const<'tcx>,\n+    b: ty::Const<'tcx>,\n     // FIXME(oli-obk): this should just be `bool` with valtrees\n ) -> RelateResult<'tcx, bool> {\n     let tcx = relation.tcx();\n@@ -648,9 +648,9 @@ fn check_const_value_eq<'tcx, R: TypeRelation<'tcx>>(\n         }\n \n         (ConstValue::ByRef { alloc: alloc_a, .. }, ConstValue::ByRef { alloc: alloc_b, .. })\n-            if a.ty.is_ref() || b.ty.is_ref() =>\n+            if a.ty().is_ref() || b.ty().is_ref() =>\n         {\n-            if a.ty.is_ref() && b.ty.is_ref() {\n+            if a.ty().is_ref() && b.ty().is_ref() {\n                 alloc_a == alloc_b\n             } else {\n                 false\n@@ -663,7 +663,7 @@ fn check_const_value_eq<'tcx, R: TypeRelation<'tcx>>(\n             // Both the variant and each field have to be equal.\n             if a_destructured.variant == b_destructured.variant {\n                 for (a_field, b_field) in iter::zip(a_destructured.fields, b_destructured.fields) {\n-                    relation.consts(a_field, b_field)?;\n+                    relation.consts(*a_field, *b_field)?;\n                 }\n \n                 true\n@@ -756,12 +756,12 @@ impl<'tcx> Relate<'tcx> for ty::Region<'tcx> {\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for &'tcx ty::Const<'tcx> {\n+impl<'tcx> Relate<'tcx> for ty::Const<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &'tcx ty::Const<'tcx>,\n-        b: &'tcx ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        a: ty::Const<'tcx>,\n+        b: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n         relation.consts(a, b)\n     }\n }"}, {"sha": "c1d714ed8d65e8db7c6f536dcdc5223b8cd32040", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -1078,7 +1078,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     }\n \n     fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        visitor.visit_ty(self)\n+        visitor.visit_ty(*self)\n     }\n }\n \n@@ -1112,24 +1112,24 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n         self,\n         folder: &mut F,\n     ) -> Result<Self, F::Error> {\n-        let new = self.inner.kind.try_fold_with(folder)?;\n+        let new = self.kind().try_fold_with(folder)?;\n         Ok(folder.tcx().reuse_or_mk_predicate(self, new))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.inner.kind.visit_with(visitor)\n+        self.kind().visit_with(visitor)\n     }\n \n     fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n         visitor.visit_predicate(*self)\n     }\n \n     fn has_vars_bound_at_or_above(&self, binder: ty::DebruijnIndex) -> bool {\n-        self.inner.outer_exclusive_binder > binder\n+        self.outer_exclusive_binder() > binder\n     }\n \n     fn has_type_flags(&self, flags: ty::TypeFlags) -> bool {\n-        self.inner.flags.intersects(flags)\n+        self.flags().intersects(flags)\n     }\n }\n \n@@ -1159,15 +1159,15 @@ impl<'tcx, T: TypeFoldable<'tcx>, I: Idx> TypeFoldable<'tcx> for IndexVec<I, T>\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for ty::Const<'tcx> {\n     fn try_super_fold_with<F: FallibleTypeFolder<'tcx>>(\n         self,\n         folder: &mut F,\n     ) -> Result<Self, F::Error> {\n-        let ty = self.ty.try_fold_with(folder)?;\n-        let val = self.val.try_fold_with(folder)?;\n-        if ty != self.ty || val != self.val {\n-            Ok(folder.tcx().mk_const(ty::Const { ty, val }))\n+        let ty = self.ty().try_fold_with(folder)?;\n+        let val = self.val().try_fold_with(folder)?;\n+        if ty != self.ty() || val != self.val() {\n+            Ok(folder.tcx().mk_const(ty::ConstS { ty, val }))\n         } else {\n             Ok(self)\n         }\n@@ -1178,12 +1178,12 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.ty.visit_with(visitor)?;\n-        self.val.visit_with(visitor)\n+        self.ty().visit_with(visitor)?;\n+        self.val().visit_with(visitor)\n     }\n \n     fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        visitor.visit_const(self)\n+        visitor.visit_const(*self)\n     }\n }\n "}, {"sha": "9835211a74865f6733e63645f9c28c6335cc476e", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 126, "deletions": 85, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -9,9 +9,10 @@ use crate::ty::fold::ValidateBoundVars;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n use crate::ty::InferTy::{self, *};\n use crate::ty::{self, AdtDef, DefIdTree, Discr, Term, Ty, TyCtxt, TypeFlags, TypeFoldable};\n-use crate::ty::{DelaySpanBugEmitted, List, ParamEnv, TyS};\n+use crate::ty::{DelaySpanBugEmitted, List, ParamEnv};\n use polonius_engine::Atom;\n use rustc_data_structures::captures::Captures;\n+use rustc_data_structures::intern::Interned;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::Idx;\n@@ -21,8 +22,9 @@ use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi;\n use std::borrow::Cow;\n use std::cmp::Ordering;\n+use std::fmt;\n use std::marker::PhantomData;\n-use std::ops::Range;\n+use std::ops::{Deref, Range};\n use ty::util::IntTypeExt;\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n@@ -114,7 +116,7 @@ pub enum TyKind<'tcx> {\n     Str,\n \n     /// An array with the given length. Written as `[T; N]`.\n-    Array(Ty<'tcx>, &'tcx ty::Const<'tcx>),\n+    Array(Ty<'tcx>, ty::Const<'tcx>),\n \n     /// The pointee of an array slice. Written as `[T]`.\n     Slice(Ty<'tcx>),\n@@ -196,7 +198,7 @@ pub enum TyKind<'tcx> {\n     Never,\n \n     /// A tuple type. For example, `(i32, bool)`.\n-    /// Use `TyS::tuple_fields` to iterate over the field types.\n+    /// Use `Ty::tuple_fields` to iterate over the field types.\n     Tuple(SubstsRef<'tcx>),\n \n     /// The projection of an associated type. For example,\n@@ -282,7 +284,7 @@ static_assert_size!(TyKind<'_>, 32);\n ///   in scope on the function that defined the closure,\n /// - CK represents the *closure kind* (Fn vs FnMut vs FnOnce). This\n ///   is rather hackily encoded via a scalar type. See\n-///   `TyS::to_opt_closure_kind` for details.\n+///   `Ty::to_opt_closure_kind` for details.\n /// - CS represents the *closure signature*, representing as a `fn()`\n ///   type. For example, `fn(u32, u32) -> u32` would mean that the closure\n ///   implements `CK<(u32, u32), Output = u32>`, where `CK` is the trait\n@@ -1391,14 +1393,34 @@ impl ParamConst {\n     }\n }\n \n-pub type Region<'tcx> = &'tcx RegionKind;\n+/// Use this rather than `TyKind`, whenever possible.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable)]\n+#[cfg_attr(not(bootstrap), rustc_pass_by_value)]\n+pub struct Region<'tcx>(pub Interned<'tcx, RegionKind>);\n+\n+impl<'tcx> Deref for Region<'tcx> {\n+    type Target = RegionKind;\n+\n+    fn deref(&self) -> &RegionKind {\n+        &self.0.0\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for Region<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:?}\", self.kind())\n+    }\n+}\n \n /// Representation of regions. Note that the NLL checker uses a distinct\n /// representation of regions. For this reason, it internally replaces all the\n /// regions with inference variables -- the index of the variable is then used\n /// to index into internal NLL data structures. See `rustc_const_eval::borrow_check`\n /// module for more information.\n ///\n+/// Note: operations are on the wrapper `Region` type, which is interned,\n+/// rather than this type.\n+///\n /// ## The Region lattice within a given function\n ///\n /// In general, the region lattice looks like\n@@ -1655,40 +1677,59 @@ impl<'tcx> PolyExistentialProjection<'tcx> {\n }\n \n /// Region utilities\n-impl RegionKind {\n+impl<'tcx> Region<'tcx> {\n+    pub fn kind(self) -> RegionKind {\n+        *self.0.0\n+    }\n+\n     /// Is this region named by the user?\n-    pub fn has_name(&self) -> bool {\n+    pub fn has_name(self) -> bool {\n         match *self {\n-            RegionKind::ReEarlyBound(ebr) => ebr.has_name(),\n-            RegionKind::ReLateBound(_, br) => br.kind.is_named(),\n-            RegionKind::ReFree(fr) => fr.bound_region.is_named(),\n-            RegionKind::ReStatic => true,\n-            RegionKind::ReVar(..) => false,\n-            RegionKind::RePlaceholder(placeholder) => placeholder.name.is_named(),\n-            RegionKind::ReEmpty(_) => false,\n-            RegionKind::ReErased => false,\n+            ty::ReEarlyBound(ebr) => ebr.has_name(),\n+            ty::ReLateBound(_, br) => br.kind.is_named(),\n+            ty::ReFree(fr) => fr.bound_region.is_named(),\n+            ty::ReStatic => true,\n+            ty::ReVar(..) => false,\n+            ty::RePlaceholder(placeholder) => placeholder.name.is_named(),\n+            ty::ReEmpty(_) => false,\n+            ty::ReErased => false,\n         }\n     }\n \n     #[inline]\n-    pub fn is_late_bound(&self) -> bool {\n+    pub fn is_static(self) -> bool {\n+        matches!(*self, ty::ReStatic)\n+    }\n+\n+    #[inline]\n+    pub fn is_erased(self) -> bool {\n+        matches!(*self, ty::ReErased)\n+    }\n+\n+    #[inline]\n+    pub fn is_late_bound(self) -> bool {\n         matches!(*self, ty::ReLateBound(..))\n     }\n \n     #[inline]\n-    pub fn is_placeholder(&self) -> bool {\n+    pub fn is_placeholder(self) -> bool {\n         matches!(*self, ty::RePlaceholder(..))\n     }\n \n     #[inline]\n-    pub fn bound_at_or_above_binder(&self, index: ty::DebruijnIndex) -> bool {\n+    pub fn is_empty(self) -> bool {\n+        matches!(*self, ty::ReEmpty(..))\n+    }\n+\n+    #[inline]\n+    pub fn bound_at_or_above_binder(self, index: ty::DebruijnIndex) -> bool {\n         match *self {\n             ty::ReLateBound(debruijn, _) => debruijn >= index,\n             _ => false,\n         }\n     }\n \n-    pub fn type_flags(&self) -> TypeFlags {\n+    pub fn type_flags(self) -> TypeFlags {\n         let mut flags = TypeFlags::empty();\n \n         match *self {\n@@ -1746,8 +1787,8 @@ impl RegionKind {\n     /// of the impl, and for all the other highlighted regions, it\n     /// would return the `DefId` of the function. In other cases (not shown), this\n     /// function might return the `DefId` of a closure.\n-    pub fn free_region_binding_scope(&self, tcx: TyCtxt<'_>) -> DefId {\n-        match self {\n+    pub fn free_region_binding_scope(self, tcx: TyCtxt<'_>) -> DefId {\n+        match *self {\n             ty::ReEarlyBound(br) => tcx.parent(br.def_id).unwrap(),\n             ty::ReFree(fr) => fr.scope,\n             _ => bug!(\"free_region_binding_scope invoked on inappropriate region: {:?}\", self),\n@@ -1756,117 +1797,117 @@ impl RegionKind {\n }\n \n /// Type utilities\n-impl<'tcx> TyS<'tcx> {\n+impl<'tcx> Ty<'tcx> {\n     #[inline(always)]\n-    pub fn kind(&self) -> &TyKind<'tcx> {\n-        &self.kind\n+    pub fn kind(self) -> &'tcx TyKind<'tcx> {\n+        &self.0.0.kind\n     }\n \n     #[inline(always)]\n-    pub fn flags(&self) -> TypeFlags {\n-        self.flags\n+    pub fn flags(self) -> TypeFlags {\n+        self.0.0.flags\n     }\n \n     #[inline]\n-    pub fn is_unit(&self) -> bool {\n+    pub fn is_unit(self) -> bool {\n         match self.kind() {\n             Tuple(ref tys) => tys.is_empty(),\n             _ => false,\n         }\n     }\n \n     #[inline]\n-    pub fn is_never(&self) -> bool {\n+    pub fn is_never(self) -> bool {\n         matches!(self.kind(), Never)\n     }\n \n     #[inline]\n-    pub fn is_primitive(&self) -> bool {\n+    pub fn is_primitive(self) -> bool {\n         self.kind().is_primitive()\n     }\n \n     #[inline]\n-    pub fn is_adt(&self) -> bool {\n+    pub fn is_adt(self) -> bool {\n         matches!(self.kind(), Adt(..))\n     }\n \n     #[inline]\n-    pub fn is_ref(&self) -> bool {\n+    pub fn is_ref(self) -> bool {\n         matches!(self.kind(), Ref(..))\n     }\n \n     #[inline]\n-    pub fn is_ty_var(&self) -> bool {\n+    pub fn is_ty_var(self) -> bool {\n         matches!(self.kind(), Infer(TyVar(_)))\n     }\n \n     #[inline]\n-    pub fn ty_vid(&self) -> Option<ty::TyVid> {\n+    pub fn ty_vid(self) -> Option<ty::TyVid> {\n         match self.kind() {\n             &Infer(TyVar(vid)) => Some(vid),\n             _ => None,\n         }\n     }\n \n     #[inline]\n-    pub fn is_ty_infer(&self) -> bool {\n+    pub fn is_ty_infer(self) -> bool {\n         matches!(self.kind(), Infer(_))\n     }\n \n     #[inline]\n-    pub fn is_phantom_data(&self) -> bool {\n+    pub fn is_phantom_data(self) -> bool {\n         if let Adt(def, _) = self.kind() { def.is_phantom_data() } else { false }\n     }\n \n     #[inline]\n-    pub fn is_bool(&self) -> bool {\n+    pub fn is_bool(self) -> bool {\n         *self.kind() == Bool\n     }\n \n     /// Returns `true` if this type is a `str`.\n     #[inline]\n-    pub fn is_str(&self) -> bool {\n+    pub fn is_str(self) -> bool {\n         *self.kind() == Str\n     }\n \n     #[inline]\n-    pub fn is_param(&self, index: u32) -> bool {\n+    pub fn is_param(self, index: u32) -> bool {\n         match self.kind() {\n             ty::Param(ref data) => data.index == index,\n             _ => false,\n         }\n     }\n \n     #[inline]\n-    pub fn is_slice(&self) -> bool {\n+    pub fn is_slice(self) -> bool {\n         match self.kind() {\n             RawPtr(TypeAndMut { ty, .. }) | Ref(_, ty, _) => matches!(ty.kind(), Slice(_) | Str),\n             _ => false,\n         }\n     }\n \n     #[inline]\n-    pub fn is_array(&self) -> bool {\n+    pub fn is_array(self) -> bool {\n         matches!(self.kind(), Array(..))\n     }\n \n     #[inline]\n-    pub fn is_simd(&self) -> bool {\n+    pub fn is_simd(self) -> bool {\n         match self.kind() {\n             Adt(def, _) => def.repr.simd(),\n             _ => false,\n         }\n     }\n \n-    pub fn sequence_element_type(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+    pub fn sequence_element_type(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match self.kind() {\n-            Array(ty, _) | Slice(ty) => ty,\n+            Array(ty, _) | Slice(ty) => *ty,\n             Str => tcx.types.u8,\n             _ => bug!(\"`sequence_element_type` called on non-sequence value: {}\", self),\n         }\n     }\n \n-    pub fn simd_size_and_type(&self, tcx: TyCtxt<'tcx>) -> (u64, Ty<'tcx>) {\n+    pub fn simd_size_and_type(self, tcx: TyCtxt<'tcx>) -> (u64, Ty<'tcx>) {\n         match self.kind() {\n             Adt(def, substs) => {\n                 assert!(def.repr.simd(), \"`simd_size_and_type` called on non-SIMD type\");\n@@ -1881,7 +1922,7 @@ impl<'tcx> TyS<'tcx> {\n                         // The way we evaluate the `N` in `[T; N]` here only works since we use\n                         // `simd_size_and_type` post-monomorphization. It will probably start to ICE\n                         // if we use it in generic code. See the `simd-array-trait` ui test.\n-                        (f0_len.eval_usize(tcx, ParamEnv::empty()) as u64, f0_elem_ty)\n+                        (f0_len.eval_usize(tcx, ParamEnv::empty()) as u64, *f0_elem_ty)\n                     }\n                     // Otherwise, the fields of this Adt are the SIMD components (and we assume they\n                     // all have the same type).\n@@ -1893,12 +1934,12 @@ impl<'tcx> TyS<'tcx> {\n     }\n \n     #[inline]\n-    pub fn is_region_ptr(&self) -> bool {\n+    pub fn is_region_ptr(self) -> bool {\n         matches!(self.kind(), Ref(..))\n     }\n \n     #[inline]\n-    pub fn is_mutable_ptr(&self) -> bool {\n+    pub fn is_mutable_ptr(self) -> bool {\n         matches!(\n             self.kind(),\n             RawPtr(TypeAndMut { mutbl: hir::Mutability::Mut, .. })\n@@ -1908,34 +1949,34 @@ impl<'tcx> TyS<'tcx> {\n \n     /// Get the mutability of the reference or `None` when not a reference\n     #[inline]\n-    pub fn ref_mutability(&self) -> Option<hir::Mutability> {\n+    pub fn ref_mutability(self) -> Option<hir::Mutability> {\n         match self.kind() {\n             Ref(_, _, mutability) => Some(*mutability),\n             _ => None,\n         }\n     }\n \n     #[inline]\n-    pub fn is_unsafe_ptr(&self) -> bool {\n+    pub fn is_unsafe_ptr(self) -> bool {\n         matches!(self.kind(), RawPtr(_))\n     }\n \n     /// Tests if this is any kind of primitive pointer type (reference, raw pointer, fn pointer).\n     #[inline]\n-    pub fn is_any_ptr(&self) -> bool {\n+    pub fn is_any_ptr(self) -> bool {\n         self.is_region_ptr() || self.is_unsafe_ptr() || self.is_fn_ptr()\n     }\n \n     #[inline]\n-    pub fn is_box(&self) -> bool {\n+    pub fn is_box(self) -> bool {\n         match self.kind() {\n             Adt(def, _) => def.is_box(),\n             _ => false,\n         }\n     }\n \n     /// Panics if called on any type other than `Box<T>`.\n-    pub fn boxed_ty(&self) -> Ty<'tcx> {\n+    pub fn boxed_ty(self) -> Ty<'tcx> {\n         match self.kind() {\n             Adt(def, substs) if def.is_box() => substs.type_at(0),\n             _ => bug!(\"`boxed_ty` is called on non-box type {:?}\", self),\n@@ -1946,7 +1987,7 @@ impl<'tcx> TyS<'tcx> {\n     /// (A RawPtr is scalar because it represents a non-managed pointer, so its\n     /// contents are abstract to rustc.)\n     #[inline]\n-    pub fn is_scalar(&self) -> bool {\n+    pub fn is_scalar(self) -> bool {\n         matches!(\n             self.kind(),\n             Bool | Char\n@@ -1962,99 +2003,99 @@ impl<'tcx> TyS<'tcx> {\n \n     /// Returns `true` if this type is a floating point type.\n     #[inline]\n-    pub fn is_floating_point(&self) -> bool {\n+    pub fn is_floating_point(self) -> bool {\n         matches!(self.kind(), Float(_) | Infer(FloatVar(_)))\n     }\n \n     #[inline]\n-    pub fn is_trait(&self) -> bool {\n+    pub fn is_trait(self) -> bool {\n         matches!(self.kind(), Dynamic(..))\n     }\n \n     #[inline]\n-    pub fn is_enum(&self) -> bool {\n+    pub fn is_enum(self) -> bool {\n         matches!(self.kind(), Adt(adt_def, _) if adt_def.is_enum())\n     }\n \n     #[inline]\n-    pub fn is_union(&self) -> bool {\n+    pub fn is_union(self) -> bool {\n         matches!(self.kind(), Adt(adt_def, _) if adt_def.is_union())\n     }\n \n     #[inline]\n-    pub fn is_closure(&self) -> bool {\n+    pub fn is_closure(self) -> bool {\n         matches!(self.kind(), Closure(..))\n     }\n \n     #[inline]\n-    pub fn is_generator(&self) -> bool {\n+    pub fn is_generator(self) -> bool {\n         matches!(self.kind(), Generator(..))\n     }\n \n     #[inline]\n-    pub fn is_integral(&self) -> bool {\n+    pub fn is_integral(self) -> bool {\n         matches!(self.kind(), Infer(IntVar(_)) | Int(_) | Uint(_))\n     }\n \n     #[inline]\n-    pub fn is_fresh_ty(&self) -> bool {\n+    pub fn is_fresh_ty(self) -> bool {\n         matches!(self.kind(), Infer(FreshTy(_)))\n     }\n \n     #[inline]\n-    pub fn is_fresh(&self) -> bool {\n+    pub fn is_fresh(self) -> bool {\n         matches!(self.kind(), Infer(FreshTy(_) | FreshIntTy(_) | FreshFloatTy(_)))\n     }\n \n     #[inline]\n-    pub fn is_char(&self) -> bool {\n+    pub fn is_char(self) -> bool {\n         matches!(self.kind(), Char)\n     }\n \n     #[inline]\n-    pub fn is_numeric(&self) -> bool {\n+    pub fn is_numeric(self) -> bool {\n         self.is_integral() || self.is_floating_point()\n     }\n \n     #[inline]\n-    pub fn is_signed(&self) -> bool {\n+    pub fn is_signed(self) -> bool {\n         matches!(self.kind(), Int(_))\n     }\n \n     #[inline]\n-    pub fn is_ptr_sized_integral(&self) -> bool {\n+    pub fn is_ptr_sized_integral(self) -> bool {\n         matches!(self.kind(), Int(ty::IntTy::Isize) | Uint(ty::UintTy::Usize))\n     }\n \n     #[inline]\n-    pub fn has_concrete_skeleton(&self) -> bool {\n+    pub fn has_concrete_skeleton(self) -> bool {\n         !matches!(self.kind(), Param(_) | Infer(_) | Error(_))\n     }\n \n     /// Returns the type and mutability of `*ty`.\n     ///\n     /// The parameter `explicit` indicates if this is an *explicit* dereference.\n     /// Some types -- notably unsafe ptrs -- can only be dereferenced explicitly.\n-    pub fn builtin_deref(&self, explicit: bool) -> Option<TypeAndMut<'tcx>> {\n+    pub fn builtin_deref(self, explicit: bool) -> Option<TypeAndMut<'tcx>> {\n         match self.kind() {\n             Adt(def, _) if def.is_box() => {\n                 Some(TypeAndMut { ty: self.boxed_ty(), mutbl: hir::Mutability::Not })\n             }\n-            Ref(_, ty, mutbl) => Some(TypeAndMut { ty, mutbl: *mutbl }),\n+            Ref(_, ty, mutbl) => Some(TypeAndMut { ty: *ty, mutbl: *mutbl }),\n             RawPtr(mt) if explicit => Some(*mt),\n             _ => None,\n         }\n     }\n \n     /// Returns the type of `ty[i]`.\n-    pub fn builtin_index(&self) -> Option<Ty<'tcx>> {\n+    pub fn builtin_index(self) -> Option<Ty<'tcx>> {\n         match self.kind() {\n-            Array(ty, _) | Slice(ty) => Some(ty),\n+            Array(ty, _) | Slice(ty) => Some(*ty),\n             _ => None,\n         }\n     }\n \n-    pub fn fn_sig(&self, tcx: TyCtxt<'tcx>) -> PolyFnSig<'tcx> {\n+    pub fn fn_sig(self, tcx: TyCtxt<'tcx>) -> PolyFnSig<'tcx> {\n         match self.kind() {\n             FnDef(def_id, substs) => tcx.fn_sig(*def_id).subst(tcx, substs),\n             FnPtr(f) => *f,\n@@ -2070,22 +2111,22 @@ impl<'tcx> TyS<'tcx> {\n     }\n \n     #[inline]\n-    pub fn is_fn(&self) -> bool {\n+    pub fn is_fn(self) -> bool {\n         matches!(self.kind(), FnDef(..) | FnPtr(_))\n     }\n \n     #[inline]\n-    pub fn is_fn_ptr(&self) -> bool {\n+    pub fn is_fn_ptr(self) -> bool {\n         matches!(self.kind(), FnPtr(_))\n     }\n \n     #[inline]\n-    pub fn is_impl_trait(&self) -> bool {\n+    pub fn is_impl_trait(self) -> bool {\n         matches!(self.kind(), Opaque(..))\n     }\n \n     #[inline]\n-    pub fn ty_adt_def(&self) -> Option<&'tcx AdtDef> {\n+    pub fn ty_adt_def(self) -> Option<&'tcx AdtDef> {\n         match self.kind() {\n             Adt(adt, _) => Some(adt),\n             _ => None,\n@@ -2094,7 +2135,7 @@ impl<'tcx> TyS<'tcx> {\n \n     /// Iterates over tuple fields.\n     /// Panics when called on anything but a tuple.\n-    pub fn tuple_fields(&self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> {\n+    pub fn tuple_fields(self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> {\n         match self.kind() {\n             Tuple(substs) => substs.iter().map(|field| field.expect_ty()),\n             _ => bug!(\"tuple_fields called on non-tuple\"),\n@@ -2103,7 +2144,7 @@ impl<'tcx> TyS<'tcx> {\n \n     /// Get the `i`-th element of a tuple.\n     /// Panics when called on anything but a tuple.\n-    pub fn tuple_element_ty(&self, i: usize) -> Option<Ty<'tcx>> {\n+    pub fn tuple_element_ty(self, i: usize) -> Option<Ty<'tcx>> {\n         match self.kind() {\n             Tuple(substs) => substs.iter().nth(i).map(|field| field.expect_ty()),\n             _ => bug!(\"tuple_fields called on non-tuple\"),\n@@ -2114,7 +2155,7 @@ impl<'tcx> TyS<'tcx> {\n     //\n     // FIXME: This requires the optimized MIR in the case of generators.\n     #[inline]\n-    pub fn variant_range(&self, tcx: TyCtxt<'tcx>) -> Option<Range<VariantIdx>> {\n+    pub fn variant_range(self, tcx: TyCtxt<'tcx>) -> Option<Range<VariantIdx>> {\n         match self.kind() {\n             TyKind::Adt(adt, _) => Some(adt.variant_range()),\n             TyKind::Generator(def_id, substs, _) => {\n@@ -2130,7 +2171,7 @@ impl<'tcx> TyS<'tcx> {\n     // FIXME: This requires the optimized MIR in the case of generators.\n     #[inline]\n     pub fn discriminant_for_variant(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         variant_index: VariantIdx,\n     ) -> Option<Discr<'tcx>> {\n@@ -2151,7 +2192,7 @@ impl<'tcx> TyS<'tcx> {\n     }\n \n     /// Returns the type of the discriminant of this type.\n-    pub fn discriminant_ty(&'tcx self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+    pub fn discriminant_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match self.kind() {\n             ty::Adt(adt, _) if adt.is_enum() => adt.repr.discr_type().to_ty(tcx),\n             ty::Generator(_, substs, _) => substs.as_generator().discr_ty(tcx),\n@@ -2195,7 +2236,7 @@ impl<'tcx> TyS<'tcx> {\n \n     /// Returns the type of metadata for (potentially fat) pointers to this type.\n     pub fn ptr_metadata_ty(\n-        &'tcx self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         normalize: impl FnMut(Ty<'tcx>) -> Ty<'tcx>,\n     ) -> Ty<'tcx> {\n@@ -2256,7 +2297,7 @@ impl<'tcx> TyS<'tcx> {\n     /// to represent the closure kind, because it has not yet been\n     /// inferred. Once upvar inference (in `rustc_typeck/src/check/upvar.rs`)\n     /// is complete, that type variable will be unified.\n-    pub fn to_opt_closure_kind(&self) -> Option<ty::ClosureKind> {\n+    pub fn to_opt_closure_kind(self) -> Option<ty::ClosureKind> {\n         match self.kind() {\n             Int(int_ty) => match int_ty {\n                 ty::IntTy::I8 => Some(ty::ClosureKind::Fn),\n@@ -2285,7 +2326,7 @@ impl<'tcx> TyS<'tcx> {\n     /// bound such as `[_]: Copy`. A function with such a bound obviously never\n     /// can be called, but that doesn't mean it shouldn't typecheck. This is why\n     /// this method doesn't return `Option<bool>`.\n-    pub fn is_trivially_sized(&self, tcx: TyCtxt<'tcx>) -> bool {\n+    pub fn is_trivially_sized(self, tcx: TyCtxt<'tcx>) -> bool {\n         match self.kind() {\n             ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n             | ty::Uint(_)"}, {"sha": "151dbcea6b524d4d1b25c1f774cd512f53a4e70a", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -6,6 +6,7 @@ use crate::ty::fold::{FallibleTypeFolder, TypeFoldable, TypeFolder, TypeVisitor}\n use crate::ty::sty::{ClosureSubsts, GeneratorSubsts, InlineConstSubsts};\n use crate::ty::{self, Lift, List, ParamConst, Ty, TyCtxt};\n \n+use rustc_data_structures::intern::Interned;\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n use rustc_serialize::{self, Decodable, Encodable};\n@@ -25,10 +26,13 @@ use std::ops::ControlFlow;\n /// To reduce memory usage, a `GenericArg` is an interned pointer,\n /// with the lowest 2 bits being reserved for a tag to\n /// indicate the type (`Ty`, `Region`, or `Const`) it points to.\n+///\n+/// Note: the `PartialEq`, `Eq` and `Hash` derives are only valid because `Ty`,\n+/// `Region` and `Const` are all interned.\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct GenericArg<'tcx> {\n     ptr: NonZeroUsize,\n-    marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>, &'tcx ty::Const<'tcx>)>,\n+    marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>, ty::Const<'tcx>)>,\n }\n \n const TAG_MASK: usize = 0b11;\n@@ -40,26 +44,26 @@ const CONST_TAG: usize = 0b10;\n pub enum GenericArgKind<'tcx> {\n     Lifetime(ty::Region<'tcx>),\n     Type(Ty<'tcx>),\n-    Const(&'tcx ty::Const<'tcx>),\n+    Const(ty::Const<'tcx>),\n }\n \n impl<'tcx> GenericArgKind<'tcx> {\n     fn pack(self) -> GenericArg<'tcx> {\n         let (tag, ptr) = match self {\n             GenericArgKind::Lifetime(lt) => {\n                 // Ensure we can use the tag bits.\n-                assert_eq!(mem::align_of_val(lt) & TAG_MASK, 0);\n-                (REGION_TAG, lt as *const _ as usize)\n+                assert_eq!(mem::align_of_val(lt.0.0) & TAG_MASK, 0);\n+                (REGION_TAG, lt.0.0 as *const ty::RegionKind as usize)\n             }\n             GenericArgKind::Type(ty) => {\n                 // Ensure we can use the tag bits.\n-                assert_eq!(mem::align_of_val(ty) & TAG_MASK, 0);\n-                (TYPE_TAG, ty as *const _ as usize)\n+                assert_eq!(mem::align_of_val(ty.0.0) & TAG_MASK, 0);\n+                (TYPE_TAG, ty.0.0 as *const ty::TyS<'tcx> as usize)\n             }\n             GenericArgKind::Const(ct) => {\n                 // Ensure we can use the tag bits.\n-                assert_eq!(mem::align_of_val(ct) & TAG_MASK, 0);\n-                (CONST_TAG, ct as *const _ as usize)\n+                assert_eq!(mem::align_of_val(ct.0.0) & TAG_MASK, 0);\n+                (CONST_TAG, ct.0.0 as *const ty::ConstS<'tcx> as usize)\n             }\n         };\n \n@@ -101,8 +105,8 @@ impl<'tcx> From<Ty<'tcx>> for GenericArg<'tcx> {\n     }\n }\n \n-impl<'tcx> From<&'tcx ty::Const<'tcx>> for GenericArg<'tcx> {\n-    fn from(c: &'tcx ty::Const<'tcx>) -> GenericArg<'tcx> {\n+impl<'tcx> From<ty::Const<'tcx>> for GenericArg<'tcx> {\n+    fn from(c: ty::Const<'tcx>) -> GenericArg<'tcx> {\n         GenericArgKind::Const(c).pack()\n     }\n }\n@@ -111,11 +115,20 @@ impl<'tcx> GenericArg<'tcx> {\n     #[inline]\n     pub fn unpack(self) -> GenericArgKind<'tcx> {\n         let ptr = self.ptr.get();\n+        // SAFETY: use of `Interned::new_unchecked` here is ok because these\n+        // pointers were originally created from `Interned` types in `pack()`,\n+        // and this is just going in the other direction.\n         unsafe {\n             match ptr & TAG_MASK {\n-                REGION_TAG => GenericArgKind::Lifetime(&*((ptr & !TAG_MASK) as *const _)),\n-                TYPE_TAG => GenericArgKind::Type(&*((ptr & !TAG_MASK) as *const _)),\n-                CONST_TAG => GenericArgKind::Const(&*((ptr & !TAG_MASK) as *const _)),\n+                REGION_TAG => GenericArgKind::Lifetime(ty::Region(Interned::new_unchecked(\n+                    &*((ptr & !TAG_MASK) as *const ty::RegionKind),\n+                ))),\n+                TYPE_TAG => GenericArgKind::Type(Ty(Interned::new_unchecked(\n+                    &*((ptr & !TAG_MASK) as *const ty::TyS<'tcx>),\n+                ))),\n+                CONST_TAG => GenericArgKind::Const(ty::Const(Interned::new_unchecked(\n+                    &*((ptr & !TAG_MASK) as *const ty::ConstS<'tcx>),\n+                ))),\n                 _ => intrinsics::unreachable(),\n             }\n         }\n@@ -132,7 +145,7 @@ impl<'tcx> GenericArg<'tcx> {\n     }\n \n     /// Unpack the `GenericArg` as a const when it is known certainly to be a const.\n-    pub fn expect_const(self) -> &'tcx ty::Const<'tcx> {\n+    pub fn expect_const(self) -> ty::Const<'tcx> {\n         match self.unpack() {\n             GenericArgKind::Const(c) => c,\n             _ => bug!(\"expected a const, but found another kind\"),\n@@ -289,7 +302,7 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n     }\n \n     #[inline]\n-    pub fn consts(&'a self) -> impl DoubleEndedIterator<Item = &'tcx ty::Const<'tcx>> + 'a {\n+    pub fn consts(&'a self) -> impl DoubleEndedIterator<Item = ty::Const<'tcx>> + 'a {\n         self.iter().filter_map(|k| {\n             if let GenericArgKind::Const(ct) = k.unpack() { Some(ct) } else { None }\n         })\n@@ -324,7 +337,7 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n     }\n \n     #[inline]\n-    pub fn const_at(&self, i: usize) -> &'tcx ty::Const<'tcx> {\n+    pub fn const_at(&self, i: usize) -> ty::Const<'tcx> {\n         if let GenericArgKind::Const(ct) = self[i].unpack() {\n             ct\n         } else {\n@@ -503,8 +516,8 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n         }\n     }\n \n-    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ty::ConstKind::Param(p) = c.val {\n+    fn fold_const(&mut self, c: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+        if let ty::ConstKind::Param(p) = c.val() {\n             self.const_for_param(p, c)\n         } else {\n             c.super_fold_with(self)\n@@ -553,11 +566,7 @@ impl<'a, 'tcx> SubstFolder<'a, 'tcx> {\n         self.shift_vars_through_binders(ty)\n     }\n \n-    fn const_for_param(\n-        &self,\n-        p: ParamConst,\n-        source_ct: &'tcx ty::Const<'tcx>,\n-    ) -> &'tcx ty::Const<'tcx> {\n+    fn const_for_param(&self, p: ParamConst, source_ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n         // Look up the const in the substitutions. It really should be in there.\n         let opt_ct = self.substs.get(p.index as usize).map(|k| k.unpack());\n         let ct = match opt_ct {"}, {"sha": "c2a4cea2b1ae66f09c132941ce0891e39f29a9f3", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -5,12 +5,15 @@ use crate::ty::fold::{FallibleTypeFolder, TypeFolder};\n use crate::ty::layout::IntegerExt;\n use crate::ty::query::TyCtxtAt;\n use crate::ty::subst::{GenericArgKind, Subst, SubstsRef};\n-use crate::ty::TyKind::*;\n-use crate::ty::{self, DebruijnIndex, DefIdTree, List, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{\n+    self, Const, DebruijnIndex, DefIdTree, List, ReEarlyBound, Region, Ty, TyCtxt, TyKind::*,\n+    TypeFoldable,\n+};\n use rustc_apfloat::Float as _;\n use rustc_ast as ast;\n use rustc_attr::{self as attr, SignedInt, UnsignedInt};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n@@ -389,15 +392,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         let result = iter::zip(item_substs, impl_substs)\n             .filter(|&(_, k)| {\n                 match k.unpack() {\n-                    GenericArgKind::Lifetime(&ty::RegionKind::ReEarlyBound(ref ebr)) => {\n+                    GenericArgKind::Lifetime(Region(Interned(ReEarlyBound(ref ebr), _))) => {\n                         !impl_generics.region_param(ebr, self).pure_wrt_drop\n                     }\n-                    GenericArgKind::Type(&ty::TyS { kind: ty::Param(ref pt), .. }) => {\n-                        !impl_generics.type_param(pt, self).pure_wrt_drop\n-                    }\n-                    GenericArgKind::Const(&ty::Const {\n-                        val: ty::ConstKind::Param(ref pc), ..\n-                    }) => !impl_generics.const_param(pc, self).pure_wrt_drop,\n+                    GenericArgKind::Type(Ty(Interned(\n+                        ty::TyS { kind: ty::Param(ref pt), .. },\n+                        _,\n+                    ))) => !impl_generics.type_param(pt, self).pure_wrt_drop,\n+                    GenericArgKind::Const(Const(Interned(\n+                        ty::ConstS { val: ty::ConstKind::Param(ref pc), .. },\n+                        _,\n+                    ))) => !impl_generics.const_param(pc, self).pure_wrt_drop,\n                     GenericArgKind::Lifetime(_)\n                     | GenericArgKind::Type(_)\n                     | GenericArgKind::Const(_) => {\n@@ -577,7 +582,7 @@ impl<'tcx> OpaqueTypeExpander<'tcx> {\n         let substs = substs.fold_with(self);\n         if !self.check_recursion || self.seen_opaque_tys.insert(def_id) {\n             let expanded_ty = match self.expanded_cache.get(&(def_id, substs)) {\n-                Some(expanded_ty) => expanded_ty,\n+                Some(expanded_ty) => *expanded_ty,\n                 None => {\n                     let generic_ty = self.tcx.type_of(def_id);\n                     let concrete_ty = generic_ty.subst(self.tcx, substs);\n@@ -606,7 +611,7 @@ impl<'tcx> TypeFolder<'tcx> for OpaqueTypeExpander<'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if let ty::Opaque(def_id, substs) = t.kind {\n+        if let ty::Opaque(def_id, substs) = *t.kind() {\n             self.expand_opaque_ty(def_id, substs).unwrap_or(t)\n         } else if t.has_opaque_types() {\n             t.super_fold_with(self)\n@@ -616,10 +621,10 @@ impl<'tcx> TypeFolder<'tcx> for OpaqueTypeExpander<'tcx> {\n     }\n }\n \n-impl<'tcx> ty::TyS<'tcx> {\n+impl<'tcx> Ty<'tcx> {\n     /// Returns the maximum value for the given numeric type (including `char`s)\n     /// or returns `None` if the type is not numeric.\n-    pub fn numeric_max_val(&'tcx self, tcx: TyCtxt<'tcx>) -> Option<&'tcx ty::Const<'tcx>> {\n+    pub fn numeric_max_val(self, tcx: TyCtxt<'tcx>) -> Option<Const<'tcx>> {\n         let val = match self.kind() {\n             ty::Int(_) | ty::Uint(_) => {\n                 let (size, signed) = int_size_and_signed(tcx, self);\n@@ -634,12 +639,12 @@ impl<'tcx> ty::TyS<'tcx> {\n             }),\n             _ => None,\n         };\n-        val.map(|v| ty::Const::from_bits(tcx, v, ty::ParamEnv::empty().and(self)))\n+        val.map(|v| Const::from_bits(tcx, v, ty::ParamEnv::empty().and(self)))\n     }\n \n     /// Returns the minimum value for the given numeric type (including `char`s)\n     /// or returns `None` if the type is not numeric.\n-    pub fn numeric_min_val(&'tcx self, tcx: TyCtxt<'tcx>) -> Option<&'tcx ty::Const<'tcx>> {\n+    pub fn numeric_min_val(self, tcx: TyCtxt<'tcx>) -> Option<Const<'tcx>> {\n         let val = match self.kind() {\n             ty::Int(_) | ty::Uint(_) => {\n                 let (size, signed) = int_size_and_signed(tcx, self);\n@@ -653,7 +658,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             }),\n             _ => None,\n         };\n-        val.map(|v| ty::Const::from_bits(tcx, v, ty::ParamEnv::empty().and(self)))\n+        val.map(|v| Const::from_bits(tcx, v, ty::ParamEnv::empty().and(self)))\n     }\n \n     /// Checks whether values of this type `T` are *moved* or *copied*\n@@ -664,7 +669,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// full requirements for the `Copy` trait (cc #29149) -- this\n     /// winds up being reported as an error during NLL borrow check.\n     pub fn is_copy_modulo_regions(\n-        &'tcx self,\n+        self,\n         tcx_at: TyCtxtAt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> bool {\n@@ -677,7 +682,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// over-approximation in generic contexts, where one can have\n     /// strange rules like `<T as Foo<'static>>::Bar: Sized` that\n     /// actually carry lifetime requirements.\n-    pub fn is_sized(&'tcx self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+    pub fn is_sized(self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         self.is_trivially_sized(tcx_at.tcx) || tcx_at.is_sized_raw(param_env.and(self))\n     }\n \n@@ -688,15 +693,15 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// optimization as well as the rules around static values. Note\n     /// that the `Freeze` trait is not exposed to end users and is\n     /// effectively an implementation detail.\n-    pub fn is_freeze(&'tcx self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+    pub fn is_freeze(self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         self.is_trivially_freeze() || tcx_at.is_freeze_raw(param_env.and(self))\n     }\n \n     /// Fast path helper for testing if a type is `Freeze`.\n     ///\n     /// Returning true means the type is known to be `Freeze`. Returning\n     /// `false` means nothing -- could be `Freeze`, might not be.\n-    fn is_trivially_freeze(&self) -> bool {\n+    fn is_trivially_freeze(self) -> bool {\n         match self.kind() {\n             ty::Int(_)\n             | ty::Uint(_)\n@@ -710,7 +715,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             | ty::FnDef(..)\n             | ty::Error(_)\n             | ty::FnPtr(_) => true,\n-            ty::Tuple(_) => self.tuple_fields().all(Self::is_trivially_freeze),\n+            ty::Tuple(_) => self.tuple_fields().all(|f| Self::is_trivially_freeze(f)),\n             ty::Slice(elem_ty) | ty::Array(elem_ty, _) => elem_ty.is_trivially_freeze(),\n             ty::Adt(..)\n             | ty::Bound(..)\n@@ -728,15 +733,15 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n \n     /// Checks whether values of this type `T` implement the `Unpin` trait.\n-    pub fn is_unpin(&'tcx self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+    pub fn is_unpin(self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         self.is_trivially_unpin() || tcx_at.is_unpin_raw(param_env.and(self))\n     }\n \n     /// Fast path helper for testing if a type is `Unpin`.\n     ///\n     /// Returning true means the type is known to be `Unpin`. Returning\n     /// `false` means nothing -- could be `Unpin`, might not be.\n-    fn is_trivially_unpin(&self) -> bool {\n+    fn is_trivially_unpin(self) -> bool {\n         match self.kind() {\n             ty::Int(_)\n             | ty::Uint(_)\n@@ -750,7 +755,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             | ty::FnDef(..)\n             | ty::Error(_)\n             | ty::FnPtr(_) => true,\n-            ty::Tuple(_) => self.tuple_fields().all(Self::is_trivially_unpin),\n+            ty::Tuple(_) => self.tuple_fields().all(|f| Self::is_trivially_unpin(f)),\n             ty::Slice(elem_ty) | ty::Array(elem_ty, _) => elem_ty.is_trivially_unpin(),\n             ty::Adt(..)\n             | ty::Bound(..)\n@@ -776,7 +781,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     ///\n     /// Note that this method is used to check eligible types in unions.\n     #[inline]\n-    pub fn needs_drop(&'tcx self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+    pub fn needs_drop(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         // Avoid querying in simple cases.\n         match needs_drop_components(self, &tcx.data_layout) {\n             Err(AlwaysRequiresDrop) => true,\n@@ -809,11 +814,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// Note that this method is used to check for change in drop order for\n     /// 2229 drop reorder migration analysis.\n     #[inline]\n-    pub fn has_significant_drop(\n-        &'tcx self,\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> bool {\n+    pub fn has_significant_drop(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         // Avoid querying in simple cases.\n         match needs_drop_components(self, &tcx.data_layout) {\n             Err(AlwaysRequiresDrop) => true,\n@@ -858,7 +859,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// want to know whether a given call to `PartialEq::eq` will proceed structurally all the way\n     /// down, you will need to use a type visitor.\n     #[inline]\n-    pub fn is_structural_eq_shallow(&'tcx self, tcx: TyCtxt<'tcx>) -> bool {\n+    pub fn is_structural_eq_shallow(self, tcx: TyCtxt<'tcx>) -> bool {\n         match self.kind() {\n             // Look for an impl of both `PartialStructuralEq` and `StructuralEq`.\n             Adt(..) => tcx.has_structural_eq_impls(self),\n@@ -903,16 +904,16 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// - `&'a mut u8` -> `u8`\n     /// - `&'a &'b u8` -> `u8`\n     /// - `&'a *const &'b u8 -> *const &'b u8`\n-    pub fn peel_refs(&'tcx self) -> Ty<'tcx> {\n+    pub fn peel_refs(self) -> Ty<'tcx> {\n         let mut ty = self;\n         while let Ref(_, inner_ty, _) = ty.kind() {\n-            ty = inner_ty;\n+            ty = *inner_ty;\n         }\n         ty\n     }\n \n-    pub fn outer_exclusive_binder(&'tcx self) -> DebruijnIndex {\n-        self.outer_exclusive_binder\n+    pub fn outer_exclusive_binder(self) -> DebruijnIndex {\n+        self.0.outer_exclusive_binder\n     }\n }\n \n@@ -993,11 +994,11 @@ pub fn needs_drop_components<'tcx>(\n \n         ty::Dynamic(..) | ty::Error(_) => Err(AlwaysRequiresDrop),\n \n-        ty::Slice(ty) => needs_drop_components(ty, target_layout),\n+        ty::Slice(ty) => needs_drop_components(*ty, target_layout),\n         ty::Array(elem_ty, size) => {\n-            match needs_drop_components(elem_ty, target_layout) {\n+            match needs_drop_components(*elem_ty, target_layout) {\n                 Ok(v) if v.is_empty() => Ok(v),\n-                res => match size.val.try_to_bits(target_layout.pointer_size) {\n+                res => match size.val().try_to_bits(target_layout.pointer_size) {\n                     // Arrays of size zero don't need drop, even if their element\n                     // type does.\n                     Some(0) => Ok(SmallVec::new()),"}, {"sha": "ab70c15160ca6e09749f3aab0dfe5e8e6fdfd50e", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -1,8 +1,8 @@\n //! An iterator over the type substructure.\n //! WARNING: this does not keep track of the region depth.\n \n-use crate::ty;\n use crate::ty::subst::{GenericArg, GenericArgKind};\n+use crate::ty::{self, Ty};\n use rustc_data_structures::sso::SsoHashSet;\n use smallvec::{self, SmallVec};\n \n@@ -96,7 +96,7 @@ impl<'tcx> GenericArg<'tcx> {\n     }\n }\n \n-impl<'tcx> super::TyS<'tcx> {\n+impl<'tcx> Ty<'tcx> {\n     /// Iterator that walks `self` and any types reachable from\n     /// `self`, in depth-first order. Note that just walks the types\n     /// that appear in `self`, it does not descend into the fields of\n@@ -107,7 +107,7 @@ impl<'tcx> super::TyS<'tcx> {\n     /// Foo<Bar<isize>> => { Foo<Bar<isize>>, Bar<isize>, isize }\n     /// [isize] => { [isize], isize }\n     /// ```\n-    pub fn walk(&'tcx self) -> TypeWalker<'tcx> {\n+    pub fn walk(self) -> TypeWalker<'tcx> {\n         TypeWalker::new(self.into())\n     }\n }\n@@ -189,8 +189,8 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n         },\n         GenericArgKind::Lifetime(_) => {}\n         GenericArgKind::Const(parent_ct) => {\n-            stack.push(parent_ct.ty.into());\n-            match parent_ct.val {\n+            stack.push(parent_ct.ty().into());\n+            match parent_ct.val() {\n                 ty::ConstKind::Infer(_)\n                 | ty::ConstKind::Param(_)\n                 | ty::ConstKind::Placeholder(_)"}, {"sha": "79ac09d523d079f55b7f5b4c6429a2b6d463d334", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -23,7 +23,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         inferred_ty: ty,\n                     })\n                 });\n-                assert_eq!(literal.ty, ty);\n+                assert_eq!(literal.ty(), ty);\n                 Constant { span, user_ty, literal: literal.into() }\n             }\n             ExprKind::StaticRef { literal, .. } => {"}, {"sha": "c706e6ef1d4664eacb472ce3f01c0a2577d20f9c", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -348,7 +348,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 let place_builder = place_builder.clone();\n                                 this.consume_by_copy_or_move(\n                                     place_builder\n-                                        .field(n, ty)\n+                                        .field(n, *ty)\n                                         .into_place(this.tcx, this.typeck_results),\n                                 )\n                             }"}, {"sha": "ec8cb30965d75467d0a6a1e2a26f19361ef61c25", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -964,13 +964,13 @@ enum TestKind<'tcx> {\n         ///\n         /// For `bool` we always generate two edges, one for `true` and one for\n         /// `false`.\n-        options: FxIndexMap<&'tcx ty::Const<'tcx>, u128>,\n+        options: FxIndexMap<ty::Const<'tcx>, u128>,\n     },\n \n     /// Test for equality with value, possibly after an unsizing coercion to\n     /// `ty`,\n     Eq {\n-        value: &'tcx ty::Const<'tcx>,\n+        value: ty::Const<'tcx>,\n         // Integer types are handled by `SwitchInt`, and constants with ADT\n         // types are converted back into patterns, so this can only be `&str`,\n         // `&[T]`, `f32` or `f64`."}, {"sha": "4f9a2c0ce779da4e53ea14d374ce0692ffa4e339", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -210,7 +210,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             PatKind::Range(PatRange { lo, hi, end }) => {\n-                let (range, bias) = match *lo.ty.kind() {\n+                let (range, bias) = match *lo.ty().kind() {\n                     ty::Char => {\n                         (Some(('\\u{0000}' as u128, '\\u{10FFFF}' as u128, Size::from_bits(32))), 0)\n                     }\n@@ -228,7 +228,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     _ => (None, 0),\n                 };\n                 if let Some((min, max, sz)) = range {\n-                    if let (Some(lo), Some(hi)) = (lo.val.try_to_bits(sz), hi.val.try_to_bits(sz)) {\n+                    if let (Some(lo), Some(hi)) =\n+                        (lo.val().try_to_bits(sz), hi.val().try_to_bits(sz))\n+                    {\n                         // We want to compare ranges numerically, but the order of the bitwise\n                         // representation of signed integers does not match their numeric order.\n                         // Thus, to correct the ordering, we need to shift the range of signed"}, {"sha": "ce848773b10cc6c1fb965ed8afa626ea13d0016e", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -59,8 +59,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             },\n \n             PatKind::Range(range) => {\n-                assert_eq!(range.lo.ty, match_pair.pattern.ty);\n-                assert_eq!(range.hi.ty, match_pair.pattern.ty);\n+                assert_eq!(range.lo.ty(), match_pair.pattern.ty);\n+                assert_eq!(range.hi.ty(), match_pair.pattern.ty);\n                 Test { span: match_pair.pattern.span, kind: TestKind::Range(range) }\n             }\n \n@@ -86,7 +86,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         test_place: &PlaceBuilder<'tcx>,\n         candidate: &Candidate<'pat, 'tcx>,\n         switch_ty: Ty<'tcx>,\n-        options: &mut FxIndexMap<&'tcx ty::Const<'tcx>, u128>,\n+        options: &mut FxIndexMap<ty::Const<'tcx>, u128>,\n     ) -> bool {\n         let Some(match_pair) = candidate.match_pairs.iter().find(|mp| mp.place == *test_place) else {\n             return false;\n@@ -266,7 +266,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         ty,\n                     );\n                 } else if let [success, fail] = *make_target_blocks(self) {\n-                    assert_eq!(value.ty, ty);\n+                    assert_eq!(value.ty(), ty);\n                     let expect = self.literal_operand(test.span, value);\n                     let val = Operand::Copy(place);\n                     self.compare(block, success, fail, source_info, BinOp::Eq, expect, val);\n@@ -275,7 +275,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            TestKind::Range(PatRange { ref lo, ref hi, ref end }) => {\n+            TestKind::Range(PatRange { lo, hi, ref end }) => {\n                 let lower_bound_success = self.cfg.start_new_block();\n                 let target_blocks = make_target_blocks(self);\n \n@@ -369,7 +369,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         block: BasicBlock,\n         make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n         source_info: SourceInfo,\n-        value: &'tcx ty::Const<'tcx>,\n+        value: ty::Const<'tcx>,\n         place: Place<'tcx>,\n         mut ty: Ty<'tcx>,\n     ) {\n@@ -390,14 +390,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             _ => None,\n         };\n         let opt_ref_ty = unsize(ty);\n-        let opt_ref_test_ty = unsize(value.ty);\n+        let opt_ref_test_ty = unsize(value.ty());\n         match (opt_ref_ty, opt_ref_test_ty) {\n             // nothing to do, neither is an array\n             (None, None) => {}\n             (Some((region, elem_ty, _)), _) | (None, Some((region, elem_ty, _))) => {\n                 let tcx = self.tcx;\n                 // make both a slice\n-                ty = tcx.mk_imm_ref(region, tcx.mk_slice(elem_ty));\n+                ty = tcx.mk_imm_ref(*region, tcx.mk_slice(*elem_ty));\n                 if opt_ref_ty.is_some() {\n                     let temp = self.temp(ty, source_info.span);\n                     self.cfg.push_assign(\n@@ -646,7 +646,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                     let tcx = self.tcx;\n \n-                    let test_ty = test.lo.ty;\n+                    let test_ty = test.lo.ty();\n                     let lo = compare_const_vals(tcx, test.lo, pat.hi, self.param_env, test_ty)?;\n                     let hi = compare_const_vals(tcx, test.hi, pat.lo, self.param_env, test_ty)?;\n \n@@ -764,17 +764,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         span_bug!(match_pair.pattern.span, \"simplifyable pattern found: {:?}\", match_pair.pattern)\n     }\n \n-    fn const_range_contains(\n-        &self,\n-        range: PatRange<'tcx>,\n-        value: &'tcx ty::Const<'tcx>,\n-    ) -> Option<bool> {\n+    fn const_range_contains(&self, range: PatRange<'tcx>, value: ty::Const<'tcx>) -> Option<bool> {\n         use std::cmp::Ordering::*;\n \n         let tcx = self.tcx;\n \n-        let a = compare_const_vals(tcx, range.lo, value, self.param_env, range.lo.ty)?;\n-        let b = compare_const_vals(tcx, value, range.hi, self.param_env, range.lo.ty)?;\n+        let a = compare_const_vals(tcx, range.lo, value, self.param_env, range.lo.ty())?;\n+        let b = compare_const_vals(tcx, value, range.hi, self.param_env, range.lo.ty())?;\n \n         match (b, range.end) {\n             (Less, _) | (Equal, RangeEnd::Included) if a != Greater => Some(true),\n@@ -785,7 +781,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn values_not_contained_in_range(\n         &self,\n         range: PatRange<'tcx>,\n-        options: &FxIndexMap<&'tcx ty::Const<'tcx>, u128>,\n+        options: &FxIndexMap<ty::Const<'tcx>, u128>,\n     ) -> Option<bool> {\n         for &val in options.keys() {\n             if self.const_range_contains(range, val)? {\n@@ -831,7 +827,7 @@ fn trait_method<'tcx>(\n     method_name: Symbol,\n     self_ty: Ty<'tcx>,\n     params: &[GenericArg<'tcx>],\n-) -> &'tcx ty::Const<'tcx> {\n+) -> ty::Const<'tcx> {\n     let substs = tcx.mk_substs_trait(self_ty, params);\n \n     // The unhygienic comparison here is acceptable because this is only"}, {"sha": "fd5914460140a84044acf8c62b889c51d56a0f07", "filename": "compiler/rustc_mir_build/src/build/misc.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -25,11 +25,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     /// Convenience function for creating a literal operand, one\n     /// without any user type annotation.\n-    crate fn literal_operand(\n-        &mut self,\n-        span: Span,\n-        literal: &'tcx ty::Const<'tcx>,\n-    ) -> Operand<'tcx> {\n+    crate fn literal_operand(&mut self, span: Span, literal: ty::Const<'tcx>) -> Operand<'tcx> {\n         let literal = literal.into();\n         let constant = Box::new(Constant { span, user_ty: None, literal });\n         Operand::Constant(constant)"}, {"sha": "fb403615e572f51755aab74c341b65a84fbc6d16", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -903,7 +903,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let mut closure_ty = self.local_decls[ty::CAPTURE_STRUCT_LOCAL].ty;\n             if let ty::Ref(_, ty, _) = closure_ty.kind() {\n                 closure_env_projs.push(ProjectionElem::Deref);\n-                closure_ty = ty;\n+                closure_ty = *ty;\n             }\n             let upvar_substs = match closure_ty.kind() {\n                 ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),"}, {"sha": "ec2ff3c37ab73526d852ae95dd6e627ec0af8508", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -10,7 +10,7 @@ use rustc_target::abi::Size;\n crate fn lit_to_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     lit_input: LitToConstInput<'tcx>,\n-) -> Result<&'tcx ty::Const<'tcx>, LitToConstError> {\n+) -> Result<ty::Const<'tcx>, LitToConstError> {\n     let LitToConstInput { lit, ty, neg } = lit_input;\n \n     let trunc = |n| {"}, {"sha": "29216776de163714ddc14710aeca0370ce6bfe4d", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -583,7 +583,7 @@ impl<'tcx> Cx<'tcx> {\n                     _ => span_bug!(expr.span, \"unexpected repeat expr ty: {:?}\", ty),\n                 };\n \n-                ExprKind::Repeat { value: self.mirror_expr(v), count }\n+                ExprKind::Repeat { value: self.mirror_expr(v), count: *count }\n             }\n             hir::ExprKind::Ret(ref v) => {\n                 ExprKind::Return { value: v.as_ref().map(|v| self.mirror_expr(v)) }\n@@ -708,7 +708,7 @@ impl<'tcx> Cx<'tcx> {\n                                 // in case we are offsetting from a computed discriminant\n                                 // and not the beginning of discriminants (which is always `0`)\n                                 let substs = InternalSubsts::identity_for_item(self.tcx(), did);\n-                                let lhs = ty::Const {\n+                                let lhs = ty::ConstS {\n                                     val: ty::ConstKind::Unevaluated(ty::Unevaluated::new(\n                                         ty::WithOptConstParam::unknown(did),\n                                         substs,\n@@ -890,7 +890,7 @@ impl<'tcx> Cx<'tcx> {\n                 let name = self.tcx.hir().name(hir_id);\n                 let val = ty::ConstKind::Param(ty::ParamConst::new(index, name));\n                 ExprKind::Literal {\n-                    literal: self.tcx.mk_const(ty::Const {\n+                    literal: self.tcx.mk_const(ty::ConstS {\n                         val,\n                         ty: self.typeck_results().node_type(expr.hir_id),\n                     }),\n@@ -903,7 +903,7 @@ impl<'tcx> Cx<'tcx> {\n                 let user_ty = self.user_substs_applied_to_res(expr.hir_id, res);\n                 debug!(\"convert_path_expr: (const) user_ty={:?}\", user_ty);\n                 ExprKind::Literal {\n-                    literal: self.tcx.mk_const(ty::Const {\n+                    literal: self.tcx.mk_const(ty::ConstS {\n                         val: ty::ConstKind::Unevaluated(ty::Unevaluated::new(\n                             ty::WithOptConstParam::unknown(def_id),\n                             substs,"}, {"sha": "a65a3ed31f638c8536edd79c8188c64ec3e39d8d", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -79,7 +79,7 @@ impl<'tcx> Cx<'tcx> {\n         ty: Ty<'tcx>,\n         sp: Span,\n         neg: bool,\n-    ) -> &'tcx ty::Const<'tcx> {\n+    ) -> ty::Const<'tcx> {\n         trace!(\"const_eval_literal: {:#?}, {:?}, {:?}, {:?}\", lit, ty, sp, neg);\n \n         match self.tcx.at(sp).lit_to_const(LitToConstInput { lit, ty, neg }) {"}, {"sha": "d357ac6930266914bd84de97c4ef3f63125002b2", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -556,7 +556,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n         }\n     }\n     if let ty::Ref(_, sub_ty, _) = scrut_ty.kind() {\n-        if cx.tcx.is_ty_uninhabited_from(cx.module, sub_ty, cx.param_env) {\n+        if cx.tcx.is_ty_uninhabited_from(cx.module, *sub_ty, cx.param_env) {\n             err.note(\"references are always considered inhabited\");\n         }\n     }"}, {"sha": "7db71ed598d932ec73ca3c56ffa9dff1554269bd", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -22,7 +22,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     pub(super) fn const_to_pat(\n         &self,\n-        cv: &'tcx ty::Const<'tcx>,\n+        cv: ty::Const<'tcx>,\n         id: hir::HirId,\n         span: Span,\n         mir_structural_match_violation: bool,\n@@ -152,11 +152,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         ty.is_structural_eq_shallow(self.infcx.tcx)\n     }\n \n-    fn to_pat(\n-        &mut self,\n-        cv: &'tcx ty::Const<'tcx>,\n-        mir_structural_match_violation: bool,\n-    ) -> Pat<'tcx> {\n+    fn to_pat(&mut self, cv: ty::Const<'tcx>, mir_structural_match_violation: bool) -> Pat<'tcx> {\n         trace!(self.treat_byte_string_as_slice);\n         // This method is just a wrapper handling a validity check; the heavy lifting is\n         // performed by the recursive `recur` method, which is not meant to be\n@@ -171,10 +167,11 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n             // If we were able to successfully convert the const to some pat,\n             // double-check that all types in the const implement `Structural`.\n \n-            let structural = self.search_for_structural_match_violation(cv.ty);\n+            let structural = self.search_for_structural_match_violation(cv.ty());\n             debug!(\n                 \"search_for_structural_match_violation cv.ty: {:?} returned: {:?}\",\n-                cv.ty, structural\n+                cv.ty(),\n+                structural\n             );\n \n             // This can occur because const qualification treats all associated constants as\n@@ -189,7 +186,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n             }\n \n             if let Some(msg) = structural {\n-                if !self.type_may_have_partial_eq_impl(cv.ty) {\n+                if !self.type_may_have_partial_eq_impl(cv.ty()) {\n                     // span_fatal avoids ICE from resolution of non-existent method (rare case).\n                     self.tcx().sess.span_fatal(self.span, &msg);\n                 } else if mir_structural_match_violation && !self.saw_const_match_lint.get() {\n@@ -247,7 +244,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n \n     fn field_pats(\n         &self,\n-        vals: impl Iterator<Item = &'tcx ty::Const<'tcx>>,\n+        vals: impl Iterator<Item = ty::Const<'tcx>>,\n     ) -> Result<Vec<FieldPat<'tcx>>, FallbackToConstRef> {\n         vals.enumerate()\n             .map(|(idx, val)| {\n@@ -260,15 +257,15 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n     // Recursive helper for `to_pat`; invoke that (instead of calling this directly).\n     fn recur(\n         &self,\n-        cv: &'tcx ty::Const<'tcx>,\n+        cv: ty::Const<'tcx>,\n         mir_structural_match_violation: bool,\n     ) -> Result<Pat<'tcx>, FallbackToConstRef> {\n         let id = self.id;\n         let span = self.span;\n         let tcx = self.tcx();\n         let param_env = self.param_env;\n \n-        let kind = match cv.ty.kind() {\n+        let kind = match cv.ty().kind() {\n             ty::Float(_) => {\n                 if self.include_lint_checks {\n                     tcx.struct_span_lint_hir(\n@@ -292,14 +289,14 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 PatKind::Wild\n             }\n             ty::Adt(..)\n-                if !self.type_may_have_partial_eq_impl(cv.ty)\n+                if !self.type_may_have_partial_eq_impl(cv.ty())\n                     // FIXME(#73448): Find a way to bring const qualification into parity with\n                     // `search_for_structural_match_violation` and then remove this condition.\n-                    && self.search_for_structural_match_violation(cv.ty).is_some() =>\n+                    && self.search_for_structural_match_violation(cv.ty()).is_some() =>\n             {\n                 // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n                 // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n-                let msg = self.search_for_structural_match_violation(cv.ty).unwrap();\n+                let msg = self.search_for_structural_match_violation(cv.ty()).unwrap();\n                 self.saw_const_match_error.set(true);\n                 if self.include_lint_checks {\n                     tcx.sess.span_err(self.span, &msg);\n@@ -317,7 +314,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n             // details.\n             // Backwards compatibility hack because we can't cause hard errors on these\n             // types, so we compare them via `PartialEq::eq` at runtime.\n-            ty::Adt(..) if !self.type_marked_structural(cv.ty) && self.behind_reference.get() => {\n+            ty::Adt(..) if !self.type_marked_structural(cv.ty()) && self.behind_reference.get() => {\n                 if self.include_lint_checks\n                     && !self.saw_const_match_error.get()\n                     && !self.saw_const_match_lint.get()\n@@ -331,7 +328,8 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                             let msg = format!(\n                                 \"to use a constant of type `{}` in a pattern, \\\n                                  `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                                cv.ty, cv.ty,\n+                                cv.ty(),\n+                                cv.ty(),\n                             );\n                             lint.build(&msg).emit()\n                         },\n@@ -342,8 +340,12 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // `PartialEq::eq` on it.\n                 return Err(fallback_to_const_ref(self));\n             }\n-            ty::Adt(adt_def, _) if !self.type_marked_structural(cv.ty) => {\n-                debug!(\"adt_def {:?} has !type_marked_structural for cv.ty: {:?}\", adt_def, cv.ty);\n+            ty::Adt(adt_def, _) if !self.type_marked_structural(cv.ty()) => {\n+                debug!(\n+                    \"adt_def {:?} has !type_marked_structural for cv.ty: {:?}\",\n+                    adt_def,\n+                    cv.ty()\n+                );\n                 let path = tcx.def_path_str(adt_def.did);\n                 let msg = format!(\n                     \"to use a constant of type `{}` in a pattern, \\\n@@ -378,7 +380,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                     .destructure_const(param_env.and(cv))\n                     .fields\n                     .iter()\n-                    .map(|val| self.recur(val, false))\n+                    .map(|val| self.recur(*val, false))\n                     .collect::<Result<_, _>>()?,\n                 slice: None,\n                 suffix: Vec::new(),\n@@ -387,7 +389,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // These are not allowed and will error elsewhere anyway.\n                 ty::Dynamic(..) => {\n                     self.saw_const_match_error.set(true);\n-                    let msg = format!(\"`{}` cannot be used in patterns\", cv.ty);\n+                    let msg = format!(\"`{}` cannot be used in patterns\", cv.ty());\n                     if self.include_lint_checks {\n                         tcx.sess.span_err(span, &msg);\n                     } else {\n@@ -414,13 +416,13 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                                     .destructure_const(param_env.and(array))\n                                     .fields\n                                     .iter()\n-                                    .map(|val| self.recur(val, false))\n+                                    .map(|val| self.recur(*val, false))\n                                     .collect::<Result<_, _>>()?,\n                                 slice: None,\n                                 suffix: vec![],\n                             }),\n                             span,\n-                            ty: pointee_ty,\n+                            ty: *pointee_ty,\n                         },\n                     };\n                     self.behind_reference.set(old);\n@@ -440,7 +442,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                                     .destructure_const(param_env.and(array))\n                                     .fields\n                                     .iter()\n-                                    .map(|val| self.recur(val, false))\n+                                    .map(|val| self.recur(*val, false))\n                                     .collect::<Result<_, _>>()?,\n                                 slice: None,\n                                 suffix: vec![],\n@@ -457,7 +459,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // this pattern to a `PartialEq::eq` comparison and `PartialEq::eq` takes a\n                 // reference. This makes the rest of the matching logic simpler as it doesn't have\n                 // to figure out how to get a reference again.\n-                ty::Adt(adt_def, _) if !self.type_marked_structural(pointee_ty) => {\n+                ty::Adt(adt_def, _) if !self.type_marked_structural(*pointee_ty) => {\n                     if self.behind_reference.get() {\n                         if self.include_lint_checks\n                             && !self.saw_const_match_error.get()\n@@ -544,7 +546,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n             }\n             _ => {\n                 self.saw_const_match_error.set(true);\n-                let msg = format!(\"`{}` cannot be used in patterns\", cv.ty);\n+                let msg = format!(\"`{}` cannot be used in patterns\", cv.ty());\n                 if self.include_lint_checks {\n                     tcx.sess.span_err(span, &msg);\n                 } else {\n@@ -560,12 +562,12 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n             && mir_structural_match_violation\n             // FIXME(#73448): Find a way to bring const qualification into parity with\n             // `search_for_structural_match_violation` and then remove this condition.\n-            && self.search_for_structural_match_violation(cv.ty).is_some()\n+            && self.search_for_structural_match_violation(cv.ty()).is_some()\n         {\n             self.saw_const_match_lint.set(true);\n             // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n             // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n-            let msg = self.search_for_structural_match_violation(cv.ty).unwrap().replace(\n+            let msg = self.search_for_structural_match_violation(cv.ty()).unwrap().replace(\n                 \"in a pattern,\",\n                 \"in a pattern, the constant's initializer must be trivial or\",\n             );\n@@ -577,6 +579,6 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n             );\n         }\n \n-        Ok(Pat { span, ty: cv.ty, kind: Box::new(kind) })\n+        Ok(Pat { span, ty: cv.ty(), kind: Box::new(kind) })\n     }\n }"}, {"sha": "e4d9bd9c237e9889cfc7325c031699ce3c585404", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -136,12 +136,12 @@ impl IntRange {\n     fn from_const<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        value: &Const<'tcx>,\n+        value: Const<'tcx>,\n     ) -> Option<IntRange> {\n-        if let Some((target_size, bias)) = Self::integral_size_and_signed_bias(tcx, value.ty) {\n-            let ty = value.ty;\n+        let ty = value.ty();\n+        if let Some((target_size, bias)) = Self::integral_size_and_signed_bias(tcx, ty) {\n             let val = (|| {\n-                if let ty::ConstKind::Value(ConstValue::Scalar(scalar)) = value.val {\n+                if let ty::ConstKind::Value(ConstValue::Scalar(scalar)) = value.val() {\n                     // For this specific pattern we can skip a lot of effort and go\n                     // straight to the result, after doing a bit of checking. (We\n                     // could remove this branch and just fall through, which\n@@ -630,9 +630,9 @@ pub(super) enum Constructor<'tcx> {\n     /// Ranges of integer literal values (`2`, `2..=5` or `2..5`).\n     IntRange(IntRange),\n     /// Ranges of floating-point literal values (`2.0..=5.2`).\n-    FloatRange(&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>, RangeEnd),\n+    FloatRange(ty::Const<'tcx>, ty::Const<'tcx>, RangeEnd),\n     /// String literals. Strings are not quite the same as `&[u8]` so we treat them separately.\n-    Str(&'tcx ty::Const<'tcx>),\n+    Str(ty::Const<'tcx>),\n     /// Array and slice patterns.\n     Slice(Slice),\n     /// Constants that must not be matched structurally. They are treated as black\n@@ -815,8 +815,14 @@ impl<'tcx> Constructor<'tcx> {\n                 FloatRange(other_from, other_to, other_end),\n             ) => {\n                 match (\n-                    compare_const_vals(pcx.cx.tcx, self_to, other_to, pcx.cx.param_env, pcx.ty),\n-                    compare_const_vals(pcx.cx.tcx, self_from, other_from, pcx.cx.param_env, pcx.ty),\n+                    compare_const_vals(pcx.cx.tcx, *self_to, *other_to, pcx.cx.param_env, pcx.ty),\n+                    compare_const_vals(\n+                        pcx.cx.tcx,\n+                        *self_from,\n+                        *other_from,\n+                        pcx.cx.param_env,\n+                        pcx.ty,\n+                    ),\n                 ) {\n                     (Some(to), Some(from)) => {\n                         (from == Ordering::Greater || from == Ordering::Equal)\n@@ -828,8 +834,13 @@ impl<'tcx> Constructor<'tcx> {\n             }\n             (Str(self_val), Str(other_val)) => {\n                 // FIXME: there's probably a more direct way of comparing for equality\n-                match compare_const_vals(pcx.cx.tcx, self_val, other_val, pcx.cx.param_env, pcx.ty)\n-                {\n+                match compare_const_vals(\n+                    pcx.cx.tcx,\n+                    *self_val,\n+                    *other_val,\n+                    pcx.cx.param_env,\n+                    pcx.ty,\n+                ) {\n                     Some(comparison) => comparison == Ordering::Equal,\n                     None => false,\n                 }\n@@ -929,15 +940,15 @@ impl<'tcx> SplitWildcard<'tcx> {\n             ty::Bool => smallvec![make_range(0, 1)],\n             ty::Array(sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n                 let len = len.eval_usize(cx.tcx, cx.param_env) as usize;\n-                if len != 0 && cx.is_uninhabited(sub_ty) {\n+                if len != 0 && cx.is_uninhabited(*sub_ty) {\n                     smallvec![]\n                 } else {\n                     smallvec![Slice(Slice::new(Some(len), VarLen(0, 0)))]\n                 }\n             }\n             // Treat arrays of a constant but unknown length like slices.\n             ty::Array(sub_ty, _) | ty::Slice(sub_ty) => {\n-                let kind = if cx.is_uninhabited(sub_ty) { FixedLen(0) } else { VarLen(0, 0) };\n+                let kind = if cx.is_uninhabited(*sub_ty) { FixedLen(0) } else { VarLen(0, 0) };\n                 smallvec![Slice(Slice::new(None, kind))]\n             }\n             ty::Adt(def, substs) if def.is_enum() => {\n@@ -1368,13 +1379,13 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                 }\n             }\n             PatKind::Constant { value } => {\n-                if let Some(int_range) = IntRange::from_const(cx.tcx, cx.param_env, value) {\n+                if let Some(int_range) = IntRange::from_const(cx.tcx, cx.param_env, *value) {\n                     ctor = IntRange(int_range);\n                     fields = Fields::empty();\n                 } else {\n                     match pat.ty.kind() {\n                         ty::Float(_) => {\n-                            ctor = FloatRange(value, value, RangeEnd::Included);\n+                            ctor = FloatRange(*value, *value, RangeEnd::Included);\n                             fields = Fields::empty();\n                         }\n                         ty::Ref(_, t, _) if t.is_str() => {\n@@ -1386,7 +1397,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                             // fields.\n                             // Note: `t` is `str`, not `&str`.\n                             let subpattern =\n-                                DeconstructedPat::new(Str(value), Fields::empty(), t, pat.span);\n+                                DeconstructedPat::new(Str(*value), Fields::empty(), *t, pat.span);\n                             ctor = Single;\n                             fields = Fields::singleton(cx, subpattern)\n                         }\n@@ -1401,11 +1412,11 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                 }\n             }\n             &PatKind::Range(PatRange { lo, hi, end }) => {\n-                let ty = lo.ty;\n+                let ty = lo.ty();\n                 ctor = if let Some(int_range) = IntRange::from_range(\n                     cx.tcx,\n-                    lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n-                    hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n+                    lo.eval_bits(cx.tcx, cx.param_env, lo.ty()),\n+                    hi.eval_bits(cx.tcx, cx.param_env, hi.ty()),\n                     ty,\n                     &end,\n                 ) {"}, {"sha": "ddf39fb824cda7cb307f969faf8acdf1554baefe", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 debug!(\"{:?}: wrapping pattern with type {:?}\", pat, ref_ty);\n                 Pat {\n                     span: pat.span,\n-                    ty: ref_ty,\n+                    ty: *ref_ty,\n                     kind: Box::new(PatKind::Deref { subpattern: pat }),\n                 }\n             },\n@@ -121,13 +121,13 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     fn lower_pattern_range(\n         &mut self,\n         ty: Ty<'tcx>,\n-        lo: &'tcx ty::Const<'tcx>,\n-        hi: &'tcx ty::Const<'tcx>,\n+        lo: ty::Const<'tcx>,\n+        hi: ty::Const<'tcx>,\n         end: RangeEnd,\n         span: Span,\n     ) -> PatKind<'tcx> {\n-        assert_eq!(lo.ty, ty);\n-        assert_eq!(hi.ty, ty);\n+        assert_eq!(lo.ty(), ty);\n+        assert_eq!(hi.ty(), ty);\n         let cmp = compare_const_vals(self.tcx, lo, hi, self.param_env, ty);\n         match (end, cmp) {\n             // `x..y` where `x < y`.\n@@ -177,16 +177,16 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         lo: Option<&PatKind<'tcx>>,\n         hi: Option<&PatKind<'tcx>>,\n-    ) -> Option<(&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>)> {\n+    ) -> Option<(ty::Const<'tcx>, ty::Const<'tcx>)> {\n         match (lo, hi) {\n             (Some(PatKind::Constant { value: lo }), Some(PatKind::Constant { value: hi })) => {\n-                Some((lo, hi))\n+                Some((*lo, *hi))\n             }\n             (Some(PatKind::Constant { value: lo }), None) => {\n-                Some((lo, ty.numeric_max_val(self.tcx)?))\n+                Some((*lo, ty.numeric_max_val(self.tcx)?))\n             }\n             (None, Some(PatKind::Constant { value: hi })) => {\n-                Some((ty.numeric_min_val(self.tcx)?, hi))\n+                Some((ty.numeric_min_val(self.tcx)?, *hi))\n             }\n             _ => None,\n         }\n@@ -275,7 +275,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 let var_ty = ty;\n                 if let ty::BindByReference(_) = bm {\n                     if let ty::Ref(_, rty, _) = ty.kind() {\n-                        ty = rty;\n+                        ty = *rty;\n                     } else {\n                         bug!(\"`ref {}` has wrong type {}\", ident, ty);\n                     }\n@@ -493,7 +493,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 let const_ =\n                     ty::Const::from_value(self.tcx, value, self.typeck_results.node_type(id));\n \n-                let pattern = self.const_to_pat(&const_, id, span, mir_structural_match_violation);\n+                let pattern = self.const_to_pat(const_, id, span, mir_structural_match_violation);\n \n                 if !is_associated_const {\n                     return pattern;\n@@ -514,7 +514,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                                 user_ty_span: span,\n                             },\n                         }),\n-                        ty: const_.ty,\n+                        ty: const_.ty(),\n                     }\n                 } else {\n                     pattern\n@@ -546,7 +546,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         // Evaluate early like we do in `lower_path`.\n         let value = value.eval(self.tcx, self.param_env);\n \n-        match value.val {\n+        match value.val() {\n             ConstKind::Param(_) => {\n                 self.errors.push(PatternError::ConstParamInPattern(span));\n                 return PatKind::Wild;\n@@ -744,8 +744,8 @@ impl<'tcx> PatternFoldable<'tcx> for PatKind<'tcx> {\n \n crate fn compare_const_vals<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    a: &'tcx ty::Const<'tcx>,\n-    b: &'tcx ty::Const<'tcx>,\n+    a: ty::Const<'tcx>,\n+    b: ty::Const<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Option<Ordering> {\n@@ -756,13 +756,13 @@ crate fn compare_const_vals<'tcx>(\n     let fallback = || from_bool(a == b);\n \n     // Use the fallback if any type differs\n-    if a.ty != b.ty || a.ty != ty {\n+    if a.ty() != b.ty() || a.ty() != ty {\n         return fallback();\n     }\n \n     // Early return for equal constants (so e.g. references to ZSTs can be compared, even if they\n     // are just integer addresses).\n-    if a.val == b.val {\n+    if a.val() == b.val() {\n         return from_bool(true);\n     }\n \n@@ -797,7 +797,7 @@ crate fn compare_const_vals<'tcx>(\n         if let (\n             ty::ConstKind::Value(a_val @ ConstValue::Slice { .. }),\n             ty::ConstKind::Value(b_val @ ConstValue::Slice { .. }),\n-        ) = (a.val, b.val)\n+        ) = (a.val(), b.val())\n         {\n             let a_bytes = get_slice_bytes(&tcx, a_val);\n             let b_bytes = get_slice_bytes(&tcx, b_val);"}, {"sha": "3e1013b0351525841acc9931ffa1baeac10f7561", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -880,9 +880,9 @@ where\n             ty::Dynamic(..) => self.complete_drop(self.succ, self.unwind),\n             ty::Array(ety, size) => {\n                 let size = size.try_eval_usize(self.tcx(), self.elaborator.param_env());\n-                self.open_drop_for_array(ety, size)\n+                self.open_drop_for_array(*ety, size)\n             }\n-            ty::Slice(ety) => self.open_drop_for_array(ety, None),\n+            ty::Slice(ety) => self.open_drop_for_array(*ety, None),\n \n             _ => bug!(\"open drop from non-ADT `{:?}`\", ty),\n         }"}, {"sha": "5810ce6edc9643f8925ec8a7ffe64f5b026d65f7", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -484,7 +484,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 let err = ConstEvalErr::new(&self.ecx, error, Some(c.span));\n                 if let Some(lint_root) = self.lint_root(source_info) {\n                     let lint_only = match c.literal {\n-                        ConstantKind::Ty(ct) => match ct.val {\n+                        ConstantKind::Ty(ct) => match ct.val() {\n                             // Promoteds must lint and not error as the user didn't ask for them\n                             ConstKind::Unevaluated(ty::Unevaluated {\n                                 def: _,\n@@ -801,7 +801,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     ) {\n         if let Rvalue::Use(Operand::Constant(c)) = rval {\n             match c.literal {\n-                ConstantKind::Ty(c) if matches!(c.val, ConstKind::Unevaluated(..)) => {}\n+                ConstantKind::Ty(c) if matches!(c.val(), ConstKind::Unevaluated(..)) => {}\n                 _ => {\n                     trace!(\"skipping replace of Rvalue::Use({:?} because it is already a const\", c);\n                     return;\n@@ -841,7 +841,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     // Found a value represented as a pair. For now only do const-prop if the type\n                     // of `rvalue` is also a tuple with two scalars.\n                     // FIXME: enable the general case stated above ^.\n-                    let ty = &value.layout.ty;\n+                    let ty = value.layout.ty;\n                     // Only do it for tuples\n                     if let ty::Tuple(substs) = ty.kind() {\n                         // Only do it if tuple is also a pair with two scalars\n@@ -875,7 +875,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                                     literal: self\n                                         .ecx\n                                         .tcx\n-                                        .mk_const(ty::Const {\n+                                        .mk_const(ty::ConstS {\n                                             ty,\n                                             val: ty::ConstKind::Value(ConstValue::ByRef {\n                                                 alloc,"}, {"sha": "d787443f6aa4e87669522cd1d7fe6ad77720e19e", "filename": "compiler/rustc_mir_transform/src/coverage/tests.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -37,24 +37,12 @@ use rustc_data_structures::graph::WithSuccessors;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::coverage::CoverageKind;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{self, DebruijnIndex, TyS, TypeFlags};\n+use rustc_middle::ty::{self, BOOL_TY};\n use rustc_span::{self, BytePos, Pos, Span, DUMMY_SP};\n \n // All `TEMP_BLOCK` targets should be replaced before calling `to_body() -> mir::Body`.\n const TEMP_BLOCK: BasicBlock = BasicBlock::MAX;\n \n-fn dummy_ty() -> &'static TyS<'static> {\n-    thread_local! {\n-        static DUMMY_TYS: &'static TyS<'static> = Box::leak(Box::new(TyS::make_for_test(\n-            ty::Bool,\n-            TypeFlags::empty(),\n-            DebruijnIndex::from_usize(0),\n-        )));\n-    }\n-\n-    &DUMMY_TYS.with(|tys| *tys)\n-}\n-\n struct MockBlocks<'tcx> {\n     blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n     dummy_place: Place<'tcx>,\n@@ -166,7 +154,7 @@ impl<'tcx> MockBlocks<'tcx> {\n     fn switchint(&mut self, some_from_block: Option<BasicBlock>) -> BasicBlock {\n         let switchint_kind = TerminatorKind::SwitchInt {\n             discr: Operand::Move(Place::from(self.new_temp())),\n-            switch_ty: dummy_ty(),\n+            switch_ty: BOOL_TY, // just a dummy value\n             targets: SwitchTargets::static_if(0, TEMP_BLOCK, TEMP_BLOCK),\n         };\n         self.add_block_from(some_from_block, switchint_kind)"}, {"sha": "ba234dccaa63e39710000a04f38b008c044bbc97", "filename": "compiler/rustc_mir_transform/src/early_otherwise_branch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -153,7 +153,7 @@ impl<'tcx> MirPass<'tcx> for EarlyOtherwiseBranch {\n             // create temp to store inequality comparison between the two discriminants, `_t` in\n             // example above\n             let nequal = BinOp::Ne;\n-            let comp_res_type = nequal.ty(tcx, parent_ty, opt_data.child_ty);\n+            let comp_res_type = nequal.ty(tcx, *parent_ty, opt_data.child_ty);\n             let comp_temp = patch.new_temp(comp_res_type, opt_data.child_source.span);\n             patch.add_statement(parent_end, StatementKind::StorageLive(comp_temp));\n \n@@ -343,7 +343,7 @@ fn evaluate_candidate<'tcx>(\n     Some(OptimizationData {\n         destination,\n         child_place: *child_place,\n-        child_ty,\n+        child_ty: *child_ty,\n         child_source: child_terminator.source_info,\n     })\n }"}, {"sha": "f0e4129b002e8ac329b20e78e11a1b50720cdb02", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -625,7 +625,7 @@ impl<'tcx> Inliner<'tcx> {\n                 caller_body.required_consts.extend(\n                     callee_body.required_consts.iter().copied().filter(|&ct| {\n                         match ct.literal.const_for_ty() {\n-                            Some(ct) => matches!(ct.val, ConstKind::Unevaluated(_)),\n+                            Some(ct) => matches!(ct.val(), ConstKind::Unevaluated(_)),\n                             None => true,\n                         }\n                     }),"}, {"sha": "0392c5a5468225c15b5284463db3b936a51684a2", "filename": "compiler/rustc_mir_transform/src/normalize_array_len.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -3,10 +3,11 @@\n \n use crate::MirPass;\n use rustc_data_structures::fx::FxIndexMap;\n+use rustc_data_structures::intern::Interned;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty::{self, ReErased, Region, TyCtxt};\n \n const MAX_NUM_BLOCKS: usize = 800;\n const MAX_NUM_LOCALS: usize = 3000;\n@@ -231,11 +232,15 @@ fn normalize_array_len_call<'tcx>(\n                                     // current way of patching doesn't allow to work with `mut`\n                                     (\n                                         ty::Ref(\n-                                            ty::RegionKind::ReErased,\n+                                            Region(Interned(ReErased, _)),\n                                             operand_ty,\n                                             Mutability::Not,\n                                         ),\n-                                        ty::Ref(ty::RegionKind::ReErased, cast_ty, Mutability::Not),\n+                                        ty::Ref(\n+                                            Region(Interned(ReErased, _)),\n+                                            cast_ty,\n+                                            Mutability::Not,\n+                                        ),\n                                     ) => {\n                                         match (operand_ty.kind(), cast_ty.kind()) {\n                                             // current way of patching doesn't allow to work with `mut`"}, {"sha": "1c48efd8b42cb585e1798242b46437f77a5aa1fd", "filename": "compiler/rustc_mir_transform/src/required_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -15,7 +15,7 @@ impl<'a, 'tcx> RequiredConstsVisitor<'a, 'tcx> {\n impl<'tcx> Visitor<'tcx> for RequiredConstsVisitor<'_, 'tcx> {\n     fn visit_constant(&mut self, constant: &Constant<'tcx>, _: Location) {\n         if let Some(ct) = constant.literal.const_for_ty() {\n-            if let ConstKind::Unevaluated(_) = ct.val {\n+            if let ConstKind::Unevaluated(_) = ct.val() {\n                 self.required_consts.push(*constant);\n             }\n         }"}, {"sha": "8ea550fa123b6d4196947fefad7f21bcaf4b7e8d", "filename": "compiler/rustc_mir_transform/src/reveal_all.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -39,6 +39,6 @@ impl<'tcx> MutVisitor<'tcx> for RevealAllVisitor<'tcx> {\n         // We have to use `try_normalize_erasing_regions` here, since it's\n         // possible that we visit impossible-to-satisfy where clauses here,\n         // see #91745\n-        *ty = self.tcx.try_normalize_erasing_regions(self.param_env, *ty).unwrap_or(ty);\n+        *ty = self.tcx.try_normalize_erasing_regions(self.param_env, *ty).unwrap_or(*ty);\n     }\n }"}, {"sha": "b8feeb993e7c8a6a45ebcef69cbb7c7c6b8aa2a4", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -68,7 +68,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n         ty::InstanceDef::DropGlue(def_id, ty) => {\n             // FIXME(#91576): Drop shims for generators aren't subject to the MIR passes at the end\n             // of this function. Is this intentional?\n-            if let Some(ty::Generator(gen_def_id, substs, _)) = ty.map(ty::TyS::kind) {\n+            if let Some(ty::Generator(gen_def_id, substs, _)) = ty.map(Ty::kind) {\n                 let body = tcx.optimized_mir(*gen_def_id).generator_drop().unwrap();\n                 let body = body.clone().subst(tcx, substs);\n                 debug!(\"make_shim({:?}) = {:?}\", instance, body);\n@@ -137,7 +137,7 @@ fn local_decls_for_sig<'tcx>(\n     span: Span,\n ) -> IndexVec<Local, LocalDecl<'tcx>> {\n     iter::once(LocalDecl::new(sig.output(), span))\n-        .chain(sig.inputs().iter().map(|ity| LocalDecl::new(ity, span).immutable()))\n+        .chain(sig.inputs().iter().map(|ity| LocalDecl::new(*ity, span).immutable()))\n         .collect()\n }\n "}, {"sha": "8a1fe6e91cb16b53e8ae1344f7633eea4ba307ae", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -709,7 +709,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         let literal = self.monomorphize(constant.literal);\n         let val = match literal {\n             mir::ConstantKind::Val(val, _) => val,\n-            mir::ConstantKind::Ty(ct) => match ct.val {\n+            mir::ConstantKind::Ty(ct) => match ct.val() {\n                 ty::ConstKind::Value(val) => val,\n                 ty::ConstKind::Unevaluated(ct) => {\n                     let param_env = ty::ParamEnv::reveal_all();\n@@ -731,13 +731,13 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         self.visit_ty(literal.ty(), TyContext::Location(location));\n     }\n \n-    fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, location: Location) {\n-        debug!(\"visiting const {:?} @ {:?}\", *constant, location);\n+    fn visit_const(&mut self, constant: ty::Const<'tcx>, location: Location) {\n+        debug!(\"visiting const {:?} @ {:?}\", constant, location);\n \n-        let substituted_constant = self.monomorphize(*constant);\n+        let substituted_constant = self.monomorphize(constant);\n         let param_env = ty::ParamEnv::reveal_all();\n \n-        match substituted_constant.val {\n+        match substituted_constant.val() {\n             ty::ConstKind::Value(val) => collect_const_value(self.tcx, val, self.output),\n             ty::ConstKind::Unevaluated(unevaluated) => {\n                 match self.tcx.const_eval_resolve(param_env, unevaluated, None) {\n@@ -1042,7 +1042,7 @@ fn find_vtable_types_for_unsizing<'tcx>(\n     match (&source_ty.kind(), &target_ty.kind()) {\n         (&ty::Ref(_, a, _), &ty::Ref(_, b, _) | &ty::RawPtr(ty::TypeAndMut { ty: b, .. }))\n         | (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }), &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n-            ptr_vtable(a, b)\n+            ptr_vtable(*a, *b)\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             ptr_vtable(source_ty.boxed_ty(), target_ty.boxed_ty())"}, {"sha": "48b6951f10ef0751b8230b4d6e65154b67696d5c", "filename": "compiler/rustc_monomorphize/src/polymorphize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -267,7 +267,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n         self.super_local_decl(local, local_decl);\n     }\n \n-    fn visit_const(&mut self, c: &&'tcx Const<'tcx>, _: Location) {\n+    fn visit_const(&mut self, c: Const<'tcx>, _: Location) {\n         c.visit_with(self);\n     }\n \n@@ -278,12 +278,12 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n \n impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n-    fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+    fn visit_const(&mut self, c: Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n         if !c.has_param_types_or_consts() {\n             return ControlFlow::CONTINUE;\n         }\n \n-        match c.val {\n+        match c.val() {\n             ty::ConstKind::Param(param) => {\n                 debug!(?param);\n                 self.unused_parameters.clear(param.index);\n@@ -348,12 +348,12 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for HasUsedGenericParams<'a> {\n     type BreakTy = ();\n \n     #[instrument(level = \"debug\", skip(self))]\n-    fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+    fn visit_const(&mut self, c: Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n         if !c.has_param_types_or_consts() {\n             return ControlFlow::CONTINUE;\n         }\n \n-        match c.val {\n+        match c.val() {\n             ty::ConstKind::Param(param) => {\n                 if self.unused_parameters.contains(param.index).unwrap_or(false) {\n                     ControlFlow::CONTINUE"}, {"sha": "48594e73f5b8359ed32e0c4e43ab00d2833d514a", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -280,8 +280,8 @@ where\n         }\n     }\n \n-    fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        self.visit_ty(c.ty)?;\n+    fn visit_const(&mut self, c: Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        self.visit_ty(c.ty())?;\n         let tcx = self.def_id_visitor.tcx();\n         if let Ok(Some(ct)) = AbstractConst::from_const(tcx, c) {\n             self.visit_abstract_const_expr(tcx, ct)?;"}, {"sha": "84de31a194da08d711acaf3c08b28e18bff728d8", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -275,7 +275,7 @@ impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n     }\n }\n \n-impl<'tcx> Key for (&'tcx ty::Const<'tcx>, mir::Field) {\n+impl<'tcx> Key for (ty::Const<'tcx>, mir::Field) {\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -345,7 +345,7 @@ impl<'tcx> Key for mir::ConstantKind<'tcx> {\n     }\n }\n \n-impl<'tcx> Key for &'tcx ty::Const<'tcx> {\n+impl<'tcx> Key for ty::Const<'tcx> {\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true"}, {"sha": "718a2971c403d02b494f653e61be9f89cb8e7766", "filename": "compiler/rustc_query_impl/src/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_query_impl%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_query_impl%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fvalues.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -1,5 +1,5 @@\n use super::QueryCtxt;\n-use rustc_middle::ty::{self, AdtSizedConstraint, Ty, TyS};\n+use rustc_middle::ty::{self, AdtSizedConstraint, Ty};\n \n pub(super) trait Value<'tcx>: Sized {\n     fn from_cycle_error(tcx: QueryCtxt<'tcx>) -> Self;\n@@ -12,7 +12,7 @@ impl<'tcx, T> Value<'tcx> for T {\n     }\n }\n \n-impl<'tcx> Value<'tcx> for &'_ TyS<'_> {\n+impl<'tcx> Value<'tcx> for Ty<'_> {\n     fn from_cycle_error(tcx: QueryCtxt<'tcx>) -> Self {\n         // SAFETY: This is never called when `Self` is not `Ty<'tcx>`.\n         // FIXME: Represent the above fact in the trait system somehow."}, {"sha": "a8c2a5e1424b829712ec6666a6f38aaf397cd641", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -11,7 +11,7 @@ use crate::{NameBinding, NameBindingKind, PathResult, PrivacyError, ToNameBindin\n \n use rustc_ast::NodeId;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::ptr_key::PtrKey;\n+use rustc_data_structures::intern::Interned;\n use rustc_errors::{pluralize, struct_span_err, Applicability};\n use rustc_hir::def::{self, PartialRes};\n use rustc_hir::def_id::DefId;\n@@ -134,7 +134,7 @@ impl<'a> Import<'a> {\n pub struct NameResolution<'a> {\n     /// Single imports that may define the name in the namespace.\n     /// Imports are arena-allocated, so it's ok to use pointers as keys.\n-    single_imports: FxHashSet<PtrKey<'a, Import<'a>>>,\n+    single_imports: FxHashSet<Interned<'a, Import<'a>>>,\n     /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n     shadowed_glob: Option<&'a NameBinding<'a>>,\n@@ -153,7 +153,7 @@ impl<'a> NameResolution<'a> {\n     }\n \n     crate fn add_single_import(&mut self, import: &'a Import<'a>) {\n-        self.single_imports.insert(PtrKey(import));\n+        self.single_imports.insert(Interned::new_unchecked(import));\n     }\n }\n \n@@ -850,7 +850,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     Err(Determined) => {\n                         let key = this.new_key(target, ns);\n                         this.update_resolution(parent, key, |_, resolution| {\n-                            resolution.single_imports.remove(&PtrKey(import));\n+                            resolution.single_imports.remove(&Interned::new_unchecked(import));\n                         });\n                     }\n                     Ok(binding) if !binding.is_importable() => {"}, {"sha": "28d8d9247ac131b827ec0b44cc5c2301521a4b39", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -38,7 +38,7 @@ use rustc_ast::{ItemKind, ModKind, Path};\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n-use rustc_data_structures::ptr_key::PtrKey;\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_expand::base::{DeriveResolutions, SyntaxExtension, SyntaxExtensionKind};\n@@ -964,7 +964,7 @@ pub struct Resolver<'a> {\n     /// language items.\n     empty_module: Module<'a>,\n     module_map: FxHashMap<DefId, Module<'a>>,\n-    binding_parent_modules: FxHashMap<PtrKey<'a, NameBinding<'a>>, Module<'a>>,\n+    binding_parent_modules: FxHashMap<Interned<'a, NameBinding<'a>>, Module<'a>>,\n     underscore_disambiguator: u32,\n \n     /// Maps glob imports to the names of items actually imported.\n@@ -1115,7 +1115,7 @@ impl<'a> ResolverArenas<'a> {\n         self.name_resolutions.alloc(Default::default())\n     }\n     fn alloc_macro_rules_scope(&'a self, scope: MacroRulesScope<'a>) -> MacroRulesScopeRef<'a> {\n-        PtrKey(self.dropless.alloc(Cell::new(scope)))\n+        Interned::new_unchecked(self.dropless.alloc(Cell::new(scope)))\n     }\n     fn alloc_macro_rules_binding(\n         &'a self,\n@@ -2938,7 +2938,9 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn set_binding_parent_module(&mut self, binding: &'a NameBinding<'a>, module: Module<'a>) {\n-        if let Some(old_module) = self.binding_parent_modules.insert(PtrKey(binding), module) {\n+        if let Some(old_module) =\n+            self.binding_parent_modules.insert(Interned::new_unchecked(binding), module)\n+        {\n             if !ptr::eq(module, old_module) {\n                 span_bug!(binding.span, \"parent module is reset for binding\");\n             }\n@@ -2954,8 +2956,8 @@ impl<'a> Resolver<'a> {\n         // is disambiguated to mitigate regressions from macro modularization.\n         // Scoping for `macro_rules` behaves like scoping for `let` at module level, in general.\n         match (\n-            self.binding_parent_modules.get(&PtrKey(macro_rules)),\n-            self.binding_parent_modules.get(&PtrKey(modularized)),\n+            self.binding_parent_modules.get(&Interned::new_unchecked(macro_rules)),\n+            self.binding_parent_modules.get(&Interned::new_unchecked(modularized)),\n         ) {\n             (Some(macro_rules), Some(modularized)) => {\n                 macro_rules.nearest_parent_mod() == modularized.nearest_parent_mod()"}, {"sha": "89c2a0c74bd36b950f89d88b749b00dc06b86b0e", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -11,7 +11,7 @@ use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust;\n use rustc_attr::StabilityLevel;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::ptr_key::PtrKey;\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::struct_span_err;\n use rustc_expand::base::{Annotatable, DeriveResolutions, Indeterminate, ResolverExpand};\n@@ -71,7 +71,7 @@ pub enum MacroRulesScope<'a> {\n /// This helps to avoid uncontrollable growth of `macro_rules!` scope chains,\n /// which usually grow lineraly with the number of macro invocations\n /// in a module (including derives) and hurt performance.\n-pub(crate) type MacroRulesScopeRef<'a> = PtrKey<'a, Cell<MacroRulesScope<'a>>>;\n+pub(crate) type MacroRulesScopeRef<'a> = Interned<'a, Cell<MacroRulesScope<'a>>>;\n \n // Macro namespace is separated into two sub-namespaces, one for bang macros and\n // one for attribute-like macros (attributes, derives)."}, {"sha": "cec1d4bc15717c35f2c1a8e4a523d707da8f4ba5", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -243,10 +243,10 @@ impl<'tcx> Printer<'tcx> for &mut SymbolPrinter<'tcx> {\n         Ok(self)\n     }\n \n-    fn print_const(self, ct: &'tcx ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n+    fn print_const(self, ct: ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n         // only print integers\n-        if let ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int { .. })) = ct.val {\n-            if ct.ty.is_integral() {\n+        if let ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int { .. })) = ct.val() {\n+            if ct.ty().is_integral() {\n                 return self.pretty_print_const(ct, true);\n             }\n         }"}, {"sha": "c21c3d3ac330f487449d17757c853e635f97b2f0", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -116,7 +116,7 @@ struct SymbolMangler<'tcx> {\n     /// The values are start positions in `out`, in bytes.\n     paths: FxHashMap<(DefId, &'tcx [GenericArg<'tcx>]), usize>,\n     types: FxHashMap<Ty<'tcx>, usize>,\n-    consts: FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n+    consts: FxHashMap<ty::Const<'tcx>, usize>,\n }\n \n impl<'tcx> SymbolMangler<'tcx> {\n@@ -420,7 +420,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n                     hir::Mutability::Not => \"R\",\n                     hir::Mutability::Mut => \"Q\",\n                 });\n-                if *r != ty::ReErased {\n+                if !r.is_erased() {\n                     self = r.print(self)?;\n                 }\n                 self = ty.print(self)?;\n@@ -576,10 +576,10 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n         Ok(self)\n     }\n \n-    fn print_const(mut self, ct: &'tcx ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n+    fn print_const(mut self, ct: ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n         // We only mangle a typed value if the const can be evaluated.\n         let ct = ct.eval(self.tcx, ty::ParamEnv::reveal_all());\n-        match ct.val {\n+        match ct.val() {\n             ty::ConstKind::Value(_) => {}\n \n             // Placeholders (should be demangled as `_`).\n@@ -603,14 +603,14 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n         }\n         let start = self.out.len();\n \n-        match ct.ty.kind() {\n+        match ct.ty().kind() {\n             ty::Uint(_) | ty::Int(_) | ty::Bool | ty::Char => {\n-                self = ct.ty.print(self)?;\n+                self = ct.ty().print(self)?;\n \n-                let mut bits = ct.eval_bits(self.tcx, ty::ParamEnv::reveal_all(), ct.ty);\n+                let mut bits = ct.eval_bits(self.tcx, ty::ParamEnv::reveal_all(), ct.ty());\n \n                 // Negative integer values are mangled using `n` as a \"sign prefix\".\n-                if let ty::Int(ity) = ct.ty.kind() {\n+                if let ty::Int(ity) = ct.ty().kind() {\n                     let val =\n                         Integer::from_int_ty(&self.tcx, *ity).size().sign_extend(bits) as i128;\n                     if val < 0 {\n@@ -627,7 +627,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n             // handle `&str` and include both `&` (\"R\") and `str` (\"e\") prefixes.\n             ty::Ref(_, ty, hir::Mutability::Not) if *ty == self.tcx.types.str_ => {\n                 self.push(\"R\");\n-                match ct.val {\n+                match ct.val() {\n                     ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => {\n                         // NOTE(eddyb) the following comment was kept from `ty::print::pretty`:\n                         // The `inspect` here is okay since we checked the bounds, and there are no\n@@ -671,7 +671,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n                     Ok(this)\n                 };\n \n-                match *ct.ty.kind() {\n+                match *ct.ty().kind() {\n                     ty::Array(..) => {\n                         self.push(\"A\");\n                         self = print_field_list(self)?;\n@@ -721,7 +721,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n             }\n \n             _ => {\n-                bug!(\"symbol_names: unsupported constant of type `{}` ({:?})\", ct.ty, ct);\n+                bug!(\"symbol_names: unsupported constant of type `{}` ({:?})\", ct.ty(), ct);\n             }\n         }\n \n@@ -811,7 +811,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n     ) -> Result<Self::Path, Self::Error> {\n         // Don't print any regions if they're all erased.\n         let print_regions = args.iter().any(|arg| match arg.unpack() {\n-            GenericArgKind::Lifetime(r) => *r != ty::ReErased,\n+            GenericArgKind::Lifetime(r) => !r.is_erased(),\n             _ => false,\n         });\n         let args = args.iter().cloned().filter(|arg| match arg.unpack() {"}, {"sha": "c93ff0aa6e27734ace8720f23342e36572b8308c", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -141,7 +141,7 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match r {\n+        match *r {\n             // Ignore bound regions and `'static` regions that appear in the\n             // type, we only need to remap regions that reference lifetimes\n             // from the function declaraion.\n@@ -287,10 +287,10 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n         trace!(\"checking const {:?}\", ct);\n         // Find a const parameter\n-        match ct.val {\n+        match ct.val() {\n             ty::ConstKind::Param(..) => {\n                 // Look it up in the substitution list.\n                 match self.map.get(&ct.into()).map(|k| k.unpack()) {\n@@ -311,7 +311,7 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                             )\n                             .emit();\n \n-                        self.tcx().const_error(ct.ty)\n+                        self.tcx().const_error(ct.ty())\n                     }\n                 }\n             }"}, {"sha": "5fe7b62f454186c9fb453064f16fb6efff068e46", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -437,16 +437,12 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                     for (new_region, old_region) in\n                         iter::zip(new_substs.regions(), old_substs.regions())\n                     {\n-                        match (new_region, old_region) {\n+                        match (*new_region, *old_region) {\n                             // If both predicates have an `ReLateBound` (a HRTB) in the\n                             // same spot, we do nothing.\n-                            (\n-                                ty::RegionKind::ReLateBound(_, _),\n-                                ty::RegionKind::ReLateBound(_, _),\n-                            ) => {}\n+                            (ty::ReLateBound(_, _), ty::ReLateBound(_, _)) => {}\n \n-                            (ty::RegionKind::ReLateBound(_, _), _)\n-                            | (_, ty::RegionKind::ReVar(_)) => {\n+                            (ty::ReLateBound(_, _), _) | (_, ty::ReVar(_)) => {\n                                 // One of these is true:\n                                 // The new predicate has a HRTB in a spot where the old\n                                 // predicate does not (if they both had a HRTB, the previous\n@@ -472,8 +468,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                                 // `user_computed_preds`.\n                                 return false;\n                             }\n-                            (_, ty::RegionKind::ReLateBound(_, _))\n-                            | (ty::RegionKind::ReVar(_), _) => {\n+                            (_, ty::ReLateBound(_, _)) | (ty::ReVar(_), _) => {\n                                 // This is the opposite situation as the previous arm.\n                                 // One of these is true:\n                                 //\n@@ -814,14 +809,14 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                     };\n                 }\n                 ty::PredicateKind::ConstEquate(c1, c2) => {\n-                    let evaluate = |c: &'tcx ty::Const<'tcx>| {\n-                        if let ty::ConstKind::Unevaluated(unevaluated) = c.val {\n+                    let evaluate = |c: ty::Const<'tcx>| {\n+                        if let ty::ConstKind::Unevaluated(unevaluated) = c.val() {\n                             match select.infcx().const_eval_resolve(\n                                 obligation.param_env,\n                                 unevaluated,\n                                 Some(obligation.cause.span),\n                             ) {\n-                                Ok(val) => Ok(ty::Const::from_value(select.tcx(), val, c.ty)),\n+                                Ok(val) => Ok(ty::Const::from_value(select.tcx(), val, c.ty())),\n                                 Err(err) => Err(err),\n                             }\n                         } else {\n@@ -880,8 +875,8 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx> {\n     }\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        (match r {\n-            ty::ReVar(vid) => self.vid_to_region.get(vid).cloned(),\n+        (match *r {\n+            ty::ReVar(vid) => self.vid_to_region.get(&vid).cloned(),\n             _ => None,\n         })\n         .unwrap_or_else(|| r.super_fold_with(self))"}, {"sha": "b2aa72e0e67416e4f2b36713e0bcdda14c769440", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -626,7 +626,7 @@ fn orphan_check_trait_ref<'tcx>(\n                 .substs\n                 .types()\n                 .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n-                .find(|ty| ty_is_local_constructor(ty, in_crate));\n+                .find(|ty| ty_is_local_constructor(*ty, in_crate));\n \n             debug!(\"orphan_check_trait_ref: uncovered ty local_type: `{:?}`\", local_type);\n "}, {"sha": "1994faed70c66bfabe0514160b28a582530c8cc3", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -8,6 +8,7 @@\n //! In this case we try to build an abstract representation of this constant using\n //! `thir_abstract_const` which can then be checked for structural equality with other\n //! generic constants mentioned in the `caller_bounds` of the current environment.\n+use rustc_data_structures::intern::Interned;\n use rustc_errors::ErrorReported;\n use rustc_hir::def::DefKind;\n use rustc_index::vec::IndexVec;\n@@ -201,9 +202,9 @@ impl<'tcx> AbstractConst<'tcx> {\n \n     pub fn from_const(\n         tcx: TyCtxt<'tcx>,\n-        ct: &ty::Const<'tcx>,\n+        ct: ty::Const<'tcx>,\n     ) -> Result<Option<AbstractConst<'tcx>>, ErrorReported> {\n-        match ct.val {\n+        match ct.val() {\n             ty::ConstKind::Unevaluated(uv) => AbstractConst::new(tcx, uv.shrink()),\n             ty::ConstKind::Error(_) => Err(ErrorReported),\n             _ => Ok(None),\n@@ -293,7 +294,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 }\n             }\n \n-            fn visit_const(&mut self, ct: &'tcx ty::Const<'tcx>) {\n+            fn visit_const(&mut self, ct: ty::Const<'tcx>) {\n                 self.is_poly |= ct.has_param_types_or_consts();\n             }\n         }\n@@ -334,7 +335,11 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         self.recurse_build(self.body_id)?;\n \n         for n in self.nodes.iter() {\n-            if let Node::Leaf(ty::Const { val: ty::ConstKind::Unevaluated(ct), ty: _ }) = n {\n+            if let Node::Leaf(ty::Const(Interned(\n+                ty::ConstS { val: ty::ConstKind::Unevaluated(ct), ty: _ },\n+                _,\n+            ))) = n\n+            {\n                 // `AbstractConst`s should not contain any promoteds as they require references which\n                 // are not allowed.\n                 assert_eq!(ct.promoted, None);\n@@ -602,11 +607,11 @@ pub(super) fn try_unify<'tcx>(\n \n     match (a.root(tcx), b.root(tcx)) {\n         (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n-            if a_ct.ty != b_ct.ty {\n+            if a_ct.ty() != b_ct.ty() {\n                 return false;\n             }\n \n-            match (a_ct.val, b_ct.val) {\n+            match (a_ct.val(), b_ct.val()) {\n                 // We can just unify errors with everything to reduce the amount of\n                 // emitted errors here.\n                 (ty::ConstKind::Error(_), _) | (_, ty::ConstKind::Error(_)) => true,"}, {"sha": "f22b4e8d072a81f243d8b0d5687a1e4b548868de", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -1251,7 +1251,7 @@ trait InferCtxtPrivExt<'hir, 'tcx> {\n \n     fn is_recursive_obligation(\n         &self,\n-        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+        obligated_types: &mut Vec<Ty<'tcx>>,\n         cause_code: &ObligationCauseCode<'tcx>,\n     ) -> bool;\n }\n@@ -1506,7 +1506,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n             loop {\n                 match t.kind() {\n                     ty::Ref(_, inner, _) | ty::RawPtr(ty::TypeAndMut { ty: inner, .. }) => {\n-                        t = inner\n+                        t = *inner\n                     }\n                     _ => break t,\n                 }\n@@ -2054,7 +2054,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n                 if let ty::Param(ty::ParamTy { name, .. }) = *ty.kind() {\n                     let infcx = self.infcx;\n-                    self.var_map.entry(ty).or_insert_with(|| {\n+                    *self.var_map.entry(ty).or_insert_with(|| {\n                         infcx.next_ty_var(TypeVariableOrigin {\n                             kind: TypeVariableOriginKind::TypeParameterDefinition(name, None),\n                             span: DUMMY_SP,\n@@ -2245,7 +2245,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn is_recursive_obligation(\n         &self,\n-        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+        obligated_types: &mut Vec<Ty<'tcx>>,\n         cause_code: &ObligationCauseCode<'tcx>,\n     ) -> bool {\n         if let ObligationCauseCode::BuiltinDerivedObligation(ref data) = cause_code {"}, {"sha": "6c8a08c09e7778acd9549e4ebf59bc81d5636e3f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -211,7 +211,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     let type_string = self.tcx.type_of(def.did).to_string();\n                     flags.push((sym::_Self, Some(format!(\"[{}]\", type_string))));\n \n-                    let len = len.val.try_to_value().and_then(|v| v.try_to_machine_usize(self.tcx));\n+                    let len =\n+                        len.val().try_to_value().and_then(|v| v.try_to_machine_usize(self.tcx));\n                     let string = match len {\n                         Some(n) => format!(\"[{}; {}]\", type_string, n),\n                         None => format!(\"[{}; _]\", type_string),"}, {"sha": "40cb9647a355541b505577e5e181876bcba28a79", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -167,7 +167,7 @@ pub trait InferCtxtExt<'tcx> {\n         predicate: &T,\n         param_env: ty::ParamEnv<'tcx>,\n         cause_code: &ObligationCauseCode<'tcx>,\n-        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+        obligated_types: &mut Vec<Ty<'tcx>>,\n         seen_requirements: &mut FxHashSet<DefId>,\n     ) where\n         T: fmt::Display;\n@@ -839,7 +839,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let ty::Ref(_, inner_ty, _) = suggested_ty.kind() else {\n                     break;\n                 };\n-                suggested_ty = inner_ty;\n+                suggested_ty = *inner_ty;\n \n                 let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n@@ -1597,7 +1597,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             if let Some(cause) =\n                 typeck_results.generator_interior_types.as_ref().skip_binder().iter().find(\n                     |ty::GeneratorInteriorTypeCause { ty, .. }| {\n-                        ty_matches(typeck_results.generator_interior_types.rebind(ty))\n+                        ty_matches(typeck_results.generator_interior_types.rebind(*ty))\n                     },\n                 )\n             {\n@@ -1904,7 +1904,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         predicate: &T,\n         param_env: ty::ParamEnv<'tcx>,\n         cause_code: &ObligationCauseCode<'tcx>,\n-        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+        obligated_types: &mut Vec<Ty<'tcx>>,\n         seen_requirements: &mut FxHashSet<DefId>,\n     ) where\n         T: fmt::Display,"}, {"sha": "1989184f48f0e26c434e5edc8d4747dbd302e58f", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -562,7 +562,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                         //\n                         // Let's just see where this breaks :shrug:\n                         if let (ty::ConstKind::Unevaluated(a), ty::ConstKind::Unevaluated(b)) =\n-                            (c1.val, c2.val)\n+                            (c1.val(), c2.val())\n                         {\n                             if infcx.try_unify_abstract_consts(a.shrink(), b.shrink()) {\n                                 return ProcessResult::Changed(vec![]);\n@@ -572,14 +572,14 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n \n                     let stalled_on = &mut pending_obligation.stalled_on;\n \n-                    let mut evaluate = |c: &'tcx Const<'tcx>| {\n-                        if let ty::ConstKind::Unevaluated(unevaluated) = c.val {\n+                    let mut evaluate = |c: Const<'tcx>| {\n+                        if let ty::ConstKind::Unevaluated(unevaluated) = c.val() {\n                             match self.selcx.infcx().const_eval_resolve(\n                                 obligation.param_env,\n                                 unevaluated,\n                                 Some(obligation.cause.span),\n                             ) {\n-                                Ok(val) => Ok(Const::from_value(self.selcx.tcx(), val, c.ty)),\n+                                Ok(val) => Ok(Const::from_value(self.selcx.tcx(), val, c.ty())),\n                                 Err(ErrorHandled::TooGeneric) => {\n                                     stalled_on.extend(\n                                         unevaluated"}, {"sha": "5f338664c9a98be4d0e97e9e7210ea3281fe6eac", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -499,7 +499,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(&mut self, constant: ty::Const<'tcx>) -> ty::Const<'tcx> {\n         if self.selcx.tcx().lazy_normalization() {\n             constant\n         } else {\n@@ -622,24 +622,24 @@ impl<'tcx> TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        match *ct {\n-            ty::Const { val: ty::ConstKind::Bound(debruijn, _), ty: _ }\n+    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+        match ct.val() {\n+            ty::ConstKind::Bound(debruijn, _)\n                 if debruijn.as_usize() + 1\n                     > self.current_index.as_usize() + self.universe_indices.len() =>\n             {\n                 bug!(\"Bound vars outside of `self.universe_indices`\");\n             }\n-            ty::Const { val: ty::ConstKind::Bound(debruijn, bound_const), ty }\n-                if debruijn >= self.current_index =>\n-            {\n+            ty::ConstKind::Bound(debruijn, bound_const) if debruijn >= self.current_index => {\n                 let universe = self.universe_for(debruijn);\n                 let p = ty::PlaceholderConst {\n                     universe,\n-                    name: ty::BoundConst { var: bound_const, ty },\n+                    name: ty::BoundConst { var: bound_const, ty: ct.ty() },\n                 };\n                 self.mapped_consts.insert(p, bound_const);\n-                self.infcx.tcx.mk_const(ty::Const { val: ty::ConstKind::Placeholder(p), ty })\n+                self.infcx\n+                    .tcx\n+                    .mk_const(ty::ConstS { val: ty::ConstKind::Placeholder(p), ty: ct.ty() })\n             }\n             _ if ct.has_vars_bound_at_or_above(self.current_index) => ct.super_fold_with(self),\n             _ => ct,\n@@ -697,7 +697,7 @@ impl<'tcx> TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n     }\n \n     fn fold_region(&mut self, r0: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        let r1 = match r0 {\n+        let r1 = match *r0 {\n             ty::ReVar(_) => self\n                 .infcx\n                 .inner\n@@ -758,8 +758,8 @@ impl<'tcx> TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ty::Const { val: ty::ConstKind::Placeholder(p), ty } = *ct {\n+    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+        if let ty::ConstKind::Placeholder(p) = ct.val() {\n             let replace_var = self.mapped_consts.get(&p);\n             match replace_var {\n                 Some(replace_var) => {\n@@ -771,8 +771,10 @@ impl<'tcx> TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n                     let db = ty::DebruijnIndex::from_usize(\n                         self.universe_indices.len() - index + self.current_index.as_usize() - 1,\n                     );\n-                    self.tcx()\n-                        .mk_const(ty::Const { val: ty::ConstKind::Bound(db, *replace_var), ty })\n+                    self.tcx().mk_const(ty::ConstS {\n+                        val: ty::ConstKind::Bound(db, *replace_var),\n+                        ty: ct.ty(),\n+                    })\n                 }\n                 None => ct,\n             }\n@@ -1862,7 +1864,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n             crate::traits::InternalSubsts::identity_for_item(tcx, assoc_ty.item.def_id);\n         let did = ty::WithOptConstParam::unknown(assoc_ty.item.def_id);\n         let val = ty::ConstKind::Unevaluated(ty::Unevaluated::new(did, identity_substs));\n-        tcx.mk_const(ty::Const { ty, val }).into()\n+        tcx.mk_const(ty::ConstS { ty, val }).into()\n     } else {\n         ty.into()\n     };"}, {"sha": "55903a3c36a29ae09b82d291e72e6f43411005e9", "filename": "compiler/rustc_trait_selection/src/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -104,7 +104,7 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         | ty::Error(_) => true,\n \n         // [T; N] and [T] have same properties as T.\n-        ty::Array(ty, _) | ty::Slice(ty) => trivial_dropck_outlives(tcx, ty),\n+        ty::Array(ty, _) | ty::Slice(ty) => trivial_dropck_outlives(tcx, *ty),\n \n         // (T1..Tn) and closures have same properties as T1..Tn --\n         // check if *any* of those are trivial."}, {"sha": "6a2bd9ce1ea91d3043d04b07a38048fb20c1e35c", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -140,8 +140,8 @@ impl<'tcx> TypeVisitor<'tcx> for MaxEscapingBoundVarVisitor {\n         ControlFlow::CONTINUE\n     }\n \n-    fn visit_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        match ct.val {\n+    fn visit_const(&mut self, ct: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match ct.val() {\n             ty::ConstKind::Bound(debruijn, _) if debruijn >= self.outer_index => {\n                 self.escaping =\n                     self.escaping.max(debruijn.as_usize() - self.outer_index.as_usize());\n@@ -188,7 +188,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n         }\n \n         if let Some(ty) = self.cache.get(&ty) {\n-            return Ok(ty);\n+            return Ok(*ty);\n         }\n \n         // See note in `rustc_trait_selection::traits::project` about why we\n@@ -324,8 +324,8 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n \n     fn try_fold_const(\n         &mut self,\n-        constant: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+        constant: ty::Const<'tcx>,\n+    ) -> Result<ty::Const<'tcx>, Self::Error> {\n         let constant = constant.try_super_fold_with(self)?;\n         Ok(constant.eval(self.infcx.tcx, self.param_env))\n     }"}, {"sha": "84bc7cdff28905f1742f022cca737c48b8efbae2", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -983,7 +983,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // Lifetimes aren't allowed to change during unsizing.\n                     GenericArgKind::Lifetime(_) => None,\n \n-                    GenericArgKind::Const(ct) => match ct.val {\n+                    GenericArgKind::Const(ct) => match ct.val() {\n                         ty::ConstKind::Param(p) => Some(p.index),\n                         _ => None,\n                     },"}, {"sha": "64af875dd22bbb8a2024f88e824c79fd90e76dba", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -643,23 +643,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         //\n                         // Let's just see where this breaks :shrug:\n                         if let (ty::ConstKind::Unevaluated(a), ty::ConstKind::Unevaluated(b)) =\n-                            (c1.val, c2.val)\n+                            (c1.val(), c2.val())\n                         {\n                             if self.infcx.try_unify_abstract_consts(a.shrink(), b.shrink()) {\n                                 return Ok(EvaluatedToOk);\n                             }\n                         }\n                     }\n \n-                    let evaluate = |c: &'tcx ty::Const<'tcx>| {\n-                        if let ty::ConstKind::Unevaluated(unevaluated) = c.val {\n+                    let evaluate = |c: ty::Const<'tcx>| {\n+                        if let ty::ConstKind::Unevaluated(unevaluated) = c.val() {\n                             self.infcx\n                                 .const_eval_resolve(\n                                     obligation.param_env,\n                                     unevaluated,\n                                     Some(obligation.cause.span),\n                                 )\n-                                .map(|val| ty::Const::from_value(self.tcx(), val, c.ty))\n+                                .map(|val| ty::Const::from_value(self.tcx(), val, c.ty()))\n                         } else {\n                             Ok(c)\n                         }\n@@ -2033,7 +2033,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .skip_binder() // binder moved -\\\n             .iter()\n             .flat_map(|ty| {\n-                let ty: ty::Binder<'tcx, Ty<'tcx>> = types.rebind(ty); // <----/\n+                let ty: ty::Binder<'tcx, Ty<'tcx>> = types.rebind(*ty); // <----/\n \n                 self.infcx.commit_unconditionally(|_| {\n                     let placeholder_ty = self.infcx.replace_bound_vars_with_placeholders(ty);"}, {"sha": "38a6220082ff6318678f9c8aaaf6f2f4307a5e00", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -510,7 +510,7 @@ crate fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Option<St\n     for (mut p, _) in predicates {\n         if let Some(poly_trait_ref) = p.to_opt_poly_trait_pred() {\n             if Some(poly_trait_ref.def_id()) == sized_trait {\n-                types_without_default_bounds.remove(poly_trait_ref.self_ty().skip_binder());\n+                types_without_default_bounds.remove(&poly_trait_ref.self_ty().skip_binder());\n                 continue;\n             }\n "}, {"sha": "2dd3b77a73cdff8273ae00059e965b5bc0579611", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -41,15 +41,17 @@ pub fn obligations<'a, 'tcx>(\n             .into()\n         }\n         GenericArgKind::Const(ct) => {\n-            match ct.val {\n+            match ct.val() {\n                 ty::ConstKind::Infer(infer) => {\n                     let resolved = infcx.shallow_resolve(infer);\n                     if resolved == infer {\n                         // No progress.\n                         return None;\n                     }\n \n-                    infcx.tcx.mk_const(ty::Const { val: ty::ConstKind::Infer(resolved), ty: ct.ty })\n+                    infcx\n+                        .tcx\n+                        .mk_const(ty::ConstS { val: ty::ConstKind::Infer(resolved), ty: ct.ty() })\n                 }\n                 _ => ct,\n             }\n@@ -198,7 +200,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n     trait_ref: &ty::TraitRef<'tcx>,\n     item: Option<&hir::Item<'tcx>>,\n     cause: &mut traits::ObligationCause<'tcx>,\n-    pred: &ty::Predicate<'tcx>,\n+    pred: ty::Predicate<'tcx>,\n ) {\n     debug!(\n         \"extended_cause_with_original_assoc_item_obligation {:?} {:?} {:?} {:?}\",\n@@ -319,7 +321,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 trait_ref,\n                 item,\n                 &mut cause,\n-                &obligation.predicate,\n+                obligation.predicate,\n             );\n             traits::Obligation::with_depth(cause, depth, param_env, obligation.predicate)\n         };\n@@ -442,7 +444,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 GenericArgKind::Lifetime(_) => continue,\n \n                 GenericArgKind::Const(constant) => {\n-                    match constant.val {\n+                    match constant.val() {\n                         ty::ConstKind::Unevaluated(uv) => {\n                             let obligations = self.nominal_obligations(uv.def.did, uv.substs);\n                             self.out.extend(obligations);\n@@ -464,9 +466,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                             if resolved != infer {\n                                 let cause = self.cause(traits::MiscObligation);\n \n-                                let resolved_constant = self.infcx.tcx.mk_const(ty::Const {\n+                                let resolved_constant = self.infcx.tcx.mk_const(ty::ConstS {\n                                     val: ty::ConstKind::Infer(resolved),\n-                                    ..*constant\n+                                    ty: constant.ty(),\n                                 });\n                                 self.out.push(traits::Obligation::with_depth(\n                                     cause,"}, {"sha": "51b66e1bb6503c08bde62e38a5ea014af4fc4b71", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -711,11 +711,11 @@ fn bound_vars_for_item<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> SubstsRef<'tcx\n                 var: ty::BoundVar::from_usize(substs.len()),\n                 kind: ty::BrAnon(substs.len() as u32),\n             };\n-            tcx.mk_region(ty::RegionKind::ReLateBound(ty::INNERMOST, br)).into()\n+            tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n         }\n \n         ty::GenericParamDefKind::Const { .. } => tcx\n-            .mk_const(ty::Const {\n+            .mk_const(ty::ConstS {\n                 val: ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from(param.index)),\n                 ty: tcx.type_of(param.def_id),\n             })\n@@ -735,7 +735,7 @@ fn binders_for<'tcx>(\n                 chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General)\n             }\n             ty::subst::GenericArgKind::Const(c) => {\n-                chalk_ir::VariableKind::Const(c.ty.lower_into(interner))\n+                chalk_ir::VariableKind::Const(c.ty().lower_into(interner))\n             }\n         }),\n     )"}, {"sha": "9d810d0881b5f8351fb7694a02aa6378ef231991", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 29, "deletions": 33, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -35,7 +35,7 @@ use rustc_ast::ast;\n use rustc_middle::traits::{ChalkEnvironmentAndGoal, ChalkRustInterner as RustInterner};\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n-use rustc_middle::ty::{self, Binder, Region, RegionKind, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n+use rustc_middle::ty::{self, Binder, Region, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_span::def_id::DefId;\n \n use chalk_ir::{FnSig, ForeignDefId};\n@@ -389,7 +389,7 @@ impl<'tcx> LowerInto<'tcx, Ty<'tcx>> for &chalk_ir::Ty<RustInterner<'tcx>> {\n             TyKind::Array(ty, c) => {\n                 let ty = ty.lower_into(interner);\n                 let c = c.lower_into(interner);\n-                ty::Array(ty, interner.tcx.mk_const(c))\n+                ty::Array(ty, c)\n             }\n             TyKind::FnDef(id, substitution) => ty::FnDef(id.0, substitution.lower_into(interner)),\n             TyKind::Closure(closure, substitution) => {\n@@ -449,53 +449,49 @@ impl<'tcx> LowerInto<'tcx, Ty<'tcx>> for &chalk_ir::Ty<RustInterner<'tcx>> {\n \n impl<'tcx> LowerInto<'tcx, chalk_ir::Lifetime<RustInterner<'tcx>>> for Region<'tcx> {\n     fn lower_into(self, interner: RustInterner<'tcx>) -> chalk_ir::Lifetime<RustInterner<'tcx>> {\n-        use rustc_middle::ty::RegionKind::*;\n-\n-        match self {\n-            ReEarlyBound(_) => {\n+        match *self {\n+            ty::ReEarlyBound(_) => {\n                 panic!(\"Should have already been substituted.\");\n             }\n-            ReLateBound(db, br) => chalk_ir::LifetimeData::BoundVar(chalk_ir::BoundVar::new(\n+            ty::ReLateBound(db, br) => chalk_ir::LifetimeData::BoundVar(chalk_ir::BoundVar::new(\n                 chalk_ir::DebruijnIndex::new(db.as_u32()),\n                 br.var.as_usize(),\n             ))\n             .intern(interner),\n-            ReFree(_) => unimplemented!(),\n-            ReStatic => chalk_ir::LifetimeData::Static.intern(interner),\n-            ReVar(_) => unimplemented!(),\n-            RePlaceholder(placeholder_region) => {\n+            ty::ReFree(_) => unimplemented!(),\n+            ty::ReStatic => chalk_ir::LifetimeData::Static.intern(interner),\n+            ty::ReVar(_) => unimplemented!(),\n+            ty::RePlaceholder(placeholder_region) => {\n                 chalk_ir::LifetimeData::Placeholder(chalk_ir::PlaceholderIndex {\n                     ui: chalk_ir::UniverseIndex { counter: placeholder_region.universe.index() },\n                     idx: 0,\n                 })\n                 .intern(interner)\n             }\n-            ReEmpty(ui) => {\n+            ty::ReEmpty(ui) => {\n                 chalk_ir::LifetimeData::Empty(chalk_ir::UniverseIndex { counter: ui.index() })\n                     .intern(interner)\n             }\n-            ReErased => chalk_ir::LifetimeData::Erased.intern(interner),\n+            ty::ReErased => chalk_ir::LifetimeData::Erased.intern(interner),\n         }\n     }\n }\n \n impl<'tcx> LowerInto<'tcx, Region<'tcx>> for &chalk_ir::Lifetime<RustInterner<'tcx>> {\n     fn lower_into(self, interner: RustInterner<'tcx>) -> Region<'tcx> {\n         let kind = match self.data(interner) {\n-            chalk_ir::LifetimeData::BoundVar(var) => ty::RegionKind::ReLateBound(\n+            chalk_ir::LifetimeData::BoundVar(var) => ty::ReLateBound(\n                 ty::DebruijnIndex::from_u32(var.debruijn.depth()),\n                 ty::BoundRegion {\n                     var: ty::BoundVar::from_usize(var.index),\n                     kind: ty::BrAnon(var.index as u32),\n                 },\n             ),\n             chalk_ir::LifetimeData::InferenceVar(_var) => unimplemented!(),\n-            chalk_ir::LifetimeData::Placeholder(p) => {\n-                ty::RegionKind::RePlaceholder(ty::Placeholder {\n-                    universe: ty::UniverseIndex::from_usize(p.ui.counter),\n-                    name: ty::BoundRegionKind::BrAnon(p.idx as u32),\n-                })\n-            }\n+            chalk_ir::LifetimeData::Placeholder(p) => ty::RePlaceholder(ty::Placeholder {\n+                universe: ty::UniverseIndex::from_usize(p.ui.counter),\n+                name: ty::BoundRegionKind::BrAnon(p.idx as u32),\n+            }),\n             chalk_ir::LifetimeData::Static => return interner.tcx.lifetimes.re_static,\n             chalk_ir::LifetimeData::Empty(ui) => {\n                 ty::ReEmpty(ty::UniverseIndex::from_usize(ui.counter))\n@@ -509,8 +505,8 @@ impl<'tcx> LowerInto<'tcx, Region<'tcx>> for &chalk_ir::Lifetime<RustInterner<'t\n \n impl<'tcx> LowerInto<'tcx, chalk_ir::Const<RustInterner<'tcx>>> for ty::Const<'tcx> {\n     fn lower_into(self, interner: RustInterner<'tcx>) -> chalk_ir::Const<RustInterner<'tcx>> {\n-        let ty = self.ty.lower_into(interner);\n-        let value = match self.val {\n+        let ty = self.ty().lower_into(interner);\n+        let value = match self.val() {\n             ty::ConstKind::Value(val) => {\n                 chalk_ir::ConstValue::Concrete(chalk_ir::ConcreteConst { interned: val })\n             }\n@@ -536,7 +532,7 @@ impl<'tcx> LowerInto<'tcx, ty::Const<'tcx>> for &chalk_ir::Const<RustInterner<'t\n             chalk_ir::ConstValue::Placeholder(_p) => unimplemented!(),\n             chalk_ir::ConstValue::Concrete(c) => ty::ConstKind::Value(c.interned),\n         };\n-        ty::Const { ty, val }\n+        interner.tcx.mk_const(ty::ConstS { ty, val })\n     }\n }\n \n@@ -572,7 +568,7 @@ impl<'tcx> LowerInto<'tcx, ty::subst::GenericArg<'tcx>>\n             }\n             chalk_ir::GenericArgData::Const(c) => {\n                 let c: ty::Const<'tcx> = c.lower_into(interner);\n-                interner.tcx.mk_const(c).into()\n+                c.into()\n             }\n         }\n     }\n@@ -915,8 +911,8 @@ impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n     }\n \n     fn visit_region(&mut self, r: Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        match r {\n-            ty::ReLateBound(index, br) if *index == self.binder_index => match br.kind {\n+        match *r {\n+            ty::ReLateBound(index, br) if index == self.binder_index => match br.kind {\n                 ty::BoundRegionKind::BrNamed(def_id, _name) => {\n                     if !self.named_parameters.iter().any(|d| *d == def_id) {\n                         self.named_parameters.push(def_id);\n@@ -977,12 +973,12 @@ impl<'a, 'tcx> TypeFolder<'tcx> for NamedBoundVarSubstitutor<'a, 'tcx> {\n     }\n \n     fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n-        match r {\n-            ty::ReLateBound(index, br) if *index == self.binder_index => match br.kind {\n+        match *r {\n+            ty::ReLateBound(index, br) if index == self.binder_index => match br.kind {\n                 ty::BrNamed(def_id, _name) => match self.named_parameters.get(&def_id) {\n                     Some(idx) => {\n                         let new_br = ty::BoundRegion { var: br.var, kind: ty::BrAnon(*idx) };\n-                        return self.tcx.mk_region(RegionKind::ReLateBound(*index, new_br));\n+                        return self.tcx.mk_region(ty::ReLateBound(index, new_br));\n                     }\n                     None => panic!(\"Missing `BrNamed`.\"),\n                 },\n@@ -1054,7 +1050,7 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n     }\n \n     fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n-        match r {\n+        match *r {\n             // FIXME(chalk) - jackh726 - this currently isn't hit in any tests,\n             // since canonicalization will already change these to canonical\n             // variables (ty::ReLateBound).\n@@ -1064,14 +1060,14 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n                         var: ty::BoundVar::from_u32(*idx),\n                         kind: ty::BrAnon(*idx),\n                     };\n-                    self.tcx.mk_region(RegionKind::ReLateBound(self.binder_index, br))\n+                    self.tcx.mk_region(ty::ReLateBound(self.binder_index, br))\n                 }\n                 None => {\n                     let idx = self.named_regions.len() as u32;\n                     let br =\n                         ty::BoundRegion { var: ty::BoundVar::from_u32(idx), kind: ty::BrAnon(idx) };\n                     self.named_regions.insert(_re.def_id, idx);\n-                    self.tcx.mk_region(RegionKind::ReLateBound(self.binder_index, br))\n+                    self.tcx.mk_region(ty::ReLateBound(self.binder_index, br))\n                 }\n             },\n \n@@ -1144,7 +1140,7 @@ impl<'tcx> TypeVisitor<'tcx> for PlaceholdersCollector {\n     }\n \n     fn visit_region(&mut self, r: Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        match r {\n+        match *r {\n             ty::RePlaceholder(p) if p.universe == self.universe_index => {\n                 if let ty::BoundRegionKind::BrAnon(anon) = p.name {\n                     self.next_anon_region_placeholder = self.next_anon_region_placeholder.max(anon);"}, {"sha": "455fc46a42e84476f0a70d05cfdaae0e055939b8", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -192,7 +192,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n         ty::Array(ety, _) | ty::Slice(ety) => {\n             // single-element containers, behave like their element\n             rustc_data_structures::stack::ensure_sufficient_stack(|| {\n-                dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ety, constraints)\n+                dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, *ety, constraints)\n             })?;\n         }\n "}, {"sha": "a4aa965ec95333edee98c9a80e18aad5d8eff579", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -39,7 +39,7 @@ fn try_normalize_after_erasing_regions<'tcx, T: TypeFoldable<'tcx> + PartialEq +\n                 // always only region relations, and we are about to\n                 // erase those anyway:\n                 debug_assert_eq!(\n-                    normalized_obligations.iter().find(|p| not_outlives_predicate(&p.predicate)),\n+                    normalized_obligations.iter().find(|p| not_outlives_predicate(p.predicate)),\n                     None,\n                 );\n \n@@ -57,7 +57,7 @@ fn try_normalize_after_erasing_regions<'tcx, T: TypeFoldable<'tcx> + PartialEq +\n     })\n }\n \n-fn not_outlives_predicate<'tcx>(p: &ty::Predicate<'tcx>) -> bool {\n+fn not_outlives_predicate<'tcx>(p: ty::Predicate<'tcx>) -> bool {\n     match p.kind().skip_binder() {\n         ty::PredicateKind::RegionOutlives(..) | ty::PredicateKind::TypeOutlives(..) => false,\n         ty::PredicateKind::Trait(..)"}, {"sha": "91c4398c178ca293c261442067830357e851afb8", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -90,8 +90,8 @@ impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n     }\n \n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        match r {\n-            ty::ReLateBound(index, br) if *index == self.binder_index => {\n+        match *r {\n+            ty::ReLateBound(index, br) if index == self.binder_index => {\n                 match self.vars.entry(br.var.as_u32()) {\n                     Entry::Vacant(entry) => {\n                         entry.insert(ty::BoundVariableKind::Region(br.kind));"}, {"sha": "b08f8f6230837685c2898fb7e22467eba9597ce4", "filename": "compiler/rustc_ty_utils/src/representability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -92,7 +92,7 @@ fn are_inner_types_recursive<'tcx>(\n             seen,\n             shadow_seen,\n             representable_cache,\n-            ty,\n+            *ty,\n             force_result,\n         ),\n         ty::Adt(def, substs) => {\n@@ -255,7 +255,7 @@ fn is_type_structurally_recursive<'tcx>(\n     force_result: &mut bool,\n ) -> Representability {\n     debug!(\"is_type_structurally_recursive: {:?} {:?}\", ty, sp);\n-    if let Some(representability) = representable_cache.get(ty) {\n+    if let Some(representability) = representable_cache.get(&ty) {\n         debug!(\n             \"is_type_structurally_recursive: {:?} {:?} - (cached) {:?}\",\n             ty, sp, representability"}, {"sha": "e44f80d5ac3f2e9b2ec5c18e6051886364e17cc8", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -410,7 +410,7 @@ fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n \n     let self_ty = trait_ref.self_ty();\n     let self_ty_matches = match self_ty.kind() {\n-        ty::Dynamic(ref data, ty::ReStatic) => data.principal().is_none(),\n+        ty::Dynamic(ref data, re) if re.is_static() => data.principal().is_none(),\n         _ => false,\n     };\n \n@@ -474,7 +474,7 @@ pub fn conservative_is_privately_uninhabited_raw<'tcx>(\n                 Some(0) | None => false,\n                 // If the array is definitely non-empty, it's uninhabited if\n                 // the type of its elements is uninhabited.\n-                Some(1..) => tcx.conservative_is_privately_uninhabited(param_env.and(ty)),\n+                Some(1..) => tcx.conservative_is_privately_uninhabited(param_env.and(*ty)),\n             }\n         }\n         ty::Ref(..) => {"}, {"sha": "845f03183c30c867f93d8439c19602a5ef9916d7", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -83,7 +83,7 @@ pub trait AstConv<'tcx> {\n         ty: Ty<'tcx>,\n         param: Option<&ty::GenericParamDef>,\n         span: Span,\n-    ) -> &'tcx Const<'tcx>;\n+    ) -> Const<'tcx>;\n \n     /// Projecting an associated type from a (potentially)\n     /// higher-ranked trait reference is more complicated, because of\n@@ -1428,7 +1428,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         // `trait_object_dummy_self`, so check for that.\n                         let references_self = match pred.skip_binder().term {\n                             ty::Term::Ty(ty) => ty.walk().any(|arg| arg == dummy_self.into()),\n-                            ty::Term::Const(c) => c.ty.walk().any(|arg| arg == dummy_self.into()),\n+                            ty::Term::Const(c) => c.ty().walk().any(|arg| arg == dummy_self.into()),\n                         };\n \n                         // If the projection output contains `Self`, force the user to\n@@ -2669,7 +2669,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         // If any of the derived region bounds are 'static, that is always\n         // the best choice.\n-        if derived_region_bounds.iter().any(|&r| ty::ReStatic == *r) {\n+        if derived_region_bounds.iter().any(|r| r.is_static()) {\n             return Some(tcx.lifetimes.re_static);\n         }\n "}, {"sha": "3701b255b756bfe48be2cacad3b9cae6b5e7551b", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -4,7 +4,7 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir::{self as hir, ExprKind};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::traits::Obligation;\n-use rustc_middle::ty::{self, ToPredicate, Ty, TyS};\n+use rustc_middle::ty::{self, ToPredicate, Ty};\n use rustc_span::{MultiSpan, Span};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{\n@@ -505,7 +505,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(crate) fn opt_suggest_box_span(\n         &self,\n         span: Span,\n-        outer_ty: &'tcx TyS<'tcx>,\n+        outer_ty: Ty<'tcx>,\n         orig_expected: Expectation<'tcx>,\n     ) -> Option<Span> {\n         match (orig_expected, self.ret_coercion_impl_trait.map(|ty| (self.body_id.owner, ty))) {"}, {"sha": "f64a90ed10e22a3ea2a8137967c3d855cdf6ecb6", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -269,7 +269,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         },\n                     };\n                     autoref = Some(Adjustment {\n-                        kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n+                        kind: Adjust::Borrow(AutoBorrow::Ref(*region, mutbl)),\n                         target: method.sig.inputs()[0],\n                     });\n                 }\n@@ -628,7 +628,7 @@ impl<'a, 'tcx> DeferredCallResolution<'tcx> {\n                 for (method_arg_ty, self_arg_ty) in\n                     iter::zip(method_sig.inputs().iter().skip(1), self.fn_sig.inputs())\n                 {\n-                    fcx.demand_eqtype(self.call_expr.span, &self_arg_ty, &method_arg_ty);\n+                    fcx.demand_eqtype(self.call_expr.span, *self_arg_ty, *method_arg_ty);\n                 }\n \n                 fcx.demand_eqtype(self.call_expr.span, method_sig.output(), self.fn_sig.output());"}, {"sha": "56b6c09069027bcba1dfaba683b554b6656f4e55", "filename": "compiler/rustc_typeck/src/check/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -369,7 +369,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                             .try_coerce(\n                                 self.expr,\n                                 fcx.tcx.mk_ref(\n-                                    &ty::RegionKind::ReErased,\n+                                    fcx.tcx.lifetimes.re_erased,\n                                     TypeAndMut { ty: expr_ty, mutbl },\n                                 ),\n                                 self.cast_ty,\n@@ -419,7 +419,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                         .try_coerce(\n                             self.expr,\n                             fcx.tcx.mk_ref(\n-                                &ty::RegionKind::ReErased,\n+                                fcx.tcx.lifetimes.re_erased,\n                                 TypeAndMut { ty: self.expr_ty, mutbl },\n                             ),\n                             self.cast_ty,\n@@ -885,7 +885,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     });\n \n                 // this will report a type mismatch if needed\n-                fcx.demand_eqtype(self.span, ety, m_cast.ty);\n+                fcx.demand_eqtype(self.span, *ety, m_cast.ty);\n                 return Ok(CastKind::ArrayPtrCast);\n             }\n         }"}, {"sha": "27c8a1978355754b1a014eee54da6a207f78f58b", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::layout::MAX_SIMD_LANES;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n-use rustc_middle::ty::{self, OpaqueTypeKey, ParamEnv, RegionKind, Ty, TyCtxt};\n+use rustc_middle::ty::{self, OpaqueTypeKey, ParamEnv, Ty, TyCtxt};\n use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVENTIONS};\n use rustc_span::symbol::sym;\n use rustc_span::{self, MultiSpan, Span};\n@@ -269,7 +269,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n                             ty::Adt(ref adt, _) => {\n                                 adt.did == panic_info_did\n                                     && mutbl == hir::Mutability::Not\n-                                    && *region != RegionKind::ReStatic\n+                                    && !region.is_static()\n                             }\n                             _ => false,\n                         },\n@@ -469,8 +469,8 @@ pub(super) fn check_opaque_for_inheriting_lifetimes<'tcx>(\n \n         fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n             debug!(\"FindParentLifetimeVisitor: r={:?}\", r);\n-            if let RegionKind::ReEarlyBound(ty::EarlyBoundRegion { index, .. }) = r {\n-                if *index < self.0.parent_count as u32 {\n+            if let ty::ReEarlyBound(ty::EarlyBoundRegion { index, .. }) = *r {\n+                if index < self.0.parent_count as u32 {\n                     return ControlFlow::Break(FoundParentLifetime);\n                 } else {\n                     return ControlFlow::CONTINUE;\n@@ -480,8 +480,8 @@ pub(super) fn check_opaque_for_inheriting_lifetimes<'tcx>(\n             r.super_visit_with(self)\n         }\n \n-        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            if let ty::ConstKind::Unevaluated(..) = c.val {\n+        fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            if let ty::ConstKind::Unevaluated(..) = c.val() {\n                 // FIXME(#72219) We currently don't detect lifetimes within substs\n                 // which would violate this check. Even though the particular substitution is not used\n                 // within the const, this should still be fixed."}, {"sha": "3c626837ef1a327b73cf74c2e7e31a27236932a5", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -450,7 +450,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .skip_binder()\n             .inputs()\n             .iter()\n-            .map(|ty| ArgKind::from_expected_ty(ty, None))\n+            .map(|ty| ArgKind::from_expected_ty(*ty, None))\n             .collect();\n         let (closure_span, found_args) = match self.get_fn_like_arguments(expr_map_node) {\n             Some((sp, args)) => (Some(sp), args),"}, {"sha": "be7ac006926a9fc5201b24f41f59681b166c3949", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -142,7 +142,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     where\n         F: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n     {\n-        self.unify(&a, &b)\n+        self.unify(a, b)\n             .and_then(|InferOk { value: ty, obligations }| success(f(ty), ty, obligations))\n     }\n \n@@ -472,7 +472,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n         };\n         adjustments.push(Adjustment {\n-            kind: Adjust::Borrow(AutoBorrow::Ref(r_borrow, mutbl)),\n+            kind: Adjust::Borrow(AutoBorrow::Ref(*r_borrow, mutbl)),\n             target: ty,\n         });\n "}, {"sha": "457e9cf1ea54a95bee943ad69033b99b15707d55", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -1306,7 +1306,7 @@ pub fn check_type_bounds<'tcx>(\n         GenericParamDefKind::Const { .. } => {\n             let bound_var = ty::BoundVariableKind::Const;\n             bound_vars.push(bound_var);\n-            tcx.mk_const(ty::Const {\n+            tcx.mk_const(ty::ConstS {\n                 ty: tcx.type_of(param.def_id),\n                 val: ty::ConstKind::Bound(\n                     ty::INNERMOST,"}, {"sha": "d0e96e7538cf046de0341566083cf4d57d90530e", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -734,7 +734,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, ref expr),\n                 _,\n                 &ty::Ref(_, checked, _),\n-            ) if self.infcx.can_sub(self.param_env, checked, &expected).is_ok() => {\n+            ) if self.infcx.can_sub(self.param_env, checked, expected).is_ok() => {\n                 // We have `&T`, check if what was expected was `T`. If so,\n                 // we may want to suggest removing a `&`.\n                 if sm.is_imported(expr.span) {"}, {"sha": "22d2022902f01b5ee6747524be70e6e9af9fb10a", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -362,9 +362,9 @@ impl<'tcx> TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n \n     fn consts(\n         &mut self,\n-        a: &'tcx ty::Const<'tcx>,\n-        b: &'tcx ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        a: ty::Const<'tcx>,\n+        b: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n         debug!(\"SimpleEqRelation::consts(a={:?}, b={:?})\", a, b);\n         ty::relate::super_relate_consts(self, a, b)\n     }"}, {"sha": "b5f13703edfbe9930b2f79a6a98be3289108e20d", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -421,9 +421,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // Places may legitimately have unsized types.\n                         // For example, dereferences of a fat pointer and\n                         // the last field of a struct can be unsized.\n-                        ExpectHasType(ty)\n+                        ExpectHasType(*ty)\n                     } else {\n-                        Expectation::rvalue_hint(self, ty)\n+                        Expectation::rvalue_hint(self, *ty)\n                     }\n                 }\n                 _ => NoExpectation,\n@@ -2181,7 +2181,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         base: &hir::Expr<'_>,\n         field: Ident,\n-        len: &ty::Const<'tcx>,\n+        len: ty::Const<'tcx>,\n     ) {\n         if let (Some(len), Ok(user_index)) =\n             (len.try_eval_usize(self.tcx, self.param_env), field.as_str().parse::<u64>())\n@@ -2216,7 +2216,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn no_such_field_err(\n         &self,\n         field: Ident,\n-        expr_t: &'tcx ty::TyS<'tcx>,\n+        expr_t: Ty<'tcx>,\n         id: HirId,\n     ) -> DiagnosticBuilder<'_> {\n         let span = field.span;\n@@ -2233,7 +2233,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         // try to add a suggestion in case the field is a nested field of a field of the Adt\n-        if let Some((fields, substs)) = self.get_field_candidates(span, &expr_t) {\n+        if let Some((fields, substs)) = self.get_field_candidates(span, expr_t) {\n             for candidate_field in fields.iter() {\n                 if let Some(field_path) = self.check_for_nested_field(\n                     span,\n@@ -2312,7 +2312,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             field_path.push(candidate_field.ident(self.tcx).normalize_to_macros_2_0());\n             let field_ty = candidate_field.ty(self.tcx, subst);\n-            if let Some((nested_fields, subst)) = self.get_field_candidates(span, &field_ty) {\n+            if let Some((nested_fields, subst)) = self.get_field_candidates(span, field_ty) {\n                 for field in nested_fields.iter() {\n                     let accessible = field.vis.is_accessible_from(id, self.tcx);\n                     if accessible {\n@@ -2449,7 +2449,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // allows them to be inferred based on how they are used later in the\n         // function.\n         if is_input {\n-            let ty = self.structurally_resolved_type(expr.span, &ty);\n+            let ty = self.structurally_resolved_type(expr.span, ty);\n             match *ty.kind() {\n                 ty::FnDef(..) => {\n                     let fnptr_ty = self.tcx.mk_fn_ptr(ty.fn_sig(self.tcx));"}, {"sha": "7214cdf3312a78998c9374b15ae800f7cc6ca265", "filename": "compiler/rustc_typeck/src/check/fallback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -70,7 +70,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // unconstrained opaque type variables, in addition to performing\n         // other kinds of fallback.\n         for ty in &self.unsolved_variables() {\n-            fallback_has_occurred |= self.fallback_opaque_type_vars(ty);\n+            fallback_has_occurred |= self.fallback_opaque_type_vars(*ty);\n         }\n \n         // See if we can make any more progress.\n@@ -176,7 +176,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             .type_var_origin(ty)\n             .map(|origin| origin.span)\n             .unwrap_or(rustc_span::DUMMY_SP);\n-        let oty = self.inner.borrow().opaque_types_vars.get(ty).copied();\n+        let oty = self.inner.borrow().opaque_types_vars.get(&ty).copied();\n         if let Some(opaque_ty) = oty {\n             debug!(\n                 \"fallback_opaque_type_vars(ty={:?}): falling back to opaque type {:?}\","}, {"sha": "96bbc2800d50a212d833827a13b32568146891a2", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -498,14 +498,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty\n     }\n \n-    pub fn array_length_to_const(&self, length: &hir::ArrayLen) -> &'tcx ty::Const<'tcx> {\n+    pub fn array_length_to_const(&self, length: &hir::ArrayLen) -> ty::Const<'tcx> {\n         match length {\n             &hir::ArrayLen::Infer(_, span) => self.ct_infer(self.tcx.types.usize, None, span),\n             hir::ArrayLen::Body(anon_const) => self.to_const(anon_const),\n         }\n     }\n \n-    pub fn to_const(&self, ast_c: &hir::AnonConst) -> &'tcx ty::Const<'tcx> {\n+    pub fn to_const(&self, ast_c: &hir::AnonConst) -> ty::Const<'tcx> {\n         let const_def_id = self.tcx.hir().local_def_id(ast_c.hir_id);\n         let c = ty::Const::from_anon_const(self.tcx, const_def_id);\n         self.register_wf_obligation(\n@@ -520,7 +520,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         ast_c: &hir::AnonConst,\n         param_def_id: DefId,\n-    ) -> &'tcx ty::Const<'tcx> {\n+    ) -> ty::Const<'tcx> {\n         let const_def = ty::WithOptConstParam {\n             did: self.tcx.hir().local_def_id(ast_c.hir_id),\n             const_param_did: Some(param_def_id),\n@@ -605,7 +605,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         field: &'tcx ty::FieldDef,\n         substs: SubstsRef<'tcx>,\n     ) -> Ty<'tcx> {\n-        self.normalize_associated_types_in(span, &field.ty(self.tcx, substs))\n+        self.normalize_associated_types_in(span, field.ty(self.tcx, substs))\n     }\n \n     pub(in super::super) fn resolve_generator_interiors(&self, def_id: DefId) {\n@@ -756,7 +756,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // is polymorphic) and the expected return type.\n                 // No argument expectations are produced if unification fails.\n                 let origin = self.misc(call_span);\n-                let ures = self.at(&origin, self.param_env).sup(ret_ty, &formal_ret);\n+                let ures = self.at(&origin, self.param_env).sup(ret_ty, formal_ret);\n \n                 // FIXME(#27336) can't use ? here, Try::from_error doesn't default\n                 // to identity so the resulting type is not constrained."}, {"sha": "222c14d0d47b9ef244ead29af396dff2a667064a", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -239,7 +239,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         param: Option<&ty::GenericParamDef>,\n         span: Span,\n-    ) -> &'tcx Const<'tcx> {\n+    ) -> Const<'tcx> {\n         if let Some(param) = param {\n             if let GenericArgKind::Const(ct) = self.var_for_def(span, param).unpack() {\n                 return ct;\n@@ -282,7 +282,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         if ty.has_escaping_bound_vars() {\n             ty // FIXME: normalization and escaping regions\n         } else {\n-            self.normalize_associated_types_in(span, &ty)\n+            self.normalize_associated_types_in(span, ty)\n         }\n     }\n "}, {"sha": "576dc6f127cbda11e8674189937c4824c5c72fc9", "filename": "compiler/rustc_typeck/src/check/gather_locals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n         debug!(\n             \"local variable {:?} is assigned type {}\",\n             decl.pat,\n-            self.fcx.ty_to_string(&*self.fcx.locals.borrow().get(&decl.hir_id).unwrap().decl_ty)\n+            self.fcx.ty_to_string(self.fcx.locals.borrow().get(&decl.hir_id).unwrap().decl_ty)\n         );\n     }\n }\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n             debug!(\n                 \"pattern binding {} is assigned to {} with type {:?}\",\n                 ident,\n-                self.fcx.ty_to_string(&*self.fcx.locals.borrow().get(&p.hir_id).unwrap().decl_ty),\n+                self.fcx.ty_to_string(self.fcx.locals.borrow().get(&p.hir_id).unwrap().decl_ty),\n                 var_ty\n             );\n         }"}, {"sha": "d360f34ae709c53e79cae9d75271b8ed07056c38", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -155,7 +155,7 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n \n                 self.types.insert(ty::GeneratorInteriorTypeCause {\n                     span: source_span,\n-                    ty: &ty,\n+                    ty,\n                     scope_span,\n                     yield_span: yield_data.span,\n                     expr: expr.map(|e| e.hir_id),\n@@ -416,7 +416,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n                 let tcx = self.fcx.tcx;\n                 let ref_ty = tcx.mk_ref(\n                     // Use `ReErased` as `resolve_interior` is going to replace all the regions anyway.\n-                    tcx.mk_region(ty::RegionKind::ReErased),\n+                    tcx.mk_region(ty::ReErased),\n                     ty::TypeAndMut { ty, mutbl: hir::Mutability::Not },\n                 );\n                 self.record("}, {"sha": "fdc3ba17e3ccf4284e4727e3a2e8b3f4b477a74b", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -185,7 +185,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n \n                 if unsize {\n                     let unsized_ty = if let ty::Array(elem_ty, _) = base_ty.kind() {\n-                        self.tcx.mk_slice(elem_ty)\n+                        self.tcx.mk_slice(*elem_ty)\n                     } else {\n                         bug!(\n                             \"AutorefOrPtrAdjustment's unsize flag should only be set for array ty, found {}\",\n@@ -201,8 +201,8 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             }\n             Some(probe::AutorefOrPtrAdjustment::ToConstPtr) => {\n                 target = match target.kind() {\n-                    ty::RawPtr(ty::TypeAndMut { ty, mutbl }) => {\n-                        assert_eq!(*mutbl, hir::Mutability::Mut);\n+                    &ty::RawPtr(ty::TypeAndMut { ty, mutbl }) => {\n+                        assert_eq!(mutbl, hir::Mutability::Mut);\n                         self.tcx.mk_ptr(ty::TypeAndMut { mutbl: hir::Mutability::Not, ty })\n                     }\n                     other => panic!(\"Cannot adjust receiver type {:?} to const ptr\", other),"}, {"sha": "e5ef52e0324e795b76ef40b9f1db3913a23a18e2", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -227,7 +227,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let ty::Ref(region, t_type, mutability) = self_ty.kind() {\n                 let trait_type = self\n                     .tcx\n-                    .mk_ref(region, ty::TypeAndMut { ty: t_type, mutbl: mutability.invert() });\n+                    .mk_ref(*region, ty::TypeAndMut { ty: *t_type, mutbl: mutability.invert() });\n                 // We probe again to see if there might be a borrow mutability discrepancy.\n                 match self.lookup_probe(\n                     span,"}, {"sha": "c429e0f165370227d3b1dd2d3ace973b91757bc3", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -515,7 +515,7 @@ fn method_autoderef_steps<'tcx>(\n                 steps.push(CandidateStep {\n                     self_ty: infcx.make_query_response_ignoring_pending_obligations(\n                         inference_vars,\n-                        infcx.tcx.mk_slice(elem_ty),\n+                        infcx.tcx.mk_slice(*elem_ty),\n                     ),\n                     autoderefs: dereferences,\n                     // this could be from an unsafe deref if we had\n@@ -1247,7 +1247,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         }\n \n         let ty = match self_ty.kind() {\n-            ty::RawPtr(ty::TypeAndMut { ty, mutbl: hir::Mutability::Mut }) => ty,\n+            &ty::RawPtr(ty::TypeAndMut { ty, mutbl: hir::Mutability::Mut }) => ty,\n             _ => return None,\n         };\n "}, {"sha": "81e2b3bc1621f2b026091c52bedb3667b0076158", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -703,7 +703,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let mut bound_spans = vec![];\n \n                     let mut collect_type_param_suggestions =\n-                        |self_ty: Ty<'tcx>, parent_pred: &ty::Predicate<'tcx>, obligation: &str| {\n+                        |self_ty: Ty<'tcx>, parent_pred: ty::Predicate<'tcx>, obligation: &str| {\n                             // We don't care about regions here, so it's fine to skip the binder here.\n                             if let (ty::Param(_), ty::PredicateKind::Trait(p)) =\n                                 (self_ty.kind(), parent_pred.kind().skip_binder())\n@@ -892,15 +892,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .filter(|(pred, _, _parent_pred)| !skip_list.contains(&pred))\n                         .filter_map(|(pred, parent_pred, _cause)| {\n                             format_pred(*pred).map(|(p, self_ty)| {\n-                                collect_type_param_suggestions(self_ty, pred, &p);\n+                                collect_type_param_suggestions(self_ty, *pred, &p);\n                                 match parent_pred {\n                                     None => format!(\"`{}`\", &p),\n                                     Some(parent_pred) => match format_pred(*parent_pred) {\n                                         None => format!(\"`{}`\", &p),\n                                         Some((parent_p, _)) => {\n                                             collect_type_param_suggestions(\n                                                 self_ty,\n-                                                parent_pred,\n+                                                *parent_pred,\n                                                 &p,\n                                             );\n                                             format!(\"`{}`\\nwhich is required by `{}`\", p, parent_p)\n@@ -1086,8 +1086,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let ty::Ref(region, t_type, mutability) = rcvr_ty.kind() {\n                     if needs_mut {\n                         let trait_type = self.tcx.mk_ref(\n-                            region,\n-                            ty::TypeAndMut { ty: t_type, mutbl: mutability.invert() },\n+                            *region,\n+                            ty::TypeAndMut { ty: *t_type, mutbl: mutability.invert() },\n                         );\n                         err.note(&format!(\"you need `{}` instead of `{}`\", trait_type, rcvr_ty));\n                     }\n@@ -1462,13 +1462,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // just this list.\n             for (rcvr_ty, post) in &[\n                 (rcvr_ty, \"\"),\n-                (self.tcx.mk_mut_ref(&ty::ReErased, rcvr_ty), \"&mut \"),\n-                (self.tcx.mk_imm_ref(&ty::ReErased, rcvr_ty), \"&\"),\n+                (self.tcx.mk_mut_ref(self.tcx.lifetimes.re_erased, rcvr_ty), \"&mut \"),\n+                (self.tcx.mk_imm_ref(self.tcx.lifetimes.re_erased, rcvr_ty), \"&\"),\n             ] {\n                 if let Ok(pick) = self.lookup_probe(\n                     span,\n                     item_name,\n-                    rcvr_ty,\n+                    *rcvr_ty,\n                     rcvr,\n                     crate::check::method::probe::ProbeScope::AllTraits,\n                 ) {\n@@ -1487,10 +1487,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     break;\n                 }\n                 for (rcvr_ty, pre) in &[\n-                    (self.tcx.mk_lang_item(rcvr_ty, LangItem::OwnedBox), \"Box::new\"),\n-                    (self.tcx.mk_lang_item(rcvr_ty, LangItem::Pin), \"Pin::new\"),\n-                    (self.tcx.mk_diagnostic_item(rcvr_ty, sym::Arc), \"Arc::new\"),\n-                    (self.tcx.mk_diagnostic_item(rcvr_ty, sym::Rc), \"Rc::new\"),\n+                    (self.tcx.mk_lang_item(*rcvr_ty, LangItem::OwnedBox), \"Box::new\"),\n+                    (self.tcx.mk_lang_item(*rcvr_ty, LangItem::Pin), \"Pin::new\"),\n+                    (self.tcx.mk_diagnostic_item(*rcvr_ty, sym::Arc), \"Arc::new\"),\n+                    (self.tcx.mk_diagnostic_item(*rcvr_ty, sym::Rc), \"Rc::new\"),\n                 ] {\n                     if let Some(new_rcvr_t) = *rcvr_ty {\n                         if let Ok(pick) = self.lookup_probe("}, {"sha": "dd49d6f489259695639bba5fd8c08a64dbc899f8", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -221,7 +221,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             },\n                         };\n                         let autoref = Adjustment {\n-                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n+                            kind: Adjust::Borrow(AutoBorrow::Ref(*region, mutbl)),\n                             target: method.sig.inputs()[0],\n                         };\n                         self.apply_adjustments(lhs_expr, vec![autoref]);\n@@ -238,7 +238,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             },\n                         };\n                         let autoref = Adjustment {\n-                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n+                            kind: Adjust::Borrow(AutoBorrow::Ref(*region, mutbl)),\n                             target: method.sig.inputs()[1],\n                         };\n                         // HACK(eddyb) Bypass checks due to reborrows being in\n@@ -399,8 +399,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 };\n                 if let Ref(_, rty, _) = lhs_ty.kind() {\n-                    if self.infcx.type_is_copy_modulo_regions(self.param_env, rty, lhs_expr.span)\n-                        && self.lookup_op_method(rty, &[rhs_ty], Op::Binary(op, is_assign)).is_ok()\n+                    if self.infcx.type_is_copy_modulo_regions(self.param_env, *rty, lhs_expr.span)\n+                        && self.lookup_op_method(*rty, &[rhs_ty], Op::Binary(op, is_assign)).is_ok()\n                     {\n                         if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n                             let msg = &format!(\n@@ -452,7 +452,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     self.tcx,\n                                     self.body_id,\n                                     &mut err,\n-                                    ty,\n+                                    *ty,\n                                     rhs_ty,\n                                     missing_trait,\n                                     p,\n@@ -878,7 +878,7 @@ enum Op {\n /// Dereferences a single level of immutable referencing.\n fn deref_ty_if_possible<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.kind() {\n-        ty::Ref(_, ty, hir::Mutability::Not) => ty,\n+        ty::Ref(_, ty, hir::Mutability::Not) => *ty,\n         _ => ty,\n     }\n }"}, {"sha": "320f5a97e0a24960be2bae19bda41f385d7277f1", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -1935,7 +1935,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         element_ty: Ty<'tcx>,\n         arr_ty: Ty<'tcx>,\n         slice: Option<&'tcx Pat<'tcx>>,\n-        len: &ty::Const<'tcx>,\n+        len: ty::Const<'tcx>,\n         min_len: u64,\n     ) -> (Option<Ty<'tcx>>, Ty<'tcx>) {\n         if let Some(len) = len.try_eval_usize(self.tcx, self.param_env) {"}, {"sha": "318979b462759413fad36d629de06aa229041fef", "filename": "compiler/rustc_typeck/src/check/place_op.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -31,7 +31,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.apply_adjustments(\n                 oprnd_expr,\n                 vec![Adjustment {\n-                    kind: Adjust::Borrow(AutoBorrow::Ref(region, AutoBorrowMutability::Not)),\n+                    kind: Adjust::Borrow(AutoBorrow::Ref(*region, AutoBorrowMutability::Not)),\n                     target: method.sig.inputs()[0],\n                 }],\n             );\n@@ -142,7 +142,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if unsize {\n                 // We only unsize arrays here.\n                 if let ty::Array(element_ty, _) = adjusted_ty.kind() {\n-                    self_ty = self.tcx.mk_slice(element_ty);\n+                    self_ty = self.tcx.mk_slice(*element_ty);\n                 } else {\n                     continue;\n                 }\n@@ -165,9 +165,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let mut adjustments = self.adjust_steps(autoderef);\n                 if let ty::Ref(region, _, hir::Mutability::Not) = method.sig.inputs()[0].kind() {\n                     adjustments.push(Adjustment {\n-                        kind: Adjust::Borrow(AutoBorrow::Ref(region, AutoBorrowMutability::Not)),\n+                        kind: Adjust::Borrow(AutoBorrow::Ref(*region, AutoBorrowMutability::Not)),\n                         target: self.tcx.mk_ref(\n-                            region,\n+                            *region,\n                             ty::TypeAndMut { mutbl: hir::Mutability::Not, ty: adjusted_ty },\n                         ),\n                     });\n@@ -432,9 +432,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // not the case today.\n                         allow_two_phase_borrow: AllowTwoPhase::No,\n                     };\n-                    adjustment.kind = Adjust::Borrow(AutoBorrow::Ref(region, mutbl));\n-                    adjustment.target =\n-                        self.tcx.mk_ref(region, ty::TypeAndMut { ty: source, mutbl: mutbl.into() });\n+                    adjustment.kind = Adjust::Borrow(AutoBorrow::Ref(*region, mutbl));\n+                    adjustment.target = self\n+                        .tcx\n+                        .mk_ref(*region, ty::TypeAndMut { ty: source, mutbl: mutbl.into() });\n                 }\n                 source = adjustment.target;\n             }"}, {"sha": "513e8576f2d1936882fbfe59a76469e39ed49523", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -689,7 +689,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         let rptr_ty = self.resolve_node_type(id);\n         if let ty::Ref(r, _, _) = rptr_ty.kind() {\n             debug!(\"rptr_ty={}\", rptr_ty);\n-            self.link_region(span, r, ty::BorrowKind::from_mutbl(mutbl), cmt_borrowed);\n+            self.link_region(span, *r, ty::BorrowKind::from_mutbl(mutbl), cmt_borrowed);\n         }\n     }\n "}, {"sha": "949d857bff46288302154e0c80ea49e6e63f19be", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -966,7 +966,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.tcx,\n                     ty,\n                     max_capture_info.capture_kind,\n-                    Some(&ty::ReErased),\n+                    Some(self.tcx.lifetimes.re_erased),\n                 )\n             }\n         };\n@@ -997,7 +997,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.tcx,\n                 capture.place.ty(),\n                 capture.info.capture_kind,\n-                Some(&ty::ReErased),\n+                Some(self.tcx.lifetimes.re_erased),\n             );\n \n             // Checks if a capture implements any of the auto traits\n@@ -1499,7 +1499,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // If the data will be moved out of this place, then the place will be truncated\n             // at the first Deref in `adjust_upvar_borrow_kind_for_consume` and then moved into\n             // the closure.\n-            hir::CaptureBy::Value if !place.deref_tys().any(ty::TyS::is_ref) => {\n+            hir::CaptureBy::Value if !place.deref_tys().any(Ty::is_ref) => {\n                 ty::UpvarCapture::ByValue\n             }\n             hir::CaptureBy::Value | hir::CaptureBy::Ref => ty::UpvarCapture::ByRef(ty::ImmBorrow),\n@@ -1813,7 +1813,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         );\n \n         // Raw pointers don't inherit mutability\n-        if place_with_id.place.deref_tys().any(ty::TyS::is_unsafe_ptr) {\n+        if place_with_id.place.deref_tys().any(Ty::is_unsafe_ptr) {\n             capture_kind = ty::UpvarCapture::ByRef(ty::BorrowKind::ImmBorrow);\n         }\n "}, {"sha": "9bdeb3a679a3d487b7f34c25a8fb401857732c0d", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -336,7 +336,7 @@ fn check_gat_where_clauses(\n             // Ignore `'static` lifetimes for the purpose of this lint: it's\n             // because we know it outlives everything and so doesn't give meaninful\n             // clues\n-            if let ty::ReStatic = region {\n+            if region.is_static() {\n                 continue;\n             }\n             for (ty, ty_idx) in &types {\n@@ -355,12 +355,11 @@ fn check_gat_where_clauses(\n                     // Same for the region. In our example, 'a corresponds\n                     // to the 'me parameter.\n                     let region_param = generics.param_at(*region_idx, tcx);\n-                    let region_param =\n-                        tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n-                            def_id: region_param.def_id,\n-                            index: region_param.index,\n-                            name: region_param.name,\n-                        }));\n+                    let region_param = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                        def_id: region_param.def_id,\n+                        index: region_param.index,\n+                        name: region_param.name,\n+                    }));\n                     // The predicate we expect to see. (In our example,\n                     // `Self: 'me`.)\n                     let clause = ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n@@ -381,14 +380,14 @@ fn check_gat_where_clauses(\n             // Ignore `'static` lifetimes for the purpose of this lint: it's\n             // because we know it outlives everything and so doesn't give meaninful\n             // clues\n-            if let ty::ReStatic = region_a {\n+            if region_a.is_static() {\n                 continue;\n             }\n             for (region_b, region_b_idx) in &regions {\n                 if region_a == region_b {\n                     continue;\n                 }\n-                if let ty::ReStatic = region_b {\n+                if region_b.is_static() {\n                     continue;\n                 }\n \n@@ -397,20 +396,18 @@ fn check_gat_where_clauses(\n                     debug!(\"required clause: {} must outlive {}\", region_a, region_b);\n                     // Translate into the generic parameters of the GAT.\n                     let region_a_param = generics.param_at(*region_a_idx, tcx);\n-                    let region_a_param =\n-                        tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n-                            def_id: region_a_param.def_id,\n-                            index: region_a_param.index,\n-                            name: region_a_param.name,\n-                        }));\n+                    let region_a_param = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                        def_id: region_a_param.def_id,\n+                        index: region_a_param.index,\n+                        name: region_a_param.name,\n+                    }));\n                     // Same for the region.\n                     let region_b_param = generics.param_at(*region_b_idx, tcx);\n-                    let region_b_param =\n-                        tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n-                            def_id: region_b_param.def_id,\n-                            index: region_b_param.index,\n-                            name: region_b_param.name,\n-                        }));\n+                    let region_b_param = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                        def_id: region_b_param.def_id,\n+                        index: region_b_param.index,\n+                        name: region_b_param.name,\n+                    }));\n                     // The predicate we expect to see.\n                     let clause = ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n                         region_a_param,\n@@ -569,7 +566,7 @@ fn resolve_regions_with_wf_tys<'tcx>(\n     wf_tys: &FxHashSet<Ty<'tcx>>,\n     add_constraints: impl for<'a> FnOnce(\n         &'a InferCtxt<'a, 'tcx>,\n-        &'a Vec<(&'tcx ty::RegionKind, GenericKind<'tcx>)>,\n+        &'a Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n     ),\n ) -> bool {\n     // Unfortunately, we have to use a new `InferCtxt` each call, because\n@@ -1298,8 +1295,8 @@ fn check_where_clauses<'tcx, 'fcx>(\n                     ControlFlow::BREAK\n                 }\n \n-                fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                    if let ty::ConstKind::Param(param) = c.val {\n+                fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                    if let ty::ConstKind::Param(param) = c.val() {\n                         self.params.insert(param.index);\n                     }\n                     c.super_visit_with(self)"}, {"sha": "3843e7e54bec4cca7e056ef73663ca7c3965c2b4", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -720,7 +720,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n         }\n     }\n \n-    fn report_const_error(&self, c: &'tcx ty::Const<'tcx>) {\n+    fn report_const_error(&self, c: ty::Const<'tcx>) {\n         if !self.tcx.sess.has_errors() {\n             self.infcx\n                 .emit_inference_failure_err(\n@@ -751,7 +751,7 @@ impl<'tcx> TypeFolder<'tcx> for EraseEarlyRegions<'tcx> {\n         }\n     }\n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        if let ty::ReLateBound(..) = r { r } else { self.tcx.lifetimes.re_erased }\n+        if r.is_late_bound() { r } else { self.tcx.lifetimes.re_erased }\n     }\n }\n \n@@ -783,14 +783,14 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n         self.tcx.lifetimes.re_erased\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n         match self.infcx.fully_resolve(ct) {\n             Ok(ct) => self.infcx.tcx.erase_regions(ct),\n             Err(_) => {\n                 debug!(\"Resolver::fold_const: input const `{:?}` not fully resolvable\", ct);\n                 self.report_const_error(ct);\n                 self.replaced_with_error = true;\n-                self.tcx().const_error(ct.ty)\n+                self.tcx().const_error(ct.ty())\n             }\n         }\n     }"}, {"sha": "401ba188728c17e3cd0b8607607c7d6d61b3ab69", "filename": "compiler/rustc_typeck/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -147,7 +147,7 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did:\n         use ty::TyKind::*;\n         match (source.kind(), target.kind()) {\n             (&Ref(r_a, _, mutbl_a), Ref(r_b, _, mutbl_b))\n-                if infcx.at(&cause, param_env).eq(r_a, r_b).is_ok() && mutbl_a == *mutbl_b => {}\n+                if infcx.at(&cause, param_env).eq(r_a, *r_b).is_ok() && mutbl_a == *mutbl_b => {}\n             (&RawPtr(tm_a), &RawPtr(tm_b)) if tm_a.mutbl == tm_b.mutbl => (),\n             (&Adt(def_a, substs_a), &Adt(def_b, substs_b))\n                 if def_a.is_struct() && def_b.is_struct() =>"}, {"sha": "9bb310037965555f0d784fd1c50242d23561aae8", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -301,7 +301,7 @@ impl<'tcx> TypeVisitor<'tcx> for AreUniqueParamsVisitor {\n         }\n     }\n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        match r {\n+        match *r {\n             ty::ReEarlyBound(p) => {\n                 if self.seen.insert(p.index) {\n                     ControlFlow::CONTINUE\n@@ -312,8 +312,8 @@ impl<'tcx> TypeVisitor<'tcx> for AreUniqueParamsVisitor {\n             _ => ControlFlow::Break(NotUniqueParam::NotParam(r.into())),\n         }\n     }\n-    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        match c.val {\n+    fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match c.val() {\n             ty::ConstKind::Param(p) => {\n                 if self.seen.insert(p.index) {\n                     ControlFlow::CONTINUE"}, {"sha": "88dc90dd3e7b04337106ea1d2c3d8a43422ae242", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -389,13 +389,8 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n         self.tcx().ty_error_with_message(span, \"bad placeholder type\")\n     }\n \n-    fn ct_infer(\n-        &self,\n-        ty: Ty<'tcx>,\n-        _: Option<&ty::GenericParamDef>,\n-        span: Span,\n-    ) -> &'tcx Const<'tcx> {\n-        let ty = self.tcx.fold_regions(ty, &mut false, |r, _| match r {\n+    fn ct_infer(&self, ty: Ty<'tcx>, _: Option<&ty::GenericParamDef>, span: Span) -> Const<'tcx> {\n+        let ty = self.tcx.fold_regions(ty, &mut false, |r, _| match *r {\n             ty::ReErased => self.tcx.lifetimes.re_static,\n             _ => r,\n         });\n@@ -1878,7 +1873,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n                 Some(ty) => {\n                     let fn_sig = tcx.typeck(def_id).liberated_fn_sigs()[hir_id];\n                     // Typeck doesn't expect erased regions to be returned from `type_of`.\n-                    let fn_sig = tcx.fold_regions(fn_sig, &mut false, |r, _| match r {\n+                    let fn_sig = tcx.fold_regions(fn_sig, &mut false, |r, _| match *r {\n                         ty::ReErased => tcx.lifetimes.re_static,\n                         _ => r,\n                     });\n@@ -2394,7 +2389,7 @@ fn const_evaluatable_predicates_of<'tcx>(\n         fn visit_anon_const(&mut self, c: &'tcx hir::AnonConst) {\n             let def_id = self.tcx.hir().local_def_id(c.hir_id);\n             let ct = ty::Const::from_anon_const(self.tcx, def_id);\n-            if let ty::ConstKind::Unevaluated(uv) = ct.val {\n+            if let ty::ConstKind::Unevaluated(uv) = ct.val() {\n                 assert_eq!(uv.promoted, None);\n                 let span = self.tcx.hir().span(c.hir_id);\n                 self.preds.insert((\n@@ -2591,7 +2586,7 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n             }\n         };\n         for (input, ty) in iter::zip(decl.inputs, fty.inputs().skip_binder()) {\n-            check(input, ty)\n+            check(input, *ty)\n         }\n         if let hir::FnRetTy::Return(ref ty) = decl.output {\n             check(ty, fty.output().skip_binder())"}, {"sha": "90555b213c1cab86a6ce974be718f5bceca2058a", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -639,7 +639,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n                         err.emit();\n                     }\n                 } else {\n-                    self.found = Some((span, concrete_type));\n+                    self.found = Some((span, *concrete_type));\n                 }\n             }\n         }\n@@ -829,7 +829,7 @@ fn infer_placeholder_type<'a>(\n     }\n \n     // Typeck doesn't expect erased regions to be returned from `type_of`.\n-    tcx.fold_regions(ty, &mut false, |r, _| match r {\n+    tcx.fold_regions(ty, &mut false, |r, _| match *r {\n         ty::ReErased => tcx.lifetimes.re_static,\n         _ => r,\n     })"}, {"sha": "909c99adab5d2d91f6162e86d206896e145f8e3b", "filename": "compiler/rustc_typeck/src/constrained_generic_params.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -79,11 +79,11 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n         ControlFlow::CONTINUE\n     }\n \n-    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        match c.val {\n+    fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match c.val() {\n             ty::ConstKind::Unevaluated(..) if !self.include_nonconstraining => {\n                 // Constant expressions are not injective\n-                return c.ty.visit_with(self);\n+                return c.ty().visit_with(self);\n             }\n             ty::ConstKind::Param(data) => {\n                 self.parameters.push(Parameter::from(data));"}, {"sha": "7b709b302f630a0b0369f32c5f9c9f84acf4e7fc", "filename": "compiler/rustc_typeck/src/hir_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -180,6 +180,6 @@ impl<'tcx> TypeFolder<'tcx> for EraseAllBoundRegions<'tcx> {\n         self.tcx\n     }\n     fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n-        if let ty::ReLateBound(..) = r { &ty::ReErased } else { r }\n+        if r.is_late_bound() { self.tcx.lifetimes.re_erased } else { r }\n     }\n }"}, {"sha": "92f88a15ee4163c3f66868ee076f07d76b54657b", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -269,7 +269,7 @@ fn check_static_lifetimes<'tcx>(\n     parent_substs: &Vec<GenericArg<'tcx>>,\n     span: Span,\n ) {\n-    if tcx.any_free_region_meets(parent_substs, |r| *r == ty::ReStatic) {\n+    if tcx.any_free_region_meets(parent_substs, |r| r.is_static()) {\n         tcx.sess.struct_span_err(span, \"cannot specialize on `'static` lifetime\").emit();\n     }\n }"}, {"sha": "1bbd6d29294a60e62fe6e067177d036f3da50c45", "filename": "compiler/rustc_typeck/src/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -192,7 +192,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         if let Some(vec) = self.typeck_results.pat_adjustments().get(pat.hir_id) {\n             if let Some(first_ty) = vec.first() {\n                 debug!(\"pat_ty(pat={:?}) found adjusted ty `{:?}`\", pat, first_ty);\n-                return Ok(first_ty);\n+                return Ok(*first_ty);\n             }\n         }\n "}, {"sha": "139be8a42de7ed91dd6a187c5d6253432f0181fe", "filename": "compiler/rustc_typeck/src/outlives/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -105,14 +105,14 @@ fn inferred_outlives_crate(tcx: TyCtxt<'_>, (): ()) -> CratePredicatesMap<'_> {\n                     match kind1.unpack() {\n                         GenericArgKind::Type(ty1) => Some((\n                             ty::Binder::dummy(ty::PredicateKind::TypeOutlives(\n-                                ty::OutlivesPredicate(ty1, region2),\n+                                ty::OutlivesPredicate(ty1, *region2),\n                             ))\n                             .to_predicate(tcx),\n                             span,\n                         )),\n                         GenericArgKind::Lifetime(region1) => Some((\n                             ty::Binder::dummy(ty::PredicateKind::RegionOutlives(\n-                                ty::OutlivesPredicate(region1, region2),\n+                                ty::OutlivesPredicate(region1, *region2),\n                             ))\n                             .to_predicate(tcx),\n                             span,"}, {"sha": "54a5037b57578da53aef14b2d097af3ddc51556b", "filename": "compiler/rustc_typeck/src/outlives/utils.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Futils.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -1,6 +1,6 @@\n use rustc_infer::infer::outlives::components::{push_outlives_components, Component};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, Region, RegionKind, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Region, Ty, TyCtxt};\n use rustc_span::Span;\n use smallvec::smallvec;\n use std::collections::BTreeMap;\n@@ -133,15 +133,15 @@ pub fn insert_outlives_predicate<'tcx>(\n \n fn is_free_region(tcx: TyCtxt<'_>, region: Region<'_>) -> bool {\n     // First, screen for regions that might appear in a type header.\n-    match region {\n+    match *region {\n         // These correspond to `T: 'a` relationships:\n         //\n         //     struct Foo<'a, T> {\n         //         field: &'a T, // this would generate a ReEarlyBound referencing `'a`\n         //     }\n         //\n         // We care about these, so fall through.\n-        RegionKind::ReEarlyBound(_) => true,\n+        ty::ReEarlyBound(_) => true,\n \n         // These correspond to `T: 'static` relationships which can be\n         // rather surprising. We are therefore putting this behind a\n@@ -150,7 +150,7 @@ fn is_free_region(tcx: TyCtxt<'_>, region: Region<'_>) -> bool {\n         //     struct Foo<'a, T> {\n         //         field: &'static T, // this would generate a ReStatic\n         //     }\n-        RegionKind::ReStatic => tcx.sess.features_untracked().infer_static_outlives_requirements,\n+        ty::ReStatic => tcx.sess.features_untracked().infer_static_outlives_requirements,\n \n         // Late-bound regions can appear in `fn` types:\n         //\n@@ -160,19 +160,16 @@ fn is_free_region(tcx: TyCtxt<'_>, region: Region<'_>) -> bool {\n         //\n         // The type above might generate a `T: 'b` bound, but we can\n         // ignore it.  We can't put it on the struct header anyway.\n-        RegionKind::ReLateBound(..) => false,\n+        ty::ReLateBound(..) => false,\n \n         // This can appear in `where Self: ` bounds (#64855):\n         //\n         //     struct Bar<T>(<Self as Foo>::Type) where Self: ;\n         //     struct Baz<'a>(&'a Self) where Self: ;\n-        RegionKind::ReEmpty(_) => false,\n+        ty::ReEmpty(_) => false,\n \n         // These regions don't appear in types from type declarations:\n-        RegionKind::ReErased\n-        | RegionKind::ReVar(..)\n-        | RegionKind::RePlaceholder(..)\n-        | RegionKind::ReFree(..) => {\n+        ty::ReErased | ty::ReVar(..) | ty::RePlaceholder(..) | ty::ReFree(..) => {\n             bug!(\"unexpected region in outlives inference: {:?}\", region);\n         }\n     }"}, {"sha": "1c8f848cf2893187c9ae70f14649cf75534b1e27", "filename": "compiler/rustc_typeck/src/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -401,12 +401,12 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn add_constraints_from_const(\n         &mut self,\n         current: &CurrentItem,\n-        val: &ty::Const<'tcx>,\n+        val: ty::Const<'tcx>,\n         variance: VarianceTermPtr<'a>,\n     ) {\n         debug!(\"add_constraints_from_const(val={:?}, variance={:?})\", val, variance);\n \n-        match &val.val {\n+        match &val.val() {\n             ty::ConstKind::Unevaluated(uv) => {\n                 self.add_constraints_from_invariant_substs(current, uv.substs, variance);\n             }"}, {"sha": "a3154d8f03bf82ee752993d13839e2ff8ebaf20d", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -297,7 +297,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     .get(name)\n                     .unwrap_or(&empty)\n                     .iter()\n-                    .map(|region| GenericBound::Outlives(Self::get_lifetime(region, names_map)))\n+                    .map(|region| GenericBound::Outlives(Self::get_lifetime(*region, names_map)))\n                     .collect();\n \n                 if bounds.is_empty() {"}, {"sha": "bcbde428e7c5aec1effa76990fee4004b3999c7c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -218,9 +218,9 @@ impl Clean<Constant> for hir::ConstArg {\n     }\n }\n \n-impl Clean<Option<Lifetime>> for ty::RegionKind {\n+impl Clean<Option<Lifetime>> for ty::Region<'_> {\n     fn clean(&self, _cx: &mut DocContext<'_>) -> Option<Lifetime> {\n-        match *self {\n+        match **self {\n             ty::ReStatic => Some(Lifetime::statik()),\n             ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name), .. }) => {\n                 Some(Lifetime(name))\n@@ -327,7 +327,7 @@ impl<'tcx> Clean<Option<WherePredicate>>\n     fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n         let ty::OutlivesPredicate(a, b) = self;\n \n-        if let (ty::ReEmpty(_), ty::ReEmpty(_)) = (a, b) {\n+        if a.is_empty() && b.is_empty() {\n             return None;\n         }\n \n@@ -342,7 +342,7 @@ impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty:\n     fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n         let ty::OutlivesPredicate(ty, lt) = self;\n \n-        if let ty::ReEmpty(_) = lt {\n+        if lt.is_empty() {\n             return None;\n         }\n \n@@ -1460,7 +1460,7 @@ fn normalize<'tcx>(cx: &mut DocContext<'tcx>, ty: Ty<'_>) -> Option<Ty<'tcx>> {\n impl<'tcx> Clean<Type> for Ty<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n         trace!(\"cleaning type: {:?}\", self);\n-        let ty = normalize(cx, self).unwrap_or(self);\n+        let ty = normalize(cx, *self).unwrap_or(*self);\n         match *ty.kind() {\n             ty::Never => Primitive(PrimitiveType::Never),\n             ty::Bool => Primitive(PrimitiveType::Bool),\n@@ -1646,7 +1646,7 @@ impl<'tcx> Clean<Constant> for ty::Const<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Constant {\n         // FIXME: instead of storing the stringified expression, store `self` directly instead.\n         Constant {\n-            type_: self.ty.clean(cx),\n+            type_: self.ty().clean(cx),\n             kind: ConstantKind::TyConst { expr: self.to_string() },\n         }\n     }"}, {"sha": "1d312df1f785890522d1bc0fa700a7d79fbe4a95", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -89,7 +89,7 @@ fn external_generic_args(\n     let args: Vec<_> = substs\n         .iter()\n         .filter_map(|kind| match kind.unpack() {\n-            GenericArgKind::Lifetime(lt) => match lt {\n+            GenericArgKind::Lifetime(lt) => match *lt {\n                 ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrAnon(_), .. }) => {\n                     Some(GenericArg::Lifetime(Lifetime::elided()))\n                 }\n@@ -226,8 +226,8 @@ crate fn name_from_pat(p: &hir::Pat<'_>) -> Symbol {\n     })\n }\n \n-crate fn print_const(cx: &DocContext<'_>, n: &ty::Const<'_>) -> String {\n-    match n.val {\n+crate fn print_const(cx: &DocContext<'_>, n: ty::Const<'_>) -> String {\n+    match n.val() {\n         ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs: _, promoted }) => {\n             let mut s = if let Some(def) = def.as_local() {\n                 let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def.did);\n@@ -297,15 +297,15 @@ fn format_integer_with_underscore_sep(num: &str) -> String {\n         .collect()\n }\n \n-fn print_const_with_custom_print_scalar(tcx: TyCtxt<'_>, ct: &ty::Const<'_>) -> String {\n+fn print_const_with_custom_print_scalar(tcx: TyCtxt<'_>, ct: ty::Const<'_>) -> String {\n     // Use a slightly different format for integer types which always shows the actual value.\n     // For all other types, fallback to the original `pretty_print_const`.\n-    match (ct.val, ct.ty.kind()) {\n+    match (ct.val(), ct.ty().kind()) {\n         (ty::ConstKind::Value(ConstValue::Scalar(int)), ty::Uint(ui)) => {\n             format!(\"{}{}\", format_integer_with_underscore_sep(&int.to_string()), ui.name_str())\n         }\n         (ty::ConstKind::Value(ConstValue::Scalar(int)), ty::Int(i)) => {\n-            let ty = tcx.lift(ct.ty).unwrap();\n+            let ty = tcx.lift(ct.ty()).unwrap();\n             let size = tcx.layout_of(ty::ParamEnv::empty().and(ty)).unwrap().size;\n             let data = int.assert_bits(size);\n             let sign_extended_data = size.sign_extend(data) as i128;"}, {"sha": "2697d46bdb2f42a510b6d12f7bf9c1a19abec2f0", "filename": "src/test/ui/issues/issue-35570.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftest%2Fui%2Fissues%2Fissue-35570.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftest%2Fui%2Fissues%2Fissue-35570.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35570.stderr?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `for<'a> (): Trait2<'a>` is not satisfied\n-  --> $DIR/issue-35570.rs:8:4\n+  --> $DIR/issue-35570.rs:8:40\n    |\n LL | fn _ice(param: Box<dyn for <'a> Trait1<<() as Trait2<'a>>::Ty>>) {\n-   |    ^^^^ the trait `for<'a> Trait2<'a>` is not implemented for `()`\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^ the trait `for<'a> Trait2<'a>` is not implemented for `()`\n \n error: aborting due to previous error\n "}, {"sha": "6844e86653299c00810f2b600408e18710338e72", "filename": "src/test/ui/regions/regions-implied-bounds-projection-gap-hr-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-hr-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-hr-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-hr-1.stderr?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `for<'z> T: Trait2<'y, 'z>` is not satisfied\n-  --> $DIR/regions-implied-bounds-projection-gap-hr-1.rs:21:4\n+  --> $DIR/regions-implied-bounds-projection-gap-hr-1.rs:21:49\n    |\n LL | fn callee<'x, 'y, T>(t: &'x dyn for<'z> Trait1< <T as Trait2<'y, 'z>>::Foo >)\n-   |    ^^^^^^ the trait `for<'z> Trait2<'y, 'z>` is not implemented for `T`\n+   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `for<'z> Trait2<'y, 'z>` is not implemented for `T`\n    |\n help: consider restricting type parameter `T`\n    |"}, {"sha": "7637666d059ef319be896210e2e7e0c6cb0feca5", "filename": "src/tools/clippy/clippy_lints/src/case_sensitive_file_extension_comparisons.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -47,7 +47,7 @@ fn check_case_sensitive_file_extension_comparison(ctx: &LateContext<'_>, expr: &\n         then {\n             let mut ty = ctx.typeck_results().expr_ty(obj);\n             ty = match ty.kind() {\n-                ty::Ref(_, ty, ..) => ty,\n+                ty::Ref(_, ty, ..) => *ty,\n                 _ => ty\n             };\n "}, {"sha": "b80d55dd192a10201dc0fa67c4c49fd7cbdbdbea", "filename": "src/tools/clippy/clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -123,7 +123,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                 if let Some(fn_sig) = fn_sig_opt(self.cx, func.hir_id) {\n                     for (expr, bound) in iter::zip(*args, fn_sig.skip_binder().inputs()) {\n                         // Push found arg type, then visit arg.\n-                        self.ty_bounds.push(TyBound::Ty(bound));\n+                        self.ty_bounds.push(TyBound::Ty(*bound));\n                         self.visit_expr(expr);\n                         self.ty_bounds.pop();\n                     }\n@@ -135,7 +135,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                 if let Some(def_id) = self.cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n                     let fn_sig = self.cx.tcx.fn_sig(def_id).skip_binder();\n                     for (expr, bound) in iter::zip(*args, fn_sig.inputs()) {\n-                        self.ty_bounds.push(TyBound::Ty(bound));\n+                        self.ty_bounds.push(TyBound::Ty(*bound));\n                         self.visit_expr(expr);\n                         self.ty_bounds.pop();\n                     }\n@@ -210,7 +210,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n \n fn fn_sig_opt<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<PolyFnSig<'tcx>> {\n     let node_ty = cx.typeck_results().node_type_opt(hir_id)?;\n-    // We can't use `TyS::fn_sig` because it automatically performs substs, this may result in FNs.\n+    // We can't use `Ty::fn_sig` because it automatically performs substs, this may result in FNs.\n     match node_ty.kind() {\n         ty::FnDef(def_id, _) => Some(cx.tcx.fn_sig(*def_id)),\n         ty::FnPtr(fn_sig) => Some(*fn_sig),"}, {"sha": "ea547793b1ea2528a0a6662e972b68041d9c4174", "filename": "src/tools/clippy/clippy_lints/src/eq_op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -7,10 +7,10 @@ use clippy_utils::{ast_utils::is_useless_with_eq_exprs, eq_expr_value, is_in_tes\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{\n-    def::Res, def_id::DefId, BinOpKind, BorrowKind, Expr, ExprKind, GenericArg, ItemKind, QPath, Ty, TyKind,\n+    def::Res, def_id::DefId, BinOpKind, BorrowKind, Expr, ExprKind, GenericArg, ItemKind, QPath, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, TyS};\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -279,7 +279,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n     }\n }\n \n-fn in_impl<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, bin_op: DefId) -> Option<(&'tcx Ty<'tcx>, &'tcx Ty<'tcx>)> {\n+fn in_impl<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, bin_op: DefId) -> Option<(&'tcx rustc_hir::Ty<'tcx>, &'tcx rustc_hir::Ty<'tcx>)> {\n     if_chain! {\n         if let Some(block) = get_enclosing_block(cx, e.hir_id);\n         if let Some(impl_def_id) = cx.tcx.impl_of_method(block.hir_id.owner.to_def_id());\n@@ -301,7 +301,7 @@ fn in_impl<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, bin_op: DefId) -> Op\n     }\n }\n \n-fn are_equal<'tcx>(cx: &LateContext<'tcx>, middle_ty: &TyS<'_>, hir_ty: &Ty<'_>) -> bool {\n+fn are_equal<'tcx>(cx: &LateContext<'tcx>, middle_ty: Ty<'_>, hir_ty: &rustc_hir::Ty<'_>) -> bool {\n     if_chain! {\n         if let ty::Adt(adt_def, _) = middle_ty.kind();\n         if let Some(local_did) = adt_def.did.as_local();"}, {"sha": "503aac8ccd02628a8702a8db7958e3b151896c0e", "filename": "src/tools/clippy/clippy_lints/src/format_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -211,7 +211,7 @@ where\n             if overloaded_deref.is_some() {\n                 n_needed = n_total;\n             }\n-            ty = target;\n+            ty = *target;\n         } else {\n             return (n_needed, ty);\n         }"}, {"sha": "6b62748ffef2e2812195961768e5d416197d6a26", "filename": "src/tools/clippy/clippy_lints/src/index_refutable_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -118,7 +118,7 @@ fn find_slice_values(cx: &LateContext<'_>, pat: &hir::Pat<'_>) -> FxIndexMap<hir\n                 // The values need to use the `ref` keyword if they can't be copied.\n                 // This will need to be adjusted if the lint want to support multable access in the future\n                 let src_is_ref = bound_ty.is_ref() && binding != hir::BindingAnnotation::Ref;\n-                let needs_ref = !(src_is_ref || is_copy(cx, inner_ty));\n+                let needs_ref = !(src_is_ref || is_copy(cx, *inner_ty));\n \n                 let slice_info = slices\n                     .entry(value_hir_id)"}, {"sha": "27db6388136139e1789e570826078a7ddaeba901", "filename": "src/tools/clippy/clippy_lints/src/large_const_arrays.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -53,9 +53,9 @@ impl<'tcx> LateLintPass<'tcx> for LargeConstArrays {\n             if let ItemKind::Const(hir_ty, _) = &item.kind;\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             if let ty::Array(element_type, cst) = ty.kind();\n-            if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.val;\n+            if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.val();\n             if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);\n-            if let Ok(element_size) = cx.layout_of(element_type).map(|l| l.size.bytes());\n+            if let Ok(element_size) = cx.layout_of(*element_type).map(|l| l.size.bytes());\n             if self.maximum_allowed_size < element_count * element_size;\n \n             then {"}, {"sha": "57b0d709acd4de9dcc4efef8062a037ddac23396", "filename": "src/tools/clippy/clippy_lints/src/large_stack_arrays.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -43,9 +43,9 @@ impl<'tcx> LateLintPass<'tcx> for LargeStackArrays {\n         if_chain! {\n             if let ExprKind::Repeat(_, _) = expr.kind;\n             if let ty::Array(element_type, cst) = cx.typeck_results().expr_ty(expr).kind();\n-            if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.val;\n+            if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.val();\n             if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);\n-            if let Ok(element_size) = cx.layout_of(element_type).map(|l| l.size.bytes());\n+            if let Ok(element_size) = cx.layout_of(*element_type).map(|l| l.size.bytes());\n             if self.maximum_allowed_size < element_count * element_size;\n             then {\n                 span_lint_and_help("}, {"sha": "35d10d53112ec6c3591555833dcace76f3c9ed6c", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -294,7 +294,7 @@ impl LenOutput<'_> {\n /// Checks if the given signature matches the expectations for `is_empty`\n fn check_is_empty_sig(sig: FnSig<'_>, self_kind: ImplicitSelfKind, len_output: LenOutput<'_>) -> bool {\n     match &**sig.inputs_and_output {\n-        [arg, res] if len_output.matches_is_empty_output(res) => {\n+        [arg, res] if len_output.matches_is_empty_output(*res) => {\n             matches!(\n                 (arg.kind(), self_kind),\n                 (ty::Ref(_, _, Mutability::Not), ImplicitSelfKind::ImmRef)"}, {"sha": "fc50e8addccec8f84e87c03fffedd10a92daa3dd", "filename": "src/tools/clippy/clippy_lints/src/loops/explicit_counter_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -7,7 +7,7 @@ use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr};\n use rustc_hir::{Expr, Pat};\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, UintTy};\n+use rustc_middle::ty::{self, Ty, UintTy};\n \n // To trigger the EXPLICIT_COUNTER_LOOP lint, a variable must be\n // incremented exactly once in the loop body, and initialized to zero\n@@ -36,7 +36,7 @@ pub(super) fn check<'tcx>(\n                 then {\n                     let mut applicability = Applicability::MachineApplicable;\n \n-                    let int_name = match ty.map(ty::TyS::kind) {\n+                    let int_name = match ty.map(Ty::kind) {\n                         // usize or inferred\n                         Some(ty::Uint(UintTy::Usize)) | None => {\n                             span_lint_and_sugg("}, {"sha": "f6ef87264c0a6f3b8f2a70cf3f3e3a44164c3f85", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -335,8 +335,8 @@ struct Start<'hir> {\n fn get_slice_like_element_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     match ty.kind() {\n         ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::Vec, adt.did) => Some(subs.type_at(0)),\n-        ty::Ref(_, subty, _) => get_slice_like_element_ty(cx, subty),\n-        ty::Slice(ty) | ty::Array(ty, _) => Some(ty),\n+        ty::Ref(_, subty, _) => get_slice_like_element_ty(cx, *subty),\n+        ty::Slice(ty) | ty::Array(ty, _) => Some(*ty),\n         _ => None,\n     }\n }"}, {"sha": "06190850bb003ebe1ef2d772e462dd35289e7a12", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -12,7 +12,7 @@ use rustc_hir::{Block, Expr, ExprKind, HirId, HirIdSet, Local, Mutability, Node,\n use rustc_lint::LateContext;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, TyS};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::sym;\n use rustc_span::{MultiSpan, Span};\n \n@@ -334,8 +334,8 @@ fn detect_iter_and_into_iters<'tcx: 'a, 'a>(\n     }\n }\n \n-fn get_captured_ids(cx: &LateContext<'_>, ty: &'_ TyS<'_>) -> HirIdSet {\n-    fn get_captured_ids_recursive(cx: &LateContext<'_>, ty: &'_ TyS<'_>, set: &mut HirIdSet) {\n+fn get_captured_ids(cx: &LateContext<'_>, ty: Ty<'_>) -> HirIdSet {\n+    fn get_captured_ids_recursive(cx: &LateContext<'_>, ty: Ty<'_>, set: &mut HirIdSet) {\n         match ty.kind() {\n             ty::Adt(_, generics) => {\n                 for generic in *generics {"}, {"sha": "772d251b620a80f45a96ef89b3972a2f16572727", "filename": "src/tools/clippy/clippy_lints/src/loops/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Futils.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -334,7 +334,7 @@ pub(super) fn make_iterator_snippet(cx: &LateContext<'_>, arg: &Expr<'_>, applic\n         // (&mut x).into_iter() ==> x.iter_mut()\n         let arg_ty = cx.typeck_results().expr_ty_adjusted(arg);\n         match &arg_ty.kind() {\n-            ty::Ref(_, inner_ty, mutbl) if has_iter_method(cx, inner_ty).is_some() => {\n+            ty::Ref(_, inner_ty, mutbl) if has_iter_method(cx, *inner_ty).is_some() => {\n                 let method_name = match mutbl {\n                     Mutability::Mut => \"iter_mut\",\n                     Mutability::Not => \"iter\","}, {"sha": "e233300e26ab898e94efcdbd13b5bee37b6dbcf7", "filename": "src/tools/clippy/clippy_lints/src/map_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -100,7 +100,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                                     let obj_ty = cx.typeck_results().expr_ty(obj);\n                                     if let ty::Ref(_, ty, mutability) = obj_ty.kind() {\n                                         if matches!(mutability, Mutability::Not) {\n-                                            let copy = is_copy(cx, ty);\n+                                            let copy = is_copy(cx, *ty);\n                                             self.lint_explicit_closure(cx, e.span, args[0].span, copy);\n                                         }\n                                     } else {"}, {"sha": "e195fddefaba32a1010d5727daeaa015fac577ae", "filename": "src/tools/clippy/clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -59,7 +59,7 @@ fn type_needs_ordered_drop_inner<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, see\n         // Check if any component type has any.\n         match ty.kind() {\n             ty::Tuple(_) => ty.tuple_fields().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n-            ty::Array(ty, _) => type_needs_ordered_drop_inner(cx, ty, seen),\n+            ty::Array(ty, _) => type_needs_ordered_drop_inner(cx, *ty, seen),\n             ty::Adt(adt, subs) => adt\n                 .all_fields()\n                 .map(|f| f.ty(cx.tcx, subs))"}, {"sha": "0c4cb45d147cae84cd16e949c6e783e436a842f8", "filename": "src/tools/clippy/clippy_lints/src/matches/single_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -8,7 +8,7 @@ use core::cmp::max;\n use rustc_errors::Applicability;\n use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, Pat, PatKind};\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, Ty, TyS};\n+use rustc_middle::ty::{self, Ty};\n \n use super::{MATCH_BOOL, SINGLE_MATCH, SINGLE_MATCH_ELSE};\n \n@@ -162,10 +162,10 @@ fn check_opt_like<'a>(\n         return;\n     }\n \n-    let in_candidate_enum = |path_info: &(String, &TyS<'_>)| -> bool {\n+    let in_candidate_enum = |path_info: &(String, Ty<'_>)| -> bool {\n         let (path, ty) = path_info;\n         for &(ty_path, pat_path) in candidates {\n-            if path == pat_path && match_type(cx, ty, ty_path) {\n+            if path == pat_path && match_type(cx, *ty, ty_path) {\n                 return true;\n             }\n         }"}, {"sha": "67a585edc2550615aa610d2c958f0a2591582c14", "filename": "src/tools/clippy/clippy_lints/src/methods/cloned_instead_of_copied.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -30,7 +30,7 @@ pub fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span,\n     };\n     match inner_ty.kind() {\n         // &T where T: Copy\n-        ty::Ref(_, ty, _) if is_copy(cx, ty) => {},\n+        ty::Ref(_, ty, _) if is_copy(cx, *ty) => {},\n         _ => return,\n     };\n     span_lint_and_sugg("}, {"sha": "c3cb02329a11c7c3b944ae1be9de30170de4c80d", "filename": "src/tools/clippy/clippy_lints/src/methods/expect_fun_call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -73,7 +73,7 @@ pub(super) fn check<'tcx>(\n                     match cx.qpath_res(p, fun.hir_id) {\n                         hir::def::Res::Def(hir::def::DefKind::Fn | hir::def::DefKind::AssocFn, def_id) => matches!(\n                             cx.tcx.fn_sig(def_id).output().skip_binder().kind(),\n-                            ty::Ref(ty::ReStatic, ..)\n+                            ty::Ref(re, ..) if re.is_static(),\n                         ),\n                         _ => false,\n                     }\n@@ -87,7 +87,7 @@ pub(super) fn check<'tcx>(\n                     .map_or(false, |method_id| {\n                         matches!(\n                             cx.tcx.fn_sig(method_id).output().skip_binder().kind(),\n-                            ty::Ref(ty::ReStatic, ..)\n+                            ty::Ref(re, ..) if re.is_static()\n                         )\n                     })\n             },"}, {"sha": "b93f1399eaeed8e9c13692355049678cf450cb42", "filename": "src/tools/clippy/clippy_lints/src/methods/iter_overeager_cloned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -26,7 +26,7 @@ pub(super) fn check<'tcx>(\n     };\n \n     match inner_ty.kind() {\n-        ty::Ref(_, ty, _) if !is_copy(cx, ty) => {},\n+        ty::Ref(_, ty, _) if !is_copy(cx, *ty) => {},\n         _ => return,\n     };\n "}, {"sha": "68a75667914aa0f8f6ab34c80d408ba3a812741a", "filename": "src/tools/clippy/clippy_lints/src/methods/manual_str_repeat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, LangItem};\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, Ty, TyS};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::sym;\n use std::borrow::Cow;\n \n@@ -37,8 +37,8 @@ fn parse_repeat_arg(cx: &LateContext<'_>, e: &Expr<'_>) -> Option<RepeatKind> {\n     } else {\n         let ty = cx.typeck_results().expr_ty(e);\n         if is_type_diagnostic_item(cx, ty, sym::String)\n-            || (is_type_lang_item(cx, ty, LangItem::OwnedBox) && get_ty_param(ty).map_or(false, TyS::is_str))\n-            || (match_type(cx, ty, &paths::COW) && get_ty_param(ty).map_or(false, TyS::is_str))\n+            || (is_type_lang_item(cx, ty, LangItem::OwnedBox) && get_ty_param(ty).map_or(false, Ty::is_str))\n+            || (match_type(cx, ty, &paths::COW) && get_ty_param(ty).map_or(false, Ty::is_str))\n         {\n             Some(RepeatKind::String)\n         } else {"}, {"sha": "3021a40fae142a03bfd4d3cdea0a83810f1c8387", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -2106,7 +2106,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             let method_sig = cx.tcx.fn_sig(impl_item.def_id);\n             let method_sig = cx.tcx.erase_late_bound_regions(method_sig);\n \n-            let first_arg_ty = &method_sig.inputs().iter().next();\n+            let first_arg_ty = method_sig.inputs().iter().next();\n \n             // check conventions w.r.t. conversion method names and predicates\n             if let Some(first_arg_ty) = first_arg_ty;\n@@ -2119,7 +2119,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                         if name == method_config.method_name &&\n                             sig.decl.inputs.len() == method_config.param_count &&\n                             method_config.output_type.matches(&sig.decl.output) &&\n-                            method_config.self_kind.matches(cx, self_ty, first_arg_ty) &&\n+                            method_config.self_kind.matches(cx, self_ty, *first_arg_ty) &&\n                             fn_header_equals(method_config.fn_header, sig.header) &&\n                             method_config.lifetime_param_cond(impl_item)\n                         {\n@@ -2151,7 +2151,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                         cx,\n                         name,\n                         self_ty,\n-                        first_arg_ty,\n+                        *first_arg_ty,\n                         first_arg.pat.span,\n                         implements_trait,\n                         false"}, {"sha": "7916fb8e3b45ca2739f6efc35a6c079bfd864ed7", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -105,7 +105,7 @@ fn check_addr_of_expr(\n         if is_copy(cx, receiver_ty) || is_cow_into_owned(cx, method_name, method_def_id);\n         if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n         then {\n-            let (target_ty, n_target_refs) = peel_mid_ty_refs(target_ty);\n+            let (target_ty, n_target_refs) = peel_mid_ty_refs(*target_ty);\n             let (receiver_ty, n_receiver_refs) = peel_mid_ty_refs(receiver_ty);\n             if receiver_ty == target_ty && n_target_refs >= n_receiver_refs {\n                 span_lint_and_sugg(\n@@ -228,7 +228,7 @@ fn check_other_call_arg<'tcx>(\n         let fn_sig = cx.tcx.fn_sig(callee_def_id).skip_binder();\n         if let Some(i) = call_args.iter().position(|arg| arg.hir_id == maybe_arg.hir_id);\n         if let Some(input) = fn_sig.inputs().get(i);\n-        let (input, n_refs) = peel_mid_ty_refs(input);\n+        let (input, n_refs) = peel_mid_ty_refs(*input);\n         if let (trait_predicates, projection_predicates) = get_input_traits_and_projections(cx, callee_def_id, input);\n         if let Some(sized_def_id) = cx.tcx.lang_items().sized_trait();\n         if let [trait_predicate] = trait_predicates"}, {"sha": "63c3273bd6816c1e27e237f5a31854967ad7920e", "filename": "src/tools/clippy/clippy_lints/src/methods/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Futils.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -19,7 +19,7 @@ pub(super) fn derefs_to_slice<'tcx>(\n             ty::Adt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n             ty::Adt(..) => is_type_diagnostic_item(cx, ty, sym::Vec),\n             ty::Array(_, size) => size.try_eval_usize(cx.tcx, cx.param_env).is_some(),\n-            ty::Ref(_, inner, _) => may_slice(cx, inner),\n+            ty::Ref(_, inner, _) => may_slice(cx, *inner),\n             _ => false,\n         }\n     }\n@@ -35,7 +35,7 @@ pub(super) fn derefs_to_slice<'tcx>(\n             ty::Slice(_) => Some(expr),\n             ty::Adt(def, _) if def.is_box() && may_slice(cx, ty.boxed_ty()) => Some(expr),\n             ty::Ref(_, inner, _) => {\n-                if may_slice(cx, inner) {\n+                if may_slice(cx, *inner) {\n                     Some(expr)\n                 } else {\n                     None"}, {"sha": "aecfea9c141cfad801b75fedc45472f76d0be272", "filename": "src/tools/clippy/clippy_lints/src/methods/wrong_self_convention.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -2,7 +2,7 @@ use crate::methods::SelfKind;\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::ty::is_copy;\n use rustc_lint::LateContext;\n-use rustc_middle::ty::TyS;\n+use rustc_middle::ty::Ty;\n use rustc_span::source_map::Span;\n use std::fmt;\n \n@@ -41,7 +41,7 @@ impl Convention {\n     fn check<'tcx>(\n         &self,\n         cx: &LateContext<'tcx>,\n-        self_ty: &'tcx TyS<'tcx>,\n+        self_ty: Ty<'tcx>,\n         other: &str,\n         implements_trait: bool,\n         is_trait_item: bool,\n@@ -84,8 +84,8 @@ impl fmt::Display for Convention {\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     item_name: &str,\n-    self_ty: &'tcx TyS<'tcx>,\n-    first_arg_ty: &'tcx TyS<'tcx>,\n+    self_ty: Ty<'tcx>,\n+    first_arg_ty: Ty<'tcx>,\n     first_arg_span: Span,\n     implements_trait: bool,\n     is_trait_item: bool,"}, {"sha": "e9f268da691565c926ce31e9ab98ce5486a5ed08", "filename": "src/tools/clippy/clippy_lints/src/methods/zst_offset.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -9,7 +9,7 @@ use super::ZST_OFFSET;\n pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n     if_chain! {\n         if let ty::RawPtr(ty::TypeAndMut { ty, .. }) = cx.typeck_results().expr_ty(recv).kind();\n-        if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty));\n+        if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(*ty));\n         if layout.is_zst();\n         then {\n             span_lint(cx, ZST_OFFSET, expr.span, \"offset calculation on zero-sized value\");"}, {"sha": "195b2e5c2ee0a0ff722e1f39bbccadc1ed649b17", "filename": "src/tools/clippy/clippy_lints/src/modulo_arithmetic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::sext;\n use if_chain::if_chain;\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use std::fmt::Display;\n \n@@ -77,7 +77,7 @@ fn floating_point_operand_info<T: Display + PartialOrd + From<f32>>(f: &T) -> Op\n     }\n }\n \n-fn might_have_negative_value(t: &ty::TyS<'_>) -> bool {\n+fn might_have_negative_value(t: Ty<'_>) -> bool {\n     t.is_signed() || t.is_floating_point()\n }\n "}, {"sha": "b4e29101b396185c2f70cf6e7f71d18e3d8550fb", "filename": "src/tools/clippy/clippy_lints/src/mut_key.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -113,7 +113,7 @@ fn check_sig<'tcx>(cx: &LateContext<'tcx>, item_hir_id: hir::HirId, decl: &hir::\n     let fn_def_id = cx.tcx.hir().local_def_id(item_hir_id);\n     let fn_sig = cx.tcx.fn_sig(fn_def_id);\n     for (hir_ty, ty) in iter::zip(decl.inputs, fn_sig.inputs().skip_binder()) {\n-        check_ty(cx, hir_ty.span, ty);\n+        check_ty(cx, hir_ty.span, *ty);\n     }\n     check_ty(cx, decl.output.span(), cx.tcx.erase_late_bound_regions(fn_sig.output()));\n }"}, {"sha": "b7f981faa2d42c6491d8745fc9b76168bd4a2fe6", "filename": "src/tools/clippy/clippy_lints/src/mut_mutex_lock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -53,7 +53,7 @@ impl<'tcx> LateLintPass<'tcx> for MutMutexLock {\n             if path.ident.name == sym!(lock);\n             let ty = cx.typeck_results().expr_ty(self_arg);\n             if let ty::Ref(_, inner_ty, Mutability::Mut) = ty.kind();\n-            if is_type_diagnostic_item(cx, inner_ty, sym::Mutex);\n+            if is_type_diagnostic_item(cx, *inner_ty, sym::Mutex);\n             then {\n                 span_lint_and_sugg(\n                     cx,"}, {"sha": "3ba99403f06d005645138f6511fd9e1c3d5418e9", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -136,14 +136,14 @@ fn is_value_unfrozen_raw<'tcx>(\n     result: Result<ConstValue<'tcx>, ErrorHandled>,\n     ty: Ty<'tcx>,\n ) -> bool {\n-    fn inner<'tcx>(cx: &LateContext<'tcx>, val: &'tcx Const<'tcx>) -> bool {\n-        match val.ty.kind() {\n+    fn inner<'tcx>(cx: &LateContext<'tcx>, val: Const<'tcx>) -> bool {\n+        match val.ty().kind() {\n             // the fact that we have to dig into every structs to search enums\n             // leads us to the point checking `UnsafeCell` directly is the only option.\n             ty::Adt(ty_def, ..) if Some(ty_def.did) == cx.tcx.lang_items().unsafe_cell_type() => true,\n             ty::Array(..) | ty::Adt(..) | ty::Tuple(..) => {\n                 let val = cx.tcx.destructure_const(cx.param_env.and(val));\n-                val.fields.iter().any(|field| inner(cx, field))\n+                val.fields.iter().any(|field| inner(cx, *field))\n             },\n             _ => false,\n         }"}, {"sha": "f4de999a9281a3391149ac7fbf1842f9dd45eb09", "filename": "src/tools/clippy/clippy_lints/src/non_send_fields_in_send_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -205,7 +205,7 @@ fn ty_allowed_with_raw_pointer_heuristic<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'t\n         ty::Tuple(_) => ty\n             .tuple_fields()\n             .all(|ty| ty_allowed_with_raw_pointer_heuristic(cx, ty, send_trait)),\n-        ty::Array(ty, _) | ty::Slice(ty) => ty_allowed_with_raw_pointer_heuristic(cx, ty, send_trait),\n+        ty::Array(ty, _) | ty::Slice(ty) => ty_allowed_with_raw_pointer_heuristic(cx, *ty, send_trait),\n         ty::Adt(_, substs) => {\n             if contains_pointer_like(cx, ty) {\n                 // descends only if ADT contains any raw pointers"}, {"sha": "d59249d7f13d32343bcb237ae44bb5afd860e0a1", "filename": "src/tools/clippy/clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -167,8 +167,8 @@ impl<'tcx> PassByRefOrValue {\n \n                     if_chain! {\n                         if !output_lts.contains(input_lt);\n-                        if is_copy(cx, ty);\n-                        if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n+                        if is_copy(cx, *ty);\n+                        if let Some(size) = cx.layout_of(*ty).ok().map(|l| l.size.bytes());\n                         if size <= self.ref_min_size;\n                         if let hir::TyKind::Rptr(_, MutTy { ty: decl_ty, .. }) = input.kind;\n                         then {"}, {"sha": "f3515ea3c2dde19addc39a4519dbbcc8990b5833", "filename": "src/tools/clippy/clippy_lints/src/size_of_in_element_count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsize_of_in_element_count.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -116,7 +116,7 @@ fn get_pointee_ty_and_count_expr<'tcx>(\n         if let ty::RawPtr(TypeAndMut { ty: pointee_ty, .. }) =\n             cx.typeck_results().expr_ty(ptr_self).kind();\n         then {\n-            return Some((pointee_ty, count));\n+            return Some((*pointee_ty, count));\n         }\n     };\n     None"}, {"sha": "f3653199b3758b2ecf4d68ef22832da4c298e8c6", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_ptr_to_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -38,7 +38,7 @@ pub(super) fn check<'tcx>(\n                     let arg = if from_ptr_ty.ty == *to_ref_ty {\n                         arg\n                     } else {\n-                        arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, to_ref_ty)))\n+                        arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, *to_ref_ty)))\n                     };\n \n                     diag.span_suggestion("}, {"sha": "7570bc2a7a8f0d8195e2f8d560f29f36a06c97b3", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_ref_to_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -56,10 +56,10 @@ pub(super) fn check<'tcx>(\n                         \"transmute from a reference to a reference\",\n                         |diag| if let Some(arg) = sugg::Sugg::hir_opt(cx, arg) {\n                             let ty_from_and_mut = ty::TypeAndMut {\n-                                ty: ty_from,\n+                                ty: *ty_from,\n                                 mutbl: *from_mutbl\n                             };\n-                            let ty_to_and_mut = ty::TypeAndMut { ty: ty_to, mutbl: *to_mutbl };\n+                            let ty_to_and_mut = ty::TypeAndMut { ty: *ty_to, mutbl: *to_mutbl };\n                             let sugg_paren = arg\n                                 .as_ty(cx.tcx.mk_ptr(ty_from_and_mut))\n                                 .as_ty(cx.tcx.mk_ptr(ty_to_and_mut));"}, {"sha": "9ed5952a109a5a4cb827fbe87c6342ae093fa981", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -200,27 +200,27 @@ fn reduce_refs<'tcx>(\n     loop {\n         return match (from_ty.kind(), to_ty.kind()) {\n             (\n-                ty::Ref(_, from_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. }),\n-                ty::Ref(_, to_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. }),\n+                &ty::Ref(_, from_sub_ty, _) | &ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. }),\n+                &ty::Ref(_, to_sub_ty, _) | &ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. }),\n             ) => {\n                 from_ty = from_sub_ty;\n                 to_ty = to_sub_ty;\n                 continue;\n             },\n-            (ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. }), _)\n+            (&ty::Ref(_, unsized_ty, _) | &ty::RawPtr(TypeAndMut { ty: unsized_ty, .. }), _)\n                 if !unsized_ty.is_sized(cx.tcx.at(span), cx.param_env) =>\n             {\n                 ReducedTys::FromFatPtr { unsized_ty }\n             },\n-            (_, ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. }))\n+            (_, &ty::Ref(_, unsized_ty, _) | &ty::RawPtr(TypeAndMut { ty: unsized_ty, .. }))\n                 if !unsized_ty.is_sized(cx.tcx.at(span), cx.param_env) =>\n             {\n                 ReducedTys::ToFatPtr { unsized_ty }\n             },\n-            (ty::Ref(_, from_ty, _) | ty::RawPtr(TypeAndMut { ty: from_ty, .. }), _) => {\n+            (&ty::Ref(_, from_ty, _) | &ty::RawPtr(TypeAndMut { ty: from_ty, .. }), _) => {\n                 ReducedTys::FromPtr { from_ty, to_ty }\n             },\n-            (_, ty::Ref(_, to_ty, _) | ty::RawPtr(TypeAndMut { ty: to_ty, .. })) => {\n+            (_, &ty::Ref(_, to_ty, _) | &ty::RawPtr(TypeAndMut { ty: to_ty, .. })) => {\n                 ReducedTys::ToPtr { from_ty, to_ty }\n             },\n             _ => ReducedTys::Other { from_ty, to_ty },\n@@ -247,7 +247,7 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n             },\n             ty::Tuple(args) => {\n                 let mut iter = args.iter().map(GenericArg::expect_ty);\n-                let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, ty)) else {\n+                let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, *ty)) else {\n                     return ReducedTy::OrderedFields(ty);\n                 };\n                 if iter.all(|ty| is_zero_sized_ty(cx, ty)) {\n@@ -265,7 +265,7 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                     .fields\n                     .iter()\n                     .map(|f| cx.tcx.type_of(f.did).subst(cx.tcx, substs));\n-                let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, ty)) else {\n+                let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, *ty)) else {\n                     return ReducedTy::OrderedFields(ty);\n                 };\n                 if iter.all(|ty| is_zero_sized_ty(cx, ty)) {"}, {"sha": "3cc3d40a143dc1c96ca8d535e866968187b0eb48", "filename": "src/tools/clippy/clippy_lints/src/transmute/useless_transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -34,7 +34,7 @@ pub(super) fn check<'tcx>(\n                 |diag| {\n                     if let Some(arg) = sugg::Sugg::hir_opt(cx, arg) {\n                         let rty_and_mut = ty::TypeAndMut {\n-                            ty: rty,\n+                            ty: *rty,\n                             mutbl: *rty_mutbl,\n                         };\n "}, {"sha": "7c39a08a336b6565c984e7cfb37c07d35a94e343", "filename": "src/tools/clippy/clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -84,7 +84,8 @@ fn get_args_to_check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Ve\n         let partial_ord_preds =\n             get_trait_predicates_for_trait_id(cx, generics, cx.tcx.lang_items().partial_ord_trait());\n         // Trying to call erase_late_bound_regions on fn_sig.inputs() gives the following error\n-        // The trait `rustc::ty::TypeFoldable<'_>` is not implemented for `&[&rustc::ty::TyS<'_>]`\n+        // The trait `rustc::ty::TypeFoldable<'_>` is not implemented for\n+        // `&[rustc_middle::ty::Ty<'_>]`\n         let inputs_output = cx.tcx.erase_late_bound_regions(fn_sig.inputs_and_output());\n         inputs_output\n             .iter()"}, {"sha": "d40583c47dd7074a8c069c0656652fdcf4652509", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -567,11 +567,11 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n     }\n }\n \n-pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n+pub fn miri_to_const(result: ty::Const<'_>) -> Option<Constant> {\n     use rustc_middle::mir::interpret::ConstValue;\n-    match result.val {\n+    match result.val() {\n         ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int(int))) => {\n-            match result.ty.kind() {\n+            match result.ty().kind() {\n                 ty::Bool => Some(Constant::Bool(int == ScalarInt::TRUE)),\n                 ty::Uint(_) | ty::Int(_) => Some(Constant::Int(int.assert_bits(int.size()))),\n                 ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n@@ -590,7 +590,7 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n                 _ => None,\n             }\n         },\n-        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty.kind() {\n+        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty().kind() {\n             ty::Ref(_, tam, _) => match tam.kind() {\n                 ty::Str => String::from_utf8(\n                     data.inspect_with_uninit_and_ptr_outside_interpreter(start..end)\n@@ -602,9 +602,9 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n             },\n             _ => None,\n         },\n-        ty::ConstKind::Value(ConstValue::ByRef { alloc, offset: _ }) => match result.ty.kind() {\n+        ty::ConstKind::Value(ConstValue::ByRef { alloc, offset: _ }) => match result.ty().kind() {\n             ty::Array(sub_type, len) => match sub_type.kind() {\n-                ty::Float(FloatTy::F32) => match miri_to_const(len) {\n+                ty::Float(FloatTy::F32) => match miri_to_const(*len) {\n                     Some(Constant::Int(len)) => alloc\n                         .inspect_with_uninit_and_ptr_outside_interpreter(0..(4 * len as usize))\n                         .to_owned()\n@@ -618,7 +618,7 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n                         .map(Constant::Vec),\n                     _ => None,\n                 },\n-                ty::Float(FloatTy::F64) => match miri_to_const(len) {\n+                ty::Float(FloatTy::F64) => match miri_to_const(*len) {\n                     Some(Constant::Int(len)) => alloc\n                         .inspect_with_uninit_and_ptr_outside_interpreter(0..(8 * len as usize))\n                         .to_owned()"}, {"sha": "4bb401273c4002b535178f015c28f4540d13cef6", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -1911,10 +1911,10 @@ pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<S\n     let expr_type = cx.typeck_results().expr_ty_adjusted(expr);\n     let expr_kind = expr_type.kind();\n     let is_primitive = match expr_kind {\n-        rustc_ty::Slice(element_type) => is_recursively_primitive_type(element_type),\n+        rustc_ty::Slice(element_type) => is_recursively_primitive_type(*element_type),\n         rustc_ty::Ref(_, inner_ty, _) if matches!(inner_ty.kind(), &rustc_ty::Slice(_)) => {\n             if let rustc_ty::Slice(element_type) = inner_ty.kind() {\n-                is_recursively_primitive_type(element_type)\n+                is_recursively_primitive_type(*element_type)\n             } else {\n                 unreachable!()\n             }"}, {"sha": "c039fec955db9d2641fc86e43ce772da69f04021", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -149,7 +149,7 @@ fn check_rvalue<'tcx>(\n         Rvalue::Cast(CastKind::Misc, operand, cast_ty) => {\n             use rustc_middle::ty::cast::CastTy;\n             let cast_in = CastTy::from_ty(operand.ty(body, tcx)).expect(\"bad input type for cast\");\n-            let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+            let cast_out = CastTy::from_ty(*cast_ty).expect(\"bad output type for cast\");\n             match (cast_in, cast_out) {\n                 (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) => {\n                     Err((span, \"casting pointers to ints is unstable in const fn\".into()))"}, {"sha": "b44899e6bd587235a64fbbb5fc2f4e066ec5759e", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -103,7 +103,7 @@ pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<\n     ];\n \n     let ty_to_check = match probably_ref_ty.kind() {\n-        ty::Ref(_, ty_to_check, _) => ty_to_check,\n+        ty::Ref(_, ty_to_check, _) => *ty_to_check,\n         _ => probably_ref_ty,\n     };\n \n@@ -209,7 +209,7 @@ fn is_normalizable_helper<'tcx>(\n     ty: Ty<'tcx>,\n     cache: &mut FxHashMap<Ty<'tcx>, bool>,\n ) -> bool {\n-    if let Some(&cached_result) = cache.get(ty) {\n+    if let Some(&cached_result) = cache.get(&ty) {\n         return cached_result;\n     }\n     // prevent recursive loops, false-negative is better than endless loop leading to stack overflow\n@@ -252,7 +252,7 @@ pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n     match ty.kind() {\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => true,\n         ty::Ref(_, inner, _) if *inner.kind() == ty::Str => true,\n-        ty::Array(inner_type, _) | ty::Slice(inner_type) => is_recursively_primitive_type(inner_type),\n+        ty::Array(inner_type, _) | ty::Slice(inner_type) => is_recursively_primitive_type(*inner_type),\n         ty::Tuple(inner_types) => inner_types.types().all(is_recursively_primitive_type),\n         _ => false,\n     }\n@@ -318,7 +318,7 @@ pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     fn peel(ty: Ty<'_>, count: usize) -> (Ty<'_>, usize) {\n         if let ty::Ref(_, ty, _) = ty.kind() {\n-            peel(ty, count + 1)\n+            peel(*ty, count + 1)\n         } else {\n             (ty, count)\n         }\n@@ -331,8 +331,8 @@ pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n pub fn peel_mid_ty_refs_is_mutable(ty: Ty<'_>) -> (Ty<'_>, usize, Mutability) {\n     fn f(ty: Ty<'_>, count: usize, mutability: Mutability) -> (Ty<'_>, usize, Mutability) {\n         match ty.kind() {\n-            ty::Ref(_, ty, Mutability::Mut) => f(ty, count + 1, mutability),\n-            ty::Ref(_, ty, Mutability::Not) => f(ty, count + 1, Mutability::Not),\n+            ty::Ref(_, ty, Mutability::Mut) => f(*ty, count + 1, mutability),\n+            ty::Ref(_, ty, Mutability::Not) => f(*ty, count + 1, Mutability::Not),\n             _ => (ty, count, mutability),\n         }\n     }\n@@ -360,7 +360,7 @@ pub fn walk_ptrs_hir_ty<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> &'tcx hir::Ty<'tcx> {\n pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     fn inner(ty: Ty<'_>, depth: usize) -> (Ty<'_>, usize) {\n         match ty.kind() {\n-            ty::Ref(_, ty, _) => inner(ty, depth + 1),\n+            ty::Ref(_, ty, _) => inner(*ty, depth + 1),\n             _ => (ty, depth),\n         }\n     }\n@@ -394,7 +394,7 @@ pub fn same_type_and_consts<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n /// Checks if a given type looks safe to be uninitialized.\n pub fn is_uninit_value_valid_for_ty(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n     match ty.kind() {\n-        ty::Array(component, _) => is_uninit_value_valid_for_ty(cx, component),\n+        ty::Array(component, _) => is_uninit_value_valid_for_ty(cx, *component),\n         ty::Tuple(types) => types.types().all(|ty| is_uninit_value_valid_for_ty(cx, ty)),\n         ty::Adt(adt, _) => cx.tcx.lang_items().maybe_uninit() == Some(adt.did),\n         _ => false,"}, {"sha": "828bf4cbef9481526edc8840762be8421397dbe7", "filename": "src/tools/clippy/doc/common_tools_writing_lints.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/55697574915ca58c3fcd7b1c854c1c93e002dc85/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md?ref=55697574915ca58c3fcd7b1c854c1c93e002dc85", "patch": "@@ -26,7 +26,7 @@ Sometimes you may want to retrieve the type `Ty` of an expression `Expr`, for ex\n - does it implement a trait?\n \n This operation is performed using the [`expr_ty()`][expr_ty] method from the [`TypeckResults`][TypeckResults] struct,\n-that gives you access to the underlying structure [`TyS`][TyS].\n+that gives you access to the underlying structure [`Ty`][Ty].\n \n Example of use:\n ```rust\n@@ -259,7 +259,7 @@ expression with a different context from `a`.\n    assert_eq!(x_is_some_span.ctxt(), x_unwrap_span.ctxt());\n    ```\n \n-[TyS]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyS.html\n+[Ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html\n [TyKind]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html\n [TypeckResults]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html\n [expr_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html#method.expr_ty"}]}