{"sha": "cc6d761a99ab3b7e28ed13ca3839358f3341da4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNmQ3NjFhOTlhYjNiN2UyOGVkMTNjYTM4MzkzNThmMzM0MWRhNGQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-13T12:49:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-13T12:49:37Z"}, "message": "Merge #9246\n\n9246: internal: unified missing fields diagnostic r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "d9d180d516ddbafc7eb950f401e9a8ab3f1e88fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9d180d516ddbafc7eb950f401e9a8ab3f1e88fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc6d761a99ab3b7e28ed13ca3839358f3341da4d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgxf7hCRBK7hj4Ov3rIwAAzNoIAFEX1M6TPeGAmvtfhWyPWeS2\niUJGeJfZdseqIxYw/N7xTqucPkRvYwak8ZHCdZXzxmDRgP9VCfoHCwuzVCpXVG6Y\npUEGs0N4+N+IK9QQOuPti4ghfppwXmTsXaEpzgo1UftBCy19r7fj85U50wVzYhz4\nPzcvrjSffeDbaRkPGx9QVrYAESjaC1p+5i4xg0gfwUx+0EOanL53YearYNYz8Kbp\n3QwIaWlW2pH/3c0oOSHN8ue0KaZHubPhIAQQHj0cY73ZnW1Azd890cOvc6MUeIU5\n05hd35jOm3Wtti8fbS4sHTuEZgngPlXaAXPz14FV7Dc1OxWRsGRYcTPFRs70NJ8=\n=eXI0\n-----END PGP SIGNATURE-----\n", "payload": "tree d9d180d516ddbafc7eb950f401e9a8ab3f1e88fe\nparent 3f53a5dd724cbc7aa20280cddba44c7d2c0c8a6d\nparent 6383252cc2770545505d40217732f14e93a396c4\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623588577 +0000\ncommitter GitHub <noreply@github.com> 1623588577 +0000\n\nMerge #9246\n\n9246: internal: unified missing fields diagnostic r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc6d761a99ab3b7e28ed13ca3839358f3341da4d", "html_url": "https://github.com/rust-lang/rust/commit/cc6d761a99ab3b7e28ed13ca3839358f3341da4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc6d761a99ab3b7e28ed13ca3839358f3341da4d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f53a5dd724cbc7aa20280cddba44c7d2c0c8a6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f53a5dd724cbc7aa20280cddba44c7d2c0c8a6d", "html_url": "https://github.com/rust-lang/rust/commit/3f53a5dd724cbc7aa20280cddba44c7d2c0c8a6d"}, {"sha": "6383252cc2770545505d40217732f14e93a396c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/6383252cc2770545505d40217732f14e93a396c4", "html_url": "https://github.com/rust-lang/rust/commit/6383252cc2770545505d40217732f14e93a396c4"}], "stats": {"total": 743, "additions": 342, "deletions": 401}, "files": [{"sha": "158626dc007f5ca849e0e381d0c9866de03e0558", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 91, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/cc6d761a99ab3b7e28ed13ca3839358f3341da4d/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc6d761a99ab3b7e28ed13ca3839358f3341da4d/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=cc6d761a99ab3b7e28ed13ca3839358f3341da4d", "patch": "@@ -6,6 +6,7 @@\n use std::any::Any;\n \n use cfg::{CfgExpr, CfgOptions, DnfExpr};\n+use either::Either;\n use hir_def::path::ModPath;\n use hir_expand::{name::Name, HirFileId, InFile};\n use stdx::format_to;\n@@ -16,7 +17,7 @@ pub use crate::diagnostics_sink::{\n };\n \n macro_rules! diagnostics {\n-    ($($diag:ident)*) => {\n+    ($($diag:ident),*) => {\n         pub enum AnyDiagnostic {$(\n             $diag(Box<$diag>),\n         )*}\n@@ -31,7 +32,7 @@ macro_rules! diagnostics {\n     };\n }\n \n-diagnostics![UnresolvedModule];\n+diagnostics![UnresolvedModule, MissingFields];\n \n #[derive(Debug)]\n pub struct UnresolvedModule {\n@@ -321,102 +322,14 @@ impl Diagnostic for MissingUnsafe {\n     }\n }\n \n-// Diagnostic: missing-structure-fields\n-//\n-// This diagnostic is triggered if record lacks some fields that exist in the corresponding structure.\n-//\n-// Example:\n-//\n-// ```rust\n-// struct A { a: u8, b: u8 }\n-//\n-// let a = A { a: 10 };\n-// ```\n #[derive(Debug)]\n pub struct MissingFields {\n     pub file: HirFileId,\n-    pub field_list_parent: AstPtr<ast::RecordExpr>,\n-    pub field_list_parent_path: Option<AstPtr<ast::Path>>,\n-    pub missed_fields: Vec<Name>,\n-}\n-\n-impl Diagnostic for MissingFields {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"missing-structure-fields\")\n-    }\n-    fn message(&self) -> String {\n-        let mut buf = String::from(\"Missing structure fields:\\n\");\n-        for field in &self.missed_fields {\n-            format_to!(buf, \"- {}\\n\", field);\n-        }\n-        buf\n-    }\n-\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile {\n-            file_id: self.file,\n-            value: self\n-                .field_list_parent_path\n-                .clone()\n-                .map(SyntaxNodePtr::from)\n-                .unwrap_or_else(|| self.field_list_parent.clone().into()),\n-        }\n-    }\n-\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n-// Diagnostic: missing-pat-fields\n-//\n-// This diagnostic is triggered if pattern lacks some fields that exist in the corresponding structure.\n-//\n-// Example:\n-//\n-// ```rust\n-// struct A { a: u8, b: u8 }\n-//\n-// let a = A { a: 10, b: 20 };\n-//\n-// if let A { a } = a {\n-//     // ...\n-// }\n-// ```\n-#[derive(Debug)]\n-pub struct MissingPatFields {\n-    pub file: HirFileId,\n-    pub field_list_parent: AstPtr<ast::RecordPat>,\n+    pub field_list_parent: Either<AstPtr<ast::RecordExpr>, AstPtr<ast::RecordPat>>,\n     pub field_list_parent_path: Option<AstPtr<ast::Path>>,\n     pub missed_fields: Vec<Name>,\n }\n \n-impl Diagnostic for MissingPatFields {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"missing-pat-fields\")\n-    }\n-    fn message(&self) -> String {\n-        let mut buf = String::from(\"Missing structure fields:\\n\");\n-        for field in &self.missed_fields {\n-            format_to!(buf, \"- {}\\n\", field);\n-        }\n-        buf\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile {\n-            file_id: self.file,\n-            value: self\n-                .field_list_parent_path\n-                .clone()\n-                .map(SyntaxNodePtr::from)\n-                .unwrap_or_else(|| self.field_list_parent.clone().into()),\n-        }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n // Diagnostic: replace-filter-map-next-with-find-map\n //\n // This diagnostic is triggered when `.filter_map(..).next()` is used, rather than the more concise `.find_map(..)`."}, {"sha": "373134f62652477319e9df363a4ed98e929f4e61", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 68, "deletions": 62, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/cc6d761a99ab3b7e28ed13ca3839358f3341da4d/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc6d761a99ab3b7e28ed13ca3839358f3341da4d/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=cc6d761a99ab3b7e28ed13ca3839358f3341da4d", "patch": "@@ -88,9 +88,9 @@ pub use crate::{\n     diagnostics::{\n         AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, InternalBailedOut, MacroError,\n         MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkOrSomeInTailExpr,\n-        MissingPatFields, MissingUnsafe, NoSuchField, RemoveThisSemicolon,\n-        ReplaceFilterMapNextWithFindMap, UnimplementedBuiltinMacro, UnresolvedExternCrate,\n-        UnresolvedImport, UnresolvedMacroCall, UnresolvedModule, UnresolvedProcMacro,\n+        MissingUnsafe, NoSuchField, RemoveThisSemicolon, ReplaceFilterMapNextWithFindMap,\n+        UnimplementedBuiltinMacro, UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall,\n+        UnresolvedModule, UnresolvedProcMacro,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope},\n@@ -609,23 +609,21 @@ impl Module {\n         }\n         for decl in self.declarations(db) {\n             match decl {\n-                crate::ModuleDef::Function(f) => f.diagnostics(db, sink, internal_diagnostics),\n-                crate::ModuleDef::Module(m) => {\n+                ModuleDef::Function(f) => acc.extend(f.diagnostics(db, sink, internal_diagnostics)),\n+                ModuleDef::Module(m) => {\n                     // Only add diagnostics from inline modules\n                     if def_map[m.id.local_id].origin.is_inline() {\n                         acc.extend(m.diagnostics(db, sink, internal_diagnostics))\n                     }\n                 }\n-                _ => {\n-                    decl.diagnostics(db, sink);\n-                }\n+                _ => decl.diagnostics(db, sink),\n             }\n         }\n \n         for impl_def in self.impl_defs(db) {\n             for item in impl_def.items(db) {\n                 if let AssocItem::Function(f) = item {\n-                    f.diagnostics(db, sink, internal_diagnostics);\n+                    acc.extend(f.diagnostics(db, sink, internal_diagnostics));\n                 }\n             }\n         }\n@@ -1033,7 +1031,8 @@ impl Function {\n         db: &dyn HirDatabase,\n         sink: &mut DiagnosticSink,\n         internal_diagnostics: bool,\n-    ) {\n+    ) -> Vec<AnyDiagnostic> {\n+        let mut acc: Vec<AnyDiagnostic> = Vec::new();\n         let krate = self.module(db).id.krate();\n \n         let source_map = db.body_with_source_map(self.id.into()).1;\n@@ -1099,64 +1098,70 @@ impl Function {\n             BodyValidationDiagnostic::collect(db, self.id.into(), internal_diagnostics)\n         {\n             match diagnostic {\n-                BodyValidationDiagnostic::RecordLiteralMissingFields {\n-                    record_expr,\n+                BodyValidationDiagnostic::RecordMissingFields {\n+                    record,\n                     variant,\n                     missed_fields,\n-                } => match source_map.expr_syntax(record_expr) {\n-                    Ok(source_ptr) => {\n-                        let root = source_ptr.file_syntax(db.upcast());\n-                        if let ast::Expr::RecordExpr(record_expr) = &source_ptr.value.to_node(&root)\n-                        {\n-                            if let Some(_) = record_expr.record_expr_field_list() {\n-                                let variant_data = variant.variant_data(db.upcast());\n-                                let missed_fields = missed_fields\n-                                    .into_iter()\n-                                    .map(|idx| variant_data.fields()[idx].name.clone())\n-                                    .collect();\n-                                sink.push(MissingFields {\n-                                    file: source_ptr.file_id,\n-                                    field_list_parent: AstPtr::new(record_expr),\n-                                    field_list_parent_path: record_expr\n-                                        .path()\n-                                        .map(|path| AstPtr::new(&path)),\n-                                    missed_fields,\n-                                })\n+                } => {\n+                    let variant_data = variant.variant_data(db.upcast());\n+                    let missed_fields = missed_fields\n+                        .into_iter()\n+                        .map(|idx| variant_data.fields()[idx].name.clone())\n+                        .collect();\n+\n+                    match record {\n+                        Either::Left(record_expr) => match source_map.expr_syntax(record_expr) {\n+                            Ok(source_ptr) => {\n+                                let root = source_ptr.file_syntax(db.upcast());\n+                                if let ast::Expr::RecordExpr(record_expr) =\n+                                    &source_ptr.value.to_node(&root)\n+                                {\n+                                    if let Some(_) = record_expr.record_expr_field_list() {\n+                                        acc.push(\n+                                            MissingFields {\n+                                                file: source_ptr.file_id,\n+                                                field_list_parent: Either::Left(AstPtr::new(\n+                                                    record_expr,\n+                                                )),\n+                                                field_list_parent_path: record_expr\n+                                                    .path()\n+                                                    .map(|path| AstPtr::new(&path)),\n+                                                missed_fields,\n+                                            }\n+                                            .into(),\n+                                        )\n+                                    }\n+                                }\n                             }\n-                        }\n-                    }\n-                    Err(SyntheticSyntax) => (),\n-                },\n-                BodyValidationDiagnostic::RecordPatMissingFields {\n-                    record_pat,\n-                    variant,\n-                    missed_fields,\n-                } => match source_map.pat_syntax(record_pat) {\n-                    Ok(source_ptr) => {\n-                        if let Some(expr) = source_ptr.value.as_ref().left() {\n-                            let root = source_ptr.file_syntax(db.upcast());\n-                            if let ast::Pat::RecordPat(record_pat) = expr.to_node(&root) {\n-                                if let Some(_) = record_pat.record_pat_field_list() {\n-                                    let variant_data = variant.variant_data(db.upcast());\n-                                    let missed_fields = missed_fields\n-                                        .into_iter()\n-                                        .map(|idx| variant_data.fields()[idx].name.clone())\n-                                        .collect();\n-                                    sink.push(MissingPatFields {\n-                                        file: source_ptr.file_id,\n-                                        field_list_parent: AstPtr::new(&record_pat),\n-                                        field_list_parent_path: record_pat\n-                                            .path()\n-                                            .map(|path| AstPtr::new(&path)),\n-                                        missed_fields,\n-                                    })\n+                            Err(SyntheticSyntax) => (),\n+                        },\n+                        Either::Right(record_pat) => match source_map.pat_syntax(record_pat) {\n+                            Ok(source_ptr) => {\n+                                if let Some(expr) = source_ptr.value.as_ref().left() {\n+                                    let root = source_ptr.file_syntax(db.upcast());\n+                                    if let ast::Pat::RecordPat(record_pat) = expr.to_node(&root) {\n+                                        if let Some(_) = record_pat.record_pat_field_list() {\n+                                            acc.push(\n+                                                MissingFields {\n+                                                    file: source_ptr.file_id,\n+                                                    field_list_parent: Either::Right(AstPtr::new(\n+                                                        &record_pat,\n+                                                    )),\n+                                                    field_list_parent_path: record_pat\n+                                                        .path()\n+                                                        .map(|path| AstPtr::new(&path)),\n+                                                    missed_fields,\n+                                                }\n+                                                .into(),\n+                                            )\n+                                        }\n+                                    }\n                                 }\n                             }\n-                        }\n+                            Err(SyntheticSyntax) => (),\n+                        },\n                     }\n-                    Err(SyntheticSyntax) => (),\n-                },\n-\n+                }\n                 BodyValidationDiagnostic::ReplaceFilterMapNextWithFindMap { method_call_expr } => {\n                     if let Ok(next_source_ptr) = source_map.expr_syntax(method_call_expr) {\n                         sink.push(ReplaceFilterMapNextWithFindMap {\n@@ -1234,6 +1239,7 @@ impl Function {\n         for diag in hir_ty::diagnostics::validate_module_item(db, krate, self.id.into()) {\n             sink.push(diag)\n         }\n+        acc\n     }\n \n     /// Whether this function declaration has a definition."}, {"sha": "2a211fd8e67b9a25078fea98f1a81c3fea8adf28", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cc6d761a99ab3b7e28ed13ca3839358f3341da4d/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc6d761a99ab3b7e28ed13ca3839358f3341da4d/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=cc6d761a99ab3b7e28ed13ca3839358f3341da4d", "patch": "@@ -8,6 +8,7 @@ use hir_def::{\n     expr::Statement, path::path, resolver::HasResolver, AssocItemId, DefWithBodyId, HasModule,\n };\n use hir_expand::name;\n+use itertools::Either;\n use rustc_hash::FxHashSet;\n \n use crate::{\n@@ -26,13 +27,8 @@ pub(crate) use hir_def::{\n };\n \n pub enum BodyValidationDiagnostic {\n-    RecordLiteralMissingFields {\n-        record_expr: ExprId,\n-        variant: VariantId,\n-        missed_fields: Vec<LocalFieldId>,\n-    },\n-    RecordPatMissingFields {\n-        record_pat: PatId,\n+    RecordMissingFields {\n+        record: Either<ExprId, PatId>,\n         variant: VariantId,\n         missed_fields: Vec<LocalFieldId>,\n     },\n@@ -95,8 +91,8 @@ impl ExprValidator {\n             if let Some((variant, missed_fields, true)) =\n                 record_literal_missing_fields(db, &self.infer, id, expr)\n             {\n-                self.diagnostics.push(BodyValidationDiagnostic::RecordLiteralMissingFields {\n-                    record_expr: id,\n+                self.diagnostics.push(BodyValidationDiagnostic::RecordMissingFields {\n+                    record: Either::Left(id),\n                     variant,\n                     missed_fields,\n                 });\n@@ -116,8 +112,8 @@ impl ExprValidator {\n             if let Some((variant, missed_fields, true)) =\n                 record_pattern_missing_fields(db, &self.infer, id, pat)\n             {\n-                self.diagnostics.push(BodyValidationDiagnostic::RecordPatMissingFields {\n-                    record_pat: id,\n+                self.diagnostics.push(BodyValidationDiagnostic::RecordMissingFields {\n+                    record: Either::Right(id),\n                     variant,\n                     missed_fields,\n                 });"}, {"sha": "3307e240b7391abe2da0e0a93e5efa646dc2c482", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cc6d761a99ab3b7e28ed13ca3839358f3341da4d/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc6d761a99ab3b7e28ed13ca3839358f3341da4d/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=cc6d761a99ab3b7e28ed13ca3839358f3341da4d", "patch": "@@ -5,6 +5,7 @@\n //! original files. So we need to map the ranges.\n \n mod unresolved_module;\n+mod missing_fields;\n \n mod fixes;\n mod field_shorthand;\n@@ -123,9 +124,6 @@ pub(crate) fn diagnostics(\n     }\n     let res = RefCell::new(res);\n     let sink_builder = DiagnosticSinkBuilder::new()\n-        .on::<hir::diagnostics::MissingFields, _>(|d| {\n-            res.borrow_mut().push(diagnostic_with_fix(d, &sema, resolve));\n-        })\n         .on::<hir::diagnostics::MissingOkOrSomeInTailExpr, _>(|d| {\n             res.borrow_mut().push(diagnostic_with_fix(d, &sema, resolve));\n         })\n@@ -232,7 +230,8 @@ pub(crate) fn diagnostics(\n     let ctx = DiagnosticsContext { config, sema, resolve };\n     for diag in diags {\n         let d = match diag {\n-            AnyDiagnostic::UnresolvedModule(d) => unresolved_module::render(&ctx, &d),\n+            AnyDiagnostic::UnresolvedModule(d) => unresolved_module::unresolved_module(&ctx, &d),\n+            AnyDiagnostic::MissingFields(d) => missing_fields::missing_fields(&ctx, &d),\n         };\n         if let Some(code) = d.code {\n             if ctx.config.disabled.contains(code.as_str()) {\n@@ -1056,20 +1055,6 @@ fn main() {\n         ));\n     }\n \n-    #[test]\n-    fn missing_record_pat_field_diagnostic() {\n-        check_diagnostics(\n-            r#\"\n-struct S { foo: i32, bar: () }\n-fn baz(s: S) {\n-    let S { foo: _ } = s;\n-      //^ Missing structure fields:\n-      //| - bar\n-}\n-\"#,\n-        );\n-    }\n-\n     #[test]\n     fn missing_record_pat_field_no_diagnostic_if_not_exhaustive() {\n         check_diagnostics("}, {"sha": "a2e792b3b61a43997906e2fede40dcf8aec551d2", "filename": "crates/ide/src/diagnostics/fixes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc6d761a99ab3b7e28ed13ca3839358f3341da4d/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc6d761a99ab3b7e28ed13ca3839358f3341da4d/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs?ref=cc6d761a99ab3b7e28ed13ca3839358f3341da4d", "patch": "@@ -2,7 +2,6 @@\n //! The same module also has all curret custom fixes for the diagnostics implemented.\n mod change_case;\n mod create_field;\n-mod fill_missing_fields;\n mod remove_semicolon;\n mod replace_with_find_map;\n mod wrap_tail_expr;"}, {"sha": "c76f6008a3096257b04d2d14d5e009623812276c", "filename": "crates/ide/src/diagnostics/fixes/fill_missing_fields.rs", "status": "removed", "additions": 0, "deletions": 217, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/3f53a5dd724cbc7aa20280cddba44c7d2c0c8a6d/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Ffill_missing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f53a5dd724cbc7aa20280cddba44c7d2c0c8a6d/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Ffill_missing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Ffill_missing_fields.rs?ref=3f53a5dd724cbc7aa20280cddba44c7d2c0c8a6d", "patch": "@@ -1,217 +0,0 @@\n-use hir::{db::AstDatabase, diagnostics::MissingFields, Semantics};\n-use ide_assists::AssistResolveStrategy;\n-use ide_db::{source_change::SourceChange, RootDatabase};\n-use syntax::{algo, ast::make, AstNode};\n-use text_edit::TextEdit;\n-\n-use crate::{\n-    diagnostics::{fix, fixes::DiagnosticWithFixes},\n-    Assist,\n-};\n-\n-impl DiagnosticWithFixes for MissingFields {\n-    fn fixes(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        _resolve: &AssistResolveStrategy,\n-    ) -> Option<Vec<Assist>> {\n-        // Note that although we could add a diagnostics to\n-        // fill the missing tuple field, e.g :\n-        // `struct A(usize);`\n-        // `let a = A { 0: () }`\n-        // but it is uncommon usage and it should not be encouraged.\n-        if self.missed_fields.iter().any(|it| it.as_tuple_index().is_some()) {\n-            return None;\n-        }\n-\n-        let root = sema.db.parse_or_expand(self.file)?;\n-        let field_list_parent = self.field_list_parent.to_node(&root);\n-        let old_field_list = field_list_parent.record_expr_field_list()?;\n-        let new_field_list = old_field_list.clone_for_update();\n-        for f in self.missed_fields.iter() {\n-            let field =\n-                make::record_expr_field(make::name_ref(&f.to_string()), Some(make::expr_unit()))\n-                    .clone_for_update();\n-            new_field_list.add_field(field);\n-        }\n-\n-        let edit = {\n-            let mut builder = TextEdit::builder();\n-            algo::diff(old_field_list.syntax(), new_field_list.syntax())\n-                .into_text_edit(&mut builder);\n-            builder.finish()\n-        };\n-        Some(vec![fix(\n-            \"fill_missing_fields\",\n-            \"Fill struct fields\",\n-            SourceChange::from_text_edit(self.file.original_file(sema.db), edit),\n-            sema.original_range(field_list_parent.syntax()).range,\n-        )])\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::diagnostics::tests::{check_fix, check_no_diagnostics};\n-\n-    #[test]\n-    fn test_fill_struct_fields_empty() {\n-        check_fix(\n-            r#\"\n-struct TestStruct { one: i32, two: i64 }\n-\n-fn test_fn() {\n-    let s = TestStruct {$0};\n-}\n-\"#,\n-            r#\"\n-struct TestStruct { one: i32, two: i64 }\n-\n-fn test_fn() {\n-    let s = TestStruct { one: (), two: () };\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fill_struct_fields_self() {\n-        check_fix(\n-            r#\"\n-struct TestStruct { one: i32 }\n-\n-impl TestStruct {\n-    fn test_fn() { let s = Self {$0}; }\n-}\n-\"#,\n-            r#\"\n-struct TestStruct { one: i32 }\n-\n-impl TestStruct {\n-    fn test_fn() { let s = Self { one: () }; }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fill_struct_fields_enum() {\n-        check_fix(\n-            r#\"\n-enum Expr {\n-    Bin { lhs: Box<Expr>, rhs: Box<Expr> }\n-}\n-\n-impl Expr {\n-    fn new_bin(lhs: Box<Expr>, rhs: Box<Expr>) -> Expr {\n-        Expr::Bin {$0 }\n-    }\n-}\n-\"#,\n-            r#\"\n-enum Expr {\n-    Bin { lhs: Box<Expr>, rhs: Box<Expr> }\n-}\n-\n-impl Expr {\n-    fn new_bin(lhs: Box<Expr>, rhs: Box<Expr>) -> Expr {\n-        Expr::Bin { lhs: (), rhs: () }\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fill_struct_fields_partial() {\n-        check_fix(\n-            r#\"\n-struct TestStruct { one: i32, two: i64 }\n-\n-fn test_fn() {\n-    let s = TestStruct{ two: 2$0 };\n-}\n-\"#,\n-            r\"\n-struct TestStruct { one: i32, two: i64 }\n-\n-fn test_fn() {\n-    let s = TestStruct{ two: 2, one: () };\n-}\n-\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fill_struct_fields_raw_ident() {\n-        check_fix(\n-            r#\"\n-struct TestStruct { r#type: u8 }\n-\n-fn test_fn() {\n-    TestStruct { $0 };\n-}\n-\"#,\n-            r\"\n-struct TestStruct { r#type: u8 }\n-\n-fn test_fn() {\n-    TestStruct { r#type: ()  };\n-}\n-\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fill_struct_fields_no_diagnostic() {\n-        check_no_diagnostics(\n-            r#\"\n-struct TestStruct { one: i32, two: i64 }\n-\n-fn test_fn() {\n-    let one = 1;\n-    let s = TestStruct{ one, two: 2 };\n-}\n-        \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fill_struct_fields_no_diagnostic_on_spread() {\n-        check_no_diagnostics(\n-            r#\"\n-struct TestStruct { one: i32, two: i64 }\n-\n-fn test_fn() {\n-    let one = 1;\n-    let s = TestStruct{ ..a };\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fill_struct_fields_blank_line() {\n-        check_fix(\n-            r#\"\n-struct S { a: (), b: () }\n-\n-fn f() {\n-    S {\n-        $0\n-    };\n-}\n-\"#,\n-            r#\"\n-struct S { a: (), b: () }\n-\n-fn f() {\n-    S {\n-        a: (),\n-        b: (),\n-    };\n-}\n-\"#,\n-        );\n-    }\n-}"}, {"sha": "66575f713cf4cada5ce1ebcf63d67fd3c9d4715d", "filename": "crates/ide/src/diagnostics/missing_fields.rs", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/cc6d761a99ab3b7e28ed13ca3839358f3341da4d/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc6d761a99ab3b7e28ed13ca3839358f3341da4d/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_fields.rs?ref=cc6d761a99ab3b7e28ed13ca3839358f3341da4d", "patch": "@@ -0,0 +1,256 @@\n+use either::Either;\n+use hir::{db::AstDatabase, InFile};\n+use ide_assists::Assist;\n+use ide_db::source_change::SourceChange;\n+use stdx::format_to;\n+use syntax::{algo, ast::make, AstNode, SyntaxNodePtr};\n+use text_edit::TextEdit;\n+\n+use crate::diagnostics::{fix, Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: missing-fields\n+//\n+// This diagnostic is triggered if record lacks some fields that exist in the corresponding structure.\n+//\n+// Example:\n+//\n+// ```rust\n+// struct A { a: u8, b: u8 }\n+//\n+// let a = A { a: 10 };\n+// ```\n+pub(super) fn missing_fields(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Diagnostic {\n+    let mut message = String::from(\"Missing structure fields:\\n\");\n+    for field in &d.missed_fields {\n+        format_to!(message, \"- {}\\n\", field);\n+    }\n+\n+    let ptr = InFile::new(\n+        d.file,\n+        d.field_list_parent_path\n+            .clone()\n+            .map(SyntaxNodePtr::from)\n+            .unwrap_or_else(|| d.field_list_parent.clone().either(|it| it.into(), |it| it.into())),\n+    );\n+\n+    Diagnostic::new(\"missing-fields\", message, ctx.sema.diagnostics_display_range(ptr).range)\n+        .with_fixes(fixes(ctx, d))\n+}\n+\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Option<Vec<Assist>> {\n+    // Note that although we could add a diagnostics to\n+    // fill the missing tuple field, e.g :\n+    // `struct A(usize);`\n+    // `let a = A { 0: () }`\n+    // but it is uncommon usage and it should not be encouraged.\n+    if d.missed_fields.iter().any(|it| it.as_tuple_index().is_some()) {\n+        return None;\n+    }\n+\n+    let root = ctx.sema.db.parse_or_expand(d.file)?;\n+    let field_list_parent = match &d.field_list_parent {\n+        Either::Left(record_expr) => record_expr.to_node(&root),\n+        // FIXE: patterns should be fixable as well.\n+        Either::Right(_) => return None,\n+    };\n+    let old_field_list = field_list_parent.record_expr_field_list()?;\n+    let new_field_list = old_field_list.clone_for_update();\n+    for f in d.missed_fields.iter() {\n+        let field =\n+            make::record_expr_field(make::name_ref(&f.to_string()), Some(make::expr_unit()))\n+                .clone_for_update();\n+        new_field_list.add_field(field);\n+    }\n+\n+    let edit = {\n+        let mut builder = TextEdit::builder();\n+        algo::diff(old_field_list.syntax(), new_field_list.syntax()).into_text_edit(&mut builder);\n+        builder.finish()\n+    };\n+    Some(vec![fix(\n+        \"fill_missing_fields\",\n+        \"Fill struct fields\",\n+        SourceChange::from_text_edit(d.file.original_file(ctx.sema.db), edit),\n+        ctx.sema.original_range(field_list_parent.syntax()).range,\n+    )])\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::{check_diagnostics, check_fix, check_no_diagnostics};\n+\n+    #[test]\n+    fn missing_record_pat_field_diagnostic() {\n+        check_diagnostics(\n+            r#\"\n+struct S { foo: i32, bar: () }\n+fn baz(s: S) {\n+    let S { foo: _ } = s;\n+      //^ Missing structure fields:\n+      //| - bar\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_empty() {\n+        check_fix(\n+            r#\"\n+struct TestStruct { one: i32, two: i64 }\n+\n+fn test_fn() {\n+    let s = TestStruct {$0};\n+}\n+\"#,\n+            r#\"\n+struct TestStruct { one: i32, two: i64 }\n+\n+fn test_fn() {\n+    let s = TestStruct { one: (), two: () };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_self() {\n+        check_fix(\n+            r#\"\n+struct TestStruct { one: i32 }\n+\n+impl TestStruct {\n+    fn test_fn() { let s = Self {$0}; }\n+}\n+\"#,\n+            r#\"\n+struct TestStruct { one: i32 }\n+\n+impl TestStruct {\n+    fn test_fn() { let s = Self { one: () }; }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_enum() {\n+        check_fix(\n+            r#\"\n+enum Expr {\n+    Bin { lhs: Box<Expr>, rhs: Box<Expr> }\n+}\n+\n+impl Expr {\n+    fn new_bin(lhs: Box<Expr>, rhs: Box<Expr>) -> Expr {\n+        Expr::Bin {$0 }\n+    }\n+}\n+\"#,\n+            r#\"\n+enum Expr {\n+    Bin { lhs: Box<Expr>, rhs: Box<Expr> }\n+}\n+\n+impl Expr {\n+    fn new_bin(lhs: Box<Expr>, rhs: Box<Expr>) -> Expr {\n+        Expr::Bin { lhs: (), rhs: () }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_partial() {\n+        check_fix(\n+            r#\"\n+struct TestStruct { one: i32, two: i64 }\n+\n+fn test_fn() {\n+    let s = TestStruct{ two: 2$0 };\n+}\n+\"#,\n+            r\"\n+struct TestStruct { one: i32, two: i64 }\n+\n+fn test_fn() {\n+    let s = TestStruct{ two: 2, one: () };\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_raw_ident() {\n+        check_fix(\n+            r#\"\n+struct TestStruct { r#type: u8 }\n+\n+fn test_fn() {\n+    TestStruct { $0 };\n+}\n+\"#,\n+            r\"\n+struct TestStruct { r#type: u8 }\n+\n+fn test_fn() {\n+    TestStruct { r#type: ()  };\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_no_diagnostic() {\n+        check_no_diagnostics(\n+            r#\"\n+struct TestStruct { one: i32, two: i64 }\n+\n+fn test_fn() {\n+    let one = 1;\n+    let s = TestStruct{ one, two: 2 };\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_no_diagnostic_on_spread() {\n+        check_no_diagnostics(\n+            r#\"\n+struct TestStruct { one: i32, two: i64 }\n+\n+fn test_fn() {\n+    let one = 1;\n+    let s = TestStruct{ ..a };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_blank_line() {\n+        check_fix(\n+            r#\"\n+struct S { a: (), b: () }\n+\n+fn f() {\n+    S {\n+        $0\n+    };\n+}\n+\"#,\n+            r#\"\n+struct S { a: (), b: () }\n+\n+fn f() {\n+    S {\n+        a: (),\n+        b: (),\n+    };\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "4c8c74ff75174485cc406438abe1f9a263879fa1", "filename": "crates/ide/src/diagnostics/unresolved_module.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc6d761a99ab3b7e28ed13ca3839358f3341da4d/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc6d761a99ab3b7e28ed13ca3839358f3341da4d/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Funresolved_module.rs?ref=cc6d761a99ab3b7e28ed13ca3839358f3341da4d", "patch": "@@ -8,7 +8,10 @@ use crate::diagnostics::{fix, Diagnostic, DiagnosticsContext};\n // Diagnostic: unresolved-module\n //\n // This diagnostic is triggered if rust-analyzer is unable to discover referred module.\n-pub(super) fn render(ctx: &DiagnosticsContext<'_>, d: &hir::UnresolvedModule) -> Diagnostic {\n+pub(super) fn unresolved_module(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::UnresolvedModule,\n+) -> Diagnostic {\n     Diagnostic::new(\n         \"unresolved-module\",\n         \"unresolved module\","}]}