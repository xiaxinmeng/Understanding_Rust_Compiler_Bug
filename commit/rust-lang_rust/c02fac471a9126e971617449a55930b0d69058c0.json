{"sha": "c02fac471a9126e971617449a55930b0d69058c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwMmZhYzQ3MWE5MTI2ZTk3MTYxNzQ0OWE1NTkzMGIwZDY5MDU4YzA=", "commit": {"author": {"name": "Jared Roesch", "email": "roeschinc@gmail.com", "date": "2015-01-04T10:35:14Z"}, "committer": {"name": "Jared Roesch", "email": "roeschinc@gmail.com", "date": "2015-01-05T08:46:01Z"}, "message": "Refactor struct parsing and add tests", "tree": {"sha": "61a8e96b9e1ef34415e8769cfe90508b6186ab02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61a8e96b9e1ef34415e8769cfe90508b6186ab02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c02fac471a9126e971617449a55930b0d69058c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c02fac471a9126e971617449a55930b0d69058c0", "html_url": "https://github.com/rust-lang/rust/commit/c02fac471a9126e971617449a55930b0d69058c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c02fac471a9126e971617449a55930b0d69058c0/comments", "author": {"login": "jroesch", "id": 696509, "node_id": "MDQ6VXNlcjY5NjUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/696509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroesch", "html_url": "https://github.com/jroesch", "followers_url": "https://api.github.com/users/jroesch/followers", "following_url": "https://api.github.com/users/jroesch/following{/other_user}", "gists_url": "https://api.github.com/users/jroesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroesch/subscriptions", "organizations_url": "https://api.github.com/users/jroesch/orgs", "repos_url": "https://api.github.com/users/jroesch/repos", "events_url": "https://api.github.com/users/jroesch/events{/privacy}", "received_events_url": "https://api.github.com/users/jroesch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jroesch", "id": 696509, "node_id": "MDQ6VXNlcjY5NjUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/696509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroesch", "html_url": "https://github.com/jroesch", "followers_url": "https://api.github.com/users/jroesch/followers", "following_url": "https://api.github.com/users/jroesch/following{/other_user}", "gists_url": "https://api.github.com/users/jroesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroesch/subscriptions", "organizations_url": "https://api.github.com/users/jroesch/orgs", "repos_url": "https://api.github.com/users/jroesch/repos", "events_url": "https://api.github.com/users/jroesch/events{/privacy}", "received_events_url": "https://api.github.com/users/jroesch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c54932cb12b8384060bfe132907ec42cc5c1bbd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c54932cb12b8384060bfe132907ec42cc5c1bbd2", "html_url": "https://github.com/rust-lang/rust/commit/c54932cb12b8384060bfe132907ec42cc5c1bbd2"}], "stats": {"total": 147, "additions": 96, "deletions": 51}, "files": [{"sha": "79e5fe7cc9a073f576f04752d5add8ddce7255e4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 76, "deletions": 45, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/c02fac471a9126e971617449a55930b0d69058c0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fac471a9126e971617449a55930b0d69058c0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c02fac471a9126e971617449a55930b0d69058c0", "patch": "@@ -4875,9 +4875,6 @@ impl<'a> Parser<'a> {\n             self.span_err(ty.span, \"`virtual` structs have been removed from the language\");\n         }\n \n-        let mut fields: Vec<StructField>;\n-        let is_tuple_like;\n-\n         // There is a special case worth noting here, as reported in issue #17904.\n         // If we are parsing a tuple struct it is the case that the where clause\n         // should follow the field list. Like so:\n@@ -4892,68 +4889,102 @@ impl<'a> Parser<'a> {\n         // Otherwise if we look ahead and see a paren we parse a tuple-style\n         // struct.\n \n-        // Will parse the where-clause if it precedes the brace.\n-        self.parse_where_clause(&mut generics);\n+        let (fields, ctor_id) = if self.token.is_keyword(keywords::Where) {\n+            self.parse_where_clause(&mut generics);\n+            if self.eat(&token::Semi) {\n+                // If we see a: `struct Foo<T> where T: Copy;` style decl.\n+                (Vec::new(), Some(ast::DUMMY_NODE_ID))\n+            } else {\n+                // If we see: `struct Foo<T> where T: Copy { ... }`\n+                (self.parse_record_struct_body(&class_name), None)\n+            }\n+        // No `where` so: `struct Foo<T>;`\n+        } else if self.eat(&token::Semi) {\n+            (Vec::new(), Some(ast::DUMMY_NODE_ID))\n+        // Record-style struct definition\n+        } else if self.token == token::OpenDelim(token::Brace) {\n+            let fields = self.parse_record_struct_body(&class_name);\n+            (fields, None)\n+        // Tuple-style struct definition with optional where-clause.\n+        } else {\n+            let fields = self.parse_tuple_struct_body(&class_name, &mut generics);\n+            (fields, Some(ast::DUMMY_NODE_ID))\n+        };\n \n+        (class_name,\n+         ItemStruct(P(ast::StructDef {\n+             fields: fields,\n+             ctor_id: ctor_id,\n+         }), generics),\n+         None)\n+    }\n+\n+    pub fn parse_record_struct_body(&mut self, class_name: &ast::Ident) -> Vec<StructField> {\n+        let mut fields = Vec::new();\n         if self.eat(&token::OpenDelim(token::Brace)) {\n-            // It's a record-like struct.\n-            is_tuple_like = false;\n-            fields = Vec::new();\n             while self.token != token::CloseDelim(token::Brace) {\n                 fields.push(self.parse_struct_decl_field(true));\n             }\n+\n             if fields.len() == 0 {\n                 self.fatal(format!(\"unit-like struct definition should be \\\n-                                    written as `struct {};`\",\n-                                   token::get_ident(class_name))[]);\n+                    written as `struct {};`\",\n+                    token::get_ident(class_name.clone()))[]);\n             }\n+\n             self.bump();\n-        } else if self.check(&token::OpenDelim(token::Paren)) {\n-            // It's a tuple-like struct.\n-            is_tuple_like = true;\n-            fields = self.parse_unspanned_seq(\n+        } else {\n+            let token_str = self.this_token_to_string();\n+            self.fatal(format!(\"expected `where`, or `{}` after struct \\\n+                                name, found `{}`\", \"{\",\n+                                token_str)[]);\n+        }\n+\n+        fields\n+    }\n+\n+    pub fn parse_tuple_struct_body(&mut self,\n+                                   class_name: &ast::Ident,\n+                                   generics: &mut ast::Generics)\n+                                   -> Vec<StructField> {\n+        // This is the case where we find `struct Foo<T>(T) where T: Copy;`\n+        if self.check(&token::OpenDelim(token::Paren)) {\n+            let fields = self.parse_unspanned_seq(\n                 &token::OpenDelim(token::Paren),\n                 &token::CloseDelim(token::Paren),\n                 seq_sep_trailing_allowed(token::Comma),\n                 |p| {\n-                let attrs = p.parse_outer_attributes();\n-                let lo = p.span.lo;\n-                let struct_field_ = ast::StructField_ {\n-                    kind: UnnamedField(p.parse_visibility()),\n-                    id: ast::DUMMY_NODE_ID,\n-                    ty: p.parse_ty_sum(),\n-                    attrs: attrs,\n-                };\n-                spanned(lo, p.span.hi, struct_field_)\n-            });\n+                    let attrs = p.parse_outer_attributes();\n+                    let lo = p.span.lo;\n+                    let struct_field_ = ast::StructField_ {\n+                        kind: UnnamedField(p.parse_visibility()),\n+                        id: ast::DUMMY_NODE_ID,\n+                        ty: p.parse_ty_sum(),\n+                        attrs: attrs,\n+                    };\n+                    spanned(lo, p.span.hi, struct_field_)\n+                });\n+\n             if fields.len() == 0 {\n                 self.fatal(format!(\"unit-like struct definition should be \\\n-                                    written as `struct {};`\",\n-                                   token::get_ident(class_name))[]);\n+                    written as `struct {};`\",\n+                    token::get_ident(class_name.clone()))[]);\n             }\n-            self.parse_where_clause(&mut generics);\n+\n+            self.parse_where_clause(generics);\n             self.expect(&token::Semi);\n-        } else if self.token.is_keyword(keywords::Where) || self.eat(&token::Semi) {\n-            // We can find a where clause here.\n-            self.parse_where_clause(&mut generics);\n-            // It's a unit-like struct.\n-            is_tuple_like = true;\n-            fields = Vec::new();\n+            fields\n+        // This is the case where we just see struct Foo<T> where T: Copy;\n+        } else if self.token.is_keyword(keywords::Where) {\n+            self.parse_where_clause(generics);\n+            self.expect(&token::Semi);\n+            Vec::new()\n+        // This case is where we see: `struct Foo<T>;`\n         } else {\n             let token_str = self.this_token_to_string();\n-            self.fatal(format!(\"expected `{}`, `(`, or `;` after struct \\\n-                                name, found `{}`\", \"{\",\n-                               token_str)[])\n+            self.fatal(format!(\"expected `where`, `{}`, `(`, or `;` after struct \\\n+                name, found `{}`\", \"{\", token_str)[]);\n         }\n-\n-        let _ = ast::DUMMY_NODE_ID;  // FIXME: Workaround for crazy bug.\n-        let new_id = ast::DUMMY_NODE_ID;\n-        (class_name,\n-         ItemStruct(P(ast::StructDef {\n-             fields: fields,\n-             ctor_id: if is_tuple_like { Some(new_id) } else { None },\n-         }), generics),\n-         None)\n     }\n \n     /// Parse a structure field declaration"}, {"sha": "2176cd13b287b62267c7d937693ff8a39dbc670f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c02fac471a9126e971617449a55930b0d69058c0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fac471a9126e971617449a55930b0d69058c0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c02fac471a9126e971617449a55930b0d69058c0", "patch": "@@ -1067,7 +1067,6 @@ impl<'a> State<'a> {\n                         span: codemap::Span) -> IoResult<()> {\n         try!(self.print_ident(ident));\n         try!(self.print_generics(generics));\n-        try!(self.print_where_clause(generics));\n         if ast_util::struct_def_is_tuple_like(struct_def) {\n             if !struct_def.fields.is_empty() {\n                 try!(self.popen());\n@@ -1086,10 +1085,12 @@ impl<'a> State<'a> {\n                 ));\n                 try!(self.pclose());\n             }\n+            try!(self.print_where_clause(generics));\n             try!(word(&mut self.s, \";\"));\n             try!(self.end());\n             self.end() // close the outer-box\n         } else {\n+            try!(self.print_where_clause(generics));\n             try!(self.nbsp());\n             try!(self.bopen());\n             try!(self.hardbreak_if_not_bol());"}, {"sha": "96ba712bbae8b7eacdb00d73f961a995b411606a", "filename": "src/test/compile-fail/issue-17904.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c02fac471a9126e971617449a55930b0d69058c0/src%2Ftest%2Fcompile-fail%2Fissue-17904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fac471a9126e971617449a55930b0d69058c0/src%2Ftest%2Fcompile-fail%2Fissue-17904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17904.rs?ref=c02fac471a9126e971617449a55930b0d69058c0", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Baz<U> where U: Eq(U); //This is parsed as the new Fn* style parenthesis syntax.\n+struct Baz<U> where U: Eq(U) -> R; // Notice this parses as well.\n+struct Baz<U>(U) where U: Eq; // This rightfully signals no error as well.\n+struct Foo<T> where T: Copy, (T); //~ ERROR unexpected token in `where` clause\n+struct Bar<T> { x: T } where T: Copy //~ ERROR expected item, found `where`\n+\n+fn main() {}"}, {"sha": "92dbea0424b6f6627bcd1faccf790bd64faae656", "filename": "src/test/compile-fail/unsized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fac471a9126e971617449a55930b0d69058c0/src%2Ftest%2Fcompile-fail%2Funsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fac471a9126e971617449a55930b0d69058c0/src%2Ftest%2Fcompile-fail%2Funsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized.rs?ref=c02fac471a9126e971617449a55930b0d69058c0", "patch": "@@ -10,7 +10,7 @@\n \n // Test syntax checks for `type` keyword.\n \n-struct S1 for type; //~ ERROR expected `{`, `(`, or `;` after struct name, found `for`\n+struct S1 for type; //~ ERROR expected `where`, `{`, `(`, or `;` after struct name, found `for`\n \n pub fn main() {\n }"}, {"sha": "3ce347d67e3d91f173ffbe55c69a5403dbac12f5", "filename": "src/test/run-pass/issue-17904.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02fac471a9126e971617449a55930b0d69058c0/src%2Ftest%2Frun-pass%2Fissue-17904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fac471a9126e971617449a55930b0d69058c0/src%2Ftest%2Frun-pass%2Fissue-17904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17904.rs?ref=c02fac471a9126e971617449a55930b0d69058c0", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Tests that type assignability is used to search for instances when\n-// making method calls, but only if there aren't any matches without\n-// it.\n-\n struct Foo<T> where T: Copy;\n struct Bar<T>(T) where T: Copy;\n struct Bleh<T, U>(T, U) where T: Copy, U: Sized;"}]}