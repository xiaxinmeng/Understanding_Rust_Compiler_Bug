{"sha": "ad451686a807cf5f86826c80ad22c04c559a8589", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkNDUxNjg2YTgwN2NmNWY4NjgyNmM4MGFkMjJjMDRjNTU5YTg1ODk=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-09-05T15:07:17Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-09-05T15:07:17Z"}, "message": "Merge #56\n\n56: Unify lookahead naming between parser and lexer. r=matklad a=zachlute\n\nResolves Issue #26.\r\n\r\nI wanted to play around with libsyntax2, and fixing a random issue seemed like a good way to mess around in the code.\r\n\r\nThis PR mostly does what's suggested in that issue. I elected to go with `at` and `at_str` instead of trying to do any fancy overloading shenanigans, because...uh, well, frankly I don't really know how to do any fancy overloading shenanigans. The only really questionable bit is `nth_is_p`, which could also have potentially been named `nth_at_p`, but `is` seemed more apropos.\r\n\r\nI also added simple tests for `Ptr` so I could be less terrified I broke something. \r\n\r\nComments and criticisms very welcome. I'm still pretty new to Rust.\n\nCo-authored-by: Zach Lute <zach.lute@gmail.com>", "tree": {"sha": "96633364368463feda5ae136fe2a993a15d5b1d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96633364368463feda5ae136fe2a993a15d5b1d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad451686a807cf5f86826c80ad22c04c559a8589", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad451686a807cf5f86826c80ad22c04c559a8589", "html_url": "https://github.com/rust-lang/rust/commit/ad451686a807cf5f86826c80ad22c04c559a8589", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad451686a807cf5f86826c80ad22c04c559a8589/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "649f7faf7d6eb25635dd624a2ea50a47ac090e09", "url": "https://api.github.com/repos/rust-lang/rust/commits/649f7faf7d6eb25635dd624a2ea50a47ac090e09", "html_url": "https://github.com/rust-lang/rust/commit/649f7faf7d6eb25635dd624a2ea50a47ac090e09"}, {"sha": "d21fead150d502aa69db82d35967e5e9d73aed56", "url": "https://api.github.com/repos/rust-lang/rust/commits/d21fead150d502aa69db82d35967e5e9d73aed56", "html_url": "https://github.com/rust-lang/rust/commit/d21fead150d502aa69db82d35967e5e9d73aed56"}], "stats": {"total": 182, "additions": 137, "deletions": 45}, "files": [{"sha": "eb417c2dc4f0f044b57c84eed099b9f21c2592d6", "filename": "crates/libsyntax2/src/lexer/comments.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad451686a807cf5f86826c80ad22c04c559a8589/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad451686a807cf5f86826c80ad22c04c559a8589/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fcomments.rs?ref=ad451686a807cf5f86826c80ad22c04c559a8589", "patch": "@@ -3,7 +3,7 @@ use lexer::ptr::Ptr;\n use SyntaxKind::{self, *};\n \n pub(crate) fn scan_shebang(ptr: &mut Ptr) -> bool {\n-    if ptr.next_is('!') && ptr.nnext_is('/') {\n+    if ptr.at_str(\"!/\") {\n         ptr.bump();\n         ptr.bump();\n         bump_until_eol(ptr);\n@@ -14,15 +14,15 @@ pub(crate) fn scan_shebang(ptr: &mut Ptr) -> bool {\n }\n \n fn scan_block_comment(ptr: &mut Ptr) -> Option<SyntaxKind> {\n-    if ptr.next_is('*') {\n+    if ptr.at('*') {\n         ptr.bump();\n         let mut depth: u32 = 1;\n         while depth > 0 {\n-            if ptr.next_is('*') && ptr.nnext_is('/') {\n+            if ptr.at_str(\"*/\") {\n                 depth -= 1;\n                 ptr.bump();\n                 ptr.bump();\n-            } else if ptr.next_is('/') && ptr.nnext_is('*') {\n+            } else if ptr.at_str(\"/*\") {\n                 depth += 1;\n                 ptr.bump();\n                 ptr.bump();\n@@ -37,7 +37,7 @@ fn scan_block_comment(ptr: &mut Ptr) -> Option<SyntaxKind> {\n }\n \n pub(crate) fn scan_comment(ptr: &mut Ptr) -> Option<SyntaxKind> {\n-    if ptr.next_is('/') {\n+    if ptr.at('/') {\n         bump_until_eol(ptr);\n         Some(COMMENT)\n     } else {\n@@ -47,7 +47,7 @@ pub(crate) fn scan_comment(ptr: &mut Ptr) -> Option<SyntaxKind> {\n \n fn bump_until_eol(ptr: &mut Ptr) {\n     loop {\n-        if ptr.next_is('\\n') || ptr.next_is('\\r') && ptr.nnext_is('\\n') {\n+        if ptr.at('\\n') || ptr.at_str(\"\\r\\n\") {\n             return;\n         }\n         if ptr.bump().is_none() {"}, {"sha": "3e11db88b2702782ea4d9fa4f71a4309c16431e5", "filename": "crates/libsyntax2/src/lexer/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad451686a807cf5f86826c80ad22c04c559a8589/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad451686a807cf5f86826c80ad22c04c559a8589/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fmod.rs?ref=ad451686a807cf5f86826c80ad22c04c559a8589", "patch": "@@ -67,7 +67,7 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n         _ => (),\n     }\n \n-    let ident_start = is_ident_start(c) && !is_string_literal_start(c, ptr.next(), ptr.nnext());\n+    let ident_start = is_ident_start(c) && !is_string_literal_start(c, ptr.current(), ptr.nth(1));\n     if ident_start {\n         return scan_ident(c, ptr);\n     }\n@@ -86,7 +86,7 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n     match c {\n         // Multi-byte tokens.\n         '.' => {\n-            return match (ptr.next(), ptr.nnext()) {\n+            return match (ptr.current(), ptr.nth(1)) {\n                 (Some('.'), Some('.')) => {\n                     ptr.bump();\n                     ptr.bump();\n@@ -105,7 +105,7 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n             };\n         }\n         ':' => {\n-            return match ptr.next() {\n+            return match ptr.current() {\n                 Some(':') => {\n                     ptr.bump();\n                     COLONCOLON\n@@ -114,7 +114,7 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n             };\n         }\n         '=' => {\n-            return match ptr.next() {\n+            return match ptr.current() {\n                 Some('=') => {\n                     ptr.bump();\n                     EQEQ\n@@ -127,7 +127,7 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n             };\n         }\n         '!' => {\n-            return match ptr.next() {\n+            return match ptr.current() {\n                 Some('=') => {\n                     ptr.bump();\n                     NEQ\n@@ -136,7 +136,7 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n             };\n         }\n         '-' => {\n-            return if ptr.next_is('>') {\n+            return if ptr.at('>') {\n                 ptr.bump();\n                 THIN_ARROW\n             } else {\n@@ -147,14 +147,14 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n         // If the character is an ident start not followed by another single\n         // quote, then this is a lifetime name:\n         '\\'' => {\n-            return if ptr.next_is_p(is_ident_start) && !ptr.nnext_is('\\'') {\n+            return if ptr.at_p(is_ident_start) && !ptr.at_str(\"''\") {\n                 ptr.bump();\n-                while ptr.next_is_p(is_ident_continue) {\n+                while ptr.at_p(is_ident_continue) {\n                     ptr.bump();\n                 }\n                 // lifetimes shouldn't end with a single quote\n                 // if we find one, then this is an invalid character literal\n-                if ptr.next_is('\\'') {\n+                if ptr.at('\\'') {\n                     ptr.bump();\n                     return CHAR; // TODO: error reporting\n                 }\n@@ -186,7 +186,7 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n }\n \n fn scan_ident(c: char, ptr: &mut Ptr) -> SyntaxKind {\n-    let is_single_letter = match ptr.next() {\n+    let is_single_letter = match ptr.current() {\n         None => true,\n         Some(c) if !is_ident_continue(c) => true,\n         _ => false,\n@@ -202,7 +202,7 @@ fn scan_ident(c: char, ptr: &mut Ptr) -> SyntaxKind {\n }\n \n fn scan_literal_suffix(ptr: &mut Ptr) {\n-    if ptr.next_is_p(is_ident_start) {\n+    if ptr.at_p(is_ident_start) {\n         ptr.bump();\n     }\n     ptr.bump_while(is_ident_continue);"}, {"sha": "22e7d4e99d6a45c61c36ce4e2ce2aef6641674b1", "filename": "crates/libsyntax2/src/lexer/numbers.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad451686a807cf5f86826c80ad22c04c559a8589/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fnumbers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad451686a807cf5f86826c80ad22c04c559a8589/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fnumbers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fnumbers.rs?ref=ad451686a807cf5f86826c80ad22c04c559a8589", "patch": "@@ -5,7 +5,7 @@ use SyntaxKind::{self, *};\n \n pub(crate) fn scan_number(c: char, ptr: &mut Ptr) -> SyntaxKind {\n     if c == '0' {\n-        match ptr.next().unwrap_or('\\0') {\n+        match ptr.current().unwrap_or('\\0') {\n             'b' | 'o' => {\n                 ptr.bump();\n                 scan_digits(ptr, false);\n@@ -26,7 +26,7 @@ pub(crate) fn scan_number(c: char, ptr: &mut Ptr) -> SyntaxKind {\n     // might be a float, but don't be greedy if this is actually an\n     // integer literal followed by field/method access or a range pattern\n     // (`0..2` and `12.foo()`)\n-    if ptr.next_is('.') && !(ptr.nnext_is('.') || ptr.nnext_is_p(is_ident_start)) {\n+    if ptr.at('.') && !(ptr.at_str(\"..\") || ptr.nth_is_p(1, is_ident_start)) {\n         // might have stuff after the ., and if it does, it needs to start\n         // with a number\n         ptr.bump();\n@@ -35,15 +35,15 @@ pub(crate) fn scan_number(c: char, ptr: &mut Ptr) -> SyntaxKind {\n         return FLOAT_NUMBER;\n     }\n     // it might be a float if it has an exponent\n-    if ptr.next_is('e') || ptr.next_is('E') {\n+    if ptr.at('e') || ptr.at('E') {\n         scan_float_exponent(ptr);\n         return FLOAT_NUMBER;\n     }\n     INT_NUMBER\n }\n \n fn scan_digits(ptr: &mut Ptr, allow_hex: bool) {\n-    while let Some(c) = ptr.next() {\n+    while let Some(c) = ptr.current() {\n         match c {\n             '_' | '0'...'9' => {\n                 ptr.bump();\n@@ -57,9 +57,9 @@ fn scan_digits(ptr: &mut Ptr, allow_hex: bool) {\n }\n \n fn scan_float_exponent(ptr: &mut Ptr) {\n-    if ptr.next_is('e') || ptr.next_is('E') {\n+    if ptr.at('e') || ptr.at('E') {\n         ptr.bump();\n-        if ptr.next_is('-') || ptr.next_is('+') {\n+        if ptr.at('-') || ptr.at('+') {\n             ptr.bump();\n         }\n         scan_digits(ptr, false);"}, {"sha": "c9a5354ea3077b80eb187f1f6fcab6729040faaf", "filename": "crates/libsyntax2/src/lexer/ptr.rs", "status": "modified", "additions": 106, "deletions": 14, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/ad451686a807cf5f86826c80ad22c04c559a8589/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad451686a807cf5f86826c80ad22c04c559a8589/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fptr.rs?ref=ad451686a807cf5f86826c80ad22c04c559a8589", "patch": "@@ -2,58 +2,70 @@ use TextUnit;\n \n use std::str::Chars;\n \n+/// A simple view into the characters of a string.\n pub(crate) struct Ptr<'s> {\n     text: &'s str,\n     len: TextUnit,\n }\n \n impl<'s> Ptr<'s> {\n+    /// Creates a new `Ptr` from a string.\n     pub fn new(text: &'s str) -> Ptr<'s> {\n         Ptr {\n             text,\n             len: 0.into(),\n         }\n     }\n \n+    /// Gets the length of the remaining string.\n     pub fn into_len(self) -> TextUnit {\n         self.len\n     }\n \n-    pub fn next(&self) -> Option<char> {\n+    /// Gets the current character, if one exists.\n+    pub fn current(&self) -> Option<char> {\n         self.chars().next()\n     }\n \n-    pub fn nnext(&self) -> Option<char> {\n-        let mut chars = self.chars();\n-        chars.next()?;\n-        chars.next()\n+    /// Gets the nth character from the current.\n+    /// For example, 0 will return the current token, 1 will return the next, etc.\n+    pub fn nth(&self, n: u32) -> Option<char> {\n+        let mut chars = self.chars().peekable();\n+        chars.by_ref().skip(n as usize).next()\n     }\n \n-    pub fn next_is(&self, c: char) -> bool {\n-        self.next() == Some(c)\n+    /// Checks whether the current character is `c`.\n+    pub fn at(&self, c: char) -> bool {\n+        self.current() == Some(c)\n     }\n \n-    pub fn nnext_is(&self, c: char) -> bool {\n-        self.nnext() == Some(c)\n+    /// Checks whether the next characters match `s`.\n+    pub fn at_str(&self, s: &str) -> bool {\n+        let chars = self.chars();\n+        chars.as_str().starts_with(s)\n     }\n \n-    pub fn next_is_p<P: Fn(char) -> bool>(&self, p: P) -> bool {\n-        self.next().map(p) == Some(true)\n+    /// Checks whether the current character satisfies the predicate `p`.\n+    pub fn at_p<P: Fn(char) -> bool>(&self, p: P) -> bool {\n+        self.current().map(p) == Some(true)\n     }\n \n-    pub fn nnext_is_p<P: Fn(char) -> bool>(&self, p: P) -> bool {\n-        self.nnext().map(p) == Some(true)\n+    /// Checks whether the nth character satisfies the predicate `p`.\n+    pub fn nth_is_p<P: Fn(char) -> bool>(&self, n: u32, p: P) -> bool {\n+        self.nth(n).map(p) == Some(true)\n     }\n \n+    /// Moves to the next character.\n     pub fn bump(&mut self) -> Option<char> {\n         let ch = self.chars().next()?;\n         self.len += TextUnit::of_char(ch);\n         Some(ch)\n     }\n \n+    /// Moves to the next character as long as `pred` is satisfied.\n     pub fn bump_while<F: Fn(char) -> bool>(&mut self, pred: F) {\n         loop {\n-            match self.next() {\n+            match self.current() {\n                 Some(c) if pred(c) => {\n                     self.bump();\n                 }\n@@ -62,13 +74,93 @@ impl<'s> Ptr<'s> {\n         }\n     }\n \n+    /// Returns the text up to the current point.\n     pub fn current_token_text(&self) -> &str {\n         let len: u32 = self.len.into();\n         &self.text[..len as usize]\n     }\n \n+    /// Returns an iterator over the remaining characters.\n     fn chars(&self) -> Chars {\n         let len: u32 = self.len.into();\n         self.text[len as usize..].chars()\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_current() {\n+        let ptr = Ptr::new(\"test\");\n+        assert_eq!(ptr.current(), Some('t'));\n+    }\n+\n+    #[test]\n+    fn test_nth() {\n+        let ptr = Ptr::new(\"test\");\n+        assert_eq!(ptr.nth(0), Some('t'));\n+        assert_eq!(ptr.nth(1), Some('e'));\n+        assert_eq!(ptr.nth(2), Some('s'));\n+        assert_eq!(ptr.nth(3), Some('t'));\n+        assert_eq!(ptr.nth(4), None);\n+    }\n+\n+    #[test]\n+    fn test_at() {\n+        let ptr = Ptr::new(\"test\");\n+        assert!(ptr.at('t'));\n+        assert!(!ptr.at('a'));\n+    }\n+\n+    #[test]\n+    fn test_at_str() {\n+        let ptr = Ptr::new(\"test\");\n+        assert!(ptr.at_str(\"t\"));\n+        assert!(ptr.at_str(\"te\"));\n+        assert!(ptr.at_str(\"test\"));\n+        assert!(!ptr.at_str(\"tests\"));\n+        assert!(!ptr.at_str(\"rust\"));\n+    }\n+\n+    #[test]\n+    fn test_at_p() {\n+        let ptr = Ptr::new(\"test\");\n+        assert!(ptr.at_p(|c| c == 't'));\n+        assert!(!ptr.at_p(|c| c == 'e'));\n+    }\n+\n+    #[test]\n+    fn test_nth_is_p() {\n+        let ptr = Ptr::new(\"test\");\n+        assert!(ptr.nth_is_p(0,|c| c == 't'));\n+        assert!(!ptr.nth_is_p(1,|c| c == 't'));\n+        assert!(ptr.nth_is_p(3,|c| c == 't'));\n+        assert!(!ptr.nth_is_p(150,|c| c == 't'));\n+    }\n+\n+    #[test]\n+    fn test_bump() {\n+        let mut ptr = Ptr::new(\"test\");\n+        assert_eq!(ptr.current(), Some('t'));\n+        ptr.bump();\n+        assert_eq!(ptr.current(), Some('e'));\n+        ptr.bump();\n+        assert_eq!(ptr.current(), Some('s'));\n+        ptr.bump();\n+        assert_eq!(ptr.current(), Some('t'));\n+        ptr.bump();\n+        assert_eq!(ptr.current(), None);\n+        ptr.bump();\n+        assert_eq!(ptr.current(), None);\n+    }\n+\n+    #[test]\n+    fn test_bump_while() {\n+        let mut ptr = Ptr::new(\"test\");\n+        assert_eq!(ptr.current(), Some('t'));\n+        ptr.bump_while(|c| c != 's');\n+        assert_eq!(ptr.current(), Some('s'));\n+    }\n+}"}, {"sha": "5ff483d14c5ef6d0a018c2debb680226f92bce05", "filename": "crates/libsyntax2/src/lexer/strings.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad451686a807cf5f86826c80ad22c04c559a8589/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad451686a807cf5f86826c80ad22c04c559a8589/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fstrings.rs?ref=ad451686a807cf5f86826c80ad22c04c559a8589", "patch": "@@ -15,11 +15,11 @@ pub(crate) fn is_string_literal_start(c: char, c1: Option<char>, c2: Option<char\n }\n \n pub(crate) fn scan_char(ptr: &mut Ptr) {\n-    while let Some(c) = ptr.next() {\n+    while let Some(c) = ptr.current() {\n         match c {\n             '\\\\' => {\n                 ptr.bump();\n-                if ptr.next_is('\\\\') || ptr.next_is('\\'') {\n+                if ptr.at('\\\\') || ptr.at('\\'') {\n                     ptr.bump();\n                 }\n             }\n@@ -57,11 +57,11 @@ pub(crate) fn scan_byte_char_or_string(ptr: &mut Ptr) -> SyntaxKind {\n }\n \n pub(crate) fn scan_string(ptr: &mut Ptr) {\n-    while let Some(c) = ptr.next() {\n+    while let Some(c) = ptr.current() {\n         match c {\n             '\\\\' => {\n                 ptr.bump();\n-                if ptr.next_is('\\\\') || ptr.next_is('\"') {\n+                if ptr.at('\\\\') || ptr.at('\"') {\n                     ptr.bump();\n                 }\n             }\n@@ -78,19 +78,19 @@ pub(crate) fn scan_string(ptr: &mut Ptr) {\n \n pub(crate) fn scan_raw_string(ptr: &mut Ptr) {\n     let mut hashes = 0;\n-    while ptr.next_is('#') {\n+    while ptr.at('#') {\n         hashes += 1;\n         ptr.bump();\n     }\n-    if !ptr.next_is('\"') {\n+    if !ptr.at('\"') {\n         return;\n     }\n     ptr.bump();\n \n     while let Some(c) = ptr.bump() {\n         if c == '\"' {\n             let mut hashes_left = hashes;\n-            while ptr.next_is('#') && hashes_left > 0{\n+            while ptr.at('#') && hashes_left > 0{\n                 hashes_left -= 1;\n                 ptr.bump();\n             }\n@@ -110,7 +110,7 @@ fn scan_byte_string(ptr: &mut Ptr) {\n }\n \n fn scan_raw_byte_string(ptr: &mut Ptr) {\n-    if !ptr.next_is('\"') {\n+    if !ptr.at('\"') {\n         return;\n     }\n     ptr.bump();"}]}