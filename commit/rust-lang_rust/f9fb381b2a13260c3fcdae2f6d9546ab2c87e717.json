{"sha": "f9fb381b2a13260c3fcdae2f6d9546ab2c87e717", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZmIzODFiMmExMzI2MGMzZmNkYWUyZjZkOTU0NmFiMmM4N2U3MTc=", "commit": {"author": {"name": "Oliver Middleton", "email": "olliemail27@gmail.com", "date": "2017-04-06T12:09:20Z"}, "committer": {"name": "Oliver Middleton", "email": "olliemail27@gmail.com", "date": "2017-04-06T12:09:20Z"}, "message": "rustdoc: Use pulldown-cmark for Markdown HTML rendering\n\nInstead of rendering all of the HTML in rustdoc this relies on\npulldown-cmark's `push_html` to do most of the work. A few iterator\nadapters are used to make rustdoc specific modifications to the output.\n\nThis also fixes MarkdownHtml and link titles in plain_summary_line.", "tree": {"sha": "3c5a52c16c1f5a25f5d2288b858e45fd7bfb0688", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c5a52c16c1f5a25f5d2288b858e45fd7bfb0688"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9fb381b2a13260c3fcdae2f6d9546ab2c87e717", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9fb381b2a13260c3fcdae2f6d9546ab2c87e717", "html_url": "https://github.com/rust-lang/rust/commit/f9fb381b2a13260c3fcdae2f6d9546ab2c87e717", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9fb381b2a13260c3fcdae2f6d9546ab2c87e717/comments", "author": {"login": "ollie27", "id": 7189418, "node_id": "MDQ6VXNlcjcxODk0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/7189418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ollie27", "html_url": "https://github.com/ollie27", "followers_url": "https://api.github.com/users/ollie27/followers", "following_url": "https://api.github.com/users/ollie27/following{/other_user}", "gists_url": "https://api.github.com/users/ollie27/gists{/gist_id}", "starred_url": "https://api.github.com/users/ollie27/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ollie27/subscriptions", "organizations_url": "https://api.github.com/users/ollie27/orgs", "repos_url": "https://api.github.com/users/ollie27/repos", "events_url": "https://api.github.com/users/ollie27/events{/privacy}", "received_events_url": "https://api.github.com/users/ollie27/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ollie27", "id": 7189418, "node_id": "MDQ6VXNlcjcxODk0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/7189418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ollie27", "html_url": "https://github.com/ollie27", "followers_url": "https://api.github.com/users/ollie27/followers", "following_url": "https://api.github.com/users/ollie27/following{/other_user}", "gists_url": "https://api.github.com/users/ollie27/gists{/gist_id}", "starred_url": "https://api.github.com/users/ollie27/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ollie27/subscriptions", "organizations_url": "https://api.github.com/users/ollie27/orgs", "repos_url": "https://api.github.com/users/ollie27/repos", "events_url": "https://api.github.com/users/ollie27/events{/privacy}", "received_events_url": "https://api.github.com/users/ollie27/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5e92753cc3e12c3c468b6badaf340fe4443145c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5e92753cc3e12c3c468b6badaf340fe4443145c", "html_url": "https://github.com/rust-lang/rust/commit/e5e92753cc3e12c3c468b6badaf340fe4443145c"}], "stats": {"total": 779, "additions": 296, "deletions": 483}, "files": [{"sha": "1e687d63f58755d732d1e71878c4ca45262d90df", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 267, "deletions": 461, "changes": 728, "blob_url": "https://github.com/rust-lang/rust/blob/f9fb381b2a13260c3fcdae2f6d9546ab2c87e717/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fb381b2a13260c3fcdae2f6d9546ab2c87e717/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=f9fb381b2a13260c3fcdae2f6d9546ab2c87e717", "patch": "@@ -16,18 +16,18 @@\n //! of `fmt::Display`. Example usage:\n //!\n //! ```rust,ignore\n-//! use rustdoc::html::markdown::{Markdown, MarkdownOutputStyle};\n+//! use rustdoc::html::markdown::Markdown;\n //!\n //! let s = \"My *markdown* _text_\";\n-//! let html = format!(\"{}\", Markdown(s, MarkdownOutputStyle::Fancy));\n+//! let html = format!(\"{}\", Markdown(s));\n //! // ... something using html\n //! ```\n \n #![allow(non_camel_case_types)]\n \n use std::ascii::AsciiExt;\n use std::cell::RefCell;\n-use std::collections::HashMap;\n+use std::collections::{HashMap, VecDeque};\n use std::default::Default;\n use std::fmt::{self, Write};\n use std::str;\n@@ -37,43 +37,23 @@ use syntax::codemap::Span;\n use html::render::derive_id;\n use html::toc::TocBuilder;\n use html::highlight;\n-use html::escape::Escape;\n use test;\n \n-use pulldown_cmark::{self, Event, Parser, Tag};\n-\n-#[derive(Copy, Clone)]\n-pub enum MarkdownOutputStyle {\n-    Compact,\n-    Fancy,\n-}\n-\n-impl MarkdownOutputStyle {\n-    pub fn is_compact(&self) -> bool {\n-        match *self {\n-            MarkdownOutputStyle::Compact => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_fancy(&self) -> bool {\n-        match *self {\n-            MarkdownOutputStyle::Fancy => true,\n-            _ => false,\n-        }\n-    }\n-}\n+use pulldown_cmark::{html, Event, Tag, Parser};\n+use pulldown_cmark::{Options, OPTION_ENABLE_FOOTNOTES, OPTION_ENABLE_TABLES};\n \n /// A unit struct which has the `fmt::Display` trait implemented. When\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n // The second parameter is whether we need a shorter version or not.\n-pub struct Markdown<'a>(pub &'a str, pub MarkdownOutputStyle);\n+pub struct Markdown<'a>(pub &'a str);\n /// A unit struct like `Markdown`, that renders the markdown with a\n /// table of contents.\n pub struct MarkdownWithToc<'a>(pub &'a str);\n /// A unit struct like `Markdown`, that renders the markdown escaping HTML tags.\n pub struct MarkdownHtml<'a>(pub &'a str);\n+/// A unit struct like `Markdown`, that renders only the first paragraph.\n+pub struct MarkdownSummaryLine<'a>(pub &'a str);\n \n /// Returns Some(code) if `s` is a line that should be stripped from\n /// documentation but used in example code. `code` is the portion of\n@@ -90,12 +70,21 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n     }\n }\n \n-/// Returns a new string with all consecutive whitespace collapsed into\n-/// single spaces.\n+/// Convert chars from a title for an id.\n ///\n-/// Any leading or trailing whitespace will be trimmed.\n-fn collapse_whitespace(s: &str) -> String {\n-    s.split_whitespace().collect::<Vec<_>>().join(\" \")\n+/// \"Hello, world!\" -> \"hello-world\"\n+fn slugify(c: char) -> Option<char> {\n+    if c.is_alphanumeric() || c == '-' || c == '_' {\n+        if c.is_ascii() {\n+            Some(c.to_ascii_lowercase())\n+        } else {\n+            Some(c)\n+        }\n+    } else if c.is_whitespace() && c.is_ascii() {\n+        Some('-')\n+    } else {\n+        None\n+    }\n }\n \n // Information about the playground if a URL has been specified, containing an\n@@ -104,103 +93,50 @@ thread_local!(pub static PLAYGROUND: RefCell<Option<(Option<String>, String)>> =\n     RefCell::new(None)\n });\n \n-macro_rules! event_loop_break {\n-    ($parser:expr, $toc_builder:expr, $shorter:expr, $buf:expr, $escape:expr, $id:expr,\n-     $($end_event:pat)|*) => {{\n-        fn inner(id: &mut Option<&mut String>, s: &str) {\n-            if let Some(ref mut id) = *id {\n-                id.push_str(s);\n-            }\n-        }\n-        while let Some(event) = $parser.next() {\n-            match event {\n-                $($end_event)|* => break,\n-                Event::Text(ref s) => {\n-                    debug!(\"Text\");\n-                    inner($id, s);\n-                    if $escape {\n-                        $buf.push_str(&format!(\"{}\", Escape(s)));\n-                    } else {\n-                        $buf.push_str(s);\n-                    }\n-                }\n-                Event::SoftBreak => {\n-                    debug!(\"SoftBreak\");\n-                    if !$buf.is_empty() {\n-                        $buf.push(' ');\n-                    }\n-                }\n-                x => {\n-                    looper($parser, &mut $buf, Some(x), $toc_builder, $shorter, $id);\n-                }\n-            }\n-        }\n-    }}\n-}\n-\n-struct ParserWrapper<'a> {\n-    parser: Parser<'a>,\n-    // The key is the footnote reference. The value is the footnote definition and the id.\n-    footnotes: HashMap<String, (String, u16)>,\n+/// Adds syntax highlighting and playground Run buttons to rust code blocks.\n+struct CodeBlocks<'a, I: Iterator<Item = Event<'a>>> {\n+    inner: I,\n }\n \n-impl<'a> ParserWrapper<'a> {\n-    pub fn new(s: &'a str) -> ParserWrapper<'a> {\n-        ParserWrapper {\n-            parser: Parser::new_ext(s, pulldown_cmark::OPTION_ENABLE_TABLES |\n-                                       pulldown_cmark::OPTION_ENABLE_FOOTNOTES),\n-            footnotes: HashMap::new(),\n+impl<'a, I: Iterator<Item = Event<'a>>> CodeBlocks<'a, I> {\n+    fn new(iter: I) -> Self {\n+        CodeBlocks {\n+            inner: iter,\n         }\n     }\n+}\n \n-    pub fn next(&mut self) -> Option<Event<'a>> {\n-        self.parser.next()\n-    }\n+impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n+    type Item = Event<'a>;\n \n-    pub fn get_entry(&mut self, key: &str) -> &mut (String, u16) {\n-        let new_id = self.footnotes.keys().count() + 1;\n-        let key = key.to_owned();\n-        self.footnotes.entry(key).or_insert((String::new(), new_id as u16))\n-    }\n-}\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let event = self.inner.next();\n+        if let Some(Event::Start(Tag::CodeBlock(lang))) = event {\n+            if !LangString::parse(&lang).rust {\n+                return Some(Event::Start(Tag::CodeBlock(lang)));\n+            }\n+        } else {\n+            return event;\n+        }\n \n-pub fn render(w: &mut fmt::Formatter,\n-              s: &str,\n-              print_toc: bool,\n-              shorter: MarkdownOutputStyle) -> fmt::Result {\n-    fn code_block(parser: &mut ParserWrapper, buffer: &mut String, lang: &str) {\n-        debug!(\"CodeBlock\");\n         let mut origtext = String::new();\n-        while let Some(event) = parser.next() {\n+        for event in &mut self.inner {\n             match event {\n-                Event::End(Tag::CodeBlock(_)) => break,\n+                Event::End(Tag::CodeBlock(..)) => break,\n                 Event::Text(ref s) => {\n                     origtext.push_str(s);\n                 }\n                 _ => {}\n             }\n         }\n-        let origtext = origtext.trim_left();\n-        debug!(\"docblock: ==============\\n{:?}\\n=======\", origtext);\n-\n         let lines = origtext.lines().filter(|l| {\n             stripped_filtered_line(*l).is_none()\n         });\n         let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n-        let block_info = if lang.is_empty() {\n-            LangString::all_false()\n-        } else {\n-            LangString::parse(lang)\n-        };\n-        if !block_info.rust {\n-            buffer.push_str(&format!(\"<pre><code class=\\\"language-{}\\\">{}</code></pre>\",\n-                            lang, text));\n-            return\n-        }\n         PLAYGROUND.with(|play| {\n             // insert newline to clearly separate it from the\n             // previous block so we can shorten the html output\n-            buffer.push('\\n');\n+            let mut s = String::from(\"\\n\");\n             let playground_button = play.borrow().as_ref().and_then(|&(ref krate, ref url)| {\n                 if url.is_empty() {\n                     return None;\n@@ -210,7 +146,7 @@ pub fn render(w: &mut fmt::Formatter,\n                 }).collect::<Vec<&str>>().join(\"\\n\");\n                 let krate = krate.as_ref().map(|s| &**s);\n                 let test = test::maketest(&test, krate, false,\n-                                          &Default::default());\n+                                        &Default::default());\n                 let channel = if test.contains(\"#![feature(\") {\n                     \"&amp;version=nightly\"\n                 } else {\n@@ -239,376 +175,186 @@ pub fn render(w: &mut fmt::Formatter,\n                     url, test_escaped, channel\n                 ))\n             });\n-            buffer.push_str(&highlight::render_with_highlighting(\n-                            &text,\n-                            Some(\"rust-example-rendered\"),\n-                            None,\n-                            playground_button.as_ref().map(String::as_str)));\n-        });\n-    }\n-\n-    fn heading(parser: &mut ParserWrapper, buffer: &mut String,\n-               toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle, level: i32) {\n-        debug!(\"Heading\");\n-        let mut ret = String::new();\n-        let mut id = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, ret, true, &mut Some(&mut id),\n-                          Event::End(Tag::Header(_)));\n-        ret = ret.trim_right().to_owned();\n-\n-        let id = id.chars().filter_map(|c| {\n-            if c.is_alphanumeric() || c == '-' || c == '_' {\n-                if c.is_ascii() {\n-                    Some(c.to_ascii_lowercase())\n-                } else {\n-                    Some(c)\n-                }\n-            } else if c.is_whitespace() && c.is_ascii() {\n-                Some('-')\n-            } else {\n-                None\n-            }\n-        }).collect::<String>();\n-\n-        let id = derive_id(id);\n-\n-        let sec = toc_builder.as_mut().map_or(\"\".to_owned(), |builder| {\n-            format!(\"{} \", builder.push(level as u32, ret.clone(), id.clone()))\n-        });\n-\n-        // Render the HTML\n-        buffer.push_str(&format!(\"<h{lvl} id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n-                                  <a href=\\\"#{id}\\\">{sec}{}</a></h{lvl}>\",\n-                                 ret, lvl = level, id = id, sec = sec));\n+            s.push_str(&highlight::render_with_highlighting(\n+                        &text,\n+                        Some(\"rust-example-rendered\"),\n+                        None,\n+                        playground_button.as_ref().map(String::as_str)));\n+            Some(Event::Html(s.into()))\n+        })\n     }\n+}\n \n-    fn inline_code(parser: &mut ParserWrapper, buffer: &mut String,\n-                   toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle,\n-                   id: &mut Option<&mut String>) {\n-        debug!(\"InlineCode\");\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, false, id, Event::End(Tag::Code));\n-        buffer.push_str(&format!(\"<code>{}</code>\",\n-                                 Escape(&collapse_whitespace(content.trim_right()))));\n-    }\n+/// Make headings links with anchor ids and build up TOC.\n+struct HeadingLinks<'a, 'b, I: Iterator<Item = Event<'a>>> {\n+    inner: I,\n+    toc: Option<&'b mut TocBuilder>,\n+    buf: VecDeque<Event<'a>>,\n+}\n \n-    fn link(parser: &mut ParserWrapper, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-            shorter: MarkdownOutputStyle, url: &str, title: &str,\n-            id: &mut Option<&mut String>) {\n-        debug!(\"Link\");\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, true, id,\n-                          Event::End(Tag::Link(_, _)));\n-        if title.is_empty() {\n-            buffer.push_str(&format!(\"<a href=\\\"{}\\\">{}</a>\", url, content));\n-        } else {\n-            buffer.push_str(&format!(\"<a href=\\\"{}\\\" title=\\\"{}\\\">{}</a>\",\n-                                     url, Escape(title), content));\n+impl<'a, 'b, I: Iterator<Item = Event<'a>>> HeadingLinks<'a, 'b, I> {\n+    fn new(iter: I, toc: Option<&'b mut TocBuilder>) -> Self {\n+        HeadingLinks {\n+            inner: iter,\n+            toc: toc,\n+            buf: VecDeque::new(),\n         }\n     }\n+}\n \n-    fn image(parser: &mut ParserWrapper, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-            shorter: MarkdownOutputStyle, url: &str, mut title: String,\n-            id: &mut Option<&mut String>) {\n-        debug!(\"Image\");\n-        event_loop_break!(parser, toc_builder, shorter, title, true, id,\n-                          Event::End(Tag::Image(_, _)));\n-        buffer.push_str(&format!(\"<img src=\\\"{}\\\" alt=\\\"{}\\\">\", url, title));\n-    }\n-\n-    fn paragraph(parser: &mut ParserWrapper, buffer: &mut String,\n-                 toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle,\n-                 id: &mut Option<&mut String>) {\n-        debug!(\"Paragraph\");\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, true, id,\n-                          Event::End(Tag::Paragraph));\n-        buffer.push_str(&format!(\"<p>{}</p>\", content.trim_right()));\n-    }\n-\n-    fn table_cell(parser: &mut ParserWrapper, buffer: &mut String,\n-                  toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle) {\n-        debug!(\"TableCell\");\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, true, &mut None,\n-                          Event::End(Tag::TableHead) |\n-                              Event::End(Tag::Table(_)) |\n-                              Event::End(Tag::TableRow) |\n-                              Event::End(Tag::TableCell));\n-        buffer.push_str(&format!(\"<td>{}</td>\", content.trim()));\n-    }\n+impl<'a, 'b, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a, 'b, I> {\n+    type Item = Event<'a>;\n \n-    fn table_row(parser: &mut ParserWrapper, buffer: &mut String,\n-                 toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle) {\n-        debug!(\"TableRow\");\n-        let mut content = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::TableHead) |\n-                    Event::End(Tag::Table(_)) |\n-                    Event::End(Tag::TableRow) => break,\n-                Event::Start(Tag::TableCell) => {\n-                    table_cell(parser, &mut content, toc_builder, shorter);\n-                }\n-                x => {\n-                    looper(parser, &mut content, Some(x), toc_builder, shorter, &mut None);\n-                }\n-            }\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if let Some(e) = self.buf.pop_front() {\n+            return Some(e);\n         }\n-        buffer.push_str(&format!(\"<tr>{}</tr>\", content));\n-    }\n \n-    fn table_head(parser: &mut ParserWrapper, buffer: &mut String,\n-                  toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle) {\n-        debug!(\"TableHead\");\n-        let mut content = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::TableHead) | Event::End(Tag::Table(_)) => break,\n-                Event::Start(Tag::TableCell) => {\n-                    table_cell(parser, &mut content, toc_builder, shorter);\n-                }\n-                x => {\n-                    looper(parser, &mut content, Some(x), toc_builder, shorter, &mut None);\n+        let event = self.inner.next();\n+        if let Some(Event::Start(Tag::Header(level))) = event {\n+            let mut id = String::new();\n+            for event in &mut self.inner {\n+                match event {\n+                    Event::End(Tag::Header(..)) => break,\n+                    Event::Text(ref text) => id.extend(text.chars().filter_map(slugify)),\n+                    _ => {},\n                 }\n+                self.buf.push_back(event);\n             }\n-        }\n-        if !content.is_empty() {\n-            buffer.push_str(&format!(\"<thead><tr>{}</tr></thead>\", content.replace(\"td>\", \"th>\")));\n-        }\n-    }\n+            let id = derive_id(id);\n \n-    fn table(parser: &mut ParserWrapper, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-             shorter: MarkdownOutputStyle) {\n-        debug!(\"Table\");\n-        let mut content = String::new();\n-        let mut rows = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::Table(_)) => break,\n-                Event::Start(Tag::TableHead) => {\n-                    table_head(parser, &mut content, toc_builder, shorter);\n-                }\n-                Event::Start(Tag::TableRow) => {\n-                    table_row(parser, &mut rows, toc_builder, shorter);\n-                }\n-                _ => {}\n+            if let Some(ref mut builder) = self.toc {\n+                let mut html_header = String::new();\n+                html::push_html(&mut html_header, self.buf.iter().cloned());\n+                let sec = builder.push(level as u32, html_header, id.clone());\n+                self.buf.push_front(Event::InlineHtml(format!(\"{} \", sec).into()));\n             }\n-        }\n-        buffer.push_str(&format!(\"<table>{}{}</table>\",\n-                                 content,\n-                                 if shorter.is_compact() || rows.is_empty() {\n-                                     String::new()\n-                                 } else {\n-                                     format!(\"<tbody>{}</tbody>\", rows)\n-                                 }));\n-    }\n \n-    fn blockquote(parser: &mut ParserWrapper, buffer: &mut String,\n-                  toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle) {\n-        debug!(\"BlockQuote\");\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, true, &mut None,\n-                          Event::End(Tag::BlockQuote));\n-        buffer.push_str(&format!(\"<blockquote>{}</blockquote>\", content.trim_right()));\n-    }\n+            self.buf.push_back(Event::InlineHtml(format!(\"</a></h{}>\", level).into()));\n \n-    fn list_item(parser: &mut ParserWrapper, buffer: &mut String,\n-                 toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle) {\n-        debug!(\"ListItem\");\n-        let mut content = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::Item) => break,\n-                Event::Text(ref s) => {\n-                    content.push_str(&format!(\"{}\", Escape(s)));\n-                }\n-                x => {\n-                    looper(parser, &mut content, Some(x), toc_builder, shorter, &mut None);\n-                }\n-            }\n-            if shorter.is_compact() {\n-                break\n-            }\n+            let start_tags = format!(\"<h{level} id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n+                                      <a href=\\\"#{id}\\\">\",\n+                                     id = id,\n+                                     level = level);\n+            return Some(Event::InlineHtml(start_tags.into()));\n         }\n-        buffer.push_str(&format!(\"<li>{}</li>\", content));\n+        event\n     }\n+}\n \n-    fn list(parser: &mut ParserWrapper, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-            shorter: MarkdownOutputStyle, is_sorted_list: bool) {\n-        debug!(\"List\");\n-        let mut content = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::List(_)) => break,\n-                Event::Start(Tag::Item) => {\n-                    list_item(parser, &mut content, toc_builder, shorter);\n-                }\n-                x => {\n-                    looper(parser, &mut content, Some(x), toc_builder, shorter, &mut None);\n-                }\n-            }\n-            if shorter.is_compact() {\n-                break\n-            }\n+/// Extracts just the first paragraph.\n+struct SummaryLine<'a, I: Iterator<Item = Event<'a>>> {\n+    inner: I,\n+    started: bool,\n+    depth: u32,\n+}\n+\n+impl<'a, I: Iterator<Item = Event<'a>>> SummaryLine<'a, I> {\n+    fn new(iter: I) -> Self {\n+        SummaryLine {\n+            inner: iter,\n+            started: false,\n+            depth: 0,\n         }\n-        buffer.push_str(&format!(\"<{0}>{1}</{0}>\",\n-                                 if is_sorted_list { \"ol\" } else { \"ul\" },\n-                                 content));\n     }\n+}\n \n-    fn emphasis(parser: &mut ParserWrapper, buffer: &mut String,\n-                toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle,\n-                id: &mut Option<&mut String>) {\n-        debug!(\"Emphasis\");\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, false, id,\n-                          Event::End(Tag::Emphasis));\n-        buffer.push_str(&format!(\"<em>{}</em>\", content));\n-    }\n+impl<'a, I: Iterator<Item = Event<'a>>> Iterator for SummaryLine<'a, I> {\n+    type Item = Event<'a>;\n \n-    fn strong(parser: &mut ParserWrapper, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-              shorter: MarkdownOutputStyle, id: &mut Option<&mut String>) {\n-        debug!(\"Strong\");\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, false, id,\n-                          Event::End(Tag::Strong));\n-        buffer.push_str(&format!(\"<strong>{}</strong>\", content));\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.started && self.depth == 0 {\n+            return None;\n+        }\n+        if !self.started {\n+            self.started = true;\n+        }\n+        let event = self.inner.next();\n+        match event {\n+            Some(Event::Start(..)) => self.depth += 1,\n+            Some(Event::End(..)) => self.depth -= 1,\n+            _ => {}\n+        }\n+        event\n     }\n+}\n \n-    fn footnote(parser: &mut ParserWrapper, buffer: &mut String,\n-                toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle,\n-                id: &mut Option<&mut String>) {\n-        debug!(\"FootnoteDefinition\");\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, true, id,\n-                          Event::End(Tag::FootnoteDefinition(_)));\n-        buffer.push_str(&content);\n-    }\n+/// Moves all footnote definitions to the end and add back links to the\n+/// references.\n+struct Footnotes<'a, I: Iterator<Item = Event<'a>>> {\n+    inner: I,\n+    footnotes: HashMap<String, (Vec<Event<'a>>, u16)>,\n+}\n \n-    fn rule(parser: &mut ParserWrapper, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-            shorter: MarkdownOutputStyle, id: &mut Option<&mut String>) {\n-        debug!(\"Rule\");\n-        let mut content = String::new();\n-        event_loop_break!(parser, toc_builder, shorter, content, true, id,\n-                          Event::End(Tag::Rule));\n-        buffer.push_str(\"<hr>\");\n+impl<'a, I: Iterator<Item = Event<'a>>> Footnotes<'a, I> {\n+    fn new(iter: I) -> Self {\n+        Footnotes {\n+            inner: iter,\n+            footnotes: HashMap::new(),\n+        }\n+    }\n+    fn get_entry(&mut self, key: &str) -> &mut (Vec<Event<'a>>, u16) {\n+        let new_id = self.footnotes.keys().count() + 1;\n+        let key = key.to_owned();\n+        self.footnotes.entry(key).or_insert((Vec::new(), new_id as u16))\n     }\n+}\n \n-    fn looper<'a>(parser: &'a mut ParserWrapper, buffer: &mut String, next_event: Option<Event<'a>>,\n-                  toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle,\n-                  id: &mut Option<&mut String>) -> bool {\n-        if let Some(event) = next_event {\n-            match event {\n-                Event::Start(Tag::CodeBlock(lang)) => {\n-                    code_block(parser, buffer, &*lang);\n-                }\n-                Event::Start(Tag::Header(level)) => {\n-                    heading(parser, buffer, toc_builder, shorter, level);\n-                }\n-                Event::Start(Tag::Code) => {\n-                    inline_code(parser, buffer, toc_builder, shorter, id);\n-                }\n-                Event::Start(Tag::Paragraph) => {\n-                    paragraph(parser, buffer, toc_builder, shorter, id);\n-                }\n-                Event::Start(Tag::Link(ref url, ref t)) => {\n-                    link(parser, buffer, toc_builder, shorter, url, t.as_ref(), id);\n-                }\n-                Event::Start(Tag::Image(ref url, ref t)) => {\n-                    image(parser, buffer, toc_builder, shorter, url, t.as_ref().to_owned(), id);\n-                }\n-                Event::Start(Tag::Table(_)) => {\n-                    table(parser, buffer, toc_builder, shorter);\n-                }\n-                Event::Start(Tag::BlockQuote) => {\n-                    blockquote(parser, buffer, toc_builder, shorter);\n-                }\n-                Event::Start(Tag::List(x)) => {\n-                    list(parser, buffer, toc_builder, shorter, x.is_some());\n-                }\n-                Event::Start(Tag::Emphasis) => {\n-                    emphasis(parser, buffer, toc_builder, shorter, id);\n-                }\n-                Event::Start(Tag::Strong) => {\n-                    strong(parser, buffer, toc_builder, shorter, id);\n-                }\n-                Event::Start(Tag::Rule) => {\n-                    rule(parser, buffer, toc_builder, shorter, id);\n-                }\n-                Event::Start(Tag::FootnoteDefinition(ref def)) => {\n-                    debug!(\"FootnoteDefinition\");\n-                    let mut content = String::new();\n-                    let def = def.as_ref();\n-                    footnote(parser, &mut content, toc_builder, shorter, id);\n-                    let entry = parser.get_entry(def);\n-                    let cur_id = (*entry).1;\n-                    (*entry).0.push_str(&format!(\"<li id=\\\"ref{}\\\">{}&nbsp;<a href=\\\"#supref{0}\\\" \\\n-                                                  rev=\\\"footnote\\\">\u21a9</a></p></li>\",\n-                                                 cur_id,\n-                                                 if content.ends_with(\"</p>\") {\n-                                                     &content[..content.len() - 4]\n-                                                 } else {\n-                                                     &content\n-                                                 }));\n-                }\n-                Event::FootnoteReference(ref reference) => {\n-                    debug!(\"FootnoteReference\");\n-                    let entry = parser.get_entry(reference.as_ref());\n-                    buffer.push_str(&format!(\"<sup id=\\\"supref{0}\\\"><a href=\\\"#ref{0}\\\">{0}</a>\\\n-                                              </sup>\",\n-                                             (*entry).1));\n-                }\n-                Event::HardBreak => {\n-                    debug!(\"HardBreak\");\n-                    if shorter.is_fancy() {\n-                        buffer.push_str(\"<br>\");\n-                    } else if !buffer.is_empty() {\n-                        buffer.push(' ');\n+impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n+    type Item = Event<'a>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        loop {\n+            match self.inner.next() {\n+                Some(Event::FootnoteReference(ref reference)) => {\n+                    let entry = self.get_entry(&reference);\n+                    let reference = format!(\"<sup id=\\\"supref{0}\\\"><a href=\\\"#ref{0}\\\">{0}\\\n+                                             </a></sup>\",\n+                                            (*entry).1);\n+                    return Some(Event::Html(reference.into()));\n+                }\n+                Some(Event::Start(Tag::FootnoteDefinition(def))) => {\n+                    let mut content = Vec::new();\n+                    for event in &mut self.inner {\n+                        if let Event::End(Tag::FootnoteDefinition(..)) = event {\n+                            break;\n+                        }\n+                        content.push(event);\n+                    }\n+                    let entry = self.get_entry(&def);\n+                    (*entry).0 = content;\n+                }\n+                Some(e) => return Some(e),\n+                None => {\n+                    if !self.footnotes.is_empty() {\n+                        let mut v: Vec<_> = self.footnotes.drain().map(|(_, x)| x).collect();\n+                        v.sort_by(|a, b| a.1.cmp(&b.1));\n+                        let mut ret = String::from(\"<div class=\\\"footnotes\\\"><hr><ol>\");\n+                        for (mut content, id) in v {\n+                            write!(ret, \"<li id=\\\"ref{}\\\">\", id).unwrap();\n+                            let mut is_paragraph = false;\n+                            if let Some(&Event::End(Tag::Paragraph)) = content.last() {\n+                                content.pop();\n+                                is_paragraph = true;\n+                            }\n+                            html::push_html(&mut ret, content.into_iter());\n+                            write!(ret,\n+                                   \"&nbsp;<a href=\\\"#supref{}\\\" rev=\\\"footnote\\\">\u21a9</a>\",\n+                                   id).unwrap();\n+                            if is_paragraph {\n+                                ret.push_str(\"</p>\");\n+                            }\n+                            ret.push_str(\"</li>\");\n+                        }\n+                        ret.push_str(\"</ol></div>\");\n+                        return Some(Event::Html(ret.into()));\n+                    } else {\n+                        return None;\n                     }\n                 }\n-                Event::Html(h) | Event::InlineHtml(h) => {\n-                    debug!(\"Html/InlineHtml\");\n-                    buffer.push_str(&*h);\n-                }\n-                _ => {}\n             }\n-            shorter.is_fancy()\n-        } else {\n-            false\n         }\n     }\n-\n-    let mut toc_builder = if print_toc {\n-        Some(TocBuilder::new())\n-    } else {\n-        None\n-    };\n-    let mut buffer = String::new();\n-    let mut parser = ParserWrapper::new(s);\n-    loop {\n-        let next_event = parser.next();\n-        if !looper(&mut parser, &mut buffer, next_event, &mut toc_builder, shorter, &mut None) {\n-            break\n-        }\n-    }\n-    if !parser.footnotes.is_empty() {\n-        let mut v: Vec<_> = parser.footnotes.values().collect();\n-        v.sort_by(|a, b| a.1.cmp(&b.1));\n-        buffer.push_str(&format!(\"<div class=\\\"footnotes\\\"><hr><ol>{}</ol></div>\",\n-                                 v.iter()\n-                                  .map(|s| s.0.as_str())\n-                                  .collect::<Vec<_>>()\n-                                  .join(\"\")));\n-    }\n-    let mut ret = toc_builder.map_or(Ok(()), |builder| {\n-        write!(w, \"<nav id=\\\"TOC\\\">{}</nav>\", builder.into_toc())\n-    });\n-\n-    if ret.is_ok() {\n-        ret = w.write_str(&buffer);\n-    }\n-    ret\n }\n \n pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Span) {\n@@ -755,17 +501,45 @@ impl LangString {\n \n impl<'a> fmt::Display for Markdown<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let Markdown(md, shorter) = *self;\n+        let Markdown(md) = *self;\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n-        render(fmt, md, false, shorter)\n+\n+        let mut opts = Options::empty();\n+        opts.insert(OPTION_ENABLE_TABLES);\n+        opts.insert(OPTION_ENABLE_FOOTNOTES);\n+\n+        let p = Parser::new_ext(md, opts);\n+\n+        let mut s = String::with_capacity(md.len() * 3 / 2);\n+\n+        html::push_html(&mut s,\n+                        Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, None))));\n+\n+        fmt.write_str(&s)\n     }\n }\n \n impl<'a> fmt::Display for MarkdownWithToc<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let MarkdownWithToc(md) = *self;\n-        render(fmt, md, true, MarkdownOutputStyle::Fancy)\n+\n+        let mut opts = Options::empty();\n+        opts.insert(OPTION_ENABLE_TABLES);\n+        opts.insert(OPTION_ENABLE_FOOTNOTES);\n+\n+        let p = Parser::new_ext(md, opts);\n+\n+        let mut s = String::with_capacity(md.len() * 3 / 2);\n+\n+        let mut toc = TocBuilder::new();\n+\n+        html::push_html(&mut s,\n+                        Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, Some(&mut toc)))));\n+\n+        write!(fmt, \"<nav id=\\\"TOC\\\">{}</nav>\", toc.into_toc())?;\n+\n+        fmt.write_str(&s)\n     }\n }\n \n@@ -774,7 +548,41 @@ impl<'a> fmt::Display for MarkdownHtml<'a> {\n         let MarkdownHtml(md) = *self;\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n-        render(fmt, md, false, MarkdownOutputStyle::Fancy)\n+\n+        let mut opts = Options::empty();\n+        opts.insert(OPTION_ENABLE_TABLES);\n+        opts.insert(OPTION_ENABLE_FOOTNOTES);\n+\n+        let p = Parser::new_ext(md, opts);\n+\n+        // Treat inline HTML as plain text.\n+        let p = p.map(|event| match event {\n+            Event::Html(text) | Event::InlineHtml(text) => Event::Text(text),\n+            _ => event\n+        });\n+\n+        let mut s = String::with_capacity(md.len() * 3 / 2);\n+\n+        html::push_html(&mut s,\n+                        Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, None))));\n+\n+        fmt.write_str(&s)\n+    }\n+}\n+\n+impl<'a> fmt::Display for MarkdownSummaryLine<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let MarkdownSummaryLine(md) = *self;\n+        // This is actually common enough to special-case\n+        if md.is_empty() { return Ok(()) }\n+\n+        let p = Parser::new(md);\n+\n+        let mut s = String::new();\n+\n+        html::push_html(&mut s, SummaryLine::new(p));\n+\n+        fmt.write_str(&s)\n     }\n }\n \n@@ -796,14 +604,10 @@ pub fn plain_summary_line(md: &str) -> String {\n             let next_event = next_event.unwrap();\n             let (ret, is_in) = match next_event {\n                 Event::Start(Tag::Paragraph) => (None, 1),\n-                Event::Start(Tag::Link(_, ref t)) if !self.is_first => {\n-                    (Some(t.as_ref().to_owned()), 1)\n-                }\n                 Event::Start(Tag::Code) => (Some(\"`\".to_owned()), 1),\n                 Event::End(Tag::Code) => (Some(\"`\".to_owned()), -1),\n                 Event::Start(Tag::Header(_)) => (None, 1),\n                 Event::Text(ref s) if self.is_in > 0 => (Some(s.as_ref().to_owned()), 0),\n-                Event::End(Tag::Link(_, ref t)) => (Some(t.as_ref().to_owned()), -1),\n                 Event::End(Tag::Paragraph) | Event::End(Tag::Header(_)) => (None, -1),\n                 _ => (None, 0),\n             };\n@@ -834,7 +638,7 @@ pub fn plain_summary_line(md: &str) -> String {\n \n #[cfg(test)]\n mod tests {\n-    use super::{LangString, Markdown, MarkdownHtml, MarkdownOutputStyle};\n+    use super::{LangString, Markdown, MarkdownHtml};\n     use super::plain_summary_line;\n     use html::render::reset_ids;\n \n@@ -874,14 +678,14 @@ mod tests {\n     #[test]\n     fn issue_17736() {\n         let markdown = \"# title\";\n-        format!(\"{}\", Markdown(markdown, MarkdownOutputStyle::Fancy));\n+        format!(\"{}\", Markdown(markdown));\n         reset_ids(true);\n     }\n \n     #[test]\n     fn test_header() {\n         fn t(input: &str, expect: &str) {\n-            let output = format!(\"{}\", Markdown(input, MarkdownOutputStyle::Fancy));\n+            let output = format!(\"{}\", Markdown(input));\n             assert_eq!(output, expect, \"original: {}\", input);\n             reset_ids(true);\n         }\n@@ -903,7 +707,7 @@ mod tests {\n     #[test]\n     fn test_header_ids_multiple_blocks() {\n         fn t(input: &str, expect: &str) {\n-            let output = format!(\"{}\", Markdown(input, MarkdownOutputStyle::Fancy));\n+            let output = format!(\"{}\", Markdown(input));\n             assert_eq!(output, expect, \"original: {}\", input);\n         }\n \n@@ -934,6 +738,7 @@ mod tests {\n         }\n \n         t(\"hello [Rust](https://www.rust-lang.org) :)\", \"hello Rust :)\");\n+        t(\"hello [Rust](https://www.rust-lang.org \\\"Rust\\\") :)\", \"hello Rust :)\");\n         t(\"code `let x = i32;` ...\", \"code `let x = i32;` ...\");\n         t(\"type `Type<'static>` ...\", \"type `Type<'static>` ...\");\n         t(\"# top header\", \"top header\");\n@@ -947,7 +752,8 @@ mod tests {\n             assert_eq!(output, expect, \"original: {}\", input);\n         }\n \n-        t(\"`Struct<'a, T>`\", \"<p><code>Struct&lt;&#39;a, T&gt;</code></p>\");\n-        t(\"Struct<'a, T>\", \"<p>Struct&lt;&#39;a, T&gt;</p>\");\n+        t(\"`Struct<'a, T>`\", \"<p><code>Struct&lt;'a, T&gt;</code></p>\\n\");\n+        t(\"Struct<'a, T>\", \"<p>Struct&lt;'a, T&gt;</p>\\n\");\n+        t(\"Struct<br>\", \"<p>Struct&lt;br&gt;</p>\\n\");\n     }\n }"}, {"sha": "1e1202f04005cdd3ccdb0b3b15b484c39b868b1e", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f9fb381b2a13260c3fcdae2f6d9546ab2c87e717/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fb381b2a13260c3fcdae2f6d9546ab2c87e717/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=f9fb381b2a13260c3fcdae2f6d9546ab2c87e717", "patch": "@@ -72,7 +72,7 @@ use html::format::{TyParamBounds, WhereClause, href, AbiSpace};\n use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace};\n use html::format::fmt_impl_for_trait_page;\n use html::item_type::ItemType;\n-use html::markdown::{self, Markdown, MarkdownHtml, MarkdownOutputStyle};\n+use html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine};\n use html::{highlight, layout};\n \n /// A pair of name and its optional document.\n@@ -1651,7 +1651,7 @@ fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLin\n             format!(\"{}\", &plain_summary_line(Some(s)))\n         };\n         write!(w, \"<div class='docblock'>{}</div>\",\n-               Markdown(&markdown, MarkdownOutputStyle::Fancy))?;\n+               Markdown(&markdown))?;\n     }\n     Ok(())\n }\n@@ -1684,8 +1684,7 @@ fn get_doc_value(item: &clean::Item) -> Option<&str> {\n fn document_full(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n     if let Some(s) = get_doc_value(item) {\n         write!(w, \"<div class='docblock'>{}</div>\",\n-               Markdown(&format!(\"{}{}\", md_render_assoc_item(item), s),\n-                                 MarkdownOutputStyle::Fancy))?;\n+               Markdown(&format!(\"{}{}\", md_render_assoc_item(item), s)))?;\n     }\n     Ok(())\n }\n@@ -1873,8 +1872,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                        </tr>\",\n                        name = *myitem.name.as_ref().unwrap(),\n                        stab_docs = stab_docs,\n-                       docs = shorter(Some(&Markdown(doc_value,\n-                                                     MarkdownOutputStyle::Compact).to_string())),\n+                       docs = MarkdownSummaryLine(doc_value),\n                        class = myitem.type_(),\n                        stab = myitem.stability_class().unwrap_or(\"\".to_string()),\n                        unsafety_flag = unsafety_flag,\n@@ -2904,7 +2902,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         write!(w, \"</span>\")?;\n         write!(w, \"</h3>\\n\")?;\n         if let Some(ref dox) = i.impl_item.doc_value() {\n-            write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox, MarkdownOutputStyle::Fancy))?;\n+            write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox))?;\n         }\n     }\n "}, {"sha": "5fadda030a4b41c5bc7798375ae6848694a3dbba", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fb381b2a13260c3fcdae2f6d9546ab2c87e717/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fb381b2a13260c3fcdae2f6d9546ab2c87e717/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=f9fb381b2a13260c3fcdae2f6d9546ab2c87e717", "patch": "@@ -25,7 +25,7 @@ use externalfiles::{ExternalHtml, LoadStringError, load_string};\n use html::render::reset_ids;\n use html::escape::Escape;\n use html::markdown;\n-use html::markdown::{Markdown, MarkdownWithToc, MarkdownOutputStyle, find_testable_code};\n+use html::markdown::{Markdown, MarkdownWithToc, find_testable_code};\n use test::{TestOptions, Collector};\n \n /// Separate any lines at the start of the file that begin with `# ` or `%`.\n@@ -96,7 +96,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n     let rendered = if include_toc {\n         format!(\"{}\", MarkdownWithToc(text))\n     } else {\n-        format!(\"{}\", Markdown(text, MarkdownOutputStyle::Fancy))\n+        format!(\"{}\", Markdown(text))\n     };\n \n     let err = write!("}, {"sha": "f048b64d104abc82ab7e60521c05884c86506ee6", "filename": "src/test/rustdoc/check-hard-break.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9fb381b2a13260c3fcdae2f6d9546ab2c87e717/src%2Ftest%2Frustdoc%2Fcheck-hard-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fb381b2a13260c3fcdae2f6d9546ab2c87e717/src%2Ftest%2Frustdoc%2Fcheck-hard-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcheck-hard-break.rs?ref=f9fb381b2a13260c3fcdae2f6d9546ab2c87e717", "patch": "@@ -13,7 +13,8 @@\n // ignore-tidy-end-whitespace\n \n // @has foo/fn.f.html\n-// @has - '<p>hard break:<br>after hard break</p>'\n+// @has - '<p>hard break:<br />'\n+// @has - 'after hard break</p>'\n /// hard break:  \n /// after hard break\n pub fn f() {}"}, {"sha": "46542677857fc797cc0461d335502f13d25a45ad", "filename": "src/test/rustdoc/check-rule-image-footnote.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9fb381b2a13260c3fcdae2f6d9546ab2c87e717/src%2Ftest%2Frustdoc%2Fcheck-rule-image-footnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fb381b2a13260c3fcdae2f6d9546ab2c87e717/src%2Ftest%2Frustdoc%2Fcheck-rule-image-footnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcheck-rule-image-footnote.rs?ref=f9fb381b2a13260c3fcdae2f6d9546ab2c87e717", "patch": "@@ -13,16 +13,21 @@\n // ignore-tidy-linelength\n \n // @has foo/fn.f.html\n-// @has - '<p>markdown test</p><p>this is a <a href=\"https://example.com\" title=\"this is a title\">link</a>.</p><p>hard break: after hard break</p><hr><p>a footnote<sup id=\"supref1\"><a href=\"#ref1\">1</a></sup>.</p><p>another footnote<sup id=\"supref2\"><a href=\"#ref2\">2</a></sup>.</p><p><img src=\"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\" alt=\"Rust\"></p><div class=\"footnotes\"><hr><ol><li id=\"ref1\"><p>Thing&nbsp;<a href=\"#supref1\" rev=\"footnote\">\u21a9</a></p></li><li id=\"ref2\"><p>Another Thing&nbsp;<a href=\"#supref2\" rev=\"footnote\">\u21a9</a></p></li></ol></div>'\n+// @has - '<p>markdown test</p>'\n+// @has - '<p>this is a <a href=\"https://example.com\" title=\"this is a title\">link</a>.</p>'\n+// @has - '<hr />'\n+// @has - '<p>a footnote<sup id=\"supref1\"><a href=\"#ref1\">1</a></sup>.</p>'\n+// @has - '<p>another footnote<sup id=\"supref2\"><a href=\"#ref2\">2</a></sup>.</p>'\n+// @has - '<p><img src=\"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\" alt=\"Rust\" /></p>'\n+// @has - '<div class=\"footnotes\"><hr><ol><li id=\"ref1\">'\n+// @has - '<p>Thing&nbsp;<a href=\"#supref1\" rev=\"footnote\">\u21a9</a></p></li><li id=\"ref2\">'\n+// @has - '<p>Another Thing&nbsp;<a href=\"#supref2\" rev=\"footnote\">\u21a9</a></p></li></ol></div>'\n /// markdown test\n ///\n /// this is a [link].\n ///\n /// [link]: https://example.com \"this is a title\"\n ///\n-/// hard break:\n-/// after hard break\n-///\n /// -----------\n ///\n /// a footnote[^footnote].\n@@ -36,5 +41,4 @@\n ///\n ///\n /// ![Rust](https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png)\n-#[deprecated(note = \"Struct<T>\")]\n pub fn f() {}"}, {"sha": "29f157e0425c90de1669310ee59b259960697464", "filename": "src/test/rustdoc/test-lists.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9fb381b2a13260c3fcdae2f6d9546ab2c87e717/src%2Ftest%2Frustdoc%2Ftest-lists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fb381b2a13260c3fcdae2f6d9546ab2c87e717/src%2Ftest%2Frustdoc%2Ftest-lists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftest-lists.rs?ref=f9fb381b2a13260c3fcdae2f6d9546ab2c87e717", "patch": "@@ -10,23 +10,27 @@\n \n #![crate_name = \"foo\"]\n \n-// ignore-tidy-linelength\n-\n // @has foo/fn.f.html\n-// @has - \"<pre class='rust fn'>pub fn f()</pre><div class='docblock'><ol><li>list<ol><li>fooooo</li><li>x</li></ol></li><li>foo</li></ol>\"\n+// @has - //ol/li \"list\"\n+// @has - //ol/li/ol/li \"fooooo\"\n+// @has - //ol/li/ol/li \"x\"\n+// @has - //ol/li \"foo\"\n /// 1. list\n ///     1. fooooo\n ///     2. x\n /// 2. foo\n pub fn f() {}\n \n // @has foo/fn.foo2.html\n-// @has - \"<pre class='rust fn'>pub fn foo2()</pre><div class='docblock'><ul><li>normal list<ul><li><p>sub list</p></li><li><p>new elem still same elem</p><p>and again same elem!</p></li></ul></li><li>new big elem</li></ul>\"\n+// @has - //ul/li \"normal list\"\n+// @has - //ul/li/ul/li \"sub list\"\n+// @has - //ul/li/ul/li \"new elem still same elem and again same elem!\"\n+// @has - //ul/li \"new big elem\"\n /// * normal list\n ///     * sub list\n ///     * new elem\n ///       still same elem\n ///\n ///       and again same elem!\n /// * new big elem\n-pub fn foo2() {}\n\\ No newline at end of file\n+pub fn foo2() {}"}, {"sha": "efadde992277fefe4b0c6544375487aa47ea6449", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9fb381b2a13260c3fcdae2f6d9546ab2c87e717/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fb381b2a13260c3fcdae2f6d9546ab2c87e717/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=f9fb381b2a13260c3fcdae2f6d9546ab2c87e717", "patch": "@@ -24,7 +24,7 @@ use std::path::PathBuf;\n \n use syntax::diagnostics::metadata::{get_metadata_dir, ErrorMetadataMap, ErrorMetadata};\n \n-use rustdoc::html::markdown::{Markdown, MarkdownOutputStyle, PLAYGROUND};\n+use rustdoc::html::markdown::{Markdown, PLAYGROUND};\n use rustc_serialize::json;\n \n enum OutputFormat {\n@@ -100,7 +100,7 @@ impl Formatter for HTMLFormatter {\n \n         // Description rendered as markdown.\n         match info.description {\n-            Some(ref desc) => write!(output, \"{}\", Markdown(desc, MarkdownOutputStyle::Fancy))?,\n+            Some(ref desc) => write!(output, \"{}\", Markdown(desc))?,\n             None => write!(output, \"<p>No description.</p>\\n\")?,\n         }\n "}]}