{"sha": "b75baad5c3fcb85676c4df648962e53c9756e7ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3NWJhYWQ1YzNmY2I4NTY3NmM0ZGY2NDg5NjJlNTNjOTc1NmU3YmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-20T04:35:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-20T04:35:58Z"}, "message": "Auto merge of #78181 - GuillaumeGomez:sized-trait, r=jyn514\n\nAdd Sized trait display when implemented on type\n\nFixes https://github.com/rust-lang/rust/issues/24183.\n\nI'm not too happy about the hack I had to add in here, however, it seems like the `Sized` trait is **very** special.\n\ncc `@jyn514`\nr? `@ollie27`", "tree": {"sha": "1f5d7c38692a14278e3eaf87de658442870ab999", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f5d7c38692a14278e3eaf87de658442870ab999"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b75baad5c3fcb85676c4df648962e53c9756e7ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b75baad5c3fcb85676c4df648962e53c9756e7ba", "html_url": "https://github.com/rust-lang/rust/commit/b75baad5c3fcb85676c4df648962e53c9756e7ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b75baad5c3fcb85676c4df648962e53c9756e7ba/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b471a3f5fe57e5c6e08acf665f2094422415a3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b471a3f5fe57e5c6e08acf665f2094422415a3d", "html_url": "https://github.com/rust-lang/rust/commit/9b471a3f5fe57e5c6e08acf665f2094422415a3d"}, {"sha": "46f24c912f55c0a31d4708a145e56b5cf0f5c8f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/46f24c912f55c0a31d4708a145e56b5cf0f5c8f0", "html_url": "https://github.com/rust-lang/rust/commit/46f24c912f55c0a31d4708a145e56b5cf0f5c8f0"}], "stats": {"total": 232, "additions": 142, "deletions": 90}, "files": [{"sha": "711b0298565d7f7d3f34f8065c363e31ab0ba1cc", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 114, "deletions": 90, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/b75baad5c3fcb85676c4df648962e53c9756e7ba/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75baad5c3fcb85676c4df648962e53c9756e7ba/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=b75baad5c3fcb85676c4df648962e53c9756e7ba", "patch": "@@ -29,6 +29,107 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         AutoTraitFinder { cx }\n     }\n \n+    fn generate_for_trait(\n+        &mut self,\n+        ty: Ty<'tcx>,\n+        trait_def_id: DefId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        param_env_def_id: DefId,\n+        f: &auto_trait::AutoTraitFinder<'tcx>,\n+        // If this is set, show only negative trait implementations, not positive ones.\n+        discard_positive_impl: bool,\n+    ) -> Option<Item> {\n+        let tcx = self.cx.tcx;\n+        let trait_ref = ty::TraitRef { def_id: trait_def_id, substs: tcx.mk_substs_trait(ty, &[]) };\n+        if !self.cx.generated_synthetics.borrow_mut().insert((ty, trait_def_id)) {\n+            debug!(\"get_auto_trait_impl_for({:?}): already generated, aborting\", trait_ref);\n+            return None;\n+        }\n+\n+        let result = f.find_auto_trait_generics(ty, param_env, trait_def_id, |infcx, info| {\n+            let region_data = info.region_data;\n+\n+            let names_map = tcx\n+                .generics_of(param_env_def_id)\n+                .params\n+                .iter()\n+                .filter_map(|param| match param.kind {\n+                    ty::GenericParamDefKind::Lifetime => Some(param.name),\n+                    _ => None,\n+                })\n+                .map(|name| (name, Lifetime(name)))\n+                .collect();\n+            let lifetime_predicates = Self::handle_lifetimes(&region_data, &names_map);\n+            let new_generics = self.param_env_to_generics(\n+                infcx.tcx,\n+                param_env_def_id,\n+                info.full_user_env,\n+                lifetime_predicates,\n+                info.vid_to_region,\n+            );\n+\n+            debug!(\n+                \"find_auto_trait_generics(param_env_def_id={:?}, trait_def_id={:?}): \\\n+                    finished with {:?}\",\n+                param_env_def_id, trait_def_id, new_generics\n+            );\n+\n+            new_generics\n+        });\n+\n+        let negative_polarity;\n+        let new_generics = match result {\n+            AutoTraitResult::PositiveImpl(new_generics) => {\n+                negative_polarity = false;\n+                if discard_positive_impl {\n+                    return None;\n+                }\n+                new_generics\n+            }\n+            AutoTraitResult::NegativeImpl => {\n+                negative_polarity = true;\n+\n+                // For negative impls, we use the generic params, but *not* the predicates,\n+                // from the original type. Otherwise, the displayed impl appears to be a\n+                // conditional negative impl, when it's really unconditional.\n+                //\n+                // For example, consider the struct Foo<T: Copy>(*mut T). Using\n+                // the original predicates in our impl would cause us to generate\n+                // `impl !Send for Foo<T: Copy>`, which makes it appear that Foo\n+                // implements Send where T is not copy.\n+                //\n+                // Instead, we generate `impl !Send for Foo<T>`, which better\n+                // expresses the fact that `Foo<T>` never implements `Send`,\n+                // regardless of the choice of `T`.\n+                let params = (tcx.generics_of(param_env_def_id), ty::GenericPredicates::default())\n+                    .clean(self.cx)\n+                    .params;\n+\n+                Generics { params, where_predicates: Vec::new() }\n+            }\n+            AutoTraitResult::ExplicitImpl => return None,\n+        };\n+\n+        Some(Item {\n+            source: Span::dummy(),\n+            name: None,\n+            attrs: Default::default(),\n+            visibility: Inherited,\n+            def_id: self.cx.next_def_id(param_env_def_id.krate),\n+            kind: box ImplItem(Impl {\n+                unsafety: hir::Unsafety::Normal,\n+                generics: new_generics,\n+                provided_trait_methods: Default::default(),\n+                trait_: Some(trait_ref.clean(self.cx).get_trait_type().unwrap()),\n+                for_: ty.clean(self.cx),\n+                items: Vec::new(),\n+                negative_polarity,\n+                synthetic: true,\n+                blanket_impl: None,\n+            }),\n+        })\n+    }\n+\n     // FIXME(eddyb) figure out a better way to pass information about\n     // parametrization of `ty` than `param_env_def_id`.\n     crate fn get_auto_trait_impls(&mut self, ty: Ty<'tcx>, param_env_def_id: DefId) -> Vec<Item> {\n@@ -38,99 +139,22 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n \n         debug!(\"get_auto_trait_impls({:?})\", ty);\n         let auto_traits: Vec<_> = self.cx.auto_traits.iter().cloned().collect();\n-        auto_traits\n+        let mut auto_traits: Vec<Item> = auto_traits\n             .into_iter()\n             .filter_map(|trait_def_id| {\n-                let trait_ref =\n-                    ty::TraitRef { def_id: trait_def_id, substs: tcx.mk_substs_trait(ty, &[]) };\n-                if !self.cx.generated_synthetics.borrow_mut().insert((ty, trait_def_id)) {\n-                    debug!(\"get_auto_trait_impl_for({:?}): already generated, aborting\", trait_ref);\n-                    return None;\n-                }\n-\n-                let result =\n-                    f.find_auto_trait_generics(ty, param_env, trait_def_id, |infcx, info| {\n-                        let region_data = info.region_data;\n-\n-                        let names_map = tcx\n-                            .generics_of(param_env_def_id)\n-                            .params\n-                            .iter()\n-                            .filter_map(|param| match param.kind {\n-                                ty::GenericParamDefKind::Lifetime => Some(param.name),\n-                                _ => None,\n-                            })\n-                            .map(|name| (name, Lifetime(name)))\n-                            .collect();\n-                        let lifetime_predicates = Self::handle_lifetimes(&region_data, &names_map);\n-                        let new_generics = self.param_env_to_generics(\n-                            infcx.tcx,\n-                            param_env_def_id,\n-                            info.full_user_env,\n-                            lifetime_predicates,\n-                            info.vid_to_region,\n-                        );\n-\n-                        debug!(\n-                            \"find_auto_trait_generics(param_env_def_id={:?}, trait_def_id={:?}): \\\n-                            finished with {:?}\",\n-                            param_env_def_id, trait_def_id, new_generics\n-                        );\n-\n-                        new_generics\n-                    });\n-\n-                let negative_polarity;\n-                let new_generics = match result {\n-                    AutoTraitResult::PositiveImpl(new_generics) => {\n-                        negative_polarity = false;\n-                        new_generics\n-                    }\n-                    AutoTraitResult::NegativeImpl => {\n-                        negative_polarity = true;\n-\n-                        // For negative impls, we use the generic params, but *not* the predicates,\n-                        // from the original type. Otherwise, the displayed impl appears to be a\n-                        // conditional negative impl, when it's really unconditional.\n-                        //\n-                        // For example, consider the struct Foo<T: Copy>(*mut T). Using\n-                        // the original predicates in our impl would cause us to generate\n-                        // `impl !Send for Foo<T: Copy>`, which makes it appear that Foo\n-                        // implements Send where T is not copy.\n-                        //\n-                        // Instead, we generate `impl !Send for Foo<T>`, which better\n-                        // expresses the fact that `Foo<T>` never implements `Send`,\n-                        // regardless of the choice of `T`.\n-                        let params =\n-                            (tcx.generics_of(param_env_def_id), ty::GenericPredicates::default())\n-                                .clean(self.cx)\n-                                .params;\n-\n-                        Generics { params, where_predicates: Vec::new() }\n-                    }\n-                    AutoTraitResult::ExplicitImpl => return None,\n-                };\n-\n-                Some(Item {\n-                    source: Span::dummy(),\n-                    name: None,\n-                    attrs: Default::default(),\n-                    visibility: Inherited,\n-                    def_id: self.cx.next_def_id(param_env_def_id.krate),\n-                    kind: box ImplItem(Impl {\n-                        unsafety: hir::Unsafety::Normal,\n-                        generics: new_generics,\n-                        provided_trait_methods: Default::default(),\n-                        trait_: Some(trait_ref.clean(self.cx).get_trait_type().unwrap()),\n-                        for_: ty.clean(self.cx),\n-                        items: Vec::new(),\n-                        negative_polarity,\n-                        synthetic: true,\n-                        blanket_impl: None,\n-                    }),\n-                })\n+                self.generate_for_trait(ty, trait_def_id, param_env, param_env_def_id, &f, false)\n             })\n-            .collect()\n+            .collect();\n+        // We are only interested in case the type *doesn't* implement the Sized trait.\n+        if !ty.is_sized(self.cx.tcx.at(rustc_span::DUMMY_SP), param_env) {\n+            // In case `#![no_core]` is used, `sized_trait` returns nothing.\n+            if let Some(item) = self.cx.tcx.lang_items().sized_trait().and_then(|sized_trait_did| {\n+                self.generate_for_trait(ty, sized_trait_did, param_env, param_env_def_id, &f, true)\n+            }) {\n+                auto_traits.push(item);\n+            }\n+        }\n+        auto_traits\n     }\n \n     fn get_lifetime(region: Region<'_>, names_map: &FxHashMap<Symbol, Lifetime>) -> Lifetime {"}, {"sha": "1c2d2ad626c5a6999ff3cda3d25a4bdbbb812450", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b75baad5c3fcb85676c4df648962e53c9756e7ba/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75baad5c3fcb85676c4df648962e53c9756e7ba/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=b75baad5c3fcb85676c4df648962e53c9756e7ba", "patch": "@@ -32,6 +32,7 @@ use std::{\n };\n \n use crate::clean;\n+use crate::clean::inline::build_external_trait;\n use crate::clean::{AttributesExt, MAX_DEF_IDX};\n use crate::config::{Options as RustdocOptions, RenderOptions};\n use crate::config::{OutputFormat, RenderInfo};\n@@ -530,6 +531,16 @@ crate fn run_global_ctxt(\n         module_trait_cache: RefCell::new(FxHashMap::default()),\n         cache: Cache::default(),\n     };\n+\n+    // Small hack to force the Sized trait to be present.\n+    //\n+    // Note that in case of `#![no_core]`, the trait is not available.\n+    if let Some(sized_trait_did) = ctxt.tcx.lang_items().sized_trait() {\n+        let mut sized_trait = build_external_trait(&mut ctxt, sized_trait_did);\n+        sized_trait.is_auto = true;\n+        ctxt.external_traits.borrow_mut().insert(sized_trait_did, sized_trait);\n+    }\n+\n     debug!(\"crate: {:?}\", tcx.hir().krate());\n \n     let mut krate = tcx.sess.time(\"clean_crate\", || clean::krate(&mut ctxt));"}, {"sha": "26d12817afca1c30bc9516bfc5df3f878ef4fa52", "filename": "src/test/rustdoc/sized_trait.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b75baad5c3fcb85676c4df648962e53c9756e7ba/src%2Ftest%2Frustdoc%2Fsized_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b75baad5c3fcb85676c4df648962e53c9756e7ba/src%2Ftest%2Frustdoc%2Fsized_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsized_trait.rs?ref=b75baad5c3fcb85676c4df648962e53c9756e7ba", "patch": "@@ -0,0 +1,17 @@\n+#![crate_name = \"foo\"]\n+\n+// @has foo/struct.Bar.html\n+// @!has - '//h3[@id=\"impl-Sized\"]'\n+pub struct Bar {\n+    a: u16,\n+}\n+\n+// @has foo/struct.Foo.html\n+// @!has - '//h3[@id=\"impl-Sized\"]'\n+pub struct Foo<T: ?Sized>(T);\n+\n+// @has foo/struct.Unsized.html\n+// @has - '//h3[@id=\"impl-Sized\"]/code' 'impl !Sized for Unsized'\n+pub struct Unsized {\n+    data: [u8],\n+}"}]}