{"sha": "4751e45521e5a1e70f5cf5086b7712c999546af8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3NTFlNDU1MjFlNWExZTcwZjVjZjUwODZiNzcxMmM5OTk1NDZhZjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-28T12:47:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-28T12:47:57Z"}, "message": "Auto merge of #33208 - nrc:save-json, r=pnkfelix\n\nsave-analysis: dump in JSON format\n\ncc #18582", "tree": {"sha": "39cc39cb818ae9b25f2dd31bf2054004f47f8471", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39cc39cb818ae9b25f2dd31bf2054004f47f8471"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4751e45521e5a1e70f5cf5086b7712c999546af8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4751e45521e5a1e70f5cf5086b7712c999546af8", "html_url": "https://github.com/rust-lang/rust/commit/4751e45521e5a1e70f5cf5086b7712c999546af8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4751e45521e5a1e70f5cf5086b7712c999546af8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f9ba992910b724bd198a196b5e408785911fdfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f9ba992910b724bd198a196b5e408785911fdfc", "html_url": "https://github.com/rust-lang/rust/commit/0f9ba992910b724bd198a196b5e408785911fdfc"}, {"sha": "7ca2b9461fdcd94ae1ac40bae02397d5a2daddd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ca2b9461fdcd94ae1ac40bae02397d5a2daddd0", "html_url": "https://github.com/rust-lang/rust/commit/7ca2b9461fdcd94ae1ac40bae02397d5a2daddd0"}], "stats": {"total": 1187, "additions": 906, "deletions": 281}, "files": [{"sha": "fec9e985e04cdc4d9c49340bb1418ba94b9062d9", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4751e45521e5a1e70f5cf5086b7712c999546af8/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4751e45521e5a1e70f5cf5086b7712c999546af8/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=4751e45521e5a1e70f5cf5086b7712c999546af8", "patch": "@@ -120,7 +120,7 @@ DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back rustc_mir\n                     log syntax serialize rustc_llvm rustc_platform_intrinsics \\\n                     rustc_const_math rustc_const_eval rustc_incremental\n DEPS_rustc_incremental := rbml rustc serialize rustc_data_structures\n-DEPS_rustc_save_analysis := rustc log syntax\n+DEPS_rustc_save_analysis := rustc log syntax serialize\n DEPS_rustc_typeck := rustc syntax rustc_platform_intrinsics rustc_const_math \\\n                      rustc_const_eval\n "}, {"sha": "9f29f9050e6a6df659a74f03f7c504a7de0db921", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=4751e45521e5a1e70f5cf5086b7712c999546af8", "patch": "@@ -618,7 +618,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     ls: bool = (false, parse_bool,\n         \"list the symbols defined by a library crate\"),\n     save_analysis: bool = (false, parse_bool,\n-        \"write syntax and type analysis information in addition to normal output\"),\n+        \"write syntax and type analysis (in JSON format) information in addition to normal output\"),\n+    save_analysis_csv: bool = (false, parse_bool,\n+        \"write syntax and type analysis (in CSV format) information in addition to normal output\"),\n     print_move_fragments: bool = (false, parse_bool,\n         \"print out move-fragment data for every fn\"),\n     flowgraph_print_loans: bool = (false, parse_bool,"}, {"sha": "4dd03fd21065406f1f01c1c119b6e26dcb33f68d", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=4751e45521e5a1e70f5cf5086b7712c999546af8", "patch": "@@ -141,8 +141,7 @@ pub fn compile_input(sess: &Session,\n                                                            dep_graph));\n \n         // Discard MTWT tables that aren't required past lowering to HIR.\n-        if !sess.opts.debugging_opts.keep_mtwt_tables &&\n-           !sess.opts.debugging_opts.save_analysis {\n+        if !keep_mtwt_tables(sess) {\n             syntax::ext::mtwt::clear_tables();\n         }\n \n@@ -179,8 +178,7 @@ pub fn compile_input(sess: &Session,\n              \"early lint checks\",\n              || lint::check_ast_crate(sess, &expanded_crate));\n \n-        let opt_crate = if sess.opts.debugging_opts.keep_ast ||\n-                           sess.opts.debugging_opts.save_analysis {\n+        let opt_crate = if keep_ast(sess) {\n             Some(&expanded_crate)\n         } else {\n             drop(expanded_crate);\n@@ -249,6 +247,18 @@ pub fn compile_input(sess: &Session,\n     Ok(())\n }\n \n+fn keep_mtwt_tables(sess: &Session) -> bool {\n+    sess.opts.debugging_opts.keep_mtwt_tables ||\n+    sess.opts.debugging_opts.save_analysis ||\n+    sess.opts.debugging_opts.save_analysis_csv\n+}\n+\n+fn keep_ast(sess: &Session) -> bool {\n+    sess.opts.debugging_opts.keep_ast ||\n+    sess.opts.debugging_opts.save_analysis ||\n+    sess.opts.debugging_opts.save_analysis_csv\n+}\n+\n /// The name used for source code that doesn't originate in a file\n /// (e.g. source from stdin or a string)\n pub fn anon_src() -> String {"}, {"sha": "b04503d12ae208a86f1d88638a3d33d6df10957d", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=4751e45521e5a1e70f5cf5086b7712c999546af8", "patch": "@@ -483,15 +483,16 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             control.after_llvm.stop = Compilation::Stop;\n         }\n \n-        if sess.opts.debugging_opts.save_analysis {\n+        if save_analysis(sess) {\n             control.after_analysis.callback = box |state| {\n                 time(state.session.time_passes(), \"save analysis\", || {\n                     save::process_crate(state.tcx.unwrap(),\n                                         state.lcx.unwrap(),\n                                         state.krate.unwrap(),\n                                         state.analysis.unwrap(),\n                                         state.crate_name.unwrap(),\n-                                        state.out_dir)\n+                                        state.out_dir,\n+                                        save_analysis_format(state.session))\n                 });\n             };\n             control.after_analysis.run_callback_on_error = true;\n@@ -502,6 +503,21 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n     }\n }\n \n+fn save_analysis(sess: &Session) -> bool {\n+    sess.opts.debugging_opts.save_analysis ||\n+    sess.opts.debugging_opts.save_analysis_csv\n+}\n+\n+fn save_analysis_format(sess: &Session) -> save::Format {\n+    if sess.opts.debugging_opts.save_analysis {\n+        save::Format::Json\n+    } else if sess.opts.debugging_opts.save_analysis_csv {\n+        save::Format::Csv\n+    } else {\n+        unreachable!();\n+    }\n+}\n+\n impl RustcDefaultCalls {\n     pub fn list_metadata(sess: &Session, matches: &getopts::Matches, input: &Input) -> Compilation {\n         let r = matches.opt_strs(\"Z\");"}, {"sha": "c786b4d711c39157329ad96d61b7b6f1fb021414", "filename": "src/librustc_save_analysis/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Flibrustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Flibrustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2FCargo.toml?ref=4751e45521e5a1e70f5cf5086b7712c999546af8", "patch": "@@ -12,3 +12,4 @@ crate-type = [\"dylib\"]\n log = { path = \"../liblog\" }\n rustc = { path = \"../librustc\" }\n syntax = { path = \"../libsyntax\" }\n+serialize = { path = \"../libserialize\" }"}, {"sha": "4d6512db861e5063aa0d53992f33f45d1459e11d", "filename": "src/librustc_save_analysis/csv_dumper.rs", "status": "modified", "additions": 27, "deletions": 154, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs?ref=4751e45521e5a1e70f5cf5086b7712c999546af8", "patch": "@@ -19,13 +19,12 @@ use super::span_utils::SpanUtils;\n \n pub struct CsvDumper<'tcx, 'b, W: 'b> {\n     output: &'b mut W,\n-    dump_spans: bool,\n     span: SpanUtils<'tcx>\n }\n \n impl<'a, 'b, W: Write> CsvDumper<'a, 'b, W> {\n     pub fn new(writer: &'b mut W, span: SpanUtils<'a>) -> CsvDumper<'a, 'b, W> {\n-        CsvDumper { output: writer, dump_spans: false, span: span }\n+        CsvDumper { output: writer, span: span }\n     }\n \n     fn record(&mut self, kind: &str, span: Span, values: String) {\n@@ -40,36 +39,23 @@ impl<'a, 'b, W: Write> CsvDumper<'a, 'b, W> {\n             error!(\"Error writing output '{}'\", info);\n         }\n     }\n-\n-    pub fn dump_span(&mut self, kind: &str, span: Span) {\n-        assert!(self.dump_spans);\n-        let result = format!(\"span,kind,{},{},text,\\\"{}\\\"\\n\",\n-                             kind,\n-                             self.span.extent_str(span),\n-                             escape(self.span.snippet(span)));\n-        self.record_raw(&result);\n-    }\n }\n \n impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n-    fn crate_prelude(&mut self, span: Span, data: CratePreludeData) {\n-        let crate_root = data.crate_root.unwrap_or(\"<no source>\".to_owned());\n-\n+    fn crate_prelude(&mut self, data: CratePreludeData) {\n         let values = make_values_str(&[\n             (\"name\", &data.crate_name),\n-            (\"crate_root\", &crate_root)\n+            (\"crate_root\", &data.crate_root)\n         ]);\n \n-        self.record(\"crate\", span, values);\n+        self.record(\"crate\", data.span, values);\n \n         for c in data.external_crates {\n             let num = c.num.to_string();\n-            let lo_loc = self.span.sess.codemap().lookup_char_pos(span.lo);\n-            let file_name = SpanUtils::make_path_string(&lo_loc.file.name);\n             let values = make_values_str(&[\n                 (\"name\", &c.name),\n                 (\"crate\", &num),\n-                (\"file_name\", &file_name)\n+                (\"file_name\", &c.file_name)\n             ]);\n \n             self.record_raw(&format!(\"external_crate{}\\n\", values));\n@@ -78,12 +64,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record_raw(\"end_external_crates\\n\");\n     }\n \n-    fn enum_data(&mut self, span: Span, data: EnumData) {\n-        if self.dump_spans {\n-            self.dump_span(\"enum\", span);\n-            return;\n-        }\n-\n+    fn enum_data(&mut self, data: EnumData) {\n         let id = data.id.to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n@@ -96,12 +77,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"enum\", data.span, values);\n     }\n \n-    fn extern_crate(&mut self, span: Span, data: ExternCrateData) {\n-        if self.dump_spans {\n-            self.dump_span(\"extern_crate\", span);\n-            return;\n-        }\n-\n+    fn extern_crate(&mut self, data: ExternCrateData) {\n         let id = data.id.to_string();\n         let crate_num = data.crate_num.to_string();\n         let scope = data.scope.to_string();\n@@ -116,12 +92,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"extern_crate\", data.span, values);\n     }\n \n-    fn impl_data(&mut self, span: Span, data: ImplData) {\n-        if self.dump_spans {\n-            self.dump_span(\"impl\", span);\n-            return;\n-        }\n-\n+    fn impl_data(&mut self, data: ImplData) {\n         let self_ref = data.self_ref.unwrap_or(null_def_id());\n         let trait_ref = data.trait_ref.unwrap_or(null_def_id());\n \n@@ -144,10 +115,6 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn inheritance(&mut self, data: InheritanceData) {\n-       if self.dump_spans {\n-           return;\n-       }\n-\n        let base_id = data.base_id.index.as_usize().to_string();\n        let base_crate = data.base_id.krate.to_string();\n        let deriv_id = data.deriv_id.to_string();\n@@ -162,12 +129,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n        self.record(\"inheritance\", data.span, values);\n     }\n \n-    fn function(&mut self, span: Span, data: FunctionData) {\n-        if self.dump_spans {\n-            self.dump_span(\"function\", span);\n-            return;\n-        }\n-\n+    fn function(&mut self, data: FunctionData) {\n         let (decl_id, decl_crate) = match data.declaration {\n             Some(id) => (id.index.as_usize().to_string(), id.krate.to_string()),\n             None => (String::new(), String::new())\n@@ -186,12 +148,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"function\", data.span, values);\n     }\n \n-    fn function_ref(&mut self, span: Span, data: FunctionRefData) {\n-        if self.dump_spans {\n-            self.dump_span(\"fn_ref\", span);\n-            return;\n-        }\n-\n+    fn function_ref(&mut self, data: FunctionRefData) {\n         let ref_id = data.ref_id.index.as_usize().to_string();\n         let ref_crate = data.ref_id.krate.to_string();\n         let scope = data.scope.to_string();\n@@ -205,12 +162,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"fn_ref\", data.span, values);\n     }\n \n-    fn function_call(&mut self, span: Span, data: FunctionCallData) {\n-        if self.dump_spans {\n-            self.dump_span(\"fn_call\", span);\n-            return;\n-        }\n-\n+    fn function_call(&mut self, data: FunctionCallData) {\n         let ref_id = data.ref_id.index.as_usize().to_string();\n         let ref_crate = data.ref_id.krate.to_string();\n         let qualname = String::new();\n@@ -225,12 +177,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"fn_call\", data.span, values);\n     }\n \n-    fn method(&mut self, span: Span, data: MethodData) {\n-        if self.dump_spans {\n-            self.dump_span(\"method_decl\", span);\n-            return;\n-        }\n-\n+    fn method(&mut self, data: MethodData) {\n         let id = data.id.to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n@@ -239,15 +186,10 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n             (\"scopeid\", &scope)\n         ]);\n \n-        self.record(\"method_decl\", span, values);\n+        self.record(\"method_decl\", data.span, values);\n     }\n \n-    fn method_call(&mut self, span: Span, data: MethodCallData) {\n-        if self.dump_spans {\n-            self.dump_span(\"method_call\", span);\n-            return;\n-        }\n-\n+    fn method_call(&mut self, data: MethodCallData) {\n         let (dcn, dck) = match data.decl_id {\n             Some(declid) => (declid.index.as_usize().to_string(), declid.krate.to_string()),\n             None => (String::new(), String::new()),\n@@ -269,12 +211,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"method_call\", data.span, values);\n     }\n \n-    fn macro_data(&mut self, span: Span, data: MacroData) {\n-        if self.dump_spans {\n-            self.dump_span(\"macro\", span);\n-            return;\n-        }\n-\n+    fn macro_data(&mut self, data: MacroData) {\n         let values = make_values_str(&[\n             (\"name\", &data.name),\n             (\"qualname\", &data.qualname)\n@@ -283,12 +220,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"macro\", data.span, values);\n     }\n \n-    fn macro_use(&mut self, span: Span, data: MacroUseData) {\n-        if self.dump_spans {\n-            self.dump_span(\"macro_use\", span);\n-            return;\n-        }\n-\n+    fn macro_use(&mut self, data: MacroUseData) {\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n             (\"callee_name\", &data.name),\n@@ -300,10 +232,6 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n     }\n \n     fn mod_data(&mut self, data: ModData) {\n-        if self.dump_spans {\n-            return;\n-        }\n-\n         let id = data.id.to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n@@ -316,12 +244,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"module\", data.span, values);\n     }\n \n-    fn mod_ref(&mut self, span: Span, data: ModRefData) {\n-        if self.dump_spans {\n-            self.dump_span(\"mod_ref\", span);\n-            return;\n-        }\n-\n+    fn mod_ref(&mut self, data: ModRefData) {\n         let (ref_id, ref_crate) = match data.ref_id {\n             Some(rid) => (rid.index.as_usize().to_string(), rid.krate.to_string()),\n             None => (0.to_string(), 0.to_string())\n@@ -338,12 +261,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"mod_ref\", data.span, values);\n     }\n \n-    fn struct_data(&mut self, span: Span, data: StructData) {\n-        if self.dump_spans {\n-            self.dump_span(\"struct\", span);\n-            return;\n-        }\n-\n+    fn struct_data(&mut self, data: StructData) {\n         let id = data.id.to_string();\n         let ctor_id = data.ctor_id.to_string();\n         let scope = data.scope.to_string();\n@@ -358,12 +276,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"struct\", data.span, values);\n     }\n \n-    fn struct_variant(&mut self, span: Span, data: StructVariantData) {\n-        if self.dump_spans {\n-            self.dump_span(\"variant_struct\", span);\n-            return;\n-        }\n-\n+    fn struct_variant(&mut self, data: StructVariantData) {\n         let id = data.id.to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n@@ -378,12 +291,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"variant_struct\", data.span, values);\n     }\n \n-    fn trait_data(&mut self, span: Span, data: TraitData) {\n-        if self.dump_spans {\n-            self.dump_span(\"trait\", span);\n-            return;\n-        }\n-\n+    fn trait_data(&mut self, data: TraitData) {\n         let id = data.id.to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n@@ -396,12 +304,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"trait\", data.span, values);\n     }\n \n-    fn tuple_variant(&mut self, span: Span, data: TupleVariantData) {\n-        if self.dump_spans {\n-            self.dump_span(\"variant\", span);\n-            return;\n-        }\n-\n+    fn tuple_variant(&mut self, data: TupleVariantData) {\n         let id = data.id.to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n@@ -416,12 +319,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"variant\", data.span, values);\n     }\n \n-    fn type_ref(&mut self, span: Span, data: TypeRefData) {\n-        if self.dump_spans {\n-            self.dump_span(\"type_ref\", span);\n-            return;\n-        }\n-\n+    fn type_ref(&mut self, data: TypeRefData) {\n         let (ref_id, ref_crate) = match data.ref_id {\n             Some(id) => (id.index.as_usize().to_string(), id.krate.to_string()),\n             None => (0.to_string(), 0.to_string())\n@@ -438,12 +336,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"type_ref\", data.span, values);\n     }\n \n-    fn typedef(&mut self, span: Span, data: TypedefData) {\n-        if self.dump_spans {\n-            self.dump_span(\"typedef\", span);\n-            return;\n-        }\n-\n+    fn typedef(&mut self, data: TypedefData) {\n         let id = data.id.to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n@@ -454,12 +347,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"typedef\", data.span, values);\n     }\n \n-    fn use_data(&mut self, span: Span, data: UseData) {\n-        if self.dump_spans {\n-            self.dump_span(\"use_alias\", span);\n-            return;\n-        }\n-\n+    fn use_data(&mut self, data: UseData) {\n         let mod_id = data.mod_id.unwrap_or(null_def_id());\n \n         let id = data.id.to_string();\n@@ -477,12 +365,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"use_alias\", data.span, values);\n     }\n \n-    fn use_glob(&mut self, span: Span, data: UseGlobData) {\n-        if self.dump_spans {\n-            self.dump_span(\"use_glob\", span);\n-            return;\n-        }\n-\n+    fn use_glob(&mut self, data: UseGlobData) {\n         let names = data.names.join(\", \");\n \n         let id = data.id.to_string();\n@@ -496,12 +379,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"use_glob\", data.span, values);\n     }\n \n-    fn variable(&mut self, span: Span, data: VariableData) {\n-        if self.dump_spans {\n-            self.dump_span(\"variable\", span);\n-            return;\n-        }\n-\n+    fn variable(&mut self, data: VariableData) {\n         let id = data.id.to_string();\n         let scope = data.scope.to_string();\n         let values = make_values_str(&[\n@@ -516,12 +394,7 @@ impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n         self.record(\"variable\", data.span, values);\n     }\n \n-    fn variable_ref(&mut self, span: Span, data: VariableRefData) {\n-        if self.dump_spans {\n-            self.dump_span(\"var_ref\", span);\n-            return;\n-        }\n-\n+    fn variable_ref(&mut self, data: VariableRefData) {\n         let ref_id = data.ref_id.index.as_usize().to_string();\n         let ref_crate = data.ref_id.krate.to_string();\n         let scope = data.scope.to_string();"}, {"sha": "b79c459920a3e5f075cbb28a6eff8f53343b4d09", "filename": "src/librustc_save_analysis/data.rs", "status": "modified", "additions": 64, "deletions": 31, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Flibrustc_save_analysis%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Flibrustc_save_analysis%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdata.rs?ref=4751e45521e5a1e70f5cf5086b7712c999546af8", "patch": "@@ -18,16 +18,47 @@ use std::hash::Hasher;\n use rustc::hir::def_id::DefId;\n use rustc::ty;\n use syntax::ast::{CrateNum, NodeId};\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, CodeMap};\n+\n+#[derive(Debug, Clone, RustcEncodable)]\n+pub struct SpanData {\n+    file_name: String,\n+    byte_start: u32,\n+    byte_end: u32,\n+    /// 1-based.\n+    line_start: usize,\n+    line_end: usize,\n+    /// 1-based, character offset.\n+    column_start: usize,\n+    column_end: usize,\n+}\n+\n+impl SpanData {\n+    pub fn from_span(span: Span, cm: &CodeMap) -> SpanData {\n+        let start = cm.lookup_char_pos(span.lo);\n+        let end = cm.lookup_char_pos(span.hi);\n+\n+        SpanData {\n+            file_name: start.file.name.clone(),\n+            byte_start: span.lo.0,\n+            byte_end: span.hi.0,\n+            line_start: start.line,\n+            line_end: end.line,\n+            column_start: start.col.0 + 1,\n+            column_end: end.col.0 + 1,\n+        }\n+    }\n+}\n \n pub struct CrateData {\n     pub name: String,\n     pub number: u32,\n+    pub span: Span,\n }\n \n /// Data for any entity in the Rust language. The actual data contained varies\n /// with the kind of entity being queried. See the nested structs for details.\n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub enum Data {\n     /// Data for Enums.\n     EnumData(EnumData),\n@@ -79,22 +110,24 @@ pub enum Data {\n }\n \n /// Data for the prelude of a crate.\n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct CratePreludeData {\n     pub crate_name: String,\n-    pub crate_root: Option<String>,\n-    pub external_crates: Vec<ExternalCrateData>\n+    pub crate_root: String,\n+    pub external_crates: Vec<ExternalCrateData>,\n+    pub span: Span,\n }\n \n /// Data for external crates in the prelude of a crate.\n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct ExternalCrateData {\n     pub name: String,\n-    pub num: CrateNum\n+    pub num: CrateNum,\n+    pub file_name: String,\n }\n \n /// Data for enum declarations.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, RustcEncodable)]\n pub struct EnumData {\n     pub id: NodeId,\n     pub value: String,\n@@ -104,7 +137,7 @@ pub struct EnumData {\n }\n \n /// Data for extern crates.\n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct ExternCrateData {\n     pub id: NodeId,\n     pub name: String,\n@@ -115,15 +148,15 @@ pub struct ExternCrateData {\n }\n \n /// Data about a function call.\n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct FunctionCallData {\n     pub span: Span,\n     pub scope: NodeId,\n     pub ref_id: DefId,\n }\n \n /// Data for all kinds of functions and methods.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, RustcEncodable)]\n pub struct FunctionData {\n     pub id: NodeId,\n     pub name: String,\n@@ -134,14 +167,14 @@ pub struct FunctionData {\n }\n \n /// Data about a function call.\n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct FunctionRefData {\n     pub span: Span,\n     pub scope: NodeId,\n     pub ref_id: DefId,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct ImplData {\n     pub id: NodeId,\n     pub span: Span,\n@@ -150,7 +183,7 @@ pub struct ImplData {\n     pub self_ref: Option<DefId>,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n // FIXME: this struct should not exist. However, removing it requires heavy\n // refactoring of dump_visitor.rs. See PR 31838 for more info.\n pub struct ImplData2 {\n@@ -164,23 +197,23 @@ pub struct ImplData2 {\n     pub self_ref: Option<TypeRefData>,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct InheritanceData {\n     pub span: Span,\n     pub base_id: DefId,\n     pub deriv_id: NodeId\n }\n \n /// Data about a macro declaration.\n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct MacroData {\n     pub span: Span,\n     pub name: String,\n     pub qualname: String,\n }\n \n /// Data about a macro use.\n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct MacroUseData {\n     pub span: Span,\n     pub name: String,\n@@ -193,7 +226,7 @@ pub struct MacroUseData {\n }\n \n /// Data about a method call.\n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct MethodCallData {\n     pub span: Span,\n     pub scope: NodeId,\n@@ -202,7 +235,7 @@ pub struct MethodCallData {\n }\n \n /// Data for method declarations (methods with a body are treated as functions).\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, RustcEncodable)]\n pub struct MethodData {\n     pub id: NodeId,\n     pub qualname: String,\n@@ -211,7 +244,7 @@ pub struct MethodData {\n }\n \n /// Data for modules.\n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct ModData {\n     pub id: NodeId,\n     pub name: String,\n@@ -222,15 +255,15 @@ pub struct ModData {\n }\n \n /// Data for a reference to a module.\n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct ModRefData {\n     pub span: Span,\n     pub scope: NodeId,\n     pub ref_id: Option<DefId>,\n     pub qualname: String\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct StructData {\n     pub span: Span,\n     pub id: NodeId,\n@@ -240,7 +273,7 @@ pub struct StructData {\n     pub value: String\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct StructVariantData {\n     pub span: Span,\n     pub id: NodeId,\n@@ -250,7 +283,7 @@ pub struct StructVariantData {\n     pub scope: NodeId\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct TraitData {\n     pub span: Span,\n     pub id: NodeId,\n@@ -259,7 +292,7 @@ pub struct TraitData {\n     pub value: String\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct TupleVariantData {\n     pub span: Span,\n     pub id: NodeId,\n@@ -271,7 +304,7 @@ pub struct TupleVariantData {\n }\n \n /// Data for a typedef.\n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct TypedefData {\n     pub id: NodeId,\n     pub span: Span,\n@@ -280,15 +313,15 @@ pub struct TypedefData {\n }\n \n /// Data for a reference to a type or trait.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, RustcEncodable)]\n pub struct TypeRefData {\n     pub span: Span,\n     pub scope: NodeId,\n     pub ref_id: Option<DefId>,\n     pub qualname: String,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct UseData {\n     pub id: NodeId,\n     pub span: Span,\n@@ -297,7 +330,7 @@ pub struct UseData {\n     pub scope: NodeId\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct UseGlobData {\n     pub id: NodeId,\n     pub span: Span,\n@@ -306,7 +339,7 @@ pub struct UseGlobData {\n }\n \n /// Data for local and global variables (consts and statics).\n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct VariableData {\n     pub id: NodeId,\n     pub name: String,\n@@ -319,7 +352,7 @@ pub struct VariableData {\n \n /// Data for the use of some item (e.g., the use of a local variable, which\n /// will refer to that variables declaration (by ref_id)).\n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable)]\n pub struct VariableRefData {\n     pub name: String,\n     pub span: Span,"}, {"sha": "6d15acff1f1cc83c543b76d969e25c10feca3586", "filename": "src/librustc_save_analysis/dump.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Flibrustc_save_analysis%2Fdump.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Flibrustc_save_analysis%2Fdump.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump.rs?ref=4751e45521e5a1e70f5cf5086b7712c999546af8", "patch": "@@ -8,33 +8,31 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::codemap::Span;\n-\n use super::data::*;\n \n pub trait Dump {\n-    fn crate_prelude(&mut self, _: Span, _: CratePreludeData) {}\n-    fn enum_data(&mut self, _: Span, _: EnumData) {}\n-    fn extern_crate(&mut self, _: Span, _: ExternCrateData) {}\n-    fn impl_data(&mut self, _: Span, _: ImplData) {}\n-    fn inheritance(&mut self, _: InheritanceData) {}\n-    fn function(&mut self, _: Span, _: FunctionData) {}\n-    fn function_ref(&mut self, _: Span, _: FunctionRefData) {}\n-    fn function_call(&mut self, _: Span, _: FunctionCallData) {}\n-    fn method(&mut self, _: Span, _: MethodData) {}\n-    fn method_call(&mut self, _: Span, _: MethodCallData) {}\n-    fn macro_data(&mut self, _: Span, _: MacroData) {}\n-    fn macro_use(&mut self, _: Span, _: MacroUseData) {}\n-    fn mod_data(&mut self, _: ModData) {}\n-    fn mod_ref(&mut self, _: Span, _: ModRefData) {}\n-    fn struct_data(&mut self, _: Span, _: StructData) {}\n-    fn struct_variant(&mut self, _: Span, _: StructVariantData) {}\n-    fn trait_data(&mut self, _: Span, _: TraitData) {}\n-    fn tuple_variant(&mut self, _: Span, _: TupleVariantData) {}\n-    fn type_ref(&mut self, _: Span, _: TypeRefData) {}\n-    fn typedef(&mut self, _: Span, _: TypedefData) {}\n-    fn use_data(&mut self, _: Span, _: UseData) {}\n-    fn use_glob(&mut self, _: Span, _: UseGlobData) {}\n-    fn variable(&mut self, _: Span, _: VariableData) {}\n-    fn variable_ref(&mut self, _: Span, _: VariableRefData) {}\n+    fn crate_prelude(&mut self, CratePreludeData) {}\n+    fn enum_data(&mut self, EnumData) {}\n+    fn extern_crate(&mut self, ExternCrateData) {}\n+    fn impl_data(&mut self, ImplData) {}\n+    fn inheritance(&mut self, InheritanceData) {}\n+    fn function(&mut self, FunctionData) {}\n+    fn function_ref(&mut self, FunctionRefData) {}\n+    fn function_call(&mut self, FunctionCallData) {}\n+    fn method(&mut self, MethodData) {}\n+    fn method_call(&mut self, MethodCallData) {}\n+    fn macro_data(&mut self, MacroData) {}\n+    fn macro_use(&mut self, MacroUseData) {}\n+    fn mod_data(&mut self, ModData) {}\n+    fn mod_ref(&mut self, ModRefData) {}\n+    fn struct_data(&mut self, StructData) {}\n+    fn struct_variant(&mut self, StructVariantData) {}\n+    fn trait_data(&mut self, TraitData) {}\n+    fn tuple_variant(&mut self, TupleVariantData) {}\n+    fn type_ref(&mut self, TypeRefData) {}\n+    fn typedef(&mut self, TypedefData) {}\n+    fn use_data(&mut self, UseData) {}\n+    fn use_glob(&mut self, UseGlobData) {}\n+    fn variable(&mut self, VariableData) {}\n+    fn variable_ref(&mut self, VariableRefData) {}\n }"}, {"sha": "a4efb68e63c25f78ca9c80934c223fc5a60d4c83", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 55, "deletions": 52, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=4751e45521e5a1e70f5cf5086b7712c999546af8", "patch": "@@ -119,20 +119,23 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n         // Info about all the external crates referenced from this crate.\n         let external_crates = self.save_ctxt.get_external_crates().into_iter().map(|c| {\n+            let lo_loc = self.span.sess.codemap().lookup_char_pos(c.span.lo);\n             ExternalCrateData {\n                 name: c.name,\n-                num: c.number\n+                num: c.number,\n+                file_name: SpanUtils::make_path_string(&lo_loc.file.name),\n             }\n         }).collect();\n \n         // The current crate.\n         let data = CratePreludeData {\n             crate_name: name.into(),\n-            crate_root: crate_root,\n-            external_crates: external_crates\n+            crate_root: crate_root.unwrap_or(\"<no source>\".to_owned()),\n+            external_crates: external_crates,\n+            span: krate.span,\n         };\n \n-        self.dumper.crate_prelude(krate.span, data);\n+        self.dumper.crate_prelude(data);\n     }\n \n     // Return all non-empty prefixes of a path.\n@@ -197,7 +200,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             } else {\n                 qualname.clone()\n             };\n-            self.dumper.mod_ref(path.span, ModRefData {\n+            self.dumper.mod_ref(ModRefData {\n                 span: *span,\n                 qualname: qualname,\n                 scope: self.cur_scope,\n@@ -222,7 +225,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             } else {\n                 qualname.clone()\n             };\n-            self.dumper.mod_ref(path.span, ModRefData {\n+            self.dumper.mod_ref(ModRefData {\n                 span: *span,\n                 qualname: qualname,\n                 scope: self.cur_scope,\n@@ -243,7 +246,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n         // write the trait part of the sub-path\n         let (ref span, ref qualname) = sub_paths[len-2];\n-        self.dumper.type_ref(path.span, TypeRefData {\n+        self.dumper.type_ref(TypeRefData {\n             ref_id: None,\n             span: *span,\n             qualname: qualname.to_owned(),\n@@ -256,7 +259,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         }\n         let sub_paths = &sub_paths[..len-2];\n         for &(ref span, ref qualname) in sub_paths {\n-            self.dumper.mod_ref(path.span, ModRefData {\n+            self.dumper.mod_ref(ModRefData {\n                 span: *span,\n                 qualname: qualname.to_owned(),\n                 scope: self.cur_scope,\n@@ -298,7 +301,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         match def {\n             Def::Mod(_) |\n             Def::ForeignMod(_) => {\n-                self.dumper.mod_ref(span, ModRefData {\n+                self.dumper.mod_ref(ModRefData {\n                     span: sub_span.expect(\"No span found for mod ref\"),\n                     ref_id: Some(def_id),\n                     scope: scope,\n@@ -310,7 +313,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             Def::TyAlias(..) |\n             Def::AssociatedTy(..) |\n             Def::Trait(_) => {\n-                self.dumper.type_ref(span, TypeRefData {\n+                self.dumper.type_ref(TypeRefData {\n                     span: sub_span.expect(\"No span found for type ref\"),\n                     ref_id: Some(def_id),\n                     scope: scope,\n@@ -323,15 +326,15 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             Def::Local(..) |\n             Def::Variant(..) |\n             Def::Upvar(..) => {\n-                self.dumper.variable_ref(span, VariableRefData {\n+                self.dumper.variable_ref(VariableRefData {\n                     span: sub_span.expect(\"No span found for var ref\"),\n                     ref_id: def_id,\n                     scope: scope,\n                     name: String::new()\n                 }.normalize(&self.tcx));\n             }\n             Def::Fn(..) => {\n-                self.dumper.function_ref(span, FunctionRefData {\n+                self.dumper.function_ref(FunctionRefData {\n                     span: sub_span.expect(\"No span found for fn ref\"),\n                     ref_id: def_id,\n                     scope: scope\n@@ -362,7 +365,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 // variable name, but who knows?)\n                 let sub_span = span_utils.span_for_last_ident(p.span);\n                 if !self.span.filter_generated(sub_span, p.span) {\n-                    self.dumper.variable(p.span, VariableData {\n+                    self.dumper.variable(VariableData {\n                         id: id,\n                         span: sub_span.expect(\"No span found for variable\"),\n                         name: path_to_string(p),\n@@ -388,12 +391,12 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n             if body.is_some() {\n                 if !self.span.filter_generated(Some(method_data.span), span) {\n-                    self.dumper.function(span, method_data.clone().normalize(&self.tcx));\n+                    self.dumper.function(method_data.clone().normalize(&self.tcx));\n                 }\n                 self.process_formals(&sig.decl.inputs, &method_data.qualname);\n             } else {\n                 if !self.span.filter_generated(Some(method_data.span), span) {\n-                    self.dumper.method(span, MethodData {\n+                    self.dumper.method(MethodData {\n                         id: method_data.id,\n                         span: method_data.span,\n                         scope: method_data.scope,\n@@ -423,7 +426,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         let trait_ref_data = self.save_ctxt.get_trait_ref_data(trait_ref, self.cur_scope);\n         if let Some(trait_ref_data) = trait_ref_data {\n             if !self.span.filter_generated(Some(trait_ref_data.span), trait_ref.path.span) {\n-                self.dumper.type_ref(trait_ref.path.span, trait_ref_data.normalize(&self.tcx));\n+                self.dumper.type_ref(trait_ref_data.normalize(&self.tcx));\n             }\n \n             visit::walk_path(self, &trait_ref.path);\n@@ -436,7 +439,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             if !self.span.filter_generated(Some(field_data.span), field.span) {\n                 field_data.scope = normalize_node_id(&self.tcx, field_data.scope) as u32;\n                 field_data.value = String::new();\n-                self.dumper.variable(field.span, field_data.normalize(&self.tcx));\n+                self.dumper.variable(field_data.normalize(&self.tcx));\n             }\n         }\n     }\n@@ -460,7 +463,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                escape(self.span.snippet(param_ss)),\n                                id);\n             if !self.span.filter_generated(Some(param_ss), full_span) {\n-                self.dumper.typedef(full_span, TypedefData {\n+                self.dumper.typedef(TypedefData {\n                     span: param_ss,\n                     id: param.id,\n                     qualname: name,\n@@ -479,7 +482,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         if let Some(fn_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(fn_data, FunctionData, item.span);\n             if !self.span.filter_generated(Some(fn_data.span), item.span) {\n-                self.dumper.function(item.span, fn_data.clone().normalize(&self.tcx));\n+                self.dumper.function(fn_data.clone().normalize(&self.tcx));\n             }\n \n             self.process_formals(&decl.inputs, &fn_data.qualname);\n@@ -503,7 +506,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             if !self.span.filter_generated(Some(var_data.span), item.span) {\n                 let mut var_data = var_data;\n                 var_data.scope = normalize_node_id(&self.tcx, var_data.scope) as u32;\n-                self.dumper.variable(item.span, var_data.normalize(&self.tcx));\n+                self.dumper.variable(var_data.normalize(&self.tcx));\n             }\n         }\n         self.visit_ty(&typ);\n@@ -521,7 +524,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         let sub_span = self.span.sub_span_after_keyword(span, keywords::Const);\n \n         if !self.span.filter_generated(sub_span, span) {\n-            self.dumper.variable(span, VariableData {\n+            self.dumper.variable(VariableData {\n                 span: sub_span.expect(\"No span found for variable\"),\n                 id: id,\n                 name: name.to_string(),\n@@ -546,7 +549,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Struct);\n         if !self.span.filter_generated(sub_span, item.span) {\n-            self.dumper.struct_data(item.span, StructData {\n+            self.dumper.struct_data(StructData {\n                 span: sub_span.expect(\"No span found for struct\"),\n                 id: item.id,\n                 ctor_id: def.id(),\n@@ -578,7 +581,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         down_cast_data!(enum_data, EnumData, item.span);\n         let normalized = enum_data.clone().normalize(&self.tcx);\n         if !self.span.filter_generated(Some(normalized.span), item.span) {\n-            self.dumper.enum_data(item.span, normalized);\n+            self.dumper.enum_data(normalized);\n         }\n \n         for variant in &enum_definition.variants {\n@@ -592,7 +595,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 ast::VariantData::Struct(..) => {\n                     let sub_span = self.span.span_for_first_ident(variant.span);\n                     if !self.span.filter_generated(sub_span, variant.span) {\n-                        self.dumper.struct_variant(variant.span, StructVariantData {\n+                        self.dumper.struct_variant(StructVariantData {\n                             span: sub_span.expect(\"No span found for struct variant\"),\n                             id: variant.node.data.id(),\n                             qualname: qualname,\n@@ -605,7 +608,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 _ => {\n                     let sub_span = self.span.span_for_first_ident(variant.span);\n                     if !self.span.filter_generated(sub_span, variant.span) {\n-                        self.dumper.tuple_variant(variant.span, TupleVariantData {\n+                        self.dumper.tuple_variant(TupleVariantData {\n                             span: sub_span.expect(\"No span found for tuple variant\"),\n                             id: variant.node.data.id(),\n                             name: name.to_string(),\n@@ -639,19 +642,19 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             if let Some(ref self_ref) = impl_data.self_ref {\n                 has_self_ref = true;\n                 if !self.span.filter_generated(Some(self_ref.span), item.span) {\n-                    self.dumper.type_ref(item.span, self_ref.clone().normalize(&self.tcx));\n+                    self.dumper.type_ref(self_ref.clone().normalize(&self.tcx));\n                 }\n             }\n             if let Some(ref trait_ref_data) = impl_data.trait_ref {\n                 if !self.span.filter_generated(Some(trait_ref_data.span), item.span) {\n-                    self.dumper.type_ref(item.span, trait_ref_data.clone().normalize(&self.tcx));\n+                    self.dumper.type_ref(trait_ref_data.clone().normalize(&self.tcx));\n                 }\n \n                 visit::walk_path(self, &trait_ref.as_ref().unwrap().path);\n             }\n \n             if !self.span.filter_generated(Some(impl_data.span), item.span) {\n-                self.dumper.impl_data(item.span, ImplData {\n+                self.dumper.impl_data(ImplData {\n                     id: impl_data.id,\n                     span: impl_data.span,\n                     scope: impl_data.scope,\n@@ -678,7 +681,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n         if !self.span.filter_generated(sub_span, item.span) {\n-            self.dumper.trait_data(item.span, TraitData {\n+            self.dumper.trait_data(TraitData {\n                 span: sub_span.expect(\"No span found for trait\"),\n                 id: item.id,\n                 qualname: qualname.clone(),\n@@ -702,7 +705,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             if let Some(id) = self.lookup_type_ref(trait_ref.ref_id) {\n                 let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n                 if !self.span.filter_generated(sub_span, trait_ref.path.span) {\n-                    self.dumper.type_ref(trait_ref.path.span, TypeRefData {\n+                    self.dumper.type_ref(TypeRefData {\n                         span: sub_span.expect(\"No span found for trait ref\"),\n                         ref_id: Some(id),\n                         scope: self.cur_scope,\n@@ -759,47 +762,47 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 if !self.span.filter_generated(Some(vrd.span), path.span) {\n                     match ref_kind {\n                         Some(recorder::TypeRef) => {\n-                            self.dumper.type_ref(path.span, TypeRefData {\n+                            self.dumper.type_ref(TypeRefData {\n                                 span: vrd.span,\n                                 ref_id: Some(vrd.ref_id),\n                                 scope: vrd.scope,\n                                 qualname: String::new()\n                             }.normalize(&self.tcx));\n                         }\n                         Some(recorder::FnRef) => {\n-                            self.dumper.function_ref(path.span, FunctionRefData {\n+                            self.dumper.function_ref(FunctionRefData {\n                                 span: vrd.span,\n                                 ref_id: vrd.ref_id,\n                                 scope: vrd.scope\n                             }.normalize(&self.tcx));\n                         }\n                         Some(recorder::ModRef) => {\n-                            self.dumper.mod_ref(path.span, ModRefData {\n+                            self.dumper.mod_ref( ModRefData {\n                                 span: vrd.span,\n                                 ref_id: Some(vrd.ref_id),\n                                 scope: vrd.scope,\n                                 qualname: String::new()\n                             }.normalize(&self.tcx));\n                         }\n                         Some(recorder::VarRef) | None\n-                            => self.dumper.variable_ref(path.span, vrd.normalize(&self.tcx))\n+                            => self.dumper.variable_ref(vrd.normalize(&self.tcx))\n                     }\n                 }\n \n             }\n             Data::TypeRefData(trd) => {\n                 if !self.span.filter_generated(Some(trd.span), path.span) {\n-                    self.dumper.type_ref(path.span, trd.normalize(&self.tcx));\n+                    self.dumper.type_ref(trd.normalize(&self.tcx));\n                 }\n             }\n             Data::MethodCallData(mcd) => {\n                 if !self.span.filter_generated(Some(mcd.span), path.span) {\n-                    self.dumper.method_call(path.span, mcd.normalize(&self.tcx));\n+                    self.dumper.method_call(mcd.normalize(&self.tcx));\n                 }\n             }\n             Data::FunctionCallData(fcd) => {\n                 if !self.span.filter_generated(Some(fcd.span), path.span) {\n-                    self.dumper.function_call(path.span, fcd.normalize(&self.tcx));\n+                    self.dumper.function_call(fcd.normalize(&self.tcx));\n                 }\n             }\n             _ => {\n@@ -841,7 +844,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         if let Some(struct_lit_data) = self.save_ctxt.get_expr_data(ex) {\n             down_cast_data!(struct_lit_data, TypeRefData, ex.span);\n             if !self.span.filter_generated(Some(struct_lit_data.span), ex.span) {\n-                self.dumper.type_ref(ex.span, struct_lit_data.normalize(&self.tcx));\n+                self.dumper.type_ref(struct_lit_data.normalize(&self.tcx));\n             }\n \n             let scope = self.save_ctxt.enclosing_scope(ex.id);\n@@ -851,7 +854,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                               .get_field_ref_data(field, variant, scope) {\n \n                     if !self.span.filter_generated(Some(field_data.span), field.ident.span) {\n-                        self.dumper.variable_ref(field.ident.span, field_data.normalize(&self.tcx));\n+                        self.dumper.variable_ref(field_data.normalize(&self.tcx));\n                     }\n                 }\n \n@@ -866,7 +869,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         if let Some(mcd) = self.save_ctxt.get_expr_data(ex) {\n             down_cast_data!(mcd, MethodCallData, ex.span);\n             if !self.span.filter_generated(Some(mcd.span), ex.span) {\n-                self.dumper.method_call(ex.span, mcd.normalize(&self.tcx));\n+                self.dumper.method_call(mcd.normalize(&self.tcx));\n             }\n         }\n \n@@ -886,7 +889,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     let sub_span = self.span.span_for_first_ident(span);\n                     if let Some(f) = variant.find_field_named(field.ident.name) {\n                         if !self.span.filter_generated(sub_span, span) {\n-                            self.dumper.variable_ref(span, VariableRefData {\n+                            self.dumper.variable_ref(VariableRefData {\n                                 span: sub_span.expect(\"No span fund for var ref\"),\n                                 ref_id: f.did,\n                                 scope: self.cur_scope,\n@@ -922,7 +925,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             let sub_span = self.span.span_for_last_ident(p.span);\n             // Rust uses the id of the pattern for var lookups, so we'll use it too.\n             if !self.span.filter_generated(sub_span, p.span) {\n-                self.dumper.variable(p.span, VariableData {\n+                self.dumper.variable(VariableData {\n                     span: sub_span.expect(\"No span found for variable\"),\n                     id: id,\n                     name: path_to_string(p),\n@@ -956,7 +959,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             && !data.imported {\n             self.mac_defs.insert(data.callee_span);\n             if let Some(sub_span) = self.span.span_for_macro_def_name(data.callee_span) {\n-                self.dumper.macro_data(data.callee_span, MacroData {\n+                self.dumper.macro_data(MacroData {\n                     span: sub_span,\n                     name: data.name.clone(),\n                     qualname: qualname.clone()\n@@ -966,7 +969,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         if !self.mac_uses.contains(&data.span) {\n             self.mac_uses.insert(data.span);\n             if let Some(sub_span) = self.span.span_for_macro_use_name(data.span) {\n-                self.dumper.macro_use(data.span, MacroUseData {\n+                self.dumper.macro_use(MacroUseData {\n                     span: sub_span,\n                     name: data.name,\n                     qualname: qualname,\n@@ -1007,7 +1010,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                         };\n \n                         if !self.span.filter_generated(sub_span, path.span) {\n-                            self.dumper.use_data(path.span, UseData {\n+                            self.dumper.use_data(UseData {\n                                 span: sub_span.expect(\"No span found for use\"),\n                                 id: item.id,\n                                 mod_id: mod_id,\n@@ -1031,7 +1034,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                         let sub_span = self.span\n                                            .sub_span_of_token(path.span, token::BinOp(token::Star));\n                         if !self.span.filter_generated(sub_span, path.span) {\n-                            self.dumper.use_glob(path.span, UseGlobData {\n+                            self.dumper.use_glob(UseGlobData {\n                                 span: sub_span.expect(\"No span found for use glob\"),\n                                 id: item.id,\n                                 names: names,\n@@ -1073,7 +1076,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                 };\n \n                 if !self.span.filter_generated(alias_span, item.span) {\n-                    self.dumper.extern_crate(item.span, ExternCrateData {\n+                    self.dumper.extern_crate(ExternCrateData {\n                         id: item.id,\n                         name: item.ident.to_string(),\n                         crate_num: cnum,\n@@ -1109,7 +1112,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                 let value = ty_to_string(&ty);\n                 let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n                 if !self.span.filter_generated(sub_span, item.span) {\n-                    self.dumper.typedef(item.span, TypedefData {\n+                    self.dumper.typedef(TypedefData {\n                         span: sub_span.expect(\"No span found for typedef\"),\n                         id: item.id,\n                         qualname: qualname.clone(),\n@@ -1189,7 +1192,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                 if let Some(id) = self.lookup_type_ref(t.id) {\n                     let sub_span = self.span.sub_span_for_type_name(t.span);\n                     if !self.span.filter_generated(sub_span, t.span) {\n-                        self.dumper.type_ref(t.span, TypeRefData {\n+                        self.dumper.type_ref(TypeRefData {\n                             span: sub_span.expect(\"No span found for type ref\"),\n                             ref_id: Some(id),\n                             scope: self.cur_scope,\n@@ -1231,7 +1234,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                 if let Some(field_data) = self.save_ctxt.get_expr_data(ex) {\n                     down_cast_data!(field_data, VariableRefData, ex.span);\n                     if !self.span.filter_generated(Some(field_data.span), ex.span) {\n-                        self.dumper.variable_ref(ex.span, field_data.normalize(&self.tcx));\n+                        self.dumper.variable_ref(field_data.normalize(&self.tcx));\n                     }\n                 }\n             }\n@@ -1244,7 +1247,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                     ty::TyStruct(def, _) => {\n                         let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n                         if !self.span.filter_generated(sub_span, ex.span) {\n-                            self.dumper.variable_ref(ex.span, VariableRefData {\n+                            self.dumper.variable_ref(VariableRefData {\n                                 span: sub_span.expect(\"No span found for var ref\"),\n                                 ref_id: def.struct_variant().fields[idx.node].did,\n                                 scope: self.cur_scope,\n@@ -1334,7 +1337,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                     assert!(p.segments.len() == 1,\n                             \"qualified path for local variable def in arm\");\n                     if !self.span.filter_generated(Some(p.span), p.span) {\n-                        self.dumper.variable(p.span, VariableData {\n+                        self.dumper.variable(VariableData {\n                             span: p.span,\n                             id: id,\n                             name: path_to_string(p),"}, {"sha": "7c379774f2b2ab16883fa5b7bbded808f864c0d1", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "added", "additions": 651, "deletions": 0, "changes": 651, "blob_url": "https://github.com/rust-lang/rust/blob/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=4751e45521e5a1e70f5cf5086b7712c999546af8", "patch": "@@ -0,0 +1,651 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::io::Write;\n+\n+use rustc_serialize::json::as_json;\n+use syntax::codemap::CodeMap;\n+\n+use syntax::ast::CrateNum;\n+\n+use super::data::{self, SpanData};\n+use super::dump::Dump;\n+\n+pub struct JsonDumper<'a, 'b, W: Write + 'b> {\n+    output: &'b mut W,\n+    codemap: &'a CodeMap,\n+    first: bool,\n+}\n+\n+impl<'a, 'b, W: Write> JsonDumper<'a, 'b, W> {\n+    pub fn new(writer: &'b mut W, codemap: &'a CodeMap) -> JsonDumper<'a, 'b, W> {\n+        if let Err(_) = write!(writer, \"[\") {\n+            error!(\"Error writing output\");\n+        }\n+        JsonDumper { output: writer, codemap:codemap, first: true }\n+    }\n+}\n+\n+impl<'a, 'b, W: Write> Drop for JsonDumper<'a, 'b, W> {\n+    fn drop(&mut self) {\n+        if let Err(_) = write!(self.output, \"]\") {\n+            error!(\"Error writing output\");\n+        }\n+    }\n+}\n+\n+macro_rules! impl_fn {\n+    ($fn_name: ident, $data_type: ident) => {\n+        fn $fn_name(&mut self, data: data::$data_type) {\n+            if self.first {\n+                self.first = false;\n+            } else {\n+                if let Err(_) = write!(self.output, \",\") {\n+                    error!(\"Error writing output\");\n+                }\n+            }\n+            let data = data.lower(self.codemap);\n+            if let Err(_) = write!(self.output, \"{}\", as_json(&data)) {\n+                error!(\"Error writing output '{}'\", as_json(&data));\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'b, W: Write + 'b> Dump for JsonDumper<'a, 'b, W> {\n+    impl_fn!(crate_prelude, CratePreludeData);\n+    impl_fn!(enum_data, EnumData);\n+    impl_fn!(extern_crate, ExternCrateData);\n+    impl_fn!(impl_data, ImplData);\n+    impl_fn!(inheritance, InheritanceData);\n+    impl_fn!(function, FunctionData);\n+    impl_fn!(function_ref, FunctionRefData);\n+    impl_fn!(function_call, FunctionCallData);\n+    impl_fn!(method, MethodData);\n+    impl_fn!(method_call, MethodCallData);\n+    impl_fn!(macro_data, MacroData);\n+    impl_fn!(macro_use, MacroUseData);\n+    impl_fn!(mod_data, ModData);\n+    impl_fn!(mod_ref, ModRefData);\n+    impl_fn!(struct_data, StructData);\n+    impl_fn!(struct_variant, StructVariantData);\n+    impl_fn!(trait_data, TraitData);\n+    impl_fn!(tuple_variant, TupleVariantData);\n+    impl_fn!(type_ref, TypeRefData);\n+    impl_fn!(typedef, TypedefData);\n+    impl_fn!(use_data, UseData);\n+    impl_fn!(use_glob, UseGlobData);\n+    impl_fn!(variable, VariableData);\n+    impl_fn!(variable_ref, VariableRefData);\n+}\n+\n+trait Lower {\n+    type Target;\n+    fn lower(self, cm: &CodeMap) -> Self::Target;\n+}\n+\n+pub type Id = u32;\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct CratePreludeData {\n+    pub crate_name: String,\n+    pub crate_root: String,\n+    pub external_crates: Vec<data::ExternalCrateData>,\n+    pub span: SpanData,\n+}\n+\n+impl Lower for data::CratePreludeData {\n+    type Target = CratePreludeData;\n+\n+    fn lower(self, cm: &CodeMap) -> CratePreludeData {\n+        CratePreludeData {\n+            crate_name: self.crate_name,\n+            crate_root: self.crate_root,\n+            external_crates: self.external_crates,\n+            span: SpanData::from_span(self.span, cm),\n+        }\n+    }\n+}\n+\n+/// Data for enum declarations.\n+#[derive(Clone, Debug, RustcEncodable)]\n+pub struct EnumData {\n+    pub id: Id,\n+    pub value: String,\n+    pub qualname: String,\n+    pub span: SpanData,\n+    pub scope: Id,\n+}\n+\n+impl Lower for data::EnumData {\n+    type Target = EnumData;\n+\n+    fn lower(self, cm: &CodeMap) -> EnumData {\n+        EnumData {\n+            id: self.id,\n+            value: self.value,\n+            qualname: self.qualname,\n+            span: SpanData::from_span(self.span, cm),\n+            scope: self.scope,\n+        }\n+    }\n+}\n+\n+/// Data for extern crates.\n+#[derive(Debug, RustcEncodable)]\n+pub struct ExternCrateData {\n+    pub id: Id,\n+    pub name: String,\n+    pub crate_num: CrateNum,\n+    pub location: String,\n+    pub span: SpanData,\n+    pub scope: Id,\n+}\n+\n+impl Lower for data::ExternCrateData {\n+    type Target = ExternCrateData;\n+\n+    fn lower(self, cm: &CodeMap) -> ExternCrateData {\n+        ExternCrateData {\n+            id: self.id,\n+            name: self.name,\n+            crate_num: self.crate_num,\n+            location: self.location,\n+            span: SpanData::from_span(self.span, cm),\n+            scope: self.scope,\n+        }\n+    }\n+}\n+\n+/// Data about a function call.\n+#[derive(Debug, RustcEncodable)]\n+pub struct FunctionCallData {\n+    pub span: SpanData,\n+    pub scope: Id,\n+    pub ref_id: Id,\n+}\n+\n+impl Lower for data::FunctionCallData {\n+    type Target = FunctionCallData;\n+\n+    fn lower(self, cm: &CodeMap) -> FunctionCallData {\n+        FunctionCallData {\n+            span: SpanData::from_span(self.span, cm),\n+            scope: self.scope,\n+            ref_id: self.ref_id.index.as_u32(),\n+        }\n+    }\n+}\n+\n+/// Data for all kinds of functions and methods.\n+#[derive(Clone, Debug, RustcEncodable)]\n+pub struct FunctionData {\n+    pub id: Id,\n+    pub name: String,\n+    pub qualname: String,\n+    pub declaration: Option<Id>,\n+    pub span: SpanData,\n+    pub scope: Id,\n+}\n+\n+impl Lower for data::FunctionData {\n+    type Target = FunctionData;\n+\n+    fn lower(self, cm: &CodeMap) -> FunctionData {\n+        FunctionData {\n+            id: self.id,\n+            name: self.name,\n+            qualname: self.qualname,\n+            declaration: self.declaration.map(|id| id.index.as_u32()),\n+            span: SpanData::from_span(self.span, cm),\n+            scope: self.scope,\n+        }\n+    }\n+}\n+\n+/// Data about a function call.\n+#[derive(Debug, RustcEncodable)]\n+pub struct FunctionRefData {\n+    pub span: SpanData,\n+    pub scope: Id,\n+    pub ref_id: Id,\n+}\n+\n+impl Lower for data::FunctionRefData {\n+    type Target = FunctionRefData;\n+\n+    fn lower(self, cm: &CodeMap) -> FunctionRefData {\n+        FunctionRefData {\n+            span: SpanData::from_span(self.span, cm),\n+            scope: self.scope,\n+            ref_id: self.ref_id.index.as_u32(),\n+        }\n+    }\n+}\n+#[derive(Debug, RustcEncodable)]\n+pub struct ImplData {\n+    pub id: Id,\n+    pub span: SpanData,\n+    pub scope: Id,\n+    pub trait_ref: Option<Id>,\n+    pub self_ref: Option<Id>,\n+}\n+\n+impl Lower for data::ImplData {\n+    type Target = ImplData;\n+\n+    fn lower(self, cm: &CodeMap) -> ImplData {\n+        ImplData {\n+            id: self.id,\n+            span: SpanData::from_span(self.span, cm),\n+            scope: self.scope,\n+            trait_ref: self.trait_ref.map(|id| id.index.as_u32()),\n+            self_ref: self.self_ref.map(|id| id.index.as_u32()),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct InheritanceData {\n+    pub span: SpanData,\n+    pub base_id: Id,\n+    pub deriv_id: Id\n+}\n+\n+impl Lower for data::InheritanceData {\n+    type Target = InheritanceData;\n+\n+    fn lower(self, cm: &CodeMap) -> InheritanceData {\n+        InheritanceData {\n+            span: SpanData::from_span(self.span, cm),\n+            base_id: self.base_id.index.as_u32(),\n+            deriv_id: self.deriv_id\n+        }\n+    }\n+}\n+\n+/// Data about a macro declaration.\n+#[derive(Debug, RustcEncodable)]\n+pub struct MacroData {\n+    pub span: SpanData,\n+    pub name: String,\n+    pub qualname: String,\n+}\n+\n+impl Lower for data::MacroData {\n+    type Target = MacroData;\n+\n+    fn lower(self, cm: &CodeMap) -> MacroData {\n+        MacroData {\n+            span: SpanData::from_span(self.span, cm),\n+            name: self.name,\n+            qualname: self.qualname,\n+        }\n+    }\n+}\n+\n+/// Data about a macro use.\n+#[derive(Debug, RustcEncodable)]\n+pub struct MacroUseData {\n+    pub span: SpanData,\n+    pub name: String,\n+    pub qualname: String,\n+    // Because macro expansion happens before ref-ids are determined,\n+    // we use the callee span to reference the associated macro definition.\n+    pub callee_span: SpanData,\n+    pub scope: Id,\n+    pub imported: bool,\n+}\n+\n+impl Lower for data::MacroUseData {\n+    type Target = MacroUseData;\n+\n+    fn lower(self, cm: &CodeMap) -> MacroUseData {\n+        MacroUseData {\n+            span: SpanData::from_span(self.span, cm),\n+            name: self.name,\n+            qualname: self.qualname,\n+            callee_span: SpanData::from_span(self.callee_span, cm),\n+            scope: self.scope,\n+            imported: self.imported,\n+        }\n+    }\n+}\n+\n+/// Data about a method call.\n+#[derive(Debug, RustcEncodable)]\n+pub struct MethodCallData {\n+    pub span: SpanData,\n+    pub scope: Id,\n+    pub ref_id: Option<Id>,\n+    pub decl_id: Option<Id>,\n+}\n+\n+impl Lower for data::MethodCallData {\n+    type Target = MethodCallData;\n+\n+    fn lower(self, cm: &CodeMap) -> MethodCallData {\n+        MethodCallData {\n+            span: SpanData::from_span(self.span, cm),\n+            scope: self.scope,\n+            ref_id: self.ref_id.map(|id| id.index.as_u32()),\n+            decl_id: self.decl_id.map(|id| id.index.as_u32()),\n+        }\n+    }\n+}\n+\n+/// Data for method declarations (methods with a body are treated as functions).\n+#[derive(Clone, Debug, RustcEncodable)]\n+pub struct MethodData {\n+    pub id: Id,\n+    pub qualname: String,\n+    pub span: SpanData,\n+    pub scope: Id,\n+}\n+\n+impl Lower for data::MethodData {\n+    type Target = MethodData;\n+\n+    fn lower(self, cm: &CodeMap) -> MethodData {\n+        MethodData {\n+            span: SpanData::from_span(self.span, cm),\n+            scope: self.scope,\n+            id: self.id,\n+            qualname: self.qualname,\n+        }\n+    }\n+}\n+\n+/// Data for modules.\n+#[derive(Debug, RustcEncodable)]\n+pub struct ModData {\n+    pub id: Id,\n+    pub name: String,\n+    pub qualname: String,\n+    pub span: SpanData,\n+    pub scope: Id,\n+    pub filename: String,\n+}\n+\n+impl Lower for data::ModData {\n+    type Target = ModData;\n+\n+    fn lower(self, cm: &CodeMap) -> ModData {\n+        ModData {\n+            id: self.id,\n+            name: self.name,\n+            qualname: self.qualname,\n+            span: SpanData::from_span(self.span, cm),\n+            scope: self.scope,\n+            filename: self.filename,\n+        }\n+    }\n+}\n+\n+/// Data for a reference to a module.\n+#[derive(Debug, RustcEncodable)]\n+pub struct ModRefData {\n+    pub span: SpanData,\n+    pub scope: Id,\n+    pub ref_id: Option<Id>,\n+    pub qualname: String\n+}\n+\n+impl Lower for data::ModRefData {\n+    type Target = ModRefData;\n+\n+    fn lower(self, cm: &CodeMap) -> ModRefData {\n+        ModRefData {\n+            span: SpanData::from_span(self.span, cm),\n+            scope: self.scope,\n+            ref_id: self.ref_id.map(|id| id.index.as_u32()),\n+            qualname: self.qualname,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct StructData {\n+    pub span: SpanData,\n+    pub id: Id,\n+    pub ctor_id: Id,\n+    pub qualname: String,\n+    pub scope: Id,\n+    pub value: String\n+}\n+\n+impl Lower for data::StructData {\n+    type Target = StructData;\n+\n+    fn lower(self, cm: &CodeMap) -> StructData {\n+        StructData {\n+            span: SpanData::from_span(self.span, cm),\n+            id: self.id,\n+            ctor_id: self.ctor_id,\n+            qualname: self.qualname,\n+            scope: self.scope,\n+            value: self.value\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct StructVariantData {\n+    pub span: SpanData,\n+    pub id: Id,\n+    pub qualname: String,\n+    pub type_value: String,\n+    pub value: String,\n+    pub scope: Id\n+}\n+\n+impl Lower for data::StructVariantData {\n+    type Target = StructVariantData;\n+\n+    fn lower(self, cm: &CodeMap) -> StructVariantData {\n+        StructVariantData {\n+            span: SpanData::from_span(self.span, cm),\n+            id: self.id,\n+            qualname: self.qualname,\n+            type_value: self.type_value,\n+            value: self.value,\n+            scope: self.scope,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct TraitData {\n+    pub span: SpanData,\n+    pub id: Id,\n+    pub qualname: String,\n+    pub scope: Id,\n+    pub value: String\n+}\n+\n+impl Lower for data::TraitData {\n+    type Target = TraitData;\n+\n+    fn lower(self, cm: &CodeMap) -> TraitData {\n+        TraitData {\n+            span: SpanData::from_span(self.span, cm),\n+            id: self.id,\n+            qualname: self.qualname,\n+            scope: self.scope,\n+            value: self.value,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct TupleVariantData {\n+    pub span: SpanData,\n+    pub id: Id,\n+    pub name: String,\n+    pub qualname: String,\n+    pub type_value: String,\n+    pub value: String,\n+    pub scope: Id,\n+}\n+\n+impl Lower for data::TupleVariantData {\n+    type Target = TupleVariantData;\n+\n+    fn lower(self, cm: &CodeMap) -> TupleVariantData {\n+        TupleVariantData {\n+            span: SpanData::from_span(self.span, cm),\n+            id: self.id,\n+            name: self.name,\n+            qualname: self.qualname,\n+            type_value: self.type_value,\n+            value: self.value,\n+            scope: self.scope,\n+        }\n+    }\n+}\n+\n+/// Data for a typedef.\n+#[derive(Debug, RustcEncodable)]\n+pub struct TypedefData {\n+    pub id: Id,\n+    pub span: SpanData,\n+    pub qualname: String,\n+    pub value: String,\n+}\n+\n+impl Lower for data::TypedefData {\n+    type Target = TypedefData;\n+\n+    fn lower(self, cm: &CodeMap) -> TypedefData {\n+        TypedefData {\n+            id: self.id,\n+            span: SpanData::from_span(self.span, cm),\n+            qualname: self.qualname,\n+            value: self.value,\n+        }\n+    }\n+}\n+\n+/// Data for a reference to a type or trait.\n+#[derive(Clone, Debug, RustcEncodable)]\n+pub struct TypeRefData {\n+    pub span: SpanData,\n+    pub scope: Id,\n+    pub ref_id: Option<Id>,\n+    pub qualname: String,\n+}\n+\n+impl Lower for data::TypeRefData {\n+    type Target = TypeRefData;\n+\n+    fn lower(self, cm: &CodeMap) -> TypeRefData {\n+        TypeRefData {\n+            span: SpanData::from_span(self.span, cm),\n+            scope: self.scope,\n+            ref_id: self.ref_id.map(|id| id.index.as_u32()),\n+            qualname: self.qualname,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct UseData {\n+    pub id: Id,\n+    pub span: SpanData,\n+    pub name: String,\n+    pub mod_id: Option<Id>,\n+    pub scope: Id\n+}\n+\n+impl Lower for data::UseData {\n+    type Target = UseData;\n+\n+    fn lower(self, cm: &CodeMap) -> UseData {\n+        UseData {\n+            id: self.id,\n+            span: SpanData::from_span(self.span, cm),\n+            name: self.name,\n+            mod_id: self.mod_id.map(|id| id.index.as_u32()),\n+            scope: self.scope,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+pub struct UseGlobData {\n+    pub id: Id,\n+    pub span: SpanData,\n+    pub names: Vec<String>,\n+    pub scope: Id\n+}\n+\n+impl Lower for data::UseGlobData {\n+    type Target = UseGlobData;\n+\n+    fn lower(self, cm: &CodeMap) -> UseGlobData {\n+        UseGlobData {\n+            id: self.id,\n+            span: SpanData::from_span(self.span, cm),\n+            names: self.names,\n+            scope: self.scope,\n+        }\n+    }\n+}\n+\n+/// Data for local and global variables (consts and statics).\n+#[derive(Debug, RustcEncodable)]\n+pub struct VariableData {\n+    pub id: Id,\n+    pub name: String,\n+    pub qualname: String,\n+    pub span: SpanData,\n+    pub scope: Id,\n+    pub value: String,\n+    pub type_value: String,\n+}\n+\n+impl Lower for data::VariableData {\n+    type Target = VariableData;\n+\n+    fn lower(self, cm: &CodeMap) -> VariableData {\n+        VariableData {\n+            id: self.id,\n+            name: self.name,\n+            qualname: self.qualname,\n+            span: SpanData::from_span(self.span, cm),\n+            scope: self.scope,\n+            value: self.value,\n+            type_value: self.type_value,\n+        }\n+    }\n+}\n+\n+/// Data for the use of some item (e.g., the use of a local variable, which\n+/// will refer to that variables declaration (by ref_id)).\n+#[derive(Debug, RustcEncodable)]\n+pub struct VariableRefData {\n+    pub name: String,\n+    pub span: SpanData,\n+    pub scope: Id,\n+    pub ref_id: Id,\n+}\n+\n+impl Lower for data::VariableRefData {\n+    type Target = VariableRefData;\n+\n+    fn lower(self, cm: &CodeMap) -> VariableRefData {\n+        VariableRefData {\n+            name: self.name,\n+            span: SpanData::from_span(self.span, cm),\n+            scope: self.scope,\n+            ref_id: self.ref_id.index.as_u32(),\n+        }\n+    }\n+}"}, {"sha": "6830735b0bab4411979bb631680c8f11273227a4", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=4751e45521e5a1e70f5cf5086b7712c999546af8", "patch": "@@ -26,6 +26,7 @@\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n+extern crate serialize as rustc_serialize;\n \n use rustc::hir::{self, lowering};\n use rustc::hir::map::NodeItem;\n@@ -45,13 +46,15 @@ use syntax::visit::{self, Visitor};\n use syntax::print::pprust::ty_to_string;\n \n mod csv_dumper;\n+mod json_dumper;\n mod data;\n mod dump;\n mod dump_visitor;\n #[macro_use]\n pub mod span_utils;\n \n pub use self::csv_dumper::CsvDumper;\n+pub use self::json_dumper::JsonDumper;\n pub use self::data::*;\n pub use self::dump::Dump;\n pub use self::dump_visitor::DumpVisitor;\n@@ -104,9 +107,17 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let mut result = Vec::new();\n \n         for n in self.tcx.sess.cstore.crates() {\n+            let span = match self.tcx.sess.cstore.extern_crate(n) {\n+                Some(ref c) => c.span,\n+                None => {\n+                    debug!(\"Skipping crate {}, no data\", n);\n+                    continue;\n+                }\n+            };\n             result.push(CrateData {\n                 name: (&self.tcx.sess.cstore.crate_name(n)[..]).to_owned(),\n                 number: n,\n+                span: span,\n             });\n         }\n \n@@ -677,24 +688,40 @@ impl<'v> Visitor<'v> for PathCollector {\n     }\n }\n \n+#[derive(Clone, Copy, Debug)]\n+pub enum Format {\n+    Csv,\n+    Json,\n+}\n+\n+impl Format {\n+    fn extension(&self) -> &'static str {\n+        match *self {\n+            Format::Csv => \".csv\",\n+            Format::Json => \".json\",\n+        }\n+    }\n+}\n+\n pub fn process_crate<'l, 'tcx>(tcx: &'l TyCtxt<'tcx>,\n                                lcx: &'l lowering::LoweringContext<'l>,\n                                krate: &ast::Crate,\n                                analysis: &'l ty::CrateAnalysis<'l>,\n                                cratename: &str,\n-                               odir: Option<&Path>) {\n+                               odir: Option<&Path>,\n+                               format: Format) {\n     let _ignore = tcx.dep_graph.in_ignore();\n \n     assert!(analysis.glob_map.is_some());\n \n     info!(\"Dumping crate {}\", cratename);\n \n     // find a path to dump our data to\n-    let mut root_path = match env::var_os(\"DXR_RUST_TEMP_FOLDER\") {\n+    let mut root_path = match env::var_os(\"RUST_SAVE_ANALYSIS_FOLDER\") {\n         Some(val) => PathBuf::from(val),\n         None => match odir {\n-            Some(val) => val.join(\"dxr\"),\n-            None => PathBuf::from(\"dxr-temp\"),\n+            Some(val) => val.join(\"save-analysis\"),\n+            None => PathBuf::from(\"save-analysis-temp\"),\n         },\n     };\n \n@@ -718,22 +745,32 @@ pub fn process_crate<'l, 'tcx>(tcx: &'l TyCtxt<'tcx>,\n     };\n     out_name.push_str(&cratename);\n     out_name.push_str(&tcx.sess.opts.cg.extra_filename);\n-    out_name.push_str(\".csv\");\n+    out_name.push_str(format.extension());\n     root_path.push(&out_name);\n     let mut output_file = File::create(&root_path).unwrap_or_else(|e| {\n         let disp = root_path.display();\n         tcx.sess.fatal(&format!(\"Could not open {}: {}\", disp, e));\n     });\n     root_path.pop();\n+    let output = &mut output_file;\n \n     let utils: SpanUtils<'tcx> = SpanUtils::new(&tcx.sess);\n     let save_ctxt = SaveContext::new(tcx, lcx);\n-    let mut dumper = CsvDumper::new(&mut output_file, utils);\n-    let mut visitor = DumpVisitor::new(tcx, save_ctxt, analysis, &mut dumper);\n-    // FIXME: we don't write anything!\n \n-    visitor.dump_crate_info(cratename, krate);\n-    visit::walk_crate(&mut visitor, krate);\n+    macro_rules! dump {\n+        ($new_dumper: expr) => {{\n+            let mut dumper = $new_dumper;\n+            let mut visitor = DumpVisitor::new(tcx, save_ctxt, analysis, &mut dumper);\n+\n+            visitor.dump_crate_info(cratename, krate);\n+            visit::walk_crate(&mut visitor, krate);\n+        }}\n+    }\n+\n+    match format {\n+        Format::Csv => dump!(CsvDumper::new(output, utils)),\n+        Format::Json => dump!(JsonDumper::new(output, utils.sess.codemap())),\n+    }\n }\n \n // Utility functions for the module."}, {"sha": "3c636baaedc5fa27b2992a149c38771290df5033", "filename": "src/test/run-make/save-analysis/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Ftest%2Frun-make%2Fsave-analysis%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/4751e45521e5a1e70f5cf5086b7712c999546af8/src%2Ftest%2Frun-make%2Fsave-analysis%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2FMakefile?ref=4751e45521e5a1e70f5cf5086b7712c999546af8", "patch": "@@ -3,4 +3,5 @@ all: code\n krate2: krate2.rs\n \t$(RUSTC) $<\n code: foo.rs krate2\n+\t$(RUSTC) foo.rs -Zsave-analysis-csv\n \t$(RUSTC) foo.rs -Zsave-analysis"}]}