{"sha": "6ac4a308101f561ec90f99c7eb405c01e2a30153", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhYzRhMzA4MTAxZjU2MWVjOTBmOTljN2ViNDA1YzAxZTJhMzAxNTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-03T16:01:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-03T16:01:12Z"}, "message": "auto merge of #16634 : apoelstra/rust/to-option-fix, r=aturon\n\nAs outlined in\r\n\r\n  https://aturon.github.io/style/naming/conversions.html\r\n\r\n`to_` functions names should only be used for expensive operations.\r\nThus `to_option` is better named `as_option`. Also, putting type\r\nnames into method names is considered bad style; what the user is\r\nreally trying to get is a reference. This `as_ref` is even better.\r\n\r\nAlso, we are missing a mutable version of this method.\r\n\r\nFinally, there is a bug in the signature of `to_option` which has\r\nbeen around since lifetime elision: originally the returned reference\r\nhad 'static lifetime, but since the elision changes this become\r\nthe lifetime of the raw pointer (which does not make sense, since\r\nthe pointer lifetime and referent lifetime are unrelated). We fix\r\nthe bug to return a reference with a fresh lifetime which will be\r\ninferred from the calling context.\r\n\r\n[breaking-change]", "tree": {"sha": "c91698169b6dc1150cabbd1f36f3cfac2b2dffb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c91698169b6dc1150cabbd1f36f3cfac2b2dffb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ac4a308101f561ec90f99c7eb405c01e2a30153", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ac4a308101f561ec90f99c7eb405c01e2a30153", "html_url": "https://github.com/rust-lang/rust/commit/6ac4a308101f561ec90f99c7eb405c01e2a30153", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ac4a308101f561ec90f99c7eb405c01e2a30153/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a8986776d16c16ef4685aa38c3f6a2c0efa7884", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a8986776d16c16ef4685aa38c3f6a2c0efa7884", "html_url": "https://github.com/rust-lang/rust/commit/8a8986776d16c16ef4685aa38c3f6a2c0efa7884"}, {"sha": "00ff5aac4ef48615321610b73f30da825700fb78", "url": "https://api.github.com/repos/rust-lang/rust/commits/00ff5aac4ef48615321610b73f30da825700fb78", "html_url": "https://github.com/rust-lang/rust/commit/00ff5aac4ef48615321610b73f30da825700fb78"}], "stats": {"total": 85, "additions": 70, "deletions": 15}, "files": [{"sha": "0ed946aa947db21c95f9c9caaf564cbca4fadc01", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac4a308101f561ec90f99c7eb405c01e2a30153/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac4a308101f561ec90f99c7eb405c01e2a30153/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=6ac4a308101f561ec90f99c7eb405c01e2a30153", "patch": "@@ -90,7 +90,7 @@ impl<T> Rawlink<T> {\n     /// Convert the `Rawlink` into an Option value\n     fn resolve_immut<'a>(&self) -> Option<&'a T> {\n         unsafe {\n-            mem::transmute(self.p.to_option())\n+            self.p.as_ref()\n         }\n     }\n "}, {"sha": "d1bea25dded41f2e36fbf9e3d69b1420414eeb94", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6ac4a308101f561ec90f99c7eb405c01e2a30153/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac4a308101f561ec90f99c7eb405c01e2a30153/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=6ac4a308101f561ec90f99c7eb405c01e2a30153", "patch": "@@ -256,27 +256,46 @@ pub unsafe fn position<T>(buf: *const T, f: |&T| -> bool) -> uint {\n pub trait RawPtr<T> {\n     /// Returns the null pointer.\n     fn null() -> Self;\n+\n     /// Returns true if the pointer is equal to the null pointer.\n     fn is_null(&self) -> bool;\n+\n     /// Returns true if the pointer is not equal to the null pointer.\n     fn is_not_null(&self) -> bool { !self.is_null() }\n+\n     /// Returns the value of this pointer (ie, the address it points to)\n     fn to_uint(&self) -> uint;\n-    /// Returns `None` if the pointer is null, or else returns the value wrapped\n-    /// in `Some`.\n+\n+    /// Returns `None` if the pointer is null, or else returns a reference to the\n+    /// value wrapped in `Some`.\n     ///\n     /// # Safety Notes\n     ///\n-    /// While this method is useful for null-safety, it is important to note\n-    /// that this is still an unsafe operation because the returned value could\n-    /// be pointing to invalid memory.\n-    unsafe fn to_option(&self) -> Option<&T>;\n+    /// While this method and its mutable counterpart are useful for null-safety,\n+    /// it is important to note that this is still an unsafe operation because\n+    /// the returned value could be pointing to invalid memory.\n+    unsafe fn as_ref<'a>(&self) -> Option<&'a T>;\n+\n+    /// A synonym for `as_ref`, except with incorrect lifetime semantics\n+    #[deprecated=\"Use `as_ref` instead\"]\n+    unsafe fn to_option<'a>(&'a self) -> Option<&'a T> {\n+        mem::transmute(self.as_ref())\n+    }\n+\n     /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n     /// the object, or one-byte-past-the-end.  `count` is in units of T; e.g. a\n     /// `count` of 3 represents a pointer offset of `3 * sizeof::<T>()` bytes.\n     unsafe fn offset(self, count: int) -> Self;\n }\n \n+/// Methods on mutable raw pointers\n+pub trait RawMutPtr<T>{\n+    /// Returns `None` if the pointer is null, or else returns a mutable reference\n+    /// to the value wrapped in `Some`. As with `as_ref`, this is unsafe because\n+    /// it cannot verify the validity of the returned pointer.\n+    unsafe fn as_mut<'a>(&self) -> Option<&'a mut T>;\n+}\n+\n impl<T> RawPtr<T> for *const T {\n     #[inline]\n     fn null() -> *const T { null() }\n@@ -293,7 +312,7 @@ impl<T> RawPtr<T> for *const T {\n     }\n \n     #[inline]\n-    unsafe fn to_option(&self) -> Option<&T> {\n+    unsafe fn as_ref<'a>(&self) -> Option<&'a T> {\n         if self.is_null() {\n             None\n         } else {\n@@ -318,7 +337,7 @@ impl<T> RawPtr<T> for *mut T {\n     }\n \n     #[inline]\n-    unsafe fn to_option(&self) -> Option<&T> {\n+    unsafe fn as_ref<'a>(&self) -> Option<&'a T> {\n         if self.is_null() {\n             None\n         } else {\n@@ -327,6 +346,17 @@ impl<T> RawPtr<T> for *mut T {\n     }\n }\n \n+impl<T> RawMutPtr<T> for *mut T {\n+    #[inline]\n+    unsafe fn as_mut<'a>(&self) -> Option<&'a mut T> {\n+        if self.is_null() {\n+            None\n+        } else {\n+            Some(&mut **self)\n+        }\n+    }\n+}\n+\n // Equality for pointers\n impl<T> PartialEq for *const T {\n     #[inline]"}, {"sha": "754391a284ddfd9a415f28ca9be2bce64063341d", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6ac4a308101f561ec90f99c7eb405c01e2a30153/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac4a308101f561ec90f99c7eb405c01e2a30153/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=6ac4a308101f561ec90f99c7eb405c01e2a30153", "patch": "@@ -102,19 +102,44 @@ fn test_is_null() {\n }\n \n #[test]\n-fn test_to_option() {\n+fn test_as_ref() {\n     unsafe {\n         let p: *const int = null();\n-        assert_eq!(p.to_option(), None);\n+        assert_eq!(p.as_ref(), None);\n \n         let q: *const int = &2;\n-        assert_eq!(q.to_option().unwrap(), &2);\n+        assert_eq!(q.as_ref().unwrap(), &2);\n \n         let p: *mut int = mut_null();\n-        assert_eq!(p.to_option(), None);\n+        assert_eq!(p.as_ref(), None);\n \n         let q: *mut int = &mut 2;\n-        assert_eq!(q.to_option().unwrap(), &2);\n+        assert_eq!(q.as_ref().unwrap(), &2);\n+\n+        // Lifetime inference\n+        let u = 2i;\n+        {\n+            let p: *const int = &u as *const _;\n+            assert_eq!(p.as_ref().unwrap(), &2);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_as_mut() {\n+    unsafe {\n+        let p: *mut int = mut_null();\n+        assert!(p.as_mut() == None);\n+\n+        let q: *mut int = &mut 2;\n+        assert!(q.as_mut().unwrap() == &mut 2);\n+\n+        // Lifetime inference\n+        let mut u = 2i;\n+        {\n+            let p: *mut int = &mut u as *mut _;\n+            assert!(p.as_mut().unwrap() == &mut 2);\n+        }\n     }\n }\n "}, {"sha": "6461a6cf402a079b1dddf7e383ba0a885f2082c7", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac4a308101f561ec90f99c7eb405c01e2a30153/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac4a308101f561ec90f99c7eb405c01e2a30153/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=6ac4a308101f561ec90f99c7eb405c01e2a30153", "patch": "@@ -282,7 +282,7 @@ impl Drop for DefaultLogger {\n pub fn log(level: u32, loc: &'static LogLocation, args: &fmt::Arguments) {\n     // Test the literal string from args against the current filter, if there\n     // is one.\n-    match unsafe { FILTER.to_option() } {\n+    match unsafe { FILTER.as_ref() } {\n         Some(filter) if filter.is_match(args.to_string().as_slice()) => return,\n         _ => {}\n     }"}]}