{"sha": "7feb003882ecf7699e6705b537673e20985accff", "node_id": "C_kwDOAAsO6NoAKDdmZWIwMDM4ODJlY2Y3Njk5ZTY3MDViNTM3NjczZTIwOTg1YWNjZmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-24T00:29:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-24T00:29:51Z"}, "message": "Auto merge of #103452 - notriddle:rollup-peewevm, r=notriddle\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #100462 (Clarify `array::from_fn` documentation)\n - #101644 (Document surprising and dangerous fs::Permissions behaviour on Unix)\n - #103005 (kmc-solid: Handle errors returned by `SOLID_FS_ReadDir`)\n - #103140 (Add diagnostic for calling a function with the same name with unresolved Macro)\n - #103254 (rustdoc: do not filter out cross-crate `Self: Sized` bounds)\n - #103347 (bootstrap: also create rustc-src component in sysroot)\n - #103402 (Fix wrapped valid-range handling in ty_find_init_error)\n - #103414 (Pretty print lifetimes captured by RPIT)\n - #103424 (rustdoc: remove no-op CSS `.code-header { border-bottom: none }`)\n - #103434 (Use functions for jump-to-def-background rustdoc GUI test)\n - #103447 (`MaybeUninit`: use `assume_init_drop()` in the partially initialized array example)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "1b40d50643374db387bde03626fabbc1845439db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b40d50643374db387bde03626fabbc1845439db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7feb003882ecf7699e6705b537673e20985accff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7feb003882ecf7699e6705b537673e20985accff", "html_url": "https://github.com/rust-lang/rust/commit/7feb003882ecf7699e6705b537673e20985accff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7feb003882ecf7699e6705b537673e20985accff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7aa361390867181d225a7775340f50e8162e16a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7aa361390867181d225a7775340f50e8162e16a2", "html_url": "https://github.com/rust-lang/rust/commit/7aa361390867181d225a7775340f50e8162e16a2"}, {"sha": "ae2b1f096f888b4a248665184cb11fe763012a50", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae2b1f096f888b4a248665184cb11fe763012a50", "html_url": "https://github.com/rust-lang/rust/commit/ae2b1f096f888b4a248665184cb11fe763012a50"}], "stats": {"total": 450, "additions": 305, "deletions": 145}, "files": [{"sha": "53c4910513422421f6feb8345d4ea435d24199b4", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -2526,7 +2526,10 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                         // return `Bound::Excluded`.  (And we have tests checking that we\n                         // handle the attribute correctly.)\n                         // We don't add a span since users cannot declare such types anyway.\n-                        (Bound::Included(lo), _) if lo > 0 => {\n+                        (Bound::Included(lo), Bound::Included(hi)) if 0 < lo && lo < hi => {\n+                            return Some((format!(\"`{}` must be non-null\", ty), None));\n+                        }\n+                        (Bound::Included(lo), Bound::Unbounded) if 0 < lo => {\n                             return Some((format!(\"`{}` must be non-null\", ty), None));\n                         }\n                         (Bound::Included(_), _) | (_, Bound::Included(_))"}, {"sha": "b8ee2b994b1e472ab6d330215587c869c0780fa7", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -16,6 +16,7 @@ use rustc_session::cstore::{ExternCrate, ExternCrateSource};\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n+use smallvec::SmallVec;\n \n use std::cell::Cell;\n use std::char;\n@@ -794,6 +795,7 @@ pub trait PrettyPrinter<'tcx>:\n         let mut traits = FxIndexMap::default();\n         let mut fn_traits = FxIndexMap::default();\n         let mut is_sized = false;\n+        let mut lifetimes = SmallVec::<[ty::Region<'tcx>; 1]>::new();\n \n         for (predicate, _) in bounds.subst_iter_copied(tcx, substs) {\n             let bound_predicate = predicate.kind();\n@@ -824,6 +826,9 @@ pub trait PrettyPrinter<'tcx>:\n                         &mut fn_traits,\n                     );\n                 }\n+                ty::PredicateKind::TypeOutlives(outlives) => {\n+                    lifetimes.push(outlives.1);\n+                }\n                 _ => {}\n             }\n         }\n@@ -977,6 +982,11 @@ pub trait PrettyPrinter<'tcx>:\n             write!(self, \"Sized\")?;\n         }\n \n+        for re in lifetimes {\n+            write!(self, \" + \")?;\n+            self = self.print_region(re)?;\n+        }\n+\n         Ok(self)\n     }\n "}, {"sha": "9526296f9511530119db79663bd07f0f61099300", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -12,7 +12,7 @@ use rustc_attr::StabilityLevel;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::struct_span_err;\n+use rustc_errors::{struct_span_err, Applicability};\n use rustc_expand::base::{Annotatable, DeriveResolutions, Indeterminate, ResolverExpand};\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::compile_declarative_macro;\n@@ -694,7 +694,19 @@ impl<'a> Resolver<'a> {\n                     check_consistency(self, &path, path_span, kind, initial_res, res)\n                 }\n                 path_res @ PathResult::NonModule(..) | path_res @ PathResult::Failed { .. } => {\n+                    let mut suggestion = None;\n                     let (span, label) = if let PathResult::Failed { span, label, .. } = path_res {\n+                        // try to suggest if it's not a macro, maybe a function\n+                        if let PathResult::NonModule(partial_res) = self.maybe_resolve_path(&path, Some(ValueNS), &parent_scope)\n+                            && partial_res.unresolved_segments() == 0 {\n+                            let sm = self.session.source_map();\n+                            let exclamation_span = sm.next_point(span);\n+                            suggestion = Some((\n+                                vec![(exclamation_span, \"\".to_string())],\n+                                    format!(\"{} is not a macro, but a {}, try to remove `!`\", Segment::names_to_string(&path), partial_res.base_res().descr()),\n+                                    Applicability::MaybeIncorrect\n+                                ));\n+                        }\n                         (span, label)\n                     } else {\n                         (\n@@ -708,7 +720,7 @@ impl<'a> Resolver<'a> {\n                     };\n                     self.report_error(\n                         span,\n-                        ResolutionError::FailedToResolve { label, suggestion: None },\n+                        ResolutionError::FailedToResolve { label, suggestion },\n                     );\n                 }\n                 PathResult::Module(..) | PathResult::Indeterminate => unreachable!(),"}, {"sha": "eae0e1c7618663459a2148fb20ab6baef6606c87", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -32,6 +32,10 @@ pub use iter::IntoIter;\n /// # Example\n ///\n /// ```rust\n+/// // type inference is helping us here, the way `from_fn` knows how many\n+/// // elements to produce is the length of array down there: only arrays of\n+/// // equal lengths can be compared, so the const generic parameter `N` is\n+/// // inferred to be 5, thus creating array of 5 elements.\n /// let array = core::array::from_fn(|i| i);\n /// assert_eq!(array, [0, 1, 2, 3, 4]);\n /// ```"}, {"sha": "7757c95de9d2a27a9dcf9369a03825c0844561fa", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -146,7 +146,6 @@ use crate::slice;\n ///\n /// ```\n /// use std::mem::MaybeUninit;\n-/// use std::ptr;\n ///\n /// // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n /// // safe because the type we are claiming to have initialized here is a\n@@ -162,7 +161,7 @@ use crate::slice;\n ///\n /// // For each item in the array, drop if we allocated it.\n /// for elem in &mut data[0..data_len] {\n-///     unsafe { ptr::drop_in_place(elem.as_mut_ptr()); }\n+///     unsafe { elem.assume_init_drop(); }\n /// }\n /// ```\n ///"}, {"sha": "188ff00e1f8dda454aecd1e3ef4874a5259ddf7b", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 64, "deletions": 3, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -1365,6 +1365,34 @@ impl FileTimes {\n impl Permissions {\n     /// Returns `true` if these permissions describe a readonly (unwritable) file.\n     ///\n+    /// # Note\n+    ///\n+    /// This function does not take Access Control Lists (ACLs) or Unix group\n+    /// membership into account.\n+    ///\n+    /// # Windows\n+    ///\n+    /// On Windows this returns [`FILE_ATTRIBUTE_READONLY`](https://docs.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants).\n+    /// If `FILE_ATTRIBUTE_READONLY` is set then writes to the file will fail\n+    /// but the user may still have permission to change this flag. If\n+    /// `FILE_ATTRIBUTE_READONLY` is *not* set then writes may still fail due\n+    /// to lack of write permission.\n+    /// The behavior of this attribute for directories depends on the Windows\n+    /// version.\n+    ///\n+    /// # Unix (including macOS)\n+    ///\n+    /// On Unix-based platforms this checks if *any* of the owner, group or others\n+    /// write permission bits are set. It does not check if the current\n+    /// user is in the file's assigned group. It also does not check ACLs.\n+    /// Therefore even if this returns true you may not be able to write to the\n+    /// file, and vice versa. The [`PermissionsExt`] trait gives direct access\n+    /// to the permission bits but also does not read ACLs. If you need to\n+    /// accurately know whether or not a file is writable use the `access()`\n+    /// function from libc.\n+    ///\n+    /// [`PermissionsExt`]: crate::os::unix::fs::PermissionsExt\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -1390,8 +1418,40 @@ impl Permissions {\n     /// using the resulting `Permission` will update file permissions to allow\n     /// writing.\n     ///\n-    /// This operation does **not** modify the filesystem. To modify the\n-    /// filesystem use the [`set_permissions`] function.\n+    /// This operation does **not** modify the files attributes. This only\n+    /// changes the in-memory value of these attributes for this `Permissions`\n+    /// instance. To modify the files attributes use the [`set_permissions`]\n+    /// function which commits these attribute changes to the file.\n+    ///\n+    /// # Note\n+    ///\n+    /// `set_readonly(false)` makes the file *world-writable* on Unix.\n+    /// You can use the [`PermissionsExt`] trait on Unix to avoid this issue.\n+    ///\n+    /// It also does not take Access Control Lists (ACLs) or Unix group\n+    /// membership into account.\n+    ///\n+    /// # Windows\n+    ///\n+    /// On Windows this sets or clears [`FILE_ATTRIBUTE_READONLY`](https://docs.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants).\n+    /// If `FILE_ATTRIBUTE_READONLY` is set then writes to the file will fail\n+    /// but the user may still have permission to change this flag. If\n+    /// `FILE_ATTRIBUTE_READONLY` is *not* set then the write may still fail if\n+    /// the user does not have permission to write to the file.\n+    ///\n+    /// In Windows 7 and earlier this attribute prevents deleting empty\n+    /// directories. It does not prevent modifying the directory contents.\n+    /// On later versions of Windows this attribute is ignored for directories.\n+    ///\n+    /// # Unix (including macOS)\n+    ///\n+    /// On Unix-based platforms this sets or clears the write access bit for\n+    /// the owner, group *and* others, equivalent to `chmod a+w <file>`\n+    /// or `chmod a-w <file>` respectively. The latter will grant write access\n+    /// to all users! You can use the [`PermissionsExt`] trait on Unix\n+    /// to avoid this issue.\n+    ///\n+    /// [`PermissionsExt`]: crate::os::unix::fs::PermissionsExt\n     ///\n     /// # Examples\n     ///\n@@ -1405,7 +1465,8 @@ impl Permissions {\n     ///\n     ///     permissions.set_readonly(true);\n     ///\n-    ///     // filesystem doesn't change\n+    ///     // filesystem doesn't change, only the in memory state of the\n+    ///     // readonly permission\n     ///     assert_eq!(false, metadata.permissions().readonly());\n     ///\n     ///     // just this particular `permissions`."}, {"sha": "6c66b93a3e1a306e1ae9ca0abc8b3bbbac4ef767", "filename": "library/std/src/sys/solid/fs.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -175,15 +175,19 @@ impl Iterator for ReadDir {\n     type Item = io::Result<DirEntry>;\n \n     fn next(&mut self) -> Option<io::Result<DirEntry>> {\n-        unsafe {\n-            let mut out_dirent = MaybeUninit::uninit();\n-            error::SolidError::err_if_negative(abi::SOLID_FS_ReadDir(\n+        let entry = unsafe {\n+            let mut out_entry = MaybeUninit::uninit();\n+            match error::SolidError::err_if_negative(abi::SOLID_FS_ReadDir(\n                 self.inner.dirp,\n-                out_dirent.as_mut_ptr(),\n-            ))\n-            .ok()?;\n-            Some(Ok(DirEntry { entry: out_dirent.assume_init(), inner: Arc::clone(&self.inner) }))\n-        }\n+                out_entry.as_mut_ptr(),\n+            )) {\n+                Ok(_) => out_entry.assume_init(),\n+                Err(e) if e.as_raw() == abi::SOLID_ERR_NOTFOUND => return None,\n+                Err(e) => return Some(Err(e.as_io_error())),\n+            }\n+        };\n+\n+        (entry.d_name[0] != 0).then(|| Ok(DirEntry { entry, inner: Arc::clone(&self.inner) }))\n     }\n }\n "}, {"sha": "e02a10b81640811b88770e6d95d9c378e32604d1", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -1177,6 +1177,20 @@ impl Step for Sysroot {\n                 );\n             }\n         }\n+        // Same for the rustc-src component.\n+        let sysroot_lib_rustlib_rustcsrc = sysroot.join(\"lib/rustlib/rustc-src\");\n+        t!(fs::create_dir_all(&sysroot_lib_rustlib_rustcsrc));\n+        let sysroot_lib_rustlib_rustcsrc_rust = sysroot_lib_rustlib_rustcsrc.join(\"rust\");\n+        if let Err(e) =\n+            symlink_dir(&builder.config, &builder.src, &sysroot_lib_rustlib_rustcsrc_rust)\n+        {\n+            eprintln!(\n+                \"warning: creating symbolic link `{}` to `{}` failed with {}\",\n+                sysroot_lib_rustlib_rustcsrc_rust.display(),\n+                builder.src.display(),\n+                e,\n+            );\n+        }\n \n         INTERNER.intern_path(sysroot)\n     }"}, {"sha": "d86a26826416423a7b63a0a0232d2473db3d4f09", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -774,31 +774,36 @@ fn clean_ty_generics<'tcx>(\n     let mut where_predicates =\n         where_predicates.into_iter().flat_map(|p| clean_predicate(*p, cx)).collect::<Vec<_>>();\n \n-    // Type parameters have a Sized bound by default unless removed with\n-    // ?Sized. Scan through the predicates and mark any type parameter with\n-    // a Sized bound, removing the bounds as we find them.\n+    // In the surface language, all type parameters except `Self` have an\n+    // implicit `Sized` bound unless removed with `?Sized`.\n+    // However, in the list of where-predicates below, `Sized` appears like a\n+    // normal bound: It's either present (the type is sized) or\n+    // absent (the type is unsized) but never *maybe* (i.e. `?Sized`).\n     //\n-    // Note that associated types also have a sized bound by default, but we\n+    // This is unsuitable for rendering.\n+    // Thus, as a first step remove all `Sized` bounds that should be implicit.\n+    //\n+    // Note that associated types also have an implicit `Sized` bound but we\n     // don't actually know the set of associated types right here so that's\n-    // handled in cleaning associated types\n+    // handled when cleaning associated types.\n     let mut sized_params = FxHashSet::default();\n-    where_predicates.retain(|pred| match *pred {\n-        WherePredicate::BoundPredicate { ty: Generic(ref g), ref bounds, .. } => {\n-            if bounds.iter().any(|b| b.is_sized_bound(cx)) {\n-                sized_params.insert(*g);\n-                false\n-            } else {\n-                true\n-            }\n+    where_predicates.retain(|pred| {\n+        if let WherePredicate::BoundPredicate { ty: Generic(g), bounds, .. } = pred\n+        && *g != kw::SelfUpper\n+        && bounds.iter().any(|b| b.is_sized_bound(cx))\n+        {\n+            sized_params.insert(*g);\n+            false\n+        } else {\n+            true\n         }\n-        _ => true,\n     });\n \n-    // Run through the type parameters again and insert a ?Sized\n-    // unbound for any we didn't find to be Sized.\n+    // As a final step, go through the type parameters again and insert a\n+    // `?Sized` bound for each one we didn't find to be `Sized`.\n     for tp in &stripped_params {\n-        if matches!(tp.kind, types::GenericParamDefKind::Type { .. })\n-            && !sized_params.contains(&tp.name)\n+        if let types::GenericParamDefKind::Type { .. } = tp.kind\n+        && !sized_params.contains(&tp.name)\n         {\n             where_predicates.push(WherePredicate::BoundPredicate {\n                 ty: Type::Generic(tp.name),"}, {"sha": "293c9787609b012dd3b2ec998850ae946c2bc1c0", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -184,7 +184,6 @@ h4.code-header {\n }\n .code-header {\n \tfont-weight: 600;\n-\tborder-bottom-style: none;\n \tmargin: 0;\n \tpadding: 0;\n }"}, {"sha": "b65faf13d0c5335b4881fe06a754fc536f1fe2ce", "filename": "src/test/rustdoc-gui/jump-to-def-background.goml", "status": "modified", "additions": 17, "deletions": 38, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Frustdoc-gui%2Fjump-to-def-background.goml", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Frustdoc-gui%2Fjump-to-def-background.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fjump-to-def-background.goml?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -1,43 +1,22 @@\n // We check the background color on the jump to definition links in the source code page.\n goto: \"file://\" + |DOC_PATH| + \"/src/link_to_definition/lib.rs.html\"\n \n-// Set the theme to dark.\n-local-storage: {\n-    \"rustdoc-theme\": \"dark\",\n-    \"rustdoc-preferred-dark-theme\": \"dark\",\n-    \"rustdoc-use-system-theme\": \"false\",\n-}\n-// We reload the page so the local storage settings are being used.\n-reload:\n-\n-assert-css: (\n-    \"body.source .example-wrap pre.rust a\",\n-    {\"background-color\": \"rgb(51, 51, 51)\"},\n-    ALL,\n-)\n-\n-// Set the theme to ayu.\n-local-storage: {\n-    \"rustdoc-theme\": \"ayu\",\n-    \"rustdoc-preferred-dark-theme\": \"ayu\",\n-    \"rustdoc-use-system-theme\": \"false\",\n-}\n-// We reload the page so the local storage settings are being used.\n-reload:\n-\n-assert-css: (\n-    \"body.source .example-wrap pre.rust a\",\n-    {\"background-color\": \"rgb(51, 51, 51)\"},\n-    ALL,\n+define-function: (\n+    \"check-background-color\",\n+    (theme, background_color),\n+    [\n+        // Set the theme.\n+        (\"local-storage\", { \"rustdoc-theme\": |theme|, \"rustdoc-use-system-theme\": \"false\" }),\n+        // We reload the page so the local storage settings are being used.\n+        (\"reload\"),\n+        (\"assert-css\", (\n+            \"body.source .example-wrap pre.rust a\",\n+            {\"background-color\": |background_color|},\n+            ALL,\n+        )),\n+    ],\n )\n \n-// Set the theme to light.\n-local-storage: {\"rustdoc-theme\": \"light\", \"rustdoc-use-system-theme\": \"false\"}\n-// We reload the page so the local storage settings are being used.\n-reload:\n-\n-assert-css: (\n-    \"body.source .example-wrap pre.rust a\",\n-    {\"background-color\": \"rgb(238, 238, 238)\"},\n-    ALL,\n-)\n+call-function: (\"check-background-color\", (\"ayu\", \"rgb(51, 51, 51)\"))\n+call-function: (\"check-background-color\", (\"dark\", \"rgb(51, 51, 51)\"))\n+call-function: (\"check-background-color\", (\"light\", \"rgb(238, 238, 238)\"))"}, {"sha": "e7a13acc6f864bd7cc41de40033c6d556ac275e6", "filename": "src/test/rustdoc/inline_cross/auxiliary/issue-24183.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fissue-24183.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fissue-24183.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fissue-24183.rs?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -0,0 +1,14 @@\n+#![crate_type = \"lib\"]\n+\n+pub trait U/*: ?Sized */ {\n+    fn modified(self) -> Self\n+    where\n+        Self: Sized\n+    {\n+        self\n+    }\n+\n+    fn touch(&self)/* where Self: ?Sized */{}\n+}\n+\n+pub trait S: Sized {}"}, {"sha": "6955a961499ba5a4f73b891f2b77debb6957443b", "filename": "src/test/rustdoc/inline_cross/issue-24183.method_no_where_self_sized.html", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-24183.method_no_where_self_sized.html", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-24183.method_no_where_self_sized.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-24183.method_no_where_self_sized.html?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -0,0 +1 @@\n+<h4 class=\"code-header\">fn <a href=\"#method.touch\" class=\"fnname\">touch</a>(&amp;self)</h4>\n\\ No newline at end of file"}, {"sha": "d11b6955f3c0f796d9fd46281404f909c2bc156c", "filename": "src/test/rustdoc/inline_cross/issue-24183.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-24183.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-24183.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fissue-24183.rs?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -0,0 +1,18 @@\n+#![crate_type = \"lib\"]\n+#![crate_name = \"usr\"]\n+\n+// aux-crate:issue_24183=issue-24183.rs\n+// edition: 2021\n+\n+// @has usr/trait.U.html\n+// @has - '//*[@class=\"item-decl\"]' \"pub trait U {\"\n+// @has - '//*[@id=\"method.modified\"]' \\\n+// \"fn modified(self) -> Self\\\n+// where \\\n+//     Self: Sized\"\n+// @snapshot method_no_where_self_sized - '//*[@id=\"method.touch\"]/*[@class=\"code-header\"]'\n+pub use issue_24183::U;\n+\n+// @has usr/trait.S.html\n+// @has - '//*[@class=\"item-decl\"]' 'pub trait S: Sized {'\n+pub use issue_24183::S;"}, {"sha": "8eb8c44bb420e03df9eb378d469d3030f81bf196", "filename": "src/test/ui/associated-type-bounds/inside-adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.rs?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -16,7 +16,7 @@ enum E2 { V(Box<dyn Iterator<Item: Copy>>) }\n //~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n enum E3 { V(dyn Iterator<Item: 'static>) }\n //~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n-//~| ERROR the size for values of type `(dyn Iterator<Item = impl Sized> + 'static)`\n+//~| ERROR the size for values of type `(dyn Iterator<Item = impl Sized + 'static> + 'static)`\n \n union U1 { f: ManuallyDrop<dyn Iterator<Item: Copy>> }\n //~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n@@ -25,6 +25,6 @@ union U2 { f: ManuallyDrop<Box<dyn Iterator<Item: Copy>>> }\n //~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n union U3 { f: ManuallyDrop<dyn Iterator<Item: 'static>> }\n //~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n-//~| ERROR the size for values of type `(dyn Iterator<Item = impl Sized> + 'static)`\n+//~| ERROR the size for values of type `(dyn Iterator<Item = impl Sized + 'static> + 'static)`\n \n fn main() {}"}, {"sha": "dbfcfa5806309c0be12cf5cf55b2c5e23b1f953a", "filename": "src/test/ui/associated-type-bounds/inside-adt.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.stderr?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -70,13 +70,13 @@ help: the `Box` type always has a statically known size and allocates its conten\n LL | enum E1 { V(Box<dyn Iterator<Item: Copy>>) }\n    |             ++++                        +\n \n-error[E0277]: the size for values of type `(dyn Iterator<Item = impl Sized> + 'static)` cannot be known at compilation time\n+error[E0277]: the size for values of type `(dyn Iterator<Item = impl Sized + 'static> + 'static)` cannot be known at compilation time\n   --> $DIR/inside-adt.rs:17:13\n    |\n LL | enum E3 { V(dyn Iterator<Item: 'static>) }\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = help: the trait `Sized` is not implemented for `(dyn Iterator<Item = impl Sized> + 'static)`\n+   = help: the trait `Sized` is not implemented for `(dyn Iterator<Item = impl Sized + 'static> + 'static)`\n    = note: no field of an enum variant may have a dynamically sized type\n    = help: change the field's type to have a statically known size\n help: borrowed types always have a statically known size\n@@ -107,14 +107,14 @@ help: the `Box` type always has a statically known size and allocates its conten\n LL | union U1 { f: Box<ManuallyDrop<dyn Iterator<Item: Copy>>> }\n    |               ++++                                      +\n \n-error[E0277]: the size for values of type `(dyn Iterator<Item = impl Sized> + 'static)` cannot be known at compilation time\n+error[E0277]: the size for values of type `(dyn Iterator<Item = impl Sized + 'static> + 'static)` cannot be known at compilation time\n   --> $DIR/inside-adt.rs:26:15\n    |\n LL | union U3 { f: ManuallyDrop<dyn Iterator<Item: 'static>> }\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = help: within `ManuallyDrop<(dyn Iterator<Item = impl Sized> + 'static)>`, the trait `Sized` is not implemented for `(dyn Iterator<Item = impl Sized> + 'static)`\n-   = note: required because it appears within the type `ManuallyDrop<(dyn Iterator<Item = impl Sized> + 'static)>`\n+   = help: within `ManuallyDrop<(dyn Iterator<Item = impl Sized + 'static> + 'static)>`, the trait `Sized` is not implemented for `(dyn Iterator<Item = impl Sized + 'static> + 'static)`\n+   = note: required because it appears within the type `ManuallyDrop<(dyn Iterator<Item = impl Sized + 'static> + 'static)>`\n    = note: no field of a union may have a dynamically sized type\n    = help: change the field's type to have a statically known size\n help: borrowed types always have a statically known size"}, {"sha": "e8548d402fae5b1a7b4a8ffa57609d6853005922", "filename": "src/test/ui/associated-types/issue-87261.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.rs?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -77,10 +77,10 @@ where\n \n fn main() {\n     accepts_trait(returns_opaque());\n-    //~^ ERROR type mismatch resolving `<impl Trait as Trait>::Associated == ()`\n+    //~^ ERROR type mismatch resolving `<impl Trait + 'static as Trait>::Associated == ()`\n \n     accepts_trait(returns_opaque_derived());\n-    //~^ ERROR type mismatch resolving `<impl DerivedTrait as Trait>::Associated == ()`\n+    //~^ ERROR type mismatch resolving `<impl DerivedTrait + 'static as Trait>::Associated == ()`\n \n     accepts_trait(returns_opaque_foo());\n     //~^ ERROR type mismatch resolving `<impl Trait + Foo as Trait>::Associated == ()`\n@@ -89,7 +89,7 @@ fn main() {\n     //~^ ERROR type mismatch resolving `<impl DerivedTrait + Foo as Trait>::Associated == ()`\n \n     accepts_generic_trait(returns_opaque_generic());\n-    //~^ ERROR type mismatch resolving `<impl GenericTrait<()> as GenericTrait<()>>::Associated == ()`\n+    //~^ ERROR type mismatch resolving `<impl GenericTrait<()> + 'static as GenericTrait<()>>::Associated == ()`\n \n     accepts_generic_trait(returns_opaque_generic_foo());\n     //~^ ERROR type mismatch resolving `<impl GenericTrait<()> + Foo as GenericTrait<()>>::Associated == ()`"}, {"sha": "2cce6b947025e5b41c1361a5d555c33661dc46f8", "filename": "src/test/ui/associated-types/issue-87261.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-87261.stderr?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -132,7 +132,7 @@ note: required by a bound in `accepts_generic_trait`\n LL | fn accepts_generic_trait<T: GenericTrait<(), Associated = ()>>(_: T) {}\n    |                                              ^^^^^^^^^^^^^^^ required by this bound in `accepts_generic_trait`\n \n-error[E0271]: type mismatch resolving `<impl Trait as Trait>::Associated == ()`\n+error[E0271]: type mismatch resolving `<impl Trait + 'static as Trait>::Associated == ()`\n   --> $DIR/issue-87261.rs:79:19\n    |\n LL | fn returns_opaque() -> impl Trait + 'static {\n@@ -144,18 +144,18 @@ LL |     accepts_trait(returns_opaque());\n    |     required by a bound introduced by this call\n    |\n    = note:    expected unit type `()`\n-           found associated type `<impl Trait as Trait>::Associated`\n+           found associated type `<impl Trait + 'static as Trait>::Associated`\n note: required by a bound in `accepts_trait`\n   --> $DIR/issue-87261.rs:43:27\n    |\n LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n    |                           ^^^^^^^^^^^^^^^ required by this bound in `accepts_trait`\n-help: consider constraining the associated type `<impl Trait as Trait>::Associated` to `()`\n+help: consider constraining the associated type `<impl Trait + 'static as Trait>::Associated` to `()`\n    |\n LL | fn returns_opaque() -> impl Trait<Associated = ()> + 'static {\n    |                                  +++++++++++++++++\n \n-error[E0271]: type mismatch resolving `<impl DerivedTrait as Trait>::Associated == ()`\n+error[E0271]: type mismatch resolving `<impl DerivedTrait + 'static as Trait>::Associated == ()`\n   --> $DIR/issue-87261.rs:82:19\n    |\n LL | fn returns_opaque_derived() -> impl DerivedTrait + 'static {\n@@ -167,13 +167,13 @@ LL |     accepts_trait(returns_opaque_derived());\n    |     required by a bound introduced by this call\n    |\n    = note:    expected unit type `()`\n-           found associated type `<impl DerivedTrait as Trait>::Associated`\n+           found associated type `<impl DerivedTrait + 'static as Trait>::Associated`\n note: required by a bound in `accepts_trait`\n   --> $DIR/issue-87261.rs:43:27\n    |\n LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n    |                           ^^^^^^^^^^^^^^^ required by this bound in `accepts_trait`\n-help: consider constraining the associated type `<impl DerivedTrait as Trait>::Associated` to `()`\n+help: consider constraining the associated type `<impl DerivedTrait + 'static as Trait>::Associated` to `()`\n    |\n LL | fn returns_opaque_derived() -> impl DerivedTrait<Associated = ()> + 'static {\n    |                                                 +++++++++++++++++\n@@ -222,7 +222,7 @@ note: required by a bound in `accepts_trait`\n LL | fn accepts_trait<T: Trait<Associated = ()>>(_: T) {}\n    |                           ^^^^^^^^^^^^^^^ required by this bound in `accepts_trait`\n \n-error[E0271]: type mismatch resolving `<impl GenericTrait<()> as GenericTrait<()>>::Associated == ()`\n+error[E0271]: type mismatch resolving `<impl GenericTrait<()> + 'static as GenericTrait<()>>::Associated == ()`\n   --> $DIR/issue-87261.rs:91:27\n    |\n LL | fn returns_opaque_generic() -> impl GenericTrait<()> + 'static {\n@@ -234,13 +234,13 @@ LL |     accepts_generic_trait(returns_opaque_generic());\n    |     required by a bound introduced by this call\n    |\n    = note:    expected unit type `()`\n-           found associated type `<impl GenericTrait<()> as GenericTrait<()>>::Associated`\n+           found associated type `<impl GenericTrait<()> + 'static as GenericTrait<()>>::Associated`\n note: required by a bound in `accepts_generic_trait`\n   --> $DIR/issue-87261.rs:44:46\n    |\n LL | fn accepts_generic_trait<T: GenericTrait<(), Associated = ()>>(_: T) {}\n    |                                              ^^^^^^^^^^^^^^^ required by this bound in `accepts_generic_trait`\n-help: consider constraining the associated type `<impl GenericTrait<()> as GenericTrait<()>>::Associated` to `()`\n+help: consider constraining the associated type `<impl GenericTrait<()> + 'static as GenericTrait<()>>::Associated` to `()`\n    |\n LL | fn returns_opaque_generic() -> impl GenericTrait<(), Associated = ()> + 'static {\n    |                                                    +++++++++++++++++"}, {"sha": "de06ded7acdb6f7666bd4e81ef40a89f22612d0c", "filename": "src/test/ui/impl-trait/hidden-lifetimes.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -1,4 +1,4 @@\n-error[E0700]: hidden type for `impl Swap` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `impl Swap + 'a` captures lifetime that does not appear in bounds\n   --> $DIR/hidden-lifetimes.rs:29:5\n    |\n LL | fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a {\n@@ -11,7 +11,7 @@ help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'\n LL | fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a + 'b {\n    |                                                                     ++++\n \n-error[E0700]: hidden type for `impl Swap` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `impl Swap + 'a` captures lifetime that does not appear in bounds\n   --> $DIR/hidden-lifetimes.rs:46:5\n    |\n LL | fn hide_rc_refcell<'a, 'b: 'a, T: 'static>(x: Rc<RefCell<&'b T>>) -> impl Swap + 'a {"}, {"sha": "57d8cbe7c93410cbf5b762a2024cdd8ef57a8c43", "filename": "src/test/ui/lint/invalid_value.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Fui%2Flint%2Finvalid_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Fui%2Flint%2Finvalid_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finvalid_value.rs?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -44,6 +44,10 @@ enum TwoUninhabited {\n     B(Void),\n }\n \n+#[rustc_layout_scalar_valid_range_start(254)]\n+#[rustc_layout_scalar_valid_range_end(1)]\n+pub(crate) struct WrapAroundRange(u8);\n+\n #[allow(unused)]\n fn generic<T: 'static>() {\n     unsafe {\n@@ -131,6 +135,9 @@ fn main() {\n         let _val: *const [()] = mem::zeroed();\n         let _val: *const [()] = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        let _val: WrapAroundRange = mem::zeroed();\n+        let _val: WrapAroundRange = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n         // Things where 0 is okay due to rustc implementation details,\n         // but that are not guaranteed to keep working.\n         let _val: Result<i32, i32> = mem::zeroed();"}, {"sha": "76afb765f0f0582b66be1caef8bb29a983a5a72b", "filename": "src/test/ui/lint/invalid_value.stderr", "status": "modified", "additions": 62, "deletions": 51, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -1,5 +1,5 @@\n error: the type `&T` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:50:32\n+  --> $DIR/invalid_value.rs:54:32\n    |\n LL |         let _val: &'static T = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n@@ -15,7 +15,7 @@ LL | #![deny(invalid_value)]\n    |         ^^^^^^^^^^^^^\n \n error: the type `&T` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:51:32\n+  --> $DIR/invalid_value.rs:55:32\n    |\n LL |         let _val: &'static T = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -26,7 +26,7 @@ LL |         let _val: &'static T = mem::uninitialized();\n    = note: references must be non-null\n \n error: the type `Wrap<&T>` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:53:38\n+  --> $DIR/invalid_value.rs:57:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      ^^^^^^^^^^^^^\n@@ -41,7 +41,7 @@ LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `Wrap<&T>` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:54:38\n+  --> $DIR/invalid_value.rs:58:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      ^^^^^^^^^^^^^^^^^^^^\n@@ -56,7 +56,7 @@ LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `!` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:61:23\n+  --> $DIR/invalid_value.rs:65:23\n    |\n LL |         let _val: ! = mem::zeroed();\n    |                       ^^^^^^^^^^^^^\n@@ -67,7 +67,7 @@ LL |         let _val: ! = mem::zeroed();\n    = note: the `!` type has no valid value\n \n error: the type `!` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:62:23\n+  --> $DIR/invalid_value.rs:66:23\n    |\n LL |         let _val: ! = mem::uninitialized();\n    |                       ^^^^^^^^^^^^^^^^^^^^\n@@ -78,7 +78,7 @@ LL |         let _val: ! = mem::uninitialized();\n    = note: the `!` type has no valid value\n \n error: the type `(i32, !)` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:64:30\n+  --> $DIR/invalid_value.rs:68:30\n    |\n LL |         let _val: (i32, !) = mem::zeroed();\n    |                              ^^^^^^^^^^^^^\n@@ -89,7 +89,7 @@ LL |         let _val: (i32, !) = mem::zeroed();\n    = note: the `!` type has no valid value\n \n error: the type `(i32, !)` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:65:30\n+  --> $DIR/invalid_value.rs:69:30\n    |\n LL |         let _val: (i32, !) = mem::uninitialized();\n    |                              ^^^^^^^^^^^^^^^^^^^^\n@@ -100,7 +100,7 @@ LL |         let _val: (i32, !) = mem::uninitialized();\n    = note: integers must not be uninitialized\n \n error: the type `Void` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:67:26\n+  --> $DIR/invalid_value.rs:71:26\n    |\n LL |         let _val: Void = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n@@ -115,7 +115,7 @@ LL | enum Void {}\n    | ^^^^^^^^^\n \n error: the type `Void` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:68:26\n+  --> $DIR/invalid_value.rs:72:26\n    |\n LL |         let _val: Void = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -130,7 +130,7 @@ LL | enum Void {}\n    | ^^^^^^^^^\n \n error: the type `&i32` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:70:34\n+  --> $DIR/invalid_value.rs:74:34\n    |\n LL |         let _val: &'static i32 = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n@@ -141,7 +141,7 @@ LL |         let _val: &'static i32 = mem::zeroed();\n    = note: references must be non-null\n \n error: the type `&i32` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:71:34\n+  --> $DIR/invalid_value.rs:75:34\n    |\n LL |         let _val: &'static i32 = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n@@ -152,7 +152,7 @@ LL |         let _val: &'static i32 = mem::uninitialized();\n    = note: references must be non-null\n \n error: the type `Ref` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:73:25\n+  --> $DIR/invalid_value.rs:77:25\n    |\n LL |         let _val: Ref = mem::zeroed();\n    |                         ^^^^^^^^^^^^^\n@@ -167,7 +167,7 @@ LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n \n error: the type `Ref` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:74:25\n+  --> $DIR/invalid_value.rs:78:25\n    |\n LL |         let _val: Ref = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -182,7 +182,7 @@ LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n \n error: the type `fn()` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:76:26\n+  --> $DIR/invalid_value.rs:80:26\n    |\n LL |         let _val: fn() = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n@@ -193,7 +193,7 @@ LL |         let _val: fn() = mem::zeroed();\n    = note: function pointers must be non-null\n \n error: the type `fn()` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:77:26\n+  --> $DIR/invalid_value.rs:81:26\n    |\n LL |         let _val: fn() = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -204,7 +204,7 @@ LL |         let _val: fn() = mem::uninitialized();\n    = note: function pointers must be non-null\n \n error: the type `Wrap<fn()>` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:79:32\n+  --> $DIR/invalid_value.rs:83:32\n    |\n LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n@@ -219,7 +219,7 @@ LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `Wrap<fn()>` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:80:32\n+  --> $DIR/invalid_value.rs:84:32\n    |\n LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -234,7 +234,7 @@ LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `WrapEnum<fn()>` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:82:36\n+  --> $DIR/invalid_value.rs:86:36\n    |\n LL |         let _val: WrapEnum<fn()> = mem::zeroed();\n    |                                    ^^^^^^^^^^^^^\n@@ -249,7 +249,7 @@ LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n \n error: the type `WrapEnum<fn()>` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:83:36\n+  --> $DIR/invalid_value.rs:87:36\n    |\n LL |         let _val: WrapEnum<fn()> = mem::uninitialized();\n    |                                    ^^^^^^^^^^^^^^^^^^^^\n@@ -264,7 +264,7 @@ LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n \n error: the type `Wrap<(RefPair, i32)>` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:85:42\n+  --> $DIR/invalid_value.rs:89:42\n    |\n LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          ^^^^^^^^^^^^^\n@@ -279,7 +279,7 @@ LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n error: the type `Wrap<(RefPair, i32)>` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:86:42\n+  --> $DIR/invalid_value.rs:90:42\n    |\n LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          ^^^^^^^^^^^^^^^^^^^^\n@@ -294,7 +294,7 @@ LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n error: the type `NonNull<i32>` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:88:34\n+  --> $DIR/invalid_value.rs:92:34\n    |\n LL |         let _val: NonNull<i32> = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n@@ -305,7 +305,7 @@ LL |         let _val: NonNull<i32> = mem::zeroed();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `NonNull<i32>` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:89:34\n+  --> $DIR/invalid_value.rs:93:34\n    |\n LL |         let _val: NonNull<i32> = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n@@ -316,7 +316,7 @@ LL |         let _val: NonNull<i32> = mem::uninitialized();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `(NonZeroU32, i32)` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:91:39\n+  --> $DIR/invalid_value.rs:95:39\n    |\n LL |         let _val: (NonZeroU32, i32) = mem::zeroed();\n    |                                       ^^^^^^^^^^^^^\n@@ -327,7 +327,7 @@ LL |         let _val: (NonZeroU32, i32) = mem::zeroed();\n    = note: `std::num::NonZeroU32` must be non-null\n \n error: the type `(NonZeroU32, i32)` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:92:39\n+  --> $DIR/invalid_value.rs:96:39\n    |\n LL |         let _val: (NonZeroU32, i32) = mem::uninitialized();\n    |                                       ^^^^^^^^^^^^^^^^^^^^\n@@ -338,7 +338,7 @@ LL |         let _val: (NonZeroU32, i32) = mem::uninitialized();\n    = note: `std::num::NonZeroU32` must be non-null\n \n error: the type `*const dyn Send` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:94:37\n+  --> $DIR/invalid_value.rs:98:37\n    |\n LL |         let _val: *const dyn Send = mem::zeroed();\n    |                                     ^^^^^^^^^^^^^\n@@ -349,7 +349,7 @@ LL |         let _val: *const dyn Send = mem::zeroed();\n    = note: the vtable of a wide raw pointer must be non-null\n \n error: the type `*const dyn Send` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:95:37\n+  --> $DIR/invalid_value.rs:99:37\n    |\n LL |         let _val: *const dyn Send = mem::uninitialized();\n    |                                     ^^^^^^^^^^^^^^^^^^^^\n@@ -360,7 +360,7 @@ LL |         let _val: *const dyn Send = mem::uninitialized();\n    = note: the vtable of a wide raw pointer must be non-null\n \n error: the type `[fn(); 2]` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:97:31\n+  --> $DIR/invalid_value.rs:101:31\n    |\n LL |         let _val: [fn(); 2] = mem::zeroed();\n    |                               ^^^^^^^^^^^^^\n@@ -371,7 +371,7 @@ LL |         let _val: [fn(); 2] = mem::zeroed();\n    = note: function pointers must be non-null\n \n error: the type `[fn(); 2]` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:98:31\n+  --> $DIR/invalid_value.rs:102:31\n    |\n LL |         let _val: [fn(); 2] = mem::uninitialized();\n    |                               ^^^^^^^^^^^^^^^^^^^^\n@@ -382,7 +382,7 @@ LL |         let _val: [fn(); 2] = mem::uninitialized();\n    = note: function pointers must be non-null\n \n error: the type `TwoUninhabited` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:100:36\n+  --> $DIR/invalid_value.rs:104:36\n    |\n LL |         let _val: TwoUninhabited = mem::zeroed();\n    |                                    ^^^^^^^^^^^^^\n@@ -397,7 +397,7 @@ LL | enum TwoUninhabited {\n    | ^^^^^^^^^^^^^^^^^^^\n \n error: the type `TwoUninhabited` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:101:36\n+  --> $DIR/invalid_value.rs:105:36\n    |\n LL |         let _val: TwoUninhabited = mem::uninitialized();\n    |                                    ^^^^^^^^^^^^^^^^^^^^\n@@ -412,7 +412,7 @@ LL | enum TwoUninhabited {\n    | ^^^^^^^^^^^^^^^^^^^\n \n error: the type `OneFruitNonZero` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:103:37\n+  --> $DIR/invalid_value.rs:107:37\n    |\n LL |         let _val: OneFruitNonZero = mem::zeroed();\n    |                                     ^^^^^^^^^^^^^\n@@ -427,7 +427,7 @@ LL |     Banana(NonZeroU32),\n    |            ^^^^^^^^^^\n \n error: the type `OneFruitNonZero` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:104:37\n+  --> $DIR/invalid_value.rs:108:37\n    |\n LL |         let _val: OneFruitNonZero = mem::uninitialized();\n    |                                     ^^^^^^^^^^^^^^^^^^^^\n@@ -442,7 +442,7 @@ LL |     Banana(NonZeroU32),\n    |            ^^^^^^^^^^\n \n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:108:26\n+  --> $DIR/invalid_value.rs:112:26\n    |\n LL |         let _val: bool = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -453,7 +453,7 @@ LL |         let _val: bool = mem::uninitialized();\n    = note: booleans must be either `true` or `false`\n \n error: the type `Wrap<char>` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:111:32\n+  --> $DIR/invalid_value.rs:115:32\n    |\n LL |         let _val: Wrap<char> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -468,7 +468,7 @@ LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `NonBig` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:114:28\n+  --> $DIR/invalid_value.rs:118:28\n    |\n LL |         let _val: NonBig = mem::uninitialized();\n    |                            ^^^^^^^^^^^^^^^^^^^^\n@@ -479,7 +479,7 @@ LL |         let _val: NonBig = mem::uninitialized();\n    = note: `NonBig` must be initialized inside its custom valid range\n \n error: the type `Fruit` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:117:27\n+  --> $DIR/invalid_value.rs:121:27\n    |\n LL |         let _val: Fruit = mem::uninitialized();\n    |                           ^^^^^^^^^^^^^^^^^^^^\n@@ -494,7 +494,7 @@ LL | enum Fruit {\n    | ^^^^^^^^^^\n \n error: the type `[bool; 2]` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:120:31\n+  --> $DIR/invalid_value.rs:124:31\n    |\n LL |         let _val: [bool; 2] = mem::uninitialized();\n    |                               ^^^^^^^^^^^^^^^^^^^^\n@@ -505,7 +505,7 @@ LL |         let _val: [bool; 2] = mem::uninitialized();\n    = note: booleans must be either `true` or `false`\n \n error: the type `i32` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:123:25\n+  --> $DIR/invalid_value.rs:127:25\n    |\n LL |         let _val: i32 = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -516,7 +516,7 @@ LL |         let _val: i32 = mem::uninitialized();\n    = note: integers must not be uninitialized\n \n error: the type `f32` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:126:25\n+  --> $DIR/invalid_value.rs:130:25\n    |\n LL |         let _val: f32 = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -527,7 +527,7 @@ LL |         let _val: f32 = mem::uninitialized();\n    = note: floats must not be uninitialized\n \n error: the type `*const ()` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:129:31\n+  --> $DIR/invalid_value.rs:133:31\n    |\n LL |         let _val: *const () = mem::uninitialized();\n    |                               ^^^^^^^^^^^^^^^^^^^^\n@@ -538,7 +538,7 @@ LL |         let _val: *const () = mem::uninitialized();\n    = note: raw pointers must not be uninitialized\n \n error: the type `*const [()]` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:132:33\n+  --> $DIR/invalid_value.rs:136:33\n    |\n LL |         let _val: *const [()] = mem::uninitialized();\n    |                                 ^^^^^^^^^^^^^^^^^^^^\n@@ -548,8 +548,19 @@ LL |         let _val: *const [()] = mem::uninitialized();\n    |\n    = note: raw pointers must not be uninitialized\n \n+error: the type `WrapAroundRange` does not permit being left uninitialized\n+  --> $DIR/invalid_value.rs:139:37\n+   |\n+LL |         let _val: WrapAroundRange = mem::uninitialized();\n+   |                                     ^^^^^^^^^^^^^^^^^^^^\n+   |                                     |\n+   |                                     this code causes undefined behavior when executed\n+   |                                     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+   = note: `WrapAroundRange` must be initialized inside its custom valid range\n+\n error: the type `Result<i32, i32>` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:137:38\n+  --> $DIR/invalid_value.rs:144:38\n    |\n LL |         let _val: Result<i32, i32> = mem::uninitialized();\n    |                                      ^^^^^^^^^^^^^^^^^^^^\n@@ -564,7 +575,7 @@ LL | pub enum Result<T, E> {\n    | ^^^^^^^^^^^^^^^^^^^^^\n \n error: the type `&i32` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:145:34\n+  --> $DIR/invalid_value.rs:152:34\n    |\n LL |         let _val: &'static i32 = mem::transmute(0usize);\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^\n@@ -575,7 +586,7 @@ LL |         let _val: &'static i32 = mem::transmute(0usize);\n    = note: references must be non-null\n \n error: the type `&[i32]` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:146:36\n+  --> $DIR/invalid_value.rs:153:36\n    |\n LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -586,7 +597,7 @@ LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    = note: references must be non-null\n \n error: the type `NonZeroU32` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:147:32\n+  --> $DIR/invalid_value.rs:154:32\n    |\n LL |         let _val: NonZeroU32 = mem::transmute(0);\n    |                                ^^^^^^^^^^^^^^^^^\n@@ -597,7 +608,7 @@ LL |         let _val: NonZeroU32 = mem::transmute(0);\n    = note: `std::num::NonZeroU32` must be non-null\n \n error: the type `NonNull<i32>` does not permit zero-initialization\n-  --> $DIR/invalid_value.rs:150:34\n+  --> $DIR/invalid_value.rs:157:34\n    |\n LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -608,7 +619,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `NonNull<i32>` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:151:34\n+  --> $DIR/invalid_value.rs:158:34\n    |\n LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -619,7 +630,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/invalid_value.rs:152:26\n+  --> $DIR/invalid_value.rs:159:26\n    |\n LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -629,5 +640,5 @@ LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |\n    = note: booleans must be either `true` or `false`\n \n-error: aborting due to 50 previous errors\n+error: aborting due to 51 previous errors\n "}, {"sha": "111ae7c73080d3eab5df9bdfa5b6f98f58510117", "filename": "src/test/ui/suggestions/issue-103112.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Fui%2Fsuggestions%2Fissue-103112.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Fui%2Fsuggestions%2Fissue-103112.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-103112.rs?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    std::process::abort!();\n+    //~^ ERROR: failed to resolve\n+}"}, {"sha": "4ca7fdf9b5a2a585692830efc1b59064268f4f32", "filename": "src/test/ui/suggestions/issue-103112.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Fui%2Fsuggestions%2Fissue-103112.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7feb003882ecf7699e6705b537673e20985accff/src%2Ftest%2Fui%2Fsuggestions%2Fissue-103112.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-103112.stderr?ref=7feb003882ecf7699e6705b537673e20985accff", "patch": "@@ -0,0 +1,15 @@\n+error[E0433]: failed to resolve: could not find `abort` in `process`\n+  --> $DIR/issue-103112.rs:2:19\n+   |\n+LL |     std::process::abort!();\n+   |                   ^^^^^ could not find `abort` in `process`\n+   |\n+help: std::process::abort is not a macro, but a function, try to remove `!`\n+   |\n+LL -     std::process::abort!();\n+LL +     std::process::abort();\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0433`."}]}