{"sha": "b3db5cd46c6941563ae8792cf61160c5793d397a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzZGI1Y2Q0NmM2OTQxNTYzYWU4NzkyY2Y2MTE2MGM1NzkzZDM5N2E=", "commit": {"author": {"name": "Taylor Yu", "email": "tlyu@mit.edu", "date": "2021-07-01T23:05:24Z"}, "committer": {"name": "Taylor Yu", "email": "tlyu@mit.edu", "date": "2021-07-02T01:55:46Z"}, "message": "add owned locked stdio handles\n\nAdd stderr_locked, stdin_locked, and stdout_locked free functions\nto obtain owned locked stdio handles in a single step. Also add\ninto_lock methods to consume a stdio handle and return an owned\nlock. These methods will make it easier to use locked stdio\nhandles without having to deal with lifetime problems or keeping\nbindings to the unlocked handles around.", "tree": {"sha": "3eb037a57b911769cf6dd27cc1138c7d8c17fa0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3eb037a57b911769cf6dd27cc1138c7d8c17fa0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3db5cd46c6941563ae8792cf61160c5793d397a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3db5cd46c6941563ae8792cf61160c5793d397a", "html_url": "https://github.com/rust-lang/rust/commit/b3db5cd46c6941563ae8792cf61160c5793d397a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3db5cd46c6941563ae8792cf61160c5793d397a/comments", "author": {"login": "tlyu", "id": 431873, "node_id": "MDQ6VXNlcjQzMTg3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/431873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tlyu", "html_url": "https://github.com/tlyu", "followers_url": "https://api.github.com/users/tlyu/followers", "following_url": "https://api.github.com/users/tlyu/following{/other_user}", "gists_url": "https://api.github.com/users/tlyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/tlyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tlyu/subscriptions", "organizations_url": "https://api.github.com/users/tlyu/orgs", "repos_url": "https://api.github.com/users/tlyu/repos", "events_url": "https://api.github.com/users/tlyu/events{/privacy}", "received_events_url": "https://api.github.com/users/tlyu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tlyu", "id": 431873, "node_id": "MDQ6VXNlcjQzMTg3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/431873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tlyu", "html_url": "https://github.com/tlyu", "followers_url": "https://api.github.com/users/tlyu/followers", "following_url": "https://api.github.com/users/tlyu/following{/other_user}", "gists_url": "https://api.github.com/users/tlyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/tlyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tlyu/subscriptions", "organizations_url": "https://api.github.com/users/tlyu/orgs", "repos_url": "https://api.github.com/users/tlyu/repos", "events_url": "https://api.github.com/users/tlyu/events{/privacy}", "received_events_url": "https://api.github.com/users/tlyu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "868c702d0c9a471a28fb55f0148eb1e3e8b1dcc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/868c702d0c9a471a28fb55f0148eb1e3e8b1dcc5", "html_url": "https://github.com/rust-lang/rust/commit/868c702d0c9a471a28fb55f0148eb1e3e8b1dcc5"}], "stats": {"total": 398, "additions": 397, "deletions": 1}, "files": [{"sha": "9e8996a3e56304c4f3d8cf1c28e10aa4a0e3782d", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3db5cd46c6941563ae8792cf61160c5793d397a/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3db5cd46c6941563ae8792cf61160c5793d397a/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=b3db5cd46c6941563ae8792cf61160c5793d397a", "patch": "@@ -277,8 +277,12 @@ pub use self::error::{Error, ErrorKind, Result};\n pub use self::stdio::set_output_capture;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::stdio::{stderr, stdin, stdout, Stderr, Stdin, Stdout};\n+#[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+pub use self::stdio::{stderr_locked, stdin_locked, stdout_locked};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::stdio::{StderrLock, StdinLock, StdoutLock};\n+#[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+pub use self::stdio::{StderrOwnedLock, StdinOwnedLock, StdoutOwnedLock};\n #[unstable(feature = \"print_internals\", issue = \"none\")]\n pub use self::stdio::{_eprint, _print};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "026d27812631170998c9354c428b1cc39936dd86", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 259, "deletions": 1, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/b3db5cd46c6941563ae8792cf61160c5793d397a/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3db5cd46c6941563ae8792cf61160c5793d397a/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=b3db5cd46c6941563ae8792cf61160c5793d397a", "patch": "@@ -261,6 +261,21 @@ pub struct StdinLock<'a> {\n     inner: MutexGuard<'a, BufReader<StdinRaw>>,\n }\n \n+/// Owned locked [`Stdin`] handle, returned by [`Stdin::into_lock`] and\n+/// [`io::stdin_locked`].\n+///\n+/// This is exactly like [`StdinLock`], except that it can outlive the\n+/// [`Stdin`] handle that was used to create it. See the [`StdinLock`]\n+/// documentation for more details.\n+///\n+/// ### Note: Windows Portability Consideration\n+///\n+/// When operating in a console, the Windows implementation of this stream does not support\n+/// non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n+/// an error.\n+#[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+pub type StdinOwnedLock = StdinLock<'static>;\n+\n /// Constructs a new handle to the standard input of the current process.\n ///\n /// Each handle returned is a reference to a shared global buffer whose access\n@@ -310,6 +325,48 @@ pub fn stdin() -> Stdin {\n     }\n }\n \n+/// Constructs a new locked handle to the standard input of the current\n+/// process.\n+///\n+/// Each handle returned is a guard granting locked access to a shared\n+/// global buffer whose access is synchronized via a mutex. If you need\n+/// more explicit control over locking, for example, in a multi-threaded\n+/// program, use the [`io::stdin`] function to obtain an unlocked handle,\n+/// along with the [`Stdin::lock`] method.\n+///\n+/// The lock is released when the returned guard goes out of scope. The\n+/// returned guard also implements the [`Read`] and [`BufRead`] traits for\n+/// accessing the underlying data.\n+///\n+/// **Note**: The mutex locked by this handle is not reentrant. Even in a\n+/// single-threaded program, calling other code that accesses [`Stdin`]\n+/// could cause a deadlock or panic, if this locked handle is held across\n+/// that call.\n+///\n+/// ### Note: Windows Portability Consideration\n+/// When operating in a console, the Windows implementation of this stream does not support\n+/// non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n+/// an error.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// #![feature(stdio_locked)]\n+/// use std::io::{self, Read};\n+///\n+/// fn main() -> io::Result<()> {\n+///     let mut buffer = String::new();\n+///     let mut handle = io::stdin_locked();\n+///\n+///     handle.read_to_string(&mut buffer)?;\n+///     Ok(())\n+/// }\n+/// ```\n+#[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+pub fn stdin_locked() -> StdinOwnedLock {\n+    stdin().into_lock()\n+}\n+\n impl Stdin {\n     /// Locks this handle to the standard input stream, returning a readable\n     /// guard.\n@@ -334,7 +391,7 @@ impl Stdin {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> StdinLock<'_> {\n-        StdinLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n+        self.lock_any()\n     }\n \n     /// Locks this handle and reads a line of input, appending it to the specified buffer.\n@@ -367,6 +424,43 @@ impl Stdin {\n     pub fn read_line(&self, buf: &mut String) -> io::Result<usize> {\n         self.lock().read_line(buf)\n     }\n+\n+    // Locks this handle with any lifetime. This depends on the\n+    // implementation detail that the underlying `Mutex` is static.\n+    fn lock_any<'a>(&self) -> StdinLock<'a> {\n+        StdinLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n+    }\n+\n+    /// Consumes this handle to the standard input stream, locking the\n+    /// shared global buffer associated with the stream and returning a\n+    /// readable guard.\n+    ///\n+    /// The lock is released when the returned guard goes out of scope. The\n+    /// returned guard also implements the [`Read`] and [`BufRead`] traits\n+    /// for accessing the underlying data.\n+    ///\n+    /// It is often simpler to directly get a locked handle using the\n+    /// [`stdin_locked`] function instead, unless nearby code also needs to\n+    /// use an unlocked handle.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(stdio_locked)]\n+    /// use std::io::{self, Read};\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let mut buffer = String::new();\n+    ///     let mut handle = io::stdin().into_lock();\n+    ///\n+    ///     handle.read_to_string(&mut buffer)?;\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+    pub fn into_lock(self) -> StdinOwnedLock {\n+        self.lock_any()\n+    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -507,6 +601,20 @@ pub struct StdoutLock<'a> {\n     inner: ReentrantMutexGuard<'a, RefCell<LineWriter<StdoutRaw>>>,\n }\n \n+/// Owned locked [`Stdout`] handle, returned by [`Stdout::into_lock`] and\n+/// [`io::stdout_locked`].\n+///\n+/// This is exactly like [`StdoutLock`], except that it can outlive the\n+/// [`Stdout`] handle that was used to create it. See the [`StdoutLock`]\n+/// documentation for more details.\n+///\n+/// ### Note: Windows Portability Consideration\n+/// When operating in a console, the Windows implementation of this stream does not support\n+/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n+/// an error.\n+#[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+pub type StdoutOwnedLock = StdoutLock<'static>;\n+\n static STDOUT: SyncOnceCell<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> = SyncOnceCell::new();\n \n /// Constructs a new handle to the standard output of the current process.\n@@ -558,6 +666,42 @@ pub fn stdout() -> Stdout {\n     }\n }\n \n+/// Constructs a new locked handle to the standard output of the current\n+/// process.\n+///\n+/// Each handle returned is a guard granting locked access to a shared\n+/// global buffer whose access is synchronized via a mutex. If you need\n+/// more explicit control over locking, for example, in a multi-threaded\n+/// program, use the [`io::stdout`] function to obtain an unlocked handle,\n+/// along with the [`Stdout::lock`] method.\n+///\n+/// The lock is released when the returned guard goes out of scope. The\n+/// returned guard also implements the [`Write`] trait for writing data.\n+///\n+/// ### Note: Windows Portability Consideration\n+/// When operating in a console, the Windows implementation of this stream does not support\n+/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n+/// an error.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// #![feature(stdio_locked)]\n+/// use std::io::{self, Write};\n+///\n+/// fn main() -> io::Result<()> {\n+///     let mut handle = io::stdout_locked();\n+///\n+///     handle.write_all(b\"hello world\")?;\n+///\n+///     Ok(())\n+/// }\n+/// ```\n+#[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+pub fn stdout_locked() -> StdoutLock<'static> {\n+    stdout().into_lock()\n+}\n+\n pub fn cleanup() {\n     if let Some(instance) = STDOUT.get() {\n         // Flush the data and disable buffering during shutdown\n@@ -595,8 +739,45 @@ impl Stdout {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> StdoutLock<'_> {\n+        self.lock_any()\n+    }\n+\n+    // Locks this handle with any lifetime. This depends on the\n+    // implementation detail that the underlying `ReentrantMutex` is\n+    // static.\n+    fn lock_any<'a>(&self) -> StdoutLock<'a> {\n         StdoutLock { inner: self.inner.lock() }\n     }\n+\n+    /// Consumes this handle to the standard output stream, locking the\n+    /// shared global buffer associated with the stream and returning a\n+    /// writable guard.\n+    ///\n+    /// The lock is released when the returned lock goes out of scope. The\n+    /// returned guard also implements the [`Write`] trait for writing data.\n+    ///\n+    /// It is often simpler to directly get a locked handle using the\n+    /// [`io::stdout_locked`] function instead, unless nearby code also\n+    /// needs to use an unlocked handle.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(stdio_locked)]\n+    /// use std::io::{self, Write};\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let mut handle = io::stdout().into_lock();\n+    ///\n+    ///     handle.write_all(b\"hello world\")?;\n+    ///\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+    pub fn into_lock(self) -> StdoutOwnedLock {\n+        self.lock_any()\n+    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -717,6 +898,20 @@ pub struct StderrLock<'a> {\n     inner: ReentrantMutexGuard<'a, RefCell<StderrRaw>>,\n }\n \n+/// Owned locked [`Stderr`] handle, returned by [`Stderr::into_lock`] and\n+/// [`io::stderr_locked`].\n+///\n+/// This is exactly like [`StderrLock`], except that it can outlive the the\n+/// [`Stderr`] handle that was used to create it. See the [`StderrLock`]\n+/// documentation for more details.\n+///\n+/// ### Note: Windows Portability Consideration\n+/// When operating in a console, the Windows implementation of this stream does not support\n+/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n+/// an error.\n+#[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+pub type StderrOwnedLock = StderrLock<'static>;\n+\n /// Constructs a new handle to the standard error of the current process.\n ///\n /// This handle is not buffered.\n@@ -769,6 +964,35 @@ pub fn stderr() -> Stderr {\n     }\n }\n \n+/// Constructs a new locked handle to the standard error of the current\n+/// process.\n+///\n+/// This handle is not buffered.\n+///\n+/// ### Note: Windows Portability Consideration\n+/// When operating in a console, the Windows implementation of this stream does not support\n+/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n+/// an error.\n+///\n+/// # Example\n+///\n+/// ```no_run\n+/// #![feature(stdio_locked)]\n+/// use std::io::{self, Write};\n+///\n+/// fn main() -> io::Result<()> {\n+///     let mut handle = io::stderr_locked();\n+///\n+///     handle.write_all(b\"hello world\")?;\n+///\n+///     Ok(())\n+/// }\n+/// ```\n+#[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+pub fn stderr_locked() -> StderrOwnedLock {\n+    stderr().into_lock()\n+}\n+\n impl Stderr {\n     /// Locks this handle to the standard error stream, returning a writable\n     /// guard.\n@@ -792,8 +1016,42 @@ impl Stderr {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> StderrLock<'_> {\n+        self.lock_any()\n+    }\n+\n+    // Locks this handle with any lifetime. This depends on the\n+    // implementation detail that the underlying `ReentrantMutex` is\n+    // static.\n+    fn lock_any<'a>(&self) -> StderrLock<'a> {\n         StderrLock { inner: self.inner.lock() }\n     }\n+\n+    /// Locks and consumes this handle to the standard error stream,\n+    /// returning a writable guard.\n+    ///\n+    /// The lock is released when the returned guard goes out of scope. The\n+    /// returned guard also implements the [`Write`] trait for writing\n+    /// data.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(stdio_locked)]\n+    /// use std::io::{self, Write};\n+    ///\n+    /// fn foo() -> io::Result<()> {\n+    ///     let stderr = io::stderr();\n+    ///     let mut handle = stderr.into_lock();\n+    ///\n+    ///     handle.write_all(b\"hello world\")?;\n+    ///\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"stdio_locked\", issue = \"none\")]\n+    pub fn into_lock(self) -> StderrOwnedLock {\n+        self.lock_any()\n+    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]"}, {"sha": "d84537e54de89fe6b930b72b427cbe6c1842ec36", "filename": "library/std/src/io/stdio/tests.rs", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/b3db5cd46c6941563ae8792cf61160c5793d397a/library%2Fstd%2Fsrc%2Fio%2Fstdio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3db5cd46c6941563ae8792cf61160c5793d397a/library%2Fstd%2Fsrc%2Fio%2Fstdio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio%2Ftests.rs?ref=b3db5cd46c6941563ae8792cf61160c5793d397a", "patch": "@@ -1,5 +1,6 @@\n use super::*;\n use crate::panic::{RefUnwindSafe, UnwindSafe};\n+use crate::sync::mpsc::sync_channel;\n use crate::thread;\n \n #[test]\n@@ -45,3 +46,136 @@ fn panic_doesnt_poison() {\n     let _a = stderr();\n     let _a = _a.lock();\n }\n+\n+#[test]\n+fn stderr_owned_lock_static() {\n+    assert_static::<StderrOwnedLock>();\n+}\n+#[test]\n+fn stdin_owned_lock_static() {\n+    assert_static::<StdinOwnedLock>();\n+}\n+#[test]\n+fn stdout_owned_lock_static() {\n+    assert_static::<StdoutOwnedLock>();\n+}\n+\n+fn assert_static<T: 'static>() {}\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+fn test_lock_stderr() {\n+    test_lock(stderr, stderr_locked);\n+}\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+fn test_lock_stdin() {\n+    test_lock(stdin, stdin_locked);\n+}\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+fn test_lock_stdout() {\n+    test_lock(stdout, stdout_locked);\n+}\n+\n+// Helper trait to make lock testing function generic.\n+trait Stdio<'a>: 'static\n+where\n+    Self::Lock: 'a,\n+{\n+    type Lock;\n+    fn lock(&'a self) -> Self::Lock;\n+}\n+impl<'a> Stdio<'a> for Stderr {\n+    type Lock = StderrLock<'a>;\n+    fn lock(&'a self) -> StderrLock<'a> {\n+        self.lock()\n+    }\n+}\n+impl<'a> Stdio<'a> for Stdin {\n+    type Lock = StdinLock<'a>;\n+    fn lock(&'a self) -> StdinLock<'a> {\n+        self.lock()\n+    }\n+}\n+impl<'a> Stdio<'a> for Stdout {\n+    type Lock = StdoutLock<'a>;\n+    fn lock(&'a self) -> StdoutLock<'a> {\n+        self.lock()\n+    }\n+}\n+\n+// Helper trait to make lock testing function generic.\n+trait StdioOwnedLock: 'static {}\n+impl StdioOwnedLock for StderrOwnedLock {}\n+impl StdioOwnedLock for StdinOwnedLock {}\n+impl StdioOwnedLock for StdoutOwnedLock {}\n+\n+// Tests locking on stdio handles by starting two threads and checking that\n+// they block each other appropriately.\n+fn test_lock<T, U>(get_handle: fn() -> T, get_locked: fn() -> U)\n+where\n+    T: for<'a> Stdio<'a>,\n+    U: StdioOwnedLock,\n+{\n+    // State enum to track different phases of the test, primarily when\n+    // each lock is acquired and released.\n+    #[derive(Debug, PartialEq)]\n+    enum State {\n+        Start1,\n+        Acquire1,\n+        Start2,\n+        Release1,\n+        Acquire2,\n+        Release2,\n+    }\n+    use State::*;\n+    // Logging vector to be checked to make sure lock acquisitions and\n+    // releases happened in the correct order.\n+    let log = Arc::new(Mutex::new(Vec::new()));\n+    let ((tx1, rx1), (tx2, rx2)) = (sync_channel(0), sync_channel(0));\n+    let th1 = {\n+        let (log, tx) = (Arc::clone(&log), tx1);\n+        thread::spawn(move || {\n+            log.lock().unwrap().push(Start1);\n+            let handle = get_handle();\n+            {\n+                let locked = handle.lock();\n+                log.lock().unwrap().push(Acquire1);\n+                tx.send(Acquire1).unwrap(); // notify of acquisition\n+                tx.send(Release1).unwrap(); // wait for release command\n+                log.lock().unwrap().push(Release1);\n+            }\n+            tx.send(Acquire1).unwrap(); // wait for th2 acquire\n+            {\n+                let locked = handle.lock();\n+                log.lock().unwrap().push(Acquire1);\n+            }\n+            log.lock().unwrap().push(Release1);\n+        })\n+    };\n+    let th2 = {\n+        let (log, tx) = (Arc::clone(&log), tx2);\n+        thread::spawn(move || {\n+            tx.send(Start2).unwrap(); // wait for start command\n+            let locked = get_locked();\n+            log.lock().unwrap().push(Acquire2);\n+            tx.send(Acquire2).unwrap(); // notify of acquisition\n+            tx.send(Release2).unwrap(); // wait for release command\n+            log.lock().unwrap().push(Release2);\n+        })\n+    };\n+    assert_eq!(rx1.recv().unwrap(), Acquire1); // wait for th1 acquire\n+    log.lock().unwrap().push(Start2);\n+    assert_eq!(rx2.recv().unwrap(), Start2); // block th2\n+    assert_eq!(rx1.recv().unwrap(), Release1); // release th1\n+    assert_eq!(rx2.recv().unwrap(), Acquire2); // wait for th2 acquire\n+    assert_eq!(rx1.recv().unwrap(), Acquire1); // block th1\n+    assert_eq!(rx2.recv().unwrap(), Release2); // release th2\n+    th2.join().unwrap();\n+    th1.join().unwrap();\n+    assert_eq!(\n+        *log.lock().unwrap(),\n+        [Start1, Acquire1, Start2, Release1, Acquire2, Release2, Acquire1, Release1]\n+    );\n+}"}]}