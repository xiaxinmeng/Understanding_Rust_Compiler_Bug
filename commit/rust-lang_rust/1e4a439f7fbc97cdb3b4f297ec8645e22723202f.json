{"sha": "1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNGE0MzlmN2ZiYzk3Y2RiM2I0ZjI5N2VjODY0NWUyMjcyMzIwMmY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-17T16:15:37Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-20T03:23:23Z"}, "message": "rustc: de-mode + fallout from libsyntax changes", "tree": {"sha": "2734b26ac36ef58d7081078d0a53bb83fbbd64ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2734b26ac36ef58d7081078d0a53bb83fbbd64ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "html_url": "https://github.com/rust-lang/rust/commit/1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c7aea3a6a5fcf04066d0368bfd6618e9494176c", "html_url": "https://github.com/rust-lang/rust/commit/3c7aea3a6a5fcf04066d0368bfd6618e9494176c"}], "stats": {"total": 1100, "additions": 547, "deletions": 553}, "files": [{"sha": "3dfa318826b7bd8340031701ff20ec0b11e6b421", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -48,7 +48,7 @@ pub enum output_type {\n     output_type_exe,\n }\n \n-pub fn llvm_err(sess: Session, +msg: ~str) -> ! {\n+pub fn llvm_err(sess: Session, msg: ~str) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n         if cstr == ptr::null() {\n@@ -153,7 +153,7 @@ pub mod jit {\n                     code: entry,\n                     env: ptr::null()\n                 };\n-                let func: &fn(++argv: ~[@~str]) = cast::transmute(closure);\n+                let func: &fn(argv: ~[@~str]) = cast::transmute(closure);\n \n                 func(~[sess.opts.binary]);\n             }\n@@ -519,7 +519,7 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n \n     // This calculates CMH as defined above\n     fn crate_meta_extras_hash(symbol_hasher: &hash::State,\n-                              +cmh_items: ~[@ast::meta_item],\n+                              cmh_items: ~[@ast::meta_item],\n                               dep_hashes: ~[~str]) -> @str {\n         fn len_and_str(s: &str) -> ~str {\n             fmt!(\"%u_%s\", s.len(), s)\n@@ -568,7 +568,7 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n                        name, default));\n     }\n \n-    fn crate_meta_name(sess: Session, output: &Path, +opt_name: Option<@str>)\n+    fn crate_meta_name(sess: Session, output: &Path, opt_name: Option<@str>)\n                     -> @str {\n         return match opt_name {\n               Some(v) => v,\n@@ -703,7 +703,7 @@ pub fn mangle(sess: Session, ss: path) -> ~str {\n }\n \n pub fn exported_name(sess: Session,\n-                     +path: path,\n+                     path: path,\n                      hash: &str,\n                      vers: &str) -> ~str {\n     return mangle(sess,\n@@ -713,7 +713,7 @@ pub fn exported_name(sess: Session,\n }\n \n pub fn mangle_exported_name(ccx: @CrateContext,\n-                            +path: path,\n+                            path: path,\n                             t: ty::t) -> ~str {\n     let hash = get_symbol_hash(ccx, t);\n     return exported_name(ccx.sess, path,\n@@ -733,17 +733,17 @@ pub fn mangle_internal_name_by_type_only(ccx: @CrateContext,\n }\n \n pub fn mangle_internal_name_by_path_and_seq(ccx: @CrateContext,\n-                                            +path: path,\n-                                            +flav: ~str) -> ~str {\n+                                            path: path,\n+                                            flav: ~str) -> ~str {\n     return mangle(ccx.sess,\n                   vec::append_one(path, path_name((ccx.names)(flav))));\n }\n \n-pub fn mangle_internal_name_by_path(ccx: @CrateContext, +path: path) -> ~str {\n+pub fn mangle_internal_name_by_path(ccx: @CrateContext, path: path) -> ~str {\n     return mangle(ccx.sess, path);\n }\n \n-pub fn mangle_internal_name_by_seq(ccx: @CrateContext, +flav: ~str) -> ~str {\n+pub fn mangle_internal_name_by_seq(ccx: @CrateContext, flav: ~str) -> ~str {\n     return fmt!(\"%s_%u\", flav, (ccx.names)(flav).repr);\n }\n \n@@ -768,7 +768,7 @@ pub fn link_binary(sess: Session,\n                    out_filename: &Path,\n                    lm: LinkMeta) {\n     // Converts a library file-stem into a cc -l argument\n-    fn unlib(config: @session::config, +stem: ~str) -> ~str {\n+    fn unlib(config: @session::config, stem: ~str) -> ~str {\n         if stem.starts_with(\"lib\") &&\n             config.os != session::os_win32 {\n             stem.slice(3, stem.len()).to_owned()"}, {"sha": "fae73d7faf2d4965eef53de19bfbd2f77b136b8d", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -55,14 +55,14 @@ pub enum pp_mode {\n  */\n pub fn anon_src() -> ~str { ~\"<anon>\" }\n \n-pub fn source_name(input: input) -> ~str {\n-    match input {\n+pub fn source_name(input: &input) -> ~str {\n+    match *input {\n       file_input(ref ifile) => ifile.to_str(),\n       str_input(_) => anon_src()\n     }\n }\n \n-pub fn default_configuration(sess: Session, argv0: @~str, input: input) ->\n+pub fn default_configuration(sess: Session, argv0: @~str, input: &input) ->\n    ast::crate_cfg {\n     let libc = match sess.targ_cfg.os {\n       session::os_win32 => ~\"msvcrt.dll\",\n@@ -105,7 +105,7 @@ pub fn default_configuration(sess: Session, argv0: @~str, input: input) ->\n          mk(@~\"build_input\", @source_name(input))];\n }\n \n-pub fn append_configuration(+cfg: ast::crate_cfg, +name: ~str)\n+pub fn append_configuration(cfg: ast::crate_cfg, name: ~str)\n                          -> ast::crate_cfg {\n     if attr::contains_name(cfg, name) {\n         cfg\n@@ -114,7 +114,7 @@ pub fn append_configuration(+cfg: ast::crate_cfg, +name: ~str)\n     }\n }\n \n-pub fn build_configuration(sess: Session, argv0: @~str, input: input) ->\n+pub fn build_configuration(sess: Session, argv0: @~str, input: &input) ->\n    ast::crate_cfg {\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n@@ -132,7 +132,7 @@ pub fn build_configuration(sess: Session, argv0: @~str, input: input) ->\n }\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n-fn parse_cfgspecs(+cfgspecs: ~[~str],\n+fn parse_cfgspecs(cfgspecs: ~[~str],\n                   demitter: diagnostic::Emitter) -> ast::crate_cfg {\n     do vec::map_consume(cfgspecs) |s| {\n         let sess = parse::new_parse_sess(Some(demitter));\n@@ -147,9 +147,9 @@ pub enum input {\n     str_input(~str)\n }\n \n-pub fn parse_input(sess: Session, +cfg: ast::crate_cfg, input: input)\n+pub fn parse_input(sess: Session, cfg: ast::crate_cfg, input: &input)\n     -> @ast::crate {\n-    match input {\n+    match *input {\n       file_input(ref file) => {\n         parse::parse_crate_from_file_using_tts(&(*file), cfg, sess.parse_sess)\n       }\n@@ -207,10 +207,10 @@ pub fn compile_rest(sess: Session,\n         lint::build_settings_crate(sess, crate));\n \n     let ast_map = time(time_passes, ~\"ast indexing\", ||\n-            syntax::ast_map::map_crate(sess.diagnostic(), *crate));\n+            syntax::ast_map::map_crate(sess.diagnostic(), crate));\n \n     time(time_passes, ~\"external crate/lib resolution\", ||\n-        creader::read_crates(sess.diagnostic(), *crate, sess.cstore,\n+        creader::read_crates(sess.diagnostic(), crate, sess.cstore,\n                              sess.filesearch,\n                              session::sess_os_to_meta_os(sess.targ_cfg.os),\n                              sess.opts.is_static,\n@@ -344,8 +344,8 @@ pub fn compile_rest(sess: Session,\n     return (crate, None);\n }\n \n-pub fn compile_upto(sess: Session, +cfg: ast::crate_cfg,\n-                input: input, upto: compile_upto,\n+pub fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n+                input: &input, upto: compile_upto,\n                 outputs: Option<@OutputFilenames>)\n     -> (@ast::crate, Option<ty::ctxt>) {\n     let time_passes = sess.time_passes();\n@@ -356,7 +356,7 @@ pub fn compile_upto(sess: Session, +cfg: ast::crate_cfg,\n     compile_rest(sess, cfg, upto, outputs, Some(crate))\n }\n \n-pub fn compile_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n+pub fn compile_input(sess: Session, cfg: ast::crate_cfg, input: &input,\n                      outdir: &Option<Path>, output: &Option<Path>) {\n     let upto = if sess.opts.parse_only { cu_parse }\n                else if sess.opts.no_trans { cu_no_trans }\n@@ -365,7 +365,7 @@ pub fn compile_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n     compile_upto(sess, cfg, input, upto, Some(outputs));\n }\n \n-pub fn pretty_print_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n+pub fn pretty_print_input(sess: Session, cfg: ast::crate_cfg, input: &input,\n                           ppm: pp_mode) {\n     fn ann_paren_for_expr(node: pprust::ann_node) {\n         match node {\n@@ -690,7 +690,7 @@ pub fn build_session_(sopts: @session::options,\n                                                     cm);\n     let cstore = @mut cstore::mk_cstore(p_s.interner);\n     let filesearch = filesearch::mk_filesearch(\n-        sopts.maybe_sysroot,\n+        &sopts.maybe_sysroot,\n         sopts.target_triple,\n         /*bad*/copy sopts.addl_lib_search_paths);\n     let lint_settings = lint::mk_lint_settings();\n@@ -711,13 +711,13 @@ pub fn build_session_(sopts: @session::options,\n     }\n }\n \n-pub fn parse_pretty(sess: Session, &&name: ~str) -> pp_mode {\n+pub fn parse_pretty(sess: Session, name: &str) -> pp_mode {\n     match name {\n-      ~\"normal\" => ppm_normal,\n-      ~\"expanded\" => ppm_expanded,\n-      ~\"typed\" => ppm_typed,\n-      ~\"expanded,identified\" => ppm_expanded_identified,\n-      ~\"identified\" => ppm_identified,\n+      &\"normal\" => ppm_normal,\n+      &\"expanded\" => ppm_expanded,\n+      &\"typed\" => ppm_typed,\n+      &\"expanded,identified\" => ppm_expanded_identified,\n+      &\"identified\" => ppm_identified,\n       _ => {\n         sess.fatal(~\"argument to `pretty` must be one of `normal`, \\\n                      `expanded`, `typed`, `identified`, \\\n@@ -790,7 +790,7 @@ pub struct OutputFilenames {\n     obj_filename: Path\n }\n \n-pub fn build_output_filenames(input: input,\n+pub fn build_output_filenames(input: &input,\n                               odir: &Option<Path>,\n                               ofile: &Option<Path>,\n                               sess: Session)\n@@ -820,13 +820,13 @@ pub fn build_output_filenames(input: input,\n         // We want to toss everything after the final '.'\n         let dirpath = match *odir {\n           Some(ref d) => (/*bad*/copy *d),\n-          None => match input {\n+          None => match *input {\n             str_input(_) => os::getcwd(),\n             file_input(ref ifile) => (*ifile).dir_path()\n           }\n         };\n \n-        let stem = match input {\n+        let stem = match *input {\n           file_input(ref ifile) => (*ifile).filestem().get(),\n           str_input(_) => ~\"rust_out\"\n         };\n@@ -903,7 +903,7 @@ mod test {\n         let sessopts = build_session_options(\n             @~\"rustc\", matches, diagnostic::emit);\n         let sess = build_session(sessopts, diagnostic::emit);\n-        let cfg = build_configuration(sess, @~\"whatever\", str_input(~\"\"));\n+        let cfg = build_configuration(sess, @~\"whatever\", &str_input(~\"\"));\n         assert!((attr::contains_name(cfg, ~\"test\")));\n     }\n \n@@ -922,7 +922,7 @@ mod test {\n         let sessopts = build_session_options(\n             @~\"rustc\", matches, diagnostic::emit);\n         let sess = build_session(sessopts, diagnostic::emit);\n-        let cfg = build_configuration(sess, @~\"whatever\", str_input(~\"\"));\n+        let cfg = build_configuration(sess, @~\"whatever\", &str_input(~\"\"));\n         let test_items = attr::find_meta_items_by_name(cfg, ~\"test\");\n         assert!((vec::len(test_items) == 1u));\n     }"}, {"sha": "1912c922524fb34563c5feeb1e3410eeb726ba33", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -215,7 +215,7 @@ pub impl Session_ {\n     fn unimpl(@self, msg: ~str) -> ! {\n         self.span_diagnostic.handler().unimpl(msg)\n     }\n-    fn span_lint_level(@self, level: lint::level, sp: span, +msg: ~str) {\n+    fn span_lint_level(@self, level: lint::level, sp: span, msg: ~str) {\n         match level {\n           lint::allow => { },\n           lint::warn => self.span_warn(sp, msg),\n@@ -228,7 +228,7 @@ pub impl Session_ {\n                  expr_id: ast::node_id,\n                  item_id: ast::node_id,\n                  span: span,\n-                 +msg: ~str) {\n+                 msg: ~str) {\n         let level = lint::get_lint_settings_level(\n             self.lint_settings, lint_mode, expr_id, item_id);\n         self.span_lint_level(level, span, msg);\n@@ -278,7 +278,7 @@ pub impl Session_ {\n     fn str_of(@self, id: ast::ident) -> @~str {\n         self.parse_sess.interner.get(id)\n     }\n-    fn ident_of(@self, +st: ~str) -> ast::ident {\n+    fn ident_of(@self, st: ~str) -> ast::ident {\n         self.parse_sess.interner.intern(@st)\n     }\n     fn intr(@self) -> @syntax::parse::token::ident_interner {\n@@ -361,7 +361,7 @@ mod test {\n     use syntax::ast;\n     use syntax::codemap;\n \n-    fn make_crate_type_attr(+t: ~str) -> ast::attribute {\n+    fn make_crate_type_attr(t: ~str) -> ast::attribute {\n         codemap::respan(codemap::dummy_sp(), ast::attribute_ {\n             style: ast::attr_outer,\n             value: @codemap::respan(codemap::dummy_sp(),"}, {"sha": "966f2a4ac70f3de5111dfa271ac627e0859e6ee7", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -15,7 +15,7 @@ use syntax::{ast, fold, attr};\n use core::option;\n use core::vec;\n \n-type in_cfg_pred = @fn(+attrs: ~[ast::attribute]) -> bool;\n+type in_cfg_pred = @fn(attrs: ~[ast::attribute]) -> bool;\n \n struct Context {\n     in_cfg: in_cfg_pred\n@@ -49,12 +49,12 @@ pub fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n     return res;\n }\n \n-fn filter_item(cx: @Context, &&item: @ast::item) ->\n+fn filter_item(cx: @Context, item: @ast::item) ->\n    Option<@ast::item> {\n     if item_in_cfg(cx, item) { option::Some(item) } else { option::None }\n }\n \n-fn filter_view_item(cx: @Context, &&view_item: @ast::view_item\n+fn filter_view_item(cx: @Context, view_item: @ast::view_item\n                    )-> Option<@ast::view_item> {\n     if view_item_in_cfg(cx, view_item) {\n         option::Some(view_item)\n@@ -74,7 +74,7 @@ fn fold_mod(cx: @Context, m: &ast::_mod, fld: @fold::ast_fold) -> ast::_mod {\n     }\n }\n \n-fn filter_foreign_item(cx: @Context, &&item: @ast::foreign_item) ->\n+fn filter_foreign_item(cx: @Context, item: @ast::foreign_item) ->\n    Option<@ast::foreign_item> {\n     if foreign_item_in_cfg(cx, item) {\n         option::Some(item)\n@@ -115,7 +115,7 @@ fn fold_item_underscore(cx: @Context, item: &ast::item_,\n     fold::noop_fold_item_underscore(&item, fld)\n }\n \n-fn filter_stmt(cx: @Context, &&stmt: @ast::stmt) ->\n+fn filter_stmt(cx: @Context, stmt: @ast::stmt) ->\n    Option<@ast::stmt> {\n     match stmt.node {\n       ast::stmt_decl(decl, _) => {\n@@ -173,12 +173,12 @@ fn trait_method_in_cfg(cx: @Context, meth: &ast::trait_method) -> bool {\n \n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(+cfg: ast::crate_cfg, +attrs: ~[ast::attribute]) -> bool {\n+fn in_cfg(cfg: ast::crate_cfg, attrs: ~[ast::attribute]) -> bool {\n     metas_in_cfg(cfg, attr::attr_metas(attrs))\n }\n \n pub fn metas_in_cfg(cfg: ast::crate_cfg,\n-                    +metas: ~[@ast::meta_item]) -> bool {\n+                    metas: ~[@ast::meta_item]) -> bool {\n     // The \"cfg\" attributes on the item\n     let cfg_metas = attr::find_meta_items_by_name(metas, ~\"cfg\");\n "}, {"sha": "4a122d238d496a717f834174b8500dd0fad1b865", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -138,7 +138,7 @@ fn fold_crate(cx: @mut TestCtxt,\n }\n \n \n-fn fold_item(cx: @mut TestCtxt, &&i: @ast::item, fld: @fold::ast_fold)\n+fn fold_item(cx: @mut TestCtxt, i: @ast::item, fld: @fold::ast_fold)\n           -> Option<@ast::item> {\n     cx.path.push(i.ident);\n     debug!(\"current path: %s\",\n@@ -336,15 +336,15 @@ fn nospan<T:Copy>(t: T) -> codemap::spanned<T> {\n     codemap::spanned { node: t, span: dummy_sp() }\n }\n \n-fn path_node(+ids: ~[ast::ident]) -> @ast::Path {\n+fn path_node(ids: ~[ast::ident]) -> @ast::Path {\n     @ast::Path { span: dummy_sp(),\n                 global: false,\n                 idents: ids,\n                 rp: None,\n                 types: ~[] }\n }\n \n-fn path_node_global(+ids: ~[ast::ident]) -> @ast::Path {\n+fn path_node_global(ids: ~[ast::ident]) -> @ast::Path {\n     @ast::Path { span: dummy_sp(),\n                  global: true,\n                  idents: ids,\n@@ -381,7 +381,7 @@ fn mk_test_descs(cx: &TestCtxt) -> @ast::expr {\n     debug!(\"building test vector from %u tests\", cx.testfns.len());\n     let mut descs = ~[];\n     for cx.testfns.each |test| {\n-        descs.push(mk_test_desc_and_fn_rec(cx, *test));\n+        descs.push(mk_test_desc_and_fn_rec(cx, test));\n     }\n \n     let sess = cx.sess;\n@@ -400,7 +400,7 @@ fn mk_test_descs(cx: &TestCtxt) -> @ast::expr {\n     }\n }\n \n-fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: Test) -> @ast::expr {\n+fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::expr {\n     let span = test.span;\n     let path = /*bad*/copy test.path;\n "}, {"sha": "369e6aeb4a5983db7d0e3d3ac55405e794ff52ff", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -1929,7 +1929,7 @@ pub fn type_to_str(names: @TypeNames, ty: TypeRef) -> @str {\n     return type_to_str_inner(names, [], ty);\n }\n \n-pub fn type_to_str_inner(names: @TypeNames, +outer0: &[TypeRef], ty: TypeRef)\n+pub fn type_to_str_inner(names: @TypeNames, outer0: &[TypeRef], ty: TypeRef)\n                       -> @str {\n     unsafe {\n         match type_has_name(names, ty) {"}, {"sha": "909e351acb1be97eb9bcf451d1ca36c5ed103589", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -30,7 +30,7 @@ use syntax::ast;\n // Traverses an AST, reading all the information about use'd crates and extern\n // libraries necessary for later resolving, typechecking, linking, etc.\n pub fn read_crates(diag: @span_handler,\n-                   crate: ast::crate,\n+                   crate: @ast::crate,\n                    cstore: @mut cstore::CStore,\n                    filesearch: @FileSearch,\n                    os: loader::os,\n@@ -126,7 +126,7 @@ struct Env {\n     intr: @ident_interner\n }\n \n-fn visit_crate(e: @mut Env, c: ast::crate) {\n+fn visit_crate(e: @mut Env, c: &ast::crate) {\n     let cstore = e.cstore;\n     let link_args = attr::find_attrs_by_name(c.node.attrs, \"link_args\");\n \n@@ -204,7 +204,7 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n     }\n }\n \n-fn metas_with(ident: @~str, key: @~str, +metas: ~[@ast::meta_item])\n+fn metas_with(ident: @~str, key: @~str, metas: ~[@ast::meta_item])\n     -> ~[@ast::meta_item] {\n     let name_items = attr::find_meta_items_by_name(metas, *key);\n     if name_items.is_empty() {\n@@ -214,7 +214,7 @@ fn metas_with(ident: @~str, key: @~str, +metas: ~[@ast::meta_item])\n     }\n }\n \n-fn metas_with_ident(ident: @~str, +metas: ~[@ast::meta_item])\n+fn metas_with_ident(ident: @~str, metas: ~[@ast::meta_item])\n     -> ~[@ast::meta_item] {\n     metas_with(ident, @~\"name\", metas)\n }\n@@ -232,7 +232,7 @@ fn existing_match(e: @mut Env, metas: &[@ast::meta_item], hash: @~str)\n \n fn resolve_crate(e: @mut Env,\n                  ident: ast::ident,\n-                 +metas: ~[@ast::meta_item],\n+                 metas: ~[@ast::meta_item],\n                  hash: @~str,\n                  span: span)\n               -> ast::crate_num {\n@@ -251,7 +251,7 @@ fn resolve_crate(e: @mut Env,\n             is_static: e.statik,\n             intr: e.intr\n         };\n-        let (lident, ldata) = loader::load_library_crate(load_ctxt);\n+        let (lident, ldata) = loader::load_library_crate(&load_ctxt);\n \n         let cfilename = Path(lident);\n         let cdata = ldata;"}, {"sha": "aaafc7c18d6f3d923dd398cf60b3156e3e37e86d", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -53,7 +53,7 @@ use writer = std::ebml::writer;\n type abbrev_map = @mut HashMap<ty::t, tyencode::ty_abbrev>;\n \n pub type encode_inlined_item = @fn(ecx: @EncodeContext,\n-                                   ebml_w: writer::Encoder,\n+                                   ebml_w: &writer::Encoder,\n                                    path: &[ast_map::path_elt],\n                                    ii: ast::inlined_item);\n \n@@ -101,31 +101,31 @@ pub fn reachable(ecx: @EncodeContext, id: node_id) -> bool {\n     ecx.reachable.contains(&id)\n }\n \n-fn encode_name(ecx: @EncodeContext, ebml_w: writer::Encoder, name: ident) {\n+fn encode_name(ecx: @EncodeContext, ebml_w: &writer::Encoder, name: ident) {\n     ebml_w.wr_tagged_str(tag_paths_data_name, *ecx.tcx.sess.str_of(name));\n }\n \n-fn encode_impl_type_basename(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_impl_type_basename(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                              name: ident) {\n     ebml_w.wr_tagged_str(tag_item_impl_type_basename,\n                          *ecx.tcx.sess.str_of(name));\n }\n \n-pub fn encode_def_id(ebml_w: writer::Encoder, id: def_id) {\n+pub fn encode_def_id(ebml_w: &writer::Encoder, id: def_id) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n-fn encode_region_param(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_region_param(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                        it: @ast::item) {\n     let opt_rp = ecx.tcx.region_paramd_items.find(&it.id);\n     for opt_rp.each |rp| {\n         do ebml_w.wr_tag(tag_region_param) {\n-            (*rp).encode(&ebml_w);\n+            rp.encode(ebml_w);\n         }\n     }\n }\n \n-fn encode_mutability(ebml_w: writer::Encoder, mt: struct_mutability) {\n+fn encode_mutability(ebml_w: &writer::Encoder, mt: struct_mutability) {\n     do ebml_w.wr_tag(tag_struct_mut) {\n         let val = match mt {\n           struct_immutable => 'a',\n@@ -140,7 +140,7 @@ struct entry<T> {\n     pos: uint\n }\n \n-fn add_to_index(ecx: @EncodeContext, ebml_w: writer::Encoder, path: &[ident],\n+fn add_to_index(ecx: @EncodeContext, ebml_w: &writer::Encoder, path: &[ident],\n                 index: &mut ~[entry<~str>], name: ident) {\n     let mut full_path = ~[];\n     full_path.push_all(path);\n@@ -153,7 +153,7 @@ fn add_to_index(ecx: @EncodeContext, ebml_w: writer::Encoder, path: &[ident],\n         });\n }\n \n-fn encode_trait_ref(ebml_w: writer::Encoder,\n+fn encode_trait_ref(ebml_w: &writer::Encoder,\n                     ecx: @EncodeContext,\n                     trait_ref: &ty::TraitRef,\n                     tag: uint)\n@@ -171,15 +171,15 @@ fn encode_trait_ref(ebml_w: writer::Encoder,\n }\n \n // Item info table encoding\n-fn encode_family(ebml_w: writer::Encoder, c: char) {\n+fn encode_family(ebml_w: &writer::Encoder, c: char) {\n     ebml_w.start_tag(tag_items_data_item_family);\n     ebml_w.writer.write(&[c as u8]);\n     ebml_w.end_tag();\n }\n \n pub fn def_to_str(did: def_id) -> ~str { fmt!(\"%d:%d\", did.crate, did.node) }\n \n-fn encode_ty_type_param_defs(ebml_w: writer::Encoder,\n+fn encode_ty_type_param_defs(ebml_w: &writer::Encoder,\n                              ecx: @EncodeContext,\n                              params: @~[ty::TypeParameterDef],\n                              tag: uint) {\n@@ -196,7 +196,7 @@ fn encode_ty_type_param_defs(ebml_w: writer::Encoder,\n     }\n }\n \n-fn encode_type_param_bounds(ebml_w: writer::Encoder,\n+fn encode_type_param_bounds(ebml_w: &writer::Encoder,\n                             ecx: @EncodeContext,\n                             params: &OptVec<TyParam>) {\n     let ty_param_defs =\n@@ -206,13 +206,13 @@ fn encode_type_param_bounds(ebml_w: writer::Encoder,\n }\n \n \n-fn encode_variant_id(ebml_w: writer::Encoder, vid: def_id) {\n+fn encode_variant_id(ebml_w: &writer::Encoder, vid: def_id) {\n     ebml_w.start_tag(tag_items_data_item_variant);\n     ebml_w.writer.write(str::to_bytes(def_to_str(vid)));\n     ebml_w.end_tag();\n }\n \n-pub fn write_type(ecx: @EncodeContext, ebml_w: writer::Encoder, typ: ty::t) {\n+pub fn write_type(ecx: @EncodeContext, ebml_w: &writer::Encoder, typ: ty::t) {\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n@@ -222,7 +222,7 @@ pub fn write_type(ecx: @EncodeContext, ebml_w: writer::Encoder, typ: ty::t) {\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n-pub fn write_vstore(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+pub fn write_vstore(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                     vstore: ty::vstore) {\n     let ty_str_ctxt = @tyencode::ctxt {\n         diag: ecx.diag,\n@@ -233,14 +233,14 @@ pub fn write_vstore(ecx: @EncodeContext, ebml_w: writer::Encoder,\n     tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n }\n \n-fn encode_type(ecx: @EncodeContext, ebml_w: writer::Encoder, typ: ty::t) {\n+fn encode_type(ecx: @EncodeContext, ebml_w: &writer::Encoder, typ: ty::t) {\n     ebml_w.start_tag(tag_items_data_item_type);\n     write_type(ecx, ebml_w, typ);\n     ebml_w.end_tag();\n }\n \n fn encode_transformed_self_ty(ecx: @EncodeContext,\n-                              ebml_w: writer::Encoder,\n+                              ebml_w: &writer::Encoder,\n                               opt_typ: Option<ty::t>)\n {\n     for opt_typ.each |&typ| {\n@@ -251,7 +251,7 @@ fn encode_transformed_self_ty(ecx: @EncodeContext,\n }\n \n fn encode_method_fty(ecx: @EncodeContext,\n-                     ebml_w: writer::Encoder,\n+                     ebml_w: &writer::Encoder,\n                      typ: &ty::BareFnTy)\n {\n     ebml_w.start_tag(tag_item_method_fty);\n@@ -267,7 +267,7 @@ fn encode_method_fty(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_symbol(ecx: @EncodeContext, ebml_w: writer::Encoder, id: node_id) {\n+fn encode_symbol(ecx: @EncodeContext, ebml_w: &writer::Encoder, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     match ecx.item_symbols.find(&id) {\n         Some(x) => {\n@@ -282,27 +282,27 @@ fn encode_symbol(ecx: @EncodeContext, ebml_w: writer::Encoder, id: node_id) {\n     ebml_w.end_tag();\n }\n \n-fn encode_discriminant(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_discriminant(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                        id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     ebml_w.writer.write(str::to_bytes(**ecx.discrim_symbols.get(&id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_disr_val(_ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_disr_val(_ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                    disr_val: int) {\n     ebml_w.start_tag(tag_disr_val);\n     ebml_w.writer.write(str::to_bytes(int::to_str(disr_val)));\n     ebml_w.end_tag();\n }\n \n-fn encode_parent_item(ebml_w: writer::Encoder, id: def_id) {\n+fn encode_parent_item(ebml_w: &writer::Encoder, id: def_id) {\n     ebml_w.start_tag(tag_items_data_parent_item);\n     ebml_w.writer.write(str::to_bytes(def_to_str(id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_enum_variant_info(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_enum_variant_info(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                             id: node_id, variants: &[variant],\n                             path: &[ast_map::path_elt],\n                             index: @mut ~[entry<int>],\n@@ -343,9 +343,9 @@ fn encode_enum_variant_info(ecx: @EncodeContext, ebml_w: writer::Encoder,\n     }\n }\n \n-fn encode_path(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_path(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                path: &[ast_map::path_elt], name: ast_map::path_elt) {\n-    fn encode_path_elt(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+    fn encode_path_elt(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                        elt: ast_map::path_elt) {\n         let (tag, name) = match elt {\n           ast_map::path_mod(name) => (tag_path_elt_mod, name),\n@@ -364,7 +364,7 @@ fn encode_path(ecx: @EncodeContext, ebml_w: writer::Encoder,\n     }\n }\n \n-fn encode_info_for_mod(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_info_for_mod(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                        md: &_mod, id: node_id, path: &[ast_map::path_elt],\n                        name: ident) {\n     ebml_w.start_tag(tag_items_data_item);\n@@ -422,7 +422,7 @@ fn encode_info_for_mod(ecx: @EncodeContext, ebml_w: writer::Encoder,\n     ebml_w.end_tag();\n }\n \n-fn encode_struct_field_family(ebml_w: writer::Encoder,\n+fn encode_struct_field_family(ebml_w: &writer::Encoder,\n                               visibility: visibility) {\n     encode_family(ebml_w, match visibility {\n         public => 'g',\n@@ -431,7 +431,7 @@ fn encode_struct_field_family(ebml_w: writer::Encoder,\n     });\n }\n \n-fn encode_visibility(ebml_w: writer::Encoder, visibility: visibility) {\n+fn encode_visibility(ebml_w: &writer::Encoder, visibility: visibility) {\n     ebml_w.start_tag(tag_items_data_item_visibility);\n     let ch = match visibility {\n         public => 'y',\n@@ -442,7 +442,7 @@ fn encode_visibility(ebml_w: writer::Encoder, visibility: visibility) {\n     ebml_w.end_tag();\n }\n \n-fn encode_self_type(ebml_w: writer::Encoder, self_type: ast::self_ty_) {\n+fn encode_self_type(ebml_w: &writer::Encoder, self_type: ast::self_ty_) {\n     ebml_w.start_tag(tag_item_trait_method_self_ty);\n \n     // Encode the base self type.\n@@ -470,7 +470,7 @@ fn encode_self_type(ebml_w: writer::Encoder, self_type: ast::self_ty_) {\n \n     ebml_w.end_tag();\n \n-    fn encode_mutability(ebml_w: writer::Encoder,\n+    fn encode_mutability(ebml_w: &writer::Encoder,\n                          m: ast::mutability) {\n         match m {\n             m_imm => {\n@@ -486,14 +486,14 @@ fn encode_self_type(ebml_w: writer::Encoder, self_type: ast::self_ty_) {\n     }\n }\n \n-fn encode_method_sort(ebml_w: writer::Encoder, sort: char) {\n+fn encode_method_sort(ebml_w: &writer::Encoder, sort: char) {\n     ebml_w.start_tag(tag_item_trait_method_sort);\n     ebml_w.writer.write(&[ sort as u8 ]);\n     ebml_w.end_tag();\n }\n \n /* Returns an index of items in this class */\n-fn encode_info_for_struct(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_info_for_struct(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                          path: &[ast_map::path_elt],\n                          fields: &[@struct_field],\n                          global_index: @mut~[entry<int>]) -> ~[entry<int>] {\n@@ -532,7 +532,7 @@ fn encode_info_for_struct(ecx: @EncodeContext, ebml_w: writer::Encoder,\n \n // This is for encoding info for ctors and dtors\n fn encode_info_for_ctor(ecx: @EncodeContext,\n-                        ebml_w: writer::Encoder,\n+                        ebml_w: &writer::Encoder,\n                         id: node_id,\n                         ident: ident,\n                         path: &[ast_map::path_elt],\n@@ -550,8 +550,8 @@ fn encode_info_for_ctor(ecx: @EncodeContext,\n         encode_type(ecx, ebml_w, its_ty);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(ident));\n         match item {\n-           Some(ref it) => {\n-             (ecx.encode_inlined_item)(ecx, ebml_w, path, (*it));\n+           Some(it) => {\n+             (ecx.encode_inlined_item)(ecx, ebml_w, path, it);\n            }\n            None => {\n              encode_symbol(ecx, ebml_w, id);\n@@ -561,7 +561,7 @@ fn encode_info_for_ctor(ecx: @EncodeContext,\n }\n \n fn encode_info_for_struct_ctor(ecx: @EncodeContext,\n-                               ebml_w: writer::Encoder,\n+                               ebml_w: &writer::Encoder,\n                                path: &[ast_map::path_elt],\n                                name: ast::ident,\n                                ctor_id: node_id,\n@@ -583,7 +583,7 @@ fn encode_info_for_struct_ctor(ecx: @EncodeContext,\n }\n \n fn encode_method_ty_fields(ecx: @EncodeContext,\n-                           ebml_w: writer::Encoder,\n+                           ebml_w: &writer::Encoder,\n                            method_ty: &ty::method)\n {\n     encode_def_id(ebml_w, method_ty.def_id);\n@@ -598,7 +598,7 @@ fn encode_method_ty_fields(ecx: @EncodeContext,\n }\n \n fn encode_info_for_method(ecx: @EncodeContext,\n-                          ebml_w: writer::Encoder,\n+                          ebml_w: &writer::Encoder,\n                           impl_path: &[ast_map::path_elt],\n                           should_inline: bool,\n                           parent_id: node_id,\n@@ -669,7 +669,7 @@ fn should_inline(attrs: &[attribute]) -> bool {\n }\n \n \n-fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_info_for_item(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                         item: @item, index: @mut ~[entry<int>],\n                         path: &[ast_map::path_elt]) {\n \n@@ -682,7 +682,7 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         };\n     if !must_write && !reachable(ecx, item.id) { return; }\n \n-    fn add_to_index_(item: @item, ebml_w: writer::Encoder,\n+    fn add_to_index_(item: @item, ebml_w: &writer::Encoder,\n                      index: @mut ~[entry<int>]) {\n         index.push(entry { val: item.id, pos: ebml_w.writer.tell() });\n     }\n@@ -998,10 +998,10 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n }\n \n fn encode_info_for_foreign_item(ecx: @EncodeContext,\n-                                ebml_w: writer::Encoder,\n+                                ebml_w: &writer::Encoder,\n                                 nitem: @foreign_item,\n                                 index: @mut ~[entry<int>],\n-                                +path: ast_map::path,\n+                                path: ast_map::path,\n                                 abi: AbiSet) {\n     if !reachable(ecx, nitem.id) { return; }\n     index.push(entry { val: nitem.id, pos: ebml_w.writer.tell() });\n@@ -1031,36 +1031,36 @@ fn encode_info_for_foreign_item(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_info_for_items(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_info_for_items(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                          crate: &crate) -> ~[entry<int>] {\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n     index.push(entry { val: crate_node_id, pos: ebml_w.writer.tell() });\n     encode_info_for_mod(ecx, ebml_w, &crate.node.module,\n                         crate_node_id, ~[],\n                         syntax::parse::token::special_idents::invalid);\n-    visit::visit_crate(*crate, (), visit::mk_vt(@visit::Visitor {\n+    visit::visit_crate(crate, (), visit::mk_vt(@visit::Visitor {\n         visit_expr: |_e, _cx, _v| { },\n         visit_item: {\n-            let ebml_w = copy ebml_w;\n+            let ebml_w = copy *ebml_w;\n             |i, cx, v| {\n                 visit::visit_item(i, cx, v);\n                 match *ecx.tcx.items.get(&i.id) {\n                     ast_map::node_item(_, pt) => {\n-                        encode_info_for_item(ecx, ebml_w, i,\n+                        encode_info_for_item(ecx, &ebml_w, i,\n                                              index, *pt);\n                     }\n                     _ => fail!(~\"bad item\")\n                 }\n             }\n         },\n         visit_foreign_item: {\n-            let ebml_w = copy ebml_w;\n+            let ebml_w = copy *ebml_w;\n             |ni, cx, v| {\n                 visit::visit_foreign_item(ni, cx, v);\n                 match *ecx.tcx.items.get(&ni.id) {\n                     ast_map::node_foreign_item(_, abi, _, pt) => {\n-                        encode_info_for_foreign_item(ecx, ebml_w, ni,\n+                        encode_info_for_foreign_item(ecx, &ebml_w, ni,\n                                                      index, /*bad*/copy *pt,\n                                                      abi);\n                     }\n@@ -1094,8 +1094,8 @@ fn create_index<T:Copy + Hash + IterBytes>(index: ~[entry<T>]) ->\n     return buckets_frozen;\n }\n \n-fn encode_index<T>(ebml_w: writer::Encoder, buckets: ~[@~[entry<T>]],\n-                   write_fn: &fn(@io::Writer, T)) {\n+fn encode_index<T>(ebml_w: &writer::Encoder, buckets: ~[@~[entry<T>]],\n+                   write_fn: &fn(@io::Writer, &T)) {\n     let writer = ebml_w.writer;\n     ebml_w.start_tag(tag_index);\n     let mut bucket_locs: ~[uint] = ~[];\n@@ -1107,7 +1107,7 @@ fn encode_index<T>(ebml_w: writer::Encoder, buckets: ~[@~[entry<T>]],\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n             assert!(elt.pos < 0xffff_ffff);\n             writer.write_be_u32(elt.pos as u32);\n-            write_fn(writer, elt.val);\n+            write_fn(writer, &elt.val);\n             ebml_w.end_tag();\n         }\n         ebml_w.end_tag();\n@@ -1122,14 +1122,14 @@ fn encode_index<T>(ebml_w: writer::Encoder, buckets: ~[@~[entry<T>]],\n     ebml_w.end_tag();\n }\n \n-fn write_str(writer: @io::Writer, &&s: ~str) { writer.write_str(s); }\n+fn write_str(writer: @io::Writer, s: ~str) { writer.write_str(s); }\n \n-fn write_int(writer: @io::Writer, &&n: int) {\n+fn write_int(writer: @io::Writer, &n: &int) {\n     assert!(n < 0x7fff_ffff);\n     writer.write_be_u32(n as u32);\n }\n \n-fn encode_meta_item(ebml_w: writer::Encoder, mi: @meta_item) {\n+fn encode_meta_item(ebml_w: &writer::Encoder, mi: @meta_item) {\n     match mi.node {\n       meta_word(name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n@@ -1166,7 +1166,7 @@ fn encode_meta_item(ebml_w: writer::Encoder, mi: @meta_item) {\n     }\n }\n \n-fn encode_attributes(ebml_w: writer::Encoder, attrs: &[attribute]) {\n+fn encode_attributes(ebml_w: &writer::Encoder, attrs: &[attribute]) {\n     ebml_w.start_tag(tag_attributes);\n     for attrs.each |attr| {\n         ebml_w.start_tag(tag_attribute);\n@@ -1183,7 +1183,7 @@ fn encode_attributes(ebml_w: writer::Encoder, attrs: &[attribute]) {\n fn synthesize_crate_attrs(ecx: @EncodeContext,\n                           crate: &crate) -> ~[attribute] {\n \n-    fn synthesize_link_attr(ecx: @EncodeContext, +items: ~[@meta_item]) ->\n+    fn synthesize_link_attr(ecx: @EncodeContext, items: ~[@meta_item]) ->\n        attribute {\n \n         assert!(!ecx.link_meta.name.is_empty());\n@@ -1231,7 +1231,7 @@ fn synthesize_crate_attrs(ecx: @EncodeContext,\n }\n \n fn encode_crate_deps(ecx: @EncodeContext,\n-                     ebml_w: writer::Encoder,\n+                     ebml_w: &writer::Encoder,\n                      cstore: @mut cstore::CStore) {\n     fn get_ordered_deps(ecx: @EncodeContext, cstore: @mut cstore::CStore)\n                      -> ~[decoder::crate_dep] {\n@@ -1272,7 +1272,7 @@ fn encode_crate_deps(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_lang_items(ecx: @EncodeContext, ebml_w: writer::Encoder) {\n+fn encode_lang_items(ecx: @EncodeContext, ebml_w: &writer::Encoder) {\n     ebml_w.start_tag(tag_lang_items);\n \n     for ecx.tcx.lang_items.each_item |def_id, i| {\n@@ -1297,7 +1297,7 @@ fn encode_lang_items(ecx: @EncodeContext, ebml_w: writer::Encoder) {\n }\n \n fn encode_link_args(ecx: @EncodeContext,\n-                    ebml_w: writer::Encoder) {\n+                    ebml_w: &writer::Encoder) {\n     ebml_w.start_tag(tag_link_args);\n \n     let link_args = cstore::get_used_link_args(ecx.cstore);\n@@ -1310,7 +1310,7 @@ fn encode_link_args(ecx: @EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_crate_dep(ecx: @EncodeContext, ebml_w: writer::Encoder,\n+fn encode_crate_dep(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                     dep: decoder::crate_dep) {\n     ebml_w.start_tag(tag_crate_dep);\n     ebml_w.start_tag(tag_crate_dep_name);\n@@ -1325,7 +1325,7 @@ fn encode_crate_dep(ecx: @EncodeContext, ebml_w: writer::Encoder,\n     ebml_w.end_tag();\n }\n \n-fn encode_hash(ebml_w: writer::Encoder, hash: &str) {\n+fn encode_hash(ebml_w: &writer::Encoder, hash: &str) {\n     ebml_w.start_tag(tag_crate_hash);\n     ebml_w.writer.write(str::to_bytes(hash));\n     ebml_w.end_tag();\n@@ -1339,7 +1339,7 @@ pub static metadata_encoding_version : &'static [u8] =\n       0x74, //'t' as u8,\n       0, 0, 0, 1 ];\n \n-pub fn encode_metadata(+parms: EncodeParams, crate: &crate) -> ~[u8] {\n+pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n     let wr = @io::BytesWriter();\n     let mut stats = Stats {\n         inline_bytes: 0,\n@@ -1372,36 +1372,36 @@ pub fn encode_metadata(+parms: EncodeParams, crate: &crate) -> ~[u8] {\n \n     let ebml_w = writer::Encoder(wr as @io::Writer);\n \n-    encode_hash(ebml_w, ecx.link_meta.extras_hash);\n+    encode_hash(&ebml_w, ecx.link_meta.extras_hash);\n \n     let mut i = wr.pos;\n     let crate_attrs = synthesize_crate_attrs(ecx, crate);\n-    encode_attributes(ebml_w, crate_attrs);\n+    encode_attributes(&ebml_w, crate_attrs);\n     ecx.stats.attr_bytes = wr.pos - i;\n \n     i = wr.pos;\n-    encode_crate_deps(ecx, ebml_w, ecx.cstore);\n+    encode_crate_deps(ecx, &ebml_w, ecx.cstore);\n     ecx.stats.dep_bytes = wr.pos - i;\n \n     // Encode the language items.\n     i = wr.pos;\n-    encode_lang_items(ecx, ebml_w);\n+    encode_lang_items(ecx, &ebml_w);\n     ecx.stats.lang_item_bytes = wr.pos - i;\n \n     // Encode the link args.\n     i = wr.pos;\n-    encode_link_args(ecx, ebml_w);\n+    encode_link_args(ecx, &ebml_w);\n     ecx.stats.link_args_bytes = wr.pos - i;\n \n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n     i = wr.pos;\n-    let items_index = encode_info_for_items(ecx, ebml_w, crate);\n+    let items_index = encode_info_for_items(ecx, &ebml_w, crate);\n     ecx.stats.item_bytes = wr.pos - i;\n \n     i = wr.pos;\n     let items_buckets = create_index(items_index);\n-    encode_index(ebml_w, items_buckets, write_int);\n+    encode_index(&ebml_w, items_buckets, write_int);\n     ecx.stats.index_bytes = wr.pos - i;\n     ebml_w.end_tag();\n "}, {"sha": "25cbb97e39e123a87b5be2449e53d71e2d22ecfc", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -35,9 +35,9 @@ pub trait FileSearch {\n     fn get_target_lib_file_path(&self, file: &Path) -> Path;\n }\n \n-pub fn mk_filesearch(maybe_sysroot: Option<Path>,\n+pub fn mk_filesearch(maybe_sysroot: &Option<Path>,\n                      target_triple: &str,\n-                     +addl_lib_search_paths: ~[Path])\n+                     addl_lib_search_paths: ~[Path])\n                   -> @FileSearch {\n     struct FileSearchImpl {\n         sysroot: Path,\n@@ -117,8 +117,8 @@ fn get_or_default_sysroot() -> Path {\n     }\n }\n \n-fn get_sysroot(maybe_sysroot: Option<Path>) -> Path {\n-    match maybe_sysroot {\n+fn get_sysroot(maybe_sysroot: &Option<Path>) -> Path {\n+    match *maybe_sysroot {\n       option::Some(ref sr) => (/*bad*/copy *sr),\n       option::None => get_or_default_sysroot()\n     }"}, {"sha": "b21b6b4983bd252f2d433cb8b9077e680d881723", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -55,7 +55,7 @@ pub struct Context {\n     intr: @ident_interner\n }\n \n-pub fn load_library_crate(cx: Context) -> (~str, @~[u8]) {\n+pub fn load_library_crate(cx: &Context) -> (~str, @~[u8]) {\n     match find_library_crate(cx) {\n       Some(ref t) => return (/*bad*/copy *t),\n       None => {\n@@ -66,12 +66,12 @@ pub fn load_library_crate(cx: Context) -> (~str, @~[u8]) {\n     }\n }\n \n-fn find_library_crate(cx: Context) -> Option<(~str, @~[u8])> {\n+fn find_library_crate(cx: &Context) -> Option<(~str, @~[u8])> {\n     attr::require_unique_names(cx.diag, cx.metas);\n     find_library_crate_aux(cx, libname(cx), cx.filesearch)\n }\n \n-fn libname(cx: Context) -> (~str, ~str) {\n+fn libname(cx: &Context) -> (~str, ~str) {\n     if cx.is_static { return (~\"lib\", ~\".rlib\"); }\n     let (dll_prefix, dll_suffix) = match cx.os {\n         os_win32 => (win32::DLL_PREFIX, win32::DLL_SUFFIX),\n@@ -85,7 +85,7 @@ fn libname(cx: Context) -> (~str, ~str) {\n }\n \n fn find_library_crate_aux(\n-    cx: Context,\n+    cx: &Context,\n     (prefix, suffix): (~str, ~str),\n     filesearch: @filesearch::FileSearch\n ) -> Option<(~str, @~[u8])> {"}, {"sha": "0c290ac08a78e3400f2edbf7dd0047456dfcdb63", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -116,16 +116,16 @@ fn enc_mt(w: @io::Writer, cx: @ctxt, mt: ty::mt) {\n }\n \n fn enc_opt<T>(w: @io::Writer, t: Option<T>, enc_f: &fn(T)) {\n-    match &t {\n-      &None => w.write_char('n'),\n-      &Some(ref v) => {\n+    match t {\n+      None => w.write_char('n'),\n+      Some(v) => {\n         w.write_char('s');\n-        enc_f((*v));\n+        enc_f(v);\n       }\n     }\n }\n \n-fn enc_substs(w: @io::Writer, cx: @ctxt, substs: ty::substs) {\n+fn enc_substs(w: @io::Writer, cx: @ctxt, substs: &ty::substs) {\n     do enc_opt(w, substs.self_r) |r| { enc_region(w, cx, r) }\n     do enc_opt(w, substs.self_ty) |t| { enc_ty(w, cx, t) }\n     w.write_char('[');\n@@ -210,7 +210,7 @@ pub fn enc_vstore(w: @io::Writer, cx: @ctxt, v: ty::vstore) {\n pub fn enc_trait_ref(w: @io::Writer, cx: @ctxt, s: &ty::TraitRef) {\n     w.write_str((cx.ds)(s.def_id));\n     w.write_char('|');\n-    enc_substs(w, cx, s.substs);\n+    enc_substs(w, cx, &s.substs);\n }\n \n pub fn enc_trait_store(w: @io::Writer, cx: @ctxt, s: ty::TraitStore) {\n@@ -224,7 +224,7 @@ pub fn enc_trait_store(w: @io::Writer, cx: @ctxt, s: ty::TraitStore) {\n     }\n }\n \n-fn enc_sty(w: @io::Writer, cx: @ctxt, +st: ty::sty) {\n+fn enc_sty(w: @io::Writer, cx: @ctxt, st: ty::sty) {\n     match st {\n       ty::ty_nil => w.write_char('n'),\n       ty::ty_bot => w.write_char('z'),\n@@ -259,14 +259,14 @@ fn enc_sty(w: @io::Writer, cx: @ctxt, +st: ty::sty) {\n         w.write_str(&\"t[\");\n         w.write_str((cx.ds)(def));\n         w.write_char('|');\n-        enc_substs(w, cx, (*substs));\n+        enc_substs(w, cx, substs);\n         w.write_char(']');\n       }\n       ty::ty_trait(def, ref substs, store, mt) => {\n         w.write_str(&\"x[\");\n         w.write_str((cx.ds)(def));\n         w.write_char('|');\n-        enc_substs(w, cx, (*substs));\n+        enc_substs(w, cx, substs);\n         enc_trait_store(w, cx, store);\n         enc_mutability(w, mt);\n         w.write_char(']');\n@@ -330,7 +330,7 @@ fn enc_sty(w: @io::Writer, cx: @ctxt, +st: ty::sty) {\n           w.write_str(s);\n           debug!(\"~~~~ %s\", ~\"|\");\n           w.write_char('|');\n-          enc_substs(w, cx, (*substs));\n+          enc_substs(w, cx, substs);\n           debug!(\"~~~~ %s\", ~\"]\");\n           w.write_char(']');\n       }"}, {"sha": "7d4cb015106075c85ddb0b969372d592e03176ec", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -80,7 +80,7 @@ trait tr_intern {\n // Top-level methods.\n \n pub fn encode_inlined_item(ecx: @e::EncodeContext,\n-                           ebml_w: writer::Encoder,\n+                           ebml_w: &writer::Encoder,\n                            path: &[ast_map::path_elt],\n                            ii: ast::inlined_item,\n                            maps: Maps) {\n@@ -89,11 +89,11 @@ pub fn encode_inlined_item(ecx: @e::EncodeContext,\n            *ecx.tcx.sess.str_of(ii.ident()),\n            ebml_w.writer.tell());\n \n-    let id_range = ast_util::compute_id_range_for_inlined_item(ii);\n+    let id_range = ast_util::compute_id_range_for_inlined_item(&ii);\n     do ebml_w.wr_tag(c::tag_ast as uint) {\n-        id_range.encode(&ebml_w);\n-        encode_ast(ebml_w, simplify_ast(ii));\n-        encode_side_tables_for_ii(ecx, maps, ebml_w, ii);\n+        id_range.encode(ebml_w);\n+        encode_ast(ebml_w, simplify_ast(&ii));\n+        encode_side_tables_for_ii(ecx, maps, ebml_w, &ii);\n     }\n \n     debug!(\"< Encoded inlined fn: %s::%s (%u)\",\n@@ -105,7 +105,7 @@ pub fn encode_inlined_item(ecx: @e::EncodeContext,\n pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n                            tcx: ty::ctxt,\n                            maps: Maps,\n-                           +path: ast_map::path,\n+                           path: ast_map::path,\n                            par_doc: ebml::Doc)\n                         -> Option<ast::inlined_item> {\n     let dcx = @DecodeContext {\n@@ -133,7 +133,7 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n                ast_map::path_to_str(path, tcx.sess.parse_sess.interner),\n                *tcx.sess.str_of(ii.ident()));\n         ast_map::map_decoded_item(tcx.sess.diagnostic(),\n-                                  dcx.tcx.items, path, ii);\n+                                  dcx.tcx.items, path, &ii);\n         decode_side_tables(xcx, ast_doc);\n         match ii {\n           ast::ii_item(i) => {\n@@ -275,9 +275,9 @@ impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-fn encode_ast(ebml_w: writer::Encoder, item: ast::inlined_item) {\n+fn encode_ast(ebml_w: &writer::Encoder, item: ast::inlined_item) {\n     do ebml_w.wr_tag(c::tag_tree as uint) {\n-        item.encode(&ebml_w)\n+        item.encode(ebml_w)\n     }\n }\n \n@@ -291,7 +291,7 @@ fn encode_ast(ebml_w: writer::Encoder, item: ast::inlined_item) {\n // As it happens, trans relies on the fact that we do not export\n // nested items, as otherwise it would get confused when translating\n // inlined items.\n-fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n+fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n     fn drop_nested_items(blk: &ast::blk_, fld: @fold::ast_fold) -> ast::blk_ {\n         let stmts_sans_items = do blk.stmts.filtered |stmt| {\n             match stmt.node {\n@@ -319,7 +319,7 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n         .. *fold::default_ast_fold()\n     });\n \n-    match ii {\n+    match *ii {\n       ast::ii_item(i) => {\n         ast::ii_item(fld.fold_item(i).get()) //hack: we're not dropping items\n       }\n@@ -388,8 +388,8 @@ fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn encode_def(ebml_w: writer::Encoder, def: ast::def) {\n-    def.encode(&ebml_w)\n+fn encode_def(ebml_w: &writer::Encoder, def: ast::def) {\n+    def.encode(ebml_w)\n }\n \n fn decode_def(xcx: @ExtendedDecodeContext, doc: ebml::Doc) -> ast::def {\n@@ -499,8 +499,8 @@ impl tr for ty::bound_region {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n-fn encode_freevar_entry(ebml_w: writer::Encoder, fv: @freevar_entry) {\n-    (*fv).encode(&ebml_w)\n+fn encode_freevar_entry(ebml_w: &writer::Encoder, fv: @freevar_entry) {\n+    (*fv).encode(ebml_w)\n }\n \n trait ebml_decoder_helper {\n@@ -561,17 +561,17 @@ trait read_method_map_entry_helper {\n \n #[cfg(stage0)]\n fn encode_method_map_entry(ecx: @e::EncodeContext,\n-                              ebml_w: writer::Encoder,\n+                              ebml_w: &writer::Encoder,\n                               mme: method_map_entry) {\n     do ebml_w.emit_struct(\"method_map_entry\", 3) {\n         do ebml_w.emit_field(~\"self_arg\", 0u) {\n             ebml_w.emit_arg(ecx, mme.self_arg);\n         }\n         do ebml_w.emit_field(~\"explicit_self\", 2u) {\n-            mme.explicit_self.encode(&ebml_w);\n+            mme.explicit_self.encode(ebml_w);\n         }\n         do ebml_w.emit_field(~\"origin\", 1u) {\n-            mme.origin.encode(&ebml_w);\n+            mme.origin.encode(ebml_w);\n         }\n     }\n }\n@@ -580,17 +580,17 @@ fn encode_method_map_entry(ecx: @e::EncodeContext,\n #[cfg(stage2)]\n #[cfg(stage3)]\n fn encode_method_map_entry(ecx: @e::EncodeContext,\n-                              ebml_w: writer::Encoder,\n+                              ebml_w: &writer::Encoder,\n                               mme: method_map_entry) {\n     do ebml_w.emit_struct(\"method_map_entry\", 3) {\n         do ebml_w.emit_struct_field(\"self_arg\", 0u) {\n             ebml_w.emit_arg(ecx, mme.self_arg);\n         }\n         do ebml_w.emit_struct_field(\"explicit_self\", 2u) {\n-            mme.explicit_self.encode(&ebml_w);\n+            mme.explicit_self.encode(ebml_w);\n         }\n         do ebml_w.emit_struct_field(\"origin\", 1u) {\n-            mme.origin.encode(&ebml_w);\n+            mme.origin.encode(ebml_w);\n         }\n     }\n }\n@@ -672,22 +672,22 @@ impl tr for method_origin {\n // Encoding and decoding vtable_res\n \n fn encode_vtable_res(ecx: @e::EncodeContext,\n-                     ebml_w: writer::Encoder,\n+                     ebml_w: &writer::Encoder,\n                      dr: typeck::vtable_res) {\n     // can't autogenerate this code because automatic code of\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written encoding routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n     do ebml_w.emit_from_vec(*dr) |vtable_origin| {\n-        encode_vtable_origin(ecx, ebml_w, *vtable_origin)\n+        encode_vtable_origin(ecx, ebml_w, vtable_origin)\n     }\n }\n \n fn encode_vtable_origin(ecx: @e::EncodeContext,\n-                      ebml_w: writer::Encoder,\n-                      vtable_origin: typeck::vtable_origin) {\n+                        ebml_w: &writer::Encoder,\n+                        vtable_origin: &typeck::vtable_origin) {\n     do ebml_w.emit_enum(~\"vtable_origin\") {\n-        match vtable_origin {\n+        match *vtable_origin {\n           typeck::vtable_static(def_id, ref tys, vtable_res) => {\n             do ebml_w.emit_enum_variant(~\"vtable_static\", 0u, 3u) {\n                 do ebml_w.emit_enum_variant_arg(0u) {\n@@ -798,13 +798,13 @@ trait ebml_writer_helpers {\n impl ebml_writer_helpers for writer::Encoder {\n     fn emit_ty(&self, ecx: @e::EncodeContext, ty: ty::t) {\n         do self.emit_opaque {\n-            e::write_type(ecx, *self, ty)\n+            e::write_type(ecx, self, ty)\n         }\n     }\n \n     fn emit_vstore(&self, ecx: @e::EncodeContext, vstore: ty::vstore) {\n         do self.emit_opaque {\n-            e::write_vstore(ecx, *self, vstore)\n+            e::write_vstore(ecx, self, vstore)\n         }\n     }\n \n@@ -897,24 +897,25 @@ impl write_tag_and_id for writer::Encoder {\n \n fn encode_side_tables_for_ii(ecx: @e::EncodeContext,\n                              maps: Maps,\n-                             ebml_w: writer::Encoder,\n-                             ii: ast::inlined_item) {\n+                             ebml_w: &writer::Encoder,\n+                             ii: &ast::inlined_item) {\n     do ebml_w.wr_tag(c::tag_table as uint) {\n-        let ebml_w = copy ebml_w;\n+        let ebml_w = copy *ebml_w;\n         ast_util::visit_ids_for_inlined_item(\n             ii,\n             |id: ast::node_id| {\n                 // Note: this will cause a copy of ebml_w, which is bad as\n                 // it has mut fields.  But I believe it's harmless since\n                 // we generate balanced EBML.\n-                encode_side_tables_for_id(ecx, maps, ebml_w, id)\n+                /*let ebml_w = copy ebml_w;*/\n+                encode_side_tables_for_id(ecx, maps, &ebml_w, id)\n             });\n     }\n }\n \n fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n                              maps: Maps,\n-                             ebml_w: writer::Encoder,\n+                             ebml_w: &writer::Encoder,\n                              id: ast::node_id) {\n     let tcx = ecx.tcx;\n \n@@ -924,7 +925,7 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n         do ebml_w.tag(c::tag_table_def) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                (*def).encode(&ebml_w)\n+                (*def).encode(ebml_w)\n             }\n         }\n     }\n@@ -1004,7 +1005,7 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n                 do ebml_w.emit_from_vec(/*bad*/ copy **m) |id| {\n-                    id.encode(&ebml_w);\n+                    id.encode(ebml_w);\n                 }\n             }\n         }\n@@ -1032,7 +1033,7 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n         do ebml_w.tag(c::tag_table_adjustments) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                (**adj).encode(&ebml_w)\n+                (**adj).encode(ebml_w)\n             }\n         }\n     }\n@@ -1048,7 +1049,7 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n                 do ebml_w.emit_from_vec(*cap_vars) |cap_var| {\n-                    cap_var.encode(&ebml_w);\n+                    cap_var.encode(ebml_w);\n                 }\n             }\n         }\n@@ -1279,9 +1280,9 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n // Testing of astencode_gen\n \n #[cfg(test)]\n-fn encode_item_ast(ebml_w: writer::Encoder, item: @ast::item) {\n+fn encode_item_ast(ebml_w: &writer::Encoder, item: @ast::item) {\n     do ebml_w.wr_tag(c::tag_tree as uint) {\n-        (*item).encode(&ebml_w)\n+        (*item).encode(ebml_w)\n     }\n }\n \n@@ -1297,7 +1298,7 @@ trait fake_ext_ctxt {\n     fn cfg(&self) -> ast::crate_cfg;\n     fn parse_sess(&self) -> @mut parse::ParseSess;\n     fn call_site(&self) -> span;\n-    fn ident_of(&self, +st: ~str) -> ast::ident;\n+    fn ident_of(&self, st: ~str) -> ast::ident;\n }\n \n #[cfg(test)]\n@@ -1314,7 +1315,7 @@ impl fake_ext_ctxt for fake_session {\n             expn_info: None\n         }\n     }\n-    fn ident_of(&self, +st: ~str) -> ast::ident {\n+    fn ident_of(&self, st: ~str) -> ast::ident {\n         self.interner.intern(@st)\n     }\n }\n@@ -1331,7 +1332,7 @@ fn roundtrip(in_item: Option<@ast::item>) {\n     let in_item = in_item.get();\n     let bytes = do io::with_bytes_writer |wr| {\n         let ebml_w = writer::Encoder(wr);\n-        encode_item_ast(ebml_w, in_item);\n+        encode_item_ast(&ebml_w, in_item);\n     };\n     let ebml_doc = reader::Doc(@bytes);\n     let out_item = decode_item_ast(ebml_doc);\n@@ -1375,7 +1376,7 @@ fn test_simplification() {\n             return alist {eq_fn: eq_int, data: ~[]};\n         }\n     ).get());\n-    let item_out = simplify_ast(item_in);\n+    let item_out = simplify_ast(&item_in);\n     let item_exp = ast::ii_item(quote_item!(\n         fn new_int_alist<B:Copy>() -> alist<int, B> {\n             return alist {eq_fn: eq_int, data: ~[]};"}, {"sha": "4766fe1fb94a985393d73c72c34985ac8389dec5", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -79,7 +79,7 @@ enum impurity_cause {\n }\n \n pub fn check_loans(bccx: @BorrowckCtxt,\n-                   +req_maps: ReqMaps,\n+                   req_maps: ReqMaps,\n                    crate: @ast::crate) {\n     let clcx = @mut CheckLoanCtxt {\n         bccx: bccx,\n@@ -94,7 +94,7 @@ pub fn check_loans(bccx: @BorrowckCtxt,\n                                            visit_block: check_loans_in_block,\n                                            visit_fn: check_loans_in_fn,\n                                            .. *visit::default_visitor()});\n-    visit::visit_crate(*crate, clcx, vt);\n+    visit::visit_crate(crate, clcx, vt);\n }\n \n #[deriving(Eq)]\n@@ -619,7 +619,7 @@ fn check_loans_in_fn(fk: &visit::fn_kind,\n                      body: &ast::blk,\n                      sp: span,\n                      id: ast::node_id,\n-                     &&self: @mut CheckLoanCtxt,\n+                     self: @mut CheckLoanCtxt,\n                      visitor: visit::vt<@mut CheckLoanCtxt>) {\n     let is_stack_closure = self.is_stack_closure(id);\n     let fty = ty::node_id_to_type(self.tcx(), id);\n@@ -726,13 +726,13 @@ fn check_loans_in_fn(fk: &visit::fn_kind,\n }\n \n fn check_loans_in_local(local: @ast::local,\n-                        &&self: @mut CheckLoanCtxt,\n+                        self: @mut CheckLoanCtxt,\n                         vt: visit::vt<@mut CheckLoanCtxt>) {\n     visit::visit_local(local, self, vt);\n }\n \n fn check_loans_in_expr(expr: @ast::expr,\n-                       &&self: @mut CheckLoanCtxt,\n+                       self: @mut CheckLoanCtxt,\n                        vt: visit::vt<@mut CheckLoanCtxt>) {\n     debug!(\"check_loans_in_expr(expr=%?/%s)\",\n            expr.id, pprust::expr_to_str(expr, self.tcx().sess.intr()));\n@@ -794,7 +794,7 @@ fn check_loans_in_expr(expr: @ast::expr,\n }\n \n fn check_loans_in_block(blk: &ast::blk,\n-                        &&self: @mut CheckLoanCtxt,\n+                        self: @mut CheckLoanCtxt,\n                         vt: visit::vt<@mut CheckLoanCtxt>) {\n     do save_and_restore_managed(self.declared_purity) {\n         self.check_for_conflicting_loans(blk.node.id);"}, {"sha": "4f2e41dca5c0473319d78559ebd4557f5a35987e", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -88,7 +88,7 @@ pub fn gather_loans(bccx: @BorrowckCtxt, crate: @ast::crate) -> ReqMaps {\n                                           visit_fn: req_loans_in_fn,\n                                           visit_stmt: add_stmt_to_map,\n                                           .. *visit::default_visitor()});\n-    visit::visit_crate(*crate, glcx, v);\n+    visit::visit_crate(crate, glcx, v);\n     let @GatherLoanCtxt{req_maps, _} = glcx;\n     return req_maps;\n }\n@@ -98,7 +98,7 @@ fn req_loans_in_fn(fk: &visit::fn_kind,\n                    body: &ast::blk,\n                    sp: span,\n                    id: ast::node_id,\n-                   &&self: @mut GatherLoanCtxt,\n+                   self: @mut GatherLoanCtxt,\n                    v: visit::vt<@mut GatherLoanCtxt>) {\n     // see explanation attached to the `root_ub` field:\n     let old_item_id = self.item_ub;\n@@ -119,7 +119,7 @@ fn req_loans_in_fn(fk: &visit::fn_kind,\n }\n \n fn req_loans_in_expr(ex: @ast::expr,\n-                     &&self: @mut GatherLoanCtxt,\n+                     self: @mut GatherLoanCtxt,\n                      vt: visit::vt<@mut GatherLoanCtxt>) {\n     let bccx = self.bccx;\n     let tcx = bccx.tcx;\n@@ -489,7 +489,7 @@ pub impl GatherLoanCtxt {\n                  cmt: cmt,\n                  loan_kind: LoanKind,\n                  scope_r: ty::Region,\n-                 +loans: ~[Loan]) {\n+                 loans: ~[Loan]) {\n         if loans.len() == 0 {\n             return;\n         }\n@@ -555,7 +555,7 @@ pub impl GatherLoanCtxt {\n \n     fn add_loans_to_scope_id(&mut self,\n                              scope_id: ast::node_id,\n-                             +loans: ~[Loan]) {\n+                             loans: ~[Loan]) {\n         debug!(\"adding %u loans to scope_id %?: %s\",\n                loans.len(), scope_id,\n                str::connect(loans.map(|l| self.bccx.loan_to_repr(l)), \", \"));\n@@ -665,7 +665,7 @@ pub impl GatherLoanCtxt {\n // Setting up info that preserve needs.\n // This is just the most convenient place to do it.\n fn add_stmt_to_map(stmt: @ast::stmt,\n-                   &&self: @mut GatherLoanCtxt,\n+                   self: @mut GatherLoanCtxt,\n                    vt: visit::vt<@mut GatherLoanCtxt>) {\n     match stmt.node {\n         ast::stmt_expr(_, id) | ast::stmt_semi(_, id) => {"}, {"sha": "15189a552fb0c4bed9e8c092bc734f4ff92d3f48", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -257,10 +257,10 @@ pub impl LoanContext {\n     }\n \n     fn issue_loan(&mut self,\n-                  +cmt: cmt,\n-                  +scope_ub: ty::Region,\n-                  +loan_kind: LoanKind,\n-                  +owns_lent_data: bool) -> bckres<()> {\n+                  cmt: cmt,\n+                  scope_ub: ty::Region,\n+                  loan_kind: LoanKind,\n+                  owns_lent_data: bool) -> bckres<()> {\n         // Subtle: the `scope_ub` is the maximal lifetime of `cmt`.\n         // Therefore, if `cmt` owns the data being lent, then the\n         // scope of the loan must be less than `scope_ub`, or else the"}, {"sha": "dec194aa8e3b950fa71dccca816c2336c13abd43", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -443,7 +443,7 @@ pub impl LoanKind {\n /// Creates and returns a new root_map\n \n impl to_bytes::IterBytes for root_map_key {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.id, &self.derefs, lsb0, f);\n     }\n }\n@@ -529,11 +529,11 @@ pub impl BorrowckCtxt {\n         self.note_and_explain_bckerr(err);\n     }\n \n-    fn span_err(&self, s: span, +m: ~str) {\n+    fn span_err(&self, s: span, m: ~str) {\n         self.tcx.sess.span_err(s, m);\n     }\n \n-    fn span_note(&self, s: span, +m: ~str) {\n+    fn span_note(&self, s: span, m: ~str) {\n         self.tcx.sess.span_note(s, m);\n     }\n "}, {"sha": "1953841e650814212fcca75402699ba3086446e4", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -26,7 +26,7 @@ pub fn check_crate(sess: Session,\n                    def_map: resolve::DefMap,\n                    method_map: typeck::method_map,\n                    tcx: ty::ctxt) {\n-    visit::visit_crate(*crate, false, visit::mk_vt(@visit::Visitor {\n+    visit::visit_crate(crate, false, visit::mk_vt(@visit::Visitor {\n         visit_item: |a,b,c| check_item(sess, ast_map, def_map, a, b, c),\n         visit_pat: check_pat,\n         visit_expr: |a,b,c|\n@@ -40,7 +40,7 @@ pub fn check_item(sess: Session,\n                   ast_map: ast_map::map,\n                   def_map: resolve::DefMap,\n                   it: @item,\n-                  &&_is_const: bool,\n+                  _is_const: bool,\n                   v: visit::vt<bool>) {\n     match it.node {\n       item_const(_, ex) => {\n@@ -58,7 +58,7 @@ pub fn check_item(sess: Session,\n     }\n }\n \n-pub fn check_pat(p: @pat, &&_is_const: bool, v: visit::vt<bool>) {\n+pub fn check_pat(p: @pat, _is_const: bool, v: visit::vt<bool>) {\n     fn is_str(e: @expr) -> bool {\n         match e.node {\n             expr_vstore(\n@@ -87,7 +87,7 @@ pub fn check_expr(sess: Session,\n                   method_map: typeck::method_map,\n                   tcx: ty::ctxt,\n                   e: @expr,\n-                  &&is_const: bool,\n+                  is_const: bool,\n                   v: visit::vt<bool>) {\n     if is_const {\n         match e.node {\n@@ -224,7 +224,7 @@ pub fn check_item_recursion(sess: Session,\n     });\n     (visitor.visit_item)(it, env, visitor);\n \n-    fn visit_item(it: @item, &&env: env, v: visit::vt<env>) {\n+    fn visit_item(it: @item, env: env, v: visit::vt<env>) {\n         if env.idstack.contains(&(it.id)) {\n             env.sess.span_fatal(env.root_it.span, ~\"recursive constant\");\n         }\n@@ -233,7 +233,7 @@ pub fn check_item_recursion(sess: Session,\n         env.idstack.pop();\n     }\n \n-    fn visit_expr(e: @expr, &&env: env, v: visit::vt<env>) {\n+    fn visit_expr(e: @expr, env: env, v: visit::vt<env>) {\n         match e.node {\n           expr_path(*) => {\n             match env.def_map.find(&e.id) {"}, {"sha": "9f26f7f83724f0276d03789a92767a2d6c21a9a3", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -20,7 +20,7 @@ pub struct Context {\n }\n \n pub fn check_crate(tcx: ty::ctxt, crate: @crate) {\n-    visit::visit_crate(*crate,\n+    visit::visit_crate(crate,\n                        Context { in_loop: false, can_ret: true },\n                        visit::mk_vt(@visit::Visitor {\n         visit_item: |i, _cx, v| {"}, {"sha": "1db8f8cc8de8127f971a51a63fe000047fb1391d", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -40,7 +40,7 @@ pub fn check_crate(tcx: ty::ctxt,\n     let cx = @MatchCheckCtxt {tcx: tcx,\n                               method_map: method_map,\n                               moves_map: moves_map};\n-    visit::visit_crate(*crate, (), visit::mk_vt(@visit::Visitor {\n+    visit::visit_crate(crate, (), visit::mk_vt(@visit::Visitor {\n         visit_expr: |a,b,c| check_expr(cx, a, b, c),\n         visit_local: |a,b,c| check_local(cx, a, b, c),\n         visit_fn: |kind, decl, body, sp, id, e, v|\n@@ -58,7 +58,7 @@ pub fn expr_is_non_moving_lvalue(cx: @MatchCheckCtxt, expr: @expr) -> bool {\n     !cx.moves_map.contains(&expr.id)\n }\n \n-pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n+pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, s: (), v: visit::vt<()>) {\n     visit::visit_expr(ex, s, v);\n     match ex.node {\n       expr_match(scrut, ref arms) => {\n@@ -259,7 +259,7 @@ pub fn is_useful(cx: @MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n                 not_useful\n               }\n               _ => {\n-                let arity = ctor_arity(cx, single, left_ty);\n+                let arity = ctor_arity(cx, &single, left_ty);\n                 is_useful_specialized(cx, m, v, single, arity, left_ty)\n               }\n             }\n@@ -268,14 +268,14 @@ pub fn is_useful(cx: @MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n             match is_useful(cx,\n                             &m.filter_mapped(|r| default(cx, *r)),\n                             v.tail()) {\n-              useful_ => useful(left_ty, (/*bad*/copy *ctor)),\n+              useful_ => useful(left_ty, /*bad*/copy *ctor),\n               ref u => (/*bad*/copy *u)\n             }\n           }\n         }\n       }\n       Some(ref v0_ctor) => {\n-        let arity = ctor_arity(cx, (*v0_ctor), left_ty);\n+        let arity = ctor_arity(cx, v0_ctor, left_ty);\n         is_useful_specialized(cx, m, v, /*bad*/copy *v0_ctor, arity, left_ty)\n       }\n     }\n@@ -284,13 +284,13 @@ pub fn is_useful(cx: @MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n pub fn is_useful_specialized(cx: @MatchCheckCtxt,\n                              m: &matrix,\n                              v: &[@pat],\n-                             +ctor: ctor,\n+                             ctor: ctor,\n                              arity: uint,\n                              lty: ty::t)\n                           -> useful {\n-    let ms = m.filter_mapped(|r| specialize(cx, *r, ctor, arity, lty));\n+    let ms = m.filter_mapped(|r| specialize(cx, *r, &ctor, arity, lty));\n     let could_be_useful = is_useful(\n-        cx, &ms, specialize(cx, v, ctor, arity, lty).get());\n+        cx, &ms, specialize(cx, v, &ctor, arity, lty).get());\n     match could_be_useful {\n       useful_ => useful(lty, ctor),\n       ref u => (/*bad*/copy *u)\n@@ -447,12 +447,12 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n     }\n }\n \n-pub fn ctor_arity(cx: @MatchCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n+pub fn ctor_arity(cx: @MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n     match ty::get(ty).sty {\n       ty::ty_tup(ref fs) => fs.len(),\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) => 1u,\n       ty::ty_enum(eid, _) => {\n-          let id = match ctor { variant(id) => id,\n+          let id = match *ctor { variant(id) => id,\n           _ => fail!(~\"impossible case\") };\n         match vec::find(*ty::enum_variants(cx.tcx, eid), |v| v.id == id ) {\n             Some(v) => v.args.len(),\n@@ -461,7 +461,7 @@ pub fn ctor_arity(cx: @MatchCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n       }\n       ty::ty_struct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n       ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n-        match ctor {\n+        match *ctor {\n           vec(n) => n,\n           _ => 0u\n         }\n@@ -476,7 +476,7 @@ pub fn wild() -> @pat {\n \n pub fn specialize(cx: @MatchCheckCtxt,\n                   r: &[@pat],\n-                  ctor_id: ctor,\n+                  ctor_id: &ctor,\n                   arity: uint,\n                   left_ty: ty::t)\n                -> Option<~[@pat]> {\n@@ -491,7 +491,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n             pat_ident(_, _, _) => {\n                 match cx.tcx.def_map.find(&pat_id) {\n                     Some(&def_variant(_, id)) => {\n-                        if variant(id) == ctor_id {\n+                        if variant(id) == *ctor_id {\n                             Some(vec::from_slice(r.tail()))\n                         } else {\n                             None\n@@ -501,11 +501,11 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                         let const_expr =\n                             lookup_const_by_id(cx.tcx, did).get();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n-                        let match_ = match ctor_id {\n-                            val(ref v) => compare_const_vals(e_v, (*v)) == 0,\n+                        let match_ = match *ctor_id {\n+                            val(ref v) => compare_const_vals(&e_v, v) == 0,\n                             range(ref c_lo, ref c_hi) => {\n-                                compare_const_vals((*c_lo), e_v) >= 0 &&\n-                                    compare_const_vals((*c_hi), e_v) <= 0\n+                                compare_const_vals(c_lo, &e_v) >= 0 &&\n+                                    compare_const_vals(c_hi, &e_v) <= 0\n                             }\n                             single => true,\n                             _ => fail!(~\"type error\")\n@@ -532,11 +532,11 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                         let const_expr =\n                             lookup_const_by_id(cx.tcx, did).get();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n-                        let match_ = match ctor_id {\n-                            val(ref v) => compare_const_vals(e_v, (*v)) == 0,\n+                        let match_ = match *ctor_id {\n+                            val(ref v) => compare_const_vals(&e_v, v) == 0,\n                             range(ref c_lo, ref c_hi) => {\n-                                compare_const_vals((*c_lo), e_v) >= 0 &&\n-                                    compare_const_vals((*c_hi), e_v) <= 0\n+                                compare_const_vals(c_lo, &e_v) >= 0 &&\n+                                    compare_const_vals(c_hi, &e_v) <= 0\n                             }\n                             single => true,\n                             _ => fail!(~\"type error\")\n@@ -547,7 +547,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                             None\n                         }\n                     }\n-                    def_variant(_, id) if variant(id) == ctor_id => {\n+                    def_variant(_, id) if variant(id) == *ctor_id => {\n                         let args = match args {\n                             Some(args) => args,\n                             None => vec::from_elem(arity, wild())\n@@ -571,7 +571,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                 // Is this a struct or an enum variant?\n                 match *cx.tcx.def_map.get(&pat_id) {\n                     def_variant(_, variant_id) => {\n-                        if variant(variant_id) == ctor_id {\n+                        if variant(variant_id) == *ctor_id {\n                             // FIXME #4731: Is this right? --pcw\n                             let args = flds.map(|ty_field| {\n                                 match flds.find(|f|\n@@ -620,19 +620,19 @@ pub fn specialize(cx: @MatchCheckCtxt,\n             }\n             pat_lit(expr) => {\n                 let e_v = eval_const_expr(cx.tcx, expr);\n-                let match_ = match ctor_id {\n-                    val(ref v) => compare_const_vals(e_v, (*v)) == 0,\n+                let match_ = match *ctor_id {\n+                    val(ref v) => compare_const_vals(&e_v, v) == 0,\n                     range(ref c_lo, ref c_hi) => {\n-                        compare_const_vals((*c_lo), e_v) >= 0 &&\n-                            compare_const_vals((*c_hi), e_v) <= 0\n+                        compare_const_vals(c_lo, &e_v) >= 0 &&\n+                            compare_const_vals(c_hi, &e_v) <= 0\n                     }\n                     single => true,\n                     _ => fail!(~\"type error\")\n                 };\n                 if match_ { Some(vec::from_slice(r.tail())) } else { None }\n             }\n             pat_range(lo, hi) => {\n-                let (c_lo, c_hi) = match ctor_id {\n+                let (c_lo, c_hi) = match *ctor_id {\n                     val(ref v) => ((/*bad*/copy *v), (/*bad*/copy *v)),\n                     range(ref lo, ref hi) =>\n                         ((/*bad*/copy *lo), (/*bad*/copy *hi)),\n@@ -641,12 +641,12 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                 };\n                 let v_lo = eval_const_expr(cx.tcx, lo),\n                 v_hi = eval_const_expr(cx.tcx, hi);\n-                let match_ = compare_const_vals(c_lo, v_lo) >= 0 &&\n-                    compare_const_vals(c_hi, v_hi) <= 0;\n+                let match_ = compare_const_vals(&c_lo, &v_lo) >= 0 &&\n+                    compare_const_vals(&c_hi, &v_hi) <= 0;\n           if match_ { Some(vec::from_slice(r.tail())) } else { None }\n       }\n             pat_vec(before, slice, after) => {\n-                match ctor_id {\n+                match *ctor_id {\n                     vec(_) => {\n                         let num_elements = before.len() + after.len();\n                         if num_elements < arity && slice.is_some() {\n@@ -682,7 +682,7 @@ pub fn default(cx: @MatchCheckCtxt, r: &[@pat]) -> Option<~[@pat]> {\n \n pub fn check_local(cx: @MatchCheckCtxt,\n                    loc: @local,\n-                   &&s: (),\n+                   s: (),\n                    v: visit::vt<()>) {\n     visit::visit_local(loc, s, v);\n     if is_refutable(cx, loc.node.pat) {\n@@ -704,7 +704,7 @@ pub fn check_fn(cx: @MatchCheckCtxt,\n                 body: &blk,\n                 sp: span,\n                 id: node_id,\n-                &&s: (),\n+                s: (),\n                 v: visit::vt<()>) {\n     visit::visit_fn(kind, decl, body, sp, id, s, v);\n     for decl.inputs.each |input| {"}, {"sha": "5148ea7fba4030a9e060420323fcc7b83ff6a1e7", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -229,7 +229,7 @@ pub fn process_crate(crate: @ast::crate,\n         visit_expr_post: |e| { classify(e, tcx); },\n         .. *visit::default_simple_visitor()\n     });\n-    visit::visit_crate(*crate, (), v);\n+    visit::visit_crate(crate, (), v);\n     tcx.sess.abort_if_errors();\n }\n \n@@ -426,8 +426,8 @@ pub fn lit_to_const(lit: @lit) -> const_val {\n     }\n }\n \n-pub fn compare_const_vals(a: const_val, b: const_val) -> int {\n-  match (&a, &b) {\n+pub fn compare_const_vals(a: &const_val, b: &const_val) -> int {\n+  match (a, b) {\n     (&const_int(a), &const_int(b)) => {\n         if a == b {\n             0\n@@ -478,15 +478,15 @@ pub fn compare_const_vals(a: const_val, b: const_val) -> int {\n }\n \n pub fn compare_lit_exprs(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> int {\n-  compare_const_vals(eval_const_expr(tcx, a), eval_const_expr(tcx, b))\n+  compare_const_vals(&eval_const_expr(tcx, a), &eval_const_expr(tcx, b))\n }\n \n pub fn lit_expr_eq(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> bool {\n     compare_lit_exprs(tcx, a, b) == 0\n }\n \n pub fn lit_eq(a: @lit, b: @lit) -> bool {\n-    compare_const_vals(lit_to_const(a), lit_to_const(b)) == 0\n+    compare_const_vals(&lit_to_const(a), &lit_to_const(b)) == 0\n }\n \n "}, {"sha": "b25c3be0d683df7aad519dc09947cb009d44d02d", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -42,9 +42,9 @@ fn collect_freevars(def_map: resolve::DefMap, blk: &ast::blk)\n     let seen = @mut HashMap::new();\n     let refs = @mut ~[];\n \n-    fn ignore_item(_i: @ast::item, &&_depth: int, _v: visit::vt<int>) { }\n+    fn ignore_item(_i: @ast::item, _depth: int, _v: visit::vt<int>) { }\n \n-    let walk_expr: @fn(expr: @ast::expr, &&depth: int, v: visit::vt<int>) =\n+    let walk_expr: @fn(expr: @ast::expr, depth: int, v: visit::vt<int>) =\n         |expr, depth, v| {\n             match expr.node {\n               ast::expr_fn_block(*) => visit::visit_expr(expr, depth + 1, v),\n@@ -107,7 +107,7 @@ pub fn annotate_freevars(def_map: resolve::DefMap, crate: @ast::crate) ->\n         visit::mk_simple_visitor(@visit::SimpleVisitor {\n             visit_fn: walk_fn,\n             .. *visit::default_simple_visitor()});\n-    visit::visit_crate(*crate, (), visitor);\n+    visit::visit_crate(crate, (), visitor);\n \n     return freevars;\n }"}, {"sha": "390ffded2fe36f10183add36869ed86b98f5cfde", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -81,7 +81,7 @@ pub fn check_crate(tcx: ty::ctxt,\n         visit_block: check_block,\n         .. *visit::default_visitor()\n     });\n-    visit::visit_crate(*crate, ctx, visit);\n+    visit::visit_crate(crate, ctx, visit);\n     tcx.sess.abort_if_errors();\n }\n \n@@ -573,7 +573,7 @@ pub fn check_cast_for_escaping_regions(\n             true\n         });\n \n-    fn is_re_scope(+r: ty::Region) -> bool {\n+    fn is_re_scope(r: ty::Region) -> bool {\n         match r {\n             ty::re_scope(*) => true,\n             _ => false"}, {"sha": "435cb896ac7a18ddcdfe16006300d471159b6862", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -370,7 +370,7 @@ pub impl<'self> LanguageItemCollector<'self> {\n \n     fn collect_local_language_items(&self) {\n         let this = ptr::addr_of(&self);\n-        visit_crate(*self.crate, (), mk_simple_visitor(@SimpleVisitor {\n+        visit_crate(self.crate, (), mk_simple_visitor(@SimpleVisitor {\n             visit_item: |item| {\n                 for item.attrs.each |attribute| {\n                     unsafe {"}, {"sha": "39144d46c83c48d7c99d526271c6936fc94a189b", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -348,7 +348,7 @@ pub impl Context {\n         }\n     }\n \n-    fn span_lint(&self, level: level, span: span, +msg: ~str) {\n+    fn span_lint(&self, level: level, span: span, msg: ~str) {\n         self.sess.span_lint_level(level, span, msg);\n     }\n \n@@ -438,7 +438,7 @@ pub impl Context {\n }\n \n \n-fn build_settings_item(i: @ast::item, &&cx: Context, v: visit::vt<Context>) {\n+fn build_settings_item(i: @ast::item, cx: Context, v: visit::vt<Context>) {\n     do cx.with_lint_attrs(/*bad*/copy i.attrs) |cx| {\n         if !cx.is_default {\n             cx.sess.lint_settings.settings_map.insert(i.id, cx.curr);\n@@ -481,7 +481,7 @@ pub fn build_settings_crate(sess: session::Session, crate: @ast::crate) {\n             visit_item: build_settings_item,\n             .. *visit::default_visitor()\n         });\n-        visit::visit_crate(*crate, cx, visit);\n+        visit::visit_crate(crate, cx, visit);\n     }\n \n     sess.abort_if_errors();\n@@ -1088,7 +1088,7 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n             check_fn(tcx, fk, decl, body, span, id),\n         .. *visit::default_simple_visitor()\n     });\n-    visit::visit_crate(*crate, (), v);\n+    visit::visit_crate(crate, (), v);\n \n     tcx.sess.abort_if_errors();\n }"}, {"sha": "3136d7bf4e4ac345ae33bb8afd8780304d62c9a1", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -182,7 +182,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                                    capture_map,\n                                    last_use_map,\n                                    0);\n-    visit::visit_crate(*crate, initial_maps, visitor);\n+    visit::visit_crate(crate, initial_maps, visitor);\n     tcx.sess.abort_if_errors();\n     return last_use_map;\n }\n@@ -358,7 +358,7 @@ pub impl IrMaps {\n         }\n     }\n \n-    fn set_captures(&mut self, node_id: node_id, +cs: ~[CaptureInfo]) {\n+    fn set_captures(&mut self, node_id: node_id, cs: ~[CaptureInfo]) {\n         self.capture_info_map.insert(node_id, @cs);\n     }\n \n@@ -402,7 +402,7 @@ pub impl IrMaps {\n     }\n }\n \n-fn visit_item(item: @item, &&self: @mut IrMaps, v: vt<@mut IrMaps>) {\n+fn visit_item(item: @item, self: @mut IrMaps, v: vt<@mut IrMaps>) {\n     do with(&mut self.cur_item, item.id) {\n         visit::visit_item(item, self, v)\n     }\n@@ -413,7 +413,7 @@ fn visit_fn(fk: &visit::fn_kind,\n             body: &blk,\n             sp: span,\n             id: node_id,\n-            &&self: @mut IrMaps,\n+            self: @mut IrMaps,\n             v: vt<@mut IrMaps>) {\n     debug!(\"visit_fn: id=%d\", id);\n     let _i = ::util::common::indenter();\n@@ -489,7 +489,7 @@ fn visit_fn(fk: &visit::fn_kind,\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n \n-fn visit_local(local: @local, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n+fn visit_local(local: @local, self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     let def_map = self.tcx.def_map;\n     do pat_util::pat_bindings(def_map, local.node.pat) |_bm, p_id, sp, path| {\n         debug!(\"adding local variable %d\", p_id);\n@@ -509,7 +509,7 @@ fn visit_local(local: @local, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     visit::visit_local(local, self, vt);\n }\n \n-fn visit_arm(arm: &arm, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n+fn visit_arm(arm: &arm, self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     let def_map = self.tcx.def_map;\n     for arm.pats.each |pat| {\n         do pat_util::pat_bindings(def_map, *pat) |bm, p_id, sp, path| {\n@@ -528,7 +528,7 @@ fn visit_arm(arm: &arm, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     visit::visit_arm(arm, self, vt);\n }\n \n-fn visit_expr(expr: @expr, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n+fn visit_expr(expr: @expr, self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       expr_path(_) => {\n@@ -1510,7 +1510,7 @@ pub impl Liveness {\n // _______________________________________________________________________\n // Checking for error conditions\n \n-fn check_local(local: @local, &&self: @Liveness, vt: vt<@Liveness>) {\n+fn check_local(local: @local, self: @Liveness, vt: vt<@Liveness>) {\n     match local.node.init {\n       Some(_) => {\n \n@@ -1544,14 +1544,14 @@ fn check_local(local: @local, &&self: @Liveness, vt: vt<@Liveness>) {\n     visit::visit_local(local, self, vt);\n }\n \n-fn check_arm(arm: &arm, &&self: @Liveness, vt: vt<@Liveness>) {\n+fn check_arm(arm: &arm, self: @Liveness, vt: vt<@Liveness>) {\n     do self.arm_pats_bindings(arm.pats) |ln, var, sp, id| {\n         self.warn_about_unused(sp, id, ln, var);\n     }\n     visit::visit_arm(arm, self, vt);\n }\n \n-fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n+fn check_expr(expr: @expr, self: @Liveness, vt: vt<@Liveness>) {\n     match expr.node {\n       expr_path(_) => {\n         for self.variable_from_def_map(expr.id, expr.span).each |var| {\n@@ -1632,7 +1632,7 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n \n fn check_fn(_fk: &visit::fn_kind, _decl: &fn_decl,\n             _body: &blk, _sp: span, _id: node_id,\n-            &&_self: @Liveness, _v: vt<@Liveness>) {\n+            _self: @Liveness, _v: vt<@Liveness>) {\n     // do not check contents of nested fns\n }\n "}, {"sha": "66ce4d16d4bc273ab251109e187e29adce9f7054", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -285,15 +285,15 @@ pub fn compute_moves(tcx: ty::ctxt,\n             capture_map: @mut HashMap::new()\n         }\n     };\n-    visit::visit_crate(*crate, visit_cx, visitor);\n+    visit::visit_crate(crate, visit_cx, visitor);\n     return visit_cx.move_maps;\n }\n \n // ______________________________________________________________________\n // Expressions\n \n fn compute_modes_for_expr(expr: @expr,\n-                          &&cx: VisitContext,\n+                          cx: VisitContext,\n                           v: vt<VisitContext>)\n {\n     cx.consume_expr(expr, v);\n@@ -760,7 +760,7 @@ pub impl VisitContext {\n \n     fn arms_have_by_move_bindings(&self,\n                                   moves_map: MovesMap,\n-                                  +arms: &[arm]) -> bool\n+                                  arms: &[arm]) -> bool\n     {\n         for arms.each |arm| {\n             for arm.pats.each |pat| {"}, {"sha": "89dad7fc01c10f787abcebb15517b59e90fe59c6", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -604,6 +604,6 @@ pub fn check_crate(tcx: ty::ctxt,\n         },\n         .. *visit::default_visitor()\n     });\n-    visit::visit_crate(*crate, method_map, visitor);\n+    visit::visit_crate(crate, method_map, visitor);\n }\n "}, {"sha": "043aa8d2533fa7a8b22b50eda86025b9bbb3923a", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -496,7 +496,7 @@ pub fn resolve_crate(sess: Session,\n         visit_local: resolve_local,\n         .. *visit::default_visitor()\n     });\n-    visit::visit_crate(*crate, cx, visitor);\n+    visit::visit_crate(crate, cx, visitor);\n     return region_maps;\n }\n \n@@ -549,8 +549,8 @@ pub struct DetermineRpCtxt {\n     ambient_variance: region_variance,\n }\n \n-pub fn join_variance(++variance1: region_variance,\n-                     ++variance2: region_variance)\n+pub fn join_variance(variance1: region_variance,\n+                     variance2: region_variance)\n                   -> region_variance {\n     match (variance1, variance2) {\n       (rv_invariant, _) => {rv_invariant}\n@@ -570,8 +570,8 @@ pub fn join_variance(++variance1: region_variance,\n /// appears in a co-variant position.  This implies that this\n /// occurrence of `r` is contra-variant with respect to the current\n /// item, and hence the function returns `rv_contravariant`.\n-pub fn add_variance(+ambient_variance: region_variance,\n-                    +variance: region_variance)\n+pub fn add_variance(ambient_variance: region_variance,\n+                    variance: region_variance)\n                  -> region_variance {\n     match (ambient_variance, variance) {\n       (rv_invariant, _) => rv_invariant,\n@@ -719,7 +719,7 @@ pub impl DetermineRpCtxt {\n }\n \n pub fn determine_rp_in_item(item: @ast::item,\n-                            &&cx: @mut DetermineRpCtxt,\n+                            cx: @mut DetermineRpCtxt,\n                             visitor: visit::vt<@mut DetermineRpCtxt>) {\n     do cx.with(item.id, true) {\n         visit::visit_item(item, cx, visitor);\n@@ -731,7 +731,7 @@ pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n                           body: &ast::blk,\n                           _: span,\n                           _: ast::node_id,\n-                          &&cx: @mut DetermineRpCtxt,\n+                          cx: @mut DetermineRpCtxt,\n                           visitor: visit::vt<@mut DetermineRpCtxt>) {\n     do cx.with(cx.item_id, false) {\n         do cx.with_ambient_variance(rv_contravariant) {\n@@ -747,15 +747,15 @@ pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n }\n \n pub fn determine_rp_in_ty_method(ty_m: &ast::ty_method,\n-                                 &&cx: @mut DetermineRpCtxt,\n+                                 cx: @mut DetermineRpCtxt,\n                                  visitor: visit::vt<@mut DetermineRpCtxt>) {\n     do cx.with(cx.item_id, false) {\n         visit::visit_ty_method(ty_m, cx, visitor);\n     }\n }\n \n pub fn determine_rp_in_ty(ty: @ast::Ty,\n-                          &&cx: @mut DetermineRpCtxt,\n+                          cx: @mut DetermineRpCtxt,\n                           visitor: visit::vt<@mut DetermineRpCtxt>) {\n     // we are only interested in types that will require an item to\n     // be region-parameterized.  if cx.item_id is zero, then this type\n@@ -871,7 +871,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n     }\n \n     fn visit_mt(mt: ast::mt,\n-                &&cx: @mut DetermineRpCtxt,\n+                cx: @mut DetermineRpCtxt,\n                 visitor: visit::vt<@mut DetermineRpCtxt>) {\n         // mutability is invariant\n         if mt.mutbl == ast::m_mutbl {\n@@ -886,7 +886,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n \n pub fn determine_rp_in_struct_field(\n         cm: @ast::struct_field,\n-        &&cx: @mut DetermineRpCtxt,\n+        cx: @mut DetermineRpCtxt,\n         visitor: visit::vt<@mut DetermineRpCtxt>) {\n     match cm.node.kind {\n       ast::named_field(_, ast::struct_mutable, _) => {\n@@ -903,7 +903,7 @@ pub fn determine_rp_in_struct_field(\n \n pub fn determine_rp_in_crate(sess: Session,\n                              ast_map: ast_map::map,\n-                             +def_map: resolve::DefMap,\n+                             def_map: resolve::DefMap,\n                              crate: @ast::crate)\n                           -> region_paramd_items {\n     let cx = @mut DetermineRpCtxt {\n@@ -927,7 +927,7 @@ pub fn determine_rp_in_crate(sess: Session,\n         visit_struct_field: determine_rp_in_struct_field,\n         .. *visit::default_visitor()\n     });\n-    visit::visit_crate(*crate, cx, visitor);\n+    visit::visit_crate(crate, cx, visitor);\n \n     // Propagate indirect dependencies\n     //"}, {"sha": "3c158c0d081f8621376c6034e086c7e0902de749", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -351,7 +351,7 @@ pub struct ImportDirective {\n }\n \n pub fn ImportDirective(privacy: Privacy,\n-                       +module_path: ~[ident],\n+                       module_path: ~[ident],\n                        subclass: @ImportDirectiveSubclass,\n                        span: span)\n                     -> ImportDirective {\n@@ -401,7 +401,7 @@ pub struct ImportResolution {\n }\n \n pub fn ImportResolution(privacy: Privacy,\n-                        +span: span,\n+                        span: span,\n                         state: @mut ImportState) -> ImportResolution {\n     ImportResolution {\n         privacy: privacy,\n@@ -904,7 +904,7 @@ pub impl Resolver {\n     fn build_reduced_graph(@mut self) {\n         let initial_parent =\n             ModuleReducedGraphParent(self.graph_root.get_module());\n-        visit_crate(*self.crate, initial_parent, mk_vt(@Visitor {\n+        visit_crate(self.crate, initial_parent, mk_vt(@Visitor {\n             visit_item: |item, context, visitor|\n                 self.build_reduced_graph_for_item(item, context, visitor),\n \n@@ -1088,7 +1088,7 @@ pub impl Resolver {\n     fn build_reduced_graph_for_item(@mut self,\n                                     item: @item,\n                                     parent: ReducedGraphParent,\n-                                    &&visitor: vt<ReducedGraphParent>) {\n+                                    visitor: vt<ReducedGraphParent>) {\n         let ident = item.ident;\n         let sp = item.span;\n         let privacy = visibility_to_privacy(item.vis);\n@@ -1173,7 +1173,7 @@ pub impl Resolver {\n                     (privacy, def_ty(local_def(item.id)), sp);\n \n                 for (*enum_definition).variants.each |variant| {\n-                    self.build_reduced_graph_for_variant(*variant,\n+                    self.build_reduced_graph_for_variant(variant,\n                         local_def(item.id),\n                         // inherited => privacy of the enum item\n                         variant_visibility_to_privacy(variant.node.vis,\n@@ -1362,11 +1362,11 @@ pub impl Resolver {\n     // Constructs the reduced graph for one variant. Variants exist in the\n     // type and/or value namespaces.\n     fn build_reduced_graph_for_variant(@mut self,\n-                                       variant: variant,\n+                                       variant: &variant,\n                                        item_id: def_id,\n-                                       +parent_privacy: Privacy,\n+                                       parent_privacy: Privacy,\n                                        parent: ReducedGraphParent,\n-                                       &&_visitor: vt<ReducedGraphParent>) {\n+                                       _visitor: vt<ReducedGraphParent>) {\n         let ident = variant.node.name;\n         let (child, _) = self.add_child(ident, parent, ForbidDuplicateValues,\n                                         variant.span);\n@@ -1402,7 +1402,7 @@ pub impl Resolver {\n     fn build_reduced_graph_for_view_item(@mut self,\n                                          view_item: @view_item,\n                                          parent: ReducedGraphParent,\n-                                         &&_visitor: vt<ReducedGraphParent>) {\n+                                         _visitor: vt<ReducedGraphParent>) {\n         let privacy = visibility_to_privacy(view_item.vis);\n         match view_item.node {\n             view_item_use(ref view_paths) => {\n@@ -1495,7 +1495,7 @@ pub impl Resolver {\n     fn build_reduced_graph_for_foreign_item(@mut self,\n                                             foreign_item: @foreign_item,\n                                             parent: ReducedGraphParent,\n-                                            &&visitor:\n+                                            visitor:\n                                                 vt<ReducedGraphParent>) {\n         let name = foreign_item.ident;\n         let (name_bindings, new_parent) =\n@@ -1526,7 +1526,7 @@ pub impl Resolver {\n     fn build_reduced_graph_for_block(@mut self,\n                                      block: &blk,\n                                      parent: ReducedGraphParent,\n-                                     &&visitor: vt<ReducedGraphParent>) {\n+                                     visitor: vt<ReducedGraphParent>) {\n         let mut new_parent;\n         if self.block_needs_anonymous_module(block) {\n             let block_id = block.node.id;\n@@ -1849,7 +1849,7 @@ pub impl Resolver {\n     fn build_import_directive(@mut self,\n                               privacy: Privacy,\n                               module_: @mut Module,\n-                              +module_path: ~[ident],\n+                              module_path: ~[ident],\n                               subclass: @ImportDirectiveSubclass,\n                               span: span) {\n         let directive = @ImportDirective(privacy, module_path,\n@@ -2912,7 +2912,7 @@ pub impl Resolver {\n                               module_: @mut Module,\n                               name: ident,\n                               namespace: Namespace,\n-                              +name_search_type: NameSearchType)\n+                              name_search_type: NameSearchType)\n                            -> ResolveResult<Target> {\n         debug!(\"(resolving name in module) resolving `%s` in `%s`\",\n                *self.session.str_of(name),\n@@ -3352,7 +3352,7 @@ pub impl Resolver {\n     fn resolve_crate(@mut self) {\n         debug!(\"(resolving crate) starting\");\n \n-        visit_crate(*self.crate, (), mk_vt(@Visitor {\n+        visit_crate(self.crate, (), mk_vt(@Visitor {\n             visit_item: |item, _context, visitor|\n                 self.resolve_item(item, visitor),\n             visit_arm: |arm, _context, visitor|\n@@ -3509,7 +3509,7 @@ pub impl Resolver {\n                 self.resolve_struct(item.id,\n                                     generics,\n                                     struct_def.fields,\n-                                    struct_def.dtor,\n+                                    &struct_def.dtor,\n                                     visitor);\n             }\n \n@@ -3768,7 +3768,7 @@ pub impl Resolver {\n                       id: node_id,\n                       generics: &Generics,\n                       fields: &[@struct_field],\n-                      optional_destructor: Option<struct_dtor>,\n+                      optional_destructor: &Option<struct_dtor>,\n                       visitor: ResolveVisitor) {\n         // If applicable, create a rib for the type parameters.\n         do self.with_type_parameter_rib(HasTypeParameters\n@@ -3784,7 +3784,7 @@ pub impl Resolver {\n             }\n \n             // Resolve the destructor, if applicable.\n-            match optional_destructor {\n+            match *optional_destructor {\n                 None => {\n                     // Nothing to do.\n                 }\n@@ -4525,7 +4525,7 @@ pub impl Resolver {\n \n     fn resolve_module_relative_path(@mut self,\n                                     path: @Path,\n-                                    +xray: XrayFlag,\n+                                    xray: XrayFlag,\n                                     namespace: Namespace)\n                                  -> Option<def> {\n         let module_path_idents = self.intern_module_part_of_path(path);\n@@ -4571,7 +4571,7 @@ pub impl Resolver {\n     /// import resolution.\n     fn resolve_crate_relative_path(@mut self,\n                                    path: @Path,\n-                                   +xray: XrayFlag,\n+                                   xray: XrayFlag,\n                                    namespace: Namespace)\n                                 -> Option<def> {\n         let module_path_idents = self.intern_module_part_of_path(path);\n@@ -5076,7 +5076,7 @@ pub impl Resolver {\n \n     fn add_fixed_trait_for_expr(@mut self,\n                                 expr_id: node_id,\n-                                +trait_id: def_id) {\n+                                trait_id: def_id) {\n         self.trait_map.insert(expr_id, @mut ~[trait_id]);\n     }\n "}, {"sha": "7339003c6143ac1f4a06b82973e71fa346c21e0c", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -785,7 +785,7 @@ pub fn enter_region<'r>(bcx: block,\n // on a set of enum variants or a literal.\n pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n     let ccx = bcx.ccx();\n-    fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], +val: Opt) {\n+    fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], val: Opt) {\n         if set.any(|l| opt_eq(tcx, l, &val)) {return;}\n         set.push(val);\n     }"}, {"sha": "e1c60234f0ff04e634442be1078abdfc4eb4bfe2", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 36, "deletions": 39, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -136,7 +136,7 @@ fn fcx_has_nonzero_span(fcx: fn_ctxt) -> bool {\n     }\n }\n \n-pub fn log_fn_time(ccx: @CrateContext, +name: ~str, start: time::Timespec,\n+pub fn log_fn_time(ccx: @CrateContext, name: ~str, start: time::Timespec,\n                    end: time::Timespec) {\n     let elapsed = 1000 * ((end.sec - start.sec) as int) +\n         ((end.nsec as int) - (start.nsec as int)) / 1000000;\n@@ -165,7 +165,7 @@ pub fn decl_cdecl_fn(llmod: ModuleRef, name: &str, llty: TypeRef)\n \n // Only use this if you are going to actually define the function. It's\n // not valid to simply declare a function as internal.\n-pub fn decl_internal_cdecl_fn(llmod: ModuleRef, +name: ~str, llty: TypeRef) ->\n+pub fn decl_internal_cdecl_fn(llmod: ModuleRef, name: ~str, llty: TypeRef) ->\n    ValueRef {\n     let llfn = decl_cdecl_fn(llmod, name, llty);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n@@ -828,7 +828,7 @@ pub fn trans_external_path(ccx: @CrateContext, did: ast::def_id, t: ty::t)\n     };\n }\n \n-pub fn invoke(bcx: block, llfn: ValueRef, +llargs: ~[ValueRef])\n+pub fn invoke(bcx: block, llfn: ValueRef, llargs: ~[ValueRef])\n            -> (ValueRef, block) {\n     let _icx = bcx.insn_ctxt(\"invoke_\");\n     if bcx.unreachable {\n@@ -924,7 +924,7 @@ pub fn have_cached_lpad(bcx: block) -> bool {\n     return res;\n }\n \n-pub fn in_lpad_scope_cx(bcx: block, f: &fn(+si: &mut scope_info)) {\n+pub fn in_lpad_scope_cx(bcx: block, f: &fn(si: &mut scope_info)) {\n     let mut bcx = bcx;\n     loop {\n         {\n@@ -1057,10 +1057,7 @@ pub fn do_spill(bcx: block, v: ValueRef, t: ty::t) -> ValueRef {\n \n // Since this function does *not* root, it is the caller's responsibility to\n // ensure that the referent is pointed to by a root.\n-// [Note-arg-mode]\n-// ++ mode is temporary, due to how borrowck treats enums. With hope,\n-// will go away anyway when we get rid of modes.\n-pub fn do_spill_noroot(++cx: block, v: ValueRef) -> ValueRef {\n+pub fn do_spill_noroot(cx: block, v: ValueRef) -> ValueRef {\n     let llptr = alloca(cx, val_ty(v));\n     Store(cx, v, llptr);\n     return llptr;\n@@ -1163,7 +1160,7 @@ pub fn init_local(bcx: block, local: @ast::local) -> block {\n                                        _match::BindLocal);\n }\n \n-pub fn trans_stmt(cx: block, s: ast::stmt) -> block {\n+pub fn trans_stmt(cx: block, s: &ast::stmt) -> block {\n     let _icx = cx.insn_ctxt(\"trans_stmt\");\n     debug!(\"trans_stmt(%s)\", stmt_to_str(s, cx.tcx().sess.intr()));\n \n@@ -1189,7 +1186,7 @@ pub fn trans_stmt(cx: block, s: ast::stmt) -> block {\n                         }\n                     }\n                 }\n-                ast::decl_item(i) => trans_item(*cx.fcx.ccx, *i)\n+                ast::decl_item(i) => trans_item(*cx.fcx.ccx, i)\n             }\n         }\n         ast::stmt_mac(*) => cx.tcx().sess.bug(~\"unexpanded macro\")\n@@ -1200,8 +1197,8 @@ pub fn trans_stmt(cx: block, s: ast::stmt) -> block {\n \n // You probably don't want to use this one. See the\n // next three functions instead.\n-pub fn new_block(cx: fn_ctxt, parent: Option<block>, +kind: block_kind,\n-                 is_lpad: bool, +name: ~str, opt_node_info: Option<NodeInfo>)\n+pub fn new_block(cx: fn_ctxt, parent: Option<block>, kind: block_kind,\n+                 is_lpad: bool, name: ~str, opt_node_info: Option<NodeInfo>)\n     -> block {\n \n     let s = if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n@@ -1245,15 +1242,15 @@ pub fn top_scope_block(fcx: fn_ctxt, opt_node_info: Option<NodeInfo>)\n \n pub fn scope_block(bcx: block,\n                    opt_node_info: Option<NodeInfo>,\n-                   +n: ~str) -> block {\n+                   n: ~str) -> block {\n     return new_block(bcx.fcx, Some(bcx), simple_block_scope(), bcx.is_lpad,\n                   n, opt_node_info);\n }\n \n pub fn loop_scope_block(bcx: block,\n                         loop_break: block,\n                         loop_label: Option<ident>,\n-                        +n: ~str,\n+                        n: ~str,\n                         opt_node_info: Option<NodeInfo>) -> block {\n     return new_block(bcx.fcx, Some(bcx), block_scope(scope_info {\n         loop_break: Some(loop_break),\n@@ -1265,12 +1262,12 @@ pub fn loop_scope_block(bcx: block,\n }\n \n // Use this when creating a block for the inside of a landing pad.\n-pub fn lpad_block(bcx: block, +n: ~str) -> block {\n+pub fn lpad_block(bcx: block, n: ~str) -> block {\n     new_block(bcx.fcx, Some(bcx), block_non_scope, true, n, None)\n }\n \n // Use this when you're making a general CFG BB within a scope.\n-pub fn sub_block(bcx: block, +n: ~str) -> block {\n+pub fn sub_block(bcx: block, n: ~str) -> block {\n     new_block(bcx.fcx, Some(bcx), block_non_scope, bcx.is_lpad, n, None)\n }\n \n@@ -1286,12 +1283,12 @@ pub fn raw_block(fcx: fn_ctxt, is_lpad: bool, llbb: BasicBlockRef) -> block {\n // need to make sure those variables go out of scope when the block ends.  We\n // do that by running a 'cleanup' function for each variable.\n // trans_block_cleanups runs all the cleanup functions for the block.\n-pub fn trans_block_cleanups(bcx: block, +cleanups: ~[cleanup]) -> block {\n+pub fn trans_block_cleanups(bcx: block, cleanups: ~[cleanup]) -> block {\n     trans_block_cleanups_(bcx, cleanups, false)\n }\n \n pub fn trans_block_cleanups_(bcx: block,\n-                             +cleanups: ~[cleanup],\n+                             cleanups: ~[cleanup],\n                              /* cleanup_cx: block, */\n                              is_lpad: bool) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_block_cleanups\");\n@@ -1387,7 +1384,7 @@ pub fn leave_block(bcx: block, out_of: block) -> block {\n \n pub fn with_scope(bcx: block,\n                   opt_node_info: Option<NodeInfo>,\n-                  +name: ~str,\n+                  name: ~str,\n                   f: &fn(block) -> block) -> block {\n     let _icx = bcx.insn_ctxt(\"with_scope\");\n \n@@ -1402,7 +1399,7 @@ pub fn with_scope(bcx: block,\n \n pub fn with_scope_result(bcx: block,\n                          opt_node_info: Option<NodeInfo>,\n-                         +name: ~str,\n+                         name: ~str,\n                          f: &fn(block) -> Result) -> Result {\n     let _icx = bcx.insn_ctxt(\"with_scope_result\");\n     let scope_cx = scope_block(bcx, opt_node_info, name);\n@@ -1412,7 +1409,7 @@ pub fn with_scope_result(bcx: block,\n }\n \n pub fn with_scope_datumblock(bcx: block, opt_node_info: Option<NodeInfo>,\n-                             +name: ~str, f: &fn(block) -> datum::DatumBlock)\n+                             name: ~str, f: &fn(block) -> datum::DatumBlock)\n                           -> datum::DatumBlock {\n     use middle::trans::datum::DatumBlock;\n \n@@ -1620,7 +1617,7 @@ pub fn make_return_pointer(fcx: fn_ctxt, output_type: ty::t) -> ValueRef {\n //  - new_fn_ctxt\n //  - trans_args\n pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n-                        +path: path,\n+                        path: path,\n                         llfndecl: ValueRef,\n                         id: ast::node_id,\n                         output_type: ty::t,\n@@ -1674,7 +1671,7 @@ pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n }\n \n pub fn new_fn_ctxt(ccx: @CrateContext,\n-                   +path: path,\n+                   path: path,\n                    llfndecl: ValueRef,\n                    output_type: ty::t,\n                    sp: Option<span>)\n@@ -1839,7 +1836,7 @@ pub enum self_arg { impl_self(ty::t), impl_owned_self(ty::t), no_self, }\n // If the function closes over its environment a closure will be\n // returned.\n pub fn trans_closure(ccx: @CrateContext,\n-                     +path: path,\n+                     path: path,\n                      decl: &ast::fn_decl,\n                      body: &ast::blk,\n                      llfndecl: ValueRef,\n@@ -1920,7 +1917,7 @@ pub fn trans_closure(ccx: @CrateContext,\n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n pub fn trans_fn(ccx: @CrateContext,\n-                +path: path,\n+                path: path,\n                 decl: &ast::fn_decl,\n                 body: &ast::blk,\n                 llfndecl: ValueRef,\n@@ -1965,7 +1962,7 @@ pub fn trans_fn(ccx: @CrateContext,\n \n pub fn trans_enum_variant(ccx: @CrateContext,\n                           enum_id: ast::node_id,\n-                          variant: ast::variant,\n+                          variant: &ast::variant,\n                           args: &[ast::variant_arg],\n                           disr: int,\n                           param_substs: Option<@param_substs>,\n@@ -2108,7 +2105,7 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n }\n \n pub fn trans_struct_dtor(ccx: @CrateContext,\n-                         +path: path,\n+                         path: path,\n                          body: &ast::blk,\n                          dtor_id: ast::node_id,\n                          psubsts: Option<@param_substs>,\n@@ -2154,7 +2151,7 @@ pub fn trans_struct_dtor(ccx: @CrateContext,\n   lldecl\n }\n \n-pub fn trans_enum_def(ccx: @CrateContext, enum_definition: ast::enum_def,\n+pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::enum_def,\n                       id: ast::node_id,\n                       path: @ast_map::path, vi: @~[ty::VariantInfo],\n                       i: &mut uint) {\n@@ -2165,7 +2162,7 @@ pub fn trans_enum_def(ccx: @CrateContext, enum_definition: ast::enum_def,\n         match variant.node.kind {\n             ast::tuple_variant_kind(ref args) if args.len() > 0 => {\n                 let llfn = get_item_val(ccx, variant.node.id);\n-                trans_enum_variant(ccx, id, *variant, *args,\n+                trans_enum_variant(ccx, id, variant, *args,\n                                    disr_val, None, llfn);\n             }\n             ast::tuple_variant_kind(_) => {\n@@ -2179,7 +2176,7 @@ pub fn trans_enum_def(ccx: @CrateContext, enum_definition: ast::enum_def,\n     }\n }\n \n-pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n+pub fn trans_item(ccx: @CrateContext, item: &ast::item) {\n     let _icx = ccx.insn_ctxt(\"trans_item\");\n     let path = match *ccx.tcx.items.get(&item.id) {\n         ast_map::node_item(_, p) => p,\n@@ -2214,7 +2211,7 @@ pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n                 match stmt.node {\n                   ast::stmt_decl(@codemap::spanned { node: ast::decl_item(i),\n                                                  _ }, _) => {\n-                    trans_item(ccx, *i);\n+                    trans_item(ccx, i);\n                   }\n                   _ => ()\n                 }\n@@ -2232,7 +2229,7 @@ pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n         if !generics.is_type_parameterized() {\n             let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n             let mut i = 0;\n-            trans_enum_def(ccx, (*enum_definition), item.id,\n+            trans_enum_def(ccx, enum_definition, item.id,\n                            path, vi, &mut i);\n         }\n       }\n@@ -2279,13 +2276,13 @@ pub fn trans_struct_def(ccx: @CrateContext, struct_def: @ast::struct_def,\n pub fn trans_mod(ccx: @CrateContext, m: &ast::_mod) {\n     let _icx = ccx.insn_ctxt(\"trans_mod\");\n     for m.items.each |item| {\n-        trans_item(ccx, **item);\n+        trans_item(ccx, *item);\n     }\n }\n \n pub fn register_fn(ccx: @CrateContext,\n                    sp: span,\n-                   +path: path,\n+                   path: path,\n                    node_id: ast::node_id,\n                    attrs: &[ast::attribute])\n                 -> ValueRef {\n@@ -2295,7 +2292,7 @@ pub fn register_fn(ccx: @CrateContext,\n \n pub fn register_fn_full(ccx: @CrateContext,\n                         sp: span,\n-                        +path: path,\n+                        path: path,\n                         node_id: ast::node_id,\n                         attrs: &[ast::attribute],\n                         node_type: ty::t)\n@@ -2307,7 +2304,7 @@ pub fn register_fn_full(ccx: @CrateContext,\n \n pub fn register_fn_fuller(ccx: @CrateContext,\n                           sp: span,\n-                          +path: path,\n+                          path: path,\n                           node_id: ast::node_id,\n                           attrs: &[ast::attribute],\n                           node_type: ty::t,\n@@ -2495,7 +2492,7 @@ pub fn item_path(ccx: @CrateContext, i: @ast::item) -> path {\n /* If there's already a symbol for the dtor with <id> and substs <substs>,\n    return it; otherwise, create one and register it, returning it as well */\n pub fn get_dtor_symbol(ccx: @CrateContext,\n-                       +path: path,\n+                       path: path,\n                        id: ast::node_id,\n                        substs: Option<@param_substs>)\n                     -> ~str {\n@@ -2749,7 +2746,7 @@ pub fn trans_constant(ccx: @CrateContext, it: @ast::item) {\n \n pub fn trans_constants(ccx: @CrateContext, crate: &ast::crate) {\n     visit::visit_crate(\n-        *crate, (),\n+        crate, (),\n         visit::mk_simple_visitor(@visit::SimpleVisitor {\n             visit_item: |a| trans_constant(ccx, a),\n             ..*visit::default_simple_visitor()\n@@ -3146,7 +3143,7 @@ pub fn trans_crate(sess: session::Session,\n                    tcx: ty::ctxt,\n                    output: &Path,\n                    emap2: resolve::ExportMap2,\n-                   +maps: astencode::Maps) -> (ModuleRef, LinkMeta) {\n+                   maps: astencode::Maps) -> (ModuleRef, LinkMeta) {\n \n     let symbol_hasher = @hash::default_state();\n     let link_meta ="}, {"sha": "ecde50f34707276ea016a94d3086d2d6500fcf7d", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -41,7 +41,7 @@ enum x86_64_reg_class {\n     memory_class\n }\n \n-fn is_sse(++c: x86_64_reg_class) -> bool {\n+fn is_sse(c: x86_64_reg_class) -> bool {\n     return match c {\n         sse_fs_class | sse_fv_class |\n         sse_ds_class | sse_dv_class => true,"}, {"sha": "3301ed62cbe1f57112f9fe9c1db7fd7822a2cb5c", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -444,7 +444,7 @@ pub fn body_contains_ret(body: &ast::blk) -> bool {\n }\n \n // See [Note-arg-mode]\n-pub fn trans_call_inner(++in_cx: block,\n+pub fn trans_call_inner(in_cx: block,\n                         call_info: Option<NodeInfo>,\n                         fn_expr_ty: ty::t,\n                         ret_ty: ty::t,\n@@ -592,7 +592,7 @@ pub enum CallArgs<'self> {\n     ArgVals(&'self [ValueRef])\n }\n \n-pub fn trans_ret_slot(+bcx: block, +fn_ty: ty::t, +dest: expr::Dest)\n+pub fn trans_ret_slot(bcx: block, fn_ty: ty::t, dest: expr::Dest)\n                       -> ValueRef {\n     let retty = ty::ty_fn_ret(fn_ty);\n \n@@ -610,12 +610,12 @@ pub fn trans_ret_slot(+bcx: block, +fn_ty: ty::t, +dest: expr::Dest)\n     }\n }\n \n-pub fn trans_args(+cx: block,\n-                  +args: CallArgs,\n-                  +fn_ty: ty::t,\n-                  +ret_flag: Option<ValueRef>,\n-                  +autoref_arg: AutorefArg,\n-                  +llargs: &mut ~[ValueRef]) -> block\n+pub fn trans_args(cx: block,\n+                  args: CallArgs,\n+                  fn_ty: ty::t,\n+                  ret_flag: Option<ValueRef>,\n+                  autoref_arg: AutorefArg,\n+                  llargs: &mut ~[ValueRef]) -> block\n {\n     let _icx = cx.insn_ctxt(\"trans_args\");\n     let mut temp_cleanups = ~[];\n@@ -663,9 +663,9 @@ pub enum AutorefArg {\n pub fn trans_arg_expr(bcx: block,\n                       formal_ty: ty::arg,\n                       arg_expr: @ast::expr,\n-                      +temp_cleanups: &mut ~[ValueRef],\n-                      +ret_flag: Option<ValueRef>,\n-                      +autoref_arg: AutorefArg) -> Result {\n+                      temp_cleanups: &mut ~[ValueRef],\n+                      ret_flag: Option<ValueRef>,\n+                      autoref_arg: AutorefArg) -> Result {\n     let _icx = bcx.insn_ctxt(\"trans_arg_expr\");\n     let ccx = bcx.ccx();\n "}, {"sha": "a2ce83c45c2e70affa31cb7a22e1b4c57c36aa95", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -59,9 +59,9 @@ use syntax::parse::token::ident_interner;\n use syntax::{ast, ast_map};\n use syntax::abi::{X86, X86_64, Arm, Mips};\n \n-pub type namegen = @fn(+s: ~str) -> ident;\n+pub type namegen = @fn(s: ~str) -> ident;\n pub fn new_namegen(intr: @ident_interner) -> namegen {\n-    let f: @fn(+s: ~str) -> ident = |prefix| {\n+    let f: @fn(s: ~str) -> ident = |prefix| {\n         intr.gensym(@fmt!(\"%s_%u\",\n                           prefix,\n                           intr.gensym(@prefix).repr))\n@@ -395,7 +395,7 @@ pub struct cleanup_path {\n     dest: BasicBlockRef\n }\n \n-pub fn scope_clean_changed(+scope_info: &mut scope_info) {\n+pub fn scope_clean_changed(scope_info: &mut scope_info) {\n     if scope_info.cleanup_paths.len() > 0u { scope_info.cleanup_paths = ~[]; }\n     scope_info.landing_pad = None;\n }\n@@ -626,7 +626,7 @@ pub struct block_ {\n     fcx: fn_ctxt\n }\n \n-pub fn block_(llbb: BasicBlockRef, parent: Option<block>, +kind: block_kind,\n+pub fn block_(llbb: BasicBlockRef, parent: Option<block>, kind: block_kind,\n               is_lpad: bool, node_info: Option<NodeInfo>, fcx: fn_ctxt)\n     -> block_ {\n \n@@ -644,7 +644,7 @@ pub fn block_(llbb: BasicBlockRef, parent: Option<block>, +kind: block_kind,\n \n pub type block = @mut block_;\n \n-pub fn mk_block(llbb: BasicBlockRef, parent: Option<block>, +kind: block_kind,\n+pub fn mk_block(llbb: BasicBlockRef, parent: Option<block>, kind: block_kind,\n             is_lpad: bool, node_info: Option<NodeInfo>, fcx: fn_ctxt)\n     -> block {\n     @mut block_(llbb, parent, kind, is_lpad, node_info, fcx)\n@@ -663,7 +663,7 @@ pub fn rslt(bcx: block, val: ValueRef) -> Result {\n }\n \n pub impl Result {\n-    fn unpack(&self, +bcx: &mut block) -> ValueRef {\n+    fn unpack(&self, bcx: &mut block) -> ValueRef {\n         *bcx = self.bcx;\n         return self.val;\n     }\n@@ -683,7 +683,7 @@ pub fn val_str(tn: @TypeNames, v: ValueRef) -> @str {\n     return ty_str(tn, val_ty(v));\n }\n \n-pub fn in_scope_cx(cx: block, f: &fn(+si: &mut scope_info)) {\n+pub fn in_scope_cx(cx: block, f: &fn(si: &mut scope_info)) {\n     let mut cur = cx;\n     loop {\n         {\n@@ -1252,7 +1252,7 @@ pub fn C_bytes_plus_null(bytes: &[u8]) -> ValueRef {\n     }\n }\n \n-pub fn C_shape(ccx: @CrateContext, +bytes: ~[u8]) -> ValueRef {\n+pub fn C_shape(ccx: @CrateContext, bytes: ~[u8]) -> ValueRef {\n     unsafe {\n         let llshape = C_bytes_plus_null(bytes);\n         let name = fmt!(\"shape%u\", (ccx.names)(~\"shape\").repr);\n@@ -1325,7 +1325,7 @@ pub struct mono_id_ {\n pub type mono_id = @mono_id_;\n \n impl to_bytes::IterBytes for mono_param_id {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n             mono_precise(t, ref mids) =>\n                 to_bytes::iter_bytes_3(&0u8, &ty::type_id(t), mids, lsb0, f),\n@@ -1339,7 +1339,7 @@ impl to_bytes::IterBytes for mono_param_id {\n }\n \n impl to_bytes::IterBytes for mono_id_ {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.def, &self.params, lsb0, f);\n     }\n }\n@@ -1433,7 +1433,7 @@ pub fn resolve_vtables_in_fn_ctxt(fcx: fn_ctxt, vts: typeck::vtable_res)\n \n // Apply the typaram substitutions in the fn_ctxt to a vtable. This should\n // eliminate any vtable_params.\n-pub fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, +vt: typeck::vtable_origin)\n+pub fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n     -> typeck::vtable_origin {\n     let tcx = fcx.ccx.tcx;\n     match vt {\n@@ -1479,7 +1479,7 @@ pub fn find_vtable(tcx: ty::ctxt, ps: &param_substs,\n     /*bad*/ copy ps.vtables.get()[vtable_off]\n }\n \n-pub fn dummy_substs(+tps: ~[ty::t]) -> ty::substs {\n+pub fn dummy_substs(tps: ~[ty::t]) -> ty::substs {\n     substs {\n         self_r: Some(ty::re_bound(ty::br_self)),\n         self_ty: None,"}, {"sha": "4f51e32f7732a07e69b73d387312fdd59aad26b6", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -39,7 +39,7 @@ pub fn trans_block(bcx: block, b: &ast::blk, dest: expr::Dest) -> block {\n     };\n     for vec::each(b.node.stmts) |s| {\n         debuginfo::update_source_pos(bcx, b.span);\n-        bcx = trans_stmt(bcx, **s);\n+        bcx = trans_stmt(bcx, *s);\n     }\n     match b.node.expr {\n         Some(e) => {"}, {"sha": "ac0cf7064538c8f5ad0ad941043c3845ac4fb254", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -159,7 +159,7 @@ pub impl DatumMode {\n }\n \n impl to_bytes::IterBytes for DatumMode {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n@@ -811,7 +811,7 @@ pub impl Datum {\n }\n \n pub impl DatumBlock {\n-    fn unpack(&self, +bcx: &mut block) -> Datum {\n+    fn unpack(&self, bcx: &mut block) -> Datum {\n         *bcx = self.bcx;\n         return self.datum;\n     }"}, {"sha": "fdd978fea3d7dd9d0b4f989a0073e02f5f170d0e", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -104,7 +104,7 @@ pub struct DebugContext {\n     crate_file: ~str\n }\n \n-pub fn mk_ctxt(+crate: ~str, intr: @ident_interner) -> DebugContext {\n+pub fn mk_ctxt(crate: ~str, intr: @ident_interner) -> DebugContext {\n     DebugContext {\n         llmetadata: @mut HashMap::new(),\n         names: new_namegen(intr),\n@@ -249,7 +249,7 @@ fn get_file_path_and_dir(work_dir: &str, full_path: &str) -> (~str, ~str) {\n     }, work_dir.to_owned())\n }\n \n-fn create_file(cx: @CrateContext, +full_path: ~str)\n+fn create_file(cx: @CrateContext, full_path: ~str)\n     -> @Metadata<FileMetadata> {\n     let cache = get_cache(cx);;\n     let tg = FileDescriptorTag;\n@@ -589,7 +589,7 @@ fn create_boxed_type(cx: @CrateContext, contents: ty::t,\n fn create_composite_type(type_tag: int, name: &str, file: ValueRef,\n                          line: int, size: int, align: int, offset: int,\n                          derived: Option<ValueRef>,\n-                         +members: Option<~[ValueRef]>)\n+                         members: Option<~[ValueRef]>)\n     -> ValueRef {\n     let lldata = ~[lltag(type_tag),\n                   file,"}, {"sha": "ba6965f0eaea3d245c2526d367258b7d74cab968", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -1572,7 +1572,7 @@ fn trans_binary(bcx: block,\n fn trans_overloaded_op(bcx: block,\n                        expr: @ast::expr,\n                        rcvr: @ast::expr,\n-                       +args: ~[@ast::expr],\n+                       args: ~[@ast::expr],\n                        ret_ty: ty::t,\n                        dest: Dest)\n                        -> block {\n@@ -1746,6 +1746,6 @@ fn trans_assign_op(bcx: block,\n     return result_datum.copy_to_datum(bcx, DROP_EXISTING, dst_datum);\n }\n \n-fn shorten(+x: ~str) -> ~str {\n+fn shorten(x: ~str) -> ~str {\n     if x.len() > 60 { x.substr(0, 60).to_owned() } else { x }\n }"}, {"sha": "854ec585d5cc2f3267a225e097737ee73ebdbe47", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -39,7 +39,7 @@ use syntax::{ast, ast_util};\n use syntax::{attr, ast_map};\n use syntax::opt_vec;\n use syntax::parse::token::special_idents;\n-use syntax::abi::{Architecture, X86, X86_64, Arm, Mips};\n+use syntax::abi::{X86, X86_64, Arm, Mips};\n use syntax::abi::{RustIntrinsic, Rust, Stdcall, Fastcall,\n                   Cdecl, Aapcs, C};\n \n@@ -139,7 +139,7 @@ type shim_ret_builder<'self> =\n               llretval: ValueRef);\n \n fn build_shim_fn_(ccx: @CrateContext,\n-                  +shim_name: ~str,\n+                  shim_name: ~str,\n                   llbasefn: ValueRef,\n                   tys: &ShimTypes,\n                   cc: lib::llvm::CallConv,\n@@ -544,7 +544,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n pub fn trans_intrinsic(ccx: @CrateContext,\n                        decl: ValueRef,\n                        item: @ast::foreign_item,\n-                       +path: ast_map::path,\n+                       path: ast_map::path,\n                        substs: @param_substs,\n                        ref_id: Option<ast::node_id>) {\n     debug!(\"trans_intrinsic(item.ident=%s)\", *ccx.sess.str_of(item.ident));\n@@ -1089,15 +1089,15 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n  *     }\n  */\n pub fn trans_foreign_fn(ccx: @CrateContext,\n-                        +path: ast_map::path,\n+                        path: ast_map::path,\n                         decl: &ast::fn_decl,\n                         body: &ast::blk,\n                         llwrapfn: ValueRef,\n                         id: ast::node_id) {\n     let _icx = ccx.insn_ctxt(\"foreign::build_foreign_fn\");\n \n     fn build_rust_fn(ccx: @CrateContext,\n-                     +path: ast_map::path,\n+                     path: ast_map::path,\n                      decl: &ast::fn_decl,\n                      body: &ast::blk,\n                      id: ast::node_id)\n@@ -1125,7 +1125,7 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n     }\n \n     fn build_shim_fn(ccx: @CrateContext,\n-                     +path: ast_map::path,\n+                     path: ast_map::path,\n                      llrustfn: ValueRef,\n                      tys: &ShimTypes)\n                      -> ValueRef {\n@@ -1266,7 +1266,7 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n \n pub fn register_foreign_fn(ccx: @CrateContext,\n                            sp: span,\n-                           +path: ast_map::path,\n+                           path: ast_map::path,\n                            node_id: ast::node_id,\n                            attrs: &[ast::attribute])\n                            -> ValueRef {"}, {"sha": "9031871de560d708d87d315cc0cca302077efee4", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -321,7 +321,7 @@ pub fn lazily_emit_tydesc_glue(ccx: @CrateContext,\n }\n \n // See [Note-arg-mode]\n-pub fn call_tydesc_glue_full(++bcx: block,\n+pub fn call_tydesc_glue_full(bcx: block,\n                              v: ValueRef,\n                              tydesc: ValueRef,\n                              field: uint,\n@@ -388,7 +388,7 @@ pub fn call_tydesc_glue_full(++bcx: block,\n }\n \n // See [Note-arg-mode]\n-pub fn call_tydesc_glue(++cx: block, v: ValueRef, t: ty::t, field: uint)\n+pub fn call_tydesc_glue(cx: block, v: ValueRef, t: ty::t, field: uint)\n     -> block {\n     let _icx = cx.insn_ctxt(\"call_tydesc_glue\");\n     let ti = get_tydesc(cx.ccx(), t);\n@@ -713,7 +713,7 @@ pub fn declare_tydesc(ccx: @CrateContext, t: ty::t) -> @mut tydesc_info {\n pub type glue_helper = @fn(block, ValueRef, ty::t);\n \n pub fn declare_generic_glue(ccx: @CrateContext, t: ty::t, llfnty: TypeRef,\n-                            +name: ~str) -> ValueRef {\n+                            name: ~str) -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"declare_generic_glue\");\n     let name = name;\n     //XXX this triggers duplicate LLVM symbols"}, {"sha": "6e8a782fd421fa42ce060965f8a7ebdfe2a5dc22", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -54,7 +54,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n           csearch::found(ast::ii_item(item)) => {\n             ccx.external.insert(fn_id, Some(item.id));\n             ccx.stats.n_inlines += 1;\n-            if translate { trans_item(ccx, *item); }\n+            if translate { trans_item(ccx, item); }\n             local_def(item.id)\n           }\n           csearch::found(ast::ii_foreign(item)) => {\n@@ -76,7 +76,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n               _ => ccx.sess.bug(~\"maybe_instantiate_inline: item has a \\\n                     non-enum parent\")\n             }\n-            if translate { trans_item(ccx, *item); }\n+            if translate { trans_item(ccx, item); }\n             local_def(my_id)\n           }\n           csearch::found_parent(_, _) => {"}, {"sha": "acb6353aa8b39632f0f947c24b26d25465183dc9", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -42,7 +42,7 @@ for non-monomorphized methods only.  Other methods will\n be generated once they are invoked with specific type parameters,\n see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n */\n-pub fn trans_impl(ccx: @CrateContext, +path: path, name: ast::ident,\n+pub fn trans_impl(ccx: @CrateContext, path: path, name: ast::ident,\n                   methods: &[@ast::method], generics: &ast::Generics,\n                   self_ty: Option<ty::t>, id: ast::node_id) {\n     let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n@@ -89,7 +89,7 @@ Translates a (possibly monomorphized) method body.\n - `impl_id`: the node ID of the impl this method is inside\n */\n pub fn trans_method(ccx: @CrateContext,\n-                    +path: path,\n+                    path: path,\n                     method: &ast::method,\n                     param_substs: Option<@param_substs>,\n                     base_self_ty: Option<ty::t>,\n@@ -443,7 +443,7 @@ pub fn trans_monomorphized_callee(bcx: block,\n                                   mentry: typeck::method_map_entry,\n                                   trait_id: ast::def_id,\n                                   n_method: uint,\n-                                  +vtbl: typeck::vtable_origin)\n+                                  vtbl: typeck::vtable_origin)\n                                -> Callee {\n     let _icx = bcx.insn_ctxt(\"impl::trans_monomorphized_callee\");\n     return match vtbl {\n@@ -724,7 +724,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n }\n \n pub fn vtable_id(ccx: @CrateContext,\n-                 +origin: typeck::vtable_origin)\n+                 origin: typeck::vtable_origin)\n               -> mono_id {\n     match origin {\n         typeck::vtable_static(impl_id, substs, sub_vtables) => {\n@@ -747,7 +747,7 @@ pub fn vtable_id(ccx: @CrateContext,\n }\n \n pub fn get_vtable(ccx: @CrateContext,\n-                  +origin: typeck::vtable_origin)\n+                  origin: typeck::vtable_origin)\n                -> ValueRef {\n     // XXX: Bad copy.\n     let hash_id = vtable_id(ccx, copy origin);"}, {"sha": "9d63ac854a90cb24432b6ae355ee07836933d1b9", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -221,9 +221,9 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         let this_tv = vec::find(*tvs, |tv| { tv.id.node == fn_id.node}).get();\n         let d = mk_lldecl();\n         set_inline_hint(d);\n-        match (*v).node.kind {\n+        match v.node.kind {\n             ast::tuple_variant_kind(ref args) => {\n-                trans_enum_variant(ccx, enum_item.id, *v, /*bad*/copy *args,\n+                trans_enum_variant(ccx, enum_item.id, v, /*bad*/copy *args,\n                                    this_tv.disr_val, psubsts, d);\n             }\n             ast::struct_variant_kind(_) =>"}, {"sha": "d7ca346dd20ee140017fff6cefd752579211c663", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -49,13 +49,13 @@ pub fn find_reachable(crate_mod: &_mod, exp_map2: resolve::ExportMap2,\n             method_map: method_map,\n             rmap: &mut rmap\n         };\n-        traverse_public_mod(cx, ast::crate_node_id, crate_mod);\n-        traverse_all_resources_and_impls(cx, crate_mod);\n+        traverse_public_mod(&cx, ast::crate_node_id, crate_mod);\n+        traverse_all_resources_and_impls(&cx, crate_mod);\n     }\n     return @rmap;\n }\n \n-fn traverse_exports(cx: ctx, mod_id: node_id) -> bool {\n+fn traverse_exports(cx: &ctx, mod_id: node_id) -> bool {\n     let mut found_export = false;\n     match cx.exp_map2.find(&mod_id) {\n       Some(ref exp2s) => {\n@@ -69,7 +69,7 @@ fn traverse_exports(cx: ctx, mod_id: node_id) -> bool {\n     return found_export;\n }\n \n-fn traverse_def_id(cx: ctx, did: def_id) {\n+fn traverse_def_id(cx: &ctx, did: def_id) {\n     if did.crate != local_crate { return; }\n     match cx.tcx.items.find(&did.node) {\n         None => (), // This can happen for self, for example\n@@ -85,7 +85,7 @@ fn traverse_def_id(cx: ctx, did: def_id) {\n     }\n }\n \n-fn traverse_public_mod(cx: ctx, mod_id: node_id, m: &_mod) {\n+fn traverse_public_mod(cx: &ctx, mod_id: node_id, m: &_mod) {\n     if !traverse_exports(cx, mod_id) {\n         // No exports, so every local item is exported\n         for m.items.each |item| {\n@@ -94,7 +94,7 @@ fn traverse_public_mod(cx: ctx, mod_id: node_id, m: &_mod) {\n     }\n }\n \n-fn traverse_public_item(cx: ctx, item: @item) {\n+fn traverse_public_item(cx: &ctx, item: @item) {\n     // XXX: it shouldn't be necessary to do this\n     let rmap: &mut HashSet<node_id> = cx.rmap;\n     if rmap.contains(&item.id) { return; }\n@@ -139,20 +139,17 @@ fn traverse_public_item(cx: ctx, item: @item) {\n         }\n       }\n       item_ty(t, _) => {\n-        traverse_ty(t, cx, mk_ty_visitor());\n+        traverse_ty(t, cx,\n+                    visit::mk_vt(@visit::Visitor {visit_ty: traverse_ty,\n+                                                  ..*visit::default_visitor()}))\n       }\n       item_const(*) |\n       item_enum(*) | item_trait(*) => (),\n       item_mac(*) => fail!(~\"item macros unimplemented\")\n     }\n }\n \n-fn mk_ty_visitor() -> visit::vt<ctx> {\n-    visit::mk_vt(@visit::Visitor {visit_ty: traverse_ty,\n-                                  ..*visit::default_visitor()})\n-}\n-\n-fn traverse_ty<'a>(ty: @Ty, cx: ctx<'a>, v: visit::vt<ctx<'a>>) {\n+fn traverse_ty<'a, 'b>(ty: @Ty, cx: &'b ctx<'a>, v: visit::vt<&'b ctx<'a>>) {\n     // XXX: it shouldn't be necessary to do this\n     let rmap: &mut HashSet<node_id> = cx.rmap;\n     if rmap.contains(&ty.id) { return; }\n@@ -175,8 +172,9 @@ fn traverse_ty<'a>(ty: @Ty, cx: ctx<'a>, v: visit::vt<ctx<'a>>) {\n     }\n }\n \n-fn traverse_inline_body(cx: ctx, body: &blk) {\n-    fn traverse_expr<'a>(e: @expr, cx: ctx<'a>, v: visit::vt<ctx<'a>>) {\n+fn traverse_inline_body(cx: &ctx, body: &blk) {\n+    fn traverse_expr<'a, 'b>(e: @expr, cx: &'b ctx<'a>,\n+                             v: visit::vt<&'b ctx<'a>>) {\n         match e.node {\n           expr_path(_) => {\n             match cx.tcx.def_map.find(&e.id) {\n@@ -221,7 +219,7 @@ fn traverse_inline_body(cx: ctx, body: &blk) {\n     // Don't ignore nested items: for example if a generic fn contains a\n     // generic impl (as in deque::create), we need to monomorphize the\n     // impl as well\n-    fn traverse_item(i: @item, cx: ctx, _v: visit::vt<ctx>) {\n+    fn traverse_item(i: @item, cx: &ctx, _v: visit::vt<&ctx>) {\n       traverse_public_item(cx, i);\n     }\n     visit::visit_block(body, cx, visit::mk_vt(@visit::Visitor {\n@@ -231,7 +229,7 @@ fn traverse_inline_body(cx: ctx, body: &blk) {\n     }));\n }\n \n-fn traverse_all_resources_and_impls(cx: ctx, crate_mod: &_mod) {\n+fn traverse_all_resources_and_impls(cx: &ctx, crate_mod: &_mod) {\n     visit::visit_mod(\n         crate_mod,\n         codemap::dummy_sp(),"}, {"sha": "ffb2cc01ab2491f6fbab5c934ae47a60d976ce46", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -121,7 +121,7 @@ pub impl Reflector {\n \n     fn bracketed(&mut self,\n                  bracket_name: ~str,\n-                 +extra: ~[ValueRef],\n+                 extra: ~[ValueRef],\n                  inner: &fn(&mut Reflector)) {\n         // XXX: Bad copy.\n         self.visit(~\"enter_\" + bracket_name, copy extra);\n@@ -145,7 +145,7 @@ pub impl Reflector {\n         }\n     }\n \n-    fn leaf(&mut self, +name: ~str) {\n+    fn leaf(&mut self, name: ~str) {\n         self.visit(name, ~[]);\n     }\n "}, {"sha": "32ea381c020a31d43dccca6bf6af6ecd19366d9c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -126,7 +126,7 @@ pub struct creader_cache_key {\n type creader_cache = @mut HashMap<creader_cache_key, t>;\n \n impl to_bytes::IterBytes for creader_cache_key {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_3(&self.cnum, &self.pos, &self.len, lsb0, f);\n     }\n }\n@@ -150,7 +150,7 @@ impl cmp::Eq for intern_key {\n }\n \n impl to_bytes::IterBytes for intern_key {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         unsafe {\n             (*self.sty).iter_bytes(lsb0, f);\n         }\n@@ -390,13 +390,13 @@ pub struct FnSig {\n }\n \n impl to_bytes::IterBytes for BareFnTy {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_3(&self.purity, &self.abis, &self.sig, lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for ClosureTy {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_5(&self.purity, &self.sigil, &self.onceness,\n                                &self.region, &self.sig, lsb0, f)\n     }\n@@ -685,7 +685,7 @@ pub enum InferTy {\n }\n \n impl to_bytes::IterBytes for InferTy {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           TyVar(ref tv) => to_bytes::iter_bytes_2(&0u8, tv, lsb0, f),\n           IntVar(ref iv) => to_bytes::iter_bytes_2(&1u8, iv, lsb0, f),\n@@ -702,7 +702,7 @@ pub enum InferRegion {\n }\n \n impl to_bytes::IterBytes for InferRegion {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n             ReVar(ref rv) => to_bytes::iter_bytes_2(&0u8, rv, lsb0, f),\n             ReSkolemized(ref v, _) => to_bytes::iter_bytes_2(&1u8, v, lsb0, f)\n@@ -790,25 +790,25 @@ impl ToStr for IntVarValue {\n }\n \n impl to_bytes::IterBytes for TyVid {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for IntVid {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for FloatVid {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for RegionVid {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n@@ -877,7 +877,7 @@ pub fn mk_ctxt(s: session::Session,\n                freevars: freevars::freevar_map,\n                region_maps: @mut middle::region::RegionMaps,\n                region_paramd_items: middle::region::region_paramd_items,\n-               +lang_items: middle::lang_items::LanguageItems,\n+               lang_items: middle::lang_items::LanguageItems,\n                crate: @ast::crate)\n             -> ctxt {\n     let mut legacy_modes = false;\n@@ -942,7 +942,7 @@ pub fn mk_ctxt(s: session::Session,\n \n // Interns a type/name combination, stores the resulting box in cx.interner,\n // and returns the box as cast to an unsafe ptr (see comments for t above).\n-fn mk_t(cx: ctxt, +st: sty) -> t {\n+fn mk_t(cx: ctxt, st: sty) -> t {\n     // Check for primitive types.\n     match st {\n         ty_nil => return mk_nil(cx),\n@@ -1141,7 +1141,7 @@ pub fn mk_estr(cx: ctxt, t: vstore) -> t {\n     mk_t(cx, ty_estr(t))\n }\n \n-pub fn mk_enum(cx: ctxt, did: ast::def_id, +substs: substs) -> t {\n+pub fn mk_enum(cx: ctxt, did: ast::def_id, substs: substs) -> t {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_enum(did, substs))\n }\n@@ -1192,13 +1192,13 @@ pub fn mk_mut_unboxed_vec(cx: ctxt, ty: t) -> t {\n     mk_t(cx, ty_unboxed_vec(mt {ty: ty, mutbl: ast::m_imm}))\n }\n \n-pub fn mk_tup(cx: ctxt, +ts: ~[t]) -> t { mk_t(cx, ty_tup(ts)) }\n+pub fn mk_tup(cx: ctxt, ts: ~[t]) -> t { mk_t(cx, ty_tup(ts)) }\n \n-pub fn mk_closure(cx: ctxt, +fty: ClosureTy) -> t {\n+pub fn mk_closure(cx: ctxt, fty: ClosureTy) -> t {\n     mk_t(cx, ty_closure(fty))\n }\n \n-pub fn mk_bare_fn(cx: ctxt, +fty: BareFnTy) -> t {\n+pub fn mk_bare_fn(cx: ctxt, fty: BareFnTy) -> t {\n     mk_t(cx, ty_bare_fn(fty))\n }\n \n@@ -1217,15 +1217,15 @@ pub fn mk_ctor_fn(cx: ctxt, input_tys: &[ty::t], output: ty::t) -> t {\n \n pub fn mk_trait(cx: ctxt,\n                 did: ast::def_id,\n-                +substs: substs,\n+                substs: substs,\n                 store: TraitStore,\n                 mutability: ast::mutability)\n              -> t {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_trait(did, substs, store, mutability))\n }\n \n-pub fn mk_struct(cx: ctxt, struct_id: ast::def_id, +substs: substs) -> t {\n+pub fn mk_struct(cx: ctxt, struct_id: ast::def_id, substs: substs) -> t {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_struct(struct_id, substs))\n }\n@@ -1236,7 +1236,7 @@ pub fn mk_int_var(cx: ctxt, v: IntVid) -> t { mk_infer(cx, IntVar(v)) }\n \n pub fn mk_float_var(cx: ctxt, v: FloatVid) -> t { mk_infer(cx, FloatVar(v)) }\n \n-pub fn mk_infer(cx: ctxt, +it: InferTy) -> t { mk_t(cx, ty_infer(it)) }\n+pub fn mk_infer(cx: ctxt, it: InferTy) -> t { mk_t(cx, ty_infer(it)) }\n \n pub fn mk_self(cx: ctxt, did: ast::def_id) -> t { mk_t(cx, ty_self(did)) }\n \n@@ -2672,7 +2672,7 @@ impl cmp::TotalEq for bound_region {\n }\n \n impl to_bytes::IterBytes for vstore {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           vstore_fixed(ref u) =>\n           to_bytes::iter_bytes_2(&0u8, u, lsb0, f),\n@@ -2687,44 +2687,44 @@ impl to_bytes::IterBytes for vstore {\n }\n \n impl to_bytes::IterBytes for substs {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_3(&self.self_r,\n                                  &self.self_ty,\n                                  &self.tps, lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for mt {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_2(&self.ty,\n                                  &self.mutbl, lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for field {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_2(&self.ident,\n                                  &self.mt, lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for arg {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.mode,\n                                &self.ty, lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for FnSig {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.inputs,\n                                &self.output,\n                                lsb0, f);\n     }\n }\n \n impl to_bytes::IterBytes for sty {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           ty_nil => 0u8.iter_bytes(lsb0, f),\n           ty_bool => 1u8.iter_bytes(lsb0, f),\n@@ -3383,7 +3383,7 @@ pub fn occurs_check(tcx: ctxt, sp: span, vid: TyVid, rt: t) {\n // Maintains a little union-set tree for inferred modes.  `canon()` returns\n // the current head value for `m0`.\n fn canon<T:Copy + cmp::Eq>(tbl: &mut HashMap<ast::node_id, ast::inferable<T>>,\n-                         +m0: ast::inferable<T>) -> ast::inferable<T> {\n+                           m0: ast::inferable<T>) -> ast::inferable<T> {\n     match m0 {\n         ast::infer(id) => {\n             let m1 = match tbl.find(&id) {"}, {"sha": "10acea1291f923e3a010599ddc01f77d2328e73c", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -248,7 +248,7 @@ pub static NO_TPS: uint = 2;\n // internal notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n-    self: &AC, rscope: &RS, &&ast_ty: @ast::Ty) -> ty::t {\n+    self: &AC, rscope: &RS, ast_ty: @ast::Ty) -> ty::t {\n \n     fn ast_mt_to_mt<AC:AstConv, RS:region_scope + Copy + Durable>(\n         self: &AC, rscope: &RS, mt: &ast::mt) -> ty::mt {"}, {"sha": "c58ad0bfa3b34a885425193736243d2e5d4fe15e", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -44,7 +44,7 @@ pub fn check_match(fcx: @mut FnCtxt,\n             block_region: ty::re_scope(arm.body.node.id)\n         };\n \n-        for arm.pats.each |p| { check_pat(pcx, *p, pattern_ty);}\n+        for arm.pats.each |p| { check_pat(&pcx, *p, pattern_ty);}\n     }\n \n     // Now typecheck the blocks.\n@@ -99,7 +99,7 @@ pub struct pat_ctxt {\n     block_region: ty::Region, // Region for the block of the arm\n }\n \n-pub fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::Path,\n+pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n                          subpats: &Option<~[@ast::pat]>, expected: ty::t) {\n \n     // Typecheck the path.\n@@ -247,7 +247,7 @@ pub fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::Path,\n /// `substitutions` are the type substitutions applied to this struct type\n /// (e.g. K,V in HashMap<K,V>).\n /// `etc` is true if the pattern said '...' and false otherwise.\n-pub fn check_struct_pat_fields(pcx: pat_ctxt,\n+pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                                span: span,\n                                path: @ast::Path,\n                                fields: &[ast::field_pat],\n@@ -299,7 +299,7 @@ pub fn check_struct_pat_fields(pcx: pat_ctxt,\n     }\n }\n \n-pub fn check_struct_pat(pcx: pat_ctxt, pat_id: ast::node_id, span: span,\n+pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::node_id, span: span,\n                         expected: ty::t, path: @ast::Path,\n                         fields: &[ast::field_pat], etc: bool,\n                         class_id: ast::def_id, substitutions: &ty::substs) {\n@@ -337,7 +337,7 @@ pub fn check_struct_pat(pcx: pat_ctxt, pat_id: ast::node_id, span: span,\n                             substitutions, etc);\n }\n \n-pub fn check_struct_like_enum_variant_pat(pcx: pat_ctxt,\n+pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n                                           pat_id: ast::node_id,\n                                           span: span,\n                                           expected: ty::t,\n@@ -375,7 +375,7 @@ pub fn check_struct_like_enum_variant_pat(pcx: pat_ctxt,\n \n // Pattern checking is top-down rather than bottom-up so that bindings get\n // their types immediately.\n-pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n+pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n "}, {"sha": "9d8a1145f22eb294e31e7bb1653d5c1b4c13c98a", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -1298,7 +1298,7 @@ pub impl<'self> LookupContext<'self> {\n         ty::item_path_str(self.tcx(), did)\n     }\n \n-    fn bug(&self, +s: ~str) -> ! {\n+    fn bug(&self, s: ~str) -> ! {\n         self.tcx().sess.bug(s)\n     }\n }"}, {"sha": "d6f892cac3c318023129c2284d403cbca4876bc2", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -257,7 +257,7 @@ pub fn check_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n         visit_item: |a| check_item(ccx, a),\n         .. *visit::default_simple_visitor()\n     });\n-    visit::visit_crate(*crate, (), visit);\n+    visit::visit_crate(crate, (), visit);\n }\n \n pub fn check_bare_fn(ccx: @mut CrateCtxt,\n@@ -430,11 +430,11 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                 match_region: region,\n                 block_region: region,\n             };\n-            _match::check_pat(pcx, input.pat, *arg_ty);\n+            _match::check_pat(&pcx, input.pat, *arg_ty);\n         }\n \n         // Add explicitly-declared locals.\n-        let visit_local: @fn(@ast::local, &&e: (), visit::vt<()>) =\n+        let visit_local: @fn(@ast::local, e: (), visit::vt<()>) =\n                 |local, e, v| {\n             let o_ty = match local.node.ty.node {\n               ast::ty_infer => None,\n@@ -449,7 +449,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         };\n \n         // Add pattern bindings.\n-        let visit_pat: @fn(@ast::pat, &&e: (), visit::vt<()>) = |p, e, v| {\n+        let visit_pat: @fn(@ast::pat, e: (), visit::vt<()>) = |p, e, v| {\n             match p.node {\n               ast::pat_ident(_, path, _)\n                   if pat_util::pat_is_binding(fcx.ccx.tcx.def_map, p) => {\n@@ -464,7 +464,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n             visit::visit_pat(p, e, v);\n         };\n \n-        let visit_block: @fn(&ast::blk, &&e: (), visit::vt<()>) = |b, e, v| {\n+        let visit_block: @fn(&ast::blk, e: (), visit::vt<()>) = |b, e, v| {\n             // non-obvious: the `blk` variable maps to region lb, so\n             // we have to keep this up-to-date.  This\n             // is... unfortunate.  It'd be nice to not need this.\n@@ -476,9 +476,9 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         // Don't descend into fns and items\n         fn visit_fn(_fk: &visit::fn_kind, _decl: &ast::fn_decl,\n                     _body: &ast::blk, _sp: span,\n-                    _id: ast::node_id, &&_t: (), _v: visit::vt<()>) {\n+                    _id: ast::node_id, _t: (), _v: visit::vt<()>) {\n         }\n-        fn visit_item(_i: @ast::item, &&_e: (), _v: visit::vt<()>) { }\n+        fn visit_item(_i: @ast::item, _e: (), _v: visit::vt<()>) { }\n \n         let visit = visit::mk_vt(\n             @visit::Visitor {visit_local: visit_local,\n@@ -714,7 +714,7 @@ pub impl FnCtxt {\n         self.inh.node_types.insert(node_id, ty);\n     }\n \n-    fn write_substs(&self, node_id: ast::node_id, +substs: ty::substs) {\n+    fn write_substs(&self, node_id: ast::node_id, substs: ty::substs) {\n         if !ty::substs_is_noop(&substs) {\n             debug!(\"write_substs(%d, %s) in fcx %s\",\n                    node_id,\n@@ -727,7 +727,7 @@ pub impl FnCtxt {\n     fn write_ty_substs(&self,\n                        node_id: ast::node_id,\n                        ty: ty::t,\n-                       +substs: ty::substs) {\n+                       substs: ty::substs) {\n         let ty = ty::subst(self.tcx(), &substs, ty);\n         self.write_ty(node_id, ty);\n         self.write_substs(node_id, substs);\n@@ -1429,9 +1429,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         self_ex: @ast::expr,\n                         self_t: ty::t,\n                         opname: ast::ident,\n-                        +args: ~[@ast::expr],\n-                        +deref_args: DerefArgs,\n-                        +autoderef_receiver: AutoderefReceiverFlag,\n+                        args: ~[@ast::expr],\n+                        deref_args: DerefArgs,\n+                        autoderef_receiver: AutoderefReceiverFlag,\n                         unbound_method: &fn(),\n                         _expected_result: Option<ty::t>\n                        )\n@@ -1570,7 +1570,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     fn check_user_unop(fcx: @mut FnCtxt,\n                        op_str: ~str,\n-                       +mname: ~str,\n+                       mname: ~str,\n                        ex: @ast::expr,\n                        rhs_expr: @ast::expr,\n                        rhs_t: ty::t,\n@@ -1775,7 +1775,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                       span: span,\n                                       class_id: ast::def_id,\n                                       node_id: ast::node_id,\n-                                      +substitutions: ty::substs,\n+                                      substitutions: ty::substs,\n                                       field_types: &[ty::field_ty],\n                                       ast_fields: &[ast::field],\n                                       check_completeness: bool)  {\n@@ -2859,7 +2859,7 @@ pub fn check_decl_local(fcx: @mut FnCtxt, local: @ast::local)  {\n         match_region: region,\n         block_region: region,\n     };\n-    _match::check_pat(pcx, local.node.pat, t);\n+    _match::check_pat(&pcx, local.node.pat, t);\n     let pat_ty = fcx.node_ty(local.node.pat.id);\n     if ty::type_is_error(pat_ty) || ty::type_is_bot(pat_ty) {\n         fcx.write_ty(local.node.id, pat_ty);\n@@ -2947,7 +2947,7 @@ pub fn check_block_with_expected(fcx0: @mut FnCtxt,\n         let mut any_err = false;\n         for blk.node.stmts.each |s| {\n             check_stmt(fcx, *s);\n-            let s_ty = fcx.node_ty(ast_util::stmt_id(**s));\n+            let s_ty = fcx.node_ty(ast_util::stmt_id(*s));\n             if last_was_bot && !warned && match s.node {\n                   ast::stmt_decl(@codemap::spanned { node: ast::decl_local(_),\n                                                  _}, _) |\n@@ -3350,7 +3350,7 @@ pub fn may_break(cx: ty::ctxt, id: ast::node_id, b: &ast::blk) -> bool {\n     // First: is there an unlabeled break immediately\n     // inside the loop?\n     (loop_query(b, |e| {\n-        match e {\n+        match *e {\n             ast::expr_break(_) => true,\n             _ => false\n         }"}, {"sha": "aec7399d5eb97f8bb0fdfd11e7948cd1f25dc39e", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -159,11 +159,11 @@ fn regionck_visitor() -> rvt {\n                                   .. *visit::default_visitor()})\n }\n \n-fn visit_item(_item: @ast::item, &&_rcx: @mut Rcx, _v: rvt) {\n+fn visit_item(_item: @ast::item, _rcx: @mut Rcx, _v: rvt) {\n     // Ignore items\n }\n \n-fn visit_local(l: @ast::local, &&rcx: @mut Rcx, v: rvt) {\n+fn visit_local(l: @ast::local, rcx: @mut Rcx, v: rvt) {\n     // Check to make sure that the regions in all local variables are\n     // within scope.\n     //\n@@ -194,11 +194,11 @@ fn visit_local(l: @ast::local, &&rcx: @mut Rcx, v: rvt) {\n     }\n }\n \n-fn visit_block(b: &ast::blk, &&rcx: @mut Rcx, v: rvt) {\n+fn visit_block(b: &ast::blk, rcx: @mut Rcx, v: rvt) {\n     visit::visit_block(b, rcx, v);\n }\n \n-fn visit_expr(expr: @ast::expr, &&rcx: @mut Rcx, v: rvt) {\n+fn visit_expr(expr: @ast::expr, rcx: @mut Rcx, v: rvt) {\n     debug!(\"regionck::visit_expr(e=%s)\", rcx.fcx.expr_to_str(expr));\n \n     for rcx.fcx.inh.adjustments.find(&expr.id).each |&adjustment| {\n@@ -333,7 +333,7 @@ fn visit_expr(expr: @ast::expr, &&rcx: @mut Rcx, v: rvt) {\n     visit::visit_expr(expr, rcx, v);\n }\n \n-fn visit_stmt(s: @ast::stmt, &&rcx: @mut Rcx, v: rvt) {\n+fn visit_stmt(s: @ast::stmt, rcx: @mut Rcx, v: rvt) {\n     visit::visit_stmt(s, rcx, v);\n }\n \n@@ -973,10 +973,10 @@ pub mod guarantor {\n     }\n \n     fn apply_autoderefs(\n-        +rcx: @mut Rcx,\n-        +expr: @ast::expr,\n-        +autoderefs: uint,\n-        +ct: ExprCategorizationType)\n+        rcx: @mut Rcx,\n+        expr: @ast::expr,\n+        autoderefs: uint,\n+        ct: ExprCategorizationType)\n      -> ExprCategorizationType {\n         let mut ct = ct;\n         let tcx = rcx.fcx.ccx.tcx;"}, {"sha": "39715f295ade962d4e8d56addeaceeb467b04cd4", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -135,7 +135,7 @@ fn lookup_vtables(vcx: &VtableContext,\n }\n \n fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n-                id: ast::def_id, +substs: ty::substs,\n+                id: ast::def_id, substs: ty::substs,\n                 is_early: bool) -> Option<ty::substs> {\n     let tcx = vcx.tcx();\n     // use a dummy type just to package up the substs that need fixing up\n@@ -480,7 +480,7 @@ pub fn location_info_for_expr(expr: @ast::expr) -> LocationInfo {\n }\n \n pub fn early_resolve_expr(ex: @ast::expr,\n-                          &&fcx: @mut FnCtxt,\n+                          fcx: @mut FnCtxt,\n                           is_early: bool) {\n     debug!(\"vtable: early_resolve_expr() ex with id %? (early: %b): %s\",\n            ex.id, is_early, expr_to_str(ex, fcx.tcx().sess.intr()));\n@@ -656,7 +656,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n }\n \n fn resolve_expr(ex: @ast::expr,\n-                &&fcx: @mut FnCtxt,\n+                fcx: @mut FnCtxt,\n                 v: visit::vt<@mut FnCtxt>) {\n     early_resolve_expr(ex, fcx, false);\n     visit::visit_expr(ex, fcx, v);"}, {"sha": "0dba55b4e72cfb50a6c68a360386d621433a01e0", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -212,12 +212,12 @@ struct WbCtxt {\n \n type wb_vt = visit::vt<@mut WbCtxt>;\n \n-fn visit_stmt(s: @ast::stmt, &&wbcx: @mut WbCtxt, v: wb_vt) {\n+fn visit_stmt(s: @ast::stmt, wbcx: @mut WbCtxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, s.span, ty::stmt_node_id(s));\n     visit::visit_stmt(s, wbcx, v);\n }\n-fn visit_expr(e: @ast::expr, &&wbcx: @mut WbCtxt, v: wb_vt) {\n+fn visit_expr(e: @ast::expr, wbcx: @mut WbCtxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, e.span, e.id);\n     resolve_method_map_entry(wbcx.fcx, e.span, e.id);\n@@ -256,12 +256,12 @@ fn visit_expr(e: @ast::expr, &&wbcx: @mut WbCtxt, v: wb_vt) {\n     }\n     visit::visit_expr(e, wbcx, v);\n }\n-fn visit_block(b: &ast::blk, &&wbcx: @mut WbCtxt, v: wb_vt) {\n+fn visit_block(b: &ast::blk, wbcx: @mut WbCtxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, b.span, b.node.id);\n     visit::visit_block(b, wbcx, v);\n }\n-fn visit_pat(p: @ast::pat, &&wbcx: @mut WbCtxt, v: wb_vt) {\n+fn visit_pat(p: @ast::pat, wbcx: @mut WbCtxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, p.span, p.id);\n     debug!(\"Type for pattern binding %s (id %d) resolved to %s\",\n@@ -271,7 +271,7 @@ fn visit_pat(p: @ast::pat, &&wbcx: @mut WbCtxt, v: wb_vt) {\n                                    p.id)));\n     visit::visit_pat(p, wbcx, v);\n }\n-fn visit_local(l: @ast::local, &&wbcx: @mut WbCtxt, v: wb_vt) {\n+fn visit_local(l: @ast::local, wbcx: @mut WbCtxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     let var_ty = wbcx.fcx.local_ty(l.span, l.node.id);\n     match resolve_type(wbcx.fcx.infcx(), var_ty, resolve_all | force_all) {\n@@ -293,7 +293,7 @@ fn visit_local(l: @ast::local, &&wbcx: @mut WbCtxt, v: wb_vt) {\n     }\n     visit::visit_local(l, wbcx, v);\n }\n-fn visit_item(_item: @ast::item, &&_wbcx: @mut WbCtxt, _v: wb_vt) {\n+fn visit_item(_item: @ast::item, _wbcx: @mut WbCtxt, _v: wb_vt) {\n     // Ignore items\n }\n "}, {"sha": "4225b5da418de1d13e1a5ab46806edb0595e17d4", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -203,7 +203,7 @@ pub impl CoherenceChecker {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n         // builds up the trait inheritance table.\n-        visit_crate(*crate, (), mk_simple_visitor(@SimpleVisitor {\n+        visit_crate(crate, (), mk_simple_visitor(@SimpleVisitor {\n             visit_item: |item| {\n //                debug!(\"(checking coherence) item '%s'\",\n //                       self.crate_context.tcx.sess.str_of(item.ident));\n@@ -655,7 +655,7 @@ pub impl CoherenceChecker {\n \n     // Privileged scope checking\n     fn check_privileged_scopes(self, crate: @crate) {\n-        visit_crate(*crate, (), mk_vt(@Visitor {\n+        visit_crate(crate, (), mk_vt(@Visitor {\n             visit_item: |item, _context, visitor| {\n                 match item.node {\n                     item_mod(ref module_) => {"}, {"sha": "8356b06e8a6c90bbab91ed510a4691e4109057e5", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -111,7 +111,7 @@ pub fn collect_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n     }\n \n     visit::visit_crate(\n-        *crate, (),\n+        crate, (),\n         visit::mk_simple_visitor(@visit::SimpleVisitor {\n             visit_item: |a| convert(ccx, a),\n             visit_foreign_item: |a|convert_foreign(ccx, a),"}, {"sha": "fdc96a21b8b5cade4580a1c493208180d7ef8b6d", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -124,7 +124,7 @@ pub struct CombineFields {\n }\n \n pub fn expected_found<C:Combine,T>(\n-        self: &C, +a: T, +b: T) -> ty::expected_found<T> {\n+        self: &C, a: T, b: T) -> ty::expected_found<T> {\n     if self.a_is_expected() {\n         ty::expected_found {expected: a, found: b}\n     } else {"}, {"sha": "db229a407b39a94d1522a53fdc3769768ad98916", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -77,8 +77,8 @@ pub impl CombineFields {\n     fn var_sub_var<T:Copy + InferStr + LatticeValue,\n                    V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n         &self,\n-        +a_id: V,\n-        +b_id: V) -> ures\n+        a_id: V,\n+        b_id: V) -> ures\n     {\n         /*!\n          *\n@@ -130,8 +130,8 @@ pub impl CombineFields {\n     fn var_sub_t<T:Copy + InferStr + LatticeValue,\n                  V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n         &self,\n-        +a_id: V,\n-        +b: T) -> ures\n+        a_id: V,\n+        b: T) -> ures\n     {\n         /*!\n          *\n@@ -154,8 +154,8 @@ pub impl CombineFields {\n     fn t_sub_var<T:Copy + InferStr + LatticeValue,\n                  V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n         &self,\n-        +a: T,\n-        +b_id: V) -> ures\n+        a: T,\n+        b_id: V) -> ures\n     {\n         /*!\n          *\n@@ -206,7 +206,7 @@ pub impl CombineFields {\n     fn set_var_to_merged_bounds<T:Copy + InferStr + LatticeValue,\n                                 V:Copy+Eq+ToStr+Vid+UnifyVid<Bounds<T>>>(\n         &self,\n-        +v_id: V,\n+        v_id: V,\n         a: &Bounds<T>,\n         b: &Bounds<T>,\n         rank: uint) -> ures\n@@ -296,7 +296,7 @@ pub impl CombineFields {\n pub trait LatticeDir {\n     fn combine_fields(&self) -> CombineFields;\n     fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T>;\n-    fn with_bnd<T:Copy>(&self, b: &Bounds<T>, +t: T) -> Bounds<T>;\n+    fn with_bnd<T:Copy>(&self, b: &Bounds<T>, t: T) -> Bounds<T>;\n }\n \n pub trait TyLatticeDir {\n@@ -306,7 +306,7 @@ pub trait TyLatticeDir {\n impl LatticeDir for Lub {\n     fn combine_fields(&self) -> CombineFields { **self }\n     fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T> { b.ub }\n-    fn with_bnd<T:Copy>(&self, b: &Bounds<T>, +t: T) -> Bounds<T> {\n+    fn with_bnd<T:Copy>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n         Bounds { ub: Some(t), ..*b }\n     }\n }\n@@ -320,7 +320,7 @@ impl TyLatticeDir for Lub {\n impl LatticeDir for Glb {\n     fn combine_fields(&self) -> CombineFields { **self }\n     fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T> { b.lb }\n-    fn with_bnd<T:Copy>(&self, b: &Bounds<T>, +t: T) -> Bounds<T> {\n+    fn with_bnd<T:Copy>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n         Bounds { lb: Some(t), ..*b }\n     }\n }\n@@ -401,8 +401,8 @@ pub fn lattice_vars<L:LatticeDir + Combine,\n                     T:Copy + InferStr + LatticeValue,\n                     V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n     self: &L,                           // defines whether we want LUB or GLB\n-    +a_vid: V,                          // first variable\n-    +b_vid: V,                          // second variable\n+    a_vid: V,                          // first variable\n+    b_vid: V,                          // second variable\n     lattice_dir_op: LatticeDirOp<T>)    // LUB or GLB operation on types\n     -> cres<LatticeVarResult<V,T>> {\n     let nde_a = self.infcx().get(a_vid);\n@@ -447,7 +447,7 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n                          T:Copy + InferStr + LatticeValue,\n                          V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n     self: &L,\n-    +a_id: V,\n+    a_id: V,\n     b: &T,\n     lattice_dir_op: LatticeDirOp<T>)\n     -> cres<T> {"}, {"sha": "a4a48cf5b788af0845e0ba3e26463d8a677f0cdc", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -643,8 +643,8 @@ pub impl InferCtxt {\n }\n \n fn next_simple_var<V:Copy,T:Copy>(\n-        +counter: &mut uint,\n-        +bindings: &mut ValsAndBindings<V,Option<T>>)\n+        counter: &mut uint,\n+        bindings: &mut ValsAndBindings<V,Option<T>>)\n      -> uint {\n     let id = *counter;\n     *counter += 1;"}, {"sha": "f34a990977ebe07d15128955b11cf34399f93cce", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -563,7 +563,7 @@ enum Constraint {\n }\n \n impl to_bytes::IterBytes for Constraint {\n-   fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+   fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           ConstrainVarSubVar(ref v0, ref v1) =>\n           to_bytes::iter_bytes_3(&0u8, v0, v1, lsb0, f),\n@@ -584,7 +584,7 @@ struct TwoRegions {\n }\n \n impl to_bytes::IterBytes for TwoRegions {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.a, &self.b, lsb0, f)\n     }\n }\n@@ -729,7 +729,7 @@ pub impl RegionVarBindings {\n         re_bound(br_fresh(sc))\n     }\n \n-    fn add_constraint(&mut self, +constraint: Constraint, span: span) {\n+    fn add_constraint(&mut self, constraint: Constraint, span: span) {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n@@ -995,7 +995,7 @@ pub impl RegionVarBindings {\n \n         return result_set;\n \n-        fn consider_adding_edge(+result_set: ~[Region],\n+        fn consider_adding_edge(result_set: ~[Region],\n                                 r: &Region,\n                                 r1: &Region,\n                                 r2: &Region) -> ~[Region]\n@@ -1030,7 +1030,7 @@ priv impl RegionVarBindings {\n         rm.is_subregion_of(sub, sup)\n     }\n \n-    fn lub_concrete_regions(&self, +a: Region, +b: Region) -> Region {\n+    fn lub_concrete_regions(&self, a: Region, b: Region) -> Region {\n         match (a, b) {\n           (re_static, _) | (_, re_static) => {\n             re_static // nothing lives longer than static\n@@ -1122,8 +1122,8 @@ priv impl RegionVarBindings {\n     }\n \n     fn glb_concrete_regions(&self,\n-                            +a: Region,\n-                            +b: Region)\n+                            a: Region,\n+                            b: Region)\n                          -> cres<Region> {\n         debug!(\"glb_concrete_regions(%?, %?)\", a, b);\n         match (a, b) {\n@@ -1330,7 +1330,7 @@ pub impl RegionVarBindings {\n \n         return (graph);\n \n-        fn insert_edge(+graph: &mut Graph,\n+        fn insert_edge(graph: &mut Graph,\n                        node_id: RegionVid,\n                        edge_dir: Direction,\n                        edge_idx: uint) {\n@@ -1457,9 +1457,9 @@ pub impl RegionVarBindings {\n             }\n         };\n \n-        fn check_node(+self: &mut RegionVarBindings,\n+        fn check_node(self: &mut RegionVarBindings,\n                       a_vid: RegionVid,\n-                      +a_node: &mut GraphNode,\n+                      a_node: &mut GraphNode,\n                       a_region: Region,\n                       b_region: Region)\n                    -> bool {\n@@ -1471,9 +1471,9 @@ pub impl RegionVarBindings {\n             false\n         }\n \n-        fn adjust_node(+self: &mut RegionVarBindings,\n+        fn adjust_node(self: &mut RegionVarBindings,\n                        a_vid: RegionVid,\n-                       +a_node: &mut GraphNode,\n+                       a_node: &mut GraphNode,\n                        a_region: Region,\n                        b_region: Region)\n                     -> bool {"}, {"sha": "220cc91dfdb4b93c95df3d234816cc4a2c36e897", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -42,7 +42,7 @@ pub trait UnifyVid<T> {\n pub impl InferCtxt {\n     fn get<T:Copy, V:Copy+Eq+Vid+UnifyVid<T>>(\n         &mut self,\n-        +vid: V) -> Node<V, T>\n+        vid: V) -> Node<V, T>\n     {\n         /*!\n          *\n@@ -88,8 +88,8 @@ pub impl InferCtxt {\n \n     fn set<T:Copy + InferStr,V:Copy + Vid + ToStr + UnifyVid<T>>(\n             &mut self,\n-            +vid: V,\n-            +new_v: VarValue<V, T>) {\n+            vid: V,\n+            new_v: VarValue<V, T>) {\n         /*!\n          *\n          * Sets the value for `vid` to `new_v`.  `vid` MUST be a root node!\n@@ -147,9 +147,9 @@ pub trait SimplyUnifiable {\n     fn to_type_err(expected_found<Self>) -> ty::type_err;\n }\n \n-pub fn mk_err<T:SimplyUnifiable>(+a_is_expected: bool,\n-                                  +a_t: T,\n-                                  +b_t: T) -> ures {\n+pub fn mk_err<T:SimplyUnifiable>(a_is_expected: bool,\n+                                 a_t: T,\n+                                 b_t: T) -> ures {\n     if a_is_expected {\n         Err(SimplyUnifiable::to_type_err(\n             ty::expected_found {expected: a_t, found: b_t}))\n@@ -163,9 +163,9 @@ pub impl InferCtxt {\n     fn simple_vars<T:Copy + Eq + InferStr + SimplyUnifiable,\n                    V:Copy + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n             &mut self,\n-            +a_is_expected: bool,\n-            +a_id: V,\n-            +b_id: V)\n+            a_is_expected: bool,\n+            a_id: V,\n+            b_id: V)\n          -> ures {\n         /*!\n          *\n@@ -201,9 +201,9 @@ pub impl InferCtxt {\n     fn simple_var_t<T:Copy + Eq + InferStr + SimplyUnifiable,\n                     V:Copy + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n             &mut self,\n-            +a_is_expected: bool,\n-            +a_id: V,\n-            +b: T)\n+            a_is_expected: bool,\n+            a_id: V,\n+            b: T)\n          -> ures {\n         /*!\n          *"}, {"sha": "f87c0dad5a9936842c0d37afa2b811b94e4e12a2", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -194,7 +194,7 @@ pub fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n }\n pub fn write_substs_to_tcx(tcx: ty::ctxt,\n                            node_id: ast::node_id,\n-                           +substs: ~[ty::t]) {\n+                           substs: ~[ty::t]) {\n     if substs.len() > 0u {\n         debug!(\"write_substs_to_tcx(%d, %?)\", node_id,\n                substs.map(|t| ppaux::ty_to_str(tcx, *t)));\n@@ -397,7 +397,7 @@ fn check_for_entry_fn(ccx: @mut CrateCtxt) {\n }\n \n pub fn check_crate(tcx: ty::ctxt,\n-                   +trait_map: resolve::TraitMap,\n+                   trait_map: resolve::TraitMap,\n                    crate: @ast::crate)\n                 -> (method_map, vtable_map) {\n     let time_passes = tcx.sess.time_passes();"}, {"sha": "62320a1d34d562e80b120df6c5954a69e8e95f0b", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -272,7 +272,7 @@ pub struct binding_rscope {\n \n pub fn in_binding_rscope<RS:region_scope + Copy + Durable>(\n         self: &RS,\n-        +region_param_names: RegionParamNames)\n+        region_param_names: RegionParamNames)\n      -> binding_rscope {\n     let base = @copy *self;\n     let base = base as @region_scope;"}, {"sha": "573ba4ca41175e584c00606f29a5d1b8eda58ece", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -18,12 +18,10 @@\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n-#[legacy_modes];\n-\n #[allow(non_implicitly_copyable_typarams)];\n #[allow(non_camel_case_types)];\n-#[allow(deprecated_mode)];\n-#[warn(deprecated_pattern)];\n+#[deny(deprecated_pattern)];\n+#[deny(deprecated_mode)];\n \n #[no_core];\n \n@@ -259,12 +257,12 @@ pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n     let odir = odir.map(|o| Path(*o));\n     let ofile = getopts::opt_maybe_str(matches, ~\"o\");\n     let ofile = ofile.map(|o| Path(*o));\n-    let cfg = build_configuration(sess, binary, input);\n+    let cfg = build_configuration(sess, binary, &input);\n     let pretty = getopts::opt_default(matches, ~\"pretty\", \"normal\").map(\n                     |a| parse_pretty(sess, *a));\n     match pretty {\n       Some::<pp_mode>(ppm) => {\n-        pretty_print_input(sess, cfg, input, ppm);\n+        pretty_print_input(sess, cfg, &input, ppm);\n         return;\n       }\n       None::<pp_mode> => {/* continue */ }\n@@ -282,7 +280,7 @@ pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n         return;\n     }\n \n-    compile_input(sess, cfg, input, &odir, &ofile);\n+    compile_input(sess, cfg, &input, &odir, &ofile);\n }\n \n #[deriving(Eq)]\n@@ -303,7 +301,7 @@ diagnostic emitter which records when we hit a fatal error. If the task\n fails without recording a fatal error then we've encountered a compiler\n bug and need to present an error.\n */\n-pub fn monitor(+f: ~fn(diagnostic::Emitter)) {\n+pub fn monitor(f: ~fn(diagnostic::Emitter)) {\n     use core::comm::*;\n     let (p, ch) = stream();\n     let ch = SharedChan::new(ch);"}, {"sha": "93deeecc101064987f4efa59302ec851316a2c9e", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4a439f7fbc97cdb3b4f297ec8645e22723202f/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=1e4a439f7fbc97cdb3b4f297ec8645e22723202f", "patch": "@@ -63,12 +63,12 @@ pub fn field_exprs(fields: ~[ast::field]) -> ~[@ast::expr] {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn loop_query(b: &ast::blk, p: @fn(ast::expr_) -> bool) -> bool {\n+pub fn loop_query(b: &ast::blk, p: @fn(&ast::expr_) -> bool) -> bool {\n     let rs = @mut false;\n     let visit_expr: @fn(@ast::expr,\n-                        &&flag: @mut bool,\n-                        v: visit::vt<@mut bool>) = |e, &&flag, v| {\n-        *flag |= p(e.node);\n+                        flag: @mut bool,\n+                        v: visit::vt<@mut bool>) = |e, flag, v| {\n+        *flag |= p(&e.node);\n         match e.node {\n           // Skip inner loops, since a break in the inner loop isn't a\n           // break inside the outer loop\n@@ -89,8 +89,8 @@ pub fn loop_query(b: &ast::blk, p: @fn(ast::expr_) -> bool) -> bool {\n pub fn block_query(b: &ast::blk, p: @fn(@ast::expr) -> bool) -> bool {\n     let rs = @mut false;\n     let visit_expr: @fn(@ast::expr,\n-                        &&flag: @mut bool,\n-                        v: visit::vt<@mut bool>) = |e, &&flag, v| {\n+                        flag: @mut bool,\n+                        v: visit::vt<@mut bool>) = |e, flag, v| {\n         *flag |= p(e);\n         visit::visit_expr(e, flag, v)\n     };\n@@ -108,7 +108,7 @@ pub fn local_rhs_span(l: @ast::local, def: span) -> span {\n     }\n }\n \n-pub fn pluralize(n: uint, +s: ~str) -> ~str {\n+pub fn pluralize(n: uint, s: ~str) -> ~str {\n     if n == 1 { s }\n     else { str::concat([s, ~\"s\"]) }\n }"}]}