{"sha": "f204b67b0f5ae6f498d29938790cd989e58f5bec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyMDRiNjdiMGY1YWU2ZjQ5OGQyOTkzODc5MGNkOTg5ZTU4ZjViZWM=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-27T04:49:36Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-27T21:26:36Z"}, "message": "Merge dtors_running and last_dtor_key fields.", "tree": {"sha": "b6c1fe21bbc9bf57b6715b54fbf1e124ba42a89a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6c1fe21bbc9bf57b6715b54fbf1e124ba42a89a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f204b67b0f5ae6f498d29938790cd989e58f5bec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f204b67b0f5ae6f498d29938790cd989e58f5bec", "html_url": "https://github.com/rust-lang/rust/commit/f204b67b0f5ae6f498d29938790cd989e58f5bec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f204b67b0f5ae6f498d29938790cd989e58f5bec/comments", "author": null, "committer": null, "parents": [{"sha": "356aecce7f3c438db6804a72a5022a2537d35104", "url": "https://api.github.com/repos/rust-lang/rust/commits/356aecce7f3c438db6804a72a5022a2537d35104", "html_url": "https://github.com/rust-lang/rust/commit/356aecce7f3c438db6804a72a5022a2537d35104"}], "stats": {"total": 47, "additions": 32, "deletions": 15}, "files": [{"sha": "a98a80256414e026ac53eeb6dbb1bd1b637862ef", "filename": "src/shims/tls.rs", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f204b67b0f5ae6f498d29938790cd989e58f5bec/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f204b67b0f5ae6f498d29938790cd989e58f5bec/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=f204b67b0f5ae6f498d29938790cd989e58f5bec", "patch": "@@ -2,10 +2,10 @@\n \n use std::collections::BTreeMap;\n use std::collections::btree_map::Entry;\n-use std::collections::HashSet;\n \n use log::trace;\n \n+use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::ty;\n use rustc_target::abi::{Size, HasDataLayout};\n \n@@ -24,6 +24,12 @@ pub struct TlsEntry<'tcx> {\n     dtor: Option<ty::Instance<'tcx>>,\n }\n \n+#[derive(Clone, Debug)]\n+struct RunningDtorsState {\n+    /// The last TlsKey used to retrieve a TLS destructor.\n+    last_dtor_key: Option<TlsKey>,\n+}\n+\n #[derive(Debug)]\n pub struct TlsData<'tcx> {\n     /// The Key to use for the next thread-local allocation.\n@@ -36,11 +42,10 @@ pub struct TlsData<'tcx> {\n     /// things work on macOS) with a data argument.\n     thread_dtors: BTreeMap<ThreadId, (ty::Instance<'tcx>, Scalar<Tag>)>,\n \n-    /// Whether we are in the \"destruct\" phase, during which some operations are UB.\n-    dtors_running: HashSet<ThreadId>,\n-\n-    /// The last TlsKey used to retrieve a TLS destructor.\n-    last_dtor_key: BTreeMap<ThreadId, TlsKey>,\n+    /// State for currently running TLS dtors. If this map contains a key for a\n+    /// specific thread, it means that we are in the \"destruct\" phase, during\n+    /// which some operations are UB.\n+    dtors_running: FxHashMap<ThreadId, RunningDtorsState>,\n }\n \n impl<'tcx> Default for TlsData<'tcx> {\n@@ -50,7 +55,6 @@ impl<'tcx> Default for TlsData<'tcx> {\n             keys: Default::default(),\n             thread_dtors: Default::default(),\n             dtors_running: Default::default(),\n-            last_dtor_key: Default::default(),\n         }\n     }\n }\n@@ -135,7 +139,7 @@ impl<'tcx> TlsData<'tcx> {\n         dtor: ty::Instance<'tcx>,\n         data: Scalar<Tag>\n     ) -> InterpResult<'tcx> {\n-        if self.dtors_running.contains(&thread) {\n+        if self.dtors_running.contains_key(&thread) {\n             // UB, according to libstd docs.\n             throw_ub_format!(\"setting thread's local storage destructor while destructors are already running\");\n         }\n@@ -192,6 +196,21 @@ impl<'tcx> TlsData<'tcx> {\n         }\n         None\n     }\n+\n+    /// Set that dtors are running for `thread`. It is guaranteed not to change\n+    /// the existing values stored in `dtors_running` for this thread. Returns\n+    /// `true` if dtors for `thread` are already running.\n+    fn set_dtors_running_for_thread(&mut self, thread: ThreadId) -> bool {\n+        if self.dtors_running.contains_key(&thread) {\n+            true\n+        } else {\n+            self.dtors_running.insert(\n+                thread,\n+                RunningDtorsState { last_dtor_key: None }\n+            );\n+            false\n+        }\n+    }\n }\n \n impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n@@ -203,7 +222,6 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         let active_thread = this.get_active_thread()?;\n         assert_eq!(this.get_total_thread_count()?, 1, \"concurrency on Windows not supported\");\n-        this.machine.tls.dtors_running.insert(active_thread);\n         // Windows has a special magic linker section that is run on certain events.\n         // Instead of searching for that section and supporting arbitrary hooks in there\n         // (that would be basically https://github.com/rust-lang/miri/issues/450),\n@@ -260,7 +278,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         assert!(this.has_terminated(active_thread)?, \"running TLS dtors for non-terminated thread\");\n         // Fetch next dtor after `key`.\n-        let last_key = this.machine.tls.last_dtor_key.get(&active_thread).cloned();\n+        let last_key = this.machine.tls.dtors_running[&active_thread].last_dtor_key.clone();\n         let dtor = match this.machine.tls.fetch_tls_dtor(last_key, active_thread) {\n             dtor @ Some(_) => dtor,\n             // We ran each dtor once, start over from the beginning.\n@@ -269,7 +287,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n         };\n         if let Some((instance, ptr, key)) = dtor {\n-            this.machine.tls.last_dtor_key.insert(active_thread, key);\n+            this.machine.tls.dtors_running.get_mut(&active_thread).unwrap().last_dtor_key = Some(key);\n             trace!(\"Running TLS dtor {:?} on {:?} at {:?}\", instance, ptr, active_thread);\n             assert!(!this.is_null(ptr).unwrap(), \"data can't be NULL when dtor is called!\");\n \n@@ -284,7 +302,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             this.enable_thread(active_thread)?;\n             return Ok(());\n         }\n-        this.machine.tls.last_dtor_key.remove(&active_thread);\n+        this.machine.tls.dtors_running.get_mut(&active_thread).unwrap().last_dtor_key = None;\n \n         Ok(())\n     }\n@@ -305,12 +323,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let active_thread = this.get_active_thread()?;\n \n         if this.tcx.sess.target.target.target_os == \"windows\" {\n-            if !this.machine.tls.dtors_running.contains(&active_thread) {\n-                this.machine.tls.dtors_running.insert(active_thread);\n+            if !this.machine.tls.set_dtors_running_for_thread(active_thread) {\n                 this.schedule_windows_tls_dtors()?;\n             }\n         } else {\n-            this.machine.tls.dtors_running.insert(active_thread);\n+            this.machine.tls.set_dtors_running_for_thread(active_thread);\n             // The macOS thread wide destructor runs \"before any TLS slots get\n             // freed\", so do that first.\n             this.schedule_macos_tls_dtor()?;"}]}