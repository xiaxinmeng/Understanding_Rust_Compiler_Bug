{"sha": "4225019750f437c8c247a2682f01abe5ada69c46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyMjUwMTk3NTBmNDM3YzhjMjQ3YTI2ODJmMDFhYmU1YWRhNjljNDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-03T13:17:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-03T13:17:20Z"}, "message": "Auto merge of #42396 - venkatagiri:remove_lifetime_extn, r=arielb1\n\nrustc: remove temporary lifetime extension by borrow hint\n\ncloses #39283.\n\nThanks to @nikomatsakis for mentoring on this one.\n\nr? @arielb1", "tree": {"sha": "e68be736cfc7746f3c46b876c65502bad39cf469", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e68be736cfc7746f3c46b876c65502bad39cf469"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4225019750f437c8c247a2682f01abe5ada69c46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4225019750f437c8c247a2682f01abe5ada69c46", "html_url": "https://github.com/rust-lang/rust/commit/4225019750f437c8c247a2682f01abe5ada69c46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4225019750f437c8c247a2682f01abe5ada69c46/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a", "html_url": "https://github.com/rust-lang/rust/commit/2f2d7413ffb99a21c2cba48aff3a972d5f9d126a"}, {"sha": "ac8a1f5b6d3035ac2135cdbbe671d58788d394ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac8a1f5b6d3035ac2135cdbbe671d58788d394ae", "html_url": "https://github.com/rust-lang/rust/commit/ac8a1f5b6d3035ac2135cdbbe671d58788d394ae"}], "stats": {"total": 170, "additions": 28, "deletions": 142}, "files": [{"sha": "0b2652c748816c5355eb236a0def7b72c1884746", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=4225019750f437c8c247a2682f01abe5ada69c46", "patch": "@@ -303,7 +303,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 arg.id,\n                 arg.pat.span,\n                 fn_body_scope_r, // Args live only as long as the fn body.\n-                fn_body_scope_r,\n                 arg_ty);\n \n             self.walk_irrefutable_pat(arg_cmt, &arg.pat);"}, {"sha": "c114aa1d7a883b9e27ba523200f1c07df94779f7", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4225019750f437c8c247a2682f01abe5ada69c46", "patch": "@@ -88,8 +88,7 @@ use std::rc::Rc;\n \n #[derive(Clone, PartialEq)]\n pub enum Categorization<'tcx> {\n-    // temporary val, argument is its scope\n-    Rvalue(ty::Region<'tcx>, ty::Region<'tcx>),\n+    Rvalue(ty::Region<'tcx>),              // temporary val, argument is its scope\n     StaticItem,\n     Upvar(Upvar),                          // upvar referenced by closure env\n     Local(ast::NodeId),                    // local variable\n@@ -827,18 +826,13 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n     /// Returns the lifetime of a temporary created by expr with id `id`.\n     /// This could be `'static` if `id` is part of a constant expression.\n-    pub fn temporary_scope(&self, id: ast::NodeId) -> (ty::Region<'tcx>, ty::Region<'tcx>)\n+    pub fn temporary_scope(&self, id: ast::NodeId) -> ty::Region<'tcx>\n     {\n-        let (scope, old_scope) =\n-            self.region_maps.old_and_new_temporary_scope(id);\n-        (self.tcx().mk_region(match scope {\n+        let scope = self.region_maps.temporary_scope(id);\n+        self.tcx().mk_region(match scope {\n             Some(scope) => ty::ReScope(scope),\n             None => ty::ReStatic\n-        }),\n-         self.tcx().mk_region(match old_scope {\n-            Some(scope) => ty::ReScope(scope),\n-            None => ty::ReStatic\n-        }))\n+        })\n     }\n \n     pub fn cat_rvalue_node(&self,\n@@ -858,13 +852,12 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // Compute maximum lifetime of this rvalue. This is 'static if\n         // we can promote to a constant, otherwise equal to enclosing temp\n         // lifetime.\n-        let (re, old_re) = if promotable {\n-            (self.tcx().types.re_static,\n-             self.tcx().types.re_static)\n+        let re = if promotable {\n+            self.tcx().types.re_static\n         } else {\n             self.temporary_scope(id)\n         };\n-        let ret = self.cat_rvalue(id, span, re, old_re, expr_ty);\n+        let ret = self.cat_rvalue(id, span, re, expr_ty);\n         debug!(\"cat_rvalue_node ret {:?}\", ret);\n         ret\n     }\n@@ -873,12 +866,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                       cmt_id: ast::NodeId,\n                       span: Span,\n                       temp_scope: ty::Region<'tcx>,\n-                      old_temp_scope: ty::Region<'tcx>,\n                       expr_ty: Ty<'tcx>) -> cmt<'tcx> {\n         let ret = Rc::new(cmt_ {\n             id:cmt_id,\n             span:span,\n-            cat:Categorization::Rvalue(temp_scope, old_temp_scope),\n+            cat:Categorization::Rvalue(temp_scope),\n             mutbl:McDeclared,\n             ty:expr_ty,\n             note: NoteNone\n@@ -1415,9 +1407,7 @@ impl<'tcx> fmt::Debug for Categorization<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             Categorization::StaticItem => write!(f, \"static\"),\n-            Categorization::Rvalue(r, or) => {\n-                write!(f, \"rvalue({:?}, {:?})\", r, or)\n-            }\n+            Categorization::Rvalue(r) => { write!(f, \"rvalue({:?})\", r) }\n             Categorization::Local(id) => {\n                let name = ty::tls::with(|tcx| tcx.local_var_name_str(id));\n                write!(f, \"local({})\", name)"}, {"sha": "6455d7ecf85ae83d640bae0525ec2660ee76a0db", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 5, "deletions": 67, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=4225019750f437c8c247a2682f01abe5ada69c46", "patch": "@@ -223,13 +223,6 @@ pub struct RegionMaps {\n     /// block (see `terminating_scopes`).\n     rvalue_scopes: NodeMap<CodeExtent>,\n \n-    /// Records the value of rvalue scopes before they were shrunk by\n-    /// #36082, for error reporting.\n-    ///\n-    /// FIXME: this should be temporary. Remove this by 1.18.0 or\n-    /// so.\n-    shrunk_rvalue_scopes: NodeMap<CodeExtent>,\n-\n     /// Encodes the hierarchy of fn bodies. Every fn body (including\n     /// closures) forms its own distinct region hierarchy, rooted in\n     /// the block that is the fn body. This map points from the id of\n@@ -301,7 +294,6 @@ impl<'tcx> RegionMaps {\n             destruction_scopes: FxHashMap(),\n             var_map: NodeMap(),\n             rvalue_scopes: NodeMap(),\n-            shrunk_rvalue_scopes: NodeMap(),\n             fn_tree: NodeMap(),\n         }\n     }\n@@ -370,12 +362,6 @@ impl<'tcx> RegionMaps {\n         self.rvalue_scopes.insert(var, lifetime);\n     }\n \n-    fn record_shrunk_rvalue_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent) {\n-        debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n-        assert!(var != lifetime.node_id());\n-        self.shrunk_rvalue_scopes.insert(var, lifetime);\n-    }\n-\n     pub fn opt_encl_scope(&self, id: CodeExtent) -> Option<CodeExtent> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n         self.scope_map.get(&id).cloned()\n@@ -395,32 +381,6 @@ impl<'tcx> RegionMaps {\n         }\n     }\n \n-    pub fn temporary_scope2(&self, expr_id: ast::NodeId)\n-                            -> (Option<CodeExtent>, bool) {\n-        let temporary_scope = self.temporary_scope(expr_id);\n-        let was_shrunk = match self.shrunk_rvalue_scopes.get(&expr_id) {\n-            Some(&s) => {\n-                info!(\"temporary_scope2({:?}, scope={:?}, shrunk={:?})\",\n-                      expr_id, temporary_scope, s);\n-                temporary_scope != Some(s)\n-            }\n-            _ => false\n-        };\n-        info!(\"temporary_scope2({:?}) - was_shrunk={:?}\", expr_id, was_shrunk);\n-        (temporary_scope, was_shrunk)\n-    }\n-\n-    pub fn old_and_new_temporary_scope(&self, expr_id: ast::NodeId)\n-                                       -> (Option<CodeExtent>,\n-                                           Option<CodeExtent>)\n-    {\n-        let temporary_scope = self.temporary_scope(expr_id);\n-        (temporary_scope,\n-         self.shrunk_rvalue_scopes\n-             .get(&expr_id).cloned()\n-             .or(temporary_scope))\n-    }\n-\n     pub fn temporary_scope(&self, expr_id: ast::NodeId) -> Option<CodeExtent> {\n         //! Returns the scope when temp created by expr_id will be cleaned up\n \n@@ -896,10 +856,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     // Rule A. `let (ref x, ref y) = (foo().x, 44)`. The rvalue `(22, 44)`\n     // would have an extended lifetime, but not `foo()`.\n     //\n-    // Rule B. `let x: &[...] = [foo().x]`. The rvalue `[foo().x]`\n-    // would have an extended lifetime, but not `foo()`.\n-    //\n-    // Rule C. `let x = &foo().x`. The rvalue ``foo()` would have extended\n+    // Rule B. `let x = &foo().x`. The rvalue ``foo()` would have extended\n     // lifetime.\n     //\n     // In some cases, multiple rules may apply (though not to the same\n@@ -916,13 +873,8 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     if let Some(ref expr) = local.init {\n         record_rvalue_scope_if_borrow_expr(visitor, &expr, blk_scope);\n \n-        let is_borrow =\n-            if let Some(ref ty) = local.ty { is_borrowed_ty(&ty) } else { false };\n-\n         if is_binding_pat(&local.pat) {\n-            record_rvalue_scope(visitor, &expr, blk_scope, false);\n-        } else if is_borrow {\n-            record_rvalue_scope(visitor, &expr, blk_scope, true);\n+            record_rvalue_scope(visitor, &expr, blk_scope);\n         }\n     }\n \n@@ -963,14 +915,6 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n         }\n     }\n \n-    /// True if `ty` is a borrowed pointer type like `&int` or `&[...]`.\n-    fn is_borrowed_ty(ty: &hir::Ty) -> bool {\n-        match ty.node {\n-            hir::TyRptr(..) => true,\n-            _ => false\n-        }\n-    }\n-\n     /// If `expr` matches the `E&` grammar, then records an extended rvalue scope as appropriate:\n     ///\n     ///     E& = & ET\n@@ -989,7 +933,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n         match expr.node {\n             hir::ExprAddrOf(_, ref subexpr) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n-                record_rvalue_scope(visitor, &subexpr, blk_id, false);\n+                record_rvalue_scope(visitor, &subexpr, blk_id);\n             }\n             hir::ExprStruct(_, ref fields, _) => {\n                 for field in fields {\n@@ -1034,21 +978,15 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     /// Note: ET is intended to match \"rvalues or lvalues based on rvalues\".\n     fn record_rvalue_scope<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n                                      expr: &hir::Expr,\n-                                     blk_scope: CodeExtent,\n-                                     is_shrunk: bool) {\n+                                     blk_scope: CodeExtent) {\n         let mut expr = expr;\n         loop {\n             // Note: give all the expressions matching `ET` with the\n             // extended temporary lifetime, not just the innermost rvalue,\n             // because in trans if we must compile e.g. `*rvalue()`\n             // into a temporary, we request the temporary scope of the\n             // outer expression.\n-            if is_shrunk {\n-                // this changed because of #36082\n-                visitor.region_maps.record_shrunk_rvalue_scope(expr.id, blk_scope);\n-            } else {\n-                visitor.region_maps.record_rvalue_scope(expr.id, blk_scope);\n-            }\n+            visitor.region_maps.record_rvalue_scope(expr.id, blk_scope);\n \n             match expr.node {\n                 hir::ExprAddrOf(_, ref subexpr) |"}, {"sha": "89c60da396913cf36986f0be7be303cdbd13703f", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=4225019750f437c8c247a2682f01abe5ada69c46", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         //! rooting etc, and presuming `cmt` is not mutated.\n \n         match cmt.cat {\n-            Categorization::Rvalue(temp_scope, _) => {\n+            Categorization::Rvalue(temp_scope) => {\n                 temp_scope\n             }\n             Categorization::Upvar(..) => {"}, {"sha": "c72bdd04011161166f6abe81f84cd68af64bb8d9", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=4225019750f437c8c247a2682f01abe5ada69c46", "patch": "@@ -1125,17 +1125,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 if let Some(_) = statement_scope_span(self.tcx, super_scope) {\n                     db.note(\"consider using a `let` binding to increase its lifetime\");\n                 }\n-\n-\n-\n-                match err.cmt.cat {\n-                    mc::Categorization::Rvalue(r, or) if r != or => {\n-                        db.note(\"\\\n-before rustc 1.16, this temporary lived longer - see issue #39283 \\\n-(https://github.com/rust-lang/rust/issues/39283)\");\n-                    }\n-                    _ => {}\n-                }\n             }\n \n             err_borrowed_pointer_too_short(loan_scope, ptr_scope) => {"}, {"sha": "6d15f0a2e5d7f28b366f9f845b45829e29575de3", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=4225019750f437c8c247a2682f01abe5ada69c46", "patch": "@@ -26,7 +26,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn expr_as_constant(&mut self, expr: Expr<'tcx>) -> Constant<'tcx> {\n         let this = self;\n-        let Expr { ty, temp_lifetime: _, temp_lifetime_was_shrunk: _, span, kind }\n+        let Expr { ty, temp_lifetime: _, span, kind }\n             = expr;\n         match kind {\n             ExprKind::Scope { extent: _, value } =>"}, {"sha": "17d74571ce4828128ef1d4798fda7b8439543198", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=4225019750f437c8c247a2682f01abe5ada69c46", "patch": "@@ -50,13 +50,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let temp = this.temp(expr_ty.clone(), expr_span);\n         let source_info = this.source_info(expr_span);\n \n-        if expr.temp_lifetime_was_shrunk && this.hir.needs_drop(expr_ty) {\n-            this.hir.tcx().sess.span_warn(\n-                expr_span,\n-                \"this temporary used to live longer - see issue #39283 \\\n-(https://github.com/rust-lang/rust/issues/39283)\");\n-        }\n-\n         if !expr_ty.is_never() && temp_lifetime.is_some() {\n             this.cfg.push(block, Statement {\n                 source_info: source_info,"}, {"sha": "47c50b78f3acca6f531340bc6814ae6a6562b797", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=4225019750f437c8c247a2682f01abe5ada69c46", "patch": "@@ -82,11 +82,10 @@ pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    block: &'tcx hir::Block)\n                                    -> ExprRef<'tcx> {\n     let block_ty = cx.tables().node_id_to_type(block.id);\n-    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(block.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(block.id);\n     let expr = Expr {\n         ty: block_ty,\n         temp_lifetime: temp_lifetime,\n-        temp_lifetime_was_shrunk: was_shrunk,\n         span: block.span,\n         kind: ExprKind::Block { body: block },\n     };"}, {"sha": "8cfeecdafb51a39349a829975ba8baf8089ef5f2", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 7, "deletions": 24, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=4225019750f437c8c247a2682f01abe5ada69c46", "patch": "@@ -26,7 +26,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     type Output = Expr<'tcx>;\n \n     fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Expr<'tcx> {\n-        let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(self.id);\n+        let temp_lifetime = cx.region_maps.temporary_scope(self.id);\n         let expr_extent = CodeExtent::Misc(self.id);\n \n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n@@ -44,7 +44,6 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         // Next, wrap this up in the expr's scope.\n         expr = Expr {\n             temp_lifetime: temp_lifetime,\n-            temp_lifetime_was_shrunk: was_shrunk,\n             ty: expr.ty,\n             span: self.span,\n             kind: ExprKind::Scope {\n@@ -57,7 +56,6 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         if let Some(extent) = cx.region_maps.opt_destruction_extent(self.id) {\n             expr = Expr {\n                 temp_lifetime: temp_lifetime,\n-                temp_lifetime_was_shrunk: was_shrunk,\n                 ty: expr.ty,\n                 span: self.span,\n                 kind: ExprKind::Scope {\n@@ -77,7 +75,7 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                     mut expr: Expr<'tcx>,\n                                     adjustment: &Adjustment<'tcx>)\n                                     -> Expr<'tcx> {\n-    let Expr { temp_lifetime, temp_lifetime_was_shrunk, span, .. } = expr;\n+    let Expr { temp_lifetime, span, .. } = expr;\n     let kind = match adjustment.kind {\n         Adjust::ReifyFnPointer => {\n             ExprKind::ReifyFnPointer { source: expr.to_ref() }\n@@ -102,7 +100,6 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n             expr = Expr {\n                 temp_lifetime,\n-                temp_lifetime_was_shrunk,\n                 ty: cx.tcx.mk_ref(deref.region,\n                                   ty::TypeAndMut {\n                                     ty: expr.ty,\n@@ -133,7 +130,6 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let region = cx.tcx.mk_region(region);\n             expr = Expr {\n                 temp_lifetime,\n-                temp_lifetime_was_shrunk,\n                 ty: cx.tcx.mk_ref(region,\n                                   ty::TypeAndMut {\n                                     ty: expr.ty,\n@@ -155,7 +151,6 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n     Expr {\n         temp_lifetime,\n-        temp_lifetime_was_shrunk,\n         ty: adjustment.target,\n         span,\n         kind,\n@@ -166,7 +161,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                           expr: &'tcx hir::Expr)\n                                           -> Expr<'tcx> {\n     let expr_ty = cx.tables().expr_ty(expr);\n-    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(expr.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(expr.id);\n \n     let kind = match expr.node {\n         // Here comes the interesting stuff:\n@@ -198,7 +193,6 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 let tupled_args = Expr {\n                     ty: cx.tcx.mk_tup(arg_tys, false),\n                     temp_lifetime: temp_lifetime,\n-                    temp_lifetime_was_shrunk: was_shrunk,\n                     span: expr.span,\n                     kind: ExprKind::Tuple { fields: args.iter().map(ToRef::to_ref).collect() },\n                 };\n@@ -575,7 +569,6 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n     Expr {\n         temp_lifetime: temp_lifetime,\n-        temp_lifetime_was_shrunk: was_shrunk,\n         ty: expr_ty,\n         span: expr.span,\n         kind: kind,\n@@ -586,14 +579,13 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  expr: &hir::Expr,\n                                  custom_callee: Option<(DefId, &'tcx Substs<'tcx>)>)\n                                  -> Expr<'tcx> {\n-    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(expr.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(expr.id);\n     let (def_id, substs) = custom_callee.unwrap_or_else(|| {\n         (cx.tables().type_dependent_defs[&expr.id].def_id(),\n          cx.tables().node_substs(expr.id))\n     });\n     Expr {\n         temp_lifetime: temp_lifetime,\n-        temp_lifetime_was_shrunk: was_shrunk,\n         ty: cx.tcx.type_of(def_id).subst(cx.tcx, substs),\n         span: expr.span,\n         kind: ExprKind::Literal {\n@@ -673,7 +665,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                expr: &'tcx hir::Expr,\n                                def: Def)\n                                -> ExprKind<'tcx> {\n-    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(expr.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(expr.id);\n \n     match def {\n         Def::Local(def_id) => {\n@@ -712,13 +704,11 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     Expr {\n                         ty: closure_ty,\n                         temp_lifetime: temp_lifetime,\n-                        temp_lifetime_was_shrunk: was_shrunk,\n                         span: expr.span,\n                         kind: ExprKind::Deref {\n                             arg: Expr {\n                                 ty: ref_closure_ty,\n                                 temp_lifetime: temp_lifetime,\n-                                temp_lifetime_was_shrunk: was_shrunk,\n                                 span: expr.span,\n                                 kind: ExprKind::SelfRef,\n                             }\n@@ -735,13 +725,11 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     Expr {\n                         ty: closure_ty,\n                         temp_lifetime: temp_lifetime,\n-                        temp_lifetime_was_shrunk: was_shrunk,\n                         span: expr.span,\n                         kind: ExprKind::Deref {\n                             arg: Expr {\n                                 ty: ref_closure_ty,\n                                 temp_lifetime: temp_lifetime,\n-                                temp_lifetime_was_shrunk: was_shrunk,\n                                 span: expr.span,\n                                 kind: ExprKind::SelfRef,\n                             }.to_ref(),\n@@ -752,7 +740,6 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     Expr {\n                         ty: closure_ty,\n                         temp_lifetime: temp_lifetime,\n-                        temp_lifetime_was_shrunk: was_shrunk,\n                         span: expr.span,\n                         kind: ExprKind::SelfRef,\n                     }\n@@ -783,7 +770,6 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     ExprKind::Deref {\n                         arg: Expr {\n                             temp_lifetime: temp_lifetime,\n-                            temp_lifetime_was_shrunk: was_shrunk,\n                             ty: cx.tcx.mk_ref(borrow.region,\n                                               ty::TypeAndMut {\n                                                   ty: var_ty,\n@@ -865,11 +851,10 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type\n-    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(expr.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(expr.id);\n     let fun = method_callee(cx, expr, custom_callee);\n     let ref_expr = Expr {\n         temp_lifetime: temp_lifetime,\n-        temp_lifetime_was_shrunk: was_shrunk,\n         ty: ref_ty,\n         span: expr.span,\n         kind: ExprKind::Call {\n@@ -894,11 +879,10 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         closure_expr_id: closure_expr.id,\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id).unwrap();\n-    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(closure_expr.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(closure_expr.id);\n     let var_ty = cx.tables().node_id_to_type(id_var);\n     let captured_var = Expr {\n         temp_lifetime: temp_lifetime,\n-        temp_lifetime_was_shrunk: was_shrunk,\n         ty: var_ty,\n         span: closure_expr.span,\n         kind: convert_var(cx, closure_expr, freevar.def),\n@@ -913,7 +897,6 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             };\n             Expr {\n                 temp_lifetime: temp_lifetime,\n-                temp_lifetime_was_shrunk: was_shrunk,\n                 ty: freevar_ty,\n                 span: closure_expr.span,\n                 kind: ExprKind::Borrow {"}, {"sha": "044096699b1a4226a8755cc452c873fa8f9bdb07", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=4225019750f437c8c247a2682f01abe5ada69c46", "patch": "@@ -99,9 +99,6 @@ pub struct Expr<'tcx> {\n     /// temporary; should be None only if in a constant context\n     pub temp_lifetime: Option<CodeExtent>,\n \n-    /// whether this temp lifetime was shrunk by #36082.\n-    pub temp_lifetime_was_shrunk: bool,\n-\n     /// span of the expression in the source\n     pub span: Span,\n "}, {"sha": "b66e311f04c6bbac5265f3f0b9b63edb2db2c9d2", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4225019750f437c8c247a2682f01abe5ada69c46/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=4225019750f437c8c247a2682f01abe5ada69c46", "patch": "@@ -912,7 +912,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                                                      cmt: mc::cmt<'tcx>,\n                                                      span: Span) {\n         match cmt.cat {\n-            Categorization::Rvalue(region, _) => {\n+            Categorization::Rvalue(region) => {\n                 match *region {\n                     ty::ReScope(rvalue_scope) => {\n                         let typ = self.resolve_type(cmt.ty);\n@@ -1030,7 +1030,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             let arg_ty = self.node_ty(arg.id);\n             let re_scope = self.tcx.mk_region(ty::ReScope(body_scope));\n             let arg_cmt = mc.cat_rvalue(\n-                arg.id, arg.pat.span, re_scope, re_scope, arg_ty);\n+                arg.id, arg.pat.span, re_scope, arg_ty);\n             debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\",\n                    arg_ty,\n                    arg_cmt,"}, {"sha": "b46756bb8f55401efc52e32525d018e6dcf412d6", "filename": "src/test/compile-fail/issue-36082.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4225019750f437c8c247a2682f01abe5ada69c46/src%2Ftest%2Fcompile-fail%2Fissue-36082.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4225019750f437c8c247a2682f01abe5ada69c46/src%2Ftest%2Fcompile-fail%2Fissue-36082.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-36082.rs?ref=4225019750f437c8c247a2682f01abe5ada69c46", "patch": "@@ -16,12 +16,10 @@ fn main() {\n     let x = RefCell::new((&mut r,s));\n \n     let val: &_ = x.borrow().0;\n-    //~^ WARNING this temporary used to live longer - see issue #39283\n-    //~^^ ERROR borrowed value does not live long enough\n+    //~^ ERROR borrowed value does not live long enough\n     //~| temporary value dropped here while still borrowed\n     //~| temporary value created here\n     //~| consider using a `let` binding to increase its lifetime\n-    //~| before rustc 1.16, this temporary lived longer - see issue #39283\n     println!(\"{}\", val);\n }\n //~^ temporary value needs to live until here"}]}