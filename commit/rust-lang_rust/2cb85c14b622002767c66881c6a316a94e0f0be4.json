{"sha": "2cb85c14b622002767c66881c6a316a94e0f0be4", "node_id": "C_kwDOAAsO6NoAKDJjYjg1YzE0YjYyMjAwMjc2N2M2Njg4MWM2YTMxNmE5NGUwZjBiZTQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-01-25T16:03:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-25T16:03:35Z"}, "message": "Merge #11281\n\n11281: ide: parallel prime caches r=jonas-schievink a=jhgg\n\ncache priming goes brrrr... the successor to #10149\r\n\r\n---\r\n\r\nthis PR implements a parallel cache priming strategy that uses a topological work queue to feed a pool of worker threads the crates to index in parallel.\r\n\r\n## todo\r\n- [x] should we keep the old prime caches?\r\n- [x] we should use num_cpus to detect how many cpus to use to prime caches. should we also expose a config for # of worker CPU threads to use?\r\n- [x] something is wonky with cancellation, need to figure it out before this can merge. \n\nCo-authored-by: Jake Heinz <jh@discordapp.com>", "tree": {"sha": "141d17e197d3da3fad2d61eb99ae313be893b371", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/141d17e197d3da3fad2d61eb99ae313be893b371"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cb85c14b622002767c66881c6a316a94e0f0be4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh8B9XCRBK7hj4Ov3rIwAANK4IAEFj7X2jsBvVu/ERvqSoMtJE\ngZjMQJhMluyt1AEiVrv0ObetzqY7uH9RhjtDVODEz3mkSDDdNwIZpuQ6pjPp+xsc\n7s/6n2QbJ8o1+ngwehnsux7EdANn4AdwU7W8zpRyuj9D9OLl7bQWAsFoE3pb8odr\nQt3qpHyvdxbjycI+H/u8WdxOQea0U76vpjJJVWwcw62p8uhmPxL7ww2OhiJd00qw\nGnskzLLXMqDktgW0H0gIbyB5QXuRvo5GBTctPA+AGPKCMDBH2P3GUDpM5XKZ4isw\nD2flSh2Rjnq6FQd3jF5o13H2OExNVMma4NqAJK/eYm71yhhVojR3GfJp+OkRexo=\n=NXPr\n-----END PGP SIGNATURE-----\n", "payload": "tree 141d17e197d3da3fad2d61eb99ae313be893b371\nparent 5f13d6af9ff59a07eb9d4e5b269c735bae17c372\nparent 25f67b6939ec84235b12a35c1e2176f3c68a6dea\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1643126615 +0000\ncommitter GitHub <noreply@github.com> 1643126615 +0000\n\nMerge #11281\n\n11281: ide: parallel prime caches r=jonas-schievink a=jhgg\n\ncache priming goes brrrr... the successor to #10149\r\n\r\n---\r\n\r\nthis PR implements a parallel cache priming strategy that uses a topological work queue to feed a pool of worker threads the crates to index in parallel.\r\n\r\n## todo\r\n- [x] should we keep the old prime caches?\r\n- [x] we should use num_cpus to detect how many cpus to use to prime caches. should we also expose a config for # of worker CPU threads to use?\r\n- [x] something is wonky with cancellation, need to figure it out before this can merge. \n\nCo-authored-by: Jake Heinz <jh@discordapp.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cb85c14b622002767c66881c6a316a94e0f0be4", "html_url": "https://github.com/rust-lang/rust/commit/2cb85c14b622002767c66881c6a316a94e0f0be4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cb85c14b622002767c66881c6a316a94e0f0be4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f13d6af9ff59a07eb9d4e5b269c735bae17c372", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f13d6af9ff59a07eb9d4e5b269c735bae17c372", "html_url": "https://github.com/rust-lang/rust/commit/5f13d6af9ff59a07eb9d4e5b269c735bae17c372"}, {"sha": "25f67b6939ec84235b12a35c1e2176f3c68a6dea", "url": "https://api.github.com/repos/rust-lang/rust/commits/25f67b6939ec84235b12a35c1e2176f3c68a6dea", "html_url": "https://github.com/rust-lang/rust/commit/25f67b6939ec84235b12a35c1e2176f3c68a6dea"}], "stats": {"total": 322, "additions": 289, "deletions": 33}, "files": [{"sha": "6cbb1324e2e7df4a999a4eb129fac13cc4203cf3", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cb85c14b622002767c66881c6a316a94e0f0be4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2cb85c14b622002767c66881c6a316a94e0f0be4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2cb85c14b622002767c66881c6a316a94e0f0be4", "patch": "@@ -597,6 +597,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"cfg\",\n  \"cov-mark\",\n+ \"crossbeam-channel\",\n  \"dot\",\n  \"either\",\n  \"expect-test\",\n@@ -1367,6 +1368,7 @@ dependencies = [\n  \"lsp-types\",\n  \"mbe\",\n  \"mimalloc\",\n+ \"num_cpus\",\n  \"oorandom\",\n  \"parking_lot\",\n  \"proc_macro_api\","}, {"sha": "250673d3fe7ef9df27055b988706481204f5e78d", "filename": "crates/ide/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cb85c14b622002767c66881c6a316a94e0f0be4/crates%2Fide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2cb85c14b622002767c66881c6a316a94e0f0be4/crates%2Fide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2FCargo.toml?ref=2cb85c14b622002767c66881c6a316a94e0f0be4", "patch": "@@ -11,6 +11,7 @@ doctest = false\n \n [dependencies]\n cov-mark = \"2.0.0-pre.1\"\n+crossbeam-channel = \"0.5.0\"\n either = \"1.5.3\"\n itertools = \"0.10.0\"\n tracing = \"0.1\""}, {"sha": "4028b0bc7257053c929d46f1a67eaf45fbcd554e", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2cb85c14b622002767c66881c6a316a94e0f0be4/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb85c14b622002767c66881c6a316a94e0f0be4/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=2cb85c14b622002767c66881c6a316a94e0f0be4", "patch": "@@ -87,7 +87,7 @@ pub use crate::{\n     moniker::{MonikerKind, MonikerResult, PackageInformation},\n     move_item::Direction,\n     navigation_target::NavigationTarget,\n-    prime_caches::PrimeCachesProgress,\n+    prime_caches::ParallelPrimeCachesProgress,\n     references::ReferenceSearchResult,\n     rename::RenameError,\n     runnables::{Runnable, RunnableKind, TestId},\n@@ -244,11 +244,11 @@ impl Analysis {\n         self.with_db(|db| status::status(&*db, file_id))\n     }\n \n-    pub fn prime_caches<F>(&self, cb: F) -> Cancellable<()>\n+    pub fn parallel_prime_caches<F>(&self, num_worker_threads: u8, cb: F) -> Cancellable<()>\n     where\n-        F: Fn(PrimeCachesProgress) + Sync + std::panic::UnwindSafe,\n+        F: Fn(ParallelPrimeCachesProgress) + Sync + std::panic::UnwindSafe,\n     {\n-        self.with_db(move |db| prime_caches::prime_caches(db, &cb))\n+        self.with_db(move |db| prime_caches::parallel_prime_caches(db, num_worker_threads, &cb))\n     }\n \n     /// Gets the text of the source file."}, {"sha": "892b34c7d909d22f43f1e0d551dc0644b994c573", "filename": "crates/ide/src/prime_caches.rs", "status": "modified", "additions": 132, "deletions": 21, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/2cb85c14b622002767c66881c6a316a94e0f0be4/crates%2Fide%2Fsrc%2Fprime_caches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb85c14b622002767c66881c6a316a94e0f0be4/crates%2Fide%2Fsrc%2Fprime_caches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fprime_caches.rs?ref=2cb85c14b622002767c66881c6a316a94e0f0be4", "patch": "@@ -2,47 +2,158 @@\n //! sometimes is counter productive when, for example, the first goto definition\n //! request takes longer to compute. This modules implemented prepopulation of\n //! various caches, it's not really advanced at the moment.\n+mod topologic_sort;\n+\n+use std::time::Duration;\n \n use hir::db::DefDatabase;\n-use ide_db::base_db::{SourceDatabase, SourceDatabaseExt};\n+use ide_db::{\n+    base_db::{\n+        salsa::{Database, ParallelDatabase, Snapshot},\n+        Cancelled, CrateGraph, CrateId, SourceDatabase, SourceDatabaseExt,\n+    },\n+    FxIndexMap,\n+};\n use rustc_hash::FxHashSet;\n \n use crate::RootDatabase;\n \n-/// We started indexing a crate.\n+/// We're indexing many crates.\n #[derive(Debug)]\n-pub struct PrimeCachesProgress {\n-    pub on_crate: String,\n-    pub n_done: usize,\n-    pub n_total: usize,\n+pub struct ParallelPrimeCachesProgress {\n+    /// the crates that we are currently priming.\n+    pub crates_currently_indexing: Vec<String>,\n+    /// the total number of crates we want to prime.\n+    pub crates_total: usize,\n+    /// the total number of crates that have finished priming\n+    pub crates_done: usize,\n }\n \n-pub(crate) fn prime_caches(db: &RootDatabase, cb: &(dyn Fn(PrimeCachesProgress) + Sync)) {\n+pub(crate) fn parallel_prime_caches(\n+    db: &RootDatabase,\n+    num_worker_threads: u8,\n+    cb: &(dyn Fn(ParallelPrimeCachesProgress) + Sync),\n+) {\n     let _p = profile::span(\"prime_caches\");\n+\n     let graph = db.crate_graph();\n+    let mut crates_to_prime = {\n+        let crate_ids = compute_crates_to_prime(db, &graph);\n+\n+        let mut builder = topologic_sort::TopologicalSortIter::builder();\n+\n+        for &crate_id in &crate_ids {\n+            let crate_data = &graph[crate_id];\n+            let dependencies = crate_data\n+                .dependencies\n+                .iter()\n+                .map(|d| d.crate_id)\n+                .filter(|i| crate_ids.contains(i));\n+\n+            builder.add(crate_id, dependencies);\n+        }\n+\n+        builder.build()\n+    };\n+\n+    enum ParallelPrimeCacheWorkerProgress {\n+        BeginCrate { crate_id: CrateId, crate_name: String },\n+        EndCrate { crate_id: CrateId },\n+    }\n+\n+    let (work_sender, progress_receiver) = {\n+        let (progress_sender, progress_receiver) = crossbeam_channel::unbounded();\n+        let (work_sender, work_receiver) = crossbeam_channel::unbounded();\n+        let prime_caches_worker = move |db: Snapshot<RootDatabase>| {\n+            while let Ok((crate_id, crate_name)) = work_receiver.recv() {\n+                progress_sender\n+                    .send(ParallelPrimeCacheWorkerProgress::BeginCrate { crate_id, crate_name })?;\n+\n+                // This also computes the DefMap\n+                db.import_map(crate_id);\n+\n+                progress_sender.send(ParallelPrimeCacheWorkerProgress::EndCrate { crate_id })?;\n+            }\n+\n+            Ok::<_, crossbeam_channel::SendError<_>>(())\n+        };\n+\n+        for _ in 0..num_worker_threads {\n+            let worker = prime_caches_worker.clone();\n+            let db = db.snapshot();\n+            std::thread::spawn(move || Cancelled::catch(|| worker(db)));\n+        }\n+\n+        (work_sender, progress_receiver)\n+    };\n+\n+    let crates_total = crates_to_prime.pending();\n+    let mut crates_done = 0;\n+\n+    // an index map is used to preserve ordering so we can sort the progress report in order of\n+    // \"longest crate to index\" first\n+    let mut crates_currently_indexing =\n+        FxIndexMap::with_capacity_and_hasher(num_worker_threads as _, Default::default());\n+\n+    while crates_done < crates_total {\n+        db.unwind_if_cancelled();\n+\n+        for crate_id in &mut crates_to_prime {\n+            work_sender\n+                .send((\n+                    crate_id,\n+                    graph[crate_id].display_name.as_deref().unwrap_or_default().to_string(),\n+                ))\n+                .ok();\n+        }\n+\n+        // recv_timeout is somewhat a hack, we need a way to from this thread check to see if the current salsa revision\n+        // is cancelled on a regular basis. workers will only exit if they are processing a task that is cancelled, or\n+        // if this thread exits, and closes the work channel.\n+        let worker_progress = match progress_receiver.recv_timeout(Duration::from_millis(10)) {\n+            Ok(p) => p,\n+            Err(crossbeam_channel::RecvTimeoutError::Timeout) => {\n+                continue;\n+            }\n+            Err(crossbeam_channel::RecvTimeoutError::Disconnected) => {\n+                // our workers may have died from a cancelled task, so we'll check and re-raise here.\n+                db.unwind_if_cancelled();\n+                break;\n+            }\n+        };\n+        match worker_progress {\n+            ParallelPrimeCacheWorkerProgress::BeginCrate { crate_id, crate_name } => {\n+                crates_currently_indexing.insert(crate_id, crate_name);\n+            }\n+            ParallelPrimeCacheWorkerProgress::EndCrate { crate_id } => {\n+                crates_currently_indexing.remove(&crate_id);\n+                crates_to_prime.mark_done(crate_id);\n+                crates_done += 1;\n+            }\n+        };\n+\n+        let progress = ParallelPrimeCachesProgress {\n+            crates_currently_indexing: crates_currently_indexing.values().cloned().collect(),\n+            crates_done,\n+            crates_total,\n+        };\n+\n+        cb(progress);\n+    }\n+}\n+\n+fn compute_crates_to_prime(db: &RootDatabase, graph: &CrateGraph) -> FxHashSet<CrateId> {\n     // We're only interested in the workspace crates and the `ImportMap`s of their direct\n     // dependencies, though in practice the latter also compute the `DefMap`s.\n     // We don't prime transitive dependencies because they're generally not visible in\n     // the current workspace.\n-    let to_prime: FxHashSet<_> = graph\n+    graph\n         .iter()\n         .filter(|&id| {\n             let file_id = graph[id].root_file_id;\n             let root_id = db.file_source_root(file_id);\n             !db.source_root(root_id).is_library\n         })\n         .flat_map(|id| graph[id].dependencies.iter().map(|krate| krate.crate_id))\n-        .collect();\n-\n-    // FIXME: This would be easy to parallelize, since it's in the ideal ordering for that.\n-    // Unfortunately rayon prevents panics from propagation out of a `scope`, which breaks\n-    // cancellation, so we cannot use rayon.\n-    let n_total = to_prime.len();\n-    for (n_done, &crate_id) in to_prime.iter().enumerate() {\n-        let crate_name = graph[crate_id].display_name.as_deref().unwrap_or_default().to_string();\n-\n-        cb(PrimeCachesProgress { on_crate: crate_name, n_done, n_total });\n-        // This also computes the DefMap\n-        db.import_map(crate_id);\n-    }\n+        .collect()\n }"}, {"sha": "b04087fa7bd08cff417a85b95a43540cc2e7d98f", "filename": "crates/ide/src/prime_caches/topologic_sort.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/2cb85c14b622002767c66881c6a316a94e0f0be4/crates%2Fide%2Fsrc%2Fprime_caches%2Ftopologic_sort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb85c14b622002767c66881c6a316a94e0f0be4/crates%2Fide%2Fsrc%2Fprime_caches%2Ftopologic_sort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fprime_caches%2Ftopologic_sort.rs?ref=2cb85c14b622002767c66881c6a316a94e0f0be4", "patch": "@@ -0,0 +1,98 @@\n+//! helper data structure to schedule work for parallel prime caches.\n+use std::{collections::VecDeque, hash::Hash};\n+\n+use rustc_hash::FxHashMap;\n+\n+pub(crate) struct TopologicSortIterBuilder<T> {\n+    nodes: FxHashMap<T, Entry<T>>,\n+}\n+\n+impl<T> TopologicSortIterBuilder<T>\n+where\n+    T: Copy + Eq + PartialEq + Hash,\n+{\n+    fn new() -> Self {\n+        Self { nodes: Default::default() }\n+    }\n+\n+    fn get_or_create_entry(&mut self, item: T) -> &mut Entry<T> {\n+        self.nodes.entry(item).or_default()\n+    }\n+\n+    pub(crate) fn add(&mut self, item: T, predecessors: impl IntoIterator<Item = T>) {\n+        let mut num_predecessors = 0;\n+\n+        for predecessor in predecessors.into_iter() {\n+            self.get_or_create_entry(predecessor).successors.push(item);\n+            num_predecessors += 1;\n+        }\n+\n+        let entry = self.get_or_create_entry(item);\n+        entry.num_predecessors += num_predecessors;\n+    }\n+\n+    pub(crate) fn build(self) -> TopologicalSortIter<T> {\n+        let ready = self\n+            .nodes\n+            .iter()\n+            .filter_map(\n+                |(item, entry)| if entry.num_predecessors == 0 { Some(*item) } else { None },\n+            )\n+            .collect();\n+\n+        TopologicalSortIter { nodes: self.nodes, ready }\n+    }\n+}\n+\n+pub(crate) struct TopologicalSortIter<T> {\n+    ready: VecDeque<T>,\n+    nodes: FxHashMap<T, Entry<T>>,\n+}\n+\n+impl<T> TopologicalSortIter<T>\n+where\n+    T: Copy + Eq + PartialEq + Hash,\n+{\n+    pub(crate) fn builder() -> TopologicSortIterBuilder<T> {\n+        TopologicSortIterBuilder::new()\n+    }\n+\n+    pub(crate) fn pending(&self) -> usize {\n+        self.nodes.len()\n+    }\n+\n+    pub(crate) fn mark_done(&mut self, item: T) {\n+        let entry = self.nodes.remove(&item).expect(\"invariant: unknown item marked as done\");\n+\n+        for successor in entry.successors {\n+            let succ_entry = self\n+                .nodes\n+                .get_mut(&successor)\n+                .expect(\"invariant: unknown successor referenced by entry\");\n+\n+            succ_entry.num_predecessors -= 1;\n+            if succ_entry.num_predecessors == 0 {\n+                self.ready.push_back(successor);\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Iterator for TopologicalSortIter<T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.ready.pop_front()\n+    }\n+}\n+\n+struct Entry<T> {\n+    successors: Vec<T>,\n+    num_predecessors: usize,\n+}\n+\n+impl<T> Default for Entry<T> {\n+    fn default() -> Self {\n+        Self { successors: Default::default(), num_predecessors: 0 }\n+    }\n+}"}, {"sha": "014001397de4264826353ec8feec60406408a1cb", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cb85c14b622002767c66881c6a316a94e0f0be4/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2cb85c14b622002767c66881c6a316a94e0f0be4/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=2cb85c14b622002767c66881c6a316a94e0f0be4", "patch": "@@ -31,6 +31,7 @@ serde = { version = \"1.0.106\", features = [\"derive\"] }\n serde_json = { version = \"1.0.48\", features = [\"preserve_order\"] }\n threadpool = \"1.7.1\"\n rayon = \"1.5\"\n+num_cpus = \"1.13.1\"\n mimalloc = { version = \"0.1.19\", default-features = false, optional = true }\n lsp-server = \"0.5.1\"\n tracing = \"0.1\""}, {"sha": "490aef50f3e70c2f675e006b8498bec448a5cae7", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cb85c14b622002767c66881c6a316a94e0f0be4/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb85c14b622002767c66881c6a316a94e0f0be4/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=2cb85c14b622002767c66881c6a316a94e0f0be4", "patch": "@@ -88,7 +88,7 @@ pub fn load_workspace(\n         load_crate_graph(crate_graph, project_folders.source_root_config, &mut vfs, &receiver);\n \n     if load_config.prefill_caches {\n-        host.analysis().prime_caches(|_| {})?;\n+        host.analysis().parallel_prime_caches(1, |_| {})?;\n     }\n     Ok((host, vfs, proc_macro_client))\n }"}, {"sha": "76b72707974cf1795bfd6c51e19f7fecd32e57f3", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2cb85c14b622002767c66881c6a316a94e0f0be4/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb85c14b622002767c66881c6a316a94e0f0be4/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=2cb85c14b622002767c66881c6a316a94e0f0be4", "patch": "@@ -298,6 +298,9 @@ config_data! {\n         /// Whether to show `can't find Cargo.toml` error message.\n         notifications_cargoTomlNotFound: bool      = \"true\",\n \n+        /// How many worker threads to to handle priming caches. The default `0` means to pick automatically.\n+        primeCaches_numThreads: ParallelPrimeCachesNumThreads = \"0\",\n+\n         /// Enable support for procedural macros, implies `#rust-analyzer.cargo.runBuildScripts#`.\n         procMacro_enable: bool                     = \"true\",\n         /// Internal config, path to proc-macro server executable (typically,\n@@ -1016,6 +1019,13 @@ impl Config {\n             yield_points: self.data.highlightRelated_yieldPoints,\n         }\n     }\n+\n+    pub fn prime_caches_num_threads(&self) -> u8 {\n+        match self.data.primeCaches_numThreads {\n+            0 => num_cpus::get_physical().try_into().unwrap_or(u8::MAX),\n+            n => n,\n+        }\n+    }\n }\n \n #[derive(Deserialize, Debug, Clone, Copy)]\n@@ -1130,6 +1140,8 @@ enum WorkspaceSymbolSearchKindDef {\n     AllSymbols,\n }\n \n+type ParallelPrimeCachesNumThreads = u8;\n+\n macro_rules! _config_data {\n     (struct $name:ident {\n         $(\n@@ -1351,6 +1363,11 @@ fn field_props(field: &str, ty: &str, doc: &[&str], default: &str) -> serde_json\n                 \"Search for all symbols kinds\"\n             ],\n         },\n+        \"ParallelPrimeCachesNumThreads\" => set! {\n+            \"type\": \"number\",\n+            \"minimum\": 0,\n+            \"maximum\": 255\n+        },\n         _ => panic!(\"{}: {}\", ty, default),\n     }\n "}, {"sha": "5bec301736ac0968a56abb8645820a4e80a6edfa", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2cb85c14b622002767c66881c6a316a94e0f0be4/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb85c14b622002767c66881c6a316a94e0f0be4/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=2cb85c14b622002767c66881c6a316a94e0f0be4", "patch": "@@ -70,7 +70,7 @@ pub(crate) enum Task {\n #[derive(Debug)]\n pub(crate) enum PrimeCachesProgress {\n     Begin,\n-    Report(ide::PrimeCachesProgress),\n+    Report(ide::ParallelPrimeCachesProgress),\n     End { cancelled: bool },\n }\n \n@@ -291,11 +291,23 @@ impl GlobalState {\n                         }\n                         PrimeCachesProgress::Report(report) => {\n                             state = Progress::Report;\n-                            message = Some(format!(\n-                                \"{}/{} ({})\",\n-                                report.n_done, report.n_total, report.on_crate\n-                            ));\n-                            fraction = Progress::fraction(report.n_done, report.n_total);\n+\n+                            message = match &report.crates_currently_indexing[..] {\n+                                [crate_name] => Some(format!(\n+                                    \"{}/{} ({})\",\n+                                    report.crates_done, report.crates_total, crate_name\n+                                )),\n+                                [crate_name, rest @ ..] => Some(format!(\n+                                    \"{}/{} ({} + {} more)\",\n+                                    report.crates_done,\n+                                    report.crates_total,\n+                                    crate_name,\n+                                    rest.len()\n+                                )),\n+                                _ => None,\n+                            };\n+\n+                            fraction = Progress::fraction(report.crates_done, report.crates_total);\n                         }\n                         PrimeCachesProgress::End { cancelled } => {\n                             state = Progress::End;\n@@ -493,11 +505,13 @@ impl GlobalState {\n             self.fetch_build_data();\n         }\n         if self.prime_caches_queue.should_start_op() {\n+            let num_worker_threads = self.config.prime_caches_num_threads();\n+\n             self.task_pool.handle.spawn_with_sender({\n                 let analysis = self.snapshot().analysis;\n                 move |sender| {\n                     sender.send(Task::PrimeCaches(PrimeCachesProgress::Begin)).unwrap();\n-                    let res = analysis.prime_caches(|progress| {\n+                    let res = analysis.parallel_prime_caches(num_worker_threads, |progress| {\n                         let report = PrimeCachesProgress::Report(progress);\n                         sender.send(Task::PrimeCaches(report)).unwrap();\n                     });"}, {"sha": "b10b0d355222d4307a541539af468c2c359be3bd", "filename": "docs/user/generated_config.adoc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2cb85c14b622002767c66881c6a316a94e0f0be4/docs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/2cb85c14b622002767c66881c6a316a94e0f0be4/docs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_config.adoc?ref=2cb85c14b622002767c66881c6a316a94e0f0be4", "patch": "@@ -454,6 +454,11 @@ Number of syntax trees rust-analyzer keeps in memory. Defaults to 128.\n --\n Whether to show `can't find Cargo.toml` error message.\n --\n+[[rust-analyzer.primeCaches.numThreads]]rust-analyzer.primeCaches.numThreads (default: `0`)::\n++\n+--\n+How many worker threads to to handle priming caches. The default `0` means to pick automatically.\n+--\n [[rust-analyzer.procMacro.enable]]rust-analyzer.procMacro.enable (default: `true`)::\n +\n --"}, {"sha": "8f4157da0d15ddfca11f144d0e05676ab0bbafae", "filename": "editors/code/package.json", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2cb85c14b622002767c66881c6a316a94e0f0be4/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/2cb85c14b622002767c66881c6a316a94e0f0be4/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=2cb85c14b622002767c66881c6a316a94e0f0be4", "patch": "@@ -880,6 +880,13 @@\n                     \"default\": true,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.primeCaches.numThreads\": {\n+                    \"markdownDescription\": \"How many worker threads to to handle priming caches. The default `0` means to pick automatically.\",\n+                    \"default\": 0,\n+                    \"type\": \"number\",\n+                    \"minimum\": 0,\n+                    \"maximum\": 255\n+                },\n                 \"rust-analyzer.procMacro.enable\": {\n                     \"markdownDescription\": \"Enable support for procedural macros, implies `#rust-analyzer.cargo.runBuildScripts#`.\",\n                     \"default\": true,"}]}