{"sha": "024b3d2b453ee116c26c3f765839ab4d60c23df9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyNGIzZDJiNDUzZWUxMTZjMjZjM2Y3NjU4MzlhYjRkNjBjMjNkZjk=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-06-11T22:46:01Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-06-11T22:46:01Z"}, "message": "Merge remote-tracking branch 'oli/function_pointers2' into fixup-function_pointers2", "tree": {"sha": "232a2de9cb32854dbce1d145cc33b26ca0458c4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/232a2de9cb32854dbce1d145cc33b26ca0458c4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/024b3d2b453ee116c26c3f765839ab4d60c23df9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/024b3d2b453ee116c26c3f765839ab4d60c23df9", "html_url": "https://github.com/rust-lang/rust/commit/024b3d2b453ee116c26c3f765839ab4d60c23df9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/024b3d2b453ee116c26c3f765839ab4d60c23df9/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c58b7c2ed7a1c8f145c9410cb6a4d0e861b220a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c58b7c2ed7a1c8f145c9410cb6a4d0e861b220a", "html_url": "https://github.com/rust-lang/rust/commit/1c58b7c2ed7a1c8f145c9410cb6a4d0e861b220a"}, {"sha": "384623daa7ca04352fc57cb2f31790961ac27e21", "url": "https://api.github.com/repos/rust-lang/rust/commits/384623daa7ca04352fc57cb2f31790961ac27e21", "html_url": "https://github.com/rust-lang/rust/commit/384623daa7ca04352fc57cb2f31790961ac27e21"}], "stats": {"total": 283, "additions": 190, "deletions": 93}, "files": [{"sha": "a4ae8cbdda25b46855a75464896db68820dd3c06", "filename": "src/error.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/024b3d2b453ee116c26c3f765839ab4d60c23df9/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/024b3d2b453ee116c26c3f765839ab4d60c23df9/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=024b3d2b453ee116c26c3f765839ab4d60c23df9", "patch": "@@ -6,6 +6,7 @@ use memory::Pointer;\n #[derive(Clone, Debug)]\n pub enum EvalError {\n     DanglingPointerDeref,\n+    InvalidFunctionPointer,\n     InvalidBool,\n     InvalidDiscriminant,\n     PointerOutOfBounds {\n@@ -28,6 +29,8 @@ impl Error for EvalError {\n         match *self {\n             EvalError::DanglingPointerDeref =>\n                 \"dangling pointer was dereferenced\",\n+            EvalError::InvalidFunctionPointer =>\n+                \"tried to use a pointer as a function pointer\",\n             EvalError::InvalidBool =>\n                 \"invalid boolean value read\",\n             EvalError::InvalidDiscriminant =>"}, {"sha": "251ebb768e0d6a3f7405c65fd1c2ae3e46a5fca3", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 115, "deletions": 85, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/024b3d2b453ee116c26c3f765839ab4d60c23df9/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/024b3d2b453ee116c26c3f765839ab4d60c23df9/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=024b3d2b453ee116c26c3f765839ab4d60c23df9", "patch": "@@ -6,7 +6,7 @@ use rustc::traits::{self, ProjectionMode};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::layout::{self, Layout, Size};\n use rustc::ty::subst::{self, Subst, Substs};\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, BareFnTy};\n use rustc::util::nodemap::DefIdMap;\n use rustc_data_structures::indexed_vec::Idx;\n use std::cell::RefCell;\n@@ -15,7 +15,7 @@ use std::rc::Rc;\n use std::{iter, mem};\n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap::{self, DUMMY_SP};\n+use syntax::codemap::{self, DUMMY_SP, Span};\n \n use error::{EvalError, EvalResult};\n use memory::{Memory, Pointer};\n@@ -40,7 +40,7 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n     mir_cache: RefCell<DefIdMap<Rc<mir::Mir<'tcx>>>>,\n \n     /// The virtual memory system.\n-    memory: Memory,\n+    memory: Memory<'tcx>,\n \n     /// Precomputed statics, constants and promoteds\n     statics: HashMap<ConstantId<'tcx>, Pointer>,\n@@ -283,6 +283,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn load_mir(&self, def_id: DefId) -> CachedMir<'a, 'tcx> {\n+        use rustc_trans::back::symbol_names::def_id_to_string;\n         match self.tcx.map.as_local_node_id(def_id) {\n             Some(node_id) => CachedMir::Ref(self.mir_map.map.get(&node_id).unwrap()),\n             None => {\n@@ -293,7 +294,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let cs = &self.tcx.sess.cstore;\n                 let mir = cs.maybe_get_item_mir(self.tcx, def_id).unwrap_or_else(|| {\n-                    panic!(\"no mir for {:?}\", def_id);\n+                    panic!(\"no mir for `{}`\", def_id_to_string(self.tcx, def_id));\n                 });\n                 let cached = Rc::new(mir);\n                 mir_cache.insert(def_id, cached.clone());\n@@ -421,84 +422,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let func_ty = self.operand_ty(func);\n                 match func_ty.sty {\n+                    ty::TyFnPtr(bare_fn_ty) => {\n+                        let ptr = self.eval_operand(func)?;\n+                        assert_eq!(ptr.offset, 0);\n+                        let fn_ptr = self.memory.read_ptr(ptr)?;\n+                        let (def_id, substs) = self.memory.get_fn(fn_ptr.alloc_id)?;\n+                        self.eval_fn_call(def_id, substs, bare_fn_ty, return_ptr, args,\n+                                          terminator.source_info.span)?\n+                    },\n                     ty::TyFnDef(def_id, substs, fn_ty) => {\n-                        use syntax::abi::Abi;\n-                        match fn_ty.abi {\n-                            Abi::RustIntrinsic => {\n-                                let name = self.tcx.item_name(def_id).as_str();\n-                                match fn_ty.sig.0.output {\n-                                    ty::FnConverging(ty) => {\n-                                        let size = self.type_size(ty, self.substs());\n-                                        let ret = return_ptr.unwrap();\n-                                        self.call_intrinsic(&name, substs, args, ret, size)?\n-                                    }\n-                                    ty::FnDiverging => unimplemented!(),\n-                                }\n-                            }\n-\n-                            Abi::C => {\n-                                match fn_ty.sig.0.output {\n-                                    ty::FnConverging(ty) => {\n-                                        let size = self.type_size(ty, self.substs());\n-                                        self.call_c_abi(def_id, args, return_ptr.unwrap(), size)?\n-                                    }\n-                                    ty::FnDiverging => unimplemented!(),\n-                                }\n-                            }\n-\n-                            Abi::Rust | Abi::RustCall => {\n-                                // TODO(solson): Adjust the first argument when calling a Fn or\n-                                // FnMut closure via FnOnce::call_once.\n-\n-                                // Only trait methods can have a Self parameter.\n-                                let (resolved_def_id, resolved_substs) = if substs.self_ty().is_some() {\n-                                    self.trait_method(def_id, substs)\n-                                } else {\n-                                    (def_id, substs)\n-                                };\n-\n-                                let mut arg_srcs = Vec::new();\n-                                for arg in args {\n-                                    let src = self.eval_operand(arg)?;\n-                                    let src_ty = self.operand_ty(arg);\n-                                    arg_srcs.push((src, src_ty));\n-                                }\n-\n-                                if fn_ty.abi == Abi::RustCall && !args.is_empty() {\n-                                    arg_srcs.pop();\n-                                    let last_arg = args.last().unwrap();\n-                                    let last = self.eval_operand(last_arg)?;\n-                                    let last_ty = self.operand_ty(last_arg);\n-                                    let last_layout = self.type_layout(last_ty, self.substs());\n-                                    match (&last_ty.sty, last_layout) {\n-                                        (&ty::TyTuple(fields),\n-                                         &Layout::Univariant { ref variant, .. }) => {\n-                                            let offsets = iter::once(0)\n-                                                .chain(variant.offset_after_field.iter()\n-                                                    .map(|s| s.bytes()));\n-                                            for (offset, ty) in offsets.zip(fields) {\n-                                                let src = last.offset(offset as isize);\n-                                                arg_srcs.push((src, ty));\n-                                            }\n-                                        }\n-                                        ty => panic!(\"expected tuple as last argument in function with 'rust-call' ABI, got {:?}\", ty),\n-                                    }\n-                                }\n-\n-                                let mir = self.load_mir(resolved_def_id);\n-                                self.push_stack_frame(\n-                                    def_id, terminator.source_info.span, mir, resolved_substs,\n-                                    return_ptr\n-                                );\n-\n-                                for (i, (src, src_ty)) in arg_srcs.into_iter().enumerate() {\n-                                    let dest = self.frame().locals[i];\n-                                    self.move_(src, dest, src_ty)?;\n-                                }\n-                            }\n-\n-                            abi => return Err(EvalError::Unimplemented(format!(\"can't handle function with {:?} ABI\", abi))),\n-                        }\n+                        self.eval_fn_call(def_id, substs, fn_ty, return_ptr, args,\n+                                          terminator.source_info.span)?\n                     }\n \n                     _ => return Err(EvalError::Unimplemented(format!(\"can't handle callee of type {:?}\", func_ty))),\n@@ -530,6 +464,93 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n+    pub fn eval_fn_call(\n+        &mut self,\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>,\n+        fn_ty: &'tcx BareFnTy,\n+        return_ptr: Option<Pointer>,\n+        args: &[mir::Operand<'tcx>],\n+        span: Span,\n+    ) -> EvalResult<()> {\n+        use syntax::abi::Abi;\n+        match fn_ty.abi {\n+            Abi::RustIntrinsic => {\n+                let name = self.tcx.item_name(def_id).as_str();\n+                match fn_ty.sig.0.output {\n+                    ty::FnConverging(ty) => {\n+                        let size = self.type_size(ty, self.substs());\n+                        let ret = return_ptr.unwrap();\n+                        self.call_intrinsic(&name, substs, args, ret, size)\n+                    }\n+                    ty::FnDiverging => unimplemented!(),\n+                }\n+            }\n+\n+            Abi::C => {\n+                match fn_ty.sig.0.output {\n+                    ty::FnConverging(ty) => {\n+                        let size = self.type_size(ty, self.substs());\n+                        self.call_c_abi(def_id, args, return_ptr.unwrap(), size)\n+                    }\n+                    ty::FnDiverging => unimplemented!(),\n+                }\n+            }\n+\n+            Abi::Rust | Abi::RustCall => {\n+                // TODO(solson): Adjust the first argument when calling a Fn or\n+                // FnMut closure via FnOnce::call_once.\n+\n+                // Only trait methods can have a Self parameter.\n+                let (resolved_def_id, resolved_substs) = if substs.self_ty().is_some() {\n+                    self.trait_method(def_id, substs)\n+                } else {\n+                    (def_id, substs)\n+                };\n+\n+                let mut arg_srcs = Vec::new();\n+                for arg in args {\n+                    let src = self.eval_operand(arg)?;\n+                    let src_ty = self.operand_ty(arg);\n+                    arg_srcs.push((src, src_ty));\n+                }\n+\n+                if fn_ty.abi == Abi::RustCall && !args.is_empty() {\n+                    arg_srcs.pop();\n+                    let last_arg = args.last().unwrap();\n+                    let last = self.eval_operand(last_arg)?;\n+                    let last_ty = self.operand_ty(last_arg);\n+                    let last_layout = self.type_layout(last_ty, self.substs());\n+                    match (&last_ty.sty, last_layout) {\n+                        (&ty::TyTuple(fields),\n+                         &Layout::Univariant { ref variant, .. }) => {\n+                            let offsets = iter::once(0)\n+                                .chain(variant.offset_after_field.iter()\n+                                    .map(|s| s.bytes()));\n+                            for (offset, ty) in offsets.zip(fields) {\n+                                let src = last.offset(offset as isize);\n+                                arg_srcs.push((src, ty));\n+                            }\n+                        }\n+                        ty => panic!(\"expected tuple as last argument in function with 'rust-call' ABI, got {:?}\", ty),\n+                    }\n+                }\n+\n+                let mir = self.load_mir(resolved_def_id);\n+                self.push_stack_frame(def_id, span, mir, resolved_substs, return_ptr);\n+\n+                for (i, (src, src_ty)) in arg_srcs.into_iter().enumerate() {\n+                    let dest = self.frame().locals[i];\n+                    self.move_(src, dest, src_ty)?;\n+                }\n+\n+                Ok(())\n+            }\n+\n+            abi => Err(EvalError::Unimplemented(format!(\"can't handle function with {:?} ABI\", abi))),\n+        }\n+    }\n+\n     fn drop(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<()> {\n         if !self.type_needs_drop(ty) {\n             debug!(\"no need to drop {:?}\", ty);\n@@ -1023,12 +1044,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Cast(kind, ref operand, dest_ty) => {\n-                let src = self.eval_operand(operand)?;\n-                let src_ty = self.operand_ty(operand);\n-\n                 use rustc::mir::repr::CastKind::*;\n                 match kind {\n                     Unsize => {\n+                        let src = self.eval_operand(operand)?;\n+                        let src_ty = self.operand_ty(operand);\n                         self.move_(src, dest, src_ty)?;\n                         let src_pointee_ty = pointee_type(src_ty).unwrap();\n                         let dest_pointee_ty = pointee_type(dest_ty).unwrap();\n@@ -1044,11 +1064,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n \n                     Misc => {\n+                        let src = self.eval_operand(operand)?;\n                         // FIXME(solson): Wrong for almost everything.\n                         let size = dest_layout.size(&self.tcx.data_layout).bytes() as usize;\n                         self.memory.copy(src, dest, size)?;\n                     }\n \n+                    ReifyFnPointer => match self.operand_ty(operand).sty {\n+                        ty::TyFnDef(def_id, substs, _) => {\n+                            let fn_ptr = self.memory.create_fn_ptr(def_id, substs);\n+                            self.memory.write_ptr(dest, fn_ptr)?;\n+                        },\n+                        ref other => panic!(\"reify fn pointer on {:?}\", other),\n+                    },\n+\n                     _ => return Err(EvalError::Unimplemented(format!(\"can't handle cast: {:?}\", rvalue))),\n                 }\n             }\n@@ -1136,7 +1165,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Value { ref value } => Ok(self.const_to_ptr(value)?),\n                     Item { def_id, substs } => {\n                         if let ty::TyFnDef(..) = ty.sty {\n-                            Err(EvalError::Unimplemented(\"unimplemented: mentions of function items\".to_string()))\n+                            // function items are zero sized\n+                            Ok(self.memory.allocate(0))\n                         } else {\n                             let cid = ConstantId {\n                                 def_id: def_id,"}, {"sha": "8603054d124c25fb57e89191f3516314959ddb1b", "filename": "src/interpreter/stepper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/024b3d2b453ee116c26c3f765839ab4d60c23df9/src%2Finterpreter%2Fstepper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/024b3d2b453ee116c26c3f765839ab4d60c23df9/src%2Finterpreter%2Fstepper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstepper.rs?ref=024b3d2b453ee116c26c3f765839ab4d60c23df9", "patch": "@@ -129,7 +129,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n             mir::Literal::Value { .. } => {}\n             mir::Literal::Item { def_id, substs } => {\n                 if let ty::TyFnDef(..) = constant.ty.sty {\n-                    // No need to do anything here, even if function pointers are implemented,\n+                    // No need to do anything here,\n                     // because the type is the actual function, not the signature of the function.\n                     // Thus we can simply create a zero sized allocation in `evaluate_operand`\n                 } else {"}, {"sha": "4bc5a07e3c2f93213604fe3151cea87df9bf4495", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/024b3d2b453ee116c26c3f765839ab4d60c23df9/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/024b3d2b453ee116c26c3f765839ab4d60c23df9/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=024b3d2b453ee116c26c3f765839ab4d60c23df9", "patch": "@@ -13,6 +13,7 @@\n #[macro_use] extern crate rustc;\n extern crate rustc_data_structures;\n extern crate rustc_mir;\n+extern crate rustc_trans;\n extern crate syntax;\n #[macro_use] extern crate log;\n extern crate log_settings;"}, {"sha": "d9999821e1b033f26a18734bc339961e77860ac9", "filename": "src/memory.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/024b3d2b453ee116c26c3f765839ab4d60c23df9/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/024b3d2b453ee116c26c3f765839ab4d60c23df9/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=024b3d2b453ee116c26c3f765839ab4d60c23df9", "patch": "@@ -3,6 +3,9 @@ use std::collections::Bound::{Included, Excluded};\n use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n use std::{fmt, iter, mem, ptr};\n \n+use rustc::hir::def_id::DefId;\n+use rustc::ty::subst::Substs;\n+\n use error::{EvalError, EvalResult};\n use primval::PrimVal;\n \n@@ -42,22 +45,37 @@ impl Pointer {\n // Top-level interpreter memory\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub struct Memory {\n+pub struct Memory<'tcx> {\n     alloc_map: HashMap<AllocId, Allocation>,\n+    functions: HashMap<AllocId, (DefId, &'tcx Substs<'tcx>)>,\n     next_id: AllocId,\n     pub pointer_size: usize,\n }\n \n-impl Memory {\n+impl<'tcx> Memory<'tcx> {\n     // FIXME: pass tcx.data_layout (This would also allow it to use primitive type alignments to diagnose unaligned memory accesses.)\n     pub fn new(pointer_size: usize) -> Self {\n         Memory {\n             alloc_map: HashMap::new(),\n+            functions: HashMap::new(),\n             next_id: AllocId(0),\n             pointer_size: pointer_size,\n         }\n     }\n \n+    // FIXME: never create two pointers to the same def_id + substs combination\n+    // maybe re-use the statics cache of the gecx?\n+    pub fn create_fn_ptr(&mut self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> Pointer {\n+        let id = self.next_id;\n+        debug!(\"creating fn ptr: {}\", id);\n+        self.next_id.0 += 1;\n+        self.functions.insert(id, (def_id, substs));\n+        Pointer {\n+            alloc_id: id,\n+            offset: 0,\n+        }\n+    }\n+\n     pub fn allocate(&mut self, size: usize) -> Pointer {\n         let alloc = Allocation {\n             bytes: vec![0; size],\n@@ -125,6 +143,11 @@ impl Memory {\n         self.alloc_map.get_mut(&id).ok_or(EvalError::DanglingPointerDeref)\n     }\n \n+    pub fn get_fn(&self, id: AllocId) -> EvalResult<(DefId, &'tcx Substs<'tcx>)> {\n+        debug!(\"reading fn ptr: {}\", id);\n+        self.functions.get(&id).map(|&did| did).ok_or(EvalError::InvalidFunctionPointer)\n+    }\n+\n     /// Print an allocation and all allocations it points to, recursively.\n     pub fn dump(&self, id: AllocId) {\n         let mut allocs_seen = HashSet::new();\n@@ -137,12 +160,18 @@ impl Memory {\n             print!(\"{}\", prefix);\n             let mut relocations = vec![];\n \n-            let alloc = match self.alloc_map.get(&id) {\n-                Some(a) => a,\n-                None => {\n+            let alloc = match (self.alloc_map.get(&id), self.functions.get(&id)) {\n+                (Some(a), None) => a,\n+                (None, Some(_)) => {\n+                    // FIXME: print function name\n+                    println!(\"function pointer\");\n+                    continue;\n+                },\n+                (None, None) => {\n                     println!(\"(deallocated)\");\n                     continue;\n-                }\n+                },\n+                (Some(_), Some(_)) => unreachable!(),\n             };\n \n             for i in 0..alloc.bytes.len() {"}, {"sha": "7752650ade8873f3dcf1c103ff5dfe5e18985c94", "filename": "tests/compile-fail/unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/024b3d2b453ee116c26c3f765839ab4d60c23df9/tests%2Fcompile-fail%2Funimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/024b3d2b453ee116c26c3f765839ab4d60c23df9/tests%2Fcompile-fail%2Funimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funimplemented.rs?ref=024b3d2b453ee116c26c3f765839ab4d60c23df9", "patch": "@@ -1,7 +1,7 @@\n #![feature(custom_attribute)]\n #![allow(dead_code, unused_attributes)]\n \n-//error-pattern:unimplemented: mentions of function items\n+//error-pattern:begin_panic_fmt\n \n \n #[miri_run]"}, {"sha": "55a6f9fbeac46266a9f24cfefb36fce7d428c324", "filename": "tests/run-pass/function_pointers.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/024b3d2b453ee116c26c3f765839ab4d60c23df9/tests%2Frun-pass%2Ffunction_pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/024b3d2b453ee116c26c3f765839ab4d60c23df9/tests%2Frun-pass%2Ffunction_pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffunction_pointers.rs?ref=024b3d2b453ee116c26c3f765839ab4d60c23df9", "patch": "@@ -0,0 +1,17 @@\n+#![feature(custom_attribute)]\n+#![allow(dead_code, unused_attributes)]\n+\n+fn f() -> i32 {\n+    42\n+}\n+\n+fn return_fn_ptr() -> fn() -> i32 {\n+    f\n+}\n+\n+#[miri_run]\n+fn call_fn_ptr() -> i32 {\n+    return_fn_ptr()()\n+}\n+\n+fn main() {}"}, {"sha": "d4f1d4023ba7f51e0d70e811ae008ab533747f3c", "filename": "tests/run-pass/zst.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/024b3d2b453ee116c26c3f765839ab4d60c23df9/tests%2Frun-pass%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/024b3d2b453ee116c26c3f765839ab4d60c23df9/tests%2Frun-pass%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fzst.rs?ref=024b3d2b453ee116c26c3f765839ab4d60c23df9", "patch": "@@ -0,0 +1,17 @@\n+#![feature(custom_attribute)]\n+#![allow(dead_code, unused_attributes)]\n+\n+struct A;\n+\n+#[miri_run]\n+fn zst_ret() -> A {\n+    A\n+}\n+\n+#[miri_run]\n+fn use_zst() -> A {\n+    let a = A;\n+    a\n+}\n+\n+fn main() {}"}]}