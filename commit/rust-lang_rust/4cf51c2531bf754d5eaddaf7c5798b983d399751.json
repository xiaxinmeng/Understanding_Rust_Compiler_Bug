{"sha": "4cf51c2531bf754d5eaddaf7c5798b983d399751", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjZjUxYzI1MzFiZjc1NGQ1ZWFkZGFmN2M1Nzk4Yjk4M2QzOTk3NTE=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2013-02-15T07:30:30Z"}, "committer": {"name": "Luqman Aden", "email": "laden@mozilla.com", "date": "2013-02-15T10:49:54Z"}, "message": "libstd: Get rid of `move`.", "tree": {"sha": "173c719a03882b7a83a0beb6005cbc2126efce9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/173c719a03882b7a83a0beb6005cbc2126efce9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cf51c2531bf754d5eaddaf7c5798b983d399751", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cf51c2531bf754d5eaddaf7c5798b983d399751", "html_url": "https://github.com/rust-lang/rust/commit/4cf51c2531bf754d5eaddaf7c5798b983d399751", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cf51c2531bf754d5eaddaf7c5798b983d399751/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9727008ed0772fc325e0822e74b429e4e7c09af0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9727008ed0772fc325e0822e74b429e4e7c09af0", "html_url": "https://github.com/rust-lang/rust/commit/9727008ed0772fc325e0822e74b429e4e7c09af0"}], "stats": {"total": 720, "additions": 357, "deletions": 363}, "files": [{"sha": "66b02ae553c4e7d9eb1d0c3e301094594ba9ace5", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -81,7 +81,7 @@ struct ARC<T> { x: SharedMutableState<T> }\n \n /// Create an atomically reference counted wrapper.\n pub fn ARC<T: Const Owned>(data: T) -> ARC<T> {\n-    ARC { x: unsafe { shared_mutable_state(move data) } }\n+    ARC { x: unsafe { shared_mutable_state(data) } }\n }\n \n /**\n@@ -113,8 +113,8 @@ pub fn clone<T: Const Owned>(rc: &ARC<T>) -> ARC<T> {\n  * guaranteed to deadlock.\n  */\n pub fn unwrap<T: Const Owned>(rc: ARC<T>) -> T {\n-    let ARC { x: x } = move rc;\n-    unsafe { unwrap_shared_mutable_state(move x) }\n+    let ARC { x: x } = rc;\n+    unsafe { unwrap_shared_mutable_state(x) }\n }\n \n impl<T: Const Owned> Clone for ARC<T> {\n@@ -134,7 +134,7 @@ struct MutexARC<T> { x: SharedMutableState<MutexARCInner<T>> }\n \n /// Create a mutex-protected ARC with the supplied data.\n pub fn MutexARC<T: Owned>(user_data: T) -> MutexARC<T> {\n-    mutex_arc_with_condvars(move user_data, 1)\n+    mutex_arc_with_condvars(user_data, 1)\n }\n /**\n  * Create a mutex-protected ARC with the supplied data and a specified number\n@@ -144,8 +144,8 @@ pub fn mutex_arc_with_condvars<T: Owned>(user_data: T,\n                                     num_condvars: uint) -> MutexARC<T> {\n     let data =\n         MutexARCInner { lock: mutex_with_condvars(num_condvars),\n-                          failed: false, data: move user_data };\n-    MutexARC { x: unsafe { shared_mutable_state(move data) } }\n+                          failed: false, data: user_data };\n+    MutexARC { x: unsafe { shared_mutable_state(data) } }\n }\n \n impl<T: Owned> Clone for MutexARC<T> {\n@@ -220,13 +220,13 @@ impl<T: Owned> &MutexARC<T> {\n  */\n // FIXME(#3724) make this a by-move method on the arc\n pub fn unwrap_mutex_arc<T: Owned>(arc: MutexARC<T>) -> T {\n-    let MutexARC { x: x } = move arc;\n-    let inner = unsafe { unwrap_shared_mutable_state(move x) };\n-    let MutexARCInner { failed: failed, data: data, _ } = move inner;\n+    let MutexARC { x: x } = arc;\n+    let inner = unsafe { unwrap_shared_mutable_state(x) };\n+    let MutexARCInner { failed: failed, data: data, _ } = inner;\n     if failed {\n         fail!(~\"Can't unwrap poisoned MutexARC - another task failed inside!\")\n     }\n-    move data\n+    data\n }\n \n // Common code for {mutex.access,rwlock.write}{,_cond}.\n@@ -284,7 +284,7 @@ struct RWARC<T> {\n \n /// Create a reader/writer ARC with the supplied data.\n pub fn RWARC<T: Const Owned>(user_data: T) -> RWARC<T> {\n-    rw_arc_with_condvars(move user_data, 1)\n+    rw_arc_with_condvars(user_data, 1)\n }\n /**\n  * Create a reader/writer ARC with the supplied data and a specified number\n@@ -296,8 +296,8 @@ pub fn rw_arc_with_condvars<T: Const Owned>(\n {\n     let data =\n         RWARCInner { lock: rwlock_with_condvars(num_condvars),\n-                     failed: false, data: move user_data };\n-    RWARC { x: unsafe { shared_mutable_state(move data) }, cant_nest: () }\n+                     failed: false, data: user_data };\n+    RWARC { x: unsafe { shared_mutable_state(data) }, cant_nest: () }\n }\n \n impl<T: Const Owned> RWARC<T> {\n@@ -386,7 +386,7 @@ impl<T: Const Owned> &RWARC<T> {\n             do (*borrow_rwlock(state)).write_downgrade |write_mode| {\n                 check_poison(false, (*state).failed);\n                 blk(RWWriteMode((&mut (*state).data,\n-                                 move write_mode,\n+                                 write_mode,\n                                  PoisonOnFail(&mut (*state).failed))))\n             }\n         }\n@@ -396,17 +396,17 @@ impl<T: Const Owned> &RWARC<T> {\n     fn downgrade(token: RWWriteMode/&a<T>) -> RWReadMode/&a<T> {\n         // The rwlock should assert that the token belongs to us for us.\n         let state = unsafe { get_shared_immutable_state(&self.x) };\n-        let RWWriteMode((data, t, _poison)) = move token;\n+        let RWWriteMode((data, t, _poison)) = token;\n         // Let readers in\n-        let new_token = (&state.lock).downgrade(move t);\n+        let new_token = (&state.lock).downgrade(t);\n         // Whatever region the input reference had, it will be safe to use\n         // the same region for the output reference. (The only 'unsafe' part\n         // of this cast is removing the mutability.)\n         let new_data = unsafe { cast::transmute_immut(data) };\n         // Downgrade ensured the token belonged to us. Just a sanity check.\n         assert ptr::ref_eq(&state.data, new_data);\n         // Produce new token\n-        RWReadMode((new_data, move new_token))\n+        RWReadMode((new_data, new_token))\n     }\n }\n \n@@ -419,13 +419,13 @@ impl<T: Const Owned> &RWARC<T> {\n  */\n // FIXME(#3724) make this a by-move method on the arc\n pub fn unwrap_rw_arc<T: Const Owned>(arc: RWARC<T>) -> T {\n-    let RWARC { x: x, _ } = move arc;\n-    let inner = unsafe { unwrap_shared_mutable_state(move x) };\n-    let RWARCInner { failed: failed, data: data, _ } = move inner;\n+    let RWARC { x: x, _ } = arc;\n+    let inner = unsafe { unwrap_shared_mutable_state(x) };\n+    let RWARCInner { failed: failed, data: data, _ } = inner;\n     if failed {\n         fail!(~\"Can't unwrap poisoned RWARC - another task failed inside!\")\n     }\n-    move data\n+    data\n }\n \n // Borrowck rightly complains about immutably aliasing the rwlock in order to\n@@ -509,7 +509,7 @@ mod tests {\n \n         let (p, c) = pipes::stream();\n \n-        do task::spawn() |move c| {\n+        do task::spawn() || {\n             let p = pipes::PortSet();\n             c.send(p.chan());\n \n@@ -532,8 +532,8 @@ mod tests {\n         let arc = ~MutexARC(false);\n         let arc2 = ~arc.clone();\n         let (p,c) = pipes::oneshot();\n-        let (c,p) = (~mut Some(move c), ~mut Some(move p));\n-        do task::spawn |move arc2, move p| {\n+        let (c,p) = (~mut Some(c), ~mut Some(p));\n+        do task::spawn || {\n             // wait until parent gets in\n             pipes::recv_one(option::swap_unwrap(p));\n             do arc2.access_cond |state, cond| {\n@@ -555,7 +555,7 @@ mod tests {\n         let arc2 = ~arc.clone();\n         let (p, c) = pipes::stream();\n \n-        do task::spawn_unlinked |move arc2, move p| {\n+        do task::spawn_unlinked || {\n             let _ = p.recv();\n             do arc2.access_cond |one, cond| {\n                 cond.signal();\n@@ -574,7 +574,7 @@ mod tests {\n     pub fn test_mutex_arc_poison() {\n         let arc = ~MutexARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try |move arc2| {\n+        do task::try || {\n             do arc2.access |one| {\n                 assert *one == 2;\n             }\n@@ -588,21 +588,21 @@ mod tests {\n         let arc = MutexARC(1);\n         let arc2 = ~(&arc).clone();\n         let (p, c) = pipes::stream();\n-        do task::spawn |move c, move arc2| {\n+        do task::spawn || {\n             do arc2.access |one| {\n                 c.send(());\n                 assert *one == 2;\n             }\n         }\n         let _ = p.recv();\n-        let one = unwrap_mutex_arc(move arc);\n+        let one = unwrap_mutex_arc(arc);\n         assert one == 1;\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     pub fn test_rw_arc_poison_wr() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try |move arc2| {\n+        do task::try || {\n             do arc2.write |one| {\n                 assert *one == 2;\n             }\n@@ -615,7 +615,7 @@ mod tests {\n     pub fn test_rw_arc_poison_ww() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try |move arc2| {\n+        do task::try || {\n             do arc2.write |one| {\n                 assert *one == 2;\n             }\n@@ -628,7 +628,7 @@ mod tests {\n     pub fn test_rw_arc_poison_dw() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try |move arc2| {\n+        do task::try || {\n             do arc2.write_downgrade |write_mode| {\n                 do (&write_mode).write |one| {\n                     assert *one == 2;\n@@ -643,7 +643,7 @@ mod tests {\n     pub fn test_rw_arc_no_poison_rr() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try |move arc2| {\n+        do task::try || {\n             do arc2.read |one| {\n                 assert *one == 2;\n             }\n@@ -656,7 +656,7 @@ mod tests {\n     pub fn test_rw_arc_no_poison_rw() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try |move arc2| {\n+        do task::try || {\n             do arc2.read |one| {\n                 assert *one == 2;\n             }\n@@ -669,9 +669,9 @@ mod tests {\n     pub fn test_rw_arc_no_poison_dr() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try |move arc2| {\n+        do task::try || {\n             do arc2.write_downgrade |write_mode| {\n-                let read_mode = arc2.downgrade(move write_mode);\n+                let read_mode = arc2.downgrade(write_mode);\n                 do (&read_mode).read |one| {\n                     assert *one == 2;\n                 }\n@@ -687,7 +687,7 @@ mod tests {\n         let arc2 = ~arc.clone();\n         let (p,c) = pipes::stream();\n \n-        do task::spawn |move arc2, move c| {\n+        do task::spawn || {\n             do arc2.write |num| {\n                 for 10.times {\n                     let tmp = *num;\n@@ -703,8 +703,8 @@ mod tests {\n         let mut children = ~[];\n         for 5.times {\n             let arc3 = ~arc.clone();\n-            do task::task().future_result(|+r| children.push(move r)).spawn\n-                |move arc3| {\n+            do task::task().future_result(|+r| children.push(r)).spawn\n+                || {\n                 do arc3.read |num| {\n                     assert *num >= 0;\n                 }\n@@ -732,9 +732,9 @@ mod tests {\n         let mut reader_convos = ~[];\n         for 10.times {\n             let ((rp1,rc1),(rp2,rc2)) = (pipes::stream(),pipes::stream());\n-            reader_convos.push((move rc1, move rp2));\n+            reader_convos.push((rc1, rp2));\n             let arcn = ~arc.clone();\n-            do task::spawn |move rp1, move rc2, move arcn| {\n+            do task::spawn || {\n                 rp1.recv(); // wait for downgrader to give go-ahead\n                 do arcn.read |state| {\n                     assert *state == 31337;\n@@ -746,7 +746,7 @@ mod tests {\n         // Writer task\n         let arc2 = ~arc.clone();\n         let ((wp1,wc1),(wp2,wc2)) = (pipes::stream(),pipes::stream());\n-        do task::spawn |move arc2, move wc2, move wp1| {\n+        do task::spawn || {\n             wp1.recv();\n             do arc2.write_cond |state, cond| {\n                 assert *state == 0;\n@@ -779,7 +779,7 @@ mod tests {\n                     }\n                 }\n             }\n-            let read_mode = arc.downgrade(move write_mode);\n+            let read_mode = arc.downgrade(write_mode);\n             do (&read_mode).read |state| {\n                 // complete handshake with other readers\n                 for vec::each(reader_convos) |x| {"}, {"sha": "75b97f494bd6f3c168f16a92ee59d56d17d2e421", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -108,7 +108,7 @@ struct BigBitv {\n }\n \n fn BigBitv(storage: ~[uint]) -> BigBitv {\n-    BigBitv {storage: move storage}\n+    BigBitv {storage: storage}\n }\n \n /**\n@@ -232,9 +232,9 @@ pub fn Bitv (nbits: uint, init: bool) -> Bitv {\n                      if nbits % uint_bits == 0 {0} else {1};\n         let elem = if init {!0} else {0};\n         let s = from_elem(nelems, elem);\n-        Big(~BigBitv(move s))\n+        Big(~BigBitv(s))\n     };\n-    Bitv {rep: move rep, nbits: nbits}\n+    Bitv {rep: rep, nbits: nbits}\n }\n \n priv impl Bitv {\n@@ -519,7 +519,7 @@ impl Clone for Bitv {\n             let mut st = from_elem(self.nbits / uint_bits + 1, 0);\n             let len = st.len();\n             for uint::range(0, len) |i| { st[i] = b.storage[i]; };\n-            Bitv{nbits: self.nbits, rep: Big(~BigBitv{storage: move st})}\n+            Bitv{nbits: self.nbits, rep: Big(~BigBitv{storage: st})}\n           }\n         }\n     }\n@@ -555,7 +555,7 @@ pub fn from_fn(len: uint, f: fn(index: uint) -> bool) -> Bitv {\n     for uint::range(0, len) |i| {\n         bitv.set(i, f(i));\n     }\n-    move bitv\n+    bitv\n }\n \n const uint_bits: uint = 32u + (1u << 32u >> 27u);"}, {"sha": "c8121daddabd03e423df8226d57e83d17c698541", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -21,7 +21,7 @@ pub struct Cell<T> {\n \n /// Creates a new full cell with the given value.\n pub fn Cell<T>(value: T) -> Cell<T> {\n-    Cell { value: Some(move value) }\n+    Cell { value: Some(value) }\n }\n \n pub pure fn empty_cell<T>() -> Cell<T> {\n@@ -37,15 +37,15 @@ impl<T> Cell<T> {\n \n         let mut value = None;\n         value <-> self.value;\n-        return option::unwrap(move value);\n+        return option::unwrap(value);\n     }\n \n     /// Returns the value, failing if the cell is full.\n     fn put_back(value: T) {\n         if !self.is_empty() {\n             fail!(~\"attempt to put a value back into a full cell\");\n         }\n-        self.value = Some(move value);\n+        self.value = Some(value);\n     }\n \n     /// Returns true if the cell is empty and false if the cell is full.\n@@ -57,8 +57,8 @@ impl<T> Cell<T> {\n     fn with_ref<R>(op: fn(v: &T) -> R) -> R {\n         let v = self.take();\n         let r = op(&v);\n-        self.put_back(move v);\n-        move r\n+        self.put_back(v);\n+        r\n     }\n }\n \n@@ -69,7 +69,7 @@ fn test_basic() {\n     let value = value_cell.take();\n     assert value == ~10;\n     assert value_cell.is_empty();\n-    value_cell.put_back(move value);\n+    value_cell.put_back(value);\n     assert !value_cell.is_empty();\n }\n "}, {"sha": "c2c21002b195da3373a7c4573363a3c4437e48a1", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -27,13 +27,13 @@ pub struct DuplexStream<T, U> {\n \n impl<T: Owned, U: Owned> GenericChan<T> for DuplexStream<T, U> {\n     fn send(x: T) {\n-        self.chan.send(move x)\n+        self.chan.send(x)\n     }\n }\n \n impl<T: Owned, U: Owned> GenericSmartChan<T> for DuplexStream<T, U> {\n     fn try_send(x: T) -> bool {\n-        self.chan.try_send(move x)\n+        self.chan.try_send(x)\n     }\n }\n \n@@ -66,12 +66,12 @@ pub fn DuplexStream<T: Owned, U: Owned>()\n     let (p1, c2) = pipes::stream();\n     let (p2, c1) = pipes::stream();\n     (DuplexStream {\n-        chan: move c1,\n-        port: move p1\n+        chan: c1,\n+        port: p1\n     },\n      DuplexStream {\n-         chan: move c2,\n-         port: move p2\n+         chan: c2,\n+         port: p2\n      })\n }\n "}, {"sha": "6d01a4418435884cb08bf0621f0be9a41bb6e576", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -41,7 +41,7 @@ pub fn create<T: Copy>() -> Deque<T> {\n       */\n     fn grow<T: Copy>(nelts: uint, lo: uint, elts: ~[Cell<T>])\n       -> ~[Cell<T>] {\n-        let mut elts = move elts;\n+        let mut elts = elts;\n         assert (nelts == vec::len(elts));\n         let mut rv = ~[];\n \n@@ -54,10 +54,10 @@ pub fn create<T: Copy>() -> Deque<T> {\n             i += 1u;\n         }\n \n-        move rv\n+        rv\n     }\n     fn get<T: Copy>(elts: &DVec<Cell<T>>, i: uint) -> T {\n-        match (*elts).get_elt(i) { Some(move t) => t, _ => fail!() }\n+        match (*elts).get_elt(i) { Some(t) => t, _ => fail!() }\n     }\n \n     struct Repr<T> {\n@@ -75,7 +75,7 @@ pub fn create<T: Copy>() -> Deque<T> {\n                 self.lo = self.elts.len() - 1u;\n             } else { self.lo -= 1u; }\n             if self.lo == self.hi {\n-                self.elts.swap(|v| grow(self.nelts, oldlo, move v));\n+                self.elts.swap(|v| grow(self.nelts, oldlo, v));\n                 self.lo = self.elts.len() - 1u;\n                 self.hi = self.nelts;\n             }\n@@ -84,7 +84,7 @@ pub fn create<T: Copy>() -> Deque<T> {\n         }\n         fn add_back(t: T) {\n             if self.lo == self.hi && self.nelts != 0u {\n-                self.elts.swap(|v| grow(self.nelts, self.lo, move v));\n+                self.elts.swap(|v| grow(self.nelts, self.lo, v));\n                 self.lo = 0u;\n                 self.hi = self.nelts;\n             }"}, {"sha": "600ff3338317467d8b3a3274fceaa219c31e9145", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -259,15 +259,15 @@ pub mod reader {\n             r_doc\n         }\n \n-        fn push_doc<T>(d: Doc, f: fn() -> T) -> T{\n+        fn push_doc<T>(d: Doc, f: fn() -> T) -> T {\n             let old_parent = self.parent;\n             let old_pos = self.pos;\n             self.parent = d;\n             self.pos = d.start;\n             let r = f();\n             self.parent = old_parent;\n             self.pos = old_pos;\n-            move r\n+            r\n         }\n \n         fn _next_uint(exp_tag: EbmlEncoderTag) -> uint {"}, {"sha": "d33ed4fd7cba952dce3a5a50a67d04db57d9283b", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 85, "deletions": 90, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -28,7 +28,7 @@ This example sends boxed integers across tasks using serialization.\n ~~~\n let (port, chan) = serial::pipe_stream();\n \n-do task::spawn |move chan| {\n+do task::spawn || {\n     for int::range(0, 10) |i| {\n         chan.send(@i)\n     }\n@@ -114,8 +114,8 @@ pub mod serial {\n         let unflat: DeserializingUnflattener<DefaultDecoder, T> =\n             DeserializingUnflattener::new(\n                 deserialize_buffer::<DefaultDecoder, T>);\n-        let byte_port = ReaderBytePort::new(move reader);\n-        FlatPort::new(move unflat, move byte_port)\n+        let byte_port = ReaderBytePort::new(reader);\n+        FlatPort::new(unflat, byte_port)\n     }\n \n     /// Create a `FlatChan` from a `Writer`\n@@ -124,8 +124,8 @@ pub mod serial {\n         let flat: SerializingFlattener<DefaultEncoder, T> =\n             SerializingFlattener::new(\n                 serialize_value::<DefaultEncoder, T>);\n-        let byte_chan = WriterByteChan::new(move writer);\n-        FlatChan::new(move flat, move byte_chan)\n+        let byte_chan = WriterByteChan::new(writer);\n+        FlatChan::new(flat, byte_chan)\n     }\n \n     /// Create a `FlatPort` from a `Port<~[u8]>`\n@@ -135,8 +135,8 @@ pub mod serial {\n         let unflat: DeserializingUnflattener<DefaultDecoder, T> =\n             DeserializingUnflattener::new(\n                 deserialize_buffer::<DefaultDecoder, T>);\n-        let byte_port = PipeBytePort::new(move port);\n-        FlatPort::new(move unflat, move byte_port)\n+        let byte_port = PipeBytePort::new(port);\n+        FlatPort::new(unflat, byte_port)\n     }\n \n     /// Create a `FlatChan` from a `Chan<~[u8]>`\n@@ -146,16 +146,16 @@ pub mod serial {\n         let flat: SerializingFlattener<DefaultEncoder, T> =\n             SerializingFlattener::new(\n                 serialize_value::<DefaultEncoder, T>);\n-        let byte_chan = PipeByteChan::new(move chan);\n-        FlatChan::new(move flat, move byte_chan)\n+        let byte_chan = PipeByteChan::new(chan);\n+        FlatChan::new(flat, byte_chan)\n     }\n \n     /// Create a pair of `FlatChan` and `FlatPort`, backed by pipes\n     pub fn pipe_stream<T: Encodable<DefaultEncoder>\n                           Decodable<DefaultDecoder>>(\n                           ) -> (PipePort<T>, PipeChan<T>) {\n         let (port, chan) = pipes::stream();\n-        return (pipe_port(move port), pipe_chan(move chan));\n+        return (pipe_port(port), pipe_chan(chan));\n     }\n }\n \n@@ -193,37 +193,37 @@ pub mod pod {\n         reader: R\n     ) -> ReaderPort<T, R> {\n         let unflat: PodUnflattener<T> = PodUnflattener::new();\n-        let byte_port = ReaderBytePort::new(move reader);\n-        FlatPort::new(move unflat, move byte_port)\n+        let byte_port = ReaderBytePort::new(reader);\n+        FlatPort::new(unflat, byte_port)\n     }\n \n     /// Create a `FlatChan` from a `Writer`\n     pub fn writer_chan<T: Copy Owned, W: Writer>(\n         writer: W\n     ) -> WriterChan<T, W> {\n         let flat: PodFlattener<T> = PodFlattener::new();\n-        let byte_chan = WriterByteChan::new(move writer);\n-        FlatChan::new(move flat, move byte_chan)\n+        let byte_chan = WriterByteChan::new(writer);\n+        FlatChan::new(flat, byte_chan)\n     }\n \n     /// Create a `FlatPort` from a `Port<~[u8]>`\n     pub fn pipe_port<T: Copy Owned>(port: Port<~[u8]>) -> PipePort<T> {\n         let unflat: PodUnflattener<T> = PodUnflattener::new();\n-        let byte_port = PipeBytePort::new(move port);\n-        FlatPort::new(move unflat, move byte_port)\n+        let byte_port = PipeBytePort::new(port);\n+        FlatPort::new(unflat, byte_port)\n     }\n \n     /// Create a `FlatChan` from a `Chan<~[u8]>`\n     pub fn pipe_chan<T: Copy Owned>(chan: Chan<~[u8]>) -> PipeChan<T> {\n         let flat: PodFlattener<T> = PodFlattener::new();\n-        let byte_chan = PipeByteChan::new(move chan);\n-        FlatChan::new(move flat, move byte_chan)\n+        let byte_chan = PipeByteChan::new(chan);\n+        FlatChan::new(flat, byte_chan)\n     }\n \n     /// Create a pair of `FlatChan` and `FlatPort`, backed by pipes\n     pub fn pipe_stream<T: Copy Owned>() -> (PipePort<T>, PipeChan<T>) {\n         let (port, chan) = pipes::stream();\n-        return (pipe_port(move port), pipe_chan(move chan));\n+        return (pipe_port(port), pipe_chan(chan));\n     }\n \n }\n@@ -261,13 +261,13 @@ const CONTINUE: [u8 * 4] = [0xAA, 0xBB, 0xCC, 0xDD];\n pub impl<T,U:Unflattener<T>,P:BytePort> FlatPort<T, U, P>: GenericPort<T> {\n     fn recv() -> T {\n         match self.try_recv() {\n-            Some(move val) => move val,\n+            Some(val) => val,\n             None => fail!(~\"port is closed\")\n         }\n     }\n     fn try_recv() -> Option<T> {\n         let command = match self.byte_port.try_recv(CONTINUE.len()) {\n-            Some(move c) => move c,\n+            Some(c) => c,\n             None => {\n                 warn!(\"flatpipe: broken pipe\");\n                 return None;\n@@ -288,8 +288,8 @@ pub impl<T,U:Unflattener<T>,P:BytePort> FlatPort<T, U, P>: GenericPort<T> {\n             let msg_len = msg_len as uint;\n \n             match self.byte_port.try_recv(msg_len) {\n-                Some(move bytes) => {\n-                    Some(self.unflattener.unflatten(move bytes))\n+                Some(bytes) => {\n+                    Some(self.unflattener.unflatten(bytes))\n                 }\n                 None => {\n                     warn!(\"flatpipe: broken pipe\");\n@@ -306,29 +306,29 @@ pub impl<T,U:Unflattener<T>,P:BytePort> FlatPort<T, U, P>: GenericPort<T> {\n impl<T,F:Flattener<T>,C:ByteChan> GenericChan<T> for FlatChan<T, F, C> {\n     fn send(val: T) {\n         self.byte_chan.send(CONTINUE.to_vec());\n-        let bytes = self.flattener.flatten(move val);\n+        let bytes = self.flattener.flatten(val);\n         let len = bytes.len() as u64;\n         do io::u64_to_be_bytes(len, size_of::<u64>()) |len_bytes| {\n             self.byte_chan.send(len_bytes.to_vec());\n         }\n-        self.byte_chan.send(move bytes);\n+        self.byte_chan.send(bytes);\n     }\n }\n \n pub impl<T,U:Unflattener<T>,P:BytePort> FlatPort<T, U, P> {\n     static fn new(u: U, p: P) -> FlatPort<T, U, P> {\n         FlatPort {\n-            unflattener: move u,\n-            byte_port: move p\n+            unflattener: u,\n+            byte_port: p\n         }\n     }\n }\n \n pub impl<T,F:Flattener<T>,C:ByteChan> FlatChan<T, F, C> {\n     static fn new(f: F, c: C) -> FlatChan<T, F, C> {\n         FlatChan {\n-            flattener: move f,\n-            byte_chan: move c\n+            flattener: f,\n+            byte_chan: c\n         }\n     }\n }\n@@ -426,7 +426,7 @@ pub mod flatteners {\n         static fn new(deserialize_buffer: DeserializeBuffer<T>\n                      ) -> DeserializingUnflattener<D, T> {\n             DeserializingUnflattener {\n-                deserialize_buffer: move deserialize_buffer\n+                deserialize_buffer: deserialize_buffer\n             }\n         }\n     }\n@@ -437,7 +437,7 @@ pub mod flatteners {\n         static fn new(serialize_value: SerializeValue<T>\n                      ) -> SerializingFlattener<S, T> {\n             SerializingFlattener {\n-                serialize_value: move serialize_value\n+                serialize_value: serialize_value\n             }\n         }\n     }\n@@ -450,7 +450,7 @@ pub mod flatteners {\n     pub fn deserialize_buffer<D: Decoder FromReader,\n                           T: Decodable<D>>(buf: &[u8]) -> T {\n         let buf = vec::from_slice(buf);\n-        let buf_reader = @BufReader::new(move buf);\n+        let buf_reader = @BufReader::new(buf);\n         let reader = buf_reader as @Reader;\n         let deser: D = FromReader::from_reader(reader);\n         Decodable::decode(&deser)\n@@ -462,8 +462,8 @@ pub mod flatteners {\n         let writer = bytes_writer as @Writer;\n         let ser = FromWriter::from_writer(writer);\n         val.encode(&ser);\n-        let bytes = bytes_writer.bytes.check_out(|bytes| move bytes);\n-        return move bytes;\n+        let bytes = bytes_writer.bytes.check_out(|bytes| bytes);\n+        return bytes;\n     }\n \n     pub trait FromReader {\n@@ -477,8 +477,8 @@ pub mod flatteners {\n     impl FromReader for json::Decoder {\n         static fn from_reader(r: Reader) -> json::Decoder {\n             match json::from_reader(r) {\n-                Ok(move json) => {\n-                    json::Decoder(move json)\n+                Ok(json) => {\n+                    json::Decoder(json)\n                 }\n                 Err(e) => fail!(fmt!(\"flatpipe: can't parse json: %?\", e))\n             }\n@@ -487,21 +487,21 @@ pub mod flatteners {\n \n     impl FromWriter for json::Encoder {\n         static fn from_writer(w: Writer) -> json::Encoder {\n-            json::Encoder(move w)\n+            json::Encoder(w)\n         }\n     }\n \n     impl FromReader for ebml::reader::Decoder {\n         static fn from_reader(r: Reader) -> ebml::reader::Decoder {\n             let buf = @r.read_whole_stream();\n             let doc = ebml::reader::Doc(buf);\n-            ebml::reader::Decoder(move doc)\n+            ebml::reader::Decoder(doc)\n         }\n     }\n \n     impl FromWriter for ebml::writer::Encoder {\n         static fn from_writer(w: Writer) -> ebml::writer::Encoder {\n-            ebml::writer::Encoder(move w)\n+            ebml::writer::Encoder(w)\n         }\n     }\n \n@@ -537,7 +537,7 @@ pub mod bytepipes {\n             }\n \n             if left == 0 {\n-                return Some(move bytes);\n+                return Some(bytes);\n             } else {\n                 warn!(\"flatpipe: dropped %? broken bytes\", left);\n                 return None;\n@@ -554,15 +554,15 @@ pub mod bytepipes {\n     pub impl<R: Reader> ReaderBytePort<R> {\n         static fn new(r: R) -> ReaderBytePort<R> {\n             ReaderBytePort {\n-                reader: move r\n+                reader: r\n             }\n         }\n     }\n \n     pub impl<W: Writer> WriterByteChan<W> {\n         static fn new(w: W) -> WriterByteChan<W> {\n             WriterByteChan {\n-                writer: move w\n+                writer: w\n             }\n         }\n     }\n@@ -587,17 +587,17 @@ pub mod bytepipes {\n                 let mut bytes = ::core::util::replace(&mut self.buf, ~[]);\n                 assert count > bytes.len();\n                 match self.try_recv(count - bytes.len()) {\n-                    Some(move rest) => {\n+                    Some(rest) => {\n                         bytes.push_all(rest);\n-                        return Some(move bytes);\n+                        return Some(bytes);\n                     }\n                     None => return None\n                 }\n             } else if self.buf.is_empty() {\n                 match self.port.try_recv() {\n-                    Some(move buf) => {\n+                    Some(buf) => {\n                         assert !buf.is_empty();\n-                        self.buf = move buf;\n+                        self.buf = buf;\n                         return self.try_recv(count);\n                     }\n                     None => return None\n@@ -610,14 +610,14 @@ pub mod bytepipes {\n \n     pub impl PipeByteChan: ByteChan {\n         fn send(&self, val: ~[u8]) {\n-            self.chan.send(move val)\n+            self.chan.send(val)\n         }\n     }\n \n     pub impl PipeBytePort {\n         static fn new(p: Port<~[u8]>) -> PipeBytePort {\n             PipeBytePort {\n-                port: move p,\n+                port: p,\n                 buf: ~[]\n             }\n         }\n@@ -626,7 +626,7 @@ pub mod bytepipes {\n     pub impl PipeByteChan {\n         static fn new(c: Chan<~[u8]>) -> PipeByteChan {\n             PipeByteChan {\n-                chan: move c\n+                chan: c\n             }\n         }\n     }\n@@ -661,14 +661,14 @@ mod test {\n     #[test]\n     fn test_serializing_memory_stream() {\n         let writer = BytesWriter();\n-        let chan = serial::writer_chan(move writer);\n+        let chan = serial::writer_chan(writer);\n \n         chan.send(10);\n \n         let bytes = chan.byte_chan.writer.bytes.get();\n \n-        let reader = BufReader::new(move bytes);\n-        let port = serial::reader_port(move reader);\n+        let reader = BufReader::new(bytes);\n+        let port = serial::reader_port(reader);\n \n         let res: int = port.recv();\n         assert res == 10i;\n@@ -678,7 +678,7 @@ mod test {\n     fn test_serializing_pipes() {\n         let (port, chan) = serial::pipe_stream();\n \n-        do task::spawn |move chan| {\n+        do task::spawn || {\n             for int::range(0, 10) |i| {\n                 chan.send(i)\n             }\n@@ -693,7 +693,7 @@ mod test {\n     fn test_serializing_boxes() {\n         let (port, chan) = serial::pipe_stream();\n \n-        do task::spawn |move chan| {\n+        do task::spawn || {\n             for int::range(0, 10) |i| {\n                 chan.send(@i)\n             }\n@@ -707,14 +707,14 @@ mod test {\n     #[test]\n     fn test_pod_memory_stream() {\n         let writer = BytesWriter();\n-        let chan = pod::writer_chan(move writer);\n+        let chan = pod::writer_chan(writer);\n \n         chan.send(10);\n \n         let bytes = chan.byte_chan.writer.bytes.get();\n \n-        let reader = BufReader::new(move bytes);\n-        let port = pod::reader_port(move reader);\n+        let reader = BufReader::new(bytes);\n+        let port = pod::reader_port(reader);\n \n         let res: int = port.recv();\n         assert res == 10;\n@@ -724,7 +724,7 @@ mod test {\n     fn test_pod_pipes() {\n         let (port, chan) = pod::pipe_stream();\n \n-        do task::spawn |move chan| {\n+        do task::spawn || {\n             for int::range(0, 10) |i| {\n                 chan.send(i)\n             }\n@@ -741,11 +741,11 @@ mod test {\n     fn test_pod_tcp_stream() {\n         fn reader_port(buf: TcpSocketBuf\n                       ) -> pod::ReaderPort<int, TcpSocketBuf> {\n-            pod::reader_port(move buf)\n+            pod::reader_port(buf)\n         }\n         fn writer_chan(buf: TcpSocketBuf\n                       ) -> pod::WriterChan<int, TcpSocketBuf> {\n-            pod::writer_chan(move buf)\n+            pod::writer_chan(buf)\n         }\n         test_some_tcp_stream(reader_port, writer_chan, 9666);\n     }\n@@ -755,11 +755,11 @@ mod test {\n     fn test_serializing_tcp_stream() {\n         fn reader_port(buf: TcpSocketBuf\n                       ) -> serial::ReaderPort<int, TcpSocketBuf> {\n-            serial::reader_port(move buf)\n+            serial::reader_port(buf)\n         }\n         fn writer_chan(buf: TcpSocketBuf\n                       ) -> serial::WriterChan<int, TcpSocketBuf> {\n-            serial::writer_chan(move buf)\n+            serial::writer_chan(buf)\n         }\n         test_some_tcp_stream(reader_port, writer_chan, 9667);\n     }\n@@ -790,27 +790,25 @@ mod test {\n \n         let addr0 = ip::v4::parse_addr(\"127.0.0.1\");\n \n-        let begin_connect_chan = Cell(move begin_connect_chan);\n-        let accept_chan = Cell(move accept_chan);\n+        let begin_connect_chan = Cell(begin_connect_chan);\n+        let accept_chan = Cell(accept_chan);\n \n         // The server task\n         let addr = copy addr0;\n-        do task::spawn |move begin_connect_chan,\n-                        move accept_chan| {\n+        do task::spawn || {\n             let iotask = &uv::global_loop::get();\n             let begin_connect_chan = begin_connect_chan.take();\n             let accept_chan = accept_chan.take();\n             let listen_res = do tcp::listen(\n-                copy addr, port, 128, iotask,\n-                |move begin_connect_chan, _kill_ch| {\n+                copy addr, port, 128, iotask, |_kill_ch| {\n                     // Tell the sender to initiate the connection\n                     debug!(\"listening\");\n                     begin_connect_chan.send(())\n-                }) |move accept_chan, new_conn, kill_ch| {\n+                }) |new_conn, kill_ch| {\n \n                 // Incoming connection. Send it to the receiver task to accept\n                 let (res_port, res_chan) = pipes::stream();\n-                accept_chan.send((move new_conn, move res_chan));\n+                accept_chan.send((new_conn, res_chan));\n                 // Wait until the connection is accepted\n                 res_port.recv();\n \n@@ -823,8 +821,7 @@ mod test {\n \n         // Client task\n         let addr = copy addr0;\n-        do task::spawn |move begin_connect_port,\n-                        move writer_chan| {\n+        do task::spawn || {\n \n             // Wait for the server to start listening\n             begin_connect_port.recv();\n@@ -833,11 +830,11 @@ mod test {\n             let iotask = &uv::global_loop::get();\n             let connect_result = tcp::connect(copy addr, port, iotask);\n             assert connect_result.is_ok();\n-            let sock = result::unwrap(move connect_result);\n-            let socket_buf: tcp::TcpSocketBuf = tcp::socket_buf(move sock);\n+            let sock = result::unwrap(connect_result);\n+            let socket_buf: tcp::TcpSocketBuf = tcp::socket_buf(sock);\n \n             // TcpSocketBuf is a Writer!\n-            let chan = writer_chan(move socket_buf);\n+            let chan = writer_chan(socket_buf);\n \n             for int::range(0, 10) |i| {\n                 debug!(\"sending %?\", i);\n@@ -846,23 +843,21 @@ mod test {\n         }\n \n         // Reciever task\n-        do task::spawn |move accept_port, move finish_chan,\n-                        move reader_port| {\n-\n+        do task::spawn || {\n             // Wait for a connection\n             let (conn, res_chan) = accept_port.recv();\n \n             debug!(\"accepting connection\");\n             let accept_result = tcp::accept(conn);\n             debug!(\"accepted\");\n             assert accept_result.is_ok();\n-            let sock = result::unwrap(move accept_result);\n+            let sock = result::unwrap(accept_result);\n             res_chan.send(());\n \n-            let socket_buf: tcp::TcpSocketBuf = tcp::socket_buf(move sock);\n+            let socket_buf: tcp::TcpSocketBuf = tcp::socket_buf(sock);\n \n             // TcpSocketBuf is a Reader!\n-            let port = reader_port(move socket_buf);\n+            let port = reader_port(socket_buf);\n \n             for int::range(0, 10) |i| {\n                 let j = port.recv();\n@@ -897,22 +892,22 @@ mod test {\n \n         fn reader_port_loader(bytes: ~[u8]\n                              ) -> pod::ReaderPort<int, BufReader> {\n-            let reader = BufReader::new(move bytes);\n-            pod::reader_port(move reader)\n+            let reader = BufReader::new(bytes);\n+            pod::reader_port(reader)\n         }\n \n         fn pipe_port_loader(bytes: ~[u8]\n                            ) -> pod::PipePort<int> {\n             let (port, chan) = pipes::stream();\n             if !bytes.is_empty() {\n-                chan.send(move bytes);\n+                chan.send(bytes);\n             }\n-            pod::pipe_port(move port)\n+            pod::pipe_port(port)\n         }\n \n         fn test_try_recv_none1<P: BytePort>(loader: PortLoader<P>) {\n             let bytes = ~[];\n-            let port = loader(move bytes);\n+            let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n             assert res.is_none();\n         }\n@@ -929,7 +924,7 @@ mod test {\n         fn test_try_recv_none2<P: BytePort>(loader: PortLoader<P>) {\n             // The control word in the protocol is interrupted\n             let bytes = ~[0];\n-            let port = loader(move bytes);\n+            let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n             assert res.is_none();\n         }\n@@ -947,7 +942,7 @@ mod test {\n             const CONTINUE: [u8 * 4] = [0xAA, 0xBB, 0xCC, 0xDD];\n             // The control word is followed by garbage\n             let bytes = CONTINUE.to_vec() + ~[0];\n-            let port = loader(move bytes);\n+            let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n             assert res.is_none();\n         }\n@@ -962,7 +957,7 @@ mod test {\n         }\n \n         fn test_try_recv_none4<P: BytePort>(+loader: PortLoader<P>) {\n-            assert do task::try |move loader| {\n+            assert do task::try || {\n                 const CONTINUE: [u8 * 4] = [0xAA, 0xBB, 0xCC, 0xDD];\n                 // The control word is followed by a valid length,\n                 // then undeserializable garbage\n@@ -972,7 +967,7 @@ mod test {\n                 };\n                 let bytes = CONTINUE.to_vec() + len_bytes + ~[0, 0, 0, 0];\n \n-                let port = loader(move bytes);\n+                let port = loader(bytes);\n \n                 let _res: Option<int> = port.try_recv();\n             }.is_err();"}, {"sha": "8af2f350e51f7276dbe3e99ce638407602ef6415", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -55,7 +55,7 @@ pub fn find<K: Eq Ord, V: Copy>(m: Treemap<K, V>, k: K) -> Option<V> {\n       Node(@ref kk, @copy v, left, right) => {\n         if k == *kk {\n             Some(v)\n-        } else if k < *kk { find(left, move k) } else { find(right, move k) }\n+        } else if k < *kk { find(left, k) } else { find(right, k) }\n       }\n     }\n }"}, {"sha": "6de6363695c779e66e1af5faacbed1a31251bf02", "filename": "src/libstd/future.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -71,10 +71,10 @@ impl<A> Future<A> {\n \n             let mut state = Evaluating;\n             self.state <-> state;\n-            match move state {\n+            match state {\n                 Forced(_) | Evaluating => fail!(~\"Logic error.\"),\n-                Pending(move f) => {\n-                    self.state = Forced(move f());\n+                Pending(f) => {\n+                    self.state = Forced(f());\n                     self.get_ref()\n                 }\n             }\n@@ -90,7 +90,7 @@ pub fn from_value<A>(val: A) -> Future<A> {\n      * not block.\n      */\n \n-    Future {state: Forced(move val)}\n+    Future {state: Forced(val)}\n }\n \n pub fn from_port<A:Owned>(port: PortOne<A>) ->\n@@ -102,13 +102,13 @@ pub fn from_port<A:Owned>(port: PortOne<A>) ->\n      * waiting for the result to be received on the port.\n      */\n \n-    let port = ~mut Some(move port);\n-    do from_fn |move port| {\n+    let port = ~mut Some(port);\n+    do from_fn || {\n         let mut port_ = None;\n         port_ <-> *port;\n-        let port = option::unwrap(move port_);\n-        match recv(move port) {\n-            oneshot::send(move data) => move data\n+        let port = option::unwrap(port_);\n+        match recv(port) {\n+            oneshot::send(data) => data\n         }\n     }\n }\n@@ -122,7 +122,7 @@ pub fn from_fn<A>(f: ~fn() -> A) -> Future<A> {\n      * function. It is not spawned into another task.\n      */\n \n-    Future {state: Pending(move f)}\n+    Future {state: Pending(f)}\n }\n \n pub fn spawn<A:Owned>(blk: fn~() -> A) -> Future<A> {\n@@ -135,13 +135,13 @@ pub fn spawn<A:Owned>(blk: fn~() -> A) -> Future<A> {\n \n     let (chan, port) = oneshot::init();\n \n-    let chan = ~mut Some(move chan);\n-    do task::spawn |move blk, move chan| {\n+    let chan = ~mut Some(chan);\n+    do task::spawn || {\n         let chan = option::swap_unwrap(&mut *chan);\n-        send_one(move chan, blk());\n+        send_one(chan, blk());\n     }\n \n-    return from_port(move port);\n+    return from_port(port);\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n@@ -162,8 +162,8 @@ pub mod test {\n     #[test]\n     pub fn test_from_port() {\n         let (ch, po) = oneshot::init();\n-        send_one(move ch, ~\"whale\");\n-        let f = from_port(move po);\n+        send_one(ch, ~\"whale\");\n+        let f = from_port(po);\n         assert f.get() == ~\"whale\";\n     }\n \n@@ -203,7 +203,7 @@ pub mod test {\n     pub fn test_sendable_future() {\n         let expected = ~\"schlorf\";\n         let f = do spawn |copy expected| { copy expected };\n-        do task::spawn |move f, move expected| {\n+        do task::spawn |f, expected| {\n             let actual = f.get();\n             assert actual == expected;\n         }"}, {"sha": "3726943321c353e6c24a7adaad8aec0003b9b353", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -35,7 +35,7 @@\n  *    fn do_work(in: &str, out: Option<~str>) {\n  *      io::println(in);\n  *      io::println(match out {\n- *        Some(move x) => x,\n+ *        Some(x) => x,\n  *        None => ~\"No Output\"\n  *      });\n  *    }\n@@ -339,7 +339,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n             i += 1;\n         }\n         return Ok(Matches {opts: vec::from_slice(opts),\n-                   vals: move vals,\n+                   vals: vals,\n                    free: free});\n     }\n }\n@@ -1178,7 +1178,7 @@ mod tests {\n         let args = ~[~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\"];\n         let opts = ~[optopt(~\"e\"), optopt(~\"encrypt\")];\n         let matches = &match getopts(args, opts) {\n-          result::Ok(move m) => m,\n+          result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n         assert opts_present(matches, ~[~\"e\"]);\n@@ -1199,7 +1199,7 @@ mod tests {\n         let args = ~[~\"-Lfoo\", ~\"-M.\"];\n         let opts = ~[optmulti(~\"L\"), optmulti(~\"M\")];\n         let matches = &match getopts(args, opts) {\n-          result::Ok(move m) => m,\n+          result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n         assert opts_present(matches, ~[~\"L\"]);"}, {"sha": "b1c6e2d44e572fb0df7a4fb93de9fa8f60a96838", "filename": "src/libstd/io_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fio_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fio_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio_util.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -20,7 +20,7 @@ pub struct BufReader {\n pub impl BufReader {\n     static pub fn new(v: ~[u8]) -> BufReader {\n         BufReader {\n-            buf: move v,\n+            buf: v,\n             pos: 0\n         }\n     }\n@@ -38,7 +38,7 @@ pub impl BufReader {\n         // FIXME #4429: This isn't correct if f fails\n         self.pos = bytes_reader.pos;\n \n-        return move res;\n+        return res;\n     }\n }\n "}, {"sha": "5aa05e9cf75668b48ff020f82c7022e6ccc91991", "filename": "src/libstd/json.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -388,18 +388,18 @@ pub fn Parser(rdr: io::Reader) -> Parser {\n \n pub impl Parser {\n     fn parse() -> Result<Json, Error> {\n-        match move self.parse_value() {\n-          Ok(move value) => {\n+        match self.parse_value() {\n+          Ok(value) => {\n             // Skip trailing whitespaces.\n             self.parse_whitespace();\n             // Make sure there is no trailing characters.\n             if self.eof() {\n-                Ok(move value)\n+                Ok(value)\n             } else {\n                 self.error(~\"trailing characters\")\n             }\n           }\n-          Err(move e) => Err(e)\n+          Err(e) => Err(e)\n         }\n     }\n }\n@@ -438,9 +438,9 @@ priv impl Parser {\n           'f' => self.parse_ident(~\"alse\", Boolean(false)),\n           '0' .. '9' | '-' => self.parse_number(),\n           '\"' =>\n-            match move self.parse_str() {\n-              Ok(move s) => Ok(String(s)),\n-              Err(move e) => Err(e),\n+            match self.parse_str() {\n+              Ok(s) => Ok(String(s)),\n+              Err(e) => Err(e),\n             },\n           '[' => self.parse_list(),\n           '{' => self.parse_object(),\n@@ -455,7 +455,7 @@ priv impl Parser {\n     fn parse_ident(ident: &str, value: Json) -> Result<Json, Error> {\n         if str::all(ident, |c| c == self.next_char()) {\n             self.bump();\n-            Ok(move value)\n+            Ok(value)\n         } else {\n             self.error(~\"invalid syntax\")\n         }\n@@ -662,13 +662,13 @@ priv impl Parser {\n \n         if self.ch == ']' {\n             self.bump();\n-            return Ok(List(move values));\n+            return Ok(List(values));\n         }\n \n         loop {\n-            match move self.parse_value() {\n-              Ok(move v) => values.push(move v),\n-              Err(move e) => return Err(e)\n+            match self.parse_value() {\n+              Ok(v) => values.push(v),\n+              Err(e) => return Err(e)\n             }\n \n             self.parse_whitespace();\n@@ -678,7 +678,7 @@ priv impl Parser {\n \n             match self.ch {\n               ',' => self.bump(),\n-              ']' => { self.bump(); return Ok(List(move values)); }\n+              ']' => { self.bump(); return Ok(List(values)); }\n               _ => return self.error(~\"expected `,` or `]`\")\n             }\n         };\n@@ -692,7 +692,7 @@ priv impl Parser {\n \n         if self.ch == '}' {\n           self.bump();\n-          return Ok(Object(move values));\n+          return Ok(Object(values));\n         }\n \n         while !self.eof() {\n@@ -702,9 +702,9 @@ priv impl Parser {\n                 return self.error(~\"key must be a string\");\n             }\n \n-            let key = match move self.parse_str() {\n-              Ok(move key) => key,\n-              Err(move e) => return Err(e)\n+            let key = match self.parse_str() {\n+              Ok(key) => key,\n+              Err(e) => return Err(e)\n             };\n \n             self.parse_whitespace();\n@@ -715,15 +715,15 @@ priv impl Parser {\n             }\n             self.bump();\n \n-            match move self.parse_value() {\n-              Ok(move value) => { values.insert(key, move value); }\n-              Err(move e) => return Err(e)\n+            match self.parse_value() {\n+              Ok(value) => { values.insert(key, value); }\n+              Err(e) => return Err(e)\n             }\n             self.parse_whitespace();\n \n             match self.ch {\n               ',' => self.bump(),\n-              '}' => { self.bump(); return Ok(Object(move values)); }\n+              '}' => { self.bump(); return Ok(Object(values)); }\n               _ => {\n                   if self.eof() { break; }\n                   return self.error(~\"expected `,` or `}`\");\n@@ -753,7 +753,7 @@ pub struct Decoder {\n }\n \n pub fn Decoder(json: Json) -> Decoder {\n-    Decoder { json: move json, stack: ~[] }\n+    Decoder { json: json, stack: ~[] }\n }\n \n priv impl Decoder {\n@@ -868,7 +868,7 @@ pub impl Decoder: serialize::Decoder {\n         };\n         let res = f(len);\n         self.pop();\n-        move res\n+        res\n     }\n \n     fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T {\n@@ -879,7 +879,7 @@ pub impl Decoder: serialize::Decoder {\n         };\n         let res = f(len);\n         self.pop();\n-        move res\n+        res\n     }\n \n     fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n@@ -897,14 +897,14 @@ pub impl Decoder: serialize::Decoder {\n         debug!(\"read_rec()\");\n         let value = f();\n         self.pop();\n-        move value\n+        value\n     }\n \n     fn read_struct<T>(&self, _name: &str, _len: uint, f: fn() -> T) -> T {\n         debug!(\"read_struct()\");\n         let value = f();\n         self.pop();\n-        move value\n+        value\n     }\n \n     fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T {\n@@ -934,7 +934,7 @@ pub impl Decoder: serialize::Decoder {\n         debug!(\"read_tup(len=%u)\", len);\n         let value = f();\n         self.pop();\n-        move value\n+        value\n     }\n \n     fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n@@ -1219,11 +1219,11 @@ mod tests {\n \n         for items.each |item| {\n             match *item {\n-                (copy key, copy value) => { d.insert(key, move value); },\n+                (copy key, copy value) => { d.insert(key, value); },\n             }\n         };\n \n-        Object(move d)\n+        Object(d)\n     }\n \n     #[test]"}, {"sha": "4a185f68e17f9ee3af8c1c60a885abb5978a2e12", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -181,7 +181,7 @@ pub mod v4 {\n      */\n     pub fn parse_addr(ip: &str) -> IpAddr {\n         match try_parse_addr(ip) {\n-          result::Ok(move addr) => move addr,\n+          result::Ok(addr) => addr,\n           result::Err(ref err_data) => fail!(err_data.err_msg)\n         }\n     }\n@@ -276,7 +276,7 @@ pub mod v6 {\n      */\n     pub fn parse_addr(ip: &str) -> IpAddr {\n         match try_parse_addr(ip) {\n-          result::Ok(move addr) => move addr,\n+          result::Ok(addr) => addr,\n           result::Err(copy err_data) => fail!(err_data.err_msg)\n         }\n     }\n@@ -331,7 +331,7 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n                             result::Err(GetAddrUnknownError));\n                         break;\n                     };\n-                    out_vec.push(move new_ip_addr);\n+                    out_vec.push(new_ip_addr);\n \n                     let next_addr = ll::get_next_addrinfo(curr_addr);\n                     if next_addr == ptr::null::<addrinfo>() as *addrinfo {\n@@ -345,7 +345,7 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n                 }\n                 log(debug, fmt!(\"successful process addrinfo result, len: %?\",\n                                 vec::len(out_vec)));\n-                output_ch.send(result::Ok(move out_vec));\n+                output_ch.send(result::Ok(out_vec));\n             }\n             else {\n                 log(debug, ~\"addrinfo pointer is NULL\");\n@@ -427,7 +427,7 @@ mod test {\n         }\n         // note really sure how to realiably test/assert\n         // this.. mostly just wanting to see it work, atm.\n-        let results = result::unwrap(move ga_result);\n+        let results = result::unwrap(ga_result);\n         log(debug, fmt!(\"test_get_addr: Number of results for %s: %?\",\n                         localhost_name, vec::len(results)));\n         for vec::each(results) |r| {"}, {"sha": "9f750a2bf711a7b5b0ebfd9ccd3dcbe9a49de9ae", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -177,7 +177,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n         // we can send into the interact cb to be handled in libuv..\n         debug!(\"stream_handle_ptr outside interact %?\",\n                         stream_handle_ptr);\n-        do iotask::interact(iotask) |move input_ip, loop_ptr| {\n+        do iotask::interact(iotask) |loop_ptr| {\n             unsafe {\n                 debug!(\"in interact cb for tcp client connect..\");\n                 debug!(\"stream_handle_ptr in interact %?\",\n@@ -629,10 +629,10 @@ pub fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n               new_connect_cb: fn~(TcpNewConnection,\n                                   SharedChan<Option<TcpErrData>>))\n     -> result::Result<(), TcpListenErrData> {\n-    do listen_common(move host_ip, port, backlog, iotask,\n-                     move on_establish_cb)\n+    do listen_common(host_ip, port, backlog, iotask,\n+                     on_establish_cb)\n         // on_connect_cb\n-        |move new_connect_cb, handle| {\n+        |handle| {\n         unsafe {\n             let server_data_ptr = uv::ll::get_data_for_uv_handle(handle)\n                 as *TcpListenFcData;\n@@ -659,7 +659,7 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n             server_stream_ptr: server_stream_ptr,\n             stream_closed_ch: stream_closed_ch,\n             kill_ch: kill_ch.clone(),\n-            on_connect_cb: move on_connect_cb,\n+            on_connect_cb: on_connect_cb,\n             iotask: iotask.clone(),\n             ipv6: match &host_ip {\n                 &ip::Ipv4(_) => { false }\n@@ -678,7 +678,7 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n         // tcp::connect (because the iotask::interact cb isn't\n         // nested within a core::comm::listen block)\n         let loc_ip = copy(host_ip);\n-        do iotask::interact(iotask) |move loc_ip, loop_ptr| {\n+        do iotask::interact(iotask) |loop_ptr| {\n             unsafe {\n                 match uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n                     0i32 => {\n@@ -815,7 +815,7 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n  */\n pub fn socket_buf(sock: TcpSocket) -> TcpSocketBuf {\n     TcpSocketBuf(@TcpBufferedSocketData {\n-        sock: move sock, mut buf: ~[], buf_off: 0\n+        sock: sock, mut buf: ~[], buf_off: 0\n     })\n }\n \n@@ -851,12 +851,12 @@ impl TcpSocket {\n                 let addr = uv::ll::ip6_addr(\"\", 0);\n                 uv::ll::tcp_getpeername6(self.socket_data.stream_handle_ptr,\n                                          ptr::addr_of(&addr));\n-                ip::Ipv6(move addr)\n+                ip::Ipv6(addr)\n             } else {\n                 let addr = uv::ll::ip4_addr(\"\", 0);\n                 uv::ll::tcp_getpeername(self.socket_data.stream_handle_ptr,\n                                         ptr::addr_of(&addr));\n-                ip::Ipv4(move addr)\n+                ip::Ipv4(addr)\n             }\n         }\n     }\n@@ -1047,7 +1047,7 @@ fn read_common_impl(socket_data: *TcpSocketData, timeout_msecs: uint)\n                 Some(result::get(&rs_result).recv())\n             };\n             log(debug, ~\"tcp::read after recv_timeout\");\n-            match move read_result {\n+            match read_result {\n                 None => {\n                     log(debug, ~\"tcp::read: timed out..\");\n                     let err_data = TcpErrData {\n@@ -1057,7 +1057,7 @@ fn read_common_impl(socket_data: *TcpSocketData, timeout_msecs: uint)\n                     read_stop_common_impl(socket_data);\n                     result::Err(err_data)\n                 }\n-                Some(move data_result) => {\n+                Some(data_result) => {\n                     log(debug, ~\"tcp::read got data\");\n                     read_stop_common_impl(socket_data);\n                     data_result\n@@ -1091,7 +1091,7 @@ fn read_stop_common_impl(socket_data: *TcpSocketData) ->\n             }\n         }\n         match stop_po.recv() {\n-            Some(move err_data) => Err(err_data),\n+            Some(err_data) => Err(err_data),\n             None => Ok(())\n         }\n     }\n@@ -1183,7 +1183,7 @@ fn write_common_impl(socket_data_ptr: *TcpSocketData,\n         // aftermath, so we don't have to sit here blocking.\n         match result_po.recv() {\n             TcpWriteSuccess => Ok(()),\n-            TcpWriteError(move err_data) => Err(err_data)\n+            TcpWriteError(err_data) => Err(err_data)\n         }\n     }\n }\n@@ -1613,10 +1613,10 @@ pub mod test {\n         debug!(\"server started, firing up client..\");\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n         let iotask = uv::global_loop::get();\n-        let connect_result = connect(move server_ip_addr, server_port,\n+        let connect_result = connect(server_ip_addr, server_port,\n                                      &iotask);\n \n-        let sock = result::unwrap(move connect_result);\n+        let sock = result::unwrap(connect_result);\n \n         debug!(\"testing peer address\");\n         // This is what we are actually testing!\n@@ -1784,11 +1784,11 @@ pub mod test {\n         // client\n         debug!(\"server started, firing up client..\");\n         let server_addr = ip::v4::parse_addr(server_ip);\n-        let conn_result = connect(move server_addr, server_port, hl_loop);\n+        let conn_result = connect(server_addr, server_port, hl_loop);\n         if result::is_err(&conn_result) {\n             assert false;\n         }\n-        let sock_buf = @socket_buf(result::unwrap(move conn_result));\n+        let sock_buf = @socket_buf(result::unwrap(conn_result));\n         buf_write(sock_buf, expected_req);\n \n         let buf_reader = sock_buf as Reader;\n@@ -1819,7 +1819,7 @@ pub mod test {\n         let (server_po, server_ch) = stream::<~str>();\n         let server_ch = SharedChan(server_ch);\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n-        let listen_result = listen(move server_ip_addr, server_port, 128,\n+        let listen_result = listen(server_ip_addr, server_port, 128,\n                                    iotask,\n             // on_establish_cb -- called when listener is set up\n             |kill_ch| {\n@@ -1849,15 +1849,15 @@ pub mod test {\n                     else {\n                         debug!(\"SERVER/WORKER: send on cont ch\");\n                         cont_ch.send(());\n-                        let sock = result::unwrap(move accept_result);\n+                        let sock = result::unwrap(accept_result);\n                         let peer_addr = sock.get_peer_addr();\n                         debug!(\"SERVER: successfully accepted \\\n                                 connection from %s:%u\",\n                                  ip::format_addr(&peer_addr),\n                                  ip::get_port(&peer_addr));\n                         let received_req_bytes = read(&sock, 0u);\n-                        match move received_req_bytes {\n-                          result::Ok(move data) => {\n+                        match received_req_bytes {\n+                          result::Ok(data) => {\n                             debug!(\"SERVER: got REQ str::from_bytes..\");\n                             debug!(\"SERVER: REQ data len: %?\",\n                                             vec::len(data));\n@@ -1868,7 +1868,7 @@ pub mod test {\n                             debug!(\"SERVER: after write.. die\");\n                             kill_ch.send(None);\n                           }\n-                          result::Err(move err_data) => {\n+                          result::Err(err_data) => {\n                             debug!(\"SERVER: error recvd: %s %s\",\n                                 err_data.err_name, err_data.err_msg);\n                             kill_ch.send(Some(err_data));\n@@ -1904,7 +1904,7 @@ pub mod test {\n     fn run_tcp_test_server_fail(server_ip: &str, server_port: uint,\n                                 iotask: &IoTask) -> TcpListenErrData {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n-        let listen_result = listen(move server_ip_addr, server_port, 128,\n+        let listen_result = listen(server_ip_addr, server_port, 128,\n                                    iotask,\n             // on_establish_cb -- called when listener is set up\n             |kill_ch| {\n@@ -1929,15 +1929,15 @@ pub mod test {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n \n         debug!(\"CLIENT: starting..\");\n-        let connect_result = connect(move server_ip_addr, server_port,\n+        let connect_result = connect(server_ip_addr, server_port,\n                                      iotask);\n         if result::is_err(&connect_result) {\n             debug!(\"CLIENT: failed to connect\");\n             let err_data = result::get_err(&connect_result);\n             Err(err_data)\n         }\n         else {\n-            let sock = result::unwrap(move connect_result);\n+            let sock = result::unwrap(connect_result);\n             let resp_bytes = str::to_bytes(resp);\n             tcp_write_single(&sock, resp_bytes);\n             let read_result = sock.read(0u);"}, {"sha": "29cb57c01be4517b0e6dbb91ab026fb7f50e3b90", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -253,7 +253,7 @@ pub fn decode_form_urlencoded(s: &[u8]) -> LinearMap<~str, ~[~str]> {\n                 '&' | ';' => {\n                     if key != ~\"\" && value != ~\"\" {\n                         let mut values = match m.pop(&key) {\n-                            Some(move values) => values,\n+                            Some(values) => values,\n                             None => ~[],\n                         };\n \n@@ -287,7 +287,7 @@ pub fn decode_form_urlencoded(s: &[u8]) -> LinearMap<~str, ~[~str]> {\n \n         if key != ~\"\" && value != ~\"\" {\n             let mut values = match m.pop(&key) {\n-                Some(move values) => values,\n+                Some(values) => values,\n                 None => ~[],\n             };\n \n@@ -671,7 +671,7 @@ pub pure fn from_str(rawurl: &str) -> Result<Url, ~str> {\n impl FromStr for Url {\n     static pure fn from_str(s: &str) -> Option<Url> {\n         match from_str(s) {\n-            Ok(move url) => Some(url),\n+            Ok(url) => Some(url),\n             Err(_) => None\n         }\n     }"}, {"sha": "701268e044ae393515b946c0c21d3b8a9a6fef0b", "filename": "src/libstd/oldmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -132,7 +132,7 @@ pub mod chained {\n                 entry.next = new_chains[idx];\n                 new_chains[idx] = Some(entry);\n             }\n-            self.chains = move new_chains;\n+            self.chains = new_chains;\n         }\n \n         pure fn each_entry(blk: fn(@Entry<K,V>) -> bool) {\n@@ -321,7 +321,7 @@ pub mod chained {\n             if opt_v.is_none() {\n                 fail!(fmt!(\"Key not found in table: %?\", k));\n             }\n-            option::unwrap(move opt_v)\n+            option::unwrap(opt_v)\n         }\n     }\n "}, {"sha": "c4ba465acea94f1833b54cf6f5a03296aa0e9e21", "filename": "src/libstd/oldsmallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Foldsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Foldsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldsmallintmap.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -69,7 +69,7 @@ pub pure fn get<T: Copy>(self: SmallIntMap<T>, key: uint) -> T {\n         error!(\"smallintmap::get(): key not present\");\n         fail!();\n       }\n-      Some(move v) => return v\n+      Some(v) => return v\n     }\n }\n "}, {"sha": "3929e8c0ea7634c7ec1535fe1e0158ff0b801759", "filename": "src/libstd/par.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -58,7 +58,7 @@ fn map_slices<A: Copy Owned, B: Copy Owned>(\n             do vec::as_imm_buf(xs) |p, _len| {\n                 let f = f();\n                 let base = base;\n-                let f = do future_spawn() |move f| {\n+                let f = do future_spawn() || {\n                     unsafe {\n                         let len = end - base;\n                         let slice = (ptr::offset(p, base),\n@@ -72,7 +72,7 @@ fn map_slices<A: Copy Owned, B: Copy Owned>(\n                         f(base, slice)\n                     }\n                 };\n-                futures.push(move f);\n+                futures.push(f);\n             };\n             base += items_per_task;\n         }"}, {"sha": "b216834a20500cd370d406a016435bd9718c9bc1", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -139,27 +139,27 @@ impl <T: Ord> PriorityQueue<T> {\n \n     priv fn siftup(&mut self, start: uint, mut pos: uint) {\n         unsafe {\n-            let new = move *addr_of(&self.data[pos]);\n+            let new = *addr_of(&self.data[pos]);\n \n             while pos > start {\n                 let parent = (pos - 1) >> 1;\n                 if new > self.data[parent] {\n                     let mut x = rusti::init();\n                     x <-> self.data[parent];\n-                    rusti::move_val_init(&mut self.data[pos], move x);\n+                    rusti::move_val_init(&mut self.data[pos], x);\n                     pos = parent;\n                     loop\n                 }\n                 break\n             }\n-            rusti::move_val_init(&mut self.data[pos], move new);\n+            rusti::move_val_init(&mut self.data[pos], new);\n         }\n     }\n \n     priv fn siftdown_range(&mut self, mut pos: uint, end: uint) {\n         unsafe {\n             let start = pos;\n-            let new = move *addr_of(&self.data[pos]);\n+            let new = *addr_of(&self.data[pos]);\n \n             let mut child = 2 * pos + 1;\n             while child < end {\n@@ -169,12 +169,12 @@ impl <T: Ord> PriorityQueue<T> {\n                 }\n                 let mut x = rusti::init();\n                 x <-> self.data[child];\n-                rusti::move_val_init(&mut self.data[pos], move x);\n+                rusti::move_val_init(&mut self.data[pos], x);\n                 pos = child;\n                 child = 2 * pos + 1;\n             }\n \n-            rusti::move_val_init(&mut self.data[pos], move new);\n+            rusti::move_val_init(&mut self.data[pos], new);\n             self.siftup(start, pos);\n         }\n     }"}, {"sha": "1ee67d76af571f0105ed5b7cf2cfc10f28a31be8", "filename": "src/libstd/rl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frl.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -71,7 +71,7 @@ fn complete_key(_v: @CompletionCb) {}\n /// Bind to the main completion callback\n pub unsafe fn complete(cb: CompletionCb) {\n     unsafe {\n-        task::local_data::local_data_set(complete_key, @(move cb));\n+        task::local_data::local_data_set(complete_key, @(cb));\n \n         extern fn callback(line: *c_char, completions: *()) {\n             unsafe {"}, {"sha": "8e878c8fc2e312a9e75822c1a5e2a6b49876788d", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -848,11 +848,11 @@ pub mod node {\n                         offset += 1u;\n                         i      += 1u;\n                     }\n-                    cast::forget(move local_buf);\n+                    cast::forget(local_buf);\n                   }\n                 }\n             }\n-            return cast::transmute(move buf);\n+            return cast::transmute(buf);\n         }\n     }\n "}, {"sha": "242e318e8a8f0f33b031161cd2454e6800090004", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -265,7 +265,7 @@ pub fn sha1() -> Sha1 {\n          computed: false,\n          work_buf: @mut vec::from_elem(work_buf_len, 0u32)\n     };\n-    let mut sh = (move st) as Sha1;\n+    let mut sh = (st) as Sha1;\n     sh.reset();\n     return sh;\n }"}, {"sha": "e56f4cb87cd43ff3da1e9284cf70b94076d444dd", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -59,7 +59,7 @@ pub pure fn merge_sort<T: Copy>(v: &[const T], le: Le<T>) -> ~[T] {\n         }\n         rs.push_all(vec::slice(a, a_ix, a_len));\n         rs.push_all(vec::slice(b, b_ix, b_len));\n-        move rs\n+        rs\n     }\n }\n \n@@ -241,7 +241,7 @@ fn binarysort<T: Copy Ord>(array: &mut [T], start: uint) {\n         let mut n = start-left;\n \n         copy_vec(array, left+1, array, left, n);\n-        array[left] = move pivot;\n+        array[left] = pivot;\n         start += 1;\n     }\n }\n@@ -816,7 +816,7 @@ mod test_qsort {\n \n         do quick_sort(names) |x, y| { int::le(*x, *y) };\n \n-        let immut_names = move names;\n+        let immut_names = names;\n \n         let pairs = vec::zip_slice(expected, immut_names);\n         for vec::each(pairs) |p| {\n@@ -1022,14 +1022,14 @@ mod big_tests {\n         let res = do vec::from_fn(num) |i| {\n             arr[i % size]\n         };\n-        move res\n+        res\n     }\n \n     fn makeRange(n: uint) -> ~[uint] {\n         let one = do vec::from_fn(n) |i| { i };\n         let mut two = copy one;\n         vec::reverse(two);\n-        vec::append(move two, one)\n+        vec::append(two, one)\n     }\n \n     fn tabulate_unique(lo: uint, hi: uint) {\n@@ -1048,7 +1048,7 @@ mod big_tests {\n             let arr = do vec::from_fn(n) |_i| {\n                 rng.gen_float()\n             };\n-            let mut arr = move arr;\n+            let mut arr = arr;\n \n             tim_sort(arr); // *sort\n             isSorted(arr);\n@@ -1089,7 +1089,7 @@ mod big_tests {\n             let mut arr = if n > 4 {\n                 let part = vec::view(arr, 0, 4);\n                 multiplyVec(part, n)\n-            } else { move arr };\n+            } else { arr };\n             tim_sort(arr); // ~sort\n             isSorted(arr);\n \n@@ -1120,7 +1120,7 @@ mod big_tests {\n             let arr = do vec::from_fn(n) |_i| {\n                 @rng.gen_float()\n             };\n-            let mut arr = move arr;\n+            let mut arr = arr;\n \n             tim_sort(arr); // *sort\n             isSorted(arr);\n@@ -1161,7 +1161,7 @@ mod big_tests {\n             let mut arr = if n > 4 {\n                 let part = vec::view(arr, 0, 4);\n                 multiplyVec(part, n)\n-            } else { move arr };\n+            } else { arr };\n             tim_sort(arr); // ~sort\n             isSorted(arr);\n "}, {"sha": "fd0b0d6be3a2dd67d236bacdf384edb006667110", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -40,7 +40,7 @@ struct Waitqueue { head: pipes::Port<SignalEnd>,\n \n fn new_waitqueue() -> Waitqueue {\n     let (block_head, block_tail) = pipes::stream();\n-    Waitqueue { head: move block_head, tail: move block_tail }\n+    Waitqueue { head: block_head, tail: block_tail }\n }\n \n // Signals one live task from the queue.\n@@ -86,7 +86,7 @@ enum Sem<Q> = Exclusive<SemInner<Q>>;\n #[doc(hidden)]\n fn new_sem<Q: Owned>(count: int, q: Q) -> Sem<Q> {\n     Sem(exclusive(SemInner {\n-        mut count: count, waiters: new_waitqueue(), blocked: move q }))\n+        mut count: count, waiters: new_waitqueue(), blocked: q }))\n }\n #[doc(hidden)]\n fn new_sem_and_signal(count: int, num_condvars: uint)\n@@ -109,17 +109,17 @@ impl<Q: Owned> &Sem<Q> {\n                     // Create waiter nobe.\n                     let (WaitEnd, SignalEnd) = pipes::oneshot();\n                     // Tell outer scope we need to block.\n-                    waiter_nobe = Some(move WaitEnd);\n+                    waiter_nobe = Some(WaitEnd);\n                     // Enqueue ourself.\n-                    state.waiters.tail.send(move SignalEnd);\n+                    state.waiters.tail.send(SignalEnd);\n                 }\n             }\n         }\n         // Uncomment if you wish to test for sem races. Not valgrind-friendly.\n         /* for 1000.times { task::yield(); } */\n         // Need to wait outside the exclusive.\n         if waiter_nobe.is_some() {\n-            let _ = pipes::recv_one(option::unwrap(move waiter_nobe));\n+            let _ = pipes::recv_one(option::unwrap(waiter_nobe));\n         }\n     }\n     fn release() {\n@@ -215,8 +215,8 @@ impl &Condvar {\n     fn wait_on(condvar_id: uint) {\n         // Create waiter nobe.\n         let (WaitEnd, SignalEnd) = pipes::oneshot();\n-        let mut WaitEnd   = Some(move WaitEnd);\n-        let mut SignalEnd = Some(move SignalEnd);\n+        let mut WaitEnd   = Some(WaitEnd);\n+        let mut SignalEnd = Some(SignalEnd);\n         let mut reacquire = None;\n         let mut out_of_bounds = None;\n         unsafe {\n@@ -231,7 +231,7 @@ impl &Condvar {\n                         }\n                         // Enqueue ourself to be woken up by a signaller.\n                         let SignalEnd = option::swap_unwrap(&mut SignalEnd);\n-                        state.blocked[condvar_id].tail.send(move SignalEnd);\n+                        state.blocked[condvar_id].tail.send(SignalEnd);\n                     } else {\n                         out_of_bounds = Some(vec::len(state.blocked));\n                     }\n@@ -737,7 +737,7 @@ mod tests {\n     pub fn test_sem_as_mutex() {\n         let s = ~semaphore(1);\n         let s2 = ~s.clone();\n-        do task::spawn |move s2| {\n+        do task::spawn || {\n             do s2.access {\n                 for 5.times { task::yield(); }\n             }\n@@ -752,7 +752,7 @@ mod tests {\n         let (p,c) = pipes::stream();\n         let s = ~semaphore(0);\n         let s2 = ~s.clone();\n-        do task::spawn |move s2, move c| {\n+        do task::spawn || {\n             s2.acquire();\n             c.send(());\n         }\n@@ -764,7 +764,7 @@ mod tests {\n         let (p,c) = pipes::stream();\n         let s = ~semaphore(0);\n         let s2 = ~s.clone();\n-        do task::spawn |move s2, move p| {\n+        do task::spawn || {\n             for 5.times { task::yield(); }\n             s2.release();\n             let _ = p.recv();\n@@ -780,7 +780,7 @@ mod tests {\n         let s2 = ~s.clone();\n         let (p1,c1) = pipes::stream();\n         let (p2,c2) = pipes::stream();\n-        do task::spawn |move s2, move c1, move p2| {\n+        do task::spawn || {\n             do s2.access {\n                 let _ = p2.recv();\n                 c1.send(());\n@@ -799,10 +799,10 @@ mod tests {\n             let s = ~semaphore(1);\n             let s2 = ~s.clone();\n             let (p,c) = pipes::stream();\n-            let child_data = ~mut Some((move s2, move c));\n+            let child_data = ~mut Some((s2, c));\n             do s.access {\n                 let (s2,c) = option::swap_unwrap(child_data);\n-                do task::spawn |move c, move s2| {\n+                do task::spawn || {\n                     c.send(());\n                     do s2.access { }\n                     c.send(());\n@@ -825,7 +825,7 @@ mod tests {\n         let m2 = ~m.clone();\n         let mut sharedstate = ~0;\n         let ptr = ptr::addr_of(&(*sharedstate));\n-        do task::spawn |move m2, move c| {\n+        do task::spawn || {\n             let sharedstate: &mut int =\n                 unsafe { cast::reinterpret_cast(&ptr) };\n             access_shared(sharedstate, m2, 10);\n@@ -854,7 +854,7 @@ mod tests {\n         // Child wakes up parent\n         do m.lock_cond |cond| {\n             let m2 = ~m.clone();\n-            do task::spawn |move m2| {\n+            do task::spawn || {\n                 do m2.lock_cond |cond| {\n                     let woken = cond.signal();\n                     assert woken;\n@@ -865,7 +865,7 @@ mod tests {\n         // Parent wakes up child\n         let (port,chan) = pipes::stream();\n         let m3 = ~m.clone();\n-        do task::spawn |move chan, move m3| {\n+        do task::spawn || {\n             do m3.lock_cond |cond| {\n                 chan.send(());\n                 cond.wait();\n@@ -887,8 +887,8 @@ mod tests {\n         for num_waiters.times {\n             let mi = ~m.clone();\n             let (port, chan) = pipes::stream();\n-            ports.push(move port);\n-            do task::spawn |move chan, move mi| {\n+            ports.push(port);\n+            do task::spawn || {\n                 do mi.lock_cond |cond| {\n                     chan.send(());\n                     cond.wait();\n@@ -918,7 +918,7 @@ mod tests {\n     pub fn test_mutex_cond_no_waiter() {\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n-        do task::try |move m| {\n+        do task::try || {\n             do m.lock_cond |_x| { }\n         };\n         do m2.lock_cond |cond| {\n@@ -931,7 +931,7 @@ mod tests {\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n \n-        let result: result::Result<(),()> = do task::try |move m2| {\n+        let result: result::Result<(),()> = do task::try || {\n             do m2.lock {\n                 fail!();\n             }\n@@ -947,9 +947,9 @@ mod tests {\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n \n-        let result: result::Result<(),()> = do task::try |move m2| {\n+        let result: result::Result<(),()> = do task::try || {\n             let (p,c) = pipes::stream();\n-            do task::spawn |move p| { // linked\n+            do task::spawn || { // linked\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n                 task::yield();\n                 fail!();\n@@ -972,19 +972,19 @@ mod tests {\n         let m2 = ~m.clone();\n         let (p,c) = pipes::stream();\n \n-        let result: result::Result<(),()> = do task::try |move c, move m2| {\n+        let result: result::Result<(),()> = do task::try || {\n             let mut sibling_convos = ~[];\n             for 2.times {\n                 let (p,c) = pipes::stream();\n-                let c = ~mut Some(move c);\n-                sibling_convos.push(move p);\n+                let c = ~mut Some(c);\n+                sibling_convos.push(p);\n                 let mi = ~m2.clone();\n                 // spawn sibling task\n-                do task::spawn |move mi, move c| { // linked\n+                do task::spawn || { // linked\n                     do mi.lock_cond |cond| {\n                         let c = option::swap_unwrap(c);\n                         c.send(()); // tell sibling to go ahead\n-                        let _z = SendOnFailure(move c);\n+                        let _z = SendOnFailure(c);\n                         cond.wait(); // block forever\n                     }\n                 }\n@@ -993,7 +993,7 @@ mod tests {\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n             }\n             do m2.lock { }\n-            c.send(move sibling_convos); // let parent wait on all children\n+            c.send(sibling_convos); // let parent wait on all children\n             fail!();\n         };\n         assert result.is_err();\n@@ -1015,7 +1015,7 @@ mod tests {\n \n         fn SendOnFailure(c: pipes::Chan<()>) -> SendOnFailure {\n             SendOnFailure {\n-                c: move c\n+                c: c\n             }\n         }\n     }\n@@ -1025,7 +1025,7 @@ mod tests {\n         let m = ~Mutex();\n         do m.lock_cond |cond| {\n             let m2 = ~m.clone();\n-            do task::spawn |move m2| {\n+            do task::spawn || {\n                 do m2.lock_cond |cond| {\n                     cond.signal_on(0);\n                 }\n@@ -1039,7 +1039,7 @@ mod tests {\n             let m = ~mutex_with_condvars(2);\n             let m2 = ~m.clone();\n             let (p,c) = pipes::stream();\n-            do task::spawn |move m2, move c| {\n+            do task::spawn || {\n                 do m2.lock_cond |cond| {\n                     c.send(());\n                     cond.wait_on(1);\n@@ -1088,7 +1088,7 @@ mod tests {\n                 },\n             DowngradeRead =>\n                 do x.write_downgrade |mode| {\n-                    let mode = x.downgrade(move mode);\n+                    let mode = x.downgrade(mode);\n                     (&mode).read(blk);\n                 },\n         }\n@@ -1103,7 +1103,7 @@ mod tests {\n         let x2 = ~x.clone();\n         let mut sharedstate = ~0;\n         let ptr = ptr::addr_of(&(*sharedstate));\n-        do task::spawn |move c, move x2| {\n+        do task::spawn || {\n             let sharedstate: &mut int =\n                 unsafe { cast::reinterpret_cast(&ptr) };\n             access_shared(sharedstate, x2, mode1, 10);\n@@ -1148,7 +1148,7 @@ mod tests {\n         let x2 = ~x.clone();\n         let (p1,c1) = pipes::stream();\n         let (p2,c2) = pipes::stream();\n-        do task::spawn |move c1, move x2, move p2| {\n+        do task::spawn || {\n             if !make_mode2_go_first {\n                 let _ = p2.recv(); // parent sends to us once it locks, or ...\n             }\n@@ -1185,10 +1185,10 @@ mod tests {\n         // Tests that downgrade can unlock the lock in both modes\n         let x = ~RWlock();\n         do lock_rwlock_in_mode(x, Downgrade) { }\n-        test_rwlock_handshake(move x, Read, Read, false);\n+        test_rwlock_handshake(x, Read, Read, false);\n         let y = ~RWlock();\n         do lock_rwlock_in_mode(y, DowngradeRead) { }\n-        test_rwlock_exclusion(move y, Write, Write);\n+        test_rwlock_exclusion(y, Write, Write);\n     }\n     #[test]\n     pub fn test_rwlock_read_recursive() {\n@@ -1203,7 +1203,7 @@ mod tests {\n         // Child wakes up parent\n         do x.write_cond |cond| {\n             let x2 = ~x.clone();\n-            do task::spawn |move x2| {\n+            do task::spawn || {\n                 do x2.write_cond |cond| {\n                     let woken = cond.signal();\n                     assert woken;\n@@ -1214,7 +1214,7 @@ mod tests {\n         // Parent wakes up child\n         let (port,chan) = pipes::stream();\n         let x3 = ~x.clone();\n-        do task::spawn |move x3, move chan| {\n+        do task::spawn || {\n             do x3.write_cond |cond| {\n                 chan.send(());\n                 cond.wait();\n@@ -1250,8 +1250,8 @@ mod tests {\n         for num_waiters.times {\n             let xi = ~x.clone();\n             let (port, chan) = pipes::stream();\n-            ports.push(move port);\n-            do task::spawn |move chan, move xi| {\n+            ports.push(port);\n+            do task::spawn || {\n                 do lock_cond(xi, dg1) |cond| {\n                     chan.send(());\n                     cond.wait();\n@@ -1286,7 +1286,7 @@ mod tests {\n         let x = ~RWlock();\n         let x2 = ~x.clone();\n \n-        let result: result::Result<(),()> = do task::try |move x2| {\n+        let result: result::Result<(),()> = do task::try || {\n             do lock_rwlock_in_mode(x2, mode1) {\n                 fail!();\n             }\n@@ -1332,7 +1332,7 @@ mod tests {\n         let x = ~RWlock();\n         let y = ~RWlock();\n         do x.write_downgrade |xwrite| {\n-            let mut xopt = Some(move xwrite);\n+            let mut xopt = Some(xwrite);\n             do y.write_downgrade |_ywrite| {\n                 y.downgrade(option::swap_unwrap(&mut xopt));\n                 error!(\"oops, y.downgrade(x) should have failed!\");"}, {"sha": "6f479fbb9f7f583e06fa2f0c65ddf1ca0179f935", "filename": "src/libstd/task_pool.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask_pool.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -50,11 +50,11 @@ pub impl<T> TaskPool<T> {\n             let (port, chan) = pipes::stream::<Msg<T>>();\n             let init_fn = init_fn_factory();\n \n-            let task_body: ~fn() = |move port, move init_fn| {\n+            let task_body: ~fn() = || {\n                 let local_data = init_fn(i);\n                 loop {\n                     match port.recv() {\n-                        Execute(move f) => f(&local_data),\n+                        Execute(f) => f(&local_data),\n                         Quit => break\n                     }\n                 }\n@@ -64,23 +64,23 @@ pub impl<T> TaskPool<T> {\n             match opt_sched_mode {\n                 None => {\n                     // Run on this scheduler.\n-                    task::spawn(move task_body);\n+                    task::spawn(task_body);\n                 }\n                 Some(sched_mode) => {\n-                    task::task().sched_mode(sched_mode).spawn(move task_body);\n+                    task::task().sched_mode(sched_mode).spawn(task_body);\n                 }\n             }\n \n-            move chan\n+            chan\n         };\n \n-        return TaskPool { channels: move channels, next_index: 0 };\n+        return TaskPool { channels: channels, next_index: 0 };\n     }\n \n     /// Executes the function `f` on a task in the pool. The function\n     /// receives a reference to the local data returned by the `init_fn`.\n     fn execute(&self, f: ~fn(&T)) {\n-        self.channels[self.next_index].send(Execute(move f));\n+        self.channels[self.next_index].send(Execute(f));\n         self.next_index += 1;\n         if self.next_index == self.channels.len() { self.next_index = 0; }\n     }\n@@ -90,9 +90,9 @@ pub impl<T> TaskPool<T> {\n fn test_task_pool() {\n     let f: ~fn() -> ~fn(uint) -> uint = || {\n         let g: ~fn(uint) -> uint = |i| i;\n-        move g\n+        g\n     };\n-    let pool = TaskPool::new(4, Some(SingleThreaded), move f);\n+    let pool = TaskPool::new(4, Some(SingleThreaded), f);\n     for 8.times {\n         pool.execute(|i| io::println(fmt!(\"Hello from thread %u!\", *i)));\n     }"}, {"sha": "cd03de911839014d6911076b976cd46b4ee2c32f", "filename": "src/libstd/test.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -120,8 +120,8 @@ pub struct TestDescAndFn {\n pub fn test_main(args: &[~str], tests: ~[TestDescAndFn]) {\n     let opts =\n         match parse_opts(args) {\n-          either::Left(move o) => o,\n-          either::Right(move m) => fail!(m)\n+          either::Left(o) => o,\n+          either::Right(m) => fail!(m)\n         };\n     if !run_tests_console(&opts, tests) { fail!(~\"Some tests failed\"); }\n }\n@@ -173,8 +173,8 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n                  getopts::optopt(~\"logfile\")];\n     let matches =\n         match getopts::getopts(args_, opts) {\n-          Ok(move m) => m,\n-          Err(move f) => return either::Right(getopts::fail_str(f))\n+          Ok(m) => m,\n+          Err(f) => return either::Right(getopts::fail_str(f))\n         };\n \n     let filter =\n@@ -260,7 +260,7 @@ pub fn run_tests_console(opts: &TestOpts,\n                 st.failed += 1;\n                 write_failed(st.out, st.use_color);\n                 st.out.write_line(~\"\");\n-                st.failures.push(move test);\n+                st.failures.push(test);\n               }\n               TrIgnored => {\n                 st.ignored += 1;\n@@ -410,7 +410,7 @@ fn should_sort_failures_before_printing_them() {\n             mut failed: 0u,\n             mut ignored: 0u,\n             mut benchmarked: 0u,\n-            mut failures: ~[move test_b, move test_a]\n+            mut failures: ~[test_b, test_a]\n         };\n \n         print_failures(st);\n@@ -486,7 +486,7 @@ fn run_tests(opts: &TestOpts,\n         callback(TeWait(copy b.desc));\n         run_test(!opts.run_benchmarks, b, ch.clone());\n         let (test, result) = p.recv();\n-        callback(TeResult(move test, result));\n+        callback(TeResult(test, result));\n     }\n }\n \n@@ -514,7 +514,7 @@ pub fn filter_tests(\n \n     // Remove tests that don't match the test filter\n     filtered = if opts.filter.is_none() {\n-        move filtered\n+        filtered\n     } else {\n         let filter_str =\n             match opts.filter {\n@@ -534,7 +534,7 @@ pub fn filter_tests(\n \n     // Maybe pull out the ignored test and unignore them\n     filtered = if !opts.run_ignored {\n-        move filtered\n+        filtered\n     } else {\n         fn filter(test: TestDescAndFn) -> Option<TestDescAndFn> {\n             if test.desc.ignore {\n@@ -556,7 +556,7 @@ pub fn filter_tests(\n     }\n     sort::quick_sort(filtered, lteq);\n \n-    move filtered\n+    filtered\n }\n \n struct TestFuture {\n@@ -582,9 +582,9 @@ pub fn run_test(force_ignore: bool,\n         do task::spawn {\n             let mut result_future = None; // task::future_result(builder);\n             task::task().unlinked().future_result(|+r| {\n-                result_future = Some(move r);\n+                result_future = Some(r);\n             }).spawn(testfn_cell.take());\n-            let task_result = option::unwrap(move result_future).recv();\n+            let task_result = option::unwrap(result_future).recv();\n             let test_result = calc_result(&desc,\n                                           task_result == task::Success);\n             monitor_ch.send((desc, test_result));\n@@ -965,9 +965,9 @@ mod tests {\n                     },\n                     testfn: DynTestFn(copy testfn),\n                 };\n-                tests.push(move test);\n+                tests.push(test);\n             }\n-            move tests\n+            tests\n         };\n         let filtered = filter_tests(&opts, tests);\n \n@@ -980,7 +980,7 @@ mod tests {\n               ~\"test::parse_ignored_flag\",\n               ~\"test::sort_tests\"];\n \n-        let pairs = vec::zip(expected, move filtered);\n+        let pairs = vec::zip(expected, filtered);\n \n         for vec::each(pairs) |p| {\n             match *p {"}, {"sha": "0b8b6c8d34d68a341d8c6f890ca81f53b40e7f5c", "filename": "src/libstd/time.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -170,7 +170,7 @@ pub fn at_utc(clock: Timespec) -> Tm {\n         let mut Timespec { sec, nsec } = clock;\n         let mut tm = empty_tm();\n         rustrt::rust_gmtime(sec, nsec, tm);\n-        move tm\n+        tm\n     }\n }\n \n@@ -185,7 +185,7 @@ pub fn at(clock: Timespec) -> Tm {\n         let mut Timespec { sec, nsec } = clock;\n         let mut tm = empty_tm();\n         rustrt::rust_localtime(sec, nsec, tm);\n-        move tm\n+        tm\n     }\n }\n \n@@ -205,7 +205,7 @@ pub pure fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n pub pure fn strftime(format: &str, tm: &Tm) -> ~str {\n     // unsafe only because do_strftime is annoying to make pure\n     // (it does IO with a str_reader)\n-    move unsafe { do_strftime(format, tm) }\n+    unsafe { do_strftime(format, tm) }\n }\n \n impl Tm {\n@@ -240,7 +240,7 @@ impl Tm {\n \n     /// Formats the time according to the format string.\n     pure fn strftime(&self, format: &str) -> ~str {\n-        move strftime(format, self)\n+        strftime(format, self)\n     }\n \n     /**\n@@ -689,7 +689,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 '%' => {\n                     match parse_type(s, pos, rdr.read_char(), &mut tm) {\n                         Ok(next) => pos = next,\n-                        Err(move e) => { result = Err(move e); break; }\n+                        Err(e) => { result = Err(e); break; }\n                     }\n                 },\n                 c => {\n@@ -714,7 +714,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 tm_zone: copy tm.tm_zone,\n                 tm_nsec: tm.tm_nsec,\n             })\n-        } else { move result }\n+        } else { result }\n     }\n }\n \n@@ -882,7 +882,7 @@ priv fn do_strftime(format: &str, tm: &Tm) -> ~str {\n         }\n     }\n \n-    move buf\n+    buf\n }\n \n #[cfg(test)]"}, {"sha": "872d53e93ebbe70ef03c96c4c6eee447efa9d92d", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -98,7 +98,7 @@ fn get_monitor_task_gl() -> IoTask {\n \n fn spawn_loop() -> IoTask {\n     let builder = do task().add_wrapper |task_body| {\n-        fn~(move task_body) {\n+        fn~() {\n             // The I/O loop task also needs to be weak so it doesn't keep\n             // the runtime alive\n             unsafe {\n@@ -116,7 +116,7 @@ fn spawn_loop() -> IoTask {\n         }\n     };\n     let builder = builder.unlinked();\n-    spawn_iotask(move builder)\n+    spawn_iotask(builder)\n }\n \n #[cfg(test)]"}, {"sha": "be4240237adf426bd201920b211271f6ce9ec8d0", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -78,7 +78,7 @@ pub fn spawn_iotask(task: task::TaskBuilder) -> IoTask {\n  */\n pub unsafe fn interact(iotask: &IoTask,\n                    cb: fn~(*c_void)) {\n-    send_msg(iotask, Interaction(move cb));\n+    send_msg(iotask, Interaction(cb));\n }\n \n /**\n@@ -150,7 +150,7 @@ struct IoTaskLoopData {\n \n fn send_msg(iotask: &IoTask,\n             msg: IoTaskMsg) {\n-    iotask.op_chan.send(move msg);\n+    iotask.op_chan.send(msg);\n     unsafe {\n         ll::async_send(iotask.async_handle);\n     }"}, {"sha": "96b285b8c0a85c710a843330e196be8f8ae90ed8", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -1252,7 +1252,6 @@ pub mod test {\n                     get_data_for_uv_handle(stream as *libc::c_void)\n                       as *request_wrapper;\n                 let buf_base = get_base_from_buf(buf);\n-                let buf_len = get_len_from_buf(buf);\n                 let bytes = vec::from_buf(buf_base, nread as uint);\n                 let read_chan = (*client_data).read_chan.clone();\n                 let msg_from_server = str::from_bytes(bytes);"}, {"sha": "cb0f7d84b4117106de56bf632a7938b890e59171", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf51c2531bf754d5eaddaf7c5798b983d399751/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=4cf51c2531bf754d5eaddaf7c5798b983d399751", "patch": "@@ -235,7 +235,7 @@ fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n     do io::with_str_reader(s) |rdr| {\n         let j = result::unwrap(json::from_reader(rdr));\n-        Decodable::decode(&json::Decoder(move j))\n+        Decodable::decode(&json::Decoder(j))\n     }\n }\n \n@@ -323,37 +323,37 @@ impl TPrep for @Mut<Prep> {\n         Decodable<json::Decoder>>(&self,\n                                   blk: ~fn(&Exec) -> T) -> Work<T> {\n \n-        let mut bo = Some(move blk);\n+        let mut bo = Some(blk);\n \n         do self.borrow_imm |p| {\n             let cached = do p.ctxt.db.borrow_mut |db| {\n                 db.prepare(p.fn_name, &p.declared_inputs)\n             };\n \n-            match move cached {\n+            match cached {\n                 Some((ref disc_in, ref disc_out, ref res))\n                 if self.all_fresh(\"declared input\",\n                                   &p.declared_inputs) &&\n                 self.all_fresh(\"discovered input\", disc_in) &&\n                 self.all_fresh(\"discovered output\", disc_out) => {\n-                    Work::new(*self, move Left(json_decode(*res)))\n+                    Work::new(*self, Left(json_decode(*res)))\n                 }\n \n                 _ => {\n                     let (chan, port) = oneshot::init();\n                     let mut blk = None;\n                     blk <-> bo;\n                     let blk = blk.unwrap();\n-                    let chan = ~mut Some(move chan);\n-                    do task::spawn |move blk, move chan| {\n+                    let chan = ~mut Some(chan);\n+                    do task::spawn || {\n                         let exe = Exec{discovered_inputs: LinearMap::new(),\n                                        discovered_outputs: LinearMap::new()};\n                         let chan = option::swap_unwrap(&mut *chan);\n                         let v = blk(&exe);\n-                        send_one(move chan, (move exe, move v));\n+                        send_one(chan, (exe, v));\n                     }\n \n-                    Work::new(*self, move Right(move port))\n+                    Work::new(*self, Right(port))\n                 }\n             }\n         }\n@@ -365,7 +365,7 @@ impl<T:Owned\n        Decodable<json::Decoder>>\n     Work<T> {\n     static fn new(p: @Mut<Prep>, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n-        move Work { prep: p, res: Some(move e) }\n+        Work { prep: p, res: Some(e) }\n     }\n }\n \n@@ -374,18 +374,18 @@ fn unwrap<T:Owned\n             Encodable<json::Encoder>\n             Decodable<json::Decoder>>(w: Work<T>) -> T {\n \n-    let mut ww = move w;\n+    let mut ww = w;\n     let mut s = None;\n \n     ww.res <-> s;\n \n-    match move s {\n+    match s {\n         None => fail!(),\n-        Some(Left(move v)) => move v,\n-        Some(Right(move port)) => {\n+        Some(Left(v)) => v,\n+        Some(Right(port)) => {\n \n-            let (exe, v) = match recv(move port) {\n-                oneshot::send(move data) => move data\n+            let (exe, v) = match recv(port) {\n+                oneshot::send(data) => data\n             };\n \n             let s = json_encode(&v);\n@@ -399,7 +399,7 @@ fn unwrap<T:Owned\n                              s);\n                 }\n             }\n-            move v\n+            v\n         }\n     }\n }\n@@ -425,9 +425,9 @@ fn test() {\n         do prep.exec |_exe| {\n             let out = Path(\"foo.o\");\n             run::run_program(\"gcc\", [~\"foo.c\", ~\"-o\", out.to_str()]);\n-            move out.to_str()\n+            out.to_str()\n         }\n     };\n-    let s = unwrap(move w);\n+    let s = unwrap(w);\n     io::println(s);\n }"}]}