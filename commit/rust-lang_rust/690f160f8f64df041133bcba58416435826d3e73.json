{"sha": "690f160f8f64df041133bcba58416435826d3e73", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5MGYxNjBmOGY2NGRmMDQxMTMzYmNiYTU4NDE2NDM1ODI2ZDNlNzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-21T10:27:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-21T10:27:53Z"}, "message": "Auto merge of #32369 - frewsxcv:librustc-driver-lib, r=alexcrichton\n\nMinor cleanup for 'src/librustc_driver/lib.rs'\n\nReading through this file my first time. Cleaned up some stuff on the way.", "tree": {"sha": "1ee4bc0adbe44229248741031df2017ce8e0fb74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ee4bc0adbe44229248741031df2017ce8e0fb74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/690f160f8f64df041133bcba58416435826d3e73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/690f160f8f64df041133bcba58416435826d3e73", "html_url": "https://github.com/rust-lang/rust/commit/690f160f8f64df041133bcba58416435826d3e73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/690f160f8f64df041133bcba58416435826d3e73/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ec8f5c3699bf16c452cff6abaeda26abaeef02c", "html_url": "https://github.com/rust-lang/rust/commit/7ec8f5c3699bf16c452cff6abaeda26abaeef02c"}, {"sha": "4d52b0f5507f9c1f86035fa1bbee2b53dcaa08b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d52b0f5507f9c1f86035fa1bbee2b53dcaa08b6", "html_url": "https://github.com/rust-lang/rust/commit/4d52b0f5507f9c1f86035fa1bbee2b53dcaa08b6"}], "stats": {"total": 77, "additions": 36, "deletions": 41}, "files": [{"sha": "0fb192bb4db216704033d9bbabe23515ec3a41b5", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 36, "deletions": 41, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/690f160f8f64df041133bcba58416435826d3e73/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/690f160f8f64df041133bcba58416435826d3e73/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=690f160f8f64df041133bcba58416435826d3e73", "patch": "@@ -157,7 +157,7 @@ pub fn run_compiler<'a>(args: &[String],\n         }\n     }}\n \n-    let matches = match handle_options(args.to_vec()) {\n+    let matches = match handle_options(args) {\n         Some(matches) => matches,\n         None => return (Ok(()), None),\n     };\n@@ -335,10 +335,10 @@ pub struct RustcDefaultCalls;\n fn handle_explain(code: &str,\n                   descriptions: &diagnostics::registry::Registry,\n                   output: ErrorOutputType) {\n-    let normalised = if !code.starts_with(\"E\") {\n-        format!(\"E{0:0>4}\", code)\n-    } else {\n+    let normalised = if code.starts_with(\"E\") {\n         code.to_string()\n+    } else {\n+        format!(\"E{0:0>4}\", code)\n     };\n     match descriptions.find_description(&normalised) {\n         Some(ref description) => {\n@@ -870,9 +870,9 @@ fn print_flag_list<T>(cmdline_opt: &str,\n ///\n /// So with all that in mind, the comments below have some more detail about the\n /// contortions done here to get things to work out correctly.\n-pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n+pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     // Throw away the first argument, the name of the binary\n-    let _binary = args.remove(0);\n+    let args = &args[1..];\n \n     if args.is_empty() {\n         // user did not write `-v` nor `-Z unstable-options`, so do not\n@@ -916,10 +916,10 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n         if opt.stability == OptionStability::Stable {\n             continue\n         }\n-        let opt_name = if !opt.opt_group.long_name.is_empty() {\n-            &opt.opt_group.long_name\n-        } else {\n+        let opt_name = if opt.opt_group.long_name.is_empty() {\n             &opt.opt_group.short_name\n+        } else {\n+            &opt.opt_group.long_name\n         };\n         if !matches.opt_present(opt_name) {\n             continue\n@@ -1033,43 +1033,38 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n         cfg = cfg.stack_size(STACK_SIZE);\n     }\n \n-    match cfg.spawn(move || {\n-                 io::set_panic(box err);\n-                 f()\n-             })\n-             .unwrap()\n-             .join() {\n-        Ok(()) => {\n-            // fallthrough\n-        }\n-        Err(value) => {\n-            // Thread panicked without emitting a fatal diagnostic\n-            if !value.is::<errors::FatalError>() {\n-                let mut emitter = errors::emitter::BasicEmitter::stderr(errors::ColorConfig::Auto);\n-\n-                // a .span_bug or .bug call has already printed what\n-                // it wants to print.\n-                if !value.is::<errors::ExplicitBug>() {\n-                    emitter.emit(None, \"unexpected panic\", None, errors::Level::Bug);\n-                }\n+    let thread = cfg.spawn(move || {\n+         io::set_panic(box err);\n+         f()\n+     });\n \n-                let xs = [\"the compiler unexpectedly panicked. this is a bug.\".to_string(),\n-                          format!(\"we would appreciate a bug report: {}\", BUG_REPORT_URL)];\n-                for note in &xs {\n-                    emitter.emit(None, &note[..], None, errors::Level::Note)\n-                }\n-                if let None = env::var_os(\"RUST_BACKTRACE\") {\n-                    emitter.emit(None,\n-                                 \"run with `RUST_BACKTRACE=1` for a backtrace\",\n-                                 None,\n-                                 errors::Level::Note);\n-                }\n+     if let Err(value) = thread.unwrap().join() {\n+        // Thread panicked without emitting a fatal diagnostic\n+        if !value.is::<errors::FatalError>() {\n+            let mut emitter = errors::emitter::BasicEmitter::stderr(errors::ColorConfig::Auto);\n \n-                println!(\"{}\", str::from_utf8(&data.lock().unwrap()).unwrap());\n+            // a .span_bug or .bug call has already printed what\n+            // it wants to print.\n+            if !value.is::<errors::ExplicitBug>() {\n+                emitter.emit(None, \"unexpected panic\", None, errors::Level::Bug);\n             }\n \n-            exit_on_err();\n+            let xs = [\"the compiler unexpectedly panicked. this is a bug.\".to_string(),\n+                      format!(\"we would appreciate a bug report: {}\", BUG_REPORT_URL)];\n+            for note in &xs {\n+                emitter.emit(None, &note[..], None, errors::Level::Note)\n+            }\n+            if let None = env::var_os(\"RUST_BACKTRACE\") {\n+                emitter.emit(None,\n+                             \"run with `RUST_BACKTRACE=1` for a backtrace\",\n+                             None,\n+                             errors::Level::Note);\n+            }\n+\n+            println!(\"{}\", str::from_utf8(&data.lock().unwrap()).unwrap());\n         }\n+\n+        exit_on_err();\n     }\n }\n "}]}