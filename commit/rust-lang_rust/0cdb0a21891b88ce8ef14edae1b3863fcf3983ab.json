{"sha": "0cdb0a21891b88ce8ef14edae1b3863fcf3983ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjZGIwYTIxODkxYjg4Y2U4ZWYxNGVkYWUxYjM4NjNmY2YzOTgzYWI=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-07-19T17:55:12Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-07-20T00:37:43Z"}, "message": "remove dead take glue code paths\n\nCloses #7888", "tree": {"sha": "f554844c984e2605453b484bc8f72c1e4395a1cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f554844c984e2605453b484bc8f72c1e4395a1cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cdb0a21891b88ce8ef14edae1b3863fcf3983ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cdb0a21891b88ce8ef14edae1b3863fcf3983ab", "html_url": "https://github.com/rust-lang/rust/commit/0cdb0a21891b88ce8ef14edae1b3863fcf3983ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cdb0a21891b88ce8ef14edae1b3863fcf3983ab/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "404de4f4aed8902e882fda35565a3e6100f6743f", "url": "https://api.github.com/repos/rust-lang/rust/commits/404de4f4aed8902e882fda35565a3e6100f6743f", "html_url": "https://github.com/rust-lang/rust/commit/404de4f4aed8902e882fda35565a3e6100f6743f"}], "stats": {"total": 129, "additions": 4, "deletions": 125}, "files": [{"sha": "5e086f94f28676a040ffacca76eb3d87652d3a0c", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 47, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0cdb0a21891b88ce8ef14edae1b3863fcf3983ab/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cdb0a21891b88ce8ef14edae1b3863fcf3983ab/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=0cdb0a21891b88ce8ef14edae1b3863fcf3983ab", "patch": "@@ -13,15 +13,12 @@ use back::abi;\n use back::link::{mangle_internal_name_by_path_and_seq};\n use lib::llvm::{llvm, ValueRef};\n use middle::moves;\n-use middle::lang_items::ClosureExchangeMallocFnLangItem;\n use middle::trans::base::*;\n use middle::trans::build::*;\n-use middle::trans::callee;\n use middle::trans::common::*;\n use middle::trans::datum::{Datum, INIT, ByRef, ZeroMem};\n use middle::trans::expr;\n use middle::trans::glue;\n-use middle::trans::machine;\n use middle::trans::type_of::*;\n use middle::ty;\n use util::ppaux::ty_to_str;\n@@ -508,52 +505,9 @@ pub fn make_opaque_cbox_take_glue(\n             return bcx;\n         }\n         ast::OwnedSigil => {\n-            /* hard case: fallthrough to code below */\n+            fail!(\"unique closures are not copyable\")\n         }\n     }\n-\n-    // ~fn requires a deep copy.\n-    let ccx = bcx.ccx();\n-    let tcx = ccx.tcx;\n-    let llopaquecboxty = Type::opaque_box(ccx).ptr_to();\n-    let cbox_in = Load(bcx, cboxptr);\n-    do with_cond(bcx, IsNotNull(bcx, cbox_in)) |bcx| {\n-        // Load the size from the type descr found in the cbox\n-        let cbox_in = PointerCast(bcx, cbox_in, llopaquecboxty);\n-        let tydescptr = GEPi(bcx, cbox_in, [0u, abi::box_field_tydesc]);\n-        let tydesc = Load(bcx, tydescptr);\n-        let tydesc = PointerCast(bcx, tydesc, ccx.tydesc_type.ptr_to());\n-        let sz = Load(bcx, GEPi(bcx, tydesc, [0u, abi::tydesc_field_size]));\n-\n-        // Adjust sz to account for the rust_opaque_box header fields\n-        let sz = Add(bcx, sz, machine::llsize_of(ccx, Type::box_header(ccx)));\n-\n-        // Allocate memory, update original ptr, and copy existing data\n-        let opaque_tydesc = PointerCast(bcx, tydesc, Type::i8p());\n-        let mut bcx = bcx;\n-        let alloc_fn = langcall(bcx, None,\n-                                fmt!(\"allocation of type with sigil `%s`\",\n-                                    sigil.to_str()),\n-                                ClosureExchangeMallocFnLangItem);\n-        let llresult = unpack_result!(bcx, callee::trans_lang_call(\n-            bcx,\n-            alloc_fn,\n-            [opaque_tydesc, sz],\n-            None));\n-        let cbox_out = PointerCast(bcx, llresult, llopaquecboxty);\n-        call_memcpy(bcx, cbox_out, cbox_in, sz, 1);\n-        Store(bcx, cbox_out, cboxptr);\n-\n-        // Take the (deeply cloned) type descriptor\n-        let tydesc_out = GEPi(bcx, cbox_out, [0u, abi::box_field_tydesc]);\n-        let bcx = glue::take_ty(bcx, tydesc_out, ty::mk_type(tcx));\n-\n-        // Take the data in the tuple\n-        let cdata_out = GEPi(bcx, cbox_out, [0u, abi::box_field_body]);\n-        glue::call_tydesc_glue_full(bcx, cdata_out, tydesc,\n-                                    abi::tydesc_field_take_glue, None);\n-        bcx\n-    }\n }\n \n pub fn make_opaque_cbox_drop_glue("}, {"sha": "ffe6d22d5814f6125ef0c7281d90bb81dea17861", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 31, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0cdb0a21891b88ce8ef14edae1b3863fcf3983ab/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cdb0a21891b88ce8ef14edae1b3863fcf3983ab/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=0cdb0a21891b88ce8ef14edae1b3863fcf3983ab", "patch": "@@ -93,26 +93,6 @@ pub fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n     }\n }\n \n-pub fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> Result {\n-    let _icx = push_ctxt(\"take_ty_immediate\");\n-    match ty::get(t).sty {\n-      ty::ty_box(_) | ty::ty_opaque_box |\n-      ty::ty_evec(_, ty::vstore_box) |\n-      ty::ty_estr(ty::vstore_box) => {\n-        incr_refcnt_of_boxed(bcx, v);\n-        rslt(bcx, v)\n-      }\n-      ty::ty_uniq(_) => {\n-        uniq::duplicate(bcx, v, t)\n-      }\n-      ty::ty_evec(_, ty::vstore_uniq) |\n-      ty::ty_estr(ty::vstore_uniq) => {\n-        tvec::duplicate_uniq(bcx, v, t)\n-      }\n-      _ => rslt(bcx, v)\n-    }\n-}\n-\n pub fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"free_ty\");\n@@ -589,23 +569,15 @@ pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) -> block {\n       ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) => {\n         incr_refcnt_of_boxed(bcx, Load(bcx, v)); bcx\n       }\n-      ty::ty_uniq(_) => {\n-        let Result {bcx, val} = uniq::duplicate(bcx, Load(bcx, v), t);\n-        Store(bcx, val, v);\n-        bcx\n-      }\n-      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) => {\n-        let Result {bcx, val} = tvec::duplicate_uniq(bcx, Load(bcx, v), t);\n-        Store(bcx, val, v);\n-        bcx\n-      }\n       ty::ty_evec(_, ty::vstore_slice(_))\n       | ty::ty_estr(ty::vstore_slice(_)) => {\n         bcx\n       }\n-      ty::ty_closure(_) => {\n+      ty::ty_closure(ty::ClosureTy { sigil: ast::BorrowedSigil, _ }) |\n+      ty::ty_closure(ty::ClosureTy { sigil: ast::ManagedSigil, _ }) => {\n         closure::make_closure_glue(bcx, v, t, take_ty)\n       }\n+      ty::ty_closure(ty::ClosureTy { sigil: ast::OwnedSigil, _ }) => bcx,\n       ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n         let llbox = Load(bcx, GEPi(bcx, v, [0u, abi::trt_field_box]));\n         incr_refcnt_of_boxed(bcx, llbox);"}, {"sha": "8aca10f9b92e24d39e2d3eb3fee80a1f7edb81f6", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0cdb0a21891b88ce8ef14edae1b3863fcf3983ab/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cdb0a21891b88ce8ef14edae1b3863fcf3983ab/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=0cdb0a21891b88ce8ef14edae1b3863fcf3983ab", "patch": "@@ -130,23 +130,6 @@ pub fn alloc_vec(bcx: block,\n     return rslt(bcx, vptr);\n }\n \n-pub fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> Result {\n-    let _icx = push_ctxt(\"tvec::duplicate_uniq\");\n-\n-    let fill = get_fill(bcx, get_bodyptr(bcx, vptr, vec_ty));\n-    let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    let Result {bcx, val: newptr} = alloc_uniq_raw(bcx, unit_ty, fill, fill);\n-\n-    let data_ptr = get_dataptr(bcx, get_bodyptr(bcx, vptr, vec_ty));\n-    let new_data_ptr = get_dataptr(bcx, get_bodyptr(bcx, newptr, vec_ty));\n-    base::call_memcpy(bcx, new_data_ptr, data_ptr, fill, 1);\n-\n-    let bcx = if ty::type_needs_drop(bcx.tcx(), unit_ty) {\n-        iter_vec_raw(bcx, new_data_ptr, vec_ty, fill, glue::take_ty)\n-    } else { bcx };\n-    return rslt(bcx, newptr);\n-}\n-\n pub fn make_drop_glue_unboxed(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n    block {\n     let _icx = push_ctxt(\"tvec::make_drop_glue_unboxed\");"}, {"sha": "e9df83549e28dda9fb4719012131ed473ed8eca5", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0cdb0a21891b88ce8ef14edae1b3863fcf3983ab/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cdb0a21891b88ce8ef14edae1b3863fcf3983ab/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=0cdb0a21891b88ce8ef14edae1b3863fcf3983ab", "patch": "@@ -14,11 +14,8 @@ use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::common::*;\n use middle::trans::datum::immediate_rvalue;\n-use middle::trans::datum;\n use middle::trans::glue;\n use middle::ty;\n-use middle::trans::machine::llsize_of;\n-use middle::trans::type_of;\n \n pub fn make_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n     -> block {\n@@ -37,30 +34,3 @@ pub fn make_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n         }\n     }\n }\n-\n-pub fn duplicate(bcx: block, src_box: ValueRef, src_ty: ty::t) -> Result {\n-    let _icx = push_ctxt(\"uniq::duplicate\");\n-\n-    // Load the body of the source (*src)\n-    let src_datum = immediate_rvalue(src_box, src_ty);\n-    let body_datum = src_datum.box_body(bcx);\n-\n-    // Malloc space in exchange heap and copy src into it\n-    if ty::type_contents(bcx.tcx(), src_ty).contains_managed() {\n-        let MallocResult {\n-            bcx: bcx,\n-            box: dst_box,\n-            body: dst_body\n-        } = malloc_general(bcx, body_datum.ty, heap_managed_unique);\n-        body_datum.copy_to(bcx, datum::INIT, dst_body);\n-\n-        rslt(bcx, dst_box)\n-    } else {\n-        let body_datum = body_datum.to_value_datum(bcx);\n-        let llty = type_of(bcx.ccx(), body_datum.ty);\n-        let size = llsize_of(bcx.ccx(), llty);\n-        let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, body_datum.ty, heap_exchange, size);\n-        body_datum.copy_to(bcx, datum::INIT, val);\n-        Result { bcx: bcx, val: val }\n-    }\n-}"}]}