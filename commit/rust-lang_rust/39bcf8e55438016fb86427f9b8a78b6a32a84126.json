{"sha": "39bcf8e55438016fb86427f9b8a78b6a32a84126", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5YmNmOGU1NTQzODAxNmZiODY0MjdmOWI4YTc4YjZhMzJhODQxMjY=", "commit": {"author": {"name": "Eduardo Broto", "email": "ebroto@tutanota.com", "date": "2020-12-15T22:18:03Z"}, "committer": {"name": "Eduardo Broto", "email": "ebroto@tutanota.com", "date": "2020-12-15T22:18:03Z"}, "message": "Handle fatal errors when parsing doctests", "tree": {"sha": "3bfffd39dd1aa10f06a7b6597165b568289c5f10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bfffd39dd1aa10f06a7b6597165b568289c5f10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39bcf8e55438016fb86427f9b8a78b6a32a84126", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39bcf8e55438016fb86427f9b8a78b6a32a84126", "html_url": "https://github.com/rust-lang/rust/commit/39bcf8e55438016fb86427f9b8a78b6a32a84126", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39bcf8e55438016fb86427f9b8a78b6a32a84126/comments", "author": {"login": "ebroto", "id": 816908, "node_id": "MDQ6VXNlcjgxNjkwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/816908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebroto", "html_url": "https://github.com/ebroto", "followers_url": "https://api.github.com/users/ebroto/followers", "following_url": "https://api.github.com/users/ebroto/following{/other_user}", "gists_url": "https://api.github.com/users/ebroto/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebroto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebroto/subscriptions", "organizations_url": "https://api.github.com/users/ebroto/orgs", "repos_url": "https://api.github.com/users/ebroto/repos", "events_url": "https://api.github.com/users/ebroto/events{/privacy}", "received_events_url": "https://api.github.com/users/ebroto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ebroto", "id": 816908, "node_id": "MDQ6VXNlcjgxNjkwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/816908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebroto", "html_url": "https://github.com/ebroto", "followers_url": "https://api.github.com/users/ebroto/followers", "following_url": "https://api.github.com/users/ebroto/following{/other_user}", "gists_url": "https://api.github.com/users/ebroto/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebroto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebroto/subscriptions", "organizations_url": "https://api.github.com/users/ebroto/orgs", "repos_url": "https://api.github.com/users/ebroto/repos", "events_url": "https://api.github.com/users/ebroto/events{/privacy}", "received_events_url": "https://api.github.com/users/ebroto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c83e5684d653356155434849a6b14efc98afbf2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c83e5684d653356155434849a6b14efc98afbf2", "html_url": "https://github.com/rust-lang/rust/commit/6c83e5684d653356155434849a6b14efc98afbf2"}], "stats": {"total": 123, "additions": 68, "deletions": 55}, "files": [{"sha": "77203a286dd0fb9534386c25fc9778acde83e049", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 61, "deletions": 55, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/39bcf8e55438016fb86427f9b8a78b6a32a84126/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39bcf8e55438016fb86427f9b8a78b6a32a84126/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=39bcf8e55438016fb86427f9b8a78b6a32a84126", "patch": "@@ -451,66 +451,72 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n }\n \n fn check_code(cx: &LateContext<'_>, text: &str, span: Span) {\n-    fn has_needless_main(code: &str) -> bool {\n-        let filename = FileName::anon_source_code(code);\n-\n-        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-        let emitter = EmitterWriter::new(box io::sink(), None, false, false, false, None, false);\n-        let handler = Handler::with_emitter(false, None, box emitter);\n-        let sess = ParseSess::with_span_handler(handler, sm);\n-\n-        let mut parser = match maybe_new_parser_from_source_str(&sess, filename, code.into()) {\n-            Ok(p) => p,\n-            Err(errs) => {\n-                for mut err in errs {\n-                    err.cancel();\n-                }\n-                return false;\n-            },\n-        };\n-\n-        let mut relevant_main_found = false;\n-        loop {\n-            match parser.parse_item() {\n-                Ok(Some(item)) => match &item.kind {\n-                    // Tests with one of these items are ignored\n-                    ItemKind::Static(..)\n-                    | ItemKind::Const(..)\n-                    | ItemKind::ExternCrate(..)\n-                    | ItemKind::ForeignMod(..) => return false,\n-                    // We found a main function ...\n-                    ItemKind::Fn(_, sig, _, Some(block)) if item.ident.name == sym::main => {\n-                        let is_async = matches!(sig.header.asyncness, Async::Yes { .. });\n-                        let returns_nothing = match &sig.decl.output {\n-                            FnRetTy::Default(..) => true,\n-                            FnRetTy::Ty(ty) if ty.kind.is_unit() => true,\n-                            _ => false,\n-                        };\n-\n-                        if returns_nothing && !is_async && !block.stmts.is_empty() {\n-                            // This main function should be linted, but only if there are no other functions\n-                            relevant_main_found = true;\n-                        } else {\n-                            // This main function should not be linted, we're done\n-                            return false;\n+    fn has_needless_main(cx: &LateContext<'_>, code: &str) -> bool {\n+        rustc_driver::catch_fatal_errors(|| {\n+            rustc_span::with_session_globals(cx.tcx.sess.edition(), || {\n+                let filename = FileName::anon_source_code(code);\n+\n+                let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+                let emitter = EmitterWriter::new(box io::sink(), None, false, false, false, None, false);\n+                let handler = Handler::with_emitter(false, None, box emitter);\n+                let sess = ParseSess::with_span_handler(handler, sm);\n+\n+                let mut parser = match maybe_new_parser_from_source_str(&sess, filename, code.into()) {\n+                    Ok(p) => p,\n+                    Err(errs) => {\n+                        for mut err in errs {\n+                            err.cancel();\n                         }\n+                        return false;\n                     },\n-                    // Another function was found; this case is ignored too\n-                    ItemKind::Fn(..) => return false,\n-                    _ => {},\n-                },\n-                Ok(None) => break,\n-                Err(mut e) => {\n-                    e.cancel();\n-                    return false;\n-                },\n-            }\n-        }\n+                };\n+\n+                let mut relevant_main_found = false;\n+                loop {\n+                    match parser.parse_item() {\n+                        Ok(Some(item)) => match &item.kind {\n+                            // Tests with one of these items are ignored\n+                            ItemKind::Static(..)\n+                            | ItemKind::Const(..)\n+                            | ItemKind::ExternCrate(..)\n+                            | ItemKind::ForeignMod(..) => return false,\n+                            // We found a main function ...\n+                            ItemKind::Fn(_, sig, _, Some(block)) if item.ident.name == sym::main => {\n+                                let is_async = matches!(sig.header.asyncness, Async::Yes { .. });\n+                                let returns_nothing = match &sig.decl.output {\n+                                    FnRetTy::Default(..) => true,\n+                                    FnRetTy::Ty(ty) if ty.kind.is_unit() => true,\n+                                    _ => false,\n+                                };\n+\n+                                if returns_nothing && !is_async && !block.stmts.is_empty() {\n+                                    // This main function should be linted, but only if there are no other functions\n+                                    relevant_main_found = true;\n+                                } else {\n+                                    // This main function should not be linted, we're done\n+                                    return false;\n+                                }\n+                            },\n+                            // Another function was found; this case is ignored too\n+                            ItemKind::Fn(..) => return false,\n+                            _ => {},\n+                        },\n+                        Ok(None) => break,\n+                        Err(mut e) => {\n+                            e.cancel();\n+                            return false;\n+                        },\n+                    }\n+                }\n \n-        relevant_main_found\n+                relevant_main_found\n+            })\n+        })\n+        .ok()\n+        .unwrap_or_default()\n     }\n \n-    if has_needless_main(text) {\n+    if has_needless_main(cx, text) {\n         span_lint(cx, NEEDLESS_DOCTEST_MAIN, span, \"needless `fn main` in doctest\");\n     }\n }"}, {"sha": "651b9e711318b17fcb79ad4f47b34add53a40736", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39bcf8e55438016fb86427f9b8a78b6a32a84126/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39bcf8e55438016fb86427f9b8a78b6a32a84126/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=39bcf8e55438016fb86427f9b8a78b6a32a84126", "patch": "@@ -27,6 +27,7 @@ extern crate rustc_ast;\n extern crate rustc_ast_pretty;\n extern crate rustc_attr;\n extern crate rustc_data_structures;\n+extern crate rustc_driver;\n extern crate rustc_errors;\n extern crate rustc_hir;\n extern crate rustc_hir_pretty;"}, {"sha": "52c84089fa8ec84983805e952e6b561b1c6821fd", "filename": "tests/ui/needless_doc_main.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39bcf8e55438016fb86427f9b8a78b6a32a84126/tests%2Fui%2Fneedless_doc_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39bcf8e55438016fb86427f9b8a78b6a32a84126/tests%2Fui%2Fneedless_doc_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_doc_main.rs?ref=39bcf8e55438016fb86427f9b8a78b6a32a84126", "patch": "@@ -128,6 +128,12 @@ fn bad_doctests() {}\n /// ```\n fn no_false_positives() {}\n \n+/// Yields a parse error when interpreted as rust code:\n+/// ```\n+/// r#\"hi\"\n+/// ```\n+fn issue_6022() {}\n+\n fn main() {\n     bad_doctests();\n     no_false_positives();"}]}