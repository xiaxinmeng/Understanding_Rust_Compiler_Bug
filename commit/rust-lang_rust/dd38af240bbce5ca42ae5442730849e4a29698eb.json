{"sha": "dd38af240bbce5ca42ae5442730849e4a29698eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkMzhhZjI0MGJiY2U1Y2E0MmFlNTQ0MjczMDg0OWU0YTI5Njk4ZWI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-26T06:51:32Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-29T03:41:56Z"}, "message": "compiletest: Allow legacy records\n\nBut also remove most uses of structural records.", "tree": {"sha": "d4951ceff655d19663a9676d3dc7cff3865df476", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4951ceff655d19663a9676d3dc7cff3865df476"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd38af240bbce5ca42ae5442730849e4a29698eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd38af240bbce5ca42ae5442730849e4a29698eb", "html_url": "https://github.com/rust-lang/rust/commit/dd38af240bbce5ca42ae5442730849e4a29698eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd38af240bbce5ca42ae5442730849e4a29698eb/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5461e46aecbf42a23bdecb4cc3f8320fba2866b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5461e46aecbf42a23bdecb4cc3f8320fba2866b", "html_url": "https://github.com/rust-lang/rust/commit/c5461e46aecbf42a23bdecb4cc3f8320fba2866b"}], "stats": {"total": 203, "additions": 103, "deletions": 100}, "files": [{"sha": "8a868e14f08e30a2a67d0a6334b59177771217df", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd38af240bbce5ca42ae5442730849e4a29698eb/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/dd38af240bbce5ca42ae5442730849e4a29698eb/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=dd38af240bbce5ca42ae5442730849e4a29698eb", "patch": "@@ -12,6 +12,7 @@\n \n #[no_core];\n #[legacy_exports];\n+#[legacy_records];\n \n #[allow(vecs_implicitly_copyable)];\n #[allow(non_camel_case_types)];"}, {"sha": "2dc48118edd62137431a2671e48d0d375b873ab8", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dd38af240bbce5ca42ae5442730849e4a29698eb/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd38af240bbce5ca42ae5442730849e4a29698eb/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=dd38af240bbce5ca42ae5442730849e4a29698eb", "patch": "@@ -16,12 +16,12 @@ use io::ReaderUtil;\n use str;\n \n export load_errors;\n-export expected_error;\n+export ExpectedError;\n \n-type expected_error = { line: uint, kind: ~str, msg: ~str };\n+struct ExpectedError { line: uint, kind: ~str, msg: ~str }\n \n // Load any test directives embedded in the file\n-fn load_errors(testfile: &Path) -> ~[expected_error] {\n+fn load_errors(testfile: &Path) -> ~[ExpectedError] {\n     let mut error_patterns = ~[];\n     let rdr = io::file_reader(testfile).get();\n     let mut line_num = 1u;\n@@ -33,7 +33,7 @@ fn load_errors(testfile: &Path) -> ~[expected_error] {\n     return error_patterns;\n }\n \n-fn parse_expected(line_num: uint, line: ~str) -> ~[expected_error] {\n+fn parse_expected(line_num: uint, line: ~str) -> ~[ExpectedError] {\n     unsafe {\n         let error_tag = ~\"//~\";\n         let mut idx;\n@@ -63,6 +63,7 @@ fn parse_expected(line_num: uint, line: ~str) -> ~[expected_error] {\n \n         debug!(\"line=%u kind=%s msg=%s\", line_num - adjust_line, kind, msg);\n \n-        return ~[{line: line_num - adjust_line, kind: kind, msg: msg}];\n+        return ~[ExpectedError{line: line_num - adjust_line, kind: kind,\n+                               msg: msg}];\n     }\n }"}, {"sha": "db6677347cc623a6056b39f867ffb1e6a423c8c2", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd38af240bbce5ca42ae5442730849e4a29698eb/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd38af240bbce5ca42ae5442730849e4a29698eb/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=dd38af240bbce5ca42ae5442730849e4a29698eb", "patch": "@@ -17,11 +17,11 @@ use io::ReaderUtil;\n use os;\n use str;\n \n-export test_props;\n+export TestProps;\n export load_props;\n export is_test_ignored;\n \n-type test_props = {\n+struct TestProps {\n     // Lines that should be expected, in order, on standard out\n     error_patterns: ~[~str],\n     // Extra flags to pass to the compiler\n@@ -33,10 +33,10 @@ type test_props = {\n     aux_builds: ~[~str],\n     // Environment settings to use during execution\n     exec_env: ~[(~str,~str)]\n-};\n+}\n \n // Load any test directives embedded in the file\n-fn load_props(testfile: &Path) -> test_props {\n+fn load_props(testfile: &Path) -> TestProps {\n     let mut error_patterns = ~[];\n     let mut aux_builds = ~[];\n     let mut exec_env = ~[];\n@@ -64,7 +64,7 @@ fn load_props(testfile: &Path) -> test_props {\n             exec_env.push(*ee);\n         }\n     };\n-    return {\n+    return TestProps {\n         error_patterns: error_patterns,\n         compile_flags: compile_flags,\n         pp_exact: pp_exact,"}, {"sha": "398820a5a6380105608640ac897ad8c146292f3f", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dd38af240bbce5ca42ae5442730849e4a29698eb/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd38af240bbce5ca42ae5442730849e4a29698eb/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=dd38af240bbce5ca42ae5442730849e4a29698eb", "patch": "@@ -51,13 +51,14 @@ fn target_env(_lib_path: ~str, _prog: ~str) -> ~[(~str,~str)] {\n     ~[]\n }\n \n+struct Result {status: int, out: ~str, err: ~str}\n \n // FIXME (#2659): This code is duplicated in core::run::program_output\n fn run(lib_path: ~str,\n        prog: ~str,\n        args: ~[~str],\n        env: ~[(~str, ~str)],\n-       input: Option<~str>) -> {status: int, out: ~str, err: ~str} {\n+       input: Option<~str>) -> Result {\n \n     let pipe_in = os::pipe();\n     let pipe_out = os::pipe();\n@@ -105,7 +106,7 @@ fn run(lib_path: ~str,\n         };\n         count -= 1;\n     };\n-    return {status: status, out: outs, err: errs};\n+    return Result {status: status, out: outs, err: errs};\n }\n \n fn writeclose(fd: c_int, s: Option<~str>) {"}, {"sha": "5ccad97dce3ca12747f7fd5b7b8d2eba773bdaa4", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 88, "deletions": 88, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/dd38af240bbce5ca42ae5442730849e4a29698eb/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd38af240bbce5ca42ae5442730849e4a29698eb/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=dd38af240bbce5ca42ae5442730849e4a29698eb", "patch": "@@ -26,7 +26,7 @@ use common::config;\n use errors;\n use header;\n use header::load_props;\n-use header::test_props;\n+use header::TestProps;\n use procsrv;\n use util;\n use util::logv;\n@@ -49,32 +49,32 @@ fn run(config: config, testfile: ~str) {\n     }\n }\n \n-fn run_cfail_test(config: config, props: test_props, testfile: &Path) {\n-    let procres = compile_test(config, props, testfile);\n+fn run_cfail_test(config: config, props: TestProps, testfile: &Path) {\n+    let ProcRes = compile_test(config, props, testfile);\n \n-    if procres.status == 0 {\n-        fatal_procres(~\"compile-fail test compiled successfully!\", procres);\n+    if ProcRes.status == 0 {\n+        fatal_ProcRes(~\"compile-fail test compiled successfully!\", ProcRes);\n     }\n \n-    check_correct_failure_status(procres);\n+    check_correct_failure_status(ProcRes);\n \n     let expected_errors = errors::load_errors(testfile);\n     if !expected_errors.is_empty() {\n         if !props.error_patterns.is_empty() {\n             fatal(~\"both error pattern and expected errors specified\");\n         }\n-        check_expected_errors(expected_errors, testfile, procres);\n+        check_expected_errors(expected_errors, testfile, ProcRes);\n     } else {\n-        check_error_patterns(props, testfile, procres);\n+        check_error_patterns(props, testfile, ProcRes);\n     }\n }\n \n-fn run_rfail_test(config: config, props: test_props, testfile: &Path) {\n-    let procres = if !config.jit {\n-        let procres = compile_test(config, props, testfile);\n+fn run_rfail_test(config: config, props: TestProps, testfile: &Path) {\n+    let ProcRes = if !config.jit {\n+        let ProcRes = compile_test(config, props, testfile);\n \n-        if procres.status != 0 {\n-            fatal_procres(~\"compilation failed!\", procres);\n+        if ProcRes.status != 0 {\n+            fatal_ProcRes(~\"compilation failed!\", ProcRes);\n         }\n \n         exec_compiled_test(config, props, testfile)\n@@ -84,46 +84,46 @@ fn run_rfail_test(config: config, props: test_props, testfile: &Path) {\n \n     // The value our Makefile configures valgrind to return on failure\n     const valgrind_err: int = 100;\n-    if procres.status == valgrind_err {\n-        fatal_procres(~\"run-fail test isn't valgrind-clean!\", procres);\n+    if ProcRes.status == valgrind_err {\n+        fatal_ProcRes(~\"run-fail test isn't valgrind-clean!\", ProcRes);\n     }\n \n-    check_correct_failure_status(procres);\n-    check_error_patterns(props, testfile, procres);\n+    check_correct_failure_status(ProcRes);\n+    check_error_patterns(props, testfile, ProcRes);\n }\n \n-fn check_correct_failure_status(procres: procres) {\n+fn check_correct_failure_status(ProcRes: ProcRes) {\n     // The value the rust runtime returns on failure\n     const rust_err: int = 101;\n-    if procres.status != rust_err {\n-        fatal_procres(\n+    if ProcRes.status != rust_err {\n+        fatal_ProcRes(\n             fmt!(\"failure produced the wrong error code: %d\",\n-                 procres.status),\n-            procres);\n+                 ProcRes.status),\n+            ProcRes);\n     }\n }\n \n-fn run_rpass_test(config: config, props: test_props, testfile: &Path) {\n+fn run_rpass_test(config: config, props: TestProps, testfile: &Path) {\n     if !config.jit {\n-        let mut procres = compile_test(config, props, testfile);\n+        let mut ProcRes = compile_test(config, props, testfile);\n \n-        if procres.status != 0 {\n-            fatal_procres(~\"compilation failed!\", procres);\n+        if ProcRes.status != 0 {\n+            fatal_ProcRes(~\"compilation failed!\", ProcRes);\n         }\n \n-        procres = exec_compiled_test(config, props, testfile);\n+        ProcRes = exec_compiled_test(config, props, testfile);\n \n-        if procres.status != 0 {\n-            fatal_procres(~\"test run failed!\", procres);\n+        if ProcRes.status != 0 {\n+            fatal_ProcRes(~\"test run failed!\", ProcRes);\n         }\n     } else {\n-        let mut procres = jit_test(config, props, testfile);\n+        let mut ProcRes = jit_test(config, props, testfile);\n \n-        if procres.status != 0 { fatal_procres(~\"jit failed!\", procres); }\n+        if ProcRes.status != 0 { fatal_ProcRes(~\"jit failed!\", ProcRes); }\n     }\n }\n \n-fn run_pretty_test(config: config, props: test_props, testfile: &Path) {\n+fn run_pretty_test(config: config, props: TestProps, testfile: &Path) {\n     if props.pp_exact.is_some() {\n         logv(config, ~\"testing for exact pretty-printing\");\n     } else { logv(config, ~\"testing for converging pretty-printing\"); }\n@@ -136,14 +136,14 @@ fn run_pretty_test(config: config, props: test_props, testfile: &Path) {\n     let mut round = 0;\n     while round < rounds {\n         logv(config, fmt!(\"pretty-printing round %d\", round));\n-        let procres = print_source(config, testfile, srcs[round]);\n+        let ProcRes = print_source(config, testfile, srcs[round]);\n \n-        if procres.status != 0 {\n-            fatal_procres(fmt!(\"pretty-printing failed in round %d\", round),\n-                          procres);\n+        if ProcRes.status != 0 {\n+            fatal_ProcRes(fmt!(\"pretty-printing failed in round %d\", round),\n+                          ProcRes);\n         }\n \n-        srcs.push(procres.stdout);\n+        srcs.push(ProcRes.stdout);\n         round += 1;\n     }\n \n@@ -167,23 +167,23 @@ fn run_pretty_test(config: config, props: test_props, testfile: &Path) {\n     compare_source(expected, actual);\n \n     // Finally, let's make sure it actually appears to remain valid code\n-    let procres = typecheck_source(config, props, testfile, actual);\n+    let ProcRes = typecheck_source(config, props, testfile, actual);\n \n-    if procres.status != 0 {\n-        fatal_procres(~\"pretty-printed source does not typecheck\", procres);\n+    if ProcRes.status != 0 {\n+        fatal_ProcRes(~\"pretty-printed source does not typecheck\", ProcRes);\n     }\n \n     return;\n \n-    fn print_source(config: config, testfile: &Path, src: ~str) -> procres {\n+    fn print_source(config: config, testfile: &Path, src: ~str) -> ProcRes {\n         compose_and_run(config, testfile, make_pp_args(config, testfile),\n                         ~[], config.compile_lib_path, Some(src))\n     }\n \n-    fn make_pp_args(config: config, _testfile: &Path) -> procargs {\n+    fn make_pp_args(config: config, _testfile: &Path) -> ProcArgs {\n         let prog = config.rustc_path;\n         let args = ~[~\"-\", ~\"--pretty\", ~\"normal\"];\n-        return {prog: prog.to_str(), args: args};\n+        return ProcArgs {prog: prog.to_str(), args: args};\n     }\n \n     fn compare_source(expected: ~str, actual: ~str) {\n@@ -206,41 +206,41 @@ actual:\\n\\\n         }\n     }\n \n-    fn typecheck_source(config: config, props: test_props,\n-                        testfile: &Path, src: ~str) -> procres {\n+    fn typecheck_source(config: config, props: TestProps,\n+                        testfile: &Path, src: ~str) -> ProcRes {\n         compose_and_run_compiler(\n             config, props, testfile,\n             make_typecheck_args(config, testfile),\n             Some(src))\n     }\n \n-    fn make_typecheck_args(config: config, testfile: &Path) -> procargs {\n+    fn make_typecheck_args(config: config, testfile: &Path) -> ProcArgs {\n         let prog = config.rustc_path;\n         let mut args = ~[~\"-\",\n                          ~\"--no-trans\", ~\"--lib\",\n                          ~\"-L\", config.build_base.to_str(),\n                          ~\"-L\",\n                          aux_output_dir_name(config, testfile).to_str()];\n         args += split_maybe_args(config.rustcflags);\n-        return {prog: prog.to_str(), args: args};\n+        return ProcArgs {prog: prog.to_str(), args: args};\n     }\n }\n \n-fn check_error_patterns(props: test_props,\n+fn check_error_patterns(props: TestProps,\n                         testfile: &Path,\n-                        procres: procres) {\n+                        ProcRes: ProcRes) {\n     if vec::is_empty(props.error_patterns) {\n         fatal(~\"no error pattern specified in \" + testfile.to_str());\n     }\n \n-    if procres.status == 0 {\n+    if ProcRes.status == 0 {\n         fatal(~\"process did not return an error status\");\n     }\n \n     let mut next_err_idx = 0u;\n     let mut next_err_pat = props.error_patterns[next_err_idx];\n     let mut done = false;\n-    for str::split_char(procres.stderr, '\\n').each |line| {\n+    for str::split_char(ProcRes.stderr, '\\n').each |line| {\n         if str::contains(*line, next_err_pat) {\n             debug!(\"found error pattern %s\", next_err_pat);\n             next_err_idx += 1u;\n@@ -258,25 +258,25 @@ fn check_error_patterns(props: test_props,\n         vec::slice(props.error_patterns, next_err_idx,\n                    vec::len(props.error_patterns));\n     if vec::len(missing_patterns) == 1u {\n-        fatal_procres(fmt!(\"error pattern '%s' not found!\",\n-                           missing_patterns[0]), procres);\n+        fatal_ProcRes(fmt!(\"error pattern '%s' not found!\",\n+                           missing_patterns[0]), ProcRes);\n     } else {\n         for missing_patterns.each |pattern| {\n             error(fmt!(\"error pattern '%s' not found!\", *pattern));\n         }\n-        fatal_procres(~\"multiple error patterns not found\", procres);\n+        fatal_ProcRes(~\"multiple error patterns not found\", ProcRes);\n     }\n }\n \n-fn check_expected_errors(expected_errors: ~[errors::expected_error],\n+fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n                          testfile: &Path,\n-                         procres: procres) {\n+                         ProcRes: ProcRes) {\n \n     // true if we found the error in question\n     let found_flags = vec::cast_to_mut(vec::from_elem(\n         vec::len(expected_errors), false));\n \n-    if procres.status == 0 {\n+    if ProcRes.status == 0 {\n         fatal(~\"process did not return an error status\");\n     }\n \n@@ -290,7 +290,7 @@ fn check_expected_errors(expected_errors: ~[errors::expected_error],\n     //    filename:line1:col1: line2:col2: *warning:* msg\n     // where line1:col1: is the starting point, line2:col2:\n     // is the ending point, and * represents ANSI color codes.\n-    for str::split_char(procres.stderr, '\\n').each |line| {\n+    for str::split_char(ProcRes.stderr, '\\n').each |line| {\n         let mut was_expected = false;\n         for vec::eachi(expected_errors) |i, ee| {\n             if !found_flags[i] {\n@@ -312,17 +312,17 @@ fn check_expected_errors(expected_errors: ~[errors::expected_error],\n         }\n \n         if !was_expected && is_compiler_error_or_warning(*line) {\n-            fatal_procres(fmt!(\"unexpected compiler error or warning: '%s'\",\n+            fatal_ProcRes(fmt!(\"unexpected compiler error or warning: '%s'\",\n                                *line),\n-                          procres);\n+                          ProcRes);\n         }\n     }\n \n     for uint::range(0u, vec::len(found_flags)) |i| {\n         if !found_flags[i] {\n             let ee = expected_errors[i];\n-            fatal_procres(fmt!(\"expected %s on line %u not found: %s\",\n-                               ee.kind, ee.line, ee.msg), procres);\n+            fatal_ProcRes(fmt!(\"expected %s on line %u not found: %s\",\n+                               ee.kind, ee.line, ee.msg), ProcRes);\n         }\n     }\n }\n@@ -402,21 +402,21 @@ fn scan_string(haystack: ~str, needle: ~str, idx: &mut uint) -> bool {\n     return true;\n }\n \n-type procargs = {prog: ~str, args: ~[~str]};\n+struct ProcArgs {prog: ~str, args: ~[~str]}\n \n-type procres = {status: int, stdout: ~str, stderr: ~str, cmdline: ~str};\n+struct ProcRes {status: int, stdout: ~str, stderr: ~str, cmdline: ~str}\n \n-fn compile_test(config: config, props: test_props,\n-                testfile: &Path) -> procres {\n+fn compile_test(config: config, props: TestProps,\n+                testfile: &Path) -> ProcRes {\n     compile_test_(config, props, testfile, [])\n }\n \n-fn jit_test(config: config, props: test_props, testfile: &Path) -> procres {\n+fn jit_test(config: config, props: TestProps, testfile: &Path) -> ProcRes {\n     compile_test_(config, props, testfile, [~\"--jit\"])\n }\n \n-fn compile_test_(config: config, props: test_props,\n-                 testfile: &Path, extra_args: &[~str]) -> procres {\n+fn compile_test_(config: config, props: TestProps,\n+                 testfile: &Path, extra_args: &[~str]) -> ProcRes {\n     let link_args = ~[~\"-L\", aux_output_dir_name(config, testfile).to_str()];\n     compose_and_run_compiler(\n         config, props, testfile,\n@@ -425,8 +425,8 @@ fn compile_test_(config: config, props: test_props,\n         None)\n }\n \n-fn exec_compiled_test(config: config, props: test_props,\n-                      testfile: &Path) -> procres {\n+fn exec_compiled_test(config: config, props: TestProps,\n+                      testfile: &Path) -> ProcRes {\n     compose_and_run(config, testfile,\n                     make_run_args(config, props, testfile),\n                     props.exec_env,\n@@ -435,10 +435,10 @@ fn exec_compiled_test(config: config, props: test_props,\n \n fn compose_and_run_compiler(\n     config: config,\n-    props: test_props,\n+    props: TestProps,\n     testfile: &Path,\n-    args: procargs,\n-    input: Option<~str>) -> procres {\n+    args: ProcArgs,\n+    input: Option<~str>) -> ProcRes {\n \n     if !props.aux_builds.is_empty() {\n         ensure_dir(&aux_output_dir_name(config, testfile));\n@@ -455,7 +455,7 @@ fn compose_and_run_compiler(\n         let auxres = compose_and_run(config, &abs_ab, aux_args, ~[],\n                                      config.compile_lib_path, None);\n         if auxres.status != 0 {\n-            fatal_procres(\n+            fatal_ProcRes(\n                 fmt!(\"auxiliary build of %s failed to compile: \",\n                      abs_ab.to_str()),\n                 auxres);\n@@ -474,25 +474,25 @@ fn ensure_dir(path: &Path) {\n }\n \n fn compose_and_run(config: config, testfile: &Path,\n-                   procargs: procargs,\n+                   ProcArgs: ProcArgs,\n                    procenv: ~[(~str, ~str)],\n                    lib_path: ~str,\n-                   input: Option<~str>) -> procres {\n+                   input: Option<~str>) -> ProcRes {\n     return program_output(config, testfile, lib_path,\n-                       procargs.prog, procargs.args, procenv, input);\n+                       ProcArgs.prog, ProcArgs.args, procenv, input);\n }\n \n-fn make_compile_args(config: config, props: test_props, extras: ~[~str],\n+fn make_compile_args(config: config, props: TestProps, extras: ~[~str],\n                      xform: fn(config, (&Path)) -> Path,\n-                     testfile: &Path) -> procargs {\n+                     testfile: &Path) -> ProcArgs {\n     let prog = config.rustc_path;\n     let mut args = ~[testfile.to_str(),\n                      ~\"-o\", xform(config, testfile).to_str(),\n                      ~\"-L\", config.build_base.to_str()]\n         + extras;\n     args += split_maybe_args(config.rustcflags);\n     args += split_maybe_args(props.compile_flags);\n-    return {prog: prog.to_str(), args: args};\n+    return ProcArgs {prog: prog.to_str(), args: args};\n }\n \n fn make_lib_name(config: config, auxfile: &Path, testfile: &Path) -> Path {\n@@ -507,8 +507,8 @@ fn make_exe_name(config: config, testfile: &Path) -> Path {\n             str::from_slice(os::EXE_SUFFIX))\n }\n \n-fn make_run_args(config: config, _props: test_props, testfile: &Path) ->\n-   procargs {\n+fn make_run_args(config: config, _props: TestProps, testfile: &Path) ->\n+   ProcArgs {\n     let toolargs = {\n             // If we've got another tool to run under (valgrind),\n             // then split apart its command\n@@ -521,7 +521,7 @@ fn make_run_args(config: config, _props: test_props, testfile: &Path) ->\n         };\n \n     let args = toolargs + ~[make_exe_name(config, testfile).to_str()];\n-    return {prog: args[0], args: vec::slice(args, 1u, vec::len(args))};\n+    return ProcArgs {prog: args[0], args: vec::slice(args, 1, args.len())};\n }\n \n fn split_maybe_args(argstr: Option<~str>) -> ~[~str] {\n@@ -537,7 +537,7 @@ fn split_maybe_args(argstr: Option<~str>) -> ~[~str] {\n \n fn program_output(config: config, testfile: &Path, lib_path: ~str, prog: ~str,\n                   args: ~[~str], env: ~[(~str, ~str)],\n-                  input: Option<~str>) -> procres {\n+                  input: Option<~str>) -> ProcRes {\n     let cmdline =\n         {\n             let cmdline = make_cmdline(lib_path, prog, args);\n@@ -546,7 +546,7 @@ fn program_output(config: config, testfile: &Path, lib_path: ~str, prog: ~str,\n         };\n     let res = procsrv::run(lib_path, prog, args, env, input);\n     dump_output(config, testfile, res.out, res.err);\n-    return {status: res.status,\n+    return ProcRes {status: res.status,\n          stdout: res.out,\n          stderr: res.err,\n          cmdline: cmdline};\n@@ -621,7 +621,7 @@ fn error(err: ~str) { io::stdout().write_line(fmt!(\"\\nerror: %s\", err)); }\n \n fn fatal(err: ~str) -> ! { error(err); fail; }\n \n-fn fatal_procres(err: ~str, procres: procres) -> ! {\n+fn fatal_ProcRes(err: ~str, ProcRes: ProcRes) -> ! {\n     let msg =\n         fmt!(\"\\n\\\n error: %s\\n\\\n@@ -635,7 +635,7 @@ stderr:\\n\\\n %s\\n\\\n ------------------------------------------\\n\\\n \\n\",\n-             err, procres.cmdline, procres.stdout, procres.stderr);\n+             err, ProcRes.cmdline, ProcRes.stdout, ProcRes.stderr);\n     io::stdout().write_str(msg);\n     fail;\n }"}]}