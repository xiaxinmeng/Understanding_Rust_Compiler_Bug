{"sha": "acf50b79beb5909c16861cc7c91e8226b7f78272", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjZjUwYjc5YmViNTkwOWMxNjg2MWNjN2M5MWU4MjI2YjdmNzgyNzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-30T07:10:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-30T07:10:18Z"}, "message": "Auto merge of #51806 - oli-obk:lowering_cleanups1, r=cramertj\n\nLowering cleanups [1/N]", "tree": {"sha": "19e6e9829d02f450633734a93c3678b6d1720e2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19e6e9829d02f450633734a93c3678b6d1720e2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/acf50b79beb5909c16861cc7c91e8226b7f78272", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/acf50b79beb5909c16861cc7c91e8226b7f78272", "html_url": "https://github.com/rust-lang/rust/commit/acf50b79beb5909c16861cc7c91e8226b7f78272", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/acf50b79beb5909c16861cc7c91e8226b7f78272/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87ecf5442ced38a6253e670dd6d87c0c334b21fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/87ecf5442ced38a6253e670dd6d87c0c334b21fb", "html_url": "https://github.com/rust-lang/rust/commit/87ecf5442ced38a6253e670dd6d87c0c334b21fb"}, {"sha": "99575b5cac73a71685a783262249d803001a06a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/99575b5cac73a71685a783262249d803001a06a8", "html_url": "https://github.com/rust-lang/rust/commit/99575b5cac73a71685a783262249d803001a06a8"}], "stats": {"total": 323, "additions": 207, "deletions": 116}, "files": [{"sha": "c5e5fa65fc69e75fc2814ca3c97c46e33380cace", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=acf50b79beb5909c16861cc7c91e8226b7f78272", "patch": "@@ -607,9 +607,11 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             }\n             visitor.visit_lifetime(lifetime);\n         }\n-        TyImplTraitExistential(item_id, def_id, ref lifetimes) => {\n+        TyImplTraitExistential(_, def_id, ref lifetimes) => {\n+            // we are not recursing into the `existential` item, because it is already being visited\n+            // as part of the surrounding module. The `NodeId` just exists so we don't have to look\n+            // it up everywhere else in the compiler\n             visitor.visit_def_mention(Def::Existential(def_id));\n-            visitor.visit_nested_item(item_id);\n             walk_list!(visitor, visit_lifetime, lifetimes);\n         }\n         TyTypeof(ref expression) => {"}, {"sha": "0bd5b6b627fe17018ae5538b92b9f63d5f247bf3", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 103, "deletions": 57, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=acf50b79beb5909c16861cc7c91e8226b7f78272", "patch": "@@ -863,7 +863,7 @@ impl<'a> LoweringContext<'a> {\n \n         let capture_clause = self.lower_capture_clause(capture_clause);\n         let closure_hir_id = self.lower_node_id(closure_node_id).hir_id;\n-        let decl = self.lower_fn_decl(&decl, None, /* impl trait allowed */ false, false);\n+        let decl = self.lower_fn_decl(&decl, None, /* impl trait allowed */ false, None);\n         let generator = hir::Expr {\n             id: closure_node_id,\n             hir_id: closure_hir_id,\n@@ -1099,7 +1099,7 @@ impl<'a> LoweringContext<'a> {\n                                 ),\n                                 unsafety: this.lower_unsafety(f.unsafety),\n                                 abi: f.abi,\n-                                decl: this.lower_fn_decl(&f.decl, None, false, false),\n+                                decl: this.lower_fn_decl(&f.decl, None, false, None),\n                                 arg_names: this.lower_fn_args_to_names(&f.decl),\n                             }))\n                         },\n@@ -1160,25 +1160,23 @@ impl<'a> LoweringContext<'a> {\n                 }\n                 hir::TyTraitObject(bounds, lifetime_bound)\n             }\n-            TyKind::ImplTrait(ref bounds) => {\n+            TyKind::ImplTrait(def_node_id, ref bounds) => {\n                 let span = t.span;\n                 match itctx {\n                     ImplTraitContext::Existential(fn_def_id) => {\n                         self.lower_existential_impl_trait(\n-                            span, fn_def_id, |this| this.lower_param_bounds(bounds, itctx))\n+                            span, fn_def_id, def_node_id,\n+                            |this| this.lower_param_bounds(bounds, itctx),\n+                        )\n                     }\n-                    ImplTraitContext::Universal(def_id) => {\n-                        let def_node_id = self.next_id().node_id;\n-\n+                    ImplTraitContext::Universal(_def_id) => {\n+                        self.lower_node_id(def_node_id);\n                         // Add a definition for the in-band TyParam\n-                        let def_index = self.resolver.definitions().create_def_with_parent(\n-                            def_id.index,\n-                            def_node_id,\n-                            DefPathData::UniversalImplTrait,\n-                            DefIndexAddressSpace::High,\n-                            Mark::root(),\n-                            span,\n-                        );\n+                        let def_index = self\n+                            .resolver\n+                            .definitions()\n+                            .opt_def_index(def_node_id)\n+                            .unwrap();\n \n                         let hir_bounds = self.lower_param_bounds(bounds, itctx);\n                         // Set the name to `impl Bound1 + Bound2`\n@@ -1233,13 +1231,9 @@ impl<'a> LoweringContext<'a> {\n         &mut self,\n         span: Span,\n         fn_def_id: DefId,\n+        exist_ty_node_id: NodeId,\n         lower_bounds: impl FnOnce(&mut LoweringContext) -> hir::GenericBounds,\n     ) -> hir::Ty_ {\n-        // We need to manually repeat the code of `next_id` because the lowering\n-        // needs to happen while the owner_id is pointing to the item itself,\n-        // because items are their own owners\n-        let exist_ty_node_id = self.sess.next_node_id();\n-\n         // Make sure we know that some funky desugaring has been going on here.\n         // This is a first: there is code in other places like for loop\n         // desugaring that explicitly states that we don't want to track that.\n@@ -1250,18 +1244,12 @@ impl<'a> LoweringContext<'a> {\n             span,\n         );\n \n-        // Pull a new definition from the ether\n         let exist_ty_def_index = self\n             .resolver\n             .definitions()\n-            .create_def_with_parent(\n-            fn_def_id.index,\n-            exist_ty_node_id,\n-            DefPathData::ExistentialImplTrait,\n-            DefIndexAddressSpace::High,\n-            Mark::root(),\n-            exist_ty_span,\n-        );\n+            .opt_def_index(exist_ty_node_id)\n+            .unwrap();\n+\n \n         self.allocate_hir_id_counter(exist_ty_node_id, &\"existential impl trait\");\n \n@@ -1358,7 +1346,7 @@ impl<'a> LoweringContext<'a> {\n \n             fn visit_ty(&mut self, t: &'v hir::Ty) {\n                 // Don't collect elided lifetimes used inside of `fn()` syntax\n-                if let &hir::Ty_::TyBareFn(_) = &t.node {\n+                if let hir::Ty_::TyBareFn(_) = t.node {\n                     let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n                     self.collect_elided_lifetimes = false;\n \n@@ -1370,7 +1358,7 @@ impl<'a> LoweringContext<'a> {\n \n                     self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n                 } else {\n-                    hir::intravisit::walk_ty(self, t);\n+                    hir::intravisit::walk_ty(self, t)\n                 }\n             }\n \n@@ -1870,18 +1858,19 @@ impl<'a> LoweringContext<'a> {\n     // decl: the unlowered (ast) function declaration.\n     // fn_def_id: if `Some`, impl Trait arguments are lowered into generic parameters on the\n     //      given DefId, otherwise impl Trait is disallowed. Must be `Some` if\n-    //      make_ret_async is true.\n+    //      make_ret_async is also `Some`.\n     // impl_trait_return_allow: determines whether impl Trait can be used in return position.\n     //      This guards against trait declarations and implementations where impl Trait is\n     //      disallowed.\n-    // make_ret_async: if enabled, converts `-> T` into `-> impl Future<Output = T>` in the\n-    //      return type. This is used for `async fn` declarations.\n+    // make_ret_async: if `Some`, converts `-> T` into `-> impl Future<Output = T>` in the\n+    //      return type. This is used for `async fn` declarations. The `NodeId` is the id of the\n+    //      return type impl Trait item.\n     fn lower_fn_decl(\n         &mut self,\n         decl: &FnDecl,\n         fn_def_id: Option<DefId>,\n         impl_trait_return_allow: bool,\n-        make_ret_async: bool,\n+        make_ret_async: Option<NodeId>,\n     ) -> P<hir::FnDecl> {\n         let inputs = decl.inputs\n             .iter()\n@@ -1894,9 +1883,9 @@ impl<'a> LoweringContext<'a> {\n             })\n             .collect::<HirVec<_>>();\n \n-        let output = if make_ret_async {\n+        let output = if let Some(ret_id) = make_ret_async {\n             self.lower_async_fn_ret_ty(\n-                &inputs, &decl.output, fn_def_id.expect(\"make_ret_async but no fn_def_id\"))\n+                &inputs, &decl.output, fn_def_id.expect(\"make_ret_async but no fn_def_id\"), ret_id)\n         } else {\n             match decl.output {\n                 FunctionRetTy::Ty(ref ty) => match fn_def_id {\n@@ -1932,6 +1921,7 @@ impl<'a> LoweringContext<'a> {\n         inputs: &[hir::Ty],\n         output: &FunctionRetTy,\n         fn_def_id: DefId,\n+        return_impl_trait_id: NodeId,\n     ) -> hir::FunctionRetTy {\n         // Get lifetimes used in the input arguments to the function. Our output type must also\n         // have the same lifetime. FIXME(cramertj) multiple different lifetimes are not allowed\n@@ -2083,7 +2073,7 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         let impl_trait_ty = self.lower_existential_impl_trait(\n-            span, fn_def_id, |this| {\n+            span, fn_def_id, return_impl_trait_id, |this| {\n             let output_ty = match output {\n                 FunctionRetTy::Ty(ty) =>\n                     this.lower_ty(ty, ImplTraitContext::Existential(fn_def_id)),\n@@ -2570,9 +2560,9 @@ impl<'a> LoweringContext<'a> {\n                     // only cares about the input argument patterns in the function\n                     // declaration (decl), not the return types.\n                     let body_id = this.lower_body(Some(decl), |this| {\n-                        if let IsAsync::Async(async_node_id) = header.asyncness {\n+                        if let IsAsync::Async { closure_id, .. } = header.asyncness {\n                             let async_expr = this.make_async_expr(\n-                                CaptureBy::Value, async_node_id, None,\n+                                CaptureBy::Value, closure_id, None,\n                                 |this| {\n                                     let body = this.lower_block(body, false);\n                                     this.expr_block(body, ThinVec::new())\n@@ -2589,7 +2579,7 @@ impl<'a> LoweringContext<'a> {\n                         fn_def_id,\n                         AnonymousLifetimeMode::PassThrough,\n                         |this| this.lower_fn_decl(\n-                            decl, Some(fn_def_id), true, header.asyncness.is_async())\n+                            decl, Some(fn_def_id), true, header.asyncness.opt_return_id())\n                     );\n \n                     hir::ItemFn(\n@@ -2912,7 +2902,7 @@ impl<'a> LoweringContext<'a> {\n                     AnonymousLifetimeMode::PassThrough,\n                     |this| {\n                         hir::TraitItemKind::Method(\n-                            this.lower_method_sig(sig, trait_item_def_id, false, false),\n+                            this.lower_method_sig(sig, trait_item_def_id, false, None),\n                             hir::TraitMethod::Required(names),\n                         )\n                     },\n@@ -2930,7 +2920,7 @@ impl<'a> LoweringContext<'a> {\n                     AnonymousLifetimeMode::PassThrough,\n                     |this| {\n                         hir::TraitItemKind::Method(\n-                            this.lower_method_sig(sig, trait_item_def_id, false, false),\n+                            this.lower_method_sig(sig, trait_item_def_id, false, None),\n                             hir::TraitMethod::Provided(body_id),\n                         )\n                     },\n@@ -3001,9 +2991,9 @@ impl<'a> LoweringContext<'a> {\n             }\n             ImplItemKind::Method(ref sig, ref body) => {\n                 let body_id = self.lower_body(Some(&sig.decl), |this| {\n-                    if let IsAsync::Async(async_node_id) = sig.header.asyncness {\n+                    if let IsAsync::Async { closure_id, .. } = sig.header.asyncness {\n                         let async_expr = this.make_async_expr(\n-                            CaptureBy::Value, async_node_id, None,\n+                            CaptureBy::Value, closure_id, None,\n                             |this| {\n                                 let body = this.lower_block(body, false);\n                                 this.expr_block(body, ThinVec::new())\n@@ -3026,7 +3016,7 @@ impl<'a> LoweringContext<'a> {\n                                 sig,\n                                 impl_item_def_id,\n                                 impl_trait_return_allow,\n-                                sig.header.asyncness.is_async(),\n+                                sig.header.asyncness.opt_return_id(),\n                             ),\n                             body_id,\n                         )\n@@ -3082,17 +3072,73 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n+    /// Lowers `impl Trait` items and appends them to the list\n+    fn lower_impl_trait_ids(\n+        &mut self,\n+        decl: &FnDecl,\n+        header: &FnHeader,\n+        ids: &mut SmallVector<hir::ItemId>,\n+    ) {\n+        if let Some(id) = header.asyncness.opt_return_id() {\n+            ids.push(hir::ItemId { id });\n+        }\n+        struct IdVisitor<'a> { ids: &'a mut SmallVector<hir::ItemId> }\n+        impl<'a, 'b> Visitor<'a> for IdVisitor<'b> {\n+            fn visit_ty(&mut self, ty: &'a Ty) {\n+                match ty.node {\n+                    | TyKind::Typeof(_)\n+                    | TyKind::BareFn(_)\n+                    => return,\n+\n+                    TyKind::ImplTrait(id, _) => self.ids.push(hir::ItemId { id }),\n+                    _ => {},\n+                }\n+                visit::walk_ty(self, ty);\n+            }\n+            fn visit_path_segment(\n+                &mut self,\n+                path_span: Span,\n+                path_segment: &'v PathSegment,\n+            ) {\n+                if let Some(ref p) = path_segment.args {\n+                    if let GenericArgs::Parenthesized(_) = **p {\n+                        return;\n+                    }\n+                }\n+                visit::walk_path_segment(self, path_span, path_segment)\n+            }\n+        }\n+        let mut visitor = IdVisitor { ids };\n+        match decl.output {\n+            FunctionRetTy::Default(_) => {},\n+            FunctionRetTy::Ty(ref ty) => visitor.visit_ty(ty),\n+        }\n+    }\n+\n     fn lower_item_id(&mut self, i: &Item) -> SmallVector<hir::ItemId> {\n         match i.node {\n             ItemKind::Use(ref use_tree) => {\n                 let mut vec = SmallVector::one(hir::ItemId { id: i.id });\n                 self.lower_item_id_use_tree(use_tree, i.id, &mut vec);\n-                return vec;\n+                vec\n             }\n-            ItemKind::MacroDef(..) => return SmallVector::new(),\n-            _ => {}\n+            ItemKind::MacroDef(..) => SmallVector::new(),\n+            ItemKind::Fn(ref decl, ref header, ..) => {\n+                let mut ids = SmallVector::one(hir::ItemId { id: i.id });\n+                self.lower_impl_trait_ids(decl, header, &mut ids);\n+                ids\n+            },\n+            ItemKind::Impl(.., None, _, ref items) => {\n+                let mut ids = SmallVector::one(hir::ItemId { id: i.id });\n+                for item in items {\n+                    if let ImplItemKind::Method(ref sig, _) = item.node {\n+                        self.lower_impl_trait_ids(&sig.decl, &sig.header, &mut ids);\n+                    }\n+                }\n+                ids\n+            },\n+            _ => SmallVector::one(hir::ItemId { id: i.id }),\n         }\n-        SmallVector::one(hir::ItemId { id: i.id })\n     }\n \n     fn lower_item_id_use_tree(&mut self,\n@@ -3168,7 +3214,7 @@ impl<'a> LoweringContext<'a> {\n                         |this| {\n                             (\n                                 // Disallow impl Trait in foreign items\n-                                this.lower_fn_decl(fdec, None, false, false),\n+                                this.lower_fn_decl(fdec, None, false, None),\n                                 this.lower_fn_args_to_names(fdec),\n                             )\n                         },\n@@ -3192,7 +3238,7 @@ impl<'a> LoweringContext<'a> {\n         sig: &MethodSig,\n         fn_def_id: DefId,\n         impl_trait_return_allow: bool,\n-        is_async: bool,\n+        is_async: Option<NodeId>,\n     ) -> hir::MethodSig {\n         hir::MethodSig {\n             header: self.lower_fn_header(sig.header),\n@@ -3232,7 +3278,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_asyncness(&mut self, a: IsAsync) -> hir::IsAsync {\n         match a {\n-            IsAsync::Async(_) => hir::IsAsync::Async,\n+            IsAsync::Async { .. } => hir::IsAsync::Async,\n             IsAsync::NotAsync => hir::IsAsync::NotAsync,\n         }\n     }\n@@ -3535,7 +3581,7 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::Closure(\n                 capture_clause, asyncness, movability, ref decl, ref body, fn_decl_span\n             ) => {\n-                if let IsAsync::Async(async_closure_node_id) = asyncness {\n+                if let IsAsync::Async { closure_id, .. } = asyncness {\n                     let outer_decl = FnDecl {\n                         inputs: decl.inputs.clone(),\n                         output: FunctionRetTy::Default(fn_decl_span),\n@@ -3544,7 +3590,7 @@ impl<'a> LoweringContext<'a> {\n                     // We need to lower the declaration outside the new scope, because we\n                     // have to conserve the state of being inside a loop condition for the\n                     // closure argument types.\n-                    let fn_decl = self.lower_fn_decl(&outer_decl, None, false, false);\n+                    let fn_decl = self.lower_fn_decl(&outer_decl, None, false, None);\n \n                     self.with_new_scopes(|this| {\n                         // FIXME(cramertj) allow `async` non-`move` closures with\n@@ -3571,7 +3617,7 @@ impl<'a> LoweringContext<'a> {\n                                 Some(&**ty)\n                             } else { None };\n                             let async_body = this.make_async_expr(\n-                                capture_clause, async_closure_node_id, async_ret_ty,\n+                                capture_clause, closure_id, async_ret_ty,\n                                 |this| {\n                                     this.with_new_scopes(|this| this.lower_expr(body))\n                                 });\n@@ -3587,7 +3633,7 @@ impl<'a> LoweringContext<'a> {\n                     })\n                 } else {\n                     // Lower outside new scope to preserve `is_in_loop_condition`.\n-                    let fn_decl = self.lower_fn_decl(decl, None, false, false);\n+                    let fn_decl = self.lower_fn_decl(decl, None, false, None);\n \n                     self.with_new_scopes(|this| {\n                         let mut is_generator = false;"}, {"sha": "f0fc0d9b1c23c93a5fc08bae3f2daee6fda9530f", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=acf50b79beb5909c16861cc7c91e8226b7f78272", "patch": "@@ -221,23 +221,27 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         // Make sure that the DepNode of some node coincides with the HirId\n         // owner of that node.\n         if cfg!(debug_assertions) {\n-            let hir_id_owner = self.definitions.node_to_hir_id(id).owner;\n+            let hir_id = self.definitions.node_to_hir_id(id);\n \n-            if hir_id_owner != self.current_dep_node_owner {\n+            if hir_id.owner != self.current_dep_node_owner {\n                 let node_str = match self.definitions.opt_def_index(id) {\n                     Some(def_index) => {\n                         self.definitions.def_path(def_index).to_string_no_crate()\n                     }\n                     None => format!(\"{:?}\", node)\n                 };\n \n+                if hir_id == ::hir::DUMMY_HIR_ID {\n+                    debug!(\"Maybe you forgot to lower the node id {:?}?\", id);\n+                }\n+\n                 bug!(\"inconsistent DepNode for `{}`: \\\n                       current_dep_node_owner={}, hir_id.owner={}\",\n                     node_str,\n                     self.definitions\n                         .def_path(self.current_dep_node_owner)\n                         .to_string_no_crate(),\n-                    self.definitions.def_path(hir_id_owner).to_string_no_crate())\n+                    self.definitions.def_path(hir_id.owner).to_string_no_crate())\n             }\n         }\n "}, {"sha": "c1de6c15d41b3797e95d586a5c8b572ec4adae71", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=acf50b79beb5909c16861cc7c91e8226b7f78272", "patch": "@@ -77,6 +77,7 @@ impl<'a> DefCollector<'a> {\n         &mut self,\n         id: NodeId,\n         async_node_id: NodeId,\n+        return_impl_trait_id: NodeId,\n         name: Name,\n         span: Span,\n         visit_fn: impl FnOnce(&mut DefCollector<'a>)\n@@ -86,6 +87,7 @@ impl<'a> DefCollector<'a> {\n         let fn_def_data = DefPathData::ValueNs(name.as_interned_str());\n         let fn_def = self.create_def(id, fn_def_data, ITEM_LIKE_SPACE, span);\n         return self.with_parent(fn_def, |this| {\n+            this.create_def(return_impl_trait_id, DefPathData::ImplTrait, REGULAR_SPACE, span);\n             let closure_def = this.create_def(async_node_id,\n                                   DefPathData::ClosureExpr,\n                                   REGULAR_SPACE,\n@@ -120,10 +122,14 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ItemKind::Mod(..) if i.ident == keywords::Invalid.ident() => {\n                 return visit::walk_item(self, i);\n             }\n-            ItemKind::Fn(_, FnHeader { asyncness: IsAsync::Async(async_node_id), .. }, ..) => {\n+            ItemKind::Fn(_, FnHeader { asyncness: IsAsync::Async {\n+                closure_id,\n+                return_impl_trait_id,\n+            }, .. }, ..) => {\n                 return self.visit_async_fn(\n                     i.id,\n-                    async_node_id,\n+                    closure_id,\n+                    return_impl_trait_id,\n                     i.ident.name,\n                     i.span,\n                     |this| visit::walk_item(this, i)\n@@ -227,11 +233,15 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n         let def_data = match ii.node {\n             ImplItemKind::Method(MethodSig {\n-                header: FnHeader { asyncness: IsAsync::Async(async_node_id), .. }, ..\n+                header: FnHeader { asyncness: IsAsync::Async {\n+                    closure_id,\n+                    return_impl_trait_id,\n+                }, .. }, ..\n             }, ..) => {\n                 return self.visit_async_fn(\n                     ii.id,\n-                    async_node_id,\n+                    closure_id,\n+                    return_impl_trait_id,\n                     ii.ident.name,\n                     ii.span,\n                     |this| visit::walk_impl_item(this, ii)\n@@ -276,8 +286,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n                 // Async closures desugar to closures inside of closures, so\n                 // we must create two defs.\n-                if let IsAsync::Async(async_id) = asyncness {\n-                    let async_def = self.create_def(async_id,\n+                if let IsAsync::Async { closure_id, .. } = asyncness {\n+                    let async_def = self.create_def(closure_id,\n                                                     DefPathData::ClosureExpr,\n                                                     REGULAR_SPACE,\n                                                     expr.span);\n@@ -301,6 +311,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_ty(&mut self, ty: &'a Ty) {\n         match ty.node {\n             TyKind::Mac(..) => return self.visit_macro_invoc(ty.id),\n+            TyKind::ImplTrait(node_id, _) => {\n+                self.create_def(node_id, DefPathData::ImplTrait, REGULAR_SPACE, ty.span);\n+            }\n             _ => {}\n         }\n         visit::walk_ty(self, ty);"}, {"sha": "ca2789f04f2e2fe2a12df24b93b6f55129be0704", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=acf50b79beb5909c16861cc7c91e8226b7f78272", "patch": "@@ -374,10 +374,8 @@ pub enum DefPathData {\n     StructCtor,\n     /// A constant expression (see {ast,hir}::AnonConst).\n     AnonConst,\n-    /// An `impl Trait` type node in argument position.\n-    UniversalImplTrait,\n-    /// An `impl Trait` type node in return position.\n-    ExistentialImplTrait,\n+    /// An `impl Trait` type node\n+    ImplTrait,\n \n     /// GlobalMetaData identifies a piece of crate metadata that is global to\n     /// a whole crate (as opposed to just one item). GlobalMetaData components\n@@ -641,8 +639,7 @@ impl DefPathData {\n             ClosureExpr |\n             StructCtor |\n             AnonConst |\n-            ExistentialImplTrait |\n-            UniversalImplTrait => None\n+            ImplTrait => None\n         }\n     }\n \n@@ -672,8 +669,7 @@ impl DefPathData {\n             ClosureExpr => \"{{closure}}\",\n             StructCtor => \"{{constructor}}\",\n             AnonConst => \"{{constant}}\",\n-            ExistentialImplTrait => \"{{exist-impl-Trait}}\",\n-            UniversalImplTrait => \"{{univ-impl-Trait}}\",\n+            ImplTrait => \"{{impl-Trait}}\",\n         };\n \n         Symbol::intern(s).as_interned_str()"}, {"sha": "95da68bc9ffc2e147125a0300eff1a13a4a191c6", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=acf50b79beb5909c16861cc7c91e8226b7f78272", "patch": "@@ -221,8 +221,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data @ DefPathData::AnonConst |\n             data @ DefPathData::MacroDef(..) |\n             data @ DefPathData::ClosureExpr |\n-            data @ DefPathData::ExistentialImplTrait |\n-            data @ DefPathData::UniversalImplTrait |\n+            data @ DefPathData::ImplTrait |\n             data @ DefPathData::GlobalMetaData(..) => {\n                 let parent_def_id = self.parent_def_id(def_id).unwrap();\n                 self.push_item_path(buffer, parent_def_id);"}, {"sha": "c17fd79df2af0bb01f547b95e395cf331a210126", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=acf50b79beb5909c16861cc7c91e8226b7f78272", "patch": "@@ -291,8 +291,7 @@ impl PrintContext {\n                     DefPathData::Field(_) |\n                     DefPathData::StructCtor |\n                     DefPathData::AnonConst |\n-                    DefPathData::ExistentialImplTrait |\n-                    DefPathData::UniversalImplTrait |\n+                    DefPathData::ImplTrait |\n                     DefPathData::GlobalMetaData(_) => {\n                         // if we're making a symbol for something, there ought\n                         // to be a value or type-def or something in there"}, {"sha": "711bcfbde2c6f4ff52f8fc6d583fe6f9ad274c6c", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=acf50b79beb5909c16861cc7c91e8226b7f78272", "patch": "@@ -669,7 +669,7 @@ impl<'a> ReplaceBodyWithLoop<'a> {\n         if let ast::FunctionRetTy::Ty(ref ty) = ret_ty.output {\n             fn involves_impl_trait(ty: &ast::Ty) -> bool {\n                 match ty.node {\n-                    ast::TyKind::ImplTrait(_) => true,\n+                    ast::TyKind::ImplTrait(..) => true,\n                     ast::TyKind::Slice(ref subty) |\n                     ast::TyKind::Array(ref subty, _) |\n                     ast::TyKind::Ptr(ast::MutTy { ty: ref subty, .. }) |"}, {"sha": "97140d18c08656be9b6ce0c6679c3ba988f3cae9", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=acf50b79beb5909c16861cc7c91e8226b7f78272", "patch": "@@ -208,7 +208,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n                 self.no_questions_in_bounds(bounds, \"trait object types\", false);\n             }\n-            TyKind::ImplTrait(ref bounds) => {\n+            TyKind::ImplTrait(_, ref bounds) => {\n                 if !bounds.iter()\n                           .any(|b| if let GenericBound::Trait(..) = *b { true } else { false }) {\n                     self.err_handler().span_err(ty.span, \"at least one trait must be specified\");\n@@ -505,7 +505,7 @@ impl<'a> NestedImplTraitVisitor<'a> {\n \n impl<'a> Visitor<'a> for NestedImplTraitVisitor<'a> {\n     fn visit_ty(&mut self, t: &'a Ty) {\n-        if let TyKind::ImplTrait(_) = t.node {\n+        if let TyKind::ImplTrait(..) = t.node {\n             if let Some(outer_impl_trait) = self.outer_impl_trait {\n                 struct_span_err!(self.session, t.span, E0666,\n                                  \"nested `impl Trait` is not allowed\")\n@@ -570,7 +570,7 @@ impl<'a> ImplTraitProjectionVisitor<'a> {\n impl<'a> Visitor<'a> for ImplTraitProjectionVisitor<'a> {\n     fn visit_ty(&mut self, t: &'a Ty) {\n         match t.node {\n-            TyKind::ImplTrait(_) => {\n+            TyKind::ImplTrait(..) => {\n                 if self.is_banned {\n                     struct_span_err!(self.session, t.span, E0667,\n                                  \"`impl Trait` is not allowed in path parameters\")"}, {"sha": "2ef374277714e86f96f9eaa2b3242c62e7ced8f0", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=acf50b79beb5909c16861cc7c91e8226b7f78272", "patch": "@@ -777,8 +777,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         visit::walk_fn_ret_ty(self, &declaration.output);\n \n         // Resolve the function body, potentially inside the body of an async closure\n-        if let IsAsync::Async(async_closure_id) = asyncness {\n-            let rib_kind = ClosureRibKind(async_closure_id);\n+        if let IsAsync::Async { closure_id, .. } = asyncness {\n+            let rib_kind = ClosureRibKind(closure_id);\n             self.ribs[ValueNS].push(Rib::new(rib_kind));\n             self.label_ribs.push(Rib::new(rib_kind));\n         }\n@@ -3933,8 +3933,9 @@ impl<'a> Resolver<'a> {\n             // resolve the arguments within the proper scopes so that usages of them inside the\n             // closure are detected as upvars rather than normal closure arg usages.\n             ExprKind::Closure(\n-                _, IsAsync::Async(inner_closure_id), _, ref fn_decl, ref body, _span) =>\n-            {\n+                _, IsAsync::Async { closure_id: inner_closure_id, .. }, _,\n+                ref fn_decl, ref body, _span,\n+            ) => {\n                 let rib_kind = ClosureRibKind(expr.id);\n                 self.ribs[ValueNS].push(Rib::new(rib_kind));\n                 self.label_ribs.push(Rib::new(rib_kind));"}, {"sha": "70feba1eff866bf2a571269847e8c4cb9226b27a", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=acf50b79beb5909c16861cc7c91e8226b7f78272", "patch": "@@ -306,7 +306,7 @@ impl Sig for ast::Ty {\n                 let nested = pprust::bounds_to_string(bounds);\n                 Ok(text_sig(nested))\n             }\n-            ast::TyKind::ImplTrait(ref bounds) => {\n+            ast::TyKind::ImplTrait(_, ref bounds) => {\n                 // FIXME recurse into bounds\n                 let nested = pprust::bounds_to_string(bounds);\n                 Ok(text_sig(format!(\"impl {}\", nested)))"}, {"sha": "d767265ead9d44278f9bffa0b69cde33924eea7e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=acf50b79beb5909c16861cc7c91e8226b7f78272", "patch": "@@ -1547,7 +1547,11 @@ pub enum TyKind {\n     TraitObject(GenericBounds, TraitObjectSyntax),\n     /// An `impl Bound1 + Bound2 + Bound3` type\n     /// where `Bound` is a trait or a lifetime.\n-    ImplTrait(GenericBounds),\n+    ///\n+    /// The `NodeId` exists to prevent lowering from having to\n+    /// generate `NodeId`s on the fly, which would complicate\n+    /// the generation of `existential type` items significantly\n+    ImplTrait(NodeId, GenericBounds),\n     /// No-op; kept solely so that we can pretty-print faithfully\n     Paren(P<Ty>),\n     /// Unused for now\n@@ -1718,18 +1722,28 @@ pub enum Unsafety {\n \n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum IsAsync {\n-    Async(NodeId),\n+    Async {\n+        closure_id: NodeId,\n+        return_impl_trait_id: NodeId,\n+    },\n     NotAsync,\n }\n \n impl IsAsync {\n     pub fn is_async(self) -> bool {\n-        if let IsAsync::Async(_) = self {\n+        if let IsAsync::Async { .. } = self {\n             true\n         } else {\n             false\n         }\n     }\n+    /// In case this is an `Async` return the `NodeId` for the generated impl Trait item\n+    pub fn opt_return_id(self) -> Option<NodeId> {\n+        match self {\n+            IsAsync::Async { return_impl_trait_id, .. } => Some(return_impl_trait_id),\n+            IsAsync::NotAsync => None,\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]"}, {"sha": "2ae0e669fd031a3c0282c22f9f87c7b3ca63befd", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=acf50b79beb5909c16861cc7c91e8226b7f78272", "patch": "@@ -1726,7 +1726,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                                     \"labels on blocks are unstable\");\n                 }\n             }\n-            ast::ExprKind::Closure(_, ast::IsAsync::Async(_), ..) => {\n+            ast::ExprKind::Closure(_, ast::IsAsync::Async { .. }, ..) => {\n                 gate_feature_post!(&self, async_await, e.span, \"async closures are unstable\");\n             }\n             ast::ExprKind::Async(..) => {"}, {"sha": "d9d3febc4fe4d2312e33df78c4e37d86eaaee4a2", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=acf50b79beb5909c16861cc7c91e8226b7f78272", "patch": "@@ -100,6 +100,10 @@ pub trait Folder : Sized {\n         noop_fold_fn_decl(d, self)\n     }\n \n+    fn fold_asyncness(&mut self, a: IsAsync) -> IsAsync {\n+        noop_fold_asyncness(a, self)\n+    }\n+\n     fn fold_block(&mut self, b: P<Block>) -> P<Block> {\n         noop_fold_block(b, self)\n     }\n@@ -396,8 +400,8 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n             TyKind::TraitObject(bounds, syntax) => {\n                 TyKind::TraitObject(bounds.move_map(|b| fld.fold_param_bound(b)), syntax)\n             }\n-            TyKind::ImplTrait(bounds) => {\n-                TyKind::ImplTrait(bounds.move_map(|b| fld.fold_param_bound(b)))\n+            TyKind::ImplTrait(id, bounds) => {\n+                TyKind::ImplTrait(fld.new_id(id), bounds.move_map(|b| fld.fold_param_bound(b)))\n             }\n             TyKind::Mac(mac) => {\n                 TyKind::Mac(fld.fold_mac(mac))\n@@ -669,6 +673,16 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n     }\n }\n \n+pub fn noop_fold_asyncness<T: Folder>(asyncness: IsAsync, fld: &mut T) -> IsAsync {\n+    match asyncness {\n+        IsAsync::Async { closure_id, return_impl_trait_id } => IsAsync::Async {\n+            closure_id: fld.new_id(closure_id),\n+            return_impl_trait_id: fld.new_id(return_impl_trait_id),\n+        },\n+        IsAsync::NotAsync => IsAsync::NotAsync,\n+    }\n+}\n+\n pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> {\n     decl.map(|FnDecl {inputs, output, variadic}| FnDecl {\n         inputs: inputs.move_map(|x| fld.fold_arg(x)),\n@@ -996,10 +1010,7 @@ pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T)\n }\n \n pub fn noop_fold_fn_header<T: Folder>(mut header: FnHeader, folder: &mut T) -> FnHeader {\n-    header.asyncness = match header.asyncness {\n-        IsAsync::Async(node_id) => IsAsync::Async(folder.new_id(node_id)),\n-        IsAsync::NotAsync => IsAsync::NotAsync,\n-    };\n+    header.asyncness = folder.fold_asyncness(header.asyncness);\n     header\n }\n \n@@ -1249,12 +1260,8 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                           arms.move_map(|x| folder.fold_arm(x)))\n             }\n             ExprKind::Closure(capture_clause, asyncness, movability, decl, body, span) => {\n-                let asyncness = match asyncness {\n-                    IsAsync::Async(node_id) => IsAsync::Async(folder.new_id(node_id)),\n-                    IsAsync::NotAsync => IsAsync::NotAsync,\n-                };\n                 ExprKind::Closure(capture_clause,\n-                                  asyncness,\n+                                  folder.fold_asyncness(asyncness),\n                                   movability,\n                                   folder.fold_fn_decl(decl),\n                                   folder.fold_expr(body),\n@@ -1265,7 +1272,11 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                                 opt_label.map(|label| folder.fold_label(label)))\n             }\n             ExprKind::Async(capture_clause, node_id, body) => {\n-                ExprKind::Async(capture_clause, folder.new_id(node_id), folder.fold_block(body))\n+                ExprKind::Async(\n+                    capture_clause,\n+                    folder.new_id(node_id),\n+                    folder.fold_block(body),\n+                )\n             }\n             ExprKind::Assign(el, er) => {\n                 ExprKind::Assign(folder.fold_expr(el), folder.fold_expr(er))"}, {"sha": "e04fec797e02cd6ce3d90ef07551c5cfcda68e75", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=acf50b79beb5909c16861cc7c91e8226b7f78272", "patch": "@@ -1299,7 +1299,10 @@ impl<'a> Parser<'a> {\n     /// Parse asyncness: `async` or nothing\n     fn parse_asyncness(&mut self) -> IsAsync {\n         if self.eat_keyword(keywords::Async) {\n-            IsAsync::Async(ast::DUMMY_NODE_ID)\n+            IsAsync::Async {\n+                closure_id: ast::DUMMY_NODE_ID,\n+                return_impl_trait_id: ast::DUMMY_NODE_ID,\n+            }\n         } else {\n             IsAsync::NotAsync\n         }\n@@ -1537,7 +1540,7 @@ impl<'a> Parser<'a> {\n             // Always parse bounds greedily for better error recovery.\n             let bounds = self.parse_generic_bounds()?;\n             impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n-            TyKind::ImplTrait(bounds)\n+            TyKind::ImplTrait(ast::DUMMY_NODE_ID, bounds)\n         } else if self.check_keyword(keywords::Dyn) &&\n                   self.look_ahead(1, |t| t.can_begin_bound() &&\n                                          !can_continue_type_after_non_fn_ident(t)) {\n@@ -3279,10 +3282,8 @@ impl<'a> Parser<'a> {\n         } else {\n             Movability::Movable\n         };\n-        let asyncness = if self.span.edition() >= Edition::Edition2018\n-            && self.eat_keyword(keywords::Async)\n-        {\n-            IsAsync::Async(ast::DUMMY_NODE_ID)\n+        let asyncness = if self.span.edition() >= Edition::Edition2018 {\n+            self.parse_asyncness()\n         } else {\n             IsAsync::NotAsync\n         };\n@@ -6798,7 +6799,10 @@ impl<'a> Parser<'a> {\n             let fn_span = self.prev_span;\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(unsafety,\n-                                   IsAsync::Async(ast::DUMMY_NODE_ID),\n+                                   IsAsync::Async {\n+                                       closure_id: ast::DUMMY_NODE_ID,\n+                                       return_impl_trait_id: ast::DUMMY_NODE_ID,\n+                                   },\n                                    respan(fn_span, Constness::NotConst),\n                                    Abi::Rust)?;\n             let prev_span = self.prev_span;"}, {"sha": "74edf538842c6bbb717d826597a4dfe6a3d5b7e4", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=acf50b79beb5909c16861cc7c91e8226b7f78272", "patch": "@@ -1078,7 +1078,7 @@ impl<'a> State<'a> {\n                 let prefix = if syntax == ast::TraitObjectSyntax::Dyn { \"dyn\" } else { \"\" };\n                 self.print_type_bounds(prefix, &bounds[..])?;\n             }\n-            ast::TyKind::ImplTrait(ref bounds) => {\n+            ast::TyKind::ImplTrait(_, ref bounds) => {\n                 self.print_type_bounds(\"impl\", &bounds[..])?;\n             }\n             ast::TyKind::Array(ref ty, ref length) => {"}, {"sha": "bb35bcee4380616d678abc98d397c630b1f4473a", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=acf50b79beb5909c16861cc7c91e8226b7f78272", "patch": "@@ -338,7 +338,7 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n             visitor.visit_anon_const(length)\n         }\n         TyKind::TraitObject(ref bounds, ..) |\n-        TyKind::ImplTrait(ref bounds) => {\n+        TyKind::ImplTrait(_, ref bounds) => {\n             walk_list!(visitor, visit_param_bound, bounds);\n         }\n         TyKind::Typeof(ref expression) => {"}, {"sha": "4235b4be27158745ab192e7114926ce99c28a4c7", "filename": "src/test/compile-fail/private-type-in-interface.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs?ref=acf50b79beb5909c16861cc7c91e8226b7f78272", "patch": "@@ -35,6 +35,8 @@ type A = <m::Alias as m::Trait>::X; //~ ERROR type `m::Priv` is private\n trait Tr2<T> {}\n impl<T> Tr2<T> for u8 {}\n fn g() -> impl Tr2<m::Alias> { 0 } //~ ERROR type `m::Priv` is private\n+//~^ ERROR type `m::Priv` is private\n fn g_ext() -> impl Tr2<ext::Alias> { 0 } //~ ERROR type `ext::Priv` is private\n+//~^ ERROR type `ext::Priv` is private\n \n fn main() {}"}, {"sha": "6681116f0f3936cb40469f582203144298798aac", "filename": "src/test/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/acf50b79beb5909c16861cc7c91e8226b7f78272/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=acf50b79beb5909c16861cc7c91e8226b7f78272", "patch": "@@ -5,7 +5,7 @@ LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n-note: ...which requires processing `cycle2::{{exist-impl-Trait}}`...\n+note: ...which requires processing `cycle2::{{impl-Trait}}`...\n   --> $DIR/auto-trait-leak.rs:31:16\n    |\n LL | fn cycle2() -> impl Clone {\n@@ -16,7 +16,7 @@ note: ...which requires processing `cycle2`...\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n-note: ...which requires processing `cycle1::{{exist-impl-Trait}}`...\n+note: ...which requires processing `cycle1::{{impl-Trait}}`...\n   --> $DIR/auto-trait-leak.rs:24:16\n    |\n LL | fn cycle1() -> impl Clone {"}]}