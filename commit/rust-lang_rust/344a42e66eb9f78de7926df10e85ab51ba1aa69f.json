{"sha": "344a42e66eb9f78de7926df10e85ab51ba1aa69f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0NGE0MmU2NmViOWY3OGRlNzkyNmRmMTBlODVhYjUxYmExYWE2OWY=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-08-08T17:06:45Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-08-22T04:22:42Z"}, "message": "resolve: Move `get_traits_in_module_containing_item` to Resolver", "tree": {"sha": "7527090e8d1b6ec8b3b18edfb402c7f5f4710fe0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7527090e8d1b6ec8b3b18edfb402c7f5f4710fe0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/344a42e66eb9f78de7926df10e85ab51ba1aa69f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/344a42e66eb9f78de7926df10e85ab51ba1aa69f", "html_url": "https://github.com/rust-lang/rust/commit/344a42e66eb9f78de7926df10e85ab51ba1aa69f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/344a42e66eb9f78de7926df10e85ab51ba1aa69f/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e674422f8611b204dff48eb3e51b13f96ebcee32", "url": "https://api.github.com/repos/rust-lang/rust/commits/e674422f8611b204dff48eb3e51b13f96ebcee32", "html_url": "https://github.com/rust-lang/rust/commit/e674422f8611b204dff48eb3e51b13f96ebcee32"}], "stats": {"total": 174, "additions": 93, "deletions": 81}, "files": [{"sha": "d113eb22abadcefb864cb295aa4c7bec4cc6d2d1", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 15, "deletions": 80, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/344a42e66eb9f78de7926df10e85ab51ba1aa69f/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/344a42e66eb9f78de7926df10e85ab51ba1aa69f/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=344a42e66eb9f78de7926df10e85ab51ba1aa69f", "patch": "@@ -8,7 +8,7 @@\n use RibKind::*;\n \n use crate::{path_names_to_string, BindingError, CrateLint, LexicalScopeBinding};\n-use crate::{Module, ModuleOrUniformRoot, NameBindingKind, ParentScope, PathResult};\n+use crate::{Module, ModuleOrUniformRoot, ParentScope, PathResult};\n use crate::{ResolutionError, Resolver, Segment, UseError};\n \n use rustc_ast::ptr::P;\n@@ -24,7 +24,6 @@ use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_hir::TraitCandidate;\n use rustc_middle::{bug, span_bug};\n use rustc_session::lint;\n-use rustc_span::def_id::LocalDefId;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n use smallvec::{smallvec, SmallVec};\n@@ -2342,95 +2341,31 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         ident.span = ident.span.normalize_to_macros_2_0();\n         let mut search_module = self.parent_scope.module;\n         loop {\n-            self.get_traits_in_module_containing_item(ident, ns, search_module, &mut found_traits);\n+            self.r.get_traits_in_module_containing_item(\n+                ident,\n+                ns,\n+                search_module,\n+                &mut found_traits,\n+                &self.parent_scope,\n+            );\n             search_module =\n                 unwrap_or!(self.r.hygienic_lexical_parent(search_module, &mut ident.span), break);\n         }\n \n         if let Some(prelude) = self.r.prelude {\n             if !search_module.no_implicit_prelude {\n-                self.get_traits_in_module_containing_item(ident, ns, prelude, &mut found_traits);\n+                self.r.get_traits_in_module_containing_item(\n+                    ident,\n+                    ns,\n+                    prelude,\n+                    &mut found_traits,\n+                    &self.parent_scope,\n+                );\n             }\n         }\n \n         found_traits\n     }\n-\n-    fn get_traits_in_module_containing_item(\n-        &mut self,\n-        ident: Ident,\n-        ns: Namespace,\n-        module: Module<'a>,\n-        found_traits: &mut Vec<TraitCandidate>,\n-    ) {\n-        assert!(ns == TypeNS || ns == ValueNS);\n-        let mut traits = module.traits.borrow_mut();\n-        if traits.is_none() {\n-            let mut collected_traits = Vec::new();\n-            module.for_each_child(self.r, |_, name, ns, binding| {\n-                if ns != TypeNS {\n-                    return;\n-                }\n-                match binding.res() {\n-                    Res::Def(DefKind::Trait | DefKind::TraitAlias, _) => {\n-                        collected_traits.push((name, binding))\n-                    }\n-                    _ => (),\n-                }\n-            });\n-            *traits = Some(collected_traits.into_boxed_slice());\n-        }\n-\n-        for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n-            // Traits have pseudo-modules that can be used to search for the given ident.\n-            if let Some(module) = binding.module() {\n-                let mut ident = ident;\n-                if ident.span.glob_adjust(module.expansion, binding.span).is_none() {\n-                    continue;\n-                }\n-                if self\n-                    .r\n-                    .resolve_ident_in_module_unadjusted(\n-                        ModuleOrUniformRoot::Module(module),\n-                        ident,\n-                        ns,\n-                        &self.parent_scope,\n-                        false,\n-                        module.span,\n-                    )\n-                    .is_ok()\n-                {\n-                    let import_ids = self.find_transitive_imports(&binding.kind, trait_name);\n-                    let trait_def_id = module.def_id().unwrap();\n-                    found_traits.push(TraitCandidate { def_id: trait_def_id, import_ids });\n-                }\n-            } else if let Res::Def(DefKind::TraitAlias, _) = binding.res() {\n-                // For now, just treat all trait aliases as possible candidates, since we don't\n-                // know if the ident is somewhere in the transitive bounds.\n-                let import_ids = self.find_transitive_imports(&binding.kind, trait_name);\n-                let trait_def_id = binding.res().def_id();\n-                found_traits.push(TraitCandidate { def_id: trait_def_id, import_ids });\n-            } else {\n-                bug!(\"candidate is not trait or trait alias?\")\n-            }\n-        }\n-    }\n-\n-    fn find_transitive_imports(\n-        &mut self,\n-        mut kind: &NameBindingKind<'_>,\n-        trait_name: Ident,\n-    ) -> SmallVec<[LocalDefId; 1]> {\n-        let mut import_ids = smallvec![];\n-        while let NameBindingKind::Import { import, binding, .. } = kind {\n-            let id = self.r.local_def_id(import.id);\n-            self.r.maybe_unused_trait_imports.insert(id);\n-            self.r.add_to_glob_map(&import, trait_name);\n-            import_ids.push(id);\n-            kind = &binding.kind;\n-        }\n-        import_ids\n-    }\n }\n \n impl<'a> Resolver<'a> {"}, {"sha": "c24a38bcadfdb14d8fac70429d270ee80b33b812", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/344a42e66eb9f78de7926df10e85ab51ba1aa69f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/344a42e66eb9f78de7926df10e85ab51ba1aa69f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=344a42e66eb9f78de7926df10e85ab51ba1aa69f", "patch": "@@ -43,9 +43,9 @@ use rustc_index::vec::IndexVec;\n use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::hir::exports::ExportMap;\n use rustc_middle::middle::cstore::{CrateStore, MetadataLoaderDyn};\n-use rustc_middle::span_bug;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, ResolverOutputs};\n+use rustc_middle::{bug, span_bug};\n use rustc_session::lint;\n use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::Session;\n@@ -54,6 +54,7 @@ use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n+use smallvec::{smallvec, SmallVec};\n use std::cell::{Cell, RefCell};\n use std::collections::BTreeSet;\n use std::{cmp, fmt, iter, ptr};\n@@ -1430,6 +1431,82 @@ impl<'a> Resolver<'a> {\n         self.crate_loader.postprocess(krate);\n     }\n \n+    fn get_traits_in_module_containing_item(\n+        &mut self,\n+        ident: Ident,\n+        ns: Namespace,\n+        module: Module<'a>,\n+        found_traits: &mut Vec<TraitCandidate>,\n+        parent_scope: &ParentScope<'a>,\n+    ) {\n+        assert!(ns == TypeNS || ns == ValueNS);\n+        let mut traits = module.traits.borrow_mut();\n+        if traits.is_none() {\n+            let mut collected_traits = Vec::new();\n+            module.for_each_child(self, |_, name, ns, binding| {\n+                if ns != TypeNS {\n+                    return;\n+                }\n+                match binding.res() {\n+                    Res::Def(DefKind::Trait | DefKind::TraitAlias, _) => {\n+                        collected_traits.push((name, binding))\n+                    }\n+                    _ => (),\n+                }\n+            });\n+            *traits = Some(collected_traits.into_boxed_slice());\n+        }\n+\n+        for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n+            // Traits have pseudo-modules that can be used to search for the given ident.\n+            if let Some(module) = binding.module() {\n+                let mut ident = ident;\n+                if ident.span.glob_adjust(module.expansion, binding.span).is_none() {\n+                    continue;\n+                }\n+                if self\n+                    .resolve_ident_in_module_unadjusted(\n+                        ModuleOrUniformRoot::Module(module),\n+                        ident,\n+                        ns,\n+                        parent_scope,\n+                        false,\n+                        module.span,\n+                    )\n+                    .is_ok()\n+                {\n+                    let import_ids = self.find_transitive_imports(&binding.kind, trait_name);\n+                    let trait_def_id = module.def_id().unwrap();\n+                    found_traits.push(TraitCandidate { def_id: trait_def_id, import_ids });\n+                }\n+            } else if let Res::Def(DefKind::TraitAlias, _) = binding.res() {\n+                // For now, just treat all trait aliases as possible candidates, since we don't\n+                // know if the ident is somewhere in the transitive bounds.\n+                let import_ids = self.find_transitive_imports(&binding.kind, trait_name);\n+                let trait_def_id = binding.res().def_id();\n+                found_traits.push(TraitCandidate { def_id: trait_def_id, import_ids });\n+            } else {\n+                bug!(\"candidate is not trait or trait alias?\")\n+            }\n+        }\n+    }\n+\n+    fn find_transitive_imports(\n+        &mut self,\n+        mut kind: &NameBindingKind<'_>,\n+        trait_name: Ident,\n+    ) -> SmallVec<[LocalDefId; 1]> {\n+        let mut import_ids = smallvec![];\n+        while let NameBindingKind::Import { import, binding, .. } = kind {\n+            let id = self.local_def_id(import.id);\n+            self.maybe_unused_trait_imports.insert(id);\n+            self.add_to_glob_map(&import, trait_name);\n+            import_ids.push(id);\n+            kind = &binding.kind;\n+        }\n+        import_ids\n+    }\n+\n     fn new_module(\n         &self,\n         parent: Module<'a>,"}]}