{"sha": "603a75c8eaa8ee168e4333e4fba5eb782ed7192b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwM2E3NWM4ZWFhOGVlMTY4ZTQzMzNlNGZiYTVlYjc4MmVkNzE5MmI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-09-25T22:27:39Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-10-02T20:40:10Z"}, "message": "ensure that the types of methods are well-formed\n\nBy RFC1214:\nBefore calling a fn, we check that its argument and return types are WF. This check takes place after all higher-ranked lifetimes have been instantiated. Checking the argument types ensures that the implied bounds due to argument types are correct. Checking the return type ensures that the resulting type of the call is WF.\n\nThe previous code only checked the trait-ref, which was not enough\nin several cases.\n\nAs this is a soundness fix, it is a [breaking-change].\n\nFixes #28609", "tree": {"sha": "de0c588e05460fed2da1137a96526d6b308a57e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de0c588e05460fed2da1137a96526d6b308a57e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/603a75c8eaa8ee168e4333e4fba5eb782ed7192b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/603a75c8eaa8ee168e4333e4fba5eb782ed7192b", "html_url": "https://github.com/rust-lang/rust/commit/603a75c8eaa8ee168e4333e4fba5eb782ed7192b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/603a75c8eaa8ee168e4333e4fba5eb782ed7192b/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e82faeb65594302897223b2ca4ee6927fb54625f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e82faeb65594302897223b2ca4ee6927fb54625f", "html_url": "https://github.com/rust-lang/rust/commit/e82faeb65594302897223b2ca4ee6927fb54625f"}], "stats": {"total": 179, "additions": 171, "deletions": 8}, "files": [{"sha": "72131627aa5d4dd3303d2ba5a7b307d8de50174e", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/603a75c8eaa8ee168e4333e4fba5eb782ed7192b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603a75c8eaa8ee168e4333e4fba5eb782ed7192b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=603a75c8eaa8ee168e4333e4fba5eb782ed7192b", "patch": "@@ -103,22 +103,23 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // Unify the (adjusted) self type with what the method expects.\n         self.unify_receivers(self_ty, method_self_ty);\n \n-        // Add any trait/regions obligations specified on the method's type parameters.\n-        self.add_obligations(&pick, &all_substs, &method_predicates);\n-\n-        // Create the final `MethodCallee`.\n+        // Create the method type\n         let method_ty = pick.item.as_opt_method().unwrap();\n         let fty = self.tcx().mk_fn(None, self.tcx().mk_bare_fn(ty::BareFnTy {\n             sig: ty::Binder(method_sig),\n             unsafety: method_ty.fty.unsafety,\n             abi: method_ty.fty.abi.clone(),\n         }));\n+\n+        // Add any trait/regions obligations specified on the method's type parameters.\n+        self.add_obligations(fty, &all_substs, &method_predicates);\n+\n+        // Create the final `MethodCallee`.\n         let callee = ty::MethodCallee {\n             def_id: pick.item.def_id(),\n             ty: fty,\n             substs: self.tcx().mk_substs(all_substs)\n         };\n-\n         // If this is an `&mut self` method, bias the receiver\n         // expression towards mutability (this will switch\n         // e.g. `Deref` to `DerefMut` in overloaded derefs and so on).\n@@ -422,11 +423,11 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn add_obligations(&mut self,\n-                       pick: &probe::Pick<'tcx>,\n+                       fty: Ty<'tcx>,\n                        all_substs: &subst::Substs<'tcx>,\n                        method_predicates: &ty::InstantiatedPredicates<'tcx>) {\n-        debug!(\"add_obligations: pick={:?} all_substs={:?} method_predicates={:?}\",\n-               pick,\n+        debug!(\"add_obligations: fty={:?} all_substs={:?} method_predicates={:?}\",\n+               fty,\n                all_substs,\n                method_predicates);\n \n@@ -439,6 +440,11 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         self.fcx.add_wf_bounds(\n             all_substs,\n             self.call_expr);\n+\n+        // the function type must also be well-formed (this is not\n+        // implied by the substs being well-formed because of inherent\n+        // impls and late-bound regions - see issue #28609).\n+        self.fcx.register_wf_obligation(fty, self.span, traits::MiscObligation);\n     }\n \n     ///////////////////////////////////////////////////////////////////////////"}, {"sha": "e0ad51b4ea1b54532dd56d0fe0d763d7aa5ab9ed", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/603a75c8eaa8ee168e4333e4fba5eb782ed7192b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603a75c8eaa8ee168e4333e4fba5eb782ed7192b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=603a75c8eaa8ee168e4333e4fba5eb782ed7192b", "patch": "@@ -255,6 +255,9 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         traits::ObligationCause::misc(span, fcx.body_id),\n         &method_bounds);\n \n+    // Also register an obligation for the method type being well-formed.\n+    fcx.register_wf_obligation(fty, span, traits::MiscObligation);\n+\n     // FIXME(#18653) -- Try to resolve obligations, giving us more\n     // typing information, which can sometimes be needed to avoid\n     // pathological region inference failures."}, {"sha": "b9d292fd1568552dcea5450360e00cbc213283c7", "filename": "src/test/compile-fail/wf-method-late-bound-regions.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/603a75c8eaa8ee168e4333e4fba5eb782ed7192b/src%2Ftest%2Fcompile-fail%2Fwf-method-late-bound-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603a75c8eaa8ee168e4333e4fba5eb782ed7192b/src%2Ftest%2Fcompile-fail%2Fwf-method-late-bound-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-method-late-bound-regions.rs?ref=603a75c8eaa8ee168e4333e4fba5eb782ed7192b", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A method's receiver must be well-formed, even if it has late-bound regions.\n+// Because of this, a method's substs being well-formed does not imply that\n+// the method's implied bounds are met.\n+\n+struct Foo<'b>(Option<&'b ()>);\n+\n+trait Bar<'b> {\n+    fn xmute<'a>(&'a self, u: &'b u32) -> &'a u32;\n+}\n+\n+impl<'b> Bar<'b> for Foo<'b> {\n+    fn xmute<'a>(&'a self, u: &'b u32) -> &'a u32 { u }\n+}\n+\n+fn main() {\n+    let f = Foo(None);\n+    let f2 = f;\n+    let dangling = {\n+        let pointer = Box::new(42);\n+        f2.xmute(&pointer) //~ ERROR `pointer` does not live long enough\n+    };\n+    println!(\"{}\", dangling);\n+}"}, {"sha": "055c86a03a7e65faaef3a2239fefe230daa42426", "filename": "src/test/compile-fail/wf-misc-methods-issue-28609.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/603a75c8eaa8ee168e4333e4fba5eb782ed7192b/src%2Ftest%2Fcompile-fail%2Fwf-misc-methods-issue-28609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603a75c8eaa8ee168e4333e4fba5eb782ed7192b/src%2Ftest%2Fcompile-fail%2Fwf-misc-methods-issue-28609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-misc-methods-issue-28609.rs?ref=603a75c8eaa8ee168e4333e4fba5eb782ed7192b", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that misc. method calls are well-formed\n+\n+use std::marker::PhantomData;\n+use std::ops::{Deref, Shl};\n+\n+#[derive(Copy, Clone)]\n+struct S<'a, 'b: 'a> {\n+    marker: PhantomData<&'a &'b ()>,\n+    bomb: Option<&'b u32>\n+}\n+\n+type S2<'a> = S<'a, 'a>;\n+\n+impl<'a, 'b> S<'a, 'b> {\n+    fn transmute_inherent(&self, a: &'b u32) -> &'a u32 {\n+        a\n+    }\n+}\n+\n+fn return_dangling_pointer_inherent(s: S2) -> &u32 {\n+    let s = s;\n+    s.transmute_inherent(&mut 42) //~ ERROR does not live long enough\n+}\n+\n+impl<'a, 'b> Deref for S<'a, 'b> {\n+    type Target = &'a u32;\n+    fn deref(&self) -> &&'a u32 {\n+        self.bomb.as_ref().unwrap()\n+    }\n+}\n+\n+fn return_dangling_pointer_coerce(s: S2) -> &u32 {\n+    let four = 4;\n+    let mut s = s;\n+    s.bomb = Some(&four); //~ ERROR does not live long enough\n+    &s\n+}\n+\n+fn return_dangling_pointer_unary_op(s: S2) -> &u32 {\n+    let four = 4;\n+    let mut s = s;\n+    s.bomb = Some(&four); //~ ERROR does not live long enough\n+    &*s\n+}\n+\n+impl<'a, 'b> Shl<&'b u32> for S<'a, 'b> {\n+    type Output = &'a u32;\n+    fn shl(self, t: &'b u32) -> &'a u32 { t }\n+}\n+\n+fn return_dangling_pointer_binary_op(s: S2) -> &u32 {\n+    let s = s;\n+    s << &mut 3 //~ ERROR does not live long enough\n+}\n+\n+fn return_dangling_pointer_method(s: S2) -> &u32 {\n+    let s = s;\n+    s.shl(&mut 3) //~ ERROR does not live long enough\n+}\n+\n+fn return_dangling_pointer_ufcs(s: S2) -> &u32 {\n+    let s = s;\n+    S2::shl(s, &mut 3) //~ ERROR does not live long enough\n+}\n+\n+fn main() {\n+    let s = S { marker: PhantomData, bomb: None };\n+    let _inherent_dp = return_dangling_pointer_inherent(s);\n+    let _coerce_dp = return_dangling_pointer_coerce(s);\n+    let _unary_dp = return_dangling_pointer_unary_op(s);\n+    let _binary_dp = return_dangling_pointer_binary_op(s);\n+    let _method_dp = return_dangling_pointer_method(s);\n+    let _ufcs_dp = return_dangling_pointer_ufcs(s);\n+}"}, {"sha": "8f9b0cb80ba57437b21a117274c51973a27198b0", "filename": "src/test/compile-fail/wf-static-method.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/603a75c8eaa8ee168e4333e4fba5eb782ed7192b/src%2Ftest%2Fcompile-fail%2Fwf-static-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/603a75c8eaa8ee168e4333e4fba5eb782ed7192b/src%2Ftest%2Fcompile-fail%2Fwf-static-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-static-method.rs?ref=603a75c8eaa8ee168e4333e4fba5eb782ed7192b", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that static methods don't get to assume `Self` is well-formed\n+\n+trait Foo<'a, 'b>: Sized {\n+    fn make_me() -> Self { loop {} }\n+    fn static_evil(u: &'a u32) -> &'b u32;\n+}\n+\n+struct Evil<'a, 'b: 'a>(Option<&'a &'b ()>);\n+\n+impl<'a, 'b> Foo<'a, 'b> for Evil<'a, 'b> {\n+    fn make_me() -> Self { Evil(None) }\n+    fn static_evil(u: &'a u32) -> &'b u32 {\n+        u //~ ERROR cannot infer an appropriate lifetime\n+    }\n+}\n+\n+struct IndirectEvil<'a, 'b: 'a>(Option<&'a &'b ()>);\n+\n+impl<'a, 'b> Foo<'a, 'b> for IndirectEvil<'a, 'b> {\n+    fn make_me() -> Self { IndirectEvil(None) }\n+    fn static_evil(u: &'a u32) -> &'b u32 {\n+        let me = Self::make_me(); //~ ERROR lifetime bound not satisfied\n+        loop {} // (`me` could be used for the lifetime transmute).\n+    }\n+}\n+\n+fn main() {}"}]}