{"sha": "9530ba0fe2118d9a60e16861faad29ec5803d3f9", "node_id": "C_kwDOAAsO6NoAKDk1MzBiYTBmZTIxMThkOWE2MGUxNjg2MWZhYWQyOWVjNTgwM2QzZjk", "commit": {"author": {"name": "Andrew Brown", "email": "andrew.brown@intel.com", "date": "2022-09-29T18:17:15Z"}, "committer": {"name": "Andrew Brown", "email": "andrew.brown@intel.com", "date": "2022-10-10T16:01:42Z"}, "message": "Implement `env_lock` with `RwLock`\n\nCopying the approach of the Unix target, this change uses the standard\n`RwLock` to protect against concurrent access of libc's environment.\nThis locking is only enabled when WebAssembly's `atomics` feature is\nalso enabled.", "tree": {"sha": "167a9919b64cd8dabad62f7c202d4da656a9a85e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/167a9919b64cd8dabad62f7c202d4da656a9a85e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9530ba0fe2118d9a60e16861faad29ec5803d3f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9530ba0fe2118d9a60e16861faad29ec5803d3f9", "html_url": "https://github.com/rust-lang/rust/commit/9530ba0fe2118d9a60e16861faad29ec5803d3f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9530ba0fe2118d9a60e16861faad29ec5803d3f9/comments", "author": {"login": "abrown", "id": 541880, "node_id": "MDQ6VXNlcjU0MTg4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/541880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abrown", "html_url": "https://github.com/abrown", "followers_url": "https://api.github.com/users/abrown/followers", "following_url": "https://api.github.com/users/abrown/following{/other_user}", "gists_url": "https://api.github.com/users/abrown/gists{/gist_id}", "starred_url": "https://api.github.com/users/abrown/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abrown/subscriptions", "organizations_url": "https://api.github.com/users/abrown/orgs", "repos_url": "https://api.github.com/users/abrown/repos", "events_url": "https://api.github.com/users/abrown/events{/privacy}", "received_events_url": "https://api.github.com/users/abrown/received_events", "type": "User", "site_admin": false}, "committer": {"login": "abrown", "id": 541880, "node_id": "MDQ6VXNlcjU0MTg4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/541880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abrown", "html_url": "https://github.com/abrown", "followers_url": "https://api.github.com/users/abrown/followers", "following_url": "https://api.github.com/users/abrown/following{/other_user}", "gists_url": "https://api.github.com/users/abrown/gists{/gist_id}", "starred_url": "https://api.github.com/users/abrown/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abrown/subscriptions", "organizations_url": "https://api.github.com/users/abrown/orgs", "repos_url": "https://api.github.com/users/abrown/repos", "events_url": "https://api.github.com/users/abrown/events{/privacy}", "received_events_url": "https://api.github.com/users/abrown/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da638b3a9f32974c41439be6834670d7a438faa3", "url": "https://api.github.com/repos/rust-lang/rust/commits/da638b3a9f32974c41439be6834670d7a438faa3", "html_url": "https://github.com/rust-lang/rust/commit/da638b3a9f32974c41439be6834670d7a438faa3"}], "stats": {"total": 35, "additions": 23, "deletions": 12}, "files": [{"sha": "cffe1e32308b6b03980503db68415f5fdfe56985", "filename": "library/std/src/sys/wasi/os.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9530ba0fe2118d9a60e16861faad29ec5803d3f9/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9530ba0fe2118d9a60e16861faad29ec5803d3f9/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fos.rs?ref=9530ba0fe2118d9a60e16861faad29ec5803d3f9", "patch": "@@ -1,11 +1,11 @@\n #![deny(unsafe_op_in_unsafe_fn)]\n \n-use crate::any::Any;\n use crate::error::Error as StdError;\n use crate::ffi::{CStr, OsStr, OsString};\n use crate::fmt;\n use crate::io;\n use crate::marker::PhantomData;\n+use crate::ops::Drop;\n use crate::os::wasi::prelude::*;\n use crate::path::{self, PathBuf};\n use crate::str;\n@@ -24,13 +24,24 @@ mod libc {\n     }\n }\n \n-pub unsafe fn env_lock() -> impl Any {\n-    cfg_if::cfg_if! {\n-        if #[cfg(target_feature = \"atomics\")] {\n-            todo!()\n-        } else {\n-            // No need for a lock if we're single-threaded, but this function will need\n-            // to get implemented for multi-threaded scenarios\n+cfg_if::cfg_if! {\n+    if #[cfg(target_feature = \"atomics\")] {\n+        // Access to the environment must be protected by a lock in multi-threaded scenarios.\n+        use crate::sync::{PoisonError, RwLock};\n+        static ENV_LOCK: RwLock<()> = RwLock::new(());\n+        pub fn env_read_lock() -> impl Drop {\n+            ENV_LOCK.read().unwrap_or_else(PoisonError::into_inner)\n+        }\n+        pub fn env_write_lock() -> impl Drop {\n+            ENV_LOCK.write().unwrap_or_else(PoisonError::into_inner)\n+        }\n+    } else {\n+        // No need for a lock if we are single-threaded.\n+        pub fn env_read_lock() -> impl Drop {\n+            ()\n+        }\n+        pub fn env_write_lock() -> impl Drop {\n+            ()\n         }\n     }\n }\n@@ -149,7 +160,7 @@ impl Iterator for Env {\n \n pub fn env() -> Env {\n     unsafe {\n-        let _guard = env_lock();\n+        let _guard = env_read_lock();\n         let mut environ = libc::environ;\n         let mut result = Vec::new();\n         if !environ.is_null() {\n@@ -180,7 +191,7 @@ pub fn env() -> Env {\n \n pub fn getenv(k: &OsStr) -> Option<OsString> {\n     let s = run_with_cstr(k.as_bytes(), |k| unsafe {\n-        let _guard = env_lock();\n+        let _guard = env_read_lock();\n         Ok(libc::getenv(k.as_ptr()) as *const libc::c_char)\n     })\n     .ok()?;\n@@ -194,15 +205,15 @@ pub fn getenv(k: &OsStr) -> Option<OsString> {\n pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n     run_with_cstr(k.as_bytes(), |k| {\n         run_with_cstr(v.as_bytes(), |v| unsafe {\n-            let _guard = env_lock();\n+            let _guard = env_write_lock();\n             cvt(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(drop)\n         })\n     })\n }\n \n pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n     run_with_cstr(n.as_bytes(), |nbuf| unsafe {\n-        let _guard = env_lock();\n+        let _guard = env_write_lock();\n         cvt(libc::unsetenv(nbuf.as_ptr())).map(drop)\n     })\n }"}]}