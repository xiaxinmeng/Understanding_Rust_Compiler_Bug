{"sha": "cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmYzliNTE4NWJiZjVhYjA0YTI3MzYzNDdiZmE3ZmQ5YWI3MGMxZTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-19T13:33:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-19T13:33:10Z"}, "message": "Auto merge of #37213 - jseyfried:refactor_crate_var, r=nrc\n\nmacros: improve `$crate`\n\nThis PR refactors the implementation of `$crate` so that\n - `$crate` is only allowed at the start of a path (like `super`),\n - we can make `$crate` work with inter-crate re-exports (groundwork for macro modularization), and\n - we can support importing macros from an extern crate that is not declared at the crate root (also groundwork for macro modularization).\n\nThis is a [breaking-change]. For example, the following would break:\n```rust\nfn foo() {}\nmacro_rules! m { () => {\n    $crate foo $crate () $crate $crate;\n    //^ Today, `$crate` is allowed just about anywhere in unexported macros.\n} }\nfn main() {\n    m!();\n}\n```\nr? @nrc", "tree": {"sha": "52adabcf51c925346f633af820f0f8404de5f4d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52adabcf51c925346f633af820f0f8404de5f4d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7", "html_url": "https://github.com/rust-lang/rust/commit/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a41505f4f4a93bf94f4f7439d41afd826ab20b94", "url": "https://api.github.com/repos/rust-lang/rust/commits/a41505f4f4a93bf94f4f7439d41afd826ab20b94", "html_url": "https://github.com/rust-lang/rust/commit/a41505f4f4a93bf94f4f7439d41afd826ab20b94"}, {"sha": "8b0c292a728c113aaf1f27f079aae6a28110c587", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b0c292a728c113aaf1f27f079aae6a28110c587", "html_url": "https://github.com/rust-lang/rust/commit/8b0c292a728c113aaf1f27f079aae6a28110c587"}], "stats": {"total": 230, "additions": 97, "deletions": 133}, "files": [{"sha": "f19afd67faa212da8442ac9688c3d9c54ab60288", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7", "patch": "@@ -37,6 +37,7 @@ use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ext::base::{SyntaxExtension, Resolver as SyntaxResolver};\n+use syntax::ext::expand::mark_tts;\n use syntax::ext::hygiene::Mark;\n use syntax::feature_gate::{self, emit_feature_err};\n use syntax::ext::tt::macro_rules;\n@@ -95,22 +96,22 @@ impl<'b> Resolver<'b> {\n                 // Extract and intern the module part of the path. For\n                 // globs and lists, the path is found directly in the AST;\n                 // for simple paths we have to munge the path a little.\n-                let module_path: Vec<Name> = match view_path.node {\n+                let module_path: Vec<_> = match view_path.node {\n                     ViewPathSimple(_, ref full_path) => {\n                         full_path.segments\n                                  .split_last()\n                                  .unwrap()\n                                  .1\n                                  .iter()\n-                                 .map(|seg| seg.identifier.name)\n+                                 .map(|seg| seg.identifier)\n                                  .collect()\n                     }\n \n                     ViewPathGlob(ref module_ident_path) |\n                     ViewPathList(ref module_ident_path, _) => {\n                         module_ident_path.segments\n                                          .iter()\n-                                         .map(|seg| seg.identifier.name)\n+                                         .map(|seg| seg.identifier)\n                                          .collect()\n                     }\n                 };\n@@ -159,7 +160,7 @@ impl<'b> Resolver<'b> {\n                                     (module_path.clone(), node.name.name, rename)\n                                 } else {\n                                     let name = match module_path.last() {\n-                                        Some(name) => *name,\n+                                        Some(ident) => ident.name,\n                                         None => {\n                                             resolve_error(\n                                                 self,\n@@ -207,11 +208,16 @@ impl<'b> Resolver<'b> {\n                 };\n \n                 let mut custom_derive_crate = false;\n+                // The mark of the expansion that generates the loaded macros.\n+                let mut opt_mark = None;\n                 for loaded_macro in self.crate_loader.load_macros(item, is_crate_root) {\n+                    let mark = opt_mark.unwrap_or_else(Mark::fresh);\n+                    opt_mark = Some(mark);\n                     match loaded_macro.kind {\n                         LoadedMacroKind::Def(mut def) => {\n                             if def.use_locally {\n                                 self.macro_names.insert(def.ident.name);\n+                                def.body = mark_tts(&def.body, mark);\n                                 let ext = macro_rules::compile(&self.session.parse_sess, &def);\n                                 import_macro(self, def.ident.name, ext, loaded_macro.import_site);\n                             }\n@@ -249,6 +255,17 @@ impl<'b> Resolver<'b> {\n                     });\n                     self.define(parent, name, TypeNS, (module, sp, vis));\n \n+                    if let Some(mark) = opt_mark {\n+                        let invocation = self.arenas.alloc_invocation_data(InvocationData {\n+                            module: Cell::new(module),\n+                            def_index: CRATE_DEF_INDEX,\n+                            const_integer: false,\n+                            legacy_scope: Cell::new(LegacyScope::Empty),\n+                            expansion: Cell::new(LegacyScope::Empty),\n+                        });\n+                        self.invocations.insert(mark, invocation);\n+                    }\n+\n                     self.populate_module_if_necessary(module);\n                 } else if custom_derive_crate {\n                     // Define an empty module"}, {"sha": "7091d7d2a632171f89eefbfd665dd702c2c11456", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 54, "deletions": 50, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7", "patch": "@@ -53,9 +53,9 @@ use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast::{self, FloatTy};\n-use syntax::ast::{CRATE_NODE_ID, Name, NodeId, IntTy, UintTy};\n+use syntax::ast::{CRATE_NODE_ID, Name, NodeId, Ident, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n use syntax::parse::token::{self, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n@@ -509,7 +509,7 @@ struct BindingInfo {\n }\n \n // Map from the name in a pattern to its binding mode.\n-type BindingMap = FnvHashMap<ast::Ident, BindingInfo>;\n+type BindingMap = FnvHashMap<Ident, BindingInfo>;\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum PatternSource {\n@@ -714,7 +714,7 @@ enum ModulePrefixResult<'a> {\n /// One local scope.\n #[derive(Debug)]\n struct Rib<'a> {\n-    bindings: FnvHashMap<ast::Ident, Def>,\n+    bindings: FnvHashMap<Ident, Def>,\n     kind: RibKind<'a>,\n }\n \n@@ -1178,18 +1178,18 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n }\n \n trait Named {\n-    fn name(&self) -> Name;\n+    fn ident(&self) -> Ident;\n }\n \n impl Named for ast::PathSegment {\n-    fn name(&self) -> Name {\n-        self.identifier.name\n+    fn ident(&self) -> Ident {\n+        self.identifier\n     }\n }\n \n impl Named for hir::PathSegment {\n-    fn name(&self) -> Name {\n-        self.name\n+    fn ident(&self) -> Ident {\n+        Ident::with_empty_ctxt(self.name)\n     }\n }\n \n@@ -1364,7 +1364,7 @@ impl<'a> Resolver<'a> {\n     /// Resolves the given module path from the given root `search_module`.\n     fn resolve_module_path_from_root(&mut self,\n                                      mut search_module: Module<'a>,\n-                                     module_path: &[Name],\n+                                     module_path: &[Ident],\n                                      index: usize,\n                                      span: Option<Span>)\n                                      -> ResolveResult<Module<'a>> {\n@@ -1387,7 +1387,7 @@ impl<'a> Resolver<'a> {\n         // upward though scope chains; we simply resolve names directly in\n         // modules as we go.\n         while index < module_path_len {\n-            let name = module_path[index];\n+            let name = module_path[index].name;\n             match self.resolve_name_in_module(search_module, name, TypeNS, false, span) {\n                 Failed(_) => {\n                     let segment_name = name.as_str();\n@@ -1441,7 +1441,7 @@ impl<'a> Resolver<'a> {\n     /// Attempts to resolve the module part of an import directive or path\n     /// rooted at the given module.\n     fn resolve_module_path(&mut self,\n-                           module_path: &[Name],\n+                           module_path: &[Ident],\n                            use_lexical_scope: UseLexicalScopeFlag,\n                            span: Option<Span>)\n                            -> ResolveResult<Module<'a>> {\n@@ -1479,7 +1479,7 @@ impl<'a> Resolver<'a> {\n                         // This is not a crate-relative path. We resolve the\n                         // first component of the path in the current lexical\n                         // scope and then proceed to resolve below that.\n-                        let ident = ast::Ident::with_empty_ctxt(module_path[0]);\n+                        let ident = module_path[0];\n                         let lexical_binding =\n                             self.resolve_ident_in_lexical_scope(ident, TypeNS, span);\n                         if let Some(binding) = lexical_binding.and_then(LexicalScopeBinding::item) {\n@@ -1525,12 +1525,12 @@ impl<'a> Resolver<'a> {\n     /// Invariant: This must only be called during main resolution, not during\n     /// import resolution.\n     fn resolve_ident_in_lexical_scope(&mut self,\n-                                      mut ident: ast::Ident,\n+                                      mut ident: Ident,\n                                       ns: Namespace,\n                                       record_used: Option<Span>)\n                                       -> Option<LexicalScopeBinding<'a>> {\n         if ns == TypeNS {\n-            ident = ast::Ident::with_empty_ctxt(ident.name);\n+            ident = Ident::with_empty_ctxt(ident.name);\n         }\n \n         // Walk backwards up the ribs in scope.\n@@ -1577,11 +1577,22 @@ impl<'a> Resolver<'a> {\n     /// Resolves a \"module prefix\". A module prefix is one or both of (a) `self::`;\n     /// (b) some chain of `super::`.\n     /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n-    fn resolve_module_prefix(&mut self, module_path: &[Name], span: Option<Span>)\n+    fn resolve_module_prefix(&mut self, module_path: &[Ident], span: Option<Span>)\n                              -> ResolveResult<ModulePrefixResult<'a>> {\n+        if &*module_path[0].name.as_str() == \"$crate\" {\n+            let mut ctxt = module_path[0].ctxt;\n+            while ctxt.source().0 != SyntaxContext::empty() {\n+                ctxt = ctxt.source().0;\n+            }\n+            let module = self.invocations[&ctxt.source().1].module.get();\n+            let crate_root =\n+                if module.def_id().unwrap().is_local() { self.graph_root } else { module };\n+            return Success(PrefixFound(crate_root, 1))\n+        }\n+\n         // Start at the current module if we see `self` or `super`, or at the\n         // top of the crate otherwise.\n-        let mut i = match &*module_path[0].as_str() {\n+        let mut i = match &*module_path[0].name.as_str() {\n             \"self\" => 1,\n             \"super\" => 0,\n             _ => return Success(NoPrefixFound),\n@@ -1591,7 +1602,7 @@ impl<'a> Resolver<'a> {\n             self.module_map[&self.current_module.normal_ancestor_id.unwrap()];\n \n         // Now loop through all the `super`s we find.\n-        while i < module_path.len() && \"super\" == module_path[i].as_str() {\n+        while i < module_path.len() && \"super\" == module_path[i].name.as_str() {\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n                    module_to_string(&containing_module));\n             if let Some(parent) = containing_module.parent {\n@@ -1649,7 +1660,7 @@ impl<'a> Resolver<'a> {\n \n     /// Searches the current set of local scopes for labels.\n     /// Stops after meeting a closure.\n-    fn search_label(&self, mut ident: ast::Ident) -> Option<Def> {\n+    fn search_label(&self, mut ident: Ident) -> Option<Def> {\n         for rib in self.label_ribs.iter().rev() {\n             match rib.kind {\n                 NormalRibKind => {\n@@ -1813,7 +1824,7 @@ impl<'a> Resolver<'a> {\n                     // plain insert (no renaming)\n                     let def_id = self.definitions.local_def_id(type_parameter.id);\n                     let def = Def::TyParam(def_id);\n-                    function_type_rib.bindings.insert(ast::Ident::with_empty_ctxt(name), def);\n+                    function_type_rib.bindings.insert(Ident::with_empty_ctxt(name), def);\n                     self.record_def(type_parameter.id, PathResolution::new(def));\n                 }\n                 self.type_ribs.push(function_type_rib);\n@@ -2271,7 +2282,7 @@ impl<'a> Resolver<'a> {\n                      pat_id: NodeId,\n                      outer_pat_id: NodeId,\n                      pat_src: PatternSource,\n-                     bindings: &mut FnvHashMap<ast::Ident, NodeId>)\n+                     bindings: &mut FnvHashMap<Ident, NodeId>)\n                      -> PathResolution {\n         // Add the binding to the local ribs, if it\n         // doesn't already exist in the bindings map. (We\n@@ -2372,7 +2383,7 @@ impl<'a> Resolver<'a> {\n                        pat_src: PatternSource,\n                        // Maps idents to the node ID for the\n                        // outermost pattern that binds them.\n-                       bindings: &mut FnvHashMap<ast::Ident, NodeId>) {\n+                       bindings: &mut FnvHashMap<Ident, NodeId>) {\n         // Visit all direct subpatterns of this pattern.\n         let outer_pat_id = pat.id;\n         pat.walk(&mut |pat| {\n@@ -2573,7 +2584,7 @@ impl<'a> Resolver<'a> {\n \n     // Resolve a single identifier\n     fn resolve_identifier(&mut self,\n-                          identifier: ast::Ident,\n+                          identifier: Ident,\n                           namespace: Namespace,\n                           record_used: Option<Span>)\n                           -> Option<LocalDef> {\n@@ -2681,12 +2692,8 @@ impl<'a> Resolver<'a> {\n                                     namespace: Namespace)\n                                     -> Result<&'a NameBinding<'a>,\n                                               bool /* true if an error was reported */> {\n-        let module_path = segments.split_last()\n-                                  .unwrap()\n-                                  .1\n-                                  .iter()\n-                                  .map(|ps| ps.identifier.name)\n-                                  .collect::<Vec<_>>();\n+        let module_path =\n+            segments.split_last().unwrap().1.iter().map(|ps| ps.identifier).collect::<Vec<_>>();\n \n         let containing_module;\n         match self.resolve_module_path(&module_path, UseLexicalScope, Some(span)) {\n@@ -2715,7 +2722,7 @@ impl<'a> Resolver<'a> {\n                                                 bool /* true if an error was reported */>\n         where T: Named,\n     {\n-        let module_path = segments.split_last().unwrap().1.iter().map(T::name).collect::<Vec<_>>();\n+        let module_path = segments.split_last().unwrap().1.iter().map(T::ident).collect::<Vec<_>>();\n         let root_module = self.graph_root;\n \n         let containing_module;\n@@ -2734,7 +2741,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let name = segments.last().unwrap().name();\n+        let name = segments.last().unwrap().ident().name;\n         let result =\n             self.resolve_name_in_module(containing_module, name, namespace, false, Some(span));\n         result.success().ok_or(false)\n@@ -2835,7 +2842,7 @@ impl<'a> Resolver<'a> {\n         } SuggestionType::NotFound\n     }\n \n-    fn resolve_labeled_block(&mut self, label: Option<ast::Ident>, id: NodeId, block: &Block) {\n+    fn resolve_labeled_block(&mut self, label: Option<Ident>, id: NodeId, block: &Block) {\n         if let Some(label) = label {\n             let def = Def::Label(id);\n             self.with_label_rib(|this| {\n@@ -2976,9 +2983,8 @@ impl<'a> Resolver<'a> {\n                                     msg = format!(\"did you mean {}?\", msg);\n                                 } else {\n                                     // we display a help message if this is a module\n-                                    let name_path = path.segments.iter()\n-                                                        .map(|seg| seg.identifier.name)\n-                                                        .collect::<Vec<_>>();\n+                                    let name_path: Vec<_> =\n+                                        path.segments.iter().map(|seg| seg.identifier).collect();\n \n                                     match self.resolve_module_path(&name_path[..],\n                                                                    UseLexicalScope,\n@@ -3237,7 +3243,7 @@ impl<'a> Resolver<'a> {\n                 if name == lookup_name && ns == namespace {\n                     if filter_fn(name_binding.def()) {\n                         // create the path\n-                        let ident = ast::Ident::with_empty_ctxt(name);\n+                        let ident = Ident::with_empty_ctxt(name);\n                         let params = PathParameters::none();\n                         let segment = PathSegment {\n                             identifier: ident,\n@@ -3271,7 +3277,7 @@ impl<'a> Resolver<'a> {\n                         _ if module.parent.is_none() => path_segments.clone(),\n                         ModuleKind::Def(_, name) => {\n                             let mut paths = path_segments.clone();\n-                            let ident = ast::Ident::with_empty_ctxt(name);\n+                            let ident = Ident::with_empty_ctxt(name);\n                             let params = PathParameters::none();\n                             let segm = PathSegment {\n                                 identifier: ident,\n@@ -3317,7 +3323,7 @@ impl<'a> Resolver<'a> {\n             }\n         };\n \n-        let segments: Vec<_> = path.segments.iter().map(|seg| seg.identifier.name).collect();\n+        let segments: Vec<_> = path.segments.iter().map(|seg| seg.identifier).collect();\n         let mut path_resolution = err_path_resolution();\n         let vis = match self.resolve_module_path(&segments, DontUseLexicalScope, Some(path.span)) {\n             Success(module) => {\n@@ -3469,26 +3475,24 @@ impl<'a> Resolver<'a> {\n     }\n }\n \n-fn names_to_string(names: &[Name]) -> String {\n+fn names_to_string(names: &[Ident]) -> String {\n     let mut first = true;\n     let mut result = String::new();\n-    for name in names {\n+    for ident in names {\n         if first {\n             first = false\n         } else {\n             result.push_str(\"::\")\n         }\n-        result.push_str(&name.as_str());\n+        result.push_str(&ident.name.as_str());\n     }\n     result\n }\n \n fn path_names_to_string(path: &Path, depth: usize) -> String {\n-    let names: Vec<ast::Name> = path.segments[..path.segments.len() - depth]\n-                                    .iter()\n-                                    .map(|seg| seg.identifier.name)\n-                                    .collect();\n-    names_to_string(&names[..])\n+    let names: Vec<_> =\n+        path.segments[..path.segments.len() - depth].iter().map(|seg| seg.identifier).collect();\n+    names_to_string(&names)\n }\n \n /// When an entity with a given name is not available in scope, we search for\n@@ -3551,15 +3555,15 @@ fn show_candidates(session: &mut DiagnosticBuilder,\n fn module_to_string(module: Module) -> String {\n     let mut names = Vec::new();\n \n-    fn collect_mod(names: &mut Vec<ast::Name>, module: Module) {\n+    fn collect_mod(names: &mut Vec<Ident>, module: Module) {\n         if let ModuleKind::Def(_, name) = module.kind {\n             if let Some(parent) = module.parent {\n-                names.push(name);\n+                names.push(Ident::with_empty_ctxt(name));\n                 collect_mod(names, parent);\n             }\n         } else {\n             // danger, shouldn't be ident?\n-            names.push(token::intern(\"<opaque>\"));\n+            names.push(token::str_to_ident(\"<opaque>\"));\n             collect_mod(names, module.parent.unwrap());\n         }\n     }\n@@ -3568,7 +3572,7 @@ fn module_to_string(module: Module) -> String {\n     if names.is_empty() {\n         return \"???\".to_string();\n     }\n-    names_to_string(&names.into_iter().rev().collect::<Vec<ast::Name>>())\n+    names_to_string(&names.into_iter().rev().collect::<Vec<_>>())\n }\n \n fn err_path_resolution() -> PathResolution {"}, {"sha": "0f42b4520c9b7a17a890e225f94c4cb1aa845caf", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7", "patch": "@@ -29,10 +29,10 @@ use syntax_pos::Span;\n #[derive(Clone)]\n pub struct InvocationData<'a> {\n     pub module: Cell<Module<'a>>,\n-    def_index: DefIndex,\n+    pub def_index: DefIndex,\n     // True if this expansion is in a `const_integer` position, for example `[u32; m!()]`.\n     // c.f. `DefCollector::visit_ast_const_integer`.\n-    const_integer: bool,\n+    pub const_integer: bool,\n     // The scope in which the invocation path is resolved.\n     pub legacy_scope: Cell<LegacyScope<'a>>,\n     // The smallest scope that includes this invocation's expansion,"}, {"sha": "2b3945bd0d9204e62f8acaf7978fa02a51528fc0", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7", "patch": "@@ -24,7 +24,7 @@ use rustc::ty;\n use rustc::lint::builtin::PRIVATE_IN_PUBLIC;\n use rustc::hir::def::*;\n \n-use syntax::ast::{NodeId, Name};\n+use syntax::ast::{Ident, NodeId, Name};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n@@ -69,7 +69,7 @@ impl<'a> ImportDirectiveSubclass<'a> {\n pub struct ImportDirective<'a> {\n     pub id: NodeId,\n     parent: Module<'a>,\n-    module_path: Vec<Name>,\n+    module_path: Vec<Ident>,\n     imported_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n     subclass: ImportDirectiveSubclass<'a>,\n     span: Span,\n@@ -252,7 +252,7 @@ impl<'a> Resolver<'a> {\n \n     // Add an import directive to the current module.\n     pub fn add_import_directive(&mut self,\n-                                module_path: Vec<Name>,\n+                                module_path: Vec<Ident>,\n                                 subclass: ImportDirectiveSubclass<'a>,\n                                 span: Span,\n                                 id: NodeId,\n@@ -816,7 +816,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     }\n }\n \n-fn import_path_to_string(names: &[Name], subclass: &ImportDirectiveSubclass) -> String {\n+fn import_path_to_string(names: &[Ident], subclass: &ImportDirectiveSubclass) -> String {\n     if names.is_empty() {\n         import_directive_subclass_to_string(subclass)\n     } else {"}, {"sha": "bd47b1e7c121c4ca93d282958e048ec372d6f470", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7", "patch": "@@ -295,7 +295,9 @@ impl<'a> Classifier<'a> {\n                     \"Option\" | \"Result\" => Class::PreludeTy,\n                     \"Some\" | \"None\" | \"Ok\" | \"Err\" => Class::PreludeVal,\n \n+                    \"$crate\" => Class::KeyWord,\n                     _ if tas.tok.is_any_keyword() => Class::KeyWord,\n+\n                     _ => {\n                         if self.in_macro_nonterminal {\n                             self.in_macro_nonterminal = false;\n@@ -310,9 +312,6 @@ impl<'a> Classifier<'a> {\n                 }\n             }\n \n-            // Special macro vars are like keywords.\n-            token::SpecialVarNt(_) => Class::KeyWord,\n-\n             token::Lifetime(..) => Class::Lifetime,\n \n             token::Underscore | token::Eof | token::Interpolated(..) |"}, {"sha": "e84a9208029a5e7e2a4379a0be9e275f8d5154f4", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7", "patch": "@@ -939,6 +939,6 @@ impl Folder for Marker {\n }\n \n // apply a given mark to the given token trees. Used prior to expansion of a macro.\n-fn mark_tts(tts: &[TokenTree], m: Mark) -> Vec<TokenTree> {\n+pub fn mark_tts(tts: &[TokenTree], m: Mark) -> Vec<TokenTree> {\n     noop_fold_tts(tts, &mut Marker{mark:m, expn_id: None})\n }"}, {"sha": "5496d27c087409ed8f8f95b1b74c1660912581ed", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7", "patch": "@@ -58,7 +58,6 @@ impl<'a> ParserAnyMacro<'a> {\n \n struct MacroRulesMacroExpander {\n     name: ast::Ident,\n-    imported_from: Option<ast::Ident>,\n     lhses: Vec<TokenTree>,\n     rhses: Vec<TokenTree>,\n     valid: bool,\n@@ -76,7 +75,6 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n         generic_extension(cx,\n                           sp,\n                           self.name,\n-                          self.imported_from,\n                           arg,\n                           &self.lhses,\n                           &self.rhses)\n@@ -87,7 +85,6 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                           sp: Span,\n                           name: ast::Ident,\n-                          imported_from: Option<ast::Ident>,\n                           arg: &[TokenTree],\n                           lhses: &[TokenTree],\n                           rhses: &[TokenTree])\n@@ -116,10 +113,8 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                     _ => cx.span_bug(sp, \"malformed macro rhs\"),\n                 };\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n-                let trncbr = new_tt_reader(&cx.parse_sess.span_diagnostic,\n-                                           Some(named_matches),\n-                                           imported_from,\n-                                           rhs);\n+                let trncbr =\n+                    new_tt_reader(&cx.parse_sess.span_diagnostic, Some(named_matches), rhs);\n                 let mut p = Parser::new(cx.parse_sess(), cx.cfg().clone(), Box::new(trncbr));\n                 p.directory = cx.current_expansion.module.directory.clone();\n                 p.restrictions = match cx.current_expansion.no_noninline_mod {\n@@ -223,7 +218,7 @@ pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n     ];\n \n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n-    let arg_reader = new_tt_reader(&sess.span_diagnostic, None, None, def.body.clone());\n+    let arg_reader = new_tt_reader(&sess.span_diagnostic, None, def.body.clone());\n \n     let argument_map = match parse(sess, &Vec::new(), arg_reader, &argument_gram) {\n         Success(m) => m,\n@@ -269,7 +264,6 @@ pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n \n     let exp: Box<_> = Box::new(MacroRulesMacroExpander {\n         name: def.ident,\n-        imported_from: def.imported_from,\n         lhses: lhses,\n         rhses: rhses,\n         valid: valid,"}, {"sha": "38a926b6e87c9ce1f9d00f430a2b1982d3592b1f", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 29, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7", "patch": "@@ -14,7 +14,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use errors::{Handler, DiagnosticBuilder};\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n use parse::token::{DocComment, MatchNt, SubstNt};\n-use parse::token::{Token, Interpolated, NtIdent, NtTT, SpecialMacroVar};\n+use parse::token::{Token, Interpolated, NtIdent, NtTT};\n use parse::token;\n use parse::lexer::TokenAndSpan;\n use tokenstream::{self, TokenTree};\n@@ -39,10 +39,7 @@ pub struct TtReader<'a> {\n     stack: Vec<TtFrame>,\n     /* for MBE-style macro transcription */\n     interpolations: HashMap<Ident, Rc<NamedMatch>>,\n-    imported_from: Option<Ident>,\n \n-    // Some => return imported_from as the next token\n-    crate_name_next: Option<Span>,\n     repeat_idx: Vec<usize>,\n     repeat_len: Vec<usize>,\n     /* cached: */\n@@ -59,10 +56,9 @@ pub struct TtReader<'a> {\n /// (and should) be None.\n pub fn new_tt_reader(sp_diag: &Handler,\n                      interp: Option<HashMap<Ident, Rc<NamedMatch>>>,\n-                     imported_from: Option<Ident>,\n                      src: Vec<tokenstream::TokenTree>)\n                      -> TtReader {\n-    new_tt_reader_with_doc_flag(sp_diag, interp, imported_from, src, false)\n+    new_tt_reader_with_doc_flag(sp_diag, interp, src, false)\n }\n \n /// The extra `desugar_doc_comments` flag enables reading doc comments\n@@ -73,7 +69,6 @@ pub fn new_tt_reader(sp_diag: &Handler,\n /// (and should) be None.\n pub fn new_tt_reader_with_doc_flag(sp_diag: &Handler,\n                                    interp: Option<HashMap<Ident, Rc<NamedMatch>>>,\n-                                   imported_from: Option<Ident>,\n                                    src: Vec<tokenstream::TokenTree>,\n                                    desugar_doc_comments: bool)\n                                    -> TtReader {\n@@ -93,8 +88,6 @@ pub fn new_tt_reader_with_doc_flag(sp_diag: &Handler,\n             None => HashMap::new(),\n             Some(x) => x,\n         },\n-        imported_from: imported_from,\n-        crate_name_next: None,\n         repeat_idx: Vec::new(),\n         repeat_len: Vec::new(),\n         desugar_doc_comments: desugar_doc_comments,\n@@ -189,14 +182,6 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n         sp: r.cur_span.clone(),\n     };\n     loop {\n-        match r.crate_name_next.take() {\n-            None => (),\n-            Some(sp) => {\n-                r.cur_span = sp;\n-                r.cur_tok = token::Ident(r.imported_from.unwrap());\n-                return ret_val;\n-            },\n-        }\n         let should_pop = match r.stack.last() {\n             None => {\n                 assert_eq!(ret_val.tok, token::Eof);\n@@ -346,18 +331,6 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                    sep: None\n                 });\n             }\n-            TokenTree::Token(sp, token::SpecialVarNt(SpecialMacroVar::CrateMacroVar)) => {\n-                r.stack.last_mut().unwrap().idx += 1;\n-\n-                if r.imported_from.is_some() {\n-                    r.cur_span = sp;\n-                    r.cur_tok = token::ModSep;\n-                    r.crate_name_next = Some(sp);\n-                    return ret_val;\n-                }\n-\n-                // otherwise emit nothing and proceed to the next token\n-            }\n             TokenTree::Token(sp, tok) => {\n                 r.cur_span = sp;\n                 r.cur_tok = tok;"}, {"sha": "1a84a750463c8ad31cb2e3f68f0fbdcbf97618ba", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7", "patch": "@@ -276,7 +276,7 @@ pub fn filemap_to_tts(sess: &ParseSess, filemap: Rc<FileMap>)\n pub fn tts_to_parser<'a>(sess: &'a ParseSess,\n                          tts: Vec<tokenstream::TokenTree>,\n                          cfg: ast::CrateConfig) -> Parser<'a> {\n-    let trdr = lexer::new_tt_reader(&sess.span_diagnostic, None, None, tts);\n+    let trdr = lexer::new_tt_reader(&sess.span_diagnostic, None, tts);\n     let mut p = Parser::new(sess, cfg, Box::new(trdr));\n     p.check_unknown_macro_variable();\n     p"}, {"sha": "eac78f5e6c68c66b415fad127bdbfe6f1647b240", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7", "patch": "@@ -48,8 +48,7 @@ use parse::classify;\n use parse::common::SeqSep;\n use parse::lexer::{Reader, TokenAndSpan};\n use parse::obsolete::ObsoleteSyntax;\n-use parse::token::{self, intern, MatchNt, SubstNt, SpecialVarNt, InternedString};\n-use parse::token::{keywords, SpecialMacroVar};\n+use parse::token::{self, intern, keywords, MatchNt, SubstNt, InternedString};\n use parse::{new_sub_parser_from_file, ParseSess};\n use util::parser::{AssocOp, Fixity};\n use print::pprust;\n@@ -2653,8 +2652,12 @@ impl<'a> Parser<'a> {\n                                           num_captures: name_num\n                                       })));\n                 } else if self.token.is_keyword(keywords::Crate) {\n+                    let ident = match self.token {\n+                        token::Ident(id) => ast::Ident { name: token::intern(\"$crate\"), ..id },\n+                        _ => unreachable!(),\n+                    };\n                     self.bump();\n-                    return Ok(TokenTree::Token(sp, SpecialVarNt(SpecialMacroVar::CrateMacroVar)));\n+                    return Ok(TokenTree::Token(sp, token::Ident(ident)));\n                 } else {\n                     sp = mk_sp(sp.lo, self.span.hi);\n                     self.parse_ident().unwrap_or_else(|mut e| {"}, {"sha": "26b5b99c8cce669542a145e0c81e08bdd21818c0", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7", "patch": "@@ -52,21 +52,6 @@ pub enum DelimToken {\n     NoDelim,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n-pub enum SpecialMacroVar {\n-    /// `$crate` will be filled in with the name of the crate a macro was\n-    /// imported from, if any.\n-    CrateMacroVar,\n-}\n-\n-impl SpecialMacroVar {\n-    pub fn as_str(self) -> &'static str {\n-        match self {\n-            SpecialMacroVar::CrateMacroVar => \"crate\",\n-        }\n-    }\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n pub enum Lit {\n     Byte(ast::Name),\n@@ -148,8 +133,6 @@ pub enum Token {\n     // In right-hand-sides of MBE macros:\n     /// A syntactic variable that will be filled in by macro expansion.\n     SubstNt(ast::Ident),\n-    /// A macro variable with special meaning.\n-    SpecialVarNt(SpecialMacroVar),\n \n     // Junk. These carry no data because we don't really care about the data\n     // they *would* carry, and don't really want to allocate a new ident for"}, {"sha": "c6f63d772426a1d61be5bac0eab8213cf6262848", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7", "patch": "@@ -285,8 +285,6 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::Comment              => \"/* */\".to_string(),\n         token::Shebang(s)           => format!(\"/* shebang: {}*/\", s),\n \n-        token::SpecialVarNt(var)    => format!(\"${}\", var.as_str()),\n-\n         token::Interpolated(ref nt) => match *nt {\n             token::NtExpr(ref e)        => expr_to_string(&e),\n             token::NtMeta(ref e)        => meta_item_to_string(&e),"}, {"sha": "f22f920a7fa0e2c390fd20e6e028e18edbfe22eb", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7", "patch": "@@ -134,7 +134,6 @@ impl TokenTree {\n                     AttrStyle::Inner => 3,\n                 }\n             }\n-            TokenTree::Token(_, token::SpecialVarNt(..)) => 2,\n             TokenTree::Token(_, token::MatchNt(..)) => 3,\n             TokenTree::Token(_, token::Interpolated(Nonterminal::NtTT(..))) => 1,\n             TokenTree::Delimited(_, ref delimed) => delimed.tts.len() + 2,\n@@ -188,11 +187,6 @@ impl TokenTree {\n                 }\n                 delimed.tts[index - 1].clone()\n             }\n-            (&TokenTree::Token(sp, token::SpecialVarNt(var)), _) => {\n-                let v = [TokenTree::Token(sp, token::Dollar),\n-                         TokenTree::Token(sp, token::Ident(token::str_to_ident(var.as_str())))];\n-                v[index].clone()\n-            }\n             (&TokenTree::Token(sp, token::MatchNt(name, kind)), _) => {\n                 let v = [TokenTree::Token(sp, token::SubstNt(name)),\n                          TokenTree::Token(sp, token::Colon),\n@@ -223,7 +217,6 @@ impl TokenTree {\n                  -> macro_parser::NamedParseResult {\n         // `None` is because we're not interpolating\n         let arg_rdr = lexer::new_tt_reader_with_doc_flag(&cx.parse_sess().span_diagnostic,\n-                                                         None,\n                                                          None,\n                                                          tts.iter().cloned().collect(),\n                                                          true);"}, {"sha": "40ff4852e3856b159f273819fc107cff3b7c139d", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7", "patch": "@@ -38,7 +38,7 @@\n \n \n \n-    ((::std::fmt::format as\n+    (($crate::fmt::format as\n          fn(std::fmt::Arguments<'_>) -> std::string::String {std::fmt::format})(((::std::fmt::Arguments::new_v1\n                                                                                      as\n                                                                                      fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments<'_>::new_v1})(({"}]}