{"sha": "b159d9cde595bf4c8beecb687d0aa1c0231edf6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxNTlkOWNkZTU5NWJmNGM4YmVlY2I2ODdkMGFhMWMwMjMxZWRmNmM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-01-20T20:28:04Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-01-29T22:58:10Z"}, "message": "Make the save-analysis smoke test more thorough", "tree": {"sha": "21ec5e2fc1979235cf2cc99d510ff16554386bf4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21ec5e2fc1979235cf2cc99d510ff16554386bf4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b159d9cde595bf4c8beecb687d0aa1c0231edf6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b159d9cde595bf4c8beecb687d0aa1c0231edf6c", "html_url": "https://github.com/rust-lang/rust/commit/b159d9cde595bf4c8beecb687d0aa1c0231edf6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b159d9cde595bf4c8beecb687d0aa1c0231edf6c/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78f617800fd723a721582660f455d22e5b21eb4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/78f617800fd723a721582660f455d22e5b21eb4c", "html_url": "https://github.com/rust-lang/rust/commit/78f617800fd723a721582660f455d22e5b21eb4c"}], "stats": {"total": 405, "additions": 376, "deletions": 29}, "files": [{"sha": "fe70ac1edef6e782569e9c14b92c698995d80d0a", "filename": "src/test/run-make/save-analysis/SameDir.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b159d9cde595bf4c8beecb687d0aa1c0231edf6c/src%2Ftest%2Frun-make%2Fsave-analysis%2FSameDir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b159d9cde595bf4c8beecb687d0aa1c0231edf6c/src%2Ftest%2Frun-make%2Fsave-analysis%2FSameDir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2FSameDir.rs?ref=b159d9cde595bf4c8beecb687d0aa1c0231edf6c", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// sub-module in the same directory as the main crate file\n+\n+pub struct SameStruct {\n+    pub name: String\n+}"}, {"sha": "315f900868b45443131616e4672f97ed13764c8d", "filename": "src/test/run-make/save-analysis/SameDir3.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b159d9cde595bf4c8beecb687d0aa1c0231edf6c/src%2Ftest%2Frun-make%2Fsave-analysis%2FSameDir3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b159d9cde595bf4c8beecb687d0aa1c0231edf6c/src%2Ftest%2Frun-make%2Fsave-analysis%2FSameDir3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2FSameDir3.rs?ref=b159d9cde595bf4c8beecb687d0aa1c0231edf6c", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn hello(x: isize) {\n+    println!(\"macro {} :-(\", x);\n+}"}, {"sha": "5ce7855da2af65b562570855a9b7e115c3128628", "filename": "src/test/run-make/save-analysis/SubDir/mod.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b159d9cde595bf4c8beecb687d0aa1c0231edf6c/src%2Ftest%2Frun-make%2Fsave-analysis%2FSubDir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b159d9cde595bf4c8beecb687d0aa1c0231edf6c/src%2Ftest%2Frun-make%2Fsave-analysis%2FSubDir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2FSubDir%2Fmod.rs?ref=b159d9cde595bf4c8beecb687d0aa1c0231edf6c", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// sub-module in a sub-directory\n+\n+use sub::sub2 as msalias;\n+use sub::sub2;\n+use std::io::stdio::println;\n+\n+static yy: usize = 25us;\n+\n+mod sub {\n+    pub mod sub2 {\n+        use std::io::stdio::println;\n+        pub mod sub3 {\n+            use std::io::stdio::println;\n+            pub fn hello() {\n+                println(\"hello from module 3\");\n+            }\n+        }\n+        pub fn hello() {\n+            println(\"hello from a module\");\n+        }\n+\n+        pub struct nested_struct {\n+            pub field2: u32,\n+        }\n+    }\n+}\n+\n+pub struct SubStruct {\n+    pub name: String\n+}"}, {"sha": "da56e616fcf976274df83117adfd06633b2c4d2f", "filename": "src/test/run-make/save-analysis/foo.rs", "status": "modified", "additions": 308, "deletions": 29, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/b159d9cde595bf4c8beecb687d0aa1c0231edf6c/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b159d9cde595bf4c8beecb687d0aa1c0231edf6c/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs?ref=b159d9cde595bf4c8beecb687d0aa1c0231edf6c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,53 +8,332 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![ crate_name = \"test\" ]\n+#![allow(unstable)]\n #![feature(box_syntax)]\n \n-struct Foo {\n-    f: int\n+extern crate graphviz;\n+// A simple rust project\n+\n+extern crate \"flate\" as myflate;\n+\n+use graphviz::maybe_owned_vec::MaybeOwnedVector;\n+use std::collections::{HashMap,HashSet};\n+use std::cell::RefCell;\n+use std::io::stdio::println;\n+\n+\n+use sub::sub2 as msalias;\n+use sub::sub2;\n+use sub::sub2::nested_struct as sub_struct;\n+use std::num::Float;\n+use std::num::cast;\n+use std::num::{from_int,from_i8,from_i32};\n+\n+use std::mem::size_of;\n+\n+static uni: &'static str = \"Les Mis\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9rables\";\n+static yy: usize = 25us;\n+\n+static bob: Option<graphviz::maybe_owned_vec::MaybeOwnedVector<'static, isize>> = None;\n+\n+// buglink test - see issue #1337.\n+\n+fn test_alias<I: Iterator>(i: Option<<I as Iterator>::Item>) {\n+    let s = sub_struct{ field2: 45u32, };\n+\n+    // import tests\n+    fn foo(x: &Float) {}\n+    let _: Option<u8> = from_i32(45);\n+\n+    let x = 42us;\n+\n+    myflate::deflate_bytes(&[]);\n+\n+    let x = (3is, 4us);\n+    let y = x.1;\n+}\n+\n+struct TupStruct(int, int, Box<str>);\n+\n+fn test_tup_struct(x: TupStruct) -> int {\n+    x.1\n+}\n+\n+mod sub {\n+    pub mod sub2 {\n+        use std::io::stdio::println;\n+        pub mod sub3 {\n+            use std::io::stdio::println;\n+            pub fn hello() {\n+                println(\"hello from module 3\");\n+            }\n+        }\n+        pub fn hello() {\n+            println(\"hello from a module\");\n+        }\n+\n+        pub struct nested_struct {\n+            pub field2: u32,\n+        }\n+\n+        pub enum nested_enum {\n+            Nest2 = 2,\n+            Nest3 = 3\n+        }\n+    }\n+}\n+\n+pub mod SameDir;\n+pub mod SubDir;\n+\n+#[path = \"SameDir3.rs\"]\n+pub mod SameDir2;\n+\n+struct nofields;\n+\n+#[derive(Clone)]\n+struct some_fields {\n+    field1: u32,\n+}\n+\n+type SF = some_fields;\n+\n+trait SuperTrait {\n+}\n+\n+trait SomeTrait: SuperTrait {\n+    fn Method(&self, x: u32) -> u32;\n+\n+    fn prov(&self, x: u32) -> u32 {\n+        println(x.to_string().as_slice());\n+        42\n+    }\n+    fn provided_method(&self) -> u32 {\n+        42\n+    }\n+}\n+\n+trait SubTrait: SomeTrait {\n+    fn stat2(x: &Self) -> u32 {\n+        32\n+    }\n+}\n+\n+impl SomeTrait for some_fields {\n+    fn Method(&self, x: u32) -> u32 {\n+        println(x.to_string().as_slice());\n+        self.field1\n+    }\n+}\n+\n+impl SuperTrait for some_fields {\n+}\n+\n+impl SubTrait for some_fields {}\n+\n+impl some_fields {\n+    fn stat(x: u32) -> u32 {\n+        println(x.to_string().as_slice());\n+        42\n+    }\n+    fn stat2(x: &some_fields) -> u32 {\n+        42\n+    }\n+\n+    fn align_to<T>(&mut self) {\n+    }\n+\n+    fn test(&mut self) {\n+        self.align_to::<bool>();\n+    }\n }\n \n-impl Foo {\n-    fn bar(&self) -> int {\n-        println!(\"f is {}\", self.f);\n-        self.f\n+impl SuperTrait for nofields {\n+}\n+impl SomeTrait for nofields {\n+    fn Method(&self, x: u32) -> u32 {\n+        self.Method(x);\n+        43\n+    }\n+\n+    fn provided_method(&self) -> u32 {\n+        21\n     }\n }\n \n-trait Tr {\n-    fn tar(&self, x: Box<Foo>) -> Foo;\n+impl SubTrait for nofields {}\n+\n+impl SuperTrait for (Box<nofields>, Box<some_fields>) {}\n+\n+fn f_with_params<T: SomeTrait>(x: &T) {\n+    x.Method(41);\n }\n \n-impl Tr for Foo {\n-    fn tar(&self, x: Box<Foo>) -> Foo {\n-        Foo{ f: self.f + x.f }\n+type MyType = Box<some_fields>;\n+\n+enum SomeEnum<'a> {\n+    Ints(isize, isize),\n+    Floats(f64, f64),\n+    Strings(&'a str, &'a str, &'a str),\n+    MyTypes(MyType, MyType)\n+}\n+\n+#[derive(Copy)]\n+enum SomeOtherEnum {\n+    SomeConst1,\n+    SomeConst2,\n+    SomeConst3\n+}\n+\n+enum SomeStructEnum {\n+    EnumStruct{a:isize, b:isize},\n+    EnumStruct2{f1:MyType, f2:MyType},\n+    EnumStruct3{f1:MyType, f2:MyType, f3:SomeEnum<'static>}\n+}\n+\n+fn matchSomeEnum(val: SomeEnum) {\n+    match val {\n+        SomeEnum::Ints(int1, int2) => { println((int1+int2).to_string().as_slice()); }\n+        SomeEnum::Floats(float1, float2) => { println((float2*float1).to_string().as_slice()); }\n+        SomeEnum::Strings(_, _, s3) => { println(s3); }\n+        SomeEnum::MyTypes(mt1, mt2) => {\n+            println((mt1.field1 - mt2.field1).to_string().as_slice());\n+        }\n     }\n }\n \n-trait Tr2<X, Y: Tr> {\n-    fn squid(&self, y: &Y, z: Self) -> Box<X>;\n+fn matchSomeStructEnum(se: SomeStructEnum) {\n+    match se {\n+        SomeStructEnum::EnumStruct{a:a, ..} => println(a.to_string().as_slice()),\n+        SomeStructEnum::EnumStruct2{f1:f1, f2:f_2} => println(f_2.field1.to_string().as_slice()),\n+        SomeStructEnum::EnumStruct3{f1, ..} => println(f1.field1.to_string().as_slice()),\n+    }\n }\n \n-impl Tr2<Foo, Foo> for Foo {\n-    fn squid(&self, y: &Foo, z: Foo) -> Box<Foo> {\n-        box Foo { f: y.f + z.f + self.f }\n+\n+fn matchSomeStructEnum2(se: SomeStructEnum) {\n+    use SomeStructEnum::*;\n+    match se {\n+        EnumStruct{a: ref aaa, ..} => println(aaa.to_string().as_slice()),\n+        EnumStruct2{f1, f2: f2} => println(f1.field1.to_string().as_slice()),\n+        EnumStruct3{f1, f3: SomeEnum::Ints(_, _), f2} => println(f1.field1.to_string().as_slice()),\n+        _ => {},\n     }\n }\n \n-enum En {\n-    Var1,\n-    Var2,\n-    Var3(int, int, Foo)\n+fn matchSomeOtherEnum(val: SomeOtherEnum) {\n+    use SomeOtherEnum::{SomeConst2, SomeConst3};\n+    match val {\n+        SomeOtherEnum::SomeConst1 => { println(\"I'm const1.\"); }\n+        SomeConst2 | SomeConst3 => { println(\"I'm const2 or const3.\"); }\n+    }\n }\n \n-fn main() {\n-    let x = Foo { f: 237 };\n-    let _f = x.bar();\n-    let en = En::Var2;\n+fn hello<X: SomeTrait>((z, a) : (u32, String), ex: X) {\n+    SameDir2::hello(43);\n+\n+    println(yy.to_string().as_slice());\n+    let (x, y): (u32, u32) = (5, 3);\n+    println(x.to_string().as_slice());\n+    println(z.to_string().as_slice());\n+    let x: u32 = x;\n+    println(x.to_string().as_slice());\n+    let x = \"hello\";\n+    println(x);\n+\n+    let x = 32.0f32;\n+    let _ = (x + ((x * x) + 1.0).sqrt()).ln();\n \n-    let _ = match en {\n-        En::Var1 => x.bar(),\n-        En::Var2 => 34,\n-        En::Var3(x, y, f) => f.bar()\n+    let s: Box<SomeTrait> = box some_fields {field1: 43};\n+    let s2: Box<some_fields> =  box some_fields {field1: 43};\n+    let s3 = box nofields;\n+\n+    s.Method(43);\n+    s3.Method(43);\n+    s2.Method(43);\n+\n+    ex.prov(43);\n+\n+    let y: u32 = 56;\n+    // static method on struct\n+    let r = some_fields::stat(y);\n+    // trait static method, calls override\n+    let r = SubTrait::stat2(&*s2);\n+    // trait static method, calls default\n+    let r = SubTrait::stat2(&*s3);\n+\n+    let s4 = s3 as Box<SomeTrait>;\n+    s4.Method(43);\n+\n+    s4.provided_method();\n+    s2.prov(45);\n+\n+    let closure = |&: x: u32, s: &SomeTrait| {\n+        s.Method(23);\n+        return x + y;\n+    };\n+\n+    let z = closure(10, &*s);\n+}\n+\n+pub struct blah {\n+    used_link_args: RefCell<[&'static str; 0]>,\n+}\n+\n+fn main() { // foo\n+    let s = box some_fields {field1: 43};\n+    hello((43, \"a\".to_string()), *s);\n+    sub::sub2::hello();\n+    sub2::sub3::hello();\n+\n+    let h = sub2::sub3::hello;\n+    h();\n+\n+    // utf8 chars\n+    let ut = \"Les Mis\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9rables\";\n+\n+    // For some reason, this pattern of macro_rules foiled our generated code\n+    // avoiding strategy.\n+    macro_rules! variable_str(($name:expr) => (\n+        some_fields {\n+            field1: $name,\n+        }\n+    ));\n+    let vs = variable_str!(32);\n+\n+    let mut candidates: RefCell<HashMap<&'static str, &'static str>> = RefCell::new(HashMap::new());\n+    let _ = blah {\n+        used_link_args: RefCell::new([]),\n     };\n+    let s1 = nofields;\n+    let s2 = SF { field1: 55};\n+    let s3: some_fields = some_fields{ field1: 55};\n+    let s4: msalias::nested_struct = sub::sub2::nested_struct{ field2: 55};\n+    let s4: msalias::nested_struct = sub2::nested_struct{ field2: 55};\n+    println(s2.field1.to_string().as_slice());\n+    let s5: MyType = box some_fields{ field1: 55};\n+    let s = SameDir::SameStruct{name: \"Bob\".to_string()};\n+    let s = SubDir::SubStruct{name:\"Bob\".to_string()};\n+    let s6: SomeEnum = SomeEnum::MyTypes(box s2.clone(), s5);\n+    let s7: SomeEnum = SomeEnum::Strings(\"one\", \"two\", \"three\");\n+    matchSomeEnum(s6);\n+    matchSomeEnum(s7);\n+    let s8: SomeOtherEnum = SomeOtherEnum::SomeConst2;\n+    matchSomeOtherEnum(s8);\n+    let s9: SomeStructEnum =\n+        SomeStructEnum::EnumStruct2{f1: box some_fields{field1:10}, f2: box s2};\n+    matchSomeStructEnum(s9);\n+}\n+\n+impl Iterator for nofields {\n+    type Item = (usize, usize);\n+\n+    fn next(&mut self) -> Option<(usize, usize)> {\n+        panic!()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        panic!()\n+    }\n }"}]}