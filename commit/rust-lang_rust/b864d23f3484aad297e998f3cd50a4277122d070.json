{"sha": "b864d23f3484aad297e998f3cd50a4277122d070", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NjRkMjNmMzQ4NGFhZDI5N2U5OThmM2NkNTBhNDI3NzEyMmQwNzA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-02-18T21:16:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-18T21:16:26Z"}, "message": "Rollup merge of #69194 - Centril:assoc-extern-fuse, r=petrochenkov\n\nparse: fuse associated and extern items up to defaultness\n\nLanguage changes:\n\n- The grammar of extern `type` aliases is unified with associated ones, and becomes:\n  ```rust\n  TypeItem = \"type\" ident generics {\":\" bounds}? where_clause {\"=\" type}? \";\" ;\n  ```\n\n  Semantic restrictions (`ast_validation`) are added to forbid any parameters in `generics`, any bounds in `bounds`, and any predicates in `where_clause`, as well as the presence of a type expression (`= u8`).\n\n  (Work still remains to fuse this with free `type` aliases, but this can be done later.)\n\n- The grammar of constants and static items (free, associated, and extern) now permits the absence of an expression, and becomes:\n\n  ```rust\n  GlobalItem = {\"const\" {ident | \"_\"} | \"static\" \"mut\"? ident} {\"=\" expr}? \";\" ;\n  ```\n\n  - A semantic restriction is added to enforce the presence of the expression (the body).\n  - A semantic restriction is added to reject `const _` in associated contexts.\n\nTogether, these changes allow us to fuse the grammar of associated items and extern items up to `default`ness which is the main goal of the PR.\n\n-----------------------\n\nWe are now very close to fully fusing the entirely of item parsing and their ASTs. To progress further, we must make a decision: should we parse e.g. `default use foo::bar;` and whatnot? Accepting that is likely easiest from a parsing perspective, as it does not require using look-ahead, but it is perhaps not too onerous to only accept it for `fn`s (and all their various qualifiers), `const`s, `static`s, and `type`s.\n\nr? @petrochenkov", "tree": {"sha": "0a2343b3fe8b7d622cee5fef9971b261daaa079c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a2343b3fe8b7d622cee5fef9971b261daaa079c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b864d23f3484aad297e998f3cd50a4277122d070", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeTFQqCRBK7hj4Ov3rIwAAdHIIADtxuqrBJGNWxxHOYTaO0F4X\nhnZonsjZfWLGbTIy9z3DeKXk9ASatc3XG7xrv6YvKxVMK5S3OL5qqNcm4UjGrDPi\n2a30MvAIdLVUuy3ZJnRFsbJ7+k4AuUVaMIhUWXATaLJXeQCuayyU93lVptEU+IrN\nLtughkCSnO1aTQjOH9o2LIjNNkXCv1hUvGfr0CTLhCfDy3Env/3pRGreeMajLBVF\ni1WS8Bl+p37WxWqe5f+mix+w7sYCDGmzPYz5FurzNRhwc1jY1r3aNrrvn4MwdKtD\niXsIb+iG0fFTLeU7LSbg6mHk4oZvuB+fmvSIQtefR3Fgjl/e5IOgL79WfTg3PVs=\n=7CKh\n-----END PGP SIGNATURE-----\n", "payload": "tree 0a2343b3fe8b7d622cee5fef9971b261daaa079c\nparent 981acd90353b40e9529de0eda21ba5b4071134d5\nparent 045b7d53a3fe94d2f6cb32d029a3f5d74e174ed9\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1582060586 +0100\ncommitter GitHub <noreply@github.com> 1582060586 +0100\n\nRollup merge of #69194 - Centril:assoc-extern-fuse, r=petrochenkov\n\nparse: fuse associated and extern items up to defaultness\n\nLanguage changes:\n\n- The grammar of extern `type` aliases is unified with associated ones, and becomes:\n  ```rust\n  TypeItem = \"type\" ident generics {\":\" bounds}? where_clause {\"=\" type}? \";\" ;\n  ```\n\n  Semantic restrictions (`ast_validation`) are added to forbid any parameters in `generics`, any bounds in `bounds`, and any predicates in `where_clause`, as well as the presence of a type expression (`= u8`).\n\n  (Work still remains to fuse this with free `type` aliases, but this can be done later.)\n\n- The grammar of constants and static items (free, associated, and extern) now permits the absence of an expression, and becomes:\n\n  ```rust\n  GlobalItem = {\"const\" {ident | \"_\"} | \"static\" \"mut\"? ident} {\"=\" expr}? \";\" ;\n  ```\n\n  - A semantic restriction is added to enforce the presence of the expression (the body).\n  - A semantic restriction is added to reject `const _` in associated contexts.\n\nTogether, these changes allow us to fuse the grammar of associated items and extern items up to `default`ness which is the main goal of the PR.\n\n-----------------------\n\nWe are now very close to fully fusing the entirely of item parsing and their ASTs. To progress further, we must make a decision: should we parse e.g. `default use foo::bar;` and whatnot? Accepting that is likely easiest from a parsing perspective, as it does not require using look-ahead, but it is perhaps not too onerous to only accept it for `fn`s (and all their various qualifiers), `const`s, `static`s, and `type`s.\n\nr? @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b864d23f3484aad297e998f3cd50a4277122d070", "html_url": "https://github.com/rust-lang/rust/commit/b864d23f3484aad297e998f3cd50a4277122d070", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b864d23f3484aad297e998f3cd50a4277122d070/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "981acd90353b40e9529de0eda21ba5b4071134d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/981acd90353b40e9529de0eda21ba5b4071134d5", "html_url": "https://github.com/rust-lang/rust/commit/981acd90353b40e9529de0eda21ba5b4071134d5"}, {"sha": "045b7d53a3fe94d2f6cb32d029a3f5d74e174ed9", "url": "https://api.github.com/repos/rust-lang/rust/commits/045b7d53a3fe94d2f6cb32d029a3f5d74e174ed9", "html_url": "https://github.com/rust-lang/rust/commit/045b7d53a3fe94d2f6cb32d029a3f5d74e174ed9"}], "stats": {"total": 2028, "additions": 1314, "deletions": 714}, "files": [{"sha": "e0db8606bc203148b37dcaa5d5814e729cfaf34e", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 53, "deletions": 49, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -269,26 +269,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self.lower_use_tree(use_tree, &prefix, id, vis, ident, attrs)\n             }\n             ItemKind::Static(ref t, m, ref e) => {\n-                let ty = self.lower_ty(\n-                    t,\n-                    if self.sess.features_untracked().impl_trait_in_bindings {\n-                        ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc)\n-                    } else {\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n-                    },\n-                );\n-                hir::ItemKind::Static(ty, m, self.lower_const_body(span, Some(e)))\n+                let (ty, body_id) = self.lower_const_item(t, span, e.as_deref());\n+                hir::ItemKind::Static(ty, m, body_id)\n             }\n             ItemKind::Const(ref t, ref e) => {\n-                let ty = self.lower_ty(\n-                    t,\n-                    if self.sess.features_untracked().impl_trait_in_bindings {\n-                        ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc)\n-                    } else {\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n-                    },\n-                );\n-                hir::ItemKind::Const(ty, self.lower_const_body(span, Some(e)))\n+                let (ty, body_id) = self.lower_const_item(t, span, e.as_deref());\n+                hir::ItemKind::Const(ty, body_id)\n             }\n             ItemKind::Fn(FnSig { ref decl, header }, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n@@ -457,6 +443,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         //     not cause an assertion failure inside the `lower_defaultness` function.\n     }\n \n+    fn lower_const_item(\n+        &mut self,\n+        ty: &Ty,\n+        span: Span,\n+        body: Option<&Expr>,\n+    ) -> (&'hir hir::Ty<'hir>, hir::BodyId) {\n+        let itctx = if self.sess.features_untracked().impl_trait_in_bindings {\n+            ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc)\n+        } else {\n+            ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n+        };\n+        let ty = self.lower_ty(ty, itctx);\n+        (ty, self.lower_const_body(span, body))\n+    }\n+\n     fn lower_use_tree(\n         &mut self,\n         tree: &UseTree,\n@@ -678,11 +679,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                     hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n                 }\n-                ForeignItemKind::Static(ref t, m) => {\n+                ForeignItemKind::Static(ref t, m, _) => {\n                     let ty = self.lower_ty(t, ImplTraitContext::disallowed());\n                     hir::ForeignItemKind::Static(ty, m)\n                 }\n-                ForeignItemKind::Ty => hir::ForeignItemKind::Type,\n+                ForeignItemKind::Const(ref t, _) => {\n+                    // For recovery purposes.\n+                    let ty = self.lower_ty(t, ImplTraitContext::disallowed());\n+                    hir::ForeignItemKind::Static(ty, Mutability::Not)\n+                }\n+                ForeignItemKind::TyAlias(..) => hir::ForeignItemKind::Type,\n                 ForeignItemKind::Macro(_) => panic!(\"macro shouldn't exist here\"),\n             },\n             vis: self.lower_visibility(&i.vis, None),\n@@ -759,32 +765,27 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let trait_item_def_id = self.resolver.definitions().local_def_id(i.id);\n \n         let (generics, kind) = match i.kind {\n-            AssocItemKind::Const(ref ty, ref default) => {\n-                let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n+            AssocItemKind::Static(ref ty, _, ref default) // Let's pretend this is a `const`.\n+            | AssocItemKind::Const(ref ty, ref default) => {\n                 let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                (\n-                    generics,\n-                    hir::TraitItemKind::Const(\n-                        ty,\n-                        default.as_ref().map(|x| self.lower_const_body(i.span, Some(x))),\n-                    ),\n-                )\n+                let body = default.as_ref().map(|x| self.lower_const_body(i.span, Some(x)));\n+                (hir::Generics::empty(), hir::TraitItemKind::Const(ty, body))\n             }\n-            AssocItemKind::Fn(ref sig, None) => {\n+            AssocItemKind::Fn(ref sig, ref generics, None) => {\n                 let names = self.lower_fn_params_to_names(&sig.decl);\n                 let (generics, sig) =\n-                    self.lower_method_sig(&i.generics, sig, trait_item_def_id, false, None);\n+                    self.lower_method_sig(generics, sig, trait_item_def_id, false, None);\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Required(names)))\n             }\n-            AssocItemKind::Fn(ref sig, Some(ref body)) => {\n+            AssocItemKind::Fn(ref sig, ref generics, Some(ref body)) => {\n                 let body_id = self.lower_fn_body_block(i.span, &sig.decl, Some(body));\n                 let (generics, sig) =\n-                    self.lower_method_sig(&i.generics, sig, trait_item_def_id, false, None);\n+                    self.lower_method_sig(generics, sig, trait_item_def_id, false, None);\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Provided(body_id)))\n             }\n-            AssocItemKind::TyAlias(ref bounds, ref default) => {\n+            AssocItemKind::TyAlias(ref generics, ref bounds, ref default) => {\n                 let ty = default.as_ref().map(|x| self.lower_ty(x, ImplTraitContext::disallowed()));\n-                let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n+                let generics = self.lower_generics(generics, ImplTraitContext::disallowed());\n                 let kind = hir::TraitItemKind::Type(\n                     self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n                     ty,\n@@ -806,10 +807,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_trait_item_ref(&mut self, i: &AssocItem) -> hir::TraitItemRef {\n-        let (kind, has_default) = match i.kind {\n-            AssocItemKind::Const(_, ref default) => (hir::AssocItemKind::Const, default.is_some()),\n-            AssocItemKind::TyAlias(_, ref default) => (hir::AssocItemKind::Type, default.is_some()),\n-            AssocItemKind::Fn(ref sig, ref default) => {\n+        let (kind, has_default) = match &i.kind {\n+            AssocItemKind::Static(_, _, default) // Let's pretend this is a `const` for recovery.\n+            | AssocItemKind::Const(_, default) => {\n+                (hir::AssocItemKind::Const, default.is_some())\n+            }\n+            AssocItemKind::TyAlias(_, _, default) => (hir::AssocItemKind::Type, default.is_some()),\n+            AssocItemKind::Fn(sig, _, default) => {\n                 (hir::AssocItemKind::Method { has_self: sig.decl.has_self() }, default.is_some())\n             }\n             AssocItemKind::Macro(..) => unimplemented!(),\n@@ -832,22 +836,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let impl_item_def_id = self.resolver.definitions().local_def_id(i.id);\n \n         let (generics, kind) = match i.kind {\n-            AssocItemKind::Const(ref ty, ref expr) => {\n-                let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n+            AssocItemKind::Static(ref ty, _, ref expr) | AssocItemKind::Const(ref ty, ref expr) => {\n                 let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n                 (\n-                    generics,\n+                    hir::Generics::empty(),\n                     hir::ImplItemKind::Const(ty, self.lower_const_body(i.span, expr.as_deref())),\n                 )\n             }\n-            AssocItemKind::Fn(ref sig, ref body) => {\n+            AssocItemKind::Fn(ref sig, ref generics, ref body) => {\n                 self.current_item = Some(i.span);\n                 let asyncness = sig.header.asyncness;\n                 let body_id =\n                     self.lower_maybe_async_body(i.span, &sig.decl, asyncness, body.as_deref());\n                 let impl_trait_return_allow = !self.is_in_trait_impl;\n                 let (generics, sig) = self.lower_method_sig(\n-                    &i.generics,\n+                    generics,\n                     sig,\n                     impl_item_def_id,\n                     impl_trait_return_allow,\n@@ -856,8 +859,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                 (generics, hir::ImplItemKind::Method(sig, body_id))\n             }\n-            AssocItemKind::TyAlias(_, ref ty) => {\n-                let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n+            AssocItemKind::TyAlias(ref generics, _, ref ty) => {\n+                let generics = self.lower_generics(generics, ImplTraitContext::disallowed());\n                 let kind = match ty {\n                     None => {\n                         let ty = self.arena.alloc(self.ty(i.span, hir::TyKind::Err));\n@@ -901,14 +904,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             vis: self.lower_visibility(&i.vis, Some(i.id)),\n             defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n             kind: match &i.kind {\n-                AssocItemKind::Const(..) => hir::AssocItemKind::Const,\n-                AssocItemKind::TyAlias(_, ty) => {\n+                AssocItemKind::Static(..) // Let's pretend this is a `const` for recovery.\n+                | AssocItemKind::Const(..) => hir::AssocItemKind::Const,\n+                AssocItemKind::TyAlias(_, _, ty) => {\n                     match ty.as_deref().and_then(|ty| ty.kind.opaque_top_hack()) {\n                         None => hir::AssocItemKind::Type,\n                         Some(_) => hir::AssocItemKind::OpaqueTy,\n                     }\n                 }\n-                AssocItemKind::Fn(sig, _) => {\n+                AssocItemKind::Fn(sig, _, _) => {\n                     hir::AssocItemKind::Method { has_self: sig.decl.has_self() }\n                 }\n                 AssocItemKind::Macro(..) => unimplemented!(),"}, {"sha": "ac4ca30382fee6746773bdfd4a2e8852788edcbf", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -490,7 +490,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 self.lctx.allocate_hir_id_counter(item.id);\n                 let owner = match (&item.kind, ctxt) {\n                     // Ignore patterns in trait methods without bodies.\n-                    (AssocItemKind::Fn(_, None), AssocCtxt::Trait) => None,\n+                    (AssocItemKind::Fn(_, _, None), AssocCtxt::Trait) => None,\n                     _ => Some(item.id),\n                 };\n                 self.with_hir_id_owner(owner, |this| visit::walk_assoc_item(this, item, ctxt));"}, {"sha": "1194269e0ee9638af9cda5276852d70d6f744f26", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 89, "deletions": 8, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -22,6 +22,9 @@ use syntax::expand::is_proc_macro_attr;\n use syntax::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use syntax::walk_list;\n \n+const MORE_EXTERN: &str =\n+    \"for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\";\n+\n /// Is `self` allowed semantically as the first parameter in an `FnDecl`?\n enum SelfSemantic {\n     Yes,\n@@ -423,14 +426,62 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn check_impl_assoc_type_no_bounds(&self, bounds: &[GenericBound]) {\n+    fn check_type_no_bounds(&self, bounds: &[GenericBound], ctx: &str) {\n         let span = match bounds {\n             [] => return,\n             [b0] => b0.span(),\n             [b0, .., bl] => b0.span().to(bl.span()),\n         };\n         self.err_handler()\n-            .struct_span_err(span, \"bounds on associated `type`s in `impl`s have no effect\")\n+            .struct_span_err(span, &format!(\"bounds on `type`s in {} have no effect\", ctx))\n+            .emit();\n+    }\n+\n+    fn check_foreign_ty_genericless(&self, generics: &Generics) {\n+        let cannot_have = |span, descr, remove_descr| {\n+            self.err_handler()\n+                .struct_span_err(\n+                    span,\n+                    &format!(\"`type`s inside `extern` blocks cannot have {}\", descr),\n+                )\n+                .span_suggestion(\n+                    span,\n+                    &format!(\"remove the {}\", remove_descr),\n+                    String::new(),\n+                    Applicability::MaybeIncorrect,\n+                )\n+                .span_label(self.current_extern_span(), \"`extern` block begins here\")\n+                .note(MORE_EXTERN)\n+                .emit();\n+        };\n+\n+        if !generics.params.is_empty() {\n+            cannot_have(generics.span, \"generic parameters\", \"generic parameters\");\n+        }\n+\n+        if !generics.where_clause.predicates.is_empty() {\n+            cannot_have(generics.where_clause.span, \"`where` clauses\", \"`where` clause\");\n+        }\n+    }\n+\n+    fn check_foreign_kind_bodyless(&self, ident: Ident, kind: &str, body: Option<Span>) {\n+        let body = match body {\n+            None => return,\n+            Some(body) => body,\n+        };\n+        self.err_handler()\n+            .struct_span_err(ident.span, &format!(\"incorrect `{}` inside `extern` block\", kind))\n+            .span_label(ident.span, \"cannot have a body\")\n+            .span_label(body, \"the invalid body\")\n+            .span_label(\n+                self.current_extern_span(),\n+                format!(\n+                    \"`extern` blocks define existing foreign {0}s and {0}s \\\n+                    inside of them cannot have a body\",\n+                    kind\n+                ),\n+            )\n+            .note(MORE_EXTERN)\n             .emit();\n     }\n \n@@ -458,7 +509,7 @@ impl<'a> AstValidator<'a> {\n                 \"`extern` blocks define existing foreign functions and functions \\\n                 inside of them cannot have a body\",\n             )\n-            .note(\"for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\")\n+            .note(MORE_EXTERN)\n             .emit();\n     }\n \n@@ -531,6 +582,16 @@ impl<'a> AstValidator<'a> {\n             }\n         }\n     }\n+\n+    fn check_item_named(&self, ident: Ident, kind: &str) {\n+        if ident.name != kw::Underscore {\n+            return;\n+        }\n+        self.err_handler()\n+            .struct_span_err(ident.span, &format!(\"`{}` items in this context need a name\", kind))\n+            .span_label(ident.span, format!(\"`_` is not a valid name for this `{}` item\", kind))\n+            .emit();\n+    }\n }\n \n enum GenericPosition {\n@@ -900,6 +961,14 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.err_handler().span_err(item.span, \"unions cannot have zero fields\");\n                 }\n             }\n+            ItemKind::Const(.., None) => {\n+                let msg = \"free constant item without body\";\n+                self.error_item_without_body(item.span, \"constant\", msg, \" = <expr>;\");\n+            }\n+            ItemKind::Static(.., None) => {\n+                let msg = \"free static item without body\";\n+                self.error_item_without_body(item.span, \"static\", msg, \" = <expr>;\");\n+            }\n             _ => {}\n         }\n \n@@ -912,7 +981,15 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.check_foreign_fn_bodyless(fi.ident, body.as_deref());\n                 self.check_foreign_fn_headerless(fi.ident, fi.span, sig.header);\n             }\n-            ForeignItemKind::Static(..) | ForeignItemKind::Ty | ForeignItemKind::Macro(..) => {}\n+            ForeignItemKind::TyAlias(generics, bounds, body) => {\n+                self.check_foreign_kind_bodyless(fi.ident, \"type\", body.as_ref().map(|b| b.span));\n+                self.check_type_no_bounds(bounds, \"`extern` blocks\");\n+                self.check_foreign_ty_genericless(generics);\n+            }\n+            ForeignItemKind::Static(_, _, body) => {\n+                self.check_foreign_kind_bodyless(fi.ident, \"static\", body.as_ref().map(|b| b.span));\n+            }\n+            ForeignItemKind::Const(..) | ForeignItemKind::Macro(..) => {}\n         }\n \n         visit::walk_foreign_item(self, fi)\n@@ -1154,25 +1231,29 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 AssocItemKind::Const(_, body) => {\n                     self.check_impl_item_provided(item.span, body, \"constant\", \" = <expr>;\");\n                 }\n-                AssocItemKind::Fn(_, body) => {\n+                AssocItemKind::Fn(_, _, body) => {\n                     self.check_impl_item_provided(item.span, body, \"function\", \" { <body> }\");\n                 }\n-                AssocItemKind::TyAlias(bounds, body) => {\n+                AssocItemKind::TyAlias(_, bounds, body) => {\n                     self.check_impl_item_provided(item.span, body, \"type\", \" = <type>;\");\n-                    self.check_impl_assoc_type_no_bounds(bounds);\n+                    self.check_type_no_bounds(bounds, \"`impl`s\");\n                 }\n                 _ => {}\n             }\n         }\n \n         if ctxt == AssocCtxt::Trait || self.in_trait_impl {\n             self.invalid_visibility(&item.vis, None);\n-            if let AssocItemKind::Fn(sig, _) = &item.kind {\n+            if let AssocItemKind::Fn(sig, _, _) = &item.kind {\n                 self.check_trait_fn_not_const(sig.header.constness);\n                 self.check_trait_fn_not_async(item.span, sig.header.asyncness);\n             }\n         }\n \n+        if let AssocItemKind::Const(..) = item.kind {\n+            self.check_item_named(item.ident, \"const\");\n+        }\n+\n         self.with_in_trait_impl(false, |this| visit::walk_assoc_item(this, item, ctxt));\n     }\n }"}, {"sha": "3c924847a7364c75c28e4c08397b52036e7e677a", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -397,10 +397,10 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     );\n                 }\n             }\n-            ast::ForeignItemKind::Ty => {\n+            ast::ForeignItemKind::TyAlias(..) => {\n                 gate_feature_post!(&self, extern_types, i.span, \"extern types are experimental\");\n             }\n-            ast::ForeignItemKind::Macro(..) => {}\n+            ast::ForeignItemKind::Macro(..) | ast::ForeignItemKind::Const(..) => {}\n         }\n \n         visit::walk_foreign_item(self, i)\n@@ -548,12 +548,12 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         }\n \n         match i.kind {\n-            ast::AssocItemKind::Fn(ref sig, _) => {\n+            ast::AssocItemKind::Fn(ref sig, _, _) => {\n                 if let (ast::Const::Yes(_), AssocCtxt::Trait) = (sig.header.constness, ctxt) {\n                     gate_feature_post!(&self, const_fn, i.span, \"const fn is unstable\");\n                 }\n             }\n-            ast::AssocItemKind::TyAlias(_, ref ty) => {\n+            ast::AssocItemKind::TyAlias(ref generics, _, ref ty) => {\n                 if let (Some(_), AssocCtxt::Trait) = (ty, ctxt) {\n                     gate_feature_post!(\n                         &self,\n@@ -565,7 +565,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 if let Some(ty) = ty {\n                     self.check_impl_trait(ty);\n                 }\n-                self.check_gat(&i.generics, i.span);\n+                self.check_gat(generics, i.span);\n             }\n             _ => {}\n         }"}, {"sha": "6e1567ce34eba7795caeab0a7266f4b36dccb128", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 52, "deletions": 83, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -912,7 +912,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod, attrs: &[ast::Attribute]) {\n+    crate fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod, attrs: &[Attribute]) {\n         self.print_inner_attributes(attrs);\n         for item in &nmod.items {\n             self.print_foreign_item(item);\n@@ -1016,59 +1016,73 @@ impl<'a> State<'a> {\n     }\n \n     crate fn print_foreign_item(&mut self, item: &ast::ForeignItem) {\n+        let ast::ForeignItem { id, span, ident, attrs, kind, vis, tokens: _ } = item;\n+        self.print_nested_item_kind(*id, *span, *ident, attrs, ast::Defaultness::Final, kind, vis);\n+    }\n+\n+    fn print_nested_item_kind(\n+        &mut self,\n+        id: ast::NodeId,\n+        span: Span,\n+        ident: ast::Ident,\n+        attrs: &[Attribute],\n+        defaultness: ast::Defaultness,\n+        kind: &ast::AssocItemKind,\n+        vis: &ast::Visibility,\n+    ) {\n+        self.ann.pre(self, AnnNode::SubItem(id));\n         self.hardbreak_if_not_bol();\n-        self.maybe_print_comment(item.span.lo());\n-        self.print_outer_attributes(&item.attrs);\n-        match item.kind {\n-            ast::ForeignItemKind::Fn(ref sig, ref gen, ref body) => {\n-                self.print_fn_full(sig, item.ident, gen, &item.vis, body.as_deref(), &item.attrs);\n+        self.maybe_print_comment(span.lo());\n+        self.print_outer_attributes(attrs);\n+        self.print_defaultness(defaultness);\n+        match kind {\n+            ast::ForeignItemKind::Fn(sig, gen, body) => {\n+                self.print_fn_full(sig, ident, gen, vis, body.as_deref(), attrs);\n             }\n-            ast::ForeignItemKind::Static(ref t, m) => {\n-                self.head(visibility_qualified(&item.vis, \"static\"));\n-                if m == ast::Mutability::Mut {\n-                    self.word_space(\"mut\");\n-                }\n-                self.print_ident(item.ident);\n-                self.word_space(\":\");\n-                self.print_type(t);\n-                self.s.word(\";\");\n-                self.end(); // end the head-ibox\n-                self.end(); // end the outer cbox\n+            ast::ForeignItemKind::Const(ty, body) => {\n+                self.print_item_const(ident, None, ty, body.as_deref(), vis);\n             }\n-            ast::ForeignItemKind::Ty => {\n-                self.head(visibility_qualified(&item.vis, \"type\"));\n-                self.print_ident(item.ident);\n-                self.s.word(\";\");\n-                self.end(); // end the head-ibox\n-                self.end(); // end the outer cbox\n+            ast::ForeignItemKind::Static(ty, mutbl, body) => {\n+                self.print_item_const(ident, Some(*mutbl), ty, body.as_deref(), vis);\n+            }\n+            ast::ForeignItemKind::TyAlias(generics, bounds, ty) => {\n+                self.print_associated_type(ident, generics, bounds, ty.as_deref());\n             }\n-            ast::ForeignItemKind::Macro(ref m) => {\n+            ast::ForeignItemKind::Macro(m) => {\n                 self.print_mac(m);\n                 if m.args.need_semicolon() {\n                     self.s.word(\";\");\n                 }\n             }\n         }\n+        self.ann.post(self, AnnNode::SubItem(id))\n     }\n \n-    fn print_associated_const(\n+    fn print_item_const(\n         &mut self,\n         ident: ast::Ident,\n+        mutbl: Option<ast::Mutability>,\n         ty: &ast::Ty,\n-        default: Option<&ast::Expr>,\n+        body: Option<&ast::Expr>,\n         vis: &ast::Visibility,\n     ) {\n-        self.s.word(visibility_qualified(vis, \"\"));\n-        self.word_space(\"const\");\n+        let leading = match mutbl {\n+            None => \"const\",\n+            Some(ast::Mutability::Not) => \"static\",\n+            Some(ast::Mutability::Mut) => \"static mut\",\n+        };\n+        self.head(visibility_qualified(vis, leading));\n         self.print_ident(ident);\n         self.word_space(\":\");\n         self.print_type(ty);\n-        if let Some(expr) = default {\n-            self.s.space();\n+        self.s.space();\n+        self.end(); // end the head-ibox\n+        if let Some(body) = body {\n             self.word_space(\"=\");\n-            self.print_expr(expr);\n+            self.print_expr(body);\n         }\n-        self.s.word(\";\")\n+        self.s.word(\";\");\n+        self.end(); // end the outer cbox\n     }\n \n     fn print_associated_type(\n@@ -1118,34 +1132,11 @@ impl<'a> State<'a> {\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n             }\n-            ast::ItemKind::Static(ref ty, m, ref expr) => {\n-                self.head(visibility_qualified(&item.vis, \"static\"));\n-                if m == ast::Mutability::Mut {\n-                    self.word_space(\"mut\");\n-                }\n-                self.print_ident(item.ident);\n-                self.word_space(\":\");\n-                self.print_type(ty);\n-                self.s.space();\n-                self.end(); // end the head-ibox\n-\n-                self.word_space(\"=\");\n-                self.print_expr(expr);\n-                self.s.word(\";\");\n-                self.end(); // end the outer cbox\n+            ast::ItemKind::Static(ref ty, mutbl, ref body) => {\n+                self.print_item_const(item.ident, Some(mutbl), ty, body.as_deref(), &item.vis);\n             }\n-            ast::ItemKind::Const(ref ty, ref expr) => {\n-                self.head(visibility_qualified(&item.vis, \"const\"));\n-                self.print_ident(item.ident);\n-                self.word_space(\":\");\n-                self.print_type(ty);\n-                self.s.space();\n-                self.end(); // end the head-ibox\n-\n-                self.word_space(\"=\");\n-                self.print_expr(expr);\n-                self.s.word(\";\");\n-                self.end(); // end the outer cbox\n+            ast::ItemKind::Const(ref ty, ref body) => {\n+                self.print_item_const(item.ident, None, ty, body.as_deref(), &item.vis);\n             }\n             ast::ItemKind::Fn(ref sig, ref gen, ref body) => {\n                 self.print_fn_full(sig, item.ident, gen, &item.vis, body.as_deref(), &item.attrs);\n@@ -1464,30 +1455,8 @@ impl<'a> State<'a> {\n     }\n \n     crate fn print_assoc_item(&mut self, item: &ast::AssocItem) {\n-        self.ann.pre(self, AnnNode::SubItem(item.id));\n-        self.hardbreak_if_not_bol();\n-        self.maybe_print_comment(item.span.lo());\n-        self.print_outer_attributes(&item.attrs);\n-        self.print_defaultness(item.defaultness);\n-        match &item.kind {\n-            ast::AssocItemKind::Const(ty, expr) => {\n-                self.print_associated_const(item.ident, ty, expr.as_deref(), &item.vis);\n-            }\n-            ast::AssocItemKind::Fn(sig, body) => {\n-                let body = body.as_deref();\n-                self.print_fn_full(sig, item.ident, &item.generics, &item.vis, body, &item.attrs);\n-            }\n-            ast::AssocItemKind::TyAlias(bounds, ty) => {\n-                self.print_associated_type(item.ident, &item.generics, bounds, ty.as_deref());\n-            }\n-            ast::AssocItemKind::Macro(mac) => {\n-                self.print_mac(mac);\n-                if mac.args.need_semicolon() {\n-                    self.s.word(\";\");\n-                }\n-            }\n-        }\n-        self.ann.post(self, AnnNode::SubItem(item.id))\n+        let ast::AssocItem { id, span, ident, attrs, defaultness, kind, vis, tokens: _ } = item;\n+        self.print_nested_item_kind(*id, *span, *ident, attrs, *defaultness, kind, vis);\n     }\n \n     crate fn print_stmt(&mut self, st: &ast::Stmt) {"}, {"sha": "294b7463916b89d9d18137dfe0ea7503d79816ea", "filename": "src/librustc_builtin_macros/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -544,8 +544,8 @@ impl<'a> TraitDef<'a> {\n                 vis: respan(self.span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n                 defaultness: ast::Defaultness::Final,\n                 attrs: Vec::new(),\n-                generics: Generics::default(),\n                 kind: ast::AssocItemKind::TyAlias(\n+                    Generics::default(),\n                     Vec::new(),\n                     Some(type_def.to_ty(cx, self.span, type_ident, generics)),\n                 ),\n@@ -973,12 +973,11 @@ impl<'a> MethodDef<'a> {\n         P(ast::AssocItem {\n             id: ast::DUMMY_NODE_ID,\n             attrs: self.attributes.clone(),\n-            generics: fn_generics,\n             span: trait_.span,\n             vis: respan(trait_lo_sp, ast::VisibilityKind::Inherited),\n             defaultness: ast::Defaultness::Final,\n             ident: method_ident,\n-            kind: ast::AssocItemKind::Fn(sig, Some(body_block)),\n+            kind: ast::AssocItemKind::Fn(sig, fn_generics, Some(body_block)),\n             tokens: None,\n         })\n     }"}, {"sha": "e15405e1f0dfc8955192d17133cc6d4b429d09a3", "filename": "src/librustc_builtin_macros/test.rs", "status": "modified", "additions": 76, "deletions": 72, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_builtin_macros%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_builtin_macros%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -186,81 +186,85 @@ pub fn expand_test_or_bench(\n         ast::ItemKind::Const(\n             cx.ty(sp, ast::TyKind::Path(None, test_path(\"TestDescAndFn\"))),\n             // test::TestDescAndFn {\n-            cx.expr_struct(\n-                sp,\n-                test_path(\"TestDescAndFn\"),\n-                vec![\n-                    // desc: test::TestDesc {\n-                    field(\n-                        \"desc\",\n-                        cx.expr_struct(\n-                            sp,\n-                            test_path(\"TestDesc\"),\n-                            vec![\n-                                // name: \"path::to::test\"\n-                                field(\n-                                    \"name\",\n-                                    cx.expr_call(\n-                                        sp,\n-                                        cx.expr_path(test_path(\"StaticTestName\")),\n-                                        vec![cx.expr_str(\n-                                            sp,\n-                                            Symbol::intern(&item_path(\n-                                                // skip the name of the root module\n-                                                &cx.current_expansion.module.mod_path[1..],\n-                                                &item.ident,\n-                                            )),\n-                                        )],\n-                                    ),\n-                                ),\n-                                // ignore: true | false\n-                                field(\"ignore\", cx.expr_bool(sp, should_ignore(&item))),\n-                                // allow_fail: true | false\n-                                field(\"allow_fail\", cx.expr_bool(sp, should_fail(&item))),\n-                                // should_panic: ...\n-                                field(\n-                                    \"should_panic\",\n-                                    match should_panic(cx, &item) {\n-                                        // test::ShouldPanic::No\n-                                        ShouldPanic::No => cx.expr_path(should_panic_path(\"No\")),\n-                                        // test::ShouldPanic::Yes\n-                                        ShouldPanic::Yes(None) => {\n-                                            cx.expr_path(should_panic_path(\"Yes\"))\n-                                        }\n-                                        // test::ShouldPanic::YesWithMessage(\"...\")\n-                                        ShouldPanic::Yes(Some(sym)) => cx.expr_call(\n+            Some(\n+                cx.expr_struct(\n+                    sp,\n+                    test_path(\"TestDescAndFn\"),\n+                    vec![\n+                        // desc: test::TestDesc {\n+                        field(\n+                            \"desc\",\n+                            cx.expr_struct(\n+                                sp,\n+                                test_path(\"TestDesc\"),\n+                                vec![\n+                                    // name: \"path::to::test\"\n+                                    field(\n+                                        \"name\",\n+                                        cx.expr_call(\n                                             sp,\n-                                            cx.expr_path(should_panic_path(\"YesWithMessage\")),\n-                                            vec![cx.expr_str(sp, sym)],\n+                                            cx.expr_path(test_path(\"StaticTestName\")),\n+                                            vec![cx.expr_str(\n+                                                sp,\n+                                                Symbol::intern(&item_path(\n+                                                    // skip the name of the root module\n+                                                    &cx.current_expansion.module.mod_path[1..],\n+                                                    &item.ident,\n+                                                )),\n+                                            )],\n                                         ),\n-                                    },\n-                                ),\n-                                // test_type: ...\n-                                field(\n-                                    \"test_type\",\n-                                    match test_type(cx) {\n-                                        // test::TestType::UnitTest\n-                                        TestType::UnitTest => {\n-                                            cx.expr_path(test_type_path(\"UnitTest\"))\n-                                        }\n-                                        // test::TestType::IntegrationTest\n-                                        TestType::IntegrationTest => {\n-                                            cx.expr_path(test_type_path(\"IntegrationTest\"))\n-                                        }\n-                                        // test::TestPath::Unknown\n-                                        TestType::Unknown => {\n-                                            cx.expr_path(test_type_path(\"Unknown\"))\n-                                        }\n-                                    },\n-                                ),\n-                                // },\n-                            ],\n+                                    ),\n+                                    // ignore: true | false\n+                                    field(\"ignore\", cx.expr_bool(sp, should_ignore(&item))),\n+                                    // allow_fail: true | false\n+                                    field(\"allow_fail\", cx.expr_bool(sp, should_fail(&item))),\n+                                    // should_panic: ...\n+                                    field(\n+                                        \"should_panic\",\n+                                        match should_panic(cx, &item) {\n+                                            // test::ShouldPanic::No\n+                                            ShouldPanic::No => {\n+                                                cx.expr_path(should_panic_path(\"No\"))\n+                                            }\n+                                            // test::ShouldPanic::Yes\n+                                            ShouldPanic::Yes(None) => {\n+                                                cx.expr_path(should_panic_path(\"Yes\"))\n+                                            }\n+                                            // test::ShouldPanic::YesWithMessage(\"...\")\n+                                            ShouldPanic::Yes(Some(sym)) => cx.expr_call(\n+                                                sp,\n+                                                cx.expr_path(should_panic_path(\"YesWithMessage\")),\n+                                                vec![cx.expr_str(sp, sym)],\n+                                            ),\n+                                        },\n+                                    ),\n+                                    // test_type: ...\n+                                    field(\n+                                        \"test_type\",\n+                                        match test_type(cx) {\n+                                            // test::TestType::UnitTest\n+                                            TestType::UnitTest => {\n+                                                cx.expr_path(test_type_path(\"UnitTest\"))\n+                                            }\n+                                            // test::TestType::IntegrationTest\n+                                            TestType::IntegrationTest => {\n+                                                cx.expr_path(test_type_path(\"IntegrationTest\"))\n+                                            }\n+                                            // test::TestPath::Unknown\n+                                            TestType::Unknown => {\n+                                                cx.expr_path(test_type_path(\"Unknown\"))\n+                                            }\n+                                        },\n+                                    ),\n+                                    // },\n+                                ],\n+                            ),\n                         ),\n-                    ),\n-                    // testfn: test::StaticTestFn(...) | test::StaticBenchFn(...)\n-                    field(\"testfn\", test_fn), // }\n-                ],\n-            ), // }\n+                        // testfn: test::StaticTestFn(...) | test::StaticBenchFn(...)\n+                        field(\"testfn\", test_fn), // }\n+                    ],\n+                ), // }\n+            ),\n         ),\n     );\n     test_const = test_const.map(|mut tc| {"}, {"sha": "8a53e1d1861aafcff3c19598bbdc75fceda786bd", "filename": "src/librustc_expand/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbuild.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -634,7 +634,7 @@ impl<'a> ExtCtxt<'a> {\n         mutbl: ast::Mutability,\n         expr: P<ast::Expr>,\n     ) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemKind::Static(ty, mutbl, expr))\n+        self.item(span, name, Vec::new(), ast::ItemKind::Static(ty, mutbl, Some(expr)))\n     }\n \n     pub fn item_const(\n@@ -644,7 +644,7 @@ impl<'a> ExtCtxt<'a> {\n         ty: P<ast::Ty>,\n         expr: P<ast::Expr>,\n     ) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemKind::Const(ty, expr))\n+        self.item(span, name, Vec::new(), ast::ItemKind::Const(ty, Some(expr)))\n     }\n \n     pub fn attribute(&self, mi: ast::MetaItem) -> ast::Attribute {"}, {"sha": "c96b394c7b5e2b959fd4d3453d312488678cb996", "filename": "src/librustc_expand/placeholders.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_expand%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_expand%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fplaceholders.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -25,7 +25,6 @@ pub fn placeholder(\n \n     let ident = ast::Ident::invalid();\n     let attrs = Vec::new();\n-    let generics = ast::Generics::default();\n     let vis = vis.unwrap_or_else(|| dummy_spanned(ast::VisibilityKind::Inherited));\n     let span = DUMMY_SP;\n     let expr_placeholder = || {\n@@ -57,7 +56,6 @@ pub fn placeholder(\n             ident,\n             vis,\n             attrs,\n-            generics,\n             kind: ast::AssocItemKind::Macro(mac_placeholder()),\n             defaultness: ast::Defaultness::Final,\n             tokens: None,\n@@ -68,7 +66,6 @@ pub fn placeholder(\n             ident,\n             vis,\n             attrs,\n-            generics,\n             kind: ast::AssocItemKind::Macro(mac_placeholder()),\n             defaultness: ast::Defaultness::Final,\n             tokens: None,"}, {"sha": "99e9878bfd8bb76e6bac2406d09f6c0e6ba94e68", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -686,7 +686,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a, '_> {\n     fn flat_map_trait_item(&mut self, i: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n         let is_const = match i.kind {\n             ast::AssocItemKind::Const(..) => true,\n-            ast::AssocItemKind::Fn(ref sig, _) => Self::is_sig_const(sig),\n+            ast::AssocItemKind::Fn(ref sig, _, _) => Self::is_sig_const(sig),\n             _ => false,\n         };\n         self.run(is_const, |s| noop_flat_map_assoc_item(i, s))"}, {"sha": "73c5f386e65d61063ff059e30de6ebce24609492", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -640,7 +640,7 @@ declare_lint_pass!(\n impl EarlyLintPass for AnonymousParameters {\n     fn check_trait_item(&mut self, cx: &EarlyContext<'_>, it: &ast::AssocItem) {\n         match it.kind {\n-            ast::AssocItemKind::Fn(ref sig, _) => {\n+            ast::AssocItemKind::Fn(ref sig, _, _) => {\n                 for arg in sig.decl.inputs.iter() {\n                     match arg.pat.kind {\n                         ast::PatKind::Ident(_, ident, None) => {"}, {"sha": "7870b9da4cb701a5da01f93c20dda500c0fa84ce", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -603,7 +603,7 @@ impl EarlyLintPass for UnusedParens {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n         use ast::ItemKind::*;\n \n-        if let Const(.., ref expr) | Static(.., ref expr) = item.kind {\n+        if let Const(.., Some(expr)) | Static(.., Some(expr)) = &item.kind {\n             self.check_unused_parens_expr(cx, expr, \"assigned value\", false, None, None);\n         }\n     }"}, {"sha": "c9f1978a80dc4c78928fd84be192625bfc0af643", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 91, "deletions": 117, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -13,7 +13,7 @@ use syntax::ast::{AssocItem, AssocItemKind, Item, ItemKind, UseTree, UseTreeKind\n use syntax::ast::{Async, Const, Defaultness, IsAuto, PathSegment, Unsafe};\n use syntax::ast::{BindingMode, Block, FnDecl, FnSig, Mac, MacArgs, MacDelimiter, Param, SelfKind};\n use syntax::ast::{EnumDef, Generics, StructField, TraitRef, Ty, TyKind, Variant, VariantData};\n-use syntax::ast::{FnHeader, ForeignItem, ForeignItemKind, Mutability, Visibility, VisibilityKind};\n+use syntax::ast::{FnHeader, ForeignItem, Mutability, Visibility, VisibilityKind};\n use syntax::ptr::P;\n use syntax::token;\n use syntax::tokenstream::{DelimSpan, TokenStream, TokenTree};\n@@ -333,29 +333,19 @@ impl<'a> Parser<'a> {\n         self.token.is_keyword(kw::Async) && self.is_keyword_ahead(1, &[kw::Fn])\n     }\n \n-    fn missing_assoc_item_kind_err(\n-        &self,\n-        item_type: &str,\n-        prev_span: Span,\n-    ) -> DiagnosticBuilder<'a> {\n-        let expected_kinds = if item_type == \"extern\" {\n-            \"missing `fn`, `type`, or `static`\"\n-        } else {\n-            \"missing `fn`, `type`, or `const`\"\n-        };\n-\n-        // Given this code `path(`, it seems like this is not\n-        // setting the visibility of a macro invocation, but rather\n-        // a mistyped method declaration.\n-        // Create a diagnostic pointing out that `fn` is missing.\n-        //\n-        // x |     pub path(&self) {\n-        //   |        ^ missing `fn`, `type`, or `const`\n-        //     pub  path(\n-        //        ^^ `sp` below will point to this\n+    /// Given this code `path(`, it seems like this is not\n+    /// setting the visibility of a macro invocation,\n+    /// but rather a mistyped method declaration.\n+    /// Create a diagnostic pointing out that `fn` is missing.\n+    ///\n+    /// ```\n+    /// x |     pub   path(&self) {\n+    ///   |         ^ missing `fn`, `type`, `const`, or `static`\n+    /// ```\n+    fn missing_nested_item_kind_err(&self, prev_span: Span) -> DiagnosticBuilder<'a> {\n         let sp = prev_span.between(self.token.span);\n-        let mut err = self\n-            .struct_span_err(sp, &format!(\"{} for {}-item declaration\", expected_kinds, item_type));\n+        let expected_kinds = \"missing `fn`, `type`, `const`, or `static`\";\n+        let mut err = self.struct_span_err(sp, &format!(\"{} for item declaration\", expected_kinds));\n         err.span_label(sp, expected_kinds);\n         err\n     }\n@@ -546,6 +536,7 @@ impl<'a> Parser<'a> {\n                 1,\n                 &[\n                     kw::Impl,\n+                    kw::Static,\n                     kw::Const,\n                     kw::Async,\n                     kw::Fn,\n@@ -638,7 +629,7 @@ impl<'a> Parser<'a> {\n     fn parse_assoc_item(\n         &mut self,\n         at_end: &mut bool,\n-        req_name: fn(&token::Token) -> bool,\n+        req_name: ReqName,\n     ) -> PResult<'a, P<AssocItem>> {\n         let attrs = self.parse_outer_attributes()?;\n         let mut unclosed_delims = vec![];\n@@ -652,59 +643,67 @@ impl<'a> Parser<'a> {\n         if !item.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n             item.tokens = Some(tokens);\n         }\n+        self.error_on_assoc_static(&item);\n         Ok(P(item))\n     }\n \n+    fn error_on_assoc_static(&self, item: &AssocItem) {\n+        if let AssocItemKind::Static(..) = item.kind {\n+            self.struct_span_err(item.span, \"associated `static` items are not allowed\").emit();\n+        }\n+    }\n+\n     fn parse_assoc_item_(\n         &mut self,\n         at_end: &mut bool,\n         mut attrs: Vec<Attribute>,\n-        req_name: fn(&token::Token) -> bool,\n+        req_name: ReqName,\n     ) -> PResult<'a, AssocItem> {\n         let lo = self.token.span;\n         let vis = self.parse_visibility(FollowedByType::No)?;\n         let defaultness = self.parse_defaultness();\n+        let (ident, kind) = self.parse_assoc_item_kind(at_end, &mut attrs, req_name, &vis)?;\n+        let span = lo.to(self.prev_span);\n+        let id = DUMMY_NODE_ID;\n+        Ok(AssocItem { id, span, ident, attrs, vis, defaultness, kind, tokens: None })\n+    }\n \n-        let (ident, kind, generics) = if self.eat_keyword(kw::Type) {\n-            self.parse_assoc_ty()?\n+    fn parse_assoc_item_kind(\n+        &mut self,\n+        at_end: &mut bool,\n+        attrs: &mut Vec<Attribute>,\n+        req_name: ReqName,\n+        vis: &Visibility,\n+    ) -> PResult<'a, (Ident, AssocItemKind)> {\n+        if self.eat_keyword(kw::Type) {\n+            self.parse_assoc_ty()\n         } else if self.check_fn_front_matter() {\n-            let (ident, sig, generics, body) = self.parse_fn(at_end, &mut attrs, req_name)?;\n-            (ident, AssocItemKind::Fn(sig, body), generics)\n-        } else if self.check_keyword(kw::Const) {\n-            self.parse_assoc_const()?\n+            let (ident, sig, generics, body) = self.parse_fn(at_end, attrs, req_name)?;\n+            Ok((ident, AssocItemKind::Fn(sig, generics, body)))\n+        } else if self.is_static_global() {\n+            self.bump(); // `static`\n+            let mutbl = self.parse_mutability();\n+            let (ident, ty, expr) = self.parse_item_const_common(Some(mutbl))?;\n+            Ok((ident, AssocItemKind::Static(ty, mutbl, expr)))\n+        } else if self.eat_keyword(kw::Const) {\n+            let (ident, ty, expr) = self.parse_item_const_common(None)?;\n+            Ok((ident, AssocItemKind::Const(ty, expr)))\n         } else if self.isnt_macro_invocation() {\n-            return Err(self.missing_assoc_item_kind_err(\"associated\", self.prev_span));\n+            Err(self.missing_nested_item_kind_err(self.prev_span))\n         } else if self.token.is_path_start() {\n             let mac = self.parse_item_macro(&vis)?;\n             *at_end = true;\n-            (Ident::invalid(), AssocItemKind::Macro(mac), Generics::default())\n+            Ok((Ident::invalid(), AssocItemKind::Macro(mac)))\n         } else {\n-            self.recover_attrs_no_item(&attrs)?;\n-            self.unexpected()?\n-        };\n-\n-        let span = lo.to(self.prev_span);\n-        let id = DUMMY_NODE_ID;\n-        Ok(AssocItem { id, span, ident, attrs, vis, defaultness, generics, kind, tokens: None })\n-    }\n-\n-    /// This parses the grammar:\n-    ///\n-    ///     AssocConst = \"const\" Ident \":\" Ty \"=\" Expr \";\"\n-    fn parse_assoc_const(&mut self) -> PResult<'a, (Ident, AssocItemKind, Generics)> {\n-        self.expect_keyword(kw::Const)?;\n-        let ident = self.parse_ident()?;\n-        self.expect(&token::Colon)?;\n-        let ty = self.parse_ty()?;\n-        let expr = if self.eat(&token::Eq) { Some(self.parse_expr()?) } else { None };\n-        self.expect_semi()?;\n-        Ok((ident, AssocItemKind::Const(ty, expr), Generics::default()))\n+            self.recover_attrs_no_item(attrs)?;\n+            self.unexpected()\n+        }\n     }\n \n     /// Parses the following grammar:\n     ///\n     ///     AssocTy = Ident [\"<\"...\">\"] [\":\" [GenericBounds]] [\"where\" ...] [\"=\" Ty]\n-    fn parse_assoc_ty(&mut self) -> PResult<'a, (Ident, AssocItemKind, Generics)> {\n+    fn parse_assoc_ty(&mut self) -> PResult<'a, (Ident, AssocItemKind)> {\n         let ident = self.parse_ident()?;\n         let mut generics = self.parse_generics()?;\n \n@@ -716,7 +715,7 @@ impl<'a> Parser<'a> {\n         let default = if self.eat(&token::Eq) { Some(self.parse_ty()?) } else { None };\n         self.expect_semi()?;\n \n-        Ok((ident, AssocItemKind::TyAlias(bounds, default), generics))\n+        Ok((ident, AssocItemKind::TyAlias(generics, bounds, default)))\n     }\n \n     /// Parses a `UseTree`.\n@@ -875,60 +874,26 @@ impl<'a> Parser<'a> {\n         let mut attrs = self.parse_outer_attributes()?;\n         let lo = self.token.span;\n         let vis = self.parse_visibility(FollowedByType::No)?;\n+        let (ident, kind) = self.parse_assoc_item_kind(at_end, &mut attrs, |_| true, &vis)?;\n+        let item = self.mk_item(lo, ident, kind, vis, attrs);\n+        self.error_on_foreign_const(&item);\n+        Ok(P(item))\n+    }\n \n-        let (ident, kind) = if self.check_keyword(kw::Type) {\n-            // FOREIGN TYPE ITEM\n-            self.parse_item_foreign_type()?\n-        } else if self.check_fn_front_matter() {\n-            // FOREIGN FUNCTION ITEM\n-            let (ident, sig, generics, body) = self.parse_fn(at_end, &mut attrs, |_| true)?;\n-            (ident, ForeignItemKind::Fn(sig, generics, body))\n-        } else if self.is_static_global() {\n-            // FOREIGN STATIC ITEM\n-            self.bump(); // `static`\n-            self.parse_item_foreign_static()?\n-        } else if self.token.is_keyword(kw::Const) {\n-            // Treat `const` as `static` for error recovery, but don't add it to expected tokens.\n-            self.bump(); // `const`\n-            self.struct_span_err(self.prev_span, \"extern items cannot be `const`\")\n+    fn error_on_foreign_const(&self, item: &ForeignItem) {\n+        if let AssocItemKind::Const(..) = item.kind {\n+            self.struct_span_err(item.ident.span, \"extern items cannot be `const`\")\n                 .span_suggestion(\n-                    self.prev_span,\n+                    item.span.with_hi(item.ident.span.lo()),\n                     \"try using a static value\",\n-                    \"static\".to_owned(),\n+                    \"static \".to_string(),\n                     Applicability::MachineApplicable,\n                 )\n+                .note(\n+                    \"for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\",\n+                )\n                 .emit();\n-            self.parse_item_foreign_static()?\n-        } else if self.isnt_macro_invocation() {\n-            return Err(self.missing_assoc_item_kind_err(\"extern\", self.prev_span));\n-        } else if self.token.is_path_start() {\n-            let mac = self.parse_item_macro(&vis)?;\n-            *at_end = true;\n-            (Ident::invalid(), ForeignItemKind::Macro(mac))\n-        } else {\n-            self.recover_attrs_no_item(&attrs)?;\n-            self.unexpected()?\n-        };\n-        Ok(P(self.mk_item(lo, ident, kind, vis, attrs)))\n-    }\n-\n-    /// Parses a static item from a foreign module.\n-    /// Assumes that the `static` keyword is already parsed.\n-    fn parse_item_foreign_static(&mut self) -> PResult<'a, (Ident, ForeignItemKind)> {\n-        let mutbl = self.parse_mutability();\n-        let ident = self.parse_ident()?;\n-        self.expect(&token::Colon)?;\n-        let ty = self.parse_ty()?;\n-        self.expect_semi()?;\n-        Ok((ident, ForeignItemKind::Static(ty, mutbl)))\n-    }\n-\n-    /// Parses a type from a foreign module.\n-    fn parse_item_foreign_type(&mut self) -> PResult<'a, (Ident, ForeignItemKind)> {\n-        self.expect_keyword(kw::Type)?;\n-        let ident = self.parse_ident()?;\n-        self.expect_semi()?;\n-        Ok((ident, ForeignItemKind::Ty))\n+        }\n     }\n \n     fn is_static_global(&mut self) -> bool {\n@@ -964,34 +929,43 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse `[\"const\" | (\"static\" \"mut\"?)] $ident \":\" $ty = $expr` with\n+    /// Parse `[\"const\" | (\"static\" \"mut\"?)] $ident \":\" $ty (= $expr)?` with\n     /// `[\"const\" | (\"static\" \"mut\"?)]` already parsed and stored in `m`.\n     ///\n     /// When `m` is `\"const\"`, `$ident` may also be `\"_\"`.\n     fn parse_item_const(&mut self, m: Option<Mutability>) -> PResult<'a, ItemInfo> {\n+        let (id, ty, expr) = self.parse_item_const_common(m)?;\n+        let item = match m {\n+            Some(m) => ItemKind::Static(ty, m, expr),\n+            None => ItemKind::Const(ty, expr),\n+        };\n+        Ok((id, item))\n+    }\n+\n+    /// Parse `[\"const\" | (\"static\" \"mut\"?)] $ident \":\" $ty (= $expr)?` with\n+    /// `[\"const\" | (\"static\" \"mut\"?)]` already parsed and stored in `m`.\n+    ///\n+    /// When `m` is `\"const\"`, `$ident` may also be `\"_\"`.\n+    fn parse_item_const_common(\n+        &mut self,\n+        m: Option<Mutability>,\n+    ) -> PResult<'a, (Ident, P<Ty>, Option<P<ast::Expr>>)> {\n         let id = if m.is_none() { self.parse_ident_or_underscore() } else { self.parse_ident() }?;\n \n         // Parse the type of a `const` or `static mut?` item.\n         // That is, the `\":\" $ty` fragment.\n-        let ty = if self.token == token::Eq {\n-            self.recover_missing_const_type(id, m)\n-        } else {\n-            // Not `=` so expect `\":\"\" $ty` as usual.\n-            self.expect(&token::Colon)?;\n+        let ty = if self.eat(&token::Colon) {\n             self.parse_ty()?\n+        } else {\n+            self.recover_missing_const_type(id, m)\n         };\n \n-        self.expect(&token::Eq)?;\n-        let e = self.parse_expr()?;\n+        let expr = if self.eat(&token::Eq) { Some(self.parse_expr()?) } else { None };\n         self.expect_semi()?;\n-        let item = match m {\n-            Some(m) => ItemKind::Static(ty, m, e),\n-            None => ItemKind::Const(ty, e),\n-        };\n-        Ok((id, item))\n+        Ok((id, ty, expr))\n     }\n \n-    /// We were supposed to parse `:` but instead, we're already at `=`.\n+    /// We were supposed to parse `:` but the `:` was missing.\n     /// This means that the type is missing.\n     fn recover_missing_const_type(&mut self, id: Ident, m: Option<Mutability>) -> P<Ty> {\n         // Construct the error and stash it away with the hope"}, {"sha": "1f622b80e8e2ec3c33fb13f6e4708fe114a5da0c", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -826,10 +826,10 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             ForeignItemKind::Fn(..) => {\n                 (Res::Def(DefKind::Fn, self.r.definitions.local_def_id(item.id)), ValueNS)\n             }\n-            ForeignItemKind::Static(..) => {\n+            ForeignItemKind::Static(..) | ForeignItemKind::Const(..) => {\n                 (Res::Def(DefKind::Static, self.r.definitions.local_def_id(item.id)), ValueNS)\n             }\n-            ForeignItemKind::Ty => {\n+            ForeignItemKind::TyAlias(..) => {\n                 (Res::Def(DefKind::ForeignTy, self.r.definitions.local_def_id(item.id)), TypeNS)\n             }\n             ForeignItemKind::Macro(_) => unreachable!(),\n@@ -1251,8 +1251,9 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         // Add the item to the trait info.\n         let item_def_id = self.r.definitions.local_def_id(item.id);\n         let (res, ns) = match item.kind {\n-            AssocItemKind::Const(..) => (Res::Def(DefKind::AssocConst, item_def_id), ValueNS),\n-            AssocItemKind::Fn(ref sig, _) => {\n+            AssocItemKind::Static(..) // Let's pretend it's a `const` for recovery.\n+            | AssocItemKind::Const(..) => (Res::Def(DefKind::AssocConst, item_def_id), ValueNS),\n+            AssocItemKind::Fn(ref sig, _, _) => {\n                 if sig.decl.has_self() {\n                     self.r.has_self.insert(item_def_id);\n                 }"}, {"sha": "60cba55512193f781c4ceefdc9e47986d894fc61", "filename": "src/librustc_resolve/def_collector.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_resolve%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_resolve%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdef_collector.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -215,18 +215,22 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_assoc_item(&mut self, i: &'a AssocItem, ctxt: visit::AssocCtxt) {\n         let def_data = match &i.kind {\n-            AssocItemKind::Fn(FnSig { header, decl }, body) if header.asyncness.is_async() => {\n+            AssocItemKind::Fn(FnSig { header, decl }, generics, body)\n+                if header.asyncness.is_async() =>\n+            {\n                 return self.visit_async_fn(\n                     i.id,\n                     i.ident.name,\n                     i.span,\n                     header,\n-                    &i.generics,\n+                    generics,\n                     decl,\n                     body.as_deref(),\n                 );\n             }\n-            AssocItemKind::Fn(..) | AssocItemKind::Const(..) => DefPathData::ValueNs(i.ident.name),\n+            AssocItemKind::Fn(..) | AssocItemKind::Const(..) | AssocItemKind::Static(..) => {\n+                DefPathData::ValueNs(i.ident.name)\n+            }\n             AssocItemKind::TyAlias(..) => DefPathData::TypeNs(i.ident.name),\n             AssocItemKind::Macro(..) => return self.visit_macro_invoc(i.id),\n         };"}, {"sha": "73601cd2ee711f1ad87a896a8e65a03806c6b880", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 98, "deletions": 96, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -437,17 +437,18 @@ impl<'a, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n     }\n     fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n         match foreign_item.kind {\n-            ForeignItemKind::Fn(_, ref generics, _) => {\n+            ForeignItemKind::Fn(_, ref generics, _)\n+            | ForeignItemKind::TyAlias(ref generics, ..) => {\n                 self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n                     visit::walk_foreign_item(this, foreign_item);\n                 });\n             }\n-            ForeignItemKind::Static(..) => {\n+            ForeignItemKind::Const(..) | ForeignItemKind::Static(..) => {\n                 self.with_item_rib(HasGenericParams::No, |this| {\n                     visit::walk_foreign_item(this, foreign_item);\n                 });\n             }\n-            ForeignItemKind::Ty | ForeignItemKind::Macro(..) => {\n+            ForeignItemKind::Macro(..) => {\n                 visit::walk_foreign_item(self, foreign_item);\n             }\n         }\n@@ -826,41 +827,34 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         this.visit_generics(generics);\n                         walk_list!(this, visit_param_bound, bounds);\n \n-                        for trait_item in trait_items {\n+                        let walk_assoc_item = |this: &mut Self, generics, item| {\n+                            this.with_generic_param_rib(generics, AssocItemRibKind, |this| {\n+                                visit::walk_assoc_item(this, item, AssocCtxt::Trait)\n+                            });\n+                        };\n+\n+                        for item in trait_items {\n                             this.with_trait_items(trait_items, |this| {\n-                                this.with_generic_param_rib(\n-                                    &trait_item.generics,\n-                                    AssocItemRibKind,\n-                                    |this| {\n-                                        match trait_item.kind {\n-                                            AssocItemKind::Const(ref ty, ref default) => {\n-                                                this.visit_ty(ty);\n-\n-                                                // Only impose the restrictions of\n-                                                // ConstRibKind for an actual constant\n-                                                // expression in a provided default.\n-                                                if let Some(ref expr) = *default {\n-                                                    this.with_constant_rib(|this| {\n-                                                        this.visit_expr(expr);\n-                                                    });\n-                                                }\n-                                            }\n-                                            AssocItemKind::Fn(_, _) => visit::walk_assoc_item(\n-                                                this,\n-                                                trait_item,\n-                                                AssocCtxt::Trait,\n-                                            ),\n-                                            AssocItemKind::TyAlias(..) => visit::walk_assoc_item(\n-                                                this,\n-                                                trait_item,\n-                                                AssocCtxt::Trait,\n-                                            ),\n-                                            AssocItemKind::Macro(_) => {\n-                                                panic!(\"unexpanded macro in resolve!\")\n-                                            }\n-                                        };\n-                                    },\n-                                );\n+                                match &item.kind {\n+                                    AssocItemKind::Static(ty, _, default)\n+                                    | AssocItemKind::Const(ty, default) => {\n+                                        this.visit_ty(ty);\n+                                        // Only impose the restrictions of `ConstRibKind` for an\n+                                        // actual constant expression in a provided default.\n+                                        if let Some(expr) = default {\n+                                            this.with_constant_rib(|this| this.visit_expr(expr));\n+                                        }\n+                                    }\n+                                    AssocItemKind::Fn(_, generics, _) => {\n+                                        walk_assoc_item(this, generics, item);\n+                                    }\n+                                    AssocItemKind::TyAlias(generics, _, _) => {\n+                                        walk_assoc_item(this, generics, item);\n+                                    }\n+                                    AssocItemKind::Macro(_) => {\n+                                        panic!(\"unexpanded macro in resolve!\")\n+                                    }\n+                                };\n                             });\n                         }\n                     });\n@@ -888,9 +882,9 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 debug!(\"resolve_item ItemKind::Const\");\n                 self.with_item_rib(HasGenericParams::No, |this| {\n                     this.visit_ty(ty);\n-                    this.with_constant_rib(|this| {\n-                        this.visit_expr(expr);\n-                    });\n+                    if let Some(expr) = expr {\n+                        this.with_constant_rib(|this| this.visit_expr(expr));\n+                    }\n                 });\n             }\n \n@@ -1021,7 +1015,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             trait_items\n                 .iter()\n                 .filter_map(|item| match &item.kind {\n-                    AssocItemKind::TyAlias(bounds, _) if bounds.len() == 0 => Some(item.ident),\n+                    AssocItemKind::TyAlias(_, bounds, _) if bounds.len() == 0 => Some(item.ident),\n                     _ => None,\n                 })\n                 .collect(),\n@@ -1113,66 +1107,74 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         this.with_current_self_type(self_type, |this| {\n                             this.with_self_rib_ns(ValueNS, Res::SelfCtor(item_def_id), |this| {\n                                 debug!(\"resolve_implementation with_self_rib_ns(ValueNS, ...)\");\n-                                for impl_item in impl_items {\n-                                    // We also need a new scope for the impl item type parameters.\n-                                    this.with_generic_param_rib(&impl_item.generics,\n-                                                                AssocItemRibKind,\n-                                                                |this| {\n-                                        use crate::ResolutionError::*;\n-                                        match impl_item.kind {\n-                                            AssocItemKind::Const(..) => {\n-                                                debug!(\n-                                                    \"resolve_implementation AssocItemKind::Const\",\n-                                                );\n-                                                // If this is a trait impl, ensure the const\n-                                                // exists in trait\n-                                                this.check_trait_item(\n-                                                    impl_item.ident,\n-                                                    ValueNS,\n-                                                    impl_item.span,\n-                                                    |n, s| ConstNotMemberOfTrait(n, s),\n-                                                );\n-\n-                                                this.with_constant_rib(|this| {\n+                                for item in impl_items {\n+                                    use crate::ResolutionError::*;\n+                                    match &item.kind {\n+                                        AssocItemKind::Static(..) | AssocItemKind::Const(..) => {\n+                                            debug!(\"resolve_implementation AssocItemKind::Const\",);\n+                                            // If this is a trait impl, ensure the const\n+                                            // exists in trait\n+                                            this.check_trait_item(\n+                                                item.ident,\n+                                                ValueNS,\n+                                                item.span,\n+                                                |n, s| ConstNotMemberOfTrait(n, s),\n+                                            );\n+\n+                                            this.with_constant_rib(|this| {\n+                                                visit::walk_assoc_item(this, item, AssocCtxt::Impl)\n+                                            });\n+                                        }\n+                                        AssocItemKind::Fn(_, generics, _) => {\n+                                            // We also need a new scope for the impl item type parameters.\n+                                            this.with_generic_param_rib(\n+                                                generics,\n+                                                AssocItemRibKind,\n+                                                |this| {\n+                                                    // If this is a trait impl, ensure the method\n+                                                    // exists in trait\n+                                                    this.check_trait_item(\n+                                                        item.ident,\n+                                                        ValueNS,\n+                                                        item.span,\n+                                                        |n, s| MethodNotMemberOfTrait(n, s),\n+                                                    );\n+\n+                                                    visit::walk_assoc_item(\n+                                                        this,\n+                                                        item,\n+                                                        AssocCtxt::Impl,\n+                                                    )\n+                                                },\n+                                            );\n+                                        }\n+                                        AssocItemKind::TyAlias(generics, _, _) => {\n+                                            // We also need a new scope for the impl item type parameters.\n+                                            this.with_generic_param_rib(\n+                                                generics,\n+                                                AssocItemRibKind,\n+                                                |this| {\n+                                                    // If this is a trait impl, ensure the type\n+                                                    // exists in trait\n+                                                    this.check_trait_item(\n+                                                        item.ident,\n+                                                        TypeNS,\n+                                                        item.span,\n+                                                        |n, s| TypeNotMemberOfTrait(n, s),\n+                                                    );\n+\n                                                     visit::walk_assoc_item(\n                                                         this,\n-                                                        impl_item,\n+                                                        item,\n                                                         AssocCtxt::Impl,\n                                                     )\n-                                                });\n-                                            }\n-                                            AssocItemKind::Fn(..) => {\n-                                                // If this is a trait impl, ensure the method\n-                                                // exists in trait\n-                                                this.check_trait_item(impl_item.ident,\n-                                                                      ValueNS,\n-                                                                      impl_item.span,\n-                                                    |n, s| MethodNotMemberOfTrait(n, s));\n-\n-                                                visit::walk_assoc_item(\n-                                                    this,\n-                                                    impl_item,\n-                                                    AssocCtxt::Impl,\n-                                                )\n-                                            }\n-                                            AssocItemKind::TyAlias(_, _) => {\n-                                                // If this is a trait impl, ensure the type\n-                                                // exists in trait\n-                                                this.check_trait_item(impl_item.ident,\n-                                                                      TypeNS,\n-                                                                      impl_item.span,\n-                                                    |n, s| TypeNotMemberOfTrait(n, s));\n-\n-                                                visit::walk_assoc_item(\n-                                                    this,\n-                                                    impl_item,\n-                                                    AssocCtxt::Impl,\n-                                                )\n-                                            }\n-                                            AssocItemKind::Macro(_) =>\n-                                                panic!(\"unexpanded macro in resolve!\"),\n+                                                },\n+                                            );\n+                                        }\n+                                        AssocItemKind::Macro(_) => {\n+                                            panic!(\"unexpanded macro in resolve!\")\n                                         }\n-                                    });\n+                                    }\n                                 }\n                             });\n                         });"}, {"sha": "db7733e72416ad56ea1ba9e05f704f82281fcb92", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -400,7 +400,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         &mut self,\n         item: &'l ast::Item,\n         typ: &'l ast::Ty,\n-        expr: &'l ast::Expr,\n+        expr: Option<&'l ast::Expr>,\n     ) {\n         let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n         self.nest_tables(item.id, |v| {\n@@ -409,7 +409,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                 v.dumper.dump_def(&access_from!(v.save_ctxt, item, hir_id), var_data);\n             }\n             v.visit_ty(&typ);\n-            v.visit_expr(expr);\n+            walk_list!(v, visit_expr, expr);\n         });\n     }\n \n@@ -1004,7 +1004,8 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         self.process_macro_use(trait_item.span);\n         let vis_span = trait_item.span.shrink_to_lo();\n         match trait_item.kind {\n-            ast::AssocItemKind::Const(ref ty, ref expr) => {\n+            ast::AssocItemKind::Static(ref ty, _, ref expr)\n+            | ast::AssocItemKind::Const(ref ty, ref expr) => {\n                 self.process_assoc_const(\n                     trait_item.id,\n                     trait_item.ident,\n@@ -1015,18 +1016,18 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     &trait_item.attrs,\n                 );\n             }\n-            ast::AssocItemKind::Fn(ref sig, ref body) => {\n+            ast::AssocItemKind::Fn(ref sig, ref generics, ref body) => {\n                 self.process_method(\n                     sig,\n                     body.as_ref().map(|x| &**x),\n                     trait_item.id,\n                     trait_item.ident,\n-                    &trait_item.generics,\n+                    generics,\n                     respan(vis_span, ast::VisibilityKind::Public),\n                     trait_item.span,\n                 );\n             }\n-            ast::AssocItemKind::TyAlias(ref bounds, ref default_ty) => {\n+            ast::AssocItemKind::TyAlias(_, ref bounds, ref default_ty) => {\n                 // FIXME do something with _bounds (for type refs)\n                 let name = trait_item.ident.name.to_string();\n                 let qualname = format!(\n@@ -1074,7 +1075,8 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     fn process_impl_item(&mut self, impl_item: &'l ast::AssocItem, impl_id: DefId) {\n         self.process_macro_use(impl_item.span);\n         match impl_item.kind {\n-            ast::AssocItemKind::Const(ref ty, ref expr) => {\n+            ast::AssocItemKind::Static(ref ty, _, ref expr)\n+            | ast::AssocItemKind::Const(ref ty, ref expr) => {\n                 self.process_assoc_const(\n                     impl_item.id,\n                     impl_item.ident,\n@@ -1085,19 +1087,19 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     &impl_item.attrs,\n                 );\n             }\n-            ast::AssocItemKind::Fn(ref sig, ref body) => {\n+            ast::AssocItemKind::Fn(ref sig, ref generics, ref body) => {\n                 self.process_method(\n                     sig,\n                     body.as_deref(),\n                     impl_item.id,\n                     impl_item.ident,\n-                    &impl_item.generics,\n+                    generics,\n                     impl_item.vis.clone(),\n                     impl_item.span,\n                 );\n             }\n-            ast::AssocItemKind::TyAlias(_, None) => {}\n-            ast::AssocItemKind::TyAlias(_, Some(ref ty)) => {\n+            ast::AssocItemKind::TyAlias(_, _, None) => {}\n+            ast::AssocItemKind::TyAlias(_, _, Some(ref ty)) => {\n                 // FIXME: uses of the assoc type should ideally point to this\n                 // 'def' and the name here should be a ref to the def in the\n                 // trait.\n@@ -1293,8 +1295,8 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n             Fn(ref sig, ref ty_params, ref body) => {\n                 self.process_fn(item, &sig.decl, &sig.header, ty_params, body.as_deref())\n             }\n-            Static(ref typ, _, ref expr) => self.process_static_or_const_item(item, typ, expr),\n-            Const(ref typ, ref expr) => self.process_static_or_const_item(item, &typ, &expr),\n+            Static(ref typ, _, ref e) => self.process_static_or_const_item(item, typ, e.as_deref()),\n+            Const(ref typ, ref e) => self.process_static_or_const_item(item, typ, e.as_deref()),\n             Struct(ref def, ref ty_params) | Union(ref def, ref ty_params) => {\n                 self.process_struct(item, def, ty_params)\n             }\n@@ -1532,15 +1534,15 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                     self.visit_ty(&ret_ty);\n                 }\n             }\n-            ast::ForeignItemKind::Static(ref ty, _) => {\n+            ast::ForeignItemKind::Const(ref ty, _) | ast::ForeignItemKind::Static(ref ty, _, _) => {\n                 if let Some(var_data) = self.save_ctxt.get_extern_item_data(item) {\n                     down_cast_data!(var_data, DefData, item.span);\n                     self.dumper.dump_def(&access, var_data);\n                 }\n \n                 self.visit_ty(ty);\n             }\n-            ast::ForeignItemKind::Ty => {\n+            ast::ForeignItemKind::TyAlias(..) => {\n                 if let Some(var_data) = self.save_ctxt.get_extern_item_data(item) {\n                     down_cast_data!(var_data, DefData, item.span);\n                     self.dumper.dump_def(&access, var_data);"}, {"sha": "6a34e47130f18258c64b02b3b996cd52d28140b1", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -151,7 +151,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     attributes: lower_attributes(item.attrs.clone(), self),\n                 }))\n             }\n-            ast::ForeignItemKind::Static(ref ty, _) => {\n+            ast::ForeignItemKind::Const(ref ty, _) | ast::ForeignItemKind::Static(ref ty, _, _) => {\n                 filter!(self.span_utils, item.ident.span);\n \n                 let id = id_from_node_id(item.id, self);\n@@ -173,7 +173,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 }))\n             }\n             // FIXME(plietar): needs a new DefKind in rls-data\n-            ast::ForeignItemKind::Ty => None,\n+            ast::ForeignItemKind::TyAlias(..) => None,\n             ast::ForeignItemKind::Macro(..) => None,\n         }\n     }"}, {"sha": "a2c61db4b7c0b61cd72a30b5df42d03d8dbfdd54", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -334,10 +334,13 @@ impl Sig for ast::Item {\n \n                 let ty = ty.make(offset + text.len(), id, scx)?;\n                 text.push_str(&ty.text);\n-                text.push_str(\" = \");\n \n-                let expr = pprust::expr_to_string(expr).replace('\\n', \" \");\n-                text.push_str(&expr);\n+                if let Some(expr) = expr {\n+                    text.push_str(\" = \");\n+                    let expr = pprust::expr_to_string(expr).replace('\\n', \" \");\n+                    text.push_str(&expr);\n+                }\n+\n                 text.push(';');\n \n                 Ok(extend_sig(ty, text, defs, vec![]))\n@@ -355,10 +358,13 @@ impl Sig for ast::Item {\n \n                 let ty = ty.make(offset + text.len(), id, scx)?;\n                 text.push_str(&ty.text);\n-                text.push_str(\" = \");\n \n-                let expr = pprust::expr_to_string(expr).replace('\\n', \" \");\n-                text.push_str(&expr);\n+                if let Some(expr) = expr {\n+                    text.push_str(\" = \");\n+                    let expr = pprust::expr_to_string(expr).replace('\\n', \" \");\n+                    text.push_str(&expr);\n+                }\n+\n                 text.push(';');\n \n                 Ok(extend_sig(ty, text, defs, vec![]))\n@@ -754,7 +760,7 @@ impl Sig for ast::ForeignItem {\n \n                 Ok(sig)\n             }\n-            ast::ForeignItemKind::Static(ref ty, m) => {\n+            ast::ForeignItemKind::Static(ref ty, m, _) => {\n                 let mut text = \"static \".to_owned();\n                 if m == ast::Mutability::Mut {\n                     text.push_str(\"mut \");\n@@ -773,7 +779,7 @@ impl Sig for ast::ForeignItem {\n \n                 Ok(extend_sig(ty_sig, text, defs, vec![]))\n             }\n-            ast::ForeignItemKind::Ty => {\n+            ast::ForeignItemKind::TyAlias(..) => {\n                 let mut text = \"type \".to_owned();\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n@@ -786,6 +792,7 @@ impl Sig for ast::ForeignItem {\n \n                 Ok(Signature { text: text, defs: defs, refs: vec![] })\n             }\n+            ast::ForeignItemKind::Const(..) => Err(\"foreign const\"),\n             ast::ForeignItemKind::Macro(..) => Err(\"macro\"),\n         }\n     }"}, {"sha": "9ae3010a0f6561e59b3891442d358c77ca0c2bca", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 39, "deletions": 62, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -1612,46 +1612,6 @@ pub struct FnSig {\n     pub decl: P<FnDecl>,\n }\n \n-/// Represents associated items.\n-/// These include items in `impl` and `trait` definitions.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct AssocItem {\n-    pub attrs: Vec<Attribute>,\n-    pub id: NodeId,\n-    pub span: Span,\n-    pub vis: Visibility,\n-    pub ident: Ident,\n-\n-    pub defaultness: Defaultness,\n-    pub generics: Generics,\n-    pub kind: AssocItemKind,\n-    /// See `Item::tokens` for what this is.\n-    pub tokens: Option<TokenStream>,\n-}\n-\n-/// Represents various kinds of content within an `impl`.\n-///\n-/// The term \"provided\" in the variants below refers to the item having a default\n-/// definition / body. Meanwhile, a \"required\" item lacks a definition / body.\n-/// In an implementation, all items must be provided.\n-/// The `Option`s below denote the bodies, where `Some(_)`\n-/// means \"provided\" and conversely `None` means \"required\".\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum AssocItemKind {\n-    /// An associated constant, `const $ident: $ty $def?;` where `def ::= \"=\" $expr? ;`.\n-    /// If `def` is parsed, then the associated constant is provided, and otherwise required.\n-    Const(P<Ty>, Option<P<Expr>>),\n-\n-    /// An associated function.\n-    Fn(FnSig, Option<P<Block>>),\n-\n-    /// An associated type.\n-    TyAlias(GenericBounds, Option<P<Ty>>),\n-\n-    /// A macro expanding to an associated item.\n-    Macro(Mac),\n-}\n-\n #[derive(\n     Clone,\n     Copy,\n@@ -2542,11 +2502,11 @@ pub enum ItemKind {\n     /// A static item (`static`).\n     ///\n     /// E.g., `static FOO: i32 = 42;` or `static FOO: &'static str = \"bar\";`.\n-    Static(P<Ty>, Mutability, P<Expr>),\n+    Static(P<Ty>, Mutability, Option<P<Expr>>),\n     /// A constant item (`const`).\n     ///\n     /// E.g., `const FOO: i32 = 42;`.\n-    Const(P<Ty>, P<Expr>),\n+    Const(P<Ty>, Option<P<Expr>>),\n     /// A function declaration (`fn`).\n     ///\n     /// E.g., `fn foo(bar: usize) -> usize { .. }`.\n@@ -2646,28 +2606,45 @@ impl ItemKind {\n     }\n }\n \n-pub type ForeignItem = Item<ForeignItemKind>;\n+// FIXME(Centril): These definitions should be unmerged;\n+// see https://github.com/rust-lang/rust/pull/69194#discussion_r379899975\n+pub type ForeignItem = Item<AssocItemKind>;\n+pub type ForeignItemKind = AssocItemKind;\n \n-/// An item within an `extern` block.\n+/// Represents associated items.\n+/// These include items in `impl` and `trait` definitions.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum ForeignItemKind {\n-    /// A foreign function.\n-    Fn(FnSig, Generics, Option<P<Block>>),\n-    /// A foreign static item (`static ext: u8`).\n-    Static(P<Ty>, Mutability),\n-    /// A foreign type.\n-    Ty,\n-    /// A macro invocation.\n-    Macro(Mac),\n+pub struct AssocItem {\n+    pub attrs: Vec<Attribute>,\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub vis: Visibility,\n+    pub ident: Ident,\n+\n+    pub defaultness: Defaultness,\n+    pub kind: AssocItemKind,\n+    /// See `Item::tokens` for what this is.\n+    pub tokens: Option<TokenStream>,\n }\n \n-impl ForeignItemKind {\n-    pub fn descriptive_variant(&self) -> &str {\n-        match *self {\n-            ForeignItemKind::Fn(..) => \"foreign function\",\n-            ForeignItemKind::Static(..) => \"foreign static item\",\n-            ForeignItemKind::Ty => \"foreign type\",\n-            ForeignItemKind::Macro(..) => \"macro in foreign module\",\n-        }\n-    }\n+/// Represents non-free item kinds.\n+///\n+/// The term \"provided\" in the variants below refers to the item having a default\n+/// definition / body. Meanwhile, a \"required\" item lacks a definition / body.\n+/// In an implementation, all items must be provided.\n+/// The `Option`s below denote the bodies, where `Some(_)`\n+/// means \"provided\" and conversely `None` means \"required\".\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub enum AssocItemKind {\n+    /// A constant, `const $ident: $ty $def?;` where `def ::= \"=\" $expr? ;`.\n+    /// If `def` is parsed, then the constant is provided, and otherwise required.\n+    Const(P<Ty>, Option<P<Expr>>),\n+    /// A static item (`static FOO: u8`).\n+    Static(P<Ty>, Mutability, Option<P<Expr>>),\n+    /// A function.\n+    Fn(FnSig, Generics, Option<P<Block>>),\n+    /// A type.\n+    TyAlias(Generics, GenericBounds, Option<P<Ty>>),\n+    /// A macro expanding to items.\n+    Macro(Mac),\n }"}, {"sha": "92f20b719f80e4d4b0492c3e106d6cec1d8b2c6a", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -890,13 +890,9 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n     match kind {\n         ItemKind::ExternCrate(_orig_name) => {}\n         ItemKind::Use(use_tree) => vis.visit_use_tree(use_tree),\n-        ItemKind::Static(ty, _mut, expr) => {\n+        ItemKind::Static(ty, _, expr) | ItemKind::Const(ty, expr) => {\n             vis.visit_ty(ty);\n-            vis.visit_expr(expr);\n-        }\n-        ItemKind::Const(ty, expr) => {\n-            vis.visit_ty(ty);\n-            vis.visit_expr(expr);\n+            visit_opt(expr, |expr| vis.visit_expr(expr));\n         }\n         ItemKind::Fn(sig, generics, body) => {\n             visit_fn_sig(sig, vis);\n@@ -951,31 +947,43 @@ pub fn noop_flat_map_assoc_item<T: MutVisitor>(\n     mut item: P<AssocItem>,\n     visitor: &mut T,\n ) -> SmallVec<[P<AssocItem>; 1]> {\n-    let AssocItem { id, ident, vis, defaultness: _, attrs, generics, kind, span, tokens: _ } =\n+    let AssocItem { id, ident, vis, defaultness: _, attrs, kind, span, tokens: _ } =\n         item.deref_mut();\n+    walk_nested_item(visitor, id, span, ident, vis, attrs, kind);\n+    smallvec![item]\n+}\n+\n+pub fn walk_nested_item(\n+    visitor: &mut impl MutVisitor,\n+    id: &mut NodeId,\n+    span: &mut Span,\n+    ident: &mut Ident,\n+    vis: &mut Visibility,\n+    attrs: &mut Vec<Attribute>,\n+    kind: &mut AssocItemKind,\n+) {\n     visitor.visit_id(id);\n     visitor.visit_ident(ident);\n     visitor.visit_vis(vis);\n     visit_attrs(attrs, visitor);\n-    visitor.visit_generics(generics);\n     match kind {\n-        AssocItemKind::Const(ty, expr) => {\n+        AssocItemKind::Const(ty, expr) | AssocItemKind::Static(ty, _, expr) => {\n             visitor.visit_ty(ty);\n             visit_opt(expr, |expr| visitor.visit_expr(expr));\n         }\n-        AssocItemKind::Fn(sig, body) => {\n+        AssocItemKind::Fn(sig, generics, body) => {\n+            visitor.visit_generics(generics);\n             visit_fn_sig(sig, visitor);\n             visit_opt(body, |body| visitor.visit_block(body));\n         }\n-        AssocItemKind::TyAlias(bounds, ty) => {\n+        AssocItemKind::TyAlias(generics, bounds, ty) => {\n+            visitor.visit_generics(generics);\n             visit_bounds(bounds, visitor);\n             visit_opt(ty, |ty| visitor.visit_ty(ty));\n         }\n         AssocItemKind::Macro(mac) => visitor.visit_mac(mac),\n     }\n     visitor.visit_span(span);\n-\n-    smallvec![item]\n }\n \n pub fn noop_visit_fn_header<T: MutVisitor>(header: &mut FnHeader, vis: &mut T) {\n@@ -1041,22 +1049,7 @@ pub fn noop_flat_map_foreign_item<T: MutVisitor>(\n     visitor: &mut T,\n ) -> SmallVec<[P<ForeignItem>; 1]> {\n     let ForeignItem { ident, attrs, id, kind, vis, span, tokens: _ } = item.deref_mut();\n-    visitor.visit_ident(ident);\n-    visit_attrs(attrs, visitor);\n-    match kind {\n-        ForeignItemKind::Fn(sig, generics, body) => {\n-            visit_fn_sig(sig, visitor);\n-            visitor.visit_generics(generics);\n-            visit_opt(body, |body| visitor.visit_block(body));\n-        }\n-        ForeignItemKind::Static(t, _m) => visitor.visit_ty(t),\n-        ForeignItemKind::Ty => {}\n-        ForeignItemKind::Macro(mac) => visitor.visit_mac(mac),\n-    }\n-    visitor.visit_id(id);\n-    visitor.visit_span(span);\n-    visitor.visit_vis(vis);\n-\n+    walk_nested_item(visitor, id, span, ident, vis, attrs, kind);\n     smallvec![item]\n }\n "}, {"sha": "dedd42fe0f6875a9b88df8a458b723e4285ed0ff", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -300,7 +300,7 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n         ItemKind::Use(ref use_tree) => visitor.visit_use_tree(use_tree, item.id, false),\n         ItemKind::Static(ref typ, _, ref expr) | ItemKind::Const(ref typ, ref expr) => {\n             visitor.visit_ty(typ);\n-            visitor.visit_expr(expr);\n+            walk_list!(visitor, visit_expr, expr);\n         }\n         ItemKind::Fn(ref sig, ref generics, ref body) => {\n             visitor.visit_generics(generics);\n@@ -525,21 +525,8 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n }\n \n pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a ForeignItem) {\n-    visitor.visit_vis(&item.vis);\n-    visitor.visit_ident(item.ident);\n-\n-    match item.kind {\n-        ForeignItemKind::Fn(ref sig, ref generics, ref body) => {\n-            visitor.visit_generics(generics);\n-            let kind = FnKind::Fn(FnCtxt::Foreign, item.ident, sig, &item.vis, body.as_deref());\n-            visitor.visit_fn(kind, item.span, item.id);\n-        }\n-        ForeignItemKind::Static(ref typ, _) => visitor.visit_ty(typ),\n-        ForeignItemKind::Ty => (),\n-        ForeignItemKind::Macro(ref mac) => visitor.visit_mac(mac),\n-    }\n-\n-    walk_list!(visitor, visit_attribute, &item.attrs);\n+    let ForeignItem { id, span, ident, vis, attrs, kind, tokens: _ } = item;\n+    walk_nested_item(visitor, *id, *span, *ident, vis, attrs, kind, FnCtxt::Foreign);\n }\n \n pub fn walk_global_asm<'a, V: Visitor<'a>>(_: &mut V, _: &'a GlobalAsm) {\n@@ -622,24 +609,39 @@ pub fn walk_fn<'a, V: Visitor<'a>>(visitor: &mut V, kind: FnKind<'a>, _span: Spa\n }\n \n pub fn walk_assoc_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem, ctxt: AssocCtxt) {\n-    visitor.visit_vis(&item.vis);\n-    visitor.visit_ident(item.ident);\n-    walk_list!(visitor, visit_attribute, &item.attrs);\n-    visitor.visit_generics(&item.generics);\n-    match item.kind {\n-        AssocItemKind::Const(ref ty, ref expr) => {\n+    let AssocItem { id, span, ident, vis, attrs, kind, tokens: _, defaultness: _ } = item;\n+    walk_nested_item(visitor, *id, *span, *ident, vis, attrs, kind, FnCtxt::Assoc(ctxt));\n+}\n+\n+fn walk_nested_item<'a, V: Visitor<'a>>(\n+    visitor: &mut V,\n+    id: NodeId,\n+    span: Span,\n+    ident: Ident,\n+    vis: &'a Visibility,\n+    attrs: &'a [Attribute],\n+    kind: &'a AssocItemKind,\n+    ctxt: FnCtxt,\n+) {\n+    visitor.visit_vis(vis);\n+    visitor.visit_ident(ident);\n+    walk_list!(visitor, visit_attribute, attrs);\n+    match kind {\n+        AssocItemKind::Const(ty, expr) | AssocItemKind::Static(ty, _, expr) => {\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_expr, expr);\n         }\n-        AssocItemKind::Fn(ref sig, ref body) => {\n-            let kind = FnKind::Fn(FnCtxt::Assoc(ctxt), item.ident, sig, &item.vis, body.as_deref());\n-            visitor.visit_fn(kind, item.span, item.id);\n+        AssocItemKind::Fn(sig, generics, body) => {\n+            visitor.visit_generics(generics);\n+            let kind = FnKind::Fn(ctxt, ident, sig, vis, body.as_deref());\n+            visitor.visit_fn(kind, span, id);\n         }\n-        AssocItemKind::TyAlias(ref bounds, ref ty) => {\n+        AssocItemKind::TyAlias(generics, bounds, ty) => {\n+            visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_ty, ty);\n         }\n-        AssocItemKind::Macro(ref mac) => {\n+        AssocItemKind::Macro(mac) => {\n             visitor.visit_mac(mac);\n         }\n     }"}, {"sha": "2ed682cea9503ac592d86cc257560d04f8d4ae1f", "filename": "src/test/ui/did_you_mean/issue-40006.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -18,10 +18,10 @@ trait A { //~ ERROR missing\n trait B {\n     fn xxx() { ### } //~ ERROR expected\n }\n-trait C { //~ ERROR missing `fn`, `type`, or `const` for associated-item declaration\n+trait C { //~ ERROR missing `fn`, `type`, `const`, or `static` for item declaration\n     L = M;\n }\n-trait D { //~ ERROR missing `fn`, `type`, or `const` for associated-item declaration\n+trait D { //~ ERROR missing `fn`, `type`, `const`, or `static` for item declaration\n     Z = { 2 + 3 };\n }\n trait E {"}, {"sha": "119e30a3e0f57fcdbaea075cacce6d6ae2155a1f", "filename": "src/test/ui/did_you_mean/issue-40006.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -1,60 +1,60 @@\n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/issue-40006.rs:1:13\n    |\n LL |   impl dyn A {\n    |  _____________^\n LL | |     Y\n-   | |____^ missing `fn`, `type`, or `const`\n+   | |____^ missing `fn`, `type`, `const`, or `static`\n \n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/issue-40006.rs:7:10\n    |\n LL |   trait X {\n    |  __________^\n LL | |     X() {}\n-   | |____^ missing `fn`, `type`, or `const`\n+   | |____^ missing `fn`, `type`, `const`, or `static`\n \n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/issue-40006.rs:15:10\n    |\n LL |   trait A {\n    |  __________^\n LL | |     X() {}\n-   | |____^ missing `fn`, `type`, or `const`\n+   | |____^ missing `fn`, `type`, `const`, or `static`\n \n error: expected `[`, found `#`\n   --> $DIR/issue-40006.rs:19:17\n    |\n LL |     fn xxx() { ### }\n    |                 ^ expected `[`\n \n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/issue-40006.rs:21:10\n    |\n LL |   trait C {\n    |  __________^\n LL | |     L = M;\n-   | |____^ missing `fn`, `type`, or `const`\n+   | |____^ missing `fn`, `type`, `const`, or `static`\n \n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/issue-40006.rs:24:10\n    |\n LL |   trait D {\n    |  __________^\n LL | |     Z = { 2 + 3 };\n-   | |____^ missing `fn`, `type`, or `const`\n+   | |____^ missing `fn`, `type`, `const`, or `static`\n \n error: expected one of `!` or `::`, found `(`\n   --> $DIR/issue-40006.rs:28:9\n    |\n LL |     ::Y ();\n    |         ^ expected one of `!` or `::`\n \n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/issue-40006.rs:32:8\n    |\n LL |     pub hello_method(&self) {\n-   |        ^ missing `fn`, `type`, or `const`\n+   |        ^ missing `fn`, `type`, `const`, or `static`\n \n error[E0599]: no method named `hello_method` found for struct `S` in the current scope\n   --> $DIR/issue-40006.rs:38:7"}, {"sha": "7f67adbdb19c718061798bd3d9010dd4b0cea5a1", "filename": "src/test/ui/extern/extern-const.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fextern%2Fextern-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fextern%2Fextern-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-const.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -1,8 +1,12 @@\n error: extern items cannot be `const`\n-  --> $DIR/extern-const.rs:16:5\n+  --> $DIR/extern-const.rs:16:11\n    |\n LL |     const rust_dbg_static_mut: libc::c_int;\n-   |     ^^^^^ help: try using a static value: `static`\n+   |     ------^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     help: try using a static value: `static`\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n \n error: aborting due to previous error\n "}, {"sha": "f4ca3c46ea28ab0fabdae71e2d083210583c710c", "filename": "src/test/ui/issues/issue-58856-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fissues%2Fissue-58856-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fissues%2Fissue-58856-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58856-2.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -7,11 +7,11 @@ LL |     fn how_are_you(&self -> Empty {\n    |                   |     help: `)` may belong here\n    |                   unclosed delimiter\n \n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, `}`, or identifier, found `)`\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `static`, `type`, `unsafe`, `}`, or identifier, found `)`\n   --> $DIR/issue-58856-2.rs:11:1\n    |\n LL |     }\n-   |      - expected one of 11 possible tokens\n+   |      - expected one of 12 possible tokens\n LL | }\n    | ^ unexpected token\n "}, {"sha": "bab50a53b1ae486e0d9e879d7d6336ff477a78d7", "filename": "src/test/ui/issues/issue-60075.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -4,7 +4,7 @@ error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n LL |         });\n    |          ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, `}`, or identifier, found `;`\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `static`, `type`, `unsafe`, `}`, or identifier, found `;`\n   --> $DIR/issue-60075.rs:6:11\n    |\n LL |     fn qux() -> Option<usize> {"}, {"sha": "5570f081b157dd58867f0426781809e177b1a455", "filename": "src/test/ui/macros/issue-54441.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -1,5 +1,5 @@\n macro_rules! m {\n-    //~^ ERROR missing `fn`, `type`, or `static` for extern-item declaration\n+    //~^ ERROR missing `fn`, `type`, `const`, or `static` for item declaration\n     () => {\n         let\n     };"}, {"sha": "5857aacb431769af35ad7aa7c6716b407d45ea56", "filename": "src/test/ui/macros/issue-54441.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -1,11 +1,11 @@\n-error: missing `fn`, `type`, or `static` for extern-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/issue-54441.rs:1:1\n    |\n LL | / macro_rules! m {\n LL | |\n LL | |     () => {\n LL | |         let\n-   | |________^ missing `fn`, `type`, or `static`\n+   | |________^ missing `fn`, `type`, `const`, or `static`\n \n error: aborting due to previous error\n "}, {"sha": "d37ce06c555bf6defa8e2667295c9277696d9bc9", "filename": "src/test/ui/parser/assoc-const-underscore-semantic-fail.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fassoc-const-underscore-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fassoc-const-underscore-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fassoc-const-underscore-semantic-fail.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,17 @@\n+// Semantically, an associated constant cannot use `_` as a name.\n+\n+fn main() {}\n+\n+const _: () = {\n+    pub trait A {\n+        const _: () = (); //~ ERROR `const` items in this context need a name\n+    }\n+    impl A for () {\n+        const _: () = (); //~ ERROR `const` items in this context need a name\n+        //~^ ERROR const `_` is not a member of trait `A`\n+    }\n+    struct B;\n+    impl B {\n+        const _: () = (); //~ ERROR `const` items in this context need a name\n+    }\n+};"}, {"sha": "538bf0ec100dc6ad26e4b5fbfc7a12eb221e9f40", "filename": "src/test/ui/parser/assoc-const-underscore-semantic-fail.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fassoc-const-underscore-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fassoc-const-underscore-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fassoc-const-underscore-semantic-fail.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,27 @@\n+error: `const` items in this context need a name\n+  --> $DIR/assoc-const-underscore-semantic-fail.rs:7:15\n+   |\n+LL |         const _: () = ();\n+   |               ^ `_` is not a valid name for this `const` item\n+\n+error: `const` items in this context need a name\n+  --> $DIR/assoc-const-underscore-semantic-fail.rs:10:15\n+   |\n+LL |         const _: () = ();\n+   |               ^ `_` is not a valid name for this `const` item\n+\n+error: `const` items in this context need a name\n+  --> $DIR/assoc-const-underscore-semantic-fail.rs:15:15\n+   |\n+LL |         const _: () = ();\n+   |               ^ `_` is not a valid name for this `const` item\n+\n+error[E0438]: const `_` is not a member of trait `A`\n+  --> $DIR/assoc-const-underscore-semantic-fail.rs:10:9\n+   |\n+LL |         const _: () = ();\n+   |         ^^^^^^^^^^^^^^^^^ not a member of trait `A`\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0438`."}, {"sha": "60da408c8115351859b9bf2bcd113882a0927a93", "filename": "src/test/ui/parser/assoc-const-underscore-syntactic-pass.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fassoc-const-underscore-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fassoc-const-underscore-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fassoc-const-underscore-syntactic-pass.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,18 @@\n+// All constant items (associated or otherwise) may syntactically use `_` as a name.\n+\n+// check-pass\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+const _: () = {\n+    pub trait A {\n+        const _: () = ();\n+    }\n+    impl A for () {\n+        const _: () = ();\n+    }\n+    impl dyn A {\n+        const _: () = ();\n+    }\n+};"}, {"sha": "cf3debd77cbfdc631a36b2c598886cb129f60cf0", "filename": "src/test/ui/parser/assoc-static-semantic-fail.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fassoc-static-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fassoc-static-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fassoc-static-semantic-fail.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,43 @@\n+// Semantically, we do not allow e.g., `static X: u8 = 0;` as an associated item.\n+\n+#![feature(specialization)]\n+\n+fn main() {}\n+\n+struct S;\n+impl S {\n+    static IA: u8 = 0;\n+    //~^ ERROR associated `static` items are not allowed\n+    static IB: u8;\n+    //~^ ERROR associated `static` items are not allowed\n+    default static IC: u8 = 0;\n+    //~^ ERROR associated `static` items are not allowed\n+    pub(crate) default static ID: u8;\n+    //~^ ERROR associated `static` items are not allowed\n+}\n+\n+trait T {\n+    static TA: u8 = 0;\n+    //~^ ERROR associated `static` items are not allowed\n+    static TB: u8;\n+    //~^ ERROR associated `static` items are not allowed\n+    default static TC: u8 = 0;\n+    //~^ ERROR associated `static` items are not allowed\n+    //~| ERROR `default` is only allowed on items in\n+    pub(crate) default static TD: u8;\n+    //~^ ERROR associated `static` items are not allowed\n+    //~| ERROR `default` is only allowed on items in\n+    //~| ERROR unnecessary visibility qualifier\n+}\n+\n+impl T for S {\n+    static TA: u8 = 0;\n+    //~^ ERROR associated `static` items are not allowed\n+    static TB: u8;\n+    //~^ ERROR associated `static` items are not allowed\n+    default static TC: u8 = 0;\n+    //~^ ERROR associated `static` items are not allowed\n+    pub default static TD: u8;\n+    //~^ ERROR associated `static` items are not allowed\n+    //~| ERROR unnecessary visibility qualifier\n+}"}, {"sha": "d02e2855c7e62f1cf4e560231ad816c203628f00", "filename": "src/test/ui/parser/assoc-static-semantic-fail.stderr", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fassoc-static-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fassoc-static-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fassoc-static-semantic-fail.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,99 @@\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:9:5\n+   |\n+LL |     static IA: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:11:5\n+   |\n+LL |     static IB: u8;\n+   |     ^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:13:5\n+   |\n+LL |     default static IC: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:15:5\n+   |\n+LL |     pub(crate) default static ID: u8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:20:5\n+   |\n+LL |     static TA: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:22:5\n+   |\n+LL |     static TB: u8;\n+   |     ^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:24:5\n+   |\n+LL |     default static TC: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:27:5\n+   |\n+LL |     pub(crate) default static TD: u8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:34:5\n+   |\n+LL |     static TA: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:36:5\n+   |\n+LL |     static TB: u8;\n+   |     ^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:38:5\n+   |\n+LL |     default static TC: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:40:5\n+   |\n+LL |     pub default static TD: u8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `default` is only allowed on items in `impl` definitions\n+  --> $DIR/assoc-static-semantic-fail.rs:24:5\n+   |\n+LL |     default static TC: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `default` is only allowed on items in `impl` definitions\n+  --> $DIR/assoc-static-semantic-fail.rs:27:5\n+   |\n+LL |     pub(crate) default static TD: u8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0449]: unnecessary visibility qualifier\n+  --> $DIR/assoc-static-semantic-fail.rs:27:5\n+   |\n+LL |     pub(crate) default static TD: u8;\n+   |     ^^^^^^^^^^\n+\n+error[E0449]: unnecessary visibility qualifier\n+  --> $DIR/assoc-static-semantic-fail.rs:40:5\n+   |\n+LL |     pub default static TD: u8;\n+   |     ^^^ `pub` not permitted here because it's implied\n+\n+error: aborting due to 16 previous errors\n+\n+For more information about this error, try `rustc --explain E0449`."}, {"sha": "8f042767e5503101352c43ff9b05c7a2679da877", "filename": "src/test/ui/parser/assoc-static-syntactic-fail.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fassoc-static-syntactic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fassoc-static-syntactic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fassoc-static-syntactic-fail.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,27 @@\n+// Syntactically, we do allow e.g., `static X: u8 = 0;` as an associated item.\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+impl S {\n+    static IA: u8 = 0; //~ ERROR associated `static` items are not allowed\n+    static IB: u8; //~ ERROR associated `static` items are not allowed\n+    default static IC: u8 = 0; //~ ERROR associated `static` items are not allowed\n+    pub(crate) default static ID: u8; //~ ERROR associated `static` items are not allowed\n+}\n+\n+#[cfg(FALSE)]\n+trait T {\n+    static TA: u8 = 0; //~ ERROR associated `static` items are not allowed\n+    static TB: u8; //~ ERROR associated `static` items are not allowed\n+    default static TC: u8 = 0; //~ ERROR associated `static` items are not allowed\n+    pub(crate) default static TD: u8; //~ ERROR associated `static` items are not allowed\n+}\n+\n+#[cfg(FALSE)]\n+impl T for S {\n+    static TA: u8 = 0; //~ ERROR associated `static` items are not allowed\n+    static TB: u8; //~ ERROR associated `static` items are not allowed\n+    default static TC: u8 = 0; //~ ERROR associated `static` items are not allowed\n+    pub default static TD: u8; //~ ERROR associated `static` items are not allowed\n+}"}, {"sha": "bb1e5c4be2e9c5f20bcee3e02fcd0a4f4a9f2577", "filename": "src/test/ui/parser/assoc-static-syntactic-fail.stderr", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fassoc-static-syntactic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fassoc-static-syntactic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fassoc-static-syntactic-fail.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,74 @@\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:7:5\n+   |\n+LL |     static IA: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:8:5\n+   |\n+LL |     static IB: u8;\n+   |     ^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:9:5\n+   |\n+LL |     default static IC: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:10:5\n+   |\n+LL |     pub(crate) default static ID: u8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:15:5\n+   |\n+LL |     static TA: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:16:5\n+   |\n+LL |     static TB: u8;\n+   |     ^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:17:5\n+   |\n+LL |     default static TC: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:18:5\n+   |\n+LL |     pub(crate) default static TD: u8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:23:5\n+   |\n+LL |     static TA: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:24:5\n+   |\n+LL |     static TB: u8;\n+   |     ^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:25:5\n+   |\n+LL |     default static TC: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:26:5\n+   |\n+LL |     pub default static TD: u8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "50952eef22f5c0df259a6393792b41a6c4877949", "filename": "src/test/ui/parser/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdefault.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -20,7 +20,7 @@ impl Foo for u16 {\n \n impl Foo for u32 { //~ ERROR not all trait items implemented, missing: `foo`\n     default pub fn foo<T: Default>() -> T { T::default() }\n-    //~^ ERROR missing `fn`, `type`, or `const` for associated-item declaration\n+    //~^ ERROR missing `fn`, `type`, `const`, or `static` for item declaration\n }\n \n fn main() {}"}, {"sha": "07b051ece2b5de8d87e34c784b0499195ef8c880", "filename": "src/test/ui/parser/default.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fdefault.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fdefault.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdefault.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -1,8 +1,8 @@\n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/default.rs:22:12\n    |\n LL |     default pub fn foo<T: Default>() -> T { T::default() }\n-   |            ^ missing `fn`, `type`, or `const`\n+   |            ^ missing `fn`, `type`, `const`, or `static`\n \n error[E0449]: unnecessary visibility qualifier\n   --> $DIR/default.rs:16:5"}, {"sha": "f6e7f7e6abe8f98c3d71ad3cdf467583db98684e", "filename": "src/test/ui/parser/duplicate-visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -2,5 +2,5 @@ fn main() {}\n \n extern {\n     pub pub fn foo();\n-    //~^ ERROR missing `fn`, `type`, or `static` for extern-item declaration\n+    //~^ ERROR missing `fn`, `type`, `const`, or `static` for item declaration\n }"}, {"sha": "398ba65c9e1d89de4ca22ae073fab751b2059040", "filename": "src/test/ui/parser/duplicate-visibility.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -1,8 +1,8 @@\n-error: missing `fn`, `type`, or `static` for extern-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/duplicate-visibility.rs:4:8\n    |\n LL |     pub pub fn foo();\n-   |        ^ missing `fn`, `type`, or `static`\n+   |        ^ missing `fn`, `type`, `const`, or `static`\n \n error: aborting due to previous error\n "}, {"sha": "dc47f7410730c5c61c85c6f9d1534fee3733f7bb", "filename": "src/test/ui/parser/extern-no-fn.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fextern-no-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fextern-no-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fextern-no-fn.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -1,4 +1,5 @@\n-extern { //~ ERROR missing `fn`, `type`, or `static` for extern-item declaration\n+extern {\n+//~^ ERROR missing `fn`, `type`, `const`, or `static` for item declaration\n     f();\n }\n "}, {"sha": "8d55eefc8d0ecab06db34026229a733a6d86692a", "filename": "src/test/ui/parser/extern-no-fn.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fextern-no-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fextern-no-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fextern-no-fn.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -1,10 +1,11 @@\n-error: missing `fn`, `type`, or `static` for extern-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/extern-no-fn.rs:1:9\n    |\n LL |   extern {\n    |  _________^\n+LL | |\n LL | |     f();\n-   | |____^ missing `fn`, `type`, or `static`\n+   | |____^ missing `fn`, `type`, `const`, or `static`\n \n error: aborting due to previous error\n "}, {"sha": "d28b64142826cfffe6fea6f3481f6e3d98cef384", "filename": "src/test/ui/parser/foreign-const-semantic-fail.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fforeign-const-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fforeign-const-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fforeign-const-semantic-fail.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,8 @@\n+fn main() {}\n+\n+extern {\n+    const A: isize;\n+    //~^ ERROR extern items cannot be `const`\n+    const B: isize = 42;\n+    //~^ ERROR extern items cannot be `const`\n+}"}, {"sha": "f364f11bb038db393239b9773eddf9fbd17131d9", "filename": "src/test/ui/parser/foreign-const-semantic-fail.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fforeign-const-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fforeign-const-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fforeign-const-semantic-fail.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,22 @@\n+error: extern items cannot be `const`\n+  --> $DIR/foreign-const-semantic-fail.rs:4:11\n+   |\n+LL |     const A: isize;\n+   |     ------^\n+   |     |\n+   |     help: try using a static value: `static`\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: extern items cannot be `const`\n+  --> $DIR/foreign-const-semantic-fail.rs:6:11\n+   |\n+LL |     const B: isize = 42;\n+   |     ------^\n+   |     |\n+   |     help: try using a static value: `static`\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "a78f8b1623a80120a2a0eb98b17d4c7d7f7fe56d", "filename": "src/test/ui/parser/foreign-const-syntactic-fail.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fforeign-const-syntactic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fforeign-const-syntactic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fforeign-const-syntactic-fail.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,9 @@\n+// Syntactically, a `const` item inside an `extern { ... }` block is not allowed.\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+extern {\n+    const A: isize; //~ ERROR extern items cannot be `const`\n+    const B: isize = 42; //~ ERROR extern items cannot be `const`\n+}"}, {"sha": "9cf58fa95fb2dc1af38ea57019135e01dc251ac8", "filename": "src/test/ui/parser/foreign-const-syntactic-fail.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fforeign-const-syntactic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fforeign-const-syntactic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fforeign-const-syntactic-fail.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,22 @@\n+error: extern items cannot be `const`\n+  --> $DIR/foreign-const-syntactic-fail.rs:7:11\n+   |\n+LL |     const A: isize;\n+   |     ------^\n+   |     |\n+   |     help: try using a static value: `static`\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: extern items cannot be `const`\n+  --> $DIR/foreign-const-syntactic-fail.rs:8:11\n+   |\n+LL |     const B: isize = 42;\n+   |     ------^\n+   |     |\n+   |     help: try using a static value: `static`\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "9abdf33df9c46a468673061f11b0bfdaabb95198", "filename": "src/test/ui/parser/foreign-static-semantic-fail.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fforeign-static-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fforeign-static-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fforeign-static-semantic-fail.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,8 @@\n+// Syntactically, a foreign static may not have a body.\n+\n+fn main() {}\n+\n+extern {\n+    static X: u8 = 0; //~ ERROR incorrect `static` inside `extern` block\n+    static mut Y: u8 = 0; //~ ERROR incorrect `static` inside `extern` block\n+}"}, {"sha": "5942e3a94497b21e4394e1ac1fb3d16b89e6732b", "filename": "src/test/ui/parser/foreign-static-semantic-fail.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fforeign-static-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fforeign-static-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fforeign-static-semantic-fail.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,27 @@\n+error: incorrect `static` inside `extern` block\n+  --> $DIR/foreign-static-semantic-fail.rs:6:12\n+   |\n+LL | extern {\n+   | ------ `extern` blocks define existing foreign statics and statics inside of them cannot have a body\n+LL |     static X: u8 = 0;\n+   |            ^       - the invalid body\n+   |            |\n+   |            cannot have a body\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: incorrect `static` inside `extern` block\n+  --> $DIR/foreign-static-semantic-fail.rs:7:16\n+   |\n+LL | extern {\n+   | ------ `extern` blocks define existing foreign statics and statics inside of them cannot have a body\n+LL |     static X: u8 = 0;\n+LL |     static mut Y: u8 = 0;\n+   |                ^       - the invalid body\n+   |                |\n+   |                cannot have a body\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "2c805e8a0b700b189063ca899900354ead93d346", "filename": "src/test/ui/parser/foreign-static-syntactic-pass.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fforeign-static-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fforeign-static-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fforeign-static-syntactic-pass.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,11 @@\n+// Syntactically, a foreign static may have a body.\n+\n+// check-pass\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+extern {\n+    static X: u8 = 0;\n+    static mut Y: u8 = 0;\n+}"}, {"sha": "96b15232b10d0e7b601baed9a36043c99cd253e5", "filename": "src/test/ui/parser/foreign-ty-semantic-fail.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fforeign-ty-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fforeign-ty-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fforeign-ty-semantic-fail.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,18 @@\n+#![feature(extern_types)]\n+\n+fn main() {}\n+\n+extern \"C\" {\n+    type A: Ord;\n+    //~^ ERROR bounds on `type`s in `extern` blocks have no effect\n+    type B<'a> where 'a: 'static;\n+    //~^ ERROR `type`s inside `extern` blocks cannot have generic parameters\n+    //~| ERROR `type`s inside `extern` blocks cannot have `where` clauses\n+    type C<T: Ord> where T: 'static;\n+    //~^ ERROR `type`s inside `extern` blocks cannot have generic parameters\n+    //~| ERROR `type`s inside `extern` blocks cannot have `where` clauses\n+    type D = u8;\n+    //~^ ERROR incorrect `type` inside `extern` block\n+\n+    type E: where;\n+}"}, {"sha": "588e4966aaeb567d824873131bbefda212a89088", "filename": "src/test/ui/parser/foreign-ty-semantic-fail.stderr", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fforeign-ty-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fforeign-ty-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fforeign-ty-semantic-fail.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,65 @@\n+error: bounds on `type`s in `extern` blocks have no effect\n+  --> $DIR/foreign-ty-semantic-fail.rs:6:13\n+   |\n+LL |     type A: Ord;\n+   |             ^^^\n+\n+error: `type`s inside `extern` blocks cannot have generic parameters\n+  --> $DIR/foreign-ty-semantic-fail.rs:8:11\n+   |\n+LL | extern \"C\" {\n+   | ---------- `extern` block begins here\n+...\n+LL |     type B<'a> where 'a: 'static;\n+   |           ^^^^ help: remove the generic parameters\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: `type`s inside `extern` blocks cannot have `where` clauses\n+  --> $DIR/foreign-ty-semantic-fail.rs:8:16\n+   |\n+LL | extern \"C\" {\n+   | ---------- `extern` block begins here\n+...\n+LL |     type B<'a> where 'a: 'static;\n+   |                ^^^^^^^^^^^^^^^^^ help: remove the `where` clause\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: `type`s inside `extern` blocks cannot have generic parameters\n+  --> $DIR/foreign-ty-semantic-fail.rs:11:11\n+   |\n+LL | extern \"C\" {\n+   | ---------- `extern` block begins here\n+...\n+LL |     type C<T: Ord> where T: 'static;\n+   |           ^^^^^^^^ help: remove the generic parameters\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: `type`s inside `extern` blocks cannot have `where` clauses\n+  --> $DIR/foreign-ty-semantic-fail.rs:11:20\n+   |\n+LL | extern \"C\" {\n+   | ---------- `extern` block begins here\n+...\n+LL |     type C<T: Ord> where T: 'static;\n+   |                    ^^^^^^^^^^^^^^^^ help: remove the `where` clause\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: incorrect `type` inside `extern` block\n+  --> $DIR/foreign-ty-semantic-fail.rs:14:10\n+   |\n+LL | extern \"C\" {\n+   | ---------- `extern` blocks define existing foreign types and types inside of them cannot have a body\n+...\n+LL |     type D = u8;\n+   |          ^   -- the invalid body\n+   |          |\n+   |          cannot have a body\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "a746de1f14f4da082df949c3c361cbb7fe6a9216", "filename": "src/test/ui/parser/foreign-ty-syntactic-pass.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fforeign-ty-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fforeign-ty-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fforeign-ty-syntactic-pass.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+extern \"C\" {\n+    type A: Ord;\n+    type A<'a> where 'a: 'static;\n+    type A<T: Ord> where T: 'static;\n+    type A = u8;\n+    type A<'a: 'static, T: Ord + 'static>: Eq + PartialEq where T: 'static + Copy = Vec<u8>;\n+}"}, {"sha": "fa9c7ababcf9eb1a2d1fc3966a94e46364f31f1f", "filename": "src/test/ui/parser/impl-item-type-no-body-semantic-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-semantic-fail.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -11,11 +11,11 @@ impl X {\n     //~| ERROR associated types are not yet supported in inherent impls\n     type Z: Ord;\n     //~^ ERROR associated type in `impl` without body\n-    //~| ERROR bounds on associated `type`s in `impl`s have no effect\n+    //~| ERROR bounds on `type`s in `impl`s have no effect\n     //~| ERROR associated types are not yet supported in inherent impls\n     type W: Ord where Self: Eq;\n     //~^ ERROR associated type in `impl` without body\n-    //~| ERROR bounds on associated `type`s in `impl`s have no effect\n+    //~| ERROR bounds on `type`s in `impl`s have no effect\n     //~| ERROR associated types are not yet supported in inherent impls\n     type W where Self: Eq;\n     //~^ ERROR associated type in `impl` without body"}, {"sha": "541d9317c79d08eb3abbbbf0e15317a6554e9ed4", "filename": "src/test/ui/parser/impl-item-type-no-body-semantic-fail.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-semantic-fail.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -14,7 +14,7 @@ LL |     type Z: Ord;\n    |                |\n    |                help: provide a definition for the type: `= <type>;`\n \n-error: bounds on associated `type`s in `impl`s have no effect\n+error: bounds on `type`s in `impl`s have no effect\n   --> $DIR/impl-item-type-no-body-semantic-fail.rs:12:13\n    |\n LL |     type Z: Ord;\n@@ -28,7 +28,7 @@ LL |     type W: Ord where Self: Eq;\n    |                               |\n    |                               help: provide a definition for the type: `= <type>;`\n \n-error: bounds on associated `type`s in `impl`s have no effect\n+error: bounds on `type`s in `impl`s have no effect\n   --> $DIR/impl-item-type-no-body-semantic-fail.rs:16:13\n    |\n LL |     type W: Ord where Self: Eq;"}, {"sha": "014c930ef82053290f49ead17de30754cdf76c24", "filename": "src/test/ui/parser/issue-19398.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fissue-19398.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fissue-19398.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-19398.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -1,5 +1,5 @@\n trait T {\n-    //~^ ERROR missing `fn`, `type`, or `const` for associated-item declaration\n+    //~^ ERROR missing `fn`, `type`, `const`, or `static` for item declaration\n     extern \"Rust\" unsafe fn foo();\n }\n "}, {"sha": "b38b39f9bd99f21a311d64b34df77d56a07699be", "filename": "src/test/ui/parser/issue-19398.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fissue-19398.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fissue-19398.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-19398.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -1,11 +1,11 @@\n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/issue-19398.rs:1:10\n    |\n LL |   trait T {\n    |  __________^\n LL | |\n LL | |     extern \"Rust\" unsafe fn foo();\n-   | |____^ missing `fn`, `type`, or `const`\n+   | |____^ missing `fn`, `type`, `const`, or `static`\n \n error: aborting due to previous error\n "}, {"sha": "4fe05e6f041550d7d905f0516529f82610c1a80d", "filename": "src/test/ui/parser/issue-21153.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fissue-21153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fissue-21153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-21153.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -1,4 +1,5 @@\n-trait MyTrait<T>: Iterator { //~ ERROR missing `fn`, `type`, or `const`\n+trait MyTrait<T>: Iterator {\n+    //~^ ERROR missing `fn`, `type`, `const`, or `static` for item declaration\n     Item = T;\n }\n "}, {"sha": "e9824bd72908189437e8114325e40597e5fcf3aa", "filename": "src/test/ui/parser/issue-21153.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fissue-21153.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fissue-21153.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-21153.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -1,10 +1,11 @@\n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/issue-21153.rs:1:29\n    |\n LL |   trait MyTrait<T>: Iterator {\n    |  _____________________________^\n+LL | |\n LL | |     Item = T;\n-   | |____^ missing `fn`, `type`, or `const`\n+   | |____^ missing `fn`, `type`, `const`, or `static`\n \n error: aborting due to previous error\n "}, {"sha": "d25828da0b97986cea15eba61550428cad93cd29", "filename": "src/test/ui/parser/issue-32446.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fissue-32446.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fissue-32446.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-32446.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, `}`, or identifier, found `...`\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `static`, `type`, `unsafe`, `}`, or identifier, found `...`\n   --> $DIR/issue-32446.rs:4:11\n    |\n LL | trait T { ... }\n-   |           ^^^ expected one of 11 possible tokens\n+   |           ^^^ expected one of 12 possible tokens\n \n error: aborting due to previous error\n "}, {"sha": "a91ef6c67e89ee1b521eb86a5fb0caff0b2e2b03", "filename": "src/test/ui/parser/issue-41155.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fissue-41155.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fissue-41155.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-41155.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `(`, `async`, `const`, `default`, `extern`, `fn`, `type`, `unsafe`, or identifier, found `}`\n+error: expected one of `(`, `async`, `const`, `default`, `extern`, `fn`, `static`, `type`, `unsafe`, or identifier, found `}`\n   --> $DIR/issue-41155.rs:5:1\n    |\n LL |     pub\n-   |        - expected one of 9 possible tokens\n+   |        - expected one of 10 possible tokens\n LL | }\n    | ^ unexpected token\n "}, {"sha": "613b3c9856171a28f10cfdd856d7aaf8f15ba693", "filename": "src/test/ui/parser/item-free-const-no-body-semantic-fail.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,7 @@\n+// Semantically, a free `const` item cannot omit its body.\n+\n+fn main() {}\n+\n+const A: u8; //~ ERROR free constant item without body\n+const B; //~ ERROR free constant item without body\n+//~^ ERROR missing type for `const` item"}, {"sha": "4e97229fa1a411b331643243a20c699297729de0", "filename": "src/test/ui/parser/item-free-const-no-body-semantic-fail.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,24 @@\n+error: free constant item without body\n+  --> $DIR/item-free-const-no-body-semantic-fail.rs:5:1\n+   |\n+LL | const A: u8;\n+   | ^^^^^^^^^^^-\n+   |            |\n+   |            help: provide a definition for the constant: `= <expr>;`\n+\n+error: free constant item without body\n+  --> $DIR/item-free-const-no-body-semantic-fail.rs:6:1\n+   |\n+LL | const B;\n+   | ^^^^^^^-\n+   |        |\n+   |        help: provide a definition for the constant: `= <expr>;`\n+\n+error: missing type for `const` item\n+  --> $DIR/item-free-const-no-body-semantic-fail.rs:6:7\n+   |\n+LL | const B;\n+   |       ^ help: provide a type for the item: `B: [type error]`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "acfdd3c363f2542eeb81cd4bdeef36db8ecda516", "filename": "src/test/ui/parser/item-free-const-no-body-syntactic-pass.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-syntactic-pass.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,8 @@\n+// Syntactically, a free `const` item can omit its body.\n+\n+// check-pass\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+const X: u8;"}, {"sha": "780479e3d26ac6eb4a76cb6e45155ce05fadf066", "filename": "src/test/ui/parser/item-free-static-no-body-semantic-fail.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,11 @@\n+// Semantically, a free `static` item cannot omit its body.\n+\n+fn main() {}\n+\n+static A: u8; //~ ERROR free static item without body\n+static B; //~ ERROR free static item without body\n+//~^ ERROR missing type for `static` item\n+\n+static mut C: u8; //~ ERROR free static item without body\n+static mut D; //~ ERROR free static item without body\n+//~^ ERROR missing type for `static mut` item"}, {"sha": "60b7bb34c698b3a33ac5bfe1b12319a98219e63e", "filename": "src/test/ui/parser/item-free-static-no-body-semantic-fail.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,46 @@\n+error: free static item without body\n+  --> $DIR/item-free-static-no-body-semantic-fail.rs:5:1\n+   |\n+LL | static A: u8;\n+   | ^^^^^^^^^^^^-\n+   |             |\n+   |             help: provide a definition for the static: `= <expr>;`\n+\n+error: free static item without body\n+  --> $DIR/item-free-static-no-body-semantic-fail.rs:6:1\n+   |\n+LL | static B;\n+   | ^^^^^^^^-\n+   |         |\n+   |         help: provide a definition for the static: `= <expr>;`\n+\n+error: free static item without body\n+  --> $DIR/item-free-static-no-body-semantic-fail.rs:9:1\n+   |\n+LL | static mut C: u8;\n+   | ^^^^^^^^^^^^^^^^-\n+   |                 |\n+   |                 help: provide a definition for the static: `= <expr>;`\n+\n+error: free static item without body\n+  --> $DIR/item-free-static-no-body-semantic-fail.rs:10:1\n+   |\n+LL | static mut D;\n+   | ^^^^^^^^^^^^-\n+   |             |\n+   |             help: provide a definition for the static: `= <expr>;`\n+\n+error: missing type for `static` item\n+  --> $DIR/item-free-static-no-body-semantic-fail.rs:6:8\n+   |\n+LL | static B;\n+   |        ^ help: provide a type for the item: `B: [type error]`\n+\n+error: missing type for `static mut` item\n+  --> $DIR/item-free-static-no-body-semantic-fail.rs:10:12\n+   |\n+LL | static mut D;\n+   |            ^ help: provide a type for the item: `D: [type error]`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "db0039204d870f82089ea989c9be93abe775469e", "filename": "src/test/ui/parser/item-free-static-no-body-syntactic-pass.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-syntactic-pass.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -0,0 +1,8 @@\n+// Syntactically, a free `const` item can omit its body.\n+\n+// check-pass\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+static X: u8;"}, {"sha": "c76b096a1ebf402af6e2bf1b1c9eb2fe78268605", "filename": "src/test/ui/parser/macro/trait-non-item-macros.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or identifier, found `2`\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `static`, `type`, `unsafe`, or identifier, found `2`\n   --> $DIR/trait-non-item-macros.rs:2:19\n    |\n LL |     ($a:expr) => ($a)\n-   |                   ^^ expected one of 10 possible tokens\n+   |                   ^^ expected one of 11 possible tokens\n ...\n LL |     bah!(2);\n    |     -------- in this macro invocation"}, {"sha": "748db8983b59573286eab122d89d0e85775e4ef6", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-impl-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -3,7 +3,7 @@ fn main() {}\n impl T for () { //~ ERROR cannot find trait `T` in this scope\n \n fn foo(&self) {}\n-//~^ ERROR missing `fn`, `type`, or `const`\n+//~^ ERROR missing `fn`, `type`, `const`, or `static` for item declaration\n \n trait T {\n     fn foo(&self);"}, {"sha": "240be39eacef423e897d0f6f1dc98246e1697eb2", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-impl-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -7,15 +7,15 @@ LL | impl T for () {\n LL |\n    |                                                    ^\n \n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/missing-close-brace-in-impl-trait.rs:5:17\n    |\n LL |   fn foo(&self) {}\n    |  _________________^\n LL | |\n LL | |\n LL | | trait T {\n-   | |_ missing `fn`, `type`, or `const`\n+   | |_ missing `fn`, `type`, `const`, or `static`\n \n error[E0405]: cannot find trait `T` in this scope\n   --> $DIR/missing-close-brace-in-impl-trait.rs:3:6"}, {"sha": "4e8cc6489bc64c276a4fc08e1333a8d76a325af7", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -3,7 +3,7 @@ trait T {\n     fn foo(&self);\n \n pub(crate) struct Bar<T>();\n-//~^ ERROR missing `fn`, `type`, or `const`\n+//~^ ERROR missing `fn`, `type`, `const`, or `static` for item declaration\n \n impl T for Bar<usize> {\n fn foo(&self) {}"}, {"sha": "54afad5755b1587ed6643d55a4be78fbb3643c4b", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -7,11 +7,11 @@ LL | trait T {\n LL | fn main() {}\n    |                                                                 ^\n \n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/missing-close-brace-in-trait.rs:5:11\n    |\n LL | pub(crate) struct Bar<T>();\n-   |           ^ missing `fn`, `type`, or `const`\n+   |           ^ missing `fn`, `type`, `const`, or `static`\n \n error[E0601]: `main` function not found in crate `missing_close_brace_in_trait`\n   --> $DIR/missing-close-brace-in-trait.rs:1:1"}, {"sha": "71c22e62f8e4bd25bfadd34881106fec6033848b", "filename": "src/test/ui/parser/removed-syntax-extern-const.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/981acd90353b40e9529de0eda21ba5b4071134d5/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-extern-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981acd90353b40e9529de0eda21ba5b4071134d5/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-extern-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-extern-const.rs?ref=981acd90353b40e9529de0eda21ba5b4071134d5", "patch": "@@ -1,6 +0,0 @@\n-extern {\n-    const i: isize;\n-    //~^ ERROR extern items cannot be `const`\n-}\n-\n-fn main() {}"}, {"sha": "2bccbd91452f62a7276305f9b3c7fbfdceb57533", "filename": "src/test/ui/parser/removed-syntax-extern-const.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/981acd90353b40e9529de0eda21ba5b4071134d5/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-extern-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/981acd90353b40e9529de0eda21ba5b4071134d5/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-extern-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-extern-const.stderr?ref=981acd90353b40e9529de0eda21ba5b4071134d5", "patch": "@@ -1,8 +0,0 @@\n-error: extern items cannot be `const`\n-  --> $DIR/removed-syntax-extern-const.rs:2:5\n-   |\n-LL |     const i: isize;\n-   |     ^^^^^ help: try using a static value: `static`\n-\n-error: aborting due to previous error\n-"}, {"sha": "cd643b874dbda108a22c18bf7a53b67f52ddb470", "filename": "src/test/ui/parser/removed-syntax-static-fn.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -1,8 +1,10 @@\n struct S;\n \n impl S {\n-    //~^ ERROR missing `fn`, `type`, or `const` for associated-item declaration\n     static fn f() {}\n+    //~^ ERROR expected identifier, found keyword `fn`\n+    //~| ERROR expected one of `:`, `;`, or `=`\n+    //~| ERROR missing type for `static` item\n }\n \n fn main() {}"}, {"sha": "dc5625bdadea3395b416bf7381bd5518b211b128", "filename": "src/test/ui/parser/removed-syntax-static-fn.stderr", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -1,11 +1,20 @@\n-error: missing `fn`, `type`, or `const` for associated-item declaration\n-  --> $DIR/removed-syntax-static-fn.rs:3:9\n+error: expected identifier, found keyword `fn`\n+  --> $DIR/removed-syntax-static-fn.rs:4:12\n    |\n-LL |   impl S {\n-   |  _________^\n-LL | |\n-LL | |     static fn f() {}\n-   | |____^ missing `fn`, `type`, or `const`\n+LL |     static fn f() {}\n+   |            ^^ expected identifier, found keyword\n \n-error: aborting due to previous error\n+error: expected one of `:`, `;`, or `=`, found `f`\n+  --> $DIR/removed-syntax-static-fn.rs:4:15\n+   |\n+LL |     static fn f() {}\n+   |               ^ expected one of `:`, `;`, or `=`\n+\n+error: missing type for `static` item\n+  --> $DIR/removed-syntax-static-fn.rs:4:12\n+   |\n+LL |     static fn f() {}\n+   |            ^^ help: provide a type for the item: `r#fn: <type>`\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "c01ac4752e07561f0aa6de5f8e42784faa1e2007", "filename": "src/test/ui/parser/underscore_item_not_const.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Funderscore_item_not_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Funderscore_item_not_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Funderscore_item_not_const.rs?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -1,18 +1,4 @@\n-// Test that various non-const items and associated consts do not permit `_` as a name.\n-\n-// Associated `const`s:\n-\n-pub trait A {\n-    const _: () = (); //~ ERROR expected identifier, found reserved identifier `_`\n-}\n-impl A for () {\n-    const _: () = (); //~ ERROR expected identifier, found reserved identifier `_`\n-}\n-impl dyn A {\n-    const _: () = (); //~ ERROR expected identifier, found reserved identifier `_`\n-}\n-\n-// Other kinds of items:\n+// Test that various non-const items do not syntactically permit `_` as a name.\n \n static _: () = (); //~ ERROR expected identifier, found reserved identifier `_`\n struct _(); //~ ERROR expected identifier, found reserved identifier `_`"}, {"sha": "0bc7642dd196471fe0bf6459c848cc31fc6c6eb2", "filename": "src/test/ui/parser/underscore_item_not_const.stderr", "status": "modified", "additions": 13, "deletions": 31, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Funderscore_item_not_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b864d23f3484aad297e998f3cd50a4277122d070/src%2Ftest%2Fui%2Fparser%2Funderscore_item_not_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Funderscore_item_not_const.stderr?ref=b864d23f3484aad297e998f3cd50a4277122d070", "patch": "@@ -1,92 +1,74 @@\n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:6:11\n-   |\n-LL |     const _: () = ();\n-   |           ^ expected identifier, found reserved identifier\n-\n-error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:9:11\n-   |\n-LL |     const _: () = ();\n-   |           ^ expected identifier, found reserved identifier\n-\n-error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:12:11\n-   |\n-LL |     const _: () = ();\n-   |           ^ expected identifier, found reserved identifier\n-\n-error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:17:8\n+  --> $DIR/underscore_item_not_const.rs:3:8\n    |\n LL | static _: () = ();\n    |        ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:18:8\n+  --> $DIR/underscore_item_not_const.rs:4:8\n    |\n LL | struct _();\n    |        ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:19:6\n+  --> $DIR/underscore_item_not_const.rs:5:6\n    |\n LL | enum _ {}\n    |      ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:20:4\n+  --> $DIR/underscore_item_not_const.rs:6:4\n    |\n LL | fn _() {}\n    |    ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:21:5\n+  --> $DIR/underscore_item_not_const.rs:7:5\n    |\n LL | mod _ {}\n    |     ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:22:6\n+  --> $DIR/underscore_item_not_const.rs:8:6\n    |\n LL | type _ = ();\n    |      ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:23:5\n+  --> $DIR/underscore_item_not_const.rs:9:5\n    |\n LL | use _;\n    |     ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:24:5\n+  --> $DIR/underscore_item_not_const.rs:10:5\n    |\n LL | use _ as g;\n    |     ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:25:7\n+  --> $DIR/underscore_item_not_const.rs:11:7\n    |\n LL | trait _ {}\n    |       ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:26:7\n+  --> $DIR/underscore_item_not_const.rs:12:7\n    |\n LL | trait _ = Copy;\n    |       ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:27:14\n+  --> $DIR/underscore_item_not_const.rs:13:14\n    |\n LL | macro_rules! _ { () => {} }\n    |              ^ expected identifier, found reserved identifier\n \n error: expected one of `!` or `::`, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:28:7\n+  --> $DIR/underscore_item_not_const.rs:14:7\n    |\n LL | union _ { f: u8 }\n    |       ^ expected one of `!` or `::`\n \n-error: aborting due to 15 previous errors\n+error: aborting due to 12 previous errors\n "}]}