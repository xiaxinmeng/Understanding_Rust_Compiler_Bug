{"sha": "29ad8539b9c408eebbe7252f74c754f4e0a41d46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5YWQ4NTM5YjljNDA4ZWViYmU3MjUyZjc0Yzc1NGY0ZTBhNDFkNDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-24T16:21:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-24T16:21:23Z"}, "message": "auto merge of #20060 : Aatch/rust/enum-repr, r=alexcrichton\n\nThe previous behaviour of using the smallest type possible caused LLVM\r\nto treat padding too conservatively, causing poor codegen. This commit\r\nchanges the behaviour to use an alignment-sized integer as the\r\ndiscriminant. This keeps types the same size, but helps LLVM understand\r\nthe data structure a little better, resulting in better codegen.", "tree": {"sha": "0eb0bd2ba9a26f65d34680724c313320471af3eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0eb0bd2ba9a26f65d34680724c313320471af3eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29ad8539b9c408eebbe7252f74c754f4e0a41d46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29ad8539b9c408eebbe7252f74c754f4e0a41d46", "html_url": "https://github.com/rust-lang/rust/commit/29ad8539b9c408eebbe7252f74c754f4e0a41d46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29ad8539b9c408eebbe7252f74c754f4e0a41d46/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e64a8193b02ce72ef183274994a25eae281cb89c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e64a8193b02ce72ef183274994a25eae281cb89c", "html_url": "https://github.com/rust-lang/rust/commit/e64a8193b02ce72ef183274994a25eae281cb89c"}, {"sha": "b473311ad8161c8d16412acb54f4188e737e4ca4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b473311ad8161c8d16412acb54f4188e737e4ca4", "html_url": "https://github.com/rust-lang/rust/commit/b473311ad8161c8d16412acb54f4188e737e4ca4"}], "stats": {"total": 85, "additions": 79, "deletions": 6}, "files": [{"sha": "0d2876bdf81cee324a0a94fb88d8026a61e3e20a", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 61, "deletions": 6, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/29ad8539b9c408eebbe7252f74c754f4e0a41d46/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ad8539b9c408eebbe7252f74c754f4e0a41d46/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=29ad8539b9c408eebbe7252f74c754f4e0a41d46", "patch": "@@ -256,7 +256,62 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             assert!((cases.len() - 1) as i64 >= 0);\n             let bounds = IntBounds { ulo: 0, uhi: (cases.len() - 1) as u64,\n                                      slo: 0, shi: (cases.len() - 1) as i64 };\n-            let ity = range_to_inttype(cx, hint, &bounds);\n+            let min_ity = range_to_inttype(cx, hint, &bounds);\n+\n+            // Create the set of structs that represent each variant\n+            // Use the minimum integer type we figured out above\n+            let fields : Vec<_> = cases.iter().map(|c| {\n+                let mut ftys = vec!(ty_of_inttype(min_ity));\n+                ftys.push_all(c.tys.as_slice());\n+                if dtor { ftys.push(ty::mk_bool()); }\n+                mk_struct(cx, ftys.as_slice(), false, t)\n+            }).collect();\n+\n+\n+            // Check to see if we should use a different type for the\n+            // discriminant. If the overall alignment of the type is\n+            // the same as the first field in each variant, we can safely use\n+            // an alignment-sized type.\n+            // We increase the size of the discriminant to avoid LLVM copying\n+            // padding when it doesn't need to. This normally causes unaligned\n+            // load/stores and excessive memcpy/memset operations. By using a\n+            // bigger integer size, LLVM can be sure about it's contents and\n+            // won't be so conservative.\n+            // This check is needed to avoid increasing the size of types when\n+            // the alignment of the first field is smaller than the overall\n+            // alignment of the type.\n+            let (_, align) = union_size_and_align(fields.as_slice());\n+            let mut use_align = true;\n+            for st in fields.iter() {\n+                // Get the first non-zero-sized field\n+                let field = st.fields.iter().skip(1).filter(|ty| {\n+                    let t = type_of::sizing_type_of(cx, **ty);\n+                    machine::llsize_of_real(cx, t) != 0 ||\n+                    // This case is only relevant for zero-sized types with large alignment\n+                    machine::llalign_of_min(cx, t) != 1\n+                }).next();\n+\n+                if let Some(field) = field {\n+                    let field_align = type_of::align_of(cx, *field);\n+                    if field_align != align {\n+                        use_align = false;\n+                        break;\n+                    }\n+                }\n+            }\n+            let ity = if use_align {\n+                // Use the overall alignment\n+                match align {\n+                    1 => attr::UnsignedInt(ast::TyU8),\n+                    2 => attr::UnsignedInt(ast::TyU16),\n+                    4 => attr::UnsignedInt(ast::TyU32),\n+                    8 if machine::llalign_of_min(cx, Type::i64(cx)) == 8 =>\n+                        attr::UnsignedInt(ast::TyU64),\n+                    _ => min_ity // use min_ity as a fallback\n+                }\n+            } else {\n+                min_ity\n+            };\n \n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(ity));\n@@ -570,7 +625,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let discr_ty = ll_inttype(cx, ity);\n             let discr_size = machine::llsize_of_alloc(cx, discr_ty);\n             let align_units = (size + align_s - 1) / align_s - 1;\n-            let pad_ty = match align_s {\n+            let fill_ty = match align_s {\n                 1 => Type::array(&Type::i8(cx), align_units),\n                 2 => Type::array(&Type::i16(cx), align_units),\n                 4 => Type::array(&Type::i32(cx), align_units),\n@@ -580,11 +635,11 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                               align_units),\n                 _ => panic!(\"unsupported enum alignment: {}\", align)\n             };\n-            assert_eq!(machine::llalign_of_min(cx, pad_ty), align);\n+            assert_eq!(machine::llalign_of_min(cx, fill_ty), align);\n             assert_eq!(align_s % discr_size, 0);\n-            let fields = vec!(discr_ty,\n-                           Type::array(&discr_ty, align_s / discr_size - 1),\n-                           pad_ty);\n+            let fields = [discr_ty,\n+                          Type::array(&discr_ty, align_s / discr_size - 1),\n+                          fill_ty];\n             match name {\n                 None => Type::struct_(cx, fields[], false),\n                 Some(name) => {"}, {"sha": "7c007cf9d33748130652eb5952344cc17e497941", "filename": "src/test/run-pass/type-sizes.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/29ad8539b9c408eebbe7252f74c754f4e0a41d46/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ad8539b9c408eebbe7252f74c754f4e0a41d46/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-sizes.rs?ref=29ad8539b9c408eebbe7252f74c754f4e0a41d46", "patch": "@@ -18,6 +18,17 @@ struct w {a: int, b: ()}\n struct x {a: int, b: (), c: ()}\n struct y {x: int}\n \n+enum e1 {\n+    a(u8, u32), b(u32), c\n+}\n+enum e2 {\n+    a(u32), b\n+}\n+\n+enum e3 {\n+    a([u16, ..0], u8), b\n+}\n+\n pub fn main() {\n     assert_eq!(size_of::<u8>(), 1 as uint);\n     assert_eq!(size_of::<u32>(), 4 as uint);\n@@ -34,4 +45,11 @@ pub fn main() {\n     assert_eq!(size_of::<w>(), size_of::<int>());\n     assert_eq!(size_of::<x>(), size_of::<int>());\n     assert_eq!(size_of::<int>(), size_of::<y>());\n+\n+    // Make sure enum types are the appropriate size, mostly\n+    // around ensuring alignment is handled properly\n+\n+    assert_eq!(size_of::<e1>(), 8 as uint);\n+    assert_eq!(size_of::<e2>(), 8 as uint);\n+    assert_eq!(size_of::<e3>(), 4 as uint);\n }"}]}