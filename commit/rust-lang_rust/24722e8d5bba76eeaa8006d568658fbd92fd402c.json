{"sha": "24722e8d5bba76eeaa8006d568658fbd92fd402c", "node_id": "C_kwDOAAsO6NoAKDI0NzIyZThkNWJiYTc2ZWVhYTgwMDZkNTY4NjU4ZmJkOTJmZDQwMmM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-10-11T16:59:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-11T16:59:48Z"}, "message": "Rollup merge of #102612 - JhonnyBillM:migrate-codegen-ssa-to-diagnostics-structs, r=davidtwco\n\nMigrate `codegen_ssa` to diagnostics structs - [Part 1]\n\nInitial migration of `codegen_ssa`. Going to split this crate migration in at least two PRs in order to avoid a huge PR and to quick off some questions around:\n\n1. Translating messages from \"external\" crates.\n2. Interfacing with OS messages.\n3. Adding UI tests while migrating diagnostics.\n\n_See comments below._", "tree": {"sha": "9ccb5fe117f856777a8135c1be5a3823ed448df1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ccb5fe117f856777a8135c1be5a3823ed448df1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24722e8d5bba76eeaa8006d568658fbd92fd402c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjRaEECRBK7hj4Ov3rIwAAQasIAEuRJaF+Tow+XXvW1iG87dUa\nFZGYINwLyrvCsPSoOa4hsXfFFUgkiyGiH4sZ0s2M9M1BHfmx4I2ifBtjlGyvQZqB\ng9RilFrhDpqZjPEjTCOLTeH2oC810Z4kiz6rq/rxPO94a5jaoEhsH3aN/OoNDksH\nsMrG7rGFmlnP4GoIpDMHl09T1ybhQw/x62yn0tHG/VmsAUu6cd3nXud9gZ4vASgK\nHIpux87Mpmvt4yODBmgPYIIgznRHXN38+uaGKvWijhL8weW7LmuCepxWto5X5tlI\n6/A0R8PCuBUSvwQWV/+M7q0ZnHpKVzyiEnDFHmvZU0pKvmMCPcSiEMqkBQVbYzE=\n=WJtY\n-----END PGP SIGNATURE-----\n", "payload": "tree 9ccb5fe117f856777a8135c1be5a3823ed448df1\nparent d10b47ef69a36590a04c76e8868093d251adfec6\nparent 13d4f27c829a332f50a2109647f3b16bce119b8d\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1665507588 +0200\ncommitter GitHub <noreply@github.com> 1665507588 +0200\n\nRollup merge of #102612 - JhonnyBillM:migrate-codegen-ssa-to-diagnostics-structs, r=davidtwco\n\nMigrate `codegen_ssa` to diagnostics structs - [Part 1]\n\nInitial migration of `codegen_ssa`. Going to split this crate migration in at least two PRs in order to avoid a huge PR and to quick off some questions around:\n\n1. Translating messages from \"external\" crates.\n2. Interfacing with OS messages.\n3. Adding UI tests while migrating diagnostics.\n\n_See comments below._\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24722e8d5bba76eeaa8006d568658fbd92fd402c", "html_url": "https://github.com/rust-lang/rust/commit/24722e8d5bba76eeaa8006d568658fbd92fd402c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24722e8d5bba76eeaa8006d568658fbd92fd402c/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d10b47ef69a36590a04c76e8868093d251adfec6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d10b47ef69a36590a04c76e8868093d251adfec6", "html_url": "https://github.com/rust-lang/rust/commit/d10b47ef69a36590a04c76e8868093d251adfec6"}, {"sha": "13d4f27c829a332f50a2109647f3b16bce119b8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/13d4f27c829a332f50a2109647f3b16bce119b8d", "html_url": "https://github.com/rust-lang/rust/commit/13d4f27c829a332f50a2109647f3b16bce119b8d"}], "stats": {"total": 627, "additions": 535, "deletions": 92}, "files": [{"sha": "95e72184ff037c94cbe87266d0e2bd800e3365da", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 30, "deletions": 52, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/24722e8d5bba76eeaa8006d568658fbd92fd402c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24722e8d5bba76eeaa8006d568658fbd92fd402c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=24722e8d5bba76eeaa8006d568658fbd92fd402c", "patch": "@@ -31,7 +31,9 @@ use super::command::Command;\n use super::linker::{self, Linker};\n use super::metadata::{create_rmeta_file, MetadataPosition};\n use super::rpath::{self, RPathConfig};\n-use crate::{looks_like_rust_object_file, CodegenResults, CompiledModule, CrateInfo, NativeLib};\n+use crate::{\n+    errors, looks_like_rust_object_file, CodegenResults, CompiledModule, CrateInfo, NativeLib,\n+};\n \n use cc::windows_registry;\n use regex::Regex;\n@@ -93,7 +95,7 @@ pub fn link_binary<'a>(\n             let tmpdir = TempFileBuilder::new()\n                 .prefix(\"rustc\")\n                 .tempdir()\n-                .unwrap_or_else(|err| sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n+                .unwrap_or_else(|error| sess.emit_fatal(errors::CreateTempDir { error }));\n             let path = MaybeTempDir::new(tmpdir, sess.opts.cg.save_temps);\n             let out_filename = out_filename(\n                 sess,\n@@ -208,7 +210,7 @@ pub fn link_binary<'a>(\n pub fn each_linked_rlib(\n     info: &CrateInfo,\n     f: &mut dyn FnMut(CrateNum, &Path),\n-) -> Result<(), String> {\n+) -> Result<(), errors::LinkRlibError> {\n     let crates = info.used_crates.iter();\n     let mut fmts = None;\n     for (ty, list) in info.dependency_formats.iter() {\n@@ -224,26 +226,23 @@ pub fn each_linked_rlib(\n         }\n     }\n     let Some(fmts) = fmts else {\n-        return Err(\"could not find formats for rlibs\".to_string());\n+        return Err(errors::LinkRlibError::MissingFormat);\n     };\n     for &cnum in crates {\n         match fmts.get(cnum.as_usize() - 1) {\n             Some(&Linkage::NotLinked | &Linkage::IncludedFromDylib) => continue,\n             Some(_) => {}\n-            None => return Err(\"could not find formats for rlibs\".to_string()),\n+            None => return Err(errors::LinkRlibError::MissingFormat),\n         }\n-        let name = info.crate_name[&cnum];\n+        let crate_name = info.crate_name[&cnum];\n         let used_crate_source = &info.used_crate_source[&cnum];\n         if let Some((path, _)) = &used_crate_source.rlib {\n             f(cnum, &path);\n         } else {\n             if used_crate_source.rmeta.is_some() {\n-                return Err(format!(\n-                    \"could not find rlib for: `{}`, found rmeta (metadata) file\",\n-                    name\n-                ));\n+                return Err(errors::LinkRlibError::OnlyRmetaFound { crate_name });\n             } else {\n-                return Err(format!(\"could not find rlib for: `{}`\", name));\n+                return Err(errors::LinkRlibError::NotFound { crate_name });\n             }\n         }\n     }\n@@ -340,10 +339,7 @@ fn link_rlib<'a>(\n                 // -whole-archive and it isn't clear how we can currently handle such a\n                 // situation correctly.\n                 // See https://github.com/rust-lang/rust/issues/88085#issuecomment-901050897\n-                sess.err(\n-                    \"the linking modifiers `+bundle` and `+whole-archive` are not compatible \\\n-                        with each other when generating rlibs\",\n-                );\n+                sess.emit_err(errors::IncompatibleLinkingModifiers);\n             }\n             NativeLibKind::Static { bundle: None | Some(true), .. } => {}\n             NativeLibKind::Static { bundle: Some(false), .. }\n@@ -365,12 +361,8 @@ fn link_rlib<'a>(\n                 ));\n                 continue;\n             }\n-            ab.add_archive(&location, Box::new(|_| false)).unwrap_or_else(|e| {\n-                sess.fatal(&format!(\n-                    \"failed to add native library {}: {}\",\n-                    location.to_string_lossy(),\n-                    e\n-                ));\n+            ab.add_archive(&location, Box::new(|_| false)).unwrap_or_else(|error| {\n+                sess.emit_fatal(errors::AddNativeLibrary { library_path: location, error });\n             });\n         }\n     }\n@@ -385,8 +377,8 @@ fn link_rlib<'a>(\n             tmpdir.as_ref(),\n         );\n \n-        ab.add_archive(&output_path, Box::new(|_| false)).unwrap_or_else(|e| {\n-            sess.fatal(&format!(\"failed to add native library {}: {}\", output_path.display(), e));\n+        ab.add_archive(&output_path, Box::new(|_| false)).unwrap_or_else(|error| {\n+            sess.emit_fatal(errors::AddNativeLibrary { library_path: output_path, error });\n         });\n     }\n \n@@ -451,14 +443,11 @@ fn collate_raw_dylibs(\n                     // FIXME: when we add support for ordinals, figure out if we need to do anything\n                     // if we have two DllImport values with the same name but different ordinals.\n                     if import.calling_convention != old_import.calling_convention {\n-                        sess.span_err(\n-                            import.span,\n-                            &format!(\n-                                \"multiple declarations of external function `{}` from \\\n-                                 library `{}` have different calling conventions\",\n-                                import.name, name,\n-                            ),\n-                        );\n+                        sess.emit_err(errors::MultipleExternalFuncDecl {\n+                            span: import.span,\n+                            function: import.name,\n+                            library_name: &name,\n+                        });\n                     }\n                 }\n             }\n@@ -560,7 +549,7 @@ fn link_staticlib<'a>(\n         all_native_libs.extend(codegen_results.crate_info.native_libraries[&cnum].iter().cloned());\n     });\n     if let Err(e) = res {\n-        sess.fatal(&e);\n+        sess.emit_fatal(e);\n     }\n \n     ab.build(out_filename);\n@@ -673,9 +662,7 @@ fn link_dwarf_object<'a>(\n     }) {\n         Ok(()) => {}\n         Err(e) => {\n-            sess.struct_err(\"linking dwarf objects with thorin failed\")\n-                .note(&format!(\"{:?}\", e))\n-                .emit();\n+            sess.emit_err(errors::ThorinErrorWrapper(e));\n             sess.abort_if_errors();\n         }\n     }\n@@ -879,23 +866,14 @@ fn link_natively<'a>(\n                 let mut output = prog.stderr.clone();\n                 output.extend_from_slice(&prog.stdout);\n                 let escaped_output = escape_string(&output);\n-                let mut err = sess.struct_err(&format!(\n-                    \"linking with `{}` failed: {}\",\n-                    linker_path.display(),\n-                    prog.status\n-                ));\n-                err.note(&format!(\"{:?}\", &cmd)).note(&escaped_output);\n-                if escaped_output.contains(\"undefined reference to\") {\n-                    err.help(\n-                        \"some `extern` functions couldn't be found; some native libraries may \\\n-                         need to be installed or have their path specified\",\n-                    );\n-                    err.note(\"use the `-l` flag to specify native libraries to link\");\n-                    err.note(\"use the `cargo:rustc-link-lib` directive to specify the native \\\n-                              libraries to link with Cargo (see https://doc.rust-lang.org/cargo/reference/build-scripts.html#cargorustc-link-libkindname)\");\n-                }\n-                err.emit();\n-\n+                // FIXME: Add UI tests for this error.\n+                let err = errors::LinkingFailed {\n+                    linker_path: &linker_path,\n+                    exit_status: prog.status,\n+                    command: &cmd,\n+                    escaped_output: &escaped_output,\n+                };\n+                sess.diagnostic().emit_err(err);\n                 // If MSVC's `link.exe` was expected but the return code\n                 // is not a Microsoft LNK error then suggest a way to fix or\n                 // install the Visual Studio build tools."}, {"sha": "bad22ccb1fedd7dcb105e41acc12c750c73b12e4", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/24722e8d5bba76eeaa8006d568658fbd92fd402c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24722e8d5bba76eeaa8006d568658fbd92fd402c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=24722e8d5bba76eeaa8006d568658fbd92fd402c", "patch": "@@ -1,5 +1,6 @@\n use super::command::Command;\n use super::symbol_export;\n+use crate::errors;\n use rustc_span::symbol::sym;\n \n use std::ffi::{OsStr, OsString};\n@@ -434,11 +435,11 @@ impl<'a> Linker for GccLinker<'a> {\n                 // FIXME(81490): ld64 doesn't support these flags but macOS 11\n                 // has -needed-l{} / -needed_library {}\n                 // but we have no way to detect that here.\n-                self.sess.warn(\"`as-needed` modifier not implemented yet for ld64\");\n+                self.sess.emit_warning(errors::Ld64UnimplementedModifier);\n             } else if self.is_gnu && !self.sess.target.is_like_windows {\n                 self.linker_arg(\"--no-as-needed\");\n             } else {\n-                self.sess.warn(\"`as-needed` modifier not supported for current linker\");\n+                self.sess.emit_warning(errors::LinkerUnsupportedModifier);\n             }\n         }\n         self.hint_dynamic();\n@@ -492,7 +493,7 @@ impl<'a> Linker for GccLinker<'a> {\n             // FIXME(81490): ld64 as of macOS 11 supports the -needed_framework\n             // flag but we have no way to detect that here.\n             // self.cmd.arg(\"-needed_framework\").arg(framework);\n-            self.sess.warn(\"`as-needed` modifier not implemented yet for ld64\");\n+            self.sess.emit_warning(errors::Ld64UnimplementedModifier);\n         }\n         self.cmd.arg(\"-framework\").arg(framework);\n     }\n@@ -665,8 +666,8 @@ impl<'a> Linker for GccLinker<'a> {\n                     writeln!(f, \"_{}\", sym)?;\n                 }\n             };\n-            if let Err(e) = res {\n-                self.sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n+            if let Err(error) = res {\n+                self.sess.emit_fatal(errors::LibDefWriteFailure { error });\n             }\n         } else if is_windows {\n             let res: io::Result<()> = try {\n@@ -680,8 +681,8 @@ impl<'a> Linker for GccLinker<'a> {\n                     writeln!(f, \"  {}\", symbol)?;\n                 }\n             };\n-            if let Err(e) = res {\n-                self.sess.fatal(&format!(\"failed to write list.def file: {}\", e));\n+            if let Err(error) = res {\n+                self.sess.emit_fatal(errors::LibDefWriteFailure { error });\n             }\n         } else {\n             // Write an LD version script\n@@ -697,8 +698,8 @@ impl<'a> Linker for GccLinker<'a> {\n                 }\n                 writeln!(f, \"\\n  local:\\n    *;\\n}};\")?;\n             };\n-            if let Err(e) = res {\n-                self.sess.fatal(&format!(\"failed to write version script: {}\", e));\n+            if let Err(error) = res {\n+                self.sess.emit_fatal(errors::VersionScriptWriteFailure { error });\n             }\n         }\n \n@@ -915,9 +916,8 @@ impl<'a> Linker for MsvcLinker<'a> {\n                                     self.cmd.arg(arg);\n                                 }\n                             }\n-                            Err(err) => {\n-                                self.sess\n-                                    .warn(&format!(\"error enumerating natvis directory: {}\", err));\n+                            Err(error) => {\n+                                self.sess.emit_warning(errors::NoNatvisDirectory { error });\n                             }\n                         }\n                     }\n@@ -971,8 +971,8 @@ impl<'a> Linker for MsvcLinker<'a> {\n                 writeln!(f, \"  {}\", symbol)?;\n             }\n         };\n-        if let Err(e) = res {\n-            self.sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n+        if let Err(error) = res {\n+            self.sess.emit_fatal(errors::LibDefWriteFailure { error });\n         }\n         let mut arg = OsString::from(\"/DEF:\");\n         arg.push(path);\n@@ -1435,7 +1435,7 @@ impl<'a> Linker for L4Bender<'a> {\n \n     fn export_symbols(&mut self, _: &Path, _: CrateType, _: &[String]) {\n         // ToDo, not implemented, copy from GCC\n-        self.sess.warn(\"exporting symbols not implemented yet for L4Bender\");\n+        self.sess.emit_warning(errors::L4BenderExportingSymbolsUnimplemented);\n         return;\n     }\n \n@@ -1727,8 +1727,8 @@ impl<'a> Linker for BpfLinker<'a> {\n                 writeln!(f, \"{}\", sym)?;\n             }\n         };\n-        if let Err(e) = res {\n-            self.sess.fatal(&format!(\"failed to write symbols file: {}\", e));\n+        if let Err(error) = res {\n+            self.sess.emit_fatal(errors::SymbolFileWriteFailure { error });\n         } else {\n             self.cmd.arg(\"--export-symbols\").arg(&path);\n         }"}, {"sha": "1f577e9f3524f04390a672d001a18a39c7897353", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/24722e8d5bba76eeaa8006d568658fbd92fd402c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24722e8d5bba76eeaa8006d568658fbd92fd402c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=24722e8d5bba76eeaa8006d568658fbd92fd402c", "patch": "@@ -2,11 +2,11 @@ use super::link::{self, ensure_removed};\n use super::lto::{self, SerializedModule};\n use super::symbol_export::symbol_name_for_instance_in_crate;\n \n+use crate::errors;\n+use crate::traits::*;\n use crate::{\n     CachedModuleCodegen, CodegenResults, CompiledModule, CrateInfo, ModuleCodegen, ModuleKind,\n };\n-\n-use crate::traits::*;\n use jobserver::{Acquired, Client};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::memmap::Mmap;\n@@ -530,7 +530,7 @@ fn produce_final_output_artifacts(\n     // Produce final compile outputs.\n     let copy_gracefully = |from: &Path, to: &Path| {\n         if let Err(e) = fs::copy(from, to) {\n-            sess.err(&format!(\"could not copy {:?} to {:?}: {}\", from, to, e));\n+            sess.emit_err(errors::CopyPath::new(from, to, e));\n         }\n     };\n \n@@ -546,7 +546,7 @@ fn produce_final_output_artifacts(\n                 ensure_removed(sess.diagnostic(), &path);\n             }\n         } else {\n-            let ext = crate_output\n+            let extension = crate_output\n                 .temp_path(output_type, None)\n                 .extension()\n                 .unwrap()\n@@ -557,19 +557,11 @@ fn produce_final_output_artifacts(\n             if crate_output.outputs.contains_key(&output_type) {\n                 // 2) Multiple codegen units, with `--emit foo=some_name`.  We have\n                 //    no good solution for this case, so warn the user.\n-                sess.warn(&format!(\n-                    \"ignoring emit path because multiple .{} files \\\n-                                    were produced\",\n-                    ext\n-                ));\n+                sess.emit_warning(errors::IgnoringEmitPath { extension });\n             } else if crate_output.single_output_file.is_some() {\n                 // 3) Multiple codegen units, with `-o some_name`.  We have\n                 //    no good solution for this case, so warn the user.\n-                sess.warn(&format!(\n-                    \"ignoring -o because multiple .{} files \\\n-                                    were produced\",\n-                    ext\n-                ));\n+                sess.emit_warning(errors::IgnoringOutput { extension });\n             } else {\n                 // 4) Multiple codegen units, but no explicit name.  We\n                 //    just leave the `foo.0.x` files in place.\n@@ -880,14 +872,12 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n         );\n         match link_or_copy(&source_file, &output_path) {\n             Ok(_) => Some(output_path),\n-            Err(err) => {\n-                let diag_handler = cgcx.create_diag_handler();\n-                diag_handler.err(&format!(\n-                    \"unable to copy {} to {}: {}\",\n-                    source_file.display(),\n-                    output_path.display(),\n-                    err\n-                ));\n+            Err(error) => {\n+                cgcx.create_diag_handler().emit_err(errors::CopyPathBuf {\n+                    source_file,\n+                    output_path,\n+                    error,\n+                });\n                 None\n             }\n         }"}, {"sha": "0ffe887202261f00196e8496d65a72b3b343e4c3", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "added", "additions": 353, "deletions": 0, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/24722e8d5bba76eeaa8006d568658fbd92fd402c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24722e8d5bba76eeaa8006d568658fbd92fd402c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=24722e8d5bba76eeaa8006d568658fbd92fd402c", "patch": "@@ -0,0 +1,353 @@\n+//! Errors emitted by codegen_ssa\n+\n+use crate::back::command::Command;\n+use rustc_errors::{\n+    fluent, DiagnosticArgValue, DiagnosticBuilder, ErrorGuaranteed, Handler, IntoDiagnostic,\n+    IntoDiagnosticArg,\n+};\n+use rustc_macros::Diagnostic;\n+use rustc_span::{Span, Symbol};\n+use std::borrow::Cow;\n+use std::io::Error;\n+use std::path::{Path, PathBuf};\n+use std::process::ExitStatus;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::lib_def_write_failure)]\n+pub struct LibDefWriteFailure {\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::version_script_write_failure)]\n+pub struct VersionScriptWriteFailure {\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::symbol_file_write_failure)]\n+pub struct SymbolFileWriteFailure {\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::ld64_unimplemented_modifier)]\n+pub struct Ld64UnimplementedModifier;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::linker_unsupported_modifier)]\n+pub struct LinkerUnsupportedModifier;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::L4Bender_exporting_symbols_unimplemented)]\n+pub struct L4BenderExportingSymbolsUnimplemented;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::no_natvis_directory)]\n+pub struct NoNatvisDirectory {\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::copy_path_buf)]\n+pub struct CopyPathBuf {\n+    pub source_file: PathBuf,\n+    pub output_path: PathBuf,\n+    pub error: Error,\n+}\n+\n+// Reports Paths using `Debug` implementation rather than Path's `Display` implementation.\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::copy_path)]\n+pub struct CopyPath<'a> {\n+    from: DebugArgPath<'a>,\n+    to: DebugArgPath<'a>,\n+    error: Error,\n+}\n+\n+impl<'a> CopyPath<'a> {\n+    pub fn new(from: &'a Path, to: &'a Path, error: Error) -> CopyPath<'a> {\n+        CopyPath { from: DebugArgPath(from), to: DebugArgPath(to), error }\n+    }\n+}\n+\n+struct DebugArgPath<'a>(pub &'a Path);\n+\n+impl IntoDiagnosticArg for DebugArgPath<'_> {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(format!(\"{:?}\", self.0)))\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::ignoring_emit_path)]\n+pub struct IgnoringEmitPath {\n+    pub extension: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::ignoring_output)]\n+pub struct IgnoringOutput {\n+    pub extension: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::create_temp_dir)]\n+pub struct CreateTempDir {\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::incompatible_linking_modifiers)]\n+pub struct IncompatibleLinkingModifiers;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::add_native_library)]\n+pub struct AddNativeLibrary {\n+    pub library_path: PathBuf,\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::multiple_external_func_decl)]\n+pub struct MultipleExternalFuncDecl<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub function: Symbol,\n+    pub library_name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+pub enum LinkRlibError {\n+    #[diag(codegen_ssa::rlib_missing_format)]\n+    MissingFormat,\n+\n+    #[diag(codegen_ssa::rlib_only_rmeta_found)]\n+    OnlyRmetaFound { crate_name: Symbol },\n+\n+    #[diag(codegen_ssa::rlib_not_found)]\n+    NotFound { crate_name: Symbol },\n+}\n+\n+pub struct ThorinErrorWrapper(pub thorin::Error);\n+\n+impl IntoDiagnostic<'_> for ThorinErrorWrapper {\n+    fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag;\n+        match self.0 {\n+            thorin::Error::ReadInput(_) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_read_input_failure);\n+                diag\n+            }\n+            thorin::Error::ParseFileKind(_) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_input_file_kind);\n+                diag\n+            }\n+            thorin::Error::ParseObjectFile(_) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_input_object_file);\n+                diag\n+            }\n+            thorin::Error::ParseArchiveFile(_) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_input_archive_file);\n+                diag\n+            }\n+            thorin::Error::ParseArchiveMember(_) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_archive_member);\n+                diag\n+            }\n+            thorin::Error::InvalidInputKind => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_invalid_input_kind);\n+                diag\n+            }\n+            thorin::Error::DecompressData(_) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_decompress_data);\n+                diag\n+            }\n+            thorin::Error::NamelessSection(_, offset) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_section_without_name);\n+                diag.set_arg(\"offset\", format!(\"0x{:08x}\", offset));\n+                diag\n+            }\n+            thorin::Error::RelocationWithInvalidSymbol(section, offset) => {\n+                diag =\n+                    handler.struct_err(fluent::codegen_ssa::thorin_relocation_with_invalid_symbol);\n+                diag.set_arg(\"section\", section);\n+                diag.set_arg(\"offset\", format!(\"0x{:08x}\", offset));\n+                diag\n+            }\n+            thorin::Error::MultipleRelocations(section, offset) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_multiple_relocations);\n+                diag.set_arg(\"section\", section);\n+                diag.set_arg(\"offset\", format!(\"0x{:08x}\", offset));\n+                diag\n+            }\n+            thorin::Error::UnsupportedRelocation(section, offset) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_unsupported_relocation);\n+                diag.set_arg(\"section\", section);\n+                diag.set_arg(\"offset\", format!(\"0x{:08x}\", offset));\n+                diag\n+            }\n+            thorin::Error::MissingDwoName(id) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_missing_dwo_name);\n+                diag.set_arg(\"id\", format!(\"0x{:08x}\", id));\n+                diag\n+            }\n+            thorin::Error::NoCompilationUnits => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_no_compilation_units);\n+                diag\n+            }\n+            thorin::Error::NoDie => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_no_die);\n+                diag\n+            }\n+            thorin::Error::TopLevelDieNotUnit => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_top_level_die_not_unit);\n+                diag\n+            }\n+            thorin::Error::MissingRequiredSection(section) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_missing_required_section);\n+                diag.set_arg(\"section\", section);\n+                diag\n+            }\n+            thorin::Error::ParseUnitAbbreviations(_) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_unit_abbreviations);\n+                diag\n+            }\n+            thorin::Error::ParseUnitAttribute(_) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_unit_attribute);\n+                diag\n+            }\n+            thorin::Error::ParseUnitHeader(_) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_unit_header);\n+                diag\n+            }\n+            thorin::Error::ParseUnit(_) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_unit);\n+                diag\n+            }\n+            thorin::Error::IncompatibleIndexVersion(section, format, actual) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_incompatible_index_version);\n+                diag.set_arg(\"section\", section);\n+                diag.set_arg(\"actual\", actual);\n+                diag.set_arg(\"format\", format);\n+                diag\n+            }\n+            thorin::Error::OffsetAtIndex(_, index) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_offset_at_index);\n+                diag.set_arg(\"index\", index);\n+                diag\n+            }\n+            thorin::Error::StrAtOffset(_, offset) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_str_at_offset);\n+                diag.set_arg(\"offset\", format!(\"0x{:08x}\", offset));\n+                diag\n+            }\n+            thorin::Error::ParseIndex(_, section) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_index);\n+                diag.set_arg(\"section\", section);\n+                diag\n+            }\n+            thorin::Error::UnitNotInIndex(unit) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_unit_not_in_index);\n+                diag.set_arg(\"unit\", format!(\"0x{:08x}\", unit));\n+                diag\n+            }\n+            thorin::Error::RowNotInIndex(_, row) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_row_not_in_index);\n+                diag.set_arg(\"row\", row);\n+                diag\n+            }\n+            thorin::Error::SectionNotInRow => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_section_not_in_row);\n+                diag\n+            }\n+            thorin::Error::EmptyUnit(unit) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_empty_unit);\n+                diag.set_arg(\"unit\", format!(\"0x{:08x}\", unit));\n+                diag\n+            }\n+            thorin::Error::MultipleDebugInfoSection => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_multiple_debug_info_section);\n+                diag\n+            }\n+            thorin::Error::MultipleDebugTypesSection => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_multiple_debug_types_section);\n+                diag\n+            }\n+            thorin::Error::NotSplitUnit => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_not_split_unit);\n+                diag\n+            }\n+            thorin::Error::DuplicateUnit(unit) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_duplicate_unit);\n+                diag.set_arg(\"unit\", format!(\"0x{:08x}\", unit));\n+                diag\n+            }\n+            thorin::Error::MissingReferencedUnit(unit) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_missing_referenced_unit);\n+                diag.set_arg(\"unit\", format!(\"0x{:08x}\", unit));\n+                diag\n+            }\n+            thorin::Error::NoOutputObjectCreated => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_not_output_object_created);\n+                diag\n+            }\n+            thorin::Error::MixedInputEncodings => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_mixed_input_encodings);\n+                diag\n+            }\n+            thorin::Error::Io(e) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_io);\n+                diag.set_arg(\"error\", format!(\"{e}\"));\n+                diag\n+            }\n+            thorin::Error::ObjectRead(e) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_object_read);\n+                diag.set_arg(\"error\", format!(\"{e}\"));\n+                diag\n+            }\n+            thorin::Error::ObjectWrite(e) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_object_write);\n+                diag.set_arg(\"error\", format!(\"{e}\"));\n+                diag\n+            }\n+            thorin::Error::GimliRead(e) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_gimli_read);\n+                diag.set_arg(\"error\", format!(\"{e}\"));\n+                diag\n+            }\n+            thorin::Error::GimliWrite(e) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_gimli_write);\n+                diag.set_arg(\"error\", format!(\"{e}\"));\n+                diag\n+            }\n+            _ => unimplemented!(\"Untranslated thorin error\"),\n+        }\n+    }\n+}\n+\n+pub struct LinkingFailed<'a> {\n+    pub linker_path: &'a PathBuf,\n+    pub exit_status: ExitStatus,\n+    pub command: &'a Command,\n+    pub escaped_output: &'a str,\n+}\n+\n+impl IntoDiagnostic<'_> for LinkingFailed<'_> {\n+    fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = handler.struct_err(fluent::codegen_ssa::linking_failed);\n+        diag.set_arg(\"linker_path\", format!(\"{}\", self.linker_path.display()));\n+        diag.set_arg(\"exit_status\", format!(\"{}\", self.exit_status));\n+\n+        diag.note(format!(\"{:?}\", self.command)).note(self.escaped_output);\n+\n+        // Trying to match an error from OS linkers\n+        // which by now we have no way to translate.\n+        if self.escaped_output.contains(\"undefined reference to\") {\n+            diag.note(fluent::codegen_ssa::extern_funcs_not_found)\n+                .note(fluent::codegen_ssa::specify_libraries_to_link)\n+                .note(fluent::codegen_ssa::use_cargo_directive);\n+        }\n+        diag\n+    }\n+}"}, {"sha": "ceebe4d417f7d68b0014f8b75d80d6f150e97b36", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24722e8d5bba76eeaa8006d568658fbd92fd402c/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24722e8d5bba76eeaa8006d568658fbd92fd402c/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=24722e8d5bba76eeaa8006d568658fbd92fd402c", "patch": "@@ -6,6 +6,7 @@\n #![feature(strict_provenance)]\n #![feature(int_roundings)]\n #![feature(if_let_guard)]\n+#![feature(never_type)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n \n@@ -43,6 +44,7 @@ pub mod base;\n pub mod common;\n pub mod coverageinfo;\n pub mod debuginfo;\n+pub mod errors;\n pub mod glue;\n pub mod meth;\n pub mod mir;"}, {"sha": "0d0388a039e2d01a4cd2054eea6314a331fa8acc", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_ssa.ftl", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/24722e8d5bba76eeaa8006d568658fbd92fd402c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/24722e8d5bba76eeaa8006d568658fbd92fd402c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl?ref=24722e8d5bba76eeaa8006d568658fbd92fd402c", "patch": "@@ -0,0 +1,119 @@\n+codegen_ssa_lib_def_write_failure = failed to write lib.def file: {$error}\n+\n+codegen_ssa_version_script_write_failure = failed to write version script: {$error}\n+\n+codegen_ssa_symbol_file_write_failure = failed to write symbols file: {$error}\n+\n+codegen_ssa_ld64_unimplemented_modifier = `as-needed` modifier not implemented yet for ld64\n+\n+codegen_ssa_linker_unsupported_modifier = `as-needed` modifier not supported for current linker\n+\n+codegen_ssa_L4Bender_exporting_symbols_unimplemented = exporting symbols not implemented yet for L4Bender\n+\n+codegen_ssa_no_natvis_directory = error enumerating natvis directory: {$error}\n+\n+codegen_ssa_copy_path = could not copy {$from} to {$to}: {$error}\n+\n+codegen_ssa_copy_path_buf = unable to copy {$source_file} to {$output_path}: {$error}\n+\n+codegen_ssa_ignoring_emit_path = ignoring emit path because multiple .{$extension} files were produced\n+\n+codegen_ssa_ignoring_output = ignoring -o because multiple .{$extension} files were produced\n+\n+codegen_ssa_create_temp_dir = couldn't create a temp dir: {$error}\n+\n+codegen_ssa_incompatible_linking_modifiers = the linking modifiers `+bundle` and `+whole-archive` are not compatible with each other when generating rlibs\n+\n+codegen_ssa_add_native_library = failed to add native library {$library_path}: {$error}\n+\n+codegen_ssa_multiple_external_func_decl = multiple declarations of external function `{$function}` from library `{$library_name}` have different calling conventions\n+\n+codegen_ssa_rlib_missing_format = could not find formats for rlibs\n+\n+codegen_ssa_rlib_only_rmeta_found = could not find rlib for: `{$crate_name}`, found rmeta (metadata) file\n+\n+codegen_ssa_rlib_not_found = could not find rlib for: `{$crate_name}`\n+\n+codegen_ssa_linking_failed = linking with `{$linker_path}` failed: {$exit_status}\n+\n+codegen_ssa_extern_funcs_not_found = some `extern` functions couldn't be found; some native libraries may need to be installed or have their path specified\n+\n+codegen_ssa_specify_libraries_to_link = use the `-l` flag to specify native libraries to link\n+\n+codegen_ssa_use_cargo_directive = use the `cargo:rustc-link-lib` directive to specify the native libraries to link with Cargo (see https://doc.rust-lang.org/cargo/reference/build-scripts.html#cargorustc-link-libkindname)\n+\n+codegen_ssa_thorin_read_input_failure = failed to read input file\n+\n+codegen_ssa_thorin_parse_input_file_kind = failed to parse input file kind\n+\n+codegen_ssa_thorin_parse_input_object_file = failed to parse input object file\n+\n+codegen_ssa_thorin_parse_input_archive_file = failed to parse input archive file\n+\n+codegen_ssa_thorin_parse_archive_member = failed to parse archive member\n+\n+codegen_ssa_thorin_invalid_input_kind = input is not an archive or elf object\n+\n+codegen_ssa_thorin_decompress_data = failed to decompress compressed section\n+\n+codegen_ssa_thorin_section_without_name = section without name at offset {$offset}\n+\n+codegen_ssa_thorin_relocation_with_invalid_symbol = relocation with invalid symbol for section `{$section}` at offset {$offset}\n+\n+codegen_ssa_thorin_multiple_relocations = multiple relocations for section `{$section}` at offset {$offset}\n+\n+codegen_ssa_thorin_unsupported_relocation = unsupported relocation for section {$section} at offset {$offset}\n+\n+codegen_ssa_thorin_missing_dwo_name = missing path attribute to DWARF object ({$id})\n+\n+codegen_ssa_thorin_no_compilation_units = input object has no compilation units\n+\n+codegen_ssa_thorin_no_die = no top-level debugging information entry in compilation/type unit\n+\n+codegen_ssa_thorin_top_level_die_not_unit = top-level debugging information entry is not a compilation/type unit\n+\n+codegen_ssa_thorin_missing_required_section = input object missing required section `{$section}`\n+\n+codegen_ssa_thorin_parse_unit_abbreviations = failed to parse unit abbreviations\n+\n+codegen_ssa_thorin_parse_unit_attribute = failed to parse unit attribute\n+\n+codegen_ssa_thorin_parse_unit_header = failed to parse unit header\n+\n+codegen_ssa_thorin_parse_unit = failed to parse unit\n+\n+codegen_ssa_thorin_incompatible_index_version = incompatible `{$section}` index version: found version {$actual}, expected version {$format}\n+\n+codegen_ssa_thorin_offset_at_index = read offset at index {$index} of `.debug_str_offsets.dwo` section\n+\n+codegen_ssa_thorin_str_at_offset = read string at offset {$offset} of `.debug_str.dwo` section\n+\n+codegen_ssa_thorin_parse_index = failed to parse `{$section}` index section\n+\n+codegen_ssa_thorin_unit_not_in_index = unit {$unit} from input package is not in its index\n+\n+codegen_ssa_thorin_row_not_in_index = row {$row} found in index's hash table not present in index\n+\n+codegen_ssa_thorin_section_not_in_row = section not found in unit's row in index\n+\n+codegen_ssa_thorin_empty_unit = unit {$unit} in input DWARF object with no data\n+\n+codegen_ssa_thorin_multiple_debug_info_section = multiple `.debug_info.dwo` sections\n+\n+codegen_ssa_thorin_multiple_debug_types_section = multiple `.debug_types.dwo` sections in a package\n+\n+codegen_ssa_thorin_not_split_unit = regular compilation unit in object (missing dwo identifier)\n+\n+codegen_ssa_thorin_duplicate_unit = duplicate split compilation unit ({$unit})\n+\n+codegen_ssa_thorin_missing_referenced_unit = unit {$unit} referenced by executable was not found\n+\n+codegen_ssa_thorin_not_output_object_created = no output object was created from inputs\n+\n+codegen_ssa_thorin_mixed_input_encodings = input objects haved mixed encodings\n+\n+codegen_ssa_thorin_io = {$error}\n+codegen_ssa_thorin_object_read = {$error}\n+codegen_ssa_thorin_object_write = {$error}\n+codegen_ssa_thorin_gimli_read = {$error}\n+codegen_ssa_thorin_gimli_write = {$error}"}, {"sha": "77f87d5b007e3fc2d4a5cdb188da16c59be0e83b", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24722e8d5bba76eeaa8006d568658fbd92fd402c/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24722e8d5bba76eeaa8006d568658fbd92fd402c/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=24722e8d5bba76eeaa8006d568658fbd92fd402c", "patch": "@@ -40,9 +40,10 @@ fluent_messages! {\n     attr => \"../locales/en-US/attr.ftl\",\n     borrowck => \"../locales/en-US/borrowck.ftl\",\n     builtin_macros => \"../locales/en-US/builtin_macros.ftl\",\n+    codegen_gcc => \"../locales/en-US/codegen_gcc.ftl\",\n+    codegen_ssa => \"../locales/en-US/codegen_ssa.ftl\",\n     compiletest => \"../locales/en-US/compiletest.ftl\",\n     const_eval => \"../locales/en-US/const_eval.ftl\",\n-    codegen_gcc => \"../locales/en-US/codegen_gcc.ftl\",\n     driver => \"../locales/en-US/driver.ftl\",\n     expand => \"../locales/en-US/expand.ftl\",\n     hir_analysis => \"../locales/en-US/hir_analysis.ftl\","}]}