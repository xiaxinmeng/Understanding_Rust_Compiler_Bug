{"sha": "4e40a0d43640a5cf26f28cea35ec16445966a000", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlNDBhMGQ0MzY0MGE1Y2YyNmYyOGNlYTM1ZWMxNjQ0NTk2NmEwMDA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-05T05:34:28Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-14T06:56:44Z"}, "message": "rustc_trans: rename mircx: MirContext to fx: FunctionCx.", "tree": {"sha": "22affad9c936f367c4808dc5b62653c382e562e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22affad9c936f367c4808dc5b62653c382e562e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e40a0d43640a5cf26f28cea35ec16445966a000", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e40a0d43640a5cf26f28cea35ec16445966a000", "html_url": "https://github.com/rust-lang/rust/commit/4e40a0d43640a5cf26f28cea35ec16445966a000", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e40a0d43640a5cf26f28cea35ec16445966a000/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "209abc71e52b864429330e8debd8ce1080a7f3b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/209abc71e52b864429330e8debd8ce1080a7f3b4", "html_url": "https://github.com/rust-lang/rust/commit/209abc71e52b864429330e8debd8ce1080a7f3b4"}], "stats": {"total": 116, "additions": 58, "deletions": 58}, "files": [{"sha": "cbecc0eb7d1b5e708cc86168b336f3ca512aae42", "filename": "src/librustc_trans/debuginfo/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e40a0d43640a5cf26f28cea35ec16445966a000/src%2Flibrustc_trans%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e40a0d43640a5cf26f28cea35ec16445966a000/src%2Flibrustc_trans%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fdoc.rs?ref=4e40a0d43640a5cf26f28cea35ec16445966a000", "patch": "@@ -45,7 +45,7 @@\n //!\n //! All private state used by the module is stored within either the\n //! CrateDebugContext struct (owned by the CodegenCx) or the\n-//! FunctionDebugContext (owned by the MirContext).\n+//! FunctionDebugContext (owned by the FunctionCx).\n //!\n //! This file consists of three conceptual sections:\n //! 1. The public interface of the module"}, {"sha": "bf82e1d50c47387884bb1f46c24e3c4b7a4296cc", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4e40a0d43640a5cf26f28cea35ec16445966a000/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e40a0d43640a5cf26f28cea35ec16445966a000/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=4e40a0d43640a5cf26f28cea35ec16445966a000", "patch": "@@ -20,18 +20,18 @@ use rustc::mir::traversal;\n use rustc::ty;\n use rustc::ty::layout::LayoutOf;\n use type_of::LayoutLlvmExt;\n-use super::MirContext;\n+use super::FunctionCx;\n \n-pub fn memory_locals<'a, 'tcx>(mircx: &MirContext<'a, 'tcx>) -> BitVector {\n-    let mir = mircx.mir;\n-    let mut analyzer = LocalAnalyzer::new(mircx);\n+pub fn memory_locals<'a, 'tcx>(fx: &FunctionCx<'a, 'tcx>) -> BitVector {\n+    let mir = fx.mir;\n+    let mut analyzer = LocalAnalyzer::new(fx);\n \n     analyzer.visit_mir(mir);\n \n     for (index, ty) in mir.local_decls.iter().map(|l| l.ty).enumerate() {\n-        let ty = mircx.monomorphize(&ty);\n+        let ty = fx.monomorphize(&ty);\n         debug!(\"local {} has type {:?}\", index, ty);\n-        let layout = mircx.cx.layout_of(ty);\n+        let layout = fx.cx.layout_of(ty);\n         if layout.is_llvm_immediate() {\n             // These sorts of types are immediates that we can store\n             // in an ValueRef without an alloca.\n@@ -52,21 +52,21 @@ pub fn memory_locals<'a, 'tcx>(mircx: &MirContext<'a, 'tcx>) -> BitVector {\n }\n \n struct LocalAnalyzer<'mir, 'a: 'mir, 'tcx: 'a> {\n-    cx: &'mir MirContext<'a, 'tcx>,\n+    fx: &'mir FunctionCx<'a, 'tcx>,\n     memory_locals: BitVector,\n     seen_assigned: BitVector\n }\n \n impl<'mir, 'a, 'tcx> LocalAnalyzer<'mir, 'a, 'tcx> {\n-    fn new(mircx: &'mir MirContext<'a, 'tcx>) -> LocalAnalyzer<'mir, 'a, 'tcx> {\n+    fn new(fx: &'mir FunctionCx<'a, 'tcx>) -> LocalAnalyzer<'mir, 'a, 'tcx> {\n         let mut analyzer = LocalAnalyzer {\n-            cx: mircx,\n-            memory_locals: BitVector::new(mircx.mir.local_decls.len()),\n-            seen_assigned: BitVector::new(mircx.mir.local_decls.len())\n+            fx,\n+            memory_locals: BitVector::new(fx.mir.local_decls.len()),\n+            seen_assigned: BitVector::new(fx.mir.local_decls.len())\n         };\n \n         // Arguments get assigned to by means of the function being called\n-        for idx in 0..mircx.mir.arg_count {\n+        for idx in 0..fx.mir.arg_count {\n             analyzer.seen_assigned.insert(idx + 1);\n         }\n \n@@ -95,7 +95,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n \n         if let mir::Place::Local(index) = *place {\n             self.mark_assigned(index);\n-            if !self.cx.rvalue_creates_operand(rvalue) {\n+            if !self.fx.rvalue_creates_operand(rvalue) {\n                 self.mark_as_memory(index);\n             }\n         } else {\n@@ -117,7 +117,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                     }, ..\n                 }),\n                 ref args, ..\n-            } if Some(def_id) == self.cx.cx.tcx.lang_items().box_free_fn() => {\n+            } if Some(def_id) == self.fx.cx.tcx.lang_items().box_free_fn() => {\n                 // box_free(x) shares with `drop x` the property that it\n                 // is not guaranteed to be statically dominated by the\n                 // definition of x, so x must always be in an alloca.\n@@ -136,7 +136,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                     context: PlaceContext<'tcx>,\n                     location: Location) {\n         debug!(\"visit_place(place={:?}, context={:?})\", place, context);\n-        let cx = self.cx.cx;\n+        let cx = self.fx.cx;\n \n         if let mir::Place::Projection(ref proj) = *place {\n             // Allow uses of projections that are ZSTs or from scalar fields.\n@@ -145,12 +145,12 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                 _ => false\n             };\n             if is_consume {\n-                let base_ty = proj.base.ty(self.cx.mir, cx.tcx);\n-                let base_ty = self.cx.monomorphize(&base_ty);\n+                let base_ty = proj.base.ty(self.fx.mir, cx.tcx);\n+                let base_ty = self.fx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access.\n                 let elem_ty = base_ty.projection_ty(cx.tcx, &proj.elem).to_ty(cx.tcx);\n-                let elem_ty = self.cx.monomorphize(&elem_ty);\n+                let elem_ty = self.fx.monomorphize(&elem_ty);\n                 if cx.layout_of(elem_ty).is_zst() {\n                     return;\n                 }\n@@ -200,11 +200,11 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n             }\n \n             PlaceContext::Drop => {\n-                let ty = mir::Place::Local(index).ty(self.cx.mir, self.cx.cx.tcx);\n-                let ty = self.cx.monomorphize(&ty.to_ty(self.cx.cx.tcx));\n+                let ty = mir::Place::Local(index).ty(self.fx.mir, self.fx.cx.tcx);\n+                let ty = self.fx.monomorphize(&ty.to_ty(self.fx.cx.tcx));\n \n                 // Only need the place if we're actually dropping it.\n-                if self.cx.cx.type_needs_drop(ty) {\n+                if self.fx.cx.type_needs_drop(ty) {\n                     self.mark_as_memory(index);\n                 }\n             }"}, {"sha": "af1e30a4b19a6c2f5485c92d26988981f64839b7", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e40a0d43640a5cf26f28cea35ec16445966a000/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e40a0d43640a5cf26f28cea35ec16445966a000/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=4e40a0d43640a5cf26f28cea35ec16445966a000", "patch": "@@ -29,13 +29,13 @@ use type_::Type;\n use syntax::symbol::Symbol;\n use syntax_pos::Pos;\n \n-use super::{MirContext, LocalRef};\n+use super::{FunctionCx, LocalRef};\n use super::constant::Const;\n use super::place::PlaceRef;\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n-impl<'a, 'tcx> MirContext<'a, 'tcx> {\n+impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n         let mut bx = self.build_block(bb);\n         let data = &self.mir[bb];"}, {"sha": "71ce0aa3da96b9db230f20a923a1b53d67792a7d", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e40a0d43640a5cf26f28cea35ec16445966a000/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e40a0d43640a5cf26f28cea35ec16445966a000/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=4e40a0d43640a5cf26f28cea35ec16445966a000", "patch": "@@ -43,7 +43,7 @@ use std::fmt;\n use std::ptr;\n \n use super::operand::{OperandRef, OperandValue};\n-use super::MirContext;\n+use super::FunctionCx;\n \n /// A sized constant rvalue.\n /// The LLVM type might not be the same for a single Rust type,\n@@ -1118,7 +1118,7 @@ unsafe fn cast_const_int_to_float(cx: &CodegenCx,\n     }\n }\n \n-impl<'a, 'tcx> MirContext<'a, 'tcx> {\n+impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     pub fn trans_constant(&mut self,\n                           bx: &Builder<'a, 'tcx>,\n                           constant: &mir::Constant<'tcx>)"}, {"sha": "ddd78f268fadb1e911b2027bd4e293fc6689f206", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4e40a0d43640a5cf26f28cea35ec16445966a000/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e40a0d43640a5cf26f28cea35ec16445966a000/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=4e40a0d43640a5cf26f28cea35ec16445966a000", "patch": "@@ -41,7 +41,7 @@ use rustc::mir::traversal;\n use self::operand::{OperandRef, OperandValue};\n \n /// Master context for translating MIR.\n-pub struct MirContext<'a, 'tcx:'a> {\n+pub struct FunctionCx<'a, 'tcx:'a> {\n     mir: &'a mir::Mir<'tcx>,\n \n     debug_context: debuginfo::FunctionDebugContext,\n@@ -102,7 +102,7 @@ pub struct MirContext<'a, 'tcx:'a> {\n     param_substs: &'tcx Substs<'tcx>,\n }\n \n-impl<'a, 'tcx> MirContext<'a, 'tcx> {\n+impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n         where T: TransNormalize<'tcx>\n     {\n@@ -224,7 +224,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n     let scopes = debuginfo::create_mir_scopes(cx, mir, &debug_context);\n     let (landing_pads, funclets) = create_funclets(&bx, &cleanup_kinds, &block_bxs);\n \n-    let mut mircx = MirContext {\n+    let mut fx = FunctionCx {\n         mir,\n         llfn,\n         fn_ty,\n@@ -244,20 +244,20 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n         },\n     };\n \n-    let memory_locals = analyze::memory_locals(&mircx);\n+    let memory_locals = analyze::memory_locals(&fx);\n \n     // Allocate variable and temp allocas\n-    mircx.locals = {\n-        let args = arg_local_refs(&bx, &mircx, &mircx.scopes, &memory_locals);\n+    fx.locals = {\n+        let args = arg_local_refs(&bx, &fx, &fx.scopes, &memory_locals);\n \n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n-            let layout = bx.cx.layout_of(mircx.monomorphize(&decl.ty));\n+            let layout = bx.cx.layout_of(fx.monomorphize(&decl.ty));\n             assert!(!layout.ty.has_erasable_regions());\n \n             if let Some(name) = decl.name {\n                 // User variable\n-                let debug_scope = mircx.scopes[decl.source_info.scope];\n+                let debug_scope = fx.scopes[decl.source_info.scope];\n                 let dbg = debug_scope.is_valid() && bx.sess().opts.debuginfo == FullDebugInfo;\n \n                 if !memory_locals.contains(local.index()) && !dbg {\n@@ -268,15 +268,15 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                 debug!(\"alloc: {:?} ({}) -> place\", local, name);\n                 let place = PlaceRef::alloca(&bx, layout, &name.as_str());\n                 if dbg {\n-                    let (scope, span) = mircx.debug_loc(decl.source_info);\n-                    declare_local(&bx, &mircx.debug_context, name, layout.ty, scope,\n+                    let (scope, span) = fx.debug_loc(decl.source_info);\n+                    declare_local(&bx, &fx.debug_context, name, layout.ty, scope,\n                         VariableAccess::DirectVariable { alloca: place.llval },\n                         VariableKind::LocalVariable, span);\n                 }\n                 LocalRef::Place(place)\n             } else {\n                 // Temporary or return place\n-                if local == mir::RETURN_PLACE && mircx.fn_ty.ret.is_indirect() {\n+                if local == mir::RETURN_PLACE && fx.fn_ty.ret.is_indirect() {\n                     debug!(\"alloc: {:?} (return place) -> place\", local);\n                     let llretptr = llvm::get_param(llfn, 0);\n                     LocalRef::Place(PlaceRef::new_sized(llretptr, layout, layout.align))\n@@ -302,21 +302,21 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n \n     // Branch to the START block, if it's not the entry block.\n     if reentrant_start_block {\n-        bx.br(mircx.blocks[mir::START_BLOCK]);\n+        bx.br(fx.blocks[mir::START_BLOCK]);\n     }\n \n     // Up until here, IR instructions for this function have explicitly not been annotated with\n     // source code location, so we don't step into call setup code. From here on, source location\n     // emitting should be enabled.\n-    debuginfo::start_emitting_source_locations(&mircx.debug_context);\n+    debuginfo::start_emitting_source_locations(&fx.debug_context);\n \n     let rpo = traversal::reverse_postorder(&mir);\n     let mut visited = BitVector::new(mir.basic_blocks().len());\n \n     // Translate the body of each block using reverse postorder\n     for (bb, _) in rpo {\n         visited.insert(bb.index());\n-        mircx.trans_block(bb);\n+        fx.trans_block(bb);\n     }\n \n     // Remove blocks that haven't been visited, or have no\n@@ -326,7 +326,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n         if !visited.contains(bb.index()) {\n             debug!(\"trans_mir: block {:?} was not visited\", bb);\n             unsafe {\n-                llvm::LLVMDeleteBasicBlock(mircx.blocks[bb]);\n+                llvm::LLVMDeleteBasicBlock(fx.blocks[bb]);\n             }\n         }\n     }\n@@ -356,14 +356,14 @@ fn create_funclets<'a, 'tcx>(\n /// argument's value. As arguments are places, these are always\n /// indirect.\n fn arg_local_refs<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n-                            mircx: &MirContext<'a, 'tcx>,\n+                            fx: &FunctionCx<'a, 'tcx>,\n                             scopes: &IndexVec<mir::VisibilityScope, debuginfo::MirDebugScope>,\n                             memory_locals: &BitVector)\n                             -> Vec<LocalRef<'tcx>> {\n-    let mir = mircx.mir;\n+    let mir = fx.mir;\n     let tcx = bx.tcx();\n     let mut idx = 0;\n-    let mut llarg_idx = mircx.fn_ty.ret.is_indirect() as usize;\n+    let mut llarg_idx = fx.fn_ty.ret.is_indirect() as usize;\n \n     // Get the argument scope, if it exists and if we need it.\n     let arg_scope = scopes[mir::ARGUMENT_VISIBILITY_SCOPE];\n@@ -392,15 +392,15 @@ fn arg_local_refs<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n             // to reconstruct it into a tuple local variable, from multiple\n             // individual LLVM function arguments.\n \n-            let arg_ty = mircx.monomorphize(&arg_decl.ty);\n+            let arg_ty = fx.monomorphize(&arg_decl.ty);\n             let tupled_arg_tys = match arg_ty.sty {\n                 ty::TyTuple(ref tys, _) => tys,\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n             let place = PlaceRef::alloca(bx, bx.cx.layout_of(arg_ty), &name);\n             for i in 0..tupled_arg_tys.len() {\n-                let arg = &mircx.fn_ty.args[idx];\n+                let arg = &fx.fn_ty.args[idx];\n                 idx += 1;\n                 arg.store_fn_arg(bx, &mut llarg_idx, place.project_field(bx, i));\n             }\n@@ -413,7 +413,7 @@ fn arg_local_refs<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                 };\n                 declare_local(\n                     bx,\n-                    &mircx.debug_context,\n+                    &fx.debug_context,\n                     arg_decl.name.unwrap_or(keywords::Invalid.name()),\n                     arg_ty, scope,\n                     variable_access,\n@@ -425,7 +425,7 @@ fn arg_local_refs<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n             return LocalRef::Place(place);\n         }\n \n-        let arg = &mircx.fn_ty.args[idx];\n+        let arg = &fx.fn_ty.args[idx];\n         idx += 1;\n         if arg.pad.is_some() {\n             llarg_idx += 1;\n@@ -499,7 +499,7 @@ fn arg_local_refs<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n \n                 declare_local(\n                     bx,\n-                    &mircx.debug_context,\n+                    &fx.debug_context,\n                     arg_decl.name.unwrap_or(keywords::Invalid.name()),\n                     arg.layout.ty,\n                     scope,\n@@ -568,7 +568,7 @@ fn arg_local_refs<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                 };\n                 declare_local(\n                     bx,\n-                    &mircx.debug_context,\n+                    &fx.debug_context,\n                     decl.debug_name,\n                     ty,\n                     scope,"}, {"sha": "25db9f9b4c8a80c4c07273a06f65e1839dd5a70c", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e40a0d43640a5cf26f28cea35ec16445966a000/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e40a0d43640a5cf26f28cea35ec16445966a000/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=4e40a0d43640a5cf26f28cea35ec16445966a000", "patch": "@@ -24,7 +24,7 @@ use type_::Type;\n use std::fmt;\n use std::ptr;\n \n-use super::{MirContext, LocalRef};\n+use super::{FunctionCx, LocalRef};\n use super::place::PlaceRef;\n \n /// The representation of a Rust value. The enum variant is in fact\n@@ -241,7 +241,7 @@ impl<'a, 'tcx> OperandValue {\n     }\n }\n \n-impl<'a, 'tcx> MirContext<'a, 'tcx> {\n+impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     fn maybe_trans_consume_direct(&mut self,\n                                   bx: &Builder<'a, 'tcx>,\n                                   place: &mir::Place<'tcx>)"}, {"sha": "99770476e12f9233a264bf47fe7a72fc054e6d8d", "filename": "src/librustc_trans/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e40a0d43640a5cf26f28cea35ec16445966a000/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e40a0d43640a5cf26f28cea35ec16445966a000/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fplace.rs?ref=4e40a0d43640a5cf26f28cea35ec16445966a000", "patch": "@@ -25,7 +25,7 @@ use glue;\n \n use std::ptr;\n \n-use super::{MirContext, LocalRef};\n+use super::{FunctionCx, LocalRef};\n use super::operand::{OperandRef, OperandValue};\n \n #[derive(Copy, Clone, Debug)]\n@@ -399,7 +399,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> MirContext<'a, 'tcx> {\n+impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     pub fn trans_place(&mut self,\n                         bx: &Builder<'a, 'tcx>,\n                         place: &mir::Place<'tcx>)"}, {"sha": "d1bc4fe90014ce9a9638886bd54bca1ea817b06d", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e40a0d43640a5cf26f28cea35ec16445966a000/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e40a0d43640a5cf26f28cea35ec16445966a000/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=4e40a0d43640a5cf26f28cea35ec16445966a000", "patch": "@@ -29,12 +29,12 @@ use type_::Type;\n use type_of::LayoutLlvmExt;\n use value::Value;\n \n-use super::{MirContext, LocalRef};\n+use super::{FunctionCx, LocalRef};\n use super::constant::const_scalar_checked_binop;\n use super::operand::{OperandRef, OperandValue};\n use super::place::PlaceRef;\n \n-impl<'a, 'tcx> MirContext<'a, 'tcx> {\n+impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n                         bx: Builder<'a, 'tcx>,\n                         dest: PlaceRef<'tcx>,"}, {"sha": "b5b7484940192a9e82d24ea0d00c8c855ee4f030", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e40a0d43640a5cf26f28cea35ec16445966a000/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e40a0d43640a5cf26f28cea35ec16445966a000/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=4e40a0d43640a5cf26f28cea35ec16445966a000", "patch": "@@ -13,10 +13,10 @@ use rustc::mir;\n use asm;\n use builder::Builder;\n \n-use super::MirContext;\n+use super::FunctionCx;\n use super::LocalRef;\n \n-impl<'a, 'tcx> MirContext<'a, 'tcx> {\n+impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     pub fn trans_statement(&mut self,\n                            bx: Builder<'a, 'tcx>,\n                            statement: &mir::Statement<'tcx>)"}]}