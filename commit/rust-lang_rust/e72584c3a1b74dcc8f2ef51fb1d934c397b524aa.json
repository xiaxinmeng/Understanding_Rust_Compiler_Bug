{"sha": "e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MjU4NGMzYTFiNzRkY2M4ZjJlZjUxZmIxZDkzNGMzOTdiNTI0YWE=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-02-26T10:04:58Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-03-01T10:18:49Z"}, "message": "hir: remove NodeId from TraitItem", "tree": {"sha": "3806aa9e86f05debe0d150183ddf56d639b19f22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3806aa9e86f05debe0d150183ddf56d639b19f22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "html_url": "https://github.com/rust-lang/rust/commit/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43294c6c8c03780d44a5f27bbbb4e6e0c72add66", "url": "https://api.github.com/repos/rust-lang/rust/commits/43294c6c8c03780d44a5f27bbbb4e6e0c72add66", "html_url": "https://github.com/rust-lang/rust/commit/43294c6c8c03780d44a5f27bbbb4e6e0c72add66"}], "stats": {"total": 297, "additions": 149, "deletions": 148}, "files": [{"sha": "3add88c05e759fcb595d858e2a89c846a3421a88", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -3351,7 +3351,6 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         hir::TraitItem {\n-            id: node_id,\n             hir_id,\n             ident: i.ident,\n             attrs: self.lower_attrs(&i.attrs),"}, {"sha": "cf48e9cab63c38f988992b5f5033c5fd5c4d20d4", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -386,7 +386,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_trait_item(&mut self, ti: &'hir TraitItem) {\n         debug_assert_eq!(ti.hir_id.owner,\n-                         self.definitions.opt_def_index(ti.id).unwrap());\n+                         self.definitions.opt_def_index(self.hir_to_node_id[&ti.hir_id]).unwrap());\n         self.with_dep_node_owner(ti.hir_id.owner, ti, |this| {\n             this.insert(ti.span, ti.hir_id, Node::TraitItem(ti));\n "}, {"sha": "05180f3085675d7702ef1eb499143775c3383f4c", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -349,7 +349,7 @@ impl<'hir> Map<'hir> {\n                 }\n             }\n             Node::TraitItem(item) => {\n-                let def_id = self.local_def_id(item.id);\n+                let def_id = self.local_def_id_from_hir_id(item.hir_id);\n                 match item.node {\n                     TraitItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n                     TraitItemKind::Method(..) => Some(Def::Method(def_id)),"}, {"sha": "486372248c51b952630f32b5729c9ba24248c87d", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -1668,7 +1668,6 @@ pub struct TraitItemId {\n /// signature) or provided (meaning it has a default implementation).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct TraitItem {\n-    pub id: NodeId,\n     pub ident: Ident,\n     pub hir_id: HirId,\n     pub attrs: HirVec<Attribute>,"}, {"sha": "28e9403e9dba2313a1606da3bf40a903ed84b82f", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -25,7 +25,7 @@ pub enum AnnNode<'a> {\n     Name(&'a ast::Name),\n     Block(&'a hir::Block),\n     Item(&'a hir::Item),\n-    SubItem(ast::NodeId),\n+    SubItem(hir::HirId),\n     Expr(&'a hir::Expr),\n     Pat(&'a hir::Pat),\n }\n@@ -927,7 +927,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_trait_item(&mut self, ti: &hir::TraitItem) -> io::Result<()> {\n-        self.ann.pre(self, AnnNode::SubItem(ti.id))?;\n+        self.ann.pre(self, AnnNode::SubItem(ti.hir_id))?;\n         self.hardbreak_if_not_bol()?;\n         self.maybe_print_comment(ti.span.lo())?;\n         self.print_outer_attributes(&ti.attrs)?;\n@@ -959,11 +959,11 @@ impl<'a> State<'a> {\n                                            default.as_ref().map(|ty| &**ty))?;\n             }\n         }\n-        self.ann.post(self, AnnNode::SubItem(ti.id))\n+        self.ann.post(self, AnnNode::SubItem(ti.hir_id))\n     }\n \n     pub fn print_impl_item(&mut self, ii: &hir::ImplItem) -> io::Result<()> {\n-        self.ann.pre(self, AnnNode::SubItem(ii.id))?;\n+        self.ann.pre(self, AnnNode::SubItem(ii.hir_id))?;\n         self.hardbreak_if_not_bol()?;\n         self.maybe_print_comment(ii.span.lo())?;\n         self.print_outer_attributes(&ii.attrs)?;\n@@ -989,7 +989,7 @@ impl<'a> State<'a> {\n                 self.print_associated_type(ii.ident, Some(bounds), None)?;\n             }\n         }\n-        self.ann.post(self, AnnNode::SubItem(ii.id))\n+        self.ann.post(self, AnnNode::SubItem(ii.hir_id))\n     }\n \n     pub fn print_stmt(&mut self, st: &hir::Stmt) -> io::Result<()> {"}, {"sha": "0a53bdeae842699f08892b1e6a4da8bcf938762d", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -669,7 +669,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItem {\n-            id: _,\n             hir_id: _,\n             ident,\n             ref attrs,"}, {"sha": "a856bfbfd7ee686a766c0d3849dbb6b4242410f3", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -793,11 +793,11 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n         run_lints!(self, exit_lint_attrs, attrs);\n     }\n \n-    fn with_param_env<F>(&mut self, id: ast::NodeId, f: F)\n+    fn with_param_env<F>(&mut self, id: hir::HirId, f: F)\n         where F: FnOnce(&mut Self),\n     {\n         let old_param_env = self.param_env;\n-        self.param_env = self.tcx.param_env(self.tcx.hir().local_def_id(id));\n+        self.param_env = self.tcx.param_env(self.tcx.hir().local_def_id_from_hir_id(id));\n         f(self);\n         self.param_env = old_param_env;\n     }\n@@ -841,7 +841,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         let generics = self.generics.take();\n         self.generics = it.node.generics();\n         self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n-            cx.with_param_env(it.id, |cx| {\n+            cx.with_param_env(it.hir_id, |cx| {\n                 run_lints!(cx, check_item, it);\n                 hir_visit::walk_item(cx, it);\n                 run_lints!(cx, check_item_post, it);\n@@ -852,7 +852,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem) {\n         self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n-            cx.with_param_env(it.id, |cx| {\n+            cx.with_param_env(it.hir_id, |cx| {\n                 run_lints!(cx, check_foreign_item, it);\n                 hir_visit::walk_foreign_item(cx, it);\n                 run_lints!(cx, check_foreign_item_post, it);\n@@ -983,7 +983,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         let generics = self.generics.take();\n         self.generics = Some(&trait_item.generics);\n         self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |cx| {\n-            cx.with_param_env(trait_item.id, |cx| {\n+            cx.with_param_env(trait_item.hir_id, |cx| {\n                 run_lints!(cx, check_trait_item, trait_item);\n                 hir_visit::walk_trait_item(cx, trait_item);\n                 run_lints!(cx, check_trait_item_post, trait_item);\n@@ -996,7 +996,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         let generics = self.generics.take();\n         self.generics = Some(&impl_item.generics);\n         self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |cx| {\n-            cx.with_param_env(impl_item.id, |cx| {\n+            cx.with_param_env(impl_item.hir_id, |cx| {\n                 run_lints!(cx, check_impl_item, impl_item);\n                 hir_visit::walk_impl_item(cx, impl_item);\n                 run_lints!(cx, check_impl_item_post, impl_item);"}, {"sha": "dd44e19bc7df9c371b84f3065ed2dac6986ca117", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -781,7 +781,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             Method(ref sig, _) => {\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n-                    Some(tcx.hir().get_parent(trait_item.id)),\n+                    Some(tcx.hir().get_parent_item(trait_item.hir_id)),\n                     &sig.decl,\n                     &trait_item.generics,\n                     |this| intravisit::walk_trait_item(this, trait_item),\n@@ -833,7 +833,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             Method(ref sig, _) => {\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n-                    Some(tcx.hir().get_parent(impl_item.id)),\n+                    Some(tcx.hir().get_parent_item(impl_item.hir_id)),\n                     &sig.decl,\n                     &impl_item.generics,\n                     |this| intravisit::walk_impl_item(this, impl_item),\n@@ -1685,7 +1685,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// ordering is not important there.\n     fn visit_early_late<F>(\n         &mut self,\n-        parent_id: Option<ast::NodeId>,\n+        parent_id: Option<hir::HirId>,\n         decl: &'tcx hir::FnDecl,\n         generics: &'tcx hir::Generics,\n         walk: F,\n@@ -1697,7 +1697,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // Find the start of nested early scopes, e.g., in methods.\n         let mut index = 0;\n         if let Some(parent_id) = parent_id {\n-            let parent = self.tcx.hir().expect_item(parent_id);\n+            let parent = self.tcx.hir().expect_item_by_hir_id(parent_id);\n             if sub_items_have_self_param(&parent.node) {\n                 index += 1; // Self comes before lifetimes\n             }"}, {"sha": "c495268154664ee7a4987030b5c5b87cc6f856aa", "filename": "src/librustc_codegen_utils/symbol_names_test.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -6,7 +6,6 @@\n \n use rustc::hir;\n use rustc::ty::TyCtxt;\n-use syntax::ast;\n \n use rustc_mir::monomorphize::Instance;\n \n@@ -33,9 +32,9 @@ struct SymbolNamesTest<'a, 'tcx:'a> {\n \n impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n     fn process_attrs(&mut self,\n-                     node_id: ast::NodeId) {\n+                     hir_id: hir::HirId) {\n         let tcx = self.tcx;\n-        let def_id = tcx.hir().local_def_id(node_id);\n+        let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n         for attr in tcx.get_attrs(def_id).iter() {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n@@ -56,14 +55,14 @@ impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n \n impl<'a, 'tcx> hir::itemlikevisit::ItemLikeVisitor<'tcx> for SymbolNamesTest<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        self.process_attrs(item.id);\n+        self.process_attrs(item.hir_id);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        self.process_attrs(trait_item.id);\n+        self.process_attrs(trait_item.hir_id);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        self.process_attrs(impl_item.id);\n+        self.process_attrs(impl_item.hir_id);\n     }\n }"}, {"sha": "1f69d617c83b71949f40dcfc468e24a64d62fb0a", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -69,7 +69,7 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n             let mut visitor = IfThisChanged { tcx,\n                                             if_this_changed: vec![],\n                                             then_this_would_need: vec![] };\n-            visitor.process_attrs(ast::CRATE_NODE_ID, &tcx.hir().krate().attrs);\n+            visitor.process_attrs(hir::CRATE_HIR_ID, &tcx.hir().krate().attrs);\n             tcx.hir().krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n             (visitor.if_this_changed, visitor.then_this_would_need)\n         };\n@@ -87,7 +87,7 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n }\n \n type Sources = Vec<(Span, DefId, DepNode)>;\n-type Targets = Vec<(Span, ast::Name, ast::NodeId, DepNode)>;\n+type Targets = Vec<(Span, ast::Name, hir::HirId, DepNode)>;\n \n struct IfThisChanged<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -110,8 +110,8 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n         value\n     }\n \n-    fn process_attrs(&mut self, node_id: ast::NodeId, attrs: &[ast::Attribute]) {\n-        let def_id = self.tcx.hir().local_def_id(node_id);\n+    fn process_attrs(&mut self, hir_id: hir::HirId, attrs: &[ast::Attribute]) {\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(hir_id);\n         let def_path_hash = self.tcx.def_path_hash(def_id);\n         for attr in attrs {\n             if attr.check_name(ATTR_IF_THIS_CHANGED) {\n@@ -151,7 +151,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                 };\n                 self.then_this_would_need.push((attr.span,\n                                                 dep_node_interned.unwrap(),\n-                                                node_id,\n+                                                hir_id,\n                                                 dep_node));\n             }\n         }\n@@ -164,22 +164,22 @@ impl<'a, 'tcx> Visitor<'tcx> for IfThisChanged<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        self.process_attrs(item.id, &item.attrs);\n+        self.process_attrs(item.hir_id, &item.attrs);\n         intravisit::walk_item(self, item);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        self.process_attrs(trait_item.id, &trait_item.attrs);\n+        self.process_attrs(trait_item.hir_id, &trait_item.attrs);\n         intravisit::walk_trait_item(self, trait_item);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        self.process_attrs(impl_item.id, &impl_item.attrs);\n+        self.process_attrs(impl_item.hir_id, &impl_item.attrs);\n         intravisit::walk_impl_item(self, impl_item);\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n-        self.process_attrs(s.id, &s.attrs);\n+        self.process_attrs(s.hir_id, &s.attrs);\n         intravisit::walk_struct_field(self, s);\n     }\n }"}, {"sha": "2794b6c556ff24652aa081903f5f0fdbac9a67c7", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -241,7 +241,7 @@ pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n \n     /// Possibly \"deserialize\" the attribute into a clean/dirty assertion\n-    fn assertion_maybe(&mut self, item_id: ast::NodeId, attr: &Attribute)\n+    fn assertion_maybe(&mut self, item_id: hir::HirId, attr: &Attribute)\n         -> Option<Assertion>\n     {\n         let is_clean = if attr.check_name(ATTR_DIRTY) {\n@@ -269,7 +269,7 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n     }\n \n     /// Gets the \"auto\" assertion on pre-validated attr, along with the `except` labels.\n-    fn assertion_auto(&mut self, item_id: ast::NodeId, attr: &Attribute, is_clean: bool)\n+    fn assertion_auto(&mut self, item_id: hir::HirId, attr: &Attribute, is_clean: bool)\n         -> Assertion\n     {\n         let (name, mut auto) = self.auto_labels(item_id, attr);\n@@ -321,8 +321,8 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n \n     /// Return all DepNode labels that should be asserted for this item.\n     /// index=0 is the \"name\" used for error messages\n-    fn auto_labels(&mut self, item_id: ast::NodeId, attr: &Attribute) -> (&'static str, Labels) {\n-        let node = self.tcx.hir().get(item_id);\n+    fn auto_labels(&mut self, item_id: hir::HirId, attr: &Attribute) -> (&'static str, Labels) {\n+        let node = self.tcx.hir().get_by_hir_id(item_id);\n         let (name, labels) = match node {\n             HirNode::Item(item) => {\n                 match item.node {\n@@ -499,8 +499,8 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_item(&mut self, item_id: ast::NodeId, item_span: Span) {\n-        let def_id = self.tcx.hir().local_def_id(item_id);\n+    fn check_item(&mut self, item_id: hir::HirId, item_span: Span) {\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(item_id);\n         for attr in self.tcx.get_attrs(def_id).iter() {\n             let assertion = match self.assertion_maybe(item_id, attr) {\n                 Some(a) => a,\n@@ -519,15 +519,15 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        self.check_item(item.id, item.span);\n+        self.check_item(item.hir_id, item.span);\n     }\n \n     fn visit_trait_item(&mut self, item: &hir::TraitItem) {\n-        self.check_item(item.id, item.span);\n+        self.check_item(item.hir_id, item.span);\n     }\n \n     fn visit_impl_item(&mut self, item: &hir::ImplItem) {\n-        self.check_item(item.id, item.span);\n+        self.check_item(item.hir_id, item.span);\n     }\n }\n "}, {"sha": "c9cbffbaefe9dd7ed72f486f65f0b00cd72e9d29", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -324,7 +324,7 @@ pub struct MissingDoc {\n     doc_hidden_stack: Vec<bool>,\n \n     /// Private traits or trait items that leaked through. Don't check their methods.\n-    private_traits: FxHashSet<ast::NodeId>,\n+    private_traits: FxHashSet<hir::HirId>,\n }\n \n fn has_doc(attr: &ast::Attribute) -> bool {\n@@ -361,7 +361,7 @@ impl MissingDoc {\n \n     fn check_missing_docs_attrs(&self,\n                                 cx: &LateContext<'_, '_>,\n-                                id: Option<ast::NodeId>,\n+                                id: Option<hir::HirId>,\n                                 attrs: &[ast::Attribute],\n                                 sp: Span,\n                                 desc: &'static str) {\n@@ -380,7 +380,8 @@ impl MissingDoc {\n         // It's an option so the crate root can also use this function (it doesn't\n         // have a NodeId).\n         if let Some(id) = id {\n-            if !cx.access_levels.is_exported(id) {\n+            let node_id = cx.tcx.hir().hir_to_node_id(id);\n+            if !cx.access_levels.is_exported(node_id) {\n                 return;\n             }\n         }\n@@ -444,9 +445,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 // Issue #11592, traits are always considered exported, even when private.\n                 if let hir::VisibilityKind::Inherited = it.vis.node {\n-                    self.private_traits.insert(it.id);\n+                    self.private_traits.insert(it.hir_id);\n                     for trait_item_ref in trait_item_refs {\n-                        self.private_traits.insert(trait_item_ref.id.node_id);\n+                        let hir_id = cx.tcx.hir().node_to_hir_id(trait_item_ref.id.node_id);\n+                        self.private_traits.insert(hir_id);\n                     }\n                     return;\n                 }\n@@ -462,7 +464,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                         Some(Node::Item(item)) => {\n                             if let hir::VisibilityKind::Inherited = item.vis.node {\n                                 for impl_item_ref in impl_item_refs {\n-                                    self.private_traits.insert(impl_item_ref.id.node_id);\n+                                    let hir_id = cx.tcx.hir().node_to_hir_id(\n+                                        impl_item_ref.id.node_id);\n+                                    self.private_traits.insert(hir_id);\n                                 }\n                             }\n                         }\n@@ -476,11 +480,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             _ => return,\n         };\n \n-        self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs, it.span, desc);\n+        self.check_missing_docs_attrs(cx, Some(it.hir_id), &it.attrs, it.span, desc);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, trait_item: &hir::TraitItem) {\n-        if self.private_traits.contains(&trait_item.id) {\n+        if self.private_traits.contains(&trait_item.hir_id) {\n             return;\n         }\n \n@@ -491,7 +495,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         };\n \n         self.check_missing_docs_attrs(cx,\n-                                      Some(trait_item.id),\n+                                      Some(trait_item.hir_id),\n                                       &trait_item.attrs,\n                                       trait_item.span,\n                                       desc);\n@@ -510,7 +514,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ImplItemKind::Existential(_) => \"an associated existential type\",\n         };\n         self.check_missing_docs_attrs(cx,\n-                                      Some(impl_item.id),\n+                                      Some(impl_item.hir_id),\n                                       &impl_item.attrs,\n                                       impl_item.span,\n                                       desc);\n@@ -519,7 +523,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n     fn check_struct_field(&mut self, cx: &LateContext<'_, '_>, sf: &hir::StructField) {\n         if !sf.is_positional() {\n             self.check_missing_docs_attrs(cx,\n-                                          Some(sf.id),\n+                                          Some(sf.hir_id),\n                                           &sf.attrs,\n                                           sf.span,\n                                           \"a struct field\")\n@@ -528,7 +532,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n \n     fn check_variant(&mut self, cx: &LateContext<'_, '_>, v: &hir::Variant, _: &hir::Generics) {\n         self.check_missing_docs_attrs(cx,\n-                                      Some(v.node.data.id()),\n+                                      Some(v.node.data.hir_id()),\n                                       &v.node.attrs,\n                                       v.span,\n                                       \"a variant\");"}, {"sha": "bf6d6e1ba7396e557cd6a6bdc1048c0353cd08c5", "filename": "src/librustc_mir/lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_mir%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_mir%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flints.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -130,7 +130,7 @@ fn check_fn_for_unconditional_recursion(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // recurs.\n     if !reached_exit_without_self_call && !self_call_locations.is_empty() {\n         let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n-        let sp = tcx.sess.source_map().def_span(tcx.hir().span(node_id));\n+        let sp = tcx.sess.source_map().def_span(tcx.hir().span_by_hir_id(hir_id));\n         let mut db = tcx.struct_span_lint_node(UNCONDITIONAL_RECURSION,\n                                                 node_id,\n                                                 sp,"}, {"sha": "93305797eef05ab29b4af1e4b41f61df48fc6c6c", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -290,10 +290,10 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n // Set the correct `TypeckTables` for the given `item_id` (or an empty table if\n // there is no `TypeckTables` for the item).\n fn item_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         node_id: ast::NodeId,\n+                         hir_id: hir::HirId,\n                          empty_tables: &'a ty::TypeckTables<'tcx>)\n                          -> &'a ty::TypeckTables<'tcx> {\n-    let def_id = tcx.hir().local_def_id(node_id);\n+    let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n     if tcx.has_typeck_tables(def_id) { tcx.typeck_tables_of(def_id) } else { empty_tables }\n }\n \n@@ -841,22 +841,22 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let orig_current_item = mem::replace(&mut self.current_item, item.id);\n         let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, item.id, self.empty_tables));\n+            mem::replace(&mut self.tables, item_tables(self.tcx, item.hir_id, self.empty_tables));\n         intravisit::walk_item(self, item);\n         self.current_item = orig_current_item;\n         self.tables = orig_tables;\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n         let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, ti.id, self.empty_tables));\n+            mem::replace(&mut self.tables, item_tables(self.tcx, ti.hir_id, self.empty_tables));\n         intravisit::walk_trait_item(self, ti);\n         self.tables = orig_tables;\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n         let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, ii.id, self.empty_tables));\n+            mem::replace(&mut self.tables, item_tables(self.tcx, ii.hir_id, self.empty_tables));\n         intravisit::walk_impl_item(self, ii);\n         self.tables = orig_tables;\n     }\n@@ -1114,7 +1114,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             mem::replace(&mut self.current_item, self.tcx.hir().local_def_id(item.id));\n         let orig_in_body = mem::replace(&mut self.in_body, false);\n         let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, item.id, self.empty_tables));\n+            mem::replace(&mut self.tables, item_tables(self.tcx, item.hir_id, self.empty_tables));\n         intravisit::walk_item(self, item);\n         self.tables = orig_tables;\n         self.in_body = orig_in_body;\n@@ -1123,14 +1123,14 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n         let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, ti.id, self.empty_tables));\n+            mem::replace(&mut self.tables, item_tables(self.tcx, ti.hir_id, self.empty_tables));\n         intravisit::walk_trait_item(self, ti);\n         self.tables = orig_tables;\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n         let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, ii.id, self.empty_tables));\n+            mem::replace(&mut self.tables, item_tables(self.tcx, ii.hir_id, self.empty_tables));\n         intravisit::walk_impl_item(self, ii);\n         self.tables = orig_tables;\n     }\n@@ -1495,7 +1495,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    item_id: ast::NodeId,\n+    item_id: hir::HirId,\n     item_def_id: DefId,\n     span: Span,\n     /// The visitor checks that each component type is at least this visible.\n@@ -1548,8 +1548,8 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n \n         }\n \n-        let node_id = match self.tcx.hir().as_local_node_id(def_id) {\n-            Some(node_id) => node_id,\n+        let hir_id = match self.tcx.hir().as_local_hir_id(def_id) {\n+            Some(hir_id) => hir_id,\n             None => return false,\n         };\n \n@@ -1604,20 +1604,20 @@ struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n-    fn check(&self, item_id: ast::NodeId, required_visibility: ty::Visibility)\n+    fn check(&self, item_id: hir::HirId, required_visibility: ty::Visibility)\n              -> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n         let mut has_old_errors = false;\n \n         // Slow path taken only if there any errors in the crate.\n         for &id in self.old_error_set {\n             // Walk up the nodes until we find `item_id` (or we hit a root).\n-            let mut id = self.tcx.hir().hir_to_node_id(id);\n+            let mut id = id;\n             loop {\n                 if id == item_id {\n                     has_old_errors = true;\n                     break;\n                 }\n-                let parent = self.tcx.hir().get_parent_node(id);\n+                let parent = self.tcx.hir().get_parent_node_by_hir_id(id);\n                 if parent == id {\n                     break;\n                 }\n@@ -1632,8 +1632,8 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n         SearchInterfaceForPrivateItemsVisitor {\n             tcx: self.tcx,\n             item_id,\n-            item_def_id: self.tcx.hir().local_def_id(item_id),\n-            span: self.tcx.hir().span(item_id),\n+            item_def_id: self.tcx.hir().local_def_id_from_hir_id(item_id),\n+            span: self.tcx.hir().span_by_hir_id(item_id),\n             required_visibility,\n             has_pub_restricted: self.has_pub_restricted,\n             has_old_errors,\n@@ -1642,9 +1642,9 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_trait_or_impl_item(&self, node_id: ast::NodeId, assoc_item_kind: AssociatedItemKind,\n+    fn check_trait_or_impl_item(&self, hir_id: hir::HirId, assoc_item_kind: AssociatedItemKind,\n                                 defaultness: hir::Defaultness, vis: ty::Visibility) {\n-        let mut check = self.check(node_id, vis);\n+        let mut check = self.check(hir_id, vis);\n \n         let (check_ty, is_assoc_ty) = match assoc_item_kind {\n             AssociatedItemKind::Const | AssociatedItemKind::Method { .. } => (true, false),\n@@ -1682,48 +1682,49 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // Subitems of these items have inherited publicity.\n             hir::ItemKind::Const(..) | hir::ItemKind::Static(..) |\n             hir::ItemKind::Fn(..) | hir::ItemKind::Ty(..) => {\n-                self.check(item.id, item_visibility).generics().predicates().ty();\n+                self.check(item.hir_id, item_visibility).generics().predicates().ty();\n             }\n             hir::ItemKind::Existential(..) => {\n                 // `ty()` for existential types is the underlying type,\n                 // it's not a part of interface, so we skip it.\n-                self.check(item.id, item_visibility).generics().predicates();\n+                self.check(item.hir_id, item_visibility).generics().predicates();\n             }\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n-                self.check(item.id, item_visibility).generics().predicates();\n+                self.check(item.hir_id, item_visibility).generics().predicates();\n \n                 for trait_item_ref in trait_item_refs {\n-                    self.check_trait_or_impl_item(trait_item_ref.id.node_id, trait_item_ref.kind,\n+                    let hir_id = tcx.hir().node_to_hir_id(trait_item_ref.id.node_id);\n+                    self.check_trait_or_impl_item(hir_id, trait_item_ref.kind,\n                                                   trait_item_ref.defaultness, item_visibility);\n                 }\n             }\n             hir::ItemKind::TraitAlias(..) => {\n-                self.check(item.id, item_visibility).generics().predicates();\n+                self.check(item.hir_id, item_visibility).generics().predicates();\n             }\n             hir::ItemKind::Enum(ref def, _) => {\n-                self.check(item.id, item_visibility).generics().predicates();\n+                self.check(item.hir_id, item_visibility).generics().predicates();\n \n                 for variant in &def.variants {\n                     for field in variant.node.data.fields() {\n-                        self.check(field.id, item_visibility).ty();\n+                        self.check(field.hir_id, item_visibility).ty();\n                     }\n                 }\n             }\n             // Subitems of foreign modules have their own publicity.\n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     let vis = ty::Visibility::from_hir(&foreign_item.vis, item.id, tcx);\n-                    self.check(foreign_item.id, vis).generics().predicates().ty();\n+                    self.check(foreign_item.hir_id, vis).generics().predicates().ty();\n                 }\n             }\n             // Subitems of structs and unions have their own publicity.\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n-                self.check(item.id, item_visibility).generics().predicates();\n+                self.check(item.hir_id, item_visibility).generics().predicates();\n \n                 for field in struct_def.fields() {\n                     let field_visibility = ty::Visibility::from_hir(&field.vis, item.id, tcx);\n-                    self.check(field.id, min(item_visibility, field_visibility, tcx)).ty();\n+                    self.check(field.hir_id, min(item_visibility, field_visibility, tcx)).ty();\n                 }\n             }\n             // An inherent impl is public when its type is public\n@@ -1732,15 +1733,16 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // Subitems of trait impls have inherited publicity.\n             hir::ItemKind::Impl(.., ref trait_ref, _, ref impl_item_refs) => {\n                 let impl_vis = ty::Visibility::of_impl(item.id, tcx, &Default::default());\n-                self.check(item.id, impl_vis).generics().predicates();\n+                self.check(item.hir_id, impl_vis).generics().predicates();\n                 for impl_item_ref in impl_item_refs {\n                     let impl_item = tcx.hir().impl_item(impl_item_ref.id);\n                     let impl_item_vis = if trait_ref.is_none() {\n                         min(ty::Visibility::from_hir(&impl_item.vis, item.id, tcx), impl_vis, tcx)\n                     } else {\n                         impl_vis\n                     };\n-                    self.check_trait_or_impl_item(impl_item_ref.id.node_id, impl_item_ref.kind,\n+                    let hir_id = tcx.hir().node_to_hir_id(impl_item_ref.id.node_id);\n+                    self.check_trait_or_impl_item(hir_id, impl_item_ref.kind,\n                                                   impl_item_ref.defaultness, impl_item_vis);\n                 }\n             }"}, {"sha": "44883d438a1e52eddbe93a724df59185e8e1d3dd", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -612,8 +612,8 @@ struct ClauseDumper<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> ClauseDumper<'a, 'tcx> {\n-    fn process_attrs(&mut self, node_id: ast::NodeId, attrs: &[ast::Attribute]) {\n-        let def_id = self.tcx.hir().local_def_id(node_id);\n+    fn process_attrs(&mut self, hir_id: hir::HirId, attrs: &[ast::Attribute]) {\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(hir_id);\n         for attr in attrs {\n             let mut clauses = None;\n \n@@ -655,22 +655,22 @@ impl<'a, 'tcx> Visitor<'tcx> for ClauseDumper<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        self.process_attrs(item.id, &item.attrs);\n+        self.process_attrs(item.hir_id, &item.attrs);\n         intravisit::walk_item(self, item);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        self.process_attrs(trait_item.id, &trait_item.attrs);\n+        self.process_attrs(trait_item.hir_id, &trait_item.attrs);\n         intravisit::walk_trait_item(self, trait_item);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        self.process_attrs(impl_item.id, &impl_item.attrs);\n+        self.process_attrs(impl_item.hir_id, &impl_item.attrs);\n         intravisit::walk_impl_item(self, impl_item);\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n-        self.process_attrs(s.id, &s.attrs);\n+        self.process_attrs(s.hir_id, &s.attrs);\n         intravisit::walk_struct_field(self, s);\n     }\n }"}, {"sha": "154449a38f4e3212417ea7fe26c691625d0f5cd6", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -108,14 +108,14 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n             check_item_fn(tcx, item);\n         }\n         hir::ItemKind::Static(ref ty, ..) => {\n-            check_item_type(tcx, item.id, ty.span, false);\n+            check_item_type(tcx, item.hir_id, ty.span, false);\n         }\n         hir::ItemKind::Const(ref ty, ..) => {\n-            check_item_type(tcx, item.id, ty.span, false);\n+            check_item_type(tcx, item.hir_id, ty.span, false);\n         }\n         hir::ItemKind::ForeignMod(ref module) => for it in module.items.iter() {\n             if let hir::ForeignItemKind::Static(ref ty, ..) = it.node {\n-                check_item_type(tcx, it.id, ty.span, true);\n+                check_item_type(tcx, it.hir_id, ty.span, true);\n             }\n         },\n         hir::ItemKind::Struct(ref struct_def, ref ast_generics) => {\n@@ -157,7 +157,7 @@ pub fn check_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n         hir::TraitItemKind::Method(ref sig, _) => Some(sig),\n         _ => None\n     };\n-    check_associated_item(tcx, trait_item.id, trait_item.span, method_sig);\n+    check_associated_item(tcx, trait_item.hir_id, trait_item.span, method_sig);\n }\n \n pub fn check_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n@@ -168,18 +168,18 @@ pub fn check_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n         hir::ImplItemKind::Method(ref sig, _) => Some(sig),\n         _ => None\n     };\n-    check_associated_item(tcx, impl_item.id, impl_item.span, method_sig);\n+    check_associated_item(tcx, impl_item.hir_id, impl_item.span, method_sig);\n }\n \n fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   item_id: ast::NodeId,\n+                                   item_id: hir::HirId,\n                                    span: Span,\n                                    sig_if_method: Option<&hir::MethodSig>) {\n     debug!(\"check_associated_item: {:?}\", item_id);\n \n     let code = ObligationCauseCode::MiscObligation;\n     for_id(tcx, item_id, span).with_fcx(|fcx, tcx| {\n-        let item = fcx.tcx.associated_item(fcx.tcx.hir().local_def_id(item_id));\n+        let item = fcx.tcx.associated_item(fcx.tcx.hir().local_def_id_from_hir_id(item_id));\n \n         let (mut implied_bounds, self_ty) = match item.container {\n             ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n@@ -220,16 +220,15 @@ fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n fn for_item<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, item: &hir::Item)\n                             -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n-    for_id(tcx, item.id, item.span)\n+    for_id(tcx, item.hir_id, item.span)\n }\n \n-fn for_id<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, id: ast::NodeId, span: Span)\n+fn for_id<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, id: hir::HirId, span: Span)\n                           -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n-    let def_id = tcx.hir().local_def_id(id);\n-    let hir_id = tcx.hir().node_to_hir_id(id);\n+    let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     CheckWfFcxBuilder {\n         inherited: Inherited::build(tcx, def_id),\n-        id: hir_id,\n+        id,\n         span,\n         param_env: tcx.param_env(def_id),\n     }\n@@ -339,14 +338,14 @@ fn check_item_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n \n fn check_item_type<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    item_id: ast::NodeId,\n+    item_id: hir::HirId,\n     ty_span: Span,\n     allow_foreign_ty: bool,\n ) {\n     debug!(\"check_item_type: {:?}\", item_id);\n \n     for_id(tcx, item_id, ty_span).with_fcx(|fcx, gcx| {\n-        let ty = gcx.type_of(gcx.hir().local_def_id(item_id));\n+        let ty = gcx.type_of(gcx.hir().local_def_id_from_hir_id(item_id));\n         let item_ty = fcx.normalize_associated_types_in(ty_span, &ty);\n \n         let mut forbid_unsized = true;\n@@ -1025,7 +1024,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckTypeWellFormedVisitor<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         debug!(\"visit_trait_item: {:?}\", trait_item);\n-        let def_id = self.tcx.hir().local_def_id(trait_item.id);\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(trait_item.hir_id);\n         self.tcx.ensure().check_trait_item_well_formed(def_id);\n     }\n "}, {"sha": "3da090aed9c906c24d5475369843ca02b3cce1b8", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -34,7 +34,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CheckVisitor<'a, 'tcx> {\n             return;\n         }\n         if let hir::ItemKind::Use(ref path, _) = item.node {\n-            self.check_import(item.id, path.span);\n+            self.check_import(item.hir_id, path.span);\n         }\n     }\n "}, {"sha": "c11fed089139c687c817ec9dd974b181cad08d9e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -152,7 +152,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        convert_trait_item(self.tcx, trait_item.id);\n+        convert_trait_item(self.tcx, trait_item.hir_id);\n         intravisit::walk_trait_item(self, trait_item);\n     }\n \n@@ -479,9 +479,9 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n     }\n }\n \n-fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item_id: ast::NodeId) {\n-    let trait_item = tcx.hir().expect_trait_item(trait_item_id);\n-    let def_id = tcx.hir().local_def_id(trait_item.id);\n+fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item_id: hir::HirId) {\n+    let trait_item = tcx.hir().expect_trait_item_by_hir_id(trait_item_id);\n+    let def_id = tcx.hir().local_def_id_from_hir_id(trait_item.hir_id);\n     tcx.generics_of(def_id);\n \n     match trait_item.node {\n@@ -1493,7 +1493,7 @@ fn find_existential_constraints<'a, 'tcx>(\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem) {\n-            let def_id = self.tcx.hir().local_def_id(it.id);\n+            let def_id = self.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n             self.check(def_id);\n             intravisit::walk_trait_item(self, it);\n         }\n@@ -2063,7 +2063,8 @@ fn explicit_predicates_of<'a, 'tcx>(\n             };\n \n             let assoc_ty =\n-                tcx.mk_projection(tcx.hir().local_def_id(trait_item.id), self_trait_ref.substs);\n+                tcx.mk_projection(tcx.hir().local_def_id_from_hir_id(trait_item.hir_id),\n+                    self_trait_ref.substs);\n \n             let bounds = compute_bounds(\n                 &ItemCtxt::new(tcx, def_id),"}, {"sha": "d8d93b462a900b4328285b0594c0304636a83114", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -6,7 +6,6 @@\n use hir::def_id::DefId;\n use rustc::ty::subst::{UnpackedKind, SubstsRef};\n use rustc::ty::{self, Ty, TyCtxt};\n-use syntax::ast;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n@@ -72,31 +71,31 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n         match item.node {\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n-                self.visit_node_helper(item.id);\n+                self.visit_node_helper(item.hir_id);\n \n                 if let hir::VariantData::Tuple(..) = *struct_def {\n-                    self.visit_node_helper(struct_def.id());\n+                    self.visit_node_helper(struct_def.hir_id());\n                 }\n             }\n \n             hir::ItemKind::Enum(ref enum_def, _) => {\n-                self.visit_node_helper(item.id);\n+                self.visit_node_helper(item.hir_id);\n \n                 for variant in &enum_def.variants {\n                     if let hir::VariantData::Tuple(..) = variant.node.data {\n-                        self.visit_node_helper(variant.node.data.id());\n+                        self.visit_node_helper(variant.node.data.hir_id());\n                     }\n                 }\n             }\n \n             hir::ItemKind::Fn(..) => {\n-                self.visit_node_helper(item.id);\n+                self.visit_node_helper(item.hir_id);\n             }\n \n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     if let hir::ForeignItemKind::Fn(..) = foreign_item.node {\n-                        self.visit_node_helper(foreign_item.id);\n+                        self.visit_node_helper(foreign_item.hir_id);\n                     }\n                 }\n             }\n@@ -107,21 +106,21 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n         if let hir::TraitItemKind::Method(..) = trait_item.node {\n-            self.visit_node_helper(trait_item.id);\n+            self.visit_node_helper(trait_item.hir_id);\n         }\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n         if let hir::ImplItemKind::Method(..) = impl_item.node {\n-            self.visit_node_helper(impl_item.id);\n+            self.visit_node_helper(impl_item.hir_id);\n         }\n     }\n }\n \n impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n-    fn visit_node_helper(&mut self, id: ast::NodeId) {\n+    fn visit_node_helper(&mut self, id: hir::HirId) {\n         let tcx = self.terms_cx.tcx;\n-        let def_id = tcx.hir().local_def_id(id);\n+        let def_id = tcx.hir().local_def_id_from_hir_id(id);\n         self.build_constraints_for_item(def_id);\n     }\n \n@@ -138,7 +137,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             return;\n         }\n \n-        let id = tcx.hir().as_local_node_id(def_id).unwrap();\n+        let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let inferred_start = self.terms_cx.inferred_starts[&id];\n         let current_item = &CurrentItem { inferred_start };\n         match tcx.type_of(def_id).sty {\n@@ -356,7 +355,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             return;\n         }\n \n-        let (local, remote) = if let Some(id) = self.tcx().hir().as_local_node_id(def_id) {\n+        let (local, remote) = if let Some(id) = self.tcx().hir().as_local_hir_id(def_id) {\n             (Some(self.terms_cx.inferred_starts[&id]), None)\n         } else {\n             (None, Some(self.tcx().variances_of(def_id)))"}, {"sha": "cec33ba87dea46de47c7e912ac29657f6b274de6", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -83,7 +83,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n \n         let solutions = &self.solutions;\n         self.terms_cx.inferred_starts.iter().map(|(&id, &InferredIndex(start))| {\n-            let def_id = tcx.hir().local_def_id(id);\n+            let def_id = tcx.hir().local_def_id_from_hir_id(id);\n             let generics = tcx.generics_of(def_id);\n \n             let mut variances = solutions[start..start+generics.count()].to_vec();"}, {"sha": "e564a8658fcaba8a4fde306acfe1a25331b0d326", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -12,10 +12,9 @@\n use arena::TypedArena;\n use rustc::ty::{self, TyCtxt};\n use std::fmt;\n-use syntax::ast;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use crate::util::nodemap::NodeMap;\n+use crate::util::nodemap::HirIdMap;\n \n use self::VarianceTerm::*;\n \n@@ -55,11 +54,11 @@ pub struct TermsContext<'a, 'tcx: 'a> {\n     // For marker types, UnsafeCell, and other lang items where\n     // variance is hardcoded, records the item-id and the hardcoded\n     // variance.\n-    pub lang_items: Vec<(ast::NodeId, Vec<ty::Variance>)>,\n+    pub lang_items: Vec<(hir::HirId, Vec<ty::Variance>)>,\n \n     // Maps from the node id of an item to the first inferred index\n     // used for its type & region parameters.\n-    pub inferred_starts: NodeMap<InferredIndex>,\n+    pub inferred_starts: HirIdMap<InferredIndex>,\n \n     // Maps from an InferredIndex to the term for that variable.\n     pub inferred_terms: Vec<VarianceTermPtr<'a>>,\n@@ -86,7 +85,7 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n     terms_cx\n }\n \n-fn lang_items(tcx: TyCtxt<'_, '_, '_>) -> Vec<(ast::NodeId, Vec<ty::Variance>)> {\n+fn lang_items(tcx: TyCtxt<'_, '_, '_>) -> Vec<(hir::HirId, Vec<ty::Variance>)> {\n     let lang_items = tcx.lang_items();\n     let all = vec![\n         (lang_items.phantom_data(), vec![ty::Covariant]),\n@@ -96,14 +95,14 @@ fn lang_items(tcx: TyCtxt<'_, '_, '_>) -> Vec<(ast::NodeId, Vec<ty::Variance>)>\n     all.into_iter() // iterating over (Option<DefId>, Variance)\n        .filter(|&(ref d,_)| d.is_some())\n        .map(|(d, v)| (d.unwrap(), v)) // (DefId, Variance)\n-       .filter_map(|(d, v)| tcx.hir().as_local_node_id(d).map(|n| (n, v))) // (NodeId, Variance)\n+       .filter_map(|(d, v)| tcx.hir().as_local_hir_id(d).map(|n| (n, v))) // (HirId, Variance)\n        .collect()\n }\n \n impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n-    fn add_inferreds_for_item(&mut self, id: ast::NodeId) {\n+    fn add_inferreds_for_item(&mut self, id: hir::HirId) {\n         let tcx = self.tcx;\n-        let def_id = tcx.hir().local_def_id(id);\n+        let def_id = tcx.hir().local_def_id_from_hir_id(id);\n         let count = tcx.generics_of(def_id).count();\n \n         if count == 0 {\n@@ -134,31 +133,31 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n         match item.node {\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n-                self.add_inferreds_for_item(item.id);\n+                self.add_inferreds_for_item(item.hir_id);\n \n                 if let hir::VariantData::Tuple(..) = *struct_def {\n-                    self.add_inferreds_for_item(struct_def.id());\n+                    self.add_inferreds_for_item(struct_def.hir_id());\n                 }\n             }\n \n             hir::ItemKind::Enum(ref enum_def, _) => {\n-                self.add_inferreds_for_item(item.id);\n+                self.add_inferreds_for_item(item.hir_id);\n \n                 for variant in &enum_def.variants {\n                     if let hir::VariantData::Tuple(..) = variant.node.data {\n-                        self.add_inferreds_for_item(variant.node.data.id());\n+                        self.add_inferreds_for_item(variant.node.data.hir_id());\n                     }\n                 }\n             }\n \n             hir::ItemKind::Fn(..) => {\n-                self.add_inferreds_for_item(item.id);\n+                self.add_inferreds_for_item(item.hir_id);\n             }\n \n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     if let hir::ForeignItemKind::Fn(..) = foreign_item.node {\n-                        self.add_inferreds_for_item(foreign_item.id);\n+                        self.add_inferreds_for_item(foreign_item.hir_id);\n                     }\n                 }\n             }\n@@ -169,13 +168,13 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n         if let hir::TraitItemKind::Method(..) = trait_item.node {\n-            self.add_inferreds_for_item(trait_item.id);\n+            self.add_inferreds_for_item(trait_item.hir_id);\n         }\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n         if let hir::ImplItemKind::Method(..) = impl_item.node {\n-            self.add_inferreds_for_item(impl_item.id);\n+            self.add_inferreds_for_item(impl_item.hir_id);\n         }\n     }\n }"}, {"sha": "2be4fbe4d7c8f3080d63f0f72744fa50186fd240", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72584c3a1b74dcc8f2ef51fb1d934c397b524aa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e72584c3a1b74dcc8f2ef51fb1d934c397b524aa", "patch": "@@ -2022,14 +2022,15 @@ impl Clean<Item> for hir::TraitItem {\n                 AssociatedTypeItem(bounds.clean(cx), default.clean(cx))\n             }\n         };\n+        let local_did = cx.tcx.hir().local_def_id_from_hir_id(self.hir_id);\n         Item {\n             name: Some(self.ident.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id: local_did,\n             visibility: None,\n-            stability: get_stability(cx, cx.tcx.hir().local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.tcx.hir().local_def_id(self.id)),\n+            stability: get_stability(cx, local_did),\n+            deprecation: get_deprecation(cx, local_did),\n             inner,\n         }\n     }"}]}