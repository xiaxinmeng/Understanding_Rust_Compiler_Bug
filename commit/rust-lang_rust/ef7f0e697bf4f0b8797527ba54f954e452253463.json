{"sha": "ef7f0e697bf4f0b8797527ba54f954e452253463", "node_id": "C_kwDOAAsO6NoAKGVmN2YwZTY5N2JmNGYwYjg3OTc1MjdiYTU0Zjk1NGU0NTIyNTM0NjM", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2023-04-28T13:05:01Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2023-05-27T14:35:16Z"}, "message": "Rework handling of recursive panics", "tree": {"sha": "fc79f311e72bbd08615d16d74066289aaebe11ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc79f311e72bbd08615d16d74066289aaebe11ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef7f0e697bf4f0b8797527ba54f954e452253463", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef7f0e697bf4f0b8797527ba54f954e452253463", "html_url": "https://github.com/rust-lang/rust/commit/ef7f0e697bf4f0b8797527ba54f954e452253463", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef7f0e697bf4f0b8797527ba54f954e452253463/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "786178b2ab79ae471c5efc4e1faa0c83b9151703", "url": "https://api.github.com/repos/rust-lang/rust/commits/786178b2ab79ae471c5efc4e1faa0c83b9151703", "html_url": "https://github.com/rust-lang/rust/commit/786178b2ab79ae471c5efc4e1faa0c83b9151703"}], "stats": {"total": 150, "additions": 96, "deletions": 54}, "files": [{"sha": "a6a370409c0e23425fd04e253203dc1f61d59cc9", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 67, "deletions": 53, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/ef7f0e697bf4f0b8797527ba54f954e452253463/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef7f0e697bf4f0b8797527ba54f954e452253463/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=ef7f0e697bf4f0b8797527ba54f954e452253463", "patch": "@@ -298,8 +298,18 @@ pub mod panic_count {\n \n     pub const ALWAYS_ABORT_FLAG: usize = 1 << (usize::BITS - 1);\n \n-    // Panic count for the current thread.\n-    thread_local! { static LOCAL_PANIC_COUNT: Cell<usize> = const { Cell::new(0) } }\n+    /// A reason for forcing an immediate abort on panic.\n+    #[derive(Debug)]\n+    pub enum MustAbort {\n+        AlwaysAbort,\n+        PanicInHook,\n+    }\n+\n+    // Panic count for the current thread and whether a panic hook is currently\n+    // being executed..\n+    thread_local! {\n+        static LOCAL_PANIC_COUNT: Cell<(usize, bool)> = const { Cell::new((0, false)) }\n+    }\n \n     // Sum of panic counts from all threads. The purpose of this is to have\n     // a fast path in `count_is_zero` (which is used by `panicking`). In any particular\n@@ -328,34 +338,39 @@ pub mod panic_count {\n     // panicking thread consumes at least 2 bytes of address space.\n     static GLOBAL_PANIC_COUNT: AtomicUsize = AtomicUsize::new(0);\n \n-    // Return the state of the ALWAYS_ABORT_FLAG and number of panics.\n+    // Increases the global and local panic count, and returns whether an\n+    // immediate abort is required.\n     //\n-    // If ALWAYS_ABORT_FLAG is not set, the number is determined on a per-thread\n-    // base (stored in LOCAL_PANIC_COUNT), i.e. it is the amount of recursive calls\n-    // of the calling thread.\n-    // If ALWAYS_ABORT_FLAG is set, the number equals the *global* number of panic\n-    // calls. See above why LOCAL_PANIC_COUNT is not used.\n-    pub fn increase() -> (bool, usize) {\n+    // This also updates thread-local state to keep track of whether a panic\n+    // hook is currently executing.\n+    pub fn increase(run_panic_hook: bool) -> Option<MustAbort> {\n         let global_count = GLOBAL_PANIC_COUNT.fetch_add(1, Ordering::Relaxed);\n-        let must_abort = global_count & ALWAYS_ABORT_FLAG != 0;\n-        let panics = if must_abort {\n-            global_count & !ALWAYS_ABORT_FLAG\n-        } else {\n-            LOCAL_PANIC_COUNT.with(|c| {\n-                let next = c.get() + 1;\n-                c.set(next);\n-                next\n-            })\n-        };\n-        (must_abort, panics)\n+        if global_count & ALWAYS_ABORT_FLAG != 0 {\n+            return Some(MustAbort::AlwaysAbort);\n+        }\n+\n+        LOCAL_PANIC_COUNT.with(|c| {\n+            let (count, in_panic_hook) = c.get();\n+            if in_panic_hook {\n+                return Some(MustAbort::PanicInHook);\n+            }\n+            c.set((count + 1, run_panic_hook));\n+            None\n+        })\n+    }\n+\n+    pub fn finished_panic_hook() {\n+        LOCAL_PANIC_COUNT.with(|c| {\n+            let (count, _) = c.get();\n+            c.set((count, false));\n+        });\n     }\n \n     pub fn decrease() {\n         GLOBAL_PANIC_COUNT.fetch_sub(1, Ordering::Relaxed);\n         LOCAL_PANIC_COUNT.with(|c| {\n-            let next = c.get() - 1;\n-            c.set(next);\n-            next\n+            let (count, _) = c.get();\n+            c.set((count - 1, false));\n         });\n     }\n \n@@ -366,7 +381,7 @@ pub mod panic_count {\n     // Disregards ALWAYS_ABORT_FLAG\n     #[must_use]\n     pub fn get_count() -> usize {\n-        LOCAL_PANIC_COUNT.with(|c| c.get())\n+        LOCAL_PANIC_COUNT.with(|c| c.get().0)\n     }\n \n     // Disregards ALWAYS_ABORT_FLAG\n@@ -394,7 +409,7 @@ pub mod panic_count {\n     #[inline(never)]\n     #[cold]\n     fn is_zero_slow_path() -> bool {\n-        LOCAL_PANIC_COUNT.with(|c| c.get() == 0)\n+        LOCAL_PANIC_COUNT.with(|c| c.get().0 == 0)\n     }\n }\n \n@@ -655,23 +670,22 @@ fn rust_panic_with_hook(\n     location: &Location<'_>,\n     can_unwind: bool,\n ) -> ! {\n-    let (must_abort, panics) = panic_count::increase();\n-\n-    // If this is the third nested call (e.g., panics == 2, this is 0-indexed),\n-    // the panic hook probably triggered the last panic, otherwise the\n-    // double-panic check would have aborted the process. In this case abort the\n-    // process real quickly as we don't want to try calling it again as it'll\n-    // probably just panic again.\n-    if must_abort || panics > 2 {\n-        if panics > 2 {\n-            // Don't try to print the message in this case\n-            // - perhaps that is causing the recursive panics.\n-            rtprintpanic!(\"thread panicked while processing panic. aborting.\\n\");\n-        } else {\n-            // Unfortunately, this does not print a backtrace, because creating\n-            // a `Backtrace` will allocate, which we must to avoid here.\n-            let panicinfo = PanicInfo::internal_constructor(message, location, can_unwind);\n-            rtprintpanic!(\"{panicinfo}\\npanicked after panic::always_abort(), aborting.\\n\");\n+    let must_abort = panic_count::increase(true);\n+\n+    // Check if we need to abort immediately.\n+    if let Some(must_abort) = must_abort {\n+        match must_abort {\n+            panic_count::MustAbort::PanicInHook => {\n+                // Don't try to print the message in this case\n+                // - perhaps that is causing the recursive panics.\n+                rtprintpanic!(\"thread panicked while processing panic. aborting.\\n\");\n+            }\n+            panic_count::MustAbort::AlwaysAbort => {\n+                // Unfortunately, this does not print a backtrace, because creating\n+                // a `Backtrace` will allocate, which we must to avoid here.\n+                let panicinfo = PanicInfo::internal_constructor(message, location, can_unwind);\n+                rtprintpanic!(\"{panicinfo}\\npanicked after panic::always_abort(), aborting.\\n\");\n+            }\n         }\n         crate::sys::abort_internal();\n     }\n@@ -697,16 +711,16 @@ fn rust_panic_with_hook(\n     };\n     drop(hook);\n \n-    if panics > 1 || !can_unwind {\n-        // If a thread panics while it's already unwinding then we\n-        // have limited options. Currently our preference is to\n-        // just abort. In the future we may consider resuming\n-        // unwinding or otherwise exiting the thread cleanly.\n-        if !can_unwind {\n-            rtprintpanic!(\"thread caused non-unwinding panic. aborting.\\n\");\n-        } else {\n-            rtprintpanic!(\"thread panicked while panicking. aborting.\\n\");\n-        }\n+    // Indicate that we have finished executing the panic hook. After this point\n+    // it is fine if there is a panic while executing destructors, as long as it\n+    // it contained within a `catch_unwind`.\n+    panic_count::finished_panic_hook();\n+\n+    if !can_unwind {\n+        // If a thread panics while running destructors or tries to unwind\n+        // through a nounwind function (e.g. extern \"C\") then we cannot continue\n+        // unwinding and have to abort immediately.\n+        rtprintpanic!(\"thread caused non-unwinding panic. aborting.\\n\");\n         crate::sys::abort_internal();\n     }\n \n@@ -716,7 +730,7 @@ fn rust_panic_with_hook(\n /// This is the entry point for `resume_unwind`.\n /// It just forwards the payload to the panic runtime.\n pub fn rust_panic_without_hook(payload: Box<dyn Any + Send>) -> ! {\n-    panic_count::increase();\n+    panic_count::increase(false);\n \n     struct RewrapBox(Box<dyn Any + Send>);\n "}, {"sha": "66b378f62d63c738f76af9f661c5c4a8867c92e5", "filename": "tests/ui/backtrace.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef7f0e697bf4f0b8797527ba54f954e452253463/tests%2Fui%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef7f0e697bf4f0b8797527ba54f954e452253463/tests%2Fui%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbacktrace.rs?ref=ef7f0e697bf4f0b8797527ba54f954e452253463", "patch": "@@ -104,13 +104,17 @@ fn runtest(me: &str) {\n                 \"bad output3: {}\", s);\n \n         // Make sure a stack trace isn't printed too many times\n+        //\n+        // Currently it is printed 3 times (\"once\", \"twice\" and \"panic in a\n+        // function that cannot unwind\") but in the future the last one may be\n+        // removed.\n         let p = template(me).arg(\"double-fail\")\n                                     .env(\"RUST_BACKTRACE\", \"1\").spawn().unwrap();\n         let out = p.wait_with_output().unwrap();\n         assert!(!out.status.success());\n         let s = str::from_utf8(&out.stderr).unwrap();\n         let mut i = 0;\n-        for _ in 0..2 {\n+        for _ in 0..3 {\n             i += s[i + 10..].find(\"stack backtrace\").unwrap() + 10;\n         }\n         assert!(s[i + 10..].find(\"stack backtrace\").is_none(),"}, {"sha": "d43886e809579aac4154f75aaf5e593e08b2b714", "filename": "tests/ui/panics/nested_panic_caught.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ef7f0e697bf4f0b8797527ba54f954e452253463/tests%2Fui%2Fpanics%2Fnested_panic_caught.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef7f0e697bf4f0b8797527ba54f954e452253463/tests%2Fui%2Fpanics%2Fnested_panic_caught.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanics%2Fnested_panic_caught.rs?ref=ef7f0e697bf4f0b8797527ba54f954e452253463", "patch": "@@ -0,0 +1,24 @@\n+// run-pass\n+// needs-unwind\n+\n+// Checks that nested panics work correctly.\n+\n+use std::panic::catch_unwind;\n+\n+fn double() {\n+    struct Double;\n+\n+    impl Drop for Double {\n+        fn drop(&mut self) {\n+            let _ = catch_unwind(|| panic!(\"twice\"));\n+        }\n+    }\n+\n+    let _d = Double;\n+\n+    panic!(\"once\");\n+}\n+\n+fn main() {\n+    assert!(catch_unwind(|| double()).is_err());\n+}"}]}