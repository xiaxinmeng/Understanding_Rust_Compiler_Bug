{"sha": "328419534d0ed425023db68ebab2eebb28f873cf", "node_id": "C_kwDOAAsO6NoAKDMyODQxOTUzNGQwZWQ0MjUwMjNkYjY4ZWJhYjJlZWJiMjhmODczY2Y", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-12-13T14:55:13Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-12-13T14:55:13Z"}, "message": "Move ws insert rendering for macro expansion into ide_db", "tree": {"sha": "a4c3b05fa143d3d930577d5c1e890feaaf7bf1d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4c3b05fa143d3d930577d5c1e890feaaf7bf1d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/328419534d0ed425023db68ebab2eebb28f873cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/328419534d0ed425023db68ebab2eebb28f873cf", "html_url": "https://github.com/rust-lang/rust/commit/328419534d0ed425023db68ebab2eebb28f873cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/328419534d0ed425023db68ebab2eebb28f873cf/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d03397fe1173eaeb2e04c9e55ac223289e7e08ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/d03397fe1173eaeb2e04c9e55ac223289e7e08ee", "html_url": "https://github.com/rust-lang/rust/commit/d03397fe1173eaeb2e04c9e55ac223289e7e08ee"}], "stats": {"total": 234, "additions": 139, "deletions": 95}, "files": [{"sha": "9302eaf913b45d0298ebb84210a680eaf3ed569b", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/328419534d0ed425023db68ebab2eebb28f873cf/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328419534d0ed425023db68ebab2eebb28f873cf/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=328419534d0ed425023db68ebab2eebb28f873cf", "patch": "@@ -1163,9 +1163,12 @@ impl<'a> SemanticsScope<'a> {\n         Some(Crate { id: self.resolver.krate()? })\n     }\n \n+    pub fn in_macro_file(&self) -> bool {\n+        self.file_id.is_macro()\n+    }\n+\n     /// Note: `FxHashSet<TraitId>` should be treated as an opaque type, passed into `Type\n-    // FIXME: rename to visible_traits to not repeat scope?\n-    pub fn traits_in_scope(&self) -> FxHashSet<TraitId> {\n+    pub fn visible_traits(&self) -> FxHashSet<TraitId> {\n         let resolver = &self.resolver;\n         resolver.traits_in_scope(self.db.upcast())\n     }"}, {"sha": "7f57d1d638935ebeaceb8c56bbcdd1b552a6b8cb", "filename": "crates/ide/src/expand_macro.rs", "status": "modified", "additions": 7, "deletions": 84, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/328419534d0ed425023db68ebab2eebb28f873cf/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328419534d0ed425023db68ebab2eebb28f873cf/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=328419534d0ed425023db68ebab2eebb28f873cf", "patch": "@@ -1,9 +1,10 @@\n-use std::iter;\n-\n use hir::Semantics;\n-use ide_db::{helpers::pick_best_token, RootDatabase};\n+use ide_db::{\n+    helpers::{pick_best_token, render_macro_node::render_with_ws_inserted},\n+    RootDatabase,\n+};\n use itertools::Itertools;\n-use syntax::{ast, ted, AstNode, NodeOrToken, SyntaxKind, SyntaxNode, WalkEvent, T};\n+use syntax::{ast, ted, AstNode, SyntaxKind, SyntaxNode};\n \n use crate::FilePosition;\n \n@@ -49,7 +50,7 @@ pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<\n             let expansions = sema.expand_derive_macro(&attr)?;\n             Some(ExpandedMacro {\n                 name: tt,\n-                expansion: expansions.into_iter().map(insert_whitespaces).join(\"\"),\n+                expansion: expansions.into_iter().map(render_with_ws_inserted).join(\"\"),\n             })\n         } else {\n             None\n@@ -82,7 +83,7 @@ pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<\n     // FIXME:\n     // macro expansion may lose all white space information\n     // But we hope someday we can use ra_fmt for that\n-    let expansion = insert_whitespaces(expanded?);\n+    let expansion = render_with_ws_inserted(expanded?).to_string();\n     Some(ExpandedMacro { name: name.unwrap_or_else(|| \"???\".to_owned()), expansion })\n }\n \n@@ -122,84 +123,6 @@ fn expand<T: AstNode>(\n     Some(expanded)\n }\n \n-// FIXME: It would also be cool to share logic here and in the mbe tests,\n-// which are pretty unreadable at the moment.\n-fn insert_whitespaces(syn: SyntaxNode) -> String {\n-    use SyntaxKind::*;\n-    let mut res = String::new();\n-\n-    let mut indent = 0;\n-    let mut last: Option<SyntaxKind> = None;\n-\n-    for event in syn.preorder_with_tokens() {\n-        let token = match event {\n-            WalkEvent::Enter(NodeOrToken::Token(token)) => token,\n-            WalkEvent::Leave(NodeOrToken::Node(node))\n-                if matches!(node.kind(), ATTR | MATCH_ARM | STRUCT | ENUM | UNION | FN | IMPL) =>\n-            {\n-                res.push('\\n');\n-                res.extend(iter::repeat(\" \").take(2 * indent));\n-                continue;\n-            }\n-            _ => continue,\n-        };\n-        let is_next = |f: fn(SyntaxKind) -> bool, default| -> bool {\n-            token.next_token().map(|it| f(it.kind())).unwrap_or(default)\n-        };\n-        let is_last =\n-            |f: fn(SyntaxKind) -> bool, default| -> bool { last.map(f).unwrap_or(default) };\n-\n-        match token.kind() {\n-            k if is_text(k) && is_next(|it| !it.is_punct(), true) => {\n-                res.push_str(token.text());\n-                res.push(' ');\n-            }\n-            L_CURLY if is_next(|it| it != R_CURLY, true) => {\n-                indent += 1;\n-                if is_last(is_text, false) {\n-                    res.push(' ');\n-                }\n-                res.push_str(\"{\\n\");\n-                res.extend(iter::repeat(\" \").take(2 * indent));\n-            }\n-            R_CURLY if is_last(|it| it != L_CURLY, true) => {\n-                indent = indent.saturating_sub(1);\n-                res.push('\\n');\n-                res.extend(iter::repeat(\" \").take(2 * indent));\n-                res.push_str(\"}\");\n-            }\n-            R_CURLY => {\n-                res.push_str(\"}\\n\");\n-                res.extend(iter::repeat(\" \").take(2 * indent));\n-            }\n-            LIFETIME_IDENT if is_next(|it| it == IDENT || it == MUT_KW, true) => {\n-                res.push_str(token.text());\n-                res.push(' ');\n-            }\n-            AS_KW => {\n-                res.push_str(token.text());\n-                res.push(' ');\n-            }\n-            T![;] => {\n-                res.push_str(\";\\n\");\n-                res.extend(iter::repeat(\" \").take(2 * indent));\n-            }\n-            T![->] => res.push_str(\" -> \"),\n-            T![=] => res.push_str(\" = \"),\n-            T![=>] => res.push_str(\" => \"),\n-            _ => res.push_str(token.text()),\n-        }\n-\n-        last = Some(token.kind());\n-    }\n-\n-    return res;\n-\n-    fn is_text(k: SyntaxKind) -> bool {\n-        k.is_keyword() || k.is_literal() || k == IDENT\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};"}, {"sha": "6b4640ce7d7829e40fb4fd29d1f259ee80047e4d", "filename": "crates/ide_assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/328419534d0ed425023db68ebab2eebb28f873cf/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328419534d0ed425023db68ebab2eebb28f873cf/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=328419534d0ed425023db68ebab2eebb28f873cf", "patch": "@@ -124,6 +124,9 @@ fn add_missing_impl_members_inner(\n             impl_def.clone(),\n             target_scope,\n         );\n+        // if target_scope.in_macro_file() {\n+\n+        // }\n         match ctx.config.snippet_cap {\n             None => builder.replace(target, new_impl_def.to_string()),\n             Some(cap) => {"}, {"sha": "7fbbdb4f5eb1f15d591af6c5e5a70d6fd9380f4d", "filename": "crates/ide_assists/src/handlers/convert_iter_for_each_to_for.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/328419534d0ed425023db68ebab2eebb28f873cf/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328419534d0ed425023db68ebab2eebb28f873cf/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs?ref=328419534d0ed425023db68ebab2eebb28f873cf", "patch": "@@ -148,7 +148,7 @@ fn is_ref_and_impls_iter_method(\n     let ty = sema.type_of_expr(&expr_behind_ref)?.adjusted();\n     let scope = sema.scope(iterable.syntax());\n     let krate = scope.module()?.krate();\n-    let traits_in_scope = scope.traits_in_scope();\n+    let traits_in_scope = scope.visible_traits();\n     let iter_trait = FamousDefs(sema, Some(krate)).core_iter_Iterator()?;\n \n     let has_wanted_method = ty"}, {"sha": "15025cf0d0e4600320fcd16ecaab097437317a6d", "filename": "crates/ide_assists/src/handlers/generate_is_empty_from_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/328419534d0ed425023db68ebab2eebb28f873cf/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328419534d0ed425023db68ebab2eebb28f873cf/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs?ref=328419534d0ed425023db68ebab2eebb28f873cf", "patch": "@@ -92,7 +92,7 @@ fn get_impl_method(\n     let scope = ctx.sema.scope(impl_.syntax());\n     let krate = impl_def.module(db).krate();\n     let ty = impl_def.self_ty(db);\n-    let traits_in_scope = scope.traits_in_scope();\n+    let traits_in_scope = scope.visible_traits();\n     ty.iterate_method_candidates(db, krate, &traits_in_scope, Some(fn_name), |_, func| Some(func))\n }\n "}, {"sha": "e7371270fbf6d5ad9be3a51e72f67282cc9a8603", "filename": "crates/ide_completion/src/completions/dot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/328419534d0ed425023db68ebab2eebb28f873cf/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328419534d0ed425023db68ebab2eebb28f873cf/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=328419534d0ed425023db68ebab2eebb28f873cf", "patch": "@@ -79,7 +79,7 @@ fn complete_methods(\n ) {\n     if let Some(krate) = ctx.krate {\n         let mut seen_methods = FxHashSet::default();\n-        let traits_in_scope = ctx.scope.traits_in_scope();\n+        let traits_in_scope = ctx.scope.visible_traits();\n         receiver.iterate_method_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, func| {\n             if func.self_param(ctx.db).is_some() && seen_methods.insert(func.name(ctx.db)) {\n                 f(func);"}, {"sha": "782615a88484b0c3cf267f2e2f005c1b371f7d12", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/328419534d0ed425023db68ebab2eebb28f873cf/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328419534d0ed425023db68ebab2eebb28f873cf/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=328419534d0ed425023db68ebab2eebb28f873cf", "patch": "@@ -152,9 +152,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n             }\n         }\n         hir::PathResolution::Def(\n-            def\n-            @\n-            (hir::ModuleDef::Adt(_)\n+            def @ (hir::ModuleDef::Adt(_)\n             | hir::ModuleDef::TypeAlias(_)\n             | hir::ModuleDef::BuiltinType(_)),\n         ) => {\n@@ -187,7 +185,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n \n             let krate = ctx.krate;\n             if let Some(krate) = krate {\n-                let traits_in_scope = ctx.scope.traits_in_scope();\n+                let traits_in_scope = ctx.scope.visible_traits();\n                 ty.iterate_path_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, item| {\n                     add_assoc_item(acc, ctx, item);\n                     None::<()>\n@@ -220,7 +218,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                     add_enum_variants(acc, ctx, e);\n                 }\n \n-                let traits_in_scope = ctx.scope.traits_in_scope();\n+                let traits_in_scope = ctx.scope.visible_traits();\n                 let mut seen = FxHashSet::default();\n                 ty.iterate_path_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, item| {\n                     // We might iterate candidates of a trait multiple times here, so deduplicate"}, {"sha": "b8a8723a2e5d1c9b84601481c77bd31c69569b39", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/328419534d0ed425023db68ebab2eebb28f873cf/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328419534d0ed425023db68ebab2eebb28f873cf/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=328419534d0ed425023db68ebab2eebb28f873cf", "patch": "@@ -4,6 +4,7 @@ pub mod generated_lints;\n pub mod import_assets;\n pub mod insert_use;\n pub mod merge_imports;\n+pub mod render_macro_node;\n pub mod node_ext;\n pub mod rust_doc;\n "}, {"sha": "7c45d281535b15ef7f84e15aea3d4872e7633fcb", "filename": "crates/ide_db/src/helpers/render_macro_node.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/328419534d0ed425023db68ebab2eebb28f873cf/crates%2Fide_db%2Fsrc%2Fhelpers%2Frender_macro_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328419534d0ed425023db68ebab2eebb28f873cf/crates%2Fide_db%2Fsrc%2Fhelpers%2Frender_macro_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Frender_macro_node.rs?ref=328419534d0ed425023db68ebab2eebb28f873cf", "patch": "@@ -0,0 +1,116 @@\n+use syntax::{\n+    ast::make,\n+    ted::{self, Position},\n+    NodeOrToken,\n+    SyntaxKind::{self, *},\n+    SyntaxNode, SyntaxToken, WalkEvent, T,\n+};\n+\n+// FIXME: It would also be cool to share logic here and in the mbe tests,\n+// which are pretty unreadable at the moment.\n+/// Renders a [`SyntaxNode`] with whitespace inserted between tokens that require them.\n+pub fn render_with_ws_inserted(syn: SyntaxNode) -> SyntaxNode {\n+    let mut indent = 0;\n+    let mut last: Option<SyntaxKind> = None;\n+    let mut mods = Vec::new();\n+    let syn = syn.clone_subtree().clone_for_update();\n+\n+    let before = Position::before;\n+    let after = Position::after;\n+\n+    let do_indent = |pos: fn(_) -> Position, token: &SyntaxToken, indent| {\n+        (pos(token.clone()), make::tokens::whitespace(&\" \".repeat(2 * indent)))\n+    };\n+    let do_ws = |pos: fn(_) -> Position, token: &SyntaxToken| {\n+        (pos(token.clone()), make::tokens::single_space())\n+    };\n+    let do_nl = |pos: fn(_) -> Position, token: &SyntaxToken| {\n+        (pos(token.clone()), make::tokens::single_newline())\n+    };\n+\n+    for event in syn.preorder_with_tokens() {\n+        let token = match event {\n+            WalkEvent::Enter(NodeOrToken::Token(token)) => token,\n+            WalkEvent::Leave(NodeOrToken::Node(node))\n+                if matches!(node.kind(), ATTR | MATCH_ARM | STRUCT | ENUM | UNION | FN | IMPL) =>\n+            {\n+                if indent > 0 {\n+                    mods.push((\n+                        Position::after(node.clone()),\n+                        make::tokens::whitespace(&\" \".repeat(2 * indent)),\n+                    ));\n+                }\n+                mods.push((Position::after(node), make::tokens::single_newline()));\n+                continue;\n+            }\n+            _ => continue,\n+        };\n+        let tok = &token;\n+\n+        let is_next = |f: fn(SyntaxKind) -> bool, default| -> bool {\n+            tok.next_token().map(|it| f(it.kind())).unwrap_or(default)\n+        };\n+        let is_last =\n+            |f: fn(SyntaxKind) -> bool, default| -> bool { last.map(f).unwrap_or(default) };\n+\n+        match tok.kind() {\n+            k if is_text(k) && is_next(|it| !it.is_punct(), true) => {\n+                mods.push(do_ws(after, tok));\n+            }\n+            L_CURLY if is_next(|it| it != R_CURLY, true) => {\n+                indent += 1;\n+                if is_last(is_text, false) {\n+                    mods.push(do_ws(before, tok));\n+                }\n+\n+                if indent > 0 {\n+                    mods.push(do_indent(after, tok, indent));\n+                }\n+                mods.push(do_nl(after, &tok));\n+            }\n+            R_CURLY if is_last(|it| it != L_CURLY, true) => {\n+                indent = indent.saturating_sub(1);\n+\n+                if indent > 0 {\n+                    mods.push(do_indent(before, tok, indent));\n+                }\n+                mods.push(do_nl(before, tok));\n+            }\n+            R_CURLY => {\n+                if indent > 0 {\n+                    mods.push(do_indent(after, tok, indent));\n+                }\n+                mods.push(do_nl(after, tok));\n+            }\n+            LIFETIME_IDENT if is_next(|it| it == IDENT || it == MUT_KW, true) => {\n+                mods.push(do_ws(after, tok));\n+            }\n+            AS_KW => {\n+                mods.push(do_ws(after, tok));\n+            }\n+            T![;] => {\n+                if indent > 0 {\n+                    mods.push(do_indent(after, tok, indent));\n+                }\n+                mods.push(do_nl(after, tok));\n+            }\n+            T![->] | T![=] | T![=>] => {\n+                mods.push(do_ws(before, tok));\n+                mods.push(do_ws(after, tok));\n+            }\n+            _ => (),\n+        }\n+\n+        last = Some(tok.kind());\n+    }\n+\n+    for (pos, insert) in mods {\n+        ted::insert(pos, insert);\n+    }\n+\n+    syn\n+}\n+\n+fn is_text(k: SyntaxKind) -> bool {\n+    k.is_keyword() || k.is_literal() || k == IDENT\n+}"}, {"sha": "7902295d2907a6256088c7f907365f64395a4a70", "filename": "crates/ide_ssr/src/resolving.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/328419534d0ed425023db68ebab2eebb28f873cf/crates%2Fide_ssr%2Fsrc%2Fresolving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/328419534d0ed425023db68ebab2eebb28f873cf/crates%2Fide_ssr%2Fsrc%2Fresolving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2Fsrc%2Fresolving.rs?ref=328419534d0ed425023db68ebab2eebb28f873cf", "patch": "@@ -222,7 +222,7 @@ impl<'db> ResolutionScope<'db> {\n             adt.ty(self.scope.db).iterate_path_candidates(\n                 self.scope.db,\n                 self.scope.module()?.krate(),\n-                &self.scope.traits_in_scope(),\n+                &self.scope.visible_traits(),\n                 None,\n                 |_ty, assoc_item| {\n                     let item_name = assoc_item.name(self.scope.db)?;"}]}