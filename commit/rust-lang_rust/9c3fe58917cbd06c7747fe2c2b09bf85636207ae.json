{"sha": "9c3fe58917cbd06c7747fe2c2b09bf85636207ae", "node_id": "C_kwDOAAsO6NoAKDljM2ZlNTg5MTdjYmQwNmM3NzQ3ZmUyYzJiMDliZjg1NjM2MjA3YWU", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-01-27T07:20:34Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-01-27T07:26:28Z"}, "message": "small refactor to new projection code", "tree": {"sha": "ed16c36851aa92bc0925294784b63a4c9178ce7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed16c36851aa92bc0925294784b63a4c9178ce7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c3fe58917cbd06c7747fe2c2b09bf85636207ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c3fe58917cbd06c7747fe2c2b09bf85636207ae", "html_url": "https://github.com/rust-lang/rust/commit/9c3fe58917cbd06c7747fe2c2b09bf85636207ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c3fe58917cbd06c7747fe2c2b09bf85636207ae/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db137ba7d4415ac77e2b7601ef017ff2ca41b335", "url": "https://api.github.com/repos/rust-lang/rust/commits/db137ba7d4415ac77e2b7601ef017ff2ca41b335", "html_url": "https://github.com/rust-lang/rust/commit/db137ba7d4415ac77e2b7601ef017ff2ca41b335"}], "stats": {"total": 77, "additions": 40, "deletions": 37}, "files": [{"sha": "891776a937d51649dbe350c0f1e73cc0e84043fc", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/9c3fe58917cbd06c7747fe2c2b09bf85636207ae/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3fe58917cbd06c7747fe2c2b09bf85636207ae/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=9c3fe58917cbd06c7747fe2c2b09bf85636207ae", "patch": "@@ -122,6 +122,28 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             && goal.param_env.visit_with(&mut visitor).is_continue()\n     }\n \n+    /// After normalizing the projection to `normalized_alias` with the given\n+    /// `normalization_certainty`, constrain the inference variable `term` to it\n+    /// and return a query response.\n+    fn eq_term_and_make_canonical_response(\n+        &mut self,\n+        goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n+        normalization_certainty: Certainty,\n+        normalized_alias: impl Into<ty::Term<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        // The term of our goal should be fully unconstrained, so this should never fail.\n+        //\n+        // It can however be ambiguous when the `normalized_alias` contains a projection.\n+        let nested_goals = self\n+            .infcx\n+            .eq(goal.param_env, goal.predicate.term, normalized_alias.into())\n+            .expect(\"failed to unify with unconstrained term\");\n+        let rhs_certainty =\n+            self.evaluate_all(nested_goals).expect(\"failed to unify with unconstrained term\");\n+\n+        self.make_canonical_response(normalization_certainty.unify_and(rhs_certainty))\n+    }\n+\n     fn merge_project_candidates(\n         &mut self,\n         mut candidates: Vec<Candidate<'tcx>>,\n@@ -218,7 +240,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 .map(|pred| goal.with(tcx, pred));\n \n             nested_goals.extend(where_clause_bounds);\n-            let trait_ref_certainty = ecx.evaluate_all(nested_goals)?;\n+            let match_impl_certainty = ecx.evaluate_all(nested_goals)?;\n \n             // In case the associated item is hidden due to specialization, we have to\n             // return ambiguity this would otherwise be incomplete, resulting in\n@@ -230,7 +252,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 goal.predicate.def_id(),\n                 impl_def_id\n             )? else {\n-                return ecx.make_canonical_response(trait_ref_certainty.unify_and(Certainty::AMBIGUOUS));\n+                return ecx.make_canonical_response(match_impl_certainty.unify_and(Certainty::AMBIGUOUS));\n             };\n \n             if !assoc_def.item.defaultness(tcx).has_value() {\n@@ -277,17 +299,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ty.map_bound(|ty| ty.into())\n             };\n \n-            // The term of our goal should be fully unconstrained, so this should never fail.\n-            //\n-            // It can however be ambiguous when the resolved type is a projection.\n-            let nested_goals = ecx\n-                .infcx\n-                .eq(goal.param_env, goal.predicate.term, term.subst(tcx, substs))\n-                .expect(\"failed to unify with unconstrained term\");\n-            let rhs_certainty =\n-                ecx.evaluate_all(nested_goals).expect(\"failed to unify with unconstrained term\");\n-\n-            ecx.make_canonical_response(trait_ref_certainty.unify_and(rhs_certainty))\n+            ecx.eq_term_and_make_canonical_response(goal, match_impl_certainty, term.subst(tcx, substs))\n         })\n     }\n \n@@ -307,18 +319,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 )?;\n                 let subst_certainty = ecx.evaluate_all(nested_goals)?;\n \n-                // The term of our goal should be fully unconstrained, so this should never fail.\n-                //\n-                // It can however be ambiguous when the resolved type is a projection.\n-                let nested_goals = ecx\n-                    .infcx\n-                    .eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)\n-                    .expect(\"failed to unify with unconstrained term\");\n-                let rhs_certainty = ecx\n-                    .evaluate_all(nested_goals)\n-                    .expect(\"failed to unify with unconstrained term\");\n-\n-                ecx.make_canonical_response(subst_certainty.unify_and(rhs_certainty))\n+                ecx.eq_term_and_make_canonical_response(\n+                    goal,\n+                    subst_certainty,\n+                    assumption_projection_pred.term,\n+                )\n             })\n         } else {\n             Err(NoSolution)\n@@ -434,14 +439,12 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                         [ty::GenericArg::from(goal.predicate.self_ty())],\n                     ));\n \n-                    let mut nested_goals = ecx.infcx.eq(\n-                        goal.param_env,\n-                        goal.predicate.term.ty().unwrap(),\n+                    let is_sized_certainty = ecx.evaluate_goal(goal.with(tcx, sized_predicate))?.1;\n+                    return ecx.eq_term_and_make_canonical_response(\n+                        goal,\n+                        is_sized_certainty,\n                         tcx.types.unit,\n-                    )?;\n-                    nested_goals.push(goal.with(tcx, sized_predicate));\n-\n-                    return ecx.evaluate_all_and_make_canonical_response(nested_goals);\n+                    );\n                 }\n \n                 ty::Adt(def, substs) if def.is_struct() => {\n@@ -453,7 +456,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                                 tcx,\n                                 ty::Binder::dummy(goal.predicate.with_self_ty(tcx, self_ty)),\n                             );\n-                            return ecx.evaluate_all_and_make_canonical_response(vec![new_goal]);\n+                            let (_, certainty) = ecx.evaluate_goal(new_goal)?;\n+                            return ecx.make_canonical_response(certainty);\n                         }\n                     }\n                 }\n@@ -466,7 +470,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                             tcx,\n                             ty::Binder::dummy(goal.predicate.with_self_ty(tcx, self_ty)),\n                         );\n-                        return ecx.evaluate_all_and_make_canonical_response(vec![new_goal]);\n+                        let (_, certainty) = ecx.evaluate_goal(new_goal)?;\n+                        return ecx.make_canonical_response(certainty);\n                     }\n                 },\n \n@@ -479,9 +484,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ),\n             };\n \n-            let nested_goals =\n-                ecx.infcx.eq(goal.param_env, goal.predicate.term.ty().unwrap(), metadata_ty)?;\n-            ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+            ecx.eq_term_and_make_canonical_response(goal, Certainty::Yes, metadata_ty)\n         })\n     }\n "}]}