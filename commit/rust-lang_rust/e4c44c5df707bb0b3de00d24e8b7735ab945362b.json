{"sha": "e4c44c5df707bb0b3de00d24e8b7735ab945362b", "node_id": "C_kwDOAAsO6NoAKGU0YzQ0YzVkZjcwN2JiMGIzZGUwMGQyNGU4Yjc3MzVhYjk0NTM2MmI", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2021-12-14T23:48:46Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2021-12-14T23:48:46Z"}, "message": "Update comments per review feedback", "tree": {"sha": "deb4e3bf1938a5a9dfcd31573da4e6109a6dac39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deb4e3bf1938a5a9dfcd31573da4e6109a6dac39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4c44c5df707bb0b3de00d24e8b7735ab945362b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4c44c5df707bb0b3de00d24e8b7735ab945362b", "html_url": "https://github.com/rust-lang/rust/commit/e4c44c5df707bb0b3de00d24e8b7735ab945362b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4c44c5df707bb0b3de00d24e8b7735ab945362b/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92c8317d2ae45a86b632b24996cd29a30d0dc3ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/92c8317d2ae45a86b632b24996cd29a30d0dc3ce", "html_url": "https://github.com/rust-lang/rust/commit/92c8317d2ae45a86b632b24996cd29a30d0dc3ce"}], "stats": {"total": 56, "additions": 46, "deletions": 10}, "files": [{"sha": "59ac0e86943ee5e9d46ded299a1aa20f49a5b87a", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 46, "deletions": 10, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e4c44c5df707bb0b3de00d24e8b7735ab945362b/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c44c5df707bb0b3de00d24e8b7735ab945362b/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=e4c44c5df707bb0b3de00d24e8b7735ab945362b", "patch": "@@ -3436,12 +3436,30 @@ impl<T> [T] {\n         }\n     }\n \n-    /// Split a slice into a prefix, a middle of aligned simd types, and a suffix.\n+    /// Split a slice into a prefix, a middle of aligned SIMD types, and a suffix.\n     ///\n     /// This is a safe wrapper around [`slice::align_to`], so has the same weak\n-    /// preconditions as that method.  Notably, you must not assume any particular\n-    /// split between the three parts: it's legal for the middle slice to be\n-    /// empty even if the input slice is longer than `3 * LANES`.\n+    /// postconditions as that method.  You're only assured that\n+    /// `self.len() == prefix.len() + middle.len() * LANES + suffix.len()`.\n+    ///\n+    /// Notably, all of the following are possible:\n+    /// - `prefix.len() >= LANES`.\n+    /// - `middle.is_empty()` despite `self.len() >= 3 * LANES`.\n+    /// - `suffix.len() >= LANES`.\n+    ///\n+    /// That said, this is a safe method, so if you're only writing safe code,\n+    /// then this can at most cause incorrect logic, not unsoundness.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This will panic if the size of the SIMD type is different from\n+    /// `LANES` times that of the scalar.\n+    ///\n+    /// At the time of writing, the trait restrictions on `Simd<T, LANES>` keeps\n+    /// that from ever happening, as only power-of-two numbers of lanes are\n+    /// supported.  It's possible that, in the future, those restrictions might\n+    /// be lifted in a way that would make it possible to see panics from this\n+    /// method for something like `LANES == 3`.\n     ///\n     /// # Examples\n     ///\n@@ -3491,14 +3509,32 @@ impl<T> [T] {\n         unsafe { self.align_to() }\n     }\n \n-    /// Split a slice into a prefix, a middle of aligned simd types, and a suffix.\n+    /// Split a slice into a prefix, a middle of aligned SIMD types, and a suffix.\n     ///\n-    /// This is a safe wrapper around [`slice::align_to`], so has the same weak\n-    /// preconditions as that method.  Notably, you must not assume any particular\n-    /// split between the three parts: it's legal for the middle slice to be\n-    /// empty even if the input slice is longer than `3 * LANES`.\n+    /// This is a safe wrapper around [`slice::align_to_mut`], so has the same weak\n+    /// postconditions as that method.  You're only assured that\n+    /// `self.len() == prefix.len() + middle.len() * LANES + suffix.len()`.\n+    ///\n+    /// Notably, all of the following are possible:\n+    /// - `prefix.len() >= LANES`.\n+    /// - `middle.is_empty()` despite `self.len() >= 3 * LANES`.\n+    /// - `suffix.len() >= LANES`.\n+    ///\n+    /// That said, this is a safe method, so if you're only writing safe code,\n+    /// then this can at most cause incorrect logic, not unsoundness.\n+    ///\n+    /// This is the mutable version of [`slice::as_simd`]; see that for examples.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This will panic if the size of the SIMD type is different from\n+    /// `LANES` times that of the scalar.\n     ///\n-    /// This is the mutable version of [`slice::as_simd`]; see that for more.\n+    /// At the time of writing, the trait restrictions on `Simd<T, LANES>` keeps\n+    /// that from ever happening, as only power-of-two numbers of lanes are\n+    /// supported.  It's possible that, in the future, those restrictions might\n+    /// be lifted in a way that would make it possible to see panics from this\n+    /// method for something like `LANES == 3`.\n     #[unstable(feature = \"portable_simd\", issue = \"86656\")]\n     #[cfg(not(miri))] // Miri does not support all SIMD intrinsics\n     pub fn as_simd_mut<const LANES: usize>(&mut self) -> (&mut [T], &mut [Simd<T, LANES>], &mut [T])"}]}