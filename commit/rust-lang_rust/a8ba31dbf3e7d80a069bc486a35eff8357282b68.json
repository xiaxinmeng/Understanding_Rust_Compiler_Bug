{"sha": "a8ba31dbf3e7d80a069bc486a35eff8357282b68", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4YmEzMWRiZjNlN2Q4MGEwNjliYzQ4NmEzNWVmZjgzNTcyODJiNjg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-28T00:02:31Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-01T06:21:18Z"}, "message": "std: Remove usage of fmt!", "tree": {"sha": "8a00829d527c443d16988b98cd7c97f1d3d4dac6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a00829d527c443d16988b98cd7c97f1d3d4dac6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8ba31dbf3e7d80a069bc486a35eff8357282b68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8ba31dbf3e7d80a069bc486a35eff8357282b68", "html_url": "https://github.com/rust-lang/rust/commit/a8ba31dbf3e7d80a069bc486a35eff8357282b68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8ba31dbf3e7d80a069bc486a35eff8357282b68/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aaf6cc3a841095a95a9c74a6a2a3709dffd7a4e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/aaf6cc3a841095a95a9c74a6a2a3709dffd7a4e9", "html_url": "https://github.com/rust-lang/rust/commit/aaf6cc3a841095a95a9c74a6a2a3709dffd7a4e9"}], "stats": {"total": 1006, "additions": 497, "deletions": 509}, "files": [{"sha": "93a66f6d917709c32f93d2ee4d94341cd3b7b6da", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -236,7 +236,7 @@ pub mod raw {\n                 let alloc = n * (*ty).size;\n                 let total_size = alloc + sys::size_of::<Vec<()>>();\n                 if alloc / (*ty).size != n || total_size < alloc {\n-                    fail!(\"vector size is too large: %u\", n);\n+                    fail2!(\"vector size is too large: {}\", n);\n                 }\n                 (*ptr) = local_realloc(*ptr as *(), total_size) as *mut Box<Vec<()>>;\n                 (**ptr).data.alloc = alloc;"}, {"sha": "8118907322bf79c48318fc57e05a47405fa3f69a", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -116,7 +116,7 @@ impl CString {\n     ///\n     /// Fails if the CString is null.\n     pub fn with_ref<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n+        if self.buf.is_null() { fail2!(\"CString is null!\"); }\n         f(self.buf)\n     }\n \n@@ -126,7 +126,7 @@ impl CString {\n     ///\n     /// Fails if the CString is null.\n     pub fn with_mut_ref<T>(&mut self, f: &fn(*mut libc::c_char) -> T) -> T {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n+        if self.buf.is_null() { fail2!(\"CString is null!\"); }\n         f(unsafe { cast::transmute_mut_unsafe(self.buf) })\n     }\n \n@@ -152,7 +152,7 @@ impl CString {\n     /// Fails if the CString is null.\n     #[inline]\n     pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n+        if self.buf.is_null() { fail2!(\"CString is null!\"); }\n         unsafe {\n             cast::transmute((self.buf, self.len() + 1))\n         }\n@@ -273,7 +273,7 @@ impl<'self> ToCStr for &'self [u8] {\n         do self.as_imm_buf |self_buf, self_len| {\n             let buf = libc::malloc(self_len as libc::size_t + 1) as *mut u8;\n             if buf.is_null() {\n-                fail!(\"failed to allocate memory!\");\n+                fail2!(\"failed to allocate memory!\");\n             }\n \n             ptr::copy_memory(buf, self_buf, self_len);"}, {"sha": "4bbb0a5935aeeba50617ab06c0af99c7cea65c86", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -44,7 +44,7 @@ impl<T> Cell<T> {\n     pub fn take(&self) -> T {\n         let this = unsafe { transmute_mut(self) };\n         if this.is_empty() {\n-            fail!(\"attempt to take an empty cell\");\n+            fail2!(\"attempt to take an empty cell\");\n         }\n \n         this.value.take_unwrap()\n@@ -60,7 +60,7 @@ impl<T> Cell<T> {\n     pub fn put_back(&self, value: T) {\n         let this = unsafe { transmute_mut(self) };\n         if !this.is_empty() {\n-            fail!(\"attempt to put a value back into a full cell\");\n+            fail2!(\"attempt to put a value back into a full cell\");\n         }\n         this.value = Some(value);\n     }"}, {"sha": "54613adf3fec15ebf8efd82089c17cb1c82e8a81", "filename": "src/libstd/char.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -187,7 +187,7 @@ pub fn is_digit_radix(c: char, radix: uint) -> bool {\n #[inline]\n pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n     if radix > 36 {\n-        fail!(\"to_digit: radix %? is to high (maximum 36)\", radix);\n+        fail2!(\"to_digit: radix {} is to high (maximum 36)\", radix);\n     }\n     let val = match c {\n       '0' .. '9' => c as uint - ('0' as uint),\n@@ -214,7 +214,7 @@ pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n #[inline]\n pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     if radix > 36 {\n-        fail!(\"from_digit: radix %? is to high (maximum 36)\", num);\n+        fail2!(\"from_digit: radix {} is to high (maximum 36)\", num);\n     }\n     if num < radix {\n         unsafe {\n@@ -342,7 +342,7 @@ pub fn len_utf8_bytes(c: char) -> uint {\n         _ if code < MAX_TWO_B   => 2u,\n         _ if code < MAX_THREE_B => 3u,\n         _ if code < MAX_FOUR_B  => 4u,\n-        _                       => fail!(\"invalid character!\"),\n+        _                       => fail2!(\"invalid character!\"),\n     }\n }\n "}, {"sha": "77f8cb937fac000b6357061db9df89fd2fc04f64", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -56,7 +56,7 @@ do my_error::cond.trap(|raised_int| {\n Condition handling is useful in cases where propagating errors is either to\n cumbersome or just not necessary in the first place. It should also be noted,\n though, that if there is not handler installed when a condition is raised, then\n-the task invokes `fail!()` and will terminate.\n+the task invokes `fail2!()` and will terminate.\n \n ## More Info\n \n@@ -127,20 +127,20 @@ impl<T, U> Condition<T, U> {\n     /// If a handler is found, its return value is returned, otherwise this\n     /// function will not return.\n     pub fn raise(&self, t: T) -> U {\n-        let msg = fmt!(\"Unhandled condition: %s: %?\", self.name, t);\n-        self.raise_default(t, || fail!(msg.clone()))\n+        let msg = format!(\"Unhandled condition: {}: {:?}\", self.name, t);\n+        self.raise_default(t, || fail2!(\"{}\", msg.clone()))\n     }\n \n     /// Performs the same functionality as `raise`, except that when no handler\n     /// is found the `default` argument is called instead of failing the task.\n     pub fn raise_default(&self, t: T, default: &fn() -> U) -> U {\n         match local_data::pop(self.key) {\n             None => {\n-                debug!(\"Condition.raise: found no handler\");\n+                debug2!(\"Condition.raise: found no handler\");\n                 default()\n             }\n             Some(handler) => {\n-                debug!(\"Condition.raise: found handler\");\n+                debug2!(\"Condition.raise: found handler\");\n                 match handler.prev {\n                     None => {}\n                     Some(hp) => local_data::set(self.key, hp)\n@@ -183,7 +183,7 @@ impl<'self, T, U> Trap<'self, T, U> {\n     /// ```\n     pub fn inside<V>(&self, inner: &'self fn() -> V) -> V {\n         let _g = Guard { cond: self.cond };\n-        debug!(\"Trap: pushing handler to TLS\");\n+        debug2!(\"Trap: pushing handler to TLS\");\n         local_data::set(self.cond.key, self.handler);\n         inner()\n     }\n@@ -197,7 +197,7 @@ struct Guard<'self, T, U> {\n #[unsafe_destructor]\n impl<'self, T, U> Drop for Guard<'self, T, U> {\n     fn drop(&mut self) {\n-        debug!(\"Guard: popping handler from TLS\");\n+        debug2!(\"Guard: popping handler from TLS\");\n         let curr = local_data::pop(self.cond.key);\n         match curr {\n             None => {}\n@@ -216,20 +216,20 @@ mod test {\n     }\n \n     fn trouble(i: int) {\n-        debug!(\"trouble: raising condition\");\n+        debug2!(\"trouble: raising condition\");\n         let j = sadness::cond.raise(i);\n-        debug!(\"trouble: handler recovered with %d\", j);\n+        debug2!(\"trouble: handler recovered with {}\", j);\n     }\n \n     fn nested_trap_test_inner() {\n         let mut inner_trapped = false;\n \n         do sadness::cond.trap(|_j| {\n-            debug!(\"nested_trap_test_inner: in handler\");\n+            debug2!(\"nested_trap_test_inner: in handler\");\n             inner_trapped = true;\n             0\n         }).inside {\n-            debug!(\"nested_trap_test_inner: in protected block\");\n+            debug2!(\"nested_trap_test_inner: in protected block\");\n             trouble(1);\n         }\n \n@@ -241,10 +241,10 @@ mod test {\n         let mut outer_trapped = false;\n \n         do sadness::cond.trap(|_j| {\n-            debug!(\"nested_trap_test_outer: in handler\");\n+            debug2!(\"nested_trap_test_outer: in handler\");\n             outer_trapped = true; 0\n         }).inside {\n-            debug!(\"nested_guard_test_outer: in protected block\");\n+            debug2!(\"nested_guard_test_outer: in protected block\");\n             nested_trap_test_inner();\n             trouble(1);\n         }\n@@ -256,13 +256,13 @@ mod test {\n         let mut inner_trapped = false;\n \n         do sadness::cond.trap(|_j| {\n-            debug!(\"nested_reraise_trap_test_inner: in handler\");\n+            debug2!(\"nested_reraise_trap_test_inner: in handler\");\n             inner_trapped = true;\n             let i = 10;\n-            debug!(\"nested_reraise_trap_test_inner: handler re-raising\");\n+            debug2!(\"nested_reraise_trap_test_inner: handler re-raising\");\n             sadness::cond.raise(i)\n         }).inside {\n-            debug!(\"nested_reraise_trap_test_inner: in protected block\");\n+            debug2!(\"nested_reraise_trap_test_inner: in protected block\");\n             trouble(1);\n         }\n \n@@ -274,10 +274,10 @@ mod test {\n         let mut outer_trapped = false;\n \n         do sadness::cond.trap(|_j| {\n-            debug!(\"nested_reraise_trap_test_outer: in handler\");\n+            debug2!(\"nested_reraise_trap_test_outer: in handler\");\n             outer_trapped = true; 0\n         }).inside {\n-            debug!(\"nested_reraise_trap_test_outer: in protected block\");\n+            debug2!(\"nested_reraise_trap_test_outer: in protected block\");\n             nested_reraise_trap_test_inner();\n         }\n \n@@ -289,10 +289,10 @@ mod test {\n         let mut trapped = false;\n \n         do sadness::cond.trap(|j| {\n-            debug!(\"test_default: in handler\");\n+            debug2!(\"test_default: in handler\");\n             sadness::cond.raise_default(j, || { trapped=true; 5 })\n         }).inside {\n-            debug!(\"test_default: in protected block\");\n+            debug2!(\"test_default: in protected block\");\n             trouble(1);\n         }\n "}, {"sha": "657212fc692270f32fffd317ae0c35718eaeefa8", "filename": "src/libstd/either.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -78,7 +78,7 @@ impl<L, R> Either<L, R> {\n     pub fn expect_left(self, reason: &str) -> L {\n         match self {\n             Left(x) => x,\n-            Right(_) => fail!(reason.to_owned())\n+            Right(_) => fail2!(\"{}\", reason.to_owned())\n         }\n     }\n \n@@ -94,7 +94,7 @@ impl<L, R> Either<L, R> {\n     pub fn expect_right(self, reason: &str) -> R {\n         match self {\n             Right(x) => x,\n-            Left(_) => fail!(reason.to_owned())\n+            Left(_) => fail2!(\"{}\", reason.to_owned())\n         }\n     }\n "}, {"sha": "b185b67d09cbf10269848de012fc50d28dc79d3d", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -234,7 +234,7 @@ impl<'self> Parser<'self> {\n             Some((_, c @ '#')) | Some((_, c @ '{')) |\n             Some((_, c @ '\\\\')) | Some((_, c @ '}')) => { c }\n             Some((_, c)) => {\n-                self.err(fmt!(\"invalid escape character `%c`\", c));\n+                self.err(format!(\"invalid escape character `{}`\", c));\n                 c\n             }\n             None => {\n@@ -378,7 +378,7 @@ impl<'self> Parser<'self> {\n                 return None;\n             }\n             method => {\n-                self.err(fmt!(\"unknown method: `%s`\", method));\n+                self.err(format!(\"unknown method: `{}`\", method));\n                 return None;\n             }\n         }\n@@ -448,8 +448,8 @@ impl<'self> Parser<'self> {\n                     Some((_, 'f')) => {\n                         let word = self.word();\n                         if word != \"offset\" {\n-                            self.err(fmt!(\"expected `offset`, found `%s`\",\n-                                          word));\n+                            self.err(format!(\"expected `offset`, found `{}`\",\n+                                             word));\n                         } else {\n                             if !self.consume(':') {\n                                 self.err(~\"`offset` must be followed by `:`\");\n@@ -490,7 +490,8 @@ impl<'self> Parser<'self> {\n                     \"few\"   => Left(Few),\n                     \"many\"  => Left(Many),\n                     word    => {\n-                        self.err(fmt!(\"unexpected plural selector `%s`\", word));\n+                        self.err(format!(\"unexpected plural selector `{}`\",\n+                                         word));\n                         if word == \"\" {\n                             break\n                         } else {"}, {"sha": "d63acb74acdb1e5313331b0f6d505608ddc825e4", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -493,18 +493,18 @@ mod tests {\n         }\n \n         while t < 64 {\n-            debug!(\"siphash test %?\", t);\n+            debug2!(\"siphash test {}\", t);\n             let vec = u8to64_le!(vecs[t], 0);\n             let out = Bytes(buf.as_slice()).hash_keyed(k0, k1);\n-            debug!(\"got %?, expected %?\", out, vec);\n+            debug2!(\"got {:?}, expected {:?}\", out, vec);\n             assert_eq!(vec, out);\n \n             stream_full.reset();\n             stream_full.input(buf);\n             let f = stream_full.result_str();\n             let i = stream_inc.result_str();\n             let v = to_hex_str(&vecs[t]);\n-            debug!(\"%d: (%s) => inc=%s full=%s\", t, v, i, f);\n+            debug2!(\"{}: ({}) => inc={} full={}\", t, v, i, f);\n \n             assert!(f == i && f == v);\n "}, {"sha": "7b18bed0098928dc09ddfda7c25f5c839dd53531", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -179,7 +179,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n     fn value_for_bucket<'a>(&'a self, idx: uint) -> &'a V {\n         match self.buckets[idx] {\n             Some(ref bkt) => &bkt.value,\n-            None => fail!(\"HashMap::find: internal logic error\"),\n+            None => fail2!(\"HashMap::find: internal logic error\"),\n         }\n     }\n \n@@ -196,7 +196,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n     /// True if there was no previous entry with that key\n     fn insert_internal(&mut self, hash: uint, k: K, v: V) -> Option<V> {\n         match self.bucket_for_key_with_hash(hash, &k) {\n-            TableFull => { fail!(\"Internal logic error\"); }\n+            TableFull => { fail2!(\"Internal logic error\"); }\n             FoundHole(idx) => {\n                 self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n                                                 value: v});\n@@ -205,7 +205,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n             }\n             FoundEntry(idx) => {\n                 match self.buckets[idx] {\n-                    None => { fail!(\"insert_internal: Internal logic error\") }\n+                    None => { fail2!(\"insert_internal: Internal logic error\") }\n                     Some(ref mut b) => {\n                         b.hash = hash;\n                         b.key = k;\n@@ -374,7 +374,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n \n         let hash = k.hash_keyed(self.k0, self.k1) as uint;\n         let idx = match self.bucket_for_key_with_hash(hash, &k) {\n-            TableFull => fail!(\"Internal logic error\"),\n+            TableFull => fail2!(\"Internal logic error\"),\n             FoundEntry(idx) => { found(&k, self.mut_value_for_bucket(idx), a); idx }\n             FoundHole(idx) => {\n                 let v = not_found(&k, a);\n@@ -413,7 +413,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n     pub fn get<'a>(&'a self, k: &K) -> &'a V {\n         match self.find(k) {\n             Some(v) => v,\n-            None => fail!(\"No entry found for key: %?\", k),\n+            None => fail2!(\"No entry found for key: {:?}\", k),\n         }\n     }\n \n@@ -422,7 +422,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n     pub fn get_mut<'a>(&'a mut self, k: &K) -> &'a mut V {\n         match self.find_mut(k) {\n             Some(v) => v,\n-            None => fail!(\"No entry found for key: %?\", k),\n+            None => fail2!(\"No entry found for key: {:?}\", k),\n         }\n     }\n \n@@ -826,7 +826,7 @@ mod test_map {\n         assert!(m.insert(5, 14));\n         let new = 100;\n         match m.find_mut(&5) {\n-            None => fail!(), Some(x) => *x = new\n+            None => fail2!(), Some(x) => *x = new\n         }\n         assert_eq!(m.find(&5), Some(&new));\n     }\n@@ -943,7 +943,7 @@ mod test_map {\n         assert!(m.find(&1).is_none());\n         m.insert(1, 2);\n         match m.find(&1) {\n-            None => fail!(),\n+            None => fail2!(),\n             Some(v) => assert!(*v == 2)\n         }\n     }"}, {"sha": "dfe517932fcf65048d3b4aa0185cc32588519751", "filename": "src/libstd/io.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -947,9 +947,8 @@ impl Reader for *libc::FILE {\n                   match libc::ferror(*self) {\n                     0 => (),\n                     _ => {\n-                      error!(\"error reading buffer\");\n-                      error!(\"%s\", os::last_os_error());\n-                      fail!();\n+                      error2!(\"error reading buffer: {}\", os::last_os_error());\n+                      fail2!();\n                     }\n                   }\n                 }\n@@ -1194,9 +1193,8 @@ impl Writer for *libc::FILE {\n                                         len as size_t,\n                                         *self);\n                 if nout != len as size_t {\n-                    error!(\"error writing buffer\");\n-                    error!(\"%s\", os::last_os_error());\n-                    fail!();\n+                    error2!(\"error writing buffer: {}\", os::last_os_error());\n+                    fail2!();\n                 }\n             }\n         }\n@@ -1264,22 +1262,21 @@ impl Writer for fd_t {\n                     let vb = ptr::offset(vbuf, count as int) as *c_void;\n                     let nout = libc::write(*self, vb, len as IoSize);\n                     if nout < 0 as IoRet {\n-                        error!(\"error writing buffer\");\n-                        error!(\"%s\", os::last_os_error());\n-                        fail!();\n+                        error2!(\"error writing buffer: {}\", os::last_os_error());\n+                        fail2!();\n                     }\n                     count += nout as uint;\n                 }\n             }\n         }\n     }\n     fn seek(&self, _offset: int, _whence: SeekStyle) {\n-        error!(\"need 64-bit foreign calls for seek, sorry\");\n-        fail!();\n+        error2!(\"need 64-bit foreign calls for seek, sorry\");\n+        fail2!();\n     }\n     fn tell(&self) -> uint {\n-        error!(\"need 64-bit foreign calls for tell, sorry\");\n-        fail!();\n+        error2!(\"need 64-bit foreign calls for tell, sorry\");\n+        fail2!();\n     }\n     fn flush(&self) -> int { 0 }\n     fn get_type(&self) -> WriterType {\n@@ -1347,7 +1344,7 @@ pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n         }\n     };\n     if fd < (0 as c_int) {\n-        Err(fmt!(\"error opening %s: %s\", path.to_str(), os::last_os_error()))\n+        Err(format!(\"error opening {}: {}\", path.to_str(), os::last_os_error()))\n     } else {\n         Ok(fd_writer(fd, true))\n     }\n@@ -1924,17 +1921,17 @@ mod tests {\n     #[test]\n     fn test_simple() {\n         let tmpfile = &Path(\"tmp/lib-io-test-simple.tmp\");\n-        debug!(tmpfile);\n+        debug2!(\"{:?}\", tmpfile);\n         let frood: ~str =\n             ~\"A hoopy frood who really knows where his towel is.\";\n-        debug!(frood.clone());\n+        debug2!(\"{}\", frood.clone());\n         {\n             let out = io::file_writer(tmpfile, [io::Create, io::Truncate]).unwrap();\n             out.write_str(frood);\n         }\n         let inp = io::file_reader(tmpfile).unwrap();\n         let frood2: ~str = inp.read_c_str();\n-        debug!(frood2.clone());\n+        debug2!(\"{}\", frood2.clone());\n         assert_eq!(frood, frood2);\n     }\n \n@@ -1951,14 +1948,14 @@ mod tests {\n         {\n             let file = io::file_reader(&path).unwrap();\n             do file.each_byte() |_| {\n-                fail!(\"must be empty\")\n+                fail2!(\"must be empty\")\n             };\n         }\n \n         {\n             let file = io::file_reader(&path).unwrap();\n             do file.each_char() |_| {\n-                fail!(\"must be empty\")\n+                fail2!(\"must be empty\")\n             };\n         }\n     }\n@@ -2045,7 +2042,7 @@ mod tests {\n           Err(e) => {\n             assert_eq!(e, ~\"error opening not a file\");\n           }\n-          Ok(_) => fail!()\n+          Ok(_) => fail2!()\n         }\n     }\n \n@@ -2085,7 +2082,7 @@ mod tests {\n           Err(e) => {\n             assert!(e.starts_with(\"error opening\"));\n           }\n-          Ok(_) => fail!()\n+          Ok(_) => fail2!()\n         }\n     }\n \n@@ -2095,7 +2092,7 @@ mod tests {\n           Err(e) => {\n             assert!(e.starts_with(\"error opening\"));\n           }\n-          Ok(_) => fail!()\n+          Ok(_) => fail2!()\n         }\n     }\n "}, {"sha": "f1e0eff5616c930021444df95ab14ef7bb72eadf", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -723,7 +723,7 @@ pub trait ExactSize<A> : DoubleEndedIterator<A> {\n                 Some(x) => {\n                     i = match i.checked_sub(&1) {\n                         Some(x) => x,\n-                        None => fail!(\"rposition: incorrect ExactSize\")\n+                        None => fail2!(\"rposition: incorrect ExactSize\")\n                     };\n                     if predicate(x) {\n                         return Some(i)\n@@ -2452,7 +2452,7 @@ mod tests {\n         assert!(v.iter().all(|&x| x < 10));\n         assert!(!v.iter().all(|&x| x.is_even()));\n         assert!(!v.iter().all(|&x| x > 100));\n-        assert!(v.slice(0, 0).iter().all(|_| fail!()));\n+        assert!(v.slice(0, 0).iter().all(|_| fail2!()));\n     }\n \n     #[test]\n@@ -2461,7 +2461,7 @@ mod tests {\n         assert!(v.iter().any(|&x| x < 10));\n         assert!(v.iter().any(|&x| x.is_even()));\n         assert!(!v.iter().any(|&x| x > 100));\n-        assert!(!v.slice(0, 0).iter().any(|_| fail!()));\n+        assert!(!v.slice(0, 0).iter().any(|_| fail2!()));\n     }\n \n     #[test]\n@@ -2602,7 +2602,7 @@ mod tests {\n         let mut i = 0;\n         do v.iter().rposition |_elt| {\n             if i == 2 {\n-                fail!()\n+                fail2!()\n             }\n             i += 1;\n             false\n@@ -2746,12 +2746,12 @@ mod tests {\n     fn test_double_ended_range() {\n         assert_eq!(range(11i, 14).invert().collect::<~[int]>(), ~[13i, 12, 11]);\n         for _ in range(10i, 0).invert() {\n-            fail!(\"unreachable\");\n+            fail2!(\"unreachable\");\n         }\n \n         assert_eq!(range(11u, 14).invert().collect::<~[uint]>(), ~[13u, 12, 11]);\n         for _ in range(10u, 0).invert() {\n-            fail!(\"unreachable\");\n+            fail2!(\"unreachable\");\n         }\n     }\n "}, {"sha": "54c77e2d9f64dcaf75ffa21b5c0d154f45fdd098", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -143,8 +143,8 @@ pub fn pop<T: 'static>(key: Key<T>) -> Option<T> {\n         match *entry {\n             Some((k, _, loan)) if k == key_value => {\n                 if loan != NoLoan {\n-                    fail!(\"TLS value cannot be removed because it is currently \\\n-                          borrowed as %s\", loan.describe());\n+                    fail2!(\"TLS value cannot be removed because it is currently \\\n+                          borrowed as {}\", loan.describe());\n                 }\n                 // Move the data out of the `entry` slot via util::replace.\n                 // This is guaranteed to succeed because we already matched\n@@ -240,8 +240,8 @@ fn get_with<T: 'static, U>(key: Key<T>,\n                         }\n                         (ImmLoan, ImmLoan) => {}\n                         (want, cur) => {\n-                            fail!(\"TLS slot cannot be borrowed as %s because \\\n-                                   it is already borrowed as %s\",\n+                            fail2!(\"TLS slot cannot be borrowed as {} because \\\n+                                    it is already borrowed as {}\",\n                                   want.describe(), cur.describe());\n                         }\n                     }\n@@ -304,8 +304,8 @@ pub fn set<T: 'static>(key: Key<T>, data: T) {\n             match *entry {\n                 Some((ekey, _, loan)) if key == ekey => {\n                     if loan != NoLoan {\n-                        fail!(\"TLS value cannot be overwritten because it is\n-                               already borrowed as %s\", loan.describe())\n+                        fail2!(\"TLS value cannot be overwritten because it is\n+                               already borrowed as {}\", loan.describe())\n                     }\n                     true\n                 }\n@@ -388,15 +388,15 @@ mod tests {\n         static my_key: Key<@~str> = &Key;\n         modify(my_key, |data| {\n             match data {\n-                Some(@ref val) => fail!(\"unwelcome value: %s\", *val),\n+                Some(@ref val) => fail2!(\"unwelcome value: {}\", *val),\n                 None           => Some(@~\"first data\")\n             }\n         });\n         modify(my_key, |data| {\n             match data {\n                 Some(@~\"first data\") => Some(@~\"next data\"),\n-                Some(@ref val)       => fail!(\"wrong value: %s\", *val),\n-                None                 => fail!(\"missing value\")\n+                Some(@ref val)       => fail2!(\"wrong value: {}\", *val),\n+                None                 => fail2!(\"missing value\")\n             }\n         });\n         assert!(*(pop(my_key).unwrap()) == ~\"next data\");\n@@ -456,11 +456,11 @@ mod tests {\n             set(str_key, @~\"string data\");\n             set(box_key, @@());\n             set(int_key, @42);\n-            fail!();\n+            fail2!();\n         }\n         // Not quite nondeterministic.\n         set(int_key, @31337);\n-        fail!();\n+        fail2!();\n     }\n \n     #[test]"}, {"sha": "0b1475ff3801420b5526bda14833ce1185b873d4", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -12,16 +12,16 @@\n #[doc(hidden)];\n \n macro_rules! rterrln (\n-    ($( $arg:expr),+) => ( {\n-        ::rt::util::dumb_println(fmt!( $($arg),+ ));\n+    ($($arg:tt)*) => ( {\n+        ::rt::util::dumb_println(format!($($arg)*));\n     } )\n )\n \n // Some basic logging. Enabled by passing `--cfg rtdebug` to the libstd build.\n macro_rules! rtdebug (\n-    ($( $arg:expr),+) => ( {\n+    ($($arg:tt)*) => ( {\n         if cfg!(rtdebug) {\n-            rterrln!( $($arg),+ )\n+            rterrln!($($arg)*)\n         }\n     })\n )\n@@ -30,29 +30,30 @@ macro_rules! rtassert (\n     ( $arg:expr ) => ( {\n         if ::rt::util::ENFORCE_SANITY {\n             if !$arg {\n-                rtabort!(\"assertion failed: %s\", stringify!($arg));\n+                rtabort!(\"assertion failed: {}\", stringify!($arg));\n             }\n         }\n     } )\n )\n \n \n macro_rules! rtabort(\n-    ($( $msg:expr),+) => ( {\n-        ::rt::util::abort(fmt!($($msg),+));\n+    ($($msg:tt)*) => ( {\n+        ::rt::util::abort(format!($($msg)*));\n     } )\n )\n \n macro_rules! assert_once_ever(\n-    ($( $msg:expr),+) => ( {\n+    ($($msg:tt)+) => ( {\n         // FIXME(#8472) extra function should not be needed to hide unsafe\n         fn assert_once_ever() {\n             unsafe {\n                 static mut already_happened: int = 0;\n                 // Double-check lock to avoid a swap in the common case.\n                 if already_happened != 0 ||\n                     ::unstable::intrinsics::atomic_xchg_relaxed(&mut already_happened, 1) != 0 {\n-                        fail!(fmt!(\"assert_once_ever happened twice: %s\", fmt!($($msg),+)));\n+                        fail2!(\"assert_once_ever happened twice: {}\",\n+                               format!($($msg)+));\n                 }\n             }\n         }"}, {"sha": "8d76786c6d1ec2ae753dc4935b93941fda4a2312", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -816,8 +816,8 @@ impl num::ToStrRadix for f32 {\n     fn to_str_radix(&self, rdx: uint) -> ~str {\n         let (r, special) = strconv::float_to_str_common(\n             *self, rdx, true, strconv::SignNeg, strconv::DigAll);\n-        if special { fail!(\"number has a special value, \\\n-                          try to_str_radix_special() if those are expected\") }\n+        if special { fail2!(\"number has a special value, \\\n+                             try to_str_radix_special() if those are expected\") }\n         r\n     }\n }"}, {"sha": "6cd0ba63828122871f1c44f6e18bc478f8b166e7", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -864,8 +864,8 @@ impl num::ToStrRadix for f64 {\n     fn to_str_radix(&self, rdx: uint) -> ~str {\n         let (r, special) = strconv::float_to_str_common(\n             *self, rdx, true, strconv::SignNeg, strconv::DigAll);\n-        if special { fail!(\"number has a special value, \\\n-                          try to_str_radix_special() if those are expected\") }\n+        if special { fail2!(\"number has a special value, \\\n+                             try to_str_radix_special() if those are expected\") }\n         r\n     }\n }"}, {"sha": "4f676545d4f068c98cca83f08eb5cd62c4139339", "filename": "src/libstd/num/float.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -181,7 +181,7 @@ impl num::ToStrRadix for float {\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         let (r, special) = strconv::float_to_str_common(\n             *self, radix, true, strconv::SignNeg, strconv::DigAll);\n-        if special { fail!(\"number has a special value, \\\n+        if special { fail2!(\"number has a special value, \\\n                              try to_str_radix_special() if those are expected\") }\n         r\n     }\n@@ -1329,16 +1329,16 @@ mod tests {\n         // note: NaN != NaN, hence this slightly complex test\n         match from_str::<float>(\"NaN\") {\n             Some(f) => assert!(f.is_nan()),\n-            None => fail!()\n+            None => fail2!()\n         }\n         // note: -0 == 0, hence these slightly more complex tests\n         match from_str::<float>(\"-0\") {\n             Some(v) if v.is_zero() => assert!(v.is_negative()),\n-            _ => fail!()\n+            _ => fail2!()\n         }\n         match from_str::<float>(\"0\") {\n             Some(v) if v.is_zero() => assert!(v.is_positive()),\n-            _ => fail!()\n+            _ => fail2!()\n         }\n \n         assert!(from_str::<float>(\"\").is_none());\n@@ -1376,16 +1376,16 @@ mod tests {\n         // note: NaN != NaN, hence this slightly complex test\n         match from_str_hex(\"NaN\") {\n             Some(f) => assert!(f.is_nan()),\n-            None => fail!()\n+            None => fail2!()\n         }\n         // note: -0 == 0, hence these slightly more complex tests\n         match from_str_hex(\"-0\") {\n             Some(v) if v.is_zero() => assert!(v.is_negative()),\n-            _ => fail!()\n+            _ => fail2!()\n         }\n         match from_str_hex(\"0\") {\n             Some(v) if v.is_zero() => assert!(v.is_positive()),\n-            _ => fail!()\n+            _ => fail2!()\n         }\n         assert_eq!(from_str_hex(\"e\"), Some(14.));\n         assert_eq!(from_str_hex(\"E\"), Some(14.));"}, {"sha": "19e6a2dd0ef6b92d3059496e1393109ec25a99a4", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -474,19 +474,19 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+\n         ) -> Option<T> {\n     match exponent {\n         ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n-          => fail!(\"from_str_bytes_common: radix %? incompatible with \\\n+          => fail2!(\"from_str_bytes_common: radix {:?} incompatible with \\\n                     use of 'e' as decimal exponent\", radix),\n         ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n-          => fail!(\"from_str_bytes_common: radix %? incompatible with \\\n+          => fail2!(\"from_str_bytes_common: radix {:?} incompatible with \\\n                     use of 'p' as binary exponent\", radix),\n         _ if special && radix >= DIGIT_I_RADIX // first digit of 'inf'\n-          => fail!(\"from_str_bytes_common: radix %? incompatible with \\\n+          => fail2!(\"from_str_bytes_common: radix {:?} incompatible with \\\n                     special values 'inf' and 'NaN'\", radix),\n         _ if (radix as int) < 2\n-          => fail!(\"from_str_bytes_common: radix %? to low, \\\n+          => fail2!(\"from_str_bytes_common: radix {:?} to low, \\\n                     must lie in the range [2, 36]\", radix),\n         _ if (radix as int) > 36\n-          => fail!(\"from_str_bytes_common: radix %? to high, \\\n+          => fail2!(\"from_str_bytes_common: radix {:?} to high, \\\n                     must lie in the range [2, 36]\", radix),\n         _ => ()\n     }"}, {"sha": "033515875ddc6ebc87570f978ea844ac0d626c20", "filename": "src/libstd/option.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -278,7 +278,7 @@ impl<T> Option<T> {\n     pub fn get_ref<'a>(&'a self) -> &'a T {\n         match *self {\n             Some(ref x) => x,\n-            None => fail!(\"called `Option::get_ref()` on a `None` value\"),\n+            None => fail2!(\"called `Option::get_ref()` on a `None` value\"),\n         }\n     }\n \n@@ -298,7 +298,7 @@ impl<T> Option<T> {\n     pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {\n         match *self {\n             Some(ref mut x) => x,\n-            None => fail!(\"called `Option::get_mut_ref()` on a `None` value\"),\n+            None => fail2!(\"called `Option::get_mut_ref()` on a `None` value\"),\n         }\n     }\n \n@@ -320,7 +320,7 @@ impl<T> Option<T> {\n     pub fn unwrap(self) -> T {\n         match self {\n             Some(x) => x,\n-            None => fail!(\"called `Option::unwrap()` on a `None` value\"),\n+            None => fail2!(\"called `Option::unwrap()` on a `None` value\"),\n         }\n     }\n \n@@ -333,7 +333,7 @@ impl<T> Option<T> {\n     #[inline]\n     pub fn take_unwrap(&mut self) -> T {\n         if self.is_none() {\n-            fail!(\"called `Option::take_unwrap()` on a `None` value\")\n+            fail2!(\"called `Option::take_unwrap()` on a `None` value\")\n         }\n         self.take().unwrap()\n     }\n@@ -348,7 +348,7 @@ impl<T> Option<T> {\n     pub fn expect(self, reason: &str) -> T {\n         match self {\n             Some(val) => val,\n-            None => fail!(reason.to_owned()),\n+            None => fail2!(\"{}\", reason.to_owned()),\n         }\n     }\n \n@@ -722,21 +722,23 @@ mod tests {\n         let new_val = 11;\n \n         let mut x = Some(val);\n-        let mut it = x.mut_iter();\n+        {\n+            let mut it = x.mut_iter();\n \n-        assert_eq!(it.size_hint(), (1, Some(1)));\n+            assert_eq!(it.size_hint(), (1, Some(1)));\n \n-        match it.next() {\n-            Some(interior) => {\n-                assert_eq!(*interior, val);\n-                *interior = new_val;\n-                assert_eq!(x, Some(new_val));\n+            match it.next() {\n+                Some(interior) => {\n+                    assert_eq!(*interior, val);\n+                    *interior = new_val;\n+                }\n+                None => assert!(false),\n             }\n-            None => assert!(false),\n-        }\n \n-        assert_eq!(it.size_hint(), (0, Some(0)));\n-        assert!(it.next().is_none());\n+            assert_eq!(it.size_hint(), (0, Some(0)));\n+            assert!(it.next().is_none());\n+        }\n+        assert_eq!(x, Some(new_val));\n     }\n \n     #[test]"}, {"sha": "6d56aab3ec9d47ff6b5dd9528ba8abb475c7c7a1", "filename": "src/libstd/os.rs", "status": "modified", "additions": 39, "deletions": 41, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -75,7 +75,7 @@ pub fn getcwd() -> Path {\n     do buf.as_mut_buf |buf, len| {\n         unsafe {\n             if libc::getcwd(buf, len as size_t).is_null() {\n-                fail!()\n+                fail2!()\n             }\n \n             Path(str::raw::from_c_str(buf as *c_char))\n@@ -182,7 +182,8 @@ pub fn env() -> ~[(~str,~str)] {\n             };\n             let ch = GetEnvironmentStringsA();\n             if (ch as uint == 0) {\n-                fail!(\"os::env() failure getting env string from OS: %s\", os::last_os_error());\n+                fail2!(\"os::env() failure getting env string from OS: {}\",\n+                       os::last_os_error());\n             }\n             let result = str::raw::from_c_multistring(ch as *libc::c_char, None);\n             FreeEnvironmentStringsA(ch);\n@@ -197,13 +198,13 @@ pub fn env() -> ~[(~str,~str)] {\n             }\n             let environ = rust_env_pairs();\n             if (environ as uint == 0) {\n-                fail!(\"os::env() failure getting env string from OS: %s\", os::last_os_error());\n+                fail2!(\"os::env() failure getting env string from OS: {}\",\n+                       os::last_os_error());\n             }\n             let mut result = ~[];\n             ptr::array_each(environ, |e| {\n                 let env_pair = str::raw::from_c_str(e);\n-                debug!(\"get_env_pairs: %s\",\n-                       env_pair);\n+                debug2!(\"get_env_pairs: {}\", env_pair);\n                 result.push(env_pair);\n             });\n             result\n@@ -213,8 +214,7 @@ pub fn env() -> ~[(~str,~str)] {\n             let mut pairs = ~[];\n             for p in input.iter() {\n                 let vs: ~[&str] = p.splitn_iter('=', 1).collect();\n-                debug!(\"splitting: len: %u\",\n-                    vs.len());\n+                debug2!(\"splitting: len: {}\", vs.len());\n                 assert_eq!(vs.len(), 2);\n                 pairs.push((vs[0].to_owned(), vs[1].to_owned()));\n             }\n@@ -443,7 +443,7 @@ fn dup2(src: c_int, dst: c_int) -> c_int {\n \n /// Returns the proper dll filename for the given basename of a file.\n pub fn dll_filename(base: &str) -> ~str {\n-    fmt!(\"%s%s%s\", DLL_PREFIX, base, DLL_SUFFIX)\n+    format!(\"{}{}{}\", DLL_PREFIX, base, DLL_SUFFIX)\n }\n \n /// Optionally returns the filesystem path to the current executable which is\n@@ -722,14 +722,14 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n                 fn rust_list_dir_val(ptr: *dirent_t) -> *libc::c_char;\n             }\n             let mut strings = ~[];\n-            debug!(\"os::list_dir -- BEFORE OPENDIR\");\n+            debug2!(\"os::list_dir -- BEFORE OPENDIR\");\n \n             let dir_ptr = do p.with_c_str |buf| {\n                 opendir(buf)\n             };\n \n             if (dir_ptr as uint != 0) {\n-                debug!(\"os::list_dir -- opendir() SUCCESS\");\n+                debug2!(\"os::list_dir -- opendir() SUCCESS\");\n                 let mut entry_ptr = readdir(dir_ptr);\n                 while (entry_ptr as uint != 0) {\n                     strings.push(str::raw::from_c_str(rust_list_dir_val(\n@@ -739,11 +739,9 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n                 closedir(dir_ptr);\n             }\n             else {\n-                debug!(\"os::list_dir -- opendir() FAILURE\");\n+                debug2!(\"os::list_dir -- opendir() FAILURE\");\n             }\n-            debug!(\n-                \"os::list_dir -- AFTER -- #: %?\",\n-                     strings.len());\n+            debug2!(\"os::list_dir -- AFTER -- \\\\#: {}\", strings.len());\n             strings\n         }\n         #[cfg(windows)]\n@@ -777,7 +775,7 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n                     while more_files != 0 {\n                         let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr);\n                         if fp_buf as uint == 0 {\n-                            fail!(\"os::list_dir() failure: got null ptr from wfd\");\n+                            fail2!(\"os::list_dir() failure: got null ptr from wfd\");\n                         }\n                         else {\n                             let fp_vec = vec::from_buf(\n@@ -1101,7 +1099,7 @@ pub fn last_os_error() -> ~str {\n         do buf.as_mut_buf |buf, len| {\n             unsafe {\n                 if strerror_r(errno() as c_int, buf, len as size_t) < 0 {\n-                    fail!(\"strerror_r failure\");\n+                    fail2!(\"strerror_r failure\");\n                 }\n \n                 str::raw::from_c_str(buf as *c_char)\n@@ -1166,7 +1164,7 @@ pub fn last_os_error() -> ~str {\n                                          len as DWORD,\n                                          ptr::null());\n                 if res == 0 {\n-                    fail!(\"[%?] FormatMessage failure\", errno());\n+                    fail2!(\"[%?] FormatMessage failure\", errno());\n                 }\n             }\n \n@@ -1222,7 +1220,7 @@ fn real_args() -> ~[~str] {\n \n     match rt::args::clone() {\n         Some(args) => args,\n-        None => fail!(\"process arguments not initialized\")\n+        None => fail2!(\"process arguments not initialized\")\n     }\n }\n \n@@ -1385,13 +1383,13 @@ impl to_str::ToStr for MapError {\n                               negative length or unaligned offset\",\n             ErrNoMapSupport=> ~\"File doesn't support mapping\",\n             ErrNoMem => ~\"Invalid address, or not enough available memory\",\n-            ErrUnknown(code) => fmt!(\"Unknown error=%?\", code),\n+            ErrUnknown(code) => format!(\"Unknown error={}\", code),\n             ErrUnsupProt => ~\"Protection mode unsupported\",\n             ErrUnsupOffset => ~\"Offset in virtual memory mode is unsupported\",\n             ErrAlreadyExists => ~\"File mapping for specified file already exists\",\n-            ErrVirtualAlloc(code) => fmt!(\"VirtualAlloc failure=%?\", code),\n-            ErrCreateFileMappingW(code) => fmt!(\"CreateFileMappingW failure=%?\", code),\n-            ErrMapViewOfFile(code) => fmt!(\"MapViewOfFile failure=%?\", code)\n+            ErrVirtualAlloc(code) => format!(\"VirtualAlloc failure={}\", code),\n+            ErrCreateFileMappingW(code) => format!(\"CreateFileMappingW failure={}\", code),\n+            ErrMapViewOfFile(code) => format!(\"MapViewOfFile failure={}\", code)\n         }\n     }\n }\n@@ -1466,11 +1464,11 @@ impl Drop for MemoryMap {\n         unsafe {\n             match libc::munmap(self.data as *c_void, self.len) {\n                 0 => (),\n-                -1 => error!(match errno() as c_int {\n-                    libc::EINVAL => ~\"invalid addr or len\",\n-                    e => fmt!(\"unknown errno=%?\", e)\n-                }),\n-                r => error!(fmt!(\"Unexpected result %?\", r))\n+                -1 => match errno() as c_int {\n+                    libc::EINVAL => error2!(\"invalid addr or len\"),\n+                    e => error2!(\"unknown errno={}\", e)\n+                },\n+                r => error2!(\"Unexpected result {}\", r)\n             }\n         }\n     }\n@@ -1598,15 +1596,15 @@ impl Drop for MemoryMap {\n                     if libc::VirtualFree(self.data as *mut c_void,\n                                          self.len,\n                                          libc::MEM_RELEASE) == FALSE {\n-                        error!(fmt!(\"VirtualFree failed: %?\", errno()));\n+                        error!(format!(\"VirtualFree failed: {}\", errno()));\n                     }\n                 },\n                 MapFile(mapping) => {\n                     if libc::UnmapViewOfFile(self.data as LPCVOID) == FALSE {\n-                        error!(fmt!(\"UnmapViewOfFile failed: %?\", errno()));\n+                        error!(format!(\"UnmapViewOfFile failed: {}\", errno()));\n                     }\n                     if libc::CloseHandle(mapping as HANDLE) == FALSE {\n-                        error!(fmt!(\"CloseHandle failed: %?\", errno()));\n+                        error!(format!(\"CloseHandle failed: {}\", errno()));\n                     }\n                 }\n             }\n@@ -1727,7 +1725,7 @@ mod tests {\n \n     #[test]\n     pub fn last_os_error() {\n-        debug!(os::last_os_error());\n+        debug2!(\"{}\", os::last_os_error());\n     }\n \n     #[test]\n@@ -1782,7 +1780,7 @@ mod tests {\n         }\n         let n = make_rand_name();\n         setenv(n, s);\n-        debug!(s.clone());\n+        debug2!(\"{}\", s.clone());\n         assert_eq!(getenv(n), option::Some(s));\n     }\n \n@@ -1791,7 +1789,7 @@ mod tests {\n         let path = os::self_exe_path();\n         assert!(path.is_some());\n         let path = path.unwrap();\n-        debug!(path.clone());\n+        debug2!(\"{:?}\", path.clone());\n \n         // Hard to test this function\n         assert!(path.is_absolute);\n@@ -1804,7 +1802,7 @@ mod tests {\n         assert!(e.len() > 0u);\n         for p in e.iter() {\n             let (n, v) = (*p).clone();\n-            debug!(n.clone());\n+            debug2!(\"{:?}\", n.clone());\n             let v2 = getenv(n);\n             // MingW seems to set some funky environment variables like\n             // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n@@ -1829,10 +1827,10 @@ mod tests {\n     fn test() {\n         assert!((!Path(\"test-path\").is_absolute));\n \n-        debug!(\"Current working directory: %s\", getcwd().to_str());\n+        debug2!(\"Current working directory: {}\", getcwd().to_str());\n \n-        debug!(make_absolute(&Path(\"test-path\")));\n-        debug!(make_absolute(&Path(\"/usr/bin\")));\n+        debug2!(\"{:?}\", make_absolute(&Path(\"test-path\")));\n+        debug2!(\"{:?}\", make_absolute(&Path(\"/usr/bin\")));\n     }\n \n     #[test]\n@@ -1895,7 +1893,7 @@ mod tests {\n         assert!(dirs.len() > 0u);\n \n         for dir in dirs.iter() {\n-            debug!((*dir).clone());\n+            debug2!(\"{:?}\", (*dir).clone());\n         }\n     }\n \n@@ -1969,7 +1967,7 @@ mod tests {\n             let in_mode = input.get_mode();\n             let rs = os::copy_file(&input, &out);\n             if (!os::path_exists(&input)) {\n-                fail!(\"%s doesn't exist\", input.to_str());\n+                fail2!(\"{} doesn't exist\", input.to_str());\n             }\n             assert!((rs));\n             let rslt = run::process_status(\"diff\", [input.to_str(), out.to_str()]);\n@@ -2001,7 +1999,7 @@ mod tests {\n             os::MapWritable\n         ]) {\n             Ok(chunk) => chunk,\n-            Err(msg) => fail!(msg.to_str())\n+            Err(msg) => fail2!(msg.to_str())\n         };\n         assert!(chunk.len >= 16);\n \n@@ -2057,7 +2055,7 @@ mod tests {\n             MapOffset(size / 2)\n         ]) {\n             Ok(chunk) => chunk,\n-            Err(msg) => fail!(msg.to_str())\n+            Err(msg) => fail2!(msg.to_str())\n         };\n         assert!(chunk.len > 0);\n "}, {"sha": "0d4bcb4ec47f998a8a6c6bf499884730c5e7b7ea", "filename": "src/libstd/path.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -134,8 +134,8 @@ pub trait GenericPath : Clone + Eq + ToStr {\n         match (t.len(), self.filestem()) {\n             (0, None)        => (*self).clone(),\n             (0, Some(ref s)) => self.with_filename(*s),\n-            (_, None)        => self.with_filename(fmt!(\".%s\", t)),\n-            (_, Some(ref s)) => self.with_filename(fmt!(\"%s.%s\", *s, t)),\n+            (_, None)        => self.with_filename(format!(\".{}\", t)),\n+            (_, Some(ref s)) => self.with_filename(format!(\"{}.{}\", *s, t)),\n         }\n     }\n \n@@ -190,7 +190,7 @@ pub trait GenericPath : Clone + Eq + ToStr {\n     /// True if `self` is an ancestor of `other`.\n     // See `test_is_ancestor_of` for examples.\n     fn is_ancestor_of(&self, other: &Self) -> bool {\n-        debug!(\"%s / %s %? %?\", self.to_str(), other.to_str(), self.is_absolute(),\n+        debug2!(\"{} / {} {} {}\", self.to_str(), other.to_str(), self.is_absolute(),\n                self.components().len());\n         self == other ||\n             (!other.components().is_empty() &&\n@@ -1101,8 +1101,8 @@ mod tests {\n             let ss = wp.to_str();\n             let sss = s.to_owned();\n             if (ss != sss) {\n-                debug!(\"got %s\", ss);\n-                debug!(\"expected %s\", sss);\n+                debug2!(\"got {}\", ss);\n+                debug2!(\"expected {}\", sss);\n                 assert_eq!(ss, sss);\n             }\n         }\n@@ -1167,8 +1167,8 @@ mod tests {\n             let ss = wp.to_str();\n             let sss = s.to_owned();\n             if (ss != sss) {\n-                debug!(\"got %s\", ss);\n-                debug!(\"expected %s\", sss);\n+                debug2!(\"got {}\", ss);\n+                debug2!(\"expected {}\", sss);\n                 assert_eq!(ss, sss);\n             }\n         }\n@@ -1230,8 +1230,8 @@ mod tests {\n             let ss = wp.to_str();\n             let sss = s.to_owned();\n             if (ss != sss) {\n-                debug!(\"got %s\", ss);\n-                debug!(\"expected %s\", sss);\n+                debug2!(\"got {}\", ss);\n+                debug2!(\"expected {}\", sss);\n                 assert_eq!(ss, sss);\n             }\n         }\n@@ -1448,7 +1448,7 @@ mod tests {\n         let p2 = PosixPath(\"/home/brian/Dev/rust/build/stage2/bin/..\").push_rel(\n             &PosixPath(\"lib/rustc/i686-unknown-linux-gnu/lib/libstd.so\"));\n         let res = p1.get_relative_to(&p2);\n-        debug!(\"test_relative_to8: %s vs. %s\",\n+        debug2!(\"test_relative_to8: {} vs. {}\",\n                res.to_str(),\n                PosixPath(\".\").to_str());\n         assert_eq!(res, PosixPath(\".\"));\n@@ -1458,7 +1458,7 @@ mod tests {\n         let p2 = WindowsPath(\"\\\\home\\\\brian\\\\Dev\\\\rust\\\\build\\\\stage2\\\\bin\\\\..\").push_rel(\n             &WindowsPath(\"lib\\\\rustc\\\\i686-unknown-linux-gnu\\\\lib\\\\libstd.so\"));\n         let res = p1.get_relative_to(&p2);\n-        debug!(\"test_relative_to8: %s vs. %s\",\n+        debug2!(\"test_relative_to8: {} vs. {}\",\n                res.to_str(),\n                WindowsPath(\".\").to_str());\n         assert_eq!(res, WindowsPath(\".\"));"}, {"sha": "c27665d76985acacde8b3995ae3b4532c0912452", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -236,16 +236,16 @@ pub fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n   SAFETY NOTE: Pointer-arithmetic. Dragons be here.\n */\n pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: &fn(*T)) {\n-    debug!(\"array_each_with_len: before iterate\");\n+    debug2!(\"array_each_with_len: before iterate\");\n     if (arr as uint == 0) {\n-        fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n+        fail2!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n     }\n     //let start_ptr = *arr;\n     for e in range(0, len) {\n         let n = offset(arr, e as int);\n         cb(*n);\n     }\n-    debug!(\"array_each_with_len: after iterate\");\n+    debug2!(\"array_each_with_len: after iterate\");\n }\n \n /**\n@@ -259,11 +259,10 @@ pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: &fn(*T)) {\n */\n pub unsafe fn array_each<T>(arr: **T, cb: &fn(*T)) {\n     if (arr as uint == 0) {\n-        fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n+        fail2!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n     }\n     let len = buf_len(arr);\n-    debug!(\"array_each inferred len: %u\",\n-                    len);\n+    debug2!(\"array_each inferred len: {}\", len);\n     array_each_with_len(arr, len, cb);\n }\n \n@@ -670,8 +669,8 @@ pub mod ptr_tests {\n                      let expected = do expected_arr[ctr].with_ref |buf| {\n                          str::raw::from_c_str(buf)\n                      };\n-                     debug!(\n-                         \"test_ptr_array_each_with_len e: %s, a: %s\",\n+                     debug2!(\n+                         \"test_ptr_array_each_with_len e: {}, a: {}\",\n                          expected, actual);\n                      assert_eq!(actual, expected);\n                      ctr += 1;\n@@ -707,8 +706,8 @@ pub mod ptr_tests {\n                      let expected = do expected_arr[ctr].with_ref |buf| {\n                          str::raw::from_c_str(buf)\n                      };\n-                     debug!(\n-                         \"test_ptr_array_each e: %s, a: %s\",\n+                     debug2!(\n+                         \"test_ptr_array_each e: {}, a: {}\",\n                          expected, actual);\n                      assert_eq!(actual, expected);\n                      ctr += 1;"}, {"sha": "cc0e843b8965083c304ae13f58fc84115782efdd", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -897,7 +897,7 @@ mod test {\n         let mut ra = IsaacRng::new_seeded(seed);\n         // Regression test that isaac is actually using the above vector\n         let r = ra.next();\n-        error!(\"%?\", r);\n+        debug2!(\"{:?}\", r);\n         assert!(r == 890007737u32 // on x86_64\n                      || r == 2935188040u32); // on x86\n     }\n@@ -940,7 +940,7 @@ mod test {\n         let mut r = rng();\n         let a = r.gen::<float>();\n         let b = r.gen::<float>();\n-        debug!((a, b));\n+        debug2!(\"{:?}\", (a, b));\n     }\n \n     #[test]\n@@ -953,9 +953,9 @@ mod test {\n     #[test]\n     fn test_gen_ascii_str() {\n         let mut r = rng();\n-        debug!(r.gen_ascii_str(10u));\n-        debug!(r.gen_ascii_str(10u));\n-        debug!(r.gen_ascii_str(10u));\n+        debug2!(\"{}\", r.gen_ascii_str(10u));\n+        debug2!(\"{}\", r.gen_ascii_str(10u));\n+        debug2!(\"{}\", r.gen_ascii_str(10u));\n         assert_eq!(r.gen_ascii_str(0u).len(), 0u);\n         assert_eq!(r.gen_ascii_str(10u).len(), 10u);\n         assert_eq!(r.gen_ascii_str(16u).len(), 16u);"}, {"sha": "e9d1accbd4795cdeb64e3af73f278e8012e5dc5b", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -189,7 +189,7 @@ impl<'self> ReprVisitor<'self> {\n         } else if mtbl == 1 {\n             // skip, this is ast::m_imm\n         } else {\n-            fail!(\"invalid mutability value\");\n+            fail2!(\"invalid mutability value\");\n         }\n     }\n \n@@ -312,7 +312,7 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n \n     // Type no longer exists, vestigial function.\n     fn visit_estr_fixed(&mut self, _n: uint, _sz: uint,\n-                        _align: uint) -> bool { fail!(); }\n+                        _align: uint) -> bool { fail2!(); }\n \n     fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.writer.write(['@' as u8]);\n@@ -355,7 +355,7 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n     }\n \n     // Type no longer exists, vestigial function.\n-    fn visit_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { fail!(); }\n+    fn visit_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { fail2!(); }\n \n     fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         do self.get::<raw::Vec<()>> |this, b| {\n@@ -567,7 +567,7 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n                         _align: uint)\n                         -> bool {\n         match self.var_stk.pop() {\n-            SearchingFor(*) => fail!(\"enum value matched no variant\"),\n+            SearchingFor(*) => fail2!(\"enum value matched no variant\"),\n             _ => true\n         }\n     }"}, {"sha": "34efe1cfbf14b04a71e41535912601e17d787254", "filename": "src/libstd/result.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -46,7 +46,8 @@ impl<T, E: ToStr> Result<T, E> {\n     pub fn get_ref<'a>(&'a self) -> &'a T {\n         match *self {\n             Ok(ref t) => t,\n-            Err(ref e) => fail!(\"called `Result::get_ref()` on `Err` value: %s\", e.to_str()),\n+            Err(ref e) => fail2!(\"called `Result::get_ref()` on `Err` value: {}\",\n+                                 e.to_str()),\n         }\n     }\n \n@@ -106,7 +107,8 @@ impl<T, E: ToStr> Result<T, E> {\n     pub fn unwrap(self) -> T {\n         match self {\n             Ok(t) => t,\n-            Err(e) => fail!(\"called `Result::unwrap()` on `Err` value: %s\", e.to_str()),\n+            Err(e) => fail2!(\"called `Result::unwrap()` on `Err` value: {}\",\n+                             e.to_str()),\n         }\n     }\n \n@@ -123,7 +125,7 @@ impl<T, E: ToStr> Result<T, E> {\n     pub fn expect(self, reason: &str) -> T {\n         match self {\n             Ok(t) => t,\n-            Err(_) => fail!(reason.to_owned()),\n+            Err(_) => fail2!(\"{}\", reason.to_owned()),\n         }\n     }\n \n@@ -133,7 +135,7 @@ impl<T, E: ToStr> Result<T, E> {\n     pub fn expect_err(self, reason: &str) -> E {\n         match self {\n             Err(e) => e,\n-            Ok(_) => fail!(reason.to_owned()),\n+            Ok(_) => fail2!(\"{}\", reason.to_owned()),\n         }\n     }\n \n@@ -547,7 +549,7 @@ mod tests {\n                    Err(2));\n \n         // test that it does not take more elements than it needs\n-        let functions = [|| Ok(()), || Err(1), || fail!()];\n+        let functions = [|| Ok(()), || Err(1), || fail2!()];\n \n         assert_eq!(collect(functions.iter().map(|f| (*f)())),\n                    Err(1));\n@@ -567,7 +569,7 @@ mod tests {\n                    Err(2));\n \n         // test that it does not take more elements than it needs\n-        let functions = [|| Ok(()), || Err(1), || fail!()];\n+        let functions = [|| Ok(()), || Err(1), || fail2!()];\n \n         assert_eq!(fold_(functions.iter()\n                         .map(|f| (*f)())),"}, {"sha": "100ea3e05461fdec61a9a0d4bb6dba16b0f6abf4", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -163,14 +163,14 @@ mod imp {\n     }\n \n     pub fn take() -> Option<~[~str]> {\n-        fail!()\n+        fail2!()\n     }\n \n     pub fn put(_args: ~[~str]) {\n-        fail!()\n+        fail2!()\n     }\n \n     pub fn clone() -> Option<~[~str]> {\n-        fail!()\n+        fail2!()\n     }\n }"}, {"sha": "d703272420cbb4423baaa6b15dcd306b3ec0bdef", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -78,7 +78,7 @@ unsafe fn fail_borrowed(box: *mut raw::Box<()>, file: *c_char, line: size_t) {\n                     msg.push_str(sep);\n                     let filename = str::raw::from_c_str(entry.file);\n                     msg.push_str(filename);\n-                    msg.push_str(fmt!(\":%u\", entry.line as uint));\n+                    msg.push_str(format!(\":{}\", entry.line));\n                     sep = \" and at \";\n                 }\n             }\n@@ -221,7 +221,7 @@ pub unsafe fn unrecord_borrow(a: *u8, old_ref_count: uint,\n             assert!(!borrow_list.is_empty());\n             let br = borrow_list.pop();\n             if br.box != a || br.file != file || br.line != line {\n-                let err = fmt!(\"wrong borrow found, br=%?\", br);\n+                let err = format!(\"wrong borrow found, br={:?}\", br);\n                 do err.with_c_str |msg_p| {\n                     sys::begin_unwind_(msg_p, file, line)\n                 }"}, {"sha": "7d61b556bb595eaf02e6c48443832ba29883da2e", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -196,7 +196,7 @@ impl<T> PortOne<T> {\n         match self.try_recv() {\n             Some(val) => val,\n             None => {\n-                fail!(\"receiving on closed channel\");\n+                fail2!(\"receiving on closed channel\");\n             }\n         }\n     }\n@@ -495,7 +495,7 @@ impl<T> GenericPort<T> for Port<T> {\n         match self.try_recv() {\n             Some(val) => val,\n             None => {\n-                fail!(\"receiving on closed channel\");\n+                fail2!(\"receiving on closed channel\");\n             }\n         }\n     }\n@@ -650,7 +650,7 @@ impl<T: Send> GenericPort<T> for SharedPort<T> {\n         match self.try_recv() {\n             Some(val) => val,\n             None => {\n-                fail!(\"receiving on a closed channel\");\n+                fail2!(\"receiving on a closed channel\");\n             }\n         }\n     }\n@@ -770,7 +770,7 @@ mod test {\n                 port.recv();\n             };\n             // What is our res?\n-            rtdebug!(\"res is: %?\", res.is_err());\n+            rtdebug!(\"res is: {:?}\", res.is_err());\n             assert!(res.is_err());\n         }\n     }"}, {"sha": "853cc08a0ba773d3d511709f1b894b79b4be3c1f", "filename": "src/libstd/rt/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcontext.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -167,9 +167,9 @@ fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void,\n     unsafe { *sp = 0; }\n \n     rtdebug!(\"creating call frame\");\n-    rtdebug!(\"fptr %x\", fptr as uint);\n-    rtdebug!(\"arg %x\", arg as uint);\n-    rtdebug!(\"sp %x\", sp as uint);\n+    rtdebug!(\"fptr {}\", fptr as uint);\n+    rtdebug!(\"arg {}\", arg as uint);\n+    rtdebug!(\"sp {}\", sp as uint);\n \n     regs[RUSTRT_ARG0] = arg as uint;\n     regs[RUSTRT_RSP] = sp as uint;"}, {"sha": "2844cc81892dd0b633a00b0b3846e613361663f4", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -85,7 +85,7 @@ unsafe fn entries(crate_map: *CrateMap) -> *ModEntry {\n             return (*v0).entries;\n         }\n         1 => return (*crate_map).entries,\n-        _ => fail!(\"Unknown crate map version!\")\n+        _ => fail2!(\"Unknown crate map version!\")\n     }\n }\n \n@@ -96,7 +96,7 @@ unsafe fn iterator(crate_map: *CrateMap) -> **CrateMap {\n             return vec::raw::to_ptr((*v0).children);\n         }\n         1 => return vec::raw::to_ptr((*crate_map).children),\n-        _ => fail!(\"Unknown crate map version!\")\n+        _ => fail2!(\"Unknown crate map version!\")\n     }\n }\n "}, {"sha": "495d1f97cd2bafd71f51f0e6e5e8e4c364524ad5", "filename": "src/libstd/rt/io/comm_adapters.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fcomm_adapters.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -15,45 +15,45 @@ use super::{Reader, Writer};\n struct PortReader<P>;\n \n impl<P: GenericPort<~[u8]>> PortReader<P> {\n-    pub fn new(_port: P) -> PortReader<P> { fail!() }\n+    pub fn new(_port: P) -> PortReader<P> { fail2!() }\n }\n \n impl<P: GenericPort<~[u8]>> Reader for PortReader<P> {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail2!() }\n \n-    fn eof(&mut self) -> bool { fail!() }\n+    fn eof(&mut self) -> bool { fail2!() }\n }\n \n struct ChanWriter<C>;\n \n impl<C: GenericChan<~[u8]>> ChanWriter<C> {\n-    pub fn new(_chan: C) -> ChanWriter<C> { fail!() }\n+    pub fn new(_chan: C) -> ChanWriter<C> { fail2!() }\n }\n \n impl<C: GenericChan<~[u8]>> Writer for ChanWriter<C> {\n-    fn write(&mut self, _buf: &[u8]) { fail!() }\n+    fn write(&mut self, _buf: &[u8]) { fail2!() }\n \n-    fn flush(&mut self) { fail!() }\n+    fn flush(&mut self) { fail2!() }\n }\n \n struct ReaderPort<R>;\n \n impl<R: Reader> ReaderPort<R> {\n-    pub fn new(_reader: R) -> ReaderPort<R> { fail!() }\n+    pub fn new(_reader: R) -> ReaderPort<R> { fail2!() }\n }\n \n impl<R: Reader> GenericPort<~[u8]> for ReaderPort<R> {\n-    fn recv(&self) -> ~[u8] { fail!() }\n+    fn recv(&self) -> ~[u8] { fail2!() }\n \n-    fn try_recv(&self) -> Option<~[u8]> { fail!() }\n+    fn try_recv(&self) -> Option<~[u8]> { fail2!() }\n }\n \n struct WriterChan<W>;\n \n impl<W: Writer> WriterChan<W> {\n-    pub fn new(_writer: W) -> WriterChan<W> { fail!() }\n+    pub fn new(_writer: W) -> WriterChan<W> { fail2!() }\n }\n \n impl<W: Writer> GenericChan<~[u8]> for WriterChan<W> {\n-    fn send(&self, _x: ~[u8]) { fail!() }\n+    fn send(&self, _x: ~[u8]) { fail2!() }\n }"}, {"sha": "69f0423bf5d37aa038c1f78535318413623a246e", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -288,7 +288,7 @@ impl<T: Reader> ReaderUtil for T {\n         let mut buf = [0];\n         match self.read(buf) {\n             Some(0) => {\n-                debug!(\"read 0 bytes. trying again\");\n+                debug2!(\"read 0 bytes. trying again\");\n                 self.read_byte()\n             }\n             Some(1) => Some(buf[0]),"}, {"sha": "a18eec8773ebd8d6e75c5e3334591f5e6c75ec7b", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -59,7 +59,7 @@ use path::Path;\n ///     }).inside {\n ///         let stream = match open(p, Create, ReadWrite) {\n ///             Some(s) => s,\n-///             None => fail!(\"whoops! I'm sure this raised, anyways..\");\n+///             None => fail2!(\"whoops! I'm sure this raised, anyways..\");\n ///         }\n ///         // do some stuff with that stream\n ///\n@@ -223,7 +223,7 @@ pub fn rmdir<P: PathLike>(path: &P) {\n ///     }).inside {\n ///         let info = match stat(p) {\n ///             Some(s) => s,\n-///             None => fail!(\"whoops! I'm sure this raised, anyways..\");\n+///             None => fail2!(\"whoops! I'm sure this raised, anyways..\");\n ///         }\n ///         if stat.is_file {\n ///             // just imagine the possibilities ...\n@@ -271,7 +271,7 @@ pub fn stat<P: PathLike>(path: &P) -> Option<FileStat> {\n ///                 else { cb(entry); }\n ///             }\n ///         }\n-///         else { fail!(\"nope\"); }\n+///         else { fail2!(\"nope\"); }\n ///     }\n ///\n /// # Errors\n@@ -596,7 +596,7 @@ impl FileInfo for Path { }\n ///             else { cb(entry); }\n ///         }\n ///     }\n-///     else { fail!(\"nope\"); }\n+///     else { fail2!(\"nope\"); }\n /// }\n /// ```\n trait DirectoryInfo : FileSystemInfo {\n@@ -631,7 +631,8 @@ trait DirectoryInfo : FileSystemInfo {\n                     kind: PathAlreadyExists,\n                     desc: \"Path already exists\",\n                     detail:\n-                        Some(fmt!(\"%s already exists; can't mkdir it\", self.get_path().to_str()))\n+                        Some(format!(\"{} already exists; can't mkdir it\",\n+                                     self.get_path().to_str()))\n                 })\n             },\n             None => mkdir(self.get_path())\n@@ -657,8 +658,8 @@ trait DirectoryInfo : FileSystemInfo {\n                         let ioerr = IoError {\n                             kind: MismatchedFileTypeForOperation,\n                             desc: \"Cannot do rmdir() on a non-directory\",\n-                            detail: Some(fmt!(\n-                                \"%s is a non-directory; can't rmdir it\",\n+                            detail: Some(format!(\n+                                \"{} is a non-directory; can't rmdir it\",\n                                 self.get_path().to_str()))\n                         };\n                         io_error::cond.raise(ioerr);\n@@ -669,7 +670,8 @@ trait DirectoryInfo : FileSystemInfo {\n                 io_error::cond.raise(IoError {\n                     kind: PathDoesntExist,\n                     desc: \"Path doesn't exist\",\n-                    detail: Some(fmt!(\"%s doesn't exist; can't rmdir it\", self.get_path().to_str()))\n+                    detail: Some(format!(\"{} doesn't exist; can't rmdir it\",\n+                                         self.get_path().to_str()))\n                 })\n         }\n     }\n@@ -707,7 +709,7 @@ mod test {\n                 let mut read_stream = open(filename, Open, Read).unwrap();\n                 let mut read_buf = [0, .. 1028];\n                 let read_str = match read_stream.read(read_buf).unwrap() {\n-                    -1|0 => fail!(\"shouldn't happen\"),\n+                    -1|0 => fail2!(\"shouldn't happen\"),\n                     n => str::from_utf8(read_buf.slice_to(n))\n                 };\n                 assert!(read_str == message.to_owned());\n@@ -875,7 +877,7 @@ mod test {\n             }\n             let stat_res = match stat(filename) {\n                 Some(s) => s,\n-                None => fail!(\"shouldn't happen\")\n+                None => fail2!(\"shouldn't happen\")\n             };\n             assert!(stat_res.is_file);\n             unlink(filename);\n@@ -889,7 +891,7 @@ mod test {\n             mkdir(filename);\n             let stat_res = match stat(filename) {\n                 Some(s) => s,\n-                None => fail!(\"shouldn't happen\")\n+                None => fail2!(\"shouldn't happen\")\n             };\n             assert!(stat_res.is_dir);\n             rmdir(filename);\n@@ -942,7 +944,7 @@ mod test {\n             dir.mkdir();\n             let prefix = \"foo\";\n             for n in range(0,3) {\n-                let f = dir.push(fmt!(\"%d.txt\", n));\n+                let f = dir.push(format!(\"{}.txt\", n));\n                 let mut w = f.open_writer(Create);\n                 let msg_str = (prefix + n.to_str().to_owned()).to_owned();\n                 let msg = msg_str.as_bytes();\n@@ -959,14 +961,14 @@ mod test {\n                             let read_str = str::from_utf8(mem);\n                             let expected = match n {\n                                 Some(n) => prefix+n,\n-                                None => fail!(\"really shouldn't happen..\")\n+                                None => fail2!(\"really shouldn't happen..\")\n                             };\n                             assert!(expected == read_str);\n                         }\n                         f.unlink();\n                     }\n                 },\n-                None => fail!(\"shouldn't happen\")\n+                None => fail2!(\"shouldn't happen\")\n             }\n             dir.rmdir();\n         }"}, {"sha": "72029d07263e316a87d030f0614568a9c5fea0f3", "filename": "src/libstd/rt/io/flate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fflate.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -29,9 +29,9 @@ impl<W: Writer> DeflateWriter<W> {\n }\n \n impl<W: Writer> Writer for DeflateWriter<W> {\n-    fn write(&mut self, _buf: &[u8]) { fail!() }\n+    fn write(&mut self, _buf: &[u8]) { fail2!() }\n \n-    fn flush(&mut self) { fail!() }\n+    fn flush(&mut self) { fail2!() }\n }\n \n impl<W: Writer> Decorator<W> for DeflateWriter<W> {\n@@ -68,9 +68,9 @@ impl<R: Reader> InflateReader<R> {\n }\n \n impl<R: Reader> Reader for InflateReader<R> {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail2!() }\n \n-    fn eof(&mut self) -> bool { fail!() }\n+    fn eof(&mut self) -> bool { fail2!() }\n }\n \n impl<R: Reader> Decorator<R> for InflateReader<R> {"}, {"sha": "1f396a4476e1e61f7484c017b20601ab9d40a1b9", "filename": "src/libstd/rt/io/mem.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmem.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -40,7 +40,7 @@ impl Writer for MemWriter {\n impl Seek for MemWriter {\n     fn tell(&self) -> u64 { self.buf.len() as u64 }\n \n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail2!() }\n }\n \n impl Decorator<~[u8]> for MemWriter {\n@@ -102,7 +102,7 @@ impl Reader for MemReader {\n impl Seek for MemReader {\n     fn tell(&self) -> u64 { self.pos as u64 }\n \n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail2!() }\n }\n \n impl Decorator<~[u8]> for MemReader {\n@@ -143,15 +143,15 @@ impl<'self> BufWriter<'self> {\n }\n \n impl<'self> Writer for BufWriter<'self> {\n-    fn write(&mut self, _buf: &[u8]) { fail!() }\n+    fn write(&mut self, _buf: &[u8]) { fail2!() }\n \n-    fn flush(&mut self) { fail!() }\n+    fn flush(&mut self) { fail2!() }\n }\n \n impl<'self> Seek for BufWriter<'self> {\n-    fn tell(&self) -> u64 { fail!() }\n+    fn tell(&self) -> u64 { fail2!() }\n \n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail2!() }\n }\n \n \n@@ -193,7 +193,7 @@ impl<'self> Reader for BufReader<'self> {\n impl<'self> Seek for BufReader<'self> {\n     fn tell(&self) -> u64 { self.pos as u64 }\n \n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail2!() }\n }\n \n ///Calls a function with a MemWriter and returns"}, {"sha": "c2f137ba119ab14a18470b08ee5dfed74e513bb0", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -585,7 +585,7 @@ pub fn standard_error(kind: IoErrorKind) -> IoError {\n                 detail: None\n             }\n         }\n-        _ => fail!()\n+        _ => fail2!()\n     }\n }\n "}, {"sha": "f5f77f4e853f9421e49461b1b254c2e8a4ac6608", "filename": "src/libstd/rt/io/native/file.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -25,25 +25,25 @@ impl FileDesc {\n     ///\n     /// The `FileDesc` takes ownership of the file descriptor\n     /// and will close it upon destruction.\n-    pub fn new(_fd: fd_t) -> FileDesc { fail!() }\n+    pub fn new(_fd: fd_t) -> FileDesc { fail2!() }\n }\n \n impl Reader for FileDesc {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail2!() }\n \n-    fn eof(&mut self) -> bool { fail!() }\n+    fn eof(&mut self) -> bool { fail2!() }\n }\n \n impl Writer for FileDesc {\n-    fn write(&mut self, _buf: &[u8]) { fail!() }\n+    fn write(&mut self, _buf: &[u8]) { fail2!() }\n \n-    fn flush(&mut self) { fail!() }\n+    fn flush(&mut self) { fail2!() }\n }\n \n impl Seek for FileDesc {\n-    fn tell(&self) -> u64 { fail!() }\n+    fn tell(&self) -> u64 { fail2!() }\n \n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail2!() }\n }\n \n pub struct CFile(*FILE);\n@@ -53,22 +53,22 @@ impl CFile {\n     ///\n     /// The `CFile` takes ownership of the file descriptor\n     /// and will close it upon destruction.\n-    pub fn new(_file: *FILE) -> CFile { fail!() }\n+    pub fn new(_file: *FILE) -> CFile { fail2!() }\n }\n \n impl Reader for CFile {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail2!() }\n \n-    fn eof(&mut self) -> bool { fail!() }\n+    fn eof(&mut self) -> bool { fail2!() }\n }\n \n impl Writer for CFile {\n-    fn write(&mut self, _buf: &[u8]) { fail!() }\n+    fn write(&mut self, _buf: &[u8]) { fail2!() }\n \n-    fn flush(&mut self) { fail!() }\n+    fn flush(&mut self) { fail2!() }\n }\n \n impl Seek for CFile {\n-    fn tell(&self) -> u64 { fail!() }\n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+    fn tell(&self) -> u64 { fail2!() }\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail2!() }\n }"}, {"sha": "6a6619cc548208214b177271ed64c4da728517c8", "filename": "src/libstd/rt/io/net/ip.rs", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use num::FromStrRadix;\n use vec::MutableCloneableVector;\n use to_str::ToStr;\n use from_str::FromStr;\n@@ -27,37 +26,22 @@ impl ToStr for IpAddr {\n     fn to_str(&self) -> ~str {\n         match *self {\n             Ipv4Addr(a, b, c, d) =>\n-                fmt!(\"%u.%u.%u.%u\",\n-                    a as uint, b as uint, c as uint, d as uint),\n+                format!(\"{}.{}.{}.{}\", a, b, c, d),\n \n             // Ipv4 Compatible address\n             Ipv6Addr(0, 0, 0, 0, 0, 0, g, h) => {\n-                let a = fmt!(\"%04x\", g as uint);\n-                let b = FromStrRadix::from_str_radix(a.slice(2, 4), 16).unwrap();\n-                let a = FromStrRadix::from_str_radix(a.slice(0, 2), 16).unwrap();\n-                let c = fmt!(\"%04x\", h as uint);\n-                let d = FromStrRadix::from_str_radix(c.slice(2, 4), 16).unwrap();\n-                let c = FromStrRadix::from_str_radix(c.slice(0, 2), 16).unwrap();\n-\n-                fmt!(\"::%u.%u.%u.%u\", a, b, c, d)\n+                format!(\"::{}.{}.{}.{}\", (g >> 8) as u8, g as u8,\n+                        (h >> 8) as u8, h as u8)\n             }\n \n             // Ipv4-Mapped address\n             Ipv6Addr(0, 0, 0, 0, 0, 0xFFFF, g, h) => {\n-                let a = fmt!(\"%04x\", g as uint);\n-                let b = FromStrRadix::from_str_radix(a.slice(2, 4), 16).unwrap();\n-                let a = FromStrRadix::from_str_radix(a.slice(0, 2), 16).unwrap();\n-                let c = fmt!(\"%04x\", h as uint);\n-                let d = FromStrRadix::from_str_radix(c.slice(2, 4), 16).unwrap();\n-                let c = FromStrRadix::from_str_radix(c.slice(0, 2), 16).unwrap();\n-\n-                fmt!(\"::FFFF:%u.%u.%u.%u\", a, b, c, d)\n+                format!(\"::FFFF:{}.{}.{}.{}\", (g >> 8) as u8, g as u8,\n+                        (h >> 8) as u8, h as u8)\n             }\n \n             Ipv6Addr(a, b, c, d, e, f, g, h) =>\n-                fmt!(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n-                    a as uint, b as uint, c as uint, d as uint,\n-                    e as uint, f as uint, g as uint, h as uint)\n+                format!(\"{}:{}:{}:{}:{}:{}:{}:{}\", a, b, c, d, e, f, g, h)\n         }\n     }\n }\n@@ -72,8 +56,8 @@ pub struct SocketAddr {\n impl ToStr for SocketAddr {\n     fn to_str(&self) -> ~str {\n         match self.ip {\n-            Ipv4Addr(*) => fmt!(\"%s:%u\", self.ip.to_str(), self.port as uint),\n-            Ipv6Addr(*) => fmt!(\"[%s]:%u\", self.ip.to_str(), self.port as uint),\n+            Ipv4Addr(*) => format!(\"{}:{}\", self.ip.to_str(), self.port),\n+            Ipv6Addr(*) => format!(\"[{}]:{}\", self.ip.to_str(), self.port),\n         }\n     }\n }"}, {"sha": "c1cda5ad681160c4850e6bf6aa6b02d4cf687ac0", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -38,7 +38,7 @@ impl TcpStream {\n         match stream {\n             Ok(s) => Some(TcpStream::new(s)),\n             Err(ioerr) => {\n-                rtdebug!(\"failed to connect: %?\", ioerr);\n+                rtdebug!(\"failed to connect: {:?}\", ioerr);\n                 io_error::cond.raise(ioerr);\n                 None\n             }\n@@ -49,7 +49,7 @@ impl TcpStream {\n         match (**self).peer_name() {\n             Ok(pn) => Some(pn),\n             Err(ioerr) => {\n-                rtdebug!(\"failed to get peer name: %?\", ioerr);\n+                rtdebug!(\"failed to get peer name: {:?}\", ioerr);\n                 io_error::cond.raise(ioerr);\n                 None\n             }\n@@ -60,7 +60,7 @@ impl TcpStream {\n         match (**self).socket_name() {\n             Ok(sn) => Some(sn),\n             Err(ioerr) => {\n-                rtdebug!(\"failed to get socket name: %?\", ioerr);\n+                rtdebug!(\"failed to get socket name: {:?}\", ioerr);\n                 io_error::cond.raise(ioerr);\n                 None\n             }\n@@ -82,7 +82,7 @@ impl Reader for TcpStream {\n         }\n     }\n \n-    fn eof(&mut self) -> bool { fail!() }\n+    fn eof(&mut self) -> bool { fail2!() }\n }\n \n impl Writer for TcpStream {\n@@ -117,7 +117,7 @@ impl TcpListener {\n         match (**self).socket_name() {\n             Ok(sn) => Some(sn),\n             Err(ioerr) => {\n-                rtdebug!(\"failed to get socket name: %?\", ioerr);\n+                rtdebug!(\"failed to get socket name: {:?}\", ioerr);\n                 io_error::cond.raise(ioerr);\n                 None\n             }"}, {"sha": "e47b9b9e925cb2736771a518190b49f5134102ef", "filename": "src/libstd/rt/io/net/udp.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -61,7 +61,7 @@ impl UdpSocket {\n         match (***self).socket_name() {\n             Ok(sn) => Some(sn),\n             Err(ioerr) => {\n-                rtdebug!(\"failed to get socket name: %?\", ioerr);\n+                rtdebug!(\"failed to get socket name: {:?}\", ioerr);\n                 io_error::cond.raise(ioerr);\n                 None\n             }\n@@ -92,7 +92,7 @@ impl Reader for UdpStream {\n         }\n     }\n \n-    fn eof(&mut self) -> bool { fail!() }\n+    fn eof(&mut self) -> bool { fail2!() }\n }\n \n impl Writer for UdpStream {\n@@ -102,7 +102,7 @@ impl Writer for UdpStream {\n         }\n     }\n \n-    fn flush(&mut self) { fail!() }\n+    fn flush(&mut self) { fail2!() }\n }\n \n #[cfg(test)]\n@@ -151,10 +151,10 @@ mod test {\n                                 assert_eq!(buf[0], 99);\n                                 assert_eq!(src, client_ip);\n                             }\n-                            None => fail!()\n+                            None => fail2!()\n                         }\n                     }\n-                    None => fail!()\n+                    None => fail2!()\n                 }\n             }\n \n@@ -164,7 +164,7 @@ mod test {\n                         port.take().recv();\n                         client.sendto([99], server_ip)\n                     }\n-                    None => fail!()\n+                    None => fail2!()\n                 }\n             }\n         }\n@@ -190,10 +190,10 @@ mod test {\n                                 assert_eq!(buf[0], 99);\n                                 assert_eq!(src, client_ip);\n                             }\n-                            None => fail!()\n+                            None => fail2!()\n                         }\n                     }\n-                    None => fail!()\n+                    None => fail2!()\n                 }\n             }\n \n@@ -203,7 +203,7 @@ mod test {\n                         port.take().recv();\n                         client.sendto([99], server_ip)\n                     }\n-                    None => fail!()\n+                    None => fail2!()\n                 }\n             }\n         }\n@@ -230,10 +230,10 @@ mod test {\n                                 assert_eq!(nread, 1);\n                                 assert_eq!(buf[0], 99);\n                             }\n-                            None => fail!()\n+                            None => fail2!()\n                         }\n                     }\n-                    None => fail!()\n+                    None => fail2!()\n                 }\n             }\n \n@@ -245,7 +245,7 @@ mod test {\n                         port.take().recv();\n                         stream.write([99]);\n                     }\n-                    None => fail!()\n+                    None => fail2!()\n                 }\n             }\n         }\n@@ -272,10 +272,10 @@ mod test {\n                                 assert_eq!(nread, 1);\n                                 assert_eq!(buf[0], 99);\n                             }\n-                            None => fail!()\n+                            None => fail2!()\n                         }\n                     }\n-                    None => fail!()\n+                    None => fail2!()\n                 }\n             }\n \n@@ -287,7 +287,7 @@ mod test {\n                         port.take().recv();\n                         stream.write([99]);\n                     }\n-                    None => fail!()\n+                    None => fail2!()\n                 }\n             }\n         }"}, {"sha": "07de33935ee2a6a9b7581dba8450fb3051fe2805", "filename": "src/libstd/rt/io/net/unix.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -16,36 +16,36 @@ pub struct UnixStream;\n \n impl UnixStream {\n     pub fn connect<P: PathLike>(_path: &P) -> Option<UnixStream> {\n-        fail!()\n+        fail2!()\n     }\n }\n \n impl Reader for UnixStream {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail2!() }\n \n-    fn eof(&mut self) -> bool { fail!() }\n+    fn eof(&mut self) -> bool { fail2!() }\n }\n \n impl Writer for UnixStream {\n-    fn write(&mut self, _v: &[u8]) { fail!() }\n+    fn write(&mut self, _v: &[u8]) { fail2!() }\n \n-    fn flush(&mut self) { fail!() }\n+    fn flush(&mut self) { fail2!() }\n }\n \n pub struct UnixListener;\n \n impl UnixListener {\n     pub fn bind<P: PathLike>(_path: &P) -> Option<UnixListener> {\n-        fail!()\n+        fail2!()\n     }\n }\n \n impl Listener<UnixStream, UnixAcceptor> for UnixListener {\n-    fn listen(self) -> Option<UnixAcceptor> { fail!() }\n+    fn listen(self) -> Option<UnixAcceptor> { fail2!() }\n }\n \n pub struct UnixAcceptor;\n \n impl Acceptor<UnixStream> for UnixAcceptor {\n-    fn accept(&mut self) -> Option<UnixStream> { fail!() }\n+    fn accept(&mut self) -> Option<UnixStream> { fail2!() }\n }"}, {"sha": "4186cce8c8d001d8a76077eabb540f64f26b9d00", "filename": "src/libstd/rt/io/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fpipe.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -59,7 +59,7 @@ impl Reader for PipeStream {\n         }\n     }\n \n-    fn eof(&mut self) -> bool { fail!() }\n+    fn eof(&mut self) -> bool { fail2!() }\n }\n \n impl Writer for PipeStream {\n@@ -72,5 +72,5 @@ impl Writer for PipeStream {\n         }\n     }\n \n-    fn flush(&mut self) { fail!() }\n+    fn flush(&mut self) { fail2!() }\n }"}, {"sha": "734a40429a62f70b03fa29c59edbbbfec3ddbdad", "filename": "src/libstd/rt/io/stdio.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fstdio.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -11,15 +11,15 @@\n use prelude::*;\n use super::{Reader, Writer};\n \n-pub fn stdin() -> StdReader { fail!() }\n+pub fn stdin() -> StdReader { fail2!() }\n \n-pub fn stdout() -> StdWriter { fail!() }\n+pub fn stdout() -> StdWriter { fail2!() }\n \n-pub fn stderr() -> StdReader { fail!() }\n+pub fn stderr() -> StdReader { fail2!() }\n \n-pub fn print(_s: &str) { fail!() }\n+pub fn print(_s: &str) { fail2!() }\n \n-pub fn println(_s: &str) { fail!() }\n+pub fn println(_s: &str) { fail2!() }\n \n pub enum StdStream {\n     StdIn,\n@@ -30,23 +30,23 @@ pub enum StdStream {\n pub struct StdReader;\n \n impl StdReader {\n-    pub fn new(_stream: StdStream) -> StdReader { fail!() }\n+    pub fn new(_stream: StdStream) -> StdReader { fail2!() }\n }\n \n impl Reader for StdReader {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail2!() }\n \n-    fn eof(&mut self) -> bool { fail!() }\n+    fn eof(&mut self) -> bool { fail2!() }\n }\n \n pub struct StdWriter;\n \n impl StdWriter {\n-    pub fn new(_stream: StdStream) -> StdWriter { fail!() }\n+    pub fn new(_stream: StdStream) -> StdWriter { fail2!() }\n }\n \n impl Writer for StdWriter {\n-    fn write(&mut self, _buf: &[u8]) { fail!() }\n+    fn write(&mut self, _buf: &[u8]) { fail2!() }\n \n-    fn flush(&mut self) { fail!() }\n+    fn flush(&mut self) { fail2!() }\n }"}, {"sha": "19b33feacbd868028419bd5613e54ff67fd7d52a", "filename": "src/libstd/rt/io/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ftimer.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -36,7 +36,7 @@ impl Timer {\n         match timer {\n             Ok(t) => Some(Timer(t)),\n             Err(ioerr) => {\n-                rtdebug!(\"Timer::init: failed to init: %?\", ioerr);\n+                rtdebug!(\"Timer::init: failed to init: {:?}\", ioerr);\n                 io_error::cond.raise(ioerr);\n                 None\n             }"}, {"sha": "09f99b9302eeb23b570599fa2425f90287e3d95e", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -306,7 +306,7 @@ impl BlockedTask {\n                 match flag.compare_and_swap(KILL_RUNNING, task_ptr, Relaxed) {\n                     KILL_RUNNING => Right(Killable(flag_arc)),\n                     KILL_KILLED  => Left(revive_task_ptr(task_ptr, Some(flag_arc))),\n-                    x            => rtabort!(\"can't block task! kill flag = %?\", x),\n+                    x            => rtabort!(\"can't block task! kill flag = {}\", x),\n                 }\n             }\n         }\n@@ -403,7 +403,7 @@ impl KillHandle {\n         // FIXME(#7544)(bblum): is it really necessary to prohibit double kill?\n         match inner.unkillable.compare_and_swap(KILL_RUNNING, KILL_UNKILLABLE, Relaxed) {\n             KILL_RUNNING    => { }, // normal case\n-            KILL_KILLED     => if !already_failing { fail!(KILLED_MSG) },\n+            KILL_KILLED     => if !already_failing { fail2!(\"{}\", KILLED_MSG) },\n             _               => rtabort!(\"inhibit_kill: task already unkillable\"),\n         }\n     }\n@@ -416,7 +416,7 @@ impl KillHandle {\n         // FIXME(#7544)(bblum): is it really necessary to prohibit double kill?\n         match inner.unkillable.compare_and_swap(KILL_UNKILLABLE, KILL_RUNNING, Relaxed) {\n             KILL_UNKILLABLE => { }, // normal case\n-            KILL_KILLED     => if !already_failing { fail!(KILLED_MSG) },\n+            KILL_KILLED     => if !already_failing { fail2!(\"{}\", KILLED_MSG) },\n             _               => rtabort!(\"allow_kill: task already killable\"),\n         }\n     }\n@@ -624,7 +624,7 @@ impl Death {\n                 // synchronization during unwinding or cleanup (for example,\n                 // sending on a notify port). In that case failing won't help.\n                 if self.unkillable == 0 && (!already_failing) && kill_handle.killed() {\n-                    fail!(KILLED_MSG);\n+                    fail2!(\"{}\", KILLED_MSG);\n                 },\n             // This may happen during task death (see comments in collect_failure).\n             None => rtassert!(self.unkillable > 0),\n@@ -650,7 +650,7 @@ impl Death {\n         if self.unkillable == 0 {\n             // we need to decrement the counter before failing.\n             self.unkillable -= 1;\n-            fail!(\"Cannot enter a rekillable() block without a surrounding unkillable()\");\n+            fail2!(\"Cannot enter a rekillable() block without a surrounding unkillable()\");\n         }\n         self.unkillable -= 1;\n         if self.unkillable == 0 {"}, {"sha": "51eb2505f550c3e8348ed1295adb4baa5ad9f8d7", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -90,15 +90,15 @@ fn parse_logging_spec(spec: ~str) -> ~[LogDirective]{\n                         log_level = num;\n                     },\n                     _ => {\n-                        dumb_println(fmt!(\"warning: invalid logging spec \\\n-                                           '%s', ignoring it\", parts[1]));\n+                        dumb_println(format!(\"warning: invalid logging spec \\\n+                                              '{}', ignoring it\", parts[1]));\n                         loop;\n                     }\n                 }\n             },\n             _ => {\n-                dumb_println(fmt!(\"warning: invalid logging spec '%s',\\\n-                                  ignoring it\", s));\n+                dumb_println(format!(\"warning: invalid logging spec '{}',\\\n+                                      ignoring it\", s));\n                 loop;\n             }\n         }\n@@ -165,10 +165,12 @@ fn update_log_settings(crate_map: *u8, settings: ~str) {\n     }\n \n     if n_matches < (dirs.len() as u32) {\n-        dumb_println(fmt!(\"warning: got %u RUST_LOG specs but only matched %u of them.\\n\\\n-                          You may have mistyped a RUST_LOG spec.\\n\\\n-                          Use RUST_LOG=::help to see the list of crates and modules.\\n\",\n-                          dirs.len() as uint, n_matches as uint));\n+        dumb_println(format!(\"warning: got {} RUST_LOG specs but only matched\\n\\\n+                              {} of them. You may have mistyped a RUST_LOG \\\n+                              spec. \\n\\\n+                              Use RUST_LOG=::help to see the list of crates \\\n+                              and modules.\\n\",\n+                             dirs.len(), n_matches));\n     }\n }\n "}, {"sha": "bddcb700433c744482567bca9ceb7af79a44c922", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -191,7 +191,7 @@ impl Scheduler {\n         // action will have given it away.\n         let sched: ~Scheduler = Local::take();\n \n-        rtdebug!(\"starting scheduler %u\", sched.sched_id());\n+        rtdebug!(\"starting scheduler {}\", sched.sched_id());\n         sched.run();\n \n         // Close the idle callback.\n@@ -207,7 +207,7 @@ impl Scheduler {\n         // the cleanup code it runs.\n         let mut stask: ~Task = Local::take();\n \n-        rtdebug!(\"stopping scheduler %u\", stask.sched.get_ref().sched_id());\n+        rtdebug!(\"stopping scheduler {}\", stask.sched.get_ref().sched_id());\n \n         // Should not have any messages\n         let message = stask.sched.get_mut_ref().message_queue.pop();\n@@ -999,7 +999,7 @@ mod test {\n                                                  Sched(t1_handle)) || {\n                 rtassert!(Task::on_appropriate_sched());\n             };\n-            rtdebug!(\"task1 id: **%u**\", borrow::to_uint(task1));\n+            rtdebug!(\"task1 id: **{}**\", borrow::to_uint(task1));\n \n             let task2 = ~do Task::new_root(&mut normal_sched.stack_pool, None) {\n                 rtassert!(Task::on_appropriate_sched());\n@@ -1013,7 +1013,7 @@ mod test {\n                                                  Sched(t4_handle)) {\n                 rtassert!(Task::on_appropriate_sched());\n             };\n-            rtdebug!(\"task4 id: **%u**\", borrow::to_uint(task4));\n+            rtdebug!(\"task4 id: **{}**\", borrow::to_uint(task4));\n \n             let task1 = Cell::new(task1);\n             let task2 = Cell::new(task2);\n@@ -1038,7 +1038,7 @@ mod test {\n                 sh.send(Shutdown);\n             };\n \n-            rtdebug!(\"normal task: %u\", borrow::to_uint(normal_task));\n+            rtdebug!(\"normal task: {}\", borrow::to_uint(normal_task));\n \n             let special_task = ~do Task::new_root(&mut special_sched.stack_pool, None) {\n                 rtdebug!(\"*about to submit task1*\");\n@@ -1049,7 +1049,7 @@ mod test {\n                 chan.take().send(());\n             };\n \n-            rtdebug!(\"special task: %u\", borrow::to_uint(special_task));\n+            rtdebug!(\"special task: {}\", borrow::to_uint(special_task));\n \n             let special_sched = Cell::new(special_sched);\n             let normal_sched = Cell::new(normal_sched);\n@@ -1238,12 +1238,12 @@ mod test {\n             while (true) {\n                 match p.recv() {\n                     (1, end_chan) => {\n-                                        debug!(\"%d\\n\", id);\n+                                debug2!(\"{}\\n\", id);\n                                 end_chan.send(());\n                                 return;\n                     }\n                     (token, end_chan) => {\n-                        debug!(\"thread: %d   got token: %d\", id, token);\n+                        debug2!(\"thread: {}   got token: {}\", id, token);\n                         ch.send((token - 1, end_chan));\n                         if token <= n_tasks {\n                             return;"}, {"sha": "0068d1030738e15d86a0ef750705d762234b24b9", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -225,7 +225,7 @@ impl Task {\n     }\n \n     pub fn run(&mut self, f: &fn()) {\n-        rtdebug!(\"run called on task: %u\", borrow::to_uint(self));\n+        rtdebug!(\"run called on task: {}\", borrow::to_uint(self));\n \n         // The only try/catch block in the world. Attempt to run the task's\n         // client-specified code and catch any failures.\n@@ -329,7 +329,7 @@ impl Task {\n \n impl Drop for Task {\n     fn drop(&mut self) {\n-        rtdebug!(\"called drop for a task: %u\", borrow::to_uint(self));\n+        rtdebug!(\"called drop for a task: {}\", borrow::to_uint(self));\n         rtassert!(self.destroyed)\n     }\n }\n@@ -498,7 +498,7 @@ mod test {\n             let result = spawntask_try(||());\n             rtdebug!(\"trying first assert\");\n             assert!(result.is_ok());\n-            let result = spawntask_try(|| fail!());\n+            let result = spawntask_try(|| fail2!());\n             rtdebug!(\"trying second assert\");\n             assert!(result.is_err());\n         }\n@@ -516,7 +516,7 @@ mod test {\n     #[test]\n     fn logging() {\n         do run_in_newsched_task() {\n-            info!(\"here i am. logging in a newsched task\");\n+            info2!(\"here i am. logging in a newsched task\");\n         }\n     }\n \n@@ -558,7 +558,7 @@ mod test {\n     fn linked_failure() {\n         do run_in_newsched_task() {\n             let res = do spawntask_try {\n-                spawntask_random(|| fail!());\n+                spawntask_random(|| fail2!());\n             };\n             assert!(res.is_err());\n         }\n@@ -599,7 +599,7 @@ mod test {\n             builder.future_result(|r| result = Some(r));\n             builder.unlinked();\n             do builder.spawn {\n-                fail!();\n+                fail2!();\n             }\n             assert_eq!(result.unwrap().recv(), Failure);\n         }"}, {"sha": "b6611eee9e62dacf2058ba86bbdcf173f8733687", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -114,15 +114,15 @@ mod darwin_fd_limit {\n                   to_mut_unsafe_ptr(&mut size),\n                   mut_null(), 0) != 0 {\n             let err = last_os_error();\n-            error!(\"raise_fd_limit: error calling sysctl: %s\", err);\n+            error2!(\"raise_fd_limit: error calling sysctl: {}\", err);\n             return;\n         }\n \n         // Fetch the current resource limits\n         let mut rlim = rlimit{rlim_cur: 0, rlim_max: 0};\n         if getrlimit(RLIMIT_NOFILE, to_mut_unsafe_ptr(&mut rlim)) != 0 {\n             let err = last_os_error();\n-            error!(\"raise_fd_limit: error calling getrlimit: %s\", err);\n+            error2!(\"raise_fd_limit: error calling getrlimit: {}\", err);\n             return;\n         }\n \n@@ -132,7 +132,7 @@ mod darwin_fd_limit {\n         // Set our newly-increased resource limit\n         if setrlimit(RLIMIT_NOFILE, to_unsafe_ptr(&rlim)) != 0 {\n             let err = last_os_error();\n-            error!(\"raise_fd_limit: error calling setrlimit: %s\", err);\n+            error2!(\"raise_fd_limit: error calling setrlimit: {}\", err);\n             return;\n         }\n     }"}, {"sha": "68996a3a2a50db196b0099ce4d92490f8f8b4366", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -61,7 +61,7 @@ pub fn default_sched_threads() -> uint {\n             let opt_n: Option<uint> = FromStr::from_str(nstr);\n             match opt_n {\n                 Some(n) if n > 0 => n,\n-                _ => rtabort!(\"`RUST_THREADS` is `%s`, should be a positive integer\", nstr)\n+                _ => rtabort!(\"`RUST_THREADS` is `{}`, should be a positive integer\", nstr)\n             }\n         }\n         None => {\n@@ -127,10 +127,10 @@ which at the time convulsed us with joy, yet which are now partly lost to my\n memory and partly incapable of presentation to others.\",\n         _ => \"You've met with a terrible fate, haven't you?\"\n     };\n-    rterrln!(\"%s\", \"\");\n-    rterrln!(\"%s\", quote);\n-    rterrln!(\"%s\", \"\");\n-    rterrln!(\"fatal runtime error: %s\", msg);\n+    rterrln!(\"{}\", \"\");\n+    rterrln!(\"{}\", quote);\n+    rterrln!(\"{}\", \"\");\n+    rterrln!(\"fatal runtime error: {}\", msg);\n \n     abort();\n "}, {"sha": "dc5b512e56ea65cf3b00559003b2aa29438f3228", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -505,7 +505,7 @@ mod test {\n                 let unlink_req = FsRequest::new();\n                 let result = unlink_req.unlink_sync(&loop_, &Path(path_str));\n                 assert!(result.is_ok());\n-            } else { fail!(\"nread was 0.. wudn't expectin' that.\"); }\n+            } else { fail2!(\"nread was 0.. wudn't expectin' that.\"); }\n             loop_.close();\n         }\n     }\n@@ -595,7 +595,7 @@ mod test {\n                     assert!(uverr.is_none());\n                     let loop_ = req.get_loop();\n                     let stat = req.get_stat();\n-                    naive_print(&loop_, fmt!(\"%?\", stat));\n+                    naive_print(&loop_, format!(\"{:?}\", stat));\n                     assert!(stat.is_dir());\n                     let rmdir_req = FsRequest::new();\n                     do rmdir_req.rmdir(&loop_, &path) |req,uverr| {"}, {"sha": "0c5351ea9e46d6367f1ce9c1fb1f3028ce496020", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -240,7 +240,7 @@ impl UvError {\n \n impl ToStr for UvError {\n     fn to_str(&self) -> ~str {\n-        fmt!(\"%s: %s\", self.name(), self.desc())\n+        format!(\"{}: {}\", self.name(), self.desc())\n     }\n }\n \n@@ -269,7 +269,7 @@ pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n             ECONNRESET => ConnectionReset,\n             EPIPE => BrokenPipe,\n             err => {\n-                rtdebug!(\"uverr.code %d\", err as int);\n+                rtdebug!(\"uverr.code {}\", err as int);\n                 // XXX: Need to map remaining uv error types\n                 OtherIoError\n             }"}, {"sha": "ca42fd32f096b15dd91c1b978761060fe9fb9688", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -34,7 +34,7 @@ fn sockaddr_to_UvSocketAddr(addr: *uvll::sockaddr) -> UvSocketAddr {\n         match addr {\n             _ if is_ip4_addr(addr) => UvIpv4SocketAddr(addr as *uvll::sockaddr_in),\n             _ if is_ip6_addr(addr) => UvIpv6SocketAddr(addr as *uvll::sockaddr_in6),\n-            _ => fail!(),\n+            _ => fail2!(),\n         }\n     }\n }\n@@ -156,8 +156,8 @@ impl StreamWatcher {\n         }\n \n         extern fn read_cb(stream: *uvll::uv_stream_t, nread: ssize_t, buf: Buf) {\n-            rtdebug!(\"buf addr: %x\", buf.base as uint);\n-            rtdebug!(\"buf len: %d\", buf.len as int);\n+            rtdebug!(\"buf addr: {}\", buf.base);\n+            rtdebug!(\"buf len: {}\", buf.len);\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n             let cb = stream_watcher.get_watcher_data().read_cb.get_ref();\n             let status = status_to_maybe_uv_error(nread as c_int);\n@@ -266,7 +266,7 @@ impl TcpWatcher {\n             self.get_watcher_data().connect_cb = Some(cb);\n \n             let connect_handle = ConnectRequest::new().native_handle();\n-            rtdebug!(\"connect_t: %x\", connect_handle as uint);\n+            rtdebug!(\"connect_t: {}\", connect_handle);\n             do socket_addr_as_uv_socket_addr(address) |addr| {\n                 let result = match addr {\n                     UvIpv4SocketAddr(addr) => uvll::tcp_connect(connect_handle,\n@@ -278,7 +278,7 @@ impl TcpWatcher {\n             }\n \n             extern fn connect_cb(req: *uvll::uv_connect_t, status: c_int) {\n-                rtdebug!(\"connect_t: %x\", req as uint);\n+                rtdebug!(\"connect_t: {}\", req);\n                 let connect_request: ConnectRequest = NativeHandle::from_native_handle(req);\n                 let mut stream_watcher = connect_request.stream();\n                 connect_request.delete();\n@@ -379,8 +379,8 @@ impl UdpWatcher {\n                 return;\n             }\n \n-            rtdebug!(\"buf addr: %x\", buf.base as uint);\n-            rtdebug!(\"buf len: %d\", buf.len as int);\n+            rtdebug!(\"buf addr: {}\", buf.base);\n+            rtdebug!(\"buf len: {}\", buf.len);\n             let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n             let cb = udp_watcher.get_watcher_data().udp_recv_cb.get_ref();\n             let status = status_to_maybe_uv_error(nread as c_int);\n@@ -652,11 +652,11 @@ mod test {\n                     let buf = vec_from_uv_buf(buf);\n                     let mut count = count_cell.take();\n                     if status.is_none() {\n-                        rtdebug!(\"got %d bytes\", nread);\n+                        rtdebug!(\"got {} bytes\", nread);\n                         let buf = buf.unwrap();\n                         for byte in buf.slice(0, nread as uint).iter() {\n                             assert!(*byte == count as u8);\n-                            rtdebug!(\"%u\", *byte as uint);\n+                            rtdebug!(\"{}\", *byte as uint);\n                             count += 1;\n                         }\n                     } else {\n@@ -727,12 +727,12 @@ mod test {\n                     let buf = vec_from_uv_buf(buf);\n                     let mut count = count_cell.take();\n                     if status.is_none() {\n-                        rtdebug!(\"got %d bytes\", nread);\n+                        rtdebug!(\"got {} bytes\", nread);\n                         let buf = buf.unwrap();\n                         let r = buf.slice(0, nread as uint);\n                         for byte in r.iter() {\n                             assert!(*byte == count as u8);\n-                            rtdebug!(\"%u\", *byte as uint);\n+                            rtdebug!(\"{}\", *byte as uint);\n                             count += 1;\n                         }\n                     } else {\n@@ -798,12 +798,12 @@ mod test {\n \n                 let buf = vec_from_uv_buf(buf);\n                 let mut count = 0;\n-                rtdebug!(\"got %d bytes\", nread);\n+                rtdebug!(\"got {} bytes\", nread);\n \n                 let buf = buf.unwrap();\n                 for &byte in buf.slice(0, nread as uint).iter() {\n                     assert!(byte == count as u8);\n-                    rtdebug!(\"%u\", byte as uint);\n+                    rtdebug!(\"{}\", byte as uint);\n                     count += 1;\n                 }\n                 assert_eq!(count, MAX);\n@@ -858,12 +858,12 @@ mod test {\n \n                 let buf = vec_from_uv_buf(buf);\n                 let mut count = 0;\n-                rtdebug!(\"got %d bytes\", nread);\n+                rtdebug!(\"got {} bytes\", nread);\n \n                 let buf = buf.unwrap();\n                 for &byte in buf.slice(0, nread as uint).iter() {\n                     assert!(byte == count as u8);\n-                    rtdebug!(\"%u\", byte as uint);\n+                    rtdebug!(\"{}\", byte as uint);\n                     count += 1;\n                 }\n                 assert_eq!(count, MAX);"}, {"sha": "ddaf0c2872519de7be5a47af6ac92b7b3bbb5683", "filename": "src/libstd/rt/uv/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -199,7 +199,7 @@ fn with_env<T>(env: Option<&[(~str, ~str)]>, f: &fn(**libc::c_char) -> T) -> T {\n     // As with argv, create some temporary storage and then the actual array\n     let mut envp = vec::with_capacity(env.len());\n     for &(ref key, ref value) in env.iter() {\n-        envp.push(fmt!(\"%s=%s\", *key, *value).to_c_str());\n+        envp.push(format!(\"{}={}\", *key, *value).to_c_str());\n     }\n     let mut c_envp = vec::with_capacity(envp.len() + 1);\n     for s in envp.iter() {"}, {"sha": "f9b71db70434794202d31d8a98ec874b6409870f", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -1802,7 +1802,7 @@ fn test_simple_tcp_server_and_client() {\n                 let nread = stream.read(buf).unwrap();\n                 assert_eq!(nread, 8);\n                 for i in range(0u, nread) {\n-                    rtdebug!(\"%u\", buf[i] as uint);\n+                    rtdebug!(\"{}\", buf[i]);\n                     assert_eq!(buf[i], i as u8);\n                 }\n             }\n@@ -1919,7 +1919,7 @@ fn test_simple_udp_server_and_client() {\n                 let (nread,src) = server_socket.recvfrom(buf).unwrap();\n                 assert_eq!(nread, 8);\n                 for i in range(0u, nread) {\n-                    rtdebug!(\"%u\", buf[i] as uint);\n+                    rtdebug!(\"{}\", buf[i]);\n                     assert_eq!(buf[i], i as u8);\n                 }\n                 assert_eq!(src, client_addr);\n@@ -2031,13 +2031,13 @@ fn test_read_read_read() {\n                 let mut total_bytes_read = 0;\n                 while total_bytes_read < MAX {\n                     let nread = stream.read(buf).unwrap();\n-                    rtdebug!(\"read %u bytes\", nread as uint);\n+                    rtdebug!(\"read {} bytes\", nread);\n                     total_bytes_read += nread;\n                     for i in range(0u, nread) {\n                         assert_eq!(buf[i], 1);\n                     }\n                 }\n-                rtdebug!(\"read %u bytes total\", total_bytes_read as uint);\n+                rtdebug!(\"read {} bytes total\", total_bytes_read);\n             }\n         }\n     }"}, {"sha": "074c232e14915f21c14b1ad0fe364edcc87364c5", "filename": "src/libstd/run.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -199,23 +199,23 @@ impl Process {\n     fn input_fd(&mut self) -> c_int {\n         match self.input {\n             Some(fd) => fd,\n-            None => fail!(\"This Process's stdin was redirected to an \\\n+            None => fail2!(\"This Process's stdin was redirected to an \\\n                            existing file descriptor.\")\n         }\n     }\n \n     fn output_file(&mut self) -> *libc::FILE {\n         match self.output {\n             Some(file) => file,\n-            None => fail!(\"This Process's stdout was redirected to an \\\n+            None => fail2!(\"This Process's stdout was redirected to an \\\n                            existing file descriptor.\")\n         }\n     }\n \n     fn error_file(&mut self) -> *libc::FILE {\n         match self.error {\n             Some(file) => file,\n-            None => fail!(\"This Process's stderr was redirected to an \\\n+            None => fail2!(\"This Process's stderr was redirected to an \\\n                            existing file descriptor.\")\n         }\n     }\n@@ -373,7 +373,7 @@ impl Process {\n             ((1, o), (2, e)) => (e, o),\n             ((2, e), (1, o)) => (e, o),\n             ((x, _), (y, _)) => {\n-                fail!(\"unexpected file numbers: %u, %u\", x, y);\n+                fail2!(\"unexpected file numbers: {}, {}\", x, y);\n             }\n         };\n \n@@ -482,29 +482,29 @@ fn spawn_process_os(prog: &str, args: &[~str],\n \n         let orig_std_in = get_osfhandle(in_fd) as HANDLE;\n         if orig_std_in == INVALID_HANDLE_VALUE as HANDLE {\n-            fail!(\"failure in get_osfhandle: %s\", os::last_os_error());\n+            fail2!(\"failure in get_osfhandle: {}\", os::last_os_error());\n         }\n         if DuplicateHandle(cur_proc, orig_std_in, cur_proc, &mut si.hStdInput,\n                            0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-            fail!(\"failure in DuplicateHandle: %s\", os::last_os_error());\n+            fail2!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n         }\n \n         let orig_std_out = get_osfhandle(out_fd) as HANDLE;\n         if orig_std_out == INVALID_HANDLE_VALUE as HANDLE {\n-            fail!(\"failure in get_osfhandle: %s\", os::last_os_error());\n+            fail2!(\"failure in get_osfhandle: {}\", os::last_os_error());\n         }\n         if DuplicateHandle(cur_proc, orig_std_out, cur_proc, &mut si.hStdOutput,\n                            0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-            fail!(\"failure in DuplicateHandle: %s\", os::last_os_error());\n+            fail2!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n         }\n \n         let orig_std_err = get_osfhandle(err_fd) as HANDLE;\n         if orig_std_err == INVALID_HANDLE_VALUE as HANDLE {\n-            fail!(\"failure in get_osfhandle: %s\", os::last_os_error());\n+            fail2!(\"failure in get_osfhandle: {}\", os::last_os_error());\n         }\n         if DuplicateHandle(cur_proc, orig_std_err, cur_proc, &mut si.hStdError,\n                            0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-            fail!(\"failure in DuplicateHandle: %s\", os::last_os_error());\n+            fail2!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n         }\n \n         let cmd = make_command_line(prog, args);\n@@ -529,7 +529,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n         CloseHandle(si.hStdError);\n \n         for msg in create_err.iter() {\n-            fail!(\"failure in CreateProcess: %s\", *msg);\n+            fail2!(\"failure in CreateProcess: {}\", *msg);\n         }\n \n         // We close the thread handle because we don't care about keeping the thread id valid,\n@@ -669,21 +669,21 @@ fn spawn_process_os(prog: &str, args: &[~str],\n \n         let pid = fork();\n         if pid < 0 {\n-            fail!(\"failure in fork: %s\", os::last_os_error());\n+            fail2!(\"failure in fork: {}\", os::last_os_error());\n         } else if pid > 0 {\n             return SpawnProcessResult {pid: pid, handle: ptr::null()};\n         }\n \n         rustrt::rust_unset_sigprocmask();\n \n         if dup2(in_fd, 0) == -1 {\n-            fail!(\"failure in dup2(in_fd, 0): %s\", os::last_os_error());\n+            fail2!(\"failure in dup2(in_fd, 0): {}\", os::last_os_error());\n         }\n         if dup2(out_fd, 1) == -1 {\n-            fail!(\"failure in dup2(out_fd, 1): %s\", os::last_os_error());\n+            fail2!(\"failure in dup2(out_fd, 1): {}\", os::last_os_error());\n         }\n         if dup2(err_fd, 2) == -1 {\n-            fail!(\"failure in dup3(err_fd, 2): %s\", os::last_os_error());\n+            fail2!(\"failure in dup3(err_fd, 2): {}\", os::last_os_error());\n         }\n         // close all other fds\n         for fd in range(3, getdtablesize()).invert() {\n@@ -692,7 +692,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n \n         do with_dirp(dir) |dirp| {\n             if !dirp.is_null() && chdir(dirp) == -1 {\n-                fail!(\"failure in chdir: %s\", os::last_os_error());\n+                fail2!(\"failure in chdir: {}\", os::last_os_error());\n             }\n         }\n \n@@ -703,7 +703,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n             do with_argv(prog, args) |argv| {\n                 execvp(*argv, argv);\n                 // execvp only returns if an error occurred\n-                fail!(\"failure in execvp: %s\", os::last_os_error());\n+                fail2!(\"failure in execvp: {}\", os::last_os_error());\n             }\n         }\n     }\n@@ -749,7 +749,7 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n             let mut tmps = vec::with_capacity(env.len());\n \n             for pair in env.iter() {\n-                let kv = fmt!(\"%s=%s\", pair.first(), pair.second());\n+                let kv = format!(\"{}={}\", pair.first(), pair.second());\n                 tmps.push(kv.to_c_str());\n             }\n \n@@ -777,7 +777,7 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n             let mut blk = ~[];\n \n             for pair in env.iter() {\n-                let kv = fmt!(\"%s=%s\", pair.first(), pair.second());\n+                let kv = format!(\"{}={}\", pair.first(), pair.second());\n                 blk.push_all(kv.as_bytes());\n                 blk.push(0);\n             }\n@@ -890,22 +890,22 @@ fn waitpid(pid: pid_t) -> int {\n \n             let proc = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION, FALSE, pid as DWORD);\n             if proc.is_null() {\n-                fail!(\"failure in OpenProcess: %s\", os::last_os_error());\n+                fail2!(\"failure in OpenProcess: {}\", os::last_os_error());\n             }\n \n             loop {\n                 let mut status = 0;\n                 if GetExitCodeProcess(proc, &mut status) == FALSE {\n                     CloseHandle(proc);\n-                    fail!(\"failure in GetExitCodeProcess: %s\", os::last_os_error());\n+                    fail2!(\"failure in GetExitCodeProcess: {}\", os::last_os_error());\n                 }\n                 if status != STILL_ACTIVE {\n                     CloseHandle(proc);\n                     return status as int;\n                 }\n                 if WaitForSingleObject(proc, INFINITE) == WAIT_FAILED {\n                     CloseHandle(proc);\n-                    fail!(\"failure in WaitForSingleObject: %s\", os::last_os_error());\n+                    fail2!(\"failure in WaitForSingleObject: {}\", os::last_os_error());\n                 }\n             }\n         }\n@@ -943,7 +943,7 @@ fn waitpid(pid: pid_t) -> int {\n \n         let mut status = 0 as c_int;\n         if unsafe { waitpid(pid, &mut status, 0) } == -1 {\n-            fail!(\"failure in waitpid: %s\", os::last_os_error());\n+            fail2!(\"failure in waitpid: {}\", os::last_os_error());\n         }\n \n         return if WIFEXITED(status) {\n@@ -1342,7 +1342,7 @@ mod tests {\n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n             // don't check windows magical empty-named variables\n-            assert!(k.is_empty() || output.contains(fmt!(\"%s=%s\", *k, *v)));\n+            assert!(k.is_empty() || output.contains(format!(\"{}={}\", *k, *v)));\n         }\n     }\n     #[test]\n@@ -1357,8 +1357,8 @@ mod tests {\n         for &(ref k, ref v) in r.iter() {\n             // don't check android RANDOM variables\n             if *k != ~\"RANDOM\" {\n-                assert!(output.contains(fmt!(\"%s=%s\", *k, *v)) ||\n-                        output.contains(fmt!(\"%s=\\'%s\\'\", *k, *v)));\n+                assert!(output.contains(format!(\"{}={}\", *k, *v)) ||\n+                        output.contains(format!(\"{}=\\'{}\\'\", *k, *v)));\n             }\n         }\n     }"}, {"sha": "2554a0ad58823ae6d9d4ab23b2ab4989f8dc5efb", "filename": "src/libstd/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -35,7 +35,7 @@ pub trait SelectPort<T> : SelectPortInner<T> { }\n /// port whose data is ready. (If multiple are ready, returns the lowest index.)\n pub fn select<A: Select>(ports: &mut [A]) -> uint {\n     if ports.is_empty() {\n-        fail!(\"can't select on an empty list\");\n+        fail2!(\"can't select on an empty list\");\n     }\n \n     for (index, port) in ports.mut_iter().enumerate() {\n@@ -116,7 +116,7 @@ pub fn select2<TA, A: SelectPort<TA>, TB, B: SelectPort<TB>>(mut a: A, mut b: B)\n     match result {\n         0 => Left ((a.recv_ready(), b)),\n         1 => Right((a, b.recv_ready())),\n-        x => fail!(\"impossible case in select2: %?\", x)\n+        x => fail2!(\"impossible case in select2: {:?}\", x)\n     }\n }\n \n@@ -335,7 +335,7 @@ mod test {\n                         let _ = dead_cs;\n                     }\n                     do task::spawn {\n-                        fail!(); // should kill sibling awake\n+                        fail2!(); // should kill sibling awake\n                     }\n \n                     // wait for killed selector to close (NOT send on) its c."}, {"sha": "6c9992b81391acfffff0d976eade6ffce2269185", "filename": "src/libstd/str.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -134,8 +134,8 @@ pub fn from_utf8(vv: &[u8]) -> ~str {\n     match from_utf8_opt(vv) {\n         None => {\n             let first_bad_byte = *vv.iter().find(|&b| !is_utf8([*b])).unwrap();\n-            cond.raise(fmt!(\"from_utf8: input is not UTF-8; first bad byte is %u\",\n-                            first_bad_byte as uint))\n+            cond.raise(format!(\"from_utf8: input is not UTF-8; first bad \\\n+                                byte is {}\", first_bad_byte))\n         }\n         Some(s) => s\n     }\n@@ -161,8 +161,8 @@ pub fn from_utf8_owned(vv: ~[u8]) -> ~str {\n \n     if !is_utf8(vv) {\n         let first_bad_byte = *vv.iter().find(|&b| !is_utf8([*b])).unwrap();\n-        cond.raise(fmt!(\"from_utf8: input is not UTF-8; first bad byte is %u\",\n-                        first_bad_byte as uint))\n+        cond.raise(format!(\"from_utf8: input is not UTF-8; first bad byte is {}\",\n+                           first_bad_byte))\n     } else {\n         unsafe { raw::from_utf8_owned(vv) }\n     }\n@@ -1229,7 +1229,7 @@ pub mod raw {\n                 match ctr {\n                     0 => assert_eq!(x, &~\"zero\"),\n                     1 => assert_eq!(x, &~\"one\"),\n-                    _ => fail!(\"shouldn't happen!\")\n+                    _ => fail2!(\"shouldn't happen!\")\n                 }\n                 ctr += 1;\n             }\n@@ -2000,8 +2000,8 @@ impl<'self> StrSlice<'self> for &'self str {\n         if end_byte.is_none() && count == end { end_byte = Some(self.len()) }\n \n         match (begin_byte, end_byte) {\n-            (None, _) => fail!(\"slice_chars: `begin` is beyond end of string\"),\n-            (_, None) => fail!(\"slice_chars: `end` is beyond end of string\"),\n+            (None, _) => fail2!(\"slice_chars: `begin` is beyond end of string\"),\n+            (_, None) => fail2!(\"slice_chars: `end` is beyond end of string\"),\n             (Some(a), Some(b)) => unsafe { raw::slice_bytes(*self, a, b) }\n         }\n     }\n@@ -2723,12 +2723,12 @@ mod tests {\n \n     #[test]\n     fn test_collect() {\n-        let empty = \"\";\n+        let empty = ~\"\";\n         let s: ~str = empty.iter().collect();\n-        assert_eq!(empty, s.as_slice());\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n+        assert_eq!(empty, s);\n+        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n         let s: ~str = data.iter().collect();\n-        assert_eq!(data, s.as_slice());\n+        assert_eq!(data, s);\n     }\n \n     #[test]\n@@ -3242,7 +3242,7 @@ mod tests {\n         // original problem code path anymore.)\n         let s = ~\"\";\n         let _bytes = s.as_bytes();\n-        fail!();\n+        fail2!();\n     }\n \n     #[test]\n@@ -3300,8 +3300,8 @@ mod tests {\n         while i < n1 {\n             let a: u8 = s1[i];\n             let b: u8 = s2[i];\n-            debug!(a);\n-            debug!(b);\n+            debug2!(\"{}\", a);\n+            debug2!(\"{}\", b);\n             assert_eq!(a, b);\n             i += 1u;\n         }"}, {"sha": "25425e07577d0bd3311416896594b50733ef07e5", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -134,7 +134,7 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n     use str::Str;\n \n     unsafe {\n-        // XXX: Bad re-allocations. fail! needs some refactoring\n+        // XXX: Bad re-allocations. fail2! needs some refactoring\n         let msg = str::raw::from_c_str(msg);\n         let file = str::raw::from_c_str(file);\n \n@@ -148,7 +148,7 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n                              n, msg.as_slice(), file.as_slice(), line);\n             }\n         } else {\n-            rterrln!(\"failed in non-task context at '%s', %s:%i\",\n+            rterrln!(\"failed in non-task context at '{}', {}:{}\",\n                      msg, file, line as int);\n         }\n "}, {"sha": "200e2de0271cde96475729e663b4d5fd092fdb4e", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -181,7 +181,7 @@ pub fn task() -> TaskBuilder {\n impl TaskBuilder {\n     fn consume(&mut self) -> TaskBuilder {\n         if self.consumed {\n-            fail!(\"Cannot copy a task_builder\"); // Fake move mode on self\n+            fail2!(\"Cannot copy a task_builder\"); // Fake move mode on self\n         }\n         self.consumed = true;\n         let gen_body = self.gen_body.take();\n@@ -271,7 +271,7 @@ impl TaskBuilder {\n         // sending out messages.\n \n         if self.opts.notify_chan.is_some() {\n-            fail!(\"Can't set multiple future_results for one task!\");\n+            fail2!(\"Can't set multiple future_results for one task!\");\n         }\n \n         // Construct the future and give it to the caller.\n@@ -532,7 +532,7 @@ pub fn with_task_name<U>(blk: &fn(Option<&str>) -> U) -> U {\n             }\n         }\n     } else {\n-        fail!(\"no task name exists in non-green task context\")\n+        fail2!(\"no task name exists in non-green task context\")\n     }\n }\n \n@@ -640,7 +640,7 @@ fn test_kill_unkillable_task() {\n     do run_in_newsched_task {\n         do task::try {\n             do task::spawn {\n-                fail!();\n+                fail2!();\n             }\n             do task::unkillable { }\n         };\n@@ -659,7 +659,7 @@ fn test_kill_rekillable_task() {\n             do task::unkillable {\n                 do task::rekillable {\n                     do task::spawn {\n-                        fail!();\n+                        fail2!();\n                     }\n                 }\n             }\n@@ -689,7 +689,7 @@ fn test_rekillable_nested_failure() {\n         do unkillable {\n             do rekillable {\n                 let (port,chan) = comm::stream();\n-                do task::spawn { chan.send(()); fail!(); }\n+                do task::spawn { chan.send(()); fail2!(); }\n                 port.recv(); // wait for child to exist\n                 port.recv(); // block forever, expect to get killed.\n             }\n@@ -733,7 +733,7 @@ fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n                 do 16.times { task::deschedule(); }\n                 ch.send(()); // If killed first, grandparent hangs.\n             }\n-            fail!(); // Shouldn't kill either (grand)parent or (grand)child.\n+            fail2!(); // Shouldn't kill either (grand)parent or (grand)child.\n         }\n         po.recv();\n     }\n@@ -743,15 +743,15 @@ fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n fn test_spawn_unlinked_unsup_no_fail_up() { // child unlinked fails\n     use rt::test::run_in_newsched_task;\n     do run_in_newsched_task {\n-        do spawn_unlinked { fail!(); }\n+        do spawn_unlinked { fail2!(); }\n     }\n }\n #[ignore(reason = \"linked failure\")]\n #[test]\n fn test_spawn_unlinked_sup_no_fail_up() { // child unlinked fails\n     use rt::test::run_in_newsched_task;\n     do run_in_newsched_task {\n-        do spawn_supervised { fail!(); }\n+        do spawn_supervised { fail2!(); }\n         // Give child a chance to fail-but-not-kill-us.\n         do 16.times { task::deschedule(); }\n     }\n@@ -763,7 +763,7 @@ fn test_spawn_unlinked_sup_fail_down() {\n     do run_in_newsched_task {\n         let result: Result<(),()> = do try {\n             do spawn_supervised { block_forever(); }\n-            fail!(); // Shouldn't leave a child hanging around.\n+            fail2!(); // Shouldn't leave a child hanging around.\n         };\n         assert!(result.is_err());\n     }\n@@ -783,7 +783,7 @@ fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n             b0.opts.supervised = true;\n \n             do b0.spawn {\n-                fail!();\n+                fail2!();\n             }\n             block_forever(); // We should get punted awake\n         };\n@@ -802,7 +802,7 @@ fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n             b0.opts.linked = true;\n             b0.opts.supervised = true;\n             do b0.spawn { block_forever(); }\n-            fail!(); // *both* mechanisms would be wrong if this didn't kill the child\n+            fail2!(); // *both* mechanisms would be wrong if this didn't kill the child\n         };\n         assert!(result.is_err());\n     }\n@@ -814,7 +814,7 @@ fn test_spawn_linked_unsup_fail_up() { // child fails; parent fails\n     do run_in_newsched_task {\n         let result: Result<(),()> = do try {\n             // Default options are to spawn linked & unsupervised.\n-            do spawn { fail!(); }\n+            do spawn { fail2!(); }\n             block_forever(); // We should get punted awake\n         };\n         assert!(result.is_err());\n@@ -828,7 +828,7 @@ fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n         let result: Result<(),()> = do try {\n             // Default options are to spawn linked & unsupervised.\n             do spawn { block_forever(); }\n-            fail!();\n+            fail2!();\n         };\n         assert!(result.is_err());\n     }\n@@ -843,7 +843,7 @@ fn test_spawn_linked_unsup_default_opts() { // parent fails; child fails\n             let mut builder = task();\n             builder.linked();\n             do builder.spawn { block_forever(); }\n-            fail!();\n+            fail2!();\n         };\n         assert!(result.is_err());\n     }\n@@ -863,7 +863,7 @@ fn test_spawn_failure_propagate_grandchild() {\n                 do spawn_supervised { block_forever(); }\n             }\n             do 16.times { task::deschedule(); }\n-            fail!();\n+            fail2!();\n         };\n         assert!(result.is_err());\n     }\n@@ -880,7 +880,7 @@ fn test_spawn_failure_propagate_secondborn() {\n                 do spawn { block_forever(); } // linked\n             }\n             do 16.times { task::deschedule(); }\n-            fail!();\n+            fail2!();\n         };\n         assert!(result.is_err());\n     }\n@@ -897,7 +897,7 @@ fn test_spawn_failure_propagate_nephew_or_niece() {\n                 do spawn_supervised { block_forever(); }\n             }\n             do 16.times { task::deschedule(); }\n-            fail!();\n+            fail2!();\n         };\n         assert!(result.is_err());\n     }\n@@ -914,7 +914,7 @@ fn test_spawn_linked_sup_propagate_sibling() {\n                 do spawn { block_forever(); } // linked\n             }\n             do 16.times { task::deschedule(); }\n-            fail!();\n+            fail2!();\n         };\n         assert!(result.is_err());\n     }\n@@ -994,7 +994,7 @@ fn test_future_result() {\n     builder.future_result(|r| result = Some(r));\n     builder.unlinked();\n     do builder.spawn {\n-        fail!();\n+        fail2!();\n     }\n     assert_eq!(result.unwrap().recv(), Failure);\n }\n@@ -1012,17 +1012,17 @@ fn test_try_success() {\n         ~\"Success!\"\n     } {\n         result::Ok(~\"Success!\") => (),\n-        _ => fail!()\n+        _ => fail2!()\n     }\n }\n \n #[test]\n fn test_try_fail() {\n     match do try {\n-        fail!()\n+        fail2!()\n     } {\n         result::Err(()) => (),\n-        result::Ok(()) => fail!()\n+        result::Ok(()) => fail2!()\n     }\n }\n \n@@ -1212,7 +1212,7 @@ fn test_unkillable() {\n         deschedule();\n         // We want to fail after the unkillable task\n         // blocks on recv\n-        fail!();\n+        fail2!();\n     }\n \n     unsafe {\n@@ -1247,7 +1247,7 @@ fn test_unkillable_nested() {\n         deschedule();\n         // We want to fail after the unkillable task\n         // blocks on recv\n-        fail!();\n+        fail2!();\n     }\n \n     unsafe {\n@@ -1312,7 +1312,7 @@ fn test_spawn_watched() {\n                 t.watched();\n                 do t.spawn {\n                     task::deschedule();\n-                    fail!();\n+                    fail2!();\n                 }\n             }\n         };\n@@ -1348,7 +1348,7 @@ fn test_indestructible() {\n                 do t.spawn {\n                     p3.recv();\n                     task::deschedule();\n-                    fail!();\n+                    fail2!();\n                 }\n                 c3.send(());\n                 p2.recv();"}, {"sha": "a77c9744298025f5cc1f92857a4cef68252dab7e", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -712,7 +712,7 @@ fn test_spawn_raw_unsupervise() {\n         .. default_task_opts()\n     };\n     do spawn_raw(opts) {\n-        fail!();\n+        fail2!();\n     }\n }\n \n@@ -741,7 +741,7 @@ fn test_spawn_raw_notify_failure() {\n         .. default_task_opts()\n     };\n     do spawn_raw(opts) {\n-        fail!();\n+        fail2!();\n     }\n     assert_eq!(notify_po.recv(), Failure);\n }"}, {"sha": "554b9a851004835dba303540008bf3b68546e579", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -45,7 +45,7 @@ impl<A:ToStr> ToStr for (A,) {\n     fn to_str(&self) -> ~str {\n         match *self {\n             (ref a,) => {\n-                fmt!(\"(%s,)\", (*a).to_str())\n+                format!(\"({},)\", (*a).to_str())\n             }\n         }\n     }\n@@ -98,7 +98,7 @@ impl<A:ToStr,B:ToStr> ToStr for (A, B) {\n         //let &(ref a, ref b) = self;\n         match *self {\n             (ref a, ref b) => {\n-                fmt!(\"(%s, %s)\", (*a).to_str(), (*b).to_str())\n+                format!(\"({}, {})\", (*a).to_str(), (*b).to_str())\n             }\n         }\n     }\n@@ -111,7 +111,7 @@ impl<A:ToStr,B:ToStr,C:ToStr> ToStr for (A, B, C) {\n         //let &(ref a, ref b, ref c) = self;\n         match *self {\n             (ref a, ref b, ref c) => {\n-                fmt!(\"(%s, %s, %s)\",\n+                format!(\"({}, {}, {})\",\n                     (*a).to_str(),\n                     (*b).to_str(),\n                     (*c).to_str()\n@@ -221,7 +221,7 @@ mod tests {\n \n     impl ToStr for StructWithToStrWithoutEqOrHash {\n         fn to_str(&self) -> ~str {\n-            fmt!(\"s%d\", self.value)\n+            format!(\"s{}\", self.value)\n         }\n     }\n "}, {"sha": "c1b0cd500d6a1a77a128d9c11e978fd9b0cb414a", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -422,7 +422,7 @@ fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n       External(stored, _) if stored == key => {\n         match replace(child, Nothing) {\n             External(_, value) => (Some(value), true),\n-            _ => fail!()\n+            _ => fail2!()\n         }\n       }\n       External(*) => (None, false),\n@@ -531,7 +531,7 @@ mod test_map {\n         assert!(m.insert(5, 14));\n         let new = 100;\n         match m.find_mut(&5) {\n-            None => fail!(), Some(x) => *x = new\n+            None => fail2!(), Some(x) => *x = new\n         }\n         assert_eq!(m.find(&5), Some(&new));\n     }"}, {"sha": "0045aef06f106b4d797039ded7a108f891038471", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -33,7 +33,7 @@ impl Drop for DynamicLibrary {\n             }\n         } {\n             Ok(()) => {},\n-            Err(str) => fail!(str)\n+            Err(str) => fail2!(\"{}\", str)\n         }\n     }\n }\n@@ -96,15 +96,15 @@ mod test {\n         // The math library does not need to be loaded since it is already\n         // statically linked in\n         let libm = match DynamicLibrary::open(None) {\n-            Err(error) => fail!(\"Could not load self as module: %s\", error),\n+            Err(error) => fail2!(\"Could not load self as module: {}\", error),\n             Ok(libm) => libm\n         };\n \n         // Unfortunately due to issue #6194 it is not possible to call\n         // this as a C function\n         let cosine: extern fn(libc::c_double) -> libc::c_double = unsafe {\n             match libm.symbol(\"cos\") {\n-                Err(error) => fail!(\"Could not load function cos: %s\", error),\n+                Err(error) => fail2!(\"Could not load function cos: {}\", error),\n                 Ok(cosine) => cosine\n             }\n         };\n@@ -113,7 +113,7 @@ mod test {\n         let expected_result = 1.0;\n         let result = cosine(argument);\n         if result != expected_result {\n-            fail!(\"cos(%?) != %? but equaled %? instead\", argument,\n+            fail2!(\"cos({:?}) != {:?} but equaled {:?} instead\", argument,\n                   expected_result, result)\n         }\n     }\n@@ -129,7 +129,7 @@ mod test {\n         let path = GenericPath::from_str(\"/dev/null\");\n         match DynamicLibrary::open(Some(&path)) {\n             Err(_) => {}\n-            Ok(_) => fail!(\"Successfully opened the empty library.\")\n+            Ok(_) => fail2!(\"Successfully opened the empty library.\")\n         }\n     }\n }\n@@ -241,7 +241,7 @@ pub mod dl {\n                 if 0 == error {\n                     Ok(result)\n                 } else {\n-                    Err(fmt!(\"Error code %?\", error))\n+                    Err(format!(\"Error code {}\", error))\n                 }\n             }\n         }"}, {"sha": "b224c22df20a63aee7d085081b21ae9728731b89", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -333,14 +333,14 @@ pub mod ct {\n             'f' => TyFloat,\n             'p' => TyPointer,\n             '?' => TyPoly,\n-            _ => err(fmt!(\"unknown type in conversion: %c\", s.char_at(i)))\n+            _ => err(format!(\"unknown type in conversion: {}\", s.char_at(i)))\n         };\n \n         Parsed::new(t, i + 1)\n     }\n \n     #[cfg(test)]\n-    fn die(s: &str) -> ! { fail!(s.to_owned()) }\n+    fn die(s: &str) -> ! { fail2!(s.to_owned()) }\n \n     #[test]\n     fn test_parse_count() {\n@@ -698,6 +698,6 @@ mod test {\n     #[test]\n     fn fmt_slice() {\n         let s = \"abc\";\n-        let _s = fmt!(\"%s\", s);\n+        let _s = format!(\"{}\", s);\n     }\n }"}, {"sha": "9fe3435c21ba1510ff2cbcead90222814639d638", "filename": "src/libstd/unstable/finally.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Ffinally.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -87,7 +87,7 @@ fn test_fail() {\n     let mut i = 0;\n     do (|| {\n         i = 10;\n-        fail!();\n+        fail2!();\n     }).finally {\n         assert!(failing());\n         assert_eq!(i, 10);"}, {"sha": "fca477763c5e6f5751d74369ff5d89b1bd8f78ec", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -27,8 +27,8 @@ pub fn fail_(expr: *c_char, file: *c_char, line: size_t) -> ! {\n #[lang=\"fail_bounds_check\"]\n pub fn fail_bounds_check(file: *c_char, line: size_t,\n                          index: size_t, len: size_t) {\n-    let msg = fmt!(\"index out of bounds: the len is %d but the index is %d\",\n-                    len as int, index as int);\n+    let msg = format!(\"index out of bounds: the len is {} but the index is {}\",\n+                      len as int, index as int);\n     do msg.with_c_str |buf| {\n         fail_(buf, file, line);\n     }"}, {"sha": "066c2173b5af2334753949e0b190d5c79c557545", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -172,7 +172,7 @@ impl<T: Send> UnsafeArc<T> {\n                     // If 'put' returns the server end back to us, we were rejected;\n                     // someone else was trying to unwrap. Avoid guaranteed deadlock.\n                     cast::forget(data);\n-                    fail!(\"Another task is already unwrapping this Arc!\");\n+                    fail2!(\"Another task is already unwrapping this Arc!\");\n                 }\n             }\n         }\n@@ -386,7 +386,7 @@ impl<T:Send> Exclusive<T> {\n         let rec = self.x.get();\n         do (*rec).lock.lock {\n             if (*rec).failed {\n-                fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n+                fail2!(\"Poisoned Exclusive::new - another task failed inside!\");\n             }\n             (*rec).failed = true;\n             let result = f(&mut (*rec).data);\n@@ -618,7 +618,7 @@ mod tests {\n             let x2 = x.clone();\n             do task::spawn {\n                 do 10.times { task::deschedule(); } // try to let the unwrapper go\n-                fail!(); // punt it awake from its deadlock\n+                fail2!(); // punt it awake from its deadlock\n             }\n             let _z = x.unwrap();\n             unsafe { do x2.with |_hello| { } }"}, {"sha": "aa927d0f0a03b2c1138c1d2b4c9d607fd2df0046", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ba31dbf3e7d80a069bc486a35eff8357282b68/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=a8ba31dbf3e7d80a069bc486a35eff8357282b68", "patch": "@@ -1022,7 +1022,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     /// Returns the first element of a vector, failing if the vector is empty.\n     #[inline]\n     fn head(&self) -> &'self T {\n-        if self.len() == 0 { fail!(\"head: empty vector\") }\n+        if self.len() == 0 { fail2!(\"head: empty vector\") }\n         &self[0]\n     }\n \n@@ -1055,7 +1055,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     /// Returns the last element of a vector, failing if the vector is empty.\n     #[inline]\n     fn last(&self) -> &'self T {\n-        if self.len() == 0 { fail!(\"last: empty vector\") }\n+        if self.len() == 0 { fail2!(\"last: empty vector\") }\n         &self[self.len() - 1]\n     }\n \n@@ -1301,7 +1301,7 @@ impl<T> OwnedVector<T> for ~[T] {\n                     let alloc = n * sys::nonzero_size_of::<T>();\n                     let size = alloc + sys::size_of::<Vec<()>>();\n                     if alloc / sys::nonzero_size_of::<T>() != n || size < alloc {\n-                        fail!(\"vector size is too large: %u\", n);\n+                        fail2!(\"vector size is too large: {}\", n);\n                     }\n                     *ptr = realloc_raw(*ptr as *mut c_void, size)\n                            as *mut Vec<()>;\n@@ -1343,7 +1343,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     fn reserve_additional(&mut self, n: uint) {\n         if self.capacity() - self.len() < n {\n             match self.len().checked_add(&n) {\n-                None => fail!(\"vec::reserve_additional: `uint` overflow\"),\n+                None => fail2!(\"vec::reserve_additional: `uint` overflow\"),\n                 Some(new_cap) => self.reserve_at_least(new_cap)\n             }\n         }\n@@ -1570,7 +1570,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     fn swap_remove(&mut self, index: uint) -> T {\n         let ln = self.len();\n         if index >= ln {\n-            fail!(\"vec::swap_remove - index %u >= length %u\", index, ln);\n+            fail2!(\"vec::swap_remove - index {} >= length {}\", index, ln);\n         }\n         if index < ln - 1 {\n             self.swap(index, ln - 1);\n@@ -2958,7 +2958,7 @@ mod tests {\n                 3 => assert_eq!(v, [2, 3, 1]),\n                 4 => assert_eq!(v, [2, 1, 3]),\n                 5 => assert_eq!(v, [1, 2, 3]),\n-                _ => fail!(),\n+                _ => fail2!(),\n             }\n         }\n     }\n@@ -3205,7 +3205,7 @@ mod tests {\n     #[should_fail]\n     fn test_from_fn_fail() {\n         do from_fn(100) |v| {\n-            if v == 50 { fail!() }\n+            if v == 50 { fail2!() }\n             (~0, @0)\n         };\n     }\n@@ -3224,7 +3224,7 @@ mod tests {\n             fn clone(&self) -> S {\n                 let s = unsafe { cast::transmute_mut(self) };\n                 s.f += 1;\n-                if s.f == 10 { fail!() }\n+                if s.f == 10 { fail2!() }\n                 S { f: s.f, boxes: s.boxes.clone() }\n             }\n         }\n@@ -3241,7 +3241,7 @@ mod tests {\n             push((~0, @0));\n             push((~0, @0));\n             push((~0, @0));\n-            fail!();\n+            fail2!();\n         };\n     }\n \n@@ -3251,7 +3251,7 @@ mod tests {\n         let mut v = ~[];\n         do v.grow_fn(100) |i| {\n             if i == 50 {\n-                fail!()\n+                fail2!()\n             }\n             (~0, @0)\n         }\n@@ -3264,7 +3264,7 @@ mod tests {\n         let mut i = 0;\n         do v.map |_elt| {\n             if i == 2 {\n-                fail!()\n+                fail2!()\n             }\n             i += 1;\n             ~[(~0, @0)]\n@@ -3278,7 +3278,7 @@ mod tests {\n         let mut i = 0;\n         do flat_map(v) |_elt| {\n             if i == 2 {\n-                fail!()\n+                fail2!()\n             }\n             i += 1;\n             ~[(~0, @0)]\n@@ -3292,7 +3292,7 @@ mod tests {\n         let mut i = 0;\n         for _ in v.permutations_iter() {\n             if i == 2 {\n-                fail!()\n+                fail2!()\n             }\n             i += 1;\n         }\n@@ -3303,7 +3303,7 @@ mod tests {\n     fn test_as_imm_buf_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         do v.as_imm_buf |_buf, _i| {\n-            fail!()\n+            fail2!()\n         }\n     }\n \n@@ -3312,7 +3312,7 @@ mod tests {\n     fn test_as_mut_buf_fail() {\n         let mut v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         do v.as_mut_buf |_buf, _i| {\n-            fail!()\n+            fail2!()\n         }\n     }\n \n@@ -3702,11 +3702,11 @@ mod tests {\n         assert_eq!(cnt, 11);\n \n         let xs = ~[Foo, Foo, Foo];\n-        assert_eq!(fmt!(\"%?\", xs.slice(0, 2).to_owned()),\n+        assert_eq!(format!(\"{:?}\", xs.slice(0, 2).to_owned()),\n                    ~\"~[vec::tests::Foo, vec::tests::Foo]\");\n \n         let xs: [Foo, ..3] = [Foo, Foo, Foo];\n-        assert_eq!(fmt!(\"%?\", xs.slice(0, 2).to_owned()),\n+        assert_eq!(format!(\"{:?}\", xs.slice(0, 2).to_owned()),\n                    ~\"~[vec::tests::Foo, vec::tests::Foo]\");\n         cnt = 0;\n         for f in xs.iter() {\n@@ -3749,7 +3749,7 @@ mod bench {\n                 sum += *x;\n             }\n             // sum == 11806, to stop dead code elimination.\n-            if sum == 0 {fail!()}\n+            if sum == 0 {fail2!()}\n         }\n     }\n "}]}