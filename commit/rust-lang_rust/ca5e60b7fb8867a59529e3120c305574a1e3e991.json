{"sha": "ca5e60b7fb8867a59529e3120c305574a1e3e991", "node_id": "C_kwDOAAsO6NoAKGNhNWU2MGI3ZmI4ODY3YTU5NTI5ZTMxMjBjMzA1NTc0YTFlM2U5OTE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-05-22T18:16:14Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-05-24T02:39:10Z"}, "message": "split out the various responsibilities of Lazy", "tree": {"sha": "20a1110450924ce62c161e68021a919a6c56582b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20a1110450924ce62c161e68021a919a6c56582b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca5e60b7fb8867a59529e3120c305574a1e3e991", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca5e60b7fb8867a59529e3120c305574a1e3e991", "html_url": "https://github.com/rust-lang/rust/commit/ca5e60b7fb8867a59529e3120c305574a1e3e991", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca5e60b7fb8867a59529e3120c305574a1e3e991/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee160f2f5e73b6f5954bc33f059c316d9e8582c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee160f2f5e73b6f5954bc33f059c316d9e8582c4", "html_url": "https://github.com/rust-lang/rust/commit/ee160f2f5e73b6f5954bc33f059c316d9e8582c4"}], "stats": {"total": 790, "additions": 370, "deletions": 420}, "files": [{"sha": "cf60cf501d0bcfb0d45231a2bb227a344a170472", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 54, "deletions": 150, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/ca5e60b7fb8867a59529e3120c305574a1e3e991/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca5e60b7fb8867a59529e3120c305574a1e3e991/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=ca5e60b7fb8867a59529e3120c305574a1e3e991", "patch": "@@ -1,12 +1,10 @@\n // Decoding metadata from a single crate's metadata\n \n use crate::creader::{CStore, CrateMetadataRef};\n-use crate::rmeta::table::{FixedSizeEncoding, Table};\n use crate::rmeta::*;\n \n use rustc_ast as ast;\n use rustc_ast::ptr::P;\n-use rustc_attr as attr;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;\n@@ -20,10 +18,8 @@ use rustc_hir::definitions::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc_hir::diagnostic_items::DiagnosticItems;\n use rustc_hir::lang_items;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::arena::ArenaAllocatable;\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n-use rustc_middle::middle::stability::DeprecationEntry;\n use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_middle::thir;\n use rustc_middle::ty::codec::TyDecoder;\n@@ -85,7 +81,6 @@ pub(crate) struct CrateMetadata {\n     blob: MetadataBlob,\n \n     // --- Some data pre-decoded from the metadata blob, usually for performance ---\n-    /// Properties of the whole crate.\n     /// NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n     /// lifetime is only used behind `Lazy`, and therefore acts like a\n     /// universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n@@ -94,12 +89,12 @@ pub(crate) struct CrateMetadata {\n     /// Trait impl data.\n     /// FIXME: Used only from queries and can use query cache,\n     /// so pre-decoding can probably be avoided.\n-    trait_impls: FxHashMap<(u32, DefIndex), Lazy<[(DefIndex, Option<SimplifiedType>)]>>,\n+    trait_impls: FxHashMap<(u32, DefIndex), LazyArray<(DefIndex, Option<SimplifiedType>)>>,\n     /// Inherent impls which do not follow the normal coherence rules.\n     ///\n     /// These can be introduced using either `#![rustc_coherence_is_core]`\n     /// or `#[rustc_allow_incoherent_impl]`.\n-    incoherent_impls: FxHashMap<SimplifiedType, Lazy<[DefIndex]>>,\n+    incoherent_impls: FxHashMap<SimplifiedType, LazyArray<DefIndex>>,\n     /// Proc macro descriptions for this crate, if it's a proc macro crate.\n     raw_proc_macros: Option<&'static [ProcMacro]>,\n     /// Source maps for code from the crate.\n@@ -265,138 +260,41 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (CrateMetadataRef<'a>, TyCtxt<'tcx>) {\n     }\n }\n \n-impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> Lazy<T> {\n+impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> LazyValue<T> {\n     fn decode<M: Metadata<'a, 'tcx>>(self, metadata: M) -> T {\n         let mut dcx = metadata.decoder(self.position.get());\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         T::decode(&mut dcx)\n     }\n }\n \n-impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable<DecodeContext<'a, 'tcx>>> Lazy<[T]> {\n-    fn decode<M: Metadata<'a, 'tcx>>(\n-        self,\n-        metadata: M,\n-    ) -> impl ExactSizeIterator<Item = T> + Captures<'a> + Captures<'tcx> + 'x {\n-        let mut dcx = metadata.decoder(self.position.get());\n-        dcx.lazy_state = LazyState::NodeStart(self.position);\n-        (0..self.meta).map(move |_| T::decode(&mut dcx))\n-    }\n-}\n-\n-trait LazyQueryDecodable<'a, 'tcx, T> {\n-    fn decode_query(\n-        self,\n-        cdata: CrateMetadataRef<'a>,\n-        tcx: TyCtxt<'tcx>,\n-        err: impl FnOnce() -> !,\n-    ) -> T;\n-}\n-\n-impl<'a, 'tcx, T> LazyQueryDecodable<'a, 'tcx, T> for T {\n-    fn decode_query(self, _: CrateMetadataRef<'a>, _: TyCtxt<'tcx>, _: impl FnOnce() -> !) -> T {\n-        self\n-    }\n-}\n-\n-impl<'a, 'tcx, T> LazyQueryDecodable<'a, 'tcx, T> for Option<T> {\n-    fn decode_query(self, _: CrateMetadataRef<'a>, _: TyCtxt<'tcx>, err: impl FnOnce() -> !) -> T {\n-        if let Some(l) = self { l } else { err() }\n-    }\n+struct DecodeIterator<'a, 'tcx, T> {\n+    range: std::ops::Range<usize>,\n+    dcx: DecodeContext<'a, 'tcx>,\n+    _phantom: PhantomData<fn() -> T>,\n }\n \n-impl<'a, 'tcx, T> LazyQueryDecodable<'a, 'tcx, T> for Option<Lazy<T>>\n-where\n-    T: Decodable<DecodeContext<'a, 'tcx>>,\n-{\n-    fn decode_query(\n-        self,\n-        cdata: CrateMetadataRef<'a>,\n-        tcx: TyCtxt<'tcx>,\n-        err: impl FnOnce() -> !,\n-    ) -> T {\n-        if let Some(l) = self { l.decode((cdata, tcx)) } else { err() }\n-    }\n-}\n+impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> Iterator for DecodeIterator<'a, 'tcx, T> {\n+    type Item = T;\n \n-impl<'a, 'tcx, T> LazyQueryDecodable<'a, 'tcx, &'tcx T> for Option<Lazy<T>>\n-where\n-    T: Decodable<DecodeContext<'a, 'tcx>>,\n-    T: ArenaAllocatable<'tcx>,\n-{\n-    fn decode_query(\n-        self,\n-        cdata: CrateMetadataRef<'a>,\n-        tcx: TyCtxt<'tcx>,\n-        err: impl FnOnce() -> !,\n-    ) -> &'tcx T {\n-        if let Some(l) = self { tcx.arena.alloc(l.decode((cdata, tcx))) } else { err() }\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.range.next().map(|_| T::decode(&mut self.dcx))\n     }\n }\n \n-impl<'a, 'tcx, T> LazyQueryDecodable<'a, 'tcx, Option<T>> for Option<Lazy<T>>\n-where\n-    T: Decodable<DecodeContext<'a, 'tcx>>,\n+impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> ExactSizeIterator\n+    for DecodeIterator<'a, 'tcx, T>\n {\n-    fn decode_query(\n-        self,\n-        cdata: CrateMetadataRef<'a>,\n-        tcx: TyCtxt<'tcx>,\n-        _err: impl FnOnce() -> !,\n-    ) -> Option<T> {\n-        self.map(|l| l.decode((cdata, tcx)))\n+    fn len(&self) -> usize {\n+        self.range.len()\n     }\n }\n \n-impl<'a, 'tcx, T, E> LazyQueryDecodable<'a, 'tcx, Result<Option<T>, E>> for Option<Lazy<T>>\n-where\n-    T: Decodable<DecodeContext<'a, 'tcx>>,\n-{\n-    fn decode_query(\n-        self,\n-        cdata: CrateMetadataRef<'a>,\n-        tcx: TyCtxt<'tcx>,\n-        _err: impl FnOnce() -> !,\n-    ) -> Result<Option<T>, E> {\n-        Ok(self.map(|l| l.decode((cdata, tcx))))\n-    }\n-}\n-\n-impl<'a, 'tcx, T> LazyQueryDecodable<'a, 'tcx, &'tcx [T]> for Option<Lazy<[T], usize>>\n-where\n-    T: Decodable<DecodeContext<'a, 'tcx>> + Copy,\n-{\n-    fn decode_query(\n-        self,\n-        cdata: CrateMetadataRef<'a>,\n-        tcx: TyCtxt<'tcx>,\n-        _err: impl FnOnce() -> !,\n-    ) -> &'tcx [T] {\n-        if let Some(l) = self { tcx.arena.alloc_from_iter(l.decode((cdata, tcx))) } else { &[] }\n-    }\n-}\n-\n-impl<'a, 'tcx> LazyQueryDecodable<'a, 'tcx, Option<DeprecationEntry>>\n-    for Option<Lazy<attr::Deprecation>>\n-{\n-    fn decode_query(\n-        self,\n-        cdata: CrateMetadataRef<'a>,\n-        tcx: TyCtxt<'tcx>,\n-        _err: impl FnOnce() -> !,\n-    ) -> Option<DeprecationEntry> {\n-        self.map(|l| l.decode((cdata, tcx))).map(DeprecationEntry::external)\n-    }\n-}\n-\n-impl<'a, 'tcx> LazyQueryDecodable<'a, 'tcx, Option<DefId>> for Option<RawDefId> {\n-    fn decode_query(\n-        self,\n-        cdata: CrateMetadataRef<'a>,\n-        _: TyCtxt<'tcx>,\n-        _: impl FnOnce() -> !,\n-    ) -> Option<DefId> {\n-        self.map(|raw_def_id| raw_def_id.decode(cdata))\n+impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable<DecodeContext<'a, 'tcx>>> LazyArray<T> {\n+    fn decode<M: Metadata<'a, 'tcx>>(self, metadata: M) -> DecodeIterator<'a, 'tcx, T> {\n+        let mut dcx = metadata.decoder(self.position.get());\n+        dcx.lazy_state = LazyState::NodeStart(self.position);\n+        DecodeIterator { range: (0..self.len), dcx, _phantom: PhantomData }\n     }\n }\n \n@@ -423,7 +321,7 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n         self.cdata().map_encoded_cnum_to_current(cnum)\n     }\n \n-    fn read_lazy_with_meta<T: ?Sized + LazyMeta>(&mut self, meta: T::Meta) -> Lazy<T> {\n+    fn read_lazy_offset_then<T>(&mut self, f: impl Fn(NonZeroUsize) -> T) -> T {\n         let distance = self.read_usize();\n         let position = match self.lazy_state {\n             LazyState::NoNode => bug!(\"read_lazy_with_meta: outside of a metadata node\"),\n@@ -434,8 +332,21 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n             }\n             LazyState::Previous(last_pos) => last_pos.get() + distance,\n         };\n-        self.lazy_state = LazyState::Previous(NonZeroUsize::new(position).unwrap());\n-        Lazy::from_position_and_meta(NonZeroUsize::new(position).unwrap(), meta)\n+        let position = NonZeroUsize::new(position).unwrap();\n+        self.lazy_state = LazyState::Previous(position);\n+        f(position)\n+    }\n+\n+    fn read_lazy<T>(&mut self) -> LazyValue<T> {\n+        self.read_lazy_offset_then(|pos| LazyValue::from_position(pos))\n+    }\n+\n+    fn read_lazy_array<T>(&mut self, len: usize) -> LazyArray<T> {\n+        self.read_lazy_offset_then(|pos| LazyArray::from_position_and_len(pos, len))\n+    }\n+\n+    fn read_lazy_table<I, T>(&mut self, len: usize) -> LazyTable<I, T> {\n+        self.read_lazy_offset_then(|pos| LazyTable::from_position_and_len(pos, len))\n     }\n \n     #[inline]\n@@ -714,36 +625,29 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx\n     }\n }\n \n-impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> Decodable<DecodeContext<'a, 'tcx>>\n-    for Lazy<T>\n-{\n+impl<'a, 'tcx, T> Decodable<DecodeContext<'a, 'tcx>> for LazyValue<T> {\n     fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Self {\n-        decoder.read_lazy_with_meta(())\n+        decoder.read_lazy()\n     }\n }\n \n-impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> Decodable<DecodeContext<'a, 'tcx>>\n-    for Lazy<[T]>\n-{\n+impl<'a, 'tcx, T> Decodable<DecodeContext<'a, 'tcx>> for LazyArray<T> {\n     fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Self {\n         let len = decoder.read_usize();\n-        if len == 0 { Lazy::empty() } else { decoder.read_lazy_with_meta(len) }\n+        if len == 0 { LazyArray::empty() } else { decoder.read_lazy_array(len) }\n     }\n }\n \n-impl<'a, 'tcx, I: Idx, T> Decodable<DecodeContext<'a, 'tcx>> for Lazy<Table<I, T>>\n-where\n-    Option<T>: FixedSizeEncoding,\n-{\n+impl<'a, 'tcx, I: Idx, T> Decodable<DecodeContext<'a, 'tcx>> for LazyTable<I, T> {\n     fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Self {\n         let len = decoder.read_usize();\n-        decoder.read_lazy_with_meta(len)\n+        decoder.read_lazy_table(len)\n     }\n }\n \n implement_ty_decoder!(DecodeContext<'a, 'tcx>);\n \n-impl<'tcx> MetadataBlob {\n+impl MetadataBlob {\n     pub(crate) fn new(metadata_ref: MetadataRef) -> MetadataBlob {\n         MetadataBlob(Lrc::new(metadata_ref))\n     }\n@@ -753,18 +657,18 @@ impl<'tcx> MetadataBlob {\n     }\n \n     pub(crate) fn get_rustc_version(&self) -> String {\n-        Lazy::<String>::from_position(NonZeroUsize::new(METADATA_HEADER.len() + 4).unwrap())\n+        LazyValue::<String>::from_position(NonZeroUsize::new(METADATA_HEADER.len() + 4).unwrap())\n             .decode(self)\n     }\n \n-    pub(crate) fn get_root(&self) -> CrateRoot<'tcx> {\n+    pub(crate) fn get_root<'tcx>(&self) -> CrateRoot<'tcx> {\n         let slice = &self.blob()[..];\n         let offset = METADATA_HEADER.len();\n         let pos = (((slice[offset + 0] as u32) << 24)\n             | ((slice[offset + 1] as u32) << 16)\n             | ((slice[offset + 2] as u32) << 8)\n             | ((slice[offset + 3] as u32) << 0)) as usize;\n-        Lazy::<CrateRoot<'tcx>>::from_position(NonZeroUsize::new(pos).unwrap()).decode(self)\n+        LazyValue::<CrateRoot<'tcx>>::from_position(NonZeroUsize::new(pos).unwrap()).decode(self)\n     }\n \n     pub(crate) fn list_crate_metadata(&self, out: &mut dyn io::Write) -> io::Result<()> {\n@@ -963,7 +867,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .tables\n                 .children\n                 .get(self, index)\n-                .unwrap_or_else(Lazy::empty)\n+                .unwrap_or_else(LazyArray::empty)\n                 .decode(self)\n                 .map(|index| ty::FieldDef {\n                     did: self.local_def_id(index),\n@@ -996,7 +900,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .tables\n                 .children\n                 .get(self, item_id)\n-                .unwrap_or_else(Lazy::empty)\n+                .unwrap_or_else(LazyArray::empty)\n                 .decode(self)\n                 .map(|index| self.get_variant(&self.kind(index), index, did))\n                 .collect()\n@@ -1016,7 +920,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_trait_item_def_id(self, id: DefIndex) -> Option<DefId> {\n-        self.root.tables.trait_item_def_id.get(self, id).map(|d| d.decode(self))\n+        self.root.tables.trait_item_def_id.get(self, id).map(|d| d.decode_from_cdata(self))\n     }\n \n     fn get_expn_that_defined(self, id: DefIndex, sess: &Session) -> ExpnId {\n@@ -1202,7 +1106,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .children\n             .get(self, id)\n-            .unwrap_or_else(Lazy::empty)\n+            .unwrap_or_else(LazyArray::empty)\n             .decode((self, sess))\n             .map(move |child_index| self.local_def_id(child_index))\n     }\n@@ -1278,7 +1182,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .children\n             .get(self, id)\n-            .unwrap_or_else(Lazy::empty)\n+            .unwrap_or_else(LazyArray::empty)\n             .decode(self)\n             .map(move |index| respan(self.get_span(index, sess), self.item_name(index)))\n     }\n@@ -1288,7 +1192,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .children\n             .get(self, id)\n-            .unwrap_or_else(Lazy::empty)\n+            .unwrap_or_else(LazyArray::empty)\n             .decode(self)\n             .map(move |field_index| self.get_visibility(field_index))\n     }\n@@ -1303,7 +1207,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .tables\n                 .inherent_impls\n                 .get(self, id)\n-                .unwrap_or_else(Lazy::empty)\n+                .unwrap_or_else(LazyArray::empty)\n                 .decode(self)\n                 .map(|index| self.local_def_id(index)),\n         )\n@@ -1318,7 +1222,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .tables\n                 .inherent_impls\n                 .get(self, ty_index)\n-                .unwrap_or_else(Lazy::empty)\n+                .unwrap_or_else(LazyArray::empty)\n                 .decode(self)\n                 .map(move |impl_index| (ty_def_id, self.local_def_id(impl_index)))\n         })"}, {"sha": "da2ac41af928488938a97c48cf63793b1b04f22d", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 72, "deletions": 11, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/ca5e60b7fb8867a59529e3120c305574a1e3e991/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca5e60b7fb8867a59529e3120c305574a1e3e991/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=ca5e60b7fb8867a59529e3120c305574a1e3e991", "patch": "@@ -1,14 +1,16 @@\n-use super::LazyQueryDecodable;\n use crate::creader::{CStore, LoadedMacro};\n use crate::foreign_modules;\n use crate::native_libs;\n \n use rustc_ast as ast;\n+use rustc_attr::Deprecation;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n+use rustc_middle::arena::ArenaAllocatable;\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::exported_symbols::ExportedSymbol;\n+use rustc_middle::middle::stability::DeprecationEntry;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::{ExternProviders, Providers};\n use rustc_middle::ty::{self, TyCtxt, Visibility};\n@@ -23,15 +25,74 @@ use rustc_data_structures::sync::Lrc;\n use smallvec::SmallVec;\n use std::any::Any;\n \n+use super::{Decodable, DecodeContext, DecodeIterator};\n+\n+trait ProcessQueryValue<'tcx, T> {\n+    fn process_decoded(self, _tcx: TyCtxt<'tcx>, _err: impl Fn() -> !) -> T;\n+}\n+\n+impl<T> ProcessQueryValue<'_, Option<T>> for Option<T> {\n+    fn process_decoded(self, _tcx: TyCtxt<'_>, _err: impl Fn() -> !) -> Option<T> {\n+        self\n+    }\n+}\n+\n+impl<T> ProcessQueryValue<'_, T> for Option<T> {\n+    fn process_decoded(self, _tcx: TyCtxt<'_>, err: impl Fn() -> !) -> T {\n+        if let Some(value) = self { value } else { err() }\n+    }\n+}\n+\n+impl<'tcx, T: ArenaAllocatable<'tcx>> ProcessQueryValue<'tcx, &'tcx T> for Option<T> {\n+    fn process_decoded(self, tcx: TyCtxt<'tcx>, err: impl Fn() -> !) -> &'tcx T {\n+        if let Some(value) = self { tcx.arena.alloc(value) } else { err() }\n+    }\n+}\n+\n+impl<T, E> ProcessQueryValue<'_, Result<Option<T>, E>> for Option<T> {\n+    fn process_decoded(self, _tcx: TyCtxt<'_>, _err: impl Fn() -> !) -> Result<Option<T>, E> {\n+        Ok(self)\n+    }\n+}\n+\n+impl<'a, 'tcx, T: Copy + Decodable<DecodeContext<'a, 'tcx>>> ProcessQueryValue<'tcx, &'tcx [T]>\n+    for Option<DecodeIterator<'a, 'tcx, T>>\n+{\n+    fn process_decoded(self, tcx: TyCtxt<'tcx>, _err: impl Fn() -> !) -> &'tcx [T] {\n+        if let Some(iter) = self { tcx.arena.alloc_from_iter(iter) } else { &[] }\n+    }\n+}\n+\n+impl ProcessQueryValue<'_, Option<DeprecationEntry>> for Option<Deprecation> {\n+    fn process_decoded(self, _tcx: TyCtxt<'_>, _err: impl Fn() -> !) -> Option<DeprecationEntry> {\n+        self.map(DeprecationEntry::external)\n+    }\n+}\n+\n macro_rules! provide_one {\n     (<$lt:tt> $tcx:ident, $def_id:ident, $other:ident, $cdata:ident, $name:ident => { table }) => {\n         provide_one! {\n             <$lt> $tcx, $def_id, $other, $cdata, $name => {\n-                $cdata.root.tables.$name.get($cdata, $def_id.index).decode_query(\n-                    $cdata,\n-                    $tcx,\n-                    || panic!(\"{:?} does not have a {:?}\", $def_id, stringify!($name)),\n-                )\n+                $cdata\n+                    .root\n+                    .tables\n+                    .$name\n+                    .get($cdata, $def_id.index)\n+                    .map(|lazy| lazy.decode(($cdata, $tcx)))\n+                    .process_decoded($tcx, || panic!(\"{:?} does not have a {:?}\", $def_id, stringify!($name)))\n+            }\n+        }\n+    };\n+    (<$lt:tt> $tcx:ident, $def_id:ident, $other:ident, $cdata:ident, $name:ident => { table_direct }) => {\n+        provide_one! {\n+            <$lt> $tcx, $def_id, $other, $cdata, $name => {\n+                // We don't decode `table_direct`, since it's not a Lazy, but an actual value\n+                $cdata\n+                    .root\n+                    .tables\n+                    .$name\n+                    .get($cdata, $def_id.index)\n+                    .process_decoded($tcx, || panic!(\"{:?} does not have a {:?}\", $def_id, stringify!($name)))\n             }\n         }\n     };\n@@ -143,15 +204,15 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     lookup_deprecation_entry => { table }\n     visibility => { table }\n     unused_generic_params => { table }\n-    opt_def_kind => { table }\n+    opt_def_kind => { table_direct }\n     impl_parent => { table }\n-    impl_polarity => { table }\n-    impl_defaultness => { table }\n-    impl_constness => { table }\n+    impl_polarity => { table_direct }\n+    impl_defaultness => { table_direct }\n+    impl_constness => { table_direct }\n     coerce_unsized_info => { table }\n     mir_const_qualif => { table }\n     rendered_const => { table }\n-    asyncness => { table }\n+    asyncness => { table_direct }\n     fn_arg_names => { table }\n     generator_kind => { table }\n     trait_def => { table }"}, {"sha": "598e011820e9f4483ca125850217057b0a10aac8", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 108, "deletions": 110, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/ca5e60b7fb8867a59529e3120c305574a1e3e991/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca5e60b7fb8867a59529e3120c305574a1e3e991/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=ca5e60b7fb8867a59529e3120c305574a1e3e991", "patch": "@@ -1,5 +1,5 @@\n use crate::rmeta::def_path_hash_map::DefPathHashMapRef;\n-use crate::rmeta::table::{FixedSizeEncoding, TableBuilder};\n+use crate::rmeta::table::TableBuilder;\n use crate::rmeta::*;\n \n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -17,7 +17,6 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::lang_items;\n use rustc_hir::{AnonConst, GenericParamKind};\n use rustc_index::bit_set::GrowableBitSet;\n-use rustc_index::vec::Idx;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::middle::exported_symbols::{\n@@ -38,6 +37,7 @@ use rustc_span::{\n     self, DebuggerVisualizerFile, ExternalSource, FileName, SourceFile, Span, SyntaxContext,\n };\n use rustc_target::abi::VariantIdx;\n+use std::borrow::Borrow;\n use std::hash::Hash;\n use std::num::NonZeroUsize;\n use tracing::{debug, trace};\n@@ -79,7 +79,7 @@ pub(super) struct EncodeContext<'a, 'tcx> {\n macro_rules! empty_proc_macro {\n     ($self:ident) => {\n         if $self.is_proc_macro {\n-            return Lazy::empty();\n+            return LazyArray::empty();\n         }\n     };\n }\n@@ -124,33 +124,26 @@ impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, T: Encodable<EncodeContext<'a, 'tcx>>> Encodable<EncodeContext<'a, 'tcx>>\n-    for Lazy<T>\n-{\n+impl<'a, 'tcx, T> Encodable<EncodeContext<'a, 'tcx>> for LazyValue<T> {\n     fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n-        e.emit_lazy_distance(*self)\n+        e.emit_lazy_distance(self.position)\n     }\n }\n \n-impl<'a, 'tcx, T: Encodable<EncodeContext<'a, 'tcx>>> Encodable<EncodeContext<'a, 'tcx>>\n-    for Lazy<[T]>\n-{\n+impl<'a, 'tcx, T> Encodable<EncodeContext<'a, 'tcx>> for LazyArray<T> {\n     fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n-        e.emit_usize(self.meta)?;\n-        if self.meta == 0 {\n+        e.emit_usize(self.len)?;\n+        if self.len == 0 {\n             return Ok(());\n         }\n-        e.emit_lazy_distance(*self)\n+        e.emit_lazy_distance(self.position)\n     }\n }\n \n-impl<'a, 'tcx, I: Idx, T> Encodable<EncodeContext<'a, 'tcx>> for Lazy<Table<I, T>>\n-where\n-    Option<T>: FixedSizeEncoding,\n-{\n+impl<'a, 'tcx, I, T> Encodable<EncodeContext<'a, 'tcx>> for LazyTable<I, T> {\n     fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n-        e.emit_usize(self.meta)?;\n-        e.emit_lazy_distance(*self)\n+        e.emit_usize(self.len)?;\n+        e.emit_lazy_distance(self.position)\n     }\n }\n \n@@ -345,34 +338,7 @@ impl<'a, 'tcx> TyEncoder<'tcx> for EncodeContext<'a, 'tcx> {\n     }\n }\n \n-/// Helper trait to allow overloading `EncodeContext::lazy` for iterators.\n-trait EncodeContentsForLazy<'a, 'tcx, T: ?Sized + LazyMeta> {\n-    fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'a, 'tcx>) -> T::Meta;\n-}\n-\n-impl<'a, 'tcx, T: Encodable<EncodeContext<'a, 'tcx>>> EncodeContentsForLazy<'a, 'tcx, T> for &T {\n-    fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'a, 'tcx>) {\n-        self.encode(ecx).unwrap()\n-    }\n-}\n-\n-impl<'a, 'tcx, T: Encodable<EncodeContext<'a, 'tcx>>> EncodeContentsForLazy<'a, 'tcx, T> for T {\n-    fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'a, 'tcx>) {\n-        self.encode(ecx).unwrap()\n-    }\n-}\n-\n-impl<'a, 'tcx, I, T: Encodable<EncodeContext<'a, 'tcx>>> EncodeContentsForLazy<'a, 'tcx, [T]> for I\n-where\n-    I: IntoIterator,\n-    I::Item: EncodeContentsForLazy<'a, 'tcx, T>,\n-{\n-    fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'a, 'tcx>) -> usize {\n-        self.into_iter().map(|value| value.encode_contents_for_lazy(ecx)).count()\n-    }\n-}\n-\n-// Shorthand for `$self.$tables.$table.set($def_id.index, $self.lazy($value))`, which would\n+// Shorthand for `$self.$tables.$table.set($def_id.index, $self.lazy_value($value))`, which would\n // normally need extra variables to avoid errors about multiple mutable borrows.\n macro_rules! record {\n     ($self:ident.$tables:ident.$table:ident[$def_id:expr] <- $value:expr) => {{\n@@ -384,12 +350,24 @@ macro_rules! record {\n     }};\n }\n \n+// Shorthand for `$self.$tables.$table.set($def_id.index, $self.lazy_value($value))`, which would\n+// normally need extra variables to avoid errors about multiple mutable borrows.\n+macro_rules! record_array {\n+    ($self:ident.$tables:ident.$table:ident[$def_id:expr] <- $value:expr) => {{\n+        {\n+            let value = $value;\n+            let lazy = $self.lazy_array(value);\n+            $self.$tables.$table.set($def_id.index, lazy);\n+        }\n+    }};\n+}\n+\n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    fn emit_lazy_distance<T: ?Sized + LazyMeta>(\n+    fn emit_lazy_distance(\n         &mut self,\n-        lazy: Lazy<T>,\n+        position: NonZeroUsize,\n     ) -> Result<(), <Self as Encoder>::Error> {\n-        let pos = lazy.position.get();\n+        let pos = position.get();\n         let distance = match self.lazy_state {\n             LazyState::NoNode => bug!(\"emit_lazy_distance: outside of a metadata node\"),\n             LazyState::NodeStart(start) => {\n@@ -399,31 +377,51 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             LazyState::Previous(last_pos) => {\n                 assert!(\n-                    last_pos <= lazy.position,\n+                    last_pos <= position,\n                     \"make sure that the calls to `lazy*` \\\n                      are in the same order as the metadata fields\",\n                 );\n-                lazy.position.get() - last_pos.get()\n+                position.get() - last_pos.get()\n             }\n         };\n         self.lazy_state = LazyState::Previous(NonZeroUsize::new(pos).unwrap());\n         self.emit_usize(distance)\n     }\n \n-    fn lazy<T: ?Sized + LazyMeta>(\n+    fn lazy<T: Encodable<EncodeContext<'a, 'tcx>>, B: Borrow<T>>(\n+        &mut self,\n+        value: B,\n+    ) -> LazyValue<T> {\n+        let pos = NonZeroUsize::new(self.position()).unwrap();\n+\n+        assert_eq!(self.lazy_state, LazyState::NoNode);\n+        self.lazy_state = LazyState::NodeStart(pos);\n+        value.borrow().encode(self).unwrap();\n+        self.lazy_state = LazyState::NoNode;\n+\n+        assert!(pos.get() <= self.position());\n+\n+        LazyValue::from_position(pos)\n+    }\n+\n+    fn lazy_array<\n+        T: Encodable<EncodeContext<'a, 'tcx>>,\n+        I: IntoIterator<Item = B>,\n+        B: Borrow<T>,\n+    >(\n         &mut self,\n-        value: impl EncodeContentsForLazy<'a, 'tcx, T>,\n-    ) -> Lazy<T> {\n+        values: I,\n+    ) -> LazyArray<T> {\n         let pos = NonZeroUsize::new(self.position()).unwrap();\n \n         assert_eq!(self.lazy_state, LazyState::NoNode);\n         self.lazy_state = LazyState::NodeStart(pos);\n-        let meta = value.encode_contents_for_lazy(self);\n+        let len = values.into_iter().map(|value| value.borrow().encode(self).unwrap()).count();\n         self.lazy_state = LazyState::NoNode;\n \n         assert!(pos.get() <= self.position());\n \n-        Lazy::from_position_and_meta(pos, meta)\n+        LazyArray::from_position_and_len(pos, len)\n     }\n \n     fn encode_info_for_items(&mut self) {\n@@ -458,13 +456,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_def_path_hash_map(&mut self) -> Lazy<DefPathHashMapRef<'tcx>> {\n+    fn encode_def_path_hash_map(&mut self) -> LazyValue<DefPathHashMapRef<'tcx>> {\n         self.lazy(DefPathHashMapRef::BorrowedFromTcx(\n             self.tcx.resolutions(()).definitions.def_path_hash_to_def_index_map(),\n         ))\n     }\n \n-    fn encode_source_map(&mut self) -> Lazy<[rustc_span::SourceFile]> {\n+    fn encode_source_map(&mut self) -> LazyArray<rustc_span::SourceFile> {\n         let source_map = self.tcx.sess.source_map();\n         let all_source_files = source_map.files();\n \n@@ -534,10 +532,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             })\n             .collect::<Vec<_>>();\n \n-        self.lazy(adapted.iter().map(|rc| &**rc))\n+        self.lazy_array(adapted.iter().map(|rc| &**rc))\n     }\n \n-    fn encode_crate_root(&mut self) -> Lazy<CrateRoot<'tcx>> {\n+    fn encode_crate_root(&mut self) -> LazyValue<CrateRoot<'tcx>> {\n         let tcx = self.tcx;\n         let mut i = self.position();\n \n@@ -619,7 +617,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 }\n                 n = new_n;\n             }\n-            self.lazy(interpret_alloc_index)\n+            self.lazy_array(interpret_alloc_index)\n         };\n \n         // Encode the proc macro data. This affects 'tables',\n@@ -951,7 +949,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             .iter()\n             .filter(|attr| !rustc_feature::is_builtin_only_local(attr.name_or_empty()));\n \n-        record!(self.tables.attributes[def_id.to_def_id()] <- attrs.clone());\n+        record_array!(self.tables.attributes[def_id.to_def_id()] <- attrs.clone());\n         if attrs.any(|attr| attr.may_have_doc_links()) {\n             self.tables.may_have_doc_links.set(def_id.local_def_index, ());\n         }\n@@ -984,15 +982,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             if should_encode_variances(def_kind) {\n                 let v = self.tcx.variances_of(def_id);\n-                record!(self.tables.variances_of[def_id] <- v);\n+                record_array!(self.tables.variances_of[def_id] <- v);\n             }\n             if should_encode_generics(def_kind) {\n                 let g = tcx.generics_of(def_id);\n                 record!(self.tables.generics_of[def_id] <- g);\n                 record!(self.tables.explicit_predicates_of[def_id] <- self.tcx.explicit_predicates_of(def_id));\n                 let inferred_outlives = self.tcx.inferred_outlives_of(def_id);\n                 if !inferred_outlives.is_empty() {\n-                    record!(self.tables.inferred_outlives_of[def_id] <- inferred_outlives);\n+                    record_array!(self.tables.inferred_outlives_of[def_id] <- inferred_outlives);\n                 }\n             }\n             if let DefKind::Trait | DefKind::TraitAlias = def_kind {\n@@ -1004,7 +1002,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             if implementations.is_empty() {\n                 continue;\n             }\n-            record!(self.tables.inherent_impls[def_id.to_def_id()] <- implementations.iter().map(|&def_id| {\n+            record_array!(self.tables.inherent_impls[def_id.to_def_id()] <- implementations.iter().map(|&def_id| {\n                 assert!(def_id.is_local());\n                 def_id.index\n             }));\n@@ -1031,7 +1029,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n         self.tables.impl_constness.set(def_id.index, hir::Constness::Const);\n-        record!(self.tables.children[def_id] <- variant.fields.iter().map(|f| {\n+        record_array!(self.tables.children[def_id] <- variant.fields.iter().map(|f| {\n             assert!(f.did.is_local());\n             f.did.index\n         }));\n@@ -1079,19 +1077,19 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // items - we encode information about proc-macros later on.\n         let reexports = if !self.is_proc_macro {\n             match tcx.module_reexports(local_def_id) {\n-                Some(exports) => self.lazy(exports),\n-                _ => Lazy::empty(),\n+                Some(exports) => self.lazy_array(exports),\n+                _ => LazyArray::empty(),\n             }\n         } else {\n-            Lazy::empty()\n+            LazyArray::empty()\n         };\n \n         record!(self.tables.kind[def_id] <- EntryKind::Mod(reexports));\n         if self.is_proc_macro {\n             // Encode this here because we don't do it in encode_def_ids.\n             record!(self.tables.expn_that_defined[def_id] <- tcx.expn_that_defined(local_def_id));\n         } else {\n-            record!(self.tables.children[def_id] <- iter_from_generator(|| {\n+            record_array!(self.tables.children[def_id] <- iter_from_generator(|| {\n                 for item_id in md.item_ids {\n                     match tcx.hir().item(*item_id).kind {\n                         // Foreign items are planted into their parent modules\n@@ -1156,7 +1154,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         debug!(\"EncodeContext::encode_explicit_item_bounds({:?})\", def_id);\n         let bounds = self.tcx.explicit_item_bounds(def_id);\n         if !bounds.is_empty() {\n-            record!(self.tables.explicit_item_bounds[def_id] <- bounds);\n+            record_array!(self.tables.explicit_item_bounds[def_id] <- bounds);\n         }\n     }\n \n@@ -1188,10 +1186,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let hir::TraitItemKind::Fn(m_sig, m) = &ast_item.kind else { bug!() };\n                 match *m {\n                     hir::TraitFn::Required(ref names) => {\n-                        record!(self.tables.fn_arg_names[def_id] <- *names)\n+                        record_array!(self.tables.fn_arg_names[def_id] <- *names)\n                     }\n                     hir::TraitFn::Provided(body) => {\n-                        record!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body))\n+                        record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body))\n                     }\n                 };\n                 self.tables.asyncness.set(def_id.index, m_sig.header.asyncness);\n@@ -1253,7 +1251,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             ty::AssocKind::Fn => {\n                 let hir::ImplItemKind::Fn(ref sig, body) = ast_item.kind else { bug!() };\n                 self.tables.asyncness.set(def_id.index, sig.header.asyncness);\n-                record!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n+                record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n                 // Can be inside `impl const Trait`, so using sig.header.constness is not reliable\n                 let constness = if self.tcx.is_const_fn_raw(def_id) {\n                     hir::Constness::Const\n@@ -1385,7 +1383,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             hir::ItemKind::Fn(ref sig, .., body) => {\n                 self.tables.asyncness.set(def_id.index, sig.header.asyncness);\n-                record!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n+                record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n                 self.tables.impl_constness.set(def_id.index, sig.header.constness);\n                 EntryKind::Fn\n             }\n@@ -1485,14 +1483,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         record!(self.tables.kind[def_id] <- entry_kind);\n         // FIXME(eddyb) there should be a nicer way to do this.\n         match item.kind {\n-            hir::ItemKind::Enum(..) => record!(self.tables.children[def_id] <-\n+            hir::ItemKind::Enum(..) => record_array!(self.tables.children[def_id] <-\n                 self.tcx.adt_def(def_id).variants().iter().map(|v| {\n                     assert!(v.def_id.is_local());\n                     v.def_id.index\n                 })\n             ),\n             hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n-                record!(self.tables.children[def_id] <-\n+                record_array!(self.tables.children[def_id] <-\n                     self.tcx.adt_def(def_id).non_enum_variant().fields.iter().map(|f| {\n                         assert!(f.did.is_local());\n                         f.did.index\n@@ -1501,7 +1499,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             hir::ItemKind::Impl { .. } | hir::ItemKind::Trait(..) => {\n                 let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n-                record!(self.tables.children[def_id] <-\n+                record_array!(self.tables.children[def_id] <-\n                     associated_item_def_ids.iter().map(|&def_id| {\n                         assert!(def_id.is_local());\n                         def_id.index\n@@ -1583,16 +1581,16 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.encode_item_type(def_id.to_def_id());\n     }\n \n-    fn encode_native_libraries(&mut self) -> Lazy<[NativeLib]> {\n+    fn encode_native_libraries(&mut self) -> LazyArray<NativeLib> {\n         empty_proc_macro!(self);\n         let used_libraries = self.tcx.native_libraries(LOCAL_CRATE);\n-        self.lazy(used_libraries.iter())\n+        self.lazy_array(used_libraries.iter())\n     }\n \n-    fn encode_foreign_modules(&mut self) -> Lazy<[ForeignModule]> {\n+    fn encode_foreign_modules(&mut self) -> LazyArray<ForeignModule> {\n         empty_proc_macro!(self);\n         let foreign_modules = self.tcx.foreign_modules(LOCAL_CRATE);\n-        self.lazy(foreign_modules.iter().map(|(_, m)| m).cloned())\n+        self.lazy_array(foreign_modules.iter().map(|(_, m)| m).cloned())\n     }\n \n     fn encode_hygiene(&mut self) -> (SyntaxContextTable, ExpnDataTable, ExpnHashTable) {\n@@ -1631,7 +1629,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let proc_macro_decls_static = tcx.proc_macro_decls_static(()).unwrap().local_def_index;\n             let stability = tcx.lookup_stability(CRATE_DEF_ID);\n             let macros =\n-                self.lazy(tcx.resolutions(()).proc_macros.iter().map(|p| p.local_def_index));\n+                self.lazy_array(tcx.resolutions(()).proc_macros.iter().map(|p| p.local_def_index));\n             let spans = self.tcx.sess.parse_sess.proc_macro_quoted_spans();\n             for (i, span) in spans.into_iter().enumerate() {\n                 let span = self.lazy(span);\n@@ -1697,12 +1695,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_debugger_visualizers(&mut self) -> Lazy<[DebuggerVisualizerFile]> {\n+    fn encode_debugger_visualizers(&mut self) -> LazyArray<DebuggerVisualizerFile> {\n         empty_proc_macro!(self);\n-        self.lazy(self.tcx.debugger_visualizers(LOCAL_CRATE).iter())\n+        self.lazy_array(self.tcx.debugger_visualizers(LOCAL_CRATE).iter())\n     }\n \n-    fn encode_crate_deps(&mut self) -> Lazy<[CrateDep]> {\n+    fn encode_crate_deps(&mut self) -> LazyArray<CrateDep> {\n         empty_proc_macro!(self);\n \n         let deps = self\n@@ -1734,29 +1732,29 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // the assumption that they are numbered 1 to n.\n         // FIXME (#2166): This is not nearly enough to support correct versioning\n         // but is enough to get transitive crate dependencies working.\n-        self.lazy(deps.iter().map(|&(_, ref dep)| dep))\n+        self.lazy_array(deps.iter().map(|&(_, ref dep)| dep))\n     }\n \n-    fn encode_lib_features(&mut self) -> Lazy<[(Symbol, Option<Symbol>)]> {\n+    fn encode_lib_features(&mut self) -> LazyArray<(Symbol, Option<Symbol>)> {\n         empty_proc_macro!(self);\n         let tcx = self.tcx;\n         let lib_features = tcx.lib_features(());\n-        self.lazy(lib_features.to_vec())\n+        self.lazy_array(lib_features.to_vec())\n     }\n \n-    fn encode_diagnostic_items(&mut self) -> Lazy<[(Symbol, DefIndex)]> {\n+    fn encode_diagnostic_items(&mut self) -> LazyArray<(Symbol, DefIndex)> {\n         empty_proc_macro!(self);\n         let tcx = self.tcx;\n         let diagnostic_items = &tcx.diagnostic_items(LOCAL_CRATE).name_to_id;\n-        self.lazy(diagnostic_items.iter().map(|(&name, def_id)| (name, def_id.index)))\n+        self.lazy_array(diagnostic_items.iter().map(|(&name, def_id)| (name, def_id.index)))\n     }\n \n-    fn encode_lang_items(&mut self) -> Lazy<[(DefIndex, usize)]> {\n+    fn encode_lang_items(&mut self) -> LazyArray<(DefIndex, usize)> {\n         empty_proc_macro!(self);\n         let tcx = self.tcx;\n         let lang_items = tcx.lang_items();\n         let lang_items = lang_items.items().iter();\n-        self.lazy(lang_items.enumerate().filter_map(|(i, &opt_def_id)| {\n+        self.lazy_array(lang_items.enumerate().filter_map(|(i, &opt_def_id)| {\n             if let Some(def_id) = opt_def_id {\n                 if def_id.is_local() {\n                     return Some((def_id.index, i));\n@@ -1766,19 +1764,19 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }))\n     }\n \n-    fn encode_lang_items_missing(&mut self) -> Lazy<[lang_items::LangItem]> {\n+    fn encode_lang_items_missing(&mut self) -> LazyArray<lang_items::LangItem> {\n         empty_proc_macro!(self);\n         let tcx = self.tcx;\n-        self.lazy(&tcx.lang_items().missing)\n+        self.lazy_array(&tcx.lang_items().missing)\n     }\n \n-    fn encode_traits(&mut self) -> Lazy<[DefIndex]> {\n+    fn encode_traits(&mut self) -> LazyArray<DefIndex> {\n         empty_proc_macro!(self);\n-        self.lazy(self.tcx.traits_in_crate(LOCAL_CRATE).iter().map(|def_id| def_id.index))\n+        self.lazy_array(self.tcx.traits_in_crate(LOCAL_CRATE).iter().map(|def_id| def_id.index))\n     }\n \n     /// Encodes an index, mapping each trait to its (local) implementations.\n-    fn encode_impls(&mut self) -> Lazy<[TraitImpls]> {\n+    fn encode_impls(&mut self) -> LazyArray<TraitImpls> {\n         debug!(\"EncodeContext::encode_traits_and_impls()\");\n         empty_proc_macro!(self);\n         let tcx = self.tcx;\n@@ -1817,15 +1815,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n                 TraitImpls {\n                     trait_id: (trait_def_id.krate.as_u32(), trait_def_id.index),\n-                    impls: self.lazy(&impls),\n+                    impls: self.lazy_array(&impls),\n                 }\n             })\n             .collect();\n \n-        self.lazy(&all_impls)\n+        self.lazy_array(&all_impls)\n     }\n \n-    fn encode_incoherent_impls(&mut self) -> Lazy<[IncoherentImpls]> {\n+    fn encode_incoherent_impls(&mut self) -> LazyArray<IncoherentImpls> {\n         debug!(\"EncodeContext::encode_traits_and_impls()\");\n         empty_proc_macro!(self);\n         let tcx = self.tcx;\n@@ -1845,11 +1843,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     tcx.hir().def_path_hash(LocalDefId { local_def_index })\n                 });\n \n-                IncoherentImpls { self_ty: simp, impls: self.lazy(impls) }\n+                IncoherentImpls { self_ty: simp, impls: self.lazy_array(impls) }\n             })\n             .collect();\n \n-        self.lazy(&all_impls)\n+        self.lazy_array(&all_impls)\n     }\n \n     // Encodes all symbols exported from this crate into the metadata.\n@@ -1861,13 +1859,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_exported_symbols(\n         &mut self,\n         exported_symbols: &[(ExportedSymbol<'tcx>, SymbolExportInfo)],\n-    ) -> Lazy<[(ExportedSymbol<'tcx>, SymbolExportInfo)]> {\n+    ) -> LazyArray<(ExportedSymbol<'tcx>, SymbolExportInfo)> {\n         empty_proc_macro!(self);\n         // The metadata symbol name is special. It should not show up in\n         // downstream crates.\n         let metadata_symbol_name = SymbolName::new(self.tcx, &metadata_symbol_name(self.tcx));\n \n-        self.lazy(\n+        self.lazy_array(\n             exported_symbols\n                 .iter()\n                 .filter(|&&(ref exported_symbol, _)| match *exported_symbol {\n@@ -1878,21 +1876,21 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         )\n     }\n \n-    fn encode_dylib_dependency_formats(&mut self) -> Lazy<[Option<LinkagePreference>]> {\n+    fn encode_dylib_dependency_formats(&mut self) -> LazyArray<Option<LinkagePreference>> {\n         empty_proc_macro!(self);\n         let formats = self.tcx.dependency_formats(());\n         for (ty, arr) in formats.iter() {\n             if *ty != CrateType::Dylib {\n                 continue;\n             }\n-            return self.lazy(arr.iter().map(|slot| match *slot {\n+            return self.lazy_array(arr.iter().map(|slot| match *slot {\n                 Linkage::NotLinked | Linkage::IncludedFromDylib => None,\n \n                 Linkage::Dynamic => Some(LinkagePreference::RequireDynamic),\n                 Linkage::Static => Some(LinkagePreference::RequireStatic),\n             }));\n         }\n-        Lazy::empty()\n+        LazyArray::empty()\n     }\n \n     fn encode_info_for_foreign_item(&mut self, def_id: DefId, nitem: &hir::ForeignItem<'_>) {\n@@ -1903,7 +1901,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         match nitem.kind {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n                 self.tables.asyncness.set(def_id.index, hir::IsAsync::NotAsync);\n-                record!(self.tables.fn_arg_names[def_id] <- *names);\n+                record_array!(self.tables.fn_arg_names[def_id] <- *names);\n                 let constness = if self.tcx.is_const_fn_raw(def_id) {\n                     hir::Constness::Const\n                 } else {"}, {"sha": "8e3985e59acf48fa2e01a97323e3279bd64c3dff", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 123, "deletions": 112, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/ca5e60b7fb8867a59529e3120c305574a1e3e991/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca5e60b7fb8867a59529e3120c305574a1e3e991/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=ca5e60b7fb8867a59529e3120c305574a1e3e991", "patch": "@@ -1,7 +1,7 @@\n use crate::creader::CrateMetadataRef;\n use decoder::Metadata;\n use def_path_hash_map::DefPathHashMapRef;\n-use table::{Table, TableBuilder};\n+use table::TableBuilder;\n \n use rustc_ast as ast;\n use rustc_attr as attr;\n@@ -20,8 +20,8 @@ use rustc_middle::mir;\n use rustc_middle::thir;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::GeneratorDiagnosticData;\n use rustc_middle::ty::{self, ReprOptions, Ty};\n+use rustc_middle::ty::{GeneratorDiagnosticData, TyCtxt};\n use rustc_serialize::opaque::Encoder;\n use rustc_session::config::SymbolManglingVersion;\n use rustc_session::cstore::{CrateDepKind, ForeignModule, LinkagePreference, NativeLib};\n@@ -62,20 +62,6 @@ const METADATA_VERSION: u8 = 6;\n /// and further followed by the rustc version string.\n pub const METADATA_HEADER: &[u8] = &[b'r', b'u', b's', b't', 0, 0, 0, METADATA_VERSION];\n \n-/// Additional metadata for a `Lazy<T>` where `T` may not be `Sized`,\n-/// e.g. for `Lazy<[T]>`, this is the length (count of `T` values).\n-trait LazyMeta {\n-    type Meta: Copy + 'static;\n-}\n-\n-impl<T> LazyMeta for T {\n-    type Meta = ();\n-}\n-\n-impl<T> LazyMeta for [T] {\n-    type Meta = usize;\n-}\n-\n /// A value of type T referred to by its absolute position\n /// in the metadata, and which can be decoded lazily.\n ///\n@@ -92,7 +78,7 @@ impl<T> LazyMeta for [T] {\n /// Also invalid are nodes being referred in a different\n /// order than they were encoded in.\n ///\n-/// # Sequences (`Lazy<[T]>`)\n+/// # Sequences (`LazyArray<T>`)\n ///\n /// Unlike `Lazy<Vec<T>>`, the length is encoded next to the\n /// position, not at the position, which means that the length\n@@ -105,36 +91,64 @@ impl<T> LazyMeta for [T] {\n #[must_use]\n // FIXME(#59875) the `Meta` parameter only exists to dodge\n // invariance wrt `T` (coming from the `meta: T::Meta` field).\n-struct Lazy<T, Meta = <T as LazyMeta>::Meta>\n-where\n-    T: ?Sized + LazyMeta<Meta = Meta>,\n-    Meta: 'static + Copy,\n-{\n+struct LazyValue<T> {\n+    position: NonZeroUsize,\n+    _marker: PhantomData<fn() -> T>,\n+}\n+\n+impl<T> LazyValue<T> {\n+    fn from_position(position: NonZeroUsize) -> LazyValue<T> {\n+        LazyValue { position, _marker: PhantomData }\n+    }\n+}\n+\n+struct LazyArray<T> {\n+    position: NonZeroUsize,\n+    len: usize,\n+    _marker: PhantomData<fn() -> T>,\n+}\n+\n+impl<T> LazyArray<T> {\n+    fn from_position_and_len(position: NonZeroUsize, len: usize) -> LazyArray<T> {\n+        LazyArray { position, len, _marker: PhantomData }\n+    }\n+\n+    fn empty() -> LazyArray<T> {\n+        LazyArray::from_position_and_len(NonZeroUsize::new(1).unwrap(), 0)\n+    }\n+}\n+\n+/// Random-access table (i.e. offering constant-time `get`/`set`), similar to\n+/// `LazyArray<T>`, but without requiring encoding or decoding all the values\n+/// eagerly and in-order.\n+struct LazyTable<I, T> {\n     position: NonZeroUsize,\n-    meta: Meta,\n-    _marker: PhantomData<T>,\n+    len: usize,\n+    _marker: PhantomData<fn(I) -> T>,\n }\n \n-impl<T: ?Sized + LazyMeta> Lazy<T> {\n-    fn from_position_and_meta(position: NonZeroUsize, meta: T::Meta) -> Lazy<T> {\n-        Lazy { position, meta, _marker: PhantomData }\n+impl<I, T> LazyTable<I, T> {\n+    fn from_position_and_len(position: NonZeroUsize, len: usize) -> LazyTable<I, T> {\n+        LazyTable { position, len, _marker: PhantomData }\n     }\n }\n \n-impl<T> Lazy<T> {\n-    fn from_position(position: NonZeroUsize) -> Lazy<T> {\n-        Lazy::from_position_and_meta(position, ())\n+impl<T> Copy for LazyValue<T> {}\n+impl<T> Clone for LazyValue<T> {\n+    fn clone(&self) -> Self {\n+        *self\n     }\n }\n \n-impl<T> Lazy<[T]> {\n-    fn empty() -> Lazy<[T]> {\n-        Lazy::from_position_and_meta(NonZeroUsize::new(1).unwrap(), 0)\n+impl<T> Copy for LazyArray<T> {}\n+impl<T> Clone for LazyArray<T> {\n+    fn clone(&self) -> Self {\n+        *self\n     }\n }\n \n-impl<T: ?Sized + LazyMeta> Copy for Lazy<T> {}\n-impl<T: ?Sized + LazyMeta> Clone for Lazy<T> {\n+impl<I, T> Copy for LazyTable<I, T> {}\n+impl<I, T> Clone for LazyTable<I, T> {\n     fn clone(&self) -> Self {\n         *self\n     }\n@@ -155,29 +169,20 @@ enum LazyState {\n     Previous(NonZeroUsize),\n }\n \n-// FIXME(#59875) `Lazy!(T)` replaces `Lazy<T>`, passing the `Meta` parameter\n-// manually, instead of relying on the default, to get the correct variance.\n-// Only needed when `T` itself contains a parameter (e.g. `'tcx`).\n-macro_rules! Lazy {\n-    (Table<$I:ty, $T:ty>) => {Lazy<Table<$I, $T>, usize>};\n-    ([$T:ty]) => {Lazy<[$T], usize>};\n-    ($T:ty) => {Lazy<$T, ()>};\n-}\n-\n-type SyntaxContextTable = Lazy<Table<u32, Lazy<SyntaxContextData>>>;\n-type ExpnDataTable = Lazy<Table<ExpnIndex, Lazy<ExpnData>>>;\n-type ExpnHashTable = Lazy<Table<ExpnIndex, Lazy<ExpnHash>>>;\n+type SyntaxContextTable = LazyTable<u32, LazyValue<SyntaxContextData>>;\n+type ExpnDataTable = LazyTable<ExpnIndex, LazyValue<ExpnData>>;\n+type ExpnHashTable = LazyTable<ExpnIndex, LazyValue<ExpnHash>>;\n \n #[derive(MetadataEncodable, MetadataDecodable)]\n pub(crate) struct ProcMacroData {\n     proc_macro_decls_static: DefIndex,\n     stability: Option<attr::Stability>,\n-    macros: Lazy<[DefIndex]>,\n+    macros: LazyArray<DefIndex>,\n }\n \n /// Serialized metadata for a crate.\n /// When compiling a proc-macro crate, we encode many of\n-/// the `Lazy<[T]>` fields as `Lazy::empty()`. This serves two purposes:\n+/// the `LazyArray<T>` fields as `Lazy::empty()`. This serves two purposes:\n ///\n /// 1. We avoid performing unnecessary work. Proc-macro crates can only\n /// export proc-macros functions, which are compiled into a shared library.\n@@ -205,32 +210,32 @@ pub(crate) struct CrateRoot<'tcx> {\n     has_panic_handler: bool,\n     has_default_lib_allocator: bool,\n \n-    crate_deps: Lazy<[CrateDep]>,\n-    dylib_dependency_formats: Lazy<[Option<LinkagePreference>]>,\n-    lib_features: Lazy<[(Symbol, Option<Symbol>)]>,\n-    lang_items: Lazy<[(DefIndex, usize)]>,\n-    lang_items_missing: Lazy<[lang_items::LangItem]>,\n-    diagnostic_items: Lazy<[(Symbol, DefIndex)]>,\n-    native_libraries: Lazy<[NativeLib]>,\n-    foreign_modules: Lazy<[ForeignModule]>,\n-    traits: Lazy<[DefIndex]>,\n-    impls: Lazy<[TraitImpls]>,\n-    incoherent_impls: Lazy<[IncoherentImpls]>,\n-    interpret_alloc_index: Lazy<[u32]>,\n+    crate_deps: LazyArray<CrateDep>,\n+    dylib_dependency_formats: LazyArray<Option<LinkagePreference>>,\n+    lib_features: LazyArray<(Symbol, Option<Symbol>)>,\n+    lang_items: LazyArray<(DefIndex, usize)>,\n+    lang_items_missing: LazyArray<lang_items::LangItem>,\n+    diagnostic_items: LazyArray<(Symbol, DefIndex)>,\n+    native_libraries: LazyArray<NativeLib>,\n+    foreign_modules: LazyArray<ForeignModule>,\n+    traits: LazyArray<DefIndex>,\n+    impls: LazyArray<TraitImpls>,\n+    incoherent_impls: LazyArray<IncoherentImpls>,\n+    interpret_alloc_index: LazyArray<u32>,\n     proc_macro_data: Option<ProcMacroData>,\n \n     tables: LazyTables<'tcx>,\n-    debugger_visualizers: Lazy<[rustc_span::DebuggerVisualizerFile]>,\n+    debugger_visualizers: LazyArray<rustc_span::DebuggerVisualizerFile>,\n \n-    exported_symbols: Lazy!([(ExportedSymbol<'tcx>, SymbolExportInfo)]),\n+    exported_symbols: LazyArray<(ExportedSymbol<'tcx>, SymbolExportInfo)>,\n \n     syntax_contexts: SyntaxContextTable,\n     expn_data: ExpnDataTable,\n     expn_hashes: ExpnHashTable,\n \n-    def_path_hash_map: Lazy<DefPathHashMapRef<'tcx>>,\n+    def_path_hash_map: LazyValue<DefPathHashMapRef<'tcx>>,\n \n-    source_map: Lazy<[rustc_span::SourceFile]>,\n+    source_map: LazyArray<rustc_span::SourceFile>,\n \n     compiler_builtins: bool,\n     needs_allocator: bool,\n@@ -257,7 +262,12 @@ impl Into<RawDefId> for DefId {\n }\n \n impl RawDefId {\n-    fn decode(self, cdata: CrateMetadataRef<'_>) -> DefId {\n+    /// This exists so that `provide_one!` is happy\n+    fn decode(self, meta: (CrateMetadataRef<'_>, TyCtxt<'_>)) -> DefId {\n+        self.decode_from_cdata(meta.0)\n+    }\n+\n+    fn decode_from_cdata(self, cdata: CrateMetadataRef<'_>) -> DefId {\n         let krate = CrateNum::from_u32(self.krate);\n         let krate = cdata.map_encoded_cnum_to_current(krate);\n         DefId { krate, index: DefIndex::from_u32(self.index) }\n@@ -276,21 +286,21 @@ pub(crate) struct CrateDep {\n #[derive(MetadataEncodable, MetadataDecodable)]\n pub(crate) struct TraitImpls {\n     trait_id: (u32, DefIndex),\n-    impls: Lazy<[(DefIndex, Option<SimplifiedType>)]>,\n+    impls: LazyArray<(DefIndex, Option<SimplifiedType>)>,\n }\n \n #[derive(MetadataEncodable, MetadataDecodable)]\n pub(crate) struct IncoherentImpls {\n     self_ty: SimplifiedType,\n-    impls: Lazy<[DefIndex]>,\n+    impls: LazyArray<DefIndex>,\n }\n \n /// Define `LazyTables` and `TableBuilders` at the same time.\n macro_rules! define_tables {\n     ($($name:ident: Table<$IDX:ty, $T:ty>),+ $(,)?) => {\n         #[derive(MetadataEncodable, MetadataDecodable)]\n         pub(crate) struct LazyTables<'tcx> {\n-            $($name: Lazy!(Table<$IDX, $T>)),+\n+            $($name: LazyTable<$IDX, $T>),+\n         }\n \n         #[derive(Default)]\n@@ -309,61 +319,62 @@ macro_rules! define_tables {\n }\n \n define_tables! {\n-    kind: Table<DefIndex, Lazy<EntryKind>>,\n-    attributes: Table<DefIndex, Lazy<[ast::Attribute]>>,\n-    children: Table<DefIndex, Lazy<[DefIndex]>>,\n+    kind: Table<DefIndex, LazyValue<EntryKind>>,\n+    attributes: Table<DefIndex, LazyArray<ast::Attribute>>,\n+    children: Table<DefIndex, LazyArray<DefIndex>>,\n \n     opt_def_kind: Table<DefIndex, DefKind>,\n-    visibility: Table<DefIndex, Lazy<ty::Visibility>>,\n-    def_span: Table<DefIndex, Lazy<Span>>,\n-    def_ident_span: Table<DefIndex, Lazy<Span>>,\n-    lookup_stability: Table<DefIndex, Lazy<attr::Stability>>,\n-    lookup_const_stability: Table<DefIndex, Lazy<attr::ConstStability>>,\n-    lookup_deprecation_entry: Table<DefIndex, Lazy<attr::Deprecation>>,\n+    visibility: Table<DefIndex, LazyValue<ty::Visibility>>,\n+    def_span: Table<DefIndex, LazyValue<Span>>,\n+    def_ident_span: Table<DefIndex, LazyValue<Span>>,\n+    lookup_stability: Table<DefIndex, LazyValue<attr::Stability>>,\n+    lookup_const_stability: Table<DefIndex, LazyValue<attr::ConstStability>>,\n+    lookup_deprecation_entry: Table<DefIndex, LazyValue<attr::Deprecation>>,\n     // As an optimization, a missing entry indicates an empty `&[]`.\n-    explicit_item_bounds: Table<DefIndex, Lazy!([(ty::Predicate<'tcx>, Span)])>,\n-    explicit_predicates_of: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n-    generics_of: Table<DefIndex, Lazy<ty::Generics>>,\n+    explicit_item_bounds: Table<DefIndex, LazyArray<(ty::Predicate<'tcx>, Span)>>,\n+    explicit_predicates_of: Table<DefIndex, LazyValue<ty::GenericPredicates<'tcx>>>,\n+    generics_of: Table<DefIndex, LazyValue<ty::Generics>>,\n     // As an optimization, a missing entry indicates an empty `&[]`.\n-    inferred_outlives_of: Table<DefIndex, Lazy!([(ty::Predicate<'tcx>, Span)])>,\n-    super_predicates_of: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n-    type_of: Table<DefIndex, Lazy!(Ty<'tcx>)>,\n-    variances_of: Table<DefIndex, Lazy<[ty::Variance]>>,\n-    fn_sig: Table<DefIndex, Lazy!(ty::PolyFnSig<'tcx>)>,\n-    codegen_fn_attrs: Table<DefIndex, Lazy!(CodegenFnAttrs)>,\n-    impl_trait_ref: Table<DefIndex, Lazy!(ty::TraitRef<'tcx>)>,\n-    const_param_default: Table<DefIndex, Lazy<rustc_middle::ty::Const<'tcx>>>,\n-    optimized_mir: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n-    mir_for_ctfe: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n-    promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n-    thir_abstract_const: Table<DefIndex, Lazy!(&'tcx [thir::abstract_const::Node<'tcx>])>,\n+    inferred_outlives_of: Table<DefIndex, LazyArray<(ty::Predicate<'tcx>, Span)>>,\n+    super_predicates_of: Table<DefIndex, LazyValue<ty::GenericPredicates<'tcx>>>,\n+    type_of: Table<DefIndex, LazyValue<Ty<'tcx>>>,\n+    variances_of: Table<DefIndex, LazyArray<ty::Variance>>,\n+    fn_sig: Table<DefIndex, LazyValue<ty::PolyFnSig<'tcx>>>,\n+    codegen_fn_attrs: Table<DefIndex, LazyValue<CodegenFnAttrs>>,\n+    impl_trait_ref: Table<DefIndex, LazyValue<ty::TraitRef<'tcx>>>,\n+    const_param_default: Table<DefIndex, LazyValue<rustc_middle::ty::Const<'tcx>>>,\n+    optimized_mir: Table<DefIndex, LazyValue<mir::Body<'tcx>>>,\n+    mir_for_ctfe: Table<DefIndex, LazyValue<mir::Body<'tcx>>>,\n+    promoted_mir: Table<DefIndex, LazyValue<IndexVec<mir::Promoted, mir::Body<'tcx>>>>,\n+    // FIXME(compiler-errors): Why isn't this a LazyArray?\n+    thir_abstract_const: Table<DefIndex, LazyValue<&'tcx [thir::abstract_const::Node<'tcx>]>>,\n     impl_parent: Table<DefIndex, RawDefId>,\n     impl_polarity: Table<DefIndex, ty::ImplPolarity>,\n     impl_constness: Table<DefIndex, hir::Constness>,\n     is_intrinsic: Table<DefIndex, ()>,\n     impl_defaultness: Table<DefIndex, hir::Defaultness>,\n     // FIXME(eddyb) perhaps compute this on the fly if cheap enough?\n-    coerce_unsized_info: Table<DefIndex, Lazy!(ty::adjustment::CoerceUnsizedInfo)>,\n-    mir_const_qualif: Table<DefIndex, Lazy!(mir::ConstQualifs)>,\n-    rendered_const: Table<DefIndex, Lazy!(String)>,\n+    coerce_unsized_info: Table<DefIndex, LazyValue<ty::adjustment::CoerceUnsizedInfo>>,\n+    mir_const_qualif: Table<DefIndex, LazyValue<mir::ConstQualifs>>,\n+    rendered_const: Table<DefIndex, LazyValue<String>>,\n     asyncness: Table<DefIndex, hir::IsAsync>,\n-    fn_arg_names: Table<DefIndex, Lazy!([Ident])>,\n-    generator_kind: Table<DefIndex, Lazy!(hir::GeneratorKind)>,\n-    trait_def: Table<DefIndex, Lazy!(ty::TraitDef)>,\n+    fn_arg_names: Table<DefIndex, LazyArray<Ident>>,\n+    generator_kind: Table<DefIndex, LazyValue<hir::GeneratorKind>>,\n+    trait_def: Table<DefIndex, LazyValue<ty::TraitDef>>,\n \n     trait_item_def_id: Table<DefIndex, RawDefId>,\n-    inherent_impls: Table<DefIndex, Lazy<[DefIndex]>>,\n-    expn_that_defined: Table<DefIndex, Lazy<ExpnId>>,\n-    unused_generic_params: Table<DefIndex, Lazy<FiniteBitSet<u32>>>,\n-    repr_options: Table<DefIndex, Lazy<ReprOptions>>,\n+    inherent_impls: Table<DefIndex, LazyArray<DefIndex>>,\n+    expn_that_defined: Table<DefIndex, LazyValue<ExpnId>>,\n+    unused_generic_params: Table<DefIndex, LazyValue<FiniteBitSet<u32>>>,\n+    repr_options: Table<DefIndex, LazyValue<ReprOptions>>,\n     // `def_keys` and `def_path_hashes` represent a lazy version of a\n     // `DefPathTable`. This allows us to avoid deserializing an entire\n     // `DefPathTable` up front, since we may only ever use a few\n     // definitions from any given crate.\n-    def_keys: Table<DefIndex, Lazy<DefKey>>,\n+    def_keys: Table<DefIndex, LazyValue<DefKey>>,\n     def_path_hashes: Table<DefIndex, DefPathHash>,\n-    proc_macro_quoted_spans: Table<usize, Lazy<Span>>,\n-    generator_diagnostic_data: Table<DefIndex, Lazy<GeneratorDiagnosticData<'tcx>>>,\n+    proc_macro_quoted_spans: Table<usize, LazyValue<Span>>,\n+    generator_diagnostic_data: Table<DefIndex, LazyValue<GeneratorDiagnosticData<'tcx>>>,\n     may_have_doc_links: Table<DefIndex, ()>,\n }\n \n@@ -382,19 +393,19 @@ enum EntryKind {\n     OpaqueTy,\n     Enum,\n     Field,\n-    Variant(Lazy<VariantData>),\n-    Struct(Lazy<VariantData>),\n-    Union(Lazy<VariantData>),\n+    Variant(LazyValue<VariantData>),\n+    Struct(LazyValue<VariantData>),\n+    Union(LazyValue<VariantData>),\n     Fn,\n     ForeignFn,\n-    Mod(Lazy<[ModChild]>),\n-    MacroDef(Lazy<ast::MacArgs>, /*macro_rules*/ bool),\n+    Mod(LazyArray<ModChild>),\n+    MacroDef(LazyValue<ast::MacArgs>, /*macro_rules*/ bool),\n     ProcMacro(MacroKind),\n     Closure,\n     Generator,\n     Trait,\n     Impl,\n-    AssocFn(Lazy<AssocFnData>),\n+    AssocFn(LazyValue<AssocFnData>),\n     AssocType(AssocContainer),\n     AssocConst(AssocContainer),\n     TraitAlias,"}, {"sha": "83d4c48e4ea8e164ab2be88bec962b4f20dff57b", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 13, "deletions": 37, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ca5e60b7fb8867a59529e3120c305574a1e3e991/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca5e60b7fb8867a59529e3120c305574a1e3e991/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=ca5e60b7fb8867a59529e3120c305574a1e3e991", "patch": "@@ -201,15 +201,15 @@ impl FixedSizeEncoding for Option<()> {\n }\n \n // NOTE(eddyb) there could be an impl for `usize`, which would enable a more\n-// generic `Lazy<T>` impl, but in the general case we might not need / want to\n-// fit every `usize` in `u32`.\n-impl<T> FixedSizeEncoding for Option<Lazy<T>> {\n+// generic `LazyValue<T>` impl, but in the general case we might not need / want\n+// to fit every `usize` in `u32`.\n+impl<T> FixedSizeEncoding for Option<LazyValue<T>> {\n     type ByteArray = [u8; 4];\n \n     #[inline]\n     fn from_bytes(b: &[u8; 4]) -> Self {\n         let position = NonZeroUsize::new(u32::from_bytes(b) as usize)?;\n-        Some(Lazy::from_position(position))\n+        Some(LazyValue::from_position(position))\n     }\n \n     #[inline]\n@@ -220,15 +220,15 @@ impl<T> FixedSizeEncoding for Option<Lazy<T>> {\n     }\n }\n \n-impl<T> FixedSizeEncoding for Option<Lazy<[T]>> {\n+impl<T> FixedSizeEncoding for Option<LazyArray<T>> {\n     type ByteArray = [u8; 8];\n \n     #[inline]\n     fn from_bytes(b: &[u8; 8]) -> Self {\n         let ([ref position_bytes, ref meta_bytes],[])= b.as_chunks::<4>() else { panic!() };\n         let position = NonZeroUsize::new(u32::from_bytes(position_bytes) as usize)?;\n         let len = u32::from_bytes(meta_bytes) as usize;\n-        Some(Lazy::from_position_and_meta(position, len))\n+        Some(LazyArray::from_position_and_len(position, len))\n     }\n \n     #[inline]\n@@ -239,28 +239,12 @@ impl<T> FixedSizeEncoding for Option<Lazy<[T]>> {\n         let position: u32 = position.try_into().unwrap();\n         position.write_to_bytes(position_bytes);\n \n-        let len = self.map_or(0, |lazy| lazy.meta);\n+        let len = self.map_or(0, |lazy| lazy.len);\n         let len: u32 = len.try_into().unwrap();\n         len.write_to_bytes(meta_bytes);\n     }\n }\n \n-/// Random-access table (i.e. offering constant-time `get`/`set`), similar to\n-/// `Vec<Option<T>>`, but without requiring encoding or decoding all the values\n-/// eagerly and in-order.\n-/// A total of `(max_idx + 1)` times `Option<T> as FixedSizeEncoding>::ByteArray`\n-/// are used for a table, where `max_idx` is the largest index passed to\n-/// `TableBuilder::set`.\n-pub(super) struct Table<I: Idx, T>\n-where\n-    Option<T>: FixedSizeEncoding,\n-{\n-    _marker: PhantomData<(fn(&I), T)>,\n-    // NOTE(eddyb) this makes `Table` not implement `Sized`, but no\n-    // value of `Table` is ever created (it's always behind `Lazy`).\n-    _bytes: [u8],\n-}\n-\n /// Helper for constructing a table's serialization (also see `Table`).\n pub(super) struct TableBuilder<I: Idx, T>\n where\n@@ -296,7 +280,7 @@ where\n         Some(value).write_to_bytes(&mut self.blocks[i]);\n     }\n \n-    pub(crate) fn encode<const N: usize>(&self, buf: &mut Encoder) -> Lazy<Table<I, T>>\n+    pub(crate) fn encode<const N: usize>(&self, buf: &mut Encoder) -> LazyTable<I, T>\n     where\n         Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n     {\n@@ -305,19 +289,11 @@ where\n             buf.emit_raw_bytes(block).unwrap();\n         }\n         let num_bytes = self.blocks.len() * N;\n-        Lazy::from_position_and_meta(NonZeroUsize::new(pos as usize).unwrap(), num_bytes)\n+        LazyTable::from_position_and_len(NonZeroUsize::new(pos as usize).unwrap(), num_bytes)\n     }\n }\n \n-impl<I: Idx, T> LazyMeta for Table<I, T>\n-where\n-    Option<T>: FixedSizeEncoding,\n-{\n-    /// Number of bytes in the data stream.\n-    type Meta = usize;\n-}\n-\n-impl<I: Idx, T> Lazy<Table<I, T>>\n+impl<I: Idx, T> LazyTable<I, T>\n where\n     Option<T>: FixedSizeEncoding,\n {\n@@ -331,10 +307,10 @@ where\n     where\n         Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n     {\n-        debug!(\"Table::lookup: index={:?} len={:?}\", i, self.meta);\n+        debug!(\"LazyTable::lookup: index={:?} len={:?}\", i, self.len);\n \n         let start = self.position.get();\n-        let bytes = &metadata.blob()[start..start + self.meta];\n+        let bytes = &metadata.blob()[start..start + self.len];\n         let (bytes, []) = bytes.as_chunks::<N>() else { panic!() };\n         let bytes = bytes.get(i.index())?;\n         FixedSizeEncoding::from_bytes(bytes)\n@@ -345,6 +321,6 @@ where\n     where\n         Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n     {\n-        self.meta / N\n+        self.len / N\n     }\n }"}]}