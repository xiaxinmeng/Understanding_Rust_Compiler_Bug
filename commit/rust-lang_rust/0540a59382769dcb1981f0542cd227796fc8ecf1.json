{"sha": "0540a59382769dcb1981f0542cd227796fc8ecf1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1NDBhNTkzODI3NjlkY2IxOTgxZjA1NDJjZDIyNzc5NmZjOGVjZjE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-04-08T09:00:20Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-04-23T00:30:58Z"}, "message": "Check for unsized types in enums.\n\nAnd allow the last field of a struct or variant to be unsized.", "tree": {"sha": "4c59f180ab564f532bfa25cfececaf7ff5f38dc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c59f180ab564f532bfa25cfececaf7ff5f38dc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0540a59382769dcb1981f0542cd227796fc8ecf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0540a59382769dcb1981f0542cd227796fc8ecf1", "html_url": "https://github.com/rust-lang/rust/commit/0540a59382769dcb1981f0542cd227796fc8ecf1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0540a59382769dcb1981f0542cd227796fc8ecf1/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f78add10cde772b9d743a84a604dc584b63a06fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f78add10cde772b9d743a84a604dc584b63a06fc", "html_url": "https://github.com/rust-lang/rust/commit/f78add10cde772b9d743a84a604dc584b63a06fc"}], "stats": {"total": 180, "additions": 164, "deletions": 16}, "files": [{"sha": "7e0e4abef9d35706d7f375c54116178731466a85", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0540a59382769dcb1981f0542cd227796fc8ecf1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0540a59382769dcb1981f0542cd227796fc8ecf1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0540a59382769dcb1981f0542cd227796fc8ecf1", "patch": "@@ -2608,6 +2608,10 @@ pub fn type_is_sized(cx: &ctxt, ty: ty::t) -> bool {\n             !tps.any(|ty| !type_is_sized(cx, ty))\n         }\n         ty_tup(ref ts) => !ts.iter().any(|t| !type_is_sized(cx, *t)),\n+        ty_enum(did, ref substs) => {\n+            let variants = substd_enum_variants(cx, did, substs);\n+            !variants.iter().any(|v| v.args.iter().any(|t| !type_is_sized(cx, *t)))\n+        }\n         _ => true\n     }\n }"}, {"sha": "b4f22f3fa6ed67b55f71c09218861badb0a4a812", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 66, "deletions": 16, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/0540a59382769dcb1981f0542cd227796fc8ecf1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0540a59382769dcb1981f0542cd227796fc8ecf1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=0540a59382769dcb1981f0542cd227796fc8ecf1", "patch": "@@ -317,9 +317,23 @@ impl<'a> Visitor<()> for CheckItemTypesVisitor<'a> {\n     }\n }\n \n+struct CheckItemSizedTypesVisitor<'a> { ccx: &'a CrateCtxt<'a> }\n+\n+impl<'a> Visitor<()> for CheckItemSizedTypesVisitor<'a> {\n+    fn visit_item(&mut self, i: &ast::Item, _: ()) {\n+        check_item_sized(self.ccx, i);\n+        visit::walk_item(self, i, ());\n+    }\n+}\n+\n pub fn check_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n     let mut visit = CheckItemTypesVisitor { ccx: ccx };\n     visit::walk_crate(&mut visit, krate, ());\n+\n+    ccx.tcx.sess.abort_if_errors();\n+\n+    let mut visit = CheckItemSizedTypesVisitor { ccx: ccx };\n+    visit::walk_crate(&mut visit, krate, ());\n }\n \n fn check_bare_fn(ccx: &CrateCtxt,\n@@ -562,19 +576,19 @@ fn check_for_field_shadowing(tcx: &ty::ctxt,\n }\n \n fn check_fields_sized(tcx: &ty::ctxt,\n-                      id: ast::NodeId) {\n-    let struct_def = tcx.map.expect_struct(id);\n-    // FIXME(#13121) allow the last field to be DST\n-    for f in struct_def.fields.iter() {\n+                      struct_def: @ast::StructDef) {\n+    let len = struct_def.fields.len();\n+    for i in range(0, len) {\n+        let f = struct_def.fields.get(i);\n         let t = ty::node_id_to_type(tcx, f.node.id);\n-        if !ty::type_is_sized(tcx, t) {\n+        if !ty::type_is_sized(tcx, t) && i < (len - 1) {\n             match f.node.kind {\n                 ast::NamedField(ident, _) => {\n-                    tcx.sess.span_err(f.span, format!(\"Dynamically sized type in field {}\",\n+                    tcx.sess.span_err(f.span, format!(\"type of field {} is dynamically sized\",\n                                                       token::get_ident(ident)));\n                 }\n                 ast::UnnamedField(_) => {\n-                    tcx.sess.span_err(f.span, \"Dynamically sized type in field\");\n+                    tcx.sess.span_err(f.span, \"dynamically sized type in field\");\n                 }\n             }\n         }\n@@ -584,14 +598,8 @@ fn check_fields_sized(tcx: &ty::ctxt,\n pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     let tcx = ccx.tcx;\n \n-    // Check that the struct is representable\n     check_representable(tcx, span, id, \"struct\");\n-\n-    // Check that the struct is instantiable\n-    if check_instantiable(tcx, span, id) {\n-        // This might cause stack overflow if id is not instantiable.\n-        check_fields_sized(tcx, id);\n-    }\n+    check_instantiable(tcx, span, id);\n \n     // Check there are no overlapping fields in super-structs\n     check_for_field_shadowing(tcx, local_def(id));\n@@ -601,6 +609,24 @@ pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     }\n }\n \n+pub fn check_item_sized(ccx: &CrateCtxt, it: &ast::Item) {\n+    debug!(\"check_item(it.id={}, it.ident={})\",\n+           it.id,\n+           ty::item_path_str(ccx.tcx, local_def(it.id)));\n+    let _indenter = indenter();\n+\n+    match it.node {\n+        ast::ItemEnum(ref enum_definition, _) => {\n+            check_enum_variants_sized(ccx,\n+                                      enum_definition.variants.as_slice());\n+        }\n+        ast::ItemStruct(..) => {\n+            check_fields_sized(ccx.tcx, ccx.tcx.map.expect_struct(it.id));\n+        }\n+        _ => {}\n+    }\n+}\n+\n pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n     debug!(\"check_item(it.id={}, it.ident={})\",\n            it.id,\n@@ -3459,7 +3485,7 @@ pub fn check_const_with_ty(fcx: &FnCtxt,\n pub fn check_representable(tcx: &ty::ctxt,\n                            sp: Span,\n                            item_id: ast::NodeId,\n-                           designation: &str) {\n+                           designation: &str) -> bool {\n     let rty = ty::node_id_to_type(tcx, item_id);\n \n     // Check that it is possible to represent this type. This call identifies\n@@ -3473,9 +3499,11 @@ pub fn check_representable(tcx: &ty::ctxt,\n           sp, format!(\"illegal recursive {} type; \\\n                        wrap the inner value in a box to make it representable\",\n                       designation));\n+        return false\n       }\n       ty::Representable | ty::ContainsRecursive => (),\n     }\n+    return true\n }\n \n /// Checks whether a type can be created without an instance of itself.\n@@ -3532,6 +3560,29 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n     }\n }\n \n+pub fn check_enum_variants_sized(ccx: &CrateCtxt,\n+                                 vs: &[ast::P<ast::Variant>]) {\n+    for &v in vs.iter() {\n+        match v.node.kind {\n+            ast::TupleVariantKind(ref args) if args.len() > 0 => {\n+                let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n+                let arg_tys: Vec<ty::t> = ty::ty_fn_args(ctor_ty).iter().map(|a| *a).collect();\n+                for i in range(0, args.len()) {\n+                    let t = arg_tys.get(i);\n+                    // Allow the last field in an enum to be unsized.\n+                    if !ty::type_is_sized(ccx.tcx, *t) && i < args.len() -1 {\n+                        ccx.tcx.sess.span_err(args.get(i).ty.span,\n+                                              format!(\"type {} is dynamically sized\",\n+                                                      ppaux::ty_to_str(ccx.tcx, *t)));\n+                    }\n+                }\n+            },\n+            ast::StructVariantKind(struct_def) => check_fields_sized(ccx.tcx, struct_def),\n+            _ => {}\n+        }\n+    }\n+}\n+\n pub fn check_enum_variants(ccx: &CrateCtxt,\n                            sp: Span,\n                            vs: &[ast::P<ast::Variant>],\n@@ -3652,7 +3703,6 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n     // cache so that ty::enum_variants won't repeat this work\n     ccx.tcx.enum_var_cache.borrow_mut().insert(local_def(id), Rc::new(variants));\n \n-    // Check that it is possible to represent this enum.\n     check_representable(ccx.tcx, sp, id, \"enum\");\n \n     // Check that it is possible to instantiate this enum:"}, {"sha": "7a167237d3e5db38f8a8d1adcbef41dd24d58835", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0540a59382769dcb1981f0542cd227796fc8ecf1/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0540a59382769dcb1981f0542cd227796fc8ecf1/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=0540a59382769dcb1981f0542cd227796fc8ecf1", "patch": "@@ -283,6 +283,13 @@ impl Map {\n         }\n     }\n \n+    pub fn expect_variant(&self, id: NodeId) -> P<Variant> {\n+        match self.find(id) {\n+            Some(NodeVariant(variant)) => variant,\n+            _ => fail!(format!(\"expected variant, found {}\", self.node_to_str(id))),\n+        }\n+    }\n+\n     pub fn expect_foreign_item(&self, id: NodeId) -> @ForeignItem {\n         match self.find(id) {\n             Some(NodeForeignItem(item)) => item,"}, {"sha": "0ff5b1c9b5ad8b76c1ca08b67e031567ac4153a8", "filename": "src/test/compile-fail/unsized3.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0540a59382769dcb1981f0542cd227796fc8ecf1/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0540a59382769dcb1981f0542cd227796fc8ecf1/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized3.rs?ref=0540a59382769dcb1981f0542cd227796fc8ecf1", "patch": "@@ -25,6 +25,35 @@ fn f3<type X: T>(x: &X) {\n fn f4<X: T>(x: &X) {\n }\n \n+// Test with unsized enum.\n+enum E<type X> {\n+    V(X),\n+}\n+\n+fn f5<Y>(x: &Y) {}\n+fn f6<type X>(x: &X) {}\n+fn f7<type X>(x1: &E<X>, x2: &E<X>) {\n+    f5(x1); //~ERROR instantiating a type parameter with an incompatible type `E<X>`, which does not\n+    f6(x2); // ok\n+}\n+\n+\n+// Test with unsized struct.\n+struct S<type X> {\n+    x: X,\n+}\n+\n+fn f8<type X>(x1: &S<X>, x2: &S<X>) {\n+    f5(x1); //~ERROR instantiating a type parameter with an incompatible type `S<X>`, which does not\n+    f6(x2); // ok\n+}\n+\n+// Test some tuples.\n+fn f9<type X>(x1: ~S<X>, x2: ~E<X>) {\n+    f5(&(*x1, 34)); //~ERROR instantiating a type parameter with an incompatible type `(S<X>,int)`,\n+    f5(&(32, *x2)); //~ERROR instantiating a type parameter with an incompatible type `(int,E<X>)`,\n+}\n+\n // I would like these to fail eventually.\n /*\n // impl - bounded"}, {"sha": "c3b50dcdcafeaeeb6a2233d4c6c75eba97bfa895", "filename": "src/test/compile-fail/unsized5.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0540a59382769dcb1981f0542cd227796fc8ecf1/src%2Ftest%2Fcompile-fail%2Funsized5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0540a59382769dcb1981f0542cd227796fc8ecf1/src%2Ftest%2Fcompile-fail%2Funsized5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized5.rs?ref=0540a59382769dcb1981f0542cd227796fc8ecf1", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(struct_variant)]\n+\n+// Test `type` types not allowed in fields or local variables.\n+\n+/*trait T for type {}\n+\n+fn f5<type X>(x: &X) {\n+    let _: X; // ERROR local variable with dynamically sized type X\n+    let _: (int, (X, int)); // ERROR local variable with dynamically sized type (int,(X,int))\n+}\n+fn f6<type X: T>(x: &X) {\n+    let _: X; // ERROR local variable with dynamically sized type X\n+    let _: (int, (X, int)); // ERROR local variable with dynamically sized type (int,(X,int))\n+}*/\n+\n+struct S1<type X> {\n+    f1: X, //~ ERROR type of field f1 is dynamically sized\n+    f2: int,\n+}\n+struct S2<type X> {\n+    f: int,\n+    g: X, //~ ERROR type of field g is dynamically sized\n+    h: int,\n+}\n+\n+enum E<type X> {\n+    V1(X, int), //~ERROR type X is dynamically sized\n+    V2{f1: X, f: int}, //~ERROR type of field f1 is dynamically sized\n+}\n+\n+pub fn main() {\n+}"}, {"sha": "db0cc83d7866af826dcdadb3602850083b1b822c", "filename": "src/test/run-pass/unsized.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0540a59382769dcb1981f0542cd227796fc8ecf1/src%2Ftest%2Frun-pass%2Funsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0540a59382769dcb1981f0542cd227796fc8ecf1/src%2Ftest%2Frun-pass%2Funsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized.rs?ref=0540a59382769dcb1981f0542cd227796fc8ecf1", "patch": "@@ -19,6 +19,7 @@ trait T6<Y, type X> {}\n trait T7<type X, type Y> {}\n trait T8<type X: T2> {}\n struct S1<type X>;\n+enum E<type X> {}\n impl <type X> T1 for S1<X> {}\n fn f<type X>() {}\n "}, {"sha": "7cc2dfd816f358dca7af5f2393419daaa854d597", "filename": "src/test/run-pass/unsized2.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0540a59382769dcb1981f0542cd227796fc8ecf1/src%2Ftest%2Frun-pass%2Funsized2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0540a59382769dcb1981f0542cd227796fc8ecf1/src%2Ftest%2Frun-pass%2Funsized2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized2.rs?ref=0540a59382769dcb1981f0542cd227796fc8ecf1", "patch": "@@ -7,6 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+#![feature(struct_variant)]\n \n // Test sized-ness checking in substitution.\n \n@@ -78,5 +79,20 @@ trait T7<type X: T> {\n     fn m2(x: &T5<X>);\n }\n \n+// The last field in a struct or variant may be unsized\n+struct S2<type X> {\n+    f: X,\n+}\n+struct S3<type X> {\n+    f1: int,\n+    f2: X,\n+}\n+enum E<type X> {\n+    V1(X),\n+    V2{x: X},\n+    V3(int, X),\n+    V4{u: int, x: X},\n+}\n+\n pub fn main() {\n }"}]}