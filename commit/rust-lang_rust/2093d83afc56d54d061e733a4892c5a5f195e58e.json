{"sha": "2093d83afc56d54d061e733a4892c5a5f195e58e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwOTNkODNhZmM1NmQ1NGQwNjFlNzMzYTQ4OTJjNWE1ZjE5NWU1OGU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-14T19:22:29Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-15T00:15:47Z"}, "message": "def_collector: Fully visit async functions", "tree": {"sha": "ae29a367022a7deeaa52af4a7b91905e097b3e4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae29a367022a7deeaa52af4a7b91905e097b3e4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2093d83afc56d54d061e733a4892c5a5f195e58e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2093d83afc56d54d061e733a4892c5a5f195e58e", "html_url": "https://github.com/rust-lang/rust/commit/2093d83afc56d54d061e733a4892c5a5f195e58e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2093d83afc56d54d061e733a4892c5a5f195e58e/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cdbc87a49b0b705a41a004a6d486b0952521ae7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cdbc87a49b0b705a41a004a6d486b0952521ae7", "html_url": "https://github.com/rust-lang/rust/commit/7cdbc87a49b0b705a41a004a6d486b0952521ae7"}], "stats": {"total": 96, "additions": 35, "deletions": 61}, "files": [{"sha": "1d6542f25dbe25ef554f8186855972c92ea73e17", "filename": "src/librustc_resolve/def_collector.rs", "status": "modified", "additions": 22, "deletions": 61, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/2093d83afc56d54d061e733a4892c5a5f195e58e/src%2Flibrustc_resolve%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2093d83afc56d54d061e733a4892c5a5f195e58e/src%2Flibrustc_resolve%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdef_collector.rs?ref=2093d83afc56d54d061e733a4892c5a5f195e58e", "patch": "@@ -2,7 +2,7 @@ use log::debug;\n use rustc::hir::map::definitions::*;\n use rustc_ast::ast::*;\n use rustc_ast::token::{self, Token};\n-use rustc_ast::visit;\n+use rustc_ast::visit::{self, FnKind};\n use rustc_expand::expand::AstFragment;\n use rustc_hir::def_id::DefIndex;\n use rustc_span::hygiene::ExpnId;\n@@ -38,42 +38,6 @@ impl<'a> DefCollector<'a> {\n         self.parent_def = orig_parent_def;\n     }\n \n-    fn visit_async_fn(\n-        &mut self,\n-        id: NodeId,\n-        name: Name,\n-        span: Span,\n-        header: &FnHeader,\n-        generics: &'a Generics,\n-        decl: &'a FnDecl,\n-        body: Option<&'a Block>,\n-    ) {\n-        let (closure_id, return_impl_trait_id) = match header.asyncness {\n-            Async::Yes { span: _, closure_id, return_impl_trait_id } => {\n-                (closure_id, return_impl_trait_id)\n-            }\n-            _ => unreachable!(),\n-        };\n-\n-        // For async functions, we need to create their inner defs inside of a\n-        // closure to match their desugared representation.\n-        let fn_def_data = DefPathData::ValueNs(name);\n-        let fn_def = self.create_def(id, fn_def_data, span);\n-        return self.with_parent(fn_def, |this| {\n-            this.create_def(return_impl_trait_id, DefPathData::ImplTrait, span);\n-\n-            visit::walk_generics(this, generics);\n-            visit::walk_fn_decl(this, decl);\n-\n-            let closure_def = this.create_def(closure_id, DefPathData::ClosureExpr, span);\n-            this.with_parent(closure_def, |this| {\n-                if let Some(body) = body {\n-                    visit::walk_block(this, body);\n-                }\n-            })\n-        });\n-    }\n-\n     fn collect_field(&mut self, field: &'a StructField, index: Option<usize>) {\n         let index = |this: &Self| {\n             index.unwrap_or_else(|| {\n@@ -117,17 +81,6 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             | ItemKind::ExternCrate(..)\n             | ItemKind::ForeignMod(..)\n             | ItemKind::TyAlias(..) => DefPathData::TypeNs(i.ident.name),\n-            ItemKind::Fn(_, sig, generics, body) if sig.header.asyncness.is_async() => {\n-                return self.visit_async_fn(\n-                    i.id,\n-                    i.ident.name,\n-                    i.span,\n-                    &sig.header,\n-                    generics,\n-                    &sig.decl,\n-                    body.as_deref(),\n-                );\n-            }\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) => {\n                 DefPathData::ValueNs(i.ident.name)\n             }\n@@ -154,6 +107,27 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         });\n     }\n \n+    fn visit_fn(&mut self, fn_kind: FnKind<'a>, span: Span, _: NodeId) {\n+        if let FnKind::Fn(_, _, sig, _, body) = fn_kind {\n+            if let Async::Yes { closure_id, return_impl_trait_id, .. } = sig.header.asyncness {\n+                self.create_def(return_impl_trait_id, DefPathData::ImplTrait, span);\n+\n+                // For async functions, we need to create their inner defs inside of a\n+                // closure to match their desugared representation. Besides that,\n+                // we must mirror everything that `visit::walk_fn` below does.\n+                self.visit_fn_header(&sig.header);\n+                visit::walk_fn_decl(self, &sig.decl);\n+                if let Some(body) = body {\n+                    let closure_def = self.create_def(closure_id, DefPathData::ClosureExpr, span);\n+                    self.with_parent(closure_def, |this| this.visit_block(body));\n+                }\n+                return;\n+            }\n+        }\n+\n+        visit::walk_fn(self, fn_kind, span);\n+    }\n+\n     fn visit_use_tree(&mut self, use_tree: &'a UseTree, id: NodeId, _nested: bool) {\n         self.create_def(id, DefPathData::Misc, use_tree.span);\n         visit::walk_use_tree(self, use_tree, id);\n@@ -215,19 +189,6 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_assoc_item(&mut self, i: &'a AssocItem, ctxt: visit::AssocCtxt) {\n         let def_data = match &i.kind {\n-            AssocItemKind::Fn(_, FnSig { header, decl }, generics, body)\n-                if header.asyncness.is_async() =>\n-            {\n-                return self.visit_async_fn(\n-                    i.id,\n-                    i.ident.name,\n-                    i.span,\n-                    header,\n-                    generics,\n-                    decl,\n-                    body.as_deref(),\n-                );\n-            }\n             AssocItemKind::Fn(..) | AssocItemKind::Const(..) => DefPathData::ValueNs(i.ident.name),\n             AssocItemKind::TyAlias(..) => DefPathData::TypeNs(i.ident.name),\n             AssocItemKind::Macro(..) => return self.visit_macro_invoc(i.id),"}, {"sha": "af77c3463b5ddb4d8c15ca982eb7f84c44a0fdb5", "filename": "src/test/ui/async-await/expansion-in-attrs.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2093d83afc56d54d061e733a4892c5a5f195e58e/src%2Ftest%2Fui%2Fasync-await%2Fexpansion-in-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2093d83afc56d54d061e733a4892c5a5f195e58e/src%2Ftest%2Fui%2Fasync-await%2Fexpansion-in-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fexpansion-in-attrs.rs?ref=2093d83afc56d54d061e733a4892c5a5f195e58e", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+// edition:2018\n+\n+macro_rules! with_doc {\n+    ($doc: expr) => {\n+        #[doc = $doc]\n+        async fn f() {}\n+    };\n+}\n+\n+with_doc!(concat!(\"\"));\n+\n+fn main() {}"}]}