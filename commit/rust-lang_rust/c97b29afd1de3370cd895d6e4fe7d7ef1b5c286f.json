{"sha": "c97b29afd1de3370cd895d6e4fe7d7ef1b5c286f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5N2IyOWFmZDFkZTMzNzBjZDg5NWQ2ZTRmZTdkN2VmMWI1YzI4NmY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-05-18T03:37:17Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-05-18T03:39:17Z"}, "message": "Refactor encoder::encode_module_item_paths\n\nto eliminate some repeated code.", "tree": {"sha": "dfef497f39c22bb0b505a9ebfb3c87810b4a22ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfef497f39c22bb0b505a9ebfb3c87810b4a22ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c97b29afd1de3370cd895d6e4fe7d7ef1b5c286f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c97b29afd1de3370cd895d6e4fe7d7ef1b5c286f", "html_url": "https://github.com/rust-lang/rust/commit/c97b29afd1de3370cd895d6e4fe7d7ef1b5c286f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c97b29afd1de3370cd895d6e4fe7d7ef1b5c286f/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf2fc2c34e99d8acaa706da7d2f4afe3ee3e7dfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf2fc2c34e99d8acaa706da7d2f4afe3ee3e7dfc", "html_url": "https://github.com/rust-lang/rust/commit/cf2fc2c34e99d8acaa706da7d2f4afe3ee3e7dfc"}], "stats": {"total": 126, "additions": 64, "deletions": 62}, "files": [{"sha": "a1e85c8cc0cdfd8d9fc519ce6bad904565ec2048", "filename": "src/librustsyntax/ast_util.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c97b29afd1de3370cd895d6e4fe7d7ef1b5c286f/src%2Flibrustsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c97b29afd1de3370cd895d6e4fe7d7ef1b5c286f/src%2Flibrustsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast_util.rs?ref=c97b29afd1de3370cd895d6e4fe7d7ef1b5c286f", "patch": "@@ -521,6 +521,13 @@ fn compute_id_range_for_inlined_item(item: inlined_item) -> id_range {\n     compute_id_range { |f| visit_ids_for_inlined_item(item, f) }\n }\n \n+pure fn is_item_impl(item: @ast::item) -> bool {\n+    alt item.node {\n+       item_impl(*) { true }\n+       _            { false }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "93c9db81035058a32686f7dfe841fff0ffc7f626", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 57, "deletions": 62, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/c97b29afd1de3370cd895d6e4fe7d7ef1b5c286f/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c97b29afd1de3370cd895d6e4fe7d7ef1b5c286f/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=c97b29afd1de3370cd895d6e4fe7d7ef1b5c286f", "patch": "@@ -79,6 +79,13 @@ fn encode_def_id(ebml_w: ebml::writer, id: def_id) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n+/* Encodes the given name, then def_id as tagged strings */\n+fn encode_name_and_def_id(ebml_w: ebml::writer, nm: ident,\n+                          id: node_id) {\n+    encode_name(ebml_w, nm);\n+    encode_def_id(ebml_w, local_def(id));\n+}\n+\n fn encode_region_param(ebml_w: ebml::writer, rp: region_param) {\n     ebml_w.wr_tag(tag_region_param) {||\n         serialize_region_param(ebml_w, rp)\n@@ -146,90 +153,79 @@ fn encode_class_item_paths(ebml_w: ebml::writer,\n \n fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                             module: _mod, path: [str], &index: [entry<str>]) {\n-    // FIXME factor out add_to_index/start/encode_name/encode_def_id/end ops\n     for module.items.each {|it|\n         if !reachable(ecx, it.id) ||\n            !ast_util::is_exported(it.ident, module) { cont; }\n+        if !ast_util::is_item_impl(it) {\n+            add_to_index(ebml_w, path, index, it.ident);\n+        }\n         alt it.node {\n           item_const(_, _) {\n-            add_to_index(ebml_w, path, index, it.ident);\n             encode_named_def_id(ebml_w, it.ident, local_def(it.id));\n           }\n           item_fn(_, tps, _) {\n-            add_to_index(ebml_w, path, index, it.ident);\n             encode_named_def_id(ebml_w, it.ident, local_def(it.id));\n           }\n           item_mod(_mod) {\n-            add_to_index(ebml_w, path, index, it.ident);\n-            ebml_w.start_tag(tag_paths_data_mod);\n-            encode_name(ebml_w, it.ident);\n-            encode_def_id(ebml_w, local_def(it.id));\n-            encode_module_item_paths(ebml_w, ecx, _mod, path + [it.ident],\n-                                     index);\n-            ebml_w.end_tag();\n+            ebml_w.wr_tag(tag_paths_data_mod) {||\n+               encode_name_and_def_id(ebml_w, it.ident, it.id);\n+               encode_module_item_paths(ebml_w, ecx, _mod, path + [it.ident],\n+                                        index);\n+            }\n           }\n           item_native_mod(nmod) {\n-            add_to_index(ebml_w, path, index, it.ident);\n-            ebml_w.start_tag(tag_paths_data_mod);\n-            encode_name(ebml_w, it.ident);\n-            encode_def_id(ebml_w, local_def(it.id));\n-            encode_native_module_item_paths(ebml_w, nmod, path + [it.ident],\n-                                            index);\n-            ebml_w.end_tag();\n+            ebml_w.wr_tag(tag_paths_data_mod) {||\n+              encode_name_and_def_id(ebml_w, it.ident, it.id);\n+              encode_native_module_item_paths(ebml_w, nmod,\n+                   path + [it.ident], index);\n+            }\n           }\n           item_ty(_, tps, _) {\n-            add_to_index(ebml_w, path, index, it.ident);\n-            ebml_w.start_tag(tag_paths_data_item);\n-            encode_name(ebml_w, it.ident);\n-            encode_def_id(ebml_w, local_def(it.id));\n-            ebml_w.end_tag();\n+            ebml_w.wr_tag(tag_paths_data_item) {||\n+              encode_name_and_def_id(ebml_w, it.ident, it.id);\n+            }\n           }\n           item_res(_, tps, _, _, ctor_id, _) {\n+            ebml_w.wr_tag(tag_paths_data_item) {||\n+                encode_name_and_def_id(ebml_w, it.ident, ctor_id);\n+            }\n+            // The same ident has to be added twice (with different positions)\n+            // because it's for both the ctor and the dtor.\n             add_to_index(ebml_w, path, index, it.ident);\n-            ebml_w.start_tag(tag_paths_data_item);\n-            encode_name(ebml_w, it.ident);\n-            encode_def_id(ebml_w, local_def(ctor_id));\n-            ebml_w.end_tag();\n-            add_to_index(ebml_w, path, index, it.ident);\n-            ebml_w.start_tag(tag_paths_data_item);\n-            encode_name(ebml_w, it.ident);\n-            encode_def_id(ebml_w, local_def(it.id));\n-            ebml_w.end_tag();\n+            ebml_w.wr_tag(tag_paths_data_item) {||\n+                encode_name_and_def_id(ebml_w, it.ident, it.id);\n+            }\n           }\n           item_class(_, _, items, ctor, m_dtor, _) {\n-            add_to_index(ebml_w, path, index, it.ident);\n-            ebml_w.start_tag(tag_paths_data_item);\n-            encode_name(ebml_w, it.ident);\n-            encode_def_id(ebml_w, local_def(it.id));\n-            ebml_w.end_tag();\n-            ebml_w.start_tag(tag_paths);\n-            add_to_index(ebml_w, path, index, it.ident);\n-            #debug(\"ctor id: %d\", ctor.node.id);\n-            encode_named_def_id(ebml_w, it.ident, local_def(ctor.node.id));\n-            /* Encode id for dtor */\n-            option::iter(m_dtor) {|dtor|\n-                ebml_w.start_tag(tag_item_dtor);\n-                encode_def_id(ebml_w, local_def(dtor.node.id));\n-                ebml_w.end_tag();\n-            };\n-            encode_class_item_paths(ebml_w, items, path + [it.ident],\n-                                      index);\n-            ebml_w.end_tag();\n+            ebml_w.wr_tag(tag_paths_data_item) {||\n+                encode_name_and_def_id(ebml_w, it.ident, it.id);\n+            }\n+            ebml_w.wr_tag(tag_paths) {||\n+                // As in the res case, we add the same ident twice: for the\n+                // class and for its ctor\n+                add_to_index(ebml_w, path, index, it.ident);\n+                encode_named_def_id(ebml_w, it.ident,\n+                                    local_def(ctor.node.id));\n+                /* Encode id for dtor */\n+                option::iter(m_dtor) {|dtor|\n+                        ebml_w.wr_tag(tag_item_dtor) {||\n+                           encode_def_id(ebml_w, local_def(dtor.node.id));\n+                    }\n+                };\n+                encode_class_item_paths(ebml_w, items, path + [it.ident],\n+                                        index);\n+            }\n           }\n           item_enum(variants, _, _) {\n-            add_to_index(ebml_w, path, index, it.ident);\n-            ebml_w.start_tag(tag_paths_data_item);\n-            encode_name(ebml_w, it.ident);\n-            encode_def_id(ebml_w, local_def(it.id));\n-            ebml_w.end_tag();\n-            encode_enum_variant_paths(ebml_w, variants, path, index);\n+              ebml_w.wr_tag(tag_paths_data_item) {||\n+                  encode_name_and_def_id(ebml_w, it.ident, it.id);\n+              }\n+              encode_enum_variant_paths(ebml_w, variants, path, index);\n           }\n           item_iface(*) {\n-            add_to_index(ebml_w, path, index, it.ident);\n-            ebml_w.start_tag(tag_paths_data_item);\n-            encode_name(ebml_w, it.ident);\n-            encode_def_id(ebml_w, local_def(it.id));\n-            ebml_w.end_tag();\n+              ebml_w.wr_tag(tag_paths_data_item) {||\n+                  encode_name_and_def_id(ebml_w, it.ident, it.id);\n+              }\n           }\n           item_impl(*) {}\n         }\n@@ -629,7 +625,6 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_enum_variant_info(ecx, ebml_w, item.id, variants,\n                                  path, index, tps);\n       }\n-      // FIXME: not sure if the dtor should be serialized\n       item_class(tps, ifaces, items, ctor, _dtor, rp) {\n         /* First, encode the fields and methods\n            These come first because we need to write them to make\n@@ -810,7 +805,6 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                 encode_info_for_item(ecx, ebml_w, i, index, *pt);\n                 /* encode ctor, then encode items */\n                 alt i.node {\n-                   // FIXME: not doing anything with dtor\n                    item_class(tps, _, _, ctor, _, _) {\n                    /* this is assuming that ctors aren't inlined...\n                       probably shouldn't assume that */\n@@ -1023,6 +1017,7 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n     // the assumption that they are numbered 1 to n.\n     // FIXME: This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n+    // See #2166\n     ebml_w.start_tag(tag_crate_deps);\n     for get_ordered_deps(cstore).each {|dep|\n         encode_crate_dep(ebml_w, dep);"}]}