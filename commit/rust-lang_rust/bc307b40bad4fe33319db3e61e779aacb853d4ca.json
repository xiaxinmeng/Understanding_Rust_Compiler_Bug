{"sha": "bc307b40bad4fe33319db3e61e779aacb853d4ca", "node_id": "C_kwDOAAsO6NoAKGJjMzA3YjQwYmFkNGZlMzMzMTlkYjNlNjFlNzc5YWFjYjg1M2Q0Y2E", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-09-01T10:18:55Z"}, "committer": {"name": "Christian Poveda", "email": "git@pvdrz.com", "date": "2022-09-13T20:16:41Z"}, "message": "organize clock arithmetic more like the stdlib", "tree": {"sha": "ac90f5770c0e2740c6824055f4d4f5d3e87e09e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac90f5770c0e2740c6824055f4d4f5d3e87e09e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc307b40bad4fe33319db3e61e779aacb853d4ca", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYIAB0WIQRsB8A/3NrzTlMMjT0nUl7150IKUAUCYyDlKQAKCRAnUl7150IK\nUPxQAQCFs8SR7SIiWHOSSx/qtHKsWSN+xodOlctvHTcbP/MEPQD+JGhIDDHDQjsu\nxyzm5vCmEiIPgW8JywAHcBHJTJyAJQ8=\n=aRmU\n-----END PGP SIGNATURE-----", "payload": "tree ac90f5770c0e2740c6824055f4d4f5d3e87e09e0\nparent f5e2f731785029c2fa50f590f41ff14f5e83299d\nauthor Ralf Jung <post@ralfj.de> 1662027535 +0200\ncommitter Christian Poveda <git@pvdrz.com> 1663100201 -0500\n\norganize clock arithmetic more like the stdlib\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc307b40bad4fe33319db3e61e779aacb853d4ca", "html_url": "https://github.com/rust-lang/rust/commit/bc307b40bad4fe33319db3e61e779aacb853d4ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc307b40bad4fe33319db3e61e779aacb853d4ca/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5e2f731785029c2fa50f590f41ff14f5e83299d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5e2f731785029c2fa50f590f41ff14f5e83299d", "html_url": "https://github.com/rust-lang/rust/commit/f5e2f731785029c2fa50f590f41ff14f5e83299d"}], "stats": {"total": 111, "additions": 50, "deletions": 61}, "files": [{"sha": "4fab2b2c5f38bf177ff1a43c74f583fcd9a3eaf1", "filename": "src/clock.rs", "status": "modified", "additions": 38, "deletions": 50, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/bc307b40bad4fe33319db3e61e779aacb853d4ca/src%2Fclock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc307b40bad4fe33319db3e61e779aacb853d4ca/src%2Fclock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fclock.rs?ref=bc307b40bad4fe33319db3e61e779aacb853d4ca", "patch": "@@ -20,6 +20,32 @@ enum InstantKind {\n     Virtual { nanoseconds: u64 },\n }\n \n+impl Instant {\n+    pub fn checked_add(&self, duration: Duration) -> Option<Instant> {\n+        match self.kind {\n+            InstantKind::Host(instant) =>\n+                instant.checked_add(duration).map(|i| Instant { kind: InstantKind::Host(i) }),\n+            InstantKind::Virtual { nanoseconds } =>\n+                u128::from(nanoseconds)\n+                    .checked_add(duration.as_nanos())\n+                    .and_then(|n| u64::try_from(n).ok())\n+                    .map(|nanoseconds| Instant { kind: InstantKind::Virtual { nanoseconds } }),\n+        }\n+    }\n+\n+    pub fn duration_since(&self, earlier: Instant) -> Duration {\n+        match (&self.kind, earlier.kind) {\n+            (InstantKind::Host(instant), InstantKind::Host(earlier)) =>\n+                instant.duration_since(earlier),\n+            (\n+                InstantKind::Virtual { nanoseconds },\n+                InstantKind::Virtual { nanoseconds: earlier },\n+            ) => Duration::from_nanos(nanoseconds.saturating_sub(earlier)),\n+            _ => panic!(\"all `Instant` must be of the same kind\"),\n+        }\n+    }\n+}\n+\n /// A monotone clock used for `Instant` simulation.\n #[derive(Debug)]\n pub struct Clock {\n@@ -50,24 +76,14 @@ impl Clock {\n         Self { kind }\n     }\n \n-    /// Get the current time relative to this clock.\n-    pub fn get(&self) -> Duration {\n-        match &self.kind {\n-            ClockKind::Host { time_anchor } =>\n-                StdInstant::now().saturating_duration_since(*time_anchor),\n-            ClockKind::Virtual { nanoseconds } =>\n-                Duration::from_nanos(nanoseconds.load(Ordering::Relaxed)),\n-        }\n-    }\n-\n     /// Let the time pass for a small interval.\n     pub fn tick(&self) {\n         match &self.kind {\n             ClockKind::Host { .. } => {\n                 // Time will pass without us doing anything.\n             }\n             ClockKind::Virtual { nanoseconds } => {\n-                nanoseconds.fetch_add(NANOSECOND_PER_BASIC_BLOCK, Ordering::Relaxed);\n+                nanoseconds.fetch_add(NANOSECOND_PER_BASIC_BLOCK, Ordering::SeqCst);\n             }\n         }\n     }\n@@ -78,54 +94,26 @@ impl Clock {\n             ClockKind::Host { .. } => std::thread::sleep(duration),\n             ClockKind::Virtual { nanoseconds } => {\n                 // Just pretend that we have slept for some time.\n-                nanoseconds.fetch_add(duration.as_nanos().try_into().unwrap(), Ordering::Relaxed);\n+                nanoseconds.fetch_add(duration.as_nanos().try_into().unwrap(), Ordering::SeqCst);\n             }\n         }\n     }\n \n-    /// Compute `now + duration` relative to this clock.\n-    pub fn get_time_relative(&self, duration: Duration) -> Option<Instant> {\n+    /// Return the `anchor` instant, to convert between monotone instants and durations relative to the anchor.\n+    pub fn anchor(&self) -> Instant {\n         match &self.kind {\n-            ClockKind::Host { .. } =>\n-                StdInstant::now()\n-                    .checked_add(duration)\n-                    .map(|instant| Instant { kind: InstantKind::Host(instant) }),\n-            ClockKind::Virtual { nanoseconds } =>\n-                nanoseconds\n-                    .load(Ordering::Relaxed)\n-                    .checked_add(duration.as_nanos().try_into().unwrap())\n-                    .map(|nanoseconds| Instant { kind: InstantKind::Virtual { nanoseconds } }),\n+            ClockKind::Host { time_anchor } => Instant { kind: InstantKind::Host(*time_anchor) },\n+            ClockKind::Virtual { .. } => Instant { kind: InstantKind::Virtual { nanoseconds: 0 } },\n         }\n     }\n \n-    /// Compute `start + duration` relative to this clock where `start` is the instant of time when\n-    /// this clock was created.\n-    pub fn get_time_absolute(&self, duration: Duration) -> Option<Instant> {\n+    pub fn now(&self) -> Instant {\n         match &self.kind {\n-            ClockKind::Host { time_anchor } =>\n-                time_anchor\n-                    .checked_add(duration)\n-                    .map(|instant| Instant { kind: InstantKind::Host(instant) }),\n-            ClockKind::Virtual { .. } =>\n-                Some(Instant {\n-                    kind: InstantKind::Virtual {\n-                        nanoseconds: duration.as_nanos().try_into().unwrap(),\n-                    },\n-                }),\n-        }\n-    }\n-\n-    /// Returns the duration until the given instant.\n-    pub fn duration_until(&self, instant: &Instant) -> Duration {\n-        match (&instant.kind, &self.kind) {\n-            (InstantKind::Host(instant), ClockKind::Host { .. }) =>\n-                instant.saturating_duration_since(StdInstant::now()),\n-            (\n-                InstantKind::Virtual { nanoseconds },\n-                ClockKind::Virtual { nanoseconds: current_ns },\n-            ) =>\n-                Duration::from_nanos(nanoseconds.saturating_sub(current_ns.load(Ordering::Relaxed))),\n-            _ => panic!(),\n+            ClockKind::Host { .. } => Instant { kind: InstantKind::Host(StdInstant::now()) },\n+            ClockKind::Virtual { nanoseconds } =>\n+                Instant {\n+                    kind: InstantKind::Virtual { nanoseconds: nanoseconds.load(Ordering::SeqCst) },\n+                },\n         }\n     }\n }"}, {"sha": "5364b341ae3ae211b811f789d87a96cc81edb6bc", "filename": "src/concurrency/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc307b40bad4fe33319db3e61e779aacb853d4ca/src%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc307b40bad4fe33319db3e61e779aacb853d4ca/src%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fthread.rs?ref=bc307b40bad4fe33319db3e61e779aacb853d4ca", "patch": "@@ -191,7 +191,7 @@ impl Time {\n     /// How long do we have to wait from now until the specified time?\n     fn get_wait_time(&self, clock: &Clock) -> Duration {\n         match self {\n-            Time::Monotonic(instant) => clock.duration_until(instant),\n+            Time::Monotonic(instant) => instant.duration_since(clock.now()),\n             Time::RealTime(time) =>\n                 time.duration_since(SystemTime::now()).unwrap_or(Duration::new(0, 0)),\n         }"}, {"sha": "933c298ee4d506e14bb7f6002aa96376943c1d5e", "filename": "src/shims/time.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bc307b40bad4fe33319db3e61e779aacb853d4ca/src%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc307b40bad4fe33319db3e61e779aacb853d4ca/src%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftime.rs?ref=bc307b40bad4fe33319db3e61e779aacb853d4ca", "patch": "@@ -41,7 +41,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             this.check_no_isolation(\"`clock_gettime` with real time clocks\")?;\n             system_time_to_duration(&SystemTime::now())?\n         } else if relative_clocks.contains(&clk_id) {\n-            this.machine.clock.get()\n+            this.machine.clock.now().duration_since(this.machine.clock.anchor())\n         } else {\n             let einval = this.eval_libc(\"EINVAL\")?;\n             this.set_last_error(einval)?;\n@@ -125,7 +125,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // QueryPerformanceCounter uses a hardware counter as its basis.\n         // Miri will emulate a counter with a resolution of 1 nanosecond.\n-        let duration = this.machine.clock.get();\n+        let duration = this.machine.clock.now().duration_since(this.machine.clock.anchor());\n         let qpc = i64::try_from(duration.as_nanos()).map_err(|_| {\n             err_unsup_format!(\"programs running longer than 2^63 nanoseconds are not supported\")\n         })?;\n@@ -164,7 +164,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // This returns a u64, with time units determined dynamically by `mach_timebase_info`.\n         // We return plain nanoseconds.\n-        let duration = this.machine.clock.get();\n+        let duration = this.machine.clock.now().duration_since(this.machine.clock.anchor());\n         let res = u64::try_from(duration.as_nanos()).map_err(|_| {\n             err_unsup_format!(\"programs running longer than 2^64 nanoseconds are not supported\")\n         })?;\n@@ -207,9 +207,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n         };\n         // If adding the duration overflows, let's just sleep for an hour. Waking up early is always acceptable.\n-        let timeout_time = this.machine.clock.get_time_relative(duration).unwrap_or_else(|| {\n-            this.machine.clock.get_time_relative(Duration::from_secs(3600)).unwrap()\n-        });\n+        let now = this.machine.clock.now();\n+        let timeout_time = now\n+            .checked_add(duration)\n+            .unwrap_or_else(|| now.checked_add(Duration::from_secs(3600)).unwrap());\n \n         let active_thread = this.get_active_thread();\n         this.block_thread(active_thread);\n@@ -235,7 +236,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let timeout_ms = this.read_scalar(timeout)?.to_u32()?;\n \n         let duration = Duration::from_millis(timeout_ms.into());\n-        let timeout_time = this.machine.clock.get_time_relative(duration).unwrap();\n+        let timeout_time = this.machine.clock.now().checked_add(duration).unwrap();\n \n         let active_thread = this.get_active_thread();\n         this.block_thread(active_thread);"}, {"sha": "cf5a945c5fa5b9f757ce4b8cc1fecf69c98f1320", "filename": "src/shims/unix/linux/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc307b40bad4fe33319db3e61e779aacb853d4ca/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc307b40bad4fe33319db3e61e779aacb853d4ca/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=bc307b40bad4fe33319db3e61e779aacb853d4ca", "patch": "@@ -106,14 +106,14 @@ pub fn futex<'tcx>(\n                     if op & futex_realtime != 0 {\n                         Time::RealTime(SystemTime::UNIX_EPOCH.checked_add(duration).unwrap())\n                     } else {\n-                        Time::Monotonic(this.machine.clock.get_time_absolute(duration).unwrap())\n+                        Time::Monotonic(this.machine.clock.anchor().checked_add(duration).unwrap())\n                     }\n                 } else {\n                     // FUTEX_WAIT uses a relative timestamp.\n                     if op & futex_realtime != 0 {\n                         Time::RealTime(SystemTime::now().checked_add(duration).unwrap())\n                     } else {\n-                        Time::Monotonic(this.machine.clock.get_time_relative(duration).unwrap())\n+                        Time::Monotonic(this.machine.clock.now().checked_add(duration).unwrap())\n                     }\n                 })\n             };"}, {"sha": "496985fd083fc1d30c213adc45342b233925c6ee", "filename": "src/shims/unix/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc307b40bad4fe33319db3e61e779aacb853d4ca/src%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc307b40bad4fe33319db3e61e779aacb853d4ca/src%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fsync.rs?ref=bc307b40bad4fe33319db3e61e779aacb853d4ca", "patch": "@@ -840,7 +840,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let timeout_time = if clock_id == this.eval_libc_i32(\"CLOCK_REALTIME\")? {\n             Time::RealTime(SystemTime::UNIX_EPOCH.checked_add(duration).unwrap())\n         } else if clock_id == this.eval_libc_i32(\"CLOCK_MONOTONIC\")? {\n-            Time::Monotonic(this.machine.clock.get_time_absolute(duration).unwrap())\n+            Time::Monotonic(this.machine.clock.anchor().checked_add(duration).unwrap())\n         } else {\n             throw_unsup_format!(\"unsupported clock id: {}\", clock_id);\n         };"}]}