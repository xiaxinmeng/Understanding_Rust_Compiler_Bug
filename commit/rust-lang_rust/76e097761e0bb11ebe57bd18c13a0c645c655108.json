{"sha": "76e097761e0bb11ebe57bd18c13a0c645c655108", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2ZTA5Nzc2MWUwYmIxMWViZTU3YmQxOGMxM2EwYzY0NWM2NTUxMDg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-13T04:24:48Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-15T19:19:15Z"}, "message": "core::rt: `read` raises `read_error`", "tree": {"sha": "fe28a21669e80be8cb528f5b4671ca18119292b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe28a21669e80be8cb528f5b4671ca18119292b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76e097761e0bb11ebe57bd18c13a0c645c655108", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76e097761e0bb11ebe57bd18c13a0c645c655108", "html_url": "https://github.com/rust-lang/rust/commit/76e097761e0bb11ebe57bd18c13a0c645c655108", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76e097761e0bb11ebe57bd18c13a0c645c655108/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b764d4cb4f0c893caf5a6395db9b1e10a167a28f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b764d4cb4f0c893caf5a6395db9b1e10a167a28f", "html_url": "https://github.com/rust-lang/rust/commit/b764d4cb4f0c893caf5a6395db9b1e10a167a28f"}], "stats": {"total": 270, "additions": 29, "deletions": 241}, "files": [{"sha": "1c68934e80b05a12f28204190dec779ef0c1664f", "filename": "src/libcore/rt/io/extensions.rs", "status": "modified", "additions": 6, "deletions": 232, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/76e097761e0bb11ebe57bd18c13a0c645c655108/src%2Flibcore%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e097761e0bb11ebe57bd18c13a0c645c655108/src%2Flibcore%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fextensions.rs?ref=76e097761e0bb11ebe57bd18c13a0c645c655108", "patch": "@@ -114,434 +114,208 @@ pub trait ReaderByteConversions {\n     /// Reads `n` little-endian unsigned integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_uint_n(&mut self, nbytes: uint) -> u64;\n \n     /// Reads `n` little-endian signed integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_int_n(&mut self, nbytes: uint) -> i64;\n \n     /// Reads `n` big-endian unsigned integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_uint_n(&mut self, nbytes: uint) -> u64;\n \n     /// Reads `n` big-endian signed integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_int_n(&mut self, nbytes: uint) -> i64;\n \n     /// Reads a little-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_uint(&mut self) -> uint;\n \n     /// Reads a little-endian integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_int(&mut self) -> int;\n \n     /// Reads a big-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_uint(&mut self) -> uint;\n \n     /// Reads a big-endian integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_int(&mut self) -> int;\n \n     /// Reads a big-endian `u64`.\n     ///\n     /// `u64`s are 8 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_u64(&mut self) -> u64;\n \n     /// Reads a big-endian `u32`.\n     ///\n     /// `u32`s are 4 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_u32(&mut self) -> u32;\n \n     /// Reads a big-endian `u16`.\n     ///\n     /// `u16`s are 2 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_u16(&mut self) -> u16;\n \n     /// Reads a big-endian `i64`.\n     ///\n     /// `i64`s are 8 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_i64(&mut self) -> i64;\n \n     /// Reads a big-endian `i32`.\n     ///\n     /// `i32`s are 4 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_i32(&mut self) -> i32;\n \n     /// Reads a big-endian `i16`.\n     ///\n     /// `i16`s are 2 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_i16(&mut self) -> i16;\n \n     /// Reads a big-endian `f64`.\n     ///\n     /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_f64(&mut self) -> f64;\n \n     /// Reads a big-endian `f32`.\n     ///\n     /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_be_f32(&mut self) -> f32;\n \n     /// Reads a little-endian `u64`.\n     ///\n     /// `u64`s are 8 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_u64(&mut self) -> u64;\n \n     /// Reads a little-endian `u32`.\n     ///\n     /// `u32`s are 4 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_u32(&mut self) -> u32;\n \n     /// Reads a little-endian `u16`.\n     ///\n     /// `u16`s are 2 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_u16(&mut self) -> u16;\n \n     /// Reads a little-endian `i64`.\n     ///\n     /// `i64`s are 8 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_i64(&mut self) -> i64;\n \n     /// Reads a little-endian `i32`.\n     ///\n     /// `i32`s are 4 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_i32(&mut self) -> i32;\n \n     /// Reads a little-endian `i16`.\n     ///\n     /// `i16`s are 2 bytes long.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_i16(&mut self) -> i16;\n \n     /// Reads a little-endian `f64`.\n     ///\n     /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_f64(&mut self) -> f64;\n \n     /// Reads a little-endian `f32`.\n     ///\n     /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_le_f32(&mut self) -> f32;\n \n     /// Read a u8.\n     ///\n     /// `u8`s are 1 byte.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_u8(&mut self) -> u8;\n \n     /// Read an i8.\n     ///\n     /// `i8`s are 1 byte.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error. Returns `0` if\n-    /// the condition is handled.\n     fn read_i8(&mut self) -> i8;\n \n }\n \n pub trait WriterByteConversions {\n     /// Write the result of passing n through `int::to_str_bytes`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_int(&mut self, n: int);\n \n     /// Write the result of passing n through `uint::to_str_bytes`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_uint(&mut self, n: uint);\n \n     /// Write a little-endian uint (number of bytes depends on system).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_uint(&mut self, n: uint);\n \n     /// Write a little-endian int (number of bytes depends on system).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_int(&mut self, n: int);\n \n     /// Write a big-endian uint (number of bytes depends on system).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_uint(&mut self, n: uint);\n \n     /// Write a big-endian int (number of bytes depends on system).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_int(&mut self, n: int);\n \n     /// Write a big-endian u64 (8 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_u64(&mut self, n: u64);\n \n     /// Write a big-endian u32 (4 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_u32(&mut self, n: u32);\n \n     /// Write a big-endian u16 (2 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_u16(&mut self, n: u16);\n \n     /// Write a big-endian i64 (8 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_i64(&mut self, n: i64);\n \n     /// Write a big-endian i32 (4 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_i32(&mut self, n: i32);\n \n     /// Write a big-endian i16 (2 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_i16(&mut self, n: i16);\n \n     /// Write a big-endian IEEE754 double-precision floating-point (8 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_f64(&mut self, f: f64);\n \n     /// Write a big-endian IEEE754 single-precision floating-point (4 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_be_f32(&mut self, f: f32);\n \n     /// Write a little-endian u64 (8 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_u64(&mut self, n: u64);\n \n     /// Write a little-endian u32 (4 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_u32(&mut self, n: u32);\n \n     /// Write a little-endian u16 (2 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_u16(&mut self, n: u16);\n \n     /// Write a little-endian i64 (8 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_i64(&mut self, n: i64);\n \n     /// Write a little-endian i32 (4 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_i32(&mut self, n: i32);\n \n     /// Write a little-endian i16 (2 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_i16(&mut self, n: i16);\n \n     /// Write a little-endian IEEE754 double-precision floating-point\n     /// (8 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_f64(&mut self, f: f64);\n \n     /// Write a litten-endian IEEE754 single-precision floating-point\n     /// (4 bytes).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_le_f32(&mut self, f: f32);\n \n     /// Write a u8 (1 byte).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_u8(&mut self, n: u8);\n \n     /// Write a i8 (1 byte).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `io_error` condition on error.\n     fn write_i8(&mut self, n: i8);\n }\n \n@@ -552,7 +326,7 @@ mod test {\n     use cell::Cell;\n     use rt::io::mem::MemReader;\n     use rt::io::mock::*;\n-    use rt::io::{io_error, placeholder_error};\n+    use rt::io::{read_error, placeholder_error};\n \n     #[test]\n     fn read_byte() {\n@@ -592,10 +366,10 @@ mod test {\n     fn read_byte_error() {\n         let mut reader = MockReader::new();\n         reader.read = |_| {\n-            io_error::cond.raise(placeholder_error());\n+            read_error::cond.raise(placeholder_error());\n             None\n         };\n-        do io_error::cond.trap(|_| {\n+        do read_error::cond.trap(|_| {\n         }).in {\n             let byte = reader.read_byte();\n             assert!(byte == None);\n@@ -681,13 +455,13 @@ mod test {\n                     buf[0] = 10;\n                     Some(1)\n                 } else {\n-                    io_error::cond.raise(placeholder_error());\n+                    read_error::cond.raise(placeholder_error());\n                     None\n                 }\n             }\n         };\n         let mut buf = ~[8, 9];\n-        do io_error::cond.trap(|_| { } ).in {\n+        do read_error::cond.trap(|_| { } ).in {\n             assert!(!reader.push_bytes(&mut buf, 4));\n         }\n         assert!(buf == ~[8, 9, 10]);\n@@ -710,7 +484,7 @@ mod test {\n                     buf[0] = 10;\n                     Some(1)\n                 } else {\n-                    io_error::cond.raise(placeholder_error());\n+                    read_error::cond.raise(placeholder_error());\n                     None\n                 }\n             }"}, {"sha": "4ec5e83c382618b1bc6528893f21e08a25ca9f89", "filename": "src/libcore/rt/io/mod.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/76e097761e0bb11ebe57bd18c13a0c645c655108/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e097761e0bb11ebe57bd18c13a0c645c655108/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmod.rs?ref=76e097761e0bb11ebe57bd18c13a0c645c655108", "patch": "@@ -350,17 +350,31 @@ condition! {\n     /*pub*/ io_error: super::IoError -> ();\n }\n \n+// XXX: Can't put doc comments on macros\n+// Raised by `read` on error\n+condition! {\n+    // FIXME (#6009): uncomment `pub` after expansion support lands.\n+    /*pub*/ read_error: super::IoError -> ();\n+}\n+\n pub trait Reader {\n     /// Read bytes, up to the length of `buf` and place them in `buf`.\n-    /// Returns the number of bytes read, or `None` on EOF. The number\n-    /// of bytes read my be less than the number requested, even 0.\n+    /// Returns the number of bytes read. The number of bytes read my\n+    /// be less than the number requested, even 0. Returns `None` on EOF.\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `io_error` condition on error, then returns `None`.\n+    /// Raises the `read_error` condition on error. If the condition\n+    /// is handled then no guarantee is made about the number of bytes\n+    /// read and the contents of `buf`. If the condition is handled\n+    /// returns `None` (XXX see below).\n     ///\n     /// # XXX\n     ///\n+    /// * Should raise error on eof\n+    /// * If the condition is handled it should still return the bytes read,\n+    ///   in which case there's no need to return Option\n+    ///\n     /// This doesn't take a `len` argument like the old `read`.\n     /// Will people often need to slice their vectors to call this\n     /// and will that be annoying?"}, {"sha": "f5b3c20f651e13543a93bb35c566ff4aa248422e", "filename": "src/libcore/rt/io/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76e097761e0bb11ebe57bd18c13a0c645c655108/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e097761e0bb11ebe57bd18c13a0c645c655108/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=76e097761e0bb11ebe57bd18c13a0c645c655108", "patch": "@@ -13,7 +13,7 @@ use result::{Ok, Err};\n use rt::sched::local_sched::unsafe_borrow_io;\n use rt::io::net::ip::IpAddr;\n use rt::io::{Reader, Writer, Listener};\n-use rt::io::{io_error, EndOfFile};\n+use rt::io::{io_error, read_error, EndOfFile};\n use rt::rtio::{IoFactory,\n                RtioTcpListener, RtioTcpListenerObject,\n                RtioTcpStream, RtioTcpStreamObject};\n@@ -58,7 +58,7 @@ impl Reader for TcpStream {\n             Err(ioerr) => {\n                 // EOF is indicated by returning None\n                 if ioerr.kind != EndOfFile {\n-                    io_error::cond.raise(ioerr);\n+                    read_error::cond.raise(ioerr);\n                 }\n                 return None;\n             }"}, {"sha": "6ae747f8b4b4c2da517b5c9bdaa6050d4004135e", "filename": "src/libcore/rt/io/option.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76e097761e0bb11ebe57bd18c13a0c645c655108/src%2Flibcore%2Frt%2Fio%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e097761e0bb11ebe57bd18c13a0c645c655108/src%2Flibcore%2Frt%2Fio%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Foption.rs?ref=76e097761e0bb11ebe57bd18c13a0c645c655108", "patch": "@@ -18,7 +18,7 @@\n \n use option::*;\n use super::{Reader, Writer, Listener};\n-use super::{standard_error, PreviousIoError, io_error, IoError};\n+use super::{standard_error, PreviousIoError, io_error, read_error, IoError};\n \n fn prev_io_error() -> IoError {\n     standard_error(PreviousIoError)\n@@ -45,7 +45,7 @@ impl<R: Reader> Reader for Option<R> {\n         match *self {\n             Some(ref mut reader) => reader.read(buf),\n             None => {\n-                io_error::cond.raise(prev_io_error());\n+                read_error::cond.raise(prev_io_error());\n                 None\n             }\n         }\n@@ -79,7 +79,7 @@ mod test {\n     use option::*;\n     use super::super::mem::*;\n     use rt::test::*;\n-    use super::super::{PreviousIoError, io_error};\n+    use super::super::{PreviousIoError, io_error, read_error};\n \n     #[test]\n     fn test_option_writer() {\n@@ -133,7 +133,7 @@ mod test {\n         let mut buf = [];\n \n         let mut called = false;\n-        do io_error::cond.trap(|err| {\n+        do read_error::cond.trap(|err| {\n             assert!(err.kind == PreviousIoError);\n             called = true;\n         }).in {"}]}