{"sha": "b977b5c508bc34fea27a2bfa4b637ab6df8ad7f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NzdiNWM1MDhiYzM0ZmVhMjdhMmJmYTRiNjM3YWI2ZGY4YWQ3ZjQ=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-27T21:14:04Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-27T22:22:11Z"}, "message": "Put the bound function in bind in the bindings, not in a distinguished spot.", "tree": {"sha": "644b9926b70fa3b2366f72d47a0140022bb0075e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/644b9926b70fa3b2366f72d47a0140022bb0075e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b977b5c508bc34fea27a2bfa4b637ab6df8ad7f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b977b5c508bc34fea27a2bfa4b637ab6df8ad7f4", "html_url": "https://github.com/rust-lang/rust/commit/b977b5c508bc34fea27a2bfa4b637ab6df8ad7f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b977b5c508bc34fea27a2bfa4b637ab6df8ad7f4/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db1923159692818becfc0fe386f19cb0f6151855", "url": "https://api.github.com/repos/rust-lang/rust/commits/db1923159692818becfc0fe386f19cb0f6151855", "html_url": "https://github.com/rust-lang/rust/commit/db1923159692818becfc0fe386f19cb0f6151855"}], "stats": {"total": 45, "additions": 22, "deletions": 23}, "files": [{"sha": "8c104b56402669c424eb8de31ba3e55f870e4f40", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b977b5c508bc34fea27a2bfa4b637ab6df8ad7f4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b977b5c508bc34fea27a2bfa4b637ab6df8ad7f4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b977b5c508bc34fea27a2bfa4b637ab6df8ad7f4", "patch": "@@ -4411,10 +4411,12 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n     // \"target\", in this context, means the function that's having some of its\n     // arguments bound and that will be called inside the thunk we're\n     // creating.  (In our running example, target is the function f.)  Pick\n-    // out the pointer to the target function from the environment.\n+    // out the pointer to the target function from the environment. The\n+    // target function lives in the first binding spot.\n     let lltarget =\n         GEP_tup_like(bcx, closure_ty, llclosure,\n-                     ~[0, abi::box_rc_field_body, abi::closure_elt_target]);\n+                     ~[0, abi::box_rc_field_body,\n+                       abi::closure_elt_bindings, 0]);\n     bcx = lltarget.bcx;\n \n     // And then, pick out the target function's own environment.  That's what\n@@ -4457,7 +4459,7 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n \n     let a: uint = 3u; // retptr, task ptr, env come first\n \n-    let b: int = 0;\n+    let b: int = 1;\n     let outgoing_arg_index: uint = 0u;\n     let llout_arg_tys: TypeRef[] =\n         type_of_explicit_args(cx.ccx, sp, outgoing_args);\n@@ -4547,13 +4549,14 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n     }\n \n     // Figure out which tydescs we need to pass, if any.\n-    let outgoing_fty: ty::t;\n+    let outgoing_fty: ty::t = ty::expr_ty(bcx_tcx(cx), f);\n+    let outgoing_fty_real; // the type with typarams still in it\n     let lltydescs: ValueRef[];\n     alt f_res.generic {\n-      none. { outgoing_fty = ty::expr_ty(bcx_tcx(cx), f); lltydescs = ~[]; }\n+      none. { outgoing_fty_real = outgoing_fty; lltydescs = ~[]; }\n       some(ginfo) {\n         lazily_emit_all_generic_info_tydesc_glues(cx, ginfo);\n-        outgoing_fty = ginfo.item_type;\n+        outgoing_fty_real = ginfo.item_type;\n         lltydescs = ginfo.tydescs;\n       }\n     }\n@@ -4565,9 +4568,17 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n     }\n     let bcx = f_res.res.bcx;\n \n+    // Cast the function we are binding to be the type that the closure\n+    // will expect it to have. The type the closure knows about has the\n+    // type parameters substituted with the real types.\n+    let llclosurety = T_ptr(type_of(bcx_ccx(cx), cx.sp, outgoing_fty));\n+    let src_loc = bcx.build.PointerCast(f_res.res.val, llclosurety);\n+    let bound_f = {res: {bcx: bcx, val: src_loc} with f_res};\n+\n+    // Arrange for the bound function to live in the first binding spot.\n+    let bound_tys: ty::t[] = ~[outgoing_fty];\n+    let bound_vals: lval_result[] = ~[bound_f];\n     // Translate the bound expressions.\n-    let bound_tys: ty::t[] = ~[];\n-    let bound_vals: lval_result[] = ~[];\n     for e: @ast::expr  in bound {\n         let lv = trans_lval(bcx, e);\n         bcx = lv.res.bcx;\n@@ -4627,14 +4638,6 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n     bcx = bindings_tydesc.bcx;\n     bcx.build.Store(bindings_tydesc.val, bound_tydesc);\n \n-    // Store thunk-target.\n-    let bound_target =\n-        bcx.build.GEP(closure, ~[C_int(0), C_int(abi::closure_elt_target)]);\n-    let llclosurety = T_ptr(type_of(bcx_ccx(cx), cx.sp, outgoing_fty));\n-    let src_loc = bcx.build.PointerCast(f_res.res.val, llclosurety);\n-    let src = bcx.build.Load(src_loc);\n-    bcx.build.Store(src, bound_target);\n-\n     // Copy expr values into boxed bindings.\n     let i = 0u;\n     let bindings =\n@@ -4647,28 +4650,24 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n \n     // If necessary, copy tydescs describing type parameters into the\n     // appropriate slot in the closure.\n-    alt f_res.generic {\n-      none. {/* nothing to do */ }\n-      some(ginfo) {\n+    if ty_param_count > 0u {\n         let ty_params_slot =\n             bcx.build.GEP(closure,\n                           ~[C_int(0), C_int(abi::closure_elt_ty_params)]);\n         let i = 0;\n-        for td: ValueRef  in ginfo.tydescs {\n+        for td: ValueRef  in lltydescs {\n             let ty_param_slot =\n                 bcx.build.GEP(ty_params_slot, ~[C_int(0), C_int(i)]);\n             bcx.build.Store(td, ty_param_slot);\n             i += 1;\n         }\n-        outgoing_fty = ginfo.item_type;\n-      }\n     }\n \n     // Make thunk\n     // The type of the entire bind expression.\n     let pair_ty = node_id_type(bcx_ccx(cx), id);\n     let llthunk =\n-        trans_bind_thunk(cx.fcx.lcx, cx.sp, pair_ty, outgoing_fty,\n+        trans_bind_thunk(cx.fcx.lcx, cx.sp, pair_ty, outgoing_fty_real,\n                          args, closure_ty, bound_tys, ty_param_count);\n \n     // Construct the function pair"}]}