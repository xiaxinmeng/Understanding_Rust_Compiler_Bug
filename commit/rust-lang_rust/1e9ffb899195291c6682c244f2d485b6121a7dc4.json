{"sha": "1e9ffb899195291c6682c244f2d485b6121a7dc4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlOWZmYjg5OTE5NTI5MWM2NjgyYzI0NGYyZDQ4NWI2MTIxYTdkYzQ=", "commit": {"author": {"name": "Alan Somers", "email": "asomers@gmail.com", "date": "2016-04-06T02:22:18Z"}, "committer": {"name": "Alan Somers", "email": "asomers@gmail.com", "date": "2016-04-06T02:22:18Z"}, "message": "Merge github.com:rust-lang/rust", "tree": {"sha": "39f12484dfe0fb508929497ba163824cdc1f9518", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39f12484dfe0fb508929497ba163824cdc1f9518"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e9ffb899195291c6682c244f2d485b6121a7dc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e9ffb899195291c6682c244f2d485b6121a7dc4", "html_url": "https://github.com/rust-lang/rust/commit/1e9ffb899195291c6682c244f2d485b6121a7dc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e9ffb899195291c6682c244f2d485b6121a7dc4/comments", "author": {"login": "asomers", "id": 129721, "node_id": "MDQ6VXNlcjEyOTcyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/129721?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asomers", "html_url": "https://github.com/asomers", "followers_url": "https://api.github.com/users/asomers/followers", "following_url": "https://api.github.com/users/asomers/following{/other_user}", "gists_url": "https://api.github.com/users/asomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/asomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asomers/subscriptions", "organizations_url": "https://api.github.com/users/asomers/orgs", "repos_url": "https://api.github.com/users/asomers/repos", "events_url": "https://api.github.com/users/asomers/events{/privacy}", "received_events_url": "https://api.github.com/users/asomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "asomers", "id": 129721, "node_id": "MDQ6VXNlcjEyOTcyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/129721?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asomers", "html_url": "https://github.com/asomers", "followers_url": "https://api.github.com/users/asomers/followers", "following_url": "https://api.github.com/users/asomers/following{/other_user}", "gists_url": "https://api.github.com/users/asomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/asomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asomers/subscriptions", "organizations_url": "https://api.github.com/users/asomers/orgs", "repos_url": "https://api.github.com/users/asomers/repos", "events_url": "https://api.github.com/users/asomers/events{/privacy}", "received_events_url": "https://api.github.com/users/asomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "112463a3b1b1fc30c8f407e50e9ef692034ccb37", "url": "https://api.github.com/repos/rust-lang/rust/commits/112463a3b1b1fc30c8f407e50e9ef692034ccb37", "html_url": "https://github.com/rust-lang/rust/commit/112463a3b1b1fc30c8f407e50e9ef692034ccb37"}, {"sha": "241a9d0ddf99fd40d273c615e9b1e8ce6052d94a", "url": "https://api.github.com/repos/rust-lang/rust/commits/241a9d0ddf99fd40d273c615e9b1e8ce6052d94a", "html_url": "https://github.com/rust-lang/rust/commit/241a9d0ddf99fd40d273c615e9b1e8ce6052d94a"}], "stats": {"total": 2621, "additions": 1689, "deletions": 932}, "files": [{"sha": "6591812280122067c5ec3aee46686d7f4616c070", "filename": "mk/rt.mk", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -157,6 +157,8 @@ else ifeq ($(findstring android, $(OSTYPE_$(1))), android)\n   # If the test suite passes, however, without symbol prefixes then we should be\n   # good to go!\n   JEMALLOC_ARGS_$(1) := --disable-tls --with-jemalloc-prefix=je_\n+else ifeq ($(findstring dragonfly, $(OSTYPE_$(1))), dragonfly)\n+  JEMALLOC_ARGS_$(1) := --with-jemalloc-prefix=je_\n endif\n \n ifdef CFG_ENABLE_DEBUG_JEMALLOC"}, {"sha": "5d521913b48f3b1d30ce2689d90a784ee949ef87", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -86,6 +86,8 @@ fn main() {\n         // should be good to go!\n         cmd.arg(\"--with-jemalloc-prefix=je_\");\n         cmd.arg(\"--disable-tls\");\n+    } else if target.contains(\"dragonfly\") {\n+        cmd.arg(\"--with-jemalloc-prefix=je_\");\n     }\n \n     if cfg!(feature = \"debug-jemalloc\") {"}, {"sha": "3a30bebec547889c4f1772b1b33d43849cb9b7d7", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -42,22 +42,27 @@ use libc::{c_int, c_void, size_t};\n extern {}\n \n // Note that the symbols here are prefixed by default on OSX (we don't\n-// explicitly request it), and on Android we explicitly request it as\n-// unprefixing cause segfaults (mismatches in allocators).\n+// explicitly request it), and on Android and DragonFly we explicitly request\n+// it as unprefixing cause segfaults (mismatches in allocators).\n extern {\n-    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\"),\n+    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                   target_os = \"dragonfly\"),\n                link_name = \"je_mallocx\")]\n     fn mallocx(size: size_t, flags: c_int) -> *mut c_void;\n-    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\"),\n+    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                   target_os = \"dragonfly\"),\n                link_name = \"je_rallocx\")]\n     fn rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;\n-    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\"),\n+    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                   target_os = \"dragonfly\"),\n                link_name = \"je_xallocx\")]\n     fn xallocx(ptr: *mut c_void, size: size_t, extra: size_t, flags: c_int) -> size_t;\n-    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\"),\n+    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                   target_os = \"dragonfly\"),\n                link_name = \"je_sdallocx\")]\n     fn sdallocx(ptr: *mut c_void, size: size_t, flags: c_int);\n-    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\"),\n+    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                   target_os = \"dragonfly\"),\n                link_name = \"je_nallocx\")]\n     fn nallocx(size: size_t, flags: c_int) -> size_t;\n }"}, {"sha": "7265c17d1845354f979a39b4ceb3a6934025b2ab", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -1 +1 @@\n-Subproject commit fb2f0bbdab5aa79d684d1e15ccd755f8d37bc07e\n+Subproject commit 7265c17d1845354f979a39b4ceb3a6934025b2ab"}, {"sha": "67669c54ac5eb047ffdd1322df97c638173e71e6", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -37,7 +37,7 @@ use super::equate::Equate;\n use super::glb::Glb;\n use super::lub::Lub;\n use super::sub::Sub;\n-use super::{InferCtxt};\n+use super::InferCtxt;\n use super::{MiscVariable, TypeTrace};\n use super::type_variable::{RelationDir, BiTo, EqTo, SubtypeOf, SupertypeOf};\n \n@@ -46,6 +46,7 @@ use ty::{self, Ty, TyCtxt};\n use ty::error::TypeError;\n use ty::fold::{TypeFolder, TypeFoldable};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n+use traits::PredicateObligations;\n \n use syntax::ast;\n use syntax::codemap::Span;\n@@ -56,6 +57,7 @@ pub struct CombineFields<'a, 'tcx: 'a> {\n     pub a_is_expected: bool,\n     pub trace: TypeTrace<'tcx>,\n     pub cause: Option<ty::relate::Cause>,\n+    pub obligations: PredicateObligations<'tcx>,\n }\n \n pub fn super_combine_tys<'a,'tcx:'a,R>(infcx: &InferCtxt<'a, 'tcx>,"}, {"sha": "5540046c9e36345f4a082f8ebbb6ec72c5aa2a88", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -16,6 +16,7 @@ use super::type_variable::{EqTo};\n use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n+use traits::PredicateObligations;\n \n /// Ensures `a` is made equal to `b`. Returns `a` on success.\n pub struct Equate<'a, 'tcx: 'a> {\n@@ -26,6 +27,10 @@ impl<'a, 'tcx> Equate<'a, 'tcx> {\n     pub fn new(fields: CombineFields<'a, 'tcx>) -> Equate<'a, 'tcx> {\n         Equate { fields: fields }\n     }\n+\n+    pub fn obligations(self) -> PredicateObligations<'tcx> {\n+        self.fields.obligations\n+    }\n }\n \n impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {"}, {"sha": "37717c2b6bc99dab3541b2106b9720b358773552", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -16,6 +16,7 @@ use super::Subtype;\n \n use ty::{self, Ty, TyCtxt};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n+use traits::PredicateObligations;\n \n /// \"Greatest lower bound\" (common subtype)\n pub struct Glb<'a, 'tcx: 'a> {\n@@ -26,6 +27,10 @@ impl<'a, 'tcx> Glb<'a, 'tcx> {\n     pub fn new(fields: CombineFields<'a, 'tcx>) -> Glb<'a, 'tcx> {\n         Glb { fields: fields }\n     }\n+\n+    pub fn obligations(self) -> PredicateObligations<'tcx> {\n+        self.fields.obligations\n+    }\n }\n \n impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Glb<'a, 'tcx> {"}, {"sha": "32b2fe911e86dda8375c4d552faeaf019b1859e2", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -16,6 +16,7 @@ use super::Subtype;\n \n use ty::{self, Ty, TyCtxt};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n+use traits::PredicateObligations;\n \n /// \"Least upper bound\" (common supertype)\n pub struct Lub<'a, 'tcx: 'a> {\n@@ -26,6 +27,10 @@ impl<'a, 'tcx> Lub<'a, 'tcx> {\n     pub fn new(fields: CombineFields<'a, 'tcx>) -> Lub<'a, 'tcx> {\n         Lub { fields: fields }\n     }\n+\n+    pub fn obligations(self) -> PredicateObligations<'tcx> {\n+        self.fields.obligations\n+    }\n }\n \n impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Lub<'a, 'tcx> {"}, {"sha": "e22fb98890438c77f45a4045a2a73e1c5aec089f", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 61, "deletions": 36, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -27,13 +27,13 @@ use middle::region::CodeExtent;\n use ty::subst;\n use ty::subst::Substs;\n use ty::subst::Subst;\n-use traits::{self, ProjectionMode};\n use ty::adjustment;\n use ty::{TyVid, IntVid, FloatVid};\n use ty::{self, Ty, TyCtxt};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use ty::fold::{TypeFolder, TypeFoldable};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n+use traits::{self, PredicateObligations, ProjectionMode};\n use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{RefCell, Ref};\n use std::fmt;\n@@ -63,6 +63,12 @@ pub mod sub;\n pub mod type_variable;\n pub mod unify_key;\n \n+pub struct InferOk<'tcx, T> {\n+    pub value: T,\n+    pub obligations: PredicateObligations<'tcx>,\n+}\n+pub type InferResult<'tcx, T> = Result<InferOk<'tcx, T>, TypeError<'tcx>>;\n+\n pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n@@ -391,16 +397,15 @@ pub fn mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                           origin: TypeOrigin,\n                           a: Ty<'tcx>,\n                           b: Ty<'tcx>)\n-                          -> UnitResult<'tcx>\n+    -> InferResult<'tcx, ()>\n {\n     debug!(\"mk_subty({:?} <: {:?})\", a, b);\n     cx.sub_types(a_is_expected, origin, a, b)\n }\n \n-pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                              a: Ty<'tcx>,\n-                              b: Ty<'tcx>)\n-                              -> UnitResult<'tcx> {\n+pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>)\n+    -> UnitResult<'tcx>\n+{\n     debug!(\"can_mk_subty({:?} <: {:?})\", a, b);\n     cx.probe(|_| {\n         let trace = TypeTrace {\n@@ -412,7 +417,7 @@ pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n }\n \n pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>)\n-                             -> UnitResult<'tcx>\n+    -> UnitResult<'tcx>\n {\n     cx.can_equate(&a, &b)\n }\n@@ -432,7 +437,7 @@ pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                          origin: TypeOrigin,\n                          a: Ty<'tcx>,\n                          b: Ty<'tcx>)\n-                         -> UnitResult<'tcx>\n+    -> InferResult<'tcx, ()>\n {\n     debug!(\"mk_eqty({:?} <: {:?})\", a, b);\n     cx.eq_types(a_is_expected, origin, a, b)\n@@ -443,7 +448,7 @@ pub fn mk_eq_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                   origin: TypeOrigin,\n                                   a: ty::TraitRef<'tcx>,\n                                   b: ty::TraitRef<'tcx>)\n-                                  -> UnitResult<'tcx>\n+    -> InferResult<'tcx, ()>\n {\n     debug!(\"mk_eq_trait_refs({:?} = {:?})\", a, b);\n     cx.eq_trait_refs(a_is_expected, origin, a, b)\n@@ -454,7 +459,7 @@ pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                         origin: TypeOrigin,\n                                         a: ty::PolyTraitRef<'tcx>,\n                                         b: ty::PolyTraitRef<'tcx>)\n-                                        -> UnitResult<'tcx>\n+    -> InferResult<'tcx, ()>\n {\n     debug!(\"mk_sub_poly_trait_refs({:?} <: {:?})\", a, b);\n     cx.sub_poly_trait_refs(a_is_expected, origin, a, b)\n@@ -465,7 +470,7 @@ pub fn mk_eq_impl_headers<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                     origin: TypeOrigin,\n                                     a: &ty::ImplHeader<'tcx>,\n                                     b: &ty::ImplHeader<'tcx>)\n-                                    -> UnitResult<'tcx>\n+    -> InferResult<'tcx, ()>\n {\n     debug!(\"mk_eq_impl_header({:?} = {:?})\", a, b);\n     match (a.trait_ref, b.trait_ref) {\n@@ -574,6 +579,12 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     Ok(infcx.tcx.erase_regions(&result))\n }\n \n+impl<'tcx, T> InferOk<'tcx, T> {\n+    fn unit(self) -> InferOk<'tcx, ()> {\n+        InferOk { value: (), obligations: self.obligations }\n+    }\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn projection_mode(&self) -> ProjectionMode {\n         self.projection_mode\n@@ -661,39 +672,51 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     fn combine_fields(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                      -> CombineFields<'a, 'tcx> {\n-        CombineFields {infcx: self,\n-                       a_is_expected: a_is_expected,\n-                       trace: trace,\n-                       cause: None}\n+        -> CombineFields<'a, 'tcx>\n+    {\n+        CombineFields {\n+            infcx: self,\n+            a_is_expected: a_is_expected,\n+            trace: trace,\n+            cause: None,\n+            obligations: PredicateObligations::new(),\n+        }\n     }\n \n     pub fn equate<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n-        -> RelateResult<'tcx, T>\n+        -> InferResult<'tcx, T>\n         where T: Relate<'a, 'tcx>\n     {\n-        self.combine_fields(a_is_expected, trace).equate().relate(a, b)\n+        let mut equate = self.combine_fields(a_is_expected, trace).equate();\n+        let result = equate.relate(a, b);\n+        result.map(|t| InferOk { value: t, obligations: equate.obligations() })\n     }\n \n     pub fn sub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n-        -> RelateResult<'tcx, T>\n+        -> InferResult<'tcx, T>\n         where T: Relate<'a, 'tcx>\n     {\n-        self.combine_fields(a_is_expected, trace).sub().relate(a, b)\n+        let mut sub = self.combine_fields(a_is_expected, trace).sub();\n+        let result = sub.relate(a, b);\n+        result.map(|t| InferOk { value: t, obligations: sub.obligations() })\n     }\n \n     pub fn lub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n-        -> RelateResult<'tcx, T>\n+        -> InferResult<'tcx, T>\n         where T: Relate<'a, 'tcx>\n     {\n-        self.combine_fields(a_is_expected, trace).lub().relate(a, b)\n+        let mut lub = self.combine_fields(a_is_expected, trace).lub();\n+        let result = lub.relate(a, b);\n+        result.map(|t| InferOk { value: t, obligations: lub.obligations() })\n     }\n \n     pub fn glb<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n-        -> RelateResult<'tcx, T>\n+        -> InferResult<'tcx, T>\n         where T: Relate<'a, 'tcx>\n     {\n-        self.combine_fields(a_is_expected, trace).glb().relate(a, b)\n+        let mut glb = self.combine_fields(a_is_expected, trace).glb();\n+        let result = glb.relate(a, b);\n+        result.map(|t| InferOk { value: t, obligations: glb.obligations() })\n     }\n \n     fn start_snapshot(&self) -> CombinedSnapshot {\n@@ -829,12 +852,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                      origin: TypeOrigin,\n                      a: Ty<'tcx>,\n                      b: Ty<'tcx>)\n-                     -> UnitResult<'tcx>\n+        -> InferResult<'tcx, ()>\n     {\n         debug!(\"sub_types({:?} <: {:?})\", a, b);\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n-            self.sub(a_is_expected, trace, &a, &b).map(|_| ())\n+            self.sub(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n         })\n     }\n \n@@ -843,11 +866,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     origin: TypeOrigin,\n                     a: Ty<'tcx>,\n                     b: Ty<'tcx>)\n-                    -> UnitResult<'tcx>\n+        -> InferResult<'tcx, ()>\n     {\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n-            self.equate(a_is_expected, trace, &a, &b).map(|_| ())\n+            self.equate(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n         })\n     }\n \n@@ -856,7 +879,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                           origin: TypeOrigin,\n                           a: ty::TraitRef<'tcx>,\n                           b: ty::TraitRef<'tcx>)\n-                          -> UnitResult<'tcx>\n+        -> InferResult<'tcx, ()>\n     {\n         debug!(\"eq_trait_refs({:?} <: {:?})\",\n                a,\n@@ -866,7 +889,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 origin: origin,\n                 values: TraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n-            self.equate(a_is_expected, trace, &a, &b).map(|_| ())\n+            self.equate(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n         })\n     }\n \n@@ -875,7 +898,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                origin: TypeOrigin,\n                                a: ty::PolyTraitRef<'tcx>,\n                                b: ty::PolyTraitRef<'tcx>)\n-                               -> UnitResult<'tcx>\n+        -> InferResult<'tcx, ()>\n     {\n         debug!(\"sub_poly_trait_refs({:?} <: {:?})\",\n                a,\n@@ -885,7 +908,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 origin: origin,\n                 values: PolyTraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n-            self.sub(a_is_expected, trace, &a, &b).map(|_| ())\n+            self.sub(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n         })\n     }\n \n@@ -928,20 +951,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn equality_predicate(&self,\n                               span: Span,\n                               predicate: &ty::PolyEquatePredicate<'tcx>)\n-                              -> UnitResult<'tcx> {\n+        -> InferResult<'tcx, ()>\n+    {\n         self.commit_if_ok(|snapshot| {\n             let (ty::EquatePredicate(a, b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let origin = TypeOrigin::EquatePredicate(span);\n-            let () = mk_eqty(self, false, origin, a, b)?;\n-            self.leak_check(&skol_map, snapshot)\n+            let eqty_ok = mk_eqty(self, false, origin, a, b)?;\n+            self.leak_check(&skol_map, snapshot).map(|_| eqty_ok.unit())\n         })\n     }\n \n     pub fn region_outlives_predicate(&self,\n                                      span: Span,\n                                      predicate: &ty::PolyRegionOutlivesPredicate)\n-                                     -> UnitResult<'tcx> {\n+        -> UnitResult<'tcx>\n+    {\n         self.commit_if_ok(|snapshot| {\n             let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);"}, {"sha": "ece8c0c696af83ad35acc7646a447bda1f118204", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -16,6 +16,7 @@ use super::type_variable::{SubtypeOf, SupertypeOf};\n use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n use ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n+use traits::PredicateObligations;\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n@@ -27,6 +28,10 @@ impl<'a, 'tcx> Sub<'a, 'tcx> {\n     pub fn new(f: CombineFields<'a, 'tcx>) -> Sub<'a, 'tcx> {\n         Sub { fields: f }\n     }\n+\n+    pub fn obligations(self) -> PredicateObligations<'tcx> {\n+        self.fields.obligations\n+    }\n }\n \n impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {"}, {"sha": "1573d0c4292ac047fc66028c07e8484a5ae1408f", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -179,6 +179,12 @@ declare_lint! {\n     \"lints that have been renamed or removed\"\n }\n \n+declare_lint! {\n+    pub SUPER_OR_SELF_IN_GLOBAL_PATH,\n+    Warn,\n+    \"detects super or self keywords at the beginning of global path\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -213,7 +219,8 @@ impl LintPass for HardwiredLints {\n             RAW_POINTER_DERIVE,\n             TRANSMUTE_FROM_FN_ITEM_TYPES,\n             OVERLAPPING_INHERENT_IMPLS,\n-            RENAMED_AND_REMOVED_LINTS\n+            RENAMED_AND_REMOVED_LINTS,\n+            SUPER_OR_SELF_IN_GLOBAL_PATH\n         )\n     }\n }"}, {"sha": "4451e7ac472e544c463c49c35c6c74359d4b41f1", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -1502,7 +1502,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 } else {\n                     let ends_with_stmt = match body.expr {\n                         None if !body.stmts.is_empty() =>\n-                            match body.stmts.first().unwrap().node {\n+                            match body.stmts.last().unwrap().node {\n                                 hir::StmtSemi(ref e, _) => {\n                                     self.ir.tcx.expr_ty(&e) == t_ret\n                                 },\n@@ -1515,7 +1515,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                                                    E0269,\n                                                    \"not all control paths return a value\");\n                     if ends_with_stmt {\n-                        let last_stmt = body.stmts.first().unwrap();\n+                        let last_stmt = body.stmts.last().unwrap();\n                         let original_span = original_sp(self.ir.tcx.sess.codemap(),\n                                                         last_stmt.span, sp);\n                         let span_semicolon = Span {"}, {"sha": "11e8dae8717649577970d340f2bfab536e78b492", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 185, "deletions": 150, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use dep_graph::DepGraph;\n-use infer::InferCtxt;\n+use infer::{InferCtxt, InferOk};\n use ty::{self, Ty, TyCtxt, TypeFoldable, ToPolyTraitRef};\n use rustc_data_structures::obligation_forest::{Backtrace, ObligationForest, Error};\n use std::iter;\n@@ -320,103 +320,172 @@ impl<'tcx> FulfillmentContext<'tcx> {\n fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                               tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n                               pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-                              mut backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n+                              backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n                               region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n                               -> Result<Option<Vec<PendingPredicateObligation<'tcx>>>,\n                                         FulfillmentErrorCode<'tcx>>\n {\n-    match process_predicate1(selcx, pending_obligation, backtrace.clone(), region_obligations) {\n-        Ok(Some(v)) => {\n-            // FIXME(#30977) The code below is designed to detect (and\n-            // permit) DAGs, while still ensuring that the reasoning\n-            // is acyclic. However, it does a few things\n-            // suboptimally. For example, it refreshes type variables\n-            // a lot, probably more than needed, but also less than\n-            // you might want.\n-            //\n-            //   - more than needed: I want to be very sure we don't\n-            //     accidentally treat a cycle as a DAG, so I am\n-            //     refreshing type variables as we walk the ancestors;\n-            //     but we are going to repeat this a lot, which is\n-            //     sort of silly, and it would be nicer to refresh\n-            //     them *in place* so that later predicate processing\n-            //     can benefit from the same work;\n-            //   - less than you might want: we only add items in the cache here,\n-            //     but maybe we learn more about type variables and could add them into\n-            //     the cache later on.\n-\n-            let tcx = selcx.tcx();\n-\n-            // Compute a little FnvHashSet for the ancestors. We only\n-            // do this the first time that we care.\n-            let mut cache = None;\n-            let mut is_ancestor = |predicate: &ty::Predicate<'tcx>| {\n-                if cache.is_none() {\n-                    let mut c = FnvHashSet();\n-                    for ancestor in backtrace.by_ref() {\n-                        // Ugh. This just feels ridiculously\n-                        // inefficient.  But we need to compare\n-                        // predicates without being concerned about\n-                        // the vagaries of type inference, so for now\n-                        // just ensure that they are always\n-                        // up-to-date. (I suppose we could just use a\n-                        // snapshot and check if they are unifiable?)\n-                        let resolved_predicate =\n-                            selcx.infcx().resolve_type_vars_if_possible(\n-                                &ancestor.obligation.predicate);\n-                        c.insert(resolved_predicate);\n-                    }\n-                    cache = Some(c);\n+    match process_predicate1(selcx, pending_obligation, region_obligations) {\n+        Ok(Some(v)) => process_child_obligations(selcx,\n+                                                 tree_cache,\n+                                                 &pending_obligation.obligation,\n+                                                 backtrace,\n+                                                 v),\n+        Ok(None) => Ok(None),\n+        Err(e) => Err(e)\n+    }\n+}\n+\n+fn process_child_obligations<'a,'tcx>(\n+    selcx: &mut SelectionContext<'a,'tcx>,\n+    tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n+    pending_obligation: &PredicateObligation<'tcx>,\n+    backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n+    child_obligations: Vec<PredicateObligation<'tcx>>)\n+    -> Result<Option<Vec<PendingPredicateObligation<'tcx>>>,\n+              FulfillmentErrorCode<'tcx>>\n+{\n+    // FIXME(#30977) The code below is designed to detect (and\n+    // permit) DAGs, while still ensuring that the reasoning\n+    // is acyclic. However, it does a few things\n+    // suboptimally. For example, it refreshes type variables\n+    // a lot, probably more than needed, but also less than\n+    // you might want.\n+    //\n+    //   - more than needed: I want to be very sure we don't\n+    //     accidentally treat a cycle as a DAG, so I am\n+    //     refreshing type variables as we walk the ancestors;\n+    //     but we are going to repeat this a lot, which is\n+    //     sort of silly, and it would be nicer to refresh\n+    //     them *in place* so that later predicate processing\n+    //     can benefit from the same work;\n+    //   - less than you might want: we only add items in the cache here,\n+    //     but maybe we learn more about type variables and could add them into\n+    //     the cache later on.\n+\n+    let tcx = selcx.tcx();\n+\n+    let mut ancestor_set = AncestorSet::new(&backtrace);\n+\n+    let pending_predicate_obligations: Vec<_> =\n+        child_obligations\n+        .into_iter()\n+        .filter_map(|obligation| {\n+            // Probably silly, but remove any inference\n+            // variables. This is actually crucial to the ancestor\n+            // check marked (*) below, but it's not clear that it\n+            // makes sense to ALWAYS do it.\n+            let obligation = selcx.infcx().resolve_type_vars_if_possible(&obligation);\n+\n+            // Screen out obligations that we know globally\n+            // are true.\n+            if tcx.fulfilled_predicates.borrow().check_duplicate(&obligation.predicate) {\n+                return None;\n+            }\n+\n+            // Check whether this obligation appears\n+            // somewhere else in the tree. If not, we have to\n+            // process it for sure.\n+            if !tree_cache.is_duplicate_or_add(&obligation.predicate) {\n+                return Some(PendingPredicateObligation {\n+                    obligation: obligation,\n+                    stalled_on: vec![]\n+                });\n+            }\n+\n+            debug!(\"process_child_obligations: duplicate={:?}\",\n+                   obligation.predicate);\n+\n+            // OK, the obligation appears elsewhere in the tree.\n+            // This is either a fatal error or else something we can\n+            // ignore. If the obligation appears in our *ancestors*\n+            // (rather than some more distant relative), that\n+            // indicates a cycle. Cycles are either considered\n+            // resolved (if this is a coinductive case) or a fatal\n+            // error.\n+            if let Some(index) = ancestor_set.has(selcx.infcx(), &obligation.predicate) {\n+                //                            ~~~ (*) see above\n+                debug!(\"process_child_obligations: cycle index = {}\", index);\n+\n+                let backtrace = backtrace.clone();\n+                let cycle: Vec<_> =\n+                    iter::once(&obligation)\n+                    .chain(Some(pending_obligation))\n+                    .chain(backtrace.take(index + 1).map(|p| &p.obligation))\n+                    .cloned()\n+                    .collect();\n+                if coinductive_match(selcx, &cycle) {\n+                    debug!(\"process_child_obligations: coinductive match\");\n+                    None\n+                } else {\n+                    report_overflow_error_cycle(selcx.infcx(), &cycle);\n                 }\n+            } else {\n+                // Not a cycle. Just ignore this obligation then,\n+                // we're already in the process of proving it.\n+                debug!(\"process_child_obligations: not a cycle\");\n+                None\n+            }\n+        })\n+        .collect();\n \n-                cache.as_ref().unwrap().contains(predicate)\n-            };\n+    Ok(Some(pending_predicate_obligations))\n+}\n+\n+struct AncestorSet<'b, 'tcx: 'b> {\n+    populated: bool,\n+    cache: FnvHashMap<ty::Predicate<'tcx>, usize>,\n+    backtrace: Backtrace<'b, PendingPredicateObligation<'tcx>>,\n+}\n \n-            let pending_predicate_obligations: Vec<_> =\n-                v.into_iter()\n-                 .filter_map(|obligation| {\n-                     // Probably silly, but remove any inference\n-                     // variables. This is actually crucial to the\n-                     // ancestor check below, but it's not clear that\n-                     // it makes sense to ALWAYS do it.\n-                     let obligation = selcx.infcx().resolve_type_vars_if_possible(&obligation);\n-\n-                     // Screen out obligations that we know globally\n-                     // are true. This should really be the DAG check\n-                     // mentioned above.\n-                     if tcx.fulfilled_predicates.borrow().check_duplicate(&obligation.predicate) {\n-                         return None;\n-                     }\n-\n-                     // Check whether this obligation appears somewhere else in the tree.\n-                     if tree_cache.is_duplicate_or_add(&obligation.predicate) {\n-                         // If the obligation appears as a parent,\n-                         // allow it, because that is a cycle.\n-                         // Otherwise though we can just ignore\n-                         // it. Note that we have to be careful around\n-                         // inference variables here -- for the\n-                         // purposes of the ancestor check, we retain\n-                         // the invariant that all type variables are\n-                         // fully refreshed.\n-                         if !is_ancestor(&obligation.predicate) {\n-                             return None;\n-                         }\n-                     }\n-\n-                     Some(PendingPredicateObligation {\n-                         obligation: obligation,\n-                         stalled_on: vec![]\n-                     })\n-                 })\n-                 .collect();\n-\n-            Ok(Some(pending_predicate_obligations))\n+impl<'b, 'tcx> AncestorSet<'b, 'tcx> {\n+    fn new(backtrace: &Backtrace<'b, PendingPredicateObligation<'tcx>>) -> Self {\n+        AncestorSet {\n+            populated: false,\n+            cache: FnvHashMap(),\n+            backtrace: backtrace.clone(),\n         }\n-        Ok(None) => Ok(None),\n-        Err(e) => Err(e)\n     }\n-}\n \n+    /// Checks whether any of the ancestors in the backtrace are equal\n+    /// to `predicate` (`predicate` is assumed to be fully\n+    /// type-resolved).  Returns `None` if not; otherwise, returns\n+    /// `Some` with the index within the backtrace.\n+    fn has<'a>(&mut self,\n+               infcx: &InferCtxt<'a, 'tcx>,\n+               predicate: &ty::Predicate<'tcx>)\n+               -> Option<usize> {\n+        // the first time, we have to populate the cache\n+        if !self.populated {\n+            let backtrace = self.backtrace.clone();\n+            for (index, ancestor) in backtrace.enumerate() {\n+                // Ugh. This just feels ridiculously\n+                // inefficient.  But we need to compare\n+                // predicates without being concerned about\n+                // the vagaries of type inference, so for now\n+                // just ensure that they are always\n+                // up-to-date. (I suppose we could just use a\n+                // snapshot and check if they are unifiable?)\n+                let resolved_predicate =\n+                    infcx.resolve_type_vars_if_possible(\n+                        &ancestor.obligation.predicate);\n+\n+                // Though we try to avoid it, it can happen that a\n+                // cycle already exists in the predecessors. This\n+                // happens if the type variables were not fully known\n+                // at the time that the ancestors were pushed. We'll\n+                // just ignore such cycles for now, on the premise\n+                // that they will repeat themselves and we'll deal\n+                // with them properly then.\n+                self.cache.entry(resolved_predicate)\n+                          .or_insert(index);\n+            }\n+            self.populated = true;\n+        }\n+\n+        self.cache.get(predicate).cloned()\n+    }\n+}\n \n /// Return the set of type variables contained in a trait ref\n fn trait_ref_type_vars<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx>,\n@@ -438,7 +507,6 @@ fn trait_ref_type_vars<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx>,\n /// - `Err` if the predicate does not hold\n fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                                pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-                               backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n                                region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n                                -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n                                          FulfillmentErrorCode<'tcx>>\n@@ -461,16 +529,6 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n \n     let obligation = &mut pending_obligation.obligation;\n \n-    // If we exceed the recursion limit, take a moment to look for a\n-    // cycle so we can give a better error report from here, where we\n-    // have more context.\n-    let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n-    if obligation.recursion_depth >= recursion_limit {\n-        if let Some(cycle) = scan_for_cycle(obligation, &backtrace) {\n-            report_overflow_error_cycle(selcx.infcx(), &cycle);\n-        }\n-    }\n-\n     if obligation.predicate.has_infer_types() {\n         obligation.predicate = selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n     }\n@@ -481,10 +539,6 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                 return Ok(Some(vec![]));\n             }\n \n-            if coinductive_match(selcx, obligation, data, &backtrace) {\n-                return Ok(Some(vec![]));\n-            }\n-\n             let trait_obligation = obligation.with(data.clone());\n             match selcx.select(&trait_obligation) {\n                 Ok(Some(vtable)) => {\n@@ -526,7 +580,11 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n \n         ty::Predicate::Equate(ref binder) => {\n             match selcx.infcx().equality_predicate(obligation.cause.span, binder) {\n-                Ok(()) => Ok(Some(Vec::new())),\n+                Ok(InferOk { obligations, .. }) => {\n+                    // FIXME(#32730) propagate obligations\n+                    assert!(obligations.is_empty());\n+                    Ok(Some(Vec::new()))\n+                },\n                 Err(_) => Err(CodeSelectionError(Unimplemented)),\n             }\n         }\n@@ -609,63 +667,40 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n \n /// For defaulted traits, we use a co-inductive strategy to solve, so\n /// that recursion is ok. This routine returns true if the top of the\n-/// stack (`top_obligation` and `top_data`):\n+/// stack (`cycle[0]`):\n /// - is a defaulted trait, and\n /// - it also appears in the backtrace at some position `X`; and,\n /// - all the predicates at positions `X..` between `X` an the top are\n ///   also defaulted traits.\n fn coinductive_match<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n-                              top_obligation: &PredicateObligation<'tcx>,\n-                              top_data: &ty::PolyTraitPredicate<'tcx>,\n-                              backtrace: &Backtrace<PendingPredicateObligation<'tcx>>)\n+                              cycle: &[PredicateObligation<'tcx>])\n                               -> bool\n {\n-    if selcx.tcx().trait_has_default_impl(top_data.def_id()) {\n-        debug!(\"coinductive_match: top_data={:?}\", top_data);\n-        for bt_obligation in backtrace.clone() {\n-            debug!(\"coinductive_match: bt_obligation={:?}\", bt_obligation);\n-\n-            // *Everything* in the backtrace must be a defaulted trait.\n-            match bt_obligation.obligation.predicate {\n-                ty::Predicate::Trait(ref data) => {\n-                    if !selcx.tcx().trait_has_default_impl(data.def_id()) {\n-                        debug!(\"coinductive_match: trait does not have default impl\");\n-                        break;\n-                    }\n-                }\n-                _ => { break; }\n-            }\n-\n-            // And we must find a recursive match.\n-            if bt_obligation.obligation.predicate == top_obligation.predicate {\n-                debug!(\"coinductive_match: found a match in the backtrace\");\n-                return true;\n-            }\n-        }\n-    }\n-\n-    false\n+    let len = cycle.len();\n+\n+    assert_eq!(cycle[0].predicate, cycle[len - 1].predicate);\n+\n+    cycle[0..len-1]\n+        .iter()\n+        .all(|bt_obligation| {\n+            let result = coinductive_obligation(selcx, bt_obligation);\n+            debug!(\"coinductive_match: bt_obligation={:?} coinductive={}\",\n+                   bt_obligation, result);\n+            result\n+        })\n }\n \n-fn scan_for_cycle<'a,'tcx>(top_obligation: &PredicateObligation<'tcx>,\n-                           backtrace: &Backtrace<PendingPredicateObligation<'tcx>>)\n-                           -> Option<Vec<PredicateObligation<'tcx>>>\n-{\n-    let mut map = FnvHashMap();\n-    let all_obligations =\n-        || iter::once(top_obligation)\n-               .chain(backtrace.clone()\n-                               .map(|p| &p.obligation));\n-    for (index, bt_obligation) in all_obligations().enumerate() {\n-        if let Some(&start) = map.get(&bt_obligation.predicate) {\n-            // Found a cycle starting at position `start` and running\n-            // until the current position (`index`).\n-            return Some(all_obligations().skip(start).take(index - start + 1).cloned().collect());\n-        } else {\n-            map.insert(bt_obligation.predicate.clone(), index);\n+fn coinductive_obligation<'a, 'tcx>(selcx: &SelectionContext<'a, 'tcx>,\n+                                    obligation: &PredicateObligation<'tcx>)\n+                                    -> bool {\n+    match obligation.predicate {\n+        ty::Predicate::Trait(ref data) => {\n+            selcx.tcx().trait_has_default_impl(data.def_id())\n+        }\n+        _ => {\n+            false\n         }\n     }\n-    None\n }\n \n fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,"}, {"sha": "d4d61ec024471b1e39f118ff484676e8664a0e3a", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -24,7 +24,7 @@ use super::VtableImplData;\n use super::util;\n \n use middle::def_id::DefId;\n-use infer::{self, TypeOrigin};\n+use infer::{self, InferOk, TypeOrigin};\n use ty::subst::Subst;\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder};\n@@ -232,7 +232,11 @@ fn project_and_unify_type<'cx,'tcx>(\n     let infcx = selcx.infcx();\n     let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n     match infer::mk_eqty(infcx, true, origin, normalized_ty, obligation.predicate.ty) {\n-        Ok(()) => Ok(Some(obligations)),\n+        Ok(InferOk { obligations: inferred_obligations, .. }) => {\n+            // FIXME(#32730) propagate obligations\n+            assert!(inferred_obligations.is_empty());\n+            Ok(Some(obligations))\n+        },\n         Err(err) => Err(MismatchedProjectionTypes { err: err }),\n     }\n }\n@@ -278,7 +282,10 @@ fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext\n             let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n             let obligation_ty = obligation.predicate.ty;\n             match infer::mk_eqty(infcx, true, origin, obligation_ty, ret_type) {\n-                Ok(()) => { }\n+                Ok(InferOk { obligations, .. }) => {\n+                    // FIXME(#32730) propagate obligations\n+                    assert!(obligations.is_empty());\n+                }\n                 Err(_) => { /* ignore errors */ }\n             }\n         }\n@@ -829,7 +836,10 @@ fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n                     infcx.sub_poly_trait_refs(false,\n                                               origin,\n                                               data_poly_trait_ref,\n-                                              obligation_poly_trait_ref).is_ok()\n+                                              obligation_poly_trait_ref)\n+                        // FIXME(#32730) propagate obligations\n+                        .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+                        .is_ok()\n                 });\n \n                 debug!(\"assemble_candidates_from_predicates: candidate={:?} \\\n@@ -1082,7 +1092,10 @@ fn confirm_param_env_candidate<'cx,'tcx>(\n                               origin,\n                               obligation.predicate.trait_ref.clone(),\n                               projection.projection_ty.trait_ref.clone()) {\n-        Ok(()) => { }\n+        Ok(InferOk { obligations, .. }) => {\n+            // FIXME(#32730) propagate obligations\n+            assert!(obligations.is_empty());\n+        }\n         Err(e) => {\n             span_bug!(\n                 obligation.cause.span,"}, {"sha": "f68386feddb59641c2fa5546a19a8244b510d8a3", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 50, "deletions": 33, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -38,7 +38,7 @@ use super::util;\n \n use middle::def_id::DefId;\n use infer;\n-use infer::{InferCtxt, TypeFreshener, TypeOrigin};\n+use infer::{InferCtxt, InferOk, TypeFreshener, TypeOrigin};\n use ty::subst::{Subst, Substs, TypeSpace};\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use traits;\n@@ -484,7 +484,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::Predicate::Equate(ref p) => {\n                 // does this code ever run?\n                 match self.infcx.equality_predicate(obligation.cause.span, p) {\n-                    Ok(()) => EvaluatedToOk,\n+                    Ok(InferOk { obligations, .. }) => {\n+                        // FIXME(#32730) propagate obligations\n+                        assert!(obligations.is_empty());\n+                        EvaluatedToOk\n+                    },\n                     Err(_) => EvaluatedToErr\n                 }\n             }\n@@ -1185,7 +1189,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                              origin,\n                                              trait_bound.clone(),\n                                              ty::Binder(skol_trait_ref.clone())) {\n-            Ok(()) => { }\n+            Ok(InferOk { obligations, .. }) => {\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty());\n+            }\n             Err(_) => { return false; }\n         }\n \n@@ -2487,13 +2494,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let origin = TypeOrigin::RelateOutputImplTypes(obligation_cause.span);\n \n         let obligation_trait_ref = obligation_trait_ref.clone();\n-        match self.infcx.sub_poly_trait_refs(false,\n-                                             origin,\n-                                             expected_trait_ref.clone(),\n-                                             obligation_trait_ref.clone()) {\n-            Ok(()) => Ok(()),\n-            Err(e) => Err(OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n-        }\n+        self.infcx.sub_poly_trait_refs(false,\n+                                       origin,\n+                                       expected_trait_ref.clone(),\n+                                       obligation_trait_ref.clone())\n+            // FIXME(#32730) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+            .map_err(|e| OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n     }\n \n     fn confirm_builtin_unsize_candidate(&mut self,\n@@ -2524,9 +2531,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 let new_trait = tcx.mk_trait(data_a.principal.clone(), bounds);\n                 let origin = TypeOrigin::Misc(obligation.cause.span);\n-                if self.infcx.sub_types(false, origin, new_trait, target).is_err() {\n-                    return Err(Unimplemented);\n-                }\n+                let InferOk { obligations, .. } =\n+                    self.infcx.sub_types(false, origin, new_trait, target)\n+                    .map_err(|_| Unimplemented)?;\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty());\n \n                 // Register one obligation for 'a: 'b.\n                 let cause = ObligationCause::new(obligation.cause.span,\n@@ -2589,9 +2598,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // [T; n] -> [T].\n             (&ty::TyArray(a, _), &ty::TySlice(b)) => {\n                 let origin = TypeOrigin::Misc(obligation.cause.span);\n-                if self.infcx.sub_types(false, origin, a, b).is_err() {\n-                    return Err(Unimplemented);\n-                }\n+                let InferOk { obligations, .. } =\n+                    self.infcx.sub_types(false, origin, a, b)\n+                    .map_err(|_| Unimplemented)?;\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty());\n             }\n \n             // Struct<T> -> Struct<U>.\n@@ -2647,9 +2658,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n                 let new_struct = tcx.mk_struct(def, tcx.mk_substs(new_substs));\n                 let origin = TypeOrigin::Misc(obligation.cause.span);\n-                if self.infcx.sub_types(false, origin, new_struct, target).is_err() {\n-                    return Err(Unimplemented);\n-                }\n+                let InferOk { obligations, .. } =\n+                    self.infcx.sub_types(false, origin, new_struct, target)\n+                    .map_err(|_| Unimplemented)?;\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty());\n \n                 // Construct the nested Field<T>: Unsize<Field<U>> predicate.\n                 nested.push(util::predicate_for_trait_def(tcx,\n@@ -2734,13 +2747,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                skol_obligation_trait_ref);\n \n         let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n-        if let Err(e) = self.infcx.eq_trait_refs(false,\n-                                                 origin,\n-                                                 impl_trait_ref.value.clone(),\n-                                                 skol_obligation_trait_ref) {\n-            debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e);\n-            return Err(());\n-        }\n+        let InferOk { obligations, .. } =\n+            self.infcx.eq_trait_refs(false,\n+                                     origin,\n+                                     impl_trait_ref.value.clone(),\n+                                     skol_obligation_trait_ref)\n+            .map_err(|e| {\n+                debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e);\n+                ()\n+            })?;\n+        // FIXME(#32730) propagate obligations\n+        assert!(obligations.is_empty());\n \n         if let Err(e) = self.infcx.leak_check(&skol_map, snapshot) {\n             debug!(\"match_impl: failed leak check due to `{}`\", e);\n@@ -2803,13 +2820,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                poly_trait_ref);\n \n         let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n-        match self.infcx.sub_poly_trait_refs(false,\n-                                             origin,\n-                                             poly_trait_ref,\n-                                             obligation.predicate.to_poly_trait_ref()) {\n-            Ok(()) => Ok(()),\n-            Err(_) => Err(()),\n-        }\n+        self.infcx.sub_poly_trait_refs(false,\n+                                       origin,\n+                                       poly_trait_ref,\n+                                       obligation.predicate.to_poly_trait_ref())\n+            // FIXME(#32730) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+            .map_err(|_| ())\n     }\n \n     ///////////////////////////////////////////////////////////////////////////"}, {"sha": "54223e16e17c5e0355605e81d1581bfb888f8002", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -116,21 +116,9 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n pub trait TypeFolder<'tcx> : Sized {\n     fn tcx<'a>(&'a self) -> &'a TyCtxt<'tcx>;\n \n-    /// Invoked by the `super_*` routines when we enter a region\n-    /// binding level (for example, when entering a function\n-    /// signature). This is used by clients that want to track the\n-    /// Debruijn index nesting level.\n-    fn enter_region_binder(&mut self) { }\n-\n-    /// Invoked by the `super_*` routines when we exit a region\n-    /// binding level. This is used by clients that want to\n-    /// track the Debruijn index nesting level.\n-    fn exit_region_binder(&mut self) { }\n-\n     fn fold_binder<T>(&mut self, t: &Binder<T>) -> Binder<T>\n         where T : TypeFoldable<'tcx>\n     {\n-        // FIXME(#20526) this should replace `enter_region_binder`/`exit_region_binder`.\n         t.super_fold_with(self)\n     }\n \n@@ -197,8 +185,9 @@ pub trait TypeFolder<'tcx> : Sized {\n }\n \n pub trait TypeVisitor<'tcx> : Sized {\n-    fn enter_region_binder(&mut self) { }\n-    fn exit_region_binder(&mut self) { }\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> bool {\n+        t.super_visit_with(self)\n+    }\n \n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n         t.super_visit_with(self)\n@@ -296,12 +285,11 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n {\n     fn tcx(&self) -> &TyCtxt<'tcx> { self.tcx }\n \n-    fn enter_region_binder(&mut self) {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.current_depth += 1;\n-    }\n-\n-    fn exit_region_binder(&mut self) {\n+        let t = t.super_fold_with(self);\n         self.current_depth -= 1;\n+        t\n     }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n@@ -438,12 +426,11 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n {\n     fn tcx(&self) -> &TyCtxt<'tcx> { self.tcx }\n \n-    fn enter_region_binder(&mut self) {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.current_depth += 1;\n-    }\n-\n-    fn exit_region_binder(&mut self) {\n+        let t = t.super_fold_with(self);\n         self.current_depth -= 1;\n+        t\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n@@ -596,12 +583,11 @@ struct HasEscapingRegionsVisitor {\n }\n \n impl<'tcx> TypeVisitor<'tcx> for HasEscapingRegionsVisitor {\n-    fn enter_region_binder(&mut self) {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> bool {\n         self.depth += 1;\n-    }\n-\n-    fn exit_region_binder(&mut self) {\n+        let result = t.super_visit_with(self);\n         self.depth -= 1;\n+        result\n     }\n \n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {"}, {"sha": "82cc9e7f2e3db91c3a52c7b46b846d93ae8780d5", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 8, "deletions": 38, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -190,21 +190,19 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n \n impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.enter_region_binder();\n-        let result = ty::Binder(self.0.fold_with(folder));\n-        folder.exit_region_binder();\n-        result\n+        ty::Binder(self.0.fold_with(folder))\n     }\n \n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_binder(self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        visitor.enter_region_binder();\n-        if self.0.visit_with(visitor) { return true }\n-        visitor.exit_region_binder();\n-        false\n+        self.0.visit_with(visitor)\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        visitor.visit_binder(self)\n     }\n }\n \n@@ -220,39 +218,11 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for P<[T]> {\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for VecPerParamSpace<T> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-\n-        // Things in the Fn space take place under an additional level\n-        // of region binding relative to the other spaces. This is\n-        // because those entries are attached to a method, and methods\n-        // always introduce a level of region binding.\n-\n-        let result = self.map_enumerated(|(space, index, elem)| {\n-            if space == subst::FnSpace && index == 0 {\n-                // enter new level when/if we reach the first thing in fn space\n-                folder.enter_region_binder();\n-            }\n-            elem.fold_with(folder)\n-        });\n-        if result.len(subst::FnSpace) > 0 {\n-            // if there was anything in fn space, exit the region binding level\n-            folder.exit_region_binder();\n-        }\n-        result\n+        self.map(|elem| elem.fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        let mut entered_region_binder = false;\n-        let result = self.iter_enumerated().any(|(space, index, t)| {\n-            if space == subst::FnSpace && index == 0 {\n-                visitor.enter_region_binder();\n-                entered_region_binder = true;\n-            }\n-            t.visit_with(visitor)\n-        });\n-        if entered_region_binder {\n-            visitor.exit_region_binder();\n-        }\n-        result\n+        self.iter().any(|elem| elem.visit_with(visitor))\n     }\n }\n "}, {"sha": "93157f28482a54d1d2af8a3f194bbe94679f3655", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -582,12 +582,11 @@ struct SubstFolder<'a, 'tcx: 'a> {\n impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n     fn tcx(&self) -> &TyCtxt<'tcx> { self.tcx }\n \n-    fn enter_region_binder(&mut self) {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.region_binders_passed += 1;\n-    }\n-\n-    fn exit_region_binder(&mut self) {\n+        let t = t.super_fold_with(self);\n         self.region_binders_passed -= 1;\n+        t\n     }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {"}, {"sha": "5a00b4573decfdf0e16bb96949e5cb48905d5a43", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -343,10 +343,15 @@ pub fn eval_const_expr(tcx: &TyCtxt, e: &Expr) -> ConstVal {\n     match eval_const_expr_partial(tcx, e, ExprTypeChecked, None) {\n         Ok(r) => r,\n         // non-const path still needs to be a fatal error, because enums are funky\n-        Err(ref s) if s.kind == NonConstPath => tcx.sess.span_fatal(s.span, &s.description()),\n         Err(s) => {\n-            tcx.sess.span_err(s.span, &s.description());\n-            Dummy\n+            match s.kind {\n+                NonConstPath |\n+                UnimplementedConstVal(_) => tcx.sess.span_fatal(s.span, &s.description()),\n+                _ => {\n+                    tcx.sess.span_err(s.span, &s.description());\n+                    Dummy\n+                }\n+            }\n         },\n     }\n }\n@@ -607,6 +612,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n           const_val => signal!(e, NotOn(const_val)),\n         }\n       }\n+      hir::ExprUnary(hir::UnDeref, _) => signal!(e, UnimplementedConstVal(\"deref operation\")),\n       hir::ExprBinary(op, ref a, ref b) => {\n         let b_ty = match op.node {\n             hir::BiShl | hir::BiShr => ty_hint.erase_hint(),\n@@ -745,7 +751,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n                   if let Some(const_expr) = lookup_variant_by_id(tcx, enum_def, variant_def) {\n                       eval_const_expr_partial(tcx, const_expr, ty_hint, None)?\n                   } else {\n-                      signal!(e, NonConstPath);\n+                      signal!(e, UnimplementedConstVal(\"enum variants\"));\n                   }\n               }\n               Def::Struct(..) => {\n@@ -768,6 +774,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n           let callee_val = eval_const_expr_partial(tcx, callee, sub_ty_hint, fn_args)?;\n           let did = match callee_val {\n               Function(did) => did,\n+              Struct(_) => signal!(e, UnimplementedConstVal(\"tuple struct constructors\")),\n               callee => signal!(e, CallOn(callee)),\n           };\n           let (decl, result) = if let Some(fn_like) = lookup_const_fn_by_id(tcx, did) {\n@@ -798,7 +805,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => eval_const_expr_partial(tcx, &expr, ty_hint, fn_args)?,\n-            None => bug!(),\n+            None => signal!(e, UnimplementedConstVal(\"empty block\")),\n         }\n       }\n       hir::ExprType(ref e, _) => eval_const_expr_partial(tcx, &e, ty_hint, fn_args)?,\n@@ -840,7 +847,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n             },\n \n             Str(ref s) if idx as usize >= s.len() => signal!(e, IndexOutOfBounds),\n-            Str(_) => bug!(\"unimplemented\"), // FIXME: return a const char\n+            // FIXME: return a const char\n+            Str(_) => signal!(e, UnimplementedConstVal(\"indexing into str\")),\n             _ => signal!(e, IndexedNonVec),\n         }\n       }\n@@ -894,6 +902,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n             signal!(base, ExpectedConstStruct);\n         }\n       }\n+      hir::ExprAddrOf(..) => signal!(e, UnimplementedConstVal(\"address operator\")),\n       _ => signal!(e, MiscCatchAll)\n     };\n \n@@ -1073,6 +1082,7 @@ fn cast_const_int<'tcx>(tcx: &TyCtxt<'tcx>, val: ConstInt, ty: ty::Ty) -> CastRe\n             Ok(Float(val as f64))\n         },\n         ty::TyFloat(ast::FloatTy::F32) => Ok(Float(val.to_u64().unwrap() as f32 as f64)),\n+        ty::TyRawPtr(_) => Err(ErrKind::UnimplementedConstVal(\"casting an address to a raw ptr\")),\n         _ => Err(CannotCast),\n     }\n }\n@@ -1094,6 +1104,7 @@ fn cast_const<'tcx>(tcx: &TyCtxt<'tcx>, val: ConstVal, ty: ty::Ty) -> CastResult\n         Bool(b) => cast_const_int(tcx, Infer(b as u64), ty),\n         Float(f) => cast_const_float(tcx, f, ty),\n         Char(c) => cast_const_int(tcx, Infer(c as u64), ty),\n+        Function(_) => Err(UnimplementedConstVal(\"casting fn pointers\")),\n         _ => Err(CannotCast),\n     }\n }"}, {"sha": "ce0d42203b987baf56ebe03fe2d0e3e64adb98df", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -24,8 +24,8 @@ use rustc::ty::subst;\n use rustc::ty::subst::Subst;\n use rustc::traits::ProjectionMode;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::relate::{TypeRelation, RelateResult};\n-use rustc::infer::{self, TypeOrigin};\n+use rustc::ty::relate::TypeRelation;\n+use rustc::infer::{self, InferOk, InferResult, TypeOrigin};\n use rustc_metadata::cstore::CStore;\n use rustc::front::map as hir_map;\n use rustc::session::{self, config};\n@@ -355,17 +355,17 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         infer::TypeTrace::dummy(self.tcx())\n     }\n \n-    pub fn sub(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+    pub fn sub(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n         self.infcx.sub(true, trace, t1, t2)\n     }\n \n-    pub fn lub(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+    pub fn lub(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n         self.infcx.lub(true, trace, t1, t2)\n     }\n \n-    pub fn glb(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+    pub fn glb(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n         self.infcx.glb(true, trace, t1, t2)\n     }\n@@ -374,7 +374,10 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// region checks).\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n         match self.sub(&t1, &t2) {\n-            Ok(_) => {}\n+            Ok(InferOk { obligations, .. }) => {\n+                // FIXME(#32730) once obligations are being propagated, assert the right thing.\n+                assert!(obligations.is_empty());\n+            }\n             Err(ref e) => {\n                 panic!(\"unexpected error computing sub({:?},{:?}): {}\", t1, t2, e);\n             }\n@@ -395,7 +398,10 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// Checks that `LUB(t1,t2) == t_lub`\n     pub fn check_lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_lub: Ty<'tcx>) {\n         match self.lub(&t1, &t2) {\n-            Ok(t) => {\n+            Ok(InferOk { obligations, value: t }) => {\n+                // FIXME(#32730) once obligations are being propagated, assert the right thing.\n+                assert!(obligations.is_empty());\n+\n                 self.assert_eq(t, t_lub);\n             }\n             Err(ref e) => {\n@@ -411,7 +417,10 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n             Err(e) => {\n                 panic!(\"unexpected error computing LUB: {:?}\", e)\n             }\n-            Ok(t) => {\n+            Ok(InferOk { obligations, value: t }) => {\n+                // FIXME(#32730) once obligations are being propagated, assert the right thing.\n+                assert!(obligations.is_empty());\n+\n                 self.assert_eq(t, t_glb);\n \n                 // sanity check for good measure:"}, {"sha": "0780e4cd04834ff2f6437808f40b1db2a13fdadf", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -167,6 +167,10 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(INVALID_TYPE_PARAM_DEFAULT),\n             reference: \"PR 30742 <https://github.com/rust-lang/rust/pull/30724>\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(SUPER_OR_SELF_IN_GLOBAL_PATH),\n+            reference: \"PR #32403 <https://github.com/rust-lang/rust/pull/32403>\",\n+        },\n         FutureIncompatibleInfo {\n             id: LintId::of(MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT),\n             reference: \"RFC 218 <https://github.com/rust-lang/rfcs/blob/\\"}, {"sha": "ce8ede7f4b9592be12d82a5caf829bc507c81e67", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -12,7 +12,7 @@\n #![allow(unreachable_code)]\n \n use rustc::dep_graph::DepNode;\n-use rustc::infer::{self, InferCtxt};\n+use rustc::infer::{self, InferCtxt, InferOk};\n use rustc::traits::{self, ProjectionMode};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -338,13 +338,17 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     {\n         infer::mk_subty(self.infcx, false, infer::TypeOrigin::Misc(span),\n                         sup, sub)\n+            // FIXME(#32730) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n     fn mk_eqty(&self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>)\n                 -> infer::UnitResult<'tcx>\n     {\n         infer::mk_eqty(self.infcx, false, infer::TypeOrigin::Misc(span),\n                        a, b)\n+            // FIXME(#32730) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n     fn tcx(&self) -> &'a TyCtxt<'tcx> {"}, {"sha": "ba5d8ef45b621554d615e640a93198aa923c52ac", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -28,7 +28,7 @@ use rustc::dep_graph::DepNode;\n use rustc::ty::cast::{CastKind};\n use rustc_const_eval::{ConstEvalErr, lookup_const_fn_by_id, compare_lit_exprs};\n use rustc_const_eval::{eval_const_expr_partial, lookup_const_by_id};\n-use rustc_const_eval::ErrKind::IndexOpFeatureGated;\n+use rustc_const_eval::ErrKind::{IndexOpFeatureGated, UnimplementedConstVal};\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc::middle::def::Def;\n use rustc::middle::def_id::DefId;\n@@ -110,6 +110,16 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n                 entry.insert(ConstQualif::empty());\n             }\n         }\n+        if let Err(err) = eval_const_expr_partial(self.tcx, expr, ExprTypeChecked, None) {\n+            match err.kind {\n+                UnimplementedConstVal(_) => {},\n+                IndexOpFeatureGated => {},\n+                _ => self.tcx.sess.add_lint(CONST_ERR, expr.id, expr.span,\n+                                         format!(\"constant evaluation error: {}. This will \\\n+                                                 become a HARD ERROR in the future\",\n+                                                 err.description())),\n+            }\n+        }\n         self.with_mode(mode, |this| {\n             this.with_euv(None, |euv| euv.consume_expr(expr));\n             this.visit_expr(expr);\n@@ -435,6 +445,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                             match eval_const_expr_partial(\n                                     self.tcx, ex, ExprTypeChecked, None) {\n                                 Ok(_) => {}\n+                                Err(ConstEvalErr { kind: UnimplementedConstVal(_), ..}) |\n                                 Err(ConstEvalErr { kind: IndexOpFeatureGated, ..}) => {},\n                                 Err(msg) => {\n                                     self.tcx.sess.add_lint(CONST_ERR, ex.id,"}, {"sha": "f36a8269dc002290d83bec2e34d835ef1b64e9c8", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 26, "deletions": 44, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -14,8 +14,7 @@\n //! any imports resolved.\n \n use DefModifiers;\n-use resolve_imports::ImportDirective;\n-use resolve_imports::ImportDirectiveSubclass::{self, SingleImport, GlobImport};\n+use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n use {NameBinding, NameBindingKind};\n@@ -24,13 +23,14 @@ use Resolver;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n use rustc::middle::cstore::{CrateStore, ChildItem, DlDef};\n+use rustc::lint;\n use rustc::middle::def::*;\n use rustc::middle::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::ty::VariantKind;\n \n-use syntax::ast::{Name, NodeId};\n+use syntax::ast::Name;\n use syntax::attr::AttrMetaMethods;\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::{special_idents, SELF_KEYWORD_NAME, SUPER_KEYWORD_NAME};\n use syntax::codemap::{Span, DUMMY_SP};\n \n use rustc_front::hir;\n@@ -117,8 +117,10 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                 // Extract and intern the module part of the path. For\n                 // globs and lists, the path is found directly in the AST;\n                 // for simple paths we have to munge the path a little.\n-                let module_path = match view_path.node {\n+                let is_global;\n+                let module_path: Vec<Name> = match view_path.node {\n                     ViewPathSimple(_, ref full_path) => {\n+                        is_global = full_path.global;\n                         full_path.segments\n                                  .split_last()\n                                  .unwrap()\n@@ -130,13 +132,26 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n \n                     ViewPathGlob(ref module_ident_path) |\n                     ViewPathList(ref module_ident_path, _) => {\n+                        is_global = module_ident_path.global;\n                         module_ident_path.segments\n                                          .iter()\n                                          .map(|seg| seg.identifier.name)\n                                          .collect()\n                     }\n                 };\n \n+                // Checking for special identifiers in path\n+                // prevent `self` or `super` at beginning of global path\n+                if is_global && (module_path.first() == Some(&SELF_KEYWORD_NAME) ||\n+                                 module_path.first() == Some(&SUPER_KEYWORD_NAME)) {\n+                    self.session.add_lint(\n+                        lint::builtin::SUPER_OR_SELF_IN_GLOBAL_PATH,\n+                        item.id,\n+                        item.span,\n+                        format!(\"expected identifier, found keyword `{}`\",\n+                                module_path.first().unwrap().as_str()));\n+                }\n+\n                 // Build up the import directives.\n                 let is_prelude = item.attrs.iter().any(|attr| {\n                     attr.name() == special_idents::prelude_import.name.as_str()\n@@ -152,8 +167,8 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                         }\n \n                         let subclass = ImportDirectiveSubclass::single(binding, source_name);\n-                        self.build_import_directive(parent,\n-                                                    module_path,\n+                        self.unresolved_imports += 1;\n+                        parent.add_import_directive(module_path,\n                                                     subclass,\n                                                     view_path.span,\n                                                     item.id,\n@@ -203,8 +218,8 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                                 }\n                             };\n                             let subclass = ImportDirectiveSubclass::single(rename, name);\n-                            self.build_import_directive(parent,\n-                                                        module_path,\n+                            self.unresolved_imports += 1;\n+                            parent.add_import_directive(module_path,\n                                                         subclass,\n                                                         source_item.span,\n                                                         source_item.node.id(),\n@@ -213,8 +228,8 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n                         }\n                     }\n                     ViewPathGlob(_) => {\n-                        self.build_import_directive(parent,\n-                                                    module_path,\n+                        self.unresolved_imports += 1;\n+                        parent.add_import_directive(module_path,\n                                                     GlobImport,\n                                                     view_path.span,\n                                                     item.id,\n@@ -521,39 +536,6 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n         }\n     }\n \n-    /// Creates and adds an import directive to the given module.\n-    fn build_import_directive(&mut self,\n-                              module_: Module<'b>,\n-                              module_path: Vec<Name>,\n-                              subclass: ImportDirectiveSubclass,\n-                              span: Span,\n-                              id: NodeId,\n-                              is_public: bool,\n-                              is_prelude: bool) {\n-        // Bump the reference count on the name. Or, if this is a glob, set\n-        // the appropriate flag.\n-\n-        match subclass {\n-            SingleImport { target, .. } => {\n-                module_.increment_outstanding_references_for(target, ValueNS, is_public);\n-                module_.increment_outstanding_references_for(target, TypeNS, is_public);\n-            }\n-            GlobImport if !is_prelude => {\n-                // Set the glob flag. This tells us that we don't know the\n-                // module's exports ahead of time.\n-                module_.inc_glob_count(is_public)\n-            }\n-            // Prelude imports are not included in the glob counts since they do not get added to\n-            // `resolved_globs` -- they are handled separately in `resolve_imports`.\n-            GlobImport => {}\n-        }\n-\n-        let directive =\n-            ImportDirective::new(module_path, subclass, span, id, is_public, is_prelude);\n-        module_.add_import_directive(directive);\n-        self.unresolved_imports += 1;\n-    }\n-\n     /// Ensures that the reduced graph rooted at the given external module\n     /// is built, building it if it is not.\n     pub fn populate_module_if_necessary(&mut self, module: Module<'b>) {"}, {"sha": "98e40d73133278be38e91f8708f07295c6d55242", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -828,8 +828,8 @@ pub struct ModuleS<'a> {\n     // is the NodeId of the local `extern crate` item (otherwise, `extern_crate_id` is None).\n     extern_crate_id: Option<NodeId>,\n \n-    resolutions: RefCell<HashMap<(Name, Namespace), NameResolution<'a>>>,\n-    unresolved_imports: RefCell<Vec<&'a ImportDirective>>,\n+    resolutions: RefCell<HashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n+    unresolved_imports: RefCell<Vec<&'a ImportDirective<'a>>>,\n \n     // The module children of this node, including normal modules and anonymous modules.\n     // Anonymous children are pseudo-modules that are implicitly created around items\n@@ -849,14 +849,8 @@ pub struct ModuleS<'a> {\n \n     prelude: RefCell<Option<Module<'a>>>,\n \n-    glob_importers: RefCell<Vec<(Module<'a>, &'a ImportDirective)>>,\n-    resolved_globs: RefCell<(Vec<Module<'a>> /* public */, Vec<Module<'a>> /* private */)>,\n-\n-    // The number of public glob imports in this module.\n-    public_glob_count: Cell<usize>,\n-\n-    // The number of private glob imports in this module.\n-    private_glob_count: Cell<usize>,\n+    glob_importers: RefCell<Vec<(Module<'a>, &'a ImportDirective<'a>)>>,\n+    globs: RefCell<Vec<&'a ImportDirective<'a>>>,\n \n     // Whether this module is populated. If not populated, any attempt to\n     // access the children must be preceded with a\n@@ -884,22 +878,15 @@ impl<'a> ModuleS<'a> {\n             module_children: RefCell::new(NodeMap()),\n             prelude: RefCell::new(None),\n             glob_importers: RefCell::new(Vec::new()),\n-            resolved_globs: RefCell::new((Vec::new(), Vec::new())),\n-            public_glob_count: Cell::new(0),\n-            private_glob_count: Cell::new(0),\n+            globs: RefCell::new((Vec::new())),\n             populated: Cell::new(!external),\n             arenas: arenas\n         }\n     }\n \n-    fn add_import_directive(&self, import_directive: ImportDirective) {\n-        let import_directive = self.arenas.alloc_import_directive(import_directive);\n-        self.unresolved_imports.borrow_mut().push(import_directive);\n-    }\n-\n     fn for_each_child<F: FnMut(Name, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n         for (&(name, ns), name_resolution) in self.resolutions.borrow().iter() {\n-            name_resolution.binding.map(|binding| f(name, ns, binding));\n+            name_resolution.borrow().binding.map(|binding| f(name, ns, binding));\n         }\n     }\n \n@@ -929,11 +916,6 @@ impl<'a> ModuleS<'a> {\n             _ => false,\n         }\n     }\n-\n-    fn inc_glob_count(&self, is_public: bool) {\n-        let glob_count = if is_public { &self.public_glob_count } else { &self.private_glob_count };\n-        glob_count.set(glob_count.get() + 1);\n-    }\n }\n \n impl<'a> fmt::Debug for ModuleS<'a> {\n@@ -1135,7 +1117,8 @@ pub struct Resolver<'a, 'tcx: 'a> {\n struct ResolverArenas<'a> {\n     modules: arena::TypedArena<ModuleS<'a>>,\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n-    import_directives: arena::TypedArena<ImportDirective>,\n+    import_directives: arena::TypedArena<ImportDirective<'a>>,\n+    name_resolutions: arena::TypedArena<RefCell<NameResolution<'a>>>,\n }\n \n impl<'a> ResolverArenas<'a> {\n@@ -1145,9 +1128,13 @@ impl<'a> ResolverArenas<'a> {\n     fn alloc_name_binding(&'a self, name_binding: NameBinding<'a>) -> &'a NameBinding<'a> {\n         self.name_bindings.alloc(name_binding)\n     }\n-    fn alloc_import_directive(&'a self, import_directive: ImportDirective) -> &'a ImportDirective {\n+    fn alloc_import_directive(&'a self, import_directive: ImportDirective<'a>)\n+                              -> &'a ImportDirective {\n         self.import_directives.alloc(import_directive)\n     }\n+    fn alloc_name_resolution(&'a self) -> &'a RefCell<NameResolution<'a>> {\n+        self.name_resolutions.alloc(Default::default())\n+    }\n }\n \n #[derive(PartialEq)]\n@@ -1216,6 +1203,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             modules: arena::TypedArena::new(),\n             name_bindings: arena::TypedArena::new(),\n             import_directives: arena::TypedArena::new(),\n+            name_resolutions: arena::TypedArena::new(),\n         }\n     }\n "}, {"sha": "2aa8925fb54b58be6ce79fa23e7f30f34b457a3e", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 174, "deletions": 133, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -30,7 +30,7 @@ use syntax::codemap::Span;\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use std::mem::replace;\n-use std::cell::Cell;\n+use std::cell::{Cell, RefCell};\n \n /// Contains data for specific types of import directives.\n #[derive(Clone, Debug)]\n@@ -57,38 +57,21 @@ impl ImportDirectiveSubclass {\n \n /// One import directive.\n #[derive(Debug,Clone)]\n-pub struct ImportDirective {\n+pub struct ImportDirective<'a> {\n     module_path: Vec<Name>,\n+    target_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n     subclass: ImportDirectiveSubclass,\n     span: Span,\n     id: NodeId,\n     is_public: bool, // see note in ImportResolutionPerNamespace about how to use this\n     is_prelude: bool,\n }\n \n-impl ImportDirective {\n-    pub fn new(module_path: Vec<Name>,\n-               subclass: ImportDirectiveSubclass,\n-               span: Span,\n-               id: NodeId,\n-               is_public: bool,\n-               is_prelude: bool)\n-               -> ImportDirective {\n-        ImportDirective {\n-            module_path: module_path,\n-            subclass: subclass,\n-            span: span,\n-            id: id,\n-            is_public: is_public,\n-            is_prelude: is_prelude,\n-        }\n-    }\n-\n+impl<'a> ImportDirective<'a> {\n     // Given the binding to which this directive resolves in a particular namespace,\n     // this returns the binding for the name this directive defines in that namespace.\n-    fn import<'a>(&self,\n-                  binding: &'a NameBinding<'a>,\n-                  privacy_error: Option<Box<PrivacyError<'a>>>) -> NameBinding<'a> {\n+    fn import(&self, binding: &'a NameBinding<'a>, privacy_error: Option<Box<PrivacyError<'a>>>)\n+              -> NameBinding<'a> {\n         let mut modifiers = match self.is_public {\n             true => DefModifiers::PUBLIC | DefModifiers::IMPORTABLE,\n             false => DefModifiers::empty(),\n@@ -110,17 +93,52 @@ impl ImportDirective {\n }\n \n #[derive(Clone, Default)]\n-/// Records information about the resolution of a name in a module.\n+/// Records information about the resolution of a name in a namespace of a module.\n pub struct NameResolution<'a> {\n-    /// The number of unresolved single imports of any visibility that could define the name.\n-    outstanding_references: u32,\n-    /// The number of unresolved `pub` single imports that could define the name.\n-    pub_outstanding_references: u32,\n+    /// The single imports that define the name in the namespace.\n+    single_imports: SingleImports<'a>,\n     /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n     duplicate_globs: Vec<&'a NameBinding<'a>>,\n }\n \n+#[derive(Clone, Debug)]\n+enum SingleImports<'a> {\n+    /// No single imports can define the name in the namespace.\n+    None,\n+    /// Only the given single import can define the name in the namespace.\n+    MaybeOne(&'a ImportDirective<'a>),\n+    /// At least one single import will define the name in the namespace.\n+    AtLeastOne,\n+}\n+\n+impl<'a> Default for SingleImports<'a> {\n+    fn default() -> Self {\n+        SingleImports::None\n+    }\n+}\n+\n+impl<'a> SingleImports<'a> {\n+    fn add_directive(&mut self, directive: &'a ImportDirective<'a>) {\n+        match *self {\n+            SingleImports::None => *self = SingleImports::MaybeOne(directive),\n+            // If two single imports can define the name in the namespace, we can assume that at\n+            // least one of them will define it since otherwise both would have to define only one\n+            // namespace, leading to a duplicate error.\n+            SingleImports::MaybeOne(_) => *self = SingleImports::AtLeastOne,\n+            SingleImports::AtLeastOne => {}\n+        };\n+    }\n+\n+    fn directive_failed(&mut self) {\n+        match *self {\n+            SingleImports::None => unreachable!(),\n+            SingleImports::MaybeOne(_) => *self = SingleImports::None,\n+            SingleImports::AtLeastOne => {}\n+        }\n+    }\n+}\n+\n impl<'a> NameResolution<'a> {\n     fn try_define(&mut self, binding: &'a NameBinding<'a>) -> Result<(), &'a NameBinding<'a>> {\n         if let Some(old_binding) = self.binding {\n@@ -139,40 +157,54 @@ impl<'a> NameResolution<'a> {\n         Ok(())\n     }\n \n+    // Returns the binding for the name if it is known or None if it not known.\n+    fn binding(&self) -> Option<&'a NameBinding<'a>> {\n+        self.binding.and_then(|binding| match self.single_imports {\n+            SingleImports::None => Some(binding),\n+            _ if !binding.defined_with(DefModifiers::GLOB_IMPORTED) => Some(binding),\n+            _ => None, // The binding could be shadowed by a single import, so it is not known.\n+        })\n+    }\n+\n     // Returns Some(the resolution of the name), or None if the resolution depends\n     // on whether more globs can define the name.\n-    fn try_result(&self, allow_private_imports: bool)\n+    fn try_result(&self, ns: Namespace, allow_private_imports: bool)\n                   -> Option<ResolveResult<&'a NameBinding<'a>>> {\n         match self.binding {\n             Some(binding) if !binding.defined_with(DefModifiers::GLOB_IMPORTED) =>\n-                Some(Success(binding)),\n-            // If (1) we don't allow private imports, (2) no public single import can define the\n-            // name, and (3) no public glob has defined the name, the resolution depends on globs.\n-            _ if !allow_private_imports && self.pub_outstanding_references == 0 &&\n-                 !self.binding.map(NameBinding::is_public).unwrap_or(false) => None,\n-            _ if self.outstanding_references > 0 => Some(Indeterminate),\n-            Some(binding) => Some(Success(binding)),\n-            None => None,\n-        }\n-    }\n-\n-    fn increment_outstanding_references(&mut self, is_public: bool) {\n-        self.outstanding_references += 1;\n-        if is_public {\n-            self.pub_outstanding_references += 1;\n-        }\n-    }\n-\n-    fn decrement_outstanding_references(&mut self, is_public: bool) {\n-        let decrement_references = |count: &mut _| {\n-            assert!(*count > 0);\n-            *count -= 1;\n+                return Some(Success(binding)),\n+            _ => {} // Items and single imports are not shadowable\n         };\n \n-        decrement_references(&mut self.outstanding_references);\n-        if is_public {\n-            decrement_references(&mut self.pub_outstanding_references);\n+        // Check if a single import can still define the name.\n+        match self.single_imports {\n+            SingleImports::None => {},\n+            SingleImports::AtLeastOne => return Some(Indeterminate),\n+            SingleImports::MaybeOne(directive) => {\n+                // If (1) we don't allow private imports, (2) no public single import can define\n+                // the name, and (3) no public glob has defined the name, the resolution depends\n+                // on whether more globs can define the name.\n+                if !allow_private_imports && !directive.is_public &&\n+                   !self.binding.map(NameBinding::is_public).unwrap_or(false) {\n+                    return None;\n+                }\n+\n+                let target_module = match directive.target_module.get() {\n+                    Some(target_module) => target_module,\n+                    None => return Some(Indeterminate),\n+                };\n+                let name = match directive.subclass {\n+                    SingleImport { source, .. } => source,\n+                    GlobImport => unreachable!(),\n+                };\n+                match target_module.resolve_name(name, ns, false) {\n+                    Failed(_) => {}\n+                    _ => return Some(Indeterminate),\n+                }\n+            }\n         }\n+\n+        self.binding.map(Success)\n     }\n \n     fn report_conflicts<F: FnMut(&NameBinding, &NameBinding)>(&self, mut report: F) {\n@@ -195,45 +227,36 @@ impl<'a> NameResolution<'a> {\n }\n \n impl<'a> ::ModuleS<'a> {\n+    fn resolution(&self, name: Name, ns: Namespace) -> &'a RefCell<NameResolution<'a>> {\n+        *self.resolutions.borrow_mut().entry((name, ns))\n+             .or_insert_with(|| self.arenas.alloc_name_resolution())\n+    }\n+\n     pub fn resolve_name(&self, name: Name, ns: Namespace, allow_private_imports: bool)\n                         -> ResolveResult<&'a NameBinding<'a>> {\n-        let resolutions = match self.resolutions.borrow_state() {\n-            ::std::cell::BorrowState::Unused => self.resolutions.borrow(),\n-            _ => return Failed(None), // This happens when there is a cycle of glob imports\n+        let resolution = self.resolution(name, ns);\n+        let resolution = match resolution.borrow_state() {\n+            ::std::cell::BorrowState::Unused => resolution.borrow_mut(),\n+            _ => return Failed(None), // This happens when there is a cycle of imports\n         };\n \n-        let resolution = resolutions.get(&(name, ns)).cloned().unwrap_or_default();\n-        if let Some(result) = resolution.try_result(allow_private_imports) {\n+        if let Some(result) = resolution.try_result(ns, allow_private_imports) {\n             // If the resolution doesn't depend on glob definability, check privacy and return.\n             return result.and_then(|binding| {\n                 let allowed = allow_private_imports || !binding.is_import() || binding.is_public();\n                 if allowed { Success(binding) } else { Failed(None) }\n             });\n         }\n \n-        let (ref mut public_globs, ref mut private_globs) = *self.resolved_globs.borrow_mut();\n-\n-        // Check if the public globs are determined\n-        if public_globs.len() < self.public_glob_count.get() {\n-            return Indeterminate;\n-        }\n-        for module in public_globs.iter() {\n-            if let Indeterminate = module.resolve_name(name, ns, false) {\n-                return Indeterminate;\n-            }\n-        }\n-\n-        if !allow_private_imports {\n-            return Failed(None);\n-        }\n-\n-        // Check if the private globs are determined\n-        if private_globs.len() < self.private_glob_count.get() {\n-            return Indeterminate;\n-        }\n-        for module in private_globs.iter() {\n-            if let Indeterminate = module.resolve_name(name, ns, false) {\n-                return Indeterminate;\n+        // Check if the globs are determined\n+        for directive in self.globs.borrow().iter() {\n+            if !allow_private_imports && !directive.is_public { continue }\n+            match directive.target_module.get() {\n+                None => return Indeterminate,\n+                Some(target_module) => match target_module.resolve_name(name, ns, false) {\n+                    Indeterminate => return Indeterminate,\n+                    _ => {}\n+                }\n             }\n         }\n \n@@ -243,7 +266,7 @@ impl<'a> ::ModuleS<'a> {\n     // Invariant: this may not be called until import resolution is complete.\n     pub fn resolve_name_in_lexical_scope(&self, name: Name, ns: Namespace)\n                                          -> Option<&'a NameBinding<'a>> {\n-        self.resolutions.borrow().get(&(name, ns)).and_then(|resolution| resolution.binding)\n+        self.resolution(name, ns).borrow().binding\n             .or_else(|| self.prelude.borrow().and_then(|prelude| {\n                 prelude.resolve_name(name, ns, false).success()\n             }))\n@@ -258,23 +281,49 @@ impl<'a> ::ModuleS<'a> {\n         })\n     }\n \n-    pub fn increment_outstanding_references_for(&self, name: Name, ns: Namespace, is_public: bool) {\n-        self.resolutions.borrow_mut().entry((name, ns)).or_insert_with(Default::default)\n-            .increment_outstanding_references(is_public);\n+    pub fn add_import_directive(&self,\n+                                module_path: Vec<Name>,\n+                                subclass: ImportDirectiveSubclass,\n+                                span: Span,\n+                                id: NodeId,\n+                                is_public: bool,\n+                                is_prelude: bool) {\n+        let directive = self.arenas.alloc_import_directive(ImportDirective {\n+            module_path: module_path,\n+            target_module: Cell::new(None),\n+            subclass: subclass,\n+            span: span,\n+            id: id,\n+            is_public: is_public,\n+            is_prelude: is_prelude,\n+        });\n+\n+        self.unresolved_imports.borrow_mut().push(directive);\n+        match directive.subclass {\n+            SingleImport { target, .. } => {\n+                for &ns in &[ValueNS, TypeNS] {\n+                    self.resolution(target, ns).borrow_mut().single_imports\n+                                                            .add_directive(directive);\n+                }\n+            }\n+            // We don't add prelude imports to the globs since they only affect lexical scopes,\n+            // which are not relevant to import resolution.\n+            GlobImport if directive.is_prelude => {}\n+            GlobImport => self.globs.borrow_mut().push(directive),\n+        }\n     }\n \n     // Use `update` to mutate the resolution for the name.\n     // If the resolution becomes a success, define it in the module's glob importers.\n     fn update_resolution<T, F>(&self, name: Name, ns: Namespace, update: F) -> T\n         where F: FnOnce(&mut NameResolution<'a>) -> T\n     {\n-        let mut resolutions = self.resolutions.borrow_mut();\n-        let resolution = resolutions.entry((name, ns)).or_insert_with(Default::default);\n-        let was_success = resolution.try_result(false).and_then(ResolveResult::success).is_some();\n+        let mut resolution = &mut *self.resolution(name, ns).borrow_mut();\n+        let was_known = resolution.binding().is_some();\n \n         let t = update(resolution);\n-        if !was_success {\n-            if let Some(Success(binding)) = resolution.try_result(false) {\n+        if !was_known {\n+            if let Some(binding) = resolution.binding() {\n                 self.define_in_glob_importers(name, ns, binding);\n             }\n         }\n@@ -292,7 +341,7 @@ impl<'a> ::ModuleS<'a> {\n struct ImportResolvingError<'a> {\n     /// Module where the error happened\n     source_module: Module<'a>,\n-    import_directive: &'a ImportDirective,\n+    import_directive: &'a ImportDirective<'a>,\n     span: Span,\n     help: String,\n }\n@@ -424,46 +473,36 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     /// don't know whether the name exists at the moment due to other\n     /// currently-unresolved imports, or success if we know the name exists.\n     /// If successful, the resolved bindings are written into the module.\n-    fn resolve_import(&mut self, directive: &'b ImportDirective) -> ResolveResult<()> {\n+    fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> ResolveResult<()> {\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n                names_to_string(&directive.module_path),\n                module_to_string(self.resolver.current_module));\n \n-        let target_module = match self.resolver.resolve_module_path(&directive.module_path,\n-                                                                    DontUseLexicalScope,\n-                                                                    directive.span) {\n-            Success(module) => module,\n-            Indeterminate => return Indeterminate,\n-            Failed(err) => return Failed(err),\n+        let target_module = match directive.target_module.get() {\n+            Some(module) => module,\n+            _ => match self.resolver.resolve_module_path(&directive.module_path,\n+                                                         DontUseLexicalScope,\n+                                                         directive.span) {\n+                Success(module) => module,\n+                Indeterminate => return Indeterminate,\n+                Failed(err) => return Failed(err),\n+            },\n         };\n \n+        directive.target_module.set(Some(target_module));\n         let (source, target, value_determined, type_determined) = match directive.subclass {\n             SingleImport { source, target, ref value_determined, ref type_determined } =>\n                 (source, target, value_determined, type_determined),\n             GlobImport => return self.resolve_glob_import(target_module, directive),\n         };\n \n         // We need to resolve both namespaces for this to succeed.\n-        let module_ = self.resolver.current_module;\n-        let (value_result, type_result) = {\n-            let mut resolve_in_ns = |ns, determined: bool| {\n-                // Temporarily count the directive as determined so that the resolution fails\n-                // (as opposed to being indeterminate) when it can only be defined by the directive.\n-                if !determined {\n-                    module_.resolutions.borrow_mut().get_mut(&(target, ns)).unwrap()\n-                           .decrement_outstanding_references(directive.is_public);\n-                }\n-                let result =\n-                    self.resolver.resolve_name_in_module(target_module, source, ns, false, true);\n-                if !determined {\n-                    module_.increment_outstanding_references_for(target, ns, directive.is_public)\n-                }\n-                result\n-            };\n-            (resolve_in_ns(ValueNS, value_determined.get()),\n-             resolve_in_ns(TypeNS, type_determined.get()))\n-        };\n+        let value_result =\n+            self.resolver.resolve_name_in_module(target_module, source, ValueNS, false, true);\n+        let type_result =\n+            self.resolver.resolve_name_in_module(target_module, source, TypeNS, false, true);\n \n+        let module_ = self.resolver.current_module;\n         for &(ns, result, determined) in &[(ValueNS, &value_result, value_determined),\n                                            (TypeNS, &type_result, type_determined)] {\n             if determined.get() { continue }\n@@ -488,18 +527,24 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     let binding = &directive.import(binding, None);\n                     self.resolver.report_conflict(module_, target, ns, binding, old_binding);\n                 }\n+            } else {\n+                module_.update_resolution(target, ns, |resolution| {\n+                    resolution.single_imports.directive_failed();\n+                });\n             }\n-\n-            module_.update_resolution(target, ns, |resolution| {\n-                resolution.decrement_outstanding_references(directive.is_public);\n-            })\n         }\n \n         match (&value_result, &type_result) {\n             (&Indeterminate, _) | (_, &Indeterminate) => return Indeterminate,\n             (&Failed(_), &Failed(_)) => {\n-                let children = target_module.resolutions.borrow();\n-                let names = children.keys().map(|&(ref name, _)| name);\n+                let resolutions = target_module.resolutions.borrow();\n+                let names = resolutions.iter().filter_map(|(&(ref name, _), resolution)| {\n+                    match *resolution.borrow() {\n+                        NameResolution { binding: Some(_), .. } => Some(name),\n+                        NameResolution { single_imports: SingleImports::None, .. } => None,\n+                        _ => Some(name),\n+                    }\n+                });\n                 let lev_suggestion = match find_best_match_for_name(names, &source.as_str(), None) {\n                     Some(name) => format!(\". Did you mean to use `{}`?\", name),\n                     None => \"\".to_owned(),\n@@ -579,7 +624,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     // succeeds or bails out (as importing * from an empty module or a module\n     // that exports nothing is valid). target_module is the module we are\n     // actually importing, i.e., `foo` in `use foo::*`.\n-    fn resolve_glob_import(&mut self, target_module: Module<'b>, directive: &'b ImportDirective)\n+    fn resolve_glob_import(&mut self, target_module: Module<'b>, directive: &'b ImportDirective<'b>)\n                            -> ResolveResult<()> {\n         if let Some(Def::Trait(_)) = target_module.def {\n             self.resolver.session.span_err(directive.span, \"items in traits are not importable.\");\n@@ -598,15 +643,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             return Success(());\n         }\n \n-        // Add to target_module's glob_importers and module_'s resolved_globs\n+        // Add to target_module's glob_importers\n         target_module.glob_importers.borrow_mut().push((module_, directive));\n-        match *module_.resolved_globs.borrow_mut() {\n-            (ref mut public_globs, _) if directive.is_public => public_globs.push(target_module),\n-            (_, ref mut private_globs) => private_globs.push(target_module),\n-        }\n \n         for (&(name, ns), resolution) in target_module.resolutions.borrow().iter() {\n-            if let Some(Success(binding)) = resolution.try_result(false) {\n+            if let Some(binding) = resolution.borrow().binding() {\n                 if binding.defined_with(DefModifiers::IMPORTABLE | DefModifiers::PUBLIC) {\n                     let _ = module_.try_define_child(name, ns, directive.import(binding, None));\n                 }\n@@ -630,11 +671,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     // reporting conflicts, reporting the PRIVATE_IN_PUBLIC lint, and reporting unresolved imports.\n     fn finalize_resolutions(&mut self, module: Module<'b>, report_unresolved_imports: bool) {\n         // Since import resolution is finished, globs will not define any more names.\n-        module.public_glob_count.set(0); module.private_glob_count.set(0);\n-        *module.resolved_globs.borrow_mut() = (Vec::new(), Vec::new());\n+        *module.globs.borrow_mut() = Vec::new();\n \n         let mut reexports = Vec::new();\n         for (&(name, ns), resolution) in module.resolutions.borrow().iter() {\n+            let resolution = resolution.borrow();\n             resolution.report_conflicts(|b1, b2| {\n                 self.resolver.report_conflict(module, name, ns, b1, b2)\n             });"}, {"sha": "6b0945b2bb24822fe64c0a76fb00e47b9df80a15", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -541,14 +541,6 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     };\n \n-    let llfn = declare::declare_fn(ccx, &sym, ty);\n-    attributes::from_fn_attrs(ccx, attrs, llfn);\n-    if let Some(id) = local_item {\n-        // FIXME(eddyb) Doubt all extern fn should allow unwinding.\n-        attributes::unwind(llfn, true);\n-        ccx.item_symbols().borrow_mut().insert(id, sym);\n-    }\n-\n     // This is subtle and surprising, but sometimes we have to bitcast\n     // the resulting fn pointer.  The reason has to do with external\n     // functions.  If you have two crates that both bind the same C\n@@ -572,12 +564,32 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // This can occur on either a crate-local or crate-external\n     // reference. It also occurs when testing libcore and in some\n     // other weird situations. Annoying.\n+\n     let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n-    let llfn = if common::val_ty(llfn) != llptrty {\n-        debug!(\"get_fn: casting {:?} to {:?}\", llfn, llptrty);\n-        consts::ptrcast(llfn, llptrty)\n+    let llfn = if let Some(llfn) = declare::get_declared_value(ccx, &sym) {\n+        if common::val_ty(llfn) != llptrty {\n+            if local_item.is_some() {\n+                bug!(\"symbol `{}` previously declared as {:?}, now wanted as {:?}\",\n+                     sym, Value(llfn), llptrty);\n+            }\n+            debug!(\"get_fn: casting {:?} to {:?}\", llfn, llptrty);\n+            consts::ptrcast(llfn, llptrty)\n+        } else {\n+            debug!(\"get_fn: not casting pointer!\");\n+            llfn\n+        }\n     } else {\n+        let llfn = declare::declare_fn(ccx, &sym, ty);\n+        assert_eq!(common::val_ty(llfn), llptrty);\n         debug!(\"get_fn: not casting pointer!\");\n+\n+        attributes::from_fn_attrs(ccx, attrs, llfn);\n+        if let Some(id) = local_item {\n+            // FIXME(eddyb) Doubt all extern fn should allow unwinding.\n+            attributes::unwind(llfn, true);\n+            ccx.item_symbols().borrow_mut().insert(id, sym);\n+        }\n+\n         llfn\n     };\n "}, {"sha": "eb520fe744a3d7b3190da3a8baaddfbf52b6dc40", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -26,6 +26,7 @@ use abi::{Abi, FnType};\n use attributes;\n use context::CrateContext;\n use type_::Type;\n+use value::Value;\n \n use std::ffi::CString;\n \n@@ -146,27 +147,33 @@ pub fn define_internal_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n \n-/// Get defined or externally defined (AvailableExternally linkage) value by\n-/// name.\n-pub fn get_defined_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n-    debug!(\"get_defined_value(name={:?})\", name);\n+/// Get declared value by name.\n+pub fn get_declared_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n+    debug!(\"get_declared_value(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         bug!(\"name {:?} contains an interior null byte\", name)\n     });\n     let val = unsafe { llvm::LLVMGetNamedValue(ccx.llmod(), namebuf.as_ptr()) };\n     if val.is_null() {\n-        debug!(\"get_defined_value: {:?} value is null\", name);\n+        debug!(\"get_declared_value: {:?} value is null\", name);\n         None\n     } else {\n+        debug!(\"get_declared_value: {:?} => {:?}\", name, Value(val));\n+        Some(val)\n+    }\n+}\n+\n+/// Get defined or externally defined (AvailableExternally linkage) value by\n+/// name.\n+pub fn get_defined_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n+    get_declared_value(ccx, name).and_then(|val|{\n         let declaration = unsafe {\n             llvm::LLVMIsDeclaration(val) != 0\n         };\n-        debug!(\"get_defined_value: found {:?} value (declaration: {})\",\n-                name, declaration);\n         if !declaration {\n             Some(val)\n         } else {\n             None\n         }\n-    }\n+    })\n }"}, {"sha": "28d5d9ac176ffc163f5f3f8da82cd3a139c3d3a0", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -752,33 +752,47 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n             match split[1] {\n                 \"cxchg\" | \"cxchgweak\" => {\n-                    let cmp = from_immediate(bcx, llargs[1]);\n-                    let src = from_immediate(bcx, llargs[2]);\n-                    let ptr = PointerCast(bcx, llargs[0], val_ty(src).ptr_to());\n-                    let weak = if split[1] == \"cxchgweak\" { llvm::True } else { llvm::False };\n-                    let val = AtomicCmpXchg(bcx, ptr, cmp, src, order, failorder, weak);\n-                    let result = ExtractValue(bcx, val, 0);\n-                    let success = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n-                    Store(bcx,\n-                          result,\n-                          PointerCast(bcx, StructGEP(bcx, llresult, 0), val_ty(src).ptr_to()));\n-                    Store(bcx, success, StructGEP(bcx, llresult, 1));\n+                    let sty = &substs.types.get(FnSpace, 0).sty;\n+                    if int_type_width_signed(sty, ccx).is_some() {\n+                        let weak = if split[1] == \"cxchgweak\" { llvm::True } else { llvm::False };\n+                        let val = AtomicCmpXchg(bcx, llargs[0], llargs[1], llargs[2],\n+                                                order, failorder, weak);\n+                        let result = ExtractValue(bcx, val, 0);\n+                        let success = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n+                        Store(bcx, result, StructGEP(bcx, llresult, 0));\n+                        Store(bcx, success, StructGEP(bcx, llresult, 1));\n+                    } else {\n+                        span_invalid_monomorphization_error(\n+                            tcx.sess, span,\n+                            &format!(\"invalid monomorphization of `{}` intrinsic: \\\n+                                      expected basic integer type, found `{}`\", name, sty));\n+                    }\n                     C_nil(ccx)\n                 }\n \n                 \"load\" => {\n-                    let tp_ty = *substs.types.get(FnSpace, 0);\n-                    let mut ptr = llargs[0];\n-                    if let Some(ty) = fn_ty.ret.cast {\n-                        ptr = PointerCast(bcx, ptr, ty.ptr_to());\n+                    let sty = &substs.types.get(FnSpace, 0).sty;\n+                    if int_type_width_signed(sty, ccx).is_some() {\n+                        AtomicLoad(bcx, llargs[0], order)\n+                    } else {\n+                        span_invalid_monomorphization_error(\n+                            tcx.sess, span,\n+                            &format!(\"invalid monomorphization of `{}` intrinsic: \\\n+                                      expected basic integer type, found `{}`\", name, sty));\n+                        C_nil(ccx)\n                     }\n-                    to_immediate(bcx, AtomicLoad(bcx, ptr, order), tp_ty)\n                 }\n \n                 \"store\" => {\n-                    let val = from_immediate(bcx, llargs[1]);\n-                    let ptr = PointerCast(bcx, llargs[0], val_ty(val).ptr_to());\n-                    AtomicStore(bcx, val, ptr, order);\n+                    let sty = &substs.types.get(FnSpace, 0).sty;\n+                    if int_type_width_signed(sty, ccx).is_some() {\n+                        AtomicStore(bcx, llargs[1], llargs[0], order);\n+                    } else {\n+                        span_invalid_monomorphization_error(\n+                            tcx.sess, span,\n+                            &format!(\"invalid monomorphization of `{}` intrinsic: \\\n+                                      expected basic integer type, found `{}`\", name, sty));\n+                    }\n                     C_nil(ccx)\n                 }\n \n@@ -809,9 +823,16 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         _ => ccx.sess().fatal(\"unknown atomic operation\")\n                     };\n \n-                    let val = from_immediate(bcx, llargs[1]);\n-                    let ptr = PointerCast(bcx, llargs[0], val_ty(val).ptr_to());\n-                    AtomicRMW(bcx, atom_op, ptr, val, order)\n+                    let sty = &substs.types.get(FnSpace, 0).sty;\n+                    if int_type_width_signed(sty, ccx).is_some() {\n+                        AtomicRMW(bcx, atom_op, llargs[0], llargs[1], order)\n+                    } else {\n+                        span_invalid_monomorphization_error(\n+                            tcx.sess, span,\n+                            &format!(\"invalid monomorphization of `{}` intrinsic: \\\n+                                      expected basic integer type, found `{}`\", name, sty));\n+                        C_nil(ccx)\n+                    }\n                 }\n             }\n "}, {"sha": "55c3a5add37bb9e96ff59e78b8fc9c55e1c331b9", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use middle::def::{self, Def};\n-use rustc::infer::{self, TypeOrigin};\n+use rustc::infer::{self, InferOk, TypeOrigin};\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n use middle::pat_util::pat_is_resolved_const;\n use rustc::ty::subst::Substs;\n@@ -531,7 +531,12 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n \n         let result = if is_if_let_fallback {\n-            fcx.infcx().eq_types(true, origin, arm_ty, result_ty).map(|_| arm_ty)\n+            fcx.infcx().eq_types(true, origin, arm_ty, result_ty)\n+                .map(|InferOk { obligations, .. }| {\n+                    // FIXME(#32730) propagate obligations\n+                    assert!(obligations.is_empty());\n+                    arm_ty\n+                })\n         } else if i == 0 {\n             // Special-case the first arm, as it has no \"previous expressions\".\n             coercion::try(fcx, &arm.body, coerce_first)"}, {"sha": "cafd0519c2821645ae939f4149f502fb43445689", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -62,7 +62,7 @@\n \n use check::{autoderef, FnCtxt, UnresolvedTypeAction};\n \n-use rustc::infer::{Coercion, TypeOrigin, TypeTrace};\n+use rustc::infer::{Coercion, InferOk, TypeOrigin, TypeTrace};\n use rustc::traits::{self, ObligationCause};\n use rustc::traits::{predicate_for_trait_def, report_selection_error};\n use rustc::ty::adjustment::{AutoAdjustment, AutoDerefRef, AdjustDerefRef};\n@@ -118,8 +118,18 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             let trace = TypeTrace::types(self.origin, false, a, b);\n             if self.use_lub {\n                 infcx.lub(false, trace, &a, &b)\n+                    .map(|InferOk { value, obligations }| {\n+                        // FIXME(#32730) propagate obligations\n+                        assert!(obligations.is_empty());\n+                        value\n+                    })\n             } else {\n                 infcx.sub(false, trace, &a, &b)\n+                    .map(|InferOk { value, obligations }| {\n+                        // FIXME(#32730) propagate obligations\n+                        assert!(obligations.is_empty());\n+                        value\n+                    })\n             }\n         })\n     }\n@@ -655,12 +665,22 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n         (&ty::TyFnDef(a_def_id, a_substs, a_fty),\n          &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n             // The signature must always match.\n-            let fty = fcx.infcx().lub(true, trace.clone(), a_fty, b_fty)?;\n+            let fty = fcx.infcx().lub(true, trace.clone(), a_fty, b_fty)\n+                .map(|InferOk { value, obligations }| {\n+                    // FIXME(#32730) propagate obligations\n+                    assert!(obligations.is_empty());\n+                    value\n+                })?;\n \n             if a_def_id == b_def_id {\n                 // Same function, maybe the parameters match.\n                 let substs = fcx.infcx().commit_if_ok(|_| {\n                     fcx.infcx().lub(true, trace.clone(), a_substs, b_substs)\n+                        .map(|InferOk { value, obligations }| {\n+                            // FIXME(#32730) propagate obligations\n+                            assert!(obligations.is_empty());\n+                            value\n+                        })\n                 }).map(|s| fcx.tcx().mk_substs(s));\n \n                 if let Ok(substs) = substs {\n@@ -724,6 +744,11 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n         if !noop {\n             return fcx.infcx().commit_if_ok(|_| {\n                 fcx.infcx().lub(true, trace.clone(), &prev_ty, &new_ty)\n+                    .map(|InferOk { value, obligations }| {\n+                        // FIXME(#32730) propagate obligations\n+                        assert!(obligations.is_empty());\n+                        value\n+                    })\n             });\n         }\n     }\n@@ -736,6 +761,11 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n             } else {\n                 fcx.infcx().commit_if_ok(|_| {\n                     fcx.infcx().lub(true, trace, &prev_ty, &new_ty)\n+                        .map(|InferOk { value, obligations }| {\n+                            // FIXME(#32730) propagate obligations\n+                            assert!(obligations.is_empty());\n+                            value\n+                        })\n                 })\n             }\n         }"}, {"sha": "3c12ab8d59840ea61ade8994d21005ed7ca109f8", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use middle::free_region::FreeRegionMap;\n-use rustc::infer::{self, TypeOrigin};\n+use rustc::infer::{self, InferOk, TypeOrigin};\n use rustc::ty::{self, TyCtxt};\n use rustc::traits::{self, ProjectionMode};\n use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace};\n@@ -475,7 +475,10 @@ pub fn compare_const_impl<'tcx>(tcx: &TyCtxt<'tcx>,\n     });\n \n     match err {\n-        Ok(()) => { }\n+        Ok(InferOk { obligations, .. }) => {\n+            // FIXME(#32730) propagate obligations\n+            assert!(obligations.is_empty())\n+        }\n         Err(terr) => {\n             debug!(\"checking associated const for compatibility: impl ty {:?}, trait ty {:?}\",\n                    impl_ty,"}, {"sha": "bc2ef9aafee59d4b669000991d0f8b7606ba0d18", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -11,7 +11,7 @@\n \n use check::{coercion, FnCtxt};\n use rustc::ty::Ty;\n-use rustc::infer::TypeOrigin;\n+use rustc::infer::{InferOk, TypeOrigin};\n \n use syntax::codemap::Span;\n use rustc_front::hir;\n@@ -21,16 +21,28 @@ use rustc_front::hir;\n pub fn suptype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n                          expected: Ty<'tcx>, actual: Ty<'tcx>) {\n     let origin = TypeOrigin::Misc(sp);\n-    if let Err(e) = fcx.infcx().sub_types(false, origin, actual, expected) {\n-        fcx.infcx().report_mismatched_types(origin, expected, actual, e);\n+    match fcx.infcx().sub_types(false, origin, actual, expected) {\n+        Ok(InferOk { obligations, .. }) => {\n+            // FIXME(#32730) propagate obligations\n+            assert!(obligations.is_empty());\n+        },\n+        Err(e) => {\n+            fcx.infcx().report_mismatched_types(origin, expected, actual, e);\n+        }\n     }\n }\n \n pub fn eqtype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n                         expected: Ty<'tcx>, actual: Ty<'tcx>) {\n     let origin = TypeOrigin::Misc(sp);\n-    if let Err(e) = fcx.infcx().eq_types(false, origin, actual, expected) {\n-        fcx.infcx().report_mismatched_types(origin, expected, actual, e);\n+    match fcx.infcx().eq_types(false, origin, actual, expected) {\n+        Ok(InferOk { obligations, .. }) => {\n+            // FIXME(#32730) propagate obligations\n+            assert!(obligations.is_empty());\n+        },\n+        Err(e) => {\n+            fcx.infcx().report_mismatched_types(origin, expected, actual, e);\n+        }\n     }\n }\n "}, {"sha": "2e15ac0e13084d3fb7dba28f99dee9d282e3fc21", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -21,8 +21,7 @@ use rustc::ty::subst;\n use rustc::ty::subst::Subst;\n use rustc::traits;\n use rustc::ty::{self, NoPreference, Ty, TyCtxt, ToPolyTraitRef, TraitRef, TypeFoldable};\n-use rustc::infer;\n-use rustc::infer::{InferCtxt, TypeOrigin};\n+use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin};\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n use rustc_front::hir;\n@@ -1151,6 +1150,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn make_sub_ty(&self, sub: Ty<'tcx>, sup: Ty<'tcx>) -> infer::UnitResult<'tcx> {\n         self.infcx().sub_types(false, TypeOrigin::Misc(DUMMY_SP), sub, sup)\n+            // FIXME(#32730) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n     fn has_applicable_self(&self, item: &ty::ImplOrTraitItem) -> bool {"}, {"sha": "32b5a63817ea5e7cd586df4e9d07256b6e988e30", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -14,14 +14,15 @@\n use CrateCtxt;\n \n use astconv::AstConv;\n-use check::{self, FnCtxt};\n+use check::{self, FnCtxt, UnresolvedTypeAction, autoderef};\n use front::map as hir_map;\n use rustc::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TypeFoldable};\n use middle::cstore::{self, CrateStore};\n use middle::def::Def;\n use middle::def_id::DefId;\n use middle::lang_items::FnOnceTraitLangItem;\n use rustc::ty::subst::Substs;\n+use rustc::ty::LvaluePreference;\n use rustc::traits::{Obligation, SelectionContext};\n use util::nodemap::{FnvHashSet};\n \n@@ -50,23 +51,37 @@ fn is_fn_ty<'a, 'tcx>(ty: &Ty<'tcx>, fcx: &FnCtxt<'a, 'tcx>, span: Span) -> bool\n             if let Ok(fn_once_trait_did) =\n                     cx.lang_items.require(FnOnceTraitLangItem) {\n                 let infcx = fcx.infcx();\n-                infcx.probe(|_| {\n-                    let fn_once_substs =\n-                        Substs::new_trait(vec![infcx.next_ty_var()],\n-                                          Vec::new(),\n-                                          ty);\n-                    let trait_ref =\n-                      ty::TraitRef::new(fn_once_trait_did,\n-                                        cx.mk_substs(fn_once_substs));\n-                    let poly_trait_ref = trait_ref.to_poly_trait_ref();\n-                    let obligation = Obligation::misc(span,\n-                                                      fcx.body_id,\n-                                                      poly_trait_ref\n-                                                         .to_predicate());\n-                    let mut selcx = SelectionContext::new(infcx);\n-\n-                    return selcx.evaluate_obligation(&obligation)\n-                })\n+                let (_, _, opt_is_fn) = autoderef(fcx,\n+                                                  span,\n+                                                  ty,\n+                                                  || None,\n+                                                  UnresolvedTypeAction::Ignore,\n+                                                  LvaluePreference::NoPreference,\n+                                                  |ty, _| {\n+                    infcx.probe(|_| {\n+                        let fn_once_substs =\n+                            Substs::new_trait(vec![infcx.next_ty_var()],\n+                                              Vec::new(),\n+                                              ty);\n+                        let trait_ref =\n+                          ty::TraitRef::new(fn_once_trait_did,\n+                                            cx.mk_substs(fn_once_substs));\n+                        let poly_trait_ref = trait_ref.to_poly_trait_ref();\n+                        let obligation = Obligation::misc(span,\n+                                                          fcx.body_id,\n+                                                          poly_trait_ref\n+                                                             .to_predicate());\n+                        let mut selcx = SelectionContext::new(infcx);\n+\n+                        if selcx.evaluate_obligation(&obligation) {\n+                            Some(())\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                });\n+\n+                opt_is_fn.is_some()\n             } else {\n                 false\n             }"}, {"sha": "e485fbe1621c87413f2ff696d77ffaef97a04826", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -88,8 +88,7 @@ use middle::astconv_util::prohibit_type_params;\n use middle::cstore::LOCAL_CRATE;\n use middle::def::{self, Def};\n use middle::def_id::DefId;\n-use rustc::infer;\n-use rustc::infer::{TypeOrigin, TypeTrace, type_variable};\n+use rustc::infer::{self, InferOk, TypeOrigin, TypeTrace, type_variable};\n use middle::pat_util::{self, pat_id_map};\n use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n use rustc::traits::{self, report_fulfillment_errors, ProjectionMode};\n@@ -1627,6 +1626,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     sup: Ty<'tcx>)\n                     -> Result<(), TypeError<'tcx>> {\n         infer::mk_subty(self.infcx(), a_is_expected, origin, sub, sup)\n+            // FIXME(#32730) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n     pub fn mk_eqty(&self,\n@@ -1636,6 +1637,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                    sup: Ty<'tcx>)\n                    -> Result<(), TypeError<'tcx>> {\n         infer::mk_eqty(self.infcx(), a_is_expected, origin, sub, sup)\n+            // FIXME(#32730) propagate obligations\n+            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n     pub fn mk_subr(&self,\n@@ -1914,7 +1917,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     match infer::mk_eqty(self.infcx(), false,\n                                                          TypeOrigin::Misc(default.origin_span),\n                                                          ty, default.ty) {\n-                                        Ok(()) => {}\n+                                        Ok(InferOk { obligations, .. }) => {\n+                                            // FIXME(#32730) propagate obligations\n+                                            assert!(obligations.is_empty())\n+                                        },\n                                         Err(_) => {\n                                             conflicts.push((*ty, default));\n                                         }\n@@ -2007,7 +2013,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             match infer::mk_eqty(self.infcx(), false,\n                                                  TypeOrigin::Misc(default.origin_span),\n                                                  ty, default.ty) {\n-                                Ok(()) => {}\n+                                // FIXME(#32730) propagate obligations\n+                                Ok(InferOk { obligations, .. }) => assert!(obligations.is_empty()),\n                                 Err(_) => {\n                                     result = Some(default);\n                                 }\n@@ -2773,8 +2780,10 @@ fn expected_types_for_fn_args<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 let ures = fcx.infcx().sub_types(false, origin, formal_ret_ty, ret_ty);\n                 // FIXME(#15760) can't use try! here, FromError doesn't default\n                 // to identity so the resulting type is not constrained.\n-                if let Err(e) = ures {\n-                    return Err(e);\n+                match ures {\n+                    // FIXME(#32730) propagate obligations\n+                    Ok(InferOk { obligations, .. }) => assert!(obligations.is_empty()),\n+                    Err(e) => return Err(e),\n                 }\n \n                 // Record all the argument types, with the substitutions\n@@ -2902,13 +2911,23 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 fcx.infcx().commit_if_ok(|_| {\n                     let trace = TypeTrace::types(origin, true, then_ty, else_ty);\n                     fcx.infcx().lub(true, trace, &then_ty, &else_ty)\n+                        .map(|InferOk { value, obligations }| {\n+                            // FIXME(#32730) propagate obligations\n+                            assert!(obligations.is_empty());\n+                            value\n+                        })\n                 })\n             };\n             (origin, then_ty, else_ty, result)\n         } else {\n             let origin = TypeOrigin::IfExpressionWithNoElse(sp);\n             (origin, unit, then_ty,\n-             fcx.infcx().eq_types(true, origin, unit, then_ty).map(|_| unit))\n+             fcx.infcx().eq_types(true, origin, unit, then_ty)\n+                 .map(|InferOk { obligations, .. }| {\n+                     // FIXME(#32730) propagate obligations\n+                     assert!(obligations.is_empty());\n+                     unit\n+                 }))\n         };\n \n         let if_ty = match result {"}, {"sha": "15bf6671de50129227a05570fe1fc311da5c0063", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -92,7 +92,7 @@ use middle::region::{self, CodeExtent};\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, MethodCall, TypeFoldable};\n-use rustc::infer::{self, GenericKind, InferCtxt, SubregionOrigin, TypeOrigin, VerifyBound};\n+use rustc::infer::{self, GenericKind, InferCtxt, InferOk, SubregionOrigin, TypeOrigin, VerifyBound};\n use middle::pat_util;\n use rustc::ty::adjustment;\n use rustc::ty::wf::ImpliedBound;\n@@ -1841,7 +1841,11 @@ fn declared_projection_bounds_from_trait<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n \n                 // check whether this predicate applies to our current projection\n                 match infer::mk_eqty(infcx, false, TypeOrigin::Misc(span), ty, outlives.0) {\n-                    Ok(()) => { Ok(outlives.1) }\n+                    Ok(InferOk { obligations, .. }) => {\n+                        // FIXME(#32730) propagate obligations\n+                        assert!(obligations.is_empty());\n+                        Ok(outlives.1)\n+                    }\n                     Err(_) => { Err(()) }\n                 }\n             });"}, {"sha": "7437d6087718acbb1bc1b4b0d55faded67f7c441", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -14,7 +14,6 @@\n pub use self::Type::*;\n pub use self::PrimitiveType::*;\n pub use self::TypeKind::*;\n-pub use self::StructField::*;\n pub use self::VariantKind::*;\n pub use self::Mutability::*;\n pub use self::Import::*;\n@@ -53,6 +52,7 @@ use std::env::current_dir;\n use core::DocContext;\n use doctree;\n use visit_ast;\n+use html::item_type::ItemType;\n \n /// A stable identifier to the particular version of JSON output.\n /// Increment this when the `Crate` and related structures change.\n@@ -273,36 +273,49 @@ impl Item {\n     }\n     pub fn is_crate(&self) -> bool {\n         match self.inner {\n-            ModuleItem(Module { items: _, is_crate: true }) => true,\n-            _ => false\n+            StrippedItem(box ModuleItem(Module { is_crate: true, ..})) |\n+            ModuleItem(Module { is_crate: true, ..}) => true,\n+            _ => false,\n         }\n     }\n     pub fn is_mod(&self) -> bool {\n-        match self.inner { ModuleItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Module\n     }\n     pub fn is_trait(&self) -> bool {\n-        match self.inner { TraitItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Trait\n     }\n     pub fn is_struct(&self) -> bool {\n-        match self.inner { StructItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Struct\n     }\n     pub fn is_enum(&self) -> bool {\n-        match self.inner { EnumItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Module\n     }\n     pub fn is_fn(&self) -> bool {\n-        match self.inner { FunctionItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Function\n     }\n     pub fn is_associated_type(&self) -> bool {\n-        match self.inner { AssociatedTypeItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::AssociatedType\n     }\n     pub fn is_associated_const(&self) -> bool {\n-        match self.inner { AssociatedConstItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::AssociatedConst\n     }\n     pub fn is_method(&self) -> bool {\n-        match self.inner { MethodItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Method\n     }\n     pub fn is_ty_method(&self) -> bool {\n-        match self.inner { TyMethodItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::TyMethod\n+    }\n+    pub fn is_stripped(&self) -> bool {\n+        match self.inner { StrippedItem(..) => true, _ => false }\n+    }\n+    pub fn has_stripped_fields(&self) -> Option<bool> {\n+        match self.inner {\n+            StructItem(ref _struct) => Some(_struct.fields_stripped),\n+            VariantItem(Variant { kind: StructVariant(ref vstruct)} ) => {\n+                Some(vstruct.fields_stripped)\n+            },\n+            _ => None,\n+        }\n     }\n \n     pub fn stability_class(&self) -> String {\n@@ -341,7 +354,7 @@ pub enum ItemEnum {\n     TyMethodItem(TyMethod),\n     /// A method with a body.\n     MethodItem(Method),\n-    StructFieldItem(StructField),\n+    StructFieldItem(Type),\n     VariantItem(Variant),\n     /// `fn`s from an extern block\n     ForeignFunctionItem(Function),\n@@ -352,6 +365,8 @@ pub enum ItemEnum {\n     AssociatedConstItem(Type, Option<String>),\n     AssociatedTypeItem(Vec<TyParamBound>, Option<Type>),\n     DefaultImplItem(DefaultImpl),\n+    /// An item that has been stripped by a rustdoc pass\n+    StrippedItem(Box<ItemEnum>),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -1733,12 +1748,6 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum StructField {\n-    HiddenStructField, // inserted later by strip passes\n-    TypedStructField(Type),\n-}\n-\n impl Clean<Item> for hir::StructField {\n     fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n@@ -1749,7 +1758,7 @@ impl Clean<Item> for hir::StructField {\n             stability: get_stability(cx, cx.map.local_def_id(self.id)),\n             deprecation: get_deprecation(cx, cx.map.local_def_id(self.id)),\n             def_id: cx.map.local_def_id(self.id),\n-            inner: StructFieldItem(TypedStructField(self.ty.clean(cx))),\n+            inner: StructFieldItem(self.ty.clean(cx)),\n         }\n     }\n }\n@@ -1766,7 +1775,7 @@ impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n             stability: get_stability(cx, self.did),\n             deprecation: get_deprecation(cx, self.did),\n             def_id: self.did,\n-            inner: StructFieldItem(TypedStructField(self.unsubst_ty().clean(cx))),\n+            inner: StructFieldItem(self.unsubst_ty().clean(cx)),\n         }\n     }\n }\n@@ -1897,9 +1906,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n                             def_id: field.did,\n                             stability: get_stability(cx, field.did),\n                             deprecation: get_deprecation(cx, field.did),\n-                            inner: StructFieldItem(\n-                                TypedStructField(field.unsubst_ty().clean(cx))\n-                            )\n+                            inner: StructFieldItem(field.unsubst_ty().clean(cx))\n                         }\n                     }).collect()\n                 })"}, {"sha": "5595c749256dfc7971a46edbd2b42c3b36806b7d", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -10,28 +10,50 @@\n \n use clean::*;\n \n+pub enum FoldItem {\n+    Retain(Item),\n+    Strip(Item),\n+    Erase,\n+}\n+\n+impl FoldItem {\n+    pub fn fold(self) -> Option<Item> {\n+        match self {\n+            FoldItem::Erase => None,\n+            FoldItem::Retain(i) => Some(i),\n+            FoldItem::Strip(item@ Item { inner: StrippedItem(..), .. } ) => Some(item),\n+            FoldItem::Strip(mut i) => {\n+                i.inner = StrippedItem(box i.inner);\n+                Some(i)\n+            }\n+        }\n+    }\n+}\n+\n pub trait DocFolder : Sized {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n         self.fold_item_recur(item)\n     }\n \n     /// don't override!\n-    fn fold_item_recur(&mut self, item: Item) -> Option<Item> {\n-        let Item { attrs, name, source, visibility, def_id, inner, stability, deprecation } = item;\n-        let inner = match inner {\n+    fn fold_inner_recur(&mut self, inner: ItemEnum) -> ItemEnum {\n+        match inner {\n+            StrippedItem(..) => unreachable!(),\n+            ModuleItem(i) => {\n+                ModuleItem(self.fold_mod(i))\n+            },\n             StructItem(mut i) => {\n                 let num_fields = i.fields.len();\n                 i.fields = i.fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n-                i.fields_stripped |= num_fields != i.fields.len();\n+                i.fields_stripped |= num_fields != i.fields.len() ||\n+                                     i.fields.iter().any(|f| f.is_stripped());\n                 StructItem(i)\n             },\n-            ModuleItem(i) => {\n-                ModuleItem(self.fold_mod(i))\n-            },\n             EnumItem(mut i) => {\n                 let num_variants = i.variants.len();\n                 i.variants = i.variants.into_iter().filter_map(|x| self.fold_item(x)).collect();\n-                i.variants_stripped |= num_variants != i.variants.len();\n+                i.variants_stripped |= num_variants != i.variants.len() ||\n+                                       i.variants.iter().any(|f| f.is_stripped());\n                 EnumItem(i)\n             },\n             TraitItem(mut i) => {\n@@ -48,13 +70,24 @@ pub trait DocFolder : Sized {\n                     StructVariant(mut j) => {\n                         let num_fields = j.fields.len();\n                         j.fields = j.fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n-                        j.fields_stripped |= num_fields != j.fields.len();\n+                        j.fields_stripped |= num_fields != j.fields.len() ||\n+                                             j.fields.iter().any(|f| f.is_stripped());\n                         VariantItem(Variant {kind: StructVariant(j), ..i2})\n                     },\n                     _ => VariantItem(i2)\n                 }\n             },\n             x => x\n+        }\n+    }\n+\n+    /// don't override!\n+    fn fold_item_recur(&mut self, item: Item) -> Option<Item> {\n+        let Item { attrs, name, source, visibility, def_id, inner, stability, deprecation } = item;\n+\n+        let inner = match inner {\n+            StrippedItem(box i) => StrippedItem(box self.fold_inner_recur(i)),\n+            _ => self.fold_inner_recur(inner),\n         };\n \n         Some(Item { attrs: attrs, name: name, source: source, inner: inner,\n@@ -70,9 +103,8 @@ pub trait DocFolder : Sized {\n     }\n \n     fn fold_crate(&mut self, mut c: Crate) -> Crate {\n-        c.module = c.module.and_then(|module| {\n-            self.fold_item(module)\n-        });\n+        c.module = c.module.and_then(|module| self.fold_item(module));\n+\n         c.external_traits = c.external_traits.into_iter().map(|(k, mut v)| {\n             v.items = v.items.into_iter().filter_map(|i| self.fold_item(i)).collect();\n             (k, v)"}, {"sha": "7ca4703a2e1859e298a9ba486156f196758526c6", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -17,22 +17,36 @@ use html::escape::Escape;\n \n use std::io;\n use std::io::prelude::*;\n-use syntax::parse::lexer;\n+use syntax::parse::lexer::{self, Reader};\n use syntax::parse::token;\n use syntax::parse;\n \n-/// Highlights some source code, returning the HTML output.\n-pub fn highlight(src: &str, class: Option<&str>, id: Option<&str>) -> String {\n+/// Highlights `src`, returning the HTML output.\n+pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>) -> String {\n     debug!(\"highlighting: ================\\n{}\\n==============\", src);\n     let sess = parse::ParseSess::new();\n     let fm = sess.codemap().new_filemap(\"<stdin>\".to_string(), src.to_string());\n \n     let mut out = Vec::new();\n-    doit(&sess,\n-         lexer::StringReader::new(&sess.span_diagnostic, fm),\n-         class,\n-         id,\n-         &mut out).unwrap();\n+    write_header(class, id, &mut out).unwrap();\n+    write_source(&sess,\n+                 lexer::StringReader::new(&sess.span_diagnostic, fm),\n+                 &mut out).unwrap();\n+    write_footer(&mut out).unwrap();\n+    String::from_utf8_lossy(&out[..]).into_owned()\n+}\n+\n+/// Highlights `src`, returning the HTML output. Returns only the inner html to\n+/// be inserted into an element. C.f., `render_with_highlighting` which includes\n+/// an enclosing `<pre>` block.\n+pub fn render_inner_with_highlighting(src: &str) -> String {\n+    let sess = parse::ParseSess::new();\n+    let fm = sess.codemap().new_filemap(\"<stdin>\".to_string(), src.to_string());\n+\n+    let mut out = Vec::new();\n+    write_source(&sess,\n+                 lexer::StringReader::new(&sess.span_diagnostic, fm),\n+                 &mut out).unwrap();\n     String::from_utf8_lossy(&out[..]).into_owned()\n }\n \n@@ -43,17 +57,10 @@ pub fn highlight(src: &str, class: Option<&str>, id: Option<&str>) -> String {\n /// it's used. All source code emission is done as slices from the source map,\n /// not from the tokens themselves, in order to stay true to the original\n /// source.\n-fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n-        class: Option<&str>, id: Option<&str>,\n-        out: &mut Write) -> io::Result<()> {\n-    use syntax::parse::lexer::Reader;\n-\n-    write!(out, \"<pre \")?;\n-    match id {\n-        Some(id) => write!(out, \"id='{}' \", id)?,\n-        None => {}\n-    }\n-    write!(out, \"class='rust {}'>\\n\", class.unwrap_or(\"\"))?;\n+fn write_source(sess: &parse::ParseSess,\n+                mut lexer: lexer::StringReader,\n+                out: &mut Write)\n+                -> io::Result<()> {\n     let mut is_attribute = false;\n     let mut is_macro = false;\n     let mut is_macro_nonterminal = false;\n@@ -184,5 +191,21 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n         }\n     }\n \n+    Ok(())\n+}\n+\n+fn write_header(class: Option<&str>,\n+                id: Option<&str>,\n+                out: &mut Write)\n+                -> io::Result<()> {\n+    write!(out, \"<pre \")?;\n+    match id {\n+        Some(id) => write!(out, \"id='{}' \", id)?,\n+        None => {}\n+    }\n+    write!(out, \"class='rust {}'>\\n\", class.unwrap_or(\"\"))\n+}\n+\n+fn write_footer(out: &mut Write) -> io::Result<()> {\n     write!(out, \"</pre>\\n\")\n }"}, {"sha": "74f7b099044f16b3700faf88061e6567ae82cb87", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -44,7 +44,12 @@ pub enum ItemType {\n \n impl ItemType {\n     pub fn from_item(item: &clean::Item) -> ItemType {\n-        match item.inner {\n+        let inner = match item.inner {\n+            clean::StrippedItem(box ref item) => item,\n+            ref inner@_ => inner,\n+        };\n+\n+        match *inner {\n             clean::ModuleItem(..)          => ItemType::Module,\n             clean::ExternCrateItem(..)     => ItemType::ExternCrate,\n             clean::ImportItem(..)          => ItemType::Import,\n@@ -67,6 +72,7 @@ impl ItemType {\n             clean::AssociatedConstItem(..) => ItemType::AssociatedConst,\n             clean::AssociatedTypeItem(..)  => ItemType::AssociatedType,\n             clean::DefaultImplItem(..)     => ItemType::Impl,\n+            clean::StrippedItem(..)        => unreachable!(),\n         }\n     }\n "}, {"sha": "3baf22b38ef6874b2fca3e4199c3c11c96fead9e", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -262,9 +262,9 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                                               &Default::default());\n                     s.push_str(&format!(\"<span class='rusttest'>{}</span>\", Escape(&test)));\n                 });\n-                s.push_str(&highlight::highlight(&text,\n-                                                 Some(\"rust-example-rendered\"),\n-                                                 None));\n+                s.push_str(&highlight::render_with_highlighting(&text,\n+                                                                Some(\"rust-example-rendered\"),\n+                                                                None));\n                 let output = CString::new(s).unwrap();\n                 hoedown_buffer_puts(ob, output.as_ptr());\n             })"}, {"sha": "1427dfcbaf178341dbb61b9302f22eacc04c4c6a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 147, "deletions": 168, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -91,12 +91,20 @@ pub struct Context {\n     /// String representation of how to get back to the root path of the 'doc/'\n     /// folder in terms of a relative URL.\n     pub root_path: String,\n-    /// The path to the crate root source minus the file name.\n-    /// Used for simplifying paths to the highlighted source code files.\n-    pub src_root: PathBuf,\n     /// The current destination folder of where HTML artifacts should be placed.\n     /// This changes as the context descends into the module hierarchy.\n     pub dst: PathBuf,\n+    /// A flag, which when `true`, will render pages which redirect to the\n+    /// real location of an item. This is used to allow external links to\n+    /// publicly reused items to redirect to the right location.\n+    pub render_redirect_pages: bool,\n+    pub shared: Arc<SharedContext>,\n+}\n+\n+pub struct SharedContext {\n+    /// The path to the crate root source minus the file name.\n+    /// Used for simplifying paths to the highlighted source code files.\n+    pub src_root: PathBuf,\n     /// This describes the layout of each page, and is not modified after\n     /// creation of the context (contains info like the favicon and added html).\n     pub layout: layout::Layout,\n@@ -106,10 +114,6 @@ pub struct Context {\n     pub include_sources: bool,\n     /// The local file sources we've emitted and their respective url-paths.\n     pub local_sources: HashMap<PathBuf, String>,\n-    /// A flag, which when turned off, will render pages which redirect to the\n-    /// real location of an item. This is used to allow external links to\n-    /// publicly reused items to redirect to the right location.\n-    pub render_redirect_pages: bool,\n     /// All the passes that were run on this crate.\n     pub passes: HashSet<String>,\n     /// The base-URL of the issue tracker for when an item has been tagged with\n@@ -245,8 +249,7 @@ pub struct Cache {\n     parent_stack: Vec<DefId>,\n     parent_is_trait_impl: bool,\n     search_index: Vec<IndexItem>,\n-    privmod: bool,\n-    remove_priv: bool,\n+    stripped_mod: bool,\n     access_levels: AccessLevels<DefId>,\n     deref_trait_did: Option<DefId>,\n \n@@ -260,7 +263,7 @@ pub struct Cache {\n \n /// Helper struct to render all source code to HTML pages\n struct SourceCollector<'a> {\n-    cx: &'a mut Context,\n+    scx: &'a mut SharedContext,\n \n     /// Root destination to place all HTML output into\n     dst: PathBuf,\n@@ -413,43 +416,37 @@ pub fn run(mut krate: clean::Crate,\n         Some(p) => p.to_path_buf(),\n         None => PathBuf::new(),\n     };\n-    let mut cx = Context {\n-        dst: dst,\n+    let mut scx = SharedContext {\n         src_root: src_root,\n         passes: passes,\n-        current: Vec::new(),\n-        root_path: String::new(),\n+        include_sources: true,\n+        local_sources: HashMap::new(),\n+        issue_tracker_base_url: None,\n         layout: layout::Layout {\n             logo: \"\".to_string(),\n             favicon: \"\".to_string(),\n             external_html: external_html.clone(),\n             krate: krate.name.clone(),\n             playground_url: \"\".to_string(),\n         },\n-        include_sources: true,\n-        local_sources: HashMap::new(),\n-        render_redirect_pages: false,\n-        issue_tracker_base_url: None,\n     };\n \n-    try_err!(mkdir(&cx.dst), &cx.dst);\n-\n     // Crawl the crate attributes looking for attributes which control how we're\n     // going to emit HTML\n     if let Some(attrs) = krate.module.as_ref().map(|m| m.attrs.list(\"doc\")) {\n         for attr in attrs {\n             match *attr {\n                 clean::NameValue(ref x, ref s)\n                         if \"html_favicon_url\" == *x => {\n-                    cx.layout.favicon = s.to_string();\n+                    scx.layout.favicon = s.to_string();\n                 }\n                 clean::NameValue(ref x, ref s)\n                         if \"html_logo_url\" == *x => {\n-                    cx.layout.logo = s.to_string();\n+                    scx.layout.logo = s.to_string();\n                 }\n                 clean::NameValue(ref x, ref s)\n                         if \"html_playground_url\" == *x => {\n-                    cx.layout.playground_url = s.to_string();\n+                    scx.layout.playground_url = s.to_string();\n                     markdown::PLAYGROUND_KRATE.with(|slot| {\n                         if slot.borrow().is_none() {\n                             let name = krate.name.clone();\n@@ -459,16 +456,25 @@ pub fn run(mut krate: clean::Crate,\n                 }\n                 clean::NameValue(ref x, ref s)\n                         if \"issue_tracker_base_url\" == *x => {\n-                    cx.issue_tracker_base_url = Some(s.to_string());\n+                    scx.issue_tracker_base_url = Some(s.to_string());\n                 }\n                 clean::Word(ref x)\n                         if \"html_no_source\" == *x => {\n-                    cx.include_sources = false;\n+                    scx.include_sources = false;\n                 }\n                 _ => {}\n             }\n         }\n     }\n+    try_err!(mkdir(&dst), &dst);\n+    krate = render_sources(&dst, &mut scx, krate)?;\n+    let cx = Context {\n+        current: Vec::new(),\n+        root_path: String::new(),\n+        dst: dst,\n+        render_redirect_pages: false,\n+        shared: Arc::new(scx),\n+    };\n \n     // Crawl the crate to build various caches used for the output\n     let analysis = ::ANALYSISKEY.with(|a| a.clone());\n@@ -492,8 +498,7 @@ pub fn run(mut krate: clean::Crate,\n         parent_is_trait_impl: false,\n         extern_locations: HashMap::new(),\n         primitive_locations: HashMap::new(),\n-        remove_priv: cx.passes.contains(\"strip-private\"),\n-        privmod: false,\n+        stripped_mod: false,\n         access_levels: access_levels,\n         orphan_methods: Vec::new(),\n         traits: mem::replace(&mut krate.external_traits, HashMap::new()),\n@@ -540,7 +545,6 @@ pub fn run(mut krate: clean::Crate,\n     CURRENT_LOCATION_KEY.with(|s| s.borrow_mut().clear());\n \n     write_shared(&cx, &krate, &*cache, index)?;\n-    let krate = render_sources(&mut cx, krate)?;\n \n     // And finally render the whole crate's documentation\n     cx.krate(krate)\n@@ -762,16 +766,16 @@ fn write_shared(cx: &Context,\n     Ok(())\n }\n \n-fn render_sources(cx: &mut Context,\n+fn render_sources(dst: &Path, scx: &mut SharedContext,\n                   krate: clean::Crate) -> Result<clean::Crate, Error> {\n     info!(\"emitting source files\");\n-    let dst = cx.dst.join(\"src\");\n+    let dst = dst.join(\"src\");\n     try_err!(mkdir(&dst), &dst);\n     let dst = dst.join(&krate.name);\n     try_err!(mkdir(&dst), &dst);\n     let mut folder = SourceCollector {\n         dst: dst,\n-        cx: cx,\n+        scx: scx,\n     };\n     Ok(folder.fold_crate(krate))\n }\n@@ -849,7 +853,7 @@ impl<'a> DocFolder for SourceCollector<'a> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         // If we're including source files, and we haven't seen this file yet,\n         // then we need to render it out to the filesystem\n-        if self.cx.include_sources\n+        if self.scx.include_sources\n             // skip all invalid spans\n             && item.source.filename != \"\"\n             // macros from other libraries get special filenames which we can\n@@ -862,7 +866,7 @@ impl<'a> DocFolder for SourceCollector<'a> {\n             // something like that), so just don't include sources for the\n             // entire crate. The other option is maintaining this mapping on a\n             // per-file basis, but that's probably not worth it...\n-            self.cx\n+            self.scx\n                 .include_sources = match self.emit_source(&item.source.filename) {\n                 Ok(()) => true,\n                 Err(e) => {\n@@ -874,7 +878,6 @@ impl<'a> DocFolder for SourceCollector<'a> {\n                 }\n             };\n         }\n-\n         self.fold_item_recur(item)\n     }\n }\n@@ -883,7 +886,7 @@ impl<'a> SourceCollector<'a> {\n     /// Renders the given filename into its corresponding HTML source file.\n     fn emit_source(&mut self, filename: &str) -> io::Result<()> {\n         let p = PathBuf::from(filename);\n-        if self.cx.local_sources.contains_key(&p) {\n+        if self.scx.local_sources.contains_key(&p) {\n             // We've already emitted this source\n             return Ok(());\n         }\n@@ -904,7 +907,7 @@ impl<'a> SourceCollector<'a> {\n         let mut cur = self.dst.clone();\n         let mut root_path = String::from(\"../../\");\n         let mut href = String::new();\n-        clean_srcpath(&self.cx.src_root, &p, false, |component| {\n+        clean_srcpath(&self.scx.src_root, &p, false, |component| {\n             cur.push(component);\n             mkdir(&cur).unwrap();\n             root_path.push_str(\"../\");\n@@ -928,24 +931,25 @@ impl<'a> SourceCollector<'a> {\n             description: &desc,\n             keywords: BASIC_KEYWORDS,\n         };\n-        layout::render(&mut w, &self.cx.layout,\n+        layout::render(&mut w, &self.scx.layout,\n                        &page, &(\"\"), &Source(contents))?;\n         w.flush()?;\n-        self.cx.local_sources.insert(p, href);\n+        self.scx.local_sources.insert(p, href);\n         Ok(())\n     }\n }\n \n impl DocFolder for Cache {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        // If this is a private module, we don't want it in the search index.\n-        let orig_privmod = match item.inner {\n-            clean::ModuleItem(..) => {\n-                let prev = self.privmod;\n-                self.privmod = prev || (self.remove_priv && item.visibility != Some(hir::Public));\n+        // If this is a stripped module,\n+        // we don't want it or its children in the search index.\n+        let orig_stripped_mod = match item.inner {\n+            clean::StrippedItem(box clean::ModuleItem(..)) => {\n+                let prev = self.stripped_mod;\n+                self.stripped_mod = true;\n                 prev\n             }\n-            _ => self.privmod,\n+            _ => self.stripped_mod,\n         };\n \n         // Register any generics to their corresponding string. This is used\n@@ -983,6 +987,7 @@ impl DocFolder for Cache {\n         // Index this method for searching later on\n         if let Some(ref s) = item.name {\n             let (parent, is_method) = match item.inner {\n+                clean::StrippedItem(..) => ((None, None), false),\n                 clean::AssociatedConstItem(..) |\n                 clean::TypedefItem(_, true) if self.parent_is_trait_impl => {\n                     // skip associated items in trait impls\n@@ -1021,20 +1026,17 @@ impl DocFolder for Cache {\n                 }\n                 _ => ((None, Some(&*self.stack)), false)\n             };\n-            let hidden_field = match item.inner {\n-                clean::StructFieldItem(clean::HiddenStructField) => true,\n-                _ => false\n-            };\n \n             match parent {\n-                (parent, Some(path)) if is_method || (!self.privmod && !hidden_field) => {\n+                (parent, Some(path)) if is_method || (!self.stripped_mod) => {\n                     // Needed to determine `self` type.\n                     let parent_basename = self.parent_stack.first().and_then(|parent| {\n                         match self.paths.get(parent) {\n                             Some(&(ref fqp, _)) => Some(fqp[fqp.len() - 1].clone()),\n                             _ => None\n                         }\n                     });\n+                    debug_assert!(!item.is_stripped());\n \n                     // A crate has a module at its root, containing all items,\n                     // which should not be indexed. The crate-item itself is\n@@ -1051,7 +1053,7 @@ impl DocFolder for Cache {\n                         });\n                     }\n                 }\n-                (Some(parent), None) if is_method || (!self.privmod && !hidden_field)=> {\n+                (Some(parent), None) if is_method || (!self.stripped_mod)=> {\n                     if parent.is_local() {\n                         // We have a parent, but we don't know where they're\n                         // defined yet. Wait for later to index this item.\n@@ -1075,7 +1077,7 @@ impl DocFolder for Cache {\n             clean::StructItem(..) | clean::EnumItem(..) |\n             clean::TypedefItem(..) | clean::TraitItem(..) |\n             clean::FunctionItem(..) | clean::ModuleItem(..) |\n-            clean::ForeignFunctionItem(..) if !self.privmod => {\n+            clean::ForeignFunctionItem(..) if !self.stripped_mod => {\n                 // Reexported items mean that the same id can show up twice\n                 // in the rustdoc ast that we're looking at. We know,\n                 // however, that a reexported item doesn't show up in the\n@@ -1093,7 +1095,7 @@ impl DocFolder for Cache {\n             }\n             // link variants to their parent enum because pages aren't emitted\n             // for each variant\n-            clean::VariantItem(..) if !self.privmod => {\n+            clean::VariantItem(..) if !self.stripped_mod => {\n                 let mut stack = self.stack.clone();\n                 stack.pop();\n                 self.paths.insert(item.def_id, (stack, ItemType::Enum));\n@@ -1176,7 +1178,7 @@ impl DocFolder for Cache {\n \n         if pushed { self.stack.pop().unwrap(); }\n         if parent_pushed { self.parent_stack.pop().unwrap(); }\n-        self.privmod = orig_privmod;\n+        self.stripped_mod = orig_stripped_mod;\n         self.parent_is_trait_impl = orig_parent_is_trait_impl;\n         return ret;\n     }\n@@ -1233,15 +1235,12 @@ impl Context {\n \n         // render the crate documentation\n         let mut work = vec!((self, item));\n-        loop {\n-            match work.pop() {\n-                Some((mut cx, item)) => cx.item(item, |cx, item| {\n-                    work.push((cx.clone(), item));\n-                })?,\n-                None => break,\n-            }\n-        }\n \n+        while let Some((mut cx, item)) = work.pop() {\n+            cx.item(item, |cx, item| {\n+                work.push((cx.clone(), item))\n+            })?\n+        }\n         Ok(())\n     }\n \n@@ -1272,10 +1271,10 @@ impl Context {\n             let tyname = shortty(it).to_static_str();\n             let desc = if it.is_crate() {\n                 format!(\"API documentation for the Rust `{}` crate.\",\n-                        cx.layout.krate)\n+                        cx.shared.layout.krate)\n             } else {\n                 format!(\"API documentation for the Rust `{}` {} in crate `{}`.\",\n-                        it.name.as_ref().unwrap(), tyname, cx.layout.krate)\n+                        it.name.as_ref().unwrap(), tyname, cx.shared.layout.krate)\n             };\n             let keywords = make_item_keywords(it);\n             let page = layout::Page {\n@@ -1293,90 +1292,83 @@ impl Context {\n             // write syscall all the time.\n             let mut writer = BufWriter::new(w);\n             if !cx.render_redirect_pages {\n-                layout::render(&mut writer, &cx.layout, &page,\n+                layout::render(&mut writer, &cx.shared.layout, &page,\n                                &Sidebar{ cx: cx, item: it },\n                                &Item{ cx: cx, item: it })?;\n+\n             } else {\n                 let mut url = repeat(\"../\").take(cx.current.len())\n                                            .collect::<String>();\n-                match cache().paths.get(&it.def_id) {\n-                    Some(&(ref names, _)) => {\n-                        for name in &names[..names.len() - 1] {\n-                            url.push_str(name);\n-                            url.push_str(\"/\");\n-                        }\n-                        url.push_str(&item_path(it));\n-                        layout::redirect(&mut writer, &url)?;\n+                if let Some(&(ref names, _)) = cache().paths.get(&it.def_id) {\n+                    for name in &names[..names.len() - 1] {\n+                        url.push_str(name);\n+                        url.push_str(\"/\");\n                     }\n-                    None => {}\n+                    url.push_str(&item_path(it));\n+                    layout::redirect(&mut writer, &url)?;\n                 }\n             }\n             writer.flush()\n         }\n \n-        // Private modules may survive the strip-private pass if they\n-        // contain impls for public types. These modules can also\n+        // Stripped modules survive the rustdoc passes (i.e. `strip-private`)\n+        // if they contain impls for public types. These modules can also\n         // contain items such as publicly reexported structures.\n         //\n         // External crates will provide links to these structures, so\n-        // these modules are recursed into, but not rendered normally (a\n-        // flag on the context).\n+        // these modules are recursed into, but not rendered normally\n+        // (a flag on the context).\n         if !self.render_redirect_pages {\n-            self.render_redirect_pages = self.ignore_private_item(&item);\n+            self.render_redirect_pages = self.maybe_ignore_item(&item);\n         }\n \n-        match item.inner {\n+        if item.is_mod() {\n             // modules are special because they add a namespace. We also need to\n             // recurse into the items of the module as well.\n-            clean::ModuleItem(..) => {\n-                let name = item.name.as_ref().unwrap().to_string();\n-                let mut item = Some(item);\n-                self.recurse(name, |this| {\n-                    let item = item.take().unwrap();\n-                    let joint_dst = this.dst.join(\"index.html\");\n-                    let dst = try_err!(File::create(&joint_dst), &joint_dst);\n-                    try_err!(render(dst, this, &item, false), &joint_dst);\n-\n-                    let m = match item.inner {\n-                        clean::ModuleItem(m) => m,\n-                        _ => unreachable!()\n-                    };\n-\n-                    // render sidebar-items.js used throughout this module\n-                    {\n-                        let items = this.build_sidebar_items(&m);\n-                        let js_dst = this.dst.join(\"sidebar-items.js\");\n-                        let mut js_out = BufWriter::new(try_err!(File::create(&js_dst), &js_dst));\n-                        try_err!(write!(&mut js_out, \"initSidebarItems({});\",\n-                                    as_json(&items)), &js_dst);\n-                    }\n+            let name = item.name.as_ref().unwrap().to_string();\n+            let mut item = Some(item);\n+            self.recurse(name, |this| {\n+                let item = item.take().unwrap();\n+                let joint_dst = this.dst.join(\"index.html\");\n+                let dst = try_err!(File::create(&joint_dst), &joint_dst);\n+                try_err!(render(dst, this, &item, false), &joint_dst);\n \n-                    for item in m.items {\n-                        f(this,item);\n-                    }\n-                    Ok(())\n-                })\n-            }\n+                let m = match item.inner {\n+                    clean::StrippedItem(box clean::ModuleItem(m)) |\n+                    clean::ModuleItem(m) => m,\n+                    _ => unreachable!()\n+                };\n \n-            // Things which don't have names (like impls) don't get special\n-            // pages dedicated to them.\n-            _ if item.name.is_some() => {\n-                let joint_dst = self.dst.join(&item_path(&item));\n+                // render sidebar-items.js used throughout this module\n+                {\n+                    let items = this.build_sidebar_items(&m);\n+                    let js_dst = this.dst.join(\"sidebar-items.js\");\n+                    let mut js_out = BufWriter::new(try_err!(File::create(&js_dst), &js_dst));\n+                    try_err!(write!(&mut js_out, \"initSidebarItems({});\",\n+                                    as_json(&items)), &js_dst);\n+                }\n \n-                let dst = try_err!(File::create(&joint_dst), &joint_dst);\n-                try_err!(render(dst, self, &item, true), &joint_dst);\n+                for item in m.items {\n+                    f(this,item);\n+                }\n                 Ok(())\n-            }\n+            })\n+        } else if item.name.is_some() {\n+            let joint_dst = self.dst.join(&item_path(&item));\n \n-            _ => Ok(())\n+            let dst = try_err!(File::create(&joint_dst), &joint_dst);\n+            try_err!(render(dst, self, &item, true), &joint_dst);\n+            Ok(())\n+        } else {\n+            Ok(())\n         }\n     }\n \n     fn build_sidebar_items(&self, m: &clean::Module) -> BTreeMap<String, Vec<NameDoc>> {\n         // BTreeMap instead of HashMap to get a sorted output\n         let mut map = BTreeMap::new();\n         for item in &m.items {\n-            if self.ignore_private_item(item) { continue }\n+            if self.maybe_ignore_item(item) { continue }\n \n             let short = shortty(item).to_static_str();\n             let myname = match item.name {\n@@ -1394,27 +1386,18 @@ impl Context {\n         return map;\n     }\n \n-    fn ignore_private_item(&self, it: &clean::Item) -> bool {\n+    fn maybe_ignore_item(&self, it: &clean::Item) -> bool {\n         match it.inner {\n+            clean::StrippedItem(..) => true,\n             clean::ModuleItem(ref m) => {\n-                (m.items.is_empty() &&\n-                 it.doc_value().is_none() &&\n-                 it.visibility != Some(hir::Public)) ||\n-                (self.passes.contains(\"strip-private\") && it.visibility != Some(hir::Public))\n-            }\n-            clean::PrimitiveItem(..) => it.visibility != Some(hir::Public),\n+                it.doc_value().is_none() && m.items.is_empty() && it.visibility != Some(hir::Public)\n+            },\n             _ => false,\n         }\n     }\n }\n \n impl<'a> Item<'a> {\n-    fn ismodule(&self) -> bool {\n-        match self.item.inner {\n-            clean::ModuleItem(..) => true, _ => false\n-        }\n-    }\n-\n     /// Generate a url appropriate for an `href` attribute back to the source of\n     /// this item.\n     ///\n@@ -1457,10 +1440,11 @@ impl<'a> Item<'a> {\n         // know the span, so we plow forward and generate a proper url. The url\n         // has anchors for the line numbers that we're linking to.\n         } else if self.item.def_id.is_local() {\n-            self.cx.local_sources.get(&PathBuf::from(&self.item.source.filename)).map(|path| {\n+            let path = PathBuf::from(&self.item.source.filename);\n+            self.cx.shared.local_sources.get(&path).map(|path| {\n                 format!(\"{root}src/{krate}/{path}#{href}\",\n                         root = self.cx.root_path,\n-                        krate = self.cx.layout.krate,\n+                        krate = self.cx.shared.layout.krate,\n                         path = path,\n                         href = href)\n             })\n@@ -1495,6 +1479,7 @@ impl<'a> Item<'a> {\n \n impl<'a> fmt::Display for Item<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        debug_assert!(!self.item.is_stripped());\n         // Write the breadcrumb trail header for the top\n         write!(fmt, \"\\n<h1 class='fqn'><span class='in-band'>\")?;\n         match self.item.inner {\n@@ -1516,7 +1501,7 @@ impl<'a> fmt::Display for Item<'a> {\n         };\n         if !is_primitive {\n             let cur = &self.cx.current;\n-            let amt = if self.ismodule() { cur.len() - 1 } else { cur.len() };\n+            let amt = if self.item.is_mod() { cur.len() - 1 } else { cur.len() };\n             for (i, component) in cur.iter().enumerate().take(amt) {\n                 write!(fmt, \"<a href='{}index.html'>{}</a>::<wbr>\",\n                        repeat(\"../\").take(cur.len() - i - 1)\n@@ -1542,7 +1527,7 @@ impl<'a> fmt::Display for Item<'a> {\n         // [src] link in the downstream documentation will actually come back to\n         // this page, and this link will be auto-clicked. The `id` attribute is\n         // used to find the link to auto-click.\n-        if self.cx.include_sources && !is_primitive {\n+        if self.cx.shared.include_sources && !is_primitive {\n             if let Some(l) = self.href() {\n                 write!(fmt, \"<a id='src-{}' class='srclink' \\\n                               href='{}' title='{}'>[src]</a>\",\n@@ -1575,15 +1560,12 @@ impl<'a> fmt::Display for Item<'a> {\n }\n \n fn item_path(item: &clean::Item) -> String {\n-    match item.inner {\n-        clean::ModuleItem(..) => {\n-            format!(\"{}/index.html\", item.name.as_ref().unwrap())\n-        }\n-        _ => {\n-            format!(\"{}.{}.html\",\n-                    shortty(item).to_static_str(),\n-                    *item.name.as_ref().unwrap())\n-        }\n+    if item.is_mod() {\n+        format!(\"{}/index.html\", item.name.as_ref().unwrap())\n+    } else {\n+        format!(\"{}.{}.html\",\n+                shortty(item).to_static_str(),\n+                *item.name.as_ref().unwrap())\n     }\n }\n \n@@ -1626,7 +1608,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     document(w, cx, item)?;\n \n     let mut indices = (0..items.len()).filter(|i| {\n-        !cx.ignore_private_item(&items[*i])\n+        !cx.maybe_ignore_item(&items[*i])\n     }).collect::<Vec<usize>>();\n \n     // the order of item types in the listing\n@@ -1670,6 +1652,9 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     let mut curty = None;\n     for &idx in &indices {\n         let myitem = &items[idx];\n+        if myitem.is_stripped() {\n+            continue;\n+        }\n \n         let myty = Some(shortty(myitem));\n         if curty == Some(ItemType::ExternCrate) && myty == Some(ItemType::Import) {\n@@ -1774,7 +1759,7 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Optio\n             format!(\"Deprecated{}{}\", since, Markdown(&reason))\n         } else if stab.level == stability::Unstable {\n             let unstable_extra = if show_reason {\n-                match (!stab.feature.is_empty(), &cx.issue_tracker_base_url, stab.issue) {\n+                match (!stab.feature.is_empty(), &cx.shared.issue_tracker_base_url, stab.issue) {\n                     (true, &Some(ref tracker_url), Some(issue_no)) if issue_no > 0 =>\n                         format!(\" (<code>{}</code> <a href=\\\"{}{}\\\">#{}</a>)\",\n                                 Escape(&stab.feature), tracker_url, issue_no, issue_no),\n@@ -2146,6 +2131,7 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                where_clause = WhereClause(g))\n     }\n     match item.inner {\n+        clean::StrippedItem(..) => Ok(()),\n         clean::TyMethodItem(ref m) => {\n             method(w, item, m.unsafety, hir::Constness::NotConst,\n                    m.abi, &m.generics, &m.self_, &m.decl, link)\n@@ -2182,8 +2168,7 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     document(w, cx, it)?;\n     let mut fields = s.fields.iter().filter(|f| {\n         match f.inner {\n-            clean::StructFieldItem(clean::HiddenStructField) => false,\n-            clean::StructFieldItem(clean::TypedStructField(..)) => true,\n+            clean::StructFieldItem(..) => true,\n             _ => false,\n         }\n     }).peekable();\n@@ -2273,7 +2258,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             if let clean::VariantItem( Variant { kind: StructVariant(ref s) } ) = variant.inner {\n                 let fields = s.fields.iter().filter(|f| {\n                     match f.inner {\n-                        clean::StructFieldItem(clean::TypedStructField(..)) => true,\n+                        clean::StructFieldItem(..) => true,\n                         _ => false,\n                     }\n                 });\n@@ -2332,24 +2317,17 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n     match ty {\n         doctree::Plain => {\n             write!(w, \" {{\\n{}\", tab)?;\n-            let mut fields_stripped = false;\n             for field in fields {\n-                match field.inner {\n-                    clean::StructFieldItem(clean::HiddenStructField) => {\n-                        fields_stripped = true;\n-                    }\n-                    clean::StructFieldItem(clean::TypedStructField(ref ty)) => {\n-                        write!(w, \"    {}{}: {},\\n{}\",\n-                               VisSpace(field.visibility),\n-                               field.name.as_ref().unwrap(),\n-                               *ty,\n-                               tab)?;\n-                    }\n-                    _ => unreachable!(),\n-                };\n+                if let clean::StructFieldItem(ref ty) = field.inner {\n+                    write!(w, \"    {}{}: {},\\n{}\",\n+                           VisSpace(field.visibility),\n+                           field.name.as_ref().unwrap(),\n+                           *ty,\n+                           tab)?;\n+                }\n             }\n \n-            if fields_stripped {\n+            if it.has_stripped_fields().unwrap() {\n                 write!(w, \"    // some fields omitted\\n{}\", tab)?;\n             }\n             write!(w, \"}}\")?;\n@@ -2361,10 +2339,10 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                     write!(w, \", \")?;\n                 }\n                 match field.inner {\n-                    clean::StructFieldItem(clean::HiddenStructField) => {\n+                    clean::StrippedItem(box clean::StructFieldItem(..)) => {\n                         write!(w, \"_\")?\n                     }\n-                    clean::StructFieldItem(clean::TypedStructField(ref ty)) => {\n+                    clean::StructFieldItem(ref ty) => {\n                         write!(w, \"{}{}\", VisSpace(field.visibility), *ty)?\n                     }\n                     _ => unreachable!()\n@@ -2540,6 +2518,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                 assoc_type(w, item, bounds, default.as_ref(), link)?;\n                 write!(w, \"</code></h4>\\n\")?;\n             }\n+            clean::StrippedItem(..) => return Ok(()),\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n         }\n \n@@ -2661,16 +2640,16 @@ impl<'a> fmt::Display for Source<'a> {\n             write!(fmt, \"<span id=\\\"{0}\\\">{0:1$}</span>\\n\", i, cols)?;\n         }\n         write!(fmt, \"</pre>\")?;\n-        write!(fmt, \"{}\", highlight::highlight(s, None, None))?;\n+        write!(fmt, \"{}\", highlight::render_with_highlighting(s, None, None))?;\n         Ok(())\n     }\n }\n \n fn item_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n               t: &clean::Macro) -> fmt::Result {\n-    w.write_str(&highlight::highlight(&t.source,\n-                                      Some(\"macro\"),\n-                                      None))?;\n+    w.write_str(&highlight::render_with_highlighting(&t.source,\n+                                                     Some(\"macro\"),\n+                                                     None))?;\n     render_stability_since_raw(w, it.stable_since(), None)?;\n     document(w, cx, it)\n }"}, {"sha": "f93ecb46228c2b4baca320809f6378321e0c5a19", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -21,6 +21,7 @@ use clean::Item;\n use plugins;\n use fold;\n use fold::DocFolder;\n+use fold::FoldItem::Strip;\n \n /// Strip items marked `#[doc(hidden)]`\n pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n@@ -39,18 +40,12 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n \n                     // use a dedicated hidden item for given item type if any\n                     match i.inner {\n-                        clean::StructFieldItem(..) => {\n-                            return Some(clean::Item {\n-                                inner: clean::StructFieldItem(clean::HiddenStructField),\n-                                ..i\n-                            });\n-                        }\n-                        _ => {\n-                            return None;\n+                        clean::StructFieldItem(..) | clean::ModuleItem(..) => {\n+                            return Strip(i).fold()\n                         }\n+                        _ => return None,\n                     }\n                 }\n-\n                 self.fold_item_recur(i)\n             }\n         }\n@@ -125,36 +120,32 @@ struct Stripper<'a> {\n impl<'a> fold::DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match i.inner {\n+            clean::StrippedItem(..) => return Some(i),\n             // These items can all get re-exported\n             clean::TypedefItem(..) | clean::StaticItem(..) |\n             clean::StructItem(..) | clean::EnumItem(..) |\n             clean::TraitItem(..) | clean::FunctionItem(..) |\n             clean::VariantItem(..) | clean::MethodItem(..) |\n-            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) => {\n+            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n+            clean::ConstantItem(..) => {\n                 if i.def_id.is_local() {\n                     if !self.access_levels.is_exported(i.def_id) {\n                         return None;\n                     }\n                 }\n             }\n \n-            clean::ConstantItem(..) => {\n-                if i.def_id.is_local() && !self.access_levels.is_exported(i.def_id) {\n-                    return None;\n-                }\n-            }\n-\n             clean::StructFieldItem(..) => {\n                 if i.visibility != Some(hir::Public) {\n-                    return Some(clean::Item {\n-                        inner: clean::StructFieldItem(clean::HiddenStructField),\n-                        ..i\n-                    })\n+                    return Strip(i).fold();\n                 }\n             }\n \n-            // handled below\n-            clean::ModuleItem(..) => {}\n+            clean::ModuleItem(..) => {\n+                if i.def_id.is_local() && i.visibility != Some(hir::Public) {\n+                    return Strip(self.fold_item_recur(i).unwrap()).fold()\n+                }\n+            }\n \n             // trait impls for private items should be stripped\n             clean::ImplItem(clean::Impl{\n@@ -165,7 +156,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n                 }\n             }\n             // handled in the `strip-priv-imports` pass\n-            clean::ExternCrateItem(..) | clean::ImportItem(_) => {}\n+            clean::ExternCrateItem(..) | clean::ImportItem(..) => {}\n \n             clean::DefaultImplItem(..) | clean::ImplItem(..) => {}\n \n@@ -187,7 +178,6 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n \n             // implementations of traits are always public.\n             clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n-\n             // Struct variant fields have inherited visibility\n             clean::VariantItem(clean::Variant {\n                 kind: clean::StructVariant(..)\n@@ -202,19 +192,17 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             self.fold_item_recur(i)\n         };\n \n-        i.and_then(|i| {\n-            match i.inner {\n-                // emptied modules/impls have no need to exist\n-                clean::ModuleItem(ref m)\n-                    if m.items.is_empty() &&\n-                       i.doc_value().is_none() => None,\n-                clean::ImplItem(ref i) if i.items.is_empty() => None,\n-                _ => {\n-                    self.retained.insert(i.def_id);\n-                    Some(i)\n-                }\n+        i.and_then(|i| { match i.inner {\n+            // emptied modules/impls have no need to exist\n+            clean::ModuleItem(ref m)\n+                if m.items.is_empty() &&\n+                   i.doc_value().is_none() => None,\n+            clean::ImplItem(ref i) if i.items.is_empty() => None,\n+            _ => {\n+                self.retained.insert(i.def_id);\n+                Some(i)\n             }\n-        })\n+        }})\n     }\n }\n "}, {"sha": "5bd3b9c4f59e706448321db39f9bc58d32ec38e9", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -431,7 +431,7 @@ impl Collector {\n                 // compiler failures are test failures\n                 should_panic: testing::ShouldPanic::No,\n             },\n-            testfn: testing::DynTestFn(Box::new(move|| {\n+            testfn: testing::DynTestFn(box move|| {\n                 runtest(&test,\n                         &cratename,\n                         cfgs,\n@@ -442,7 +442,7 @@ impl Collector {\n                         as_test_harness,\n                         compile_fail,\n                         &opts);\n-            }))\n+            })\n         });\n     }\n "}, {"sha": "f8b2d4dd23240bdcaf5f32fcbffe81357c46758d", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -85,12 +85,46 @@ pub fn init() {\n \n     #[cfg(not(target_os = \"nacl\"))]\n     unsafe fn reset_sigpipe() {\n-        assert!(libc::signal(libc::SIGPIPE, libc::SIG_IGN) != !0);\n+        assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != !0);\n     }\n     #[cfg(target_os = \"nacl\")]\n     unsafe fn reset_sigpipe() {}\n }\n \n+// Currently the minimum supported Android version of the standard library is\n+// API level 18 (android-18). Back in those days [1] the `signal` function was\n+// just an inline wrapper around `bsd_signal`, but starting in API level\n+// android-20 the `signal` symbols was introduced [2]. Finally, in android-21\n+// the API `bsd_signal` was removed [3].\n+//\n+// Basically this means that if we want to be binary compatible with multiple\n+// Android releases (oldest being 18 and newest being 21) then we need to check\n+// for both symbols and not actually link against either.\n+//\n+// Note that if we're not on android we just link against the `android` symbol\n+// itself.\n+//\n+// [1]: https://chromium.googlesource.com/android_tools/+/20ee6d20/ndk/platforms\n+//                                       /android-18/arch-arm/usr/include/signal.h\n+// [2]: https://chromium.googlesource.com/android_tools/+/fbd420/ndk_experimental\n+//                                       /platforms/android-20/arch-arm\n+//                                       /usr/include/signal.h\n+// [3]: https://chromium.googlesource.com/android_tools/+/20ee6d/ndk/platforms\n+//                                       /android-21/arch-arm/usr/include/signal.h\n+#[cfg(target_os = \"android\")]\n+unsafe fn signal(signum: libc::c_int,\n+                 handler: libc::sighandler_t) -> libc::sighandler_t {\n+    weak!(fn signal(libc::c_int, libc::sighandler_t) -> libc::sighandler_t);\n+    weak!(fn bsd_signal(libc::c_int, libc::sighandler_t) -> libc::sighandler_t);\n+\n+    let f = signal.get().or_else(|| bsd_signal.get());\n+    let f = f.expect(\"neither `signal` nor `bsd_signal` symbols found\");\n+    f(signum, handler)\n+}\n+\n+#[cfg(not(target_os = \"android\"))]\n+pub use libc::signal;\n+\n pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     match errno as libc::c_int {\n         libc::ECONNREFUSED => ErrorKind::ConnectionRefused,"}, {"sha": "270c2096b2c3b33aa34f3fca35e8fbd2fa600ec6", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -393,7 +393,7 @@ impl Command {\n             t!(cvt(libc::sigemptyset(&mut set)));\n             t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set,\n                                          ptr::null_mut())));\n-            let ret = libc::signal(libc::SIGPIPE, libc::SIG_DFL);\n+            let ret = super::signal(libc::SIGPIPE, libc::SIG_DFL);\n             if ret == libc::SIG_ERR {\n                 return io::Error::last_os_error()\n             }"}, {"sha": "99ab8741159e39075825b1a4e01fab4f2dea9cf1", "filename": "src/libstd/sys/unix/weak.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibstd%2Fsys%2Funix%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibstd%2Fsys%2Funix%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fweak.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -75,11 +75,5 @@ unsafe fn fetch(name: &str) -> usize {\n         Ok(cstr) => cstr,\n         Err(..) => return 0,\n     };\n-    let lib = libc::dlopen(0 as *const _, libc::RTLD_LAZY);\n-    if lib.is_null() {\n-        return 0\n-    }\n-    let ret = libc::dlsym(lib, name.as_ptr()) as usize;\n-    libc::dlclose(lib);\n-    return ret\n+    libc::dlsym(libc::RTLD_DEFAULT, name.as_ptr()) as usize\n }"}, {"sha": "8a50f07e6d85419d0253edbb9365519db5e9259a", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -52,6 +52,7 @@ impl Duration {\n     /// If the nanoseconds is greater than 1 billion (the number of nanoseconds\n     /// in a second), then it will carry over into the seconds provided.\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n+    #[inline]\n     pub fn new(secs: u64, nanos: u32) -> Duration {\n         let secs = secs + (nanos / NANOS_PER_SEC) as u64;\n         let nanos = nanos % NANOS_PER_SEC;\n@@ -60,12 +61,14 @@ impl Duration {\n \n     /// Creates a new `Duration` from the specified number of seconds.\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n+    #[inline]\n     pub fn from_secs(secs: u64) -> Duration {\n         Duration { secs: secs, nanos: 0 }\n     }\n \n     /// Creates a new `Duration` from the specified number of milliseconds.\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n+    #[inline]\n     pub fn from_millis(millis: u64) -> Duration {\n         let secs = millis / MILLIS_PER_SEC;\n         let nanos = ((millis % MILLIS_PER_SEC) as u32) * NANOS_PER_MILLI;\n@@ -77,6 +80,7 @@ impl Duration {\n     /// The extra precision represented by this duration is ignored (e.g. extra\n     /// nanoseconds are not represented in the returned value).\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n+    #[inline]\n     pub fn as_secs(&self) -> u64 { self.secs }\n \n     /// Returns the nanosecond precision represented by this duration.\n@@ -85,6 +89,7 @@ impl Duration {\n     /// represented by nanoseconds. The returned number always represents a\n     /// fractional portion of a second (e.g. it is less than one billion).\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n+    #[inline]\n     pub fn subsec_nanos(&self) -> u32 { self.nanos }\n }\n "}, {"sha": "f369582bc5c30f674c5a8fe78462ab9345a520d0", "filename": "src/libsyntax/errors/json.rs", "status": "modified", "additions": 60, "deletions": 15, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibsyntax%2Ferrors%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibsyntax%2Ferrors%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fjson.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -20,7 +20,7 @@\n // FIXME spec the JSON output properly.\n \n \n-use codemap::{Span, MultiSpan, CodeMap};\n+use codemap::{self, Span, MultiSpan, CodeMap};\n use diagnostics::registry::Registry;\n use errors::{Level, DiagnosticBuilder, SubDiagnostic, RenderSpan, CodeSuggestion};\n use errors::emitter::Emitter;\n@@ -197,8 +197,8 @@ impl DiagnosticSpan {\n \n     fn from_render_span(rsp: &RenderSpan, je: &JsonEmitter) -> Vec<DiagnosticSpan> {\n         match *rsp {\n-            // FIXME(#30701) handle Suggestion properly\n             RenderSpan::FullSpan(ref msp) |\n+            // FIXME(#30701) handle Suggestion properly\n             RenderSpan::Suggestion(CodeSuggestion { ref msp, .. }) => {\n                 DiagnosticSpan::from_multispan(msp, je)\n             }\n@@ -207,13 +207,13 @@ impl DiagnosticSpan {\n                     let end = je.cm.lookup_char_pos(span.hi);\n                     DiagnosticSpan {\n                         file_name: end.file.name.clone(),\n-                        byte_start: span.lo.0,\n+                        byte_start: span.hi.0,\n                         byte_end: span.hi.0,\n-                        line_start: 0,\n+                        line_start: end.line,\n                         line_end: end.line,\n-                        column_start: 0,\n+                        column_start: end.col.0 + 1,\n                         column_end: end.col.0 + 1,\n-                        text: DiagnosticSpanLine::from_span(span, je),\n+                        text: DiagnosticSpanLine::from_span_end(span, je),\n                     }\n                 }).collect()\n             }\n@@ -237,25 +237,70 @@ impl DiagnosticSpan {\n     }\n }\n \n-impl DiagnosticSpanLine {\n-    fn from_span(span: &Span, je: &JsonEmitter) -> Vec<DiagnosticSpanLine> {\n-        let lines = match je.cm.span_to_lines(*span) {\n+macro_rules! get_lines_for_span {\n+    ($span: ident, $je: ident) => {\n+        match $je.cm.span_to_lines(*$span) {\n             Ok(lines) => lines,\n             Err(_) => {\n                 debug!(\"unprintable span\");\n                 return Vec::new();\n             }\n-        };\n+        }\n+    }\n+}\n+\n+impl DiagnosticSpanLine {\n+    fn line_from_filemap(fm: &codemap::FileMap,\n+                         index: usize,\n+                         h_start: usize,\n+                         h_end: usize)\n+                         -> DiagnosticSpanLine {\n+        DiagnosticSpanLine {\n+            text: fm.get_line(index).unwrap().to_owned(),\n+            highlight_start: h_start,\n+            highlight_end: h_end,\n+        }\n+    }\n+\n+    /// Create a list of DiagnosticSpanLines from span - each line with any part\n+    /// of `span` gets a DiagnosticSpanLine, with the highlight indicating the\n+    /// `span` within the line.\n+    fn from_span(span: &Span, je: &JsonEmitter) -> Vec<DiagnosticSpanLine> {\n+        let lines = get_lines_for_span!(span, je);\n \n         let mut result = Vec::new();\n         let fm = &*lines.file;\n \n         for line in &lines.lines {\n-            result.push(DiagnosticSpanLine {\n-                text: fm.get_line(line.line_index).unwrap().to_owned(),\n-                highlight_start: line.start_col.0 + 1,\n-                highlight_end: line.end_col.0 + 1,\n-            });\n+            result.push(DiagnosticSpanLine::line_from_filemap(fm,\n+                                                              line.line_index,\n+                                                              line.start_col.0 + 1,\n+                                                              line.end_col.0 + 1));\n+        }\n+\n+        result\n+    }\n+\n+    /// Create a list of DiagnosticSpanLines from span - the result covers all\n+    /// of `span`, but the highlight is zero-length and at the end of `span`.\n+    fn from_span_end(span: &Span, je: &JsonEmitter) -> Vec<DiagnosticSpanLine> {\n+        let lines = get_lines_for_span!(span, je);\n+\n+        let mut result = Vec::new();\n+        let fm = &*lines.file;\n+\n+        for (i, line) in lines.lines.iter().enumerate() {\n+            // Invariant - CodeMap::span_to_lines will not return extra context\n+            // lines - the last line returned is the last line of `span`.\n+            let highlight = if i == lines.lines.len() - 1 {\n+                (line.end_col.0 + 1, line.end_col.0 + 1)\n+            } else {\n+                (0, 0)\n+            };\n+            result.push(DiagnosticSpanLine::line_from_filemap(fm,\n+                                                              line.line_index,\n+                                                              highlight.0,\n+                                                              highlight.1));\n         }\n \n         result"}, {"sha": "75916b87c129d1ba6e9df8faecafa82ab44d7399", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -6124,7 +6124,7 @@ impl<'a> Parser<'a> {\n \n         // Allow a leading :: because the paths are absolute either way.\n         // This occurs with \"use $crate::...\" in macros.\n-        self.eat(&token::ModSep);\n+        let is_global = self.eat(&token::ModSep);\n \n         if self.check(&token::OpenDelim(token::Brace)) {\n             // use {foo,bar}\n@@ -6135,7 +6135,7 @@ impl<'a> Parser<'a> {\n                 |p| p.parse_path_list_item())?;\n             let path = ast::Path {\n                 span: mk_sp(lo, self.span.hi),\n-                global: false,\n+                global: is_global,\n                 segments: Vec::new()\n             };\n             return Ok(P(spanned(lo, self.span.hi, ViewPathList(path, idents))));\n@@ -6164,7 +6164,7 @@ impl<'a> Parser<'a> {\n                     )?;\n                     let path = ast::Path {\n                         span: mk_sp(lo, self.span.hi),\n-                        global: false,\n+                        global: is_global,\n                         segments: path.into_iter().map(|identifier| {\n                             ast::PathSegment {\n                                 identifier: identifier,\n@@ -6180,7 +6180,7 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                     let path = ast::Path {\n                         span: mk_sp(lo, self.span.hi),\n-                        global: false,\n+                        global: is_global,\n                         segments: path.into_iter().map(|identifier| {\n                             ast::PathSegment {\n                                 identifier: identifier,\n@@ -6203,7 +6203,7 @@ impl<'a> Parser<'a> {\n         let mut rename_to = path[path.len() - 1];\n         let path = ast::Path {\n             span: mk_sp(lo, self.last_span.hi),\n-            global: false,\n+            global: is_global,\n             segments: path.into_iter().map(|identifier| {\n                 ast::PathSegment {\n                     identifier: identifier,"}, {"sha": "16417ac004461f685f0d5a04756565f73aba8e9f", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -514,7 +514,7 @@ macro_rules! declare_special_idents_and_keywords {(\n // If the special idents get renumbered, remember to modify these two as appropriate\n pub const SELF_KEYWORD_NAME: ast::Name = ast::Name(SELF_KEYWORD_NAME_NUM);\n const STATIC_KEYWORD_NAME: ast::Name = ast::Name(STATIC_KEYWORD_NAME_NUM);\n-const SUPER_KEYWORD_NAME: ast::Name = ast::Name(SUPER_KEYWORD_NAME_NUM);\n+pub const SUPER_KEYWORD_NAME: ast::Name = ast::Name(SUPER_KEYWORD_NAME_NUM);\n const SELF_TYPE_KEYWORD_NAME: ast::Name = ast::Name(SELF_TYPE_KEYWORD_NAME_NUM);\n \n pub const SELF_KEYWORD_NAME_NUM: u32 = 1;"}, {"sha": "61dfd4f8f867d42280e1b53380cc47dc4beff782", "filename": "src/snapshots.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -9,13 +9,15 @@ S 2016-03-18 235d774\n   freebsd-x86_64 390b9a9f60f3d0d6a52c04d939a0355f572d03b3\n \n S 2016-02-17 4d3eebf\n+  dragonfly-x86_64 765bb5820ad406e966ec0ac51c8070b656459b02\n   linux-i386 5f194aa7628c0703f0fd48adc4ec7f3cc64b98c7\n   linux-x86_64 d29b7607d13d64078b6324aec82926fb493f59ba\n   macos-i386 4c8e42dd649e247f3576bf9dfa273327b4907f9c\n   macos-x86_64 411a41363f922d1d93fa62ff2fedf5c35e9cccb2\n   winnt-i386 0c336d794a65f8e285c121866c7d59aa2dd0d1e1\n   winnt-x86_64 27e75b1bf99770b3564bcebd7f3230be01135a92\n   openbsd-x86_64 ac957c6b84de2bd67f01df085d9ea515f96e22f3\n+  freebsd-i386 4e2af0b34eb335e173aebff543be693724a956c2\n   freebsd-x86_64 f38991fbb81c1cd8d0bbda396f98f13a55b42804\n \n S 2015-12-18 3391630"}, {"sha": "2b061e3997d844b99bb4458e52fdf685da49739c", "filename": "src/test/auxiliary/reexp_stripped.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fauxiliary%2Freexp_stripped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fauxiliary%2Freexp_stripped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Freexp_stripped.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use private::Quz;\n+pub use hidden::Bar;\n+\n+mod private {\n+    pub struct Quz;\n+}\n+\n+#[doc(hidden)]\n+pub mod hidden {\n+    pub struct Bar;\n+}"}, {"sha": "02148a138c9d905c9f02d23c2ae5476d2b694db3", "filename": "src/test/compile-fail/consider-removing-last-semi.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fconsider-removing-last-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fconsider-removing-last-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconsider-removing-last-semi.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f() -> String {  //~ ERROR E0269\n+                    //~^ HELP detailed explanation\n+    0u8;\n+    \"bla\".to_string();  //~ HELP consider removing this semicolon\n+}\n+\n+fn g() -> String {  //~ ERROR E0269\n+                    //~^ HELP detailed explanation\n+    \"this won't work\".to_string();\n+    \"removeme\".to_string(); //~ HELP consider removing this semicolon\n+}\n+\n+fn main() {}"}, {"sha": "cdcdb919bdef57e2bafc84849e8dd0532f4606bc", "filename": "src/test/compile-fail/const-err-early.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fconst-err-early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fconst-err-early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err-early.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_indexing)]\n+#![deny(const_err)]\n+\n+pub const A: i8 = -std::i8::MIN; //~ ERROR attempted to negate with overflow\n+pub const B: u8 = 200u8 + 200u8; //~ ERROR attempted to add with overflow\n+pub const C: u8 = 200u8 * 4; //~ ERROR attempted to multiply with overflow\n+pub const D: u8 = 42u8 - (42u8 + 1); //~ ERROR attempted to subtract with overflow\n+pub const E: u8 = [5u8][1]; //~ ERROR index out of bounds\n+\n+fn main() {\n+    let _e = [6u8][1];\n+}"}, {"sha": "45e8fc37d878b60dddd0be3089b057ea680a2522", "filename": "src/test/compile-fail/const-err.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -10,15 +10,11 @@\n \n #![feature(rustc_attrs)]\n #![allow(exceeding_bitshifts)]\n-#![deny(const_err)]\n \n fn black_box<T>(_: T) {\n     unimplemented!()\n }\n \n-const BLA: u8 = 200u8 + 200u8;\n-//~^ ERROR attempted to add with overflow\n-\n #[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let a = -std::i8::MIN;\n@@ -30,7 +26,8 @@ fn main() {\n     //~^ WARN attempted to multiply with overflow\n     let d = 42u8 - (42u8 + 1);\n     //~^ WARN attempted to subtract with overflow\n-    let _e = BLA;\n+    let _e = [5u8][1];\n+    //~^ ERROR const index-expr is out of bounds\n     black_box(a);\n     black_box(b);\n     black_box(c);"}, {"sha": "9fdd24c42fdbd48447d526393e541ac19312c354", "filename": "src/test/compile-fail/const-eval-span.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fconst-eval-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fconst-eval-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-span.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -14,7 +14,7 @@\n struct S(i32);\n \n const CONSTANT: S = S(0);\n-//~^ ERROR: constant evaluation error: call on struct [E0080]\n+//~^ ERROR: unimplemented constant expression: tuple struct constructors [E0080]\n \n enum E {\n     V = CONSTANT,"}, {"sha": "4567cd4a74bb2a3ae343d9aea7679b1c8324e0fa", "filename": "src/test/compile-fail/const-pattern-not-const-evaluable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -17,12 +17,12 @@ enum Cake {\n use Cake::*;\n \n const BOO: (Cake, Cake) = (Marmor, BlackForest);\n-//~^ ERROR: constant evaluation error: non-constant path in constant expression [E0471]\n+//~^ ERROR: constant evaluation error: unimplemented constant expression: enum variants [E0471]\n const FOO: Cake = BOO.1;\n \n const fn foo() -> Cake {\n-    Marmor //~ ERROR: constant evaluation error: non-constant path in constant expression [E0471]\n-    //~^ ERROR: non-constant path in constant expression\n+    Marmor //~ ERROR: constant evaluation error: unimplemented constant expression: enum variants\n+    //~^ ERROR: unimplemented constant expression: enum variants\n }\n \n const WORKS: Cake = Marmor;"}, {"sha": "93e09c6d8d2d25161dc4b1ec1b5f624fb662ea4b", "filename": "src/test/compile-fail/feature-gate-negate-unsigned.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -17,7 +17,8 @@ impl std::ops::Neg for S {\n }\n \n const _MAX: usize = -1;\n-//~^ ERROR unary negation of unsigned integer\n+//~^ WARN unary negation of unsigned integer\n+//~| ERROR unary negation of unsigned integer\n //~| HELP use a cast or the `!` operator\n \n fn main() {"}, {"sha": "4743b779ef63ee825778259a6435ff8c084a302f", "filename": "src/test/compile-fail/issue-32119.rs", "status": "renamed", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fissue-32119.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fissue-32119.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32119.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -9,15 +9,20 @@\n // except according to those terms.\n \n #![feature(rustc_attrs)]\n-#![allow(unused_imports)]\n \n-pub type Type = i32;\n+pub type T = ();\n+mod foo { pub use super::T; }\n+mod bar { pub use super::T; }\n \n-mod one { use super::Type; }\n-pub use self::one::*;\n+pub use foo::*;\n+pub use bar::*;\n \n-mod two { use super::Type; }\n-pub use self::two::*;\n+mod baz {\n+    pub type T = ();\n+    mod foo { pub use super::T as S; }\n+    mod bar { pub use super::foo::S as T; }\n+    pub use self::bar::*;\n+}\n \n #[rustc_error]\n fn main() {} //~ ERROR compilation successful", "previous_filename": "src/test/compile-fail/issue-32089.rs"}, {"sha": "fe7e66a2116ebb7fa4d5740b7929dff14bc9db3d", "filename": "src/test/compile-fail/issue-32128.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fissue-32128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fissue-32128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32128.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Example {\n+    example: Box<Fn(i32) -> i32>\n+}\n+\n+fn main() {\n+    let demo = Example {\n+        example: Box::new(|x| {\n+            x + 1\n+        })\n+    };\n+\n+    demo.example(1);    //~ ERROR no method named `example`\n+                        //~^ NOTE use `(demo.example)(...)`\n+    // (demo.example)(1);\n+}"}, {"sha": "8af243afc22996b064c55ecc24e68aec2c7d82c4", "filename": "src/test/compile-fail/issue-32326.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fissue-32326.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fissue-32326.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32326.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #32326. We ran out of memory because we\n+// attempted to expand this case up to the recursion limit, and 2^N is\n+// too big.\n+\n+enum Expr { //~ ERROR E0072\n+    Plus(Expr, Expr),\n+    Literal(i64),\n+}\n+\n+fn main() { }"}, {"sha": "9564a080b8ee7d6ca7f8c8dbb04d125921408ba9", "filename": "src/test/compile-fail/non-constant-enum-for-vec-repeat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -15,5 +15,5 @@ enum State { ST_NULL, ST_WHITESPACE }\n \n fn main() {\n     [State::ST_NULL; (State::ST_WHITESPACE as usize)];\n-    //~^ ERROR expected constant integer for repeat count, but non-constant path\n+    //~^ ERROR expected constant integer for repeat count, but unimplemented constant expression\n }"}, {"sha": "d2376eecd9b504295aaf90f81fc932187847c3eb", "filename": "src/test/compile-fail/non-interger-atomic.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fnon-interger-atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fnon-interger-atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-interger-atomic.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -0,0 +1,117 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(core_intrinsics, rustc_attrs)]\n+#![allow(warnings)]\n+\n+use std::intrinsics;\n+\n+#[derive(Copy, Clone)]\n+struct Foo(i64);\n+type Bar = &'static Fn();\n+type Quux = [u8; 100];\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_bool_load(p: &mut bool, v: bool) {\n+    intrinsics::atomic_load(p);\n+    //~^ ERROR `atomic_load` intrinsic: expected basic integer type, found `bool`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_bool_store(p: &mut bool, v: bool) {\n+    intrinsics::atomic_store(p, v);\n+    //~^ ERROR `atomic_store` intrinsic: expected basic integer type, found `bool`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_bool_xchg(p: &mut bool, v: bool) {\n+    intrinsics::atomic_xchg(p, v);\n+    //~^ ERROR `atomic_xchg` intrinsic: expected basic integer type, found `bool`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_bool_cxchg(p: &mut bool, v: bool) {\n+    intrinsics::atomic_cxchg(p, v, v);\n+    //~^ ERROR `atomic_cxchg` intrinsic: expected basic integer type, found `bool`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Foo_load(p: &mut Foo, v: Foo) {\n+    intrinsics::atomic_load(p);\n+    //~^ ERROR `atomic_load` intrinsic: expected basic integer type, found `Foo`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Foo_store(p: &mut Foo, v: Foo) {\n+    intrinsics::atomic_store(p, v);\n+    //~^ ERROR `atomic_store` intrinsic: expected basic integer type, found `Foo`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Foo_xchg(p: &mut Foo, v: Foo) {\n+    intrinsics::atomic_xchg(p, v);\n+    //~^ ERROR `atomic_xchg` intrinsic: expected basic integer type, found `Foo`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Foo_cxchg(p: &mut Foo, v: Foo) {\n+    intrinsics::atomic_cxchg(p, v, v);\n+    //~^ ERROR `atomic_cxchg` intrinsic: expected basic integer type, found `Foo`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Bar_load(p: &mut Bar, v: Bar) {\n+    intrinsics::atomic_load(p);\n+    //~^ ERROR expected basic integer type, found `&'static std::ops::Fn() + 'static`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Bar_store(p: &mut Bar, v: Bar) {\n+    intrinsics::atomic_store(p, v);\n+    //~^ ERROR expected basic integer type, found `&'static std::ops::Fn() + 'static`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Bar_xchg(p: &mut Bar, v: Bar) {\n+    intrinsics::atomic_xchg(p, v);\n+    //~^ ERROR expected basic integer type, found `&'static std::ops::Fn() + 'static`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Bar_cxchg(p: &mut Bar, v: Bar) {\n+    intrinsics::atomic_cxchg(p, v, v);\n+    //~^ ERROR expected basic integer type, found `&'static std::ops::Fn() + 'static`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Quux_load(p: &mut Quux, v: Quux) {\n+    intrinsics::atomic_load(p);\n+    //~^ ERROR `atomic_load` intrinsic: expected basic integer type, found `[u8; 100]`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Quux_store(p: &mut Quux, v: Quux) {\n+    intrinsics::atomic_store(p, v);\n+    //~^ ERROR `atomic_store` intrinsic: expected basic integer type, found `[u8; 100]`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Quux_xchg(p: &mut Quux, v: Quux) {\n+    intrinsics::atomic_xchg(p, v);\n+    //~^ ERROR `atomic_xchg` intrinsic: expected basic integer type, found `[u8; 100]`\n+}\n+\n+#[rustc_no_mir] // FIXME #27840 MIR doesn't provide precise spans for calls.\n+unsafe fn test_Quux_cxchg(p: &mut Quux, v: Quux) {\n+    intrinsics::atomic_cxchg(p, v, v);\n+    //~^ ERROR `atomic_cxchg` intrinsic: expected basic integer type, found `[u8; 100]`\n+}\n+\n+fn main() {}"}, {"sha": "3d7c4868e96fe3bff3e62da72e0752ecc45c519a", "filename": "src/test/compile-fail/sized-cycle-note.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fsized-cycle-note.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fsized-cycle-note.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsized-cycle-note.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -20,11 +20,11 @@ struct Baz { q: Option<Foo> }\n \n struct Foo { q: Option<Baz> }\n //~^ ERROR recursive type `Foo` has infinite size\n-//~| type `Foo` is embedded within `std::option::Option<Foo>`...\n-//~| ...which in turn is embedded within `std::option::Option<Foo>`...\n-//~| ...which in turn is embedded within `Baz`...\n-//~| ...which in turn is embedded within `std::option::Option<Baz>`...\n-//~| ...which in turn is embedded within `Foo`, completing the cycle.\n+//~| NOTE type `Foo` is embedded within `std::option::Option<Foo>`...\n+//~| NOTE ...which in turn is embedded within `std::option::Option<Foo>`...\n+//~| NOTE ...which in turn is embedded within `Baz`...\n+//~| NOTE ...which in turn is embedded within `std::option::Option<Baz>`...\n+//~| NOTE ...which in turn is embedded within `Foo`, completing the cycle.\n \n impl Foo { fn bar(&self) {} }\n "}, {"sha": "cdf4b405fd83e7bd398c6a55eb6082eed820f1e3", "filename": "src/test/compile-fail/traits-inductive-overflow-auto-normal-auto.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-auto-normal-auto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-auto-normal-auto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-auto-normal-auto.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test for a potential corner case in current impl where you have an\n+// auto trait (Magic1) that depends on a normal trait (Magic2) which\n+// in turn depends on the auto trait (Magic1). This was incorrectly\n+// being considered coinductive, but because of the normal trait\n+// interfering, it should not be.\n+\n+#![feature(optin_builtin_traits)]\n+\n+trait Magic1: Magic2 { }\n+impl Magic1 for .. {}\n+\n+trait Magic2 { }\n+impl<T: Magic1> Magic2 for T { }\n+\n+fn is_magic1<T: Magic1>() { }\n+\n+#[derive(Debug)]\n+struct NoClone;\n+\n+fn main() {\n+    is_magic1::<NoClone>(); //~ ERROR E0275\n+}"}, {"sha": "d721d428f29f597e7957a63fc9938ee1f6b2e6a9", "filename": "src/test/compile-fail/use-super-global-path.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fuse-super-global-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Fcompile-fail%2Fuse-super-global-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-super-global-path.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+mod foo {\n+    pub fn g() {\n+        use ::super::main; //~ WARN expected identifier, found keyword `super`\n+        //~^ WARN this was previously accepted by the compiler but is being phased out\n+        main();\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { foo::g(); } //~ ERROR compilation successful"}, {"sha": "6c393ce99e34df204e3d2c2eb8b2fcc7c0cae7db", "filename": "src/test/run-pass/foreign-dupe.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -31,9 +31,20 @@ mod rustrt2 {\n     }\n }\n \n+mod rustrt3 {\n+    // Different type, but same ABI (on all supported platforms).\n+    // Ensures that we don't ICE or trigger LLVM asserts when\n+    // importing the same symbol under different types.\n+    // See https://github.com/rust-lang/rust/issues/32740.\n+    extern {\n+        pub fn rust_get_test_int() -> *const u8;\n+    }\n+}\n+\n pub fn main() {\n     unsafe {\n-        rustrt1::rust_get_test_int();\n-        rustrt2::rust_get_test_int();\n+        let x = rustrt1::rust_get_test_int();\n+        assert_eq!(x, rustrt2::rust_get_test_int());\n+        assert_eq!(x as *const _, rustrt3::rust_get_test_int());\n     }\n }"}, {"sha": "6e20662b702a94c254547bf231018e1938bae0ea", "filename": "src/test/run-pass/issue-23550.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Frun-pass%2Fissue-23550.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Frun-pass%2Fissue-23550.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23550.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -16,24 +16,16 @@ use std::intrinsics;\n #[derive(Copy, Clone)]\n struct Wrap(i64);\n \n-// These volatile and atomic intrinsics used to cause an ICE\n+// These volatile intrinsics used to cause an ICE\n \n unsafe fn test_bool(p: &mut bool, v: bool) {\n     intrinsics::volatile_load(p);\n     intrinsics::volatile_store(p, v);\n-    intrinsics::atomic_load(p);\n-    intrinsics::atomic_cxchg(p, v, v);\n-    intrinsics::atomic_store(p, v);\n-    intrinsics::atomic_xchg(p, v);\n }\n \n unsafe fn test_immediate_fca(p: &mut Wrap, v: Wrap) {\n     intrinsics::volatile_load(p);\n     intrinsics::volatile_store(p, v);\n-    intrinsics::atomic_load(p);\n-    intrinsics::atomic_cxchg(p, v, v);\n-    intrinsics::atomic_store(p, v);\n-    intrinsics::atomic_xchg(p, v);\n }\n \n fn main() {}"}, {"sha": "98e66e8c024bd3a49d48e574aa265db506cdba6b", "filename": "src/test/rustdoc/redirect.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Frustdoc%2Fredirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Frustdoc%2Fredirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fredirect.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:reexp_stripped.rs\n+// build-aux-docs\n+// ignore-cross-compile\n+\n+extern crate reexp_stripped;\n+\n+pub trait Foo {}\n+\n+// @has redirect/index.html\n+// @has - '//code' 'pub use reexp_stripped::Bar'\n+// @has - '//code/a' 'Bar'\n+// @has reexp_stripped/hidden/struct.Bar.html\n+// @has - '//p/a' '../../reexp_stripped/struct.Bar.html'\n+// @has 'reexp_stripped/struct.Bar.html'\n+#[doc(no_inline)]\n+pub use reexp_stripped::Bar;\n+impl Foo for Bar {}\n+\n+// @has redirect/index.html\n+// @has - '//code' 'pub use reexp_stripped::Quz'\n+// @has - '//code/a' 'Quz'\n+// @has reexp_stripped/private/struct.Quz.html\n+// @has - '//p/a' '../../reexp_stripped/struct.Quz.html'\n+// @has 'reexp_stripped/struct.Quz.html'\n+#[doc(no_inline)]\n+pub use reexp_stripped::Quz;\n+impl Foo for Quz {}\n+\n+mod private_no_inline {\n+    pub struct Qux;\n+    impl ::Foo for Qux {}\n+}\n+\n+// @has redirect/index.html\n+// @has - '//code' 'pub use private_no_inline::Qux'\n+// @!has - '//code/a' 'Qux'\n+#[doc(no_inline)]\n+pub use private_no_inline::Qux;"}, {"sha": "c4327f70728cb138d7d660b7f903c34f272d40e5", "filename": "src/test/rustdoc/structfields.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Frustdoc%2Fstructfields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9ffb899195291c6682c244f2d485b6121a7dc4/src%2Ftest%2Frustdoc%2Fstructfields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fstructfields.rs?ref=1e9ffb899195291c6682c244f2d485b6121a7dc4", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// @has structfields/struct.Foo.html\n+pub struct Foo {\n+    // @has - //pre \"pub a: ()\"\n+    pub a: (),\n+    // @has - //pre \"// some fields omitted\"\n+    // @!has - //pre \"b: ()\"\n+    b: (),\n+    // @!has - //pre \"c: usize\"\n+    #[doc(hidden)]\n+    c: usize,\n+    // @has - //pre \"pub d: usize\"\n+    pub d: usize,\n+}\n+\n+// @has structfields/struct.Bar.html\n+pub struct Bar {\n+    // @has - //pre \"pub a: ()\"\n+    pub a: (),\n+    // @!has - //pre \"// some fields omitted\"\n+}\n+\n+// @has structfields/enum.Qux.html\n+pub enum Qux {\n+    Quz {\n+        // @has - //pre \"a: ()\"\n+        a: (),\n+        // @!has - //pre \"b: ()\"\n+        #[doc(hidden)]\n+        b: (),\n+        // @has - //pre \"c: usize\"\n+        c: usize,\n+        // @has - //pre \"// some fields omitted\"\n+    },\n+}"}]}