{"sha": "c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2MDliMmVhZjMyMzE4NmExMTY3ZWMxYTlmZmE2OWE3ZDRhNWIxYjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-20T19:54:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-20T19:54:15Z"}, "message": "Auto merge of #78317 - est31:linear_in_impl_count, r=matthewjasper\n\nTurn quadratic time on number of impl blocks into linear time\n\nPreviously, if you had a lot of inherent impl blocks on a type like:\n\n```Rust\nstruct Foo;\n\nimpl Foo { fn foo_1() {} }\n// ...\nimpl Foo { fn foo_100_000() {} }\n```\n\nThe compiler would be very slow at processing it, because\nan internal algorithm would run in O(n^2), where n is the number\nof impl blocks. Now, we add a new algorithm that allocates but\nis faster asymptotically.\n\nComparing rustc nightly with a local build of rustc as of this PR (results in seconds):\n\n| N | real time before | real time after |\n| - | - | - |\n| 4_000 | 0.57 | 0.46 |\n| 8_000  | 1.31  | 0.84 |\n| 16_000  | 3.56 | 1.69 |\n| 32_000 | 10.60 | 3.73 |\n\nI've tuned up the numbers to make the effect larger than the startup noise of rustc, but the asymptotic difference should hold for smaller n as well.\n\nNote: current state of the PR omits error messages if there are other errors present already. For now, I'm mainly interested in a perf run to study whether this issue is present at all. Please queue one for this PR. Thanks!", "tree": {"sha": "cfe92040fc57b5e8bb2b08d37dbf49e9eafbf0f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfe92040fc57b5e8bb2b08d37dbf49e9eafbf0f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9", "html_url": "https://github.com/rust-lang/rust/commit/c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0e5c7d1fee37f1890455b977495bfe262716701", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0e5c7d1fee37f1890455b977495bfe262716701", "html_url": "https://github.com/rust-lang/rust/commit/b0e5c7d1fee37f1890455b977495bfe262716701"}, {"sha": "73a7d935dc55b4757706a966179459670e386582", "url": "https://api.github.com/repos/rust-lang/rust/commits/73a7d935dc55b4757706a966179459670e386582", "html_url": "https://github.com/rust-lang/rust/commit/73a7d935dc55b4757706a966179459670e386582"}], "stats": {"total": 381, "additions": 365, "deletions": 16}, "files": [{"sha": "50d88674328177a07ef3c1a9ce450ac4177245e3", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 159, "deletions": 16, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9", "patch": "@@ -1,10 +1,13 @@\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::{self, TyCtxt};\n+use rustc_span::Symbol;\n use rustc_trait_selection::traits::{self, SkipLeakCheck};\n use smallvec::SmallVec;\n+use std::collections::hash_map::Entry;\n \n pub fn crate_inherent_impls_overlap_check(tcx: TyCtxt<'_>, crate_num: CrateNum) {\n     assert_eq!(crate_num, LOCAL_CRATE);\n@@ -33,12 +36,9 @@ impl InherentOverlapChecker<'tcx> {\n         }\n \n         for item1 in impl_items1.in_definition_order() {\n-            let collision = impl_items2.filter_by_name_unhygienic(item1.ident.name).any(|item2| {\n-                // Symbols and namespace match, compare hygienically.\n-                item1.kind.namespace() == item2.kind.namespace()\n-                    && item1.ident.normalize_to_macros_2_0()\n-                        == item2.ident.normalize_to_macros_2_0()\n-            });\n+            let collision = impl_items2\n+                .filter_by_name_unhygienic(item1.ident.name)\n+                .any(|item2| self.compare_hygienically(item1, item2));\n \n             if collision {\n                 return true;\n@@ -48,6 +48,12 @@ impl InherentOverlapChecker<'tcx> {\n         false\n     }\n \n+    fn compare_hygienically(&self, item1: &ty::AssocItem, item2: &ty::AssocItem) -> bool {\n+        // Symbols and namespace match, compare hygienically.\n+        item1.kind.namespace() == item2.kind.namespace()\n+            && item1.ident.normalize_to_macros_2_0() == item2.ident.normalize_to_macros_2_0()\n+    }\n+\n     fn check_for_common_items_in_impls(\n         &self,\n         impl1: DefId,\n@@ -58,12 +64,9 @@ impl InherentOverlapChecker<'tcx> {\n         let impl_items2 = self.tcx.associated_items(impl2);\n \n         for item1 in impl_items1.in_definition_order() {\n-            let collision = impl_items2.filter_by_name_unhygienic(item1.ident.name).find(|item2| {\n-                // Symbols and namespace match, compare hygienically.\n-                item1.kind.namespace() == item2.kind.namespace()\n-                    && item1.ident.normalize_to_macros_2_0()\n-                        == item2.ident.normalize_to_macros_2_0()\n-            });\n+            let collision = impl_items2\n+                .filter_by_name_unhygienic(item1.ident.name)\n+                .find(|item2| self.compare_hygienically(item1, item2));\n \n             if let Some(item2) = collision {\n                 let name = item1.ident.normalize_to_macros_2_0();\n@@ -134,10 +137,150 @@ impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n                     .map(|impl_def_id| (impl_def_id, self.tcx.associated_items(*impl_def_id)))\n                     .collect::<SmallVec<[_; 8]>>();\n \n-                for (i, &(&impl1_def_id, impl_items1)) in impls_items.iter().enumerate() {\n-                    for &(&impl2_def_id, impl_items2) in &impls_items[(i + 1)..] {\n-                        if self.impls_have_common_items(impl_items1, impl_items2) {\n-                            self.check_for_overlapping_inherent_impls(impl1_def_id, impl2_def_id);\n+                // Perform a O(n^2) algorithm for small n,\n+                // otherwise switch to an allocating algorithm with\n+                // faster asymptotic runtime.\n+                const ALLOCATING_ALGO_THRESHOLD: usize = 500;\n+                if impls.len() < ALLOCATING_ALGO_THRESHOLD {\n+                    for (i, &(&impl1_def_id, impl_items1)) in impls_items.iter().enumerate() {\n+                        for &(&impl2_def_id, impl_items2) in &impls_items[(i + 1)..] {\n+                            if self.impls_have_common_items(impl_items1, impl_items2) {\n+                                self.check_for_overlapping_inherent_impls(\n+                                    impl1_def_id,\n+                                    impl2_def_id,\n+                                );\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    // Build a set of connected regions of impl blocks.\n+                    // Two impl blocks are regarded as connected if they share\n+                    // an item with the same unhygienic identifier.\n+                    // After we have assembled the connected regions,\n+                    // run the O(n^2) algorithm on each connected region.\n+                    // This is advantageous to running the algorithm over the\n+                    // entire graph when there are many connected regions.\n+\n+                    struct ConnectedRegion {\n+                        idents: SmallVec<[Symbol; 8]>,\n+                        impl_blocks: FxHashSet<usize>,\n+                    }\n+                    // Highest connected region id\n+                    let mut highest_region_id = 0;\n+                    let mut connected_region_ids = FxHashMap::default();\n+                    let mut connected_regions = FxHashMap::default();\n+\n+                    for (i, &(&_impl_def_id, impl_items)) in impls_items.iter().enumerate() {\n+                        if impl_items.len() == 0 {\n+                            continue;\n+                        }\n+                        // First obtain a list of existing connected region ids\n+                        let mut idents_to_add = SmallVec::<[Symbol; 8]>::new();\n+                        let ids = impl_items\n+                            .in_definition_order()\n+                            .filter_map(|item| {\n+                                let entry = connected_region_ids.entry(item.ident.name);\n+                                if let Entry::Occupied(e) = &entry {\n+                                    Some(*e.get())\n+                                } else {\n+                                    idents_to_add.push(item.ident.name);\n+                                    None\n+                                }\n+                            })\n+                            .collect::<FxHashSet<usize>>();\n+                        match ids.len() {\n+                            0 | 1 => {\n+                                let id_to_set = if ids.len() == 0 {\n+                                    // Create a new connected region\n+                                    let region = ConnectedRegion {\n+                                        idents: idents_to_add,\n+                                        impl_blocks: std::iter::once(i).collect(),\n+                                    };\n+                                    connected_regions.insert(highest_region_id, region);\n+                                    (highest_region_id, highest_region_id += 1).0\n+                                } else {\n+                                    // Take the only id inside the list\n+                                    let id_to_set = *ids.iter().next().unwrap();\n+                                    let region = connected_regions.get_mut(&id_to_set).unwrap();\n+                                    region.impl_blocks.insert(i);\n+                                    region.idents.extend_from_slice(&idents_to_add);\n+                                    id_to_set\n+                                };\n+                                let (_id, region) = connected_regions.iter().next().unwrap();\n+                                // Update the connected region ids\n+                                for ident in region.idents.iter() {\n+                                    connected_region_ids.insert(*ident, id_to_set);\n+                                }\n+                            }\n+                            _ => {\n+                                // We have multiple connected regions to merge.\n+                                // In the worst case this might add impl blocks\n+                                // one by one and can thus be O(n^2) in the size\n+                                // of the resulting final connected region, but\n+                                // this is no issue as the final step to check\n+                                // for overlaps runs in O(n^2) as well.\n+\n+                                // Take the smallest id from the list\n+                                let id_to_set = *ids.iter().min().unwrap();\n+\n+                                // Sort the id list so that the algorithm is deterministic\n+                                let mut ids = ids.into_iter().collect::<SmallVec<[_; 8]>>();\n+                                ids.sort();\n+\n+                                let mut region = connected_regions.remove(&id_to_set).unwrap();\n+                                region.idents.extend_from_slice(&idents_to_add);\n+                                region.impl_blocks.insert(i);\n+\n+                                for &id in ids.iter() {\n+                                    if id == id_to_set {\n+                                        continue;\n+                                    }\n+                                    let r = connected_regions.remove(&id).unwrap();\n+                                    // Update the connected region ids\n+                                    for ident in r.idents.iter() {\n+                                        connected_region_ids.insert(*ident, id_to_set);\n+                                    }\n+                                    region.idents.extend_from_slice(&r.idents);\n+                                    region.impl_blocks.extend(r.impl_blocks);\n+                                }\n+                                connected_regions.insert(id_to_set, region);\n+                            }\n+                        }\n+                    }\n+\n+                    debug!(\n+                        \"churning through {} components (sum={}, avg={}, var={}, max={})\",\n+                        connected_regions.len(),\n+                        impls.len(),\n+                        impls.len() / connected_regions.len(),\n+                        {\n+                            let avg = impls.len() / connected_regions.len();\n+                            let s = connected_regions\n+                                .iter()\n+                                .map(|r| r.1.impl_blocks.len() as isize - avg as isize)\n+                                .map(|v| v.abs() as usize)\n+                                .sum::<usize>();\n+                            s / connected_regions.len()\n+                        },\n+                        connected_regions.iter().map(|r| r.1.impl_blocks.len()).max().unwrap()\n+                    );\n+                    // List of connected regions is built. Now, run the overlap check\n+                    // for each pair of impl blocks in the same connected region.\n+                    for (_id, region) in connected_regions.into_iter() {\n+                        let mut impl_blocks =\n+                            region.impl_blocks.into_iter().collect::<SmallVec<[_; 8]>>();\n+                        impl_blocks.sort();\n+                        for (i, &impl1_items_idx) in impl_blocks.iter().enumerate() {\n+                            let &(&impl1_def_id, impl_items1) = &impls_items[impl1_items_idx];\n+                            for &impl2_items_idx in impl_blocks[(i + 1)..].iter() {\n+                                let &(&impl2_def_id, impl_items2) = &impls_items[impl2_items_idx];\n+                                if self.impls_have_common_items(impl_items1, impl_items2) {\n+                                    self.check_for_overlapping_inherent_impls(\n+                                        impl1_def_id,\n+                                        impl2_def_id,\n+                                    );\n+                                }\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "42ed5d19deb8409262f8d0ed281a9bcc77594041", "filename": "src/test/ui/inherent-impls-overlap-check/auxiliary/repeat.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9/src%2Ftest%2Fui%2Finherent-impls-overlap-check%2Fauxiliary%2Frepeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9/src%2Ftest%2Fui%2Finherent-impls-overlap-check%2Fauxiliary%2Frepeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finherent-impls-overlap-check%2Fauxiliary%2Frepeat.rs?ref=c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9", "patch": "@@ -0,0 +1,54 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::{Ident, Group, TokenStream, TokenTree as Tt};\n+\n+// This constant has to be above the ALLOCATING_ALGO_THRESHOLD\n+// constant in inherent_impls_overlap.rs\n+const REPEAT_COUNT: u32 = 501;\n+\n+#[proc_macro]\n+/// Repeats the input many times, while replacing idents\n+/// named \"IDENT\" with \"id_$v\", where v is a counter.\n+pub fn repeat_with_idents(input: TokenStream) -> TokenStream {\n+    let mut res = Vec::new();\n+    fn visit_stream(res: &mut Vec<Tt>, stream :TokenStream, v: u32) {\n+        let mut stream_iter = stream.into_iter();\n+        while let Some(tt) = stream_iter.next() {\n+            match tt {\n+                Tt::Group(group) => {\n+                    let tt = Tt::Group(visit_group(group, v));\n+                    res.push(tt);\n+                },\n+                Tt::Ident(id) => {\n+                    let id = if &id.to_string() == \"IDENT\" {\n+                        Ident::new(&format!(\"id_{}\", v), id.span())\n+                    } else {\n+                        id\n+                    };\n+                    res.push(Tt::Ident(id));\n+                },\n+                Tt::Punct(p) => {\n+                    res.push(Tt::Punct(p));\n+                },\n+                Tt::Literal(lit) => {\n+                    res.push(Tt::Literal(lit));\n+                },\n+            }\n+        }\n+    }\n+    fn visit_group(group :Group, v: u32) -> Group {\n+        let mut res = Vec::new();\n+        visit_stream(&mut res, group.stream(), v);\n+        let stream = res.into_iter().collect();\n+        let delim = group.delimiter();\n+        Group::new(delim, stream)\n+    }\n+    for v in 0 .. REPEAT_COUNT {\n+        visit_stream(&mut res, input.clone(), v)\n+    }\n+    res.into_iter().collect()\n+}"}, {"sha": "341bfc7b605fcb0e5dd96e51649ce082c7313dff", "filename": "src/test/ui/inherent-impls-overlap-check/no-overlap.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9/src%2Ftest%2Fui%2Finherent-impls-overlap-check%2Fno-overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9/src%2Ftest%2Fui%2Finherent-impls-overlap-check%2Fno-overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finherent-impls-overlap-check%2Fno-overlap.rs?ref=c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9", "patch": "@@ -0,0 +1,34 @@\n+// run-pass\n+// aux-build:repeat.rs\n+\n+// This tests the allocating algo branch of the\n+// inherent impls overlap checker.\n+// This branch was added by PR:\n+// https://github.com/rust-lang/rust/pull/78317\n+// In this test, we repeat many impl blocks\n+// to trigger the allocating branch.\n+\n+#![allow(unused)]\n+\n+extern crate repeat;\n+\n+// Simple case where each impl block is distinct\n+\n+struct Foo {}\n+\n+repeat::repeat_with_idents!(impl Foo { fn IDENT() {} });\n+\n+// There are overlapping impl blocks but due to generics,\n+// they may overlap.\n+\n+struct Bar<T>(T);\n+\n+struct A;\n+struct B;\n+\n+repeat::repeat_with_idents!(impl Bar<A> { fn IDENT() {} });\n+\n+impl Bar<A> { fn foo() {} }\n+impl Bar<B> { fn foo() {} }\n+\n+fn main() {}"}, {"sha": "6f2801197e90c00aa14c63f2f5692a5489a0f604", "filename": "src/test/ui/inherent-impls-overlap-check/overlap.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9/src%2Ftest%2Fui%2Finherent-impls-overlap-check%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9/src%2Ftest%2Fui%2Finherent-impls-overlap-check%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finherent-impls-overlap-check%2Foverlap.rs?ref=c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9", "patch": "@@ -0,0 +1,71 @@\n+// aux-build:repeat.rs\n+\n+#![allow(unused)]\n+\n+// This tests the allocating algo branch of the\n+// inherent impls overlap checker.\n+// This branch was added by PR:\n+// https://github.com/rust-lang/rust/pull/78317\n+// In this test, we repeat many impl blocks\n+// to trigger the allocating branch.\n+\n+// Simple overlap\n+\n+extern crate repeat;\n+\n+struct Foo {}\n+\n+repeat::repeat_with_idents!(impl Foo { fn IDENT() {} });\n+\n+impl Foo { fn hello() {} } //~ERROR duplicate definitions with name `hello`\n+impl Foo { fn hello() {} }\n+\n+// Transitive overlap\n+\n+struct Foo2 {}\n+\n+repeat::repeat_with_idents!(impl Foo2 { fn IDENT() {} });\n+\n+impl Foo2 {\n+    fn bar() {}\n+    fn hello2() {} //~ERROR duplicate definitions with name `hello2`\n+}\n+\n+impl Foo2 {\n+    fn baz() {}\n+    fn hello2() {}\n+}\n+\n+// Slightly stronger transitive overlap\n+\n+struct Foo3 {}\n+\n+repeat::repeat_with_idents!(impl Foo3 { fn IDENT() {} });\n+\n+impl Foo3 {\n+    fn bar() {} //~ERROR duplicate definitions with name `bar`\n+    fn hello3() {} //~ERROR duplicate definitions with name `hello3`\n+}\n+\n+impl Foo3 {\n+    fn bar() {}\n+    fn hello3() {}\n+}\n+\n+// Generic overlap\n+\n+struct Bar<T>(T);\n+\n+struct A;\n+struct B;\n+\n+repeat::repeat_with_idents!(impl Bar<A> { fn IDENT() {} });\n+\n+impl Bar<A> { fn foo() {} fn bar2() {} }\n+impl Bar<B> {\n+    fn foo() {}\n+    fn bar2() {} //~ERROR duplicate definitions with name `bar2`\n+}\n+impl Bar<B> { fn bar2() {} }\n+\n+fn main() {}"}, {"sha": "3dd2793712f580c5382f1ebfffb5b5d693c6869a", "filename": "src/test/ui/inherent-impls-overlap-check/overlap.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9/src%2Ftest%2Fui%2Finherent-impls-overlap-check%2Foverlap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9/src%2Ftest%2Fui%2Finherent-impls-overlap-check%2Foverlap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finherent-impls-overlap-check%2Foverlap.stderr?ref=c609b2eaf323186a1167ec1a9ffa69a7d4a5b1b9", "patch": "@@ -0,0 +1,47 @@\n+error[E0592]: duplicate definitions with name `hello`\n+  --> $DIR/overlap.rs:20:12\n+   |\n+LL | impl Foo { fn hello() {} }\n+   |            ^^^^^^^^^^ duplicate definitions for `hello`\n+LL | impl Foo { fn hello() {} }\n+   |            ---------- other definition for `hello`\n+\n+error[E0592]: duplicate definitions with name `hello2`\n+  --> $DIR/overlap.rs:31:5\n+   |\n+LL |     fn hello2() {}\n+   |     ^^^^^^^^^^^ duplicate definitions for `hello2`\n+...\n+LL |     fn hello2() {}\n+   |     ----------- other definition for `hello2`\n+\n+error[E0592]: duplicate definitions with name `bar`\n+  --> $DIR/overlap.rs:46:5\n+   |\n+LL |     fn bar() {}\n+   |     ^^^^^^^^ duplicate definitions for `bar`\n+...\n+LL |     fn bar() {}\n+   |     -------- other definition for `bar`\n+\n+error[E0592]: duplicate definitions with name `hello3`\n+  --> $DIR/overlap.rs:47:5\n+   |\n+LL |     fn hello3() {}\n+   |     ^^^^^^^^^^^ duplicate definitions for `hello3`\n+...\n+LL |     fn hello3() {}\n+   |     ----------- other definition for `hello3`\n+\n+error[E0592]: duplicate definitions with name `bar2`\n+  --> $DIR/overlap.rs:67:5\n+   |\n+LL |     fn bar2() {}\n+   |     ^^^^^^^^^ duplicate definitions for `bar2`\n+LL | }\n+LL | impl Bar<B> { fn bar2() {} }\n+   |               --------- other definition for `bar2`\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0592`."}]}