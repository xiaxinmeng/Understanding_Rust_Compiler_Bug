{"sha": "2642f64570888bcd640cc1737849787a141bdd36", "node_id": "C_kwDOAAsO6NoAKDI2NDJmNjQ1NzA4ODhiY2Q2NDBjYzE3Mzc4NDk3ODdhMTQxYmRkMzY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-23T18:08:29Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-23T18:08:29Z"}, "message": "internal: Simplify", "tree": {"sha": "ffdf481ef3bf87247ddacf9751dbae46cea48440", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffdf481ef3bf87247ddacf9751dbae46cea48440"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2642f64570888bcd640cc1737849787a141bdd36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2642f64570888bcd640cc1737849787a141bdd36", "html_url": "https://github.com/rust-lang/rust/commit/2642f64570888bcd640cc1737849787a141bdd36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2642f64570888bcd640cc1737849787a141bdd36/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "312ac83caf5cd383f10177fbade646ef02a3f6ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/312ac83caf5cd383f10177fbade646ef02a3f6ef", "html_url": "https://github.com/rust-lang/rust/commit/312ac83caf5cd383f10177fbade646ef02a3f6ef"}], "stats": {"total": 169, "additions": 75, "deletions": 94}, "files": [{"sha": "0b2e78bdcfbed719e85ee85b26f3973f43c4aaeb", "filename": "crates/hir-def/src/generics.rs", "status": "modified", "additions": 23, "deletions": 45, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2642f64570888bcd640cc1737849787a141bdd36/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2642f64570888bcd640cc1737849787a141bdd36/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fgenerics.rs?ref=2642f64570888bcd640cc1737849787a141bdd36", "patch": "@@ -146,6 +146,15 @@ impl GenericParams {\n     ) -> Interned<GenericParams> {\n         let _p = profile::span(\"generic_params_query\");\n \n+        macro_rules! id_to_generics {\n+            ($id:ident) => {{\n+                let id = $id.lookup(db).id;\n+                let tree = id.item_tree(db);\n+                let item = &tree[id.value];\n+                item.generic_params.clone()\n+            }};\n+        }\n+\n         match def {\n             GenericDefId::FunctionId(id) => {\n                 let loc = id.lookup(db);\n@@ -166,42 +175,12 @@ impl GenericParams {\n \n                 Interned::new(generic_params)\n             }\n-            GenericDefId::AdtId(AdtId::StructId(id)) => {\n-                let id = id.lookup(db).id;\n-                let tree = id.item_tree(db);\n-                let item = &tree[id.value];\n-                item.generic_params.clone()\n-            }\n-            GenericDefId::AdtId(AdtId::EnumId(id)) => {\n-                let id = id.lookup(db).id;\n-                let tree = id.item_tree(db);\n-                let item = &tree[id.value];\n-                item.generic_params.clone()\n-            }\n-            GenericDefId::AdtId(AdtId::UnionId(id)) => {\n-                let id = id.lookup(db).id;\n-                let tree = id.item_tree(db);\n-                let item = &tree[id.value];\n-                item.generic_params.clone()\n-            }\n-            GenericDefId::TraitId(id) => {\n-                let id = id.lookup(db).id;\n-                let tree = id.item_tree(db);\n-                let item = &tree[id.value];\n-                item.generic_params.clone()\n-            }\n-            GenericDefId::TypeAliasId(id) => {\n-                let id = id.lookup(db).id;\n-                let tree = id.item_tree(db);\n-                let item = &tree[id.value];\n-                item.generic_params.clone()\n-            }\n-            GenericDefId::ImplId(id) => {\n-                let id = id.lookup(db).id;\n-                let tree = id.item_tree(db);\n-                let item = &tree[id.value];\n-                item.generic_params.clone()\n-            }\n+            GenericDefId::AdtId(AdtId::StructId(id)) => id_to_generics!(id),\n+            GenericDefId::AdtId(AdtId::EnumId(id)) => id_to_generics!(id),\n+            GenericDefId::AdtId(AdtId::UnionId(id)) => id_to_generics!(id),\n+            GenericDefId::TraitId(id) => id_to_generics!(id),\n+            GenericDefId::TypeAliasId(id) => id_to_generics!(id),\n+            GenericDefId::ImplId(id) => id_to_generics!(id),\n             GenericDefId::EnumVariantId(_) | GenericDefId::ConstId(_) => {\n                 Interned::new(GenericParams::default())\n             }\n@@ -393,15 +372,14 @@ impl GenericParams {\n \n     pub fn find_trait_self_param(&self) -> Option<LocalTypeOrConstParamId> {\n         self.type_or_consts.iter().find_map(|(id, p)| {\n-            if let TypeOrConstParamData::TypeParamData(p) = p {\n-                if p.provenance == TypeParamProvenance::TraitSelf {\n-                    Some(id)\n-                } else {\n-                    None\n-                }\n-            } else {\n-                None\n-            }\n+            matches!(\n+                p,\n+                TypeOrConstParamData::TypeParamData(TypeParamData {\n+                    provenance: TypeParamProvenance::TraitSelf,\n+                    ..\n+                })\n+            )\n+            .then(|| id)\n         })\n     }\n }"}, {"sha": "3aade788d7e87ec7997f88af8baa4f534323c3b2", "filename": "crates/hir-def/src/path.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2642f64570888bcd640cc1737849787a141bdd36/crates%2Fhir-def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2642f64570888bcd640cc1737849787a141bdd36/crates%2Fhir-def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath.rs?ref=2642f64570888bcd640cc1737849787a141bdd36", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     intern::Interned,\n     type_ref::{ConstScalarOrPath, LifetimeRef},\n };\n-use hir_expand::name::{name, Name};\n+use hir_expand::name::Name;\n use syntax::ast;\n \n use crate::type_ref::{TypeBound, TypeRef};\n@@ -134,9 +134,7 @@ impl Path {\n     }\n \n     pub fn is_self_type(&self) -> bool {\n-        self.type_anchor.is_none()\n-            && *self.generic_args == [None]\n-            && self.mod_path.as_ident() == Some(&name!(Self))\n+        self.type_anchor.is_none() && *self.generic_args == [None] && self.mod_path.is_Self()\n     }\n }\n "}, {"sha": "6b16a0c876f8e8b45ce46a83c7c6dbc86f680b7e", "filename": "crates/hir-def/src/type_ref.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2642f64570888bcd640cc1737849787a141bdd36/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2642f64570888bcd640cc1737849787a141bdd36/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs?ref=2642f64570888bcd640cc1737849787a141bdd36", "patch": "@@ -109,7 +109,6 @@ pub enum TypeRef {\n     Slice(Box<TypeRef>),\n     /// A fn pointer. Last element of the vector is the return type.\n     Fn(Vec<(Option<Name>, TypeRef)>, bool /*varargs*/),\n-    // For\n     ImplTrait(Vec<Interned<TypeBound>>),\n     DynTrait(Vec<Interned<TypeBound>>),\n     Macro(AstId<ast::MacroCall>),"}, {"sha": "d38e4a52a8cb4a17518cc73025e99c0a27c8f426", "filename": "crates/hir-expand/src/mod_path.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2642f64570888bcd640cc1737849787a141bdd36/crates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2642f64570888bcd640cc1737849787a141bdd36/crates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fmod_path.rs?ref=2642f64570888bcd640cc1737849787a141bdd36", "patch": "@@ -80,6 +80,12 @@ impl ModPath {\n         self.kind == PathKind::Super(0) && self.segments.is_empty()\n     }\n \n+    #[allow(non_snake_case)]\n+    pub fn is_Self(&self) -> bool {\n+        self.kind == PathKind::Plain\n+            && matches!(&*self.segments, [name] if *name == known::SELF_TYPE)\n+    }\n+\n     /// If this path is a single identifier, like `foo`, return its name.\n     pub fn as_ident(&self) -> Option<&Name> {\n         if self.kind != PathKind::Plain {"}, {"sha": "adee8cf958fb5870a8e472bdbc8ed4d8d664d256", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2642f64570888bcd640cc1737849787a141bdd36/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2642f64570888bcd640cc1737849787a141bdd36/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=2642f64570888bcd640cc1737849787a141bdd36", "patch": "@@ -5,31 +5,33 @@\n //!  - Building the type for an item: This happens through the `type_for_def` query.\n //!\n //! This usually involves resolving names, collecting generic arguments etc.\n-use std::cell::{Cell, RefCell};\n-use std::{iter, sync::Arc};\n+use std::{\n+    cell::{Cell, RefCell},\n+    iter,\n+    sync::Arc,\n+};\n \n use base_db::CrateId;\n-use chalk_ir::fold::Fold;\n-use chalk_ir::interner::HasInterner;\n-use chalk_ir::{cast::Cast, fold::Shift, Mutability, Safety};\n-use hir_def::generics::TypeOrConstParamData;\n-use hir_def::intern::Interned;\n-use hir_def::lang_item::lang_attr;\n-use hir_def::path::{ModPath, PathKind};\n-use hir_def::type_ref::ConstScalarOrPath;\n+use chalk_ir::{cast::Cast, fold::Fold, fold::Shift, interner::HasInterner, Mutability, Safety};\n+\n use hir_def::{\n     adt::StructKind,\n     body::{Expander, LowerCtx},\n     builtin_type::BuiltinType,\n-    generics::{TypeParamProvenance, WherePredicate, WherePredicateTypeTarget},\n-    path::{GenericArg, Path, PathSegment, PathSegments},\n+    generics::{\n+        TypeOrConstParamData, TypeParamProvenance, WherePredicate, WherePredicateTypeTarget,\n+    },\n+    intern::Interned,\n+    lang_item::lang_attr,\n+    path::{GenericArg, ModPath, Path, PathKind, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n-    type_ref::{TraitBoundModifier, TraitRef as HirTraitRef, TypeBound, TypeRef},\n-    AdtId, AssocItemId, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId, HasModule,\n-    ImplId, ItemContainerId, LocalFieldId, Lookup, StaticId, StructId, TraitId, TypeAliasId,\n-    UnionId, VariantId,\n+    type_ref::{\n+        ConstScalarOrPath, TraitBoundModifier, TraitRef as HirTraitRef, TypeBound, TypeRef,\n+    },\n+    AdtId, AssocItemId, ConstId, ConstParamId, EnumId, EnumVariantId, FunctionId, GenericDefId,\n+    HasModule, ImplId, ItemContainerId, LocalFieldId, Lookup, StaticId, StructId, TraitId,\n+    TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId, VariantId,\n };\n-use hir_def::{ConstParamId, TypeOrConstParamId, TypeParamId};\n use hir_expand::{name::Name, ExpandResult};\n use itertools::Either;\n use la_arena::ArenaMap;\n@@ -38,20 +40,19 @@ use smallvec::SmallVec;\n use stdx::{impl_from, never};\n use syntax::{ast, SmolStr};\n \n-use crate::consteval::{\n-    intern_scalar_const, path_to_const, unknown_const, unknown_const_as_generic,\n-};\n-use crate::utils::Generics;\n-use crate::{all_super_traits, make_binders, Const, GenericArgData, ParamKind};\n use crate::{\n+    all_super_traits,\n+    consteval::{intern_scalar_const, path_to_const, unknown_const, unknown_const_as_generic},\n     db::HirDatabase,\n+    make_binders,\n     mapping::ToChalk,\n     static_lifetime, to_assoc_type_id, to_chalk_trait_id, to_placeholder_idx,\n+    utils::Generics,\n     utils::{all_super_trait_refs, associated_type_by_name_including_super_traits, generics},\n-    AliasEq, AliasTy, Binders, BoundVar, CallableSig, DebruijnIndex, DynTy, FnPointer, FnSig,\n-    FnSubst, ImplTraitId, Interner, PolyFnSig, ProjectionTy, QuantifiedWhereClause,\n-    QuantifiedWhereClauses, ReturnTypeImplTrait, ReturnTypeImplTraits, Substitution,\n-    TraitEnvironment, TraitRef, TraitRefExt, Ty, TyBuilder, TyKind, WhereClause,\n+    AliasEq, AliasTy, Binders, BoundVar, CallableSig, Const, DebruijnIndex, DynTy, FnPointer,\n+    FnSig, FnSubst, GenericArgData, ImplTraitId, Interner, ParamKind, PolyFnSig, ProjectionTy,\n+    QuantifiedWhereClause, QuantifiedWhereClauses, ReturnTypeImplTrait, ReturnTypeImplTraits,\n+    Substitution, TraitEnvironment, TraitRef, TraitRefExt, Ty, TyBuilder, TyKind, WhereClause,\n };\n \n #[derive(Debug)]"}, {"sha": "2e1447936888d69e216cda74ef467b8082f908f9", "filename": "crates/hir-ty/src/utils.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2642f64570888bcd640cc1737849787a141bdd36/crates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2642f64570888bcd640cc1737849787a141bdd36/crates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Futils.rs?ref=2642f64570888bcd640cc1737849787a141bdd36", "patch": "@@ -12,13 +12,12 @@ use hir_def::{\n         WherePredicateTypeTarget,\n     },\n     intern::Interned,\n-    path::Path,\n     resolver::{HasResolver, TypeNs},\n     type_ref::{TraitBoundModifier, TypeRef},\n     ConstParamId, FunctionId, GenericDefId, ItemContainerId, Lookup, TraitId, TypeAliasId,\n     TypeOrConstParamId, TypeParamId,\n };\n-use hir_expand::name::{known, name, Name};\n+use hir_expand::name::{known, Name};\n use itertools::Either;\n use rustc_hash::FxHashSet;\n use smallvec::{smallvec, SmallVec};\n@@ -53,25 +52,25 @@ fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> SmallVec<[Trait\n         .iter()\n         .filter_map(|pred| match pred {\n             WherePredicate::ForLifetime { target, bound, .. }\n-            | WherePredicate::TypeBound { target, bound } => match target {\n-                WherePredicateTypeTarget::TypeRef(type_ref) => match &**type_ref {\n-                    TypeRef::Path(p) if p == &Path::from(name![Self]) => bound.as_path(),\n-                    _ => None,\n-                },\n-                WherePredicateTypeTarget::TypeOrConstParam(local_id)\n-                    if Some(*local_id) == trait_self =>\n-                {\n-                    bound.as_path()\n+            | WherePredicate::TypeBound { target, bound } => {\n+                let is_trait = match target {\n+                    WherePredicateTypeTarget::TypeRef(type_ref) => match &**type_ref {\n+                        TypeRef::Path(p) => p.is_self_type(),\n+                        _ => false,\n+                    },\n+                    WherePredicateTypeTarget::TypeOrConstParam(local_id) => {\n+                        Some(*local_id) == trait_self\n+                    }\n+                };\n+                match is_trait {\n+                    true => bound.as_path(),\n+                    false => None,\n                 }\n-                _ => None,\n-            },\n+            }\n             WherePredicate::Lifetime { .. } => None,\n         })\n-        .filter_map(|(path, bound_modifier)| match bound_modifier {\n-            TraitBoundModifier::None => Some(path),\n-            TraitBoundModifier::Maybe => None,\n-        })\n-        .filter_map(|path| match resolver.resolve_path_in_type_ns_fully(db, path.mod_path()) {\n+        .filter(|(_, bound_modifier)| matches!(bound_modifier, TraitBoundModifier::None))\n+        .filter_map(|(path, _)| match resolver.resolve_path_in_type_ns_fully(db, path.mod_path()) {\n             Some(TypeNs::TraitId(t)) => Some(t),\n             _ => None,\n         })"}]}