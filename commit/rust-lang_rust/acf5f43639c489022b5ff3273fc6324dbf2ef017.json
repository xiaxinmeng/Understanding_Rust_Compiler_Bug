{"sha": "acf5f43639c489022b5ff3273fc6324dbf2ef017", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjZjVmNDM2MzljNDg5MDIyYjVmZjMyNzNmYzYzMjRkYmYyZWYwMTc=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-02-12T12:41:34Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-02-12T15:18:42Z"}, "message": "Refactor the code", "tree": {"sha": "b0b1444eb3c6e2c83fe7213af0c4fbbe88a1c3b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0b1444eb3c6e2c83fe7213af0c4fbbe88a1c3b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/acf5f43639c489022b5ff3273fc6324dbf2ef017", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/acf5f43639c489022b5ff3273fc6324dbf2ef017", "html_url": "https://github.com/rust-lang/rust/commit/acf5f43639c489022b5ff3273fc6324dbf2ef017", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/acf5f43639c489022b5ff3273fc6324dbf2ef017/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07058cbf9f16591b8c250ce59026117ddae71c61", "url": "https://api.github.com/repos/rust-lang/rust/commits/07058cbf9f16591b8c250ce59026117ddae71c61", "html_url": "https://github.com/rust-lang/rust/commit/07058cbf9f16591b8c250ce59026117ddae71c61"}], "stats": {"total": 189, "additions": 93, "deletions": 96}, "files": [{"sha": "86615d6590b869ef809d97d871ef239e88aad14c", "filename": "crates/ra_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 93, "deletions": 96, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/acf5f43639c489022b5ff3273fc6324dbf2ef017/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acf5f43639c489022b5ff3273fc6324dbf2ef017/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=acf5f43639c489022b5ff3273fc6324dbf2ef017", "patch": "@@ -36,15 +36,8 @@ use std::collections::BTreeSet;\n // # pub mod std { pub mod collections { pub struct HashMap { } } }\n // ```\n pub(crate) fn auto_import(ctx: AssistCtx) -> Option<Assist> {\n-    let auto_import_assets = if let Some(path_under_caret) = ctx.find_node_at_offset::<ast::Path>()\n-    {\n-        AutoImportAssets::for_regular_path(path_under_caret, &ctx)?\n-    } else {\n-        AutoImportAssets::for_method_call(ctx.find_node_at_offset()?, &ctx)?\n-    };\n-\n-    let proposed_imports = auto_import_assets\n-        .search_for_imports(ctx.db, auto_import_assets.module_with_name_to_import);\n+    let auto_import_assets = AutoImportAssets::new(&ctx)?;\n+    let proposed_imports = auto_import_assets.search_for_imports(ctx.db);\n     if proposed_imports.is_empty() {\n         return None;\n     }\n@@ -54,7 +47,6 @@ pub(crate) fn auto_import(ctx: AssistCtx) -> Option<Assist> {\n     } else {\n         auto_import_assets.get_import_group_message()\n     };\n-\n     let mut group = ctx.add_assist_group(assist_group_name);\n     for import in proposed_imports {\n         group.add_assist(AssistId(\"auto_import\"), format!(\"Import `{}`\", &import), |edit| {\n@@ -77,6 +69,14 @@ struct AutoImportAssets {\n }\n \n impl AutoImportAssets {\n+    fn new(ctx: &AssistCtx) -> Option<Self> {\n+        if let Some(path_under_caret) = ctx.find_node_at_offset::<ast::Path>() {\n+            Self::for_regular_path(path_under_caret, &ctx)\n+        } else {\n+            Self::for_method_call(ctx.find_node_at_offset()?, &ctx)\n+        }\n+    }\n+\n     fn for_method_call(method_call: ast::MethodCallExpr, ctx: &AssistCtx) -> Option<Self> {\n         let syntax_under_caret = method_call.syntax().to_owned();\n         let source_analyzer = ctx.source_analyzer(&syntax_under_caret, None);\n@@ -111,94 +111,88 @@ impl AutoImportAssets {\n         })\n     }\n \n-    fn get_search_query(&self) -> String {\n+    fn get_search_query(&self) -> &str {\n         match &self.import_candidate {\n-            ImportCandidate::UnqualifiedName(name_ref)\n-            | ImportCandidate::QualifierStart(name_ref) => name_ref.syntax().to_string(),\n-            ImportCandidate::TraitFunction(_, trait_function) => {\n-                trait_function.syntax().to_string()\n-            }\n-            ImportCandidate::TraitMethod(_, trait_method) => trait_method.syntax().to_string(),\n+            ImportCandidate::UnqualifiedName(name) => name,\n+            ImportCandidate::QualifierStart(qualifier_start) => qualifier_start,\n+            ImportCandidate::TraitFunction(_, trait_function_name) => trait_function_name,\n+            ImportCandidate::TraitMethod(_, trait_method_name) => trait_method_name,\n         }\n     }\n \n     fn get_import_group_message(&self) -> String {\n         match &self.import_candidate {\n-            ImportCandidate::UnqualifiedName(name_ref)\n-            | ImportCandidate::QualifierStart(name_ref) => format!(\"Import {}\", name_ref.syntax()),\n-            ImportCandidate::TraitFunction(_, trait_function) => {\n-                format!(\"Import a trait for function {}\", trait_function.syntax())\n+            ImportCandidate::UnqualifiedName(name) => format!(\"Import {}\", name),\n+            ImportCandidate::QualifierStart(qualifier_start) => {\n+                format!(\"Import {}\", qualifier_start)\n             }\n-            ImportCandidate::TraitMethod(_, trait_method) => {\n-                format!(\"Import a trait for method {}\", trait_method.syntax())\n+            ImportCandidate::TraitFunction(_, trait_function_name) => {\n+                format!(\"Import a trait for function {}\", trait_function_name)\n+            }\n+            ImportCandidate::TraitMethod(_, trait_method_name) => {\n+                format!(\"Import a trait for method {}\", trait_method_name)\n             }\n         }\n     }\n \n-    fn search_for_imports(\n-        &self,\n-        db: &RootDatabase,\n-        module_with_name_to_import: Module,\n-    ) -> BTreeSet<ModPath> {\n+    fn search_for_imports(&self, db: &RootDatabase) -> BTreeSet<ModPath> {\n         let _p = profile(\"auto_import::search_for_imports\");\n+        let current_crate = self.module_with_name_to_import.krate();\n         ImportsLocator::new(db)\n             .find_imports(&self.get_search_query())\n             .into_iter()\n             .map(|module_def| match &self.import_candidate {\n                 ImportCandidate::TraitFunction(function_callee, _) => {\n                     let mut applicable_traits = Vec::new();\n                     if let ModuleDef::Function(located_function) = module_def {\n-                        let trait_candidates = Self::get_trait_candidates(\n-                            db,\n-                            located_function,\n-                            module_with_name_to_import.krate(),\n-                        )\n-                        .into_iter()\n-                        .map(|trait_candidate| trait_candidate.into())\n-                        .collect();\n-\n-                        function_callee.iterate_path_candidates(\n-                            db,\n-                            module_with_name_to_import.krate(),\n-                            &trait_candidates,\n-                            None,\n-                            |_, assoc| {\n-                                if let AssocContainerId::TraitId(trait_id) = assoc.container(db) {\n-                                    applicable_traits.push(\n-                                        module_with_name_to_import\n-                                            .find_use_path(db, ModuleDef::Trait(trait_id.into())),\n-                                    );\n-                                };\n-                                None::<()>\n-                            },\n-                        );\n+                        let trait_candidates: FxHashSet<_> =\n+                            Self::get_trait_candidates(db, located_function, current_crate)\n+                                .into_iter()\n+                                .map(|trait_candidate| trait_candidate.into())\n+                                .collect();\n+                        if !trait_candidates.is_empty() {\n+                            function_callee.iterate_path_candidates(\n+                                db,\n+                                current_crate,\n+                                &trait_candidates,\n+                                None,\n+                                |_, assoc| {\n+                                    if let AssocContainerId::TraitId(trait_id) = assoc.container(db)\n+                                    {\n+                                        applicable_traits.push(\n+                                            self.module_with_name_to_import.find_use_path(\n+                                                db,\n+                                                ModuleDef::Trait(trait_id.into()),\n+                                            ),\n+                                        );\n+                                    };\n+                                    None::<()>\n+                                },\n+                            );\n+                        };\n                     }\n                     applicable_traits\n                 }\n                 ImportCandidate::TraitMethod(function_callee, _) => {\n                     let mut applicable_traits = Vec::new();\n                     if let ModuleDef::Function(located_function) = module_def {\n-                        let trait_candidates: FxHashSet<_> = Self::get_trait_candidates(\n-                            db,\n-                            located_function,\n-                            module_with_name_to_import.krate(),\n-                        )\n-                        .into_iter()\n-                        .map(|trait_candidate| trait_candidate.into())\n-                        .collect();\n-\n+                        let trait_candidates: FxHashSet<_> =\n+                            Self::get_trait_candidates(db, located_function, current_crate)\n+                                .into_iter()\n+                                .map(|trait_candidate| trait_candidate.into())\n+                                .collect();\n                         if !trait_candidates.is_empty() {\n                             function_callee.iterate_method_candidates(\n                                 db,\n-                                module_with_name_to_import.krate(),\n+                                current_crate,\n                                 &trait_candidates,\n                                 None,\n                                 |_, funciton| {\n                                     if let AssocContainerId::TraitId(trait_id) =\n                                         funciton.container(db)\n                                     {\n                                         applicable_traits.push(\n-                                            module_with_name_to_import.find_use_path(\n+                                            self.module_with_name_to_import.find_use_path(\n                                                 db,\n                                                 ModuleDef::Trait(trait_id.into()),\n                                             ),\n@@ -211,7 +205,7 @@ impl AutoImportAssets {\n                     }\n                     applicable_traits\n                 }\n-                _ => vec![module_with_name_to_import.find_use_path(db, module_def)],\n+                _ => vec![self.module_with_name_to_import.find_use_path(db, module_def)],\n             })\n             .flatten()\n             .filter_map(std::convert::identity)\n@@ -235,22 +229,19 @@ impl AutoImportAssets {\n                 crate_def_map\n                     .modules\n                     .iter()\n-                    .map(|(_, module_data)| {\n-                        let mut traits = Vec::new();\n-                        for module_def_id in module_data.scope.declarations() {\n-                            if let ModuleDef::Trait(trait_candidate) = module_def_id.into() {\n-                                if trait_candidate\n-                                    .items(db)\n-                                    .into_iter()\n-                                    .any(|item| item == AssocItem::Function(called_function))\n-                                {\n-                                    traits.push(trait_candidate)\n-                                }\n-                            }\n+                    .map(|(_, module_data)| module_data.scope.declarations())\n+                    .flatten()\n+                    .filter_map(|module_def_id| match module_def_id.into() {\n+                        ModuleDef::Trait(trait_candidate)\n+                            if trait_candidate\n+                                .items(db)\n+                                .into_iter()\n+                                .any(|item| item == AssocItem::Function(called_function)) =>\n+                        {\n+                            Some(trait_candidate)\n                         }\n-                        traits\n+                        _ => None,\n                     })\n-                    .flatten()\n                     .collect::<FxHashSet<_>>()\n             })\n             .flatten()\n@@ -259,12 +250,20 @@ impl AutoImportAssets {\n }\n \n #[derive(Debug)]\n-// TODO kb rustdocs\n enum ImportCandidate {\n-    UnqualifiedName(ast::NameRef),\n-    QualifierStart(ast::NameRef),\n-    TraitFunction(Type, ast::PathSegment),\n-    TraitMethod(Type, ast::NameRef),\n+    /// Simple name like 'HashMap'\n+    UnqualifiedName(String),\n+    /// First part of the qualified name.\n+    /// For 'std::collections::HashMap', that will be 'std'.\n+    QualifierStart(String),\n+    /// A trait function that has no self parameter.\n+    /// For 'test_mod::TestEnum::test_function', `Type` is the `test_mod::TestEnum` expression type\n+    /// and `String`is the `test_function`\n+    TraitFunction(Type, String),\n+    /// A trait method with self parameter.\n+    /// For 'test_enum.test_method()', `Type` is the `test_enum` expression type\n+    /// and `String` is the `test_method`\n+    TraitMethod(Type, String),\n }\n \n impl ImportCandidate {\n@@ -278,7 +277,7 @@ impl ImportCandidate {\n         }\n         Some(Self::TraitMethod(\n             source_analyzer.type_of(db, &method_call.expr()?)?,\n-            method_call.name_ref()?,\n+            method_call.name_ref()?.syntax().to_string(),\n         ))\n     }\n \n@@ -299,36 +298,34 @@ impl ImportCandidate {\n             if let Some(qualifier_start_resolution) =\n                 source_analyzer.resolve_path(db, &qualifier_start_path)\n             {\n-                let qualifier_resolution = if &qualifier_start_path == path_under_caret {\n+                let qualifier_resolution = if qualifier_start_path == qualifier {\n                     qualifier_start_resolution\n                 } else {\n                     source_analyzer.resolve_path(db, &qualifier)?\n                 };\n                 if let PathResolution::Def(ModuleDef::Adt(function_callee)) = qualifier_resolution {\n-                    Some(ImportCandidate::TraitFunction(function_callee.ty(db), segment))\n+                    Some(ImportCandidate::TraitFunction(\n+                        function_callee.ty(db),\n+                        segment.syntax().to_string(),\n+                    ))\n                 } else {\n                     None\n                 }\n             } else {\n-                Some(ImportCandidate::QualifierStart(qualifier_start))\n+                Some(ImportCandidate::QualifierStart(qualifier_start.syntax().to_string()))\n             }\n         } else {\n-            if source_analyzer.resolve_path(db, path_under_caret).is_none() {\n-                Some(ImportCandidate::UnqualifiedName(\n-                    segment.syntax().descendants().find_map(ast::NameRef::cast)?,\n-                ))\n-            } else {\n-                None\n-            }\n+            Some(ImportCandidate::UnqualifiedName(\n+                segment.syntax().descendants().find_map(ast::NameRef::cast)?.syntax().to_string(),\n+            ))\n         }\n     }\n }\n \n #[cfg(test)]\n mod tests {\n-    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n-\n     use super::*;\n+    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     #[test]\n     fn applicable_when_found_an_import() {"}]}