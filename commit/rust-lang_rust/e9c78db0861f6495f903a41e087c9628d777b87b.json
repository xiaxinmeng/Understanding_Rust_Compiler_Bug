{"sha": "e9c78db0861f6495f903a41e087c9628d777b87b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5Yzc4ZGIwODYxZjY0OTVmOTAzYTQxZTA4N2M5NjI4ZDc3N2I4N2I=", "commit": {"author": {"name": "Juan Aguilar Santillana", "email": "mhpoin@gmail.com", "date": "2020-05-08T20:48:26Z"}, "committer": {"name": "Juan Aguilar Santillana", "email": "mhpoin@gmail.com", "date": "2020-05-08T20:48:26Z"}, "message": "Update annotate-snippets-rs to 0.8.0", "tree": {"sha": "59efda00d8d0d39e73eeb372c15674b8a606a27f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59efda00d8d0d39e73eeb372c15674b8a606a27f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9c78db0861f6495f903a41e087c9628d777b87b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9c78db0861f6495f903a41e087c9628d777b87b", "html_url": "https://github.com/rust-lang/rust/commit/e9c78db0861f6495f903a41e087c9628d777b87b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9c78db0861f6495f903a41e087c9628d777b87b/comments", "author": {"login": "botika", "id": 2625545, "node_id": "MDQ6VXNlcjI2MjU1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2625545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/botika", "html_url": "https://github.com/botika", "followers_url": "https://api.github.com/users/botika/followers", "following_url": "https://api.github.com/users/botika/following{/other_user}", "gists_url": "https://api.github.com/users/botika/gists{/gist_id}", "starred_url": "https://api.github.com/users/botika/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/botika/subscriptions", "organizations_url": "https://api.github.com/users/botika/orgs", "repos_url": "https://api.github.com/users/botika/repos", "events_url": "https://api.github.com/users/botika/events{/privacy}", "received_events_url": "https://api.github.com/users/botika/received_events", "type": "User", "site_admin": false}, "committer": {"login": "botika", "id": 2625545, "node_id": "MDQ6VXNlcjI2MjU1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2625545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/botika", "html_url": "https://github.com/botika", "followers_url": "https://api.github.com/users/botika/followers", "following_url": "https://api.github.com/users/botika/following{/other_user}", "gists_url": "https://api.github.com/users/botika/gists{/gist_id}", "starred_url": "https://api.github.com/users/botika/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/botika/subscriptions", "organizations_url": "https://api.github.com/users/botika/orgs", "repos_url": "https://api.github.com/users/botika/repos", "events_url": "https://api.github.com/users/botika/events{/privacy}", "received_events_url": "https://api.github.com/users/botika/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b805396bf46dce972692a6846ce2ad8481c5f85", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b805396bf46dce972692a6846ce2ad8481c5f85", "html_url": "https://github.com/rust-lang/rust/commit/7b805396bf46dce972692a6846ce2ad8481c5f85"}], "stats": {"total": 220, "additions": 92, "deletions": 128}, "files": [{"sha": "7e0448a152f4d85c837c85e3abdf81474a3ba645", "filename": "Cargo.lock", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9c78db0861f6495f903a41e087c9628d777b87b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e9c78db0861f6495f903a41e087c9628d777b87b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e9c78db0861f6495f903a41e087c9628d777b87b", "patch": "@@ -48,6 +48,12 @@ dependencies = [\n  \"ansi_term\",\n ]\n \n+[[package]]\n+name = \"annotate-snippets\"\n+version = \"0.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d78ea013094e5ea606b1c05fe35f1dd7ea1eb1ea259908d040b25bd5ec677ee5\"\n+\n [[package]]\n name = \"ansi_term\"\n version = \"0.11.0\"\n@@ -3277,7 +3283,7 @@ version = \"654.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"908e1ea187c6bb368af4ba6db980001e920515e67371ddc4086e749baabe6080\"\n dependencies = [\n- \"annotate-snippets\",\n+ \"annotate-snippets 0.6.1\",\n  \"atty\",\n  \"log\",\n  \"rustc-ap-rustc_data_structures\",\n@@ -3761,7 +3767,7 @@ version = \"0.0.0\"\n name = \"rustc_errors\"\n version = \"0.0.0\"\n dependencies = [\n- \"annotate-snippets\",\n+ \"annotate-snippets 0.8.0\",\n  \"atty\",\n  \"log\",\n  \"rustc_data_structures\",\n@@ -4408,7 +4414,7 @@ dependencies = [\n name = \"rustfmt-nightly\"\n version = \"1.4.14\"\n dependencies = [\n- \"annotate-snippets\",\n+ \"annotate-snippets 0.6.1\",\n  \"bytecount\",\n  \"cargo_metadata 0.8.0\",\n  \"derive-new\","}, {"sha": "5882a6855b673a3f414050ccf0469f1b4f3bdc8f", "filename": "src/librustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9c78db0861f6495f903a41e087c9628d777b87b/src%2Flibrustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e9c78db0861f6495f903a41e087c9628d777b87b/src%2Flibrustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2FCargo.toml?ref=e9c78db0861f6495f903a41e087c9628d777b87b", "patch": "@@ -17,7 +17,7 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n unicode-width = \"0.1.4\"\n atty = \"0.2\"\n termcolor = \"1.0\"\n-annotate-snippets = \"0.6.1\"\n+annotate-snippets = \"0.8.0\"\n termize = \"0.1.1\"\n \n [target.'cfg(windows)'.dependencies]"}, {"sha": "df5e43626aab9e6fef9d8382b12fe5bee56637ac", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 81, "deletions": 123, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/e9c78db0861f6495f903a41e087c9628d777b87b/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c78db0861f6495f903a41e087c9628d777b87b/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=e9c78db0861f6495f903a41e087c9628d777b87b", "patch": "@@ -8,12 +8,11 @@\n use crate::emitter::FileWithAnnotatedLines;\n use crate::snippet::Line;\n use crate::{CodeSuggestion, Diagnostic, DiagnosticId, Emitter, Level, SubDiagnostic};\n-use annotate_snippets::display_list::DisplayList;\n-use annotate_snippets::formatter::DisplayListFormatter;\n+use annotate_snippets::display_list::{DisplayList, FormatOptions};\n use annotate_snippets::snippet::*;\n use rustc_data_structures::sync::Lrc;\n use rustc_span::source_map::SourceMap;\n-use rustc_span::{Loc, MultiSpan, SourceFile};\n+use rustc_span::{MultiSpan, SourceFile};\n \n /// Generates diagnostics using annotate-snippet\n pub struct AnnotateSnippetEmitterWriter {\n@@ -59,112 +58,20 @@ impl Emitter for AnnotateSnippetEmitterWriter {\n     }\n }\n \n-/// Collects all the data needed to generate the data structures needed for the\n-/// `annotate-snippets` library.\n-struct DiagnosticConverter<'a> {\n-    source_map: Option<Lrc<SourceMap>>,\n-    level: Level,\n-    message: String,\n-    code: Option<DiagnosticId>,\n-    msp: MultiSpan,\n-    #[allow(dead_code)]\n-    children: &'a [SubDiagnostic],\n-    #[allow(dead_code)]\n-    suggestions: &'a [CodeSuggestion],\n+/// Provides the source string for the given `line` of `file`\n+fn source_string(file: Lrc<SourceFile>, line: &Line) -> String {\n+    file.get_line(line.line_index - 1).map(|a| a.to_string()).unwrap_or_default()\n }\n \n-impl<'a> DiagnosticConverter<'a> {\n-    /// Turns rustc Diagnostic information into a `annotate_snippets::snippet::Snippet`.\n-    fn to_annotation_snippet(&self) -> Option<Snippet> {\n-        if let Some(source_map) = &self.source_map {\n-            // Make sure our primary file comes first\n-            let primary_lo = if let Some(ref primary_span) = self.msp.primary_span().as_ref() {\n-                source_map.lookup_char_pos(primary_span.lo())\n-            } else {\n-                // FIXME(#59346): Not sure when this is the case and what\n-                // should be done if it happens\n-                return None;\n-            };\n-            let annotated_files =\n-                FileWithAnnotatedLines::collect_annotations(&self.msp, &self.source_map);\n-            let slices = self.slices_for_files(annotated_files, primary_lo);\n-\n-            Some(Snippet {\n-                title: Some(Annotation {\n-                    label: Some(self.message.to_string()),\n-                    id: self.code.clone().map(|c| match c {\n-                        DiagnosticId::Error(val) | DiagnosticId::Lint(val) => val,\n-                    }),\n-                    annotation_type: Self::annotation_type_for_level(self.level),\n-                }),\n-                footer: vec![],\n-                slices,\n-            })\n-        } else {\n-            // FIXME(#59346): Is it ok to return None if there's no source_map?\n-            None\n-        }\n-    }\n-\n-    fn slices_for_files(\n-        &self,\n-        annotated_files: Vec<FileWithAnnotatedLines>,\n-        primary_lo: Loc,\n-    ) -> Vec<Slice> {\n-        // FIXME(#64205): Provide a test case where `annotated_files` is > 1\n-        annotated_files\n-            .iter()\n-            .flat_map(|annotated_file| {\n-                annotated_file\n-                    .lines\n-                    .iter()\n-                    .map(|line| {\n-                        let line_source = Self::source_string(annotated_file.file.clone(), &line);\n-                        Slice {\n-                            source: line_source,\n-                            line_start: line.line_index,\n-                            origin: Some(primary_lo.file.name.to_string()),\n-                            // FIXME(#59346): Not really sure when `fold` should be true or false\n-                            fold: false,\n-                            annotations: line\n-                                .annotations\n-                                .iter()\n-                                .map(|a| self.annotation_to_source_annotation(a.clone()))\n-                                .collect(),\n-                        }\n-                    })\n-                    .collect::<Vec<Slice>>()\n-            })\n-            .collect::<Vec<Slice>>()\n-    }\n-\n-    /// Turns a `crate::snippet::Annotation` into a `SourceAnnotation`\n-    fn annotation_to_source_annotation(\n-        &self,\n-        annotation: crate::snippet::Annotation,\n-    ) -> SourceAnnotation {\n-        SourceAnnotation {\n-            range: (annotation.start_col, annotation.end_col),\n-            label: annotation.label.unwrap_or(\"\".to_string()),\n-            annotation_type: Self::annotation_type_for_level(self.level),\n-        }\n-    }\n-\n-    /// Provides the source string for the given `line` of `file`\n-    fn source_string(file: Lrc<SourceFile>, line: &Line) -> String {\n-        file.get_line(line.line_index - 1).map(|a| a.to_string()).unwrap_or(String::new())\n-    }\n-\n-    /// Maps `Diagnostic::Level` to `snippet::AnnotationType`\n-    fn annotation_type_for_level(level: Level) -> AnnotationType {\n-        match level {\n-            Level::Bug | Level::Fatal | Level::Error => AnnotationType::Error,\n-            Level::Warning => AnnotationType::Warning,\n-            Level::Note => AnnotationType::Note,\n-            Level::Help => AnnotationType::Help,\n-            // FIXME(#59346): Not sure how to map these two levels\n-            Level::Cancelled | Level::FailureNote => AnnotationType::Error,\n-        }\n+/// Maps `Diagnostic::Level` to `snippet::AnnotationType`\n+fn annotation_type_for_level(level: Level) -> AnnotationType {\n+    match level {\n+        Level::Bug | Level::Fatal | Level::Error => AnnotationType::Error,\n+        Level::Warning => AnnotationType::Warning,\n+        Level::Note => AnnotationType::Note,\n+        Level::Help => AnnotationType::Help,\n+        // FIXME(#59346): Not sure how to map these two levels\n+        Level::Cancelled | Level::FailureNote => AnnotationType::Error,\n     }\n }\n \n@@ -191,25 +98,76 @@ impl AnnotateSnippetEmitterWriter {\n         message: String,\n         code: &Option<DiagnosticId>,\n         msp: &MultiSpan,\n-        children: &[SubDiagnostic],\n-        suggestions: &[CodeSuggestion],\n+        _children: &[SubDiagnostic],\n+        _suggestions: &[CodeSuggestion],\n     ) {\n-        let converter = DiagnosticConverter {\n-            source_map: self.source_map.clone(),\n-            level: *level,\n-            message,\n-            code: code.clone(),\n-            msp: msp.clone(),\n-            children,\n-            suggestions,\n-        };\n-        if let Some(snippet) = converter.to_annotation_snippet() {\n-            let dl = DisplayList::from(snippet);\n-            let dlf = DisplayListFormatter::new(true, self.ui_testing);\n+        if let Some(source_map) = &self.source_map {\n+            // Make sure our primary file comes first\n+            let primary_lo = if let Some(ref primary_span) = msp.primary_span().as_ref() {\n+                source_map.lookup_char_pos(primary_span.lo())\n+            } else {\n+                // FIXME(#59346): Not sure when this is the case and what\n+                // should be done if it happens\n+                return;\n+            };\n+            let annotated_files =\n+                FileWithAnnotatedLines::collect_annotations(msp, &self.source_map);\n+            // owned: line source, line index, annotations\n+            type Owned = (String, usize, Vec<crate::snippet::Annotation>);\n+            let origin = primary_lo.file.name.to_string();\n+            let annotated_files: Vec<Owned> = annotated_files\n+                .into_iter()\n+                .flat_map(|annotated_file| {\n+                    let file = annotated_file.file;\n+                    annotated_file\n+                        .lines\n+                        .into_iter()\n+                        .map(|line| {\n+                            (source_string(file.clone(), &line), line.line_index, line.annotations)\n+                        })\n+                        .collect::<Vec<Owned>>()\n+                })\n+                .collect();\n+            let snippet = Snippet {\n+                title: Some(Annotation {\n+                    label: Some(&message),\n+                    id: code.as_ref().map(|c| match c {\n+                        DiagnosticId::Error(val) | DiagnosticId::Lint(val) => val.as_str(),\n+                    }),\n+                    annotation_type: annotation_type_for_level(*level),\n+                }),\n+                footer: vec![],\n+                opt: FormatOptions { color: true, anonymized_line_numbers: self.ui_testing },\n+                slices: annotated_files\n+                    .iter()\n+                    .map(|(source, line_index, annotations)| {\n+                        Slice {\n+                            source,\n+                            line_start: *line_index,\n+                            origin: Some(&origin),\n+                            // FIXME(#59346): Not really sure when `fold` should be true or false\n+                            fold: false,\n+                            annotations: annotations\n+                                .into_iter()\n+                                .map(|annotation| SourceAnnotation {\n+                                    range: (annotation.start_col, annotation.end_col),\n+                                    label: annotation\n+                                        .label\n+                                        .as_ref()\n+                                        .map(|s| s.as_str())\n+                                        .unwrap_or_default(),\n+                                    annotation_type: annotation_type_for_level(*level),\n+                                })\n+                                .collect(),\n+                        }\n+                    })\n+                    .collect(),\n+            };\n             // FIXME(#59346): Figure out if we can _always_ print to stderr or not.\n             // `emitter.rs` has the `Destination` enum that lists various possible output\n             // destinations.\n-            eprintln!(\"{}\", dlf.format(&dl));\n-        };\n+            eprintln!(\"{}\", DisplayList::from(snippet))\n+        }\n+        // FIXME(#59346): Is it ok to return None if there's no source_map?\n     }\n }"}, {"sha": "c16f022a77fa338c5edc16d91d6d81d50be029ff", "filename": "src/test/ui/annotate-snippet/missing-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9c78db0861f6495f903a41e087c9628d777b87b/src%2Ftest%2Fui%2Fannotate-snippet%2Fmissing-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e9c78db0861f6495f903a41e087c9628d777b87b/src%2Ftest%2Fui%2Fannotate-snippet%2Fmissing-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fannotate-snippet%2Fmissing-type.stderr?ref=e9c78db0861f6495f903a41e087c9628d777b87b", "patch": "@@ -1,5 +1,5 @@\n error[E0412]: cannot find type `Iter` in this scope\n-  --> $DIR/missing-type.rs:4:11\n+  --> $DIR/missing-type.rs:4:12\n    |\n LL |     let x: Iter;\n    |            ^^^^ not found in this scope"}]}