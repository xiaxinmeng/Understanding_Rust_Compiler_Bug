{"sha": "27e42058811e448b1a7dd8630d86ab247fbfcb9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3ZTQyMDU4ODExZTQ0OGIxYTdkZDg2MzBkODZhYjI0N2ZiZmNiOWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-16T01:11:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-16T01:11:37Z"}, "message": "Auto merge of #86993 - jackh726:project-gat-binders, r=nikomatsakis\n\nReplace associated item bound vars with placeholders when projecting\n\nFixes #76407\nFixes #76826\n\nSimilar, but more limited, to #85499. This allows us to handle things like `for<'a> <T as Trait>::Assoc<'a>` but not `for<'a> <T as Trait<'a>>::Assoc`, unblocking GATs.\n\nr? `@nikomatsakis`", "tree": {"sha": "a11138d6fca09fbad42be25162d8723aa789bb44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a11138d6fca09fbad42be25162d8723aa789bb44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27e42058811e448b1a7dd8630d86ab247fbfcb9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27e42058811e448b1a7dd8630d86ab247fbfcb9b", "html_url": "https://github.com/rust-lang/rust/commit/27e42058811e448b1a7dd8630d86ab247fbfcb9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27e42058811e448b1a7dd8630d86ab247fbfcb9b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1f8e27b74c541d3d555149c8efa4bfe9385cd56", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1f8e27b74c541d3d555149c8efa4bfe9385cd56", "html_url": "https://github.com/rust-lang/rust/commit/b1f8e27b74c541d3d555149c8efa4bfe9385cd56"}, {"sha": "cf001dc8894ae726de96f4db032f11c22f24c393", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf001dc8894ae726de96f4db032f11c22f24c393", "html_url": "https://github.com/rust-lang/rust/commit/cf001dc8894ae726de96f4db032f11c22f24c393"}], "stats": {"total": 704, "additions": 671, "deletions": 33}, "files": [{"sha": "95ea38d32b69508aeb4eeaa27046bdf096c47bbb", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/27e42058811e448b1a7dd8630d86ab247fbfcb9b/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e42058811e448b1a7dd8630d86ab247fbfcb9b/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=27e42058811e448b1a7dd8630d86ab247fbfcb9b", "patch": "@@ -2483,9 +2483,10 @@ impl<'tcx> ty::Instance<'tcx> {\n                 // `src/test/ui/polymorphization/normalized_sig_types.rs`), and codegen not keeping\n                 // track of a polymorphization `ParamEnv` to allow normalizing later.\n                 let mut sig = match *ty.kind() {\n-                    ty::FnDef(def_id, substs) => tcx\n+                    ty::FnDef(def_id, substs) if tcx.sess.opts.debugging_opts.polymorphize => tcx\n                         .normalize_erasing_regions(tcx.param_env(def_id), tcx.fn_sig(def_id))\n                         .subst(tcx, substs),\n+                    ty::FnDef(def_id, substs) => tcx.fn_sig(def_id).subst(tcx, substs),\n                     _ => unreachable!(),\n                 };\n "}, {"sha": "98fde3707f70ed0613f968590428144582bc22bd", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 339, "deletions": 1, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/27e42058811e448b1a7dd8630d86ab247fbfcb9b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e42058811e448b1a7dd8630d86ab247fbfcb9b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=27e42058811e448b1a7dd8630d86ab247fbfcb9b", "patch": "@@ -29,6 +29,8 @@ use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_span::symbol::sym;\n \n+use std::collections::BTreeMap;\n+\n pub use rustc_middle::traits::Reveal;\n \n pub type PolyProjectionObligation<'tcx> = Obligation<'tcx, ty::PolyProjectionPredicate<'tcx>>;\n@@ -296,6 +298,7 @@ struct AssocTypeNormalizer<'a, 'b, 'tcx> {\n     cause: ObligationCause<'tcx>,\n     obligations: &'a mut Vec<PredicateObligation<'tcx>>,\n     depth: usize,\n+    universes: Vec<Option<ty::UniverseIndex>>,\n }\n \n impl<'a, 'b, 'tcx> AssocTypeNormalizer<'a, 'b, 'tcx> {\n@@ -306,12 +309,18 @@ impl<'a, 'b, 'tcx> AssocTypeNormalizer<'a, 'b, 'tcx> {\n         depth: usize,\n         obligations: &'a mut Vec<PredicateObligation<'tcx>>,\n     ) -> AssocTypeNormalizer<'a, 'b, 'tcx> {\n-        AssocTypeNormalizer { selcx, param_env, cause, obligations, depth }\n+        AssocTypeNormalizer { selcx, param_env, cause, obligations, depth, universes: vec![] }\n     }\n \n     fn fold<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n         let value = self.selcx.infcx().resolve_vars_if_possible(value);\n \n+        assert!(\n+            !value.has_escaping_bound_vars(),\n+            \"Normalizing {:?} without wrapping in a `Binder`\",\n+            value\n+        );\n+\n         if !value.has_projections() { value } else { value.fold_with(self) }\n     }\n }\n@@ -321,6 +330,16 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n         self.selcx.tcx()\n     }\n \n+    fn fold_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: ty::Binder<'tcx, T>,\n+    ) -> ty::Binder<'tcx, T> {\n+        self.universes.push(None);\n+        let t = t.super_fold_with(self);\n+        self.universes.pop();\n+        t\n+    }\n+\n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         if !ty.has_projections() {\n             return ty;\n@@ -396,6 +415,52 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 normalized_ty\n             }\n \n+            ty::Projection(data) if !data.trait_ref(self.tcx()).has_escaping_bound_vars() => {\n+                // Okay, so you thought the previous branch was hacky. Well, to\n+                // extend upon this, when the *trait ref* doesn't have escaping\n+                // bound vars, but the associated item *does* (can only occur\n+                // with GATs), then we might still be able to project the type.\n+                // For this, we temporarily replace the bound vars with\n+                // placeholders. Note though, that in the case that we still\n+                // can't project for whatever reason (e.g. self type isn't\n+                // known enough), we *can't* register an obligation and return\n+                // an inference variable (since then that obligation would have\n+                // bound vars and that's a can of worms). Instead, we just\n+                // give up and fall back to pretending like we never tried!\n+\n+                let infcx = self.selcx.infcx();\n+                let (data, mapped_regions, mapped_types, mapped_consts) =\n+                    BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, data);\n+                let normalized_ty = opt_normalize_projection_type(\n+                    self.selcx,\n+                    self.param_env,\n+                    data,\n+                    self.cause.clone(),\n+                    self.depth,\n+                    &mut self.obligations,\n+                )\n+                .ok()\n+                .flatten()\n+                .unwrap_or_else(|| ty);\n+\n+                let normalized_ty = PlaceholderReplacer::replace_placeholders(\n+                    infcx,\n+                    mapped_regions,\n+                    mapped_types,\n+                    mapped_consts,\n+                    &self.universes,\n+                    normalized_ty,\n+                );\n+                debug!(\n+                    ?self.depth,\n+                    ?ty,\n+                    ?normalized_ty,\n+                    obligations.len = ?self.obligations.len(),\n+                    \"AssocTypeNormalizer: normalized type\"\n+                );\n+                normalized_ty\n+            }\n+\n             _ => ty,\n         }\n     }\n@@ -410,6 +475,279 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n     }\n }\n \n+pub struct BoundVarReplacer<'me, 'tcx> {\n+    infcx: &'me InferCtxt<'me, 'tcx>,\n+    // These three maps track the bound variable that were replaced by placeholders. It might be\n+    // nice to remove these since we already have the `kind` in the placeholder; we really just need\n+    // the `var` (but we *could* bring that into scope if we were to track them as we pass them).\n+    mapped_regions: BTreeMap<ty::PlaceholderRegion, ty::BoundRegion>,\n+    mapped_types: BTreeMap<ty::PlaceholderType, ty::BoundTy>,\n+    mapped_consts: BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar>,\n+    // The current depth relative to *this* folding, *not* the entire normalization. In other words,\n+    // the depth of binders we've passed here.\n+    current_index: ty::DebruijnIndex,\n+    // The `UniverseIndex` of the binding levels above us. These are optional, since we are lazy:\n+    // we don't actually create a universe until we see a bound var we have to replace.\n+    universe_indices: &'me mut Vec<Option<ty::UniverseIndex>>,\n+}\n+\n+impl<'me, 'tcx> BoundVarReplacer<'me, 'tcx> {\n+    /// Returns `Some` if we *were* able to replace bound vars. If there are any bound vars that\n+    /// use a binding level above `universe_indices.len()`, we fail.\n+    pub fn replace_bound_vars<T: TypeFoldable<'tcx>>(\n+        infcx: &'me InferCtxt<'me, 'tcx>,\n+        universe_indices: &'me mut Vec<Option<ty::UniverseIndex>>,\n+        value: T,\n+    ) -> (\n+        T,\n+        BTreeMap<ty::PlaceholderRegion, ty::BoundRegion>,\n+        BTreeMap<ty::PlaceholderType, ty::BoundTy>,\n+        BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar>,\n+    ) {\n+        let mapped_regions: BTreeMap<ty::PlaceholderRegion, ty::BoundRegion> = BTreeMap::new();\n+        let mapped_types: BTreeMap<ty::PlaceholderType, ty::BoundTy> = BTreeMap::new();\n+        let mapped_consts: BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar> = BTreeMap::new();\n+\n+        let mut replacer = BoundVarReplacer {\n+            infcx,\n+            mapped_regions,\n+            mapped_types,\n+            mapped_consts,\n+            current_index: ty::INNERMOST,\n+            universe_indices,\n+        };\n+\n+        let value = value.super_fold_with(&mut replacer);\n+\n+        (value, replacer.mapped_regions, replacer.mapped_types, replacer.mapped_consts)\n+    }\n+\n+    fn universe_for(&mut self, debruijn: ty::DebruijnIndex) -> ty::UniverseIndex {\n+        let infcx = self.infcx;\n+        let index =\n+            self.universe_indices.len() - debruijn.as_usize() + self.current_index.as_usize() - 1;\n+        let universe = self.universe_indices[index].unwrap_or_else(|| {\n+            for i in self.universe_indices.iter_mut().take(index + 1) {\n+                *i = i.or_else(|| Some(infcx.create_next_universe()))\n+            }\n+            self.universe_indices[index].unwrap()\n+        });\n+        universe\n+    }\n+}\n+\n+impl TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: ty::Binder<'tcx, T>,\n+    ) -> ty::Binder<'tcx, T> {\n+        self.current_index.shift_in(1);\n+        let t = t.super_fold_with(self);\n+        self.current_index.shift_out(1);\n+        t\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match *r {\n+            ty::ReLateBound(debruijn, _)\n+                if debruijn.as_usize() + 1\n+                    > self.current_index.as_usize() + self.universe_indices.len() =>\n+            {\n+                bug!(\"Bound vars outside of `self.universe_indices`\");\n+            }\n+            ty::ReLateBound(debruijn, br) if debruijn >= self.current_index => {\n+                let universe = self.universe_for(debruijn);\n+                let p = ty::PlaceholderRegion { universe, name: br.kind };\n+                self.mapped_regions.insert(p.clone(), br);\n+                self.infcx.tcx.mk_region(ty::RePlaceholder(p))\n+            }\n+            _ => r,\n+        }\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match *t.kind() {\n+            ty::Bound(debruijn, _)\n+                if debruijn.as_usize() + 1\n+                    > self.current_index.as_usize() + self.universe_indices.len() =>\n+            {\n+                bug!(\"Bound vars outside of `self.universe_indices`\");\n+            }\n+            ty::Bound(debruijn, bound_ty) if debruijn >= self.current_index => {\n+                let universe = self.universe_for(debruijn);\n+                let p = ty::PlaceholderType { universe, name: bound_ty.var };\n+                self.mapped_types.insert(p.clone(), bound_ty);\n+                self.infcx.tcx.mk_ty(ty::Placeholder(p))\n+            }\n+            _ if t.has_vars_bound_at_or_above(self.current_index) => t.super_fold_with(self),\n+            _ => t,\n+        }\n+    }\n+\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        match *ct {\n+            ty::Const { val: ty::ConstKind::Bound(debruijn, _), ty: _ }\n+                if debruijn.as_usize() + 1\n+                    > self.current_index.as_usize() + self.universe_indices.len() =>\n+            {\n+                bug!(\"Bound vars outside of `self.universe_indices`\");\n+            }\n+            ty::Const { val: ty::ConstKind::Bound(debruijn, bound_const), ty }\n+                if debruijn >= self.current_index =>\n+            {\n+                let universe = self.universe_for(debruijn);\n+                let p = ty::PlaceholderConst {\n+                    universe,\n+                    name: ty::BoundConst { var: bound_const, ty },\n+                };\n+                self.mapped_consts.insert(p.clone(), bound_const);\n+                self.infcx.tcx.mk_const(ty::Const { val: ty::ConstKind::Placeholder(p), ty })\n+            }\n+            _ if ct.has_vars_bound_at_or_above(self.current_index) => ct.super_fold_with(self),\n+            _ => ct,\n+        }\n+    }\n+}\n+\n+// The inverse of `BoundVarReplacer`: replaces placeholders with the bound vars from which they came.\n+pub struct PlaceholderReplacer<'me, 'tcx> {\n+    infcx: &'me InferCtxt<'me, 'tcx>,\n+    mapped_regions: BTreeMap<ty::PlaceholderRegion, ty::BoundRegion>,\n+    mapped_types: BTreeMap<ty::PlaceholderType, ty::BoundTy>,\n+    mapped_consts: BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar>,\n+    universe_indices: &'me Vec<Option<ty::UniverseIndex>>,\n+    current_index: ty::DebruijnIndex,\n+}\n+\n+impl<'me, 'tcx> PlaceholderReplacer<'me, 'tcx> {\n+    pub fn replace_placeholders<T: TypeFoldable<'tcx>>(\n+        infcx: &'me InferCtxt<'me, 'tcx>,\n+        mapped_regions: BTreeMap<ty::PlaceholderRegion, ty::BoundRegion>,\n+        mapped_types: BTreeMap<ty::PlaceholderType, ty::BoundTy>,\n+        mapped_consts: BTreeMap<ty::PlaceholderConst<'tcx>, ty::BoundVar>,\n+        universe_indices: &'me Vec<Option<ty::UniverseIndex>>,\n+        value: T,\n+    ) -> T {\n+        let mut replacer = PlaceholderReplacer {\n+            infcx,\n+            mapped_regions,\n+            mapped_types,\n+            mapped_consts,\n+            universe_indices,\n+            current_index: ty::INNERMOST,\n+        };\n+        value.super_fold_with(&mut replacer)\n+    }\n+}\n+\n+impl TypeFolder<'tcx> for PlaceholderReplacer<'_, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: ty::Binder<'tcx, T>,\n+    ) -> ty::Binder<'tcx, T> {\n+        if !t.has_placeholders() && !t.has_infer_regions() {\n+            return t;\n+        }\n+        self.current_index.shift_in(1);\n+        let t = t.super_fold_with(self);\n+        self.current_index.shift_out(1);\n+        t\n+    }\n+\n+    fn fold_region(&mut self, r0: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        let r1 = match r0 {\n+            ty::ReVar(_) => self\n+                .infcx\n+                .inner\n+                .borrow_mut()\n+                .unwrap_region_constraints()\n+                .opportunistic_resolve_region(self.infcx.tcx, r0),\n+            _ => r0,\n+        };\n+\n+        let r2 = match *r1 {\n+            ty::RePlaceholder(p) => {\n+                let replace_var = self.mapped_regions.get(&p);\n+                match replace_var {\n+                    Some(replace_var) => {\n+                        let index = self\n+                            .universe_indices\n+                            .iter()\n+                            .position(|u| matches!(u, Some(pu) if *pu == p.universe))\n+                            .unwrap_or_else(|| bug!(\"Unexpected placeholder universe.\"));\n+                        let db = ty::DebruijnIndex::from_usize(\n+                            self.universe_indices.len() - index + self.current_index.as_usize() - 1,\n+                        );\n+                        self.tcx().mk_region(ty::ReLateBound(db, *replace_var))\n+                    }\n+                    None => r1,\n+                }\n+            }\n+            _ => r1,\n+        };\n+\n+        debug!(?r0, ?r1, ?r2, \"fold_region\");\n+\n+        r2\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        match *ty.kind() {\n+            ty::Placeholder(p) => {\n+                let replace_var = self.mapped_types.get(&p);\n+                match replace_var {\n+                    Some(replace_var) => {\n+                        let index = self\n+                            .universe_indices\n+                            .iter()\n+                            .position(|u| matches!(u, Some(pu) if *pu == p.universe))\n+                            .unwrap_or_else(|| bug!(\"Unexpected placeholder universe.\"));\n+                        let db = ty::DebruijnIndex::from_usize(\n+                            self.universe_indices.len() - index + self.current_index.as_usize() - 1,\n+                        );\n+                        self.tcx().mk_ty(ty::Bound(db, *replace_var))\n+                    }\n+                    None => ty,\n+                }\n+            }\n+\n+            _ if ty.has_placeholders() || ty.has_infer_regions() => ty.super_fold_with(self),\n+            _ => ty,\n+        }\n+    }\n+\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        if let ty::Const { val: ty::ConstKind::Placeholder(p), ty } = *ct {\n+            let replace_var = self.mapped_consts.get(&p);\n+            match replace_var {\n+                Some(replace_var) => {\n+                    let index = self\n+                        .universe_indices\n+                        .iter()\n+                        .position(|u| matches!(u, Some(pu) if *pu == p.universe))\n+                        .unwrap_or_else(|| bug!(\"Unexpected placeholder universe.\"));\n+                    let db = ty::DebruijnIndex::from_usize(\n+                        self.universe_indices.len() - index + self.current_index.as_usize() - 1,\n+                    );\n+                    self.tcx()\n+                        .mk_const(ty::Const { val: ty::ConstKind::Bound(db, *replace_var), ty })\n+                }\n+                None => ct,\n+            }\n+        } else {\n+            ct.super_fold_with(self)\n+        }\n+    }\n+}\n+\n /// The guts of `normalize`: normalize a specific projection like `<T\n /// as Trait>::Item`. The result is always a type (and possibly\n /// additional obligations). If ambiguity arises, which implies that"}, {"sha": "94539eda0f89eff70bad2efe1e5ca8ef1f54f6e0", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/27e42058811e448b1a7dd8630d86ab247fbfcb9b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e42058811e448b1a7dd8630d86ab247fbfcb9b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=27e42058811e448b1a7dd8630d86ab247fbfcb9b", "patch": "@@ -61,6 +61,7 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n             error: false,\n             cache: SsoHashMap::new(),\n             anon_depth: 0,\n+            universes: vec![],\n         };\n \n         let result = value.fold_with(&mut normalizer);\n@@ -91,13 +92,24 @@ struct QueryNormalizer<'cx, 'tcx> {\n     cache: SsoHashMap<Ty<'tcx>, Ty<'tcx>>,\n     error: bool,\n     anon_depth: usize,\n+    universes: Vec<Option<ty::UniverseIndex>>,\n }\n \n impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n     fn tcx<'c>(&'c self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n \n+    fn fold_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: ty::Binder<'tcx, T>,\n+    ) -> ty::Binder<'tcx, T> {\n+        self.universes.push(None);\n+        let t = t.super_fold_with(self);\n+        self.universes.pop();\n+        t\n+    }\n+\n     #[instrument(level = \"debug\", skip(self))]\n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         if !ty.has_projections() {\n@@ -204,6 +216,80 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                     }\n                 }\n             }\n+            ty::Projection(data) if !data.trait_ref(self.infcx.tcx).has_escaping_bound_vars() => {\n+                // See note in `rustc_trait_selection::traits::project`\n+\n+                // One other point mentioning: In `traits::project`, if a\n+                // projection can't be normalized, we return an inference variable\n+                // and register an obligation to later resolve that. Here, the query\n+                // will just return ambiguity. In both cases, the effect is the same: we only want\n+                // to return `ty` because there are bound vars that we aren't yet handling in a more\n+                // complete way.\n+\n+                // `BoundVarReplacer` can't handle escaping bound vars. Ideally, we want this before even calling\n+                // `QueryNormalizer`, but some const-generics tests pass escaping bound vars.\n+                // Also, use `ty` so we get that sweet `outer_exclusive_binder` optimization\n+                assert!(!ty.has_vars_bound_at_or_above(ty::DebruijnIndex::from_usize(\n+                    self.universes.len()\n+                )));\n+\n+                let tcx = self.infcx.tcx;\n+                let infcx = self.infcx;\n+                let (data, mapped_regions, mapped_types, mapped_consts) =\n+                    crate::traits::project::BoundVarReplacer::replace_bound_vars(\n+                        infcx,\n+                        &mut self.universes,\n+                        data,\n+                    );\n+                let data = data.super_fold_with(self);\n+\n+                let mut orig_values = OriginalQueryValues::default();\n+                // HACK(matthewjasper) `'static` is special-cased in selection,\n+                // so we cannot canonicalize it.\n+                let c_data = self\n+                    .infcx\n+                    .canonicalize_hr_query_hack(self.param_env.and(data), &mut orig_values);\n+                debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n+                debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n+                let normalized_ty = match tcx.normalize_projection_ty(c_data) {\n+                    Ok(result) => {\n+                        // We don't expect ambiguity.\n+                        if result.is_ambiguous() {\n+                            self.error = true;\n+                            return ty;\n+                        }\n+                        match self.infcx.instantiate_query_response_and_region_obligations(\n+                            self.cause,\n+                            self.param_env,\n+                            &orig_values,\n+                            result,\n+                        ) {\n+                            Ok(InferOk { value: result, obligations }) => {\n+                                debug!(\"QueryNormalizer: result = {:#?}\", result);\n+                                debug!(\"QueryNormalizer: obligations = {:#?}\", obligations);\n+                                self.obligations.extend(obligations);\n+                                result.normalized_ty\n+                            }\n+                            Err(_) => {\n+                                self.error = true;\n+                                ty\n+                            }\n+                        }\n+                    }\n+                    Err(NoSolution) => {\n+                        self.error = true;\n+                        ty\n+                    }\n+                };\n+                crate::traits::project::PlaceholderReplacer::replace_placeholders(\n+                    infcx,\n+                    mapped_regions,\n+                    mapped_types,\n+                    mapped_consts,\n+                    &self.universes,\n+                    normalized_ty,\n+                )\n+            }\n \n             _ => ty,\n         })();"}, {"sha": "26d3cc9d89168cc4d44381294804cf3bb6f89b79", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27e42058811e448b1a7dd8630d86ab247fbfcb9b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e42058811e448b1a7dd8630d86ab247fbfcb9b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=27e42058811e448b1a7dd8630d86ab247fbfcb9b", "patch": "@@ -406,7 +406,6 @@ fn check_associated_item(\n             }\n             ty::AssocKind::Fn => {\n                 let sig = fcx.tcx.fn_sig(item.def_id);\n-                let sig = fcx.normalize_associated_types_in(span, sig);\n                 let hir_sig = sig_if_method.expect(\"bad signature for method\");\n                 check_fn_or_method(\n                     fcx,\n@@ -611,7 +610,6 @@ fn check_item_fn(\n     for_id(tcx, item_id, span).with_fcx(|fcx| {\n         let def_id = tcx.hir().local_def_id(item_id);\n         let sig = tcx.fn_sig(def_id);\n-        let sig = fcx.normalize_associated_types_in(span, sig);\n         let mut implied_bounds = vec![];\n         check_fn_or_method(fcx, ident.span, sig, decl, def_id.to_def_id(), &mut implied_bounds);\n         implied_bounds\n@@ -898,8 +896,8 @@ fn check_fn_or_method<'fcx, 'tcx>(\n     def_id: DefId,\n     implied_bounds: &mut Vec<Ty<'tcx>>,\n ) {\n-    let sig = fcx.normalize_associated_types_in(span, sig);\n     let sig = fcx.tcx.liberate_late_bound_regions(def_id, sig);\n+    let sig = fcx.normalize_associated_types_in(span, sig);\n \n     for (&input_ty, ty) in iter::zip(sig.inputs(), hir_decl.inputs) {\n         fcx.register_wf_obligation(input_ty.into(), ty.span, ObligationCauseCode::MiscObligation);\n@@ -1077,8 +1075,8 @@ fn check_method_receiver<'fcx, 'tcx>(\n     let span = fn_sig.decl.inputs[0].span;\n \n     let sig = fcx.tcx.fn_sig(method.def_id);\n-    let sig = fcx.normalize_associated_types_in(span, sig);\n     let sig = fcx.tcx.liberate_late_bound_regions(method.def_id, sig);\n+    let sig = fcx.normalize_associated_types_in(span, sig);\n \n     debug!(\"check_method_receiver: sig={:?}\", sig);\n "}, {"sha": "e8c11a32bf7fdabb47d0fea9e4dd73725e86af4a", "filename": "src/test/ui/associated-types/associated-types-for-unimpl-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr?ref=27e42058811e448b1a7dd8630d86ab247fbfcb9b", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `Self: Get` is not satisfied\n-  --> $DIR/associated-types-for-unimpl-trait.rs:10:5\n+  --> $DIR/associated-types-for-unimpl-trait.rs:10:8\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n+   |        ^^^^ the trait `Get` is not implemented for `Self`\n    |\n help: consider further restricting `Self`\n    |"}, {"sha": "e3be434698ab9897ad8d5be41eda0450692cd8e7", "filename": "src/test/ui/associated-types/associated-types-no-suitable-bound.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-bound.stderr?ref=27e42058811e448b1a7dd8630d86ab247fbfcb9b", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `T: Get` is not satisfied\n-  --> $DIR/associated-types-no-suitable-bound.rs:11:5\n+  --> $DIR/associated-types-no-suitable-bound.rs:11:8\n    |\n LL |     fn uhoh<T>(foo: <T as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `T`\n+   |        ^^^^ the trait `Get` is not implemented for `T`\n    |\n help: consider restricting type parameter `T`\n    |"}, {"sha": "9dc3414e9edf0de03844b6a79aa388014848f977", "filename": "src/test/ui/associated-types/associated-types-no-suitable-supertrait-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr?ref=27e42058811e448b1a7dd8630d86ab247fbfcb9b", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `Self: Get` is not satisfied\n-  --> $DIR/associated-types-no-suitable-supertrait-2.rs:17:5\n+  --> $DIR/associated-types-no-suitable-supertrait-2.rs:17:8\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n+   |        ^^^^ the trait `Get` is not implemented for `Self`\n    |\n help: consider further restricting `Self`\n    |"}, {"sha": "c2aed3f9de548f953162878e5ed4880a21e2e135", "filename": "src/test/ui/associated-types/associated-types-no-suitable-supertrait.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr?ref=27e42058811e448b1a7dd8630d86ab247fbfcb9b", "patch": "@@ -1,19 +1,19 @@\n error[E0277]: the trait bound `Self: Get` is not satisfied\n-  --> $DIR/associated-types-no-suitable-supertrait.rs:17:5\n+  --> $DIR/associated-types-no-suitable-supertrait.rs:17:8\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n+   |        ^^^^ the trait `Get` is not implemented for `Self`\n    |\n help: consider further restricting `Self`\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) where Self: Get {}\n    |                                                              ^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `(T, U): Get` is not satisfied\n-  --> $DIR/associated-types-no-suitable-supertrait.rs:22:5\n+  --> $DIR/associated-types-no-suitable-supertrait.rs:22:8\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <(T, U) as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `(T, U)`\n+   |        ^^^^ the trait `Get` is not implemented for `(T, U)`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "fb842d968676d40d44105519ac78342f41076a36", "filename": "src/test/ui/associated-types/associated-types-projection-to-unrelated-trait-in-method-without-default.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.stderr?ref=27e42058811e448b1a7dd8630d86ab247fbfcb9b", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `Self: Get` is not satisfied\n-  --> $DIR/associated-types-projection-to-unrelated-trait-in-method-without-default.rs:10:5\n+  --> $DIR/associated-types-projection-to-unrelated-trait-in-method-without-default.rs:10:8\n    |\n LL |     fn okay<U:Get>(&self, foo: U, bar: <Self as Get>::Value);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n+   |        ^^^^ the trait `Get` is not implemented for `Self`\n    |\n help: consider further restricting `Self`\n    |"}, {"sha": "a5abf1ba99d6a05746a7adecc990875bf5690774", "filename": "src/test/ui/associated-types/normalization-debruijn-1.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-debruijn-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-debruijn-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-debruijn-1.rs?ref=27e42058811e448b1a7dd8630d86ab247fbfcb9b", "patch": "@@ -0,0 +1,36 @@\n+// build-pass\n+// edition:2018\n+\n+// Regression test to ensure we handle debruijn indices correctly in projection\n+// normalization under binders. Found in crater run for #85499\n+\n+use std::future::Future;\n+use std::pin::Pin;\n+pub enum Outcome<S, E> {\n+    Success((S, E)),\n+}\n+pub struct Request<'r> {\n+    _marker: std::marker::PhantomData<&'r ()>,\n+}\n+pub trait FromRequest<'r>: Sized {\n+    type Error;\n+    fn from_request<'life0>(\n+        request: &'r Request<'life0>,\n+    ) -> Pin<Box<dyn Future<Output = Outcome<Self, Self::Error>>>>;\n+}\n+impl<'r, T: FromRequest<'r>> FromRequest<'r> for Option<T> {\n+    type Error = ();\n+    fn from_request<'life0>(\n+        request: &'r Request<'life0>,\n+    ) -> Pin<Box<dyn Future<Output = Outcome<Self, Self::Error>>>> {\n+        Box::pin(async move {\n+            let request = request;\n+            match T::from_request(request).await {\n+                _ => todo!(),\n+            }\n+        });\n+        todo!()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "abe248e16a19809eda9413821fa813ce7460a176", "filename": "src/test/ui/associated-types/normalization-debruijn-2.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-debruijn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-debruijn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-debruijn-2.rs?ref=27e42058811e448b1a7dd8630d86ab247fbfcb9b", "patch": "@@ -0,0 +1,31 @@\n+// build-pass\n+// edition:2018\n+\n+// Regression test to ensure we handle debruijn indices correctly in projection\n+// normalization under binders. Found in crater run for #85499\n+\n+use std::future::Future;\n+use std::pin::Pin;\n+pub enum Outcome<S, E> {\n+    Success(S),\n+    Failure(E),\n+}\n+pub struct Request<'r> {\n+    _marker: std::marker::PhantomData<&'r ()>,\n+}\n+pub trait FromRequest<'r>: Sized {\n+    type Error;\n+    fn from_request<'life0>(\n+        request: &'r Request<'life0>,\n+    ) -> Pin<Box<dyn Future<Output = Outcome<Self, Self::Error>>>>;\n+}\n+pub struct S<T> {\n+    _marker: std::marker::PhantomData<T>,\n+}\n+impl<'r, T: FromRequest<'r>> S<T> {\n+    pub async fn from_request(request: &'r Request<'_>) {\n+        let _ = T::from_request(request).await;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2bea78cf7bd6931bac3d9da04f8c37f9f83e5871", "filename": "src/test/ui/associated-types/normalization-debruijn-3.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-debruijn-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-debruijn-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-debruijn-3.rs?ref=27e42058811e448b1a7dd8630d86ab247fbfcb9b", "patch": "@@ -0,0 +1,41 @@\n+// build-pass\n+// edition:2018\n+\n+// Regression test to ensure we handle debruijn indices correctly in projection\n+// normalization under binders. Found in crater run for #85499\n+\n+use std::future::{Future, Ready};\n+async fn read() {\n+    let _ = connect(&()).await;\n+}\n+async fn connect<A: ToSocketAddr>(addr: A) {\n+    let _ = addr.to_socket_addr().await;\n+}\n+pub trait ToSocketAddr {\n+    type Future: Future<Output = ()>;\n+    fn to_socket_addr(&self) -> Self::Future;\n+}\n+impl ToSocketAddr for &() {\n+    type Future = Ready<()>;\n+    fn to_socket_addr(&self) -> Self::Future {\n+        unimplemented!()\n+    }\n+}\n+struct Server;\n+impl Server {\n+    fn and_then<F>(self, _fun: F) -> AndThen<F> {\n+        unimplemented!()\n+    }\n+}\n+struct AndThen<F> {\n+    _marker: std::marker::PhantomData<F>,\n+}\n+pub async fn run<F>(_: F) {\n+}\n+fn main() {\n+    let _ = async {\n+        let server = Server;\n+        let verification_route = server.and_then(read);\n+        run(verification_route).await;\n+    };\n+}"}, {"sha": "f8e3f5b58d1b372718e6dd60010ac4524fb1ce76", "filename": "src/test/ui/associated-types/normalization-generality.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-generality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-generality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-generality.rs?ref=27e42058811e448b1a7dd8630d86ab247fbfcb9b", "patch": "@@ -0,0 +1,36 @@\n+// build-pass\n+\n+// Ensures that we don't regress on \"implementation is not general enough\" when\n+// normalizating under binders.\n+\n+#![feature(no_core)]\n+\n+pub trait Yokeable<'a> {\n+    type Output: 'a;\n+}\n+\n+pub struct Yoke<Y: for<'a> Yokeable<'a>> {\n+    _yokeable: Y,\n+}\n+\n+impl<Y: for<'a> Yokeable<'a>> Yoke<Y> {\n+    pub fn project<'this, P>(\n+        &'this self,\n+        _f: for<'a> fn(<Y as Yokeable<'a>>::Output, &'a ()) -> <P as Yokeable<'a>>::Output,\n+    ) -> Yoke<P>\n+    where\n+        P: for<'a> Yokeable<'a>,\n+    {\n+        unimplemented!()\n+    }\n+}\n+\n+pub fn slice(y: Yoke<&'static ()>) -> Yoke<&'static ()> {\n+    y.project(move |yk, _| yk)\n+}\n+\n+impl<'a, T> Yokeable<'a> for &'static T {\n+    type Output = &'a T;\n+}\n+\n+fn main() {}"}, {"sha": "42f19feb5f132a1644e84276b02ae5cd5b93bfcf", "filename": "src/test/ui/generic-associated-types/issue-76407.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76407.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76407.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76407.rs?ref=27e42058811e448b1a7dd8630d86ab247fbfcb9b", "patch": "@@ -0,0 +1,28 @@\n+// check-pass\n+\n+#![feature(generic_associated_types)]\n+#![allow(incomplete_features)]\n+\n+trait Marker {}\n+\n+impl Marker for u32 {}\n+\n+trait MyTrait {\n+    type Item<'a>;\n+}\n+\n+struct MyStruct;\n+\n+impl MyTrait for MyStruct {\n+    type Item<'a> = u32;\n+}\n+\n+fn ty_check<T>()\n+where\n+    T: MyTrait,\n+    for<'a> T::Item<'a>: Marker\n+{}\n+\n+fn main() {\n+    ty_check::<MyStruct>();\n+}"}, {"sha": "a905ef4eb13fd823b0a62ff066792ab47d730f5b", "filename": "src/test/ui/generic-associated-types/issue-76826.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76826.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76826.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-76826.rs?ref=27e42058811e448b1a7dd8630d86ab247fbfcb9b", "patch": "@@ -0,0 +1,45 @@\n+// run-pass\n+\n+#![feature(generic_associated_types)]\n+#![allow(incomplete_features)]\n+\n+pub trait Iter {\n+    type Item<'a> where Self: 'a;\n+\n+    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;\n+\n+    fn for_each<F>(mut self, mut f: F)\n+        where Self: Sized, F: for<'a> FnMut(Self::Item<'a>)\n+    {\n+        while let Some(item) = self.next() {\n+            f(item);\n+        }\n+    }\n+}\n+\n+pub struct Windows<T> {\n+    items: Vec<T>,\n+    start: usize,\n+    len: usize,\n+}\n+\n+impl<T> Windows<T> {\n+    pub fn new(items: Vec<T>, len: usize) -> Self {\n+        Self { items, start: 0, len }\n+    }\n+}\n+\n+impl<T> Iter for Windows<T> {\n+    type Item<'a> where T: 'a = &'a mut [T];\n+\n+    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>> {\n+        let slice = self.items.get_mut(self.start..self.start + self.len)?;\n+        self.start += 1;\n+        Some(slice)\n+    }\n+}\n+\n+fn main() {\n+    Windows::new(vec![1, 2, 3, 4, 5], 3)\n+        .for_each(|slice| println!(\"{:?}\", slice));\n+}"}, {"sha": "8872f51753c94789fa0841a9a635e7d00c3fdfe2", "filename": "src/test/ui/issues/issue-18611.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fissues%2Fissue-18611.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fissues%2Fissue-18611.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18611.stderr?ref=27e42058811e448b1a7dd8630d86ab247fbfcb9b", "patch": "@@ -1,10 +1,8 @@\n error[E0277]: the trait bound `isize: HasState` is not satisfied\n-  --> $DIR/issue-18611.rs:1:1\n+  --> $DIR/issue-18611.rs:1:4\n    |\n-LL | / fn add_state(op: <isize as HasState>::State) {\n-LL | |\n-LL | | }\n-   | |_^ the trait `HasState` is not implemented for `isize`\n+LL | fn add_state(op: <isize as HasState>::State) {\n+   |    ^^^^^^^^^ the trait `HasState` is not implemented for `isize`\n \n error: aborting due to previous error\n "}, {"sha": "03e3311e0f39bac7d151723e1276e51e79bcba52", "filename": "src/test/ui/issues/issue-20831-debruijn.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr?ref=27e42058811e448b1a7dd8630d86ab247fbfcb9b", "patch": "@@ -1,8 +1,8 @@\n error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n-  --> $DIR/issue-20831-debruijn.rs:28:33\n+  --> $DIR/issue-20831-debruijn.rs:28:8\n    |\n LL |     fn subscribe(&mut self, t : Box<dyn Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^\n    |\n note: first, the lifetime cannot outlive the anonymous lifetime defined on the method body at 28:58...\n   --> $DIR/issue-20831-debruijn.rs:28:58\n@@ -15,10 +15,10 @@ note: ...but the lifetime must also be valid for the lifetime `'a` as defined on\n LL | impl<'a> Publisher<'a> for MyStruct<'a> {\n    |      ^^\n note: ...so that the types are compatible\n-  --> $DIR/issue-20831-debruijn.rs:28:33\n+  --> $DIR/issue-20831-debruijn.rs:28:8\n    |\n LL |     fn subscribe(&mut self, t : Box<dyn Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^\n    = note: expected `Publisher<'_>`\n               found `Publisher<'_>`\n "}, {"sha": "8c7c8918f3fc60d5d63127de280eb492ea3cb8dc", "filename": "src/test/ui/nll/normalization-bounds-error.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fnll%2Fnormalization-bounds-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fnll%2Fnormalization-bounds-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fnormalization-bounds-error.stderr?ref=27e42058811e448b1a7dd8630d86ab247fbfcb9b", "patch": "@@ -1,8 +1,8 @@\n error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'d` due to conflicting requirements\n-  --> $DIR/normalization-bounds-error.rs:12:1\n+  --> $DIR/normalization-bounds-error.rs:12:4\n    |\n LL | fn visit_seq<'d, 'a: 'd>() -> <&'a () as Visitor<'d>>::Value {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |    ^^^^^^^^^\n    |\n note: first, the lifetime cannot outlive the lifetime `'d` as defined on the function body at 12:14...\n   --> $DIR/normalization-bounds-error.rs:12:14\n@@ -15,10 +15,10 @@ note: ...but the lifetime must also be valid for the lifetime `'a` as defined on\n LL | fn visit_seq<'d, 'a: 'd>() -> <&'a () as Visitor<'d>>::Value {}\n    |                  ^^\n note: ...so that the types are compatible\n-  --> $DIR/normalization-bounds-error.rs:12:1\n+  --> $DIR/normalization-bounds-error.rs:12:4\n    |\n LL | fn visit_seq<'d, 'a: 'd>() -> <&'a () as Visitor<'d>>::Value {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |    ^^^^^^^^^\n    = note: expected `Visitor<'d>`\n               found `Visitor<'_>`\n "}, {"sha": "a0eb7d10bd94a0ab61200d679765757bf4369659", "filename": "src/test/ui/wf/wf-foreign-fn-decl-ret.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fwf%2Fwf-foreign-fn-decl-ret.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27e42058811e448b1a7dd8630d86ab247fbfcb9b/src%2Ftest%2Fui%2Fwf%2Fwf-foreign-fn-decl-ret.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-foreign-fn-decl-ret.stderr?ref=27e42058811e448b1a7dd8630d86ab247fbfcb9b", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `(): Foo` is not satisfied\n-  --> $DIR/wf-foreign-fn-decl-ret.rs:11:5\n+  --> $DIR/wf-foreign-fn-decl-ret.rs:11:12\n    |\n LL |     pub fn lint_me() -> <() as Foo>::Assoc;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Foo` is not implemented for `()`\n+   |            ^^^^^^^ the trait `Foo` is not implemented for `()`\n \n error[E0277]: the trait bound `u32: Unsatisfied` is not satisfied\n   --> $DIR/wf-foreign-fn-decl-ret.rs:14:32"}]}