{"sha": "d793d80cf7e60d1bdaefffb221dd45875ed9574a", "node_id": "C_kwDOAAsO6NoAKGQ3OTNkODBjZjdlNjBkMWJkYWVmZmZiMjIxZGQ0NTg3NWVkOTU3NGE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-10-26T18:00:18Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-10-27T15:43:33Z"}, "message": "(almost) Always use ObligationCtxt when dealing with canonical queries", "tree": {"sha": "a169efa7c83bd47738def9c5275db24e1ea33176", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a169efa7c83bd47738def9c5275db24e1ea33176"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d793d80cf7e60d1bdaefffb221dd45875ed9574a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d793d80cf7e60d1bdaefffb221dd45875ed9574a", "html_url": "https://github.com/rust-lang/rust/commit/d793d80cf7e60d1bdaefffb221dd45875ed9574a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d793d80cf7e60d1bdaefffb221dd45875ed9574a/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0da281b6068a7d889ae89a9bd8991284cc9b7535", "url": "https://api.github.com/repos/rust-lang/rust/commits/0da281b6068a7d889ae89a9bd8991284cc9b7535", "html_url": "https://github.com/rust-lang/rust/commit/0da281b6068a7d889ae89a9bd8991284cc9b7535"}], "stats": {"total": 215, "additions": 104, "deletions": 111}, "files": [{"sha": "dac6abe37f5891d3e3667be00defec2bf8184374", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d793d80cf7e60d1bdaefffb221dd45875ed9574a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d793d80cf7e60d1bdaefffb221dd45875ed9574a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=d793d80cf7e60d1bdaefffb221dd45875ed9574a", "patch": "@@ -5,14 +5,14 @@ use rustc_infer::infer::region_constraints::Constraint;\n use rustc_infer::infer::region_constraints::RegionConstraintData;\n use rustc_infer::infer::RegionVariableOrigin;\n use rustc_infer::infer::{InferCtxt, RegionResolutionError, SubregionOrigin, TyCtxtInferExt as _};\n-use rustc_infer::traits::{Normalized, ObligationCause, TraitEngine, TraitEngineExt};\n+use rustc_infer::traits::ObligationCause;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::RegionVid;\n use rustc_middle::ty::UniverseIndex;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::type_op;\n-use rustc_trait_selection::traits::{SelectionContext, TraitEngineExt as _};\n+use rustc_trait_selection::traits::ObligationCtxt;\n use rustc_traits::{type_op_ascribe_user_type_with_span, type_op_prove_predicate_with_cause};\n \n use std::fmt;\n@@ -240,9 +240,9 @@ impl<'tcx> TypeOpInfo<'tcx> for PredicateQuery<'tcx> {\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n         let (ref infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-        type_op_prove_predicate_with_cause(infcx, &mut *fulfill_cx, key, cause);\n-        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n+        let ocx = ObligationCtxt::new(infcx);\n+        type_op_prove_predicate_with_cause(&ocx, key, cause);\n+        try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }\n }\n \n@@ -281,9 +281,7 @@ where\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n         let (ref infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n-        let mut selcx = SelectionContext::new(infcx);\n+        let ocx = ObligationCtxt::new(infcx);\n \n         // FIXME(lqd): Unify and de-duplicate the following with the actual\n         // `rustc_traits::type_op::type_op_normalize` query to allow the span we need in the\n@@ -292,11 +290,9 @@ where\n         // to normalize the `nll/relate_tys/impl-fn-ignore-binder-via-bottom.rs` test. Check\n         // after #85499 lands to see if its fixes have erased this difference.\n         let (param_env, value) = key.into_parts();\n-        let Normalized { value: _, obligations } =\n-            rustc_trait_selection::traits::normalize(&mut selcx, param_env, cause, value.value);\n-        fulfill_cx.register_predicate_obligations(infcx, obligations);\n+        let _ = ocx.normalize(cause, param_env, value.value);\n \n-        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n+        try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }\n }\n \n@@ -329,9 +325,9 @@ impl<'tcx> TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n         let (ref infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-        type_op_ascribe_user_type_with_span(infcx, &mut *fulfill_cx, key, Some(cause.span)).ok()?;\n-        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n+        let ocx = ObligationCtxt::new(infcx);\n+        type_op_ascribe_user_type_with_span(&ocx, key, Some(cause.span)).ok()?;\n+        try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }\n }\n \n@@ -372,25 +368,24 @@ impl<'tcx> TypeOpInfo<'tcx> for crate::type_check::InstantiateOpaqueType<'tcx> {\n     }\n }\n \n-#[instrument(skip(fulfill_cx, infcx), level = \"debug\")]\n+#[instrument(skip(ocx), level = \"debug\")]\n fn try_extract_error_from_fulfill_cx<'tcx>(\n-    mut fulfill_cx: Box<dyn TraitEngine<'tcx> + 'tcx>,\n-    infcx: &InferCtxt<'tcx>,\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n     placeholder_region: ty::Region<'tcx>,\n     error_region: Option<ty::Region<'tcx>>,\n ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n     // We generally shouldn't have errors here because the query was\n     // already run, but there's no point using `delay_span_bug`\n     // when we're going to emit an error here anyway.\n-    let _errors = fulfill_cx.select_all_or_error(infcx);\n-    let region_constraints = infcx.with_region_constraints(|r| r.clone());\n+    let _errors = ocx.select_all_or_error();\n+    let region_constraints = ocx.infcx.with_region_constraints(|r| r.clone());\n     try_extract_error_from_region_constraints(\n-        infcx,\n+        ocx.infcx,\n         placeholder_region,\n         error_region,\n         &region_constraints,\n-        |vid| infcx.region_var_origin(vid),\n-        |vid| infcx.universe_of_region(infcx.tcx.mk_region(ty::ReVar(vid))),\n+        |vid| ocx.infcx.region_var_origin(vid),\n+        |vid| ocx.infcx.universe_of_region(ocx.infcx.tcx.mk_region(ty::ReVar(vid))),\n     )\n }\n "}, {"sha": "cbd6481f9cb81087566500347072104d4defee5a", "filename": "compiler/rustc_infer/src/infer/canonical/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d793d80cf7e60d1bdaefffb221dd45875ed9574a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d793d80cf7e60d1bdaefffb221dd45875ed9574a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs?ref=d793d80cf7e60d1bdaefffb221dd45875ed9574a", "patch": "@@ -43,7 +43,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     ///\n     /// This is only meant to be invoked as part of constructing an\n     /// inference context at the start of a query (see\n-    /// `InferCtxtBuilder::enter_with_canonical`). It basically\n+    /// `InferCtxtBuilder::build_with_canonical`). It basically\n     /// brings the canonical value \"into scope\" within your new infcx.\n     ///\n     /// At the end of processing, the substitution S (once"}, {"sha": "3763c871e481c2a84c5b9591bf6bee3cbd098b02", "filename": "compiler/rustc_trait_selection/src/infer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d793d80cf7e60d1bdaefffb221dd45875ed9574a/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d793d80cf7e60d1bdaefffb221dd45875ed9574a/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs?ref=d793d80cf7e60d1bdaefffb221dd45875ed9574a", "patch": "@@ -1,5 +1,5 @@\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n-use crate::traits::{self, TraitEngine, TraitEngineExt};\n+use crate::traits::{self, ObligationCtxt};\n \n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n@@ -142,7 +142,7 @@ pub trait InferCtxtBuilderExt<'tcx> {\n     fn enter_canonical_trait_query<K, R>(\n         &mut self,\n         canonical_key: &Canonical<'tcx, K>,\n-        operation: impl FnOnce(&InferCtxt<'tcx>, &mut dyn TraitEngine<'tcx>, K) -> Fallible<R>,\n+        operation: impl FnOnce(&ObligationCtxt<'_, 'tcx>, K) -> Fallible<R>,\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, R>>\n     where\n         K: TypeFoldable<'tcx>,\n@@ -170,17 +170,17 @@ impl<'tcx> InferCtxtBuilderExt<'tcx> for InferCtxtBuilder<'tcx> {\n     fn enter_canonical_trait_query<K, R>(\n         &mut self,\n         canonical_key: &Canonical<'tcx, K>,\n-        operation: impl FnOnce(&InferCtxt<'tcx>, &mut dyn TraitEngine<'tcx>, K) -> Fallible<R>,\n+        operation: impl FnOnce(&ObligationCtxt<'_, 'tcx>, K) -> Fallible<R>,\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, R>>\n     where\n         K: TypeFoldable<'tcx>,\n         R: Debug + TypeFoldable<'tcx>,\n         Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable<'tcx>,\n     {\n-        let (ref infcx, key, canonical_inference_vars) =\n+        let (infcx, key, canonical_inference_vars) =\n             self.build_with_canonical(DUMMY_SP, canonical_key);\n-        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-        let value = operation(infcx, &mut *fulfill_cx, key)?;\n-        infcx.make_canonicalized_query_response(canonical_inference_vars, value, &mut *fulfill_cx)\n+        let ocx = ObligationCtxt::new(&infcx);\n+        let value = operation(&ocx, key)?;\n+        ocx.make_canonicalized_query_response(canonical_inference_vars, value)\n     }\n }"}, {"sha": "18ad99b4935e10dd04f59ca81525d47db56dedb1", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d793d80cf7e60d1bdaefffb221dd45875ed9574a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d793d80cf7e60d1bdaefffb221dd45875ed9574a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=d793d80cf7e60d1bdaefffb221dd45875ed9574a", "patch": "@@ -1,14 +1,20 @@\n use std::cell::RefCell;\n+use std::fmt::Debug;\n \n use super::TraitEngine;\n use super::{ChalkFulfillmentContext, FulfillmentContext};\n use crate::infer::InferCtxtExt;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_infer::infer::canonical::{\n+    Canonical, CanonicalVarValues, CanonicalizedQueryResponse, QueryResponse,\n+};\n use rustc_infer::infer::{InferCtxt, InferOk};\n+use rustc_infer::traits::query::Fallible;\n use rustc_infer::traits::{\n     FulfillmentError, Obligation, ObligationCause, PredicateObligation, TraitEngineExt as _,\n };\n+use rustc_middle::arena::ArenaAllocatable;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::ToPredicate;\n use rustc_middle::ty::TypeFoldable;\n@@ -154,4 +160,20 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n         }\n         implied_bounds\n     }\n+\n+    pub fn make_canonicalized_query_response<T>(\n+        &self,\n+        inference_vars: CanonicalVarValues<'tcx>,\n+        answer: T,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, T>>\n+    where\n+        T: Debug + TypeFoldable<'tcx>,\n+        Canonical<'tcx, QueryResponse<'tcx, T>>: ArenaAllocatable<'tcx>,\n+    {\n+        self.infcx.make_canonicalized_query_response(\n+            inference_vars,\n+            answer,\n+            &mut **self.engine.borrow_mut(),\n+        )\n+    }\n }"}, {"sha": "82f6111f6f92e440e66dd4a5bb31b68d34ac6c8b", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d793d80cf7e60d1bdaefffb221dd45875ed9574a/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d793d80cf7e60d1bdaefffb221dd45875ed9574a/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=d793d80cf7e60d1bdaefffb221dd45875ed9574a", "patch": "@@ -28,9 +28,9 @@ fn implied_outlives_bounds<'tcx>(\n     &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, Vec<OutlivesBound<'tcx>>>>,\n     NoSolution,\n > {\n-    tcx.infer_ctxt().enter_canonical_trait_query(&goal, |infcx, _fulfill_cx, key| {\n+    tcx.infer_ctxt().enter_canonical_trait_query(&goal, |ocx, key| {\n         let (param_env, ty) = key.into_parts();\n-        compute_implied_outlives_bounds(&infcx, param_env, ty)\n+        compute_implied_outlives_bounds(&ocx.infcx, param_env, ty)\n     })\n }\n "}, {"sha": "0ffa92f1ad55d960310e1625e13f53c362ea0e09", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d793d80cf7e60d1bdaefffb221dd45875ed9574a/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d793d80cf7e60d1bdaefffb221dd45875ed9574a/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=d793d80cf7e60d1bdaefffb221dd45875ed9574a", "patch": "@@ -3,6 +3,7 @@\n \n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n+#![feature(let_chains)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "e805eb4282119b5db40be90ebe6a6324ffa9f382", "filename": "compiler/rustc_traits/src/normalize_projection_ty.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d793d80cf7e60d1bdaefffb221dd45875ed9574a/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d793d80cf7e60d1bdaefffb221dd45875ed9574a/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs?ref=d793d80cf7e60d1bdaefffb221dd45875ed9574a", "patch": "@@ -1,6 +1,5 @@\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n@@ -23,8 +22,8 @@ fn normalize_projection_ty<'tcx>(\n     tcx.sess.perf_stats.normalize_projection_ty.fetch_add(1, Ordering::Relaxed);\n     tcx.infer_ctxt().enter_canonical_trait_query(\n         &goal,\n-        |infcx, fulfill_cx, ParamEnvAnd { param_env, value: goal }| {\n-            let selcx = &mut SelectionContext::new(infcx);\n+        |ocx, ParamEnvAnd { param_env, value: goal }| {\n+            let selcx = &mut SelectionContext::new(ocx.infcx);\n             let cause = ObligationCause::dummy();\n             let mut obligations = vec![];\n             let answer = traits::normalize_projection_type(\n@@ -35,7 +34,7 @@ fn normalize_projection_ty<'tcx>(\n                 0,\n                 &mut obligations,\n             );\n-            fulfill_cx.register_predicate_obligations(infcx, obligations);\n+            ocx.register_obligations(obligations);\n             // FIXME(associated_const_equality): All users of normalize_projection_ty expected\n             // a type, but there is the possibility it could've been a const now. Maybe change\n             // it to a Term later?"}, {"sha": "827c747e8ed5b1baa4eb477554c59bab925d672b", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 50, "deletions": 74, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/d793d80cf7e60d1bdaefffb221dd45875ed9574a/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d793d80cf7e60d1bdaefffb221dd45875ed9574a/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=d793d80cf7e60d1bdaefffb221dd45875ed9574a", "patch": "@@ -2,25 +2,22 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n-use rustc_infer::infer::{DefiningAnchor, InferCtxt, TyCtxtInferExt};\n-use rustc_infer::traits::{ObligationCauseCode, TraitEngineExt as _};\n+use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n+use rustc_infer::traits::ObligationCauseCode;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{\n-    self, EarlyBinder, FnSig, Lift, PolyFnSig, Ty, TyCtxt, TypeFoldable, Variance,\n-};\n-use rustc_middle::ty::{GenericArg, UserSelfTy, UserSubsts};\n-use rustc_middle::ty::{ParamEnv, ParamEnvAnd, Predicate, ToPredicate};\n+use rustc_middle::ty::{self, FnSig, Lift, PolyFnSig, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{ParamEnvAnd, Predicate, ToPredicate};\n+use rustc_middle::ty::{UserSelfTy, UserSubsts};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n-use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use rustc_trait_selection::traits::query::type_op::ascribe_user_type::AscribeUserType;\n use rustc_trait_selection::traits::query::type_op::eq::Eq;\n use rustc_trait_selection::traits::query::type_op::normalize::Normalize;\n use rustc_trait_selection::traits::query::type_op::prove_predicate::ProvePredicate;\n use rustc_trait_selection::traits::query::type_op::subtype::Subtype;\n use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n-use rustc_trait_selection::traits::{Normalized, Obligation, ObligationCause, TraitEngine};\n+use rustc_trait_selection::traits::{Normalized, Obligation, ObligationCause, ObligationCtxt};\n use std::fmt;\n use std::iter::zip;\n \n@@ -42,17 +39,16 @@ fn type_op_ascribe_user_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, AscribeUserType<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n-    tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n-        type_op_ascribe_user_type_with_span(infcx, fulfill_cx, key, None)\n+    tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |ocx, key| {\n+        type_op_ascribe_user_type_with_span(ocx, key, None)\n     })\n }\n \n /// The core of the `type_op_ascribe_user_type` query: for diagnostics purposes in NLL HRTB errors,\n /// this query can be re-run to better track the span of the obligation cause, and improve the error\n /// message. Do not call directly unless you're in that very specific context.\n-pub fn type_op_ascribe_user_type_with_span<'a, 'tcx: 'a>(\n-    infcx: &'a InferCtxt<'tcx>,\n-    fulfill_cx: &'a mut dyn TraitEngine<'tcx>,\n+pub fn type_op_ascribe_user_type_with_span<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n     key: ParamEnvAnd<'tcx, AscribeUserType<'tcx>>,\n     span: Option<Span>,\n ) -> Result<(), NoSolution> {\n@@ -61,89 +57,74 @@ pub fn type_op_ascribe_user_type_with_span<'a, 'tcx: 'a>(\n         \"type_op_ascribe_user_type: mir_ty={:?} def_id={:?} user_substs={:?}\",\n         mir_ty, def_id, user_substs\n     );\n-\n-    let mut cx = AscribeUserTypeCx { infcx, param_env, span: span.unwrap_or(DUMMY_SP), fulfill_cx };\n+    let cx = AscribeUserTypeCx { ocx, param_env, span: span.unwrap_or(DUMMY_SP) };\n     cx.relate_mir_and_user_ty(mir_ty, def_id, user_substs)?;\n     Ok(())\n }\n \n struct AscribeUserTypeCx<'me, 'tcx> {\n-    infcx: &'me InferCtxt<'tcx>,\n-    param_env: ParamEnv<'tcx>,\n+    ocx: &'me ObligationCtxt<'me, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     span: Span,\n-    fulfill_cx: &'me mut dyn TraitEngine<'tcx>,\n }\n \n impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n-    fn normalize<T>(&mut self, value: T) -> T\n+    fn normalize<T>(&self, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         self.normalize_with_cause(value, ObligationCause::misc(self.span, hir::CRATE_HIR_ID))\n     }\n \n-    fn normalize_with_cause<T>(&mut self, value: T, cause: ObligationCause<'tcx>) -> T\n+    fn normalize_with_cause<T>(&self, value: T, cause: ObligationCause<'tcx>) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        self.infcx\n-            .partially_normalize_associated_types_in(cause, self.param_env, value)\n-            .into_value_registering_obligations(self.infcx, self.fulfill_cx)\n+        self.ocx.normalize(cause, self.param_env, value)\n     }\n \n-    fn relate<T>(&mut self, a: T, variance: Variance, b: T) -> Result<(), NoSolution>\n+    fn eq<T>(&self, a: T, b: T) -> Result<(), NoSolution>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.infcx\n-            .at(&ObligationCause::dummy_with_span(self.span), self.param_env)\n-            .relate(a, variance, b)?\n-            .into_value_registering_obligations(self.infcx, self.fulfill_cx);\n-        Ok(())\n+        Ok(self.ocx.register_infer_ok_obligations(\n+            self.ocx\n+                .infcx\n+                .at(&ObligationCause::dummy_with_span(self.span), self.param_env)\n+                .eq(a, b)?,\n+        ))\n     }\n \n-    fn prove_predicate(&mut self, predicate: Predicate<'tcx>, cause: ObligationCause<'tcx>) {\n-        self.fulfill_cx.register_predicate_obligation(\n-            self.infcx,\n-            Obligation::new(cause, self.param_env, predicate),\n-        );\n+    fn prove_predicate(&self, predicate: Predicate<'tcx>, cause: ObligationCause<'tcx>) {\n+        self.ocx.register_obligation(Obligation::new(cause, self.param_env, predicate));\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-\n-    fn subst<T>(&self, value: T, substs: &[GenericArg<'tcx>]) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        EarlyBinder(value).subst(self.tcx(), substs)\n+        self.ocx.infcx.tcx\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn relate_mir_and_user_ty(\n-        &mut self,\n+        &self,\n         mir_ty: Ty<'tcx>,\n         def_id: DefId,\n         user_substs: UserSubsts<'tcx>,\n     ) -> Result<(), NoSolution> {\n         let UserSubsts { user_self_ty, substs } = user_substs;\n         let tcx = self.tcx();\n \n-        let ty = tcx.type_of(def_id);\n-        let ty = self.subst(ty, substs);\n+        let ty = tcx.bound_type_of(def_id).subst(tcx, substs);\n         let ty = self.normalize(ty);\n         debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n \n-        self.relate(mir_ty, Variance::Invariant, ty)?;\n+        self.eq(mir_ty, ty)?;\n \n         // Prove the predicates coming along with `def_id`.\n         //\n         // Also, normalize the `instantiated_predicates`\n         // because otherwise we wind up with duplicate \"type\n         // outlives\" error messages.\n-        let instantiated_predicates =\n-            self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n+        let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n \n         let cause = ObligationCause::dummy_with_span(self.span);\n \n@@ -163,15 +144,14 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         }\n \n         if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n-            let impl_self_ty = self.tcx().type_of(impl_def_id);\n-            let impl_self_ty = self.subst(impl_self_ty, &substs);\n+            let impl_self_ty = tcx.bound_type_of(impl_def_id).subst(tcx, substs);\n             let impl_self_ty = self.normalize(impl_self_ty);\n \n-            self.relate(self_ty, Variance::Invariant, impl_self_ty)?;\n+            self.eq(self_ty, impl_self_ty)?;\n \n             self.prove_predicate(\n                 ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into()))\n-                    .to_predicate(self.tcx()),\n+                    .to_predicate(tcx),\n                 cause.clone(),\n             );\n         }\n@@ -188,7 +168,7 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         // type were ill-formed but did not appear in `ty`,\n         // which...could happen with normalization...\n         self.prove_predicate(\n-            ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into())).to_predicate(self.tcx()),\n+            ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into())).to_predicate(tcx),\n             cause,\n         );\n         Ok(())\n@@ -199,28 +179,26 @@ fn type_op_eq<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Eq<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n-    tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n+    tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |ocx, key| {\n         let (param_env, Eq { a, b }) = key.into_parts();\n-        infcx\n-            .at(&ObligationCause::dummy(), param_env)\n-            .eq(a, b)?\n-            .into_value_registering_obligations(infcx, fulfill_cx);\n+        ocx.register_infer_ok_obligations(\n+            ocx.infcx.at(&ObligationCause::dummy(), param_env).eq(a, b)?,\n+        );\n         Ok(())\n     })\n }\n \n fn type_op_normalize<'tcx, T>(\n-    infcx: &InferCtxt<'tcx>,\n-    fulfill_cx: &mut dyn TraitEngine<'tcx>,\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n     key: ParamEnvAnd<'tcx, Normalize<T>>,\n ) -> Fallible<T>\n where\n     T: fmt::Debug + TypeFoldable<'tcx> + Lift<'tcx>,\n {\n     let (param_env, Normalize { value }) = key.into_parts();\n     let Normalized { value, obligations } =\n-        infcx.at(&ObligationCause::dummy(), param_env).normalize(value)?;\n-    fulfill_cx.register_predicate_obligations(infcx, obligations);\n+        ocx.infcx.at(&ObligationCause::dummy(), param_env).normalize(value)?;\n+    ocx.register_obligations(obligations);\n     Ok(value)\n }\n \n@@ -256,12 +234,11 @@ fn type_op_subtype<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Subtype<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n-    tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n+    tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |ocx, key| {\n         let (param_env, Subtype { sub, sup }) = key.into_parts();\n-        infcx\n-            .at(&ObligationCause::dummy(), param_env)\n-            .sup(sup, sub)?\n-            .into_value_registering_obligations(infcx, fulfill_cx);\n+        ocx.register_infer_ok_obligations(\n+            ocx.infcx.at(&ObligationCause::dummy(), param_env).sup(sup, sub)?,\n+        );\n         Ok(())\n     })\n }\n@@ -274,8 +251,8 @@ fn type_op_prove_predicate<'tcx>(\n     // impl-trait/issue-99642.rs\n     tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).enter_canonical_trait_query(\n         &canonicalized,\n-        |infcx, fulfill_cx, key| {\n-            type_op_prove_predicate_with_cause(infcx, fulfill_cx, key, ObligationCause::dummy());\n+        |ocx, key| {\n+            type_op_prove_predicate_with_cause(ocx, key, ObligationCause::dummy());\n             Ok(())\n         },\n     )\n@@ -284,12 +261,11 @@ fn type_op_prove_predicate<'tcx>(\n /// The core of the `type_op_prove_predicate` query: for diagnostics purposes in NLL HRTB errors,\n /// this query can be re-run to better track the span of the obligation cause, and improve the error\n /// message. Do not call directly unless you're in that very specific context.\n-pub fn type_op_prove_predicate_with_cause<'a, 'tcx: 'a>(\n-    infcx: &'a InferCtxt<'tcx>,\n-    fulfill_cx: &'a mut dyn TraitEngine<'tcx>,\n+pub fn type_op_prove_predicate_with_cause<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n     key: ParamEnvAnd<'tcx, ProvePredicate<'tcx>>,\n     cause: ObligationCause<'tcx>,\n ) {\n     let (param_env, ProvePredicate { predicate }) = key.into_parts();\n-    fulfill_cx.register_predicate_obligation(infcx, Obligation::new(cause, param_env, predicate));\n+    ocx.register_obligation(Obligation::new(cause, param_env, predicate));\n }"}]}